[
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { 1, -1, 0, 0,0,0 }; const int dy[] = { 0,0, 1, -1, 0,0 };const int dz[] = { 0,0,0, 0, 1, -1 };\n\nconst int side[6][4] = {\n\t{ 2, 4, 5, 3 },{ 1, 3, 6, 4 },{ 1, 5, 6, 2 },{ 1, 2, 6, 5 },{ 1, 4, 6, 3 },{ 2, 3, 5, 4 }\n};\nconst int dice_right[6][6] = {\n\t{0,3,5,2,4,0},\n\t{ 4,0,1,6,0,3 },\n\t{ 2,6,0,0,1,5 },\n\t{ 5,1,0,0,6,2 },\n\t{ 3,0,6,1,0,4 },\n\t{ 0,4,2,5,3,0 }\n};\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nvi ans;\nvector<vector<vvi>> dices(3, vector<vvi>(3, vvi(3, vi(2))));\nvoid dfs() {\n\tREP(i, 3) {\n\t\tREP(j, 3) {\n\t\t\tREP(k, 3) {\n\t\t\t\tvector<vector<vvi>> copy_dices = dices;\n\t\t\t\tif (dices[i][j][k][0] == 0 && dices[i][j][k][1] == 0) {\n\t\t\t\t\tREP(l, 6) {\n\t\t\t\t\t\tREP(m, 6) {\n\t\t\t\t\t\t\tif (l + m == 7 || l == m)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tbool able = true;\n\t\t\t\t\t\t\tREP(n, 6) {\n\t\t\t\t\t\t\t\tif (0 <= i + dx[n] && i + dx[n] < 3 && 0 <= j + dy[n] && j + dy[n] < 3 && 0 <= k + dz[n] && k + dz[n] < 3) {\n\t\t\t\t\t\t\t\t\tswitch (n) {\n\t\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\t\tif (dices[i + dx[n]][j + dy[n]][k + dz[n]][0] != 0 && dices[i + dx[n]][j + dy[n]][k + dz[n]][0] != l + 1)\n\t\t\t\t\t\t\t\t\t\t\t\table = false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\t\t\tif (dices[i + dx[n]][j + dy[n]][k + dz[n]][1] != 0 && dices[i + dx[n]][j + dy[n]][k + dz[n]][1] != m + 1)\n\t\t\t\t\t\t\t\t\t\t\t\table = false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\t\t\t\t\tif (dices[i + dx[n]][j + dy[n]][k + dz[n]][0] != 0 &&\n\t\t\t\t\t\t\t\t\t\t\t\tdices[i + dx[n]][j + dy[n]][k + dz[n]][1] != 0 &&\n\t\t\t\t\t\t\t\t\t\t\t\tdice_right[dices[i + dx[n]][j + dy[n]][k + dz[n]][0] - 1][dices[i + dx[n]][j + dy[n]][k + dz[n]][1] - 1] != dice_right[l][m])\n\t\t\t\t\t\t\t\t\t\t\t\table = false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!able)\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (able) {\n\t\t\t\t\t\t\t\tdices[0][j][k][0] = l+1;\n\t\t\t\t\t\t\t\tdices[1][j][k][0] = l + 1;\n\t\t\t\t\t\t\t\tdices[2][j][k][0] = l + 1;\n\t\t\t\t\t\t\t\tdices[i][0][k][1] = m + 1;\n\t\t\t\t\t\t\t\tdices[i][1][k][1] = m + 1;\n\t\t\t\t\t\t\t\tdices[i][2][k][1] = m + 1;\n\t\t\t\t\t\t\t\tdfs();\n\t\t\t\t\t\t\t\tdices = copy_dices;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (dices[i][j][k][0] != 0 && dices[i][j][k][1] == 0) {\n\t\t\t\t\tREP(m, 6) {\n\t\t\t\t\t\tif (dices[i][j][k][0]-1 + m == 7 || dices[i][j][k][0]-1 == m)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tbool able = true;\n\t\t\t\t\t\tREP(n, 6) {\n\t\t\t\t\t\t\tif (0 <= i + dx[n] && i + dx[n] < 3 && 0 <= j + dy[n] && j + dy[n] < 3 && 0 <= k + dz[n] && k + dz[n] < 3) {\n\t\t\t\t\t\t\t\tswitch (n) {\n\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\tif (dices[i + dx[n]][j + dy[n]][k + dz[n]][0] != 0 && dices[i + dx[n]][j + dy[n]][k + dz[n]][0] != dices[i][j][k][0])\n\t\t\t\t\t\t\t\t\t\t\table = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\t\tif (dices[i + dx[n]][j + dy[n]][k + dz[n]][1] != 0 && dices[i + dx[n]][j + dy[n]][k + dz[n]][1] != m + 1)\n\t\t\t\t\t\t\t\t\t\t\table = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\t\t\t\tif (dices[i + dx[n]][j + dy[n]][k + dz[n]][0] != 0 &&\n\t\t\t\t\t\t\t\t\t\t\tdices[i + dx[n]][j + dy[n]][k + dz[n]][1] != 0 &&\n\t\t\t\t\t\t\t\t\t\t\tdice_right[dices[i + dx[n]][j + dy[n]][k + dz[n]][0] - 1][dices[i + dx[n]][j + dy[n]][k + dz[n]][1] - 1] != dice_right[dices[i][j][k][0]-1][m])\n\t\t\t\t\t\t\t\t\t\t\table = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!able)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (able) {\n\t\t\t\t\t\t\tdices[i][0][k][1] = m + 1;\n\t\t\t\t\t\t\tdices[i][1][k][1] = m + 1;\n\t\t\t\t\t\t\tdices[i][2][k][1] = m + 1;\n\t\t\t\t\t\t\tdfs();\n\t\t\t\t\t\t\tdices = copy_dices;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (dices[i][j][k][0] == 0 && dices[i][j][k][1] != 0) {\n\t\t\t\t\tREP(l, 6) {\n\t\t\t\t\t\tif (l + dices[i][j][k][1]-1 == 7 || l == dices[i][j][k][1]-1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tbool able = true;\n\t\t\t\t\t\tREP(n, 6) {\n\t\t\t\t\t\t\tif (0 <= i + dx[n] && i + dx[n] < 3 && 0 <= j + dy[n] && j + dy[n] < 3 && 0 <= k + dz[n] && k + dz[n] < 3) {\n\t\t\t\t\t\t\t\tswitch (n) {\n\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\tif (dices[i + dx[n]][j + dy[n]][k + dz[n]][0] != 0 && dices[i + dx[n]][j + dy[n]][k + dz[n]][0] != l + 1)\n\t\t\t\t\t\t\t\t\t\t\table = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\t\tif (dices[i + dx[n]][j + dy[n]][k + dz[n]][1] != 0 && dices[i + dx[n]][j + dy[n]][k + dz[n]][1] != dices[i][j][k][1])\n\t\t\t\t\t\t\t\t\t\t\table = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\t\t\t\tif (dices[i + dx[n]][j + dy[n]][k + dz[n]][0] != 0 &&\n\t\t\t\t\t\t\t\t\t\t\tdices[i + dx[n]][j + dy[n]][k + dz[n]][1] != 0 &&\n\t\t\t\t\t\t\t\t\t\t\tdice_right[dices[i + dx[n]][j + dy[n]][k + dz[n]][0] - 1][dices[i + dx[n]][j + dy[n]][k + dz[n]][1] - 1] != dice_right[l][dices[i][j][k][1]-1])\n\t\t\t\t\t\t\t\t\t\t\table = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!able)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (able) {\n\t\t\t\t\t\t\tdices[0][j][k][0] = l + 1;\n\t\t\t\t\t\t\tdices[1][j][k][0] = l + 1;\n\t\t\t\t\t\t\tdices[2][j][k][0] = l + 1;\n\t\t\t\t\t\t\tdfs();\n\t\t\t\t\t\t\tdices = copy_dices;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tREP(i,3) {\n\t\tREP(j, 3) {\n\t\t\tif (dice_right[dices[i][j][2][0] - 1][dices[i][j][2][1] - 1] == 0)\n\t\t\t\treturn;\n\t\t\tsum+=dice_right[dices[i][j][2][0] - 1][dices[i][j][2][1] - 1];\n\t\t}\n\t}\n\tans.push_back(sum);\n}\nint main() {\n\tint kurikaesu;\n\tcin >> kurikaesu;\n\twhile (kurikaesu--) {\n\t\tans.clear();\n\t\tREP(i, 3) {\n\t\t\tREP(j, 3) {\n\t\t\t\tREP(k, 3) {\n\t\t\t\t\tREP(l, 2) {\n\t\t\t\t\t\tdices[i][j][k][l] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, 3) {\n\t\t\tREP(j, 3) {\n\t\t\t\tcin >> dices[0][i][j][0];\n\t\t\t\tdices[1][i][j][0] = dices[0][i][j][0];\n\t\t\t\tdices[2][i][j][0] = dices[0][i][j][0];\n\t\t\t}\n\t\t}\n\t\tREP(i, 3) {\n\t\t\tREP(j, 3) {\n\t\t\t\tcin >> dices[i][2][j][1];\n\t\t\t\tdices[i][1][j][1] = dices[i][2][j][1];\n\t\t\t\tdices[i][0][j][1] = dices[i][2][j][1];\n\t\t\t}\n\t\t}\n\t\tdfs();\n\t\tSORT(ans);\n\t\tans.erase(unique(ans.begin(), ans.end()), ans.end());\n\t\tREP(i, ans.size()) {\n\t\t\tcout << ans[i];\n\t\t\tif (i != ans.size() - 1)\n\t\t\t\tcout << ' ';\n\t\t}\n\t\tif (ans.empty())\n\t\t\tcout << 0;\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct Dice{\n  int s[6];\n  void roll(char c){\n    //the view from above\n    // N\n    //W E\n    // S\n    //s[0]:top\n    //s[1]:south (front)\n    //s[2]:east\n    //s[3]:west\n    //s[4]:north\n    //s[5]:bottom\n    int b;\n    if(c=='E'){\n      b=s[0];\n      s[0]=s[3];\n      s[3]=s[5];\n      s[5]=s[2];\n      s[2]=b;\n    }\n    if(c=='W'){\n      b=s[0];\n      s[0]=s[2];\n      s[2]=s[5];\n      s[5]=s[3];\n      s[3]=b;\n    }\n    if(c=='N'){\n      b=s[0];\n      s[0]=s[1];\n      s[1]=s[5];\n      s[5]=s[4];\n      s[4]=b;\n    }\n    if(c=='S'){\n      b=s[0];\n      s[0]=s[4];\n      s[4]=s[5];\n      s[5]=s[1];\n      s[1]=b;\n    }\n    // migi neji\n    if(c=='R'){\n      b=s[1];\n      s[1]=s[3];\n      s[3]=s[4];\n      s[4]=s[2];\n      s[2]=b;\n    }\n    if(c=='L'){\n      b=s[1];\n      s[1]=s[2];\n      s[2]=s[4];\n      s[4]=s[3];\n      s[3]=b;\n    }\n  }\n  int top() {\n    return s[0];\n  }\n};\n\nint used[5][5][5];\nDice ds[5][5][5];\nvector<Dice> cd;\nvector<int> ans;\nint cx[]={1,2,3,1,1,2,3,1};\nint cy[]={2,2,2,3,1,1,1,1};\nint cz[]={1,1,1,1,2,2,2,3};\n\nint dx[]={0,0,1,-1,0,0};\nint dy[]={-1,0,0,0,0,1};\nint dz[]={0,-1,0,0,1,0};\n\nvoid dfs(){\n  \n  for(int k=0;k<8;k++){\n    int x=cx[k],y=cy[k],z=cz[k];\n    if(used[x][y][z]) continue;\n    //cout<<\"k:\"<<k<<endl;\n    for(int i=0;i<(int)cd.size();i++){\n      bool f=1;\n      for(int j=0;j<6;j++){\n\tint nx=x+dx[j],ny=y+dy[j],nz=z+dz[j];\n\tif(!used[nx][ny][nz]) continue;\n\tf&=cd[i].s[j]==ds[nx][ny][nz].s[j];\n      }\n      if(f){\n\tused[x][y][z]=1;\n\tds[x][y][z]=cd[i];\n\tdfs();\n\tused[x][y][z]=0;\n      }\n    }\n    return;\n  }\n  \n  for(int x=1;x<=3;x++){\n    for(int y=1;y<=3;y++){\n      for(int z=1;z<=3;z++){\n\tif(used[x][y][z]) continue;\n\t//cout<<x<<\" \"<<y<<\" \"<<z<<endl;\n\tfor(int i=0;i<(int)cd.size();i++){\n\t  bool f=1;\n\t  for(int j=0;j<6;j++){\n\t    int nx=x+dx[j],ny=y+dy[j],nz=z+dz[j];\n\t    if(!used[nx][ny][nz]) continue;\n\t    f&=cd[i].s[j]==ds[nx][ny][nz].s[j];\n\t  }\n\t  if(f){\n\t    used[x][y][z]=1;\n\t    ds[x][y][z]=cd[i];\n\t    dfs();\n\t    used[x][y][z]=0;\n\t  }\n\t}\n\treturn;\n      }\n    }\n  }\n  int tmp=0;\n  for(int y=1;y<=3;y++)\n    for(int z=1;z<=3;z++)\n      tmp+=ds[3][y][z].s[2];\n  ans.push_back(tmp);\n}\n\nsigned main(){\n  Dice d;\n  for(int i=0;i<6;i++) d.s[i]=i+1;\n  {\n    for(int i=0;i<6;i++){\n      Dice t(d);\n      if(i==1) t.roll('N'); \n      if(i==2) t.roll('S'); \n      if(i==3) t.roll('S'),t.roll('S');\n      if(i==4) t.roll('L'); \n      if(i==5) t.roll('R'); \n      for(int k=0;k<4;k++){\n\tcd.push_back(t);\n\tt.roll('E');\n      }\n    }\n    /*\n    for(int i=0;i<(int)cd.size();i++){\n      cout<<i<<\":\";\n      for(int j=0;j<6;j++) cout<<cd[i].s[j]<<\" \";\n      cout<<endl;\n    }\n    */\n  }\n  int T;\n  cin>>T;\n  while(T--){\n    memset(used,0,sizeof(used));\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tcin>>ds[j+1][0][3-i].s[0];\n\tif(ds[j+1][0][3-i].s[0]) used[j+1][0][3-i]=1;\n      }\n    }\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tcin>>ds[j+1][i+1][0].s[1];\n\tif(ds[j+1][i+1][0].s[1]) used[j+1][i+1][0]=1;\n      }\n    }\n    ans.clear();\n    dfs();\n    sort(ans.begin(),ans.end());\n    ans.erase(unique(ans.begin(),ans.end()),ans.end());\n    for(int i=0;i<(int)ans.size();i++){\n      if(i) cout<<\" \";\n      cout<<ans[i];\n    }\n    if(ans.empty()) cout<<0;\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\nusing namespace std;\n\nenum { U, F, R, D, B, L };\nstruct Dice {\n\tint face[6];\n\tDice() { face[F] = 1; face[R] = 2; face[U] = 3; face[B] = 6; face[L] = 5; face[D] = 4; }\n\tint find_face(int f) {\n\t\trep(i, 6) if(face[i] == f) return i;\n\t\treturn -1;\n\t}\n\tvoid turn(int dir) {\n\t\tswitch(dir) {\n\t\tcase R: rotate(U, R, D, L); break;\n\t\tcase B: rotate(U, B, D, F); break;\n\t\tcase L: rotate(U, L, D, R); break;\n\t\tcase F: rotate(U, F, D, B); break;\n\t\tcase U: rotate(F, R, B, L); break; // ??????????????????????¨???????\n\t\tcase D: rotate(F, L, B, R); break; // ??????????????????????¨???????\n\t\tdefault: assert(false);\n\t\t}\n\t}\n\tint & operator[](int n) { return face[n]; }\n\tvector<Dice> all() {\n\t\tvector<Dice> res;\n\t\trep(k, 6) {\n\t\t\trep(i, 4) { res.push_back(*this); turn(R); }\n\t\t\tif(k & 1) turn(U); else turn(F);\n\t\t}\n\t\treturn res;\n\t}\n\tvoid rotate(int a, int b, int c, int d) {\n\t\tint t = face[d];\n\t\tface[d] = face[c]; face[c] = face[b]; face[b] = face[a]; face[a] = t;\n\t}\n};\n\nint u[3][3][3];\nint f[3][3][3];\nint r[3][3][3];\nint ut[3][3][3];\nint ft[3][3][3];\n\nvector<Dice> ds[7][7][7];\nstruct P {\n\tint x, y, z;\n};\n\nvector<P> ps;\nvector<int> ans;\n\nvoid dfs(int n) {\n\t//cout << n << endl;\n\tif(n == 27) {\n\t\tint sum = 0;\n\t\tfor(int y = 0; y < 3; y++) {\n\t\t\tfor(int z = 0; z < 3; z++) {\n\t\t\t\tsum += r[2][y][z];\n\t\t\t}\n\t\t}\n\t\tans.push_back(sum);\n\t\treturn;\n\t}\n\n\tint x = ps[n].x, y = ps[n].y, z = ps[n].z;\n\t// u\n\tint uu = ut[x][y][z] ? u[x][y][z] : 0;\n\tfor(int i = 0; i < 3; i++) {\n\t\tif(y == i) continue;\n\t\tif(u[x][i][z] == 0) continue;\n\t\t//if(uu != 0 && uu != u[x][i][z]) return;\n\t\tuu = u[x][i][z];\n\t}\n\t// f\n\tint ff = ft[x][y][z] ? f[x][y][z] : 0;\n\tfor(int i = 0; i < 3; i++) {\n\t\tif(z == i) continue;\n\t\tif(f[x][y][i] == 0) continue;\n\t\t//if(ff != 0 && ff != f[x][y][i]) return;\n\t\tff = f[x][y][i];\n\t}\n\t// r\n\tint rr = 0;\n\tfor(int i = 0; i < 3; i++) {\n\t\tif(x == i) continue;\n\t\tif(r[i][y][z] == 0) continue;\n\t\t//if(rr != 0 && rr != r[i][y][z]) return;\n\t\trr = r[i][y][z];\n\t}\n\tfor(Dice d : ds[uu][ff][rr]) {\n\t\tu[x][y][z] = d[U];\n\t\tf[x][y][z] = d[F];\n\t\tr[x][y][z] = d[R];\n\t\tdfs(n + 1);\n\t\tif(!ut[x][y][z]) u[x][y][z] = 0;\n\t\tif(!ft[x][y][z]) f[x][y][z] = 0;\n\t\tr[x][y][z] = 0;\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t{\n\t\tDice d;\n\t\tvector<Dice> all = d.all();\n\t\tfor(Dice a : all) {\n\t\t\tfor(int i = 0; i < 7; i++) {\n\t\t\t\tfor(int j = 0; j < 7; j++) {\n\t\t\t\t\tfor(int k = 0; k < 7; k++) {\n\t\t\t\t\t\tif(i != 0 && i != a.face[U]) continue;\n\t\t\t\t\t\tif(j != 0 && j != a.face[F]) continue;\n\t\t\t\t\t\tif(k != 0 && k != a.face[R]) continue;\n\t\t\t\t\t\tds[i][j][k].push_back(a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int x = 0; x < 3; x++) {\n\t\tfor(int y = 0; y < 3; y++) {\n\t\t\tfor(int z = 0; z < 3; z++) {\n\t\t\t\tps.push_back(P{ x, y, z });\n\t\t\t}\n\t\t}\n\t}\n\n\tint n;\n\tcin >> n;\n\twhile(n--) {\n\t\tmemset(u, 0, sizeof u);\n\t\tmemset(f, 0, sizeof f);\n\t\tmemset(r, 0, sizeof r);\n\t\tmemset(ut, 0, sizeof u);\n\t\tmemset(ft, 0, sizeof f);\n\n\t\tfor(int z = 0; z < 3; z++) {\n\t\t\tfor(int x = 0; x < 3; x++) {\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tfor(int y = 0; y < 3; y++) {\n\t\t\t\t\tu[x][y][z] = a;\n\t\t\t\t\tif(a) ut[x][y][z] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int y = 0; y < 3; y++) {\n\t\t\tfor(int x = 0; x < 3; x++) {\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tfor(int z = 0; z < 3; z++) {\n\t\t\t\t\tf[x][y][z] = a;\n\t\t\t\t\tif(a) ft[x][y][z] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans.clear();\n\n\t\tdfs(0);\n\n\t\tsort(ans.begin(), ans.end());\n\t\tans.erase(unique(ans.begin(), ans.end()), ans.end());\n\n\t\tfor(int i = 0; i < ans.size(); i++) {\n\t\t\tcout << ans[i];\n\t\t\tif(i != ans.size() - 1) cout << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nint top[3][3];\nint front[3][3];\nint rights[3][3];\n\nset<int> s;\n\n\nconst int dice[6][6]={\n\t{0,3,5,2,4,0},\n\t{4,0,1,6,0,3},\n\t{2,6,0,0,1,5},\n\t{5,1,0,0,6,2},\n\t{3,0,6,1,0,4},\n\t{0,4,2,5,3,0}\n};\nconst int val[6][4]={{2,3,4,5},{1,3,4,6},{1,2,5,6},{1,2,5,6},{1,3,4,6},{2,3,4,5}};\n\nbool check(int f1,int f2,int f3,int t1,int t2,int t3){\n\trep(mask,1<<6){\n\t\tint t[3]={t1,t2,t3},f[3]={f1,f2,f3};\n\t\trep(i,3) if(f[i]==0)  f[i]=val[rights[i][0]-1][mask>>(2*i)&3];\t\n\t\trep(j,3) if(t[j]==0)  t[j]=7-dice[rights[0][j]-1][f[0]-1];\n\t\t\n\t\tbool ok=true;\n\t\trep(j,3) if(t[j]==7) ok=false;\n\t\tif(ok==false) continue;\n\n\t\trep(i,3)rep(j,3) if(dice[t[j]-1][f[i]-1]!=rights[i][j]) ok=false;\n\t\tif(ok) return true;\n\t}\n\treturn false;\n}\n\nvoid dfs(vector<int> ary,int idx){\n\tif(idx==6){\n\t\trep(i,3)rep(j,3) rights[i][j]=dice[ary[j+3]-1][ary[i]-1];\n\t\trep(i,3)rep(j,3) if(rights[i][j]==0) return;\n\n\n\t\t// rep(i,3){\n\t\t// \trep(j,3) cout << rights[i][j] << \" \";\n\t\t// \tcout << endl;\n\t\t// }\n\t\t// cout << \"----\" << endl;\n\n\t\trep(i,3) if(check(front[0][i],front[1][i],front[2][i],top[2][i],top[1][i],top[0][i])==false) return;\n\t\tint sum=0;\n\t\trep(i,3)rep(j,3) sum+=rights[i][j];\n\t\ts.insert(sum);\n\t\treturn ;\n\t}\n\n\tif(ary[idx]!=0){\n\t\tdfs(ary,idx+1);\n\t\treturn;\n\t}\n\t\n\tfor(int i=1;i<=6;++i){\n\t\tary[idx]=i;\n\t\tdfs(ary,idx+1);\n\t}\n}\n\n\nint main(void){\n\tint t;\n\tcin >> t;\n\twhile(t--){\n\t\ts.clear();\n\t\trep(i,3)rep(j,3) cin >> top[i][j];\n\t\trep(i,3)rep(j,3) cin >> front[i][j];\n\t\t\n\t\tvector<int> ary={front[0][0],front[1][0],front[2][0],top[2][0],top[1][0],top[0][0]};\n\n\t\tdfs(ary,0);\n\n\t\tif(int(s.size())==0)\n\t\t\tcout << 0 << endl;\n\t\telse{\n\t\t\tbool first=true;\n\t\t\tfor(auto &it:s) cout <<  (first?\"\":\" \") << it,first=false;\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nenum FACE { TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT };\nclass dice {\nprivate:\n\tint num[6];\n\n\tvoid roll(FACE a, FACE b, FACE c, FACE d) {\n\t\tswap(num[a], num[b]);\n\t\tswap(num[b], num[c]);\n\t\tswap(num[c], num[d]);\n\t}\n\npublic:\n\tdice() {\n\t\tnum[TOP] = 1;\n\t\tnum[BOTTOM] = 6;\n\t\tnum[FRONT] = 2;\n\t\tnum[BACK] = 5;\n\t\tnum[RIGHT] = 3;\n\t\tnum[LEFT] = 4;\n\t}\n\n\tvoid set(int top, int front) {\n        if(num[RIGHT] == top || num[LEFT] == top) west();\n        while(num[TOP] != top) north();\n        while(num[FRONT] != front) ccw();\n\t}\n\n\tconst int &operator[](FACE f) const { return num[f]; }\n\n\tvoid north() { roll(TOP, BACK, BOTTOM, FRONT); }\n\tvoid east()  { roll(TOP, LEFT, BOTTOM, RIGHT); }\n\tvoid west()  { roll(TOP, RIGHT, BOTTOM, LEFT); }\n\tvoid south() { roll(TOP, FRONT, BOTTOM, BACK); }\n\tvoid ccw()   { roll(BACK, RIGHT, FRONT, LEFT); }\n\tvoid cw()    { roll(BACK, LEFT, FRONT, RIGHT); }\n};\n\n\nint right_face[7][7];\nvoid init() {\n\tdice d;\n\tfor(int t = 1; t <= 6; ++t) {\n\t\tfor(int f = 1; f <= 6; ++f) {\n\t\t\tif(t == f || t + f == 7) continue;\n\t\t\td.set(t, f);\n\t\t\tright_face[t][f] = d[RIGHT];\n\t\t}\n\t}\n}\n\nint top[3][3][3];\nint front[3][3][3];\n\nvector<int> ans;\n\nvoid dfs(int x, int y, int z) {\n\tif(z == 3) {\n\t\tint sum = 0;\n\t\tfor(int z = 0; z < 3; ++z) {\n\t\t\tfor(int y = 0; y < 3; ++y) {\n\t\t\t\tsum += right_face[top[z][y][0]][front[z][y][0]];\n\t\t\t}\n\t\t}\n\t\tans.emplace_back(sum);\n\t}\n\telse if(y == 3) {\n\t\tdfs(0, 0, z + 1);\n\t}\n\telse if(x == 3) {\n\t\tdfs(0, y + 1, z);\n\t}\n\telse {\n\t\tconst int p_top = top[z][y][x];\n\t\tconst int p_front = front[z][y][x];\n\t\tfor(int t = 1; t <= 6; ++t) {\n\t\t\tif(top[z][y][x] && top[z][y][x] != t) continue;\n\t\t\tif(z && top[z - 1][y][x] != t) continue;\n\n\t\t\tfor(int f = 1; f <= 6; ++f) {\n\t\t\t\tif(t == f || t + f == 7) continue;\n\t\t\t\tif(front[z][y][x] && front[z][y][x] != f) continue;\n\t\t\t\tif(y && front[z][y - 1][x] != f) continue;\n\t\t\t\tif(x && right_face[top[z][y][x - 1]][front[z][y][x - 1]] != right_face[t][f]) continue;\n\n\t\t\t\ttop[z][y][x] = t;\n\t\t\t\tfront[z][y][x] = f;\n\t\t\t\tdfs(x + 1, y, z);\n\t\t\t\ttop[z][y][x] = p_top;\n\t\t\t\tfront[z][y][x] = p_front;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tans.clear();\n\tmemset(top, 0, sizeof(top));\n\tmemset(front, 0, sizeof(front));\n\n\tfor(int y = 0; y < 3; ++y) {\n\t\tfor(int x = 0; x < 3; ++x) {\n\t\t\tcin >> top[0][y][x];\n\t\t}\n\t}\n\n\tfor(int z = 0; z < 3; ++z) {\n\t\tfor(int x = 0; x < 3; ++x) {\n\t\t\tcin >> front[z][2][x];\n\t\t}\n\t}\n\n\tdfs(0, 0, 0);\n\tif(ans.size()) {\n\t\tsort(ans.begin(), ans.end());\n\t\tans.erase(unique(ans.begin(), ans.end()), ans.end());\n\t\tfor(unsigned i = 0; i < ans.size(); ++i) {\n\t\t\tcout << ans[i] << (i + 1 == ans.size() ? \"\\n\" : \" \");\n\t\t}\n\t}\n\telse {\n\t\tcout << \"0\\n\";\n\t}\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tinit();\n\n\tint n;\n\tcin >> n;\n\n\tcout << n << endl;\n\n\twhile(n--) solve();\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nstruct Solver{\n    int F[3][3];\n    int T[3][3];\n    int R[3][3];\n    int dice_R[7][7]; // [TOP][FRONT] -> RIGHT\n\n    enum FACE { TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT };\n\n    struct Dice {\n        vector<int> val;\n        Dice(vector<int> init) : val(init) {\n            assert(val.size() == 6);\n        }\n        void roll_x() { \n            roll(TOP, BACK, BOTTOM, FRONT);\n        }\n        void roll_y() {\n            roll(TOP, LEFT, BOTTOM, RIGHT);\n        }\n        void roll_z() {\n            roll(FRONT, RIGHT, BACK, LEFT);\n        }\n        void roll_r(int r){\n            if(r == 0) roll(TOP, LEFT, BOTTOM, RIGHT);\n            if(r == 1) roll(TOP, BACK, BOTTOM, FRONT);\n            if(r == 2) roll(TOP, RIGHT, BOTTOM, LEFT);\n            if(r == 3) roll(TOP, FRONT, BOTTOM, BACK);\n        }\n        void roll(int a, int b, int c, int d){ // a, b, c, d -> b, c, d, a\n            int tmp = val[a];\n            val[a] = val[b]; val[b] = val[c];\n            val[c] = val[d]; val[d] = tmp;\n        }\n    };\n\n    Solver(){\n        memset(F, 0, sizeof(F));\n        memset(T, 0, sizeof(T));\n        memset(R, 0, sizeof(R));\n\n        /* input */\n        REP(y, 3) REP(x, 3) cin >> T[y][x];\n        REP(y, 3) REP(x, 3) cin >> F[y][x];\n\n        Dice a(vector<int>({1, 6, 2, 5, 4, 3}));\n        for(int i = 0; i < 6; i++){\n            for(int j = 0; j < 4; j++){\n                //printf(\"%d %d -> %d\\n\", a.val[TOP], a.val[FRONT], a.val[RIGHT]);\n                dice_R[ a.val[TOP] ][ a.val[FRONT] ] = a.val[RIGHT];\n                a.roll_z();\n            }\n            if(i & 1) a.roll_x();\n            else a.roll_y();\n        }\n    }\n\n    set<int> answer;\n\n    void rec_F(int x, int y){\n        // printf(\"F(%d, %d)\\n\", x, y);\n        if(y == 3) {\n            rec_T(0, 0);\n        } else {\n            int nx = (x + 1 != 3 ? x + 1 : 0);\n            int ny = (x + 1 != 3 ? y : y + 1);\n            if(F[y][x] != 0){\n                rec_F(nx, ny);\n            }else{\n                for(int val = 1; val <= 6; val++){\n                    bool ok = true;\n                    for(int z = 0; z < 3; z++){\n                        if((T[z][x] == val) || (7 - T[z][x] == val)) {\n                            ok = false;\n                        }\n                    }\n                    if(ok){\n                        F[y][x] = val;\n                        rec_F(nx, ny);\n                        F[y][x] = 0;\n                    }\n                }\n            }\n        }\n    }\n\n    void rec_T(int x, int z){\n        if(z == 3) {\n            check();\n        } else {\n            int nx = (x + 1 != 3 ? x + 1 : 0);\n            int nz = (x + 1 != 3 ? z : z + 1);\n            if(T[z][x] != 0){\n                rec_T(nx, nz);\n            }else{\n                for(int val = 1; val <= 6; val++){\n                    bool ok = true;\n                    for(int y = 0; y < 3; y++){\n                        if((F[y][x] == val) || (7 - F[y][x] == val)) {\n                            ok = false;\n                        }\n                    }\n                    if(ok){\n                        T[z][x] = val;\n                        rec_T(nx, nz);\n                        T[z][x] = 0;\n                    }\n                }\n            }\n        }\n    }\n\n    // void rec_R(int z, int y){\n    //     if(y == 3){\n    //     }else{\n    //         int nz = (z + 1 != 3 ? z + 1 : 0);\n    //         int ny = (z + 1 != 3 ? y : y + 1);\n    //         assert(R[y][z] == 0);\n    //         for(int val = 1; val <= 6; val++){\n    //             bool ok = true;\n    //             for(int x = 0; x < 3; x++){\n    //                 if((F[y][x] == val) || (7 - F[y][x] == val)){\n    //                     ok = false;\n    //                 }\n    //                 if((T[2 - z][x] == val) || (7 - T[2 - z][x] == val)){\n    //                     ok = false;\n    //                 }\n    //             }\n    //             if(ok){\n    //                 R[y][z] = val;\n    //                 rec_R(nz, ny);\n    //                 R[y][z] = 0;\n    //             }\n    //         }\n    //     }\n    // }\n    //\n    void check(){\n        int sum = 0;\n        for(int y = 0; y < 3; y++){\n            for(int z = 0; z < 3; z++){\n                set<int> Rset;\n                for(int x = 0; x < 3; x++){\n                    Rset.insert(dice_R[ T[z][x] ][ F[y][x] ]);\n                }\n                if(Rset.size() != 1){\n                    // invalid face!\n                    return;\n                }\n                sum += *(Rset.begin());\n            }\n        }\n        answer.insert(sum);\n    }\n\n    vector<int> solve(){\n        answer.clear();\n        rec_F(0, 0);\n        vector<int> res(answer.begin(), answer.end());\n        if(res.empty()) res.push_back(0);\n        return res;\n    }\n};\n\nint main(){\n    int Test;\n    cin >> Test;\n    while(Test--){\n        Solver s;\n        vector<int> res = s.solve();\n        for(int i = 0; i < res.size(); i++){\n            cout << res[i];\n            if(i == res.size() - 1) cout << endl;\n            else cout << \" \";\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nenum POS {\n    TOP = 1,\n    FRONT,\n    RIGHT,\n    LEFT,\n    BACK,\n    BOTTOM\n};\n\n// dice[top][front][pos];\nint dice[7][7][7];\n\nvoid init() {\n    int right[7][7] = {};\n    right[1][2] = 3; right[1][3] = 5; right[1][4] = 2; right[1][5] = 4;\n    right[2][1] = 4; right[2][3] = 1; right[2][4] = 6; right[2][6] = 3;\n    right[3][1] = 2; right[3][2] = 6; right[3][5] = 1; right[3][6] = 5;\n    right[4][1] = 5; right[4][2] = 1; right[4][5] = 6; right[4][6] = 2;\n    right[5][1] = 3; right[5][3] = 6; right[5][4] = 1; right[5][6] = 4;\n    right[6][2] = 4; right[6][3] = 2; right[6][4] = 5; right[6][5] = 3;\n    for(int i=1; i<=6; ++i) {\n        for(int j=1; j<=6; ++j) {\n            dice[i][j][TOP] = i;\n            dice[i][j][FRONT] = j;\n            dice[i][j][RIGHT] = right[i][j];\n            dice[i][j][BOTTOM] = 7 - dice[i][j][TOP];\n            dice[i][j][BACK] = 7 - dice[i][j][FRONT];\n            dice[i][j][LEFT] = 7 - dice[i][j][RIGHT];\n        }\n    }\n}\n\nusing pii = pair<int, int>;\n\nint calc(vector<pii> const& cube) {\n    int res = 0;\n    for(int i=0; i<3; ++i) {\n        for(int j=0; j<3; ++j) {\n            auto p = cube[i*9 + j*3 + 2];\n            res += dice[p.first][p.second][RIGHT];\n        }\n    }\n    return res;\n}\n\nvoid solve(int d, vector<pii> const& init, vector<pii>& cube, vector<int>& res) {\n    if(d == 27) {\n        res.push_back(calc(cube));\n        return;\n    }\n    for(int i=1; i<=6; ++i) {\n        for(int j=1; j<=6; ++j) {\n            if(i == j || i + j == 7) {\n                continue;\n            }\n            if(init[d].first != 0 && init[d].first != i) {\n                continue;\n            }\n            if(init[d].second != 0 && init[d].second != j) {\n                continue;\n            }\n            if((d / 3) % 3 != 0) { // not back side of cube\n                if(dice[i][j][BACK] + cube[d-3].second != 7) {\n                    continue;\n                }\n            }\n            if(d % 3 != 0) { // not left side of cube\n                if(dice[i][j][LEFT] + dice[cube[d-1].first][cube[d-1].second][RIGHT] != 7) {\n                    continue;\n                }\n            }\n            if(d >= 9) { // not top of cube\n                if(i + dice[cube[d-9].first][cube[d-9].second][BOTTOM] != 7) {\n                    continue;\n                }\n            }\n            cube[d].first = i;\n            cube[d].second = j;\n            solve(d+1, init, cube, res);\n        }\n    }\n}\n\nint main() {\n    int N;\n    cin >> N;\n    init();\n    while(N--) {\n        vector<pii> cube(27);\n        for(int i=0; i<9; ++i) {\n            cin >> cube[i].first;\n        }\n        for(int i=0; i<3; ++i) {\n            for(int j=0; j<3; ++j) {\n                cin >> cube[i*9 + 6 + j].second;\n            }\n        }\n        auto init = cube;\n        vector<int> res;\n        solve(0, init, cube, res);\n        if(res.empty()) {\n            cout << 0 << endl;\n            continue;\n        }\n        sort(res.begin(), res.end());\n        res.erase(unique(res.begin(), res.end()), res.end());\n        for(int i=0; i<res.size(); ++i) {\n            cout << res[i] << \" \\n\"[i == res.size()-1] << flush;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nstruct Solver{\n    int F[3][3];\n    int T[3][3];\n    int R[3][3];\n    int dice_R[7][7]; // [TOP][FRONT] -> RIGHT\n\n    enum FACE { TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT };\n\n    struct Dice {\n        vector<int> val;\n        Dice(vector<int> init) : val(init) {\n            assert(val.size() == 6);\n        }\n        void roll_x() { \n            roll(TOP, BACK, BOTTOM, FRONT);\n        }\n        void roll_y() {\n            roll(TOP, LEFT, BOTTOM, RIGHT);\n        }\n        void roll_z() {\n            roll(FRONT, RIGHT, BACK, LEFT);\n        }\n        void roll_r(int r){\n            if(r == 0) roll(TOP, LEFT, BOTTOM, RIGHT);\n            if(r == 1) roll(TOP, BACK, BOTTOM, FRONT);\n            if(r == 2) roll(TOP, RIGHT, BOTTOM, LEFT);\n            if(r == 3) roll(TOP, FRONT, BOTTOM, BACK);\n        }\n        void roll(int a, int b, int c, int d){ // a, b, c, d -> b, c, d, a\n            int tmp = val[a];\n            val[a] = val[b]; val[b] = val[c];\n            val[c] = val[d]; val[d] = tmp;\n        }\n    };\n\n    Solver(){\n        memset(F, 0, sizeof(F));\n        memset(T, 0, sizeof(T));\n        memset(R, 0, sizeof(R));\n\n        /* input */\n        REP(y, 3) REP(x, 3) cin >> T[y][x];\n        REP(y, 3) REP(x, 3) cin >> F[y][x];\n\n        Dice a(vector<int>({1, 6, 2, 5, 4, 3}));\n        for(int i = 0; i < 6; i++){\n            for(int j = 0; j < 4; j++){\n                //printf(\"%d %d -> %d\\n\", a.val[TOP], a.val[FRONT], a.val[RIGHT]);\n                dice_R[ a.val[TOP] ][ a.val[FRONT] ] = a.val[RIGHT];\n                a.roll_z();\n            }\n            if(i & 1) a.roll_x();\n            else a.roll_y();\n        }\n    }\n\n    set<int> answer;\n\n    void rec_F(int x, int y){\n        // printf(\"F(%d, %d)\\n\", x, y);\n        if(y == 3) {\n            rec_T(0, 0);\n        } else {\n            int nx = (x + 1 != 3 ? x + 1 : 0);\n            int ny = (x + 1 != 3 ? y : y + 1);\n            for(int val = 1; val <= 6; val++){\n                if(F[y][x] != 0 && F[y][x] != val) continue;\n                bool ok = true;\n                for(int z = 0; z < 3; z++){\n                    if((T[z][x] == val) || (7 - T[z][x] == val)) {\n                        ok = false;\n                    }\n                }\n                if(ok){\n                    int tmp = F[y][x];\n                    F[y][x] = val;\n                    rec_F(nx, ny);\n                    F[y][x] = tmp;\n                }\n            }\n        }\n    }\n\n    void rec_T(int x, int z){\n        if(z == 3) {\n            check();\n        } else {\n            int nx = (x + 1 != 3 ? x + 1 : 0);\n            int nz = (x + 1 != 3 ? z : z + 1);\n            for(int val = 1; val <= 6; val++){\n                if(T[z][x] != 0 && T[z][x] != val) continue;\n                bool ok = true;\n                for(int y = 0; y < 3; y++){\n                    if((F[y][x] == val) || (7 - F[y][x] == val)) {\n                        ok = false;\n                    }\n                    if(x > 0 && dice_R[ val ][ F[y][x] ] != dice_R[ T[z][x - 1] ][ F[y][x - 1] ]){\n                        ok = false;\n                    }\n                }\n                if(ok){\n                    int tmp = T[z][x];\n                    T[z][x] = val;\n                    rec_T(nx, nz);\n                    T[z][x] = tmp;\n                }\n            }\n        }\n    }\n\n    // void rec_R(int z, int y){\n    //     if(y == 3){\n    //     }else{\n    //         int nz = (z + 1 != 3 ? z + 1 : 0);\n    //         int ny = (z + 1 != 3 ? y : y + 1);\n    //         assert(R[y][z] == 0);\n    //         for(int val = 1; val <= 6; val++){\n    //             bool ok = true;\n    //             for(int x = 0; x < 3; x++){\n    //                 if((F[y][x] == val) || (7 - F[y][x] == val)){\n    //                     ok = false;\n    //                 }\n    //                 if((T[2 - z][x] == val) || (7 - T[2 - z][x] == val)){\n    //                     ok = false;\n    //                 }\n    //             }\n    //             if(ok){\n    //                 R[y][z] = val;\n    //                 rec_R(nz, ny);\n    //                 R[y][z] = 0;\n    //             }\n    //         }\n    //     }\n    // }\n    //\n    void check(){\n        int sum = 0;\n        for(int y = 0; y < 3; y++){\n            for(int z = 0; z < 3; z++){\n                // set<int> Rset;\n                // for(int x = 0; x < 3; x++){\n                //     Rset.insert(dice_R[ T[z][x] ][ F[y][x] ]);\n                // }\n                // if(Rset.size() != 1){\n                //     // invalid face!\n                //     return;\n                // }\n                // sum += *(Rset.begin());\n                assert(dice_R[ T[z][0] ][ F[y][0] ] != 0);\n                assert(dice_R[ T[z][0] ][ F[y][0] ] == dice_R[ T[z][1] ][ F[y][1] ]);\n                assert(dice_R[ T[z][1] ][ F[y][1] ] == dice_R[ T[z][2] ][ F[y][2] ]);\n                sum += dice_R[ T[z][0] ][ F[y][0] ];\n            }\n        }\n        answer.insert(sum);\n    }\n\n    vector<int> solve(){\n        answer.clear();\n        rec_F(0, 0);\n        vector<int> res(answer.begin(), answer.end());\n        if(res.empty()) res.push_back(0);\n        return res;\n    }\n};\n\nint main(){\n    int Test;\n    cin >> Test;\n    while(Test--){\n        Solver s;\n        vector<int> res = s.solve();\n        for(int i = 0; i < res.size(); i++){\n            cout << res[i];\n            if(i == res.size() - 1) cout << endl;\n            else cout << \" \";\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Dice\n{\npublic:\n    vector<int> pip; // ì¼kãºÌÚ\n    Dice(){\n        pip.resize(6);\n        pip[0] = 3;\n        pip[1] = 2;\n        pip[2] = 4;\n        pip[3] = 5;\n        pip[4] = 1;\n        pip[5] = 6;\n    }\n    void roll(int d){ // ì¼kE¶Éñ]\n        int dir[][4] = {{4,2,5,0},{4,3,5,1},{4,0,5,2},{4,1,5,3},{0,3,2,1},{0,1,2,3}};\n        int tmp = pip[dir[d][0]];\n        for(int i=0; i<3; ++i)\n            pip[dir[d][i]] = pip[dir[d][i+1]];\n        pip[dir[d][3]] = tmp;\n    }\n};\n\nvector<vector<vector<Dice> > > dice(4, vector<vector<Dice> >(4, vector<Dice>(4)));\nset<int> ret;\n\nvoid solve(int curr)\n{\n    if(curr == 27){\n        int sum = 0;\n        for(int i=0; i<9; ++i)\n            sum += dice[3][i/3+1][i%3+1].pip[0];\n        ret.insert(sum);\n        return;\n    }\n\n    int x = curr % 3 + 1;\n    int y = curr / 3 % 3 + 1;\n    int z = curr / 9 + 1;\n\n    for(int j=0; j<6; ++j){\n        if(j < 4)\n            dice[x][y][z].roll(0);\n        else{\n            dice[x][y][z].roll(1);\n            if(j == 5)\n                dice[x][y][z].roll(1);\n        }\n        for(int k=0; k<4; ++k){\n            dice[x][y][z].roll(4);\n            if(dice[x-1][y][z].pip[0] != 0 && dice[x-1][y][z].pip[0] + dice[x][y][z].pip[2] != 7)\n                continue;\n            if(dice[x][y-1][z].pip[3] != 0 && dice[x][y-1][z].pip[3] + dice[x][y][z].pip[1] != 7)\n                continue;\n            if(dice[x][y][z-1].pip[5] != 0 && dice[x][y][z-1].pip[5] + dice[x][y][z].pip[4] != 7)\n                continue;\n            solve(curr+1);\n        }\n    }\n}\n\nint main()\n{\n    for(int i=0; i<9; ++i)\n        dice[0][i/3+1][i%3+1].pip[0] = 0;\n\n    int n;\n    cin >> n;\n\n    while(--n >= 0){\n        for(int i=0; i<9; ++i){\n            int a;\n            cin >> a;\n            if(a != 0)\n                a = 7 - a;\n            dice[i%3+1][3-i/3][0].pip[5] = a;\n        }\n        for(int i=0; i<9; ++i){\n            int a;\n            cin >> a;\n            if(a != 0)\n                a = 7 - a;\n            dice[i%3+1][0][i/3+1].pip[3] = a;\n        }\n\n        ret.clear();\n        solve(0);\n\n        if(ret.empty())\n            cout << 0 << endl;\n        else{\n            set<int>::iterator it;\n            for(it=ret.begin(); it!=ret.end(); ++it){\n                if(it != ret.begin())\n                    cout << ' ';\n                cout << *it;\n            }\n            cout << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\n\nint dx[]={0,0,1,0,-1,0};\nint dy[]={0,-1,0,1,0,0};\nint dz[]={-1,0,0,0,0,1};\nint arc[]={5,3,4,1,2,0};\n\nint dice[24][6]={\n  {1,2,3,5,4,6},\n  {0,0,0,0,0,0},\n  {0,0,0,0,0,0},\n  {0,0,0,0,0,0},\n  {2,1,4,6,3,5},\n  {0,0,0,0,0,0},\n  {0,0,0,0,0,0},\n  {0,0,0,0,0,0},\n  {3,1,2,6,5,4},\n  {0,0,0,0,0,0},\n  {0,0,0,0,0,0},\n  {0,0,0,0,0,0},\n  {4,1,5,6,2,3},\n  {0,0,0,0,0,0},\n  {0,0,0,0,0,0},\n  {0,0,0,0,0,0},\n  {5,1,3,6,4,2},\n  {0,0,0,0,0,0},\n  {0,0,0,0,0,0},\n  {0,0,0,0,0,0},\n  {6,2,4,5,3,1},\n  {0,0,0,0,0,0},\n  {0,0,0,0,0,0},\n  {0,0,0,0,0,0},\n};\nvoid init(){\n  for(int i=0;i<24;i+=4){\n    for(int j=1;j<4;j++){\n      dice[i+j][0]=dice[i][0];\n      dice[i+j][5]=dice[i][5];\n      dice[i+j][4]=dice[i+j-1][1];\n      for(int k=1;k<4;k++){\n        dice[i+j][k]=dice[i+j-1][k+1];\n      }\n    }\n  }\n}\n\nint a[5][5][5];   // a(x,y,z);\n\nvoid input(){\n  int x;\n  cin>>x;\n  if(x)r(i,24)if(dice[i][5]+x==7){a[0][3][1]=i;break;}\n  cin>>x;\n  if(x)r(i,24)if(dice[i][5]+x==7){a[0][3][2]=i;break;}\n  cin>>x;\n  if(x)r(i,24)if(dice[i][5]+x==7){a[0][3][3]=i;break;}\n  cin>>x;\n  if(x)r(i,24)if(dice[i][5]+x==7){a[0][2][1]=i;break;}\n  cin>>x;\n  if(x)r(i,24)if(dice[i][5]+x==7){a[0][2][2]=i;break;}\n  cin>>x;\n  if(x)r(i,24)if(dice[i][5]+x==7){a[0][2][3]=i;break;}\n  cin>>x;\n  if(x)r(i,24)if(dice[i][5]+x==7){a[0][1][1]=i;break;}\n  cin>>x;\n  if(x)r(i,24)if(dice[i][5]+x==7){a[0][1][2]=i;break;}\n  cin>>x;\n  if(x)r(i,24)if(dice[i][5]+x==7){a[0][1][3]=i;break;}\n  cin>>x;\n  if(x)r(i,24)if(dice[i][3]+x==7){a[1][0][1]=i;break;}\n  cin>>x;\n  if(x)r(i,24)if(dice[i][3]+x==7){a[1][0][2]=i;break;}\n  cin>>x;\n  if(x)r(i,24)if(dice[i][3]+x==7){a[1][0][3]=i;break;}\n  cin>>x;\n  if(x)r(i,24)if(dice[i][3]+x==7){a[2][0][1]=i;break;}\n  cin>>x;\n  if(x)r(i,24)if(dice[i][3]+x==7){a[2][0][2]=i;break;}\n  cin>>x;\n  if(x)r(i,24)if(dice[i][3]+x==7){a[2][0][3]=i;break;}\n  cin>>x;\n  if(x)r(i,24)if(dice[i][3]+x==7){a[3][0][1]=i;break;}\n  cin>>x;\n  if(x)r(i,24)if(dice[i][3]+x==7){a[3][0][2]=i;break;}\n  cin>>x;\n  if(x)r(i,24)if(dice[i][3]+x==7){a[3][0][3]=i;break;}\n}\nvector<int>v;\nvoid dfs(int d){\n  if(d==27){\n    int sum=0;\n    sum+=dice[a[1][1][3]][2];\n    sum+=dice[a[2][1][3]][2];\n    sum+=dice[a[3][1][3]][2];\n    sum+=dice[a[1][2][3]][2];\n    sum+=dice[a[2][2][3]][2];\n    sum+=dice[a[3][2][3]][2];\n    sum+=dice[a[1][3][3]][2];\n    sum+=dice[a[2][3][3]][2];\n    sum+=dice[a[3][3][3]][2];\n    v.push_back(sum);\n    return;\n  }\n  int x=(d%3)+1;\n  int y=((d%9)/3)+1;\n  int z=(d/9)+1;\n  int match[6];\n  memset(match,-1,sizeof(match));\n  r(i,6){\n    int nx=x+dx[i];\n    int ny=y+dy[i];\n    int nz=z+dz[i];\n    if(a[nz][ny][nx]!=-1){\n      match[i]=7-dice[a[nz][ny][nx]][arc[i]];\n    }\n  }\n  r(i,24){\n    int flag=0;\n    r(j,6){\n      if(match[j]!=-1&&dice[i][j]!=match[j])flag=1;\n    }\n    if(!flag){\n      a[z][y][x]=i;\n      dfs(d+1);\n      a[z][y][x]=-1;\n    }\n  }\n}\nsigned main(){\n  init();\n  int test;\n  cin>>test;\n  while(test--){\n    memset(a,-1,sizeof(a));\n    input();\n    dfs(0);\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n    if(v.size())r(i,v.size()){\n      if(i)cout<<' ';\n      cout<<v[i];\n    }\n    else cout<<0;\n    cout<<endl;\n    v.clear();\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int N = 3;\nconst int M = 7;\n\nint top[N][N];\nint front[N][N];\nint R[N][N];\n\nset<int> sums;\n\ninline bool check(int f, int t, int r){\n    if(min(f, M - f) == min(t, M - t) or \n       min(t, M - t) == min(r, M - r) or\n       min(r, M - r) == min(f, M - f)) return false;\n\n    if(f >= 4){\n        f = M - f;\n        r = M - r;\n    }\n    if(r >= 4){\n        r = M - r;\n        t = M - t;\n    }\n\n    int c = -1;\n    if(f == 1 and r == 2) c = M - 4;\n    if(f == 1 and r == 3) c = M - 2;\n    if(f == 2 and r == 1) c = M - 3;\n    if(f == 2 and r == 3) c = M - 6;\n    if(f == 3 and r == 1) c = M - 5;\n    if(f == 3 and r == 2) c = M - 1;\n    assert(c != -1);\n\n    return t == c;\n}\n\nvoid dfs(int depth){\n    if(depth == N * N * N){\n        int sum = 0;\n        rep(i, N) rep(j, N) sum += R[i][j];\n        sums.insert(sum);\n        return;\n    }\n\n    int i = depth / (N * N), j = depth % (N * N) / N, k = depth % N;\n    int& t_in = top[N - 1 - j][N - 1 - k];\n    int& f_in = front[i][N - 1 - k];\n    int& r_in = R[i][j];\n\n    int ts = (t_in == 0 ? 1:t_in);\n    int tt = (t_in == 0 ? M:t_in + 1);\n    int fs = (f_in == 0 ? 1:f_in);\n    int ft = (f_in == 0 ? M:f_in + 1);\n    int rs = (r_in == 0 ? 1:r_in);\n    int rt = (r_in == 0 ? M:r_in + 1);\n\n    rep(f, fs, ft){\n        rep(t, ts, tt){\n            rep(r, rs, rt){\n                if(check(f, t, r)){\n                    int t_org = t_in, f_org = f_in, r_org = r_in;\n                    t_in = t, f_in = f, r_in = r;\n                    dfs(depth + 1);\n                    t_in = t_org, f_in = f_org, r_in = r_org;\n                }\n            }\n        }\n    }\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int T = 0; cin >> T;\n    rep(loop, T){\n        rep(i, N) rep(j, N) cin >> top[i][j];\n        rep(i, N) rep(j, N) cin >> front[i][j];\n        rep(i, N) rep(j, N) R[i][j] = 0;\n        sums.clear();\n\n        dfs(0);\n\n        bool fst = true;\n        for(auto& e : sums){\n            cout << (fst ? \"\":\" \") << e;\n            fst = false;\n        }\n        if(fst) cout << 0;\n        cout << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<algorithm>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++ )\n\nint RT[24][6] = {\n    {1,2,3,4,5,6}, {1,3,5,2,4,6}, {1,5,4,3,2,6}, {1,4,2,5,3,6},\n    {4,2,1,6,5,3}, {4,1,5,2,6,3}, {4,5,6,1,2,3}, {4,6,2,5,1,3},\n    {6,2,4,3,5,1}, {6,4,5,2,3,1}, {6,5,3,4,2,1}, {6,3,2,5,4,1},\n    {3,2,6,1,5,4}, {3,6,5,2,1,4}, {3,5,1,6,2,4}, {3,1,2,5,6,4},\n    {5,1,3,4,6,2}, {5,3,6,1,4,2}, {5,6,4,3,1,2}, {5,4,1,6,3,2},\n    {2,1,4,3,6,5}, {2,4,6,1,3,5}, {2,6,3,4,1,5}, {2,3,1,6,4,5}\n};\n\nint T[3][3], F[3][3], puzzle[27];\nset<int> solved;\n\nint getRight(){\n    int sum = 0;\n    for ( int i = 2; i < 27; i += 3 ) sum += RT[puzzle[i]][2];\n    return sum;\n}\n\nvoid recursive( int pos ){\n    if ( pos == 27 ){ solved.insert(getRight()); return; }\n    int i = (pos%9)/3;\n    int j = (pos%9)%3;\n    int k = pos/9;\n\n    rep(r, 24){\n        if ( i == 0 && T[3-k-1][j] && T[3-k-1][j] != RT[r][0] ) continue;\n        if ( k == 0 && F[i][j] && F[i][j] != RT[r][1] ) continue;\n        if ( i && RT[r][0] + RT[puzzle[k*9+(i-1)*3+j]][5] != 7 ) continue;\n        if ( k && RT[r][1] + RT[puzzle[(k-1)*9+i*3+j]][4] != 7 ) continue;\n        if ( j && RT[r][3] + RT[puzzle[k*9+i*3+(j-1)]][2] != 7 ) continue;\n        puzzle[pos] = r;\n        recursive( pos+1 );\n    }\n}\n\nvoid compute(){\n    solved.clear();\n    recursive(0);\n    if ( solved.size() == 0 ) {\tcout << 0 << endl; return; }\n    set<int>::iterator p = solved.begin();\n    cout << *p;\n    for ( p++; p != solved.end(); p++ ) cout << \" \" << *p;\n    cout << endl;\n}\n\nmain(){\n    int tcase; cin >> tcase;\n    rep(t, tcase){\n      rep(i, 3) rep(j, 3) cin >> T[i][j];\n      rep(i, 3) rep(j, 3) cin >> F[i][j];\n      compute();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nstruct Solver{\n    int F[3][3];\n    int T[3][3];\n    int R[3][3];\n    int dice_R[7][7]; // [TOP][FRONT] -> RIGHT\n\n    enum FACE { TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT };\n\n    struct Dice {\n        vector<int> val;\n        Dice(vector<int> init) : val(init) {\n            assert(val.size() == 6);\n        }\n        void roll_x() { \n            roll(TOP, BACK, BOTTOM, FRONT);\n        }\n        void roll_y() {\n            roll(TOP, LEFT, BOTTOM, RIGHT);\n        }\n        void roll_z() {\n            roll(FRONT, RIGHT, BACK, LEFT);\n        }\n        void roll_r(int r){\n            if(r == 0) roll(TOP, LEFT, BOTTOM, RIGHT);\n            if(r == 1) roll(TOP, BACK, BOTTOM, FRONT);\n            if(r == 2) roll(TOP, RIGHT, BOTTOM, LEFT);\n            if(r == 3) roll(TOP, FRONT, BOTTOM, BACK);\n        }\n        void roll(int a, int b, int c, int d){ // a, b, c, d -> b, c, d, a\n            int tmp = val[a];\n            val[a] = val[b]; val[b] = val[c];\n            val[c] = val[d]; val[d] = tmp;\n        }\n    };\n\n    Solver(){\n        memset(F, 0, sizeof(F));\n        memset(T, 0, sizeof(T));\n        memset(R, 0, sizeof(R));\n\n        /* input */\n        REP(y, 3) REP(x, 3) cin >> T[y][x];\n        REP(y, 3) REP(x, 3) cin >> F[y][x];\n\n        Dice a(vector<int>({1, 6, 2, 5, 4, 3}));\n        for(int i = 0; i < 6; i++){\n            for(int j = 0; j < 4; j++){\n                //printf(\"%d %d -> %d\\n\", a.val[TOP], a.val[FRONT], a.val[RIGHT]);\n                dice_R[ a.val[TOP] ][ a.val[FRONT] ] = a.val[RIGHT];\n                a.roll_z();\n            }\n            if(i & 1) a.roll_x();\n            else a.roll_y();\n        }\n    }\n\n    set<int> answer;\n\n    void rec_F(int x, int y){\n        // printf(\"F(%d, %d)\\n\", x, y);\n        if(y == 3) {\n            rec_T(0, 0);\n        } else {\n            int nx = (x + 1 != 3 ? x + 1 : 0);\n            int ny = (x + 1 != 3 ? y : y + 1);\n            for(int val = 1; val <= 6; val++){\n                if(F[y][x] != 0 && F[y][x] != val) continue;\n                bool ok = true;\n                for(int z = 0; z < 3; z++){\n                    if((T[z][x] == val) || (7 - T[z][x] == val)) {\n                        ok = false;\n                    }\n                }\n                if(ok){\n                    int tmp = F[y][x];\n                    F[y][x] = val;\n                    rec_F(nx, ny);\n                    F[y][x] = tmp;\n                }\n            }\n        }\n    }\n\n    void rec_T(int x, int z){\n        if(z == 3) {\n            check();\n        } else {\n            int nx = (x + 1 != 3 ? x + 1 : 0);\n            int nz = (x + 1 != 3 ? z : z + 1);\n            for(int val = 1; val <= 6; val++){\n                if(T[z][x] != 0 && T[z][x] != val) continue;\n                bool ok = true;\n                for(int y = 0; y < 3; y++){\n                    if((F[y][x] == val) || (7 - F[y][x] == val)) {\n                        ok = false;\n                    }\n                    if(x > 0 && dice_R[ val ][ F[y][x] ] != dice_R[ T[z][x - 1] ][ F[y][x - 1] ]){\n                        ok = false;\n                    }\n                }\n                if(ok){\n                    int tmp = T[z][x];\n                    T[z][x] = val;\n                    rec_T(nx, nz);\n                    T[z][x] = tmp;\n                }\n            }\n        }\n    }\n\n    // void rec_R(int z, int y){\n    //     if(y == 3){\n    //     }else{\n    //         int nz = (z + 1 != 3 ? z + 1 : 0);\n    //         int ny = (z + 1 != 3 ? y : y + 1);\n    //         assert(R[y][z] == 0);\n    //         for(int val = 1; val <= 6; val++){\n    //             bool ok = true;\n    //             for(int x = 0; x < 3; x++){\n    //                 if((F[y][x] == val) || (7 - F[y][x] == val)){\n    //                     ok = false;\n    //                 }\n    //                 if((T[2 - z][x] == val) || (7 - T[2 - z][x] == val)){\n    //                     ok = false;\n    //                 }\n    //             }\n    //             if(ok){\n    //                 R[y][z] = val;\n    //                 rec_R(nz, ny);\n    //                 R[y][z] = 0;\n    //             }\n    //         }\n    //     }\n    // }\n    //\n    void check(){\n        int sum = 0;\n        for(int y = 0; y < 3; y++){\n            for(int z = 0; z < 3; z++){\n                // set<int> Rset;\n                // for(int x = 0; x < 3; x++){\n                //     Rset.insert(dice_R[ T[z][x] ][ F[y][x] ]);\n                // }\n                // if(Rset.size() != 1){\n                //     // invalid face!\n                //     return;\n                // }\n                // sum += *(Rset.begin());\n                assert(dice_R[ T[z][0] ][ F[y][0] ] != 0);\n                assert(dice_R[ T[z][0] ][ F[y][0] ] == dice_R[ T[z][1] ][ F[y][1] ]);\n                assert(dice_R[ T[z][1] ][ F[y][1] ] == dice_R[ T[z][2] ][ F[y][2] ]);\n                sum += dice_R[ T[z][0] ][ F[y][0] ];\n            }\n        }\n        answer.insert(sum);\n    }\n\n    vector<int> solve(){\n        answer.clear();\n        rec_F(0, 0);\n        vector<int> res(answer.begin(), answer.end());\n        if(res.empty()) res.push_back(0);\n        return res;\n    }\n};\n\nint main(){\n    int Test;\n    cin >> Test;\n    while(Test--){\n        Solver s;\n        vector<int> res = s.solve();\n        for(int i = 0; i < res.size(); i++){\n            cout << res[i];\n            if(i == res.size() - 1) cout << endl;\n            else cout << \" \";\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nclass Dice{\npublic:\n\tDice(){\n\t\tinit();\n\t};\n\n\tvoid setPos(int num){\n\n\t\tfor(int i = 0; i < 6; i++)work[i] = number[i];\n\n\t\tswitch(num){\n\t\tcase 0:\n\t\t\tsetNumber(work[4],work[0],work[2],work[3],work[5],work[1]);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tsetNumber(work[5],work[4],work[2],work[3],work[1],work[0]);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tsetNumber(work[1],work[5],work[2],work[3],work[0],work[4]);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tsetNumber(work[0],work[1],work[2],work[3],work[4],work[5]);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tsetNumber(work[2],work[1],work[5],work[0],work[4],work[3]);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tsetNumber(work[4],work[2],work[5],work[0],work[3],work[1]);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tsetNumber(work[3],work[4],work[5],work[0],work[1],work[2]);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tsetNumber(work[1],work[3],work[5],work[0],work[2],work[4]);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tsetNumber(work[5],work[3],work[4],work[1],work[2],work[0]);\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tsetNumber(work[2],work[5],work[4],work[1],work[0],work[3]);\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tsetNumber(work[0],work[2],work[4],work[1],work[3],work[5]);\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tsetNumber(work[3],work[0],work[4],work[1],work[5],work[2]);\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tsetNumber(work[1],work[0],work[3],work[2],work[5],work[4]);\n\t\t\tbreak;\n\t\tcase 13:\n\t\t\tsetNumber(work[5],work[1],work[3],work[2],work[4],work[0]);\n\t\t\tbreak;\n\t\tcase 14:\n\t\t\tsetNumber(work[4],work[5],work[3],work[2],work[0],work[1]);\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\tsetNumber(work[0],work[4],work[3],work[2],work[1],work[5]);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tsetNumber(work[2],work[4],work[0],work[5],work[1],work[3]);\n\t\t\tbreak;\n\t\tcase 17:\n\t\t\tsetNumber(work[1],work[2],work[0],work[5],work[3],work[4]);\n\t\t\tbreak;\n\t\tcase 18:\n\t\t\tsetNumber(work[3],work[1],work[0],work[5],work[4],work[2]);\n\t\t\tbreak;\n\t\tcase 19:\n\t\t\tsetNumber(work[4],work[3],work[0],work[5],work[2],work[1]);\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\tsetNumber(work[0],work[3],work[1],work[4],work[2],work[5]);\n\t\t\tbreak;\n\t\tcase 21:\n\t\t\tsetNumber(work[2],work[0],work[1],work[4],work[5],work[3]);\n\t\t\tbreak;\n\t\tcase 22:\n\t\t\tsetNumber(work[5],work[2],work[1],work[4],work[3],work[0]);\n\t\t\tbreak;\n\t\tcase 23:\n\t\t\tsetNumber(work[3],work[5],work[1],work[4],work[0],work[2]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\tint getTop(){\n\t\treturn number[0];\n\t}\n\n\tint getFront(){\n\t\treturn number[4];\n\t}\n\n\tint getEast(){\n\t\treturn number[2];\n\t}\n\n\tint getNorth(){\n\t\treturn number[1];\n\t}\n\n\tint getWest(){\n\t\treturn number[3];\n\t}\n\n\tint getBottom(){\n\t\treturn number[5];\n\t}\n\n\tint getSouth(){\n\t\treturn number[4];\n\t}\n\n\tvoid setNumber(int n0,int n1,int n2,int n3,int n4,int n5){\n\t\tnumber[0] = n0;\n\t\tnumber[1] = n1;\n\t\tnumber[2] = n2;\n\t\tnumber[3] = n3;\n\t\tnumber[4] = n4;\n\t\tnumber[5] = n5;\n\t}\n\n\tvoid init(){\n\t\tsetNumber(1,5,3,4,2,6);\n\t}\n\n\tvoid set(Dice arg){\n\t\tfor(int i = 0; i < 6; i++){\n\t\t\tnumber[i] = arg.number[i];\n\t\t}\n\t}\n\n\tint number[6];\n\tint work[6];\n};\n\nbool rangeCheck(int height,int row,int col){\n\tif(height >= 0 && height <= 2 && row >= 0 && row <= 2 && col >= 0 && col <= 2)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint top[3][3],front[3][3];\n\nstruct Puzzle{\n\tDice dice[3][3][3];\n\tbool check[3][3][3];\n\tint num;\n};\n\nvector<Puzzle> V;\nvector<int> ANS;\n\nvoid copyPuzzle(Puzzle& to,Puzzle from){\n\n\tfor(int a = 0; a < 3; a++){\n\t\tfor(int b = 0; b < 3; b++){\n\t\t\tfor(int c = 0; c < 3; c++){\n\t\t\t\tto.dice[a][b][c].set(from.dice[a][b][c]);\n\t\t\t\tto.check[a][b][c] = from.check[a][b][c];\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool adj_check(Puzzle puzzle,int height,int row,int col){\n\n\tif(rangeCheck(height+1,row,col) == true && puzzle.check[height+1][row][col] == true && puzzle.dice[height][row][col].getTop()+puzzle.dice[height+1][row][col].getBottom() != 7)return false;\n\n\tif(rangeCheck(height,row,col+1) == true && puzzle.check[height][row][col+1] == true && puzzle.dice[height][row][col].getEast()+puzzle.dice[height][row][col+1].getWest()!= 7)return false;\n\n\tif(rangeCheck(height,row,col-1) == true && puzzle.check[height][row][col-1] == true && puzzle.dice[height][row][col].getWest()+puzzle.dice[height][row][col-1].getEast()!= 7)return false;\n\n\tif(rangeCheck(height,row+1,col) == true && puzzle.check[height][row+1][col] == true && puzzle.dice[height][row][col].getSouth()+puzzle.dice[height][row+1][col].getNorth()!= 7)return false;\n\n\tif(rangeCheck(height,row-1,col) == true && puzzle.check[height][row-1][col] == true && puzzle.dice[height][row][col].getNorth()+puzzle.dice[height][row-1][col].getSouth()!= 7)return false;\n\n\tif(rangeCheck(height-1,row,col) == true && puzzle.check[height-1][row][col] == true && puzzle.dice[height][row][col].getBottom()+puzzle.dice[height-1][row][col].getTop()!= 7)return false;\n\n\treturn true;\n}\n\nvoid recursive(Puzzle puzzle);\n\nvoid func(Puzzle puzzle,int height,int row,int col){\n\tfor(int i = 0; i < 24; i++){\n\t\tPuzzle new_puzzle;\n\t\tcopyPuzzle(new_puzzle,puzzle);\n\t\tnew_puzzle.dice[height][row][col].setPos(i);\n\t\tif(!adj_check(new_puzzle,height,row,col))continue;\n\t\tnew_puzzle.check[height][row][col] = true;\n\t\tnew_puzzle.num = puzzle.num+1;\n\t\trecursive(new_puzzle);\n\t}\n}\n\nvoid recursive(Puzzle puzzle){\n\n\tif(puzzle.num == 27){\n\t\tV.push_back(puzzle);\n\t\treturn;\n\t}\n\n\tswitch(puzzle.num){\n\tcase 0:\n\t\tfunc(puzzle,2,1,1);\n\t\tbreak;\n\tcase 1:\n\t\tfunc(puzzle,2,0,1);\n\t\tbreak;\n\tcase 2:\n\t\tfunc(puzzle,2,1,2);\n\t\tbreak;\n\tcase 3:\n\t\tfunc(puzzle,2,2,1);\n\t\tbreak;\n\tcase 4:\n\t\tfunc(puzzle,2,1,0);\n\t\tbreak;\n\tcase 5:\n\t\tfunc(puzzle,2,0,0);\n\t\tbreak;\n\tcase 6:\n\t\tfunc(puzzle,2,0,2);\n\t\tbreak;\n\tcase 7:\n\t\tfunc(puzzle,2,2,2);\n\t\tbreak;\n\tcase 8:\n\t\tfunc(puzzle,2,2,0);\n\t\tbreak;\n\tcase 9:\n\t\tfunc(puzzle,1,1,1);\n\t\tbreak;\n\tcase 10:\n\t\tfunc(puzzle,1,0,1);\n\t\tbreak;\n\tcase 11:\n\t\tfunc(puzzle,1,1,2);\n\t\tbreak;\n\tcase 12:\n\t\tfunc(puzzle,1,2,1);\n\t\tbreak;\n\tcase 13:\n\t\tfunc(puzzle,1,1,0);\n\t\tbreak;\n\tcase 14:\n\t\tfunc(puzzle,1,0,0);\n\t\tbreak;\n\tcase 15:\n\t\tfunc(puzzle,1,0,2);\n\t\tbreak;\n\tcase 16:\n\t\tfunc(puzzle,1,2,2);\n\t\tbreak;\n\tcase 17:\n\t\tfunc(puzzle,1,2,0);\n\t\tbreak;\n\tcase 18:\n\t\tfunc(puzzle,0,1,1);\n\t\tbreak;\n\tcase 19:\n\t\tfunc(puzzle,0,0,1);\n\t\tbreak;\n\tcase 20:\n\t\tfunc(puzzle,0,1,2);\n\t\tbreak;\n\tcase 21:\n\t\tfunc(puzzle,0,2,1);\n\t\tbreak;\n\tcase 22:\n\t\tfunc(puzzle,0,1,0);\n\t\tbreak;\n\tcase 23:\n\t\tfunc(puzzle,0,0,0);\n\t\tbreak;\n\tcase 24:\n\t\tfunc(puzzle,0,0,2);\n\t\tbreak;\n\tcase 25:\n\t\tfunc(puzzle,0,2,2);\n\t\tbreak;\n\tcase 26:\n\t\tfunc(puzzle,0,2,0);\n\t\tbreak;\n\t}\n\n}\n\nvoid calc(){\n\n\tANS.clear();\n\n\tfor(int row = 0; row < 3; row++){\n\t\tfor(int col = 0; col < 3; col++)scanf(\"%d\",&top[row][col]);\n\t}\n\n\tfor(int row = 0; row < 3; row++){\n\t\tfor(int col = 0; col < 3; col++)scanf(\"%d\",&front[row][col]);\n\t}\n\n\tbool FLG;\n\n\tfor(int i = 0; i < V.size(); i++){\n\n\t\tFLG = true;\n\t\tfor(int row = 0; row < 3; row++){\n\t\t\tfor(int col = 0; col < 3; col++){\n\t\t\t\tif(top[row][col] != 0 && V[i].dice[2][row][col].getTop() != top[row][col]){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!FLG)break;\n\t\t}\n\t\tif(!FLG)continue;\n\n\t\tif((front[0][0] != 0 && V[i].dice[2][2][0].getSouth() != front[0][0]) ||\n\t\t\t\t(front[0][1] != 0 && V[i].dice[2][2][1].getSouth() != front[0][1]) ||\n\t\t\t\t(front[0][2] != 0 && V[i].dice[2][2][2].getSouth() != front[0][2]) ||\n\t\t\t\t(front[1][0] != 0 && V[i].dice[1][2][0].getSouth() != front[1][0]) ||\n\t\t\t\t(front[1][1] != 0 && V[i].dice[1][2][1].getSouth() != front[1][1]) ||\n\t\t\t\t(front[1][2] != 0 && V[i].dice[1][2][2].getSouth() != front[1][2]) ||\n\t\t\t\t(front[2][0] != 0 && V[i].dice[0][2][0].getSouth() != front[2][0]) ||\n\t\t\t\t(front[2][1] != 0 && V[i].dice[0][2][1].getSouth() != front[2][1]) ||\n\t\t\t\t(front[2][2] != 0 && V[i].dice[0][2][2].getSouth() != front[2][2])\n\t\t)continue;\n\n\t\tint sum = 0;\n\t\tfor(int h = 0; h <= 2; h++){\n\t\t\tfor(int row = 0; row <= 2; row++){\n\t\t\t\tsum += V[i].dice[h][row][2].getEast();\n\t\t\t}\n\t\t}\n\t\tANS.push_back(sum);\n\t}\n\n\tif(ANS.size() == 0){\n\t\tprintf(\"0\\n\");\n\t\treturn;\n\t}\n\n\tsort(ANS.begin(),ANS.end());\n\n\tprintf(\"%d\",ANS[0]);\n\tint pre = ANS[0];\n\n\tfor(int i = 1; i < ANS.size(); i++){\n\t\tif(ANS[i] != pre){\n\t\t\tprintf(\" %d\",ANS[i]);\n\t\t}\n\t\tpre = ANS[i];\n\t}\n\tprintf(\"\\n\");\n}\n\n\n\nint main(){\n\n\tPuzzle first;\n\tfirst.num = 0;\n\n\tfor(int a = 0; a < 3; a++){\n\t\tfor(int b = 0; b < 3; b++){\n\t\t\tfor(int c = 0; c < 3; c++)first.check[a][b][c] = false;\n\t\t}\n\t}\n\n\trecursive(first);\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tfor(int i = 0; i < N; i++)calc();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct dice{\n\tint val[6];\n\tvoid roti(){\n\t\tint t=val[5];\n\t\tval[5]=val[1];\n\t\tval[1]=val[4];\n\t\tval[4]=val[0];\n\t\tval[0]=t;\n\t}\n\tvoid rotj(){\n\t\tint t=val[3];\n\t\tval[3]=val[1];\n\t\tval[1]=val[2];\n\t\tval[2]=val[0];\n\t\tval[0]=t;\n\t}\n\tvoid rotk(){\n\t\tint t=val[3];\n\t\tval[3]=val[4];\n\t\tval[4]=val[2];\n\t\tval[2]=val[5];\n\t\tval[5]=t;\n\t}\n};\n\nint f[3][3],t[3][3];\ndice cube[3][3][3];\nint n;\nbool res[55];\n\nvoid rec(int cur){\n\tif(cur==27){\n\t\tint sum=0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\tsum+=cube[i][2][k].val[4];\n\t\t\t}\n\t\t}\n\t\tres[0]=false;\n\t\tres[sum]=true;\n\t\treturn;\n\t}\n\tint k=cur/9;\n\tint i=(cur/3)%3;\n\tint j=cur%3;\n\tdice d=(dice){2,5,6,1,3,4};\n\tfor(int r=0;r<24;r++){\n\t\td.rotk();\n\t\tif(r%4==0){\n\t\t\tif(r<16)d.rotj();\n\t\t\telse if(r==16)d.roti();\n\t\t\telse{\n\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\td.roti();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(k==0 && t[i][j] && t[i][j]!=d.val[0])continue;\n\t\tif(i==2 && f[k][j] && f[k][j]!=d.val[2])continue;\n\t\tif(i && cube[i-1][j][k].val[2]+d.val[3]!=7)continue;\n\t\tif(j && cube[i][j-1][k].val[4]+d.val[5]!=7)continue;\n\t\tif(k && cube[i][j][k-1].val[1]+d.val[0]!=7)continue;\n\t\tcube[i][j][k]=d;\n\t\trec(cur+1);\n\t}\n}\n\nvoid solve(){\n\tmemset(res,false,sizeof(res));\n\tres[0]=true;\n\trec(0);\n\tif(res[0])printf(\"0\\n\");\n\telse{\n\t\tbool c=false;\n\t\tfor(int i=1;i<=54;i++){\n\t\t\tif(res[i]){\n\t\t\t\tif(c)printf(\" \");\n\t\t\t\tc=true;\n\t\t\t\tprintf(\"%d\",i);\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<3;j++){\n\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\tscanf(\"%d\",&t[j][k]);\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\tscanf(\"%d\",&f[j][k]);\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<array>\n#include<set>\n#include<vector>\n\nusing namespace std;\n\ntypedef array<int,6> Dice;\nint TF[2][3][3];\nDice dice[24];\nDice puzzle[3][3][3];\nset<int> ans;\n\nvoid rot(Dice &d,vector<int> v){\n  auto t=d[v[0]];\n  d[v[0]]=d[v[1]];\n  d[v[1]]=d[v[2]];\n  d[v[2]]=d[v[3]];\n  d[v[3]]=t;\n}\n\nvoid dfs(int d){\n  if(d==27){\n    int s=0;\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\ts+=puzzle[i][j][2][2];\n      }\n    }\n    ans.insert(s);\n  }else{\n    int z=d/9,y=d/3%3,x=d%3;\n    for(auto e:dice){\n      if(z){\n\tif(puzzle[z-1][y][x][4]+e[1]!=7)continue;\n      }else{\n\tif(TF[1][y][x]&&TF[1][y][x]!=e[1])continue;\n      }\n      if(y){\n\tif(puzzle[z][y-1][x][5]+e[0]!=7)continue;\n      }else{\n\tif(TF[0][2-z][x]&&TF[0][2-z][x]!=e[0])continue;\n      }\n      if(x&&puzzle[z][y][x-1][2]+e[3]!=7)continue;\n      puzzle[z][y][x]=e;\n      dfs(d+1);\n    }\n  }\n}\n\nint main(){\n  Dice d{1,2,3,4,5,6};\n  for(int i=0;i<6;i++){\n    if(i%2){\n      rot(d,{0,1,5,4});\n    }else{\n      rot(d,{0,2,5,3});\n    }\n    for(int j=0;j<4;j++){\n      rot(d,{1,2,4,3});\n      dice[i*4+j]=d;\n    }\n  }\n  int N;\n  cin>>N;\n  while(N--){\n    for(int i=0;i<2;i++){\n      for(int j=0;j<3;j++){\n\tfor(int k=0;k<3;k++){\n\t  cin>>TF[i][j][k];\n\t}\n      }\n    }\n    ans.clear();\n    dfs(0);\n    if(ans.empty()){\n      cout<<0<<endl;\n    }else{\n      bool f=false;\n      for(auto e:ans){\n\tif(f++){\n\t  cout<<' ';\n\t}\n\tcout<<e;\n      }\n      cout<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\nusing namespace std;\n\nenum FACE {TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT };\n\nclass Dice\n{\npublic:\n\tint id[6];\n\tDice() {\n\t\tid[TOP] = 0; id[FRONT] = 1; id[LEFT] = 2;\n\t\tid[RIGHT] = 3; id[BACK] = 4; id[BOTTOM] = 5;\n\t}\n\n\tvoid roll_x() { roll(TOP, BACK, BOTTOM, FRONT); }\n\tvoid roll_y() { roll(TOP, LEFT, BOTTOM, RIGHT); }\n\tvoid roll_z() { roll(FRONT, RIGHT, BACK, LEFT); }\n\n\tvoid roll(FACE a, FACE b, FACE c, FACE d) {\n\t\tint tmp = id[a];\n\t\tid[a] = id[b];\n\t\tid[b] = id[c];\n\t\tid[c] = id[d];\n\t\tid[d] = tmp;\n\t}\n};\n\nDice field[3][3][3]; //x,y,z\n\nint t_tbl[3][3];\nint f_tbl[3][3];\nset<int> ans;\n\nvoid dfs(int x, int y, int z, int r)\n{\n\tif(z == 3) {\n\t\tans.insert(r);\n\t\treturn;\n\t}\n\n\tDice& d = field[x][y][z];\n\tfor(int k=0; k<6; (k&1?d.roll_y():d.roll_x()), k++)\n\tfor(int i=0; i<4; d.roll_z(), i++) {\n\t\tif(y == 0 && f_tbl[x][z]) {\n\t\t\tif(d.id[FRONT] + 1 != f_tbl[x][z]) continue;\n\t\t}\n\t\tif(z == 0 && t_tbl[x][y]) {\n\t\t\tif(d.id[TOP] + 1 != t_tbl[x][y]) continue;\n\t\t}\n\n\t\tif(x != 0) {\n\t\t\tif(field[x-1][y][z].id[RIGHT] + field[x][y][z].id[LEFT] + 2 != 7) continue;\n\t\t}\n\n\t\tif(y != 0) {\n\t\t\tif(field[x][y-1][z].id[BACK] + field[x][y][z].id[FRONT] + 2 != 7) continue;\n\t\t}\n\n\t\tif(z != 0) {\n\t\t\tif(field[x][y][z-1].id[BOTTOM] + field[x][y][z].id[TOP] + 2 != 7) continue;\n\t\t}\n\n\t\tint nx = x + 1, ny = y, nz = z;\n\t\tif(nx == 3) { nx = 0; ny += 1; };\n\t\tif(ny == 3) { ny = 0; nz += 1; };\n\n\t\tint nr = r;\n\t\tif(x == 0) nr += field[x][y][z].id[LEFT] + 1;\n\t\tdfs(nx, ny, nz, nr);\n\t}\n}\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\twhile(N--) {\n\t\tans.clear();\n\n\t\tfor(int i=0; i<3; i++)\n\t\tfor(int j=0; j<3; j++)\n\t\t\tcin >> t_tbl[j][i];\n\n\t\tfor(int i=0; i<3; i++)\n\t\tfor(int j=0; j<3; j++)\n\t\t\tcin >> f_tbl[j][i];\n\n\t\tdfs(0, 0, 0, 0);\n\n\t\tfor(set<int>::iterator it = ans.begin(); it != ans.end(); ++it) {\n\t\t\tif( it != ans.begin() ) cout << \" \";\n\t\t\tcout << *it;\n\t\t}\n\n\t\tif(ans.size() == 0) cout << 0;\n\n\t\tcout << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <climits>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef long long ll;\n\nstruct Dice{\nprivate:\n\tstatic const int _roll[4][6], _turn[2][6];\npublic:\n\tvector<int> value;\n\t//enum pos{ top, near, right, left, far, bottom };\n\n\tDice(){\n\t\tvalue.resize(6);\n\t\tfor (int i = 0; i < 6; ++i) value[i] = i;\n\t}\n\tDice(initializer_list<int> il){\n\t\tvalue.resize(6, -1);\n\t\tint cnt = 0;\n\t\tfor (auto &e : il){\n\t\t\tvalue[cnt++] = e;\n\t\t\tif (cnt >= 6) break;\n\t\t}\n\t\tfor (int i = 0; i < 6; ++i) if (value[i] < 0) value[i] = 5 - value[5 - i];\n\t}\n\n\tint top()const{ return value[0]; }\n\tint near()const{ return value[1]; }\n\tint right()const{ return value[2]; }\n\tint left()const{ return value[3]; }\n\tint far()const{ return value[4]; }\n\tint bottom()const{ return value[5]; }\n\n\tvoid roll(int dir){ // N, E, W, S\n\t\tvector<int> nxt(6);\n\t\tfor (int i = 0; i < 6; ++i){\n\t\t\tnxt[i] = value[_roll[dir][i]];\n\t\t}\n\t\tvalue = nxt;\n\t}\n\n\tvoid turn(int dir){ // L, R\n\t\tvector<int> nxt(6);\n\t\tfor (int i = 0; i < 6; ++i){\n\t\t\tnxt[i] = value[_turn[dir][i]];\n\t\t}\n\t\tvalue = nxt;\n\t}\n\n\tint &operator[](int i){\n\t\treturn value[i];\n\t}\n\tbool operator < (const Dice &rhs) const{\n\t\treturn value < rhs.value;\n\t}\n};\n\nostream& operator<<(ostream& os, const Dice &d){\n\tos << '{';\n\tfor (int i = 0; i < (int)d.value.size(); ++i) os << (i ? \", \" : \"\") << d.value[i];\n\tos << '}';\n\treturn os;\n}\n\n\nconst int Dice::_roll[4][6] = {\n\t{ 1, 5, 2, 3, 0, 4 }, // North\n\t{ 3, 1, 0, 5, 4, 2 }, // East\n\t{ 2, 1, 5, 0, 4, 3 }, // West\n\t{ 4, 0, 2, 3, 5, 1 }, // South\n};\n\nconst int Dice::_turn[2][6] = {\n\t{ 0, 3, 1, 4, 2, 5 }, // Left\n\t{ 0, 2, 4, 1, 3, 5 }, // Right\n};\n\nset<Dice> valid_set;\n\nvoid make_valid_set(){\n\trep(k, 3) rep(i, 4){\n\t\tDice d;\n\t\trep(j, k) d.roll(i);\n\t\trep(j, 4){\n\t\t\td.turn(0);\n\t\t\tvalid_set.insert(d);\n\t\t}\n\t}\n}\n\nmap<vector<int>, vector<vector<int>>> m;\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tmake_valid_set();\n\n\tvector<vector<Dice>> top(6), left(6);\n\tvector<vector<vector<Dice>>> left_top(6, vector<vector<Dice>>(6));\n\tfor (auto d : valid_set){\n\t\ttop[d.top()].push_back(d);\n\t\tleft[d.left()].push_back(d);\n\t\tleft_top[d.left()][d.top()].push_back(d);\n\t}\n\n\tfor (auto &d0 : valid_set){\n\t\t/*\n\t\t0 1 2\n\t\t3 x x\n\t\t4 x x\n\t\t*/\n\t\tfor (auto &d1 : left[d0.left()]){\n\t\t\tfor (auto &d2 : left[d0.left()]){\n\t\t\t\tfor (auto &d3 : top[d0.top()]){\n\t\t\t\t\tfor (auto &d4 : top[d0.top()]){\n\t\t\t\t\t\t// 5-8\n\t\t\t\t\t\tif (left_top[d3.left()][d1.top()].empty()) continue;\n\t\t\t\t\t\tauto &d5 = left_top[d3.left()][d1.top()][0];\n\t\t\t\t\t\tif (left_top[d3.left()][d2.top()].empty()) continue;\n\t\t\t\t\t\tauto &d6 = left_top[d3.left()][d2.top()][0];\n\t\t\t\t\t\tif (left_top[d4.left()][d1.top()].empty()) continue;\n\t\t\t\t\t\tauto &d7 = left_top[d4.left()][d1.top()][0];\n\t\t\t\t\t\tif (left_top[d4.left()][d2.top()].empty()) continue;\n\t\t\t\t\t\tauto &d8 = left_top[d4.left()][d2.top()][0];\n\n\t\t\t\t\t\tvector<int> tmp = { d0.near(), d1.near(), d2.near(), d3.near(), d4.near(), d5.near(), d6.near(), d7.near(), d8.near() };\n\t\t\t\t\t\tauto &con = m[tmp];\n\t\t\t\t\t\tcon.push_back({ d2.top(), d1.top(), d0.top(), d0.left(), d3.left(), d4.left() });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint n;\n\tcin >> n;\n\twhile (n--){\n\t\tvector<vector<int>> tl(3, vector<int>(6));\n\t\trep(i, 6) rep(j, 3) cin >> tl[2 - j][i];\n\t\trep(i, 6) rep(j, 3) --tl[2 - j][i];\n\n\t\tset<int> ans;\n\t\tfor (auto &x : m){\n\t\t\tauto &v = x.second;\n\t\t\tfor (auto &a : v){\n\t\t\t\trep(i, 6) if (tl[0][i] >= 0 && tl[0][i] != a[i]) goto NGA;\n\t\t\t\tfor (auto &b : v){\n\t\t\t\t\trep(i, 6) if (tl[1][i] >= 0 && tl[1][i] != b[i]) goto NGB;\n\t\t\t\t\tfor (auto &c : v){\n\t\t\t\t\t\trep(i, 6) if (tl[2][i] >= 0 && tl[2][i] != c[i]) goto NGC;\n\t\t\t\t\t\tgoto OK;\n\t\t\t\t\tNGC:;\n\t\t\t\t\t}\n\t\t\t\tNGB:;\n\t\t\t\t}\n\t\t\tNGA:;\n\t\t\t}\n\t\t\tcontinue;\n\t\tOK:\n\t\t\tans.insert(accumulate(ALL(x.first), 0) + 9);\n\t\t}\n\n\t\tbool f = true;\n\t\tfor (auto a : ans){\n\t\t\tcout << (f ? \"\" : \" \") << a;\n\t\t\tf = false;\n\t\t}\n\t\tif (ans.empty()) cout << 0;\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unordered_map>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n/* -----  2018/06/20  Problem: AOJ 2703 / Link: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2703  ----- */\n/* ------問題------\n\n\n\n-----問題ここまで----- */\n/* -----解説等-----\n\n\n\n----解説ここまで---- */\n\n\nusing uLL = unsigned long long;\n\nconst uLL MOD = 1e9;\n//BEGIN CUT HERE\nstruct Dice {\n\tint s[6];\n\tvoid roll(char c) {\n\t\t//the view from above\n\t\t// N\n\t\t//W E\n\t\t// S\n\t\t//s[0]:top\n\t\t//s[1]:south\n\t\t//s[2]:east\n\t\t//s[3]:west\n\t\t//s[4]:north\n\t\t//s[5]:bottom\n\t\tint b;\n\t\tif (c == 'E') {\n\t\t\tb = s[0];\n\t\t\ts[0] = s[3];\n\t\t\ts[3] = s[5];\n\t\t\ts[5] = s[2];\n\t\t\ts[2] = b;\n\t\t}\n\t\tif (c == 'W') {\n\t\t\tb = s[0];\n\t\t\ts[0] = s[2];\n\t\t\ts[2] = s[5];\n\t\t\ts[5] = s[3];\n\t\t\ts[3] = b;\n\t\t}\n\t\tif (c == 'N') {\n\t\t\tb = s[0];\n\t\t\ts[0] = s[1];\n\t\t\ts[1] = s[5];\n\t\t\ts[5] = s[4];\n\t\t\ts[4] = b;\n\t\t}\n\t\tif (c == 'S') {\n\t\t\tb = s[0];\n\t\t\ts[0] = s[4];\n\t\t\ts[4] = s[5];\n\t\t\ts[5] = s[1];\n\t\t\ts[1] = b;\n\t\t}\n\n\t\t// migi neji \n\t\tif (c == 'R') {\n\t\t\tb = s[1];\n\t\t\ts[1] = s[2];\n\t\t\ts[2] = s[4];\n\t\t\ts[4] = s[3];\n\t\t\ts[3] = b;\n\t\t}\n\n\t\tif (c == 'L') {\n\t\t\tb = s[1];\n\t\t\ts[1] = s[3];\n\t\t\ts[3] = s[4];\n\t\t\ts[4] = s[2];\n\t\t\ts[2] = b;\n\t\t}\n\n\t}\n\tint top() {\n\t\treturn s[0];\n\t}\n\tint bottom() {\n\t\treturn s[5];\n\t}\n\tuLL hash() {\n\t\tuLL res = 1;\n\t\tfor (int i = 0; i < 6; i++) res = res * (MOD)+s[i];\n\t\treturn res;\n\t}\n\tvoid print() {\n\t\tcout << \"Dice num: \";\n\t\tFOR(i, 0, 6) {\n\t\t\tcout << s[i] << \" \";\n\t\t}\n\t\tcout << \"Hash: \" << this->hash() << endl;\n\t\tcout << endl;\n\t}\n};\nvector<Dice> makeDices(Dice d) {\n\tvector<Dice> res;\n\tfor (int i = 0; i < 6; i++) {\n\t\tDice t(d);\n\t\tif (i == 1) t.roll('N');\n\t\tif (i == 2) t.roll('S');\n\t\tif (i == 3) t.roll('S'), t.roll('S');\n\t\tif (i == 4) t.roll('L');\n\t\tif (i == 5) t.roll('R');\n\t\tfor (int k = 0; k < 4; k++) {\n\t\t\tres.push_back(t);\n\t\t\tt.roll('E');\n\t\t}\n\t}\n\treturn res;\n}\n//END CUT HERE\n\nvoid solve_AOJ_ITP1_11_A() {\n\tint N = 6;\n\tDice D;\n\tFOR(i, 0, N) {\n\t\tint val; cin >> val;\n\t\tD.s[i] = val;\n\t}\n\tstring s; cin >> s;\n\tFOR(i, 0, SZ(s)) {\n\t\tD.roll(s[i]);\n\t}\n\tcout << D.top() << endl;\n}\n\nvoid solve_AOJ_ITP1_11_B() {\n\tDice D;\n\tint N = 6;\n\tFOR(i, 0, N) {\n\t\tint val; cin >> val;\n\t\tD.s[i] = val;\n\t}\n\tvector<Dice> dices = makeDices(D);\n\tint Q; cin >> Q;\n\tFOR(i, 0, Q) {\n\t\tint TOP, FRONT;\n\t\tcin >> TOP >> FRONT;\n\t\tFOR(i, 0, SZ(dices)) { //24個\n\t\t\tif (dices[i].top() == TOP && dices[i].s[1] == FRONT) {\n\t\t\t\tcout << dices[i].s[2] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve_AOJ_ITP1_11_C() {\n\tDice d[2];\n\tFOR(k, 0, 2) {\n\t\tFOR(i, 0, 6) {\n\t\t\tint val; cin >> val;\n\t\t\td[k].s[i] = val;\n\t\t}\n\t}\n\tuLL hashval = d[0].hash();\n\tvector<Dice>dices = makeDices(d[1]);\n\tFOR(i, 0, SZ(dices)) {\n\t\tif (hashval == dices[i].hash()) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tcout << \"No\" << endl;\n}\nvoid solve_AOJ_ITP1_11_D() {\n\tint N; cin >> N;\n\tvector<Dice>d(N);\n\tFOR(k, 0, N) {\n\t\tFOR(i, 0, 6) {\n\t\t\tint val; cin >> val;\n\t\t\td[k].s[i] = val;\n\t\t}\n\t}\n\tset<uLL>Se;\n\tSe.insert(d[0].hash());\n\tFOR(i, 1, N) {\n\t\tvector<Dice>dices = makeDices(d[i]);\n\t\tint flag = 0;\n\t\tFOR(j, 0, SZ(dices)) {\n\t\t\tflag |= (Se.count(dices[j].hash()));\n\t\t}\n\t\tif (flag) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn;\n\t\t}\n\t\tSe.insert(dices[i].hash());\n\n\t}\n\tcout << \"Yes\" << endl;\n}\n\nvoid solve_AOJ_0502() {\n\tint Q;\n\twhile (cin >> Q, Q) {\n\t\tDice d; FOR(i, 0, 6)d.s[i] = i + 1;\n\t\tint ans = 1;\n\t\tFOR(kim, 0, Q) {\n\t\t\tstring s; cin >> s;\n\t\t\td.roll(s[0]);\n\t\t\tans += d.top();\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\n}\n\nusing PII = pair<int, int>;\nmap<char, char>changeC;\ninline  int  mhash(const PII &a) {\n\treturn (a.first + 1200) * 2400 + a.second + 1200;\n}\nvoid solve_AOJ_2703() {\n\tconst string ORIG = \"EWNS\";\n\tconst string TO = \"RLBF\";\n\tFOR(i, 0, 4) {\n\t\tchangeC[TO[i]] = ORIG[i];\n\t}\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<map<PII, int>>Map(N);\n\t\tint x, y;\n\t\tDice dice;\n\t\tFOR(i, 0, N) {\n\t\t\tcin >> x >> y;\n\t\t\tcin >> dice.s[3] >> dice.s[2] >> dice.s[1] >> dice.s[4] >> dice.s[5] >> dice.s[0];\n\t\t\tstring s; cin >> s;\n\t\t\tMap[i][PII(y, x)] = dice.bottom();\n\t\t\tFOR(j, 0, SZ(s)) {\n\t\t\t\tdice.roll(changeC[s[j]]);\n\t\t\t\t// R,L,B,F\n\t\t\t\tif (s[j] == 'R')x++;\n\t\t\t\tif (s[j] == 'L')x--;\n\t\t\t\tif (s[j] == 'B')y++;\n\t\t\t\tif (s[j] == 'F')y--;\n\t\t\t\t// y x の移動\n\t\t\t\tMap[i][PII(y, x)] = dice.bottom();\n\t\t\t}\n\t\t}\n\n\t\tvector<int>bitdp(1 << N, 0);\n\t\tFOR(state, 0, 1 << N) {\n\t\t\tunordered_map<int, bool>used; // orderedだと結構遅かった\n\t\t\tFOR(i, 0, N) {\n\t\t\t\tif (state & 1 << i) {\n\t\t\t\t\tfor (auto it : Map[i]) {\n\t\t\t\t\t\tused[mhash(it.first)] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 記録した\n\t\t\tFOR(i, 0, N) {\n\t\t\t\tif (state & 1 << i)continue;\n\t\t\t\tint addv = 0;\n\n\t\t\t\tfor (auto it : Map[i]) {\n\t\t\t\t\tif (!used.count(mhash(it.first))) {\n\t\t\t\t\t\taddv += it.second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbitdp[state | (1 << i)] = max(bitdp[state | (1 << i)], bitdp[state] + addv);\n\t\t\t}\n\t\t}\n\t\tcout << bitdp[(1 << N) - 1] << endl;\n\n\t}\n}\n\nvoid solve_AOJ_1181() {\n\tint N;\n\tDice BaseDi;\n\tFOR(i, 0, 6)BaseDi.s[i] = i + 1;\n\tvector<Dice>dices = makeDices(BaseDi);\n\twhile (cin >> N, N) {\n\t\tVVI masu(210, VI(210, 0));\n\t\tvector<VVI>valset(210, VVI(210, VI()));\n\t\tFOR(okaduki, 0, N) {\n\t\t\tint tp, fr; cin >> tp >> fr;\n\t\t\tint X = 100, Y = 100;\n\t\t\tDice d;\n\t\t\tFOR(i, 0, SZ(dices)) {\n\t\t\t\tif (dices[i].top() == tp&&dices[i].s[1] == fr) {\n\t\t\t\t\td = dices[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (1) {\n\t\t\t\tmasu[Y][X]++;\n\t\t\t\t// 落ちる方向を決める\n\t\t\t\t// 大きな方に転がり落ちる\n\t\t\t\tint dy[] = { -1, 1, 0, 0, -1, };\n\t\t\t\tint dx[] = { -1, 0, 1, -1, 0, };\n\t\t\t\tint dir = -1;\n\t\t\t\tFOR(num, 4, 6 + 1) {\n\t\t\t\t\tif (d.top() != num && d.bottom() != num) { //面があれ\n\t\t\t\t\t\tFOR(i, 1, 4 + 1) {\n\t\t\t\t\t\t\tif (d.s[i] == num) {\n\t\t\t\t\t\t\t\tif (masu[Y][X] > masu[Y + dy[i]][X + dx[i]] + 1) {\n\t\t\t\t\t\t\t\t\tdir = i;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dir == -1) {\n\t\t\t\t\tvalset[Y][X].push_back(d.top());\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmasu[Y][X]--;\n\t\t\t\tstring TO = \"$SEWN\";\n\t\t\t\tY += dy[dir]; X += dx[dir];\n\t\t\t\td.roll(TO[dir]);\n\t\t\t}\n\t\t}\n\t\tVI a(7, 0);\n\t\tFOR(i, 0, 210) {\n\t\t\tFOR(j, 0, 210) {\n\t\t\t\tif (!SZ(valset[i][j]))continue;\n\t\t\t\tint val = valset[i][j].back();\n\t\t\t\ta[val]++;\n\t\t\t}\n\t\t}\n\t\tFOR(i, 1, 6 + 1) {\n\t\t\tcout << a[i] << \" \\n\"[i == 6];\n\t\t}\n\n\t}\n\n}\n\nvector<Dice>dices;\nint tops[3][3], fronts[3][3];\nvector<int> ans;\nDice putdice[3][3][3];\nvoid dfs(int state) {\n\tif (state == 27) {\n\t\tint ret = 0;\n\t\tFOR(i, 0, 3) {// 右の右をとる s[2]\n\t\t\tFOR(j, 0, 3) {\n\t\t\t\tret += putdice[i][2][j].s[2];\n\t\t\t}\n\t\t}\n\n\t\tans.push_back(ret);\n\t}\n\telse {\n\t\tint X = (state / 3) % 3;\n\t\tint Y = state % 3;\n\t\tint Z = state / 9;\n\t\tFOR(i, 0, 24) { // put dices to putdice\n\t\t\t// ダメなもの top .front がちゃう\n\t\t\tif (Z == 0 && tops[X][Y] && tops[X][Y] != dices[i].top())continue;\n\t\t\tif (X == 2 && fronts[Z][Y] && fronts[Z][Y] != dices[i].s[1])continue;\n\t\t\t// ダメなもの 7じゃない\n\t\t\tif (X&& putdice[X - 1][Y][Z].s[4] + dices[i].s[1] != 7)continue; // 奥\n\t\t\tif (Y&& putdice[X][Y - 1][Z].s[2] + dices[i].s[3] != 7)continue; // 左\n\t\t\tif (Z&& putdice[X][Y][Z - 1].s[5] + dices[i].s[0] != 7)continue; // 上\n\n\t\t\tputdice[X][Y][Z] = dices[i];\n\t\t\tdfs(state + 1);\n\t\t}\n\n\n\t}\n\n}\n\n\n// 24^27なきもちになるけど前処理すればだいたい決まるので解析しなくても投げる気持ちが固まる\n// パラメータの管理壊れる\nvoid solve_AOJ_1253() {\n\tDice Base;\n\tFOR(i, 0, 6)Base.s[i] = i + 1;\n\tdices = makeDices(Base);\n\n\tint Case; cin >> Case;\n\tFOR(kyo, 0, Case) {\n\t\tFOR(i, 0, 3)FOR(j, 0, 3)cin >> tops[i][j];\n\t\tFOR(i, 0, 3)FOR(j, 0, 3)cin >> fronts[i][j];\n\t\tdfs(0);\n\t\tSORT(ans); UNIQ(ans);\n\t\tFOR(i, 0, SZ(ans)) {\n\t\t\tcout << ans[i] << \" \\n\"[i == SZ(ans) - 1];\n\t\t}\n\t\tif (SZ(ans) == 0)cout << 0 << endl;\n\t\tans.clear();\n\t}\n\n\n\n\n}\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\t//solve_AOJ_ITP1_11_A();\n\t//solve_AOJ_ITP1_11_B();\n\t//solve_AOJ_ITP1_11_C();\n\t//solve_AOJ_ITP1_11_D();\n\t//solve_AOJ_0502();\n\n\t//solve_AOJ_1181();\n\t//solve_AOJ_2703();\n\tsolve_AOJ_1253();\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nclass Dice{\nprivate:\n    void roll(int a,int b,int c,int d){\n        swap(x[a],x[b]);\n        swap(x[b],x[d]);\n        swap(x[c],x[d]);\n    }\npublic:\n    int x[6];\n    Dice(){\n        for(int i = 0 ; i < 6 ; i++){\n            x[i] = i+1;\n        }\n    }\n    void roll_N(){ roll(0,1,4,5); }\n    void roll_E(){ roll(0,3,2,5); }\n    void rotation(){ roll(1,2,3,4); }\n    void roll(int top,int front){\n        for(int i = 0 ; i < 2 ; i++){\n            for(int j = 0 ; j < 4 ; j++){\n                roll_N();\n                if(top == x[0]) goto next;\n            }\n            roll_E();\n        }\n    next:\n        for(int i = 0 ; i < 4 ; i++){\n            rotation();\n            if(front == x[1]) break; \n        }\n    }\n    void clear(){ memset(x,0,sizeof(x)); }  \n}; \n \nbool can[60];\nDice d[3][3][3],d2[7][7];\nint bit[27];\n \nint calc(){\n    int sum = 0;\n    for(int i = 0 ; i < 3 ; i++){\n        for(int j = 0 ; j < 3 ; j++){\n            sum += d[i][j][2].x[2];\n        }\n    }\n    return sum;\n}\n \nbool check(int v){\n    int a = v/9, b = (v%9)/3, c = (v%9)%3;\n    int top = d[a][b][c].x[0],front = d[a][b][c].x[1];\n    for(int i = 0 ; i < 6 ; i++){\n        if(d[a][b][c].x[i] != d2[top][front].x[i]){\n            return false;\n        }\n    }\n    return true;\n}\n \nvoid solve(int v,int p,int S){\n    if(v == 27){\n        can[calc()] = 1;\n        return;\n    }\n    if(p == 6){\n        if(!check(v)) return;\n        if(S == (1<<7)-1){\n            solve(v+1,0,bit[v+1]);\n        }\n        return;\n    }\n    int a = v/9, b = (v%9)/3, c = (v%9)%3;\n    if(a-1 >= 0 && p == 0){\n        if(d[a][b][c].x[p] == 0){\n            int x = 7 - d[a-1][b][c].x[5];\n            if(S >> x & 1) return;\n            d[a][b][c].x[p] = x;\n            int x2 = d[a][b][c].x[5-p];\n            if(x2 == 0 || x + x2 == 7){\n                solve(v,p+1,S|(1<<x));\n            }\n            d[a][b][c].x[p] = 0;\n        }else{\n            if(d[a][b][c].x[p] + d[a-1][b][c].x[5] == 7){\n                solve(v,p+1,S);\n            }\n        }\n        return;\n    }\n    if(b-1 >= 0 && p == 4){\n        if(d[a][b][c].x[p] == 0){\n            int x = 7 - d[a][b-1][c].x[1];\n            if(S >> x & 1) return;\n            d[a][b][c].x[p] = x;\n            int x2 = d[a][b][c].x[5-p];\n            if(x2 == 0 || x + x2 == 7){\n                solve(v,p+1,S|(1<<x));\n            }\n            d[a][b][c].x[p] = 0;\n        }else{\n            if(d[a][b][c].x[p] + d[a][b-1][c].x[1] == 7){\n                solve(v,p+1,S);     \n            }\n        }\n        return;\n    }\n    if(c-1 >= 0 && p == 3){\n        if(d[a][b][c].x[p] == 0){\n            int x = 7 - d[a][b][c-1].x[2];\n            if(S >> x & 1) return;\n            d[a][b][c].x[p] = x;\n            int x2 = d[a][b][c].x[5-p];\n            if(x2 == 0 || x + x2 == 7){\n                solve(v,p+1,S|(1<<x));\n            }\n            d[a][b][c].x[p] = 0;\n        }else{\n            if(d[a][b][c].x[p] + d[a][b][c-1].x[2] == 7){\n                solve(v,p+1,S);\n            }\n        }\n        return;\n    }\n     \n    if(d[a][b][c].x[p] == 0){\n        if(d[a][b][c].x[5-p] != 0){\n            int x = 7 - d[a][b][c].x[5-p];\n            if(S >> x & 1) return;\n            d[a][b][c].x[p] = x;\n            solve(v,p+1,S|(1<<x));\n            d[a][b][c].x[p] = 0;\n        }else{\n            for(int i = 0 ; i < 6 ; i++){\n                d[a][b][c].x[p] = i+1;\n                int x = d[a][b][c].x[5-p];\n                if(!(S >> (i+1) & 1) &&\n                   (x == 0 || x + d[a][b][c].x[p] == 7)){\n                    solve(v,p+1,S|(1<<(i+1)));\n                }\n                d[a][b][c].x[p] = 0;\n            }\n        }\n    }else{\n        int x = d[a][b][c].x[5-p];\n        if(x + d[a][b][c].x[p] == 7){\n            solve(v,p+1,S);\n        }\n    }\n}\n \nvoid print(){\n    bool sp = false;\n    for(int i = 0 ; i < 60 ; i++){\n        if(can[i]){\n            if(sp) cout << \" \";\n            sp = true;\n            cout << i;\n        }\n    }\n    if(!sp) cout << 0;\n    cout << endl;\n}\n \nvoid init(){\n    fill(bit,bit+27,1);\n    memset(can,0,sizeof(can));\n    for(int i = 0 ; i < 3 ; i++){\n        for(int j = 0 ; j < 3 ; j++){\n            for(int k = 0 ; k < 3 ; k++){\n                d[i][j][k].clear();\n            }\n        }\n    }\n     \n    Dice dice;\n    for(int i = 1 ; i <= 6 ; i++){\n        for(int j = 1 ; j <= 6 ; j++){\n            if(i == j) continue;\n            dice.roll(i,j);\n            d2[i][j] = dice;        \n        }\n    }\n}\n \nint main(){\n    int N;\n    cin >> N;\n    while(N--){\n        init();\n        int in;\n        for(int i = 0 ; i < 3 ; i++){\n            for(int j = 0 ; j < 3 ; j++){\n                cin >> in;\n                if(in != 0){\n                    d[0][i][j].x[0] = in;\n                    d[0][i][j].x[5] = 7-in;\n                    bit[3*i+j] |= 1<<in;\n                    bit[3*i+j] |= 1<<(7-in);\n                }\n            }\n        }\n        for(int i = 0 ; i < 3 ; i++){\n            for(int j = 0 ; j < 3 ; j++){\n                cin >> in;\n                if(in != 0){\n                    d[i][2][j].x[1] = in;\n                    d[i][2][j].x[4] = 7-in;\n                    bit[9*i+6+j] |= 1<<in;\n                    bit[9*i+6+j] |= 1<<(7-in);\n                }\n            }\n        }\n        solve(0,0,bit[0]);\n        print();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n\n#define pb         push_back\n\n#define rotate_swap(x,a,b,c,d) swap(x.a,x.b);swap(x.b,x.c);swap(x.c,x.d);\n\nclass Dice{\npublic:\n  int top,front,right,left,back,bottom;\n};\n\nvoid rotate_r(Dice &x){\n  rotate_swap(x,top,left,bottom,right);\n}\n\nvoid rotate_l(Dice &x){\n  rotate_swap(x,top,right,bottom,left);\n}\n\nvoid rotate_f(Dice &x){\n  rotate_swap(x,top,back,bottom,front);\n}\n\nvoid rotate_cw(Dice &x){\n  rotate_swap(x,back,left,front,right);\n}\n\nvoid rotate_ccw(Dice &x){\n  rotate_swap(x,back,right,front,left);\n}\n\nDice data[24];\n\nvoid generate_all(Dice x){\n  rep(i,6){\n    rep(j,4){\n      data[i*4+j]=x;\n      rotate_cw(x);\n    }\n    if (i%2 == 0)rotate_r(x);\n    else rotate_f(x);\n  }\n}\n\n\nDice ini[3][3][3];\nDice now[3][3][3];\nint dx[]={-1, 0,0};\nint dy[]={ 0,-1,0};\nint dz[]={ 0, 0,-1};\n\nbool isok(int index,int z,int y,int x){\n  if (y == 0){//top\n    if (ini[z][y][x].top ==0 ||\n\tini[z][y][x].top == now[z][y][x].top);\n    else return false;\n  }else {\n    if (now[z][y-1][x].bottom+now[z][y][x].top != 7)return false;\n  }\n\n  \n\n  if (z == 0){//front\n    if (ini[z][y][x].front ==0||\n\tini[z][y][x].front == now[z][y][x].front);\n    else return false;\n  }else {\n    if (now[z-1][y][x].back+now[z][y][x].front != 7)return false;\n  }\n  \n  if (x == 0){\n  }else {\n    if (now[z][y][x-1].right+now[z][y][x].left != 7)return false;\n  }\n  return true;\n}\n\nint compute_sum(){\n  int sum=0;\n  rep(i,3){\n    rep(j,3){\n      sum+=now[i][j][2].right;\n    }\n  }\n  return sum;\n}\n\nvoid search(int level,int cur,vector<int>&ans){\n  if (level == 3){\n    ans.pb(compute_sum());\n    return;\n  }\n\n\n  if (cur == 9){\n    search(level+1,0,ans);\n    return;\n  }\n  int y=cur/3,x=cur%3;\n\n  rep(i,24){\n    now[level][y][x]=data[i];\n    if (isok(i,level,y,x)){\n      search(level,cur+1,ans);\n    }\n    now[level][y][x]=ini[level][y][x];\n  }\n}\n\n\nmain(){\n  Dice a=(Dice){1,2,3,4,5,6};\n  generate_all(a);\n  rep(i,3){\n    rep(j,3){\n      rep(k,3){\n\tini[i][j][k]=(Dice){0,0,0,0,0,0};\n      }\n    }\n  }\n\n  int te;\n  cin>>te;\n  while(te--){\n    vector<int> ans;\n    rep(i,3){\n      rep(j,3){\n\tcin>>ini[i][0][j].top;\n      }\n    }\n    rep(i,3){\n      rep(j,3){\n\tcin>>ini[0][i][j].front;\n      }\n    }\n\n    search(0,0,ans);\n    sort(ALL(ans));\n    ans.erase(unique(ALL(ans)),ans.end());\n    if (ans.size()== 0){\n      cout <<0<<endl;\n    }else {\n      rep(i,ans.size()){\n\tif (i)cout <<' ';\n\tcout << ans[i];\n      }\n      cout << endl;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<set>\nusing namespace std;\nint b[4][4];\nint c[4][4];\nint t[30][7];\nset<int>S;\nint sz=24;\nint pat[24][6]={\n{1,2,3,4,5,6},\n{1,3,5,2,4,6},\n{1,4,2,5,3,6},\n{1,5,4,3,2,6},\n{2,6,3,4,1,5},\n{2,3,1,6,4,5},\n{2,1,4,3,6,5},\n{2,4,6,1,3,5},\n{3,1,2,5,6,4},\n{3,2,6,1,5,4},\n{3,6,5,2,1,4},\n{3,5,1,6,2,4},\n{4,2,1,6,5,3},\n{4,1,5,2,6,3},\n{4,5,6,1,2,3},\n{4,6,2,5,1,3},\n{5,1,3,4,6,2},\n{5,3,6,1,4,2},\n{5,6,4,3,1,2},\n{5,4,1,6,3,2},\n{6,4,5,2,3,1},\n{6,2,4,3,5,1},\n{6,3,2,5,4,1},\n{6,5,3,4,2,1}\n};\nvoid solve(int a){\n\tif(a==27){\n\t\tint ret=0;\n\t\tfor(int i=0;i<9;i++){\n\t\t\tret+=t[i*3+2][2];\n\t\t}\n\t\tS.insert(ret);return;\n\t}\n\tfor(int i=0;i<sz;i++){\n\t\tif(a<9&&b[2-a/3][a%3]&&b[2-a/3][a%3]!=pat[i][0])continue;\n\t\tif(a%9/3==0&&c[a/9][a%3]&&c[a/9][a%3]!=pat[i][1])continue;\n\t\tif(a%3&&pat[i][3]+t[a-1][2]!=7)continue;\n\t\tif(a%9/3&&pat[i][1]+t[a-3][4]!=7)continue;\n\t\tif(a/9&&pat[i][0]+t[a-9][5]!=7)continue;\n\t\tfor(int j=0;j<6;j++)t[a][j]=pat[i][j];\n\t\tsolve(a+1);\n\t}\n}\nint perm[6];\nint main(){\n\tint T;scanf(\"%d\",&T);\n\n\twhile(T--){\n\t\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)scanf(\"%d\",&b[i][j]);\n\t\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)scanf(\"%d\",&c[i][j]);\n\t\tS.clear();\n\t\tsolve(0);\n\t\tif(!S.size())printf(\"0\\n\");\n\t\telse{\n\t\t\tbool fi=false;\n\t\t\tfor(set<int>::iterator it=S.begin();it!=S.end();it++){\n\t\t\t\tif(fi)printf(\" \");\n\t\t\t\tfi=true;\n\t\t\t\tprintf(\"%d\",(*it));\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<array>\n#include<set>\n#include<vector>\n\nusing namespace std;\n\ntypedef array<int,6> Dice;\nint TF[2][3][3];\nDice dice[24];\nDice puzzle[3][3][3];\nset<int> ans;\n\nvoid rot(Dice &d,vector<int> v){\n  auto t=d[v[0]];\n  d[v[0]]=d[v[1]];\n  d[v[1]]=d[v[2]];\n  d[v[2]]=d[v[3]];\n  d[v[3]]=t;\n}\n\nvoid dfs(int d){\n  if(d==27){\n    int s=0;\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\ts+=puzzle[i][j][2][2];\n      }\n    }\n    ans.insert(s);\n  }else{\n    int z=d/9,y=d/3%3,x=d%3;\n    for(auto e:dice){\n      if(z){\n\tif(puzzle[z-1][y][x][4]+e[1]!=7)continue;\n      }else{\n\tif(TF[1][y][x]&&TF[1][y][x]!=e[1])continue;\n      }\n      if(y){\n\tif(puzzle[z][y-1][x][5]+e[0]!=7)continue;\n      }else{\n\tif(TF[0][2-z][x]&&TF[0][2-z][x]!=e[0])continue;\n      }\n      if(x&&puzzle[z][y][x-1][2]+e[3]!=7)continue;\n      puzzle[z][y][x]=e;\n      dfs(d+1);\n    }\n  }\n}\n\nint main(){\n  Dice d{1,2,3,4,5,6};\n  for(int i=0;i<6;i++){\n    if(i%2){\n      rot(d,{0,1,5,4});\n    }else{\n      rot(d,{0,2,5,3});\n    }\n    for(int j=0;j<4;j++){\n      rot(d,{1,2,4,3});\n      dice[i*4+j]=d;\n    }\n  }\n  int N;\n  cin>>N;\n  while(N--){\n    for(int i=0;i<2;i++){\n      for(int j=0;j<3;j++){\n\tfor(int k=0;k<3;k++){\n\t  cin>>TF[i][j][k];\n\t}\n      }\n    }\n    ans.clear();\n    dfs(0);\n    if(ans.empty()){\n      cout<<0<<endl;\n    }else{\n      for(auto e:ans){\n\tcout<<e<<' ';\n      }\n      cout<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\n\nenum FACE { TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT };\ntemplate <class T>\nclass Dice {\npublic:\n  Dice() {\n    id[TOP] = 0; id[FRONT] = 1; id[LEFT] = 2;\n    id[RIGHT] = 3; id[BACK] = 4; id[BOTTOM] = 5;\n  }\n  T& operator[] (FACE f) { return var[id[f]]; }\n  const T& operator[] (FACE f) const { return var[id[f]]; }\n  bool operator==(const Dice<T>& b) const {\n    const Dice<T> &a = *this;\n    return a[TOP] == b[TOP] && a[BOTTOM] == b[BOTTOM] &&\n      a[FRONT] == b[FRONT] && a[BACK] == b[BACK] &&\n      a[LEFT] == b[LEFT] && a[RIGHT] == b[RIGHT];\n  }\n  void roll_x() { roll(TOP, BACK, BOTTOM, FRONT); }\n  void roll_y() { roll(TOP, LEFT, BOTTOM, RIGHT); }\n  void roll_z() { roll(FRONT, RIGHT, BACK, LEFT); }\n  vector<Dice> all_rolls() {\n    vector<Dice> ret;\n    for (int k = 0; k < 6; (k&1?roll_y():roll_x()),++k)\n      for (int i = 0; i < 4; roll_z(), ++i)\n        ret.push_back(*this);\n    return ret;\n  }\n  bool equivalent_to(const Dice& di) {\n    for (int k = 0; k < 6; (k&1?roll_y():roll_x()),++k)\n      for (int i = 0; i < 4; roll_z(), ++i)\n        if (*this == di) return true;\n    return false;\n  }\nprivate:\n  void roll(FACE a, FACE b, FACE c, FACE d) {\n    T tmp = id[a];\n    id[a] = id[b]; id[b] = id[c];\n    id[c] = id[d]; id[d] = tmp;\n  }\n  T var[6];\n  int id[6];\n};\n\nFACE  face[] = {TOP,BOTTOM,FRONT,BACK,LEFT,RIGHT};\nint  value[] = {  0,     5,    1,   4,   3,    2};\n\ninline FACE rev(FACE f) { return ( ( f == TOP ) ? BOTTOM : ( ( f == BOTTOM ) ? TOP : ( ( f == FRONT ) ? BACK : ( ( f == BACK) ? FRONT : ( ( f == LEFT ) ? RIGHT : LEFT ) ) ) ) ); }\n\n\nint around[6][4] = \n  {\n    {1,2,4,3},\n    {0,3,5,2},\n    {0,1,5,4},\n    {0,4,5,1},\n    {0,2,5,3},\n    {1,3,4,2}\n  };\n\nDice<int> makeDice(int top,int front) {\n  Dice<int> ret;\n  ret[TOP] = top, ret[BOTTOM] = 5-top;\n  ret[FRONT] = front, ret[BACK] = 5-front;\n  int idx = IINF;\n  for(int i=0;i<4;i++) {\n    if(around[top][i] == front) {\n      idx = i+1;\n      break;\n\t}\n  }\n  assert(idx != IINF);\n  idx %= 4;\n  ret[RIGHT] = around[top][idx], ret[LEFT] = 5-around[top][idx];\n  return ret;\n}\n\nint T[3][3], F[3][3];\nDice<int> G[3][3][3];\nint dx[] = {-1,+0,+0};\nint dy[] = {+0,-1,+0};\nint dz[] = {+0,+0,-1};\nFACE fs[] = {LEFT,BACK,TOP};\nset<int> answer;\n\nbool isValid(int x,int y,int z) { return 0 <= x && x < 3 && 0 <= y && y < 3 && 0 <= z && z < 3; }\n\nstring get(FACE f) {\n  if( f == TOP ) return \"TOP\";\n  if( f == BOTTOM ) return \"BOTTOM\";\n  if( f == FRONT ) return \"FRONT\";\n  if( f == BACK ) return \"BACK\";\n  if( f == LEFT ) return \"LEFT\";\n  if( f == RIGHT ) return \"RIGHT\";\n  assert(false);\n}\n\nvoid dfs(int cur){\n\n  if( cur >= 27 ) {\n    int cost = 0;\n    rep(y,3) rep(z,3) cost += (G[z][y][2][RIGHT]+1);\n    answer.insert(cost);\n    return;\n  }\n\n  int cx = cur % 3, cy = ( cur / 3 ) % 3, cz =  cur / 9;\n  \n  Dice<int> tmp = G[cz][cy][cx];\n  vector<Dice<int> > rot = G[cz][cy][cx].all_rolls();\n  rep(i,(int)rot.size()){\n    G[cz][cy][cx] = rot[i];\n    bool failed = false;\n    if( cz == 0 ) if( T[cy][cx] != -1 && G[cz][cy][cx][TOP]   != T[cy][cx] ) { failed = true; }\n    if( cy == 2 ) if( F[cz][cx] != -1 && G[cz][cy][cx][FRONT] != F[cz][cx] ) { failed = true; }\n    if( failed ) continue;\n    rep(j,3){\n      int nx = cx + dx[j], ny = cy + dy[j], nz = cz + dz[j];\n      if( !isValid(nx,ny,nz) ) continue;\n      FACE rface = rev(fs[j]);\n      if( ( G[cz][cy][cx][fs[j]] + G[nz][ny][nx][rface] ) != 5 ) { failed = true; break; }\n    }\n    if( failed ) continue;\n    dfs(cur+1);\n  }\n  G[cz][cy][cx] = tmp;\n}\n\nvoid compute(){\n  answer.clear();\n  rep(z,3) rep(y,3) rep(x,3) rep(i,6) G[z][y][x][face[i]] = value[i];\n  dfs(0);\n  if( answer.empty() ) { puts(\"0\"); return; }\n  bool First = true;\n  for(set<int>::iterator it = answer.begin(); it != answer.end(); it++ ) {\n    if( !First ) cout << ' ';\n    First = false;\n    cout << *it;\n  } cout << endl;\n}\n\nint main(){\n  int t;\n  cin >> t;\n  while( t-- ){\n    rep(i,3) rep(j,3) cin >> T[i][j];\n    rep(i,3) rep(j,3) cin >> F[i][j];\n    rep(i,3) rep(j,3) --T[i][j], --F[i][j];\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Dice{\nprivate:\n    void roll(int a,int b,int c,int d){\n        swap(x[a],x[b]);\n        swap(x[b],x[d]);\n        swap(x[c],x[d]);\n    }\npublic:\n    int x[6];\n    Dice(){\n        for(int i = 0 ; i < 6 ; i++){\n            x[i] = i+1;\n        }\n    }\n    void roll_N(){ roll(0,1,4,5); }\n    void roll_E(){ roll(0,3,2,5); }\n    void rotation(){ roll(1,2,3,4); }\n    void roll(int top,int front){\n        for(int i = 0 ; i < 2 ; i++){\n            for(int j = 0 ; j < 4 ; j++){\n                roll_N();\n                if(top == x[0]) goto next;\n            }\n            roll_E();\n        }\n    next:\n        for(int i = 0 ; i < 4 ; i++){\n            rotation();\n            if(front == x[1]) break; \n        }\n    }\n    void clear(){ memset(x,0,sizeof(x)); }  \n}; \n\nbool can[60];\nDice d[3][3][3],d2[7][7];\nint bit[27];\n\nint calc(){\n    int sum = 0;\n    for(int i = 0 ; i < 3 ; i++){\n        for(int j = 0 ; j < 3 ; j++){\n            sum += d[i][j][2].x[2];\n        }\n    }\n    return sum;\n}\n\nbool check(int v){\n    int a = v/9, b = (v%9)/3, c = (v%9)%3;\n    int top = d[a][b][c].x[0],front = d[a][b][c].x[1];\n    for(int i = 0 ; i < 6 ; i++){\n        if(d[a][b][c].x[i] != d2[top][front].x[i]){\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid solve(int v,int p,int S){\n    if(v == 27){\n        can[calc()] = 1;\n        return;\n    }\n    if(p == 6){\n        if(!check(v)) return;\n        if(S == (1<<7)-1){\n            solve(v+1,0,bit[v+1]);\n        }\n        return;\n    }\n    int a = v/9, b = (v%9)/3, c = (v%9)%3;\n    if(a-1 >= 0 && p == 0){\n        if(d[a][b][c].x[p] == 0){\n            int x = 7 - d[a-1][b][c].x[5];\n            if(S >> x & 1) return;\n            d[a][b][c].x[p] = x;\n            int x2 = d[a][b][c].x[5-p];\n            if(x2 == 0 || x + x2 == 7){\n                solve(v,p+1,S|(1<<x));\n            }\n            d[a][b][c].x[p] = 0;\n        }else{\n            if(d[a][b][c].x[p] + d[a-1][b][c].x[5] == 7){\n                solve(v,p+1,S);\n            }\n        }\n        return;\n    }\n    if(b-1 >= 0 && p == 4){\n        if(d[a][b][c].x[p] == 0){\n            int x = 7 - d[a][b-1][c].x[1];\n            if(S >> x & 1) return;\n            d[a][b][c].x[p] = x;\n            int x2 = d[a][b][c].x[5-p];\n            if(x2 == 0 || x + x2 == 7){\n                solve(v,p+1,S|(1<<x));\n            }\n            d[a][b][c].x[p] = 0;\n        }else{\n            if(d[a][b][c].x[p] + d[a][b-1][c].x[1] == 7){\n                solve(v,p+1,S);     \n            }\n        }\n        return;\n    }\n    if(c-1 >= 0 && p == 3){\n        if(d[a][b][c].x[p] == 0){\n            int x = 7 - d[a][b][c-1].x[2];\n            if(S >> x & 1) return;\n            d[a][b][c].x[p] = x;\n            int x2 = d[a][b][c].x[5-p];\n            if(x2 == 0 || x + x2 == 7){\n                solve(v,p+1,S|(1<<x));\n            }\n            d[a][b][c].x[p] = 0;\n        }else{\n            if(d[a][b][c].x[p] + d[a][b][c-1].x[2] == 7){\n                solve(v,p+1,S);\n            }\n        }\n        return;\n    }\n    \n    if(d[a][b][c].x[p] == 0){\n        if(d[a][b][c].x[5-p] != 0){\n            int x = 7 - d[a][b][c].x[5-p];\n            if(S >> x & 1) return;\n            d[a][b][c].x[p] = x;\n            solve(v,p+1,S|(1<<x));\n            d[a][b][c].x[p] = 0;\n        }else{\n            for(int i = 0 ; i < 6 ; i++){\n                d[a][b][c].x[p] = i+1;\n                int x = d[a][b][c].x[5-p];\n                if(!(S >> (i+1) & 1) &&\n                   (x == 0 || x + d[a][b][c].x[p] == 7)){\n                    solve(v,p+1,S|(1<<(i+1)));\n                }\n                d[a][b][c].x[p] = 0;\n            }\n        }\n    }else{\n        int x = d[a][b][c].x[5-p];\n        if(x + d[a][b][c].x[p] == 7){\n            solve(v,p+1,S);\n        }\n    }\n}\n\nvoid print(){\n    bool sp = false;\n    for(int i = 0 ; i < 60 ; i++){\n        if(can[i]){\n            if(sp) cout << \" \";\n            sp = true;\n            cout << i;\n        }\n    }\n    if(!sp) cout << 0;\n    cout << endl;\n}\n\nvoid init(){\n    fill(bit,bit+27,1);\n    memset(can,0,sizeof(can));\n    for(int i = 0 ; i < 3 ; i++){\n        for(int j = 0 ; j < 3 ; j++){\n            for(int k = 0 ; k < 3 ; k++){\n                d[i][j][k].clear();\n            }\n        }\n    }\n    \n    Dice dice;\n    for(int i = 1 ; i <= 6 ; i++){\n        for(int j = 1 ; j <= 6 ; j++){\n            if(i == j) continue;\n            dice.roll(i,j);\n            d2[i][j] = dice;        \n        }\n    }\n}\n\nint main(){\n    int N;\n    cin >> N;\n    while(N--){\n        init();\n        int in;\n        for(int i = 0 ; i < 3 ; i++){\n            for(int j = 0 ; j < 3 ; j++){\n                cin >> in;\n                if(in != 0){\n                    d[0][i][j].x[0] = in;\n                    d[0][i][j].x[5] = 7-in;\n                    bit[3*i+j] |= 1<<in;\n                    bit[3*i+j] |= 1<<(7-in);\n                }\n            }\n        }\n        for(int i = 0 ; i < 3 ; i++){\n            for(int j = 0 ; j < 3 ; j++){\n                cin >> in;\n                if(in != 0){\n                    d[i][2][j].x[1] = in;\n                    d[i][2][j].x[4] = 7-in;\n                    bit[9*i+6+j] |= 1<<in;\n                    bit[9*i+6+j] |= 1<<(7-in);\n                }\n            }\n        }\n        solve(0,0,bit[0]);\n        print();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<set>\nusing namespace std;\nint b[4][4];\nint c[4][4];\nint t[30][7];\nset<int>S;\nint sz=24;\nint pat[24][6]={\n{1,2,3,4,5,6},\n{1,3,5,2,4,6},\n{1,4,5,2,3,6},\n{1,5,4,3,2,6},\n{2,6,3,4,1,5},\n{2,3,1,6,4,5},\n{2,1,4,3,6,5},\n{2,4,6,1,3,5},\n{3,1,2,5,6,4},\n{3,2,6,1,5,4},\n{3,6,5,2,1,4},\n{3,5,1,6,2,4},\n{4,2,1,6,5,3},\n{4,1,5,2,6,3},\n{4,5,6,1,2,3},\n{4,6,2,5,1,3},\n{5,1,3,4,6,2},\n{5,3,6,1,4,2},\n{5,6,4,3,1,2},\n{5,4,1,6,3,2},\n{6,4,5,2,3,1},\n{6,2,4,3,5,1},\n{6,3,2,5,4,1},\n{6,5,3,4,2,1}\n};\nvoid solve(int a){\n\tif(a==27){\n\t\tint ret=0;\n\t\tfor(int i=0;i<9;i++){\n\t\t\tret+=t[i*3+2][2];\n\t\t}\n\t\tS.insert(ret);return;\n\t}\n\tfor(int i=0;i<sz;i++){\n\t\tif(a<9&&b[2-a/3][a%3]&&b[2-a/3][a%3]!=pat[i][0])continue;\n\t\tif(a%9/3==0&&c[a/9][a%3]&&c[a/9][a%3]!=pat[i][1])continue;\n\t\tif(a%3&&pat[i][3]+t[a-1][2]!=7)continue;\n\t\tif(a%9/3&&pat[i][1]+t[a-3][4]!=7)continue;\n\t\tif(a/9&&pat[i][0]+t[a-9][5]!=7)continue;\n\t\tfor(int j=0;j<6;j++)t[a][j]=pat[i][j];\n\t\tsolve(a+1);\n\t}\n}\nint perm[6];\nint main(){\n\tint T;scanf(\"%d\",&T);\n\n\twhile(T--){\n\t\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)scanf(\"%d\",&b[i][j]);\n\t\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)scanf(\"%d\",&c[i][j]);\n\t\tS.clear();\n\t\tsolve(0);\n\t\tif(!S.size())printf(\"0\\n\");\n\t\telse{\n\t\t\tbool fi=false;\n\t\t\tfor(set<int>::iterator it=S.begin();it!=S.end();it++){\n\t\t\t\tif(fi)printf(\" \");\n\t\t\t\tfi=true;\n\t\t\t\tprintf(\"%d\",(*it));\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nstruct Dice\n{\n\tint top, right, front;\n\tDice() :top(1), right(2), front(3) {};\n\tDice(int t, int r, int f) :top(t), right(r), front(f) {};\n\tvoid set(int t, int r, int f) { top = t, right = r, front = f; }\n\tint get_top() { return top; }\n\tint get_bottom() { return 7 - top; }\n\tint get_right() { return right; }\n\tint get_left() { return 7 - right; }\n\tint get_front() { return front; }\n\tint get_back() { return 7 - front; }\n\tvoid to_front() { swap(front, top); top = 7 - top; }\n\tvoid to_back() { REP(i, 3) to_front(); }\n\tvoid to_right() { swap(top, right); top = 7 - top; }\n\tvoid to_left() { REP(i, 3) to_right(); }\n\tvoid to_clock() { swap(front, right); right = 7 - right; }\n\tvoid to_counter() { REP(i, 3) to_clock(); }\n};\n\n\nbool operator<(const Dice& a, const Dice& b)\n{\n\tint at = a.top, bt = b.top;\n\tint af = a.front, bf = b.front;\n\tint ar = a.right, br = b.right;\n\tif (at != bt) return at < bt;\n\tif (af != bf) return ar < br;\n\tif (ar != br) return af < bf;\n\treturn false;\n}\n\nstruct Cube\n{\n\tDice dice[3][3][3];\n\tCube()\n\t{\n\t\tREP(i, 3)REP(j, 3)REP(k, 3) dice[i][j][k].set(-1, -1, -1);\n\t}\n};\n\nconst int dx[] = { -1,0,0,0,0,1 };\nconst int dy[] = { 0,-1,0,1,0,0 };\nconst int dz[] = { 0,0,-1,0,1,0 };\nint state(int x, int y, int z)\n{ \n\tif (z == 3) return 1;\n\telse if (x == -1) return 2;\n\telse if(x >= 0 && y >= 0 && z >= 0 && x < 3 && y < 3 && z < 3) return 0; \n\telse return 3;\n}\n\nset<Dice> pat;\n\nvoid init()\n{\n\tDice d(1, 3, 2);\n\tvector<Dice> v;\n\tREP(i, 4)\n\t{\n\t\td.to_front();\n\t\tv.push_back(d);\n\t}\n\tREP(i, v.size())\n\t{\n\t\tDice tmp = v[i];\n\t\tREP(j, 4)\n\t\t{\n\t\t\ttmp.to_right();\n\t\t\tpat.insert(tmp);\n\t\t}\n\t\tREP(k, 4)\n\t\t{\n\t\t\ttmp.to_clock();\n\t\t\tpat.insert(tmp);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tinit();\n\tint n; cin >> n;\n\tREP(cs, n)\n\t{\n\t\tvector<vi> top(3, vi(3)), front(3, vi(3));\n\t\tREP(i, 3)REP(j, 3) cin >> top[i][j];\n\t\tREP(i, 3)REP(j, 3) cin >> front[i][j];\n\t\tCube cube;\n\t\tset<int> ans;\n\t\tqueue<tuple<Cube, int, int, int>> que;\n\t\tque.emplace(cube, 0, 0, 0);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tCube tmp; int x, y, z; \n\t\t\ttie(tmp, x, y, z) = que.front();\n\t\t\tque.pop();\n\t\t\tint tt = -1, tf = -1, tr = -1;\n\t\t\tbool flag = true;\n\t\t\tREP(i, 6)\n\t\t\t{\n\t\t\t\tint nx = x + dx[i], ny = y + dy[i], nz = z + dz[i];\n\t\t\t\tint st = state(nx, ny, nz);\n\t\t\t\tif (st == 1)\n\t\t\t\t{\n\t\t\t\t\tif (front[x][y] != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(tf != -1 && tf != front[x][y]) flag = false;\n\t\t\t\t\t\ttf = front[x][y];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (st == 2)\n\t\t\t\t{\n\t\t\t\t\tif (top[z][y] != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tt != -1 && tt != top[z][y]) flag = false;\n\t\t\t\t\t\ttt = top[z][y];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (st == 0 && tmp.dice[nx][ny][nz].get_top() != -1)\n\t\t\t\t{\n\t\t\t\t\tif (i == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tt != -1 && tt != tmp.dice[nx][ny][nz].get_top()) flag = false;\n\t\t\t\t\t\ttt = tmp.dice[nx][ny][nz].get_top();\n\t\t\t\t\t}\n\t\t\t\t\tif (i == 1) tr = tmp.dice[nx][ny][nz].get_right();\n\t\t\t\t\tif (i == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tf != -1 && tf != tmp.dice[nx][ny][nz].get_front()) flag = false;\n\t\t\t\t\t\ttf = tmp.dice[nx][ny][nz].get_front();\n\t\t\t\t\t}\n\t\t\t\t\tif (i == 3) tr = tmp.dice[nx][ny][nz].get_right();\n\t\t\t\t\tif (i == 4) tt = tmp.dice[nx][ny][nz].get_front();\n\t\t\t\t\tif (i == 5) tt = tmp.dice[nx][ny][nz].get_top();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) continue;\n\t\t\tint nx = x, ny = y, nz = z;\n\t\t\tnz++;\n\t\t\tif (nz == 3) { nz = 0, ny++; }\n\t\t\tif (ny == 3) { ny = 0, nx++; }\n\t\t\tfor (auto d : pat)\n\t\t\t{\n\t\t\t\tif (tt != -1 && tt != d.get_top()) continue;\n\t\t\t\tif (tf != -1 && tf != d.get_front()) continue;\n\t\t\t\tif (tr != -1 && tr != d.get_right()) continue;\n\t\t\t\tCube nc = tmp;\n\t\t\t\tnc.dice[x][y][z] = d;\n\t\t\t\tif (x == 3)\n\t\t\t\t{\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\tREP(i, 3)REP(j, 3) sum += nc.dice[i][2][j].get_right();\n\t\t\t\t\tans.insert(sum);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tque.emplace(nc, nx, ny, nz);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvi ansv;\n\t\tfor (auto i : ans) ansv.push_back(i);\n\t\tif (ansv.size() == 0) cout << 0 << endl;\n\t\telse REP(i, ansv.size()) cout << ansv[i] << (i == ansv.size() - 1 ? \"\\n\" : \" \");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint number[6][6][6]=\n{\n\t{\n\t\t{0,0,0,0,0,0},\n\t\t{1,2,3,4,5,6},\n\t\t{1,3,5,2,4,6},\n\t\t{1,4,2,5,3,6},\n\t\t{1,5,4,3,2,6},\n\t\t{0,0,0,0,0,0},\n\t},\n\t{\n\t\t{2,1,4,3,6,5},\n\t\t{0,0,0,0,0,0},\n\t\t{2,3,1,6,4,5},\n\t\t{2,4,6,1,3,5},\n\t\t{0,0,0,0,0,0},\n\t\t{2,6,3,4,1,5},\n\t},\n\t{\n\t\t{3,1,2,5,6,4},\n\t\t{3,2,6,1,5,4},\n\t\t{0,0,0,0,0,0},\n\t\t{0,0,0,0,0,0},\n\t\t{3,5,1,6,2,4},\n\t\t{3,6,5,2,1,4},\n\t},\n\t{\n\t\t{4,1,5,2,6,3},\n\t\t{4,2,1,6,5,3},\n\t\t{0,0,0,0,0,0},\n\t\t{0,0,0,0,0,0},\n\t\t{4,5,6,1,2,3},\n\t\t{4,6,2,5,1,3},\n\t},\n\t{\n\t\t{5,1,3,4,6,2},\n\t\t{0,0,0,0,0,0},\n\t\t{5,3,6,1,4,2},\n\t\t{5,4,1,6,3,2},\n\t\t{0,0,0,0,0,0},\n\t\t{5,6,4,3,1,2},\n\t},\n\t{\n\t\t{0,0,0,0,0,0},\n\t\t{6,2,4,3,5,1},\n\t\t{6,3,2,5,4,1},\n\t\t{6,4,5,2,3,1},\n\t\t{6,5,3,4,2,1},\n\t\t{0,0,0,0,0,0},\n\t},\n};\nint N;\nvector<int>ans;\nint top[27];\nint frt[27];\nvoid dfs(int id)\n{\n\tif(id==27)\n\t{\n\t\tint now=0;\n\t\tfor(int i=2;i<27;i+=3)now+=number[top[i]-1][frt[i]-1][2];\n\t\tans.push_back(now);\n\t\treturn;\n\t}\n\tint stot=top[id],stof=frt[id];\n\tint t=id<9?stot:7-number[top[id-9]-1][frt[id-9]-1][5];\n\tint lt=t?t:1,rt=t?t:6;\n\tfor(int nowt=lt;nowt<=rt;nowt++)\n\t{\n\t\tint f=id%9<3?stof:7-number[top[id-3]-1][frt[id-3]-1][4];\n\t\tint lf=f?f:1,rf=f?f:6;\n\t\tfor(int nowf=lf;nowf<=rf;nowf++)\n\t\t{\n\t\t\tint left=number[nowt-1][nowf-1][3];\n\t\t\tif(left==0)continue;\n\t\t\tif(id%3!=0&&7-number[top[id-1]-1][frt[id-1]-1][2]!=left)continue;\n\t\t\ttop[id]=nowt;frt[id]=nowf;\n\t\t\tdfs(id+1);\n\t\t}\n\t}\n\ttop[id]=stot;frt[id]=stof;\n}\nmain()\n{\n\tcin>>N;\n\tfor(int ccc=0;ccc<N;ccc++)\n\t{\n\t\tans.clear();\n\t\tfor(int i=0;i<27;i++)top[i]=frt[i]=0;\n\t\tcin>>top[6]>>top[7]>>top[8]>>top[3]>>top[4]>>top[5]>>top[0]>>top[1]>>top[2];\n\t\tcin>>frt[0]>>frt[1]>>frt[2]>>frt[9]>>frt[10]>>frt[11]>>frt[18]>>frt[19]>>frt[20];\n\t\tdfs(0);\n\t\tif(ans.empty())\n\t\t{\n\t\t\tcout<<0<<endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsort(ans.begin(),ans.end());\n\t\t\tans.erase(unique(ans.begin(),ans.end()),ans.end());\n\t\t\tfor(int i=0;i<ans.size();i++)cout<<ans[i]<<(i+1==ans.size()?\"\\n\":\" \");\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\nusing namespace std;\n\nenum { U, F, R, D, B, L };\nstruct Dice {\n\tint face[6];\n\tDice() { face[F] = 1; face[R] = 2; face[U] = 3; face[B] = 6; face[L] = 5; face[D] = 4; }\n\tint find_face(int f) {\n\t\trep(i, 6) if(face[i] == f) return i;\n\t\treturn -1;\n\t}\n\tvoid turn(int dir) {\n\t\tswitch(dir) {\n\t\tcase R: rotate(U, R, D, L); break;\n\t\tcase B: rotate(U, B, D, F); break;\n\t\tcase L: rotate(U, L, D, R); break;\n\t\tcase F: rotate(U, F, D, B); break;\n\t\tcase U: rotate(F, R, B, L); break; // ??????????????????????¨???????\n\t\tcase D: rotate(F, L, B, R); break; // ??????????????????????¨???????\n\t\tdefault: assert(false);\n\t\t}\n\t}\n\tint & operator[](int n) { return face[n]; }\n\tvector<Dice> all() {\n\t\tvector<Dice> res;\n\t\trep(k, 6) {\n\t\t\trep(i, 4) { res.push_back(*this); turn(R); }\n\t\t\tif(k & 1) turn(U); else turn(F);\n\t\t}\n\t\treturn res;\n\t}\n\tvoid rotate(int a, int b, int c, int d) {\n\t\tint t = face[d];\n\t\tface[d] = face[c]; face[c] = face[b]; face[b] = face[a]; face[a] = t;\n\t}\n};\n\nint u[3][3][3];\nint f[3][3][3];\nint r[3][3][3];\nint ut[3][3][3];\nint ft[3][3][3];\n\nvector<Dice> ds[7][7][7];\nstruct P {\n\tint x, y, z;\n};\n\nvector<P> ps;\nvector<int> ans;\n\nvoid dfs(int n) {\n\t//cout << n << endl;\n\tif(n == 27) {\n\t\tint sum = 0;\n\t\tfor(int y = 0; y < 3; y++) {\n\t\t\tfor(int z = 0; z < 3; z++) {\n\t\t\t\tsum += r[2][y][z];\n\t\t\t}\n\t\t}\n\t\tans.push_back(sum);\n\t\treturn;\n\t}\n\n\tint x = ps[n].x, y = ps[n].y, z = ps[n].z;\n\t// u\n\tint uu = ut[x][y][z] ? u[x][y][z] : 0;\n\tfor(int i = 0; i < 3; i++) {\n\t\tif(y == i) continue;\n\t\tif(u[x][i][z] == 0) continue;\n\t\tif(uu != 0 && uu != u[x][i][z]) return;\n\t\tuu = u[x][i][z];\n\t}\n\t// f\n\tint ff = ft[x][y][z] ? f[x][y][z] : 0;\n\tfor(int i = 0; i < 3; i++) {\n\t\tif(z == i) continue;\n\t\tif(f[x][y][i] == 0) continue;\n\t\tif(ff != 0 && ff != f[x][y][i]) return;\n\t\tff = f[x][y][i];\n\t}\n\t// r\n\tint rr = 0;\n\tfor(int i = 0; i < 3; i++) {\n\t\tif(x == i) continue;\n\t\tif(r[i][y][z] == 0) continue;\n\t\tif(rr != 0 && rr != r[i][y][z]) return;\n\t\trr = r[i][y][z];\n\t}\n\tfor(Dice d : ds[uu][ff][rr]) {\n\t\tu[x][y][z] = d[U];\n\t\tf[x][y][z] = d[F];\n\t\tr[x][y][z] = d[R];\n\t\tdfs(n + 1);\n\t\tif(!ut[x][y][z]) u[x][y][z] = 0;\n\t\tif(!ft[x][y][z]) f[x][y][z] = 0;\n\t\tr[x][y][z] = 0;\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t{\n\t\tDice d;\n\t\tvector<Dice> all = d.all();\n\t\tfor(Dice a : all) {\n\t\t\tfor(int i = 0; i < 7; i++) {\n\t\t\t\tfor(int j = 0; j < 7; j++) {\n\t\t\t\t\tfor(int k = 0; k < 7; k++) {\n\t\t\t\t\t\tif(i != 0 && i != a.face[U]) continue;\n\t\t\t\t\t\tif(j != 0 && j != a.face[F]) continue;\n\t\t\t\t\t\tif(k != 0 && k != a.face[R]) continue;\n\t\t\t\t\t\tds[i][j][k].push_back(a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int x = 0; x < 3; x++) {\n\t\tfor(int y = 0; y < 3; y++) {\n\t\t\tfor(int z = 0; z < 3; z++) {\n\t\t\t\tps.push_back(P{ x, y, z });\n\t\t\t}\n\t\t}\n\t}\n\n\tint n;\n\tcin >> n;\n\twhile(n--) {\n\t\tmemset(u, 0, sizeof u);\n\t\tmemset(f, 0, sizeof f);\n\t\tmemset(r, 0, sizeof r);\n\t\tmemset(ut, 0, sizeof u);\n\t\tmemset(ft, 0, sizeof f);\n\n\t\tfor(int z = 0; z < 3; z++) {\n\t\t\tfor(int x = 0; x < 3; x++) {\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tfor(int y = 0; y < 3; y++) {\n\t\t\t\t\tu[x][y][z] = a;\n\t\t\t\t\tif(a) ut[x][y][z] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int y = 0; y < 3; y++) {\n\t\t\tfor(int x = 0; x < 3; x++) {\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tfor(int z = 0; z < 3; z++) {\n\t\t\t\t\tf[x][y][z] = a;\n\t\t\t\t\tif(a) ft[x][y][z] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans.clear();\n\n\t\tdfs(0);\n\n\t\tsort(ans.begin(), ans.end());\n\t\tans.erase(unique(ans.begin(), ans.end()), ans.end());\n\n\t\tif(ans.size()) {\n\t\t\tfor(int i = 0; i < ans.size(); i++) {\n\t\t\tcout << ans[i];\n\t\t\tif(i != ans.size() - 1) cout << \" \";\n\t\t}\n\t\t}\n\t\telse {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<55)+1e9; // ~ 3.6 * 1e16\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nostream& operator<<(ostream& o,T t){return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){Int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nconst Int TOP = 0,FRONT = 1,LEFT = 3, RIGHT = 2,BACK = 4,BOTTOM = 5;\nclass Dice{\npublic:\n  vector<Int> val;\n  Dice():val(6){for(Int i=0;i<6;i++) val[i] = i+1;}\n  Dice(Int val[6]){for(Int i=0;i<6;i++) this->val[i] = val[i];}\n  Dice(vector<Int> val):val(val){assert(val.size() == 6);}\n  Int& operator [](Int a){return val[a];}\n  bool operator == (Dice a)const{\n    for(Int i=0;i<6;(i%2? a.rotN():a.rotE()),i++)\n      for(Int j=0;j<4;j++){\n        if(val == a.val) return 1;\n        a.rotCW();\n      }\n    return 0;\n  }\n\n  void rot(string s){\n    if(s == \"N\" || s == \"B\") rotN();\n    else if(s == \"S\" || s == \"F\") rotS();\n    else if(s == \"E\" || s == \"R\") rotE();\n    else if(s == \"W\" || s == \"L\") rotW();\n    else if(s == \"CW\") rotCW();\n    else if(s == \"CCW\") rotCCW();\n    else assert(!\"rot error\"); /*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/\n  }\n\n  \n  void rot(char ch){rot(string(1,ch));}\n  \n  //奥に転がす\n  void rotN(){\n    swap(val[TOP],val[FRONT]);\n    swap(val[FRONT],val[BOTTOM]);\n    swap(val[BOTTOM],val[BACK]);\n  }\n\n  //手前に転がす\n  void rotS(){\n    //rotN(),rotN(),rotN();\n    swap(val[TOP],val[BACK]);\n    swap(val[BACK],val[BOTTOM]);\n    swap(val[BOTTOM],val[FRONT]);\n  }\n  \n  //右に転がす\n  void rotE(){\n    swap(val[TOP],val[LEFT]);\n    swap(val[LEFT],val[BOTTOM]);\n    swap(val[BOTTOM],val[RIGHT]);\n  }\n\n  //左に転がす\n  void rotW(){\n    //rotE(),rotE(),rotE();\n    swap(val[TOP],val[RIGHT]);\n    swap(val[RIGHT],val[BOTTOM]);\n    swap(val[BOTTOM],val[LEFT]);\n  }\n\n  //上から見て時計回りに回す\n  void rotCW(){\n    swap(val[FRONT],val[RIGHT]);\n    swap(val[RIGHT],val[BACK]);\n    swap(val[BACK],val[LEFT]);\n  }\n\n  //上からみて反時計回りに回す。\n  void rotCCW(){\n    //rotCW(),rotCW(),rotCW();\n    swap(val[FRONT],val[LEFT]);\n    swap(val[LEFT],val[BACK]);\n    swap(val[BACK],val[RIGHT]);\n  }\n\n  void init(Int top,Int front){\n    for(Int i=0;i<6;(i%2? rotN():rotE()),i++)\n      for(Int j=0;j<4;j++){\n        if(val[TOP] == top && val[FRONT] == front) return;\n        rotCW();\n      }\n    assert(!\"init error\");\n  }\n};\n\nDice getDice(Int top){\n  Int front = top == 6 || top == 1? 2:1;\n  Dice d; d.init(top, front);\n  return d;\n}\n\n\nvector<vector<Int> > Top;\nvector<vector<Int> > Front;\nvector<vector<vector<Dice> > > dice;\nvector<Int>  num;\nvoid dfs(Int i,Int j,Int k,Int sum){\n  if(j == 3) i++, j = 0;\n  if(i == 3) i = 0, k++;\n  if(k == 3) {num.push_back(sum);return;}\n\n  for(Int top = 1; top<=6; top++){\n    if(k == 0 && Top[i][j] != 0 && top != Top[i][j]) continue;\n    if(k != 0 && top + dice[i][j][k-1][BOTTOM] != 7) continue;\n    \n    auto check= [&](Dice &d){\n      if(i - 1 >= 0 && d[BACK] + dice[i-1][j][k][FRONT] != 7) return 0;\n      if(j - 1 >= 0 && d[LEFT] + dice[i][j-1][k][RIGHT] != 7) return 0;\n      if(i==2 && Front[k][j] != 0 && d[FRONT] + Front[k][j] != 7) return 0;\n      return 1;\n    };\n    Dice d = getDice(top);\n    for(Int s=0; s < 4; s++, d.rotCCW()){\n      if(!check(d)) continue;\n      dice[i][j][k] = d;\n      Int nsum = sum + (j==0? d[LEFT]:0);\n      dfs(i, j+1, k, nsum);\n    }\n  }\n}\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n  Int N;\n  cin>>N;\n  while(N--){\n    Top = vector<vector<Int> > (3,vector<Int>(3));\n    Front = vector<vector<Int> > (3,vector<Int>(3));\n    cin>>Top;\n    cin>>Front;\n  \n    num.clear();\n    dice = vector<vector<vector<Dice> > > (3, vector<vector<Dice> > (3,vector<Dice>(3)));\n    dfs(0, 0 ,0, 0);\n    sort(num.begin(),num.end());\n    num.erase(unique(num.begin(), num.end()), num.end());\n    if(num.size() == 0) cout<<0<<endl;\n    else cout<<num<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nenum FACE { TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT };\nclass dice {\nprivate:\n\tint num[6];\n\n\tvoid roll(FACE a, FACE b, FACE c, FACE d) {\n\t\tswap(num[a], num[b]);\n\t\tswap(num[b], num[c]);\n\t\tswap(num[c], num[d]);\n\t}\n\npublic:\n\tdice() {\n\t\tnum[TOP] = 1;\n\t\tnum[BOTTOM] = 6;\n\t\tnum[FRONT] = 2;\n\t\tnum[BACK] = 5;\n\t\tnum[RIGHT] = 3;\n\t\tnum[LEFT] = 4;\n\t}\n\n\tvoid set(int top, int front) {\n        if(num[RIGHT] == top || num[LEFT] == top) west();\n        while(num[TOP] != top) north();\n        while(num[FRONT] != front) ccw();\n\t}\n\n\tconst int &operator[](FACE f) const { return num[f]; }\n\n\tvoid north() { roll(TOP, BACK, BOTTOM, FRONT); }\n\tvoid east()  { roll(TOP, LEFT, BOTTOM, RIGHT); }\n\tvoid west()  { roll(TOP, RIGHT, BOTTOM, LEFT); }\n\tvoid south() { roll(TOP, FRONT, BOTTOM, BACK); }\n\tvoid ccw()   { roll(BACK, RIGHT, FRONT, LEFT); }\n\tvoid cw()    { roll(BACK, LEFT, FRONT, RIGHT); }\n};\n\n\nint right_face[7][7];\nvoid init() {\n\tdice d;\n\tfor(int t = 1; t <= 6; ++t) {\n\t\tfor(int f = 1; f <= 6; ++f) {\n\t\t\tif(t == f || t + f == 7) continue;\n\t\t\td.set(t, f);\n\t\t\tright_face[t][f] = d[RIGHT];\n\t\t}\n\t}\n}\n\nint top[3][3][3];\nint front[3][3][3];\n\nvector<int> ans;\n\nvoid dfs(int x, int y, int z) {\n\tif(z == 3) {\n\t\tint sum = 0;\n\t\tfor(int z = 0; z < 3; ++z) {\n\t\t\tfor(int y = 0; y < 3; ++y) {\n\t\t\t\tsum += right_face[top[z][y][0]][front[z][y][0]];\n\t\t\t}\n\t\t}\n\t\tans.emplace_back(sum);\n\t}\n\telse if(y == 3) {\n\t\tdfs(0, 0, z + 1);\n\t}\n\telse if(x == 3) {\n\t\tdfs(0, y + 1, z);\n\t}\n\telse {\n\t\tconst int p_top = top[z][y][x];\n\t\tconst int p_front = front[z][y][x];\n\t\tfor(int t = 1; t <= 6; ++t) {\n\t\t\tif(top[z][y][x] && top[z][y][x] != t) continue;\n\t\t\tif(z && top[z - 1][y][x] != t) continue;\n\n\t\t\tfor(int f = 1; f <= 6; ++f) {\n\t\t\t\tif(t == f || t + f == 7) continue;\n\t\t\t\tif(front[z][y][x] && front[z][y][x] != f) continue;\n\t\t\t\tif(y && front[z][y - 1][x] != f) continue;\n\t\t\t\tif(x && right_face[top[z][y][x - 1]][front[z][y][x - 1]] != right_face[t][f]) continue;\n\n\t\t\t\ttop[z][y][x] = t;\n\t\t\t\tfront[z][y][x] = f;\n\t\t\t\tdfs(x + 1, y, z);\n\t\t\t\ttop[z][y][x] = p_top;\n\t\t\t\tfront[z][y][x] = p_front;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tans.clear();\n\tmemset(top, 0, sizeof(top));\n\tmemset(front, 0, sizeof(front));\n\n\tfor(int y = 0; y < 3; ++y) {\n\t\tfor(int x = 0; x < 3; ++x) {\n\t\t\tcin >> top[0][y][x];\n\t\t}\n\t}\n\n\tfor(int z = 0; z < 3; ++z) {\n\t\tfor(int x = 0; x < 3; ++x) {\n\t\t\tcin >> front[z][0][x];\n\t\t}\n\t}\n\n\tdfs(0, 0, 0);\n\tif(ans.size()) {\n\t\tsort(ans.begin(), ans.end());\n\t\tans.erase(unique(ans.begin(), ans.end()), ans.end());\n\t\tfor(unsigned i = 0; i < ans.size(); ++i) {\n\t\t\tcout << ans[i] << (i + 1 == ans.size() ? \"\\n\" : \" \");\n\t\t}\n\t}\n\telse {\n\t\tcout << \"0\\n\";\n\t}\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tinit();\n\n\tint n;\n\tcin >> n;\n\n\tcout << n << endl;\n\n\twhile(n--) solve();\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\n\nenum Face {TOP, FRONT, RIGHT, LEFT, BACK, BOTTOM};\nFace opposite(Face f){ return (Face)(5 - (int)f);}\n\n\nclass Dice{\npublic:\n  Dice() : dice(6){\n    dice[TOP] = 0; dice[BOTTOM] = 5;\n    dice[FRONT] = 1; dice[BACK] = 4;\n    dice[RIGHT] = 2; dice[LEFT] = 3;\n  }\n\n  const int &operator[](Face f) const { return dice[f]; }\n  void rot_x(){\n    shift(dice[TOP], dice[RIGHT], dice[BOTTOM], dice[LEFT]);\n  }\n  void rot_y(){\n    shift(dice[TOP], dice[BACK], dice[BOTTOM], dice[FRONT]);\n  }\n  void rot_z(){\n    shift(dice[FRONT], dice[LEFT], dice[BACK], dice[RIGHT]);\n  }\n  \n  Dice normalize(){\n    Dice res = *this;\n    for(int i = 0; i < 6; i % 2 ? rot_y() : rot_x(), i++){\n      for(int j = 0; j < 4; rot_z(), j++){\n\tif(this->dice < res.dice) res = *this;\n      }\n    }\n    return res;\n  }\n\n  static vector<Dice> all_rots(){\n    vector<Dice> res;\n    Dice d;\n    for(int i = 0; i < 6; i % 2 ? d.rot_y() : d.rot_x(), i++){\n      for(int j = 0; j < 4; d.rot_z(), j++){\n\tres.push_back(d);\n      }\n    }\n    return res;\n  }\n\n  friend ostream &operator<<(ostream &out, const Dice &dice){\n    out << \"(T: \" << dice[TOP]   << \", F: \" << dice[FRONT]\n\t<< \", R: \"<< dice[RIGHT] << \", L: \" << dice[LEFT]\n\t<< \", Ba: \"<< dice[BACK]  << \", Bo: \" << dice[BOTTOM] << \")\";\n    return out;\n  }\n  \nprivate:\n  void shift(int &a, int &b, int &c, int &d){\n    int tmp = a;\n    a = b; b = c; c = d; d = tmp;\n  }\n  vector<int> dice;\n};\n\nset<int> sum_set;\nint T[3][3], F[3][3], R[3][3];\nDice cube[3][3][3];\n\nbool inside(int x, int y, int z){\n  return 0 <= x && x < 3 && 0 <= y && y < 3 && 0 <= z && z < 3;\n}\n\nvoid calc(int x, int y, int z){\n  \n  if(z == 3){\n    int sum = 0;\n    REP(i, 3)REP(j, 3) sum += R[i][j];\n    sum_set.insert(sum + 9);\n  }else if(y == 3){\n    calc(x, 0, z + 1);\n  }else if(x == 3){\n    calc(0, y + 1, z);\n  }else{\n    vector<Dice> dices = Dice::all_rots();\n    REP(i, dices.size()){\n      Dice dice = dices[i];\n\n\n      if(z == 0 && F[y][x] >= 0 && F[y][x] != dice[FRONT]){\n\tcontinue;\n      }\n      \n      if(y == 0 && T[2-z][x] >= 0 && T[2-z][x] != dice[TOP]){\n\tcontinue;\n      }\n\n      \n      bool ok = true;\n      int dx[6] = {0, 1, 0, 0, -1, 0};\n      int dy[6] = {0, 0, 1, -1, 0, 0};\n      int dz[6] = {1, 0, 0, 0, 0, -1};\n      Face dir[6] = {BACK, RIGHT, BOTTOM, TOP, LEFT, FRONT};\n      REP(j, 6){\n\tint nx = x + dx[j];\n\tint ny = y + dy[j];\n\tint nz = z + dz[j];\n\tif(inside(nx, ny, nz)){\n\t  if(nz > z) continue;\n\t  if(nz == z && ny > y) continue;\n\t  if(nz == z && ny == y && nx > x) continue;\n\n\t  int f  = dice[dir[j]];\n\t  int nf = cube[nx][ny][nz][opposite(dir[j])];\n\t  if(f + nf != 5) ok = false;\n\t}\n      }\n      \n      if(ok){\n\tif(x == 2) R[y][z] = dice[RIGHT];\n\tcube[x][y][z] = dice;\t \n\tcalc(x + 1, y, z);\n      }\n    }\n  }\n}\n\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    REP(i, 3)REP(j, 3){\n      cin >> T[i][j];\n      T[i][j]--;\n    }\n    \n    REP(i, 3)REP(j, 3){\n      cin >> F[i][j];\n      F[i][j]--;\n    }\n\n    sum_set.clear();\n    calc(0, 0, 0);\n\n    if(sum_set.empty()){\n      cout << 0 << endl;\n    }else{\n      vector<int> res;\n      FOREACH(it, sum_set) res.push_back(*it);\n      int sz = res.size();\n      REP(i, sz) cout << res[i] << (i + 1 == sz ? '\\n' : ' ');\n    }\n  }\n  vector<Dice> dices = Dice::all_rots();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <cstring>\nusing namespace std;\n\nclass D{\npublic:\n  int t, s, e, n, w, b;\n  D(){}\n  D(int _t, int _s, int _e, int _n, int _w, int _b){\n    t = _t; s = _s; e = _e; n = _n; w = _w; b = _b;\n  }\n  D moveEast(){\n    return D(w, s, t, n, b, e);\n  }\n  D moveNorth(){\n    return D(s, b, e, t, w, n);\n  }\n  D moveRight(){\n    return D(t, e, n, w, s, b);\n  }\n};\n\nvector<D> allState(){\n  vector<D> res;\n  D d(1, 2, 3, 5, 4, 6);\n\n  for(int i = 0; i < 6; i++){\n    for(int j = 0; j < 4; j++){\n      res.push_back(d);\n      d = d.moveRight();\n    }\n    if(i < 4)  d = d.moveNorth();\n    if(i == 3) d = d.moveEast();\n    if(i == 4) d = d.moveEast().moveEast();\n  }\n\n  return res;\n}\n\nset<int> ans;\nvector<D> v;\nvector<D> t[7][7][7]; //[top][south][west]\nD s[4][4][4]; //[z][y][x]\n\nvoid show(){\n  for(int i = 0; i < 4; i++){\n    for(int j = 0; j < 4; j++){\n      for(int k = 0; k < 4; k++){\n        printf(\"[%d][%d][%d] t:%d, s:%d, w:%d\\n\", i,j,k,s[i][j][k].t, s[i][j][k].s, s[i][j][k].w);\n      }\n    }\n  }\n}\n\nint calc(){\n  int res = 0;\n  for(int i = 1; i < 4; i++){\n    for(int j = 1; j < 4; j++){\n      res += s[i][j][3].e;\n    }\n  }\n  return res;\n}\n\nvoid dfs(int cnt){\n  if(cnt == 27){\n    int tmp = calc();\n    ans.insert(tmp);\n    return;\n  }\n\n  int x = cnt % 3 + 1;\n  int y = (cnt / 3) % 3 + 1;\n  int z = cnt / 9 + 1;\n\n  int tval = s[z - 1][y][x].t;\n  int sval = s[z][y - 1][x].s;\n  int wval = s[z][y][x - 1].w;\n\n  for(int i = 0; i < t[tval][sval][wval].size(); i++){\n    s[z][y][x] = t[tval][sval][wval][i];\n    dfs(cnt + 1);\n  }\n}\n\nint main(){\n  v = allState();\n  for(int i = 0; i < v.size(); i++){\n    for(int tflg = 0; tflg < 2; tflg++){\n      for(int sflg = 0; sflg < 2; sflg++){\n        for(int wflg = 0; wflg < 2; wflg++){\n          t[tflg ? v[i].t : 0][sflg ? v[i].s : 0][wflg ? v[i].w : 0].push_back(v[i]);\n        }\n      }\n    }\n  }\n\n  int T;\n  cin >> T;\n\n  while(T--){\n    memset(s, 0, sizeof(s));\n\n    for(int i = 1; i <= 3; i++){\n      for(int j = 1; j <= 3; j++){\n        int x;\n        cin >> x;\n        s[0][4 - i][j].t = x;\n      }\n    }\n    for(int i = 1; i <= 3; i++){\n      for(int j = 1; j <= 3; j++){\n        int x;\n        cin >> x;\n        s[i][0][j].s = x;\n      }\n    }\n\n    ans.clear();\n    dfs(0);\n\n    if(ans.size() == 0){\n      cout << \"0\\n\";\n    }\n    else{\n      for(set<int>::iterator iter = ans.begin(); iter != ans.end(); iter++){\n        if(iter != ans.begin()) cout << \" \";\n        cout << (*iter);\n      }\n      cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\nusing namespace std;\n\nenum { U, F, R, D, B, L };\nstruct Dice {\n\tint face[6];\n\tDice() { face[F] = 1; face[R] = 2; face[U] = 3; face[B] = 6; face[L] = 5; face[D] = 4; }\n\tint find_face(int f) {\n\t\trep(i, 6) if(face[i] == f) return i;\n\t\treturn -1;\n\t}\n\tvoid turn(int dir) {\n\t\tswitch(dir) {\n\t\tcase R: rotate(U, R, D, L); break;\n\t\tcase B: rotate(U, B, D, F); break;\n\t\tcase L: rotate(U, L, D, R); break;\n\t\tcase F: rotate(U, F, D, B); break;\n\t\tcase U: rotate(F, R, B, L); break; // ??????????????????????¨???????\n\t\tcase D: rotate(F, L, B, R); break; // ??????????????????????¨???????\n\t\tdefault: assert(false);\n\t\t}\n\t}\n\tint & operator[](int n) { return face[n]; }\n\tvector<Dice> all() {\n\t\tvector<Dice> res;\n\t\trep(k, 6) {\n\t\t\trep(i, 4) { res.push_back(*this); turn(R); }\n\t\t\tif(k & 1) turn(U); else turn(F);\n\t\t}\n\t\treturn res;\n\t}\n\tvoid rotate(int a, int b, int c, int d) {\n\t\tint t = face[d];\n\t\tface[d] = face[c]; face[c] = face[b]; face[b] = face[a]; face[a] = t;\n\t}\n};\n\nint u[3][3][3];\nint f[3][3][3];\nint r[3][3][3];\nint ut[3][3][3];\nint ft[3][3][3];\n\nvector<Dice> ds[7][7][7];\nstruct P {\n\tint x, y, z;\n};\n\nvector<P> ps;\nvector<int> ans;\n\nvoid dfs(int n) {\n\t//cout << n << endl;\n\tif(n == 27) {\n\t\tint sum = 0;\n\t\tfor(int y = 0; y < 3; y++) {\n\t\t\tfor(int z = 0; z < 3; z++) {\n\t\t\t\tsum += r[2][y][z];\n\t\t\t}\n\t\t}\n\t\tans.push_back(sum);\n\t\treturn;\n\t}\n\n\tint x = ps[n].x, y = ps[n].y, z = ps[n].z;\n\t// u\n\tint uu = ut[x][y][z] ? u[x][y][z] : 0;\n\tfor(int i = 0; i < 3; i++) {\n\t\tif(y == i) continue;\n\t\tif(u[x][i][z] == 0) continue;\n\t\tif(uu != 0 && uu != u[x][i][z]) return;\n\t\tuu = u[x][i][z];\n\t}\n\t// f\n\tint ff = ft[x][y][z] ? f[x][y][z] : 0;\n\tfor(int i = 0; i < 3; i++) {\n\t\tif(z == i) continue;\n\t\tif(f[x][y][i] == 0) continue;\n\t\tif(ff != 0 && ff != f[x][y][i]) return;\n\t\tff = f[x][y][i];\n\t}\n\t// r\n\tint rr = 0;\n\tfor(int i = 0; i < 3; i++) {\n\t\tif(x == i) continue;\n\t\tif(r[i][y][z] == 0) continue;\n\t\tif(rr != 0 && rr != r[i][y][z]) return;\n\t\trr = r[i][y][z];\n\t}\n\tfor(Dice d : ds[uu][ff][rr]) {\n\t\tu[x][y][z] = d[U];\n\t\tf[x][y][z] = d[F];\n\t\tr[x][y][z] = d[R];\n\t\tdfs(n + 1);\n\t\tif(!ut[x][y][z]) u[x][y][z] = 0;\n\t\tif(!ft[x][y][z]) f[x][y][z] = 0;\n\t\tr[x][y][z] = 0;\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t{\n\t\tDice d;\n\t\tvector<Dice> all = d.all();\n\t\tfor(Dice a : all) {\n\t\t\tfor(int i = 0; i < 7; i++) {\n\t\t\t\tfor(int j = 0; j < 7; j++) {\n\t\t\t\t\tfor(int k = 0; k < 7; k++) {\n\t\t\t\t\t\tif(i != 0 && i != a.face[U]) continue;\n\t\t\t\t\t\tif(j != 0 && j != a.face[F]) continue;\n\t\t\t\t\t\tif(k != 0 && k != a.face[R]) continue;\n\t\t\t\t\t\tds[i][j][k].push_back(a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int x = 0; x < 3; x++) {\n\t\tfor(int y = 0; y < 3; y++) {\n\t\t\tfor(int z = 0; z < 3; z++) {\n\t\t\t\tps.push_back(P{ x, y, z });\n\t\t\t}\n\t\t}\n\t}\n\n\tint n;\n\tcin >> n;\n\twhile(n--) {\n\t\tmemset(u, 0, sizeof u);\n\t\tmemset(f, 0, sizeof f);\n\t\tmemset(r, 0, sizeof r);\n\t\tmemset(ut, 0, sizeof u);\n\t\tmemset(ft, 0, sizeof f);\n\n\t\tfor(int z = 0; z < 3; z++) {\n\t\t\tfor(int x = 0; x < 3; x++) {\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tfor(int y = 0; y < 3; y++) {\n\t\t\t\t\tu[x][y][z] = a;\n\t\t\t\t\tif(a) ut[x][y][z] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int y = 0; y < 3; y++) {\n\t\t\tfor(int x = 0; x < 3; x++) {\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tfor(int z = 0; z < 3; z++) {\n\t\t\t\t\tf[x][y][z] = a;\n\t\t\t\t\tif(a) ft[x][y][z] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans.clear();\n\n\t\tdfs(0);\n\n\t\tsort(ans.begin(), ans.end());\n\t\tans.erase(unique(ans.begin(), ans.end()), ans.end());\n\n\t\tif(ans.size()) {\n\t\t\tfor(int i = 0; i < ans.size(); i++) {\n\t\t\t\tcout << ans[i];\n\t\t\t\tif(i != ans.size() - 1) cout << \" \";\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcout << 0;\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Dice{\nprivate:\n    void roll(int a,int b,int c,int d){\n        swap(x[a],x[b]);\n        swap(x[b],x[d]);\n        swap(x[c],x[d]);\n    }\npublic:\n    int x[6];\n    Dice(){\n        for(int i = 0 ; i < 6 ; i++){\n            x[i] = i+1;\n        }\n    }\n    void roll_N(){ roll(0,1,4,5); }\n    void roll_E(){ roll(0,3,2,5); }\n    void rotation(){ roll(1,2,3,4); }\n    void roll(int top,int front){\n        for(int i = 0 ; i < 2 ; i++){\n            for(int j = 0 ; j < 4 ; j++){\n                roll_N();\n                if(top == x[0]) goto next;\n            }\n            roll_E();\n        }\n    next:\n        for(int i = 0 ; i < 4 ; i++){\n            rotation();\n            if(front == x[1]) break; \n        }\n    }\n    void clear(){ memset(x,0,sizeof(x)); }  \n}; \n\nbool can[60];\nDice d[3][3][3];\nint bit[27];\n\nint calc(){\n    int sum = 0;\n    for(int i = 0 ; i < 3 ; i++){\n        for(int j = 0 ; j < 3 ; j++){\n            sum += d[i][j][2].x[2];\n        }\n    }\n    return sum;\n}\n\nbool check(int v){\n    int a = v/9, b = (v%9)/3, c = (v%9)%3;\n    if(a-1 >= 0){\n        if(d[a][b][c].x[0] + d[a-1][b][c].x[5] != 7){\n            return false;\n        }\n    }\n    if(b-1 >= 0){\n        if(d[a][b][c].x[4] + d[a][b-1][c].x[1] != 7){\n            return false;\n        }\n    }\n    if(c-1 >= 0){\n        if(d[a][b][c].x[3] + d[a][b][c-1].x[2] != 7){\n            return false;\n        }\n    }\n    Dice dice = d[a][b][c];\n    dice.roll(1,2);\n    for(int i = 0 ; i < 6 ; i++){\n        if(dice.x[i] != i+1) return false;\n    }\n    return true;\n}\n\nvoid solve(int v,int p,int S){\n    if(v == 27){\n        can[calc()] = 1;\n        return;\n    }\n    if(p == 6){\n        if(!check(v)) return;\n        if(S == (1<<7)-1){\n            solve(v+1,0,bit[v+1]);\n        }\n        return;\n    }\n    int a = v/9, b = (v%9)/3, c = (v%9)%3;\n    if(a-1 >= 0 && p == 0){\n        if(d[a][b][c].x[p] == 0){\n            int x = 7 - d[a-1][b][c].x[5];\n            if(S >> x & 1) return;\n            d[a][b][c].x[p] = x;\n            int x2 = d[a][b][c].x[5-p];\n            if(x2 == 0 || x + x2 == 7){\n                solve(v,p+1,S|(1<<x));\n            }\n            d[a][b][c].x[p] = 0;\n        }else{\n            if(d[a][b][c].x[p] + d[a-1][b][c].x[5] == 7){\n                solve(v,p+1,S);\n            }\n        }\n        return;\n    }\n    if(b-1 >= 0 && p == 4){\n        if(d[a][b][c].x[p] == 0){\n            int x = 7 - d[a][b-1][c].x[1];\n            if(S >> x & 1) return;\n            d[a][b][c].x[p] = x;\n            int x2 = d[a][b][c].x[5-p];\n            if(x2 == 0 || x + x2 == 7){\n                solve(v,p+1,S|(1<<x));\n            }\n            d[a][b][c].x[p] = 0;\n        }else{\n            if(d[a][b][c].x[p] + d[a][b-1][c].x[1] == 7){\n                solve(v,p+1,S);     \n            }\n        }\n        return;\n    }\n    if(c-1 >= 0 && p == 3){\n        if(d[a][b][c].x[p] == 0){\n            int x = 7 - d[a][b][c-1].x[2];\n            if(S >> x & 1) return;\n            d[a][b][c].x[p] = x;\n            int x2 = d[a][b][c].x[5-p];\n            if(x2 == 0 || x + x2 == 7){\n                solve(v,p+1,S|(1<<x));\n            }\n            d[a][b][c].x[p] = 0;\n        }else{\n            if(d[a][b][c].x[p] + d[a][b][c-1].x[2] == 7){\n                solve(v,p+1,S);\n            }\n        }\n        return;\n    }\n    \n    if(d[a][b][c].x[p] == 0){\n        if(d[a][b][c].x[5-p] != 0){\n            int x = 7 - d[a][b][c].x[5-p];\n            if(S >> x & 1) return;\n            d[a][b][c].x[p] = x;\n            solve(v,p+1,S|(1<<x));\n            d[a][b][c].x[p] = 0;\n        }else{\n            for(int i = 0 ; i < 6 ; i++){\n                d[a][b][c].x[p] = i+1;\n                int x = d[a][b][c].x[5-p];\n                if(!(S >> (i+1) & 1) &&\n                   (x == 0 || x + d[a][b][c].x[p] == 7)){\n                    solve(v,p+1,S|(1<<(i+1)));\n                }\n                d[a][b][c].x[p] = 0;\n            }\n        }\n    }else{\n        int x = d[a][b][c].x[5-p];\n        if(x + d[a][b][c].x[p] == 7){\n            solve(v,p+1,S);\n        }\n    }\n}\n\nvoid print(){\n    bool sp = false;\n    for(int i = 0 ; i < 60 ; i++){\n        if(can[i]){\n            if(sp) cout << \" \";\n            sp = true;\n            cout << i;\n        }\n    }\n    if(!sp) cout << 0;\n    cout << endl;\n}\n\nvoid init(){\n    fill(bit,bit+27,1);\n    memset(can,0,sizeof(can));\n    for(int i = 0 ; i < 3 ; i++){\n        for(int j = 0 ; j < 3 ; j++){\n            for(int k = 0 ; k < 3 ; k++){\n                d[i][j][k].clear();\n            }\n        }\n    }\n}\n\nint main(){\n    int N;\n    cin >> N;\n    while(N--){\n        init();\n        int in;\n        for(int i = 0 ; i < 3 ; i++){\n            for(int j = 0 ; j < 3 ; j++){\n                cin >> in;\n                if(in != 0){\n                    d[0][i][j].x[0] = in;\n                    d[0][i][j].x[5] = 7-in;\n                    bit[3*i+j] |= 1<<in;\n                    bit[3*i+j] |= 1<<(7-in);\n                }\n            }\n        }\n        for(int i = 0 ; i < 3 ; i++){\n            for(int j = 0 ; j < 3 ; j++){\n                cin >> in;\n                if(in != 0){\n                    d[i][2][j].x[1] = in;\n                    d[i][2][j].x[4] = 7-in;\n                    bit[9*i+6+j] |= 1<<in;\n                    bit[9*i+6+j] |= 1<<(7-in);\n                }\n            }\n        }\n        solve(0,0,bit[0]);\n        print();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct die{\n  int p[6];\n  void init(){\n    for(int i=0;i<6;i++)p[i]=i+1;\n  }\n  void roll(int a,int b,int c,int d){\n    int tmp=p[a];\n    p[a]=p[b];\n    p[b]=p[c];\n    p[c]=p[d];\n    p[d]=tmp;\n  }\n  void ra(){\n    roll(0,4,5,1);\n  }\n  void rb(){\n    roll(0,3,5,2);\n  }\n  void rc(){\n    roll(1,2,4,3);\n  }\n};\n\nvector<die> t;\n\ndie G[4][4][4];\n\nbool check(int a,int b){\n  if(a==-1||b==-1)return true;\n  else return (a+b==7);\n}\n\nvector<int> ans;\n\nvoid rec(int x,int y,int z){\n  if(x==4){\n    rec(1,y+1,z);\n    return;\n  }\n  if(y==4){\n    rec(1,1,z+1);\n    return;\n  }\n  if(z==4){\n    int sum=0;\n    for(int i=1;i<=3;i++)\n      for(int j=1;j<=3;j++)\n\tsum+=G[3][i][j].p[3];\n    ans.push_back(sum);\n    return;\n  }\n\n  for(int i=0;i<24;i++){\n    G[x][y][z]=t[i];\n    if(!check(G[x][y][z].p[0],G[x][y][z-1].p[5]))continue;\n    if(!check(G[x][y][z].p[3],G[x-1][y][z].p[2]))continue;\n    if(!check(G[x][y][z].p[1],G[x][y-1][z].p[4]))continue;\n    rec(x+1,y,z);\n  }\n}\n\nvoid init(){\n  for(int i=0;i<4;i++)\n    for(int j=0;j<4;j++)\n      for(int k=0;k<4;k++)\n\tfor(int x=0;x<6;x++)\n\t  G[i][j][k].p[x]=-1;\n}\n\nint main(){\n  die d;\n  d.init();\n  for(int i=0;i<6;i++){\n    if(i%2)d.ra();\n    else d.rb();\n    for(int j=0;j<4;j++){\n      d.rc();\n      t.push_back(d);\n    }\n  }\n  \n  int Tc;\n  cin>>Tc;\n  while(Tc--){\n    init();\n\n    int a;\n    for(int i=1;i<=3;i++){\n      for(int j=1;j<=3;j++){\n\tcin>>a;\n\tif(a==0)continue;\n\tG[j][0][i].p[4]=7-a;\n      }\n    }\n    for(int i=3;i>=1;i--){\n      for(int j=1;j<=3;j++){\n\tcin>>a;\n\tif(a==0)continue;\n\tG[j][i][0].p[5]=7-a;\n      }\n    }\n    ans.clear();\n    rec(1,1,1);\n    if(ans.size()==0)cout<<0<<endl;\n    sort(ans.begin(),ans.end());\n    for(int i=0;i<(int)ans.size();i++){\n      if(i&&ans[i]==ans[i-1])continue;\n      if(i)cout<<' ';\n      cout<<ans[i];\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int TOP = 0,FRONT = 1,LEFT = 3, RIGHT = 2,BACK = 4,BOTTOM = 5;\n\nclass Dice{\npublic:\n  int TOP = 0,FRONT = 1,LEFT = 3, RIGHT = 2,BACK = 4,BOTTOM = 5;\n  vector<int> val;\n  Dice():val(6){for(int i=0;i<6;i++) val[i] = i;}\n  Dice(int val[6]){for(int i=0;i<6;i++) this->val[i] = val[i];}\n  Dice(vector<int> val):val(val){assert(val.size() == 6);}\n  int& operator [](int a){return val[a];}\n  bool operator == (Dice a)const{\n    for(int i=0;i<6;(i%2? a.rotN():a.rotE()),i++)\n      for(int j=0;j<4;j++){\n        if(val == a.val) return 1;\n        a.rotCW();\n      }\n    return 0;\n  }\n\n  void rot(string s){\n    if(s == \"N\" || s == \"B\") rotN();\n    else if(s == \"S\" || s == \"F\") rotS();\n    else if(s == \"E\" || s == \"R\") rotE();\n    else if(s == \"W\" || s == \"L\") rotW();\n    else if(s == \"CW\") rotCW();\n    else if(s == \"CCW\") rotCCW();\n    else assert(!\"rot error\"); /*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/\n  }\n\n  void rot(char ch){rot(string(1,ch));}\n  \n  //奥に転がす\n  void rotN(){\n    swap(val[TOP],val[FRONT]);\n    swap(val[FRONT],val[BOTTOM]);\n    swap(val[BOTTOM],val[BACK]);\n  }\n\n  //手前に転がす\n  void rotS(){\n    //rotN(),rotN(),rotN();\n    swap(val[TOP],val[BACK]);\n    swap(val[BACK],val[BOTTOM]);\n    swap(val[BOTTOM],val[FRONT]);\n  }\n  \n  //右に転がす\n  void rotE(){\n    swap(val[TOP],val[LEFT]);\n    swap(val[LEFT],val[BOTTOM]);\n    swap(val[BOTTOM],val[RIGHT]);\n  }\n\n  //左に転がす\n  void rotW(){\n    //rotE(),rotE(),rotE();\n    swap(val[TOP],val[RIGHT]);\n    swap(val[RIGHT],val[BOTTOM]);\n    swap(val[BOTTOM],val[LEFT]);\n  }\n\n  //上から見て時計回りに回す\n  void rotCW(){\n    swap(val[FRONT],val[RIGHT]);\n    swap(val[RIGHT],val[BACK]);\n    swap(val[BACK],val[LEFT]);\n  }\n\n  //上からみて反時計回りに回す。\n  void rotCCW(){\n    //rotCW(),rotCW(),rotCW();\n    swap(val[FRONT],val[LEFT]);\n    swap(val[LEFT],val[BACK]);\n    swap(val[BACK],val[RIGHT]);\n  }\n\n  void init(int top,int front){\n    for(int i=0;i<6;(i%2? rotN():rotE()),i++)\n      for(int j=0;j<4;j++){\n        if(val[TOP] == top && val[FRONT] == front) return;\n        rotCW();\n      }\n    assert(!\"init error\");\n  }\n};\n\nDice dice[27];\n\nset<int> ans;\n\nbool check1(int x){\n  \n  if( x % 3 != 0 && dice[x].val[LEFT] + dice[x-1].val[RIGHT] != 5 ) return false;\n  \n  if( x % 9 >= 3 && dice[x].val[TOP] + dice[x-3].val[BOTTOM] != 5 ) return false;\n  \n  if( x >= 9 && dice[x].val[FRONT] + dice[x-9].val[BACK] != 5 ) return false;\n  \n  return true;\n}\n\nint T[9], F[9];\n\nbool check2(){\n  \n  int t[9] = {18,19,20,9,10,11,0,1,2};\n  \n  for(int i=0;i<9;i++){\n    if( T[i] == 0 ) continue;\n    if( dice[t[i]].val[TOP] + 1 != T[i] ) return false;\n  }\n  \n  for(int i=0;i<9;i++){\n    if( F[i] == 0 ) continue;\n    if( dice[i].val[FRONT] + 1 != F[i] ) return false;\n  }\n  \n  return true;\n}\n\nint cal(){\n  int res = 0;\n  for(int i=2;i<27;i+=3) res += dice[i].val[RIGHT] + 1;\n  return res;\n}\n\nvoid dfs(int x){\n  \n  if( x == 27 ){\n    \n    if( check2() == true ) ans.insert(cal());\n    \n    return;\n  }\n  \n  int top[6] = {0,1,2,3,4,5}, front[6] = {1,2,4,0,0,1};\n\n  for(int i=0;i<6;i++){\n    \n    dice[x].init( top[i], front[i] );\n    \n    for(int j=0;j<4;j++){\n\n      dice[x].rotCW();\n      \n      if( check1(x) == false ) continue;\n      \n      dfs( x + 1 );\n      \n    }\n    \n  }\n  \n}\n\nsigned main(){\n  \n  int N;\n  cin>>N;\n\n  while(N--){\n    \n    for(int i=0;i<9;i++) cin>>T[i];\n    \n    for(int i=0;i<9;i++) cin>>F[i];\n    \n    ans.clear();\n    \n    dfs(0);\n    \n    if( (int)ans.size() == 0 ) cout<<0<<endl;\n    else{\n      \n      int flag = 0;\n      \n      for(int p : ans){\n\tif( flag ) cout<<' ';\n\tcout<<p;\n\tflag = 1;\n      }\n      \n      cout<<endl;\n      \n    }\n    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n// (top,front)\nint R[7][7]={\n    {-1, -1, -1, -1, -1, -1, -1},\n    {-1, -1,  3,  5,  2,  4, -1},\n    {-1,  4, -1,  1,  6, -1,  3},\n    {-1,  2,  6, -1, -1,  1,  5},\n    {-1,  5,  1, -1, -1,  6,  2},\n    {-1,  3, -1,  6,  1, -1,  4},\n    {-1, -1,  4,  2,  5,  3, -1},\n};\n\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nconst vvi I(3,vi(3));\n\nvvi T,F;\nvector<int> ans;\n\nvoid check(){\n    vvi r(I);\n    int rsum = 0;\n    rep(i,3)rep(j,3){\n        r[i][j] = R[T[j][0]][F[i][0]];\n        if(r[i][j]==-1) return;\n        rsum += r[i][j];\n    }\n\n    rep(ti,3)rep(fi,3)rep(x,3){\n        int rv = r[fi][ti];\n\n        bool found = false;\n        int tv = T[ti][x], fv = F[fi][x];\n        for(int i=1; i<=6; ++i)for(int j=1; j<=6; ++j){\n            if(tv!=0 && tv!=i) continue;\n            if(fv!=0 && fv!=j) continue;\n\n            if(R[i][j]==rv) found = true;\n        }\n        if(!found) return;\n    }\n\n    ans.pb(rsum);\n}\n\nvoid dfs(int d){\n    if(d==6){\n        check();\n        return;\n    }\n\n    if(d<3){\n        if(T[d][0]==0){\n            for(int i=1; i<=6; ++i){\n                T[d][0] = i;\n                dfs(d+1);\n                T[d][0] = 0;\n            }\n        }\n        else dfs(d+1);\n    }\n    else{\n        if(F[d-3][0]==0){\n            for(int i=1; i<=6; ++i){\n                F[d-3][0] = i;\n                dfs(d+1);\n                F[d-3][0] = 0;\n            }\n        }\n        else dfs(d+1);\n    }\n}\n\nvoid solve(){\n    T = I;\n    F = I;\n    rep(i,3)rep(j,3) cin >>T[i][j];\n    rep(i,3)rep(j,3) cin >>F[i][j];\n\n    ans.clear();\n    dfs(0);\n\n    sort(all(ans));\n    ans.erase(unique(all(ans)), ans.end());\n    int n = ans.size();\n    if(n==0) cout << 0 << endl;\n    else rep(i,n) cout << ans[i] << \" \\n\"[i==n-1];\n}\n\nint main(){\n    int n;\n    cin >>n;\n    rep(i,n) solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\n//top,frontからrightを決定\nint ident(int a, int b) {\n\tint c;\n\tif (a == 1) {\n\t\tif (b == 2)c = 3;\n\t\telse if (b == 3)c = 5;\n\t\telse if (b == 5)c = 4;\n\t\telse c = 2;\n\t}\n\telse if (a == 2) {\n\t\tif (b == 1)c = 4;\n\t\telse if (b == 4)c = 6;\n\t\telse if (b == 6)c = 3;\n\t\telse c = 1;\n\t}\n\telse if (a == 3) {\n\t\tif (b == 1)c = 2;\n\t\telse if (b == 2)c = 6;\n\t\telse if (b == 5)c = 1;\n\t\telse c = 5;\n\t}\n\telse if (a == 4) {\n\t\tif (b == 1)c = 5;\n\t\telse if (b == 5)c = 6;\n\t\telse if (b == 6)c = 2;\n\t\telse c = 1;\n\t}\n\telse if (a == 5) {\n\t\tif (b == 1)c = 3;\n\t\telse if (b == 3)c = 6;\n\t\telse if (b == 6)c = 4;\n\t\telse c = 1;\n\t}\n\telse {\n\t\tif (b == 2)c = 4;\n\t\telse if (b == 3)c = 2;\n\t\telse if (b == 5)c = 3;\n\t\telse c = 5;\n\t}\n\treturn c;\n}\nint calc(int x) {\n\tint ret = 0;\n\trep (i,9) {\n\t\tret += x % 6 + 1;\n\t\tx /= 6;\n\t}\n\treturn ret;\n}\n//46656=6^6\nint t[3][3], f[3][3];\nint t3[9];\nvoid solve() {\n\tt3[0] = 1;\n\trep(i, 8)t3[i + 1] = t3[i] * 6;\n\tint n; cin >> n; \n\trep(aa, n) {\n\t\tmap<int, bool> mp[3];\n\t\tvector<int> c;\n\t\trep(i, 3) {\n\t\t\trep(j, 3) {\n\t\t\t\tcin >> t[i][j];\n\t\t\t}\n\t\t}\n\t\trep(i, 3) {\n\t\t\trep(j, 3) {\n\t\t\t\tcin >> f[i][j];\n\t\t\t}\n\t\t}\n\t\trep(i, 3) {\n\t\t\trep(j, 46656) {\n\t\t\t\tvector<int> v;\n\t\t\t\tint cop = j;\n\t\t\t\t\n\t\t\t\trep (k,6) {\n\t\t\t\t\tv.push_back(cop % 6 + 1); cop /= 6;\n\t\t\t\t}\n\t\t\t\tbool valid = true;\n\t\t\t\trep(k, 3) {\n\t\t\t\t\tif (t[k][i] > 0 && t[k][i] != v[k])valid = false;\n\t\t\t\t}\n\t\t\t\trep(k, 3) {\n\t\t\t\t\tif (f[k][i] > 0 && f[k][i] != v[3 + k])valid = false;\n\t\t\t\t}\n\t\t\t\tif (!valid)continue;\n\t\t\t\tint sum = 0;\n\t\t\t\trep(k, 3) {\n\t\t\t\t\trep(l, 3) {\n\t\t\t\t\t\tif (v[k]+v[3+l]==7||v[k]==v[3+l]) {\n\t\t\t\t\t\t\tvalid = false; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint u = ident(v[k], v[3 + l]);\n\t\t\t\t\t\tu--;\n\t\t\t\t\t\tsum += t3[3*k + l] * u;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!valid)continue;\n\t\t\t\tmp[i][sum] = true;\n\t\t\t\tif (i == 0)c.push_back(sum);\n\t\t\t}\n\t\t}\n\t\tsort(c.begin(), c.end());\n\t\tc.erase(unique(c.begin(), c.end()), c.end());\n\t\tvector<int> ans;\n\t\trep(i, c.size()) {\n\t\t\tif (mp[1][c[i]] && mp[2][c[i]]) {\n\t\t\t\tans.push_back(calc(c[i]));\n\t\t\t}\n\t\t}\n\t\tsort(ans.begin(), ans.end());\n\t\tans.erase(unique(ans.begin(), ans.end()), ans.end());\n\t\trep(i, ans.size()) {\n\t\t\tif (i > 0)cout << \" \";\n\t\t\tcout << ans[i];\n\t\t}\n\t\tif (ans.size() == 0)cout << 0;\n\t\tcout << endl;\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct Dice\n{\n  // int x, y;\n  int l, r, f, b, d, u;\n\n  void RollF()\n  {\n    //  --y;\n    int buff = d;\n    d = f;\n    f = u;\n    u = b;\n    b = buff;\n  }\n\n  void RollB()\n  {\n    // ++y;\n    int buff = d;\n    d = b;\n    b = u;\n    u = f;\n    f = buff;\n  }\n\n  void RollL()\n  {\n    // --x;\n    int buff = d;\n    d = l;\n    l = u;\n    u = r;\n    r = buff;\n  }\n\n  void RollR()\n  {\n    //  ++x;\n    int buff = d;\n    d = r;\n    r = u;\n    u = l;\n    l = buff;\n  }\n\n  void RollClock()\n  {\n    int buff = d;\n    d = r;\n    r = u;\n    u = l;\n    l = buff;\n  }\n\n  void RollCounterClock()\n  {\n    int buff = d;\n    d = l;\n    l = u;\n    u = r;\n    r = buff;\n  }\n\n\n  vector< Dice > makeDice()\n  {\n    vector< Dice > ret;\n    for(int i = 0; i < 6; i++) {\n      Dice d(*this);\n      if(i == 1) d.RollClock();\n      if(i == 2) d.RollCounterClock();\n      if(i == 3) d.RollClock(), d.RollClock();\n      if(i == 4) d.RollL();\n      if(i == 5) d.RollR();\n      for(int j = 0; j < 4; j++) {\n        ret.emplace_back(d);\n        d.RollF();\n      }\n    }\n    return (ret);\n  }\n};\n\nint latte[3][3], malta[3][3];\nset< int > st;\nDice dice[3][3][3];\nvector< Dice > beet;\n\nvoid dfs(int idx)\n{\n  if(idx == 27) {\n    int ret = 0;\n    for(int i = 0; i < 3; i++) {\n      for(int j = 0; j < 3; j++) {\n        ret += dice[i][2][j].r;\n      }\n    }\n    st.emplace(ret);\n    return;\n  }\n  int i = idx / 3 % 3, j = idx % 3, k = idx / 9;\n  for(auto &s : beet) {\n    dice[i][j][k] = s;\n    if(k == 0 && latte[i][j] && latte[i][j] != dice[i][j][k].u) continue;\n    if(i == 2 && malta[k][j] && malta[k][j] != dice[i][j][k].f) continue;\n    if(i && dice[i - 1][j][k].b + dice[i][j][k].f != 7) continue;\n    if(j && dice[i][j - 1][k].l + dice[i][j][k].r != 7) continue;\n    if(k && dice[i][j][k - 1].d + dice[i][j][k].u != 7) continue;\n    dfs(idx + 1);\n  }\n}\n\nint main()\n{\n  beet = ((Dice) {4, 3, 2, 5, 6, 1}).makeDice();\n\n  int T;\n  cin >> T;\n  while(T--) {\n    for(int i = 0; i < 3; i++) {\n      for(int j = 0; j < 3; j++) {\n        cin >> latte[i][j];\n      }\n    }\n    for(int i = 0; i < 3; i++) {\n      for(int j = 0; j < 3; j++) {\n        cin >> malta[i][j];\n      }\n    }\n    dfs(0);\n    bool first = false;\n    if(st.empty()) {\n      cout << 0 << endl;\n    } else {\n      for(auto &s : st) {\n        if(first++) cout << \" \";\n        cout << s;\n      }\n      cout << endl;\n      st.clear();\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n#define REP(i, n) for(int (i)=0; (i)<(n); (i)++)\nint d[6][4]={{2,3,5,4}, {1,4,6,3}, {1,2,6,5}, {1,5,6,2}, {1,3,6,4}, {2,4,5,3}};\n\nstruct dice{ int t,r; }; //topの数字、回転数\ndice cube[3][3][3];\nint t[3][3],f[3][3];\nbool ans[55];\n\nvoid solve(int x, int y, int z){\n\tif(z==3){\n\t\tint sum=0;\n\t\tREP(i,3) REP(j,3){\n\t\t\tsum += d[cube[2][i][j].t][(cube[2][i][j].r+1)%4];\n\t\t}\n\t\tans[sum] = true;\n\t\treturn;\n\t}\n\t\n\tint nx=x, ny=y, nz=z;\n\tif(x<2) nx++;\n\telse{\n\t\tnx = 0;\n\t\tif(y<2) ny++;\n\t\telse{ ny = 0; nz++; }\n\t}\n\t\n\tREP(top,6) REP(rot,4){\n\t\t//上面・前面不一致\n\t\tif(z==0 && t[y][x]!=0 && (top+1)!=t[y][x]) continue;\n\t\tif(y==2 && f[z][x]!=0 && d[top][rot]!=f[z][x]) continue;\n\t\t//隣接面不一致\n\t\tif(x!=0 && d[cube[x-1][y][z].t][(cube[x-1][y][z].r+1)%4]!=d[top][(rot+1)%4]) continue;\n\t\tif(y!=0 && d[cube[x][y-1][z].t][(cube[x][y-1][z].r)]!=d[top][rot]) continue;\n\t\tif(z!=0 && cube[x][y][z-1].t != top) continue;\n\t\tcube[x][y][z].t = top;\n\t\tcube[x][y][z].r = rot;\n\t\tsolve(nx, ny, nz);\n\t}\n}\n\n\nint main(){\n\tint rep;\n\tcin >> rep;\n\tfor(int r=0; r<rep; r++){\n\t\tmemset(ans, 0, sizeof(ans));\n\t\tREP(i,3) REP(j,3) cin >> t[i][j];\n\t\tREP(i,3) REP(j,3) cin >> f[i][j];\n\t\tsolve(0, 0, 0);\n\t\tbool nosol = true;\n\t\tREP(i,55){\n\t\t\tif(ans[i]) nosol = false;\n\t\t}\n\t\tif(nosol){\n\t\t\tcout << 0 << endl;\n\t\t}else{\n\t\t\tvector<int> a;\n\t\t\tREP(i,55){\n\t\t\t\tif(ans[i]) a.push_back(i);\n\t\t\t}\n\t\t\tREP(i, (int)a.size()-1) cout << a[i] << \" \";\n\t\t\tcout << a[a.size()-1] << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nenum FACE { TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT };\nclass dice {\nprivate:\n\tint num[6];\n\n\tvoid roll(FACE a, FACE b, FACE c, FACE d) {\n\t\tswap(num[a], num[b]);\n\t\tswap(num[b], num[c]);\n\t\tswap(num[c], num[d]);\n\t}\n\npublic:\n\tdice() {\n\t\tnum[TOP] = 1;\n\t\tnum[BOTTOM] = 6;\n\t\tnum[FRONT] = 2;\n\t\tnum[BACK] = 5;\n\t\tnum[RIGHT] = 3;\n\t\tnum[LEFT] = 4;\n\t}\n\n\tvoid set(int top, int front) {\n        if(num[RIGHT] == top || num[LEFT] == top) west();\n        while(num[TOP] != top) north();\n        while(num[FRONT] != front) ccw();\n\t}\n\n\tconst int &operator[](FACE f) const { return num[f]; }\n\n\tvoid north() { roll(TOP, BACK, BOTTOM, FRONT); }\n\tvoid east()  { roll(TOP, LEFT, BOTTOM, RIGHT); }\n\tvoid west()  { roll(TOP, RIGHT, BOTTOM, LEFT); }\n\tvoid south() { roll(TOP, FRONT, BOTTOM, BACK); }\n\tvoid ccw()   { roll(BACK, RIGHT, FRONT, LEFT); }\n\tvoid cw()    { roll(BACK, LEFT, FRONT, RIGHT); }\n};\n\n\nint right_face[7][7];\nvoid init() {\n\tdice d;\n\tfor(int t = 1; t <= 6; ++t) {\n\t\tfor(int f = 1; f <= 6; ++f) {\n\t\t\tif(t == f || t + f == 7) continue;\n\t\t\td.set(t, f);\n\t\t\tright_face[t][f] = d[RIGHT];\n\t\t}\n\t}\n}\n\nint top[3][3][3];\nint front[3][3][3];\n\nvector<int> ans;\n\nvoid dfs(int x, int y, int z) {\n\tif(z == 3) {\n\t\tint sum = 0;\n\t\tfor(int z = 0; z < 3; ++z) {\n\t\t\tfor(int y = 0; y < 3; ++y) {\n\t\t\t\tsum += right_face[top[z][y][2]][front[z][y][2]];\n\t\t\t}\n\t\t}\n\t\tans.emplace_back(sum);\n\t}\n\telse if(y == 3) {\n\t\tdfs(0, 0, z + 1);\n\t}\n\telse if(x == 3) {\n\t\tdfs(0, y + 1, z);\n\t}\n\telse {\n\t\tconst int p_top = top[z][y][x];\n\t\tconst int p_front = front[z][y][x];\n\t\tfor(int t = 1; t <= 6; ++t) {\n\t\t\tif(top[z][y][x] && top[z][y][x] != t) continue;\n\t\t\tif(z && top[z - 1][y][x] != t) continue;\n\n\t\t\tfor(int f = 1; f <= 6; ++f) {\n\t\t\t\tif(t == f || t + f == 7) continue;\n\t\t\t\tif(front[z][y][x] && front[z][y][x] != f) continue;\n\t\t\t\tif(y && front[z][y - 1][x] != f) continue;\n\t\t\t\tif(x && right_face[top[z][y][x - 1]][front[z][y][x - 1]] != right_face[t][f]) continue;\n\n\t\t\t\ttop[z][y][x] = t;\n\t\t\t\tfront[z][y][x] = f;\n\t\t\t\tdfs(x + 1, y, z);\n\t\t\t\ttop[z][y][x] = p_top;\n\t\t\t\tfront[z][y][x] = p_front;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tans.clear();\n\tmemset(top, 0, sizeof(top));\n\tmemset(front, 0, sizeof(front));\n\n\tfor(int y = 2; y >= 0; --y) {\n\t\tfor(int x = 0; x < 3; ++x) {\n\t\t\tcin >> top[0][y][x];\n\t\t}\n\t}\n\n\tfor(int z = 0; z < 3; ++z) {\n\t\tfor(int x = 0; x < 3; ++x) {\n\t\t\tcin >> front[z][0][x];\n\t\t}\n\t}\n\n\tdfs(0, 0, 0);\n\tif(ans.size()) {\n\t\tsort(ans.begin(), ans.end());\n\t\tans.erase(unique(ans.begin(), ans.end()), ans.end());\n\t\tfor(unsigned i = 0; i < ans.size(); ++i) {\n\t\t\tcout << ans[i] << (i + 1 == ans.size() ? \"\\n\" : \" \");\n\t\t}\n\t}\n\telse {\n\t\tcout << \"0\\n\";\n\t}\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tinit();\n\n\tint n;\n\tcin >> n;\n\n\twhile(n--) solve();\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { 1, -1, 0, 0,0,0 }; const int dy[] = { 0,0, 1, -1, 0,0 };const int dz[] = { 0,0,0, 0, 1, -1 };\n\nconst int side[6][4] = {\n\t{ 2, 4, 5, 3 },{ 1, 3, 6, 4 },{ 1, 5, 6, 2 },{ 1, 2, 6, 5 },{ 1, 4, 6, 3 },{ 2, 3, 5, 4 }\n};\nconst int dice_right[6][6] = {\n\t{0,3,5,2,4,0},\n\t{ 4,0,1,6,0,3 },\n\t{ 2,6,0,0,1,5 },\n\t{ 5,1,0,0,6,2 },\n\t{ 3,0,6,1,0,4 },\n\t{ 0,4,2,5,3,0 }\n};\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nvi ans;\nvector<vvi> dices(3, vvi(3, vi(3)));//men tate yoko\nbool kakutei() {\n\tbool change = true;\n\twhile (change) {\n\t\tchange = false;\n\t\tREP(i, 3) {\n\t\t\tREP(j, 3) {\n\t\t\t\tif (dices[0][i][j] == 0) {\n\t\t\t\t\tREP(k, 3) {\n\t\t\t\t\t\tif (dices[1][k][j] > 0 && dices[2][k][2 - i] > 0) {\n\t\t\t\t\t\t\tdices[0][i][j] = dice_right[dices[1][k][j] - 1][dices[2][k][2 - i] - 1];\n\t\t\t\t\t\t\tif (dices[0][i][j] == 0)\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\tchange = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dices[1][i][j] == 0) {\n\t\t\t\t\tREP(k, 3) {\n\t\t\t\t\t\tif (dices[0][k][j] > 0 && dices[2][i][2 - k] > 0) {\n\t\t\t\t\t\t\tdices[1][i][j] = dice_right[dices[2][i][2 - k] - 1][dices[0][k][j] - 1];\n\t\t\t\t\t\t\tif (dices[1][i][j] == 0)\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\tchange = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dices[2][i][j] == -1) {\n\t\t\t\t\tREP(k, 3) {\n\t\t\t\t\t\tif (dices[0][2 - j][k] > 0 && dices[1][i][k] > 0) {\n\t\t\t\t\t\t\tdices[2][i][j] = dice_right[dices[0][2 - j][k] - 1][dices[1][i][k] - 1];\n\t\t\t\t\t\t\tif (dices[2][i][j] == 0)\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\tchange = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nvoid dfs() {\n\tvector<vvi> copy_dices = dices;\n\tREP(i, 3) {\n\t\tREP(j, 3) {\n\t\t\tif (dices[0][i][j] == 0) {\n\t\t\t\tREP(k, 6) {\n\t\t\t\t\tbool clear = true;\n\t\t\t\t\tREP(l, 3) {\n\t\t\t\t\t\tif (dices[1][l][j] > 0)\n\t\t\t\t\t\t\tif (dices[1][l][j] == k + 1 || dices[1][l][j] + k + 1 == 7)\n\t\t\t\t\t\t\t\tclear = false;\n\t\t\t\t\t\tif (dices[2][l][2 - i] > 0)\n\t\t\t\t\t\t\tif (dices[2][l][2 - i] == k + 1 || dices[2][l][2 - i] + k + 1 == 7)\n\t\t\t\t\t\t\t\tclear = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (clear) {\n\t\t\t\t\t\tdices[0][i][j] = k + 1;\n\t\t\t\t\t\tif (!kakutei()) {\n\t\t\t\t\t\t\tdices = copy_dices;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tdfs();\n\t\t\t\t\t\tdices = copy_dices;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, 3) {\n\t\tREP(j, 3) {\n\t\t\tif (dices[1][i][j] == 0) {\n\t\t\t\tREP(k, 6) {\n\t\t\t\t\tbool clear = true;\n\t\t\t\t\tREP(l, 3)\n\t\t\t\t\t\tif (dices[0][l][j] == k + 1 || dices[0][l][j] + k + 1 == 7)\n\t\t\t\t\t\t\tclear = false;\n\t\t\t\t\tif (clear) {\n\t\t\t\t\t\tdices[1][i][j] = k + 1;\n\t\t\t\t\t\tif (!kakutei()) {\n\t\t\t\t\t\t\tdices = copy_dices;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdfs();\n\t\t\t\t\t\tdices = copy_dices;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tREP(i, 3) {\n\t\tREP(j, 3) {\n\t\t\tsum += dice_right[dices[0][2 - j][2] - 1][dices[1][i][2] - 1];\n\t\t}\n\t}\n\tans.push_back(sum);\n}\nint main() {\n\tint kurikaesu;\n\tcin >> kurikaesu;\n\twhile (kurikaesu--) {\n\t\tans.clear();\n\t\tREP(i, 3) {\n\t\t\tREP(j, 3) {\n\t\t\t\tREP(k, 3) {\n\t\t\t\t\tdices[i][j][k] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, 3) {\n\t\t\tREP(j, 3) {\n\t\t\t\tcin >> dices[0][i][j];\n\t\t\t}\n\t\t}\n\t\tREP(i, 3) {\n\t\t\tREP(j, 3) {\n\t\t\t\tcin >> dices[1][i][j];\n\t\t\t}\n\t\t}\n\t\tif (kakutei())\n\t\t\tdfs();\n\t\telse\n\t\t\tgoto emp;\n\t\tSORT(ans);\n\t\tans.erase(unique(ans.begin(), ans.end()), ans.end());\n\t\tREP(i, ans.size()) {\n\t\t\tcout << ans[i];\n\t\t\tif (i != ans.size() - 1)\n\t\t\t\tcout << ' ';\n\t\t}\nemp:\n\t\tif (ans.empty())\n\t\t\tcout << 0;\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct die{\n  int p[6];\n  void init(){\n    for(int i=0;i<6;i++)p[i]=i+1;\n  }\n  void roll(int a,int b,int c,int d){\n    int tmp=p[a];\n    p[a]=p[b];\n    p[b]=p[c];\n    p[c]=p[d];\n    p[d]=tmp;\n  }\n  void ra(){\n    roll(0,4,5,1);\n  }\n  void rb(){\n    roll(0,3,5,2);\n  }\n  void rc(){\n    roll(1,2,4,3);\n  }\n};\n\nvector<die> t;\n\ndie G[4][4][4];\n\nbool check(int a,int b){\n  if(a==-1||b==-1)return true;\n  else return (a+b==7);\n}\n\nvector<int> ans;\n\nvoid rec(int x,int y,int z){\n  if(x==4){\n    rec(1,y+1,z);\n    return;\n  }\n  if(y==4){\n    rec(1,1,z+1);\n    return;\n  }\n  if(z==4){\n    int sum=0;\n    for(int i=1;i<=3;i++)\n      for(int j=1;j<=3;j++)\n\tsum+=G[3][i][j].p[3];\n    ans.push_back(sum);\n    return;\n  }\n\n  for(int i=0;i<24;i++){\n    G[x][y][z]=t[i];\n    if(!check(G[x][y][z].p[0],G[x][y][z-1].p[5]))continue;\n    if(!check(G[x][y][z].p[3],G[x-1][y][z].p[2]))continue;\n    if(!check(G[x][y][z].p[1],G[x][y-1][z].p[4]))continue;\n    rec(x+1,y,z);\n  }\n}\n\nvoid init(){\n  for(int i=0;i<4;i++)\n    for(int j=0;j<4;j++)\n      for(int k=0;k<4;k++)\n\tfor(int x=0;x<6;x++)\n\t  G[i][j][k].p[x]=-1;\n}\n\nint main(){\n  die d;\n  d.init();\n  for(int i=0;i<6;i++){\n    if(i%2)d.ra();\n    else d.rb();\n    for(int j=0;j<4;j++){\n      d.rc();\n      t.push_back(d);\n    }\n  }\n  \n  int Tc;\n  cin>>Tc;\n  while(Tc--){\n    init();\n\n    int a;\n    for(int i=1;i<=3;i++){\n      for(int j=1;j<=3;j++){\n\tcin>>a;\n\tif(a==0)continue;\n\tG[j][0][i].p[4]=7-a;\n      }\n    }\n    for(int i=3;i>=1;i--){\n      for(int j=1;j<=3;j++){\n\tcin>>a;\n\tif(a==0)continue;\n\tG[j][i][0].p[5]=7-a;\n      }\n    }\n    ans.clear();\n    rec(1,1,1);\n    if(ans.size()==0)cout<<0<<endl;\n    else{\n      sort(ans.begin(),ans.end());\n      for(int i=0;i<(int)ans.size();i++){\n\tif(i&&ans[i]==ans[i-1])continue;\n\tif(i)cout<<' ';\n\tcout<<ans[i];\n      }\n      cout<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntemplate <class T>\nstruct dice {\n  T t,b,n,s,e,w;              // top bottom north south east west\n  dice() {}\n  dice(T t, T b, T n, T s, T e, T w) : t(t),b(b),n(n),s(s),e(e),w(w) {}\n  void roll(T &a, T &b, T &c, T &d) { swap(a,b); swap(b,c); swap(c,d); }\n  void roll_x() { roll(t, n, b, s); }\n  void roll_y() { roll(t, w, b, e); }\n  void roll_z() { roll(s, e, n, w); }\n  vector<dice> all_rolls() {\n    vector<dice> ret;\n    for (int k=0; k<6; (k&1?roll_y():roll_x()),++k)\n      for (int i=0; i<4; roll_z(), ++i)\n        ret.push_back(*this);\n    return ret;\n  }\n};\n \ndice<int> di[3][3][3];              // ツ偲ィツ前ツづ個債カツ湘」ツつェツ個エツ点ツ、ツ右ツ古シツつォXツ篠イツ・ツ可コツ古シツつォYツ篠イツ・ツ可彁ツ篠イ\nint top[3][3];\nint front[3][3];\n\nset<int> ans;\n\nvoid dfs(int x, int y, int z) {\n  if (x == 3) { dfs(0,y+1,z); return; }\n  if (y == 3) { dfs(0, 0, z+1); return; }\n  if (z == 3) {\n    int sum = 0; \n    REP(i, 3) REP(j, 3)\n      sum += di[2][i][j].e;\n    ans.insert(sum);\n    return;\n  }\n  dice<int> d(1,6,5,2,3,4);\n  vector<dice<int> > all = d.all_rolls();\n  int res = 0;\n  REP(i, all.size()) {\n    if (z == 0 && front[y][x] && all[i].s != front[y][x]) continue;\n    if (y == 0 && top[2-z][x] && all[i].t != top[2-z][x]) continue;\n    if (x && di[x-1][y][z].e + all[i].w != 7) continue;\n    if (y && di[x][y-1][z].b + all[i].t != 7) continue;\n    if (z && di[x][y][z-1].n + all[i].s != 7) continue;\n    di[x][y][z] = all[i];\n    //cout << \"i = \" << i << \" \" << di[x][y][z].t << \" \" << di[x][y][z].s << \" \" << di[x][y][z].e << endl;\n    dfs(x+1,y,z);\n  }\n}\n\nint main() {\n  int N;\n  cin >> N;\n  while(N--) {\n    REP(i, 3) REP(j, 3)\n      cin >> top[i][j];\n    REP(i, 3) REP(j, 3)\n      cin >> front[i][j];\n    ans.clear();\n    dfs(0,0,0);\n    if (ans.size()) {\n      bool f = 0;\n      FOR(it, ans) {\n        if (f) cout << \" \";\n        f = 1;\n        cout << *it;\n      }\n      cout << endl;\n    } else {\n      cout << 0 << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Dice{\n    array<int,6> face;\n    Dice(){\n        fill(face.begin(),face.end(),0);\n    }\n};\n\nbool isValid(Dice x){\n    bool res=true;\n    int cnt=0;\n    for(int i=0;i<6;i++){\n        if(x.face[i]==1){\n            if(i%3!=0) cnt++;\n            if(i>=3) res=!res;\n        }\n        if(x.face[i]==2){\n            if(i%3!=2) cnt++;\n            if(i>=3) res=!res;\n        }\n        if(x.face[i]==3){\n            if(i%3!=1) cnt++;\n            if(i>=3) res=!res;\n        }\n    }\n    if(cnt==2) res=!res;\n    return res;\n}\nvector<Dice> generate(){\n    vector<Dice> res;\n    for(int i=1;i<=6;i++){\n        for(int j=1;j<=6;j++){\n            if(i==j || i+j==7) continue;       \n            for(int k=1;k<=6;k++){\n                if(k==i || k+i==7) continue;\n                if(k==j || k+j==7) continue;\n                Dice x;\n                x.face[0]=i;\n                x.face[3]=7-i;\n                x.face[1]=j;\n                x.face[4]=7-j;\n                x.face[2]=k;\n                x.face[5]=7-k;\n                if(isValid(x)){\n                    res.push_back(x);\n                }\n            }\n        }\n    }\n    return res;\n};\nusing Face=array<array<int,3>,3>;\nusing Cube=array<array<array<Dice,3>,3>,3>;\nint dx[]={1,0,0,-1,0,0};\nint dy[]={0,1,0,0,-1,0};\nint dz[]={0,0,1,0,0,-1};\nvector<Cube> pred(1);\nvoid init(){\n    auto isRangeImpl=[&](int x){\n        return 0<=x && x<3;\n    };\n    auto isRange=[&](int i,int j,int k){\n        return isRangeImpl(i) && isRangeImpl(j) && isRangeImpl(k);\n    };\n    auto isOKCube=[&](const Cube &x,int i,int j,int k){\n        for(int dir=0;dir<6;dir++){\n            int toi=i+dx[dir],toj=j+dy[dir],tok=k+dz[dir];\n            if(!isRange(toi,toj,tok) || !x[toi][toj][tok].face[0]) continue;\n            if(x[i][j][k].face[dir]+x[toi][toj][tok].face[(dir+3)%6]!=7) return false;\n        }\n        return true;\n    };\n    for(int i=0;i<3;i++)for(int j=0;j<3;j++)for(int k=0;k<3;k++) pred[0][i][j][k]=Dice();\n    vector<Dice> dices=generate();\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            for(int k=0;k<3;k++){\n                vector<Cube> next;\n                for(Cube &c:pred){\n                    for(Dice &d:dices){\n                        c[i][j][k]=d;\n                        if(isOKCube(c,i,j,k)){\n                            next.push_back(c);\n                        }\n                    }\n                }\n                pred=next;\n            }\n        }\n    }\n}\nvoid solve(){\n    Face t,f;\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            cin>>t[i][j];\n        }\n    }\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            cin>>f[i][j];\n        }\n    }\n    set<int> ans;\n    for(auto &c:pred){\n        bool isok=true;\n        int sum=0;\n        for(int i=0;i<3;i++){\n            for(int j=0;j<3;j++){\n                isok=isok&&(t[2-i][j]==0 || t[2-i][j]==c[j][i][0].face[5]);\n                isok=isok&&(f[i][j]==0 || f[i][j]==c[j][0][i].face[4]);\n                sum+=c[2][i][j].face[0];\n            }\n        }\n        if(isok) ans.insert(sum);\n    }\n    if(ans.size()==0) cout<<0<<endl;\n    else{\n        vector<int> res(ans.begin(),ans.end());\n        for(int i=0;i<res.size();i++){\n            cout<<res[i]<<(i+1==res.size() ? \"\\n\" : \" \");\n        }\n    }\n    return;\n}\nint main(){\n    init();\n    int t;\n    cin>>t;\n    while(t--){\n        solve();\n    }    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\n/*\n  // 3がfront\n  1 // top\n  3 2 4 5\n  6 // botom\nもし問題文中のサイコロの展開図が上記のものと異なる場合は\nint label[]を用意し、\n上記の展開図の各面が、問題文の展開図のどの面にマッチするかをmemしておく\n基本的には上記の面の数字をindexとし、問題文の面の数字を引く\n回転配列やsetFaceの中身は変更しない\n*/\n// 回転配列\n// 使用法はsetFaceでの回転参照\nint leftR[]={0,2,6,3,4,1,5};\nint rightR[]={0,5,1,3,4,6,2};\nint frontR[]={0,4,2,1,6,5,3};\nint backR[]={0,3,2,6,1,5,4};\n// z軸を中心に右回転\nint rotateRight[]={0,1,3,5,2,4,6};\n// z軸を中心に左回転\nint rotateLeft[]={0,1,4,2,5,3,6};\n// 回転させてマッチするfaceを探す\n// curFaceに結果を代入\nvoid setFace(int *curFace,int front,int top){\n  int tmpFaces[]={0,1,2,3,4,5,6};\n  int nTmpFaces[10];\n  for(int i=0;i<4;i++){\n    for(int k=0;k<4;k++){\n      // ここで判定\n      if(tmpFaces[1]==top&&tmpFaces[3]==front){\n        for(int m=1;m<=6;m++)curFace[m]=tmpFaces[m];\n        return;\n      }\n      // z軸を中心に右回転させる\n      for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[rotateRight[l]];\n      // 回転結果をtmpFaceに反映\n      for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n    }\n    // 左へサイコロを倒す\n    for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[leftR[l]];\n    // 回転結果をtmpFaceに反映\n    for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n  }\n  for(int i=0;i<3;i++){\n    // 前へサイコロを倒す\n    for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[frontR[l]];\n    // 回転結果をtmpFaceに反映\n    for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n    if(i==1)continue;\n    for(int k=0;k<4;k++){\n      // ここで判定\n      if(tmpFaces[1]==top&&tmpFaces[3]==front){\n\tfor(int m=1;m<=6;m++)curFace[m]=tmpFaces[m];\n\treturn;\n      }\n      // z軸を中心に右回転させる\n      for(int l=1;l<=6;l++)nTmpFaces[l]=tmpFaces[rotateRight[l]];\n      // 回転結果をtmpFaceに反映\n      for(int l=1;l<=6;l++)tmpFaces[l]=nTmpFaces[l];\n    }\n  }\n}\n\ntypedef pair<pii,int> ppi;\n\nint T;\nppi field[3][3][3];\nint ts[3][3];\nint fs[3][3];\nvector<int> ans;\n\n// dfsで(0,0,0)から(3,3,3)に順に置いていく\n// 置きながら条件を満たすか調べる\nvoid dfs(int pos){\n  if(pos==27){\n    int sum=0;\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n        sum+=7-field[i][j][2].second;\n    ans.push_back(sum);\n    return;\n  }\n  int cz=pos/9;\n  int cy=(pos%9)/3;\n  int cx=(pos%9)%3;\n  for(int front=1;front<=6;front++){\n    for(int top=1;top<=6;top++){\n      if(front==top||front+top==7)continue;\n      int curFace[10];\n      setFace(curFace,front,top);\n      int right=curFace[2];\n      bool ok=true;\n      if(cz==0&&ts[cy][cx]!=0&&ts[cy][cx]!=top)ok=false;\n      if(cy==2&&fs[cz][cx]!=0&&fs[cz][cx]!=front)ok=false;\n      if(cz>0&&field[cz-1][cy][cx].first.first!=top)\n        ok=false;\n      if(cy>0&&field[cz][cy-1][cx].first.second!=front)\n        ok=false;\n      if(cx>0&&field[cz][cy][cx-1].second!=right)\n        ok=false;\n      // okならrec\n      if(ok){\n        field[cz][cy][cx].first.first=top;\n        field[cz][cy][cx].first.second=front;\n        field[cz][cy][cx].second=right;\n        dfs(pos+1);\n      }\n    }\n  }\n}\n\nint main(){\n  cin>>T;\n  while(T--){\n    for(int i=0;i<3;i++)for(int j=0;j<3;j++)cin>>ts[i][j];\n    for(int i=0;i<3;i++)for(int j=0;j<3;j++)cin>>fs[i][j];\n    ans.clear();\n    dfs(0);\n    if(ans.size()==0)cout<<0<<endl;\n    else{\n      set<int> st;\n      for(int i=0;i<(int)ans.size();i++)\n        st.insert(ans[i]);\n      ans.clear();\n      for(set<int>::iterator it=st.begin();it!=st.end();it++)\n        ans.push_back(*it);\n      for(int i=0;i<(int)ans.size();i++){\n        cout<<ans[i];\n        if(i==(int)ans.size()-1)cout<<endl;\n        else cout<<\" \";\n      }\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint magic[24][3]={\n\t{1,2,3},{1,3,5},{1,5,4},{1,4,2},\n\t{2,1,4},{2,4,6},{2,6,3},{2,3,1},\n\t{3,1,2},{3,2,6},{3,6,5},{3,5,1},\n\t{4,1,5},{4,5,6},{4,6,2},{4,2,1},\n\t{5,1,3},{5,3,6},{5,6,4},{5,4,1},\n\t{6,2,4},{6,4,5},{6,5,3},{6,3,2}\n};\nint t[3][3],f[3][3];\nint id[3][3][3];\nset<int> st;\nvoid rec(int cnt){\t//T,F,R\n\tif(cnt==27){\n\t\tint tmp=0;\n\t\trep(x,3) rep(y,3) tmp+=magic[id[x][y][0]][2];\n\t\tst.insert(tmp);\n\t\treturn;\n\t}\n\tint x=cnt/9,y=cnt%9/3,z=cnt%3;\n\trep(i,24){\n\t\tif(x==0){\n\t\t\tif(t[2-y][2-z]!=0&&magic[i][0]!=t[2-y][2-z]) continue;\n\t\t}\n\t\tif(y==0){\n\t\t\tif(f[x][2-z]!=0&&magic[i][1]!=f[x][2-z]) continue;\n\t\t}\n\t\tif(x>0&&magic[id[x-1][y][z]][0]!=magic[i][0]) continue;\n\t\tif(y>0&&magic[id[x][y-1][z]][1]!=magic[i][1]) continue;\n\t\tif(z>0&&magic[id[x][y][z-1]][2]!=magic[i][2]) continue;\n\t\tid[x][y][z]=i;\n\t\trec(cnt+1);\n\t}\n}\nint main(){\n\tint T;\n\tcin>>T;\n\trep(tt,T){\n\t\trep(i,3) rep(j,3) cin>>t[i][j];\n\t\trep(i,3) rep(j,3) cin>>f[i][j];\n\t\tst.clear();\n\t\trec(0);\n\t\tif(st.empty()) puts(\"0\");\n\t\telse{\n\t\t\tint N=st.size();\n\t\t\tfor(int x:st){\n\t\t\t\tcout<<x<<(N==1?\"\\n\":\" \");\n\t\t\t\tN--;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { 1, -1, 0, 0,0,0 }; const int dy[] = { 0,0, 1, -1, 0,0 };const int dz[] = { 0,0,0, 0, 1, -1 };\n\nconst int side[6][4] = {\n\t{ 2, 4, 5, 3 },{ 1, 3, 6, 4 },{ 1, 5, 6, 2 },{ 1, 2, 6, 5 },{ 1, 4, 6, 3 },{ 2, 3, 5, 4 }\n};\nconst int dice_right[6][6] = {\n\t{0,3,5,2,4,0},\n\t{ 4,0,1,6,0,3 },\n\t{ 2,6,0,0,1,5 },\n\t{ 5,1,0,0,6,2 },\n\t{ 3,0,6,1,0,4 },\n\t{ 0,4,2,5,3,0 }\n};\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nvi ans;\nvector<vvi> dices(3, vvi(3, vi(3)));//men tate yoko\nbool kakutei() {\n\tbool change = true;\n\twhile (change) {\n\t\tchange = false;\n\t\tREP(i, 3) {\n\t\t\tREP(j, 3) {\n\t\t\t\tif (dices[0][i][j] == 0) {\n\t\t\t\t\tREP(k, 3) {\n\t\t\t\t\t\tif (dices[1][k][j] > 0 && dices[2][k][2 - i] > 0) {\n\t\t\t\t\t\t\tdices[0][i][j] = dice_right[dices[1][k][j] - 1][dices[2][k][2 - i] - 1];\n\t\t\t\t\t\t\tif (dices[0][i][j] == 0)\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\tchange = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dices[1][i][j] == 0) {\n\t\t\t\t\tREP(k, 3) {\n\t\t\t\t\t\tif (dices[0][k][j] > 0 && dices[2][i][2 - k] > 0) {\n\t\t\t\t\t\t\tdices[1][i][j] = dice_right[dices[2][i][2 - k] - 1][dices[0][k][j] - 1];\n\t\t\t\t\t\t\tif (dices[1][i][j] == 0)\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\tchange = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dices[2][i][j] == -1) {\n\t\t\t\t\tREP(k, 3) {\n\t\t\t\t\t\tif (dices[0][2 - j][k] > 0 && dices[1][i][k] > 0) {\n\t\t\t\t\t\t\tdices[2][i][j] = dice_right[dices[0][2 - j][k] - 1][dices[1][i][k] - 1];\n\t\t\t\t\t\t\tif (dices[2][i][j] == 0)\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\tchange = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nvoid dfs() {\n\tvector<vvi> copy_dices = dices;\n\tREP(i, 3) {\n\t\tREP(j, 3) {\n\t\t\tif (dices[0][i][j] == 0) {\n\t\t\t\tREP(k, 6) {\n\t\t\t\t\tbool clear = true;\n\t\t\t\t\tREP(l, 3) {\n\t\t\t\t\t\tif (dices[1][l][j] > 0)\n\t\t\t\t\t\t\tif (dices[1][l][j] == k + 1 || dices[1][l][j] + k + 1 == 7)\n\t\t\t\t\t\t\t\tclear = false;\n\t\t\t\t\t\tif (dices[2][l][2 - i] > 0)\n\t\t\t\t\t\t\tif (dices[2][l][2 - i] == k + 1 || dices[2][l][2 - i] + k + 1 == 7)\n\t\t\t\t\t\t\t\tclear = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (clear) {\n\t\t\t\t\t\tdices[0][i][j] = k + 1;\n\t\t\t\t\t\tif (!kakutei()) {\n\t\t\t\t\t\t\tdices = copy_dices;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint ex[3] = { 0 };\n\t\t\t\t\t\tREP(l,3) {\n\t\t\t\t\t\t\tREP(x, 3) {\n\t\t\t\t\t\t\t\tREP(y, 3) {\n\t\t\t\t\t\t\t\t\tif (dices[l][x][y] <= 0)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tint a = dices[l][x][y];\n\t\t\t\t\t\t\t\t\tif (a == 4)\n\t\t\t\t\t\t\t\t\t\ta = 3;\n\t\t\t\t\t\t\t\t\tif (a == 5)\n\t\t\t\t\t\t\t\t\t\ta = 2;\n\t\t\t\t\t\t\t\t\tif (a == 6)\n\t\t\t\t\t\t\t\t\t\ta = 1;\n\t\t\t\t\t\t\t\t\tex[a - 1]++;\n\t\t\t\t\t\t\t\t\tif (ex[a - 1] > 9)\n\t\t\t\t\t\t\t\t\t\tclear = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!clear)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tdfs();\n\t\t\t\t\t\tdices = copy_dices;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (dices[1][i][j] == 0) {\n\t\t\t\tREP(k, 6) {\n\t\t\t\t\tbool clear = true;\n\t\t\t\t\tREP(l, 3)\n\t\t\t\t\t\tif (dices[0][l][j] == k + 1 || dices[0][l][j] + k + 1 == 7)\n\t\t\t\t\t\t\tclear = false;\n\t\t\t\t\tif (clear) {\n\t\t\t\t\t\tdices[1][i][j] = k + 1;\n\t\t\t\t\t\tif (!kakutei()) {\n\t\t\t\t\t\t\tdices = copy_dices;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint ex[3] = { 0 };\n\t\t\t\t\t\tREP(l, 3) {\n\t\t\t\t\t\t\tREP(x, 3) {\n\t\t\t\t\t\t\t\tREP(y, 3) {\n\t\t\t\t\t\t\t\t\tif (dices[l][x][y] <= 0)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tint a = dices[l][x][y];\n\t\t\t\t\t\t\t\t\tif (a == 4)\n\t\t\t\t\t\t\t\t\t\ta = 3;\n\t\t\t\t\t\t\t\t\tif (a == 5)\n\t\t\t\t\t\t\t\t\t\ta = 2;\n\t\t\t\t\t\t\t\t\tif (a == 6)\n\t\t\t\t\t\t\t\t\t\ta = 1;\n\t\t\t\t\t\t\t\t\tex[a - 1]++;\n\t\t\t\t\t\t\t\t\tif (ex[a - 1] > 9)\n\t\t\t\t\t\t\t\t\t\tclear = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!clear)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tdfs();\n\t\t\t\t\t\tdices = copy_dices;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tREP(i, 3) {\n\t\tREP(j, 3) {\n\t\t\tsum += dice_right[dices[0][2 - j][2] - 1][dices[1][i][2] - 1];\n\t\t}\n\t}\n\tans.push_back(sum);\n}\nint main() {\n\tint kurikaesu;\n\tcin >> kurikaesu;\n\twhile (kurikaesu--) {\n\t\tans.clear();\n\t\tREP(i, 3) {\n\t\t\tREP(j, 3) {\n\t\t\t\tREP(k, 3) {\n\t\t\t\t\tdices[i][j][k] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, 3) {\n\t\t\tREP(j, 3) {\n\t\t\t\tcin >> dices[0][i][j];\n\t\t\t}\n\t\t}\n\t\tREP(i, 3) {\n\t\t\tREP(j, 3) {\n\t\t\t\tcin >> dices[1][i][j];\n\t\t\t}\n\t\t}\n\t\tif (kakutei())\n\t\t\tdfs();\n\t\telse\n\t\t\tgoto emp;\n\t\tSORT(ans);\n\t\tans.erase(unique(ans.begin(), ans.end()), ans.end());\n\t\tREP(i, ans.size()) {\n\t\t\tcout << ans[i];\n\t\t\tif (i != ans.size() - 1)\n\t\t\t\tcout << ' ';\n\t\t}\nemp:\n\t\tif (ans.empty())\n\t\t\tcout << 0;\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\n\nenum FACE { TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT };\ntemplate <class T>\nclass Dice {\npublic:\n  Dice() {\n    id[TOP] = 0; id[FRONT] = 1; id[LEFT] = 2;\n    id[RIGHT] = 3; id[BACK] = 4; id[BOTTOM] = 5;\n  }\n  T& operator[] (FACE f) { return var[id[f]]; }\n  const T& operator[] (FACE f) const { return var[id[f]]; }\n  bool operator==(const Dice<T>& b) const {\n    const Dice<T> &a = *this;\n    return a[TOP] == b[TOP] && a[BOTTOM] == b[BOTTOM] &&\n      a[FRONT] == b[FRONT] && a[BACK] == b[BACK] &&\n      a[LEFT] == b[LEFT] && a[RIGHT] == b[RIGHT];\n  }\n  void roll_x() { roll(TOP, BACK, BOTTOM, FRONT); }\n  void roll_y() { roll(TOP, LEFT, BOTTOM, RIGHT); }\n  void roll_z() { roll(FRONT, RIGHT, BACK, LEFT); }\n  vector<Dice> all_rolls() {\n    vector<Dice> ret;\n    for (int k = 0; k < 6; (k&1?roll_y():roll_x()),++k)\n      for (int i = 0; i < 4; roll_z(), ++i)\n        ret.push_back(*this);\n    return ret;\n  }\n  bool equivalent_to(const Dice& di) {\n    for (int k = 0; k < 6; (k&1?roll_y():roll_x()),++k)\n      for (int i = 0; i < 4; roll_z(), ++i)\n        if (*this == di) return true;\n    return false;\n  }\nprivate:\n  void roll(FACE a, FACE b, FACE c, FACE d) {\n    T tmp = id[a];\n    id[a] = id[b]; id[b] = id[c];\n    id[c] = id[d]; id[d] = tmp;\n  }\n  T var[6];\n  int id[6];\n};\n\nFACE  face[] = {TOP,BOTTOM,FRONT,BACK,LEFT,RIGHT};\nint  value[] = {  0,     5,    1,   4,   3,    2};\n\ninline FACE rev(FACE f) { return ( ( f == TOP ) ? BOTTOM : ( ( f == BOTTOM ) ? TOP : ( ( f == FRONT ) ? BACK : ( ( f == BACK) ? FRONT : ( ( f == LEFT ) ? RIGHT : LEFT ) ) ) ) ); }\n\nint T[3][3], F[3][3];\nDice<int> G[3][3][3];\nint dx[] = {-1,+0,+0};\nint dy[] = {+0,-1,+0};\nint dz[] = {+0,+0,-1};\nFACE fs[] = {LEFT,BACK,TOP};\nset<int> answer;\n\nbool isValid(int x,int y,int z) { return 0 <= x && x < 3 && 0 <= y && y < 3 && 0 <= z && z < 3; }\n\nvoid dfs(int cur){\n\n  if( cur >= 27 ) {\n    int cost = 0;\n    rep(y,3) rep(z,3) cost += (G[z][y][2][RIGHT]+1);\n    answer.insert(cost);\n    return;\n  }\n\n  int cx = cur % 3, cy = ( cur / 3 ) % 3, cz =  cur / 9;\n  \n  Dice<int> tmp = G[cz][cy][cx];\n  vector<Dice<int> > rot = G[cz][cy][cx].all_rolls();\n  rep(i,(int)rot.size()){\n    G[cz][cy][cx] = rot[i];\n    bool failed = false;\n    if( cz == 0 ) if( T[cy][cx] != -1 && G[cz][cy][cx][TOP]   != T[cy][cx] ) { failed = true; }\n    if( cy == 2 ) if( F[cz][cx] != -1 && G[cz][cy][cx][FRONT] != F[cz][cx] ) { failed = true; }\n    if( failed ) continue;\n    rep(j,3){\n      int nx = cx + dx[j], ny = cy + dy[j], nz = cz + dz[j];\n      if( !isValid(nx,ny,nz) ) continue;\n      FACE rface = rev(fs[j]);\n      if( ( G[cz][cy][cx][fs[j]] + G[nz][ny][nx][rface] ) != 5 ) { failed = true; break; }\n    }\n    if( failed ) continue;\n    dfs(cur+1);\n  }\n  G[cz][cy][cx] = tmp;\n}\n\nvoid compute(){\n  answer.clear();\n  rep(z,3) rep(y,3) rep(x,3) rep(i,6) G[z][y][x][face[i]] = value[i];\n  dfs(0);\n  if( answer.empty() ) { puts(\"0\"); return; }\n  bool First = true;\n  for(set<int>::iterator it = answer.begin(); it != answer.end(); it++ ) {\n    if( !First ) cout << ' ';\n    First = false;\n    cout << *it;\n  } cout << endl;\n}\n\nint main(){\n  int t;\n  cin >> t;\n  while( t-- ){\n    rep(i,3) rep(j,3) cin >> T[i][j];\n    rep(i,3) rep(j,3) cin >> F[i][j];\n    rep(i,3) rep(j,3) --T[i][j], --F[i][j];\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define uniq(xs) ((xs).erase(unique((xs).begin(), (xs).end()), (xs).end()))\n\nnamespace {\n    struct Dice {\n        enum FACE { TOP, FRONT, RIGHT, BOTTOM, BACK, LEFT };\n        int v[6];\n        Dice() {}\n        Dice(int top, int front, int right) {\n            v[TOP]   = top;    v[BOTTOM] = 7 - top;\n            v[FRONT] = front;  v[BACK]   = 7 - front;\n            v[RIGHT] = right;  v[LEFT]   = 7 - right;\n        }\n        bool operator==(const Dice& d) const {\n            for (int i = 0; i < 6; i++)\n                if (v[i] != d.v[i])\n                    return false;\n            return true;\n        }\n        // すべて時計回り\n        void rollX() { roll(TOP, FRONT, BOTTOM, BACK); }\n        void rollY() { roll(TOP, LEFT, BOTTOM, RIGHT); }\n        void rollZ() { roll(FRONT, RIGHT, BACK, LEFT); }\n        void roll(int a, int b, int c, int d) {\n            int t = v[a];\n            v[a] = v[b]; v[b] = v[c]; v[c] = v[d]; v[d] = t;\n        }\n        vector<Dice> allState() const {\n            vector<Dice> Ret;\n            Dice d = *this;\n            for (int i = 0; i < 6; i++) {\n                if (i % 2 == 0) d.rollX();\n                else            d.rollY();\n                for (int j = 0; j < 4; j++) {\n                    d.rollZ();\n                    Ret.push_back(d);\n                }\n            }\n            return Ret;\n        }\n        bool isSameDice(const Dice& d) const {\n            vector<Dice> states = allState();\n            for (int i = 0; i < states.size(); i++) {\n                if (states[i] == d) return true;\n            }\n            return false;\n        }\n    };\n    ostream& operator<<(ostream& os, const Dice& d) {\n        os << \"(\" << d.v[0];\n        for (int i = 1; i < 6; i++) {\n            os << \",\" << d.v[i];\n        }\n        os << \")\";\n        return os;\n    }\n\n    vector< vector<int> > T;\n    vector< vector<int> > F;\n    vector<int> ans;\n    void input() {\n        ans.clear();\n        T.clear(); F.clear();\n        T.resize(3, vector<int>(3));\n        F.resize(3, vector<int>(3));\n        for (int i = 0; i < 3; i++) for (int j = 0; j < 3; j++)\n            cin >> T[i][j];\n        for (int i = 0; i < 3; i++) for (int j = 0; j < 3; j++)\n            cin >> F[i][j];\n    }\n\n    vector<Dice> states;\n    void init() {\n        Dice D(1, 2, 3);\n        states = D.allState();\n    }\n\n    ostream& operator<<(ostream& os, const vector<int>& xs) {\n        if (xs.empty()) return os << 0;\n        os << xs[0];\n        for (int i = 1; i < xs.size(); i++) {\n            os << \" \" << xs[i];\n        }\n        return os;\n    }\n\n    vector<Dice> X;\n    void dfs(int index) {\n        if (index == 27) {\n            int c = 0;\n            for (int i = 0; i < 27; i++) {\n                if (i % 3 == 2) {\n                    c += X[i].v[Dice::RIGHT];\n                }\n            };\n            ans.push_back(c);\n            return;\n        }\n        for (int i = 0; i < states.size(); i++) {\n            const Dice& state = states[i];\n            int y = (index % 9) / 3;\n            int x = index % 3;\n            if (T[y][x] != 0 && T[y][x] != state.v[Dice::TOP]) continue;\n            y = index / 9;\n            if (F[y][x] != 0 && F[y][x] != state.v[Dice::FRONT]) continue;\n            if (index >= 9) {\n                const Dice& up = X[index - 9];\n                if (up.v[Dice::BOTTOM] + state.v[Dice::TOP] != 7) continue;\n            }\n            if (index % 9 >= 3) {\n                const Dice& inner = X[index - 3];\n                if (inner.v[Dice::FRONT] + state.v[Dice::BACK] != 7) continue;\n            }\n            if (index % 3 >= 1) {\n                const Dice& n = X[index - 1];\n                if (n.v[Dice::RIGHT] + state.v[Dice::LEFT] != 7) continue;\n            }\n            X[index] = state;\n            dfs(index + 1);\n        }\n    }\n\n    void solve() {\n        X.clear(); X.resize(27);\n        dfs(0);\n        sort(ans.begin(), ans.end());\n        uniq(ans);\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    init();\n    int N; cin >> N;\n    for (int i = 0; i < N; i++) {\n        input();\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=305,INF=1<<30;\n\nint ri(int u,int f){\n    if(u==1){\n        if(f==2) return 3;\n        if(f==3) return 5;\n        if(f==5) return 4;\n        if(f==4) return 2;\n    }\n    if(u==2){\n        if(f==1) return 4;\n        if(f==4) return 6;\n        if(f==6) return 3;\n        if(f==3) return 1;\n    }\n    if(u==3){\n        if(f==1) return 2;\n        if(f==2) return 6;\n        if(f==6) return 5;\n        if(f==5) return 1;\n    }\n    if(u==4){\n        if(f==1) return 5;\n        if(f==5) return 6;\n        if(f==6) return 2;\n        if(f==2) return 1;\n    }\n    if(u==5){\n        if(f==1) return 3;\n        if(f==3) return 6;\n        if(f==6) return 4;\n        if(f==4) return 1;\n    }\n    if(u==6){\n        if(f==2) return 4;\n        if(f==4) return 5;\n        if(f==5) return 3;\n        if(f==3) return 2;\n    }\n    \n    return -1000;\n}//uとfが与えられた時にrを返す(u==1,f==2,r==3型のサイコロ)\n\nstruct dice{\n    int u,f,r,b,l,d;\n    \n    void init(int uu,int ff){\n        u=uu;\n        f=ff;\n        r=ri(u,f);\n        b=7-f;\n        l=7-r;\n        d=7-u;\n    }\n    \n    void turnF(){\n        int save=f;\n        f=u;\n        u=b;\n        b=d;\n        d=save;\n    }\n    \n    void turnR(){\n        int save=r;\n        r=u;\n        u=l;\n        l=d;\n        d=save;\n    }\n    \n    void turnB(){\n        int save=b;\n        b=u;\n        u=f;\n        f=d;\n        d=save;\n    }\n    \n    void turnL(){\n        int save=l;\n        l=u;\n        u=r;\n        r=d;\n        d=save;\n    }\n    \n    void turn1(){\n        int save=r;\n        r=b;\n        b=l;\n        l=f;\n        f=save;\n    }//時計回り\n    \n    void turn2(){\n        int save=r;\n        r=f;\n        f=l;\n        l=b;\n        b=save;\n    }//反時計回り\n};\n\nint A[3][3],B[3][3];\nset<int> ans;\n\nvector<int> X;\n\nvoid DFS(){\n    if(si(X)==8){\n        if(A[0][0]&&A[0][0]!=X[0]) return;\n        if(A[1][0]&&A[1][0]!=X[1]) return;\n        if(A[2][0]&&A[2][0]!=X[2]) return;\n        if(A[2][1]&&A[2][1]!=X[3]) return;\n        if(A[2][2]&&A[2][2]!=X[4]) return;\n        if(B[0][0]&&B[0][0]!=X[5]) return;\n        if(B[1][0]&&B[1][0]!=X[6]) return;\n        if(B[2][0]&&B[2][0]!=X[7]) return;\n        \n        if(X[2]+X[5]==7) return;\n        \n        vector<vector<vector<dice>>> Y(3,vector<vector<dice>>(3,vector<dice>(3)));\n        \n        Y[0][2][0].init(X[2],X[5]);\n        Y[0][2][1].init(X[3],7-Y[0][2][0].r);\n        Y[0][2][1].turn1();\n        Y[0][2][2].init(X[4],7-Y[0][2][1].r);\n        Y[0][2][2].turn1();\n        \n        Y[0][1][0].init(X[1],7-Y[0][2][0].b);\n        Y[0][1][1].init(7-Y[0][1][0].r,7-Y[0][2][1].b);\n        Y[0][1][1].turnL();\n        Y[0][1][2].init(7-Y[0][1][1].r,7-Y[0][2][2].b);\n        Y[0][1][2].turnL();\n        \n        Y[0][0][0].init(X[0],7-Y[0][1][0].b);\n        Y[0][0][1].init(7-Y[0][0][0].r,7-Y[0][1][1].b);\n        Y[0][0][1].turnL();\n        Y[0][0][2].init(7-Y[0][0][1].r,7-Y[0][1][2].b);\n        Y[0][0][2].turnL();\n        \n        //\n        \n        Y[1][2][0].init(7-Y[0][2][0].d,X[6]);\n        Y[1][2][1].init(7-Y[0][2][1].d,7-Y[1][2][0].r);\n        Y[1][2][1].turn1();\n        Y[1][2][2].init(7-Y[0][2][2].d,7-Y[1][2][1].r);\n        Y[1][2][2].turn1();\n        \n        Y[1][1][0].init(7-Y[0][1][0].d,7-Y[1][2][0].b);\n        Y[1][1][1].init(7-Y[0][1][1].d,7-Y[1][2][1].b);\n        Y[1][1][2].init(7-Y[0][1][2].d,7-Y[1][2][2].b);\n        \n        Y[1][0][0].init(7-Y[0][0][0].d,7-Y[1][1][0].b);\n        Y[1][0][1].init(7-Y[0][0][1].d,7-Y[1][1][1].b);\n        Y[1][0][2].init(7-Y[0][0][2].d,7-Y[1][1][2].b);\n        \n        //\n        \n        Y[2][2][0].init(7-Y[1][2][0].d,X[7]);\n        Y[2][2][1].init(7-Y[1][2][1].d,7-Y[2][2][0].r);\n        Y[2][2][1].turn1();\n        Y[2][2][2].init(7-Y[1][2][2].d,7-Y[2][2][1].r);\n        Y[2][2][2].turn1();\n        \n        Y[2][1][0].init(7-Y[1][1][0].d,7-Y[2][2][0].b);\n        Y[2][1][1].init(7-Y[1][1][1].d,7-Y[2][2][1].b);\n        Y[2][1][2].init(7-Y[1][1][2].d,7-Y[2][2][2].b);\n        \n        Y[2][0][0].init(7-Y[1][0][0].d,7-Y[2][1][0].b);\n        Y[2][0][1].init(7-Y[1][0][1].d,7-Y[2][1][1].b);\n        Y[2][0][2].init(7-Y[1][0][2].d,7-Y[2][1][2].b);\n        \n        for(int i=0;i<3;i++){\n            for(int j=0;j<3;j++){\n                if(A[i][j]&&A[i][j]!=Y[0][i][j].u) return;\n                if(B[i][j]&&B[i][j]!=Y[i][2][j].f) return;\n            }\n        }\n        \n        for(int z=0;z<3;z++){\n            for(int x=0;x<3;x++){\n                for(int y=0;y<3;y++){\n                    if(abs(Y[z][x][y].u)>=7) return;\n                    if(abs(Y[z][x][y].f)>=7) return;\n                    if(abs(Y[z][x][y].r)>=7) return;\n                    if(abs(Y[z][x][y].b)>=7) return;\n                    if(abs(Y[z][x][y].l)>=7) return;\n                    if(abs(Y[z][x][y].d)>=7) return;\n                }\n            }\n        }\n        \n        int sum=0;\n        \n        for(int z=0;z<3;z++){\n            for(int x=0;x<3;x++){\n                sum+=Y[z][x][2].r;\n            }\n        }\n        \n        ans.insert(sum);\n        \n        return;\n    }\n    \n    for(int i=1;i<=6;i++){\n        X.push_back(i);\n        DFS();\n        X.pop_back();\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int Q;cin>>Q;\n    while(Q--){\n        ans.clear();\n        for(int i=0;i<3;i++) for(int j=0;j<3;j++) cin>>A[i][j];\n        for(int i=0;i<3;i++) for(int j=0;j<3;j++) cin>>B[i][j];\n        \n        DFS();\n        \n        if(si(ans)==0) cout<<0<<endl;\n        else{\n            for(auto it=ans.begin();it!=ans.end();it++){\n                if(it!=ans.begin()) cout<<\" \";\n                cout<<*it;\n            }\n            cout<<endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct Dice\n{\n  // int x, y;\n  int l, r, f, b, d, u;\n\n  void RollN()\n  {\n    //  --y;\n    int buff = d;\n    d = f;\n    f = u;\n    u = b;\n    b = buff;\n  }\n\n  void RollS()\n  {\n    // ++y;\n    int buff = d;\n    d = b;\n    b = u;\n    u = f;\n    f = buff;\n  }\n\n  void RollL() // ----->\n  {\n    int buff = f;\n    f = l;\n    l = b;\n    b = r;\n    r = buff;\n  }\n\n  void RollR() // <------\n  {\n    int buff = f;\n    f = r;\n    r = b;\n    b = l;\n    l = buff;\n  }\n\n  void RollE() // .o -> o.\n  {\n    // --x;\n    int buff = d;\n    d = l;\n    l = u;\n    u = r;\n    r = buff;\n  }\n\n\n  void RollW() // o. -> .o\n  {\n    //  ++x;\n    int buff = d;\n    d = r;\n    r = u;\n    u = l;\n    l = buff;\n  }\n\n\n  vector< Dice > makeDice()\n  {\n    vector< Dice > ret;\n    for(int i = 0; i < 6; i++) {\n      Dice d(*this);\n      if(i == 1) d.RollN();\n      if(i == 2) d.RollS();\n      if(i == 3) d.RollS(), d.RollS();\n      if(i == 4) d.RollL();\n      if(i == 5) d.RollR();\n      for(int j = 0; j < 4; j++) {\n        ret.emplace_back(d);\n        d.RollE();\n      }\n    }\n    return (ret);\n  }\n};\n\nint latte[3][3], malta[3][3];\nset< int > st;\nDice dice[3][3][3];\nvector< Dice > beet;\n\nvoid dfs(int idx)\n{\n  if(idx == 27) {\n    int ret = 0;\n    for(int i = 0; i < 3; i++) {\n      for(int j = 0; j < 3; j++) {\n        ret += dice[i][2][j].r;\n      }\n    }\n    st.emplace(ret);\n    return;\n  }\n  int i = idx / 3 % 3, j = idx % 3, k = idx / 9;\n  for(auto &s : beet) {\n    if(k == 0 && latte[i][j] && latte[i][j] != s.u) continue;\n    if(i == 2 && malta[k][j] && malta[k][j] != s.f) continue;\n    if(i && dice[i - 1][j][k].b + s.f != 7) continue;\n    if(j && dice[i][j - 1][k].l + s.r != 7) continue;\n    if(k && dice[i][j][k - 1].d + s.u != 7) continue;\n    dice[i][j][k] = s;\n    dfs(idx + 1);\n  }\n}\n\nint main()\n{\n  beet = ((Dice) {4, 3, 2, 5, 6, 1}).makeDice();\n\n  int T;\n  cin >> T;\n  while(T--) {\n    for(int i = 0; i < 3; i++) {\n      for(int j = 0; j < 3; j++) {\n        cin >> latte[i][j];\n      }\n    }\n    for(int i = 0; i < 3; i++) {\n      for(int j = 0; j < 3; j++) {\n        cin >> malta[i][j];\n      }\n    }\n    dfs(0);\n    bool first = false;\n    if(st.empty()) {\n      cout << 0 << endl;\n    } else {\n      for(auto &s : st) {\n        if(first++) cout << \" \";\n        cout << s;\n      }\n      cout << endl;\n      st.clear();\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <set>\nusing namespace std;\n\n// If this structure is used for two-dimensional surface,\n// it assumes that the face id[0] faces the positive direction of the Y axis,\n// the face id[1] faces the positive direction of the X axis\n// and id[2] is top of the dice.\nstruct Dice {\n  int id[6], cnt;\n  const static int f[3][3];\n\n  Dice() { init(); }\n\n  void init() {\n    for(int i = 0; i < 6; ++i) {\n      id[i] = i;\n    }\n    cnt = 0;\n  }\n\n  // type (0:spin, 1:rollX, 2:rollY)\n  // dir 1( ccw     neg      pos   )\n  //    -1( cw      pos      neg   )\n  void rotate(int type, int dir = 1) {\n    const int *v = f[type];\n    int a,b,c,t; a=v[0]; b=v[1]; c=v[2]; t=id[type];\n    if(dir < 0) swap(a,c);\n    id[type]=id[a]; id[a]=id[b]; id[b]=id[c]; id[c]=t;\n  }\n\n  bool next() {\n    ++cnt;\n    if(cnt == 24) {\n      rotate(0,-1);\n      rotate(1,-1);\n      cnt = 0;\n      return false;\n    }\n    if(cnt == 4*3) {\n      rotate(2,-1);\n      rotate(0,-1);\n    } else if(cnt%4 == 0) {\n      rotate(2);\n    } else {\n      rotate(0);\n    }\n    return true;\n  }\n\n  void roll(int dir) {\n    //const static int dx[] = {1,0,-1,0};\n    //const static int dy[] = {0,1,0,-1};\n    switch(dir) {\n      case 0: rotate(1,-1); break;\n      case 1: rotate(2, 1); break;\n      case 2: rotate(1, 1); break;\n      case 3: rotate(2,-1); break;\n    }\n  }\n\n  bool operator < (const Dice &d) const {\n    for(int i = 0; i < 3; ++i)\n      if(id[i] != d.id[i]) return id[i] < d.id[i];\n    return false;\n  }\n\n  void show() {\n    cout << id[4] << \" / \\\\ \" << id[5] << endl;\n    cout << \" /   \\\\\" << endl;\n    cout << \"|\\\\ \" << id[2] << \" /|\" << endl;\n    cout << \"|\" << id[0] << \"\\\\ /\" << id[1] << \"|\" << endl;\n    cout << \" \\\\ | /\" << endl;\n    cout << \"  \\\\|/\" << endl;\n    cout << \"   \" << id[3] << endl;\n  }\n};\nconst int Dice::f[3][3] = {{4,5,1},{3,4,2},{5,3,0}};\nconst int dx[] = { 1, 0, 0,-1, 0, 0};\nconst int dy[] = { 0, 1, 0, 0,-1, 0};\nconst int dz[] = { 0, 0, 1, 0, 0,-1};\nconst int fromID[] = {5,3,4,0,2,1};\n\nstruct P {\n  int x, y, z;\n  P() {}\n  P(int x, int y, int z)\n    : x(x), y(y), z(z) {}\n};\n\ninline bool isIn(const P &p) {\n  return\n    0 <= p.x && p.x < 3 &&\n    0 <= p.y && p.y < 3 &&\n    0 <= p.z && p.z < 3;\n}\n\nvector<P> bfs() {\n  bool vis[3][3][3];\n  queue<P> que;\n  fill(vis[0][0], vis[3][0], false);\n  vis[0][0][0] = true;\n  que.push(P(0,0,0));\n  vector<P> res;\n  res.push_back(P(0,0,0));\n  while(!que.empty()) {\n    P p = que.front();\n    que.pop();\n    for(int k = 0; k < 3; ++k) {\n      P np(p.x + dx[k], p.y + dy[k], p.z + dz[k]);\n      if(!isIn(np)) continue;\n      if(vis[np.z][np.y][np.x]) continue;\n      vis[np.z][np.y][np.x] = true;\n      que.push(np);\n      res.push_back(np);\n    }\n  }\n  return res;\n}\n\nDice cube[3][3][3];\nbool exist[3][3][3];\nint T[3][3], F[3][3];\nvector<P> ps;\n\nvoid init() {\n  fill(exist[0][0], exist[3][0], false);\n}\n\nbool canPut(const P &p, const Dice d) {\n  for(int k = 0; k < 6; ++k) {\n    P np(p.x + dx[k], p.y + dy[k], p.z + dz[k]);\n    if(!isIn(np)) continue;\n    if(!exist[np.z][np.y][np.x]) continue;\n    const Dice &a = cube[np.z][np.y][np.x];\n    if(d.id[fromID[k]] != a.id[fromID[k]]) return false;\n  }\n  if(F[p.y][p.z] != 0 && d.id[0] != F[p.y][p.z]-1) return false;\n  if(T[p.x][p.z] != 0 && d.id[2] != T[p.x][p.z]-1) return false;\n  return true;\n}\n\nvoid rec(int k, set<int> *res) {\n  if(k == ps.size()) {\n    int sum = 0;\n    for(int i = 0; i < 3; ++i) {\n      for(int j = 0; j < 3; ++j) {\n        sum += cube[0][i][j].id[1] + 1;\n      }\n    }\n    res->insert(sum);\n    return;\n  }\n\n  exist[ps[k].z][ps[k].y][ps[k].x] = true;\n\n  Dice d;\n  do {\n    if(canPut(ps[k], d)) {\n      cube[ps[k].z][ps[k].y][ps[k].x] = d;\n      rec(k+1, res);\n    }\n  } while(d.next());\n\n  exist[ps[k].z][ps[k].y][ps[k].x] = false;\n}\n\nint main() {\n  ps = bfs();\n  int Tc;\n  cin >> Tc;\n  for(int tc = 0; tc < Tc; ++tc) {\n    for(int i = 2; i >= 0; --i) {\n      for(int j = 2; j >= 0; --j) {\n        cin >> T[i][j];\n      }\n    }\n    for(int i = 0; i < 3; ++i) {\n      for(int j = 2; j >= 0; --j) {\n        cin >> F[i][j];\n      }\n    }\n    set<int> ans;\n    init();\n    rec(0, &ans);\n    if(ans.size() == 0) {\n      cout << 0 << endl;\n    } else {\n      for(set<int>::iterator it = ans.begin();\n          it != ans.end(); ++it) {\n        if(it != ans.begin()) cout << \" \";\n        cout << *it;\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { 1, -1, 0, 0,0,0 }; const int dy[] = { 0,0, 1, -1, 0,0 };const int dz[] = { 0,0,0, 0, 1, -1 };\n\nconst int side[6][4] = {\n\t{ 2, 4, 5, 3 },{ 1, 3, 6, 4 },{ 1, 5, 6, 2 },{ 1, 2, 6, 5 },{ 1, 4, 6, 3 },{ 2, 3, 5, 4 }\n};\nconst int dice_right[6][6] = {\n\t{0,3,5,2,4,0},\n\t{ 4,0,1,6,0,3 },\n\t{ 2,6,0,0,1,5 },\n\t{ 5,1,0,0,6,2 },\n\t{ 3,0,6,1,0,4 },\n\t{ 0,4,2,5,3,0 }\n};\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nvi ans;\nvector<vvi> dices(3, vvi(3, vi(3)));//men tate yoko\nbool kakutei() {\n\tbool change = true;\n\twhile (change) {\n\t\tchange = false;\n\t\tREP(i, 3) {\n\t\t\tREP(j, 3) {\n\t\t\t\tif (dices[0][i][j] == 0) {\n\t\t\t\t\tREP(k, 3) {\n\t\t\t\t\t\tif (dices[1][k][j] > 0 && dices[2][k][2 - i] > 0) {\n\t\t\t\t\t\t\tdices[0][i][j] = dice_right[dices[1][k][j] - 1][dices[2][k][2 - i] - 1];\n\t\t\t\t\t\t\tif (dices[0][i][j] == 0)\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\tchange = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dices[1][i][j] == 0) {\n\t\t\t\t\tREP(k, 3) {\n\t\t\t\t\t\tif (dices[0][k][j] > 0 && dices[2][i][2 - k] > 0) {\n\t\t\t\t\t\t\tdices[1][i][j] = dice_right[dices[2][i][2 - k] - 1][dices[0][k][j] - 1];\n\t\t\t\t\t\t\tif (dices[1][i][j] == 0)\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\tchange = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dices[2][i][j] == -1) {\n\t\t\t\t\tREP(k, 3) {\n\t\t\t\t\t\tif (dices[0][2 - j][k] > 0 && dices[1][i][k] > 0) {\n\t\t\t\t\t\t\tdices[2][i][j] = dice_right[dices[0][2 - j][k] - 1][dices[1][i][k] - 1];\n\t\t\t\t\t\t\tif (dices[2][i][j] == 0)\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\tchange = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nvoid dfs() {\n\tvector<vvi> copy_dices = dices;\n\tREP(i, 3) {\n\t\tREP(j, 3) {\n\t\t\tif (dices[0][i][j] == 0) {\n\t\t\t\tREP(k, 6) {\n\t\t\t\t\tbool clear = true;\n\t\t\t\t\tREP(l, 3) {\n\t\t\t\t\t\tif (dices[1][l][j] > 0)\n\t\t\t\t\t\t\tif (dices[1][l][j] == k + 1 || dices[1][l][j] + k + 1 == 7)\n\t\t\t\t\t\t\t\tclear = false;\n\t\t\t\t\t\tif (dices[2][l][2 - i] > 0)\n\t\t\t\t\t\t\tif (dices[2][l][2 - i] == k + 1 || dices[2][l][2 - i] + k + 1 == 7)\n\t\t\t\t\t\t\t\tclear = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (clear) {\n\t\t\t\t\t\tdices[0][i][j] = k + 1;\n\t\t\t\t\t\tif (!kakutei()) {\n\t\t\t\t\t\t\tdices = copy_dices;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint ex[3] = { 0 };\n\t\t\t\t\t\tREP(l,3) {\n\t\t\t\t\t\t\tREP(x, 3) {\n\t\t\t\t\t\t\t\tREP(y, 3) {\n\t\t\t\t\t\t\t\t\tif (dices[l][x][y] <= 0)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tint a = dices[l][x][y];\n\t\t\t\t\t\t\t\t\tif (a == 4)\n\t\t\t\t\t\t\t\t\t\ta = 3;\n\t\t\t\t\t\t\t\t\tif (a == 5)\n\t\t\t\t\t\t\t\t\t\ta = 2;\n\t\t\t\t\t\t\t\t\tif (a == 6)\n\t\t\t\t\t\t\t\t\t\ta = 1;\n\t\t\t\t\t\t\t\t\tex[a - 1]++;\n\t\t\t\t\t\t\t\t\tif (ex[a - 1] > 9)\n\t\t\t\t\t\t\t\t\t\tclear = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!clear)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tdfs();\n\t\t\t\t\t\tdices = copy_dices;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, 3) {\n\t\tREP(j, 3) {\n\t\t\tif (dices[1][i][j] == 0) {\n\t\t\t\tREP(k, 6) {\n\t\t\t\t\tbool clear = true;\n\t\t\t\t\tREP(l, 3)\n\t\t\t\t\t\tif (dices[0][l][j] == k + 1 || dices[0][l][j] + k + 1 == 7)\n\t\t\t\t\t\t\tclear = false;\n\t\t\t\t\tif (clear) {\n\t\t\t\t\t\tdices[1][i][j] = k + 1;\n\t\t\t\t\t\tif (!kakutei()) {\n\t\t\t\t\t\t\tdices = copy_dices;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint ex[3] = { 0 };\n\t\t\t\t\t\tREP(l, 3) {\n\t\t\t\t\t\t\tREP(x, 3) {\n\t\t\t\t\t\t\t\tREP(y, 3) {\n\t\t\t\t\t\t\t\t\tif (dices[l][x][y] <= 0)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tint a = dices[l][x][y];\n\t\t\t\t\t\t\t\t\tif (a == 4)\n\t\t\t\t\t\t\t\t\t\ta = 3;\n\t\t\t\t\t\t\t\t\tif (a == 5)\n\t\t\t\t\t\t\t\t\t\ta = 2;\n\t\t\t\t\t\t\t\t\tif (a == 6)\n\t\t\t\t\t\t\t\t\t\ta = 1;\n\t\t\t\t\t\t\t\t\tex[a - 1]++;\n\t\t\t\t\t\t\t\t\tif (ex[a - 1] > 9)\n\t\t\t\t\t\t\t\t\t\tclear = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!clear)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tdfs();\n\t\t\t\t\t\tdices = copy_dices;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tREP(i, 3) {\n\t\tREP(j, 3) {\n\t\t\tsum += dice_right[dices[0][2 - j][2] - 1][dices[1][i][2] - 1];\n\t\t}\n\t}\n\tans.push_back(sum);\n}\nint main() {\n\tint kurikaesu;\n\tcin >> kurikaesu;\n\twhile (kurikaesu--) {\n\t\tans.clear();\n\t\tREP(i, 3) {\n\t\t\tREP(j, 3) {\n\t\t\t\tREP(k, 3) {\n\t\t\t\t\tdices[i][j][k] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, 3) {\n\t\t\tREP(j, 3) {\n\t\t\t\tcin >> dices[0][i][j];\n\t\t\t}\n\t\t}\n\t\tREP(i, 3) {\n\t\t\tREP(j, 3) {\n\t\t\t\tcin >> dices[1][i][j];\n\t\t\t}\n\t\t}\n\t\tif (kakutei())\n\t\t\tdfs();\n\t\telse\n\t\t\tgoto emp;\n\t\tSORT(ans);\n\t\tans.erase(unique(ans.begin(), ans.end()), ans.end());\n\t\tREP(i, ans.size()) {\n\t\t\tcout << ans[i];\n\t\t\tif (i != ans.size() - 1)\n\t\t\t\tcout << ' ';\n\t\t}\nemp:\n\t\tif (ans.empty())\n\t\t\tcout << 0;\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nenum FACE { TOP, FRONT, RIGHT, LEFT, BACK, BOTTOM };\n\nstruct dice{\n  int var[6];\n  int id[6];\n  \n  dice() {\n    id[0] = TOP;\n    id[1] = FRONT;\n    id[2] = RIGHT;\n    id[3] = LEFT;\n    id[4] = BACK;\n    id[5] = BOTTOM;\n    for(int i=0;i<6;i++) var[i] = 0;      \n  }\n  void set(){\n    id[0] = TOP;\n    id[1] = FRONT;\n    id[2] = RIGHT;\n    id[3] = LEFT;\n    id[4] = BACK;\n    id[5] = BOTTOM;\n    for(int i=0;i<6;i++) var[i] = i+1;      \n  }\n\n  int& operator[]( FACE f ) { return var[id[f]]; }\n  const int& operator[] (FACE f) const { return var[id[f]]; }\n  \n  bool operator==(const dice &a) const {\n    const dice &b = *this;\n    for(int i=0;i<6;i++){\n      if( a[(FACE)i] != b[(FACE)i] ) return false;\n    }\n    return true;\n  }\n\n  void roll_x(){ roll(TOP,BACK,BOTTOM,FRONT); }\n  void roll_y(){ roll(TOP,LEFT,BOTTOM,RIGHT); }\n  void roll_z(){ roll(FRONT,RIGHT,BACK,LEFT); }\n\n  vector<dice> all_rolls(){\n    vector<dice> res;\n    for(int k=0;k<6;(k&1 ? roll_y() : roll_x()), k++ ){\n      for(int i=0;i<4; roll_z(),i++)\n        res.push_back( *this );\n    }\n    return res;\n  }\n\n  void roll(FACE a,FACE b,FACE c,FACE d){\n    int tmp = id[a];\n    id[a] = id[b];\n    id[b] = id[c];\n    id[c] = id[d];\n    id[d] = tmp;\n  }\n\n  void view(){\n    cout << \" TOP \" << id[TOP] << \" \"<< (*this)[TOP] << endl;\n    cout << \" FRONT \" << id[FRONT] << \" \" << (*this)[FRONT] << endl;\n    cout << \" RIGHT \" << id[RIGHT] << \" \" << (*this)[RIGHT] << endl;\n    cout << \" LEFT \" << id[LEFT] << \" \"<< (*this)[LEFT] << endl;\n    cout << \" BACK \" << id[BACK] << \" \" << (*this)[BACK] << endl;\n    cout << \" BOTTOM \" << id[BOTTOM] << \" \" << (*this)[BOTTOM] << endl;\n  }\n\n};\n\ndice D[4][4][4];//x,y,z\nvector<int> ans;\nvoid solve(int x,int y,int z){\n  if( z == 4 ){\n    int res=0;\n    for(int i=1;i<=3;i++){\n      for(int j=1;j<=3;j++){\n        res += D[3][i][j][RIGHT];\n      }\n    }\n    ans.push_back( res );\n  } else if( y == 4 ) solve(1,1,z+1);\n  else if( x == 4 ) solve(1,y+1,z);\n  else {\n    dice d; d.set();\n    vector<dice> all = d.all_rolls();\n    for(int i=0;i<(int)all.size();i++){\n      //cout << x << \" \"<< y << \" \"<< z << endl;\n      //cout << all[i][TOP] << endl;\n      //all[i].view();\n      if( D[x-1][y][z][RIGHT] && D[x-1][y][z][RIGHT] + all[i][LEFT] != 7 ) continue;\n      if( D[x][y-1][z][BOTTOM] && D[x][y-1][z][BOTTOM] + all[i][TOP] != 7 ) continue;\n      if( D[x][y][z-1][BACK] && D[x][y][z-1][BACK] + all[i][FRONT] != 7 ) continue;\n      D[x][y][z] = all[i];\n      // cout << \"ok\" << endl;\n      // cout << x << \" \"<< y << \" \"<< z << endl;\n      //d.view();\n      solve(x+1,y,z);\n    }\n  }\n}\n\nint main(){\n  int N;\n  cin >> N;\n  for(int i=0;i<N;i++){\n\n    for(int i=0;i<=3;i++)\n      for(int j=0;j<=3;j++)\n        for(int k=0;k<=3;k++)\n          D[i][j][k] = dice();\n\n    for(int j=3;j>=1;j--){\n      for(int k=1;k<=3;k++){\n        int a;\n        cin >>a;\n        if( a != 0 ){\n          D[k][0][j][BOTTOM] = 7-a;\n        } else {\n          D[k][0][j][BOTTOM] = 0;\n        }\n      }\n    }\n    \n    for(int j=1;j<=3;j++){\n      for(int k=1;k<=3;k++){\n        int a;\n        cin >>a;\n        if( a != 0 ){\n          D[k][j][0][BACK] = 7-a;\n        } else {\n          D[k][j][0][FRONT] = 0;\n        }\n      }\n    }\n    ans.clear();\n    solve(1,1,1);\n    sort(ans.begin(),ans.end());\n    ans.erase(unique(ans.begin(),ans.end()),ans.end());\n    if( ans.empty() ) cout << 0 << endl;\n    else {\n      for(int i=0;i<(int)ans.size();i++){\n        if( i ) cout << \" \";\n        cout << ans[i];\n      }\n      cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\n/*\n    +---+\n    |   | \n    | 1 |\n    |   |\n+---+---+---+\n|   |   |   |\n| 4 | 2 | 3 |\n|   |   |   |\n+---+---+---+\n    |   |\n    | 6 |\n    |   |\n    +---+\n    |   |\n    | 5 |\n    |   |\n    +---+\n*/\n\nenum{\n  TOP    = 0,\n  FRONT  = 1,\n  RIGHT  = 2,\n  LEFT   = 3,\n  BACK   = 4,\n  BOTTOM = 5,\n};\n\n//rotation {TOPtoFRONT, TOPtoRIGHT, FRONTtoRIGHT}\nint r[4][6] = {\n  {4,0,2,3,5,1},\n  {3,1,0,5,4,2},\n  {0,3,1,4,2,5} };\n\nvoid rot(vector<int> &dice, int dir){\n  vector<int> tmp = dice;\n  rep(i,6)dice[i] = tmp[r[dir][i]];\n}\n\nint t[3][3], f[3][3];\n\nvector<int> ans;\nvector<int> cube[27];\nconst int dx[]={0,0,-1,1,0,0}, dy[]={0,-1,0,0,1,0}, dz[]={-1,0,0,0,0,1};\n\nbool check(int pos, const vector<int> &dice){\n  int x = pos%3, y = pos/3%3, z = pos/9%3;\n\n  if(y==0){\n    if(f[z][x]>0 && f[z][x] != dice[FRONT])return false;\n  }\n  if(z==0){\n    if(t[2-y][x]>0 && t[2-y][x] != dice[TOP])return false;\n  }\n  rep(d,6){\n    int nx = x+dx[d], ny = y+dy[d], nz = z+dz[d];\n    if(nx<0 || ny<0 || nz<0)continue;\n    if(nx>2 || ny>2 || nz>2)continue;\n    int nxt = nz*9+ny*3+nx;\n    if(cube[nxt][5-d]>0 && dice[d] + cube[nxt][5-d] != 7)return false;\n  }\n  return true;\n}\n\nvoid rec(int pos){\n  if(pos==27){\n    int sum = 0;\n    rep(y,3)rep(z,3)sum += cube[z*9+y*3+2][RIGHT];\n    ans.push_back(sum);\n    return;\n  }\n\n  vector<int> dice(6), init(6,-1);\n  rep(i,6)dice[i] = i+1;\n\n  rep(azu,6){\n    if(azu&1)rot(dice,0);\n    else rot(dice,1);\n\n    rep(nyan,4){\n      rot(dice,2);\n\n      if(check(pos,dice)){\n\tcube[pos] = dice;\n\trec(pos+1);\n\tcube[pos] = init;\n      }\n    }\n  }\n  return;\n}\n\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    rep(i,3)rep(j,3)cin >> t[i][j];\n    rep(i,3)rep(j,3)cin >> f[i][j];\n\n    ans.clear();\n    rep(i,27)cube[i] = vector<int>(6,-1);\n    rec(0);\n\n    if(ans.size()==0){\n      cout << 0 << endl;\n    }else{\n      sort(ans.begin(),ans.end());\n      ans.erase(unique(ans.begin(),ans.end()),ans.end());\n      rep(i,ans.size()){\n\tcout << ans[i] << (i+1==(int)ans.size()?\"\\n\":\" \");\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Dice{\nprivate:\n    void roll(int a,int b,int c,int d){\n        swap(x[a],x[b]);\n        swap(x[b],x[d]);\n        swap(x[c],x[d]);\n    }\npublic:\n    int x[6];\n    Dice(){\n        for(int i = 0 ; i < 6 ; i++){\n            x[i] = i+1;\n        }\n    }\n    void roll_N(){ roll(0,1,4,5); }\n    void roll_E(){ roll(0,3,2,5); }\n    void rotation(){ roll(1,2,3,4); }\n    void roll(int top,int front){\n        for(int i = 0 ; i < 2 ; i++){\n            for(int j = 0 ; j < 4 ; j++){\n                roll_N();\n                if(top == x[0]) goto next;\n            }\n            roll_E();\n        }\n    next:\n        for(int i = 0 ; i < 4 ; i++){\n            rotation();\n            if(front == x[1]) break; \n        }\n    }\n    void clear(){ memset(x,0,sizeof(x)); }  \n}; \n\nbool can[60];\nDice d[3][3][3];\nint bit[27];\n\nint calc(){\n    int sum = 0;\n    for(int i = 0 ; i < 3 ; i++){\n        for(int j = 0 ; j < 3 ; j++){\n            sum += d[i][j][2].x[2];\n        }\n    }\n    return sum;\n}\n\nbool check(int v){\n    int a = v/9, b = (v%9)/3, c = (v%9)%3;\n    Dice dice = d[a][b][c];\n    dice.roll(1,2);\n    for(int i = 0 ; i < 6 ; i++){\n        if(dice.x[i] != i+1) return false;\n    }\n    return true;\n}\n\nvoid solve(int v,int p,int S){\n    if(v == 27){\n        can[calc()] = 1;\n        return;\n    }\n    if(p == 6){\n        if(!check(v)) return;\n        if(S == (1<<7)-1){\n            solve(v+1,0,bit[v+1]);\n        }\n        return;\n    }\n    int a = v/9, b = (v%9)/3, c = (v%9)%3;\n    if(a-1 >= 0 && p == 0){\n        if(d[a][b][c].x[p] == 0){\n            int x = 7 - d[a-1][b][c].x[5];\n            if(S >> x & 1) return;\n            d[a][b][c].x[p] = x;\n            int x2 = d[a][b][c].x[5-p];\n            if(x2 == 0 || x + x2 == 7){\n                solve(v,p+1,S|(1<<x));\n            }\n            d[a][b][c].x[p] = 0;\n        }else{\n            if(d[a][b][c].x[p] + d[a-1][b][c].x[5] == 7){\n                solve(v,p+1,S);\n            }\n        }\n        return;\n    }\n    if(b-1 >= 0 && p == 4){\n        if(d[a][b][c].x[p] == 0){\n            int x = 7 - d[a][b-1][c].x[1];\n            if(S >> x & 1) return;\n            d[a][b][c].x[p] = x;\n            int x2 = d[a][b][c].x[5-p];\n            if(x2 == 0 || x + x2 == 7){\n                solve(v,p+1,S|(1<<x));\n            }\n            d[a][b][c].x[p] = 0;\n        }else{\n            if(d[a][b][c].x[p] + d[a][b-1][c].x[1] == 7){\n                solve(v,p+1,S);     \n            }\n        }\n        return;\n    }\n    if(c-1 >= 0 && p == 3){\n        if(d[a][b][c].x[p] == 0){\n            int x = 7 - d[a][b][c-1].x[2];\n            if(S >> x & 1) return;\n            d[a][b][c].x[p] = x;\n            int x2 = d[a][b][c].x[5-p];\n            if(x2 == 0 || x + x2 == 7){\n                solve(v,p+1,S|(1<<x));\n            }\n            d[a][b][c].x[p] = 0;\n        }else{\n            if(d[a][b][c].x[p] + d[a][b][c-1].x[2] == 7){\n                solve(v,p+1,S);\n            }\n        }\n        return;\n    }\n    \n    if(d[a][b][c].x[p] == 0){\n        if(d[a][b][c].x[5-p] != 0){\n            int x = 7 - d[a][b][c].x[5-p];\n            if(S >> x & 1) return;\n            d[a][b][c].x[p] = x;\n            solve(v,p+1,S|(1<<x));\n            d[a][b][c].x[p] = 0;\n        }else{\n            for(int i = 0 ; i < 6 ; i++){\n                d[a][b][c].x[p] = i+1;\n                int x = d[a][b][c].x[5-p];\n                if(!(S >> (i+1) & 1) &&\n                   (x == 0 || x + d[a][b][c].x[p] == 7)){\n                    solve(v,p+1,S|(1<<(i+1)));\n                }\n                d[a][b][c].x[p] = 0;\n            }\n        }\n    }else{\n        int x = d[a][b][c].x[5-p];\n        if(x + d[a][b][c].x[p] == 7){\n            solve(v,p+1,S);\n        }\n    }\n}\n\nvoid print(){\n    bool sp = false;\n    for(int i = 0 ; i < 60 ; i++){\n        if(can[i]){\n            if(sp) cout << \" \";\n            sp = true;\n            cout << i;\n        }\n    }\n    if(!sp) cout << 0;\n    cout << endl;\n}\n\nvoid init(){\n    fill(bit,bit+27,1);\n    memset(can,0,sizeof(can));\n    for(int i = 0 ; i < 3 ; i++){\n        for(int j = 0 ; j < 3 ; j++){\n            for(int k = 0 ; k < 3 ; k++){\n                d[i][j][k].clear();\n            }\n        }\n    }\n}\n\nint main(){\n    int N;\n    cin >> N;\n    while(N--){\n        init();\n        int in;\n        for(int i = 0 ; i < 3 ; i++){\n            for(int j = 0 ; j < 3 ; j++){\n                cin >> in;\n                if(in != 0){\n                    d[0][i][j].x[0] = in;\n                    d[0][i][j].x[5] = 7-in;\n                    bit[3*i+j] |= 1<<in;\n                    bit[3*i+j] |= 1<<(7-in);\n                }\n            }\n        }\n        for(int i = 0 ; i < 3 ; i++){\n            for(int j = 0 ; j < 3 ; j++){\n                cin >> in;\n                if(in != 0){\n                    d[i][2][j].x[1] = in;\n                    d[i][2][j].x[4] = 7-in;\n                    bit[9*i+6+j] |= 1<<in;\n                    bit[9*i+6+j] |= 1<<(7-in);\n                }\n            }\n        }\n        solve(0,0,bit[0]);\n        print();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n#define REP(i, n) for(int (i)=0; (i)<(n); (i)++)\nint d[6][4]={{2,3,5,4}, {1,4,6,3}, {1,2,6,5}, {1,5,6,2}, {1,3,6,4}, {2,4,5,3}};\n\nstruct dice{ int t,r; }; //topの数字、回転数\ndice cube[3][3][3];\nint t[3][3],f[3][3];\nbool ans[55];\n\nvoid solve(int x, int y, int z){\n\tif(z==3){\n\t\tint sum=0;\n\t\tREP(i,3) REP(j,3){\n\t\t\tsum += d[cube[2][i][j].t][(cube[2][i][j].r+1)%4];\n\t\t}\n\t\tans[sum] = true;\n\t\treturn;\n\t}\n\t\n\tint nx=x, ny=y, nz=z;\n\tif(x<2) nx++;\n\telse{\n\t\tnx = 0;\n\t\tif(y<2) ny++;\n\t\telse{ ny = 0; nz++; }\n\t}\n\t\n\tREP(top,6) REP(rot,4){\n\t\t//上面・前面不一致\n\t\tif(z==0 && t[y][x]!=0 && (top+1)!=t[y][x]) continue;\n\t\tif(y==2 && f[z][x]!=0 && d[top][rot]!=f[z][x]) continue;\n\t\t//隣接面不一致\n\t\tif(x!=0 && d[cube[x-1][y][z].t][(cube[x-1][y][z].r+1)%4]!=d[top][(rot+1)%4]) continue;\n\t\tif(y!=0 && d[cube[x][y-1][z].t][(cube[x][y-1][z].r)]!=d[top][rot]) continue;\n\t\tif(z!=0 && cube[x][y][z-1].t != top) continue;\n\t\tcube[x][y][z].t = top;\n\t\tcube[x][y][z].r = rot;\n\t\tsolve(nx, ny, nz);\n\t}\n}\n\nint main(){\n\tint rep;\n\tcin >> rep;\n\tfor(int r=0; r<rep; r++){\n\t\tmemset(ans, 0, sizeof(ans));\n\t\tREP(i,3) REP(j,3) cin >> t[i][j];\n\t\tREP(i,3) REP(j,3) cin >> f[i][j];\n\t\tsolve(0, 0, 0);\n\t\tbool nosol = true;\n\t\tREP(i,55){\n\t\t\tif(ans[i]) nosol = false;\n\t\t}\n\t\tif(nosol){\n\t\t\tcout << 0 << endl;\n\t\t}else{\n\t\t\tREP(i,55){\n\t\t\t\tif(ans[i]) cout << i << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\nusing namespace std;\n\nenum { U, F, R, D, B, L };\nstruct Dice {\n\tint face[6];\n\tDice() { face[F] = 1; face[R] = 2; face[U] = 3; face[B] = 6; face[L] = 5; face[D] = 4; }\n\tint find_face(int f) {\n\t\trep(i, 6) if(face[i] == f) return i;\n\t\treturn -1;\n\t}\n\tvoid turn(int dir) {\n\t\tswitch(dir) {\n\t\tcase R: rotate(U, R, D, L); break;\n\t\tcase B: rotate(U, B, D, F); break;\n\t\tcase L: rotate(U, L, D, R); break;\n\t\tcase F: rotate(U, F, D, B); break;\n\t\tcase U: rotate(F, R, B, L); break; // ??????????????????????¨???????\n\t\tcase D: rotate(F, L, B, R); break; // ??????????????????????¨???????\n\t\tdefault: assert(false);\n\t\t}\n\t}\n\tint & operator[](int n) { return face[n]; }\n\tvector<Dice> all() {\n\t\tvector<Dice> res;\n\t\trep(k, 6) {\n\t\t\trep(i, 4) { res.push_back(*this); turn(R); }\n\t\t\tif(k & 1) turn(U); else turn(F);\n\t\t}\n\t\treturn res;\n\t}\n\tvoid rotate(int a, int b, int c, int d) {\n\t\tint t = face[d];\n\t\tface[d] = face[c]; face[c] = face[b]; face[b] = face[a]; face[a] = t;\n\t}\n};\n\nint u[3][3][3];\nint f[3][3][3];\nint r[3][3][3];\nint ut[3][3][3];\nint ft[3][3][3];\n\nvector<Dice> ds[7][7][7];\nstruct P {\n\tint x, y, z;\n};\n\nvector<P> ps;\nvector<int> ans;\n\nvoid dfs(int n) {\n\t//cout << n << endl;\n\tif(n == 27) {\n\t\tint sum = 0;\n\t\tfor(int y = 0; y < 3; y++) {\n\t\t\tfor(int z = 0; z < 3; z++) {\n\t\t\t\tsum += r[2][y][z];\n\t\t\t}\n\t\t}\n\t\tans.push_back(sum);\n\t\treturn;\n\t}\n\n\tint x = ps[n].x, y = ps[n].y, z = ps[n].z;\n\t// u\n\tint uu = ut[x][y][z] ? u[x][y][z] : 0;\n\tfor(int i = 0; i < 3; i++) {\n\t\tif(y == i) continue;\n\t\tif(u[x][i][z] == 0) continue;\n\t\tif(uu != 0 && uu != u[x][i][z]) return;\n\t\tuu = u[x][i][z];\n\t}\n\t// f\n\tint ff = ft[x][y][z] ? f[x][y][z] : 0;\n\tfor(int i = 0; i < 3; i++) {\n\t\tif(z == i) continue;\n\t\tif(f[x][y][i] == 0) continue;\n\t\tif(ff != 0 && ff != f[x][y][i]) return;\n\t\tff = f[x][y][i];\n\t}\n\t// r\n\tint rr = 0;\n\tfor(int i = 0; i < 3; i++) {\n\t\tif(x == i) continue;\n\t\tif(r[i][y][z] == 0) continue;\n\t\tif(rr != 0 && rr != r[i][y][z]) return;\n\t\trr = r[i][y][z];\n\t}\n\tfor(Dice d : ds[uu][ff][rr]) {\n\t\tu[x][y][z] = d[U];\n\t\tf[x][y][z] = d[F];\n\t\tr[x][y][z] = d[R];\n\t\tdfs(n + 1);\n\t\tif(!ut[x][y][z]) u[x][y][z] = 0;\n\t\tif(!ft[x][y][z]) f[x][y][z] = 0;\n\t\tr[x][y][z] = 0;\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t{\n\t\tDice d;\n\t\tvector<Dice> all = d.all();\n\t\tfor(Dice a : all) {\n\t\t\tfor(int i = 0; i < 7; i++) {\n\t\t\t\tfor(int j = 0; j < 7; j++) {\n\t\t\t\t\tfor(int k = 0; k < 7; k++) {\n\t\t\t\t\t\tif(i != 0 && i != a.face[U]) continue;\n\t\t\t\t\t\tif(j != 0 && j != a.face[F]) continue;\n\t\t\t\t\t\tif(k != 0 && k != a.face[R]) continue;\n\t\t\t\t\t\tds[i][j][k].push_back(a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int x = 0; x < 3; x++) {\n\t\tfor(int y = 0; y < 3; y++) {\n\t\t\tfor(int z = 0; z < 3; z++) {\n\t\t\t\tps.push_back(P{ x, y, z });\n\t\t\t}\n\t\t}\n\t}\n\n\tint n;\n\tcin >> n;\n\twhile(n--) {\n\t\tmemset(u, 0, sizeof u);\n\t\tmemset(f, 0, sizeof f);\n\t\tmemset(r, 0, sizeof r);\n\t\tmemset(ut, 0, sizeof u);\n\t\tmemset(ft, 0, sizeof f);\n\n\t\tfor(int z = 0; z < 3; z++) {\n\t\t\tfor(int x = 0; x < 3; x++) {\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tfor(int y = 0; y < 3; y++) {\n\t\t\t\t\tu[x][y][z] = a;\n\t\t\t\t\tif(a) ut[x][y][z] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int y = 0; y < 3; y++) {\n\t\t\tfor(int x = 0; x < 3; x++) {\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tfor(int z = 0; z < 3; z++) {\n\t\t\t\t\tf[x][y][z] = a;\n\t\t\t\t\tif(a) ft[x][y][z] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans.clear();\n\n\t\tdfs(0);\n\n\t\tsort(ans.begin(), ans.end());\n\t\tans.erase(unique(ans.begin(), ans.end()), ans.end());\n\n\t\tfor(int i = 0; i < ans.size(); i++) {\n\t\t\tcout << ans[i];\n\t\t\tif(i != ans.size() - 1) cout << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nstruct dice{\n\tint a[6];\n\tvoid rotx(){ int tmp=a[0]; a[0]=a[4]; a[4]=a[5]; a[5]=a[2]; a[2]=tmp; }\n\tvoid roty(){ int tmp=a[0]; a[0]=a[1]; a[1]=a[5]; a[5]=a[3]; a[3]=tmp; }\n\tvoid rotz(){ int tmp=a[1]; a[1]=a[4]; a[4]=a[3]; a[3]=a[2]; a[2]=tmp; }\n};\n\nvector<dice> get_all(dice D){\n\tvector<dice> res;\n\trep(i,6){\n\t\trep(j,4){\n\t\t\tres.push_back(D);\n\t\t\tD.rotz();\n\t\t}\n\t\tif(i%2==0) D.rotx();\n\t\telse       D.roty();\n\t}\n\treturn res;\n}\n\nint top[3][3],front[3][3];\n\nvector<int> ans;\nvector<dice> S;\n\ndice D[3][3][3];\nvoid dfs(int z,int y,int x){\n\tif(z==3){\n\t\tint sum=0;\n\t\trep(i,3) rep(j,3) sum+=D[i][j][2].a[3];\n\t\tans.push_back(sum);\n\t\treturn;\n\t}\n\tif(y==3) return dfs(z+1,0,0);\n\tif(x==3) return dfs(z,y+1,0);\n\n\trep(i,S.size()){\n\t\tD[z][y][x]=S[i];\n\t\tbool ok=true;\n\t\tif(x>0 && D[z][y][x-1].a[3]+D[z][y][x].a[1]!=7) ok=false;\n\t\tif(y>0 && D[z][y-1][x].a[2]+D[z][y][x].a[4]!=7) ok=false;\n\t\tif(z>0 && D[z-1][y][x].a[5]+D[z][y][x].a[0]!=7) ok=false;\n\t\tif(z==0 && top  [y][x]!=0 && top  [y][x]!=D[z][y][x].a[0]) ok=false;\n\t\tif(y==2 && front[z][x]!=0 && front[z][x]!=D[z][y][x].a[2]) ok=false;\n\t\tif(ok) dfs(z,y,x+1);\n\t}\n}\n\nint main(){\n\tint T; scanf(\"%d\",&T);\n\twhile(T--){\n\t\trep(i,3) rep(j,3) scanf(\"%d\",top[i]+j);\n\t\trep(i,3) rep(j,3) scanf(\"%d\",front[i]+j);\n\n\t\tS=get_all((dice){1,4,2,3,5,6});\n\n\t\tans.clear();\n\t\tdfs(0,0,0);\n\n\t\tsort(ans.begin(),ans.end());\n\t\tans.erase(unique(ans.begin(),ans.end()),ans.end());\n\n\t\trep(i,ans.size()) printf(\"%d%c\",ans[i],i+1<ans.size()?' ':'\\n');\n\t\tif(ans.empty()) puts(\"0\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nenum{FRONT,BACK,RIGHT,LEFT,TOP,BOTTOM};\nstruct Die{\n\tint face[6]; // front,back,right,left,top,bottom\n\tDie():face{2,5,3,4,1,6}{}\n\tvoid Rotate(int a,int b,int c,int d){\n\t\ttie(face[a],face[b],face[c],face[d])=mt(face[b],face[c],face[d],face[a]);\n\t}\n\tvoid TurnF(){Rotate(2,4,3,5);}\n\tvoid TurnR(){Rotate(0,5,1,4);}\n\tvoid TurnU(){Rotate(0,2,1,3);}\n};\n\ntypedef vector<vector<vector<Die>>> Cube;\n\nbool ok(Cube cube,int x,int y,int z,const vvi& ts,const vvi& fs)\n{\n\tif(x>0 && cube[x][y][z].face[BACK]+cube[x-1][y][z].face[FRONT]!=7) return false;\n\tif(y>0 && cube[x][y][z].face[LEFT]+cube[x][y-1][z].face[RIGHT]!=7) return false;\n\tif(z>0 && cube[x][y][z].face[BOTTOM]+cube[x][y][z-1].face[TOP]!=7) return false;\n\tif(z==2 && cube[x][y][z].face[TOP]!=ts[x][y] && ts[x][y]) return false;\n\tif(x==2 && cube[x][y][z].face[FRONT]!=fs[2-z][y] && fs[2-z][y]) return false;\n\treturn true;\n}\n\nvoid dfs(Cube& cube,int x,int y,int z,const vvi& ts,const vvi& fs,vi& res)\n{\n\tif(x==3) x=0,y++;\n\tif(y==3) y=0,z++;\n\tif(z==3){\n\t\tint sum=0;\n\t\trep(i,3) rep(j,3)\n\t\t\tsum+=cube[i][2][j].face[RIGHT];\n\t\tres.push_back(sum);\n\t\treturn;\n\t}\n\t\n\tDie d;\n\trep(i,6){\n\t\trep(j,4){\n\t\t\tcube[x][y][z]=d;\n\t\t\tif(ok(cube,x,y,z,ts,fs))\n\t\t\t\tdfs(cube,x+1,y,z,ts,fs,res);\n\t\t\td.TurnU();\n\t\t}\n\t\ti&1?d.TurnF():d.TurnR();\n\t}\n}\n\nvoid solve(const vvi& ts,const vvi& fs)\n{\n\tCube cube(3,vector<vector<Die>>(3,vector<Die>(3)));\n\tvi res;\n\tdfs(cube,0,0,0,ts,fs,res);\n\tsort(all(res));\n\tres.erase(unique(all(res)),end(res));\n\tif(res.empty())\n\t\tcout<<0<<endl;\n\telse{\n\t\trep(i,res.size())\n\t\t\tcout<<(i?\" \":\"\")<<res[i];\n\t\tcout<<endl;\n\t}\n}\n\nint main()\n{\n\tint tc; cin>>tc;\n\trep(_,tc){\n\t\tvvi ts(3,vi(3)),fs(3,vi(3));\n\t\trep(i,3) rep(j,3) cin>>ts[i][j];\n\t\trep(i,3) rep(j,3) cin>>fs[i][j];\n\t\tsolve(ts,fs);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<55)+1e9; // ~ 3.6 * 1e16\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nostream& operator<<(ostream& o,T t){return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){Int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nconst Int TOP = 0,FRONT = 1,LEFT = 3, RIGHT = 2,BACK = 4,BOTTOM = 5;\nclass Dice{\npublic:\n  vector<Int> val;\n  Dice():val(6){for(Int i=0;i<6;i++) val[i] = i+1;}\n  Dice(Int val[6]){for(Int i=0;i<6;i++) this->val[i] = val[i];}\n  Dice(vector<Int> val):val(val){assert(val.size() == 6);}\n  Int& operator [](Int a){return val[a];}\n  bool operator == (Dice a)const{\n    for(Int i=0;i<6;(i%2? a.rotN():a.rotE()),i++)\n      for(Int j=0;j<4;j++){\n        if(val == a.val) return 1;\n        a.rotCW();\n      }\n    return 0;\n  }\n\n  void rot(string s){\n    if(s == \"N\" || s == \"B\") rotN();\n    else if(s == \"S\" || s == \"F\") rotS();\n    else if(s == \"E\" || s == \"R\") rotE();\n    else if(s == \"W\" || s == \"L\") rotW();\n    else if(s == \"CW\") rotCW();\n    else if(s == \"CCW\") rotCCW();\n    else assert(!\"rot error\"); /*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/\n  }\n\n  \n  void rot(char ch){rot(string(1,ch));}\n  \n  //奥に転がす\n  void rotN(){\n    swap(val[TOP],val[FRONT]);\n    swap(val[FRONT],val[BOTTOM]);\n    swap(val[BOTTOM],val[BACK]);\n  }\n\n  //手前に転がす\n  void rotS(){\n    //rotN(),rotN(),rotN();\n    swap(val[TOP],val[BACK]);\n    swap(val[BACK],val[BOTTOM]);\n    swap(val[BOTTOM],val[FRONT]);\n  }\n  \n  //右に転がす\n  void rotE(){\n    swap(val[TOP],val[LEFT]);\n    swap(val[LEFT],val[BOTTOM]);\n    swap(val[BOTTOM],val[RIGHT]);\n  }\n\n  //左に転がす\n  void rotW(){\n    //rotE(),rotE(),rotE();\n    swap(val[TOP],val[RIGHT]);\n    swap(val[RIGHT],val[BOTTOM]);\n    swap(val[BOTTOM],val[LEFT]);\n  }\n\n  //上から見て時計回りに回す\n  void rotCW(){\n    swap(val[FRONT],val[RIGHT]);\n    swap(val[RIGHT],val[BACK]);\n    swap(val[BACK],val[LEFT]);\n  }\n\n  //上からみて反時計回りに回す。\n  void rotCCW(){\n    //rotCW(),rotCW(),rotCW();\n    swap(val[FRONT],val[LEFT]);\n    swap(val[LEFT],val[BACK]);\n    swap(val[BACK],val[RIGHT]);\n  }\n\n  void init(Int top,Int front){\n    for(Int i=0;i<6;(i%2? rotN():rotE()),i++)\n      for(Int j=0;j<4;j++){\n        if(val[TOP] == top && val[FRONT] == front) return;\n        rotCW();\n      }\n    assert(!\"init error\");\n  }\n};\n\nDice getDice(Int top){\n  Int front = top == 6 || top == 1? 2:1;\n  Dice d; d.init(top, front);\n  return d;\n}\n\n\nvector<vector<Int> > Top;\nvector<vector<Int> > Front;\nvector<vector<vector<Dice> > > dice;\nvector<Int>  num;\nvoid dfs(Int i,Int j,Int k,Int sum){\n  if(j == 3) i++, j = 0;\n  if(i == 3) i = 0, k++;\n  if(k == 3) {num.push_back(sum);return;}\n\n  for(Int top = 1; top<=6; top++){\n    if(k == 0 && Top[i][j] != 0 && top != Top[i][j]) continue;\n    if(k != 0 && top + dice[i][j][k-1][BOTTOM] != 7) continue;\n    \n    auto check= [&](Dice &d){\n      if(i - 1 >= 0 && d[BACK] + dice[i-1][j][k][FRONT] != 7) return 0;\n      if(j - 1 >= 0 && d[LEFT] + dice[i][j-1][k][RIGHT] != 7) return 0;\n      if(i==2 && Front[k][j] != 0 && d[FRONT] + Front[k][j] != 7) return 0;\n      return 1;\n    };\n    Dice d = getDice(top);\n    for(Int s=0; s < 4; s++, d.rotCCW()){\n      if(!check(d)) continue;\n      dice[i][j][k] = d;\n      Int nsum = sum + (j==0? d[LEFT]:0);\n      dfs(i, j+1, k, nsum);\n    }\n  }\n}\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n  Int N;\n  cin>>N;\n  while(N--){\n    Top = vector<vector<Int> > (3,vector<Int>(3));\n    Front = vector<vector<Int> > (3,vector<Int>(3));\n    cin>>Top;\n    cin>>Front;\n  \n    num.clear();\n    dice = vector<vector<vector<Dice> > > (3, vector<vector<Dice> > (3,vector<Dice>(3)));\n    dfs(0, 0 ,0, 0);\n    sort(num.begin(),num.end());\n    num.erase(unique(num.begin(), num.end()), num.end());\n    if(num.size() == 0) cout<<0<<endl;\n    else cout<<num<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n#include \"dice.h\"\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { 1, -1, 0, 0,0,0 }; const int dy[] = { 0,0, 1, -1, 0,0 };const int dz[] = { 0,0,0, 0, 1, -1 };\n\nconst int side[6][4] = {\n\t{ 2, 4, 5, 3 },{ 1, 3, 6, 4 },{ 1, 5, 6, 2 },{ 1, 2, 6, 5 },{ 1, 4, 6, 3 },{ 2, 3, 5, 4 }\n};\nconst int dice_right[6][6] = {\n\t{0,3,5,2,4,0},\n\t{ 4,0,1,6,0,3 },\n\t{ 2,6,0,0,1,5 },\n\t{ 5,1,0,0,6,2 },\n\t{ 3,0,6,1,0,4 },\n\t{ 0,4,2,5,3,0 }\n};\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nvi ans;\nvector<vector<vvi>> dices(3, vector<vvi>(3, vvi(3, vi(2))));\nvoid dfs() {\n\tREP(i, 3) {\n\t\tREP(j, 3) {\n\t\t\tREP(k, 3) {\n\t\t\t\tvector<vector<vvi>> copy_dices = dices;\n\t\t\t\tif (dices[i][j][k][0] == 0 && dices[i][j][k][1] == 0) {\n\t\t\t\t\tREP(l, 6) {\n\t\t\t\t\t\tREP(m, 6) {\n\t\t\t\t\t\t\tif (l + m == 7 || l == m)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tbool able = true;\n\t\t\t\t\t\t\tREP(n, 6) {\n\t\t\t\t\t\t\t\tif (0 <= i + dx[n] && i + dx[n] < 3 && 0 <= j + dy[n] && j + dy[n] < 3 && 0 <= k + dz[n] && k + dz[n] < 3) {\n\t\t\t\t\t\t\t\t\tswitch (n) {\n\t\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\t\tif (dices[i + dx[n]][j + dy[n]][k + dz[n]][0] != 0 && dices[i + dx[n]][j + dy[n]][k + dz[n]][0] != l + 1)\n\t\t\t\t\t\t\t\t\t\t\t\table = false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\t\t\tif (dices[i + dx[n]][j + dy[n]][k + dz[n]][1] != 0 && dices[i + dx[n]][j + dy[n]][k + dz[n]][1] != m + 1)\n\t\t\t\t\t\t\t\t\t\t\t\table = false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\t\t\t\t\tif (dices[i + dx[n]][j + dy[n]][k + dz[n]][0] != 0 &&\n\t\t\t\t\t\t\t\t\t\t\t\tdices[i + dx[n]][j + dy[n]][k + dz[n]][1] != 0 &&\n\t\t\t\t\t\t\t\t\t\t\t\tdice_right[dices[i + dx[n]][j + dy[n]][k + dz[n]][0] - 1][dices[i + dx[n]][j + dy[n]][k + dz[n]][1] - 1] != dice_right[l][m])\n\t\t\t\t\t\t\t\t\t\t\t\table = false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!able)\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (able) {\n\t\t\t\t\t\t\t\tdices[0][j][k][0] = l+1;\n\t\t\t\t\t\t\t\tdices[1][j][k][0] = l + 1;\n\t\t\t\t\t\t\t\tdices[2][j][k][0] = l + 1;\n\t\t\t\t\t\t\t\tdices[i][0][k][1] = m + 1;\n\t\t\t\t\t\t\t\tdices[i][1][k][1] = m + 1;\n\t\t\t\t\t\t\t\tdices[i][2][k][1] = m + 1;\n\t\t\t\t\t\t\t\tdfs();\n\t\t\t\t\t\t\t\tdices = copy_dices;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (dices[i][j][k][0] != 0 && dices[i][j][k][1] == 0) {\n\t\t\t\t\tREP(m, 6) {\n\t\t\t\t\t\tif (dices[i][j][k][0]-1 + m == 7 || dices[i][j][k][0]-1 == m)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tbool able = true;\n\t\t\t\t\t\tREP(n, 6) {\n\t\t\t\t\t\t\tif (0 <= i + dx[n] && i + dx[n] < 3 && 0 <= j + dy[n] && j + dy[n] < 3 && 0 <= k + dz[n] && k + dz[n] < 3) {\n\t\t\t\t\t\t\t\tswitch (n) {\n\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\tif (dices[i + dx[n]][j + dy[n]][k + dz[n]][0] != 0 && dices[i + dx[n]][j + dy[n]][k + dz[n]][0] != dices[i][j][k][0])\n\t\t\t\t\t\t\t\t\t\t\table = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\t\tif (dices[i + dx[n]][j + dy[n]][k + dz[n]][1] != 0 && dices[i + dx[n]][j + dy[n]][k + dz[n]][1] != m + 1)\n\t\t\t\t\t\t\t\t\t\t\table = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\t\t\t\tif (dices[i + dx[n]][j + dy[n]][k + dz[n]][0] != 0 &&\n\t\t\t\t\t\t\t\t\t\t\tdices[i + dx[n]][j + dy[n]][k + dz[n]][1] != 0 &&\n\t\t\t\t\t\t\t\t\t\t\tdice_right[dices[i + dx[n]][j + dy[n]][k + dz[n]][0] - 1][dices[i + dx[n]][j + dy[n]][k + dz[n]][1] - 1] != dice_right[dices[i][j][k][0]-1][m])\n\t\t\t\t\t\t\t\t\t\t\table = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!able)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (able) {\n\t\t\t\t\t\t\tdices[i][0][k][1] = m + 1;\n\t\t\t\t\t\t\tdices[i][1][k][1] = m + 1;\n\t\t\t\t\t\t\tdices[i][2][k][1] = m + 1;\n\t\t\t\t\t\t\tdfs();\n\t\t\t\t\t\t\tdices = copy_dices;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (dices[i][j][k][0] == 0 && dices[i][j][k][1] != 0) {\n\t\t\t\t\tREP(l, 6) {\n\t\t\t\t\t\tif (l + dices[i][j][k][1]-1 == 7 || l == dices[i][j][k][1]-1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tbool able = true;\n\t\t\t\t\t\tREP(n, 6) {\n\t\t\t\t\t\t\tif (0 <= i + dx[n] && i + dx[n] < 3 && 0 <= j + dy[n] && j + dy[n] < 3 && 0 <= k + dz[n] && k + dz[n] < 3) {\n\t\t\t\t\t\t\t\tswitch (n) {\n\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\tif (dices[i + dx[n]][j + dy[n]][k + dz[n]][0] != 0 && dices[i + dx[n]][j + dy[n]][k + dz[n]][0] != l + 1)\n\t\t\t\t\t\t\t\t\t\t\table = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\t\tif (dices[i + dx[n]][j + dy[n]][k + dz[n]][1] != 0 && dices[i + dx[n]][j + dy[n]][k + dz[n]][1] != dices[i][j][k][1])\n\t\t\t\t\t\t\t\t\t\t\table = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\t\t\t\tif (dices[i + dx[n]][j + dy[n]][k + dz[n]][0] != 0 &&\n\t\t\t\t\t\t\t\t\t\t\tdices[i + dx[n]][j + dy[n]][k + dz[n]][1] != 0 &&\n\t\t\t\t\t\t\t\t\t\t\tdice_right[dices[i + dx[n]][j + dy[n]][k + dz[n]][0] - 1][dices[i + dx[n]][j + dy[n]][k + dz[n]][1] - 1] != dice_right[l][dices[i][j][k][1]-1])\n\t\t\t\t\t\t\t\t\t\t\table = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!able)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (able) {\n\t\t\t\t\t\t\tdices[0][j][k][0] = l + 1;\n\t\t\t\t\t\t\tdices[1][j][k][0] = l + 1;\n\t\t\t\t\t\t\tdices[2][j][k][0] = l + 1;\n\t\t\t\t\t\t\tdfs();\n\t\t\t\t\t\t\tdices = copy_dices;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tREP(i,3) {\n\t\tREP(j, 3) {\n\t\t\tif (dice_right[dices[i][j][2][0] - 1][dices[i][j][2][1] - 1] == 0)\n\t\t\t\treturn;\n\t\t\tsum+=dice_right[dices[i][j][2][0] - 1][dices[i][j][2][1] - 1];\n\t\t}\n\t}\n\tans.push_back(sum);\n}\nint main() {\n\tint kurikaesu;\n\tcin >> kurikaesu;\n\twhile (kurikaesu--) {\n\t\tans.clear();\n\t\tREP(i, 3) {\n\t\t\tREP(j, 3) {\n\t\t\t\tREP(k, 3) {\n\t\t\t\t\tREP(l, 2) {\n\t\t\t\t\t\tdices[i][j][k][l] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, 3) {\n\t\t\tREP(j, 3) {\n\t\t\t\tcin >> dices[0][i][j][0];\n\t\t\t\tdices[1][i][j][0] = dices[0][i][j][0];\n\t\t\t\tdices[2][i][j][0] = dices[0][i][j][0];\n\t\t\t}\n\t\t}\n\t\tREP(i, 3) {\n\t\t\tREP(j, 3) {\n\t\t\t\tcin >> dices[i][2][j][1];\n\t\t\t\tdices[i][1][j][1] = dices[i][2][j][1];\n\t\t\t\tdices[i][0][j][1] = dices[i][2][j][1];\n\t\t\t}\n\t\t}\n\t\tdfs();\n\t\tSORT(ans);\n\t\tans.erase(unique(ans.begin(), ans.end()), ans.end());\n\t\tREP(i, ans.size()) {\n\t\t\tcout << ans[i];\n\t\t\tif (i != ans.size() - 1)\n\t\t\t\tcout << ' ';\n\t\t}\n\t\tif (ans.empty())\n\t\t\tcout << 0;\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <climits>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef long long ll;\n\nstruct Dice{\nprivate:\n\tstatic const int _roll[4][6], _turn[2][6];\npublic:\n\tvector<int> value;\n\t//enum pos{ top, near, right, left, far, bottom };\n\n\tDice(){\n\t\tvalue.resize(6);\n\t\tfor (int i = 0; i < 6; ++i) value[i] = i;\n\t}\n\tDice(initializer_list<int> il){\n\t\tvalue.resize(6, -1);\n\t\tint cnt = 0;\n\t\tfor (auto &e : il){\n\t\t\tvalue[cnt++] = e;\n\t\t\tif (cnt >= 6) break;\n\t\t}\n\t\tfor (int i = 0; i < 6; ++i) if (value[i] < 0) value[i] = 5 - value[5 - i];\n\t}\n\n\tint top()const{ return value[0]; }\n\tint near()const{ return value[1]; }\n\tint right()const{ return value[2]; }\n\tint left()const{ return value[3]; }\n\tint far()const{ return value[4]; }\n\tint bottom()const{ return value[5]; }\n\n\tvoid roll(int dir){ // N, E, W, S\n\t\tvector<int> nxt(6);\n\t\tfor (int i = 0; i < 6; ++i){\n\t\t\tnxt[i] = value[_roll[dir][i]];\n\t\t}\n\t\tvalue = nxt;\n\t}\n\n\tvoid turn(int dir){ // L, R\n\t\tvector<int> nxt(6);\n\t\tfor (int i = 0; i < 6; ++i){\n\t\t\tnxt[i] = value[_turn[dir][i]];\n\t\t}\n\t\tvalue = nxt;\n\t}\n\n\tint &operator[](int i){\n\t\treturn value[i];\n\t}\n\tbool operator < (const Dice &rhs) const{\n\t\treturn value < rhs.value;\n\t}\n};\n\nostream& operator<<(ostream& os, const Dice &d){\n\tos << '{';\n\tfor (int i = 0; i < (int)d.value.size(); ++i) os << (i ? \", \" : \"\") << d.value[i];\n\tos << '}';\n\treturn os;\n}\n\n\nconst int Dice::_roll[4][6] = {\n\t{ 1, 5, 2, 3, 0, 4 }, // North\n\t{ 3, 1, 0, 5, 4, 2 }, // East\n\t{ 2, 1, 5, 0, 4, 3 }, // West\n\t{ 4, 0, 2, 3, 5, 1 }, // South\n};\n\nconst int Dice::_turn[2][6] = {\n\t{ 0, 3, 1, 4, 2, 5 }, // Left\n\t{ 0, 2, 4, 1, 3, 5 }, // Right\n};\n\nset<Dice> valid_set;\n\nvoid make_valid_set(){\n\trep(k, 3) rep(i, 4){\n\t\tDice d;\n\t\trep(j, k) d.roll(i);\n\t\trep(j, 4){\n\t\t\td.turn(0);\n\t\t\tvalid_set.insert(d);\n\t\t}\n\t}\n}\n\nmap<vector<int>, vector<vector<int>>> m;\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tmake_valid_set();\n\n\tvector<vector<Dice>> top(6), left(6);\n\tvector<vector<vector<Dice>>> left_top(6, vector<vector<Dice>>(6));\n\tfor (auto d : valid_set){\n\t\ttop[d.top()].push_back(d);\n\t\tleft[d.left()].push_back(d);\n\t\tleft_top[d.left()][d.top()].push_back(d);\n\t}\n\n\tfor (auto &d0 : valid_set){\n\t\t/*\n\t\t0 1 2\n\t\t3 x x\n\t\t4 x x\n\t\t*/\n\t\tfor (auto &d1 : left[d0.left()]){\n\t\t\tfor (auto &d2 : left[d0.left()]){\n\t\t\t\tfor (auto &d3 : top[d0.top()]){\n\t\t\t\t\tfor (auto &d4 : top[d0.top()]){\n\t\t\t\t\t\t// 5-8\n\t\t\t\t\t\tif (left_top[d3.left()][d1.top()].empty()) continue;\n\t\t\t\t\t\tauto &d5 = left_top[d3.left()][d1.top()][0];\n\t\t\t\t\t\tif (left_top[d3.left()][d2.top()].empty()) continue;\n\t\t\t\t\t\tauto &d6 = left_top[d3.left()][d2.top()][0];\n\t\t\t\t\t\tif (left_top[d4.left()][d1.top()].empty()) continue;\n\t\t\t\t\t\tauto &d7 = left_top[d4.left()][d1.top()][0];\n\t\t\t\t\t\tif (left_top[d4.left()][d2.top()].empty()) continue;\n\t\t\t\t\t\tauto &d8 = left_top[d4.left()][d2.top()][0];\n\n\t\t\t\t\t\tauto &con = m[{d0.near(), d1.near(), d2.near(), d3.near(), d4.near(), d5.near(), d6.near(), d7.near(), d8.near()}];\n\t\t\t\t\t\tcon.push_back({ d2.top(), d1.top(), d0.top(), d0.left(), d3.left(), d4.left() });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint n;\n\tcin >> n;\n\twhile (n--){\n\t\tvector<vector<int>> tl(3, vector<int>(6));\n\t\trep(i, 6) rep(j, 3) cin >> tl[2 - j][i];\n\t\trep(i, 6) rep(j, 3) --tl[2 - j][i];\n\n\t\tset<int> ans;\n\t\tfor (auto &x : m){\n\t\t\tauto &v = x.second;\n\t\t\tfor (auto &a : v){\n\t\t\t\trep(i, 6) if (tl[0][i] >= 0 && tl[0][i] != a[i]) goto NGA;\n\t\t\t\tfor (auto &b : v){\n\t\t\t\t\trep(i, 6) if (tl[1][i] >= 0 && tl[1][i] != b[i]) goto NGB;\n\t\t\t\t\tfor (auto &c : v){\n\t\t\t\t\t\trep(i, 6) if (tl[2][i] >= 0 && tl[2][i] != c[i]) goto NGC;\n\t\t\t\t\t\tgoto OK;\n\t\t\t\t\tNGC:;\n\t\t\t\t\t}\n\t\t\t\tNGB:;\n\t\t\t\t}\n\t\t\tNGA:;\n\t\t\t}\n\t\t\tcontinue;\n\t\tOK:\n\t\t\tans.insert(accumulate(ALL(x.first), 0) + 9);\n\t\t}\n\n\t\tbool f = true;\n\t\tfor (auto a : ans){\n\t\t\tcout << (f ? \"\" : \" \") << a;\n\t\t\tf = false;\n\t\t}\n\t\tif (ans.empty()) cout << 0;\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nchar order[25] = \"NNNNWNNNWNNNENNNENNNWNNN\";\n\nclass Dice{\npublic:\n\tDice(){\n\t\tinit();\n\t};\n\n\tvoid roll(char dst){\n\t\tfor(int i = 0; i < 6; i++) work[i] = number[i];\n\t\tswitch(dst){\n\t\tcase 'E':\n\t\t\tsetNumber(work[3],work[1],work[0],work[5],work[4],work[2]);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tsetNumber(work[1],work[5],work[2],work[3],work[0],work[4]);\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tsetNumber(work[4],work[0],work[2],work[3],work[5],work[1]);\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\tsetNumber(work[2],work[1],work[5],work[0],work[4],work[3]);\n\t\t\tbreak;\n\t\t}\n\t};\n\n\tvoid setPos(int num){\n\t\tfor(int i = 0; i <= num; i++){\n\t\t\troll(order[i]);\n\t\t}\n\t}\n\n\tint getTop(){\n\t\treturn number[0];\n\t}\n\n\tint getFront(){\n\t\treturn number[4];\n\t}\n\n\tint getEast(){\n\t\treturn number[2];\n\t}\n\n\tint getNorth(){\n\t\treturn number[1];\n\t}\n\n\tint getWest(){\n\t\treturn number[3];\n\t}\n\n\tint getBottom(){\n\t\treturn number[5];\n\t}\n\n\tint getSouth(){\n\t\treturn number[4];\n\t}\n\n\tvoid setNumber(int n0,int n1,int n2,int n3,int n4,int n5){\n\t\tnumber[0] = n0;\n\t\tnumber[1] = n1;\n\t\tnumber[2] = n2;\n\t\tnumber[3] = n3;\n\t\tnumber[4] = n4;\n\t\tnumber[5] = n5;\n\t}\n\n\tvoid init(){\n\t\tsetNumber(1,5,3,4,2,6);\n\t}\n\n\tvoid set(Dice arg){\n\t\tfor(int i = 0; i < 6; i++){\n\t\t\tnumber[i] = arg.number[i];\n\t\t}\n\t}\n\n\tint number[6];\n\tint work[6];\n};\n\nbool rangeCheck(int height,int row,int col){\n\tif(height >= 0 && height <= 2 && row >= 0 && row <= 2 && col >= 0 && col <= 2)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint top[3][3],front[3][3];\n\nstruct Puzzle{\n\tDice dice[3][3][3];\n\tbool check[3][3][3];\n\tint num;\n};\n\nvector<Puzzle> V;\nvector<int> ANS;\n\nvoid copyPuzzle(Puzzle& to,Puzzle from){\n\n\tfor(int a = 0; a < 3; a++){\n\t\tfor(int b = 0; b < 3; b++){\n\t\t\tfor(int c = 0; c < 3; c++){\n\t\t\t\tto.dice[a][b][c].set(from.dice[a][b][c]);\n\t\t\t\tto.check[a][b][c] = from.check[a][b][c];\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool adj_check(Puzzle puzzle,int height,int row,int col){\n\n\tif(rangeCheck(height+1,row,col) == true && puzzle.check[height+1][row][col] == true && puzzle.dice[height][row][col].getTop()+puzzle.dice[height+1][row][col].getBottom() != 7)return false;\n\n\tif(rangeCheck(height,row,col+1) == true && puzzle.check[height][row][col+1] == true && puzzle.dice[height][row][col].getEast()+puzzle.dice[height][row][col+1].getWest()!= 7)return false;\n\n\tif(rangeCheck(height,row,col-1) == true && puzzle.check[height][row][col-1] == true && puzzle.dice[height][row][col].getWest()+puzzle.dice[height][row][col-1].getEast()!= 7)return false;\n\n\tif(rangeCheck(height,row+1,col) == true && puzzle.check[height][row+1][col] == true && puzzle.dice[height][row][col].getSouth()+puzzle.dice[height][row+1][col].getNorth()!= 7)return false;\n\n\tif(rangeCheck(height,row-1,col) == true && puzzle.check[height][row-1][col] == true && puzzle.dice[height][row][col].getNorth()+puzzle.dice[height][row-1][col].getSouth()!= 7)return false;\n\n\tif(rangeCheck(height-1,row,col) == true && puzzle.check[height-1][row][col] == true && puzzle.dice[height][row][col].getBottom()+puzzle.dice[height-1][row][col].getTop()!= 7)return false;\n\n\treturn true;\n}\n\nvoid recursive(Puzzle puzzle);\n\nvoid func(Puzzle puzzle,int height,int row,int col){\n\tfor(int i = 0; i < 24; i++){\n\t\tPuzzle new_puzzle;\n\t\tcopyPuzzle(new_puzzle,puzzle);\n\t\tnew_puzzle.dice[height][row][col].setPos(i);\n\t\tif(!adj_check(new_puzzle,height,row,col))continue;\n\t\tnew_puzzle.check[height][row][col] = true;\n\t\tnew_puzzle.num = puzzle.num+1;\n\t\trecursive(new_puzzle);\n\t}\n}\n\nvoid recursive(Puzzle puzzle){\n\n\tif(puzzle.num == 27){\n\t\tV.push_back(puzzle);\n\t\treturn;\n\t}\n\n\tswitch(puzzle.num){\n\tcase 0:\n\t\tfunc(puzzle,2,1,1);\n\t\tbreak;\n\tcase 1:\n\t\tfunc(puzzle,2,0,1);\n\t\tbreak;\n\tcase 2:\n\t\tfunc(puzzle,2,1,2);\n\t\tbreak;\n\tcase 3:\n\t\tfunc(puzzle,2,2,1);\n\t\tbreak;\n\tcase 4:\n\t\tfunc(puzzle,2,1,0);\n\t\tbreak;\n\tcase 5:\n\t\tfunc(puzzle,2,0,0);\n\t\tbreak;\n\tcase 6:\n\t\tfunc(puzzle,2,0,2);\n\t\tbreak;\n\tcase 7:\n\t\tfunc(puzzle,2,2,2);\n\t\tbreak;\n\tcase 8:\n\t\tfunc(puzzle,2,2,0);\n\t\tbreak;\n\tcase 9:\n\t\tfunc(puzzle,1,1,1);\n\t\tbreak;\n\tcase 10:\n\t\tfunc(puzzle,1,0,1);\n\t\tbreak;\n\tcase 11:\n\t\tfunc(puzzle,1,1,2);\n\t\tbreak;\n\tcase 12:\n\t\tfunc(puzzle,1,2,1);\n\t\tbreak;\n\tcase 13:\n\t\tfunc(puzzle,1,1,0);\n\t\tbreak;\n\tcase 14:\n\t\tfunc(puzzle,1,0,0);\n\t\tbreak;\n\tcase 15:\n\t\tfunc(puzzle,1,0,2);\n\t\tbreak;\n\tcase 16:\n\t\tfunc(puzzle,1,2,2);\n\t\tbreak;\n\tcase 17:\n\t\tfunc(puzzle,1,2,0);\n\t\tbreak;\n\tcase 18:\n\t\tfunc(puzzle,0,1,1);\n\t\tbreak;\n\tcase 19:\n\t\tfunc(puzzle,0,0,1);\n\t\tbreak;\n\tcase 20:\n\t\tfunc(puzzle,0,1,2);\n\t\tbreak;\n\tcase 21:\n\t\tfunc(puzzle,0,2,1);\n\t\tbreak;\n\tcase 22:\n\t\tfunc(puzzle,0,1,0);\n\t\tbreak;\n\tcase 23:\n\t\tfunc(puzzle,0,0,0);\n\t\tbreak;\n\tcase 24:\n\t\tfunc(puzzle,0,0,2);\n\t\tbreak;\n\tcase 25:\n\t\tfunc(puzzle,0,2,2);\n\t\tbreak;\n\tcase 26:\n\t\tfunc(puzzle,0,2,0);\n\t\tbreak;\n\t}\n\n}\n\nvoid calc(){\n\n\tANS.clear();\n\n\tfor(int row = 0; row < 3; row++){\n\t\tfor(int col = 0; col < 3; col++)scanf(\"%d\",&top[row][col]);\n\t}\n\n\tfor(int row = 0; row < 3; row++){\n\t\tfor(int col = 0; col < 3; col++)scanf(\"%d\",&front[row][col]);\n\t}\n\n\tbool FLG;\n\n\tfor(int i = 0; i < V.size(); i++){\n\n\t\tFLG = true;\n\t\tfor(int row = 0; row < 3; row++){\n\t\t\tfor(int col = 0; col < 3; col++){\n\t\t\t\tif(top[row][col] != 0 && V[i].dice[2][row][col].getTop() != top[row][col]){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!FLG)break;\n\t\t}\n\t\tif(!FLG)continue;\n\n\t\tif((front[0][0] != 0 && V[i].dice[2][2][0].getSouth() != front[0][0]) ||\n\t\t\t\t(front[0][1] != 0 && V[i].dice[2][2][1].getSouth() != front[0][1]) ||\n\t\t\t\t(front[0][2] != 0 && V[i].dice[2][2][2].getSouth() != front[0][2]) ||\n\t\t\t\t(front[1][0] != 0 && V[i].dice[1][2][0].getSouth() != front[1][0]) ||\n\t\t\t\t(front[1][1] != 0 && V[i].dice[1][2][1].getSouth() != front[1][1]) ||\n\t\t\t\t(front[1][2] != 0 && V[i].dice[1][2][2].getSouth() != front[1][2]) ||\n\t\t\t\t(front[2][0] != 0 && V[i].dice[0][2][0].getSouth() != front[2][0]) ||\n\t\t\t\t(front[2][1] != 0 && V[i].dice[0][2][1].getSouth() != front[2][1]) ||\n\t\t\t\t(front[2][2] != 0 && V[i].dice[0][2][2].getSouth() != front[2][2])\n\t\t)continue;\n\n\t\tint sum = 0;\n\t\tfor(int h = 0; h <= 2; h++){\n\t\t\tfor(int row = 0; row <= 2; row++){\n\t\t\t\tsum += V[i].dice[h][row][2].getEast();\n\t\t\t}\n\t\t}\n\t\tANS.push_back(sum);\n\t}\n\n\tif(ANS.size() == 0){\n\t\tprintf(\"0\\n\");\n\t\treturn;\n\t}\n\n\tsort(ANS.begin(),ANS.end());\n\n\tprintf(\"%d\",ANS[0]);\n\tint pre = ANS[0];\n\n\tfor(int i = 1; i < ANS.size(); i++){\n\t\tif(ANS[i] != pre){\n\t\t\tprintf(\" %d\",ANS[i]);\n\t\t}\n\t\tpre = ANS[i];\n\t}\n\tprintf(\"\\n\");\n}\n\n\n\nint main(){\n\n\tPuzzle first;\n\tfirst.num = 0;\n\n\tfor(int a = 0; a < 3; a++){\n\t\tfor(int b = 0; b < 3; b++){\n\t\t\tfor(int c = 0; c < 3; c++)first.check[a][b][c] = false;\n\t\t}\n\t}\n\n\trecursive(first);\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tfor(int i = 0; i < N; i++)calc();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { 1, -1, 0, 0,0,0 }; const int dy[] = { 0,0, 1, -1, 0,0 };const int dz[] = { 0,0,0, 0, 1, -1 };\n\nconst int side[6][4] = {\n\t{ 2, 4, 5, 3 },{ 1, 3, 6, 4 },{ 1, 5, 6, 2 },{ 1, 2, 6, 5 },{ 1, 4, 6, 3 },{ 2, 3, 5, 4 }\n};\nconst int dice_right[6][6] = {\n\t{0,3,5,2,4,0},\n\t{ 4,0,1,6,0,3 },\n\t{ 2,6,0,0,1,5 },\n\t{ 5,1,0,0,6,2 },\n\t{ 3,0,6,1,0,4 },\n\t{ 0,4,2,5,3,0 }\n};\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nvi ans;\nvector<vvi> dices(3, vvi(3, vi(3)));//men tate yoko\nbool kakutei() {\n\tbool change = true;\n\twhile (change) {\n\t\tchange = false;\n\t\tREP(i, 3) {\n\t\t\tREP(j, 3) {\n\t\t\t\tif (dices[0][i][j] == 0) {\n\t\t\t\t\tREP(k, 3) {\n\t\t\t\t\t\tif (dices[1][k][j] > 0 && dices[2][k][2 - i] > 0) {\n\t\t\t\t\t\t\tdices[0][i][j] = dice_right[dices[1][k][j] - 1][dices[2][k][2 - i] - 1];\n\t\t\t\t\t\t\tif (dices[0][i][j] == 0)\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\tchange = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dices[1][i][j] == 0) {\n\t\t\t\t\tREP(k, 3) {\n\t\t\t\t\t\tif (dices[0][k][j] > 0 && dices[2][i][2 - k] > 0) {\n\t\t\t\t\t\t\tdices[1][i][j] = dice_right[dices[2][i][2 - k] - 1][dices[0][k][j] - 1];\n\t\t\t\t\t\t\tif (dices[1][i][j] == 0)\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\tchange = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dices[2][i][j] == -1) {\n\t\t\t\t\tREP(k, 3) {\n\t\t\t\t\t\tif (dices[0][2 - j][k] > 0 && dices[1][i][k] > 0) {\n\t\t\t\t\t\t\tdices[2][i][j] = dice_right[dices[0][2 - j][k] - 1][dices[1][i][k] - 1];\n\t\t\t\t\t\t\tif (dices[2][i][j] == 0)\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\tchange = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nvoid dfs() {\n\tvector<vvi> copy_dices = dices;\n\tREP(i, 3) {\n\t\tREP(j, 3) {\n\t\t\tif (dices[0][i][j] == 0) {\n\t\t\t\tREP(k, 6) {\n\t\t\t\t\tbool clear = true;\n\t\t\t\t\tREP(l, 3) {\n\t\t\t\t\t\tif (dices[1][l][j] > 0)\n\t\t\t\t\t\t\tif (dices[1][l][j] == k + 1 || dices[1][l][j] + k + 1 == 7)\n\t\t\t\t\t\t\t\tclear = false;\n\t\t\t\t\t\tif (dices[2][l][2 - i] > 0)\n\t\t\t\t\t\t\tif (dices[2][l][2 - i] == k + 1 || dices[2][l][2 - i] + k + 1 == 7)\n\t\t\t\t\t\t\t\tclear = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (clear) {\n\t\t\t\t\t\tdices[0][i][j] = k + 1;\n\t\t\t\t\t\tif (!kakutei()) {\n\t\t\t\t\t\t\tdices = copy_dices;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint ex[3] = { 0 };\n\t\t\t\t\t\tREP(l,3) {\n\t\t\t\t\t\t\tREP(x, 3) {\n\t\t\t\t\t\t\t\tREP(y, 3) {\n\t\t\t\t\t\t\t\t\tint a = dices[l][x][y];\n\t\t\t\t\t\t\t\t\tif (a == 4)\n\t\t\t\t\t\t\t\t\t\ta = 3;\n\t\t\t\t\t\t\t\t\tif (a == 5)\n\t\t\t\t\t\t\t\t\t\ta = 2;\n\t\t\t\t\t\t\t\t\tif (a == 6)\n\t\t\t\t\t\t\t\t\t\ta = 1;\n\t\t\t\t\t\t\t\t\tex[a - 1]++;\n\t\t\t\t\t\t\t\t\tif (ex[a - 1] > 9)\n\t\t\t\t\t\t\t\t\t\tclear = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!clear)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tdfs();\n\t\t\t\t\t\tdices = copy_dices;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, 3) {\n\t\tREP(j, 3) {\n\t\t\tif (dices[1][i][j] == 0) {\n\t\t\t\tREP(k, 6) {\n\t\t\t\t\tbool clear = true;\n\t\t\t\t\tREP(l, 3)\n\t\t\t\t\t\tif (dices[0][l][j] == k + 1 || dices[0][l][j] + k + 1 == 7)\n\t\t\t\t\t\t\tclear = false;\n\t\t\t\t\tif (clear) {\n\t\t\t\t\t\tdices[1][i][j] = k + 1;\n\t\t\t\t\t\tif (!kakutei()) {\n\t\t\t\t\t\t\tdices = copy_dices;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint ex[3] = { 0 };\n\t\t\t\t\t\tREP(l, 3) {\n\t\t\t\t\t\t\tREP(x, 3) {\n\t\t\t\t\t\t\t\tREP(y, 3) {\n\t\t\t\t\t\t\t\t\tint a = dices[l][x][y];\n\t\t\t\t\t\t\t\t\tif (a == 4)\n\t\t\t\t\t\t\t\t\t\ta = 3;\n\t\t\t\t\t\t\t\t\tif (a == 5)\n\t\t\t\t\t\t\t\t\t\ta = 2;\n\t\t\t\t\t\t\t\t\tif (a == 6)\n\t\t\t\t\t\t\t\t\t\ta = 1;\n\t\t\t\t\t\t\t\t\tex[a - 1]++;\n\t\t\t\t\t\t\t\t\tif (ex[a - 1] > 9)\n\t\t\t\t\t\t\t\t\t\tclear = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!clear)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tdfs();\n\t\t\t\t\t\tdices = copy_dices;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tREP(i, 3) {\n\t\tREP(j, 3) {\n\t\t\tsum += dice_right[dices[0][2 - j][2] - 1][dices[1][i][2] - 1];\n\t\t}\n\t}\n\tans.push_back(sum);\n}\nint main() {\n\tint kurikaesu;\n\tcin >> kurikaesu;\n\twhile (kurikaesu--) {\n\t\tans.clear();\n\t\tREP(i, 3) {\n\t\t\tREP(j, 3) {\n\t\t\t\tREP(k, 3) {\n\t\t\t\t\tdices[i][j][k] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, 3) {\n\t\t\tREP(j, 3) {\n\t\t\t\tcin >> dices[0][i][j];\n\t\t\t}\n\t\t}\n\t\tREP(i, 3) {\n\t\t\tREP(j, 3) {\n\t\t\t\tcin >> dices[1][i][j];\n\t\t\t}\n\t\t}\n\t\tif (kakutei())\n\t\t\tdfs();\n\t\telse\n\t\t\tgoto emp;\n\t\tSORT(ans);\n\t\tans.erase(unique(ans.begin(), ans.end()), ans.end());\n\t\tREP(i, ans.size()) {\n\t\t\tcout << ans[i];\n\t\t\tif (i != ans.size() - 1)\n\t\t\t\tcout << ' ';\n\t\t}\nemp:\n\t\tif (ans.empty())\n\t\t\tcout << 0;\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int r[][6] = {\n\t{0, 2, 3, 4, 1, 5},\n\t{4, 1, 0, 3, 5, 2},\n\t{1, 5, 2, 0, 4, 3}\n};\nvector<vi> ds;\nint cs, t[3][3], f[3][3], dice[3][3][3];\nset<int> ans;\n\nvi rot(int d, const vi &v){\n\tvi res;\n\trep(i, 6) res.pb(v[r[d][i]]);\n\treturn res;\n}\nvoid gen(set<vi> &s, const vi &v){\n\tif(s.count(v)) return;\n\ts.insert(v);\n\trep(i, 3){\n\t\tvi nv = v;\n\t\trep(j, 3){\n\t\t\tnv = rot(i, nv);\n\t\t\tgen(s, nv);\n\t\t}\n\t}\n}\nvoid rec(int x, int y, int z){\n\tif(z == 3){\n\t\trec(x, y + 1, 0);\n\t\treturn;\n\t}\n\tif(y == 3){\n\t\trec(x + 1, 0, 0);\n\t\treturn;\n\t}\n\tif(x >= 3){\n\t\tint tmp = 0;\n\t\trep(i, 3) rep(j, 3){\n\t\t\ttmp += ds[dice[i][2][j]][2];\n\t\t}\n\t\tans.insert(tmp);\n\t\treturn;\n\t}\n\t//cerr<<x<<\" \"<<y<<\" \"<<z<<endl;\n\t\n\trep(i, ds.size()){\n\t\tif(t[z][y] && ds[i][0] != t[z][y] || f[x][y] && ds[i][1] != f[x][y]) continue;\n\t\tbool ok = 1;\n\t\trep(d, 6){\n\t\t\tconst int dz[] = {0, 1, 0, -1, 0, 0};\n\t\t\tconst int dy[] = {0, 0, 1, 0, -1, 0};\n\t\t\tconst int dx[] = {-1, 0, 0, 0, 0, 1};\n\t\t\t\n\t\t\tint nx = x + dx[d], ny = y + dy[d], nz = z + dz[d];\n\t\t\tif(nx < 0 || ny < 0 || nz < 0 || nx >= 3 || ny >= 3 || nz >= 3) continue;\n\t\t\tif(dice[nx][ny][nz] < 0) continue;\n\t\t\tif(ds[dice[nx][ny][nz]][d] != ds[i][d]) ok = 0;\n\t\t}\n\t\tif(ok){\n\t\t\tdice[x][y][z] = i;\n\t\t\trec(x, y, z + 1);\n\t\t\tdice[x][y][z] = -1;\n\t\t}\n\t}\n}\n\nint main(){\n\tset<vi> s;\n\tvi v;\n\tv.pb(1); v.pb(2); v.pb(3); v.pb(5); v.pb(4); v.pb(6);\n\tgen(s, v);\n\tds = vector<vi>(all(s));\n\t\n\tcin >> cs;\n\twhile(cs--){\n\t\trep(i, 3) rep(j, 3) cin >> t[i][j];\n\t\trep(i, 3) rep(j, 3) cin >> f[i][j];\n\t\t\n\t\tmemset(dice, -1, sizeof(dice));\n\t\tans.clear();\n\t\trec(0, 0, 0);\n\t\tif(ans.empty()) cout << 0 << endl;\n\t\telse{\n\t\t\tbool f = 1;\n\t\t\teach(i, ans){\n\t\t\t\tif(f) f = 0;\n\t\t\t\telse cout << \" \";\n\t\t\t\tcout << *i;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Dice{\nprivate:\n    void roll(int a,int b,int c,int d){\n        swap(x[a],x[b]);\n        swap(x[b],x[d]);\n        swap(x[c],x[d]);\n    }\npublic:\n    int x[6];\n    Dice(){\n        for(int i = 0 ; i < 6 ; i++){\n            x[i] = i+1;\n        }\n    }\n    void roll_N(){ roll(0,1,4,5); }\n    void roll_E(){ roll(0,3,2,5); }\n    void rotation(){ roll(1,2,3,4); }\n    void roll(int top,int front){\n        for(int i = 0 ; i < 2 ; i++){\n            for(int j = 0 ; j < 4 ; j++){\n                roll_N();\n                if(top == x[0]) goto next;\n            }\n            roll_E();\n        }\n    next:\n        for(int i = 0 ; i < 4 ; i++){\n            rotation();\n            if(front == x[1]) break; \n        }\n    }\n    void clear(){ memset(x,0,sizeof(x)); }  \n}; \n\nbool can[60];\nDice d[3][3][3];\nint bit[27];\n\nint calc(){\n    int sum = 0;\n    for(int i = 0 ; i < 3 ; i++){\n        for(int j = 0 ; j < 3 ; j++){\n            sum += d[i][j][2].x[2];\n        }\n    }\n    return sum;\n}\n\nbool check(int v){\n    int a = v/9, b = (v%9)/3, c = (v%9)%3;\n    Dice dice = d[a][b][c];\n    dice.roll(1,2);\n    for(int i = 0 ; i < 6 ; i++){\n        if(dice.x[i] != i+1) return false;\n    }\n    return true;\n}\n\nvoid solve(int v,int p,int S){\n    if(v == 27){\n        can[calc()] = 1;\n        return;\n    }\n    if(p == 6){\n        if(!check(v)) return;\n        solve(v+1,0,bit[v+1]);\n        return;\n    }\n    int a = v/9, b = (v%9)/3, c = (v%9)%3;\n    if(a-1 >= 0 && p == 0){\n        if(d[a][b][c].x[p] == 0){\n            int x = 7 - d[a-1][b][c].x[5];\n            if(S >> x & 1) return;\n            d[a][b][c].x[p] = x;\n            int x2 = d[a][b][c].x[5-p];\n            if(x2 == 0 || x + x2 == 7){\n                solve(v,p+1,S|(1<<x));\n            }\n            d[a][b][c].x[p] = 0;\n        }else{\n            if(d[a][b][c].x[p] + d[a-1][b][c].x[5] == 7){\n                solve(v,p+1,S);\n            }\n        }\n        return;\n    }\n    if(b-1 >= 0 && p == 4){\n        if(d[a][b][c].x[p] == 0){\n            int x = 7 - d[a][b-1][c].x[1];\n            if(S >> x & 1) return;\n            d[a][b][c].x[p] = x;\n            int x2 = d[a][b][c].x[5-p];\n            if(x2 == 0 || x + x2 == 7){\n                solve(v,p+1,S|(1<<x));\n            }\n            d[a][b][c].x[p] = 0;\n        }else{\n            if(d[a][b][c].x[p] + d[a][b-1][c].x[1] == 7){\n                solve(v,p+1,S);     \n            }\n        }\n        return;\n    }\n    if(c-1 >= 0 && p == 3){\n        if(d[a][b][c].x[p] == 0){\n            int x = 7 - d[a][b][c-1].x[2];\n            if(S >> x & 1) return;\n            d[a][b][c].x[p] = x;\n            int x2 = d[a][b][c].x[5-p];\n            if(x2 == 0 || x + x2 == 7){\n                solve(v,p+1,S|(1<<x));\n            }\n            d[a][b][c].x[p] = 0;\n        }else{\n            if(d[a][b][c].x[p] + d[a][b][c-1].x[2] == 7){\n                solve(v,p+1,S);\n            }\n        }\n        return;\n    }\n    \n    if(d[a][b][c].x[p] == 0){\n        if(d[a][b][c].x[5-p] != 0){\n            int x = 7 - d[a][b][c].x[5-p];\n            if(S >> x & 1) return;\n            d[a][b][c].x[p] = x;\n            solve(v,p+1,S|(1<<x));\n            d[a][b][c].x[p] = 0;\n        }else{\n            for(int i = 0 ; i < 6 ; i++){\n                d[a][b][c].x[p] = i+1;\n                int x = d[a][b][c].x[5-p];\n                if(!(S >> (i+1) & 1) &&\n                   (x == 0 || x + d[a][b][c].x[p] == 7)){\n                    solve(v,p+1,S|(1<<(i+1)));\n                }\n                d[a][b][c].x[p] = 0;\n            }\n        }\n    }else{\n        int x = d[a][b][c].x[5-p];\n        if(x + d[a][b][c].x[p] == 7){\n            solve(v,p+1,S);\n        }\n    }\n}\n\nvoid print(){\n    bool sp = false;\n    for(int i = 0 ; i < 60 ; i++){\n        if(can[i]){\n            if(sp) cout << \" \";\n            sp = true;\n            cout << i;\n        }\n    }\n    if(!sp) cout << 0;\n    cout << endl;\n}\n\nvoid init(){\n    fill(bit,bit+27,1);\n    memset(can,0,sizeof(can));\n    for(int i = 0 ; i < 3 ; i++){\n        for(int j = 0 ; j < 3 ; j++){\n            for(int k = 0 ; k < 3 ; k++){\n                d[i][j][k].clear();\n            }\n        }\n    }\n}\n\nint main(){\n    int N;\n    cin >> N;\n    while(N--){\n        init();\n        int in;\n        for(int i = 0 ; i < 3 ; i++){\n            for(int j = 0 ; j < 3 ; j++){\n                cin >> in;\n                if(in != 0){\n                    d[0][i][j].x[0] = in;\n                    d[0][i][j].x[5] = 7-in;\n                    bit[3*i+j] |= 1<<in;\n                    bit[3*i+j] |= 1<<(7-in);\n                }\n            }\n        }\n        for(int i = 0 ; i < 3 ; i++){\n            for(int j = 0 ; j < 3 ; j++){\n                cin >> in;\n                if(in != 0){\n                    d[i][2][j].x[1] = in;\n                    d[i][2][j].x[4] = 7-in;\n                    bit[9*i+6+j] |= 1<<in;\n                    bit[9*i+6+j] |= 1<<(7-in);\n                }\n            }\n        }\n        solve(0,0,bit[0]);\n        print();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntemplate <class T>\nstruct dice {\n  T t,b,n,s,e,w;              // top bottom north south east west\n  dice() {}\n  dice(T t, T b, T n, T s, T e, T w) : t(t),b(b),n(n),s(s),e(e),w(w) {}\n  void roll(T &a, T &b, T &c, T &d) { swap(a,b); swap(b,c); swap(c,d); }\n  void roll_x() { roll(t, n, b, s); }\n  void roll_y() { roll(t, w, b, e); }\n  void roll_z() { roll(s, e, n, w); }\n  vector<dice> all_rolls() {\n    vector<dice> ret;\n    for (int k=0; k<6; (k&1?roll_y():roll_x()),++k)\n      for (int i=0; i<4; roll_z(), ++i)\n        ret.push_back(*this);\n    return ret;\n  }\n};\n \ndice<int> di[3][3][3];              // ツ偲ィツ前ツづ個債カツ湘」ツつェツ個エツ点ツ、ツ右ツ古シツつォXツ篠イツ・ツ可コツ古シツつォYツ篠イツ・ツ可彁ツ篠イ\nint top[3][3];\nint front[3][3];\n\nset<int> ans;\n\nvoid dfs(int x, int y, int z) {\n  if (x == 3) { dfs(0,y+1,z); return; }\n  if (y == 3) { dfs(0, 0, z+1); return; }\n  if (z == 3) {\n    int sum = 0; \n    REP(i, 3) REP(j, 3)\n      sum += di[2][i][j].e;\n    ans.insert(sum);\n    return;\n  }\n  dice<int> d(1,6,5,2,3,4);\n  vector<dice<int> > all = d.all_rolls();\n  int res = 0;\n  REP(i, all.size()) {\n    if (z == 0 && front[y][x] && all[i].s != front[y][x]) continue;\n    if (y == 0 && top[2-z][x] && all[i].t != top[2-z][x]) continue;\n    if (x && di[x-1][y][z].e + all[i].w != 7) continue;\n    if (y && di[x][y-1][z].b + all[i].t != 7) continue;\n    if (z && di[x][y][z-1].n + all[i].s != 7) continue;\n    di[x][y][z] = all[i];\n    //cout << \"i = \" << i << \" \" << di[x][y][z].t << \" \" << di[x][y][z].s << \" \" << di[x][y][z].e << endl;\n    dfs(x+1,y,z);\n  }\n}\n\nint main() {\n  int N;\n  cin >> N;\n  while(N--) {\n    REP(i, 3) REP(j, 3)\n      cin >> top[i][j];\n    REP(i, 3) REP(j, 3)\n      cin >> front[i][j];\n    ans.clear();\n    dfs(0,0,0);\n    if (ans.size()) {\n      FOR(it, ans)\n        cout << *it << \" \";\n      cout << endl;\n    } else {\n      cout << 0 << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n// (top,front)\nint R[7][7]={\n    {-1, -1, -1, -1, -1, -1, -1},\n    {-1, -1,  3,  5,  2,  4, -1},\n    {-1,  4, -1,  1,  6, -1,  3},\n    {-1,  2,  6, -1, -1,  1,  5},\n    {-1,  5,  1, -1, -1,  6,  2},\n    {-1,  3, -1,  6,  1, -1,  4},\n    {-1, -1,  4,  2,  5,  3, -1},\n};\n\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nconst vvi I(3,vi(3));\n\nvvi T,F;\nvvi t,f;\nvector<int> ans;\n\nvoid check(){\n    vvi r(I);\n    int rsum = 0;\n    rep(i,3)rep(j,3){\n        r[i][j] = R[T[j][0]][F[i][0]];\n        if(r[i][j]==-1) return;\n        rsum += r[i][j];\n    }\n\n    rep(fi,3)rep(fj,3){\n        if(f[fi][fj]==0){\n            for(int i=1; i<=6; ++i){\n                if(R[t[0][fj]][i] == r[fi][0]){\n                    f[fi][fj] = i;\n                }\n            }\n\n            if(f[fi][fj]==0) return;\n        }\n    }\n\n    rep(ti,3)rep(tj,3){\n        if(t[ti][tj]==0){\n            for(int i=1; i<=6; ++i){\n                if(R[i][f[0][tj]] == r[0][ti]){\n                    t[ti][tj] = i;\n                }\n            }\n\n            if(t[ti][tj]==0) return;\n        }\n    }\n\n\n    rep(ti,3)rep(fi,3)rep(x,3){\n        int rv = r[fi][ti];\n        if(R[t[ti][x]][f[fi][x]] != rv) return;\n    }\n\n    ans.pb(rsum);\n}\n\nvoid dfs(int d){\n    if(d==8){\n        t = T;\n        f = F;\n        check();\n        return;\n    }\n\n    if(d<3){\n        if(T[d][0]==0){\n            for(int i=1; i<=6; ++i){\n                T[d][0] = i;\n                dfs(d+1);\n                T[d][0] = 0;\n            }\n        }\n        else dfs(d+1);\n    }\n    else if(d<6){\n        if(F[d-3][0]==0){\n            for(int i=1; i<=6; ++i){\n                F[d-3][0] = i;\n                dfs(d+1);\n                F[d-3][0] = 0;\n            }\n        }\n        else dfs(d+1);\n    }\n    else{\n        if(T[0][d-5]==0){\n            for(int i=1; i<=6; ++i){\n                T[0][d-5] = i;\n                dfs(d+1);\n                T[0][d-5] = 0;\n            }\n        }\n        else dfs(d+1);\n    }\n}\n\nvoid solve(){\n    T = I;\n    F = I;\n    rep(i,3)rep(j,3) cin >>T[i][j];\n    rep(i,3)rep(j,3) cin >>F[i][j];\n\n    ans.clear();\n    dfs(0);\n\n    sort(all(ans));\n    ans.erase(unique(all(ans)), ans.end());\n    int n = ans.size();\n    if(n==0) cout << 0 << endl;\n    else rep(i,n) cout << ans[i] << \" \\n\"[i==n-1];\n}\n\nint main(){\n    int n;\n    cin >>n;\n    rep(i,n) solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1253: Dice Puzzle\n// 2017.10.21 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nchar rot[24][7] = {\n\t{ 0,1,2,3,4,5,6 },{ 0,1,3,5,2,4,6 },{ 0,1,4,2,5,3,6 },{ 0,1,5,4,3,2,6 },\n\t{ 0,2,6,3,4,1,5 },{ 0,2,3,1,6,4,5 },{ 0,2,1,4,3,6,5 },{ 0,2,4,6,1,3,5 },\n\t{ 0,3,1,2,5,6,4 },{ 0,3,2,6,1,5,4 },{ 0,3,5,1,6,2,4 },{ 0,3,6,5,2,1,4 },\n\t{ 0,4,1,5,2,6,3 },{ 0,4,2,1,6,5,3 },{ 0,4,5,6,1,2,3 },{ 0,4,6,2,5,1,3 },\n\t{ 0,5,1,3,4,6,2 },{ 0,5,3,6,1,4,2 },{ 0,5,4,1,6,3,2 },{ 0,5,6,4,3,1,2 },\n\t{ 0,6,2,4,3,5,1 },{ 0,6,3,2,5,4,1 },{ 0,6,5,3,4,2,1 },{ 0,6,4,5,2,3,1 } };\n\ntypedef struct { int x, y, z; } T;\nT n2xyz[28];\n\nchar dice[3][3][3][7];\nint top[3][3], front[3][3];\nchar ans[55], sz;\n\nvoid combi(char dice[3][3][3][7], int n)\n{\n\tint s, x, y, z, i;\n\n\tif (n == 27) {\n\t\tfor (s = 0, y = 0; y < 3; y++) for (z = 0; z < 3; z++) s += dice[z][y][2][3];\n\t\tsz = 1;\n\t\tans[s] = 1;\n\t\treturn;\n\t}\n\tx = n2xyz[n].x, y = n2xyz[n].y, z = n2xyz[n].z;\n\tfor (i = 0; i < 24; i++) {\n\t\tmemcpy(dice[z][y][x], rot[i], 7);\n\t\tif (x > 0 && dice[z][y][x][4] + dice[z][y][x-1][3] != 7) continue;\n\t\tif (y == 0) { if (front[z][x] > 0 && front[z][x] != dice[z][0][x][2]) continue; }\n\t\telse { if (dice[z][y][x][2] + dice[z][y-1][x][5] != 7) continue; }\n\t\tif (z == 0) { if (top[y][x] > 0 && top[y][x] != dice[0][y][x][1]) continue; }\n\t\telse { if (dice[z][y][x][1] + dice[z-1][y][x][6] != 7) continue; }\n\t\tcombi(dice, n + 1);\n\t}\n}\n\nint main()\n{\n\tint n, i, x, y, z;\n\n\tfor (x = 0; x < 3; x++) for (y = 0; y < 3; y++) for (z = 0; z < 3; z++) {\n\t\tn = 9 * z + 3 * y + x;\n\t\tn2xyz[n].x = x, n2xyz[n].y = y, n2xyz[n].z = z;\n\t}\n\n\tscanf(\"%d\", &n);\n\twhile (n-- > 0) {\n\t\tmemset(ans, 0, sizeof(ans));\n\t\tfor (y = 2; y >= 0; y--) for (x = 0; x < 3; x++) scanf(\"%d\", &top[y][x]);\n\t\tfor (z = 0; z < 3; z++) for (x = 0; x < 3; x++) scanf(\"%d\", &front[z][x]);\n\n\t\tsz = 0;\n\t\tcombi(dice, 0);\n\t\tif (sz == 0) puts(\"0\");\n\t\telse {\n\t\t\tfor (i = 9; i <= 54; i++) if (ans[i]) {\n\t\t\t\tif (sz > 0) sz = 0;\n\t\t\t\telse putchar(' ');\n\t\t\t\tprintf(\"%d\", i);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tint[][] top = new int[3][3];\n\tint[][] front = new int[3][3];\n\t\n\tDice<Integer> init = new Dice<>(1, 6, 5, 2, 3, 4);\n\tpublic int toIdx(int x, int y, int z){\n\t\treturn x + y * 3 + z * 9;\n\t}\n\tpublic void dfs(int idx, ArrayList<Dice<Integer>> dices, Set<Integer> answer){\n\t\tif(idx == 27){\n\t\t\tint ans = 0;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\t\tint id = toIdx(2, i, j);\n\t\t\t\t\tans += dices.get(id).get(Dice.EAST);\n\t\t\t\t}\n\t\t\t}\n\t\t\tanswer.add(ans);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint x = idx % 3;\n\t\tint y = idx / 3 % 3;\n\t\tint z = idx / 9 % 3;\n\t\t\n\t\tDice<Integer> cur = init;\n\t\tfor(int i = 0; i < 6; i++){\n\t\t\tfor(int j = 0; j < 4; cur = cur.rollClockWise(), j++){\n\t\t\t\tif(x != 0 && dices.get(toIdx(x - 1, y, z)).get(Dice.EAST) + cur.get(Dice.WEST) != 7) continue;\n\t\t\t\tif(y != 0 && dices.get(toIdx(x, y - 1, z)).get(Dice.SOUTH) + cur.get(Dice.NORTH) != 7) continue;\n\t\t\t\tif(z != 0 && dices.get(toIdx(x, y, z - 1)).get(Dice.BOTTOM) + cur.get(Dice.TOP) != 7) continue;\n\t\t\t\tif(z == 0 && top[y][x] != 0 && top[y][x] != cur.get(Dice.TOP)) continue;\n\t\t\t\tif(y == 2 && front[z][x] != 0 && front[z][x] != cur.get(Dice.SOUTH)) continue;\n\t\t\t\tdices.set(idx, cur);\n\t\t\t\tdfs(idx + 1, dices, answer);\n\t\t\t}\n\t\t\tif(i % 2 == 0) cur = cur.rollNorth();\n\t\t\telse cur = cur.rollEast();\n\t\t}\n\t}\n\t\n\tpublic void solve() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\twhile(N-- > 0){\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\t\ttop[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\t\tfront[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrayList<Dice<Integer>> dices = new ArrayList<>();\n\t\t\tfor(int i = 0; i < 27; i++){\n\t\t\t\tdices.add(null);\n\t\t\t}\n\t\t\tTreeSet<Integer> ans = new TreeSet<>();\n\t\t\tdfs(0, dices, ans);\n\t\t\tif(ans.size() == 0){\n\t\t\t\tSystem.out.println(0);\n\t\t\t}else{\n\t\t\t\tboolean flg = false;\n\t\t\t\tfor(int val : ans){\n\t\t\t\t\tif(flg) System.out.print(\" \");\n\t\t\t\t\tflg = true;\n\t\t\t\t\tSystem.out.print(val);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\t\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n}\n\nclass Dice<T> {\n\tpublic static final int TOP = 0;\n\tpublic static final int BOTTOM = 5;\n\tpublic static final int EAST = 4;\n\tpublic static final int WEST = 1;\n\tpublic static final int NORTH = 3;\n\tpublic static final int SOUTH = 2;\n\t\n\tprivate final int[] id = new int[6];\n\tprivate final ArrayList<T> values;\n\t\n\tpublic Dice(){\n\t\tvalues = new ArrayList<>(6);\n\t\tfor(int i = 0; i < 6; i++){\n\t\t\tid[i] = i;\n\t\t\tvalues.add(null);\n\t\t}\n\t}\n\t\n\tpublic Dice(T top, T bottom, T north, T south, T east, T west){\n\t\tthis();\n\t\tvalues.set(TOP, top);\n\t\tvalues.set(BOTTOM, bottom);\n\t\tvalues.set(EAST, east);\n\t\tvalues.set(WEST, west);\n\t\tvalues.set(NORTH, north);\n\t\tvalues.set(SOUTH, south);\n\t}\n\t\n\tprivate Dice(Dice<T> d){\n\t\tvalues = d.values;\n\t\tfor(int i = 0; i < 6; i++){\n\t\t\tid[i] = d.id[i];\n\t\t}\n\t}\n\n\tpublic Dice<T> rollNorth(){\n\t\treturn roll(TOP, SOUTH, BOTTOM, NORTH);\n\t}\n\tpublic Dice<T> rollSouth(){\n\t\treturn roll(TOP, NORTH, BOTTOM, SOUTH);\n\t}\n\tpublic Dice<T> rollWest(){\n\t\treturn roll(TOP, EAST, BOTTOM, WEST);\n\t}\n\tpublic Dice<T> rollEast(){\n\t\treturn roll(TOP, WEST, BOTTOM, EAST);\n\t}\n\tpublic Dice<T> rollClockWise(){\n\t\treturn roll(NORTH, WEST, SOUTH, EAST);\n\t}\n\tpublic Dice<T> rollCounterClockWise(){\n\t\treturn roll(NORTH, EAST, SOUTH, WEST);\n\t}\n\t\n\tpublic T getTop(){\n\t\treturn values.get(id[TOP]);\n\t}\n\tpublic T get(int idx){\n\t\treturn values.get(id[idx]);\n\t}\n\t\n\tpublic int getId(int face){\n\t\treturn id[face];\n\t}\n\t\n\tpublic boolean equalsDirection(Dice<T> d){\n\t\treturn d.getId(TOP) == getId(TOP) && d.getId(EAST) == getId(EAST);\n\t}\n\t\n\n\tprivate Dice<T> roll(int a, int b, int c, int d){\n\t\tDice<T> nd = new Dice<T>(this);\n\t\tint tmp = nd.id[a];\n\t\tnd.id[a] = nd.id[b];\n\t\tnd.id[b] = nd.id[c];\n\t\tnd.id[c] = nd.id[d];\n\t\tnd.id[d] = tmp;\n\t\treturn nd;\n\t}\n\tpublic String toString(){\n\t\tStringBuilder build = new StringBuilder();\n\t\tbuild.append(\"TOP:\");\n\t\tbuild.append(values.get(id[TOP]));\n\t\tbuild.append(\",BOTTOM:\");\n\t\tbuild.append(values.get(id[BOTTOM]));\n\t\tbuild.append(\",NORTH:\");\n\t\tbuild.append(values.get(id[NORTH]));\n\t\tbuild.append(\",SOUTH:\");\n\t\tbuild.append(values.get(id[SOUTH]));\n\t\tbuild.append(\",WEST:\");\n\t\tbuild.append(values.get(id[WEST]));\n\t\tbuild.append(\",EAST:\");\n\t\tbuild.append(values.get(id[EAST]));\n\t\treturn build.toString();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\npublic class Main {\n\t\n\t//Reference nanikaka's code\n\tDice [][][] data;\n\tDice [][][] work;\n\tint [] vx = {-1, 0, 0, 1,-1, 0, 0};\n\tint [] vy = {-1, 0, 1, 0, 0,-1, 0};\n\tint [] vz = {-1,-1, 0, 0, 0, 0, 1};\n\tArrayList<String> map;\n\tHashSet<Integer> set;\n\t//dice is, 2 = south, 3 = east, 1 = top, 6 = bottom, 4 = west, 5 = north;\n\n\tclass Dice{\n\t\tint [] dice;\n\t\tpublic Dice(int[] dice) {\n\t\t\tthis.dice = Arrays.copyOf(dice, 7);\n\t\t}\n\t\tprivate void slide() {\n\t\t\tswap(2,4,5,3);\n\t\t}\n\t\tprivate void turn(char c) {\n\t\t\tswitch(c){\n\t\t\tcase 'n':\n\t\t\t\tswap(1,5,6,2); break;\n\t\t\tcase 's':\n\t\t\t\tswap(1,2,6,5); break;\n\t\t\tcase 'w':\n\t\t\t\tswap(1,4,6,3); break;\n\t\t\tcase 'e':\n\t\t\t\tswap(1,3,6,4); break;\n\t\t\t}\n\t\t}\n\t\tprivate void swap(int i, int j, int k, int l) {\n\t\t\tint temp = dice[l];\n\t\t\tdice[l] = dice[k];\n\t\t\tdice[k] = dice[j];\n\t\t\tdice[j] = dice[i];\n\t\t\tdice[i] = temp;\n\t\t}\n\t\tpublic String toString(){\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(int i = 0; i <= 6; i++){\n\t\t\t\tsb.append(dice[i]);\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner (System.in);\n\t\tinit();\n\t\tint dataset = sc.nextInt();\n\t\twhile(dataset-- > 0){\n\t\t\tdata = new Dice[3][3][3];\n\t\t\t//input\n\t\t\t\n\t\t\tfor(int i = 0 ; i < 3; i++){\n\t\t\t\tfor(int j = 0 ; j < 3; j ++){\n\t\t\t\t\tfor(int k = 0 ; k < 3; k++){\n\t\t\t\t\t\tdata[i][j][k] = new Dice(new int[7]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\t\tdata[i][j][0].dice[1] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < 3 ; i++){\n\t\t\t\tfor(int j = 0 ; j < 3; j++){\n\t\t\t\t\tdata[2][j][i].dice[2] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tset = new HashSet<Integer>();\n\t\t\twork = deepcopy(data);\n\t\t\tdfs(2, 0, 0);\n\t\t\tif(set.size() == 0){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tArrayList<Integer> al = new ArrayList<Integer>();\n\t\t\tfor(int value: set){\n\t\t\t\tal.add(value);\n\t\t\t}\n\t\t\tCollections.sort(al);\n\t\t\tSystem.out.print(al.get(0));\n\t\t\tfor(int i = 1; i < al.size(); i++){\n\t\t\t\tSystem.out.print(\" \" + al.get(i));\n\t\t\t}\n\t\t\tSystem.out.println();\n\n\t\t\t//debug\n\t\t\t//disp();\n\t\t}\n\t}\n\n\tprivate void dfs(int y, int x, int z) {\n\t\t//System.out.println(\"y = \" + y + \" x= \" + x + \" z= \" + z);\n\t\tif(x == 3){\n\t\t\tint res = 0;\n\t\t\tfor(int i = 0 ; i < 3; i++){\n\t\t\t\tfor(int j = 0 ; j < 3; j++){\n\t\t\t\t\tres += data[i][2][j].dice[3];\n\t\t\t\t}\n\t\t\t}\n\t\t\tset.add(res);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t//数字を割り当てる\n\t\tfor(int ii = 0; ii < map.size(); ii++){\n\t\t\tint [] w = new int[7];\n\t\t\tfor(int i = 1; i <= 6; i++){\n\t\t\t\tw[i] = map.get(ii).charAt(i) - '0';\n\t\t\t}\n\t\t\tDice d = new Dice(w);\n\t\t\tboolean isvalid = true;\n\t\t\tfor(int i = 1; i <= 4; i++){\n\t\t\t\tif(i == 3) continue;\n\t\t\t\tint xxx = x + vx[i];\n\t\t\t\tint yyy = y + vy[i];\n\t\t\t\tint zzz = z + vz[i];\n\t\t\t\tif(! isOK(xxx,yyy,zzz)) continue;\n\t\t\t\tif(data[yyy][xxx][zzz].dice[i] != 0 && data[yyy][xxx][zzz].dice[i] != d.dice[i]){\n\t\t\t\t\tisvalid = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 1; i <= 6; i++){\n\t\t\t\tif(work[y][x][z].dice[i] != 0 && work[y][x][z].dice[i] != d.dice[i]){\n\t\t\t\t\tisvalid = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(! isvalid) continue;\n\t\t\tdata[y][x][z] = d;\n\t\t\t//再帰\n\t\t\tif( y == 0 && z == 2){\n\t\t\t\tdfs(2, x + 1, 0);\n\t\t\t}\n\t\t\telse if(y == 0){\n\t\t\t\tdfs(2, x, z + 1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdfs(y - 1, x, z);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate Dice[][][] deepcopy(Dice[][][] arg) {\n\t\tDice [][][] res = new Dice[3][3][3];\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tfor(int j = 0 ; j < 3; j++){\n\t\t\t\tfor(int k = 0 ; k < 3; k++){\n\t\t\t\t\tfor(int dind = 1; dind <= 6; dind++){\n\t\t\t\t\t\tres[i][j][k] = new Dice(arg[i][j][k].dice);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate void init() {\n\t\tmap = new ArrayList<String>();\n\t\tint [] dice = {0,1,2,3,4,5,6};\n\t\tDice d = new Dice(dice);\n\t\tString [] dir = {\"\", \"n\", \"s\", \"w\", \"e\", \"nn\"};\n\t\tString [] dirrev = {\"\", \"s\", \"n\", \"e\", \"w\", \"nn\"};\n\t\tfor(int i = 0 ; i< dir.length; i++){\n\t\t\tfor(int j = 0 ; j< dir[i].length(); j++){\n\t\t\t\td.turn(dir[i].charAt(j));\n\t\t\t}\n\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\td.slide();\n\t\t\t\tmap.add(d.toString());\n\t\t\t}\n\n\t\t\tfor(int j = 0 ; j< dirrev[i].length(); j++){\n\t\t\t\td.turn(dirrev[i].charAt(j));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean isOK(int xx, int yy, int zz) {\n\t\tif(0<= xx && xx < 3 && 0<= yy && yy < 3 && 0<= zz && zz < 3){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\npublic class Main {\n\t//1335 start\n\t//1530 stop\n\t//2242 restart\n\t//0230 restart\n\tint [][][][] data;\n\tint [] vx = {-1, 0, 0, 1,-1, 0, 0};\n\tint [] vy = {-1, 0, 1, 0, 0,-1, 0};\n\tint [] vz = {-1,-1, 0, 0, 0, 0, 1};\n\tArrayList<String> map;\n\tHashSet<Integer> set;\n\t//dice is, 2 = south, 3 = east, 1 = top, 6 = bottom, 4 = west, 5 = north;\n\n\tclass Dice{\n\t\tint [] dice;\n\t\tpublic Dice(int[] dice) {\n\t\t\tthis.dice = dice;\n\t\t}\n\t\tprivate void slide() {\n\t\t\tswap(2,4,5,3);\n\t\t}\n\t\tprivate void turn(char c) {\n\t\t\tswitch(c){\n\t\t\tcase 'n':\n\t\t\t\tswap(1,5,6,2); break;\n\t\t\tcase 's':\n\t\t\t\tswap(1,2,6,5); break;\n\t\t\tcase 'w':\n\t\t\t\tswap(1,4,6,3); break;\n\t\t\tcase 'e':\n\t\t\t\tswap(1,3,6,4); break;\n\t\t\t}\n\t\t}\n\t\tprivate void swap(int i, int j, int k, int l) {\n\t\t\tint temp = dice[l];\n\t\t\tdice[l] = dice[k];\n\t\t\tdice[k] = dice[j];\n\t\t\tdice[j] = dice[i];\n\t\t\tdice[i] = temp;\n\t\t}\n\t\tpublic String toString(){\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(int i = 0; i <= 6; i++){\n\t\t\t\tsb.append(dice[i]);\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner (System.in);\n\t\tinit();\n\t\tint dataset = sc.nextInt();\n\t\twhile(dataset-- > 0){\n\t\t\tdata = new int[3][3][3][7];\n\t\t\t//input\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\t\tdata[i][j][0][1] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < 3 ; i++){\n\t\t\t\tfor(int j = 0 ; j < 3; j++){\n\t\t\t\t\tdata[2][j][i][2] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tset = new HashSet<Integer>();\n\t\t\tdfs(2, 0, 0);\n\t\t\tif(set.size() == 0){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tArrayList<Integer> al = new ArrayList<Integer>();\n\t\t\tfor(int value: set){\n\t\t\t\tal.add(value);\n\t\t\t}\n\t\t\tCollections.sort(al);\n\t\t\tSystem.out.print(al.get(0));\n\t\t\tfor(int i = 1; i < al.size(); i++){\n\t\t\t\tSystem.out.print(\" \" + al.get(i));\n\t\t\t}\n\t\t\tSystem.out.println();\n\n\t\t\t//debug\n\t\t\t//disp();\n\t\t}\n\t}\n\n\tprivate void dfs(int y, int x, int z) {\n\t\t//System.out.println(\"y = \" + y + \" x= \" + x + \" z= \" + z);\n\t\t\n\t\tif(x == 2 && y == 0 && z == 2){\n\t\t\t//対面が埋まっていないなら埋める。\n\t\t\tfor(int i = 1; i <= 6; i++){\n\t\t\t\tif(data[y][x][z][i] != 0){\n\t\t\t\t\tdata[y][x][z][7-i] = 7 - data[y][x][z][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(int i = 0 ; i < 3; i++){\n\t\t\t\tfor(int j = 0 ; j < 3; j++){\n\t\t\t\t\tres += data[i][2][j][3];\n\t\t\t\t}\n\t\t\t}\n//\t\t\tdisp();\n//\t\t\tSystem.out.println(\"======\");\n\t\t\tset.add(res);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tboolean isvalid = true;\n\t\t\n\t\t//対面が埋まっていないなら埋める。\n\t\tfor(int i = 1; i <= 6; i++){\n\t\t\tif(data[y][x][z][i] != 0){\n\t\t\t\tif(data[y][x][z][7-i] == 0){\n\t\t\t\t\tdata[y][x][z][7-i] = 7 - data[y][x][z][i];\n\t\t\t\t}\n\t\t\t\telse if(data[y][x][z][7-i] == 7 - data[y][x][z][i]){\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tisvalid = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//同じ数字がないかチェックする\n\t\tisvalid = isvalid && validcheck(data[y][x][z]);\n\t\tif(! isvalid) return ;\n\t\t//数字を割り当てる\n\t\tint [][][][] work = deepcopy(data);\n\t\tfor(int ii = 0; ii < map.size(); ii++){\n\t\t\tdata = deepcopy(work);\n\t\t\tboolean flg = true;\n\t\t\tfor(int j = 1; j <= 6; j++){\n\t\t\t\t\n\t\t\t\tif(data[y][x][z][j] == map.get(ii).charAt(j) - '0' || data[y][x][z][j] == 0){\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tflg = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(! flg){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 1; i <= 6; i++){\n\t\t\t\tdata[y][x][z][i] = map.get(ii).charAt(i) - '0';\n\t\t\t}\n\t\t\t//周りに伝搬する\n\t\t\tfor(int i = 1; i <= 6; i++){\n\t\t\t\tint xx = vx[i] + x;\n\t\t\t\tint yy = vy[i] + y;\n\t\t\t\tint zz = vz[i] + z;\n\t\t\t\tif(! isOK(xx,yy,zz)) continue;\n\t\t\t\tif(data[yy][xx][zz][i] == data[y][x][z][i] || data[yy][xx][zz][i] == 0){\n\t\t\t\t\tdata[yy][xx][zz][i] = data[y][x][z][i];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//再帰\n\t\t\tif( y == 0 && z == 2){\n\t\t\t\tdfs(2, x + 1, 0);\n\t\t\t}\n\t\t\telse if(y == 0){\n\t\t\t\tdfs(2, x, z + 1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdfs(y - 1, x, z);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int[][][][] deepcopy(int [][][][] arg) {\n\t\tint [][][][] res = new int[3][3][3][7];\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tfor(int j = 0 ; j < 3; j++){\n\t\t\t\tfor(int k = 0 ; k < 3; k++){\n\t\t\t\t\tfor(int dind = 1; dind <= 6; dind++){\n\t\t\t\t\t\tres[i][j][k][dind] = arg[i][j][k][dind];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate boolean validcheck(int [] arg) {\n\t\tHashSet<Integer> hash = new HashSet<Integer>();\n\t\tfor(int dind = 1; dind <= 6; dind++){\n\t\t\tif(arg[dind] != 0 && hash.contains(arg[dind])){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\thash.add(arg[dind]);\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int anscheck() {\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\tif(data[i][2][j][3] == 0) return -1;\n\t\t\t\tsum += data[i][2][j][3];\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\n\tprivate void disp(){\n\t\tfor(int z = 0; z < 3; z++){\n\t\t\tSystem.out.println(\"z = \" + z);\n\t\t\tfor(int i = 0 ; i < 3; i++){\n\t\t\t\tfor(int j = 0 ; j < 3; j++){\n\t\t\t\t\tSystem.out.print(Arrays.toString(data[i][j][z]) + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\n\tprivate void init() {\n\t\tmap = new ArrayList<String>();\n\t\tint [] dice = {0,1,2,3,4,5,6};\n\t\tDice d = new Dice(dice);\n\t\tString [] dir = {\"\", \"n\", \"s\", \"w\", \"e\", \"nn\"};\n\t\tString [] dirrev = {\"\", \"s\", \"n\", \"e\", \"w\", \"nn\"};\n\t\tfor(int i = 0 ; i< dir.length; i++){\n\t\t\tfor(int j = 0 ; j< dir[i].length(); j++){\n\t\t\t\td.turn(dir[i].charAt(j));\n\t\t\t}\n\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\td.slide();\n\t\t\t\tmap.add(d.toString());\n\t\t\t}\n\n\t\t\tfor(int j = 0 ; j< dirrev[i].length(); j++){\n\t\t\t\td.turn(dirrev[i].charAt(j));\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate void assign(int y, int x, int z, int ind, int num) {\n\t\tdata[y][x][z][ind] = num;\n\t\tdata[y][x][z][7-ind] = 7-num;\n\t\t//System.out.println(\"x = \" + x + \"y = \" + y + \"z = \" + z + \"ind = \" + ind + \"num =\" + num);\n\t\tfor(int i = 1; i < 3;i++){\n\t\t\tint xx = x + vx[ind] * i;\n\t\t\tint yy = y + vy[ind] * i;\n\t\t\tint zz = z + vz[ind] * i;\n\t\t\tif(! isOK(xx,yy,zz)) break;\n\t\t\tif(data[yy][xx][zz][ind] == 0){\n\t\t\t\tassign(yy,xx,zz,ind,num);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i < 3;i++){\n\t\t\tint xx = x + vx[ind] * -i;\n\t\t\tint yy = y + vy[ind] * -i;\n\t\t\tint zz = z + vz[ind] * -i;\n\t\t\tif(! isOK(xx,yy,zz)) break;\n\t\t\tif(data[yy][xx][zz][ind] == 0){\n\t\t\t\tassign(yy,xx,zz,ind,num);\n\t\t\t}\n\t\t}\n\n\t\tint count = 0;\n\t\tint indx = 0;\n\t\tfor(int i = 1; i <= 3; i++){\n\t\t\tif(i == ind || i == (7- ind)) continue;\n\n\t\t\tif(data[y][x][z][i] == 0){\n\t\t\t\tcount++;\n\t\t\t\tindx = i;\n\t\t\t}\n\t\t}\n\t\tif(count == 1){\n\t\t\t//うめる\n\t\t\tint [] nowdice = data[y][x][z];\n\t\t\tfor(int i = 0; i < map.size(); i++){\n\t\t\t\tString now = map.get(i);\n\t\t\t\tint [] diffind = check2(nowdice, now);\n\t\t\t\tif(diffind != null){\n\t\t\t\t\tassign(y, x, z, diffind[0] + 1, now.charAt(diffind[0]) - '0');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate int[] check2(int[] nowdice, String now) {\n\t\tint count = 0;\n\t\tint [] ind = new int[2];\n\t\tfor(int i = 0; i < now.length(); i++){\n\t\t\tint nownum = now.charAt(i) - '0';\n\t\t\tif(nownum != nowdice[i+1]){\n\t\t\t\tif(count == 2){\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tind[count] = i;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn ind;\n\t}\n\n\n\tprivate boolean isOK(int xx, int yy, int zz) {\n\t\tif(0<= xx && xx < 3 && 0<= yy && yy < 3 && 0<= zz && zz < 3){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Dice Puzzle\npublic class Main{\n\n\tstatic class Dice <T>{\n\t\tpublic T[] id;\n\t\t\tenum Face{TOP, BOTTOM, FRONT, BACK, RIGHT, LEFT};\n\t\t\tpublic T get(Face f){\n\t\t\t\treturn id[f.ordinal()];\n\t\t\t}\n\t\t\tpublic Dice<T> copy(){\n\t\t\t\treturn new Dice<T>(id[0], id[1], id[2], id[3], id[4], id[5]);\n\t\t\t}\n\t\t\tpublic Dice() {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] tid = (T[])new Object[6];\n\t\t\t\tid = tid;\n\t\t\t}\n\t\t\tpublic Dice(T top, T bottom, T front, T back, T right, T left) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] tid = (T[])new Object[6];\n\t\t\t\tid = tid;\n\t\t\t\tid[Face.TOP.ordinal()] = top;\n\t\t\t\tid[Face.BOTTOM.ordinal()]= bottom;\n\t\t\t\tid[Face.FRONT.ordinal()] = front;\n\t\t\t\tid[Face.BACK.ordinal()] = back;\n\t\t\t\tid[Face.RIGHT.ordinal()] = right;\n\t\t\t\tid[Face.LEFT.ordinal()] = left;\n\t\t\t}\n\t\t\t//true: Xツ篠イツ陛サツ古シツづ可偲ィツ前ツづ可転ツつェツつキ\n\t\t\t//false: Xツ篠イツ陛サツ古シツづ可可慊づ可転ツつェツつキ\n\t\t\tvoid rollX(boolean isReverse) {\n\t\t\t\tif(!isReverse) roll(Face.TOP, Face.FRONT, Face.BOTTOM, Face.BACK);\n\t\t\t\telse roll(Face.TOP, Face.BACK, Face.BOTTOM, Face.FRONT);\n\t\t\t}\n\t\t\t//true: Yツ篠イツ陛サツ古シツづ可債カツづ鳴転ツつェツつキ\n\t\t\t//false: Yツ篠イツ陛サツ古シツづ可右ツづ鳴転ツつェツつキ\n\t\t\tvoid rollY(boolean isReverse) {\n\t\t\t\tif(!isReverse) roll(Face.TOP, Face.LEFT, Face.BOTTOM, Face.RIGHT);\n\t\t\t\telse roll(Face.TOP, Face.RIGHT, Face.BOTTOM, Face.LEFT);\n\t\t\t}\n\t\t\t//true: Zツ篠イツ陛サツ古シツづ可右ツづ鳴嘉アツつキ\n\t\t\t//false: Zツ篠イツ陛サツ古シツづ可債カツづ鳴嘉アツつキ\n\t\t\tvoid rollZ(boolean isReverse) {\n\t\t\t\tif(!isReverse) roll(Face.FRONT, Face.LEFT, Face.BACK, Face.RIGHT);\n\t\t\t\telse roll(Face.FRONT, Face.RIGHT, Face.BACK, Face.LEFT);\n\t\t\t}\n\t\t\tprivate void roll(Face w, Face x, Face y, Face z) {\n\t\t\t\tT tmp = id[w.ordinal()];\n\t\t\t\tid[w.ordinal()] = id[x.ordinal()];\n\t\t\t\tid[x.ordinal()] = id[y.ordinal()];\n\t\t\t\tid[y.ordinal()] = id[z.ordinal()];\n\t\t\t\tid[z.ordinal()] = tmp;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object o) {\n\t\t\t\tif(!(o instanceof Dice<?>))return false;\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tDice<T> d = (Dice<T>)o;\n\t\t\t\tfor(Face f : Face.values()){\n\t\t\t\t\tif(!id[f.ordinal()].equals(d.id[f.ordinal()])){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tList<Dice<T>> getAllState(){\n\t\t\t\tList<Dice<T>> lst = new ArrayList<Dice<T>>();\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\t\tlst.add(new Dice<T>(id[Face.TOP.ordinal()], id[Face.BOTTOM.ordinal()], id[Face.FRONT.ordinal()], id[Face.BACK.ordinal()], id[Face.RIGHT.ordinal()], id[Face.LEFT.ordinal()]));\n\t\t\t\t\t\trollZ(false);\n\t\t\t\t\t}\n\t\t\t\t\tif(i%2 == 1) rollY(false);\n\t\t\t\t\telse rollX(false);\n\t\t\t\t}\n\t\t\t\treturn lst;\n\t\t\t}\n\t}\n\t\n\tDice<Integer>[] dice;\n\tint[][] top, front;\n\tDice<Integer>[][][] a;\n\tSet<Integer> res;\n\tint[][] move = {\n\t\t\t{-1,0,0},\n\t\t\t{0,-1,0},\n\t\t\t{0,0,-1}\n\t};\n\t\n\tvoid dfs(int i, int j, int k){\n\t\tif(j==3){\n\t\t\tint sum = 0;\n\t\t\tfor(int y=0;y<3;y++)for(int z=0;z<3;z++)sum+=a[2][y][z].get(Dice.Face.RIGHT);\n\t\t\tres.add(sum);\n\t\t\treturn;\n\t\t}\n\t\tfor(int x=0;x<24;x++){\n\t\t\tDice<Integer> d = dice[x];\n\t\t\tif(k==0&&top[j][i]!=0&&d.get(Dice.Face.TOP)!=top[j][i])continue;\n\t\t\tif(j==2&&front[k][i]!=0&&d.get(Dice.Face.FRONT)!=front[k][i])continue;\n\t\t\tboolean ok = true;\n\t\t\tfor(int m=0;m<3;m++){\n\t\t\t\tint ni = i+move[m][0], nj = j+move[m][1], nk = k+move[m][2];\n\t\t\t\tif(0<=ni&&ni<3&&0<=nj&&nj<3&&0<=nk&&nk<3){\n\t\t\t\t\tif(m==0){\n\t\t\t\t\t\tif(a[i-1][j][k].get(Dice.Face.RIGHT)+d.get(Dice.Face.LEFT)!=7){\n\t\t\t\t\t\t\tok = false; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(m==1){\n\t\t\t\t\t\tif(a[i][j-1][k].get(Dice.Face.FRONT)+d.get(Dice.Face.BACK)!=7){\n\t\t\t\t\t\t\tok = false; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(m==2){\n\t\t\t\t\t\tif(a[i][j][k-1].get(Dice.Face.BOTTOM)+d.get(Dice.Face.TOP)!=7){\n\t\t\t\t\t\t\tok = false; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ok)continue;\n\t\t\ta[i][j][k] = d;\n\t\t\tif(i==2&&k==2){\n\t\t\t\tdfs(0, j+1, 0);\n\t\t\t}\n\t\t\telse if(i==2){\n\t\t\t\tdfs(0, j, k+1);\n\t\t\t}\n\t\t\telse dfs(i+1, j, k);\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tDice<Integer> d = new Dice<Integer>(1, 6, 2, 5, 3, 4);\n\t\tdice = new Dice[24];\n\t\tint id = 0;\n\t\tfor(Dice<Integer> x:d.getAllState())dice[id++] = x;\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\twhile(T--!=0){\n\t\t\ttop = new int[3][3]; front = new int[3][3];\n\t\t\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)top[i][j] = sc.nextInt();\n\t\t\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)front[i][j] = sc.nextInt();\n\t\t\ta = new Dice[3][3][3];\n\t\t\tres = new HashSet<Integer>();\n\t\t\tdfs(0, 0, 0);\n\t\t\tif(res.isEmpty())System.out.println(0);\n\t\t\telse{\n\t\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>();\n\t\t\t\tfor(int x:res)q.add(x);\n\t\t\t\tSystem.out.print(q.poll());\n\t\t\t\twhile(!q.isEmpty())System.out.print(\" \"+q.poll());\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Dice Puzzle\npublic class Main{\n\n\tstatic class Dice <T>{\n\t\tpublic T[] id;\n\t\t\tenum Face{TOP, BOTTOM, FRONT, BACK, RIGHT, LEFT};\n\t\t\tpublic T get(Face f){\n\t\t\t\treturn id[f.ordinal()];\n\t\t\t}\n\t\t\tpublic Dice(T top, T bottom, T front, T back, T right, T left) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] tid = (T[])new Object[6];\n\t\t\t\tid = tid;\n\t\t\t\tid[Face.TOP.ordinal()] = top;\n\t\t\t\tid[Face.BOTTOM.ordinal()]= bottom;\n\t\t\t\tid[Face.FRONT.ordinal()] = front;\n\t\t\t\tid[Face.BACK.ordinal()] = back;\n\t\t\t\tid[Face.RIGHT.ordinal()] = right;\n\t\t\t\tid[Face.LEFT.ordinal()] = left;\n\t\t\t}\n\t\t\t//true: Xツ篠イツ陛サツ古シツづ可偲ィツ前ツづ可転ツつェツつキ\n\t\t\t//false: Xツ篠イツ陛サツ古シツづ可可慊づ可転ツつェツつキ\n\t\t\tvoid rollX(boolean isReverse) {\n\t\t\t\tif(!isReverse) roll(Face.TOP, Face.FRONT, Face.BOTTOM, Face.BACK);\n\t\t\t\telse roll(Face.TOP, Face.BACK, Face.BOTTOM, Face.FRONT);\n\t\t\t}\n\t\t\t//true: Yツ篠イツ陛サツ古シツづ可債カツづ鳴転ツつェツつキ\n\t\t\t//false: Yツ篠イツ陛サツ古シツづ可右ツづ鳴転ツつェツつキ\n\t\t\tvoid rollY(boolean isReverse) {\n\t\t\t\tif(!isReverse) roll(Face.TOP, Face.LEFT, Face.BOTTOM, Face.RIGHT);\n\t\t\t\telse roll(Face.TOP, Face.RIGHT, Face.BOTTOM, Face.LEFT);\n\t\t\t}\n\t\t\t//true: Zツ篠イツ陛サツ古シツづ可右ツづ鳴嘉アツつキ\n\t\t\t//false: Zツ篠イツ陛サツ古シツづ可債カツづ鳴嘉アツつキ\n\t\t\tvoid rollZ(boolean isReverse) {\n\t\t\t\tif(!isReverse) roll(Face.FRONT, Face.LEFT, Face.BACK, Face.RIGHT);\n\t\t\t\telse roll(Face.FRONT, Face.RIGHT, Face.BACK, Face.LEFT);\n\t\t\t}\n\t\t\tprivate void roll(Face w, Face x, Face y, Face z) {\n\t\t\t\tT tmp = id[w.ordinal()];\n\t\t\t\tid[w.ordinal()] = id[x.ordinal()];\n\t\t\t\tid[x.ordinal()] = id[y.ordinal()];\n\t\t\t\tid[y.ordinal()] = id[z.ordinal()];\n\t\t\t\tid[z.ordinal()] = tmp;\n\t\t\t}\n\t\t\tList<Dice<T>> getAllState(){\n\t\t\t\tList<Dice<T>> lst = new ArrayList<Dice<T>>();\n\t\t\t\tfor(int i = 0; i < 6; i++){\n\t\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\t\tlst.add(new Dice<T>(id[Face.TOP.ordinal()], id[Face.BOTTOM.ordinal()], id[Face.FRONT.ordinal()], id[Face.BACK.ordinal()], id[Face.RIGHT.ordinal()], id[Face.LEFT.ordinal()]));\n\t\t\t\t\t\trollZ(false);\n\t\t\t\t\t}\n\t\t\t\t\tif(i%2 == 1) rollY(false);\n\t\t\t\t\telse rollX(false);\n\t\t\t\t}\n\t\t\t\treturn lst;\n\t\t\t}\n\t}\n\t\n\tDice<Integer>[] dice;\n\tint[][] top, front;\n\tDice<Integer>[][][] a;\n\tSet<Integer> res;\n\tint[][] move = {\n\t\t\t{-1,0,0},\n\t\t\t{0,-1,0},\n\t\t\t{0,0,-1}\n\t};\n\t\n\tvoid dfs(int i, int j, int k){\n\t\tif(j==3){\n\t\t\tint sum = 0;\n\t\t\tfor(int y=0;y<3;y++)for(int z=0;z<3;z++)sum+=a[2][y][z].get(Dice.Face.RIGHT);\n\t\t\tres.add(sum);\n\t\t\treturn;\n\t\t}\n\t\tfor(int x=0;x<24;x++){\n\t\t\tDice<Integer> d = dice[x];\n\t\t\tif(k==0&&top[j][i]!=0&&d.get(Dice.Face.TOP)!=top[j][i])continue;\n\t\t\tif(j==2&&front[k][i]!=0&&d.get(Dice.Face.FRONT)!=front[k][i])continue;\n\t\t\tboolean ok = true;\n\t\t\tfor(int m=0;m<3;m++){\n\t\t\t\tint ni = i+move[m][0], nj = j+move[m][1], nk = k+move[m][2];\n\t\t\t\tif(0<=ni&&ni<3&&0<=nj&&nj<3&&0<=nk&&nk<3){\n\t\t\t\t\tif(m==0){\n\t\t\t\t\t\tif(a[i-1][j][k].get(Dice.Face.RIGHT)+d.get(Dice.Face.LEFT)!=7){\n\t\t\t\t\t\t\tok = false; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(m==1){\n\t\t\t\t\t\tif(a[i][j-1][k].get(Dice.Face.FRONT)+d.get(Dice.Face.BACK)!=7){\n\t\t\t\t\t\t\tok = false; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(m==2){\n\t\t\t\t\t\tif(a[i][j][k-1].get(Dice.Face.BOTTOM)+d.get(Dice.Face.TOP)!=7){\n\t\t\t\t\t\t\tok = false; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ok)continue;\n\t\t\ta[i][j][k] = d;\n\t\t\tif(i==2&&k==2){\n\t\t\t\tdfs(0, j+1, 0);\n\t\t\t}\n\t\t\telse if(i==2){\n\t\t\t\tdfs(0, j, k+1);\n\t\t\t}\n\t\t\telse dfs(i+1, j, k);\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tDice<Integer> d = new Dice<Integer>(1, 6, 2, 5, 3, 4);\n\t\tdice = new Dice[24];\n\t\tint id = 0;\n\t\tfor(Dice<Integer> x:d.getAllState())dice[id++] = x;\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\twhile(T--!=0){\n\t\t\ttop = new int[3][3]; front = new int[3][3];\n\t\t\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)top[i][j] = sc.nextInt();\n\t\t\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)front[i][j] = sc.nextInt();\n\t\t\ta = new Dice[3][3][3];\n\t\t\tres = new HashSet<Integer>();\n\t\t\tdfs(0, 0, 0);\n\t\t\tif(res.isEmpty())System.out.println(0);\n\t\t\telse{\n\t\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>();\n\t\t\t\tfor(int x:res)q.add(x);\n\t\t\t\tSystem.out.print(q.poll());\n\t\t\t\twhile(!q.isEmpty())System.out.print(\" \"+q.poll());\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\n#     (+x,+y,+z)\nDICE = [1, 2, 3]\n\n### subroutines\n\ndef rot_x(dc0, n = 1)\n  dc = dc0.clone\n  n.times.each{tmp = dc[1]; dc[1] = 7 - dc[2]; dc[2] = tmp}\n  dc\nend\n\ndef rot_y(dc0, n = 1)\n  dc = dc0.clone\n  n.times.each{tmp = dc[2]; dc[2] = 7 - dc[0]; dc[0] = tmp}\n  dc\nend\n\ndef rot_z(dc0, n = 1)\n  dc = dc0.clone\n  n.times.each{tmp = dc[0]; dc[0] = 7 - dc[1]; dc[1] = tmp}\n  dc\nend\n\ndef right_sum()\n  rsum = 0\n  for x in (0...3)\n    for y in (0...3)\n      posz = x * 9 + y * 3\n      d = $cbs[posz][2] | $cbs[posz + 1][2] | $cbs[posz + 2][2]\n      rsum += d\n    end\n  end\n  rsum\nend\n\ndef rec(k)\n  if k >= 27\n    $rsums[right_sum()] = true\n    return\n  end\n\n  x = k / 9\n  y = (k / 3) % 3\n  z = k % 3\n\n  posx = k - x * 9\n  posy = k - y * 3\n  posz = k - z\n  xd = $cbs[0 * 9 + posx][0] | $cbs[1 * 9 + posx][0] | $cbs[2 * 9 + posx][0]\n  yd = $cbs[0 * 3 + posy][1] | $cbs[1 * 3 + posy][1] | $cbs[2 * 3 + posy][1]\n  zd = $cbs[0 * 1 + posz][2] | $cbs[1 * 1 + posz][2] | $cbs[2 * 1 + posz][2]\n\n  cbsk = $cbs[k]\n\n  $alldcs.each do |dc|\n    if (xd != 0 && xd != dc[0]) ||\n       (yd != 0 && yd != dc[1]) ||\n       (zd != 0 && zd != dc[2])\n      next\n    end\n\n    $cbs[k] = dc\n    rec(k + 1)\n    $cbs[k] = cbsk\n  end\nend\n\n### main\n\n$alldcs = []\n\nfor zr in (0...4)\n  for yr in (0...4)\n    for xr in (0...4)\n      $alldcs << rot_z(rot_y(rot_x(DICE, xr), yr), zr)\n    end\n  end\nend\n$alldcs.sort!.uniq!\n$nalldcs = $alldcs.length\n#p $alldcs\n\nn = gets.to_i\n\nn.times do\n  $cbs = 27.times.map{[0] * 3}\n\n  for y in (0...3)\n    tys = gets.split.map(&:to_i)\n    for z in (0...3)\n      tyz = tys[z]\n      next if tyz == 0\n      for x in (0...3)\n        pos = x * 9 + y * 3 + z\n        $cbs[pos][0] = tyz\n      end\n    end\n  end\n\n  for x in (0...3)\n    fxs = gets.split.map(&:to_i)\n    for z in (0...3)\n      fxz = fxs[z]\n      next if fxz == 0\n      for y in (0...3)\n        pos = x * 9 + y * 3 + z\n        $cbs[pos][1] = fxz\n      end\n    end\n  end\n  #p $cbs; exit\n\n  $rsums = {}\n\n  rec(0)\n\n  rs = $rsums.keys.sort\n  puts rs.empty? ? 0 : rs.join(' ')\nend"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\nD = [\n    (1, 5, 2, 3, 0, 4), # 'U'\n    (3, 1, 0, 5, 4, 2), # 'R'\n    (4, 0, 2, 3, 5, 1), # 'D'\n    (2, 1, 5, 0, 4, 3), # 'L'\n]\np_dice = (0, 0, 0, 1, 1, 2, 2, 3)*3\n\ndef enumerate_dice(L0):\n    L = L0[:]\n    for k in p_dice:\n        yield L\n        L[:] = (L[e] for e in D[k])\n\nL = [1, 2, 3, 4, 5, 6]\nLS = []\nfor l in enumerate_dice(L):\n    LS.append(l[:])\n\ndef solve():\n    T = [list(map(int, readline().split())) for i in range(3)]\n    F = [list(map(int, readline().split())) for i in range(3)]\n\n    T0 = [[-1]*3 for i in range(3)]\n    F0 = [[-1]*3 for i in range(3)]\n    R0 = [[-1]*3 for i in range(3)]\n    res = set()\n    def dfs(i, s):\n        if i == 27:\n            res.add(s)\n            return\n        x = i % 3; y = (i // 3) % 3; z = (i // 9) % 3\n        t0 = T0[y][x]\n        f0 = F0[z][x]\n        r0 = R0[z][y]\n        for l in LS:\n            if t0 == -1:\n                e = T[y][x]\n                if e != 0 and e != l[0]:\n                    continue\n                T0[y][x] = l[0]\n            else:\n                if l[0] != t0:\n                    continue\n            if f0 == -1:\n                e = F[z][x]\n                if e != 0 and e != l[1]:\n                    continue\n                F0[z][x] = l[1]\n            else:\n                if l[1] != f0:\n                    continue\n            if r0 == -1:\n                R0[z][y] = l[2]\n                s0 = s + l[2]\n            else:\n                if l[2] != r0:\n                    continue\n                s0 = s\n            dfs(i+1, s0)\n        if t0 == -1:\n            T0[y][x] = -1\n        if f0 == -1:\n            F0[z][x] = -1\n        if r0 == -1:\n            R0[z][y] = -1\n    dfs(0, 0)\n    if res:\n        ans = sorted(res)\n        write(\" \".join(map(str, ans)))\n        write(\"\\n\")\n    else:\n        write(\"0\\n\")\n\nN = int(readline())\nfor i in range(N):\n    solve()\n"
  }
]