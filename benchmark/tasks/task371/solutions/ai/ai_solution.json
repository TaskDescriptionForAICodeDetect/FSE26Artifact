[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    \n    int *rules = (int *)malloc(N * sizeof(int));\n    memset(rules, 0, N * sizeof(int));\n    \n    for (int i = 0; i < M; i++) {\n        int A, B;\n        scanf(\"%d %d\", &A, &B);\n        A--; B--;\n        rules[A] |= (1 << B);\n    }\n    \n    long long total = 0;\n    for (int mask = 0; mask < (1 << N); mask++) {\n        int valid = 1;\n        for (int i = 0; i < N; i++) {\n            if ((mask & (1 << i)) && (rules[i] & ~mask)) {\n                valid = 0;\n                break;\n            }\n        }\n        if (valid) {\n            total++;\n        }\n    }\n    \n    printf(\"%lld\\n\", total % MOD);\n    free(rules);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:15:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nvoid dfs(int node, vector<bool>& visited, const vector<vector<int>>& adj, vector<int>& component) {\n    visited[node] = true;\n    component.push_back(node);\n    for (int neighbor : adj[node]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, visited, adj, component);\n        }\n    }\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    vector<vector<int>> adj(N + 1);\n    for (int i = 0; i < M; ++i) {\n        int A, B;\n        cin >> A >> B;\n        adj[A].push_back(B);\n    }\n    \n    vector<bool> visited(N + 1, false);\n    vector<vector<int>> components;\n    \n    for (int i = 1; i <= N; ++i) {\n        if (!visited[i]) {\n            vector<int> component;\n            dfs(i, visited, adj, component);\n            components.push_back(component);\n        }\n    }\n    \n    unordered_map<int, int> component_id;\n    for (int i = 0; i < components.size(); ++i) {\n        for (int node : components[i]) {\n            component_id[node] = i;\n        }\n    }\n    \n    vector<vector<int>> condensed_adj(components.size());\n    vector<int> in_degree(components.size(), 0);\n    \n    for (int u = 1; u <= N; ++u) {\n        for (int v : adj[u]) {\n            int u_comp = component_id[u];\n            int v_comp = component_id[v];\n            if (u_comp != v_comp) {\n                condensed_adj[u_comp].push_back(v_comp);\n                in_degree[v_comp]++;\n            }\n        }\n    }\n    \n    vector<int> dp(components.size(), 1);\n    vector<int> topo_order;\n    vector<bool> added(components.size(), false);\n    \n    for (int i = 0; i < components.size(); ++i) {\n        if (in_degree[i] == 0) {\n            topo_order.push_back(i);\n            added[i] = true;\n        }\n    }\n    \n    for (int i = 0; i < topo_order.size(); ++i) {\n        int u = topo_order[i];\n        for (int v : condensed_adj[u]) {\n            if (!added[v]) {\n                in_degree[v]--;\n                if (in_degree[v] == 0) {\n                    topo_order.push_back(v);\n                    added[v] = true;\n                }\n            }\n        }\n    }\n    \n    for (int u : topo_order) {\n        for (int v : condensed_adj[u]) {\n            dp[v] = (dp[v] + dp[u]) % MOD;\n        }\n    }\n    \n    long long result = 1;\n    for (int i = 0; i < components.size(); ++i) {\n        result = (result * dp[i]) % MOD;\n    }\n    \n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:15:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class AlienFingerCounting {\n    static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int i = 0; i < M; i++) {\n            int A = scanner.nextInt();\n            int B = scanner.nextInt();\n            graph.get(A).add(B);\n        }\n\n        boolean[] visited = new boolean[N + 1];\n        int[] component = new int[N + 1];\n        int compId = 0;\n        for (int i = 1; i <= N; i++) {\n            if (!visited[i]) {\n                Stack<Integer> stack = new Stack<>();\n                stack.push(i);\n                visited[i] = true;\n                List<Integer> componentNodes = new ArrayList<>();\n                while (!stack.isEmpty()) {\n                    int node = stack.pop();\n                    componentNodes.add(node);\n                    for (int neighbor : graph.get(node)) {\n                        if (!visited[neighbor]) {\n                            visited[neighbor] = true;\n                            stack.push(neighbor);\n                        }\n                    }\n                }\n                for (int node : componentNodes) {\n                    component[node] = compId;\n                }\n                compId++;\n            }\n        }\n\n        int[] inDegree = new int[compId];\n        List<List<Integer>> compGraph = new ArrayList<>();\n        for (int i = 0; i < compId; i++) {\n            compGraph.add(new ArrayList<>());\n        }\n        for (int u = 1; u <= N; u++) {\n            for (int v : graph.get(u)) {\n                if (component[u] != component[v]) {\n                    compGraph.get(component[u]).add(component[v]);\n                    inDegree[component[v]]++;\n                }\n            }\n        }\n\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < compId; i++) {\n            if (inDegree[i] == 0) {\n                queue.add(i);\n            }\n        }\n\n        long[] dp = new long[compId];\n        Arrays.fill(dp, 1);\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            for (int v : compGraph.get(u)) {\n                dp[v] = (dp[v] + dp[u]) % MOD;\n                inDegree[v]--;\n                if (inDegree[v] == 0) {\n                    queue.add(v);\n                }\n            }\n        }\n\n        long result = 1;\n        for (long num : dp) {\n            result = (result * num) % MOD;\n        }\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 21:16:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class AlienFingerCounting {\n    public static int countNumbers(int N, int[][] bendingRules) {\n        final int MOD = 1000000007;\n        boolean[][] connections = new boolean[N][N];\n        int[] bendState = new int[N];\n\n        for (int[] rule : bendingRules) {\n            connections[rule[0] - 1][rule[1] - 1] = true;\n        }\n\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (connections[i][j]) {\n                    connections[i][j] = true;\n                }\n            }\n        }\n\n        int totalConfigurations = 1 << N;\n        long validConfigurations = 0;\n\n        for (int config = 0; config < totalConfigurations; config++) {\n            boolean isValidConfig = true;\n            for (int i = 0; i < N; i++) {\n                boolean fingerBent = (config & (1 << i)) != 0;\n                if (fingerBent) {\n                    for (int j = 0; j < N; j++) {\n                        if (connections[i][j] && (config & (1 << j)) == 0) {\n                            isValidConfig = false;\n                            break;\n                        }\n                    }\n                }\n                if (!isValidConfig) break;\n            }\n            if (isValidConfig) validConfigurations++;\n        }\n\n        return (int)(validConfigurations % MOD);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int[][] bendingRules = new int[M][2];\n        \n        for (int i = 0; i < M; i++) {\n            bendingRules[i][0] = scanner.nextInt();\n            bendingRules[i][1] = scanner.nextInt();\n        }\n        \n        System.out.println(countNumbers(N, bendingRules));\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:16:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nint main() {\n    int N, M, A, B;\n    scanf(\"%d %d\", &N, &M);\n    \n    int bendRules[N+1][N+1];\n    int canBend[N+1];\n    \n    memset(bendRules, 0, sizeof(bendRules));\n    memset(canBend, 0, sizeof(canBend));\n    \n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &A, &B);\n        bendRules[A][B] = 1;\n    }\n    \n    long long count = 1;\n    \n    for (int i = 1; i <= N; i++) {\n        if (canBend[i]) continue;\n        \n        count = (count * 2) % MOD;\n        \n        canBend[i] = 1;\n        \n        for (int j = 1; j <= N; j++) {\n            if (bendRules[i][j]) {\n                canBend[j] = 1;\n            }\n        }\n    }\n    \n    printf(\"%lld\\n\", count);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:16:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nclass Solution {\npublic:\n    int countNumbers(int N, vector<vector<int>>& bending_rules) {\n        vector<vector<int>> graph(N + 1);\n        vector<int> indegree(N + 1, 0);\n        \n        // Build graph and calculate indegree\n        for (auto& rule : bending_rules) {\n            graph[rule[0]].push_back(rule[1]);\n            indegree[rule[1]]++;\n        }\n        \n        // Find fingers with zero indegree\n        queue<int> q;\n        for (int i = 1; i <= N; i++) {\n            if (indegree[i] == 0) {\n                q.push(i);\n            }\n        }\n        \n        // Perform topological sort\n        vector<int> topo_order;\n        while (!q.empty()) {\n            int curr = q.front();\n            q.pop();\n            topo_order.push_back(curr);\n            \n            for (int neighbor : graph[curr]) {\n                indegree[neighbor]--;\n                if (indegree[neighbor] == 0) {\n                    q.push(neighbor);\n                }\n            }\n        }\n        \n        // Calculate number of configurations\n        vector<long long> dp(N + 1, 0);\n        dp[0] = 1;\n        \n        for (int finger : topo_order) {\n            dp[finger] = dp[finger - 1];\n        }\n        \n        long long total_configs = 1;\n        for (int i = 1; i <= N; i++) {\n            total_configs = (total_configs * 2) % MOD;\n        }\n        \n        return total_configs;\n    }\n};",
    "timestamp": "2025-08-05 21:16:28"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_ways(n, m, rules):\n    MOD = 1000000007\n    from collections import defaultdict, deque\n    \n    indegree = [0] * n\n    graph = defaultdict(list)\n    \n    for a, b in rules:\n        graph[a].append(b)\n        indegree[b] += 1\n    \n    # Find all fingers with zero indegree\n    zero_indegree = deque()\n    for i in range(n):\n        if indegree[i] == 0:\n            zero_indegree.append(i)\n    \n    # Perform topological sort\n    sorted_fingers = []\n    while zero_indegree:\n        finger = zero_indegree.popleft()\n        sorted_fingers.append(finger)\n        \n        for neighbor in graph[finger]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                zero_indegree.append(neighbor)\n    \n    # If not all fingers are in sorted order, there's a cycle\n    if len(sorted_fingers) < n:\n        return 0\n    \n    dp = [0] * (1 << n)\n    dp[0] = 1\n    \n    for mask in range(1 << n):\n        for i in sorted_fingers:\n            if mask & (1 << i) == 0:\n                continue\n            valid = True\n            for neighbor in graph[i]:\n                if mask & (1 << neighbor) == 0:\n                    valid = False\n                    break\n            if valid:\n                dp[mask] = (dp[mask] + dp[mask ^ (1 << i)]) % MOD\n\n    return sum(dp) % MOD\n\n# Example usage:\nn = 3\nm = 2\nrules = [(0, 1), (1, 2)]\nprint(count_ways(n, m, rules))  # Use this line to test with specific inputs",
    "timestamp": "2025-08-13 05:44:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\npublic class AlienFingerCounting {\n    private static final int MOD = 1000000007;\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        \n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < M; i++) {\n            int a = scanner.nextInt() - 1;\n            int b = scanner.nextInt() - 1 ;\n            graph.get(b).add(a);\n        }\n        \n        long[] dp = new long[1 << N];\n        dp[0] = 1;\n        \n        for (int mask = 0; mask < (1 << N); mask++) {\n            for (int finger = 0; finger < N; finger++) {\n                if ((mask & (1 << finger)) == 0) {\n                    boolean canBend = true;\n                    for (int prereq : graph.get(finger)) {\n                        if ((mask & (1 << prereq)) == 0) {\n                            canBend = false;\n                            break;\n                        }\n                    }\n                    if (canBend) {\n                        dp[mask | (1 << finger)] = (dp[mask | (1 << finger)] + dp[mask]) % MOD;\n                    }\n                }\n            }\n        }\n        \n        long result = 0;\n        for (int mask = 0; mask < (1 << N); mask++) {\n            result = (result + dp[mask]) % MOD;\n        }\n        \n        System.out.println(result);\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 05:44:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MOD 1000000007\n\nvoid dfs(int finger, int state, int N, int *count, bool adjacencyMatrix[N][N]) {\n    if (finger == N) {\n        (*count)++;\n        if (*count >= MOD) *count -= MOD;\n        return;\n    }\n    // Try bending the current finger and check dependent fingers\n    int canBend = 1;\n    for (int i = 0; i < N; i++) {\n        if ((state & (1 << i)) && adjacencyMatrix[i][finger]) {\n            canBend = 0;\n            break;\n        }\n    }\n    if (canBend) {\n        dfs(finger + 1, state | (1 << finger), N, count, adjacencyMatrix);\n    }\n    // Skip bending the current finger\n    dfs(finger + 1, state, N, count, adjacencyMatrix);\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    bool adjacencyMatrix[N][N];\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            adjacencyMatrix[i][j] = false;\n\n    for (int i = 0; i < M; i++) {\n        int A, B;\n        scanf(\"%d %d\", &A, &B);\n        adjacencyMatrix[A][B] = true;\n    }\n\n    int count = 0;\n    dfs(0, 0, N, &count, adjacencyMatrix);\n\n    printf(\"%d\\n\", count);\n    return 0;\n}",
    "timestamp": "2025-08-13 05:44:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_numbers(N, M, rules):\n    MOD = 10**9 + 7\n    \n    # Create adjacency list to represent bending rules\n    graph = [[] for _ in range(N)]\n    in_degree = [0] * N\n    \n    for a, b in rules:\n        graph[a-1].append(b-1)\n        in_degree[b-1] += 1\n    \n    # Use topological sorting to find fingers that can be bent independently\n    queue = []\n    for i in range(N):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    # Compute independent sets of fingers\n    independent_sets = []\n    while queue:\n        set_fingers = []\n        visited = [False] * N\n        \n        for start in queue:\n            if not visited[start]:\n                current_set = []\n                q = [start]\n                while q:\n                    finger = q.pop(0)\n                    if visited[finger]:\n                        continue\n                    visited[finger] = True\n                    current_set.append(finger)\n                    \n                    for next_finger in graph[finger]:\n                        if not visited[next_finger]:\n                            q.append(next_finger)\n                \n                set_fingers.extend(current_set)\n        \n        independent_sets.append(set_fingers)\n        \n        # Remove processed fingers and update queue\n        new_queue = []\n        for finger in queue:\n            if not visited[finger]:\n                new_queue.append(finger)\n        queue = new_queue\n    \n    # Calculate total combinations\n    total_combinations = 1\n    for independent_set in independent_sets:\n        total_combinations *= pow(2, len(independent_set), MOD)\n        total_combinations %= MOD\n    \n    return total_combinations\n\n# Input parsing\nN, M = map(int, input().split())\nrules = []\nfor _ in range(M):\n    a, b = map(int, input().split())\n    rules.append((a, b))\n\n# Output result\nprint(count_numbers(N, M, rules))",
    "timestamp": "2025-08-13 05:44:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 10**9 + 7\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(N + 1)]\n    \n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n    \n    def union(u, v):\n        root_u = find(u)\n        root_v = find(v)\n        if root_u != root_v:\n            parent[root_v] = root_u\n    \n    for _ in range(M):\n        A, B = map(int, sys.stdin.readline().split())\n        union(A, B)\n    \n    roots = set()\n    for i in range(1, N + 1):\n        roots.add(find(i))\n    \n    print(pow(2, len(roots), MOD))\n\nsolve()",
    "timestamp": "2025-08-13 05:44:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define MOD 1000000007\n\nusing namespace std;\n\nint countWays(int N, vector<pair<int, int>> &rules) {\n    vector<int> indegree(N, 0);\n    vector<vector<int>> adj(N);\n\n    // Create adjacency list and indegree array\n    for (auto &rule : rules) {\n        int from = rule.first - 1;\n        int to = rule.second - 1;\n        adj[from].push_back(to);\n        indegree[to]++;\n    }\n\n    // Topological sort to detect cycles and sort nodes\n    queue<int> q;\n    vector<int> topoSorted;\n\n    for (int i = 0; i < N; i++) {\n        if (indegree[i] == 0) {\n            q.push(i);\n        }\n    }\n\n    while (!q.empty()) {\n        int current = q.front();\n        q.pop();\n        topoSorted.push_back(current);\n\n        for (int neighbor : adj[current]) {\n            indegree[neighbor]--;\n            if (indegree[neighbor] == 0) {\n                q.push(neighbor);\n            }\n        }\n    }\n\n    if (topoSorted.size() != N) {\n        // Cycle detected, return 0\n        return 0;\n    }\n\n    // Calculate total ways to count based on topological order\n    vector<int> dp(1 << N, 0);\n    dp[0] = 1; // Base case, no fingers bent\n    \n    for (int mask = 0; mask < (1 << N); mask++) {\n        for (int next : topoSorted) {\n            if (!(mask & (1 << next))) {\n                bool canBend = true;\n\n                for (int parent : adj[next]) {\n                    if (!(mask & (1 << parent))) {\n                        canBend = false;\n                        break;\n                    }\n                }\n\n                if (canBend) {\n                    dp[mask | (1 << next)] = (dp[mask | (1 << next)] + dp[mask]) % MOD;\n                }\n            }\n        }\n    }\n    \n    int result = 0;\n    for (int i = 0; i < (1 << N); i++) {\n        result = (result + dp[i]) % MOD;\n    }\n\n    return result;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<pair<int, int>> rules(M);\n\n    for (int i = 0; i < M; i++) {\n        cin >> rules[i].first >> rules[i].second;\n    }\n\n    cout << countWays(N, rules) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:27:31"
  }
]