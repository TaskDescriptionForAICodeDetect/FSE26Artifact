[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\ntypedef long long ll;\n\n#define MAX_V 1002\n#define MOD 1000000007LL\n\nint V, E, n;\nvector<int> G[MAX_V], rG[MAX_V], vs;\nvector<int> t[MAX_V], rt[MAX_V];\nbool used[MAX_V];\nint cmp[MAX_V];\n\nll dp[MAX_V];\n\nvoid init(){\n  for(int i = 0; i < MAX_V; i++){\n    G[i].clear();\n    rG[i].clear();\n    t[i].clear();\n    rt[i].clear();\n  }\n}\n\nvoid add_edge(int from, int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v] = true;\n  for(int i = 0; i < G[v].size(); i++){\n    int to = G[v][i];\n    if(!used[to]) dfs(to);\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i = 0; i < rG[v].size(); i++){\n    int to = rG[v][i];\n    if(!used[to]) rdfs(to,k);\n  }\n}\n\nint scc(){\n  memset(used, 0, sizeof(used));\n  vs.clear();\n  for(int i = 0; i < V; i++) if(!used[i]) dfs(i);\n\n  memset(used, 0, sizeof(used));\n\n  int k = 0;\n  for(int i = 0; i < vs.size(); i++){\n    int to = vs[vs.size() - i - 1];\n    if(!used[to]) rdfs(to,k++);\n  }\n  return k;\n}\n\nvoid makeGraph(){\n  for(int i = 0; i < V; i++){\n    int from = cmp[i];\n\n    for(int j = 0; j < G[i].size(); j++){\n      int to = cmp[G[i][j]];\n      if(from == to) continue;\n\n      if(find(t[from].begin(), t[from].end(), to) == t[from].end()){\n        t[from].push_back(to);\n      }\n      if(find(rt[to].begin(), rt[to].end(), from) == rt[to].end()){\n        rt[to].push_back(from);\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> V >> E){\n    init();\n\n    for(int i = 0; i < E; i++){\n      int from, to;\n      cin >> from >> to;\n      from--;\n      to--;\n      add_edge(from, to);\n    }\n\n    n = scc();\n    makeGraph();\n\n    ll ans = 1;\n\n    for(int i = 0; i < n; i++){\n      if(rt[i].empty()){\n        dp[i] = 2;\n      }\n      else{\n        dp[i] = 1;\n\n        for(int j = 0; j < rt[i].size(); j++){\n          dp[i] *= dp[rt[i][j]];\n          dp[i] %= MOD;\n        }\n\n        dp[i]++;\n        dp[i] %= MOD;\n      }\n\n      if(t[i].empty()){\n        ans *= dp[i];\n        ans %= MOD;\n      }\n    }\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n#define int long long\n#define lint long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define SZ(v) ((int)v.size())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define POPCNT(n) (__builtin_popcount(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\ntemplate <typename T> inline T LB(vector<T>& v, T a) { return *lower_bound(ALL(v),a); }\ntemplate <typename T> inline int LBP(vector<T>& v, T a) { return lower_bound(ALL(v),a) - v.begin(); }\ntemplate <typename T> inline T UB(vector<T>& v, T a) { return *upper_bound(ALL(v),a); }\ntemplate <typename T> inline int UBP(vector<T>& v, T a) { return upper_bound(ALL(v),a) - v.begin(); }\ntemplate <typename T1, typename T2> ostream& operator<< (ostream& os, const pair<T1,T2>& p) { os << p.first << \" \" << p.second; return os; }\ntemplate <typename T1, typename T2> istream& operator>> (istream& is, pair<T1,T2>& p) { is >> p.first >> p.second; return is; }\ntemplate <typename T> ostream& operator<< (ostream& os, const vector<T>& v) { REP(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\ntemplate <typename T> istream& operator>> (istream& is, vector<T>& v) { for(T& in : v) is >> in; return is; }\ntemplate <typename T = int> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate <typename T, typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...)); }\ntemplate <typename T, typename V> typename enable_if<is_class<T>::value == 0>::type fill_v(T &t, const V &v) { t = v; }\ntemplate <typename T, typename V> typename enable_if<is_class<T>::value != 0>::type fill_v(T &t, const V &v) { for(auto &e : t) fill_v(e,v); }\nconst lint MOD = 1000000007;\nconst lint INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n\nclass StronglyConnectedComponents {\n    void dfs(int v) {\n        if (used[v]) return;\n        used[v] = true;\n        for (auto &u : gg[v]) dfs(u);\n        ord.push_back(v);\n    }\n\n    void rdfs(int v) {\n        if (~cmp[v]) return;\n        cmp[v] = sz;\n        for (auto &u : rg[v]) rdfs(u);\n    }\n\n    // 強連結成分分解\n    void build() {\n        const int n = g.size();\n        for (int i = 0; i < n; ++i) dfs(i);\n        reverse(ord.begin(), ord.end());\n        for (int i : ord) if (!~cmp[i]) rdfs(i), ++sz;\n        dag.resize(sz);\n        for (int i = 0; i < n; ++i) {\n            for (int j : g[i]) {\n                int x = cmp[i], y = cmp[j];\n                if (x == y) continue;\n                dag[x].emplace_back(y);\n            }\n        }\n    }\n\npublic:\n    using UnweightedGraph = vector<vector<int>>;\n\n    int sz;\n    const UnweightedGraph &g;\n    UnweightedGraph gg, rg, dag;\n    vector<int> cmp, ord;\n    vector<bool> used;\n\n    StronglyConnectedComponents(const UnweightedGraph &g) : sz(0), g(g), gg(g.size()), rg(g.size()), cmp(g.size(), -1), used(g.size(), false)\n    {\n        const int n = g.size();\n        for (int i = 0; i < n; ++i) {\n            for (int j : g[i]) {\n                gg[i].emplace_back(j);\n                rg[j].emplace_back(i);\n            }\n        }\n        build();\n    }\n\n    // 要素kが属する成分の番号\n    int operator[](int k) { return cmp[k]; }\n\n    // xとyが同じ成分に含まれるか\n    bool same(int x, int y) { return cmp[x] == cmp[y]; }\n\n    // 成分の個数\n    int size() { return sz; }\n};\nusing SCC = StronglyConnectedComponents;\n\nvector<vector<int>> reverse_digraph(const vector<vector<int>> &g) {\n    const int n = g.size();\n    vector<vector<int>> res(n);\n    for (int v = 0; v < n; ++v) {\n        for (int u : g[v]) {\n            res[u].push_back(v);\n        }\n    }\n    return res;\n}\n\nint dpW[1010], dpB[1010];\nbool used[1010];\n\nvoid dfs(int v, const vector<vector<int>> &g) {\n    used[v] = true;\n    int sum = 0;\n    dpW[v] = 1;\n    dpB[v] = 1;\n    for (int u : g[v]) {\n        dfs(u, g);\n        (dpB[v] *= (dpW[u] + dpB[u]) % MOD) %= MOD;\n    }\n}\n\nvoid _main() {\n    int N, M;\n    cin >> N >> M;\n    vector<vector<int>> g(N);\n    REP(i, M) {\n        int S, D;\n        cin >> S >> D;\n        S--; D--;\n        g[S].push_back(D);\n    }\n    SCC scc(g);\n    vector<vector<int>> g2 = reverse_digraph(scc.dag);\n    int ans = 1;\n    for (int i = scc.size() - 1; i >= 0; --i) {\n        if (!used[i]) {\n            dfs(i, g2);\n            (ans *= (dpW[i] + dpB[i]) % MOD) %= MOD;\n        }\n    }\n    cout << ans << endl;\n}\n\nsigned main(signed argc, char **argv) {\n    if (argc > 1) {\n        if (strchr(argv[1], 'i'))\n            freopen(\"input.txt\", \"r\", stdin);\n        if (strchr(argv[1], 'o'))\n            freopen(\"output.txt\", \"w\", stdout);\n    }\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    _main();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst long long mod = 1000000007;\n\nint N, M, A[2009], B[2009], cnt[2009], col[2009], cntv[2009], cnts;\nlong long dp[2009];\nbool used[2009], root[2009];\nvector<int> E[2009], G[2009], H[2009], I[2009];\n\nvoid dfs(int pos) {\n\tif (col[pos] >= 1) return;\n\tcol[pos] = cnts; E[cnts].push_back(pos);\n\tfor (int i = 0; i < H[pos].size(); i++) dfs(H[pos][i]);\n}\n\nvoid dfs2(int pos) {\n\tfor (int i = 0; i < I[pos].size(); i++) dfs2(I[pos][i]);\n\n\tdp[pos] = 1;\n\tfor (int i = 0; i < I[pos].size(); i++) {\n\t\tdp[pos] *= (dp[I[pos][i]] + 1LL);\n\t\tdp[pos] %= mod;\n\t}\n}\n\nint main() {\n\tcin >> N >> M;\n\tfor (int i = 1; i <= M; i++) {\n\t\tcin >> A[i] >> B[i];\n\t\tG[A[i]].push_back(B[i]);\n\t\tH[A[i]].push_back(B[i]);\n\t\tH[B[i]].push_back(A[i]);\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (col[i] >= 1) continue;\n\t\tcnts++; dfs(i);\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (used[col[i]] == true) continue;\n\t\tused[col[i]] = true;\n\n\t\tint cx = i;\n\t\twhile (cntv[cx] <= 1) {\n\t\t\tcntv[cx]++;\n\t\t\tif (G[cx].size() == 0) break;\n\t\t\tcx = G[cx][0];\n\t\t}\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (cntv[i] >= 2 || G[i].size() == 0) root[i] = true;\n\t}\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (root[A[i]] == true) continue;\n\t\tI[B[i]].push_back(A[i]);\n\t}\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (root[i] == false) continue;\n\t\tdfs2(i);\n\t}\n\n\tlong long ret = 1;\n\tfor (int i = 1; i <= cnts; i++) {\n\t\tlong long r = 1;\n\t\tfor (int pos : E[i]) { if (root[pos] == true) { r *= dp[pos]; r %= mod; } }\n\t\tr++; r %= mod;\n\t\tret *= r; ret %= mod;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define MAX_V 100000\n#define N MAX_V\nusing namespace std;\ntypedef long long ll;\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\nint n,m;\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  \n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\n\nvoid mk_G(){\n  int k=scc();\n  vector <int> tmp[N],rtmp[N];\n  for(int i=0;i<n;i++){\n    for(int j=0;j<G[i].size();j++)\n      if(cmp[i]!=cmp[G[i][j]]) tmp[cmp[i]].push_back(cmp[G[i][j]]);\n    for(int j=0;j<rG[i].size();j++)\n      if(cmp[i]!=cmp[rG[i][j]]) rtmp[cmp[i]].push_back(cmp[rG[i][j]]);\n    G[i].clear();\n    rG[i].clear();\n  }\n  n=k;\n  for(int i=0;i<k;i++) G[i]=tmp[i],rG[i]=rtmp[i];\n}\n \nll calc(int pos){\n  if(used[pos]) return 1;\n  used[pos]=1;\n  ll res=1;\n  for(int i=0;i<rG[pos].size();i++)res=res*calc(rG[pos][i])%mod;\n  return (res+1)%mod;\n}\n \n\nint main(){\n  cin>>n>>m;\n  V=n;\n  for(int i=0,a,b;i<m;i++)cin>>a>>b,add_edge(a-1,b-1);\n  mk_G();\n  ll ans=1;\n  memset(used,0,sizeof(used));\n  for(int i=0;i<n;i++) if(!G[i].size())ans=ans*calc(i)%mod;\n  cout <<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<deque>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<queue>\n#include<cassert>\n#include<climits>\n\n#define MOD (1000000007)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 2000\n\nusing namespace std;\n\ntypedef long long ull;\ntypedef pair<int,int> ii;\n\nstruct Data{\n  int  to,cost;\n  Data(int to=IINF,int cost=IINF):to(to),cost(cost){}\n};\n\n// Library - topological sort - begin \n\ntemplate<typename T>\nbool visit(const T& G,int v,vector<int>& order,vector<int>& color)\n{\n  color[v] = 1;\n  for(__typeof((G[v]).begin()) e = G[v].begin();e != G[v].end();e++)\n    {\n      if(color[e->to] == 2)continue;//このvisit以外のvisitで訪れた\n      if(color[e->to] == 1)return false;//このvisitで訪れた\n      if(!visit(G,e->to,order,color))return false;\n    }\n  order.push_back(v);\n  color[v] = 2;\n  return true;\n}\n\ntemplate<typename T>\nbool topologicalSort(const T& G,vector<int>& order)\n{\n  int SizeG = G.size();\n  vector<int> color(SizeG); \n  for(int u=0;u<SizeG;u++)\n    if(!color[u] && !visit(G,u,order,color))\n      return false;\n  reverse(order.begin(),order.end());\n  return true;\n}\n\n// Library - topological sort - end\n\nint V,E,S,D;\nvector<vector<Data> > tmp_G,tmp_rG;\nvector<int>  G[MAX];\nvector<int> rG[MAX];\nvector<int> vs;\nbool used[MAX];\nint cmp[MAX];\null dp[MAX];\n\ninline void add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k = 0;\n  for(int i = vs.size(); i >= 0 ; i-- )if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nint main(){\n\n  cin >> V >> E;\n  map<int,int> Index;\n  int dex = 0;\n  rep(i,E){\n    cin >> S >> D;\n    assert(1 <= S && S <= V);\n    assert(1 <= D && D <= V);\n    if(Index.find(S) == Index.end())Index[S] = dex++;\n    if(Index.find(D) == Index.end())Index[D] = dex++;\n    int s = Index[S];\n    int d = Index[D];\n    add_edge(s,d);\n  }\n  int nV = scc();\n  rep(i,nV)dp[i] = -1;\n\n  set<int> OUT_counter[nV];\n  rep(i,V)rep(j,G[i].size()){\n    if(cmp[i] == cmp[G[i][j]])continue;\n    OUT_counter[cmp[i]].insert(cmp[G[i][j]]);\n  }\n\n  tmp_G.clear(),tmp_rG.clear();\n  tmp_G.resize(nV),tmp_rG.resize(nV);\n  rep(i,nV)for(int j : OUT_counter[i]){\n    tmp_G[i].push_back(j);\n    tmp_rG[j].push_back(i);\n  }\n\n  vector<int> order;\n  topologicalSort(tmp_G,order);\n\n  rep(i,nV)if(tmp_rG[order[i]].empty())dp[order[i]] = 2ULL;\n\n  ull ans = 1;\n\n  rep(i,nV){\n    int cur = order[i];\n    ull cost = 1;\n    rep(j,tmp_rG[cur].size()){\n      int prev = tmp_rG[cur][j].to;\n      cost = ( cost * dp[prev] ) % MOD;\n    }\n    if(!tmp_rG[cur].empty()){\n      assert(dp[cur] == -1);\n      dp[cur] = ( cost + 1ULL ) % MOD;\n    }\n    if(tmp_G[cur].empty())ans = ( ans * dp[cur] ) % MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\nclass SCC\n{\nprivate:\n    vector<int> vs;\t// 帰りの順番, 後ろのほう要素は始点側\n    vector<bool> used;\n\n    void dfs(int v)\n    {\n        used[v] = true;\n        for (int i = 0; i < (int)g[v].size(); ++i)\n            if (!used[g[v][i]])\n                dfs(g[v][i]);\n        vs.push_back(v);\n    }\n\n    void rdfs(int v, int k)\n    {\n        used[v] = true;\n        component[v] = k;\n        for (int i = 0; i < (int)rg[v].size(); ++i)\n            if (!used[rg[v][i]])\n                rdfs(rg[v][i], k);\n    }\n\npublic:\n    int V;\n    vector<vector<int> > g;\n    vector<vector<int> > rg;\n    vector<int> component;\n    int num_components;\n\n    SCC(int V)\n        : vs(V), used(V), V(V), g(V), rg(V), component(V), num_components(-1) { }\n\n    void add_edge(int from, int to)\n    {\n        g[from].push_back(to);\n        rg[to].push_back(from);\n    }\n\n    // 強連結成分の数を返す\n    // O(V + E)\n    // グラフの始点側の値(component[v])は小さい\n    // 末端は大きい値, 最末端(component[v] == scc() - 1)\n    int scc()\n    {\n        vs.clear();\n        fill(used.begin(), used.end(), false);\n        for (int i = 0; i < V; ++i)\n            if (!used[i])\n                dfs(i);\n\n        fill(used.begin(), used.end(), false);\n        int k = 0;\n        for (int i = vs.size() - 1; i >= 0; --i)\n            if (!used[vs[i]])\n                rdfs(vs[i], k++);\n        return num_components = k;\n    }\n\n    // scc_g: graph by components, nodes: the numbers of original graph\n    // scc_g can have self loops\n    void build_graph(vector<vector<int> >& scc_g, vector<vector<int> >& original_nodes)\n    {\n        if (num_components == -1)\n            scc();\n\n        scc_g.clear();\n        scc_g.resize(num_components);\n        original_nodes.clear();\n        original_nodes.resize(num_components);\n\n\n        for (int i = 0; i < V; ++i)\n            original_nodes[component[i]].push_back(i);\n\n        for (int i = 0; i < V; ++i)\n            for (int j = 0; j < (int)g[i].size(); ++j)\n                if (component[i] != component[g[i][j]]) // remove self loop\n                    scc_g[component[i]].push_back(component[g[i][j]]);\n\n        // remove duplicated edges (O(ElogE)... decrease complexity???)\n        for (int i = 0; i < num_components; ++i)\n        {\n            sort(scc_g[i].begin(), scc_g[i].end());\n            scc_g[i].erase(unique(scc_g[i].begin(), scc_g[i].end()), scc_g[i].end());\n        }\n    }\n};\n\nconst ll mod = ten(9) + 7;\nvector<vector<int> > g, ori;\nll dfs(int cur, int par)\n{\n    ll bend = 1;\n    if (g[cur].size() > 0)\n    {\n        rep(i, g[cur].size())\n        {\n            int to = g[cur][i];\n            if (to != par)\n                (bend *= dfs(to, cur) + 1) %= mod;\n        }\n    }\n    return bend;\n}\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n\n    SCC scc(n);\n    rep(i, m)\n    {\n        int s, d;\n        cin >> s >> d;\n        --s, --d;\n        scc.add_edge(d, s); // parent(s) = d\n    }\n\n    scc.build_graph(g, ori);\n    \n    bool root[1111];\n    fill_n(root, g.size(), true);\n    rep(i, g.size()) rep(j, g[i].size())\n        root[g[i][j]] = false;\n\n    ll res = 1;\n    rep(i, g.size())\n        if (root[i])\n            (res *= dfs(i, -1) + 1) %= mod;\n\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<deque>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<queue>\n#include<cassert>\n#include<climits>\n\n#define MOD (1000000007)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 2000\n\nusing namespace std;\n\ntypedef long long ull;\ntypedef pair<int,int> ii;\n\nstruct Data{\n  int  to,cost;\n  Data(int to=IINF,int cost=IINF):to(to),cost(cost){}\n};\n\n// Library - topological sort - begin \n\ntemplate<typename T>\nbool visit(const T& G,int v,vector<int>& order,vector<int>& color)\n{\n  color[v] = 1;\n  for(__typeof((G[v]).begin()) e = G[v].begin();e != G[v].end();e++)\n    {\n      if(color[e->to] == 2)continue;//このvisit以外のvisitで訪れた\n      if(color[e->to] == 1)return false;//このvisitで訪れた\n      if(!visit(G,e->to,order,color))return false;\n    }\n  order.push_back(v);\n  color[v] = 2;\n  return true;\n}\n\ntemplate<typename T>\nbool topologicalSort(const T& G,vector<int>& order)\n{\n  int SizeG = G.size();\n  vector<int> color(SizeG); \n  for(int u=0;u<SizeG;u++)\n    if(!color[u] && !visit(G,u,order,color))\n      return false;\n  reverse(order.begin(),order.end());\n  return true;\n}\n\n// Library - topological sort - end\n\nint V,E,S,D;\nvector<vector<Data> > tmp_G,tmp_rG;\nvector<int>  G[MAX];\nvector<int> rG[MAX];\nvector<int> vs;\nbool used[MAX];\nint cmp[MAX];\null dp[MAX];\n\ninline void add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k = 0;\n  for(int i = vs.size(); i >= 0 ; i-- )if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nint main(){\n\n  cin >> V >> E;\n  rep(i,E){\n    cin >> S >> D;\n    assert(1 <= S && S <= V);\n    assert(1 <= D && D <= V);\n    add_edge(S-1,D-1);\n  }\n  int nV = scc();\n  rep(i,nV)dp[i] = -1;\n\n  set<int> OUT_counter[nV];\n  rep(i,V)rep(j,G[i].size()){\n    if(cmp[i] == cmp[G[i][j]])continue;\n    OUT_counter[cmp[i]].insert(cmp[G[i][j]]);\n  }\n\n  tmp_G.clear(),tmp_rG.clear();\n  tmp_G.resize(nV),tmp_rG.resize(nV);\n  rep(i,nV)for(int j : OUT_counter[i]){\n    tmp_G[i].push_back(j);\n    tmp_rG[j].push_back(i);\n  }\n\n  vector<int> order;\n  topologicalSort(tmp_G,order);\n\n  rep(i,nV)if(tmp_rG[order[i]].empty())dp[order[i]] = 2ULL;\n\n  ull ans = 1;\n\n  rep(i,nV){\n    int cur = order[i];\n    ull cost = 1;\n    rep(j,tmp_rG[cur].size()){\n      int prev = tmp_rG[cur][j].to;\n      cost = ( cost * dp[prev] ) % MOD;\n    }\n    if(!tmp_rG[cur].empty()){\n      assert(dp[cur] == -1);\n      dp[cur] = ( cost + 1ULL ) % MOD;\n    }\n    if(tmp_G[cur].empty())ans = ( ans * dp[cur] ) % MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MAX 1005\nll mod=1e9+7;\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n\nint n,m,a,b;\nvector<int> G[MAX],g[MAX];\nint p[MAX];\nbool flg[MAX];\n\nint update(int x){\n  flg[x]=true;\n  if(p[x]==x)return x;\n  return p[x]=update(p[x]);\n}\n\nint find(int x){\n  if(p[x]==x)return x;\n  return find(p[x]);\n}\n\nll dfs(int pos){\n  ll res=1;\n  for(int i=0;i<(int)g[pos].size();i++)\n    res=mul(res,dfs(g[pos][i]));  \n  return (res+1LL)%mod;\n}\n\nint main(){\n  while(cin>>n>>m){\n    for(int i=1;i<=n;i++){\n      p[i]=i;\n      flg[i]=false;\n      G[i].clear();\n      g[i].clear();\n    }\n    for(int i=0;i<m;i++){\n      cin>>a>>b;\n      G[b].push_back(a);\n      if(find(b)==a)update(b);\n      else p[a]=b;\n    }\n    for(int i=1;i<=n;i++){\n      for(int j=0;j<(int)G[i].size();j++){\n        int w=G[i][j];\n        if(flg[w])continue;\n        if(flg[i]){\n          g[p[i]].push_back(w);\n        }else{\n          g[i].push_back(w);\n        }\n      }\n    }\n    ll ans=1;\n    for(int i=1;i<=n;i++)if(p[i]==i)\n        ans=mul(ans,dfs(i));\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nll mod = 1000000007;\n\nclass SCC{\npublic:\n\tvector<vector<int> > G,rG,graph,bg;\n\tvector<int> vs,cmp;\n\tvector<bool> used;\n\tint V,cnt;\n\tSCC(int node_size){\n\t\tV = node_size;\n\t\tG.resize(V),rG.resize(V);\n\t\tused.resize(V),cmp.resize(V);\n\t}\n\tvoid add_edge(int from,int to){\n\t\tG[from].push_back(to);\n\t\trG[to].push_back(from);\n\t}\n\tvoid dfs(int u){\n\t\tused[u] = true;\n\t\tfor(int v : G[u]){\n\t\t\tif(!used[v]){\n\t\t\t\tdfs(v);\n\t\t\t}\n\t\t}\n\t\tvs.push_back(u);\n\t}\n\tvoid dfs(int u,const int k){\n\t\tused[u] = true;\n\t\tcmp[u] = k;\n\t\tfor(int v : rG[u]){\n\t\t\tif(!used[v]){\n\t\t\t\tdfs(v,k);\n\t\t\t}\n\t\t}\n\t}\n\tint solve(){ //強連結成分の数を返す\n\t\tfill(used.begin(),used.end(),false);\n\t\trep(i,V){\n\t\t\tif(!used[i]){\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t\tfill(used.begin(),used.end(),false);\n\t\tcnt = 0;\n\t\tfor(int i=V-1;i>=0;i--){\n\t\t\tif(!used[vs[i]]){\n\t\t\t\tdfs(vs[i],cnt++);\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\tvoid make_graph(){\n\t\tgraph.resize(cnt);\n        bg.resize(cnt);\n\t\trep(i,V){\n\t\t\tfor(int v : G[i]){\n\t\t\t\tif(cmp[i] != cmp[v]){\n\t\t\t\t\tgraph[cmp[i]].push_back(cmp[v]);\n\t\t\t\t\tbg[cmp[v]].push_back(cmp[i]);\n                }\n\t\t\t}\n\t\t}\n\t}\n};\n\nll bfs(int i,vector<vector<int> > &g,vector<vector<int> > &bg){\n    if(bg[i].size()==0){\n        return (ll)2;\n    }\n    ll ans = 1;\n    for(int v : bg[i]){\n        ans = ans*bfs(v,g,bg)%mod;\n    }\n    return (ans+1)%mod;\n}\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    SCC scc(n);\n    for(int i=0;i<m;i++){\n        int a,b;\n        cin >> a >> b;\n        a--;b--;\n        scc.add_edge(a,b);\n    }\n    int s = scc.solve();\n    scc.make_graph();\n    auto& g = scc.graph;\n    auto& bg = scc.bg;\n    ll ans = 1;\n    for(int i=0;i<s;i++){\n        if(g[i].size()==0){\n            ans = ans*bfs(i,g,bg)%mod;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Package: StandardCodeLibrary.Core\n * */\n//蠑戊ソ帛クク逕ィ逧?、エ譁?サカ蟷カ菴ソ逕ィstd蜷榊ュ礼ゥコ髣エ;\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <utility>\n#include <vector>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <climits>\nusing namespace std;\n\n//逕ィ莠主?蟆台サ」遐??逧?ョ?\n#define lp for(;;)\n#define repf(i,a,b) for (int i=(a);i<(b);++i)\n#define rrepf(i,a,b) for (int i=(a)-1;i>=(b);--i)\n#define rep(i,n) repf(i,0,n)\n#define rrep(i,n) rrepf(i,n,0)\n#define ft(i,a,b) for (int i=(a);i<=(b);++i)\n#define fdt(i,a,b) for (int i=(a);i>=(b);--i)\n#define for_nonempty_subsets(subset,set) for (int subset=set;subset;subset=(subset-1)&(set))\n#define for_in_charset(i,charset) for (cstr i=(charset);*i;i++)\n#define whl while\n#define rtn return\n#define fl(x,y) memset((x),char(y),sizeof(x))\n#define clr(x) fl(x,char(0))\n#define cpy(x,y) memcpy(x,y,sizeof(x))\n#define sf scanf\n#define pf printf\n#define vec vector\n#define pr pair\n#define que queue\n#define prq priority_queue\n#define itr iterator\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define ins insert\n#define ers erase\n#define lb lower_bound\n#define ub upper_bound\n#define rnk order_of_key\n#define sel find_by_order\n#define sz(x) (int((x).size()))\n#define all(x) (x).begin(),(x).end()\n#define srt(x) sort(all(x))\n#define uniq(x) srt(x),(x).erase(unique(all(x)),(x).end())\n#define rev(x) reverse(all(x))\n#define shf(x) random_shuffle(all(x))\n#define nxtp(x) next_permutation(all(x))\n\n//隹?ッ慕嶌蜈ウ逧?ョ?\n#ifndef DEBUG\n#define prt(x) (cerr)\n#define asrtWA(s) do if(!(s))exit(0);whl(0)\n#define asrtTLE(s) do if(!(s))whl(1);whl(0)\n#define asrtMLE(s) do if(!(s))whl(new int);whl(0)\n#define asrtOLE(s) do if(!(s))whl(1)puts(\"OLE\");whl(0)\n#define asrtRE(s) do if(!(s))*(int*)0=0;whl(0)\n#define runtime() (cerr)\n#define input(in) freopen(in,\"r\",stdin)\n#define output(out) freopen(out,\"w\",stdout)\n#else\n#define prt(x) cerr<<\"隨ャ\"<<__LINE__<<\"陦圭t: \"<<#x\"\\t=\"<<(x)<<endl\n#define asrtWA(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtTLE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtMLE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtOLE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtRE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define runtime() cerr<<\"Used: \"<<db(clock())/CLOCKS_PER_SEC<<\"s\"<<endl\n#define input(in)\n#define output(out)\n#endif\n\n//蟶ク逕ィ謨ー謐ョ邀サ蝙?\ntypedef long long int lli;\ntypedef double db;\ntypedef const char* cstr;\ntypedef string str;\ntypedef vec<int> vi;\ntypedef vec<vi> vvi;\ntypedef vec<bool> vb;\ntypedef vec<vb> vvb;\ntypedef vec<str> vs;\ntypedef pr<int,int> pii;\ntypedef pr<lli,lli> pll;\ntypedef pr<db,db> pdd;\ntypedef map<int,int> mii;\ntypedef map<str,int> msi;\ntypedef map<char,int> mci;\ntypedef set<int> si;\ntypedef set<str> ss;\ntypedef que<int> qi;\ntypedef vec<pii> vpii;\ntypedef vec<pdd> vpdd;\n\n//蟶ク逕ィ蟶ク驥?int逧?怙螟ァ蛟シ;lli逧?怙螟ァ蛟シ;db逧?ッッ蟾ョ逶ク蜈ウ蟶ク謨ー;谺ァ諡牙クク謨ー;蝨?捉邇?遘サ蜉ィ蜷鷹?;蜿匁ィ。菴ソ逕ィ逧?勁謨ー;\nint oo=(~0u)>>1;\nlli ooll=(~0ull)>>1;\ndb inf=1e+10;\ndb eps=1e-10;\ndb gam=0.5772156649015328606;\ndb pi=acos(-1.0);\nint dx[]={1,0,-1,0,1,-1,-1,1,0};\nint dy[]={0,1,0,-1,1,1,-1,-1,0};\nint MOD=1000000007;\n\n//蟶ク逕ィ蜃ス謨ー:譛?、ァ譛?ー丞?譖エ譁ー;謨ー蟄ヲ逶ク蜈ウ蜃ス謨ー;霎灘?蜥瑚セ灘?;譬醍憾謨ー扈?蟷カ譟・髮?蜿ッ蜷亥ケカ蝣?\ntemplate<typename type>inline bool cmax(type& a,const type& b){rtn a<b?a=b,true:false;}\ntemplate<typename type>inline bool cmin(type& a,const type& b){rtn b<a?a=b,true:false;}\ntemplate<typename type>inline type sqr(const type& x){rtn x*x;}\ntemplate<typename type>inline type mod(const type& x){rtn x%MOD;}\ninline int sgn(const db& x){rtn (x>+eps)-(x<-eps);}\ninline int dbcmp(const db& a,const db& b){rtn sgn(a-b);}\ntemplate<typename type>inline pr<type,type> operator-(const pr<type,type>& x){rtn mp(-x.x,-x.y);}\ntemplate<typename type>inline pr<type,type> operator+(const pr<type,type>& a,const pr<type,type>& b){rtn mp(a.x+b.x,a.y+b.y);}\ntemplate<typename type>inline pr<type,type> operator-(const pr<type,type>& a,const pr<type,type>& b){rtn mp(a.x-b.x,a.y-b.y);}\ntemplate<typename type>inline pr<type,type> operator*(const pr<type,type>& a,const type& b){rtn mp(a.x*b,a.y*b);}\ntemplate<typename type>inline pr<type,type> operator/(const pr<type,type>& a,const type& b){rtn mp(a.x/b,a.y/b);}\ntemplate<typename type>inline pr<type,type>& operator-=(pr<type,type>& a,const pr<type,type>& b){rtn a=a-b;}\ntemplate<typename type>inline pr<type,type>& operator+=(pr<type,type>& a,const pr<type,type>& b){rtn a=a+b;}\ntemplate<typename type>inline pr<type,type>& operator*=(pr<type,type>& a,const type& b){rtn a=a*b;}\ntemplate<typename type>inline pr<type,type>& operator/=(pr<type,type>& a,const type& b){rtn a=a/b;}\ntemplate<typename type>inline type cross(const pr<type,type>& a,const pr<type,type>& b){rtn a.x*b.y-a.y*b.x;}\ntemplate<typename type>inline type dot(const pr<type,type>& a,const pr<type,type>& b){rtn a.x*b.x+a.y*b.y;}\ntemplate<typename type>inline type gcd(type a,type b){if(b)whl((a%=b)&&(b%=a));rtn a+b;}\ntemplate<typename type>inline type lcm(type a,type b){rtn a*b/gcd(a,b);}\ntemplate<typename istream,typename first_type,typename second_type>inline istream& operator>>(istream& cin,pr<first_type,second_type>& x){rtn cin>>x.x>>x.y;}\ntemplate<typename ostream,typename first_type,typename second_type>inline ostream& operator<<(ostream& cout,const pr<first_type,second_type>& x){rtn cout<<x.x<<\" \"<<x.y;}\ntemplate<typename istream,typename type>inline istream& operator>>(istream& cin,vec<type>& x){rep(i,sz(x))cin>>x[i];rtn cin;}\ntemplate<typename ostream,typename type>inline ostream& operator<<(ostream& cout,const vec<type>& x){rep(i,sz(x))cout<<x[i]<<(i+1==sz(x)?\"\":\" \");rtn cout;}\ninline ostream& pdb(int prcs,db x){rtn cout<<setprecision(prcs)<<fixed<<(sgn(x)?(x):0);}\ntemplate<typename type>inline void bit_inc(vec<type>& st,int x,type inc){whl(x<sz(st))st[x]+=inc,x|=x+1;}\ntemplate<typename type>inline type bit_sum(const vec<type>& st,int x){type s=0;whl(x>=0)s+=st[x],x=(x&(x+1))-1;rtn s;}\ntemplate<typename type>inline type bit_kth(const vec<type>& st,int k){int x=0,y=0,z=0;whl((1<<(++y))<=sz(st));fdt(i,y-1,0){if((x+=1<<i)>sz(st)||z+st[x-1]>k)x-=1<<i;else z+=st[x-1];}rtn x;}\ninline void make_set(vi& st){rep(i,sz(st))st[i]=i;}\ninline int find_set(vi& st,int x){int y=x,z;whl(y!=st[y])y=st[y];whl(x!=st[x])z=st[x],st[x]=y,x=z;rtn y;}\ninline bool union_set(vi& st,int a,int b){a=find_set(st,a),b=find_set(st,b);rtn a!=b?st[a]=b,true:false;}\ntemplate<typename type>inline void merge(type& a,type& b){if(sz(a)<sz(b))swap(a,b);whl(sz(b))a.ins(*b.begin()),b.ers(b.begin());}\n\n//蛻晏ァ句喧;\nstruct Initializer\n{\n#ifndef DEBUG\n\tInitializer(){ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);}\n#else\n\t~Initializer(){runtime();}\n#endif\n}initializer;\n\n//髱樊?蜃?\n#define feach(e,s) for (__typeof__((s).begin()) e=(s).begin();e!=(s).end();++e)\n#include <ext/rope>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\nusing __gnu_cxx::rope;\ntemplate<typename key,typename value>class ext_map:public __gnu_pbds::tree<key,value,less<key>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>{};\n#define ctz __builtin_ctz\n#define clz __builtin_clz\n#define bc __builtin_popcount\n\nint main()\n{\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint V,E;\n\nstruct GROUP{\n\tvector<int> nodes;\n};\n\nGROUP group[1000];\nvector<int> G[1000];\nvector<int> reverse_G[1000];\nstack<int> S;\n\nbool check[1000];\nint table[1000];\n\nint group_index = -1;\n\nvoid dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(!check[G[node_id][i]])dfs(G[node_id][i]);\n\t}\n\tS.push(node_id);\n}\n\nvoid reverse_dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tgroup[group_index].nodes.push_back(node_id);\n\ttable[node_id] = group_index;\n\n\tfor(int i = 0; i < reverse_G[node_id].size(); i++){\n\t\tif(!check[reverse_G[node_id][i]])reverse_dfs(reverse_G[node_id][i]);\n\t}\n}\n\n\nint main(){\n\n\tscanf(\"%d %d\",&V,&E);\n\n\tfor(int i = 0; i < V;i++)check[i] = false;\n\n\tint from,to;\n\n\tfor(int loop = 0; loop < E; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tG[from].push_back(to);\n\t\treverse_G[to].push_back(from);\n\t}\n\n\tfor(int i = 0; i < V;i++){\n\t\tif(!check[i])dfs(i);\n\t}\n\n\tfor(int i = 0; i < V;i++)check[i] = false;\n\n\twhile(!S.empty()){\n\t\tif(!check[S.top()]){\n\t\t\tgroup_index++;\n\n\t\t\treverse_dfs(S.top());\n\t\t}\n\t\tS.pop();\n\t}\n\n\tint dp[group_index+1];\n\tfor(int i = 0; i <= group_index; i++)dp[i] = 1;\n\n\tint ans = 1;\n\tint count,next_group;\n\tbool visited[group_index+1];\n\n\tfor(int loop = 0; loop <= group_index; loop++){\n\n\t\tfor(int i = 0; i <= group_index; i++)visited[i] = false;\n\n\t\tvisited[loop] = true;\n\t\tcount = 0;\n\n\t\tfor(int i = 0; i < group[loop].nodes.size(); i++){\n\t\t\tfor(int k = 0; k < G[group[loop].nodes[i]].size(); k++){\n\t\t\t\tnext_group = table[G[group[loop].nodes[i]][k]];\n\n\t\t\t\tif(visited[next_group] == false){\n\t\t\t\t\tvisited[next_group] = true;\n\t\t\t\t\tcount++;\n\t\t\t\t\tdp[next_group] = dp[next_group]*(dp[loop]+1)%MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(count == 0){\n\t\t\tans = ans*(dp[loop]+1)%MOD;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans%MOD);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconstexpr ll MOD = 1000000007;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\nint main()\n{\n    int N, M;\n    cin >> N >> M;\n    vector<int> to(N, -1);\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        to[u] = v;\n    }\n    vector<int> label(N), cycle;\n    iota(label.begin(), label.end(), 0);\n    vector<bool> used(N, false), reached(N, false);\n    auto getcycle = [&](int s) {\n        for (int i = 0; i < 2 * N; i++, s = to[s]) {\n            used[s] = true;\n            if (to[s] == -1) { break; }\n        }\n        if (reached[label[s]]) { return; }\n        reached[label[s]] = true, cycle.push_back(s);\n        if (to[s] == -1) { return; }\n        for (int p = to[s]; p != s; p = to[p]) { label[p] = s; }\n    };\n    for (int i = 0; i < N; i++) {\n        if (not used[i]) { getcycle(i); }\n    }\n    vector<vector<int>> g(N);\n    for (int i = 0; i < N; i++) {\n        if (to[i] == -1 or label[i] == label[to[i]]) { continue; }\n        g[label[to[i]]].push_back(label[i]);\n    }\n    auto dfs = fix([&](auto&& self, const int s) -> ll {\n        ll ans = 1;\n        for (const int to : g[s]) { (ans *= self(self, to)) %= MOD; }\n        return (ans + 1) % MOD;\n    });\n    ll ans = 1;\n    for (const int c : cycle) { (ans *= dfs(c)) %= MOD; }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb push_back\n\ntypedef long long ll;\nconst int N = 3000;\nconst ll mod = 1000000007;\nvector<int> edge[N];\nvector<int> redge[N];\nint component[N];\nvector<int> node;\nbool vis[N];\nint order;\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size()){\n    dfs(edge[now][i]);\n  }\n  node.pb(now);\n}\n\nvoid dfs(int now,int cmp){\n  if (vis[now])return;\n  vis[now]=true;\n  component[now]=cmp;\n  rep(i,(int)redge[now].size()){\n    dfs(redge[now][i],cmp);\n  }\n}\n\nint scc(int n){\n  node.clear();\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])dfs(i);\n  }\n  reverse(node.begin(),node.end());\n  rep(i,n)vis[i]=false;\n  int comp=0;\n  rep(i,n){\n    int now=node[i];\n    if (!vis[now])dfs(now,comp),comp++;\n  }\n  return comp;\n}\n\n\nll solve(int n){\n  ll cnt[n];\n  vector<int> cedge[n];\n  vector<int> rcedge[n];\n  int m=scc(n);\n   //new graph\n  rep(i,n){\n    int now=i;\n    rep(j,(int)edge[i].size()){\n      int next=edge[i][j];\n      if (component[now] != component[next]){\n\tcedge[  component[now]].pb(component[next]);\n\trcedge[component[next]].pb(component[now]);\n      }\n    }\n  }\n\n  rep(i,m){\n    sort(cedge[i].begin(),cedge[i].end());\n    cedge[i].erase(unique(cedge[i].begin(),cedge[i].end()),\n\t\t   cedge[i].end());\n    sort(rcedge[i].begin(),rcedge[i].end());\n    rcedge[i].erase(unique(rcedge[i].begin(),rcedge[i].end()),\n\t\t    rcedge[i].end());\n  }\n\n  rep(i,m){\n    int now = i;\n    //bend now\n    cnt[now]=1;\n    rep(i,(int)rcedge[now].size()){\n      cnt[now]=(cnt[rcedge[now][i]]*cnt[now])%mod;\n    }\n    //do not bend now \n    cnt[now]=(cnt[now]+1)%mod;\n  }\n\n  ll ret=1;\n  rep(i,m){\n    if (cedge[i].size() == 0){\n      ret=(ret*cnt[i])%mod;\n    }\n  }\n  return ret;\n}\n\nmain(){\n  int n,m;\n  while(cin>>n>>m && n){\n    rep(i,n)edge[i].clear(),redge[i].clear();\n    rep(i,m){\n      int f,t;\n      cin>>f>>t;\n      edge[f-1].pb(t-1);\n      redge[t-1].pb(f-1);\n    }\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct Edge{int from, to; ll cost;};\n\nconst ll MOD = 1000000007;\nconst long double EPS = 10e-10;\nconst int MAX_V = 1000;\n\nvector<int> G[MAX_V], rG[MAX_V], vs;\nint component[MAX_V];\nbool used[MAX_V];\nll dp[MAX_V][2];\nint V,E;\n\nvoid add_edge(int s, int t){\n    G[s].push_back(t);\n    rG[t].push_back(s);\n}\n\nvoid dfs(int node){\n    used[node] = true;\n    for(int next: G[node]){\n        if(!used[next]) dfs(next);\n    }\n    vs.push_back(node);\n}\n\nvoid rdfs(int node, int k){\n    used[node] = true;\n    component[node] = k;\n    for(int next: rG[node]){\n        if(!used[next]) rdfs(next, k);\n    }\n}\n\nvoid scc(){\n    memset(used, false, sizeof(used));\n    rep(V){\n        if(!used[i]) dfs(i);\n    }\n    memset(used, false, sizeof(used));\n    int k = 0;\n    reverse(all(vs));\n    for(int i: vs){\n        if(!used[i]) rdfs(i, k++);\n    }\n}\n\nvector<int> topological_sort(int N){\n    vector<int> ret, indeg(N, 0);\n    vector<bool> used(N, false);\n    set<int> st;\n    rep(N) for(int to: G[i]) indeg[to]++;\n    rep(N) if(indeg[i] == 0) st.insert(i);\n\n    while(!st.empty()){\n        int node = *st.begin();\n        st.erase(node);\n        ret.push_back(node);\n        used[node] = true;\n        for(int next: G[node]){\n            indeg[next]--;\n            if(!used[next] && indeg[next] == 0) st.insert(next);\n        }\n    }\n\n    return ret;\n}\n\nvoid rec(int node, int color){\n    if(color == 0) dp[node][0] = 1;\n    if(dp[node][color] > 0) return;\n\n    dp[node][1] = 1LL;\n    for(int next: rG[node]){\n        dp[node][1] *= (dp[next][0] + dp[next][1]);\n        dp[node][1] %= MOD;\n    }\n    return;\n}\n\nint main(){\n    std::ios::sync_with_stdio(0); cin.tie(0);\n\n    int s, d;\n    cin >> V >> E;\n    Pii edges[E];\n    rep(E){\n        cin >> s >> d;\n        s--; d--;\n        add_edge(s, d);\n        edges[i] = Pii(s, d);\n    }\n\n    scc();\n\n    rep(V){\n        G[i].clear();\n        rG[i].clear();\n    }\n    V = *max_element(component, component+V) + 1;\n    rep(E){\n        s = edges[i].first;\n        d = edges[i].second;\n        if(component[s] != component[d]){\n            add_edge(component[s], component[d]);\n        }\n    }\n\n    vector<int> sorted_v = topological_sort(V);\n    fill(dp[0], dp[2], 0LL);\n    for(int s: sorted_v){\n        rec(s, 0); rec(s, 1);\n    }\n    ll ans = 1LL;\n    for(int v: sorted_v){\n        if(!G[v].size()) (ans *= ((dp[v][0]+dp[v][1]) % MOD)) %= MOD;\n    }\n\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  static constexpr T mod = MOD;\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n\n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n\n  Mint inv(){return pow(MOD-2);}\n\n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n\n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  static Mint comb(long long n,int k){\n    Mint num(1),dom(1);\n    for(int i=0;i<k;i++){\n      num*=Mint(n-i);\n      dom*=Mint(i+1);\n    }\n    return num/dom;\n  }\n};\ntemplate<typename T,T MOD> constexpr T Mint<T, MOD>::mod;\ntemplate<typename T,T MOD>\nostream& operator<<(ostream &os,Mint<T, MOD> m){os<<m.v;return os;}\n\n\nstruct SCC{\n  vector<vector<int> > G,R,T,C;\n  vector<int> vs,used,blg;\n  SCC(){}\n  SCC(int n):G(n),R(n),used(n),blg(n){}\n\n  void add_edge(int u,int v){\n    G[u].emplace_back(v);\n    R[v].emplace_back(u);\n  }\n\n  void dfs(int v){\n    used[v]=1;\n    for(int u:G[v])\n      if(!used[u]) dfs(u);\n    vs.emplace_back(v);\n  }\n\n  void rdfs(int v,int k){\n    used[v]=1;\n    blg[v]=k;\n    C[k].emplace_back(v);\n    for(int u:R[v])\n      if(!used[u]) rdfs(u,k);\n  }\n\n  int build(){\n    int n=G.size();\n    for(int v=0;v<n;v++)\n      if(!used[v]) dfs(v);\n\n    fill(used.begin(),used.end(),0);\n    int k=0;\n    for(int i=n-1;i>=0;i--){\n      if(!used[vs[i]]){\n        T.emplace_back();\n        C.emplace_back();\n        rdfs(vs[i],k++);\n      }\n    }\n    for(int v=0;v<n;v++)\n      for(int u:G[v])\n        if(blg[v]!=blg[u])\n          T[blg[v]].push_back(blg[u]);\n\n    for(int i=0;i<k;i++){\n      sort(T[i].begin(),T[i].end());\n      T[i].erase(unique(T[i].begin(),T[i].end()),T[i].end());\n    }\n    return k;\n  }\n  int operator[](int k) const{return blg[k];};\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  using M = Mint<int>;\n\n  int n,m;\n  cin>>n>>m;\n\n  SCC scc(n);\n  for(int i=0;i<m;i++){\n    int s,d;\n    cin>>s>>d;\n    s--;d--;\n    scc.add_edge(s,d);\n  }\n\n  int k=scc.build();\n  vector<M> dp(k,1);\n  vector<int> indeg(k,0);\n\n  M ans(1);\n  for(int i=0;i<k;i++){\n    if(indeg[i]!=0) dp[i]-=M(1);\n    for(int j:scc.T[i])\n      dp[j]*=dp[i]+M(1);\n    if(scc.T[i].empty()) ans*=dp[i]+M(1);\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n \ntypedef long long ll;\nint const inf = 1<<29;\n \nconstexpr int MOD = 1e9+7;\n \nnamespace graph { // not verified\n \nconstexpr int MaxV = 1010;\n \nstruct scc {\n \n  int V = MaxV;\n  vector<int> G[MaxV];\n  vector<int> rG[MaxV];\n  vector<int> vs;\n  vector<bool> used;\n  vector<int> comp;\n  int SCCGraphSize;\n \n  scc(): V(MaxV) { comp.resize(MaxV); }\n  scc(int V_): V(V_) { comp.resize(MaxV); }\n \n  void add_edge(int from, int to) {\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  }\n \n  void dfs(int v) {\n    used[v] = 1;\n    for(auto e: G[v]) {\n      if(!used[e]) dfs(e);\n    }\n    vs.push_back(v);\n  }\n \n  void rdfs(int v, int k) {\n    used[v] = 1;\n    comp[v] = k;\n    for(auto e: rG[v]) {\n      if(!used[e]) rdfs(e, k);\n    }\n  }\n \n  void solve() {\n    used.clear(); used.resize(MaxV);\n    vs.clear();\n    for(int i = 0; i < V; i++) {\n      if(!used[i]) dfs(i);\n    }\n    used.clear(); used.resize(MaxV);\n    int k = 0;\n    for(int i = vs.size() - 1; i >= 0; i--) {\n      if(!used[vs[i]]) rdfs(vs[i], k++);\n    }\n    SCCGraphSize = k;\n  }\n \n};\n \n}\n \nvector<vector<int>> tree;\n \nll solve(int curr, int par, vector<bool>& vis) {\n  ll ret = 1;\n  vis[curr] = 1;\n  for(auto e: tree[curr]) {\n    if(e == par) continue;\n    ret *= solve(e, curr, vis);\n    ret %= MOD;\n  }\n  return ret + 1;\n}\n \nint main() {\n \n  int N, M; cin >> N >> M;\n  graph::scc scc_graph(N);\n  rep(i, M) {\n    int S, D; cin >> S >> D; S --, D --;\n    scc_graph.add_edge(S, D);\n  }\n \n  scc_graph.solve();\n \n  auto& K = scc_graph.SCCGraphSize;\n  auto& g = scc_graph.G;\n  auto& comp = scc_graph.comp;\n \n  tree.resize(K);\n  int deg[1010] = {};\n \n  rep(i, N) {\n    for(auto e: g[i]) {\n      if(comp[i] == comp[e]) continue;\n      tree[comp[e]].push_back(comp[i]);\n      deg[comp[i]] ++;\n    }\n  }\n \n  rep(i, K) {\n    sort(tree[i].begin(), tree[i].end());\n    tree[i].erase(unique(tree[i].begin(), tree[i].end()), tree[i].end());\n  }\n \n  ll ans = 1;\n  vector<bool> vis(K);\n  rep(i, K) if(deg[i] == 0 && !vis[i]) {\n    vis[i] = 1;\n    ans *= solve(i, -1, vis);\n    ans %= MOD;\n  }\n \n  cout << ans << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Package: StandardCodeLibrary.Core\n * */\n//蠑戊ソ帛クク逕ィ逧?、エ譁?サカ蟷カ菴ソ逕ィstd蜷榊ュ礼ゥコ髣エ\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <utility>\n#include <vector>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <climits>\nusing namespace std;\n\n////蟶ク逕ィ謨ー謐ョ邀サ蝙?//typedef long long int lli;\n//typedef vector<int> vi;\n//typedef vector<vi> vvi;\n//typedef pair<lli,lli> pll;\n//typedef queue<int> qi;\ntypedef long T;\n\nint MOD=1000000007;\n\n//蟶ク逕ィ蜃ス謨ー:譛?、ァ譛?ー丞?譖エ譁ー;謨ー蟄ヲ逶ク蜈ウ蜃ス謨ー;霎灘?蜥瑚セ灘?;譬醍憾謨ー扈?蟷カ譟・髮?蜿ッ蜷亥ケカ蝣?\ntemplate<typename type>inline bool cmax(type& a,const type& b){return a<b?a=b,true:false;}\ntemplate<typename type>inline bool cmin(type& a,const type& b){return b<a?a=b,true:false;}\n\nconst int MAXV=1000;\nconst int MAXE=1000000;\ntypedef struct struct_edge* edge;\nstruct struct_edge{int v;edge n;}pool[MAXE];\nedge top;\nint V;\nedge adj[MAXV];\nvoid build_graph(int v)\n{\n\ttop=pool,memset(adj,0,sizeof adj);\n\tV=v;//轤ケ謨ー\n\t//add_edge(u,v);\n}\nvoid add_edge(int u,int v)\n{\n\ttop->v=v,top->n=adj[u],adj[u]=top++;\n}\nint ord;\nint dfn[MAXV];\nint low[MAXV];\nint stks;\nint stk[MAXV];\nbool ins[MAXV];\nint cnt;\nint bl[MAXV];\nvoid dfs(int u)\n{\n\tdfn[u]=low[u]=++ord;\n\tins[stk[stks++]=u]=true;\n\tfor (edge i=adj[u];i;i=i->n)\n\t\tif (!dfn[i->v]) dfs(i->v),cmin(low[u],low[i->v]);\n\t\telse if (ins[i->v]) cmin(low[u],dfn[i->v]);\n\tif (dfn[u]==low[u])\n\t{\n\t\tint v;\n\t\tdo ins[v=stk[--stks]]=false,bl[v]=cnt;\n\t\twhile(v!=u);\n\t\tcnt++;\n\t}\n}\nvoid tarjan()\n{\n\tord=0,memset(dfn,0,sizeof dfn),cnt=0;\n\tfor(int i=0;i<V;i++) if (!dfn[i]) dfs(i);\n}\n\nint main()\n{\n\tint n,m;\n\tcin>>n>>m;\n\tbuild_graph(n);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint s,d;\n\t\tcin>>s>>d,--s,--d;\n\t\tadd_edge(s,d);\n\t}\n\ttarjan();\n\tvector<vector<int> > adj(cnt);\n\tvector<vector<int> > radj(cnt);\n\tfor(int i=0;i<V;i++) for (edge e=::adj[i];e;e=e->n) if (bl[i]!=bl[e->v]) adj[bl[i]].push_back(bl[e->v]);\n\tfor(int i=0;i<cnt;i++) sort(adj[i].begin(),adj[i].end()),unique(adj[i].begin(),adj[i].end());\n\tvector<int> id(cnt);\n\tfor(int i=0;i<cnt;i++) for (int j=0;j<adj[i].size();j++) id[adj[i][j]]++;\n\tqueue<int> q;\n\tvector<pair<long long int,long long int> > f(n);\n\tfor(int i=0;i<cnt;i++) if (id[i]==0) q.push(i),f[i]=make_pair(1,1);\n\tlong long int ans=1;\n\twhile(q.size())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tif (!adj[u].size()) ans=(ans*(f[u].first+f[u].second))%MOD;\n\t\tfor(int i=0;i<adj[u].size();i++)\n\t\t{\n\t\t\tint v=adj[u][i];\n\t\t\tradj[v].push_back(u);\n\t\t\tif ((--id[v])==0)\n\t\t\t{\n\t\t\t\tq.push(v);\n\t\t\t\tf[v]=make_pair(1,1);\n\t\t\t\tfor (int j=0;j<radj[v].size();j++)\n\t\t\t\t{\n\t\t\t\t\tint w=radj[v][j];\n\t\t\t\t\tf[v].first*=f[w].first+f[w].second;\n\t\t\t\t\tf[v].second*=f[w].second;\n\t\t\t\t\tf[v].first%=MOD;\n\t\t\t\t\tf[v].second%=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\n\nint N, M;\nvector< int > cg[1000], rg[1000], g[1000];\nbool v[1000];\nvector< int > order;\nint cmp[1000];\nbool connect[1000][1000];\nbool in[1000];\n\nvoid dfs(int idx)\n{\n  for(int to : cg[idx]) if(!v[to]++) dfs(to);\n  order.push_back(idx);\n}\nvoid rdfs(int idx, int k)\n{\n  cmp[idx] = k;\n  for(int to : rg[idx]) if(cmp[to] == -1) rdfs(to, k);\n}\nint scc()\n{\n  int k = 0;\n  for(int i = 0; i < N; i++) if(!v[i]) dfs(i);\n  memset(cmp, -1, sizeof(cmp));\n  reverse(order.begin(), order.end());\n  for(int i : order) if(cmp[i] == -1) rdfs(i, k++);\n  return(k);\n}\n\nlong long rec(int idx)\n{\n  long long ret = 1;\n  for(int to : g[idx]) (ret *= rec(to)) %= mod;\n  return((ret + 1) % mod);\n}\n\nint main()\n{\n  cin >> N >> M;\n  \n  while(M--) {\n    int A, B;\n    cin >> A >> B;\n    --A, --B;\n    cg[B].push_back(A);\n    rg[A].push_back(B);\n  }\n  int c = scc();\n  for(int i = 0; i < N; i++) {\n    for(int to : cg[i]) {\n      if(cmp[i] == cmp[to]) continue;\n      if(connect[cmp[i]][cmp[to]]++) continue;\n      g[cmp[i]].push_back(cmp[to]);\n      in[cmp[to]] = true;\n    }\n  }\n  long long ret = 1;\n  for(int i = 0; i < c; i++) {\n    if(!in[i]) (ret *= rec(i)) %= mod;\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long mo = 1e9+7;\n\n/***********************/\n// ??±?????¨???\n/***********************/\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntypedef long long Weight;\nconst Weight INF = 1e18;\n\nstruct Edge {\n    ll src, dst;\n    Weight weight;\n    Edge(ll src, ll dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid addDirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); }\nvoid addUndirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); g[dst].push_back(Edge(dst, src, weight)); }\nvoid addDirected(Graph& g, ll src, ll dst) { addDirected(g, src, dst, 1); }\nvoid addUndirected(Graph& g, ll src, ll dst) { addUndirected(g, src, dst, 1); }\nvoid printGraph(Graph& g) {\n    rep(i, g.size()) {\n        if (!g[i].size())\n            continue;\n        rep(j, g[i].size()) \n            cout << \"(\" << i << \", \" << g[i][j].dst << \"), \";\n        cout << endl;\n    }\n}\n\n// ?????£???????§£\n// O(V+E)\n// const Graph& g               ????????°??????\n// vector< vector<ll> >& scc   ??°??????????????£?????????\nvoid visitStronglyConnectedComponents(const Graph &g, ll v, vector< vector<ll> >& scc,\n        stack<ll> &S, vector<bool> &inS,\n        vector<ll> &low, vector<ll> &num, ll& time) {\n    low[v] = num[v] = ++time;\n    S.push(v); inS[v] = true;\n    FOR(e, g[v]) {\n        ll w = e->dst;\n        if (num[w] == 0) {\n            visitStronglyConnectedComponents(g, w, scc, S, inS, low, num, time);\n            low[v] = min(low[v], low[w]);\n        } else if (inS[w])\n            low[v] = min(low[v], num[w]);\n    }\n    if (low[v] == num[v]) {\n        scc.push_back(vector<ll>());\n        while (1) {\n            ll w = S.top(); S.pop(); inS[w] = false;\n            scc.back().push_back(w);\n            if (v == w) break;\n        }\n    }\n}\nvoid stronglyConnectedComponents(const Graph& g, vector< vector<ll> >& scc) {\n    const ll n = g.size();\n    vector<ll> num(n), low(n);\n    stack<ll> S;\n    vector<bool> inS(n);\n    ll time = 0;\n    rep(u, n) if (num[u] == 0)\n        visitStronglyConnectedComponents(g, u, scc, S, inS, low, num, time);\n}\n\n// ???????????????????????????\n// ????????????????????? u ??§?????£??????u[i] ?????? u[j] ??????????????? => i < j ?????????????????????????????????\n//\n// const Graph &g\n// ??°?????????\n// vector<int> &order\n// ???????????????????????????????????????????????¨??§??£??\\???????????????????????????????????? true ?????¨???????????????\n// ?????????\n// ????????????????????????????????????????????????\n//\n// O(V+E)\nbool visitT(const Graph &g, ll v, vector<ll> &order, vector<ll> &color) {\n    color[v] = 1;\n    FOR(e, g[v]) {\n        if (color[e->dst] == 2) continue;\n        if (color[e->dst] == 1) return false;\n        if (!visitT(g, e->dst, order, color)) return false;\n    }\n    order.push_back(v); color[v] = 2;\n    return true;\n}\nbool topologicalSort(const Graph &g, vector<ll> &order) {\n    ll n = g.size();\n    vector<ll> color(n);\n    rep(u, n) if (!color[u] && !visitT(g, u, order, color))\n        return false;\n    reverse(all(order));\n    return true;\n}\n\n// ???????????°???????????????\nvoid reverseGraph(Graph& g_dst, Graph& g_src) { /*g_dst??????graph?????????*/\n    g_dst = Graph(g_src.size());\n    rep(i, g_src.size()) {\n        rep(j, g_src[i].size()) {\n            addDirected(g_dst, g_src[i][j].dst, g_src[i][j].src, g_src[i][j].weight);\n        }\n    }\n}\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, m; cin >> n >> m;\n    Graph g = Graph(n);\n    rep(i, m) {\n        ll u, v; cin >> u >> v; u--, v--;\n        addDirected(g, u, v);\n    }\n\n    // ??????????????°?????????????????????\n    vector<vector<ll>> scc;\n    stronglyConnectedComponents(g, scc);\n    /*\n    rep(i, scc.size()) {\n        rep(j, scc[i].size()) cout << scc[i][j] << \" \";\n        cout << endl;\n    }\n    */\n\n    // ?????????????????????SCC????±????????????????\n    vector<ll> scc_inv(g.size());\n    rep(i, scc.size()) rep(j, scc[i].size()) scc_inv[scc[i][j]] = i;\n//    cout << scc_inv << endl;\n\n    // ??°??????DAG?????°????????????\n    // ??°??????dag?????????i??????????????????(vector<ll> scc[i])???????????¨???????????????\n    Graph dag(scc.size());\n    rep(from, g.size()) rep(to, g[from].size()) if (scc_inv[from] != scc_inv[g[from][to].dst]) {\n        addDirected(dag, scc_inv[from], scc_inv[g[from][to].dst]);\n    }\n    /*\n    printGraph(dag);\n    */\n\n    vector<ll> order;\n    bool success = topologicalSort(dag, order);\n    /*\n    if (success) \n        cout << order << endl;\n    else \n        cout << \"NOT DAG\" << endl; // ??¶???DAG??????????????????\n    */\n    reverse(all(order));\n\n    Graph dag_rev;\n    reverseGraph(dag_rev, dag);\n    /*\n    printGraph(dag);\n    printGraph(dag_rev);\n    */\n\n    vll dp(n, -1);\n    function<ll(ll)> f = [&](ll i){\n        if (dp[i] != -1)\n            return dp[i];\n        dp[i] = 1;\n        rep(j, dag_rev[i].size()) {\n            (dp[i] *= f(dag_rev[i][j].dst) + 1) %= mo;\n        }\n        return dp[i];\n    };\n\n    ll ret = 1;\n    rep(i, n) {\n        if (dp[order[i]] != -1) \n            continue;\n        ret *= f(order[i]) + 1;\n    }\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<cassert>\n#include<climits>\n \n#define MOD (1000000007)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 2000\n \nusing namespace std;\n \ntypedef long long ull;\ntypedef pair<int,int> ii;\n \nstruct Data{\n  int  to,cost;\n  Data(int to=IINF,int cost=IINF):to(to),cost(cost){}\n};\n \n// Library - topological sort - begin \ntemplate<typename T>\nbool visit(const T& G,int v,vector<int>& order,vector<int>& color)\n{\n  color[v] = 1;\n  for(__typeof((G[v]).begin()) e = G[v].begin();e != G[v].end();e++)\n    {\n      if(color[e->to] == 2)continue;//このvisit以外のvisitで訪れた\n      if(color[e->to] == 1)return false;//このvisitで訪れた\n      if(!visit(G,e->to,order,color))return false;\n    }\n  order.push_back(v);\n  color[v] = 2;\n  return true;\n}\n \ntemplate<typename T>\nbool topologicalSort(const T& G,vector<int>& order)\n{\n  int SizeG = G.size();\n  vector<int> color(SizeG); \n  for(int u=0;u<SizeG;u++)\n    if(!color[u] && !visit(G,u,order,color))\n      return false;\n  reverse(order.begin(),order.end());\n  return true;\n}\n// Library - topological sort - end\n \nint V,E,S,D;\nvector<vector<Data> > tmp_G,tmp_rG;\nvector<int>  G[MAX];\nvector<int> rG[MAX];\nvector<int> vs;\nbool used[MAX];\nint cmp[MAX];\null dp[MAX];\n \ninline void add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n \nvoid dfs(int v){\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n \nvoid rdfs(int v,int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n \nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k = 0;\n  for(int i = vs.size()-1; i >= 0 ; i-- )if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n \nint main(){\n \n  cin >> V >> E;\n  rep(i,E){\n    cin >> S >> D;\n    assert(1 <= S && S <= V);\n    assert(1 <= D && D <= V);\n    add_edge(S-1,D-1);\n  }\n  int nV = scc();\n  rep(i,nV)dp[i] = -1;\n \n  set<int> OUT_counter[nV];\n  rep(i,V)rep(j,G[i].size()){\n    if(cmp[i] == cmp[G[i][j]])continue;\n    OUT_counter[cmp[i]].insert(cmp[G[i][j]]);\n  }\n \n  tmp_G.clear(),tmp_rG.clear();\n  tmp_G.resize(nV),tmp_rG.resize(nV);\n  rep(i,nV)for(int j : OUT_counter[i]){\n    tmp_G[i].push_back(j);\n    tmp_rG[j].push_back(i);\n  }\n \n  vector<int> order;\n  topologicalSort(tmp_G,order);\n \n  rep(i,nV)if(tmp_rG[order[i]].empty())dp[order[i]] = 2ULL;\n \n  ull ans = 1;\n  rep(i,nV){\n    int cur = order[i];\n    ull cost = 1;\n    rep(j,tmp_rG[cur].size()) cost = ( cost * dp[tmp_rG[cur][j].to] ) % MOD;\n    if(!tmp_rG[cur].empty())  dp[cur] = ( cost + 1ULL ) % MOD;\n    if(tmp_G[cur].empty())    ans = ( ans * dp[cur] ) % MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "class in{struct It{int it;const bool rev;explicit constexpr It(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(It& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const It i,n;public:explicit constexpr in(int n):i(0),n(n<0?0:n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const It& begin(){return i;}const It& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint Scc(const vector<vector<int>>& adj, vector<int>& color) {\n    const int n = adj.size();\n    vector<int> num(n, 0), low(n, 0), sta;\n    color.assign(n, 0);\n    deque<bool> inS(n, 0);\n    int t = 0, colnum = 0;\n    function<void(int)> visit = [&](int cur) {\n        low[cur] = num[cur] = ++t;\n        sta.emplace_back(cur); inS[cur] = 1;\n        for(int nxt : adj[cur]) {\n            if(num[nxt] == 0) {\n                visit(nxt);\n                low[cur] = min(low[cur], low[nxt]);\n            } else if(inS[nxt])\n              low[cur] = min(low[cur], num[nxt]);\n        }\n        if(low[cur] == num[cur]) {\n            while(true) {\n                int nxt = sta.back(); sta.pop_back(); inS[nxt] = false;\n                color[nxt] = colnum;\n                if(cur == nxt) break;\n            }\n            ++colnum;\n        }\n    };\n    for(int v : in(n))\n      if(num[v] == 0)\n        visit(v);\n    return colnum;\n}\n\nusing i64 = long long;\nconst i64 MOD = 1e9 + 7;\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> __adj(n);\n    for(int _ : in(m)) {\n        int u, v;\n        cin >> u >> v;\n        --u; --v;\n        __adj[u].emplace_back(v);\n    }\n    vector<int> color;\n    int col = Scc(__adj, color);\n    vector<vector<int>> radj(col);\n    vector<int> deg(col, 0);\n    vector<bitset<1000>> used(col, bitset<1000>(0));\n    for(int v : in(n))\n      for(int u : __adj[v])\n        if(color[v] != color[u] && used[color[u]][color[v]] == 0)\n          radj[color[u]].emplace_back(color[v]), ++deg[color[v]], used[color[u]][color[v]] = 1;\n    vector<i64> dp(col, -1LL);\n    i64 ans = 1LL;\n    function<i64(int)> dfs = [&](int v) {\n        assert(v != -1);\n        i64& res = dp[v];\n        if(res != -1LL) return res;\n        res = 1LL;\n        for(int u : radj[v])\n          res = res * dfs(u) % MOD;\n        return ++res;\n    };\n    for(int v : in(col)) {\n        if(dp[v] != -1LL || deg[v] != 0) continue;\n        ans = ans * dfs(v) % MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint V,E;\n\nstruct GROUP{\n\tvector<int> nodes;\n};\n\nGROUP group[1000];\nvector<int> G[1000];\nvector<int> reverse_G[1000];\nstack<int> S;\n\nbool check[1000];\nint table[1000];\n\nint group_index = -1;\n\nvoid dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(!check[G[node_id][i]])dfs(G[node_id][i]);\n\t}\n\tS.push(node_id);\n}\n\nvoid reverse_dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tgroup[group_index].nodes.push_back(node_id);\n\ttable[node_id] = group_index;\n\n\tfor(int i = 0; i < reverse_G[node_id].size(); i++){\n\t\tif(!check[reverse_G[node_id][i]])reverse_dfs(reverse_G[node_id][i]);\n\t}\n}\n\n\nint main(){\n\n\tscanf(\"%d %d\",&V,&E);\n\n\tfor(int i = 0; i < V;i++)check[i] = false;\n\n\tint from,to;\n\n\tfor(int loop = 0; loop < E; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tG[from].push_back(to);\n\t\treverse_G[to].push_back(from);\n\t}\n\n\tfor(int i = 0; i < V;i++){\n\t\tif(!check[i])dfs(i);\n\t}\n\n\tfor(int i = 0; i < V;i++)check[i] = false;\n\n\twhile(!S.empty()){\n\t\tif(!check[S.top()]){\n\t\t\tgroup_index++;\n\n\t\t\treverse_dfs(S.top());\n\t\t}\n\t\tS.pop();\n\t}\n\n\tll dp[group_index+1];\n\tfor(int i = 0; i <= group_index; i++)dp[i] = 1;\n\n\tll ans = 1;\n\tint count,next_group;\n\tbool visited[group_index+1];\n\n\tfor(int loop = 0; loop <= group_index; loop++){\n\n\t\tfor(int i = 0; i <= group_index; i++)visited[i] = false;\n\n\t\tvisited[loop] = true;\n\t\tcount = 0;\n\n\t\tfor(int i = 0; i < group[loop].nodes.size(); i++){\n\t\t\tfor(int k = 0; k < G[group[loop].nodes[i]].size(); k++){\n\t\t\t\tnext_group = table[G[group[loop].nodes[i]][k]];\n\n\t\t\t\tif(visited[next_group] == false){\n\t\t\t\t\tvisited[next_group] = true;\n\t\t\t\t\tcount++;\n\t\t\t\t\tdp[next_group] = dp[next_group]*(dp[loop]+1)%MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(count == 0){\n\t\t\tans = ans*(dp[loop]+1)%MOD;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans%MOD);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nstruct E {\n  int src, dst;  \n  E(int s, int d) : src(s), dst(d) {}\n};\ntypedef vector<E> Es;\ntypedef vector<Es> G;\n\nconst int N = 1000 + 1;\nint label[N];\n\nint rec(int src, const G &g, int depth)\n{\n  //cout << src << ' ' << depth << endl;\n  label[src] = depth;\n  for (int i = 0; i < g[src].size(); ++i) {\n    int dst = g[src][i].dst;\n    if (label[dst]) return label[dst];\n    int tmp = rec(dst, g, depth + 1);\n    if (tmp) return tmp;\n  }\n  label[src] = 0;\n  return 0;\n}\n\nint main(void)\n{\n  int node, edge;\n  while (cin >> node >> edge) {\n    //cout << string(20, '=') << endl;\n    G g(node);\n\n    int outd[node];\n    int ind[node];\n    fill(ind, ind + node, 0);\n    fill(outd, outd + node, 0);\n    for (int i = 0; i < edge; ++i) {\n      int src, dst;\n      cin >> src >> dst;\n      --src;\n      --dst;\n      ++ind[dst];\n      ++outd[src];\n      g[src].push_back(E(src, dst));\n    }\n    \n    fill(label, label + N, 0); \n    int l;\n    for (int i = 0; i < node; ++i) {\n      l = rec(i, g, 1);\n      if (l) break;\n    }   \n    if (l == 0) l = 1 << 29;\n\n    int cycle = 0;\n    int rest = 0;\n    int iso = 0;\n    for (int i = 0; i < node; ++i) {\n      if (l <= label[i]) ++cycle;\n      if (ind[i] == 0 && outd[i]) ++rest;      \n      if (ind[i] == 0 && outd[i] == 0) ++iso;\n    }\n    \n    \n//     for (int i = 0; i < node; ++i) {\n//       cout << label[i] << ' ';\n//     }\n//     cout << endl;\n\n\n    const int mod = 1000000007;\n    int res = rest + cycle + 1;\n    for (int i = 0; i < iso; ++i) {\n      res *= 2;\n      res %= mod;\n    }\n    cout << res << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\n#define int long long\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nclass SCC{//cmp(0 - kk-1) is scc's return. Same number is group. The number is no relatoin.\npublic:\n  int n;\n  vvi G,rG,tG;\n  vector<bool>used;\n  vi vs,cmp;\n  SCC(int size){\n    n=size;\n    G=rG=vvi(n);\n    used=vector<bool>(n);\n    cmp=vi(n);\n    vs=vi(0);\n  }\n  void add_edge(int s,int t){\n    G[s].pb(t);\n    rG[t].pb(s);\n  }\n  void rdfs(int v,int k){\n    used[v]=true;\n    cmp[v]=k;\n    rep(i,rG[v].size())if(!used[rG[v][i]])rdfs(rG[v][i],k);\n  }\n  void dfs(int v){\n    used[v]=true;\n    rep(i,G[v].size())if(!used[G[v][i]])dfs(G[v][i]);\n    vs.pb(v);\n  }\n  int scc(){\n    rep(i,n)used[i]=false;\n    rep(v,n)if(!used[v])dfs(v);\n    rep(i,n)used[i]=false;\n    int kk=0;\n    for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],kk++);\n    return kk;\n  }\n  vvi make(){\n    int N=scc();\n    tG=vvi(N);\n    rep(i,n)rep(j,G[i].size())if(cmp[i]!=cmp[G[i][j]]){\n      tG[cmp[i]].pb(cmp[G[i][j]]);\n      //\ttG[cmp[G[i][j]]].pb(cmp[i]);\n    }\n    return tG;\n  }\n};\nclass TOPO{//out is tsort's return.\npublic:\n  vvi G;\n  vi out;\n  vector<bool>V;\n  vi indeg;\n  int n;\n  TOPO(int size){\n    n=size;\n    G=vvi(n);\n    out=vi(0);\n    V=vector<bool>(n);\n    indeg=vi(n);\n  }\n  void add_edge(int s,int t){\n    G[s].pb(t);\n  }\n  void bfs(int s){\n    queue<int>q;\n    q.push(s);\n    V[s]=true;\n    while(!q.empty()){\n      int u=q.front();q.pop();\n      out.pb(u);\n      rep(i,G[u].size()){\n\tint v=G[u][i];\n\tindeg[v]--;\n\tif(indeg[v]==0&&!V[v]){\n\t  V[v]=true;\n\t  q.push(v);\n\t}\n      }\n    }\n  }\n  vi tsort(){\n    rep(i,n)indeg[i]=0;\n    rep(i,n)rep(j,G[i].size()){\n      int v=G[i][j];\n      indeg[v]++;\n    }\n    rep(i,n)if(indeg[i]==0&&!V[i])bfs(i);\n    //\trep(i,n)cout<<out[i]<<endl;\n    return out;\n  }\n};\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  SCC scc(n);\n  rep(i,m){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    scc.add_edge(a,b);\n  }\n  vvi G=scc.make();\n  n=G.size();\n  vvi rG(n);\n  TOPO tp(n);\n  rep(i,n)rep(j,G[i].size()){\n    tp.add_edge(i,G[i][j]);\n    rG[G[i][j]].pb(i);\n  }\n  vi out=tp.tsort();\n  vp dp(n,{1,1});\n  ll MOD=1000000007;\n  rep(i,n){\n    int to=out[i];\n    rep(j,rG[out[i]].size()){\n      int from=rG[out[i]][j];\n      //      cout<<from<<\" \"<<to<<endl;\n      (dp[to].first*=(ll)(dp[from].first+dp[from].second)%MOD)%=MOD;\n      (dp[to].second*=(ll)dp[from].second)%=MOD;\n    }\n    //    cout<<dp[to].first<<\" \"<<dp[to].second<<\" \"<<\"!\"<<endl;\n    //    if(rG[to].size()!=0)(dp[to].first+=MOD-dp[to].second)%=MOD;\n  }\n  ll sum=1;\n  rep(i,n)if(G[i].size()==0){\n    //    cout<<dp[i].first<<\" \"<<dp[i].second<<endl;\n    (sum*=(dp[i].first+dp[i].second)%MOD)%=MOD;\n  }\n  cout<<sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define int long long\nint mod=1e9+7;\n\n//scc\nconst int MAX_V=1e5+1;\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    if(!used[G[v][i]])dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++){\n    if(!used[rG[v][i]])rdfs(rG[v][i],k);\n  }\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++){\n    if(!used[v])dfs(v);\n  }\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!used[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nsigned main(){\n  int n;\n  cin>>V>>n;\n  vector<int> s(n),d(n);\n  for(int i=0;i<n;i++){\n    cin>>s[i]>>d[i];\n    s[i]--;\n    d[i]--;\n    add_edge(s[i],d[i]);\n  }\n\n  int sz=scc();\n\n  vector<vector<int> > dag(sz),rdag(sz);\n  for(int i=0;i<n;i++){\n    if(cmp[s[i]]!=cmp[d[i]]){\n      dag[cmp[s[i]]].push_back(cmp[d[i]]);\n      rdag[cmp[d[i]]].push_back(cmp[s[i]]);\n    }\n  }\n\n  int ans=1;\n  vector<vector<int> > dp(sz,vector<int>(2,1));\n  for(int i=0;i<sz;i++){\n    for(int j=0;j<rdag[i].size();j++){\n      (dp[i][0]*=dp[rdag[i][j]][0])%=mod;\n      (dp[i][1]*=dp[rdag[i][j]][0]+dp[rdag[i][j]][1])%=mod;\n    }\n    if(dag[i].size()==0)(ans*=dp[i][0]+dp[i][1])%=mod;\n  }\n  cout<<ans%mod<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\n#define CIN_ONLY if(1)\nstruct cww{cww(){\n    CIN_ONLY{\n        ios::sync_with_stdio(false);cin.tie(0);\n    }\n}}star;\n#define fin \"\\n\"\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define DEBUG if(0)\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l,T r)\n{bool a=l>r;if(a)l=r;return a;}\ntemplate <typename T>inline bool chmax(T &l,T r)\n{bool a=l<r;if(a)l=r;return a;}\ntemplate <typename T>\nistream& operator>>(istream &is,vector<T> &v){\n    for(auto &it:v)is>>it;\n    return is;\n}\ntypedef vector<int> V;\ntypedef vector<V> VV;\n//The number of outdegree of vertex in graph \"in\" is 1\nstruct sunny_graph{\n    int size;\n    VV g,in;\n    V S,R;\n    int getloop(int v){\n        return S[v];\n    }\n    int getroot(int v){\n        return R[v];\n    }\n    int dfs(int v,V& out,int id,V &loop){\n        S[v]=-2;\n        int u=out[v];\n        if(S[u]>=0){\n            S[v]=size;\n            return -1;\n        }\n        if(S[u]==-2||(u=dfs(u,out,id,loop))>=0){\n            S[v]=id;\n            R[v]=v;\n            loop.pb(v);\n            if(v==u)return -1;\n            else return u;\n        }\n        S[v]=size;\n        return -1;\n    }\n    void dfs2(int v){\n        for(auto &u:in[v]){\n            S[u]=S[v];\n            R[u]=R[v];\n            dfs2(u);\n        }            \n    }\n    sunny_graph(V out){\n        size=out.size();\n        in.resize(size);\n        S.resize(size,-1);\n        R.resize(size);\n        int id=0;\n        REP(v,size){\n            V L;\n            if(S[v]==-1)dfs(v,out,id,L);\n            if(L.size()){\n                g.pb(L);\n                id++;\n            }\n        }\n        REP(v,size)if(S[v]==size)in[out[v]].pb(v);\n        for(auto &s:g)for(auto &v:s)dfs2(v);\n    }\n};\nconst int mod=1e9+7;\nLL f(int v,VV &g){\n    LL res=1;\n    for(auto &u:g[v]){\n        res*=f(u,g);\n        res%=mod;\n    }\n    return (res+1)%mod;\n\n}\nint N,M;\nint main(){\n    cin>>N>>M;\n    V a(N);\n    REP(i,N)a[i]=i;\n    REP(i,M){\n        int x,y;\n        cin>>x>>y;\n        a[x-1]=y-1;\n    }\n    sunny_graph sg(a);\n    LL ans=1;\n    for(auto &it:sg.g){\n        LL res=1;\n        for(auto &v:it)for(auto &u:sg.in[v])res*=f(u,sg.in);\n        ans*=(res+1)%mod;\n        ans%=mod;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n\nusing namespace std;\n\nconst int N=106, E=1006;\n\nstruct ARC {\n    int s, t, val, next;\n    void init(int a, int b, int c, int d) {\n        s=a, t=b, val=c, next=d;\n    }\n} arc[E];\nint head[N];\n\nbool vs[N], use[N][N];\nint G[N][N], n, m, pre[N];\n\nqueue <int> Q;\n\nvoid Floyd() {\n    memset(pre, -1, sizeof pre);\n    for(int i=1; i<n; i++) pre[i]=0;\n    for(int k=0; k<n; k++)\n        for(int i=0; i<n; i++)\n            for(int j=0; j<n; j++) {\n                if(G[i][k]==-1 || G[k][j]==-1) continue;\n                if(G[i][j]==-1) G[i][j]=G[i][k]+G[k][j], pre[j]=k;\n                else if(G[i][j]>G[i][k]+G[k][j]) G[i][j]=G[i][k]+G[k][j], pre[j]=k;\n            }\n}\n\nint DFS(int u, int &sum) {\n    for(int e=head[u]; e!=-1; e=arc[e].next) {\n        int v=arc[e].t;\n        if(use[u][v]) continue;\n        use[u][v]=1;\n        if(!vs[v]) Q.push(v), vs[v]=1;\n        sum+=arc[e].val;\n        return DFS(v, sum);\n    }\n    return u;\n}\n\nint BFS() {\n    int ans=0;\n    while(!Q.empty()) {\n        int u=Q.front();\n        Q.pop();\n\n        printf(\"u=%d\\n\", u);\n\n        for(int e=head[u]; e!=-1; e=arc[e].next) {\n            int v=arc[e].t;\n\n            printf(\"\\tv=%d\\n\", v);\n\n            if(use[u][v]) continue;\n            if(!vs[v]) vs[v]=1, Q.push(v);\n            int sum=0;\n            int last=DFS(v, sum);\n\n            printf(\"arc[%d].val=%d\\n\", e, arc[e].val);\n            printf(\"u=%d v=%d last=%d sum=%d, delta=%d\\n\", u, v, last, sum, (-G[0][last])-(-G[0][v])-(sum+arc[e].val));\n\n            ans+=(-G[0][last])-(-G[0][v])-(sum+arc[e].val);\n        }\n    }\n    return ans;\n}\n\nint main() {\n    freopen(\"/home/lovezzt/桌面/in.txt\", \"r\", stdin);\n    while(scanf(\"%d%d\", &n, &m)!=EOF) {\n        memset(G, -1, sizeof G);\n        memset(head, -1, sizeof head);\n        for(int i=0, a, b, c; i<m; i++) {\n            scanf(\"%d%d%d\", &a, &b, &c);\n            arc[i].init(a, b, c, head[a]);\n            head[a]=i;\n            G[a][b]=-c;\n        }\n        Floyd();\n        while(!Q.empty()) Q.pop();\n        memset(use, 0, sizeof use);\n        for(int u=n-1; u!=-1; u=pre[u]) {\n            vs[u]=1;\n\n            printf(\"%d\\n\", u);\n\n            Q.push(u);\n            if(pre[u]!=-1) use[pre[u]][u]=1;\n        }\n        int ans=BFS();\n        printf(\"ans=%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Package: StandardCodeLibrary.Core\n * */\n//蠑戊ソ帛クク逕ィ逧?、エ譁?サカ蟷カ菴ソ逕ィstd蜷榊ュ礼ゥコ髣エ\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <utility>\n#include <vector>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <climits>\nusing namespace std;\n\n//逕ィ莠主?蟆台サ」遐??逧?ョ?#define lp for(;;)\n#define repf(i,a,b) for (int i=(a);i<(b);++i)\n#define rrepf(i,a,b) for (int i=(a)-1;i>=(b);--i)\n#define rep(i,n) repf(i,0,n)\n#define rrep(i,n) rrepf(i,n,0)\n#define ft(i,a,b) for (int i=(a);i<=(b);++i)\n#define fdt(i,a,b) for (int i=(a);i>=(b);--i)\n#define for_nonempty_subsets(subset,set) for (int subset=set;subset;subset=(subset-1)&(set))\n#define for_in_charset(i,charset) for (cstr i=(charset);*i;i++)\n#define whl while\n#define rtn return\n#define fl(x,y) memset((x),char(y),sizeof(x))\n#define clr(x) fl(x,char(0))\n#define cpy(x,y) memcpy(x,y,sizeof(x))\n#define sf scanf\n#define pf printf\n#define vec vector\n#define pr pair\n#define que queue\n#define prq priority_queue\n#define itr iterator\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define ins insert\n#define ers erase\n#define lb lower_bound\n#define ub upper_bound\n#define rnk order_of_key\n#define sel find_by_order\n#define sz(x) (int((x).size()))\n#define all(x) (x).begin(),(x).end()\n#define srt(x) sort(all(x))\n#define uniq(x) srt(x),(x).erase(unique(all(x)),(x).end())\n#define rev(x) reverse(all(x))\n#define shf(x) random_shuffle(all(x))\n#define nxtp(x) next_permutation(all(x))\n\n//隹?ッ慕嶌蜈ウ逧?ョ?#ifndef DEBUG\n#define prt(x) (cerr)\n#define asrtWA(s) do if(!(s))exit(0);whl(0)\n#define asrtTLE(s) do if(!(s))whl(1);whl(0)\n#define asrtMLE(s) do if(!(s))whl(new int);whl(0)\n#define asrtOLE(s) do if(!(s))whl(1)puts(\"OLE\");whl(0)\n#define asrtRE(s) do if(!(s))*(int*)0=0;whl(0)\n#define runtime() (cerr)\n#define input(in) freopen(in,\"r\",stdin)\n#define output(out) freopen(out,\"w\",stdout)\n#else\n#define prt(x) cerr<<\"隨ャ\"<<__LINE__<<\"陦圭t: \"<<#x\"\\t=\"<<(x)<<endl\n#define asrtWA(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtTLE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtMLE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtOLE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtRE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define runtime() cerr<<\"Used: \"<<db(clock())/CLOCKS_PER_SEC<<\"s\"<<endl\n#define input(in)\n#define output(out)\n#endif\n\n//蟶ク逕ィ謨ー謐ョ邀サ蝙?typedef long long int lli;\ntypedef double db;\ntypedef const char* cstr;\ntypedef string str;\ntypedef vec<int> vi;\ntypedef vec<vi> vvi;\ntypedef vec<bool> vb;\ntypedef vec<vb> vvb;\ntypedef vec<str> vs;\ntypedef pr<int,int> pii;\ntypedef pr<lli,lli> pll;\ntypedef pr<db,db> pdd;\ntypedef map<int,int> mii;\ntypedef map<str,int> msi;\ntypedef map<char,int> mci;\ntypedef set<int> si;\ntypedef set<str> ss;\ntypedef que<int> qi;\ntypedef vec<pii> vpii;\ntypedef vec<pdd> vpdd;\n\n//蟶ク逕ィ蟶ク驥?int逧?怙螟ァ蛟シ;lli逧?怙螟ァ蛟シ;db逧?ッッ蟾ョ逶ク蜈ウ蟶ク謨ー;谺ァ諡牙クク謨ー;蝨?捉邇?遘サ蜉ィ蜷鷹?;蜿匁ィ。菴ソ逕ィ逧?勁謨ー\nint oo=(~0u)>>1;\nlli ooll=(~0ull)>>1;\ndb inf=1e+10;\ndb eps=1e-10;\ndb gam=0.5772156649015328606;\ndb pi=acos(-1.0);\nint dx[]={1,0,-1,0,1,-1,-1,1,0};\nint dy[]={0,1,0,-1,1,1,-1,-1,0};\nint MOD=1000000007;\n\n//蟶ク逕ィ蜃ス謨ー:譛?、ァ譛?ー丞?譖エ譁ー;謨ー蟄ヲ逶ク蜈ウ蜃ス謨ー;霎灘?蜥瑚セ灘?;譬醍憾謨ー扈?蟷カ譟・髮?蜿ッ蜷亥ケカ蝣?\ntemplate<typename type>inline bool cmax(type& a,const type& b){rtn a<b?a=b,true:false;}\ntemplate<typename type>inline bool cmin(type& a,const type& b){rtn b<a?a=b,true:false;}\ntemplate<typename type>inline type sqr(const type& x){rtn x*x;}\ntemplate<typename type>inline type mod(const type& x){rtn x%MOD;}\ninline int sgn(const db& x){rtn (x>+eps)-(x<-eps);}\ninline int dbcmp(const db& a,const db& b){rtn sgn(a-b);}\ntemplate<typename type>inline pr<type,type> operator-(const pr<type,type>& x){rtn mp(-x.x,-x.y);}\ntemplate<typename type>inline pr<type,type> operator+(const pr<type,type>& a,const pr<type,type>& b){rtn mp(a.x+b.x,a.y+b.y);}\ntemplate<typename type>inline pr<type,type> operator-(const pr<type,type>& a,const pr<type,type>& b){rtn mp(a.x-b.x,a.y-b.y);}\ntemplate<typename type>inline pr<type,type> operator*(const pr<type,type>& a,const type& b){rtn mp(a.x*b,a.y*b);}\ntemplate<typename type>inline pr<type,type> operator/(const pr<type,type>& a,const type& b){rtn mp(a.x/b,a.y/b);}\ntemplate<typename type>inline pr<type,type>& operator-=(pr<type,type>& a,const pr<type,type>& b){rtn a=a-b;}\ntemplate<typename type>inline pr<type,type>& operator+=(pr<type,type>& a,const pr<type,type>& b){rtn a=a+b;}\ntemplate<typename type>inline pr<type,type>& operator*=(pr<type,type>& a,const type& b){rtn a=a*b;}\ntemplate<typename type>inline pr<type,type>& operator/=(pr<type,type>& a,const type& b){rtn a=a/b;}\ntemplate<typename type>inline type cross(const pr<type,type>& a,const pr<type,type>& b){rtn a.x*b.y-a.y*b.x;}\ntemplate<typename type>inline type dot(const pr<type,type>& a,const pr<type,type>& b){rtn a.x*b.x+a.y*b.y;}\ntemplate<typename type>inline type gcd(type a,type b){if(b)whl((a%=b)&&(b%=a));rtn a+b;}\ntemplate<typename type>inline type lcm(type a,type b){rtn a*b/gcd(a,b);}\ntemplate<typename istream,typename first_type,typename second_type>inline istream& operator>>(istream& cin,pr<first_type,second_type>& x){rtn cin>>x.x>>x.y;}\ntemplate<typename ostream,typename first_type,typename second_type>inline ostream& operator<<(ostream& cout,const pr<first_type,second_type>& x){rtn cout<<x.x<<\" \"<<x.y;}\ntemplate<typename istream,typename type>inline istream& operator>>(istream& cin,vec<type>& x){rep(i,sz(x))cin>>x[i];rtn cin;}\ntemplate<typename ostream,typename type>inline ostream& operator<<(ostream& cout,const vec<type>& x){rep(i,sz(x))cout<<x[i]<<(i+1==sz(x)?\"\":\" \");rtn cout;}\ninline ostream& pdb(int prcs,db x){rtn cout<<setprecision(prcs)<<fixed<<(sgn(x)?(x):0);}\ntemplate<typename type>inline void bit_inc(vec<type>& st,int x,type inc){whl(x<sz(st))st[x]+=inc,x|=x+1;}\ntemplate<typename type>inline type bit_sum(const vec<type>& st,int x){type s=0;whl(x>=0)s+=st[x],x=(x&(x+1))-1;rtn s;}\ntemplate<typename type>inline type bit_kth(const vec<type>& st,int k){int x=0,y=0,z=0;whl((1<<(++y))<=sz(st));fdt(i,y-1,0){if((x+=1<<i)>sz(st)||z+st[x-1]>k)x-=1<<i;else z+=st[x-1];}rtn x;}\ninline void make_set(vi& st){rep(i,sz(st))st[i]=i;}\ninline int find_set(vi& st,int x){int y=x,z;whl(y!=st[y])y=st[y];whl(x!=st[x])z=st[x],st[x]=y,x=z;rtn y;}\ninline bool union_set(vi& st,int a,int b){a=find_set(st,a),b=find_set(st,b);rtn a!=b?st[a]=b,true:false;}\ntemplate<typename type>inline void merge(type& a,type& b){if(sz(a)<sz(b))swap(a,b);whl(sz(b))a.ins(*b.begin()),b.ers(b.begin());}\n\n//蛻晏ァ句喧\nstruct Initializer\n{\n#ifndef DEBUG\n\tInitializer(){ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);}\n#else\n\t~Initializer(){runtime();}\n#endif\n}initializer;\n\n//髱樊?蜃?#define feach(e,s) for (__typeof__((s).begin()) e=(s).begin();e!=(s).end();++e)\n#include <ext/rope>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\nusing __gnu_cxx::rope;\ntemplate<typename key,typename value>class ext_map:public __gnu_pbds::tree<key,value,less<key>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>{};\n#define ctz __builtin_ctz\n#define clz __builtin_clz\n#define bc __builtin_popcount\n\nconst int MAXV=1000;\nconst int MAXE=1000000;\ntypedef struct struct_edge* edge;\nstruct struct_edge{int v;edge n;}pool[MAXE];\nedge top;\nint V;\nedge adj[MAXV];\nvoid build_graph(int v)\n{\n\ttop=pool,memset(adj,0,sizeof adj);\n\tV=v;//轤ケ謨ー\n\t//add_edge(u,v);\n}\nvoid add_edge(int u,int v)\n{\n\ttop->v=v,top->n=adj[u],adj[u]=top++;\n}\nint ord;\nint dfn[MAXV];\nint low[MAXV];\nint stks;\nint stk[MAXV];\nbool ins[MAXV];\nint cnt;\nint bl[MAXV];\nvoid dfs(int u)\n{\n\tdfn[u]=low[u]=++ord;\n\tins[stk[stks++]=u]=true;\n\tfor (edge i=adj[u];i;i=i->n)\n\t\tif (!dfn[i->v]) dfs(i->v),cmin(low[u],low[i->v]);\n\t\telse if (ins[i->v]) cmin(low[u],dfn[i->v]);\n\tif (dfn[u]==low[u])\n\t{\n\t\tint v;\n\t\tdo ins[v=stk[--stks]]=false,bl[v]=cnt;\n\t\twhile(v!=u);\n\t\tcnt++;\n\t}\n}\nvoid tarjan()\n{\n\tord=0,memset(dfn,0,sizeof dfn),cnt=0;\n\tfor(int i=0;i<V;i++) if (!dfn[i]) dfs(i);\n}\n\nint main()\n{\n\tint n,m;\n\tcin>>n>>m;\n\tbuild_graph(n);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint s,d;\n\t\tcin>>s>>d,--s,--d;\n\t\tadd_edge(s,d);\n\t}\n\ttarjan();\n\tvector<vector<int> > adj(cnt);\n\tvector<vector<int> > radj(cnt);\n\tfor(int i=0;i<V;i++) for (edge e=::adj[i];e;e=e->n) if (bl[i]!=bl[e->v]) adj[bl[i]].push_back(bl[e->v]);\n\tfor(int i=0;i<cnt;i++) sort(adj[i].begin(),adj[i].end()),unique(adj[i].begin(),adj[i].end());\n\tvector<int> id(cnt);\n\tfor(int i=0;i<cnt;i++) for (int j=0;j<adj[i].size();j++) id[adj[i][j]]++;\n\tqueue<int> q;\n\tvector<pair<long long int,long long int> > f(n);\n\tfor(int i=0;i<cnt;i++) if (id[i]==0) q.push(i),f[i]=make_pair(1,1);\n\tlong long int ans=1;\n\twhile(q.size())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tif (!adj[u].size()) ans=(ans*(f[u].first+f[u].second))%MOD;\n\t\tfor(int i=0;i<adj[u].size();i++)\n\t\t{\n\t\t\tint v=adj[u][i];\n\t\t\tradj[v].push_back(u);\n\t\t\tif ((--id[v])==0)\n\t\t\t{\n\t\t\t\tq.push(v);\n\t\t\t\tf[v]=make_pair(1,1);\n\t\t\t\tfor (int j=0;j<radj[v].size();j++)\n\t\t\t\t{\n\t\t\t\t\tint w=radj[v][j];\n\t\t\t\t\tf[v].first*=f[w].first+f[w].second;\n\t\t\t\t\tf[v].second*=f[w].second;\n\t\t\t\t\tf[v].first%=MOD;\n\t\t\t\t\tf[v].second%=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 1145\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst ll MOD = ((1e9) + 7);\n\nint N, cmp[MAX_V];\nbool used[MAX_V];\nvector<int> G[MAX_V], rG[MAX_V], vs;\n\nvoid add_edge(int from, int to)\n{\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid dfs(int v)\n{\n    used[v] = 1;\n    for (int i = 0; i < (int)G[v].size(); i++) {\n\tif (!used[G[v][i]]) {\n            dfs(G[v][i]);\n        }\n    }\n    vs.push_back(v);\n}\n\nvoid rdfs(int v, int k)\n{\n    used[v] = 1;\n    cmp[v] = k;\n    for (int i = 0; i < (int)rG[v].size(); i++) {\n\tif (!used[rG[v][i]]) {\n            rdfs(rG[v][i], k);\n        }\n    }\n}\n\nint scc()\n{\n    memset(used, 0, sizeof(used));\n    vs.clear();\n    for (int v = 0; v < N; v++) {\n\tif (!used[v]) {\n            dfs(v);\n        }\n    }\n    memset(used, 0, sizeof(used));\n    int k = 0;\n    for (int i = vs.size() - 1; i >= 0; i--) {\n\tif (!used[vs[i]]) {\n            rdfs(vs[i], k++);\n        }\n    }\n    return k;\n}\n\nvector<int> nG[MAX_V];\n\nll solve(int v)\n{\n    ll res = 1;\n    for (int i = 0; i < (int)nG[v].size(); i++) {\n        res *= solve(nG[v][i]);\n        res %= MOD;\n    }\n    res += 1;\n    return res % MOD;\n}\n\nint main()\n{\n    int M, a, b;\n    cin >> N >> M;\n    for (int i = 0; i < M; i++) {\n        cin >> a >> b; a--; b--;\n        add_edge(a, b);\n    }\n    \n    auto K = scc();\n    \n    set<pii> st;\n    int deg[MAX_V] = {};\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < (int)G[i].size(); j++) {\n            int from = cmp[i], to = cmp[G[i][j]];\n            if (from != to && st.count(pii(from, to)) == 0) {\n                st.insert(pii(from, to));\n                nG[to].push_back(from);\n                deg[from]++;\n            }\n        }\n    }\n    \n    ll res = 1;    \n    for (int i = 0; i < K; i++) {\n        if (deg[i] == 0) {\n            res *= solve(i);\n            res %= MOD;\n        }\n    }\n\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MOD 1000000007\n\nvector< vector<int> > G(1010);\nvector< vector<int> > rG(1010);\nvector< vector<int> > cG(1010);\nvector<int> post;\nint cmp[1010];\nbool used[1010];\nbool edge[1010][1010];\n\nint N, M;\n\nvoid dfs(int v)\n{\n  used[v] = true;\n  for(int i = 0; i < G[v].size(); i++){\n    if(!used[G[v][i]]) dfs(G[v][i]);\n  }\n  post.push_back(v);\n}\n\nvoid rdfs(int v, int k)\n{\n  used[v] = true;\n  cmp[v] = k;\n  for(int i = 0; i < rG[v].size(); i++){\n    if(!used[rG[v][i]]) rdfs(rG[v][i], k);\n  }\n}\n\nint scc()\n{\n  int k = 0;\n  memset(used, false, sizeof(used));\n  for(int i = 0; i < N; i++){\n    if(!used[i]) dfs(i);\n  }\n  memset(used, false, sizeof(used));\n  reverse(post.begin(), post.end());\n  for(int i = 0; i < post.size(); i++){\n    if(!used[post[i]]) rdfs(post[i], k++);\n  }\n  return k;\n}\n\nlong long solve(int v)\n{\n  long long ret = 1;\n  for(int i = 0; i < cG[v].size(); i++){\n    ret = ret * solve(cG[v][i]) % MOD;\n  }\n  return (ret + 1) % MOD;\n}\n\nint main()\n{\n  cin >> N >> M;\n  G.resize(N);\n  rG.resize(N);\n  for(int i = 0; i < M; i++){\n    int S, D;\n    cin >> S >> D;\n    --S, --D;\n    G[S].push_back(D);\n    rG[D].push_back(S);\n  }\n  int L = scc();\n  cG.resize(L);\n  memset(edge, false, sizeof(edge));\n  for(int i = 0; i < 1010; i++) edge[i][i] = true;\n  for(int i = 0; i < N; i++){\n    for(int j = 0; j < G[i].size(); j++){\n      if(!edge[cmp[i]][cmp[G[i][j]]]){\n\tedge[cmp[i]][cmp[G[i][j]]] = true;\n\tcG[cmp[G[i][j]]].push_back(cmp[i]);\n      }\n    }\n  }\n  long long ans = 1;\n  for(int i = 0; i < L; i++){\n    bool flag = false;\n    for(int j = 0; j < L; j++) if(i != j) flag |= edge[i][j];\n    if(!flag) ans = ans * solve(i) % MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 10000\n#define f first\n#define s second\n#define mp make_pair\n#define mod 1000000007\nusing namespace std;\n\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nbool visited[MAX_V];\nint cmp[MAX_V];\nvector<pair<int,int> > v;\n\nvoid add_edge(int from, int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v] = true;\n  for(int i = 0;i < G[v].size();i++){\n    if(!used[G[v][i]])dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i = 0;i < rG[v].size();i++){\n    if(!used[rG[v][i]]) rdfs(rG[v][i],k);\n  }\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v = 0;v < V;v++){\n    if(!used[v]) dfs(v);\n  }\n  memset(used,0,sizeof(used));\n  int k = 0;\n  for(int i = vs.size() - 1;i >= 0;i--){\n    if(!used[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint rec(int index,int cm){\n  int res=1;\n  int temp = v[index].f;\n  if(v[index].f==cm)return 1;\n  if(rG[v[index].s].size()==0)return 2;\n\n  for(int i=index;v[i].f==temp;i++){\n    int now = v[i].s;\n    for(int j=0;j<rG[now].size();j++){\n      if(!visited[rG[now][j]]){\n        visited[rG[now][j]]=true;\n        res*=rec(rG[now][j],v[i].f);\n        res%=mod;\n      }\n    }\n  }\n  return res+1;\n}\n\nint main()\n{\n  int a,b,m;\n\n  cin>>V>>m;\n\n  for(int i=0;i<m;i++){\n    cin>>a>>b;\n    a--;b--;\n    add_edge(a,b);\n  }\n  int sc=scc();\n\n  for(int i=0;i<V;i++){\n    v.push_back(mp((-1)*cmp[i],i));\n  }\n  sort(v.begin(),v.end());\n\n  int ans=1;\n  for(int i=0;i<v.size();i++){\n    if(!visited[i]){\n      visited[i]=true;\n      ans*=rec(i,mod);\n      ans%=mod;\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 10000\n#define f first\n#define s second\n#define mp make_pair\n#define mod 1000000007\n#define inf 1e8\nusing namespace std;\n\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V]={};\nbool visited[MAX_V]={};\nint cmp[MAX_V];\nvector<pair<int,int> > vpp;\n\nvoid add_edge(int from, int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v] = true;\n  for(int i = 0;i < G[v].size();i++){\n    if(!used[G[v][i]])dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i = 0;i < rG[v].size();i++){\n    if(!used[rG[v][i]]) rdfs(rG[v][i],k);\n  }\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v = 0;v < V;v++){\n    if(!used[v]) dfs(v);\n  }\n  memset(used,0,sizeof(used));\n  int k = 0;\n  for(int i = vs.size() - 1;i >= 0;i--){\n    if(!used[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint rec(int index,int cm){\n  int res=1;\n  int temp = vpp[index].f;\n  if(vpp[index].f==cm)return 1;\n  if(rG[vpp[index].s].size()==0)return 2;\n\n  for(int i=index;vpp[i].f==temp;i++){\n    int now = vpp[i].s;\n    for(int j=0;j<rG[now].size();j++){\n      if(!visited[rG[now][j]]){\n        visited[rG[now][j]]=true;\n        res*=rec(rG[now][j],vpp[i].f);\n        res%=mod;\n      }\n    }\n  }\n  return res+1;\n}\n\nint main()\n{\n  int a,b,m;\n\n  cin>>V>>m;\n\n  for(int i=0;i<m;i++){\n    cin>>a>>b;\n    a--;b--;\n    add_edge(a,b);\n  }\n  int sc=scc();\n\n  for(int i=0;i<V;i++){\n    vpp.push_back(mp((-1)*cmp[i],i));\n  }\n  sort(vpp.begin(),vpp.end());\n\n  int ans=1;\n  for(int i=0;i<vpp.size();i++){\n    if(!visited[i]){\n      visited[i]=true;\n      ans*=rec(i,inf);\n      ans%=mod;\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconstexpr ll MOD = 1000000007;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\nint main()\n{\n    int N, M;\n    cin >> N >> M;\n    vector<int> to(N, -1);\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        to[u] = v;\n    }\n    vector<int> label(N), cycle;\n    iota(label.begin(), label.end(), 0);\n    vector<bool> used(N, false), reached(N, false);\n    auto getcycle = [&](int s) {\n        for (int i = 0; i < 2 * N; i++, s = to[s]) {\n            used[s] = true;\n            if (to[s] == -1) { break; }\n        }\n        if (reached[label[s]]) { return; }\n        reached[label[s]] = true, cycle.push_back(s);\n        if (to[s] == -1) { return; }\n        for (int p = to[s]; p != s; p = to[p]) { label[p] = s; }\n    };\n    for (int i = 0; i < N; i++) {\n        if (not used[i]) { getcycle(i); }\n    }\n    vector<vector<int>> g(N);\n    for (int i = 0; i < N; i++) {\n        if (to[i] == -1 or label[i] == label[to[i]]) { continue; }\n        g[label[to[i]]].push_back(label[i]);\n    }\n    auto dfs = fix([&](auto&& self, const int s) -> ll {\n        ll ans = 1;\n        for (const int to : g[s]) { (ans *= self(self, to)) %= MOD; }\n        return (ans + 1) % MOD;\n    });\n    ll ans = 1;\n    for (const int c : cycle) { (ans *= dfs(c)) %= MOD; }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long mo = 1e9+7;\n\n/***********************/\n// ??±?????¨???\n/***********************/\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntypedef long long Weight;\nconst Weight INF = 1e18;\n\nstruct Edge {\n    ll src, dst;\n    Weight weight;\n    Edge(ll src, ll dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid addDirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); }\nvoid addUndirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); g[dst].push_back(Edge(dst, src, weight)); }\nvoid addDirected(Graph& g, ll src, ll dst) { addDirected(g, src, dst, 1); }\nvoid addUndirected(Graph& g, ll src, ll dst) { addUndirected(g, src, dst, 1); }\nvoid printGraph(Graph& g) {\n    rep(i, g.size()) {\n        if (!g[i].size())\n            continue;\n        rep(j, g[i].size()) \n            cout << \"(\" << i << \", \" << g[i][j].dst << \"), \";\n        cout << endl;\n    }\n}\n\n// ?????£???????§£\n// O(V+E)\n// const Graph& g               ????????°??????\n// vector< vector<ll> >& scc   ??°??????????????£?????????\nvoid visitStronglyConnectedComponents(const Graph &g, ll v, vector< vector<ll> >& scc,\n        stack<ll> &S, vector<bool> &inS,\n        vector<ll> &low, vector<ll> &num, ll& time) {\n    low[v] = num[v] = ++time;\n    S.push(v); inS[v] = true;\n    FOR(e, g[v]) {\n        ll w = e->dst;\n        if (num[w] == 0) {\n            visitStronglyConnectedComponents(g, w, scc, S, inS, low, num, time);\n            low[v] = min(low[v], low[w]);\n        } else if (inS[w])\n            low[v] = min(low[v], num[w]);\n    }\n    if (low[v] == num[v]) {\n        scc.push_back(vector<ll>());\n        while (1) {\n            ll w = S.top(); S.pop(); inS[w] = false;\n            scc.back().push_back(w);\n            if (v == w) break;\n        }\n    }\n}\nvoid stronglyConnectedComponents(const Graph& g, vector< vector<ll> >& scc) {\n    const ll n = g.size();\n    vector<ll> num(n), low(n);\n    stack<ll> S;\n    vector<bool> inS(n);\n    ll time = 0;\n    rep(u, n) if (num[u] == 0)\n        visitStronglyConnectedComponents(g, u, scc, S, inS, low, num, time);\n}\n\n// ???????????????????????????\n// ????????????????????? u ??§?????£??????u[i] ?????? u[j] ??????????????? => i < j ?????????????????????????????????\n//\n// const Graph &g\n// ??°?????????\n// vector<int> &order\n// ???????????????????????????????????????????????¨??§??£??\\???????????????????????????????????? true ?????¨???????????????\n// ?????????\n// ????????????????????????????????????????????????\n//\n// O(V+E)\nbool visitT(const Graph &g, ll v, vector<ll> &order, vector<ll> &color) {\n    color[v] = 1;\n    FOR(e, g[v]) {\n        if (color[e->dst] == 2) continue;\n        if (color[e->dst] == 1) return false;\n        if (!visitT(g, e->dst, order, color)) return false;\n    }\n    order.push_back(v); color[v] = 2;\n    return true;\n}\nbool topologicalSort(const Graph &g, vector<ll> &order) {\n    ll n = g.size();\n    vector<ll> color(n);\n    rep(u, n) if (!color[u] && !visitT(g, u, order, color))\n        return false;\n    reverse(all(order));\n    return true;\n}\n\n// ???????????°???????????????\nvoid reverseGraph(Graph& g_dst, Graph& g_src) { /*g_dst??????graph?????????*/\n    g_dst = Graph(g_src.size());\n    rep(i, g_src.size()) {\n        rep(j, g_src[i].size()) {\n            addDirected(g_dst, g_src[i][j].dst, g_src[i][j].src, g_src[i][j].weight);\n        }\n    }\n}\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, m; cin >> n >> m;\n    Graph g = Graph(n);\n    rep(i, m) {\n        ll u, v; cin >> u >> v; u--, v--;\n        addDirected(g, u, v);\n    }\n\n    // ??????????????°?????????????????????\n    vector<vector<ll>> scc;\n    stronglyConnectedComponents(g, scc);\n    /*\n    rep(i, scc.size()) {\n        rep(j, scc[i].size()) cout << scc[i][j] << \" \";\n        cout << endl;\n    }\n    */\n\n    // ?????????????????????SCC????±????????????????\n    vector<ll> scc_inv(g.size());\n    rep(i, scc.size()) rep(j, scc[i].size()) scc_inv[scc[i][j]] = i;\n//    cout << scc_inv << endl;\n\n    // ??°??????DAG?????°????????????\n    // ??°??????dag?????????i??????????????????(vector<ll> scc[i])???????????¨???????????????\n    Graph dag(scc.size());\n    rep(from, g.size()) rep(to, g[from].size()) if (scc_inv[from] != scc_inv[g[from][to].dst]) {\n        addDirected(dag, scc_inv[from], scc_inv[g[from][to].dst]);\n    }\n    /*\n    printGraph(dag);\n    */\n\n    vector<ll> order;\n    bool success = topologicalSort(dag, order);\n    /*\n    if (success) \n        cout << order << endl;\n    else \n        cout << \"NOT DAG\" << endl; // ??¶???DAG??????????????????\n    */\n    reverse(all(order));\n\n    Graph dag_rev;\n    reverseGraph(dag_rev, dag);\n    /*\n    printGraph(dag);\n    printGraph(dag_rev);\n    */\n\n    vll dp(dag.size(), -1);\n    function<ll(ll)> f = [&](ll i){\n        if (dp[i] != -1)\n            return dp[i];\n        dp[i] = 1;\n        rep(j, dag_rev[i].size()) {\n            (dp[i] *= f(dag_rev[i][j].dst) + 1) %= mo;\n        }\n        return dp[i];\n    };\n\n    ll ret = 1;\n    rep(i, dag.size()) {\n        if (dp[order[i]] != -1) \n            continue;\n        (ret *= f(order[i]) + 1) %= mo;\n    }\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iomanip>\n \nusing namespace std;\n \ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<LD, LD> PLDLD;\ntypedef vector<int> VI;\ntypedef vector<char> VB;\n \n#define FOR(i,a,b) for(int i=(a);i<(int)(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define ALL(a) a.begin(),a.end()\n \nconst LD eps=1e-5;\n//const long long INF=(LL)(1e9)*(LL)(1e9);\nconst int INF=1e9;\n \ntemplate<class T>\nvoid chmin(T& a, const T& b)\n{\n\tif(a>b)\n\t\ta=b;\n}\ntemplate<class T>\nvoid chmax(T& a, const T& b)\n{\n\tif(a<b)\n\t\ta=b;\n}\n \nconst LL pow(const LL p, const LL q)\n{\n\tLL t=1;\n\tREP(i,q)\n\t\tt*=p;\n\treturn t;\n}\n\n\nstruct Edge\n{\n    int to,from,cost;\n    Edge(int to_,int from_,int weight_):to(to_),from(from_),cost(weight_)\n    {}\n\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nconst Graph reverse_edge_Graph(const Graph& g)\n{\n    Graph rg(g.size());\n    for(auto&& es : g)\n        for(auto&& e : es)\n            rg[e.to].push_back(Edge(e.from,e.to,e.cost));\n    return rg;\n}\n\nconst tuple<vector<int>,vector< vector<int>>> SCC(const Graph& g) //StronglyConnectedComponent\n{\n    const int n = g.size();\n    Graph rg(reverse_edge_Graph(g));\n    vector<int> vs;\n    vector<char> reach(n);  //vector<bool>\n    vector<vector<int> > scc;\n    vector<int> scc_vectormap(n);\n\n    function<void(const int)> dfs = [&](const int v)\n    {\n        reach[v]=1;\n        for(auto&& e : g[v])\n            if(!reach[e.to]) dfs(e.to);\n        vs.push_back(v);\n    };\n    function<void(const int, const int)> rdfs = [&](const int v, const int k)\n    {\n        reach[v]=1;\n        scc[k].push_back(v);\n        scc_vectormap[v]=k;\n        for(auto&& e : rg[v])\n            if(!reach[e.to]) rdfs(e.to, k);\n    };\n\n    for(int i=0;i<n;i++)\n        if(!reach[i]) dfs(i);\n    fill(reach.begin(), reach.end(), 0);\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--)\n        if(!reach[vs[i]]) \n        {\n            scc.push_back(vector<int>());\n            rdfs(vs[i], k++);\n        }\n    return tuple<vector<int>, vector<vector<int>> >(scc_vectormap, scc);\n}\n\nconst Graph DAG_from_SCC(int DAG_size, Graph& g, vector<int>& scc_vectormap)\n{\n    Graph dag(DAG_size);\n    for(auto&& es : g)\n        for(auto&& e : es)\n        {\n            if(scc_vectormap[e.from]==scc_vectormap[e.to]) continue;\n            dag[scc_vectormap[e.from]].push_back(Edge(scc_vectormap[e.to], scc_vectormap[e.from], 0));\n        }\n    return dag;\n}\n\n\nclass Mod\n{\n    private:\n        static const long long MODULO = 1e9+7;\n        long long value;\n\n        const void Normalize()\n        {\n            value=value<0?(value%MODULO+MODULO):(value%MODULO);\n        }\n\n    public:\n        Mod():value(0){}\n        Mod(const long long &val)\n        {\n            value=val;\n            Normalize();\n        }\n        \n        explicit operator long long () const\n        {\n            return value;\n        }\n\n        const Mod operator -() const\n        {\n            return Mod(MODULO - value);\n        }\n        const Mod operator +(const Mod &rhs) const\n        {\n            return Mod(value + rhs.value);\n        }\n        const Mod operator -(const Mod &rhs) const\n        {\n            return Mod(value + (-rhs).value);\n        }\n        const Mod operator *(const Mod &rhs) const\n        {\n            return Mod(value * rhs.value);\n        }\n        Mod &operator +=(const Mod &rhs)\n        {\n            return *this = *this + rhs;\n        }\n        Mod &operator -=(const Mod &rhs)\n        {\n            return *this = *this - rhs;\n        }\n        Mod &operator *=(const Mod &rhs)\n        {\n            return *this = *this * rhs;\n        }\n\n\n        Mod pow(long long p) const;\n\n        Mod inv() const\n        {\n            return pow(MODULO-2);\n        }\n\n        const Mod operator /(const Mod &rhs) const\n        {\n            return *this * rhs.inv();\n        }\n        Mod &operator /=(const Mod &rhs)\n        {\n            return *this = *this / rhs;\n        }  \n        bool operator ==(const Mod &rhs)\n        {\n            return value == rhs.value;\n        }\n};\n\nMod Mod::pow(long long p) const\n{\n    Mod tmp=1, mult=*this;\n    while(p)\n    {\n        if((p&1)>0) tmp*=mult;\n        p>>=1;\n        mult*=mult;\n    }\n    return tmp;\n}\n\nnamespace std\n{\n    ostream& operator<<(ostream& os, const Mod mod)\n    {\n        os<<(long long)mod;\n        return os;\n    }\n};\n\nint main()\n{\n\t//cin.tie(0);\n\t//ios::sync_with_stdio(false);\n    \n    int v,e;\n    cin>>v>>e;\n    Graph g(v);\n    REP(i,e)\n    {\n        int s,t;\n        cin>>s>>t;\n        t--;\n        s--;\n        g[s].push_back(Edge(t,s,0));\n    }\n    VI mp;\n    vector<VI> hoge;\n    tie(mp,hoge) = SCC(g);\n\n    Graph dag=DAG_from_SCC(hoge.size(),g, mp);\n    Graph rdag=reverse_edge_Graph(dag);\n    vector<char> nr(rdag.size());\n    for(auto&& es:rdag)\n    {\n        for(auto&& e:es)\n        {\n            nr[e.to]=1;\n        }\n    }\n\n    function<Mod(const int)> dfs = [&](const int v)\n    {\n        if(rdag[v].size()==0) return Mod(1);\n        vector<Mod> ed;\n        for(auto&& e:rdag[v])\n        {\n            ed.push_back(dfs(e.to)+1);\n        }\n        Mod s=1;\n        REP(i,ed.size())\n            s*=ed[i];\n        //cout<<\"hoge\"<<v<<\" \"<<s<<endl;\n        return s;\n    };\n\n    vector<Mod> s;\n    for(int i=0;i<nr.size();i++)\n    {\n        if(nr[i]) continue;\n        s.push_back(dfs(i)+1);\n        //cout<<i<<\" \"<<s[s.size()-1]<<endl;\n    }\n    Mod ans=1;\n    REP(i,s.size())\n        ans*=s[i];\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 1005\n#define M 1000000007\nusing namespace std;\ntypedef long long ll;\n\nint V; //????????°\nvector<int> G[MAX_V]; //??°???????????£??\\??????????????¨???\nvector<int> rG[MAX_V];//?????????????????????????????°??????\nvector<int> vs;       //??°?????????????????????\nbool used[MAX_V];     //?????§???????????????\nint cmp[MAX_V];       //?±????????????£?????????????????????????????????\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  \n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\nll ans[MAX_V];\n\nvoid dfs2(int x){\n  if(used[x])return;\n  used[x]=true;\n  for(int i=0;i<G[x].size();i++){\n    int nx=G[x][i];\n    if(cmp[x]!=cmp[nx])ans[cmp[nx]]=(ans[cmp[nx]]*(ans[cmp[x]]+1))%M;\n    dfs2(nx);\n  }\n}\n\nint main(){\n  int n,m,s,d;\n  int start[MAX_V],goal[MAX_V];\n  cin>>n>>m;\n  V=n;\n  for(int i=0;i<n;i++)\n    ans[i]=start[i]=goal[i]=1;\n  for(int i=0;i<m;i++){\n    cin>>s>>d;\n    s--; d--;\n    add_edge(s,d);\n  }\n  int k=scc();\n  for(int i=0;i<n;i++)\n    for(int j=0;j<G[i].size();j++){\n      int x=G[i][j];\n      if(cmp[i]!=cmp[x])\n\tgoal[cmp[i]]=start[cmp[x]]=0;\n    }\n  for(int i=0;i<n;i++){\n    if(start[cmp[i]]){\n      memset(used,0,sizeof(used));\n      dfs2(i);\n    }\n    start[cmp[i]]=0;\n  }\n  ll cnt=1;\n  for(int i=0;i<k;i++)\n    if(goal[i])cnt=(cnt*(ans[i]+1))%M;\n  cout<<cnt<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\ntypedef int Weight; // int型におさまらないときはlong longに変更\nstruct Edge{\n  int src, dst;\n  Weight cost;\n  Edge(int f, int t, Weight c) : src(f), dst(t), cost(c) {}\n};\nbool operator<(const Edge& a, const Edge& b){\n  return a.cost < b.cost;\n}\n\n\n// 隣接リスト\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\n\n// 隣接行列\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n\n//Strongly Connected Components(強連結成分)\n\n//Step1\nvoid SCC_dfs(const Graph& G, vector<bool>& visit, vector<int>& order, int v){\n  visit[v] = true;\n  REP(i, G[v].size()){\n    int dst = G[v][i].dst;\n    if(!visit[dst]) SCC_dfs(G, visit, order, dst);\n  }\n  order.push_back(v);\n}\n\n//Step2\nGraph reverse_graph(const Graph& G){\n  Graph revG(G.size());\n  REP(i, G.size()){\n    REP(j, G[i].size()){\n      const Edge &e = G[i][j];\n      revG[e.dst].push_back(Edge(e.dst, e.src, e.cost));\n    }\n  }\n  return revG;\n}\n\n//Step3\nvoid SCC_rdfs(const Graph& G, vector<bool>& visit, vector<int>& comp, int v, int k){\n  visit[v] = true;\n  REP(i, G[v].size()){\n    int dst = G[v][i].dst;\n    if(!visit[dst]) SCC_rdfs(G, visit, comp, dst, k);\n  }\n  comp[v] = k;\n}\n\n//SCC分解\nint SCC(const Graph& G, vector<int>& comp){\n  Graph revG = reverse_graph(G);\n  comp = vector<int>(G.size());\n  vector<bool> visit(G.size());\n  vector<int> order(G.size());\n  int k = 0;\n  REP(i, G.size()) if(!visit[i]) SCC_dfs(G, visit, order, i);\n  reverse(order.begin(), order.end()); //(orderにはトポロジカル順序が入る)\n\n  visit = vector<bool>(G.size());\n  REP(i, order.size()){\n    if(!visit[order[i]]) SCC_rdfs(revG, visit, comp, order[i], k++);\n  }\n  return k;\n}\n\nll memo[1000][2];\n\nll dfs(const Graph& G, vector<bool>& used, int u, int k){\n  if(memo[u][k] != -1) return memo[u][k];\n  used[u] = true;\n  ll c0 = 1;\n  ll c1 = 1;\n  for(int i = 0; i < G[u].size(); i++){\n    int dst = G[u][i].dst;\n    c0 *= dfs(G, used, dst, 0);\n    c0 %= MOD;\n    c1 *= dfs(G, used, dst, 1);\n    c1 %= MOD;\n  }\n  if(k == 0) memo[u][k] = (c0 + c1) % MOD;\n  else memo[u][k] = c1;\n  return memo[u][k];\n}\nint main(){\n  int N, M;\n  while(cin>>N>>M && N){\n    memset(memo, -1, sizeof(memo));\n    Graph G(N);\n    REP(i, M){\n      int S, D;\n      cin>>S>>D;\n      S--; D--;\n      G[S].push_back(Edge(S, D, 1));\n    }\n    vector<int> comp;\n    int L = SCC(G, comp);\n    Graph SG_rev(N);\n    REP(i, N){\n      REP(j, G[i].size()){\n        Edge& e = G[i][j];\n        int src = comp[e.src];\n        int dst = comp[e.dst];\n        if(src != dst){\n          SG_rev[dst].push_back(Edge(dst, src, 1));\n        }\n      }\n    }\n    vector<bool> used(N);\n    ll ans = 1;\n    for(int i = L - 1; i >= 0; i--){\n      if(!used[i]) ans = (ans * dfs(SG_rev, used, i, 0)) % MOD;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nclass StronglyConnectedComponent {\npublic:\n  const ll N;\n  vector<vector<ll>> E, R;\n  vector<ll> component;\n\n  StronglyConnectedComponent(ll N): N(N), E(N), R(N), component(N) {}\n\n  void add_edge(ll u, ll v) {\n    E[u].push_back(v);\n    R[v].push_back(u);\n  }\n\n  ll discomposit() {\n    vector<ll> vs;\n    vector<bool> used1(N, false);\n    REP(i, 0, N) if(!used1[i]) dfs(i, vs, used1);\n\n    vector<bool> used2(N, false);\n    ll k = 0;\n    for(ll i = vs.size() - 1; i >= 0; i--) if(!used2[vs[i]]) rdfs(vs[i], k++, used2);\n    return k;\n  }\n\nprivate:\n  void dfs(ll v, vector<ll> &vs, vector<bool> &used) {\n    used[v] = true;\n    REP(i, 0, E[v].size()) if(!used[E[v][i]]) dfs(E[v][i], vs, used);\n    vs.push_back(v);\n  }\n\n  void rdfs(ll v, ll k, vector<bool> &used) {\n    used[v] = true;\n    component[v] = k;\n    REP(i, 0, R[v].size()) if(!used[R[v][i]]) rdfs(R[v][i], k, used);\n  }\n};\n\nconst ll MOD = 1000000007;\n\nint main(void) {\n  ll N, M;\n  cin >> N >> M;\n  vector<ll> S(M), D(M);\n  StronglyConnectedComponent scc(N);\n  REP(i, 0, M) {\n    cin >> S[i] >> D[i]; S[i]--; D[i]--;\n    scc.add_edge(S[i], D[i]);\n  }\n\n  ll n = scc.discomposit();\n  vector<pll> edge;\n  REP(i, 0, M) edge.push_back(pll(scc.component[S[i]], scc.component[D[i]]));\n  sort(edge.begin(), edge.end());\n  edge.erase(unique(edge.begin(), edge.end()), edge.end());\n\n  vector<vector<ll>> E(n), R(n);\n  REP(i, 0, edge.size()) {\n    ll s = edge[i].first, d = edge[i].second;\n    if(s == d) continue;\n    E[s].push_back(d);\n    R[d].push_back(s);\n  }\n\n  vector<ll> cnt(n);\n  REP(i, 0, n) cnt[i] = R[i].size();\n\n  stack<ll> stk;\n  REP(i, 0, n) if(cnt[i] == 0) stk.push(i);\n\n  vector<ll> dp(n, 0);\n  while(stk.size()) {\n    ll v = stk.top();\n    stk.pop();\n\n    dp[v] = 1;\n    REP(i, 0, R[v].size()) (dp[v] *= dp[R[v][i]]) %= MOD;\n    (dp[v] += 1) %= MOD;\n\n    REP(i, 0, E[v].size()) if(--cnt[E[v][i]] == 0) stk.push(E[v][i]);\n  }\n\n  ll ans = 1;\n  REP(i, 0, n) if(E[i].size() == 0) (ans *= dp[i]) %= MOD;\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define MAX_V 1111\nconst ll MOD = 1e9+7;\n\nstruct SCC{\n  int V; \n  vector<int> G[MAX_V];  //グラフの隣接リスト\n  vector<int> rG[MAX_V]; //逆に辺を貼ったグラフの隣接リスト\n  vector<int> vs;        //帰り掛け順の並び\n  bool used[MAX_V];      //すでに調べたか\n  int cmp[MAX_V];        //属する強連結成分のトポロジカル順序\n\n  SCC(int v){\n    V=v;\n    fill_n(used,MAX_V,0);\n    fill_n(cmp,MAX_V,0);\n  }\n  \n  void add_edge(int from,int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  }\n\n  void dfs(int v){\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++)\n      if(!used[G[v][i]])dfs(G[v][i]);\n    vs.push_back(v); //探索終了したものから追加\n  }\n\n  void rdfs(int v,int k){\n    used[v]=true;\n    cmp[v]=k;\n    for(int i=0;i<rG[v].size();i++)\n      if(!used[rG[v][i]])rdfs(rG[v][i],k);\n  }\n\n  int scc(){\n    memset(used,0,sizeof(used));\n    vs.clear();\n    for(int v=0;v<V;v++)\n      if(!used[v])dfs(v);\n\n    memset(used,0,sizeof(used));\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--)\n      if(!used[vs[i]])rdfs(vs[i],k++);\n\n    return k;\n  }\n\n};\n\nvector<int> g[1111];\nll used[1111]={};\n\nll dfs(int k){\n  ll res=1;\n  for(int i=0;i<g[k].size();i++){\n    res*=dfs(g[k][i]);\n    res%=MOD;\n  }\n  return (res+1)%MOD;\n}\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  SCC sc(n);\n  int s[1111],d[1111];\n  for(int i=0;i<m;i++){\n    cin>>s[i]>>d[i];\n    sc.add_edge(--s[i],--d[i]);\n  }\n  int k = sc.scc();\n  for(int i=0;i<m;i++){\n    if(sc.cmp[d[i]]==sc.cmp[s[i]])continue;\n    g[sc.cmp[d[i]]].push_back(sc.cmp[s[i]]);\n    used[sc.cmp[s[i]]]=1;\n  }\n  ll ans=1;\n  for(int i=0;i<k;i++){\n    if(used[i])continue;\n    ans*=dfs(i);\n    ans%=MOD;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nstruct SCC\n{\n\tvector<vector<int> > G;\n\tvector<vector<int> > rG;\n\tvector<int> vs;\n\tvector<bool> used;\n\tvector<int> cmp;\n\tint sz,newsz;\n\tSCC(int n):G(n),rG(n),used(n,false),cmp(n){sz = n;}\n\t\n\tvoid add_edge(int from,int to)\n\t{\n\t\tG[from].PB(to);\n\t\trG[to].PB(from);\n\t}\n\t\n\tvoid dfs(int v)\n\t{\n\t\tused[v] = true;\n\t\tREP(i,G[v].size())\n\t\t{\n\t\t\tif(!used[G[v][i]])dfs(G[v][i]);\n\t\t}\n\t\tvs.PB(v);\n\t}\n\t\n\tvoid rdfs(int v,int k)\n\t{\n\t\tused[v] = false;\n\t\tcmp[v] = k;\n\t\tREP(i,rG[v].size())\n\t\t{\n\t\t\tif(used[rG[v][i]])rdfs(rG[v][i],k);\n\t\t}\n\t}\n\t\n\tint reMake()\n\t{\n\n\t\tvs.clear();\n\t\tREP(i,sz)if(!used[i])dfs(i);\n\t\tint k = 0;\n\t\tfor(int i = sz-1;i >= 0;i--)\n\t\t{\n\t\t\tif(used[vs[i]])\n\t\t\t{\n\t\t\t\trdfs(vs[i],k++);\n\t\t\t}\n\t\t}\n\t\treturn newsz = k;\n\t}\n\t\n\t\n\t\n\tvoid makeList(vector<vector<int> > &v)\n\t{\n\t\tREP(i,sz)\n\t\t{\n\t\t\tREP(j,G[i].size())\n\t\t\t{\n\t\t\t\tif(cmp[i] == cmp[G[i][j]])continue;\n\t\t\t\tv[cmp[i]].PB(cmp[G[i][j]]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid makeReverseList(vector<vector<int> > &v)\n\t{\n\t\tREP(i,sz)\n\t\t{\n\t\t\tREP(j,G[i].size())\n\t\t\t{\n\t\t\t\tif(cmp[i] == cmp[G[i][j]])continue;\n\t\t\t\tv[cmp[G[i][j]]].PB(cmp[i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint scc_node(int n)\n\t{\n\t\treturn cmp[n];\n\t}\n};\n\n#define MOD 1000000007\n\nvector<vector<int> > v(1000);\nvector<vector<int> > rv(1000);\n\nll kaijo[1000];\nbool check[10001];\n\nll dfs(int n)\n{\n\tcheck[n] = true;\n\tll ret = 1;\n\tint num = rv[n].size();\n\tif(num == 0)\n\t{\n\t//\tcout << ' ' << ret << endl;\n\t\treturn ret;\n\t}\n\tif(num == 1)\n\t{\n\t\tret =(ret + dfs(rv[n][0]))% MOD;\n\t//cout << ' ' << ret << endl;\n\t\treturn ret;\n\t}\n\tll kai = kaijo[num-2];\n\tret = (kaijo[num] + MOD)%MOD;\n\t//cout << \"    \" << ret << endl;\n\tvector<ll> tmp;\n\t\n\tREP(i,num)\n\t{\n\t\ttmp.PB(dfs(rv[n][i]));\n\t}\n\t\n\tfor(int i = 0;i < num;i++)\n\t{\n\t\tfor(int j = i+1;j < num;j++)\n\t\t{\n\t\t\tret = (ret + (((tmp[i]*tmp[j] - 1LL)%MOD)*kai)%MOD)%MOD;\n\t\t}\n\t}\n\t//cout << ' ' << ret << endl;\n\t\n\treturn ret;\n}\n\nint main()\n{\n\tint n,m;cin >> n >> m;\n\t\n\tkaijo[0] = 1;\n\tfor(int i = 1;i < 1000;i++)\n\t{\n\t\tkaijo[i] = (kaijo[i-1]*2)%MOD;\n\t}\n\tSCC scc(n);\n\tREP(i,m)\n\t{\n\t\tint a,b;cin >> a >> b;\n\t\ta--;b--;\n\t\tscc.add_edge(a,b);\n\t}\n\t\n\tscc.reMake();\n\tscc.makeList(v);\n\tscc.makeReverseList(rv);\n\t\t\n\tll ans = 1;\n\tREP(i,scc.newsz)\n\t{\n\t\tif(v[i].size() == 0 && !check[i])\n\t\t{\n\t\t\tans = (ans * (dfs(i)+1LL))%MOD;\n\t\t//\tcout << ans << endl;\n\t\t}\n\t}\t\t\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int MOD = 1000000007;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\nint main()\n{\n    int N, M;\n    cin >> N >> M;\n    vector<int> to(N, -1);\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        to[u] = v;\n    }\n    vector<int> label(N), cycle;\n    iota(label.begin(), label.end(), 0);\n    vector<bool> used(N, false), reached(N, false);\n    auto getcycle = [&](int s) {\n        for (int i = 0; i < 2 * N; i++, s = to[s]) {\n            used[s] = true;\n            if (to[s] == -1) { break; }\n        }\n        if (reached[label[s]]) { return; }\n        reached[label[s]] = true, cycle.push_back(s);\n        if (to[s] == -1) { return; }\n        for (int p = to[s]; p != s; p = to[p]) { label[p] = s; }\n    };\n    for (int i = 0; i < N; i++) {\n        if (not used[i]) { getcycle(i); }\n    }\n    vector<vector<int>> g(N);\n    for (int i = 0; i < N; i++) {\n        if (to[i] == -1 or label[i] == label[to[i]]) { continue; }\n        g[label[to[i]]].push_back(label[i]);\n    }\n    auto dfs = fix([&](auto&& self, const int s) -> int {\n        int ans = 1;\n        for (const int to : g[s]) { (ans *= self(self, to)) %= MOD; }\n        return ans + 1;\n    });\n    int ans = 1;\n    for (const int c : cycle) { (ans *= dfs(c)) %= MOD; }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nusing node=struct{int to;};\nusing G=vector<vector<node>>;\n\ntuple<vector<int>,G> scc(const G &graph){\n\tint n=graph.size(),k=0,m=0;\n\tvector<int> ord(n,-1),low(n),comp(n,-1),par(n);\n\tstack<int>s;\n\n\tfunction<void(int,int)> dfs=[&](int v,int p){\n\t\tord[v]=k++,low[v]=ord[v],par[v]=p;\n\t\ts.push(v);\n\n\t\tfor(auto &e:graph[v]){\n\t\t\tif(ord[e.to]==-1){\n\t\t\t\tdfs(e.to,v);\n\t\t\t\tchmin(low[v],low[e.to]);\n\t\t\t}else if(comp[e.to]==-1){\n\t\t\t\tchmin(low[v],ord[e.to]);\n\t\t\t}\n\t\t}\n\n\t\tif(ord[v]==low[v]){\n\t\t\twhile(1){\n\t\t\t\tint u=s.top();s.pop();\n\t\t\t\tcomp[u]=m;\n\t\t\t\tif(u==v) break;\n\t\t\t}\n\t\t\tm++;\n\t\t}\n\t};\n\n\trep(v,n) if(ord[v]==-1) dfs(v,-1);\n\tG dag(m);\n\trep(v,n) for(auto &e:graph[v]) if(comp[v]!=comp[e.to]) dag[comp[v]].push_back({comp[e.to]});\n\treturn make_tuple(comp,dag);\n}\n\nvector<int> topological_sort(const G &graph) {\n\tint n=graph.size();\n\tvector<int> order,used(n,false);\n\t\n\tfunction<void(int)> dfs=[&](int v){\n\t\tused[v]=true;\n\t\tfor(auto &e:graph[v]){\n\t\t\tif(!used[e.to])\n\t\t\t\tdfs(e.to);\n\t\t}\n\t\torder.push_back(v);\n\t};\n\n\trep(v,n) if(!used[v]) dfs(v);\n\treverse(_all(order));\n\treturn order;\n}\n\nusing ll=long long;\nconst ll mod=1000000007LL;\n\ninline ll ADD(const ll &a, const ll &b,const ll &mod) { return a+b<mod?a+b:a+b-mod;}\ninline ll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\n\nll dp[1010][2];\n\nint main(void){\n\tint n,m;\n\tcin >> n >> m;\n\n\tG graph(n);\n\trep(loop,m){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tgraph[a-1].push_back({b-1});\n\t}\n\n\tG dag;\n\tvector<int> comp,order;\n\ttie(comp,dag)=scc(graph);\n\torder=topological_sort(dag);\n\t\n\trep(v,n) dp[v][0]=dp[v][1]=1LL;\n\tll ans=1LL;\n\n\tfor(auto &v:order){\n\t\tvector<int> already(dag.size(),false);\n\t\tfor(auto &e:dag[v]){\n\t\t\tif(already[e.to]) continue;\n\t\t\talready[e.to]=true;\n\t\t\tdp[e.to][0]=MUL(dp[e.to][0],dp[v][0],mod);\n\t\t\tdp[e.to][1]=MUL(dp[e.to][1],ADD(dp[v][0],dp[v][1],mod),mod);\n\t\t}\n\t\tif(dag[v].empty()){\n\t\t\tll cur=ADD(dp[v][0],dp[v][1],mod);\n\t\t\tans=MUL(ans,cur,mod);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\n\nint N, M;\nvector< int > cg[1000], rg[1000], g[1000];\nbool v[1000];\nvector< int > order;\nint cmp[1000];\nbool connect[1000][1000];\nbool in[1000];\nlong long dp[1000];\n\nvoid dfs(int idx)\n{\n  for(int to : cg[idx]) if(!v[to]++) dfs(to);\n  order.push_back(idx);\n}\nvoid rdfs(int idx, int k)\n{\n  cmp[idx] = k;\n  for(int to : rg[idx]) if(cmp[to] == -1) rdfs(to, k);\n}\nint scc()\n{\n  int k = 0;\n  for(int i = 0; i < N; i++) if(!v[i]) dfs(i);\n  memset(cmp, -1, sizeof(cmp));\n  reverse(order.begin(), order.end());\n  for(int i : order) if(cmp[i] == -1) rdfs(i, k++);\n  return(k);\n}\n\nlong long rec(int idx)\n{\n  if(dp[idx]) return(dp[idx]);\n  long long ret = 1;\n  for(int to : g[idx]) (ret *= rec(to)) %= mod;\n  return(dp[idx] = (ret + 1) % mod);\n}\n\nint main()\n{\n  cin >> N >> M;\n  \n  while(M--) {\n    int A, B;\n    cin >> A >> B;\n    --A, --B;\n    cg[B].push_back(A);\n    rg[A].push_back(B);\n  }\n  int c = scc();\n  for(int i = 0; i < N; i++) {\n    for(int to : cg[i]) {\n      if(cmp[i] == cmp[to]) continue;\n      if(connect[cmp[i]][cmp[to]]++) continue;\n      g[cmp[i]].push_back(cmp[to]);\n      in[cmp[to]] = true;\n    }\n  }\n  long long ret = 1;\n  for(int i = 0; i < c; i++) {\n    if(!in[i]) (ret *= rec(i)) %= mod;\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\nstruct Dscc {\npublic:\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]) {\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<Edge>>>get(const vector<vector<Edge>>&edges) {\n\t\tconst int old_node_size = edges.size();\n\t\tnums.resize(old_node_size);\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<Edge>>revedges(old_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\trevedges[j.dst].push_back(Edge(j.dst, j.src, j.weight));\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(old_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\n\t\tunis.resize(old_node_size);\n\t\tfill(unis.begin(), unis.end(), -1);\n\n\t\tnum = 0;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tconst int new_node_size = nums.size();\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < new_node_size; ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(new_node_size);\n\t\tfor (int i = 0; i < old_node_size; ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<Edge>>newedges(new_node_size);\n\t\tfor (const auto& e : edges) {\n\t\t\tfor (const auto& j : e) {\n\t\t\t\tif (unis[j.src] != unis[j.dst]) {\n\t\t\t\t\tnewedges[unis[j.src]].push_back(Edge(unis[j.src], unis[j.dst], j.weight));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id])\n\t\t\t\tdfs2(i, num, edges);\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\tvoid dfs(const int id, int &num, const vector<vector<Edge>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<Edge>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs2(i.dst, num, edges);\n\t\t\t}\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n}dscc;\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<int>>edges(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tedges[a].push_back(b);\n\t}\n\tauto p=dscc.get(edges);\n\tvector<vector<int>>newedges(p.second);\n\tvector<vector<int>>revedges(newedges.size());\n\tfor (int i = 0; i < newedges.size();++i) {\n\t\tvector<int>es(newedges[i]);\n\t\tfor (auto e : es) {\n\t\t\trevedges[e].push_back(i);\n\t\t}\n\t}\n\tvector<int>nums(newedges.size());\n\n\tfor (auto es : newedges) {\n\t\tfor (auto e : es) {\n\t\t\tnums[e]++;\n\t\t}\n\t}\n\tvector<pair<Mod, Mod>>ps(newedges.size());\n\tqueue<int>que;\n\tfor (int i = 0; i < nums.size();++i) {\n\t\tif (!nums[i])que.push(i);\n\t}\n\tvector<pair<Mod, Mod>>memo(newedges.size());\n\tMod ans = 1;\n\twhile (!que.empty()) {\n\t\tint atop(que.front());\n\t\tque.pop();\n\t\tpair<Mod, Mod>p(1, 1);\n\t\tfor (auto e : revedges[atop]) {\n\t\t\tp.first *= memo[e].first + memo[e].second;\n\t\t\tp.second *= memo[e].second;\n\t\t}\n\t\tfor (auto e : newedges[atop]) {\n\n\t\t\tnums[e]--;\n\t\t\tif (!nums[e])que.push(e);\n\t\t}\n\t\tif (newedges[atop].empty())ans *= (p.first + p.second);\n\t\tmemo[atop] = p;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nstruct E {\n  int src, dst;\n  E(int s, int d) : src(s), dst(d) {}\n};\nnamespace std {\n  bool operator < (const E a, const E b)\n  {\n    if (a.src != b.src) return a.src < b.src;\n    return a.dst < b.dst;\n  }\n  bool operator == (const E a, const E b){\n    return a.src == b.src && a.dst == b.dst;\n  }\n};\ntypedef vector<E> Es;\ntypedef vector<Es> G;\n\nconst int N = 1000 + 1;\nint label[N];\n\nint rec(int src, const G &g, int depth)\n{\n  label[src] = depth;\n  for (int i = 0; i < g[src].size(); ++i) {\n    int dst = g[src][i].dst;\n    if (label[dst]) return label[dst];\n    int tmp = rec(dst, g, depth + 1);\n    if (tmp) return tmp;\n  }\n  label[src] = 0;\n  return 0;\n}\nconst int mod = 1000000007;\n\ntypedef long long int lli;\n\nint t[N][2];\n\nvoid solve(int u, const G &g, int cnt)\n{  \n  label[u] = cnt;\n  for (int i = 0; i < g[u].size(); ++i) {\n    int v = g[u][i].dst;\n    t[v][0] = t[u][0];\n    t[v][1] = (t[u][1] * 2) % mod;\n    solve(v, g, cnt);\n    //cout << v << \" : \" << t[v][0] << ' ' << t[v][1] << endl;\n  }\n  return ;\n}\n\n\n\nint main(void)\n{\n  int node, edge;\n  while (cin >> node >> edge) {\n\n    //cout << string(20, '=') << endl;\n    \n\n    G g(node);\n\n    int outd[node];\n    int ind[node];\n    fill(ind, ind + node, 0);\n    fill(outd, outd + node, 0);\n\n    for (int i = 0; i < edge; ++i) {\n      int src, dst;\n      cin >> src >> dst;\n      --src;\n      --dst;\n      g[src].push_back(E(src, dst));\n    }\n\n    fill(label, label + N, 0);\n    int l;\n    for (int i = 0; i < node; ++i) {\n      l = rec(i, g, 1);\n      if (l) break;\n    }\n    if (l == 0) l = 1 << 20;\n    \n    int cnt = 0;\n    for (int i = 0; i < node; ++i) {\n      if (l <= label[i]) label[i] = 0;\n      else label[i] = ++cnt;\n    }\n    \n//     for (int i = 0; i < node; ++i) {\n//       cout << label[i] << ' ' ;\n//     }\n//     cout << endl;\n\n    G h(++cnt);\n    for (int i = 0; i < node; ++i) {\n      for (int j = 0; j < g[i].size(); ++j) {\n        E e = g[i][j];\n        if (label[e.src] == label[e.dst]) continue;\n        h[label[e.src]].push_back(E(label[e.src], label[e.dst]));\n      }\n    }\n\n\n\n    node = h.size();\n    for (int i = 0; i < node; ++i) {\n      sort(h[i].begin(), h[i].end());\n      vector<E>::iterator itr = unique(h[i].begin(), h[i].end());\n      h[i].erase(itr, h[i].end());\n    }\n\n\n//     for (int i = 0; i < h.size(); ++i) {\n//       cout << i << endl;\n//       for (int j = 0; j < h[i].size(); ++j) {\n//         cout << h[i][j].src << \" => \" << h[i][j].dst << endl;\n//       }\n//     }\n\n\n\n    for (int i = 0; i < node; ++i) {\n      outd[i] = h[i].size();\n      for (int j = 0; j < h[i].size(); ++j) {\n        ++ind[h[i][j].dst];\n      }\n    }\n\n    G r(h.size());\n    for (int i = 0; i < h.size(); ++i) {\n      for (int j = 0; j < h[i].size(); ++j) {\n        E rev(h[i][j].dst, h[i][j].src);\n        r[h[i][j].dst].push_back(rev);\n      }\n    }\n\n    cnt = 0;\n    fill(label, label + N, 0);\n    fill(&t[0][0], &t[N-1][2], 0);\n    vector<int> tmp;\n    for (int i = 0; i < node; ++i) {\n      if (outd[i] == 0) {\n        t[i][0] = 1;\n        t[i][1] = 1;\n        solve(i, r, ++cnt);\n        int sum = 1;\n        for (int j = 0; j < node; ++j) {\n          if (ind[j] == 0 && label[j] == cnt) {\n            sum += t[j][1];\n            sum %= mod;\n          }\n        }\n        tmp.push_back(sum);\n      }\n    }\n\n    //cout << \"tmp : \" ;for (int i = 0; i < tmp.size(); ++i) cout << tmp[i] << ' '; cout << endl;\n\n    int res = 1;\n    for (int i = 0; i < tmp.size(); ++i) {\n      res *= tmp[i];\n      res %= mod;\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MAX 1005\nll mod=1e9+7;\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n\nint n,m,a,b;\nvector<int> G[MAX],g[MAX];\nint p[MAX];\nbool flg[MAX];\n\nint update(int x){\n  flg[x]=true;\n  if(p[x]==x)return x;\n  return p[x]=update(p[x]);\n}\n\nint find(int x){\n  if(p[x]==x)return x;\n  return find(p[x]);\n}\n\nll dfs(int pos){\n  ll res=1;\n  for(int i=0;i<(int)g[pos].size();i++)\n    res=mul(res,dfs(g[pos][i]));  \n  return (res+1LL)%mod;\n}\n\nint main(){\n  cin>>n>>m;\n    for(int i=1;i<=n;i++)p[i]=i;\n    for(int i=0;i<m;i++){\n      cin>>a>>b;\n      G[b].push_back(a);\n      if(find(b)==a)update(b);\n      else p[a]=b;\n    }\n    for(int i=1;i<=n;i++){\n      for(int j=0;j<(int)G[i].size();j++){\n        int w=G[i][j];\n        if(flg[w])continue;\n        if(flg[i])g[p[i]].push_back(w);\n        else g[i].push_back(w);\n      }\n    }\n    ll ans=1;\n    for(int i=1;i<=n;i++)if(p[i]==i)ans=ans*dfs(i)%mod;\n    cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 10001\n#define f first\n#define s second\n#define mp make_pair\n#define mod 1000000007\n#define inf 1e8\nusing namespace std;\n \ntypedef long long ll;\n \nint V,m;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nvector<pair<int,int> > vpp;\nbool used[MAX_V]={};\nint cmp[MAX_V];\nll dp[MAX_V];\nvector<int> e[MAX_V];\n  \nvoid add_edge(int from, int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n  \nvoid dfs(int v){\n  used[v] = true;\n  for(int i = 0;i < G[v].size();i++){\n    if(!used[G[v][i]])dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\n  \nvoid rdfs(int v,int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i = 0;i < rG[v].size();i++){\n    if(!used[rG[v][i]]) rdfs(rG[v][i],k);\n  }\n}\n  \nvoid scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v = 0;v < V;v++){\n    if(!used[v]) dfs(v);\n  }\n  memset(used,0,sizeof(used));\n  int k = 0;\n  for(int i = vs.size() - 1;i >= 0;i--){\n    if(!used[vs[i]])rdfs(vs[i],k++);\n  }\n  return;\n}\n \nll rec(int v,int cm){\n  ll res=1;\n  int tmp=cmp[v];\n  if(tmp==cm)return 1;\n  if(dp[tmp]!=inf)return dp[tmp];\n  //  if(rG[v].size()==0)return dp[tmp]=2;\n \n  for(int i=0;i<e[tmp].size();i++){\n    int now=e[tmp][i];\n    for(int j=0;j<rG[now].size();j++){\n      int next=rG[now][j];\n      res*=rec(next,tmp);\n      res%=mod;\n    }\n  }\n  return dp[tmp]=res+1;\n}\n \nint main()\n{\n  int a,b,q;\n \n  cin>>V>>m;\n  for(int i=0;i<m;i++){\n    cin>>a>>b;\n    a--;b--;\n    add_edge(a,b);\n  }\n  \n  scc();\n \n  for(int i=0;i<V;i++){\n    vpp.push_back(mp((-1)*cmp[i],i));\n  }\n  sort(vpp.begin(),vpp.end());\n \n  for(int i=0;i<V;i++)vpp[i].f=(-1)*vpp[i].f;\n \n  for(int i=0;i<vpp.size();i++)e[vpp[i].f].push_back(vpp[i].s);\n \n  for(int i=0;i<V;i++)dp[i]=inf;\n  ll ans=1;\n  for(int i=0;i<vpp.size();i++){\n    if(dp[vpp[i].f]==inf){\n      ans*=rec(vpp[i].s,inf);\n      ans%=mod;\n    }\n  }\n \n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nstruct SCC {\n    int V;\n    vector<vi> G, rG;\n    vector<int> vs, used, cmp;\n    SCC(const vector<vi>& g) : V(g.size()), G(g), rG(V), used(V), cmp(V) {\n        for (int i = 0; i < V; i++) for (int u : G[i]) rG[u].push_back(i);\n    }\n    void dfs(int v) {\n        used[v] = 1;\n        for (int u : G[v]) if (!used[u]) dfs(u);\n        vs.push_back(v);\n    }\n    void rdfs(int v, int k) {\n        used[v] = 1;\n        cmp[v] = k;\n        for (int u : rG[v]) if (!used[u]) rdfs(u, k);\n    }\n    int calc() {\n        fill(used.begin(), used.end(), 0);\n        vs.clear();\n        for (int v = 0; v < V; v++) {\n            if (!used[v]) dfs(v);\n        }\n        fill(used.begin(), used.end(), 0);\n        int k = 0;\n        for (int i = vs.size()-1; i >= 0; i--) {\n            if (!used[vs[i]]) rdfs(vs[i], k++);\n        }\n        return k;\n    }\n};\n\nbool visit(const vector<vi>& g, int v, vector<int>& order, vector<int>& color) {\n    color[v] = 1;\n    for (int u : g[v]) {\n        if (color[u]==2) continue;\n        if (color[u]==1) return false;\n        if (!visit(g, u, order, color)) return false;\n    }\n    order.push_back(v); color[v] = 2;\n    return true;\n}\n\n// ?????????????????????????????????\n// ???????????? true ???????????????????????????(false ?????´????????????)\nbool TopologicalSort(const vector<vi>& g, vector<int>& order) {\n    int n = g.size();\n    vector<int> color(n);\n    for (int u = 0; u < n; u++) if (!color[u] && !visit(g, u, order, color)) return false;\n    reverse(order.begin(), order.end());\n    return true;\n}\n\n\nconst int MOD = 1e9+7;\nll dp[1111][2];\n\nll dfs(int v, int flag, const vector<vi>& g) {\n    ll& ret = dp[v][flag];\n    if (ret >= 0) return ret;\n    if (flag == 0) return ret = 1;\n    // v ??? 1 ???????????´???\n    ret = 1;\n    for (int ch : g[v]) {\n        ll tmp = dfs(ch, 0, g) + dfs(ch, 1, g);\n        (ret *= tmp%MOD) %= MOD;\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, M;\n    cin >> N >> M;\n    vector<vi> G(N);\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        G[v].push_back(u);\n    }\n    SCC scc(G);\n    int sz = scc.calc();\n    vector<vi> g(sz);\n    {\n        vector<set<int> > S(sz);\n        for (int i = 0; i < N; i++) {\n            for (int j : G[i]) {\n                S[scc.cmp[i]].insert(scc.cmp[j]);\n            }\n        }\n        for (int i = 0; i < sz; i++) {\n            for (int j : S[i]) if (j != i) {\n                g[i].push_back(j);\n            }\n        }\n    }\n    vector<int> order;\n    TopologicalSort(g, order);\n    // for (int i = 0; i < sz; i++) \n    //     cout << order[i] << \" \";\n    // cout << endl;\n    memset(dp, -1, sizeof(dp));\n    ll ans = 1;\n    for (int i = 0; i < sz; i++) {\n        int v = order[i];\n        if (dp[v][0] == -1) {\n            ll tmp = dfs(v, 0, g) + dfs(v, 1, g);\n            cout << v << \" \" << tmp << endl;\n            (ans *= tmp%MOD) %= MOD;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<cassert>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll M=1000000007;\n\nll dfs(int u,const vector<int> *T){\n\tif(T[u].empty()) return 2;\n\tll res=1;\n\trep(i,T[u].size()){\n\t\tint v=T[u][i];\n\t\tres=res*dfs(v,T)%M;\n\t}\n\treturn (res+1)%M;\n}\n\n// ツ出ツ篠淞青板つェツ債つ々 1 ツづ?つ「ツつ、ツ青ァツ姪アツつゥツづァ, ツ連ツ個仰青ャツ閉ェツづ債δ仰ーツプツづ可姪伉つェツつュツづ?づつつ「ツつスツ形ツづ可づ按づゥ\n// ツつアツづ個連ツ個仰青ャツ閉ェツづ可づつつ「ツづ?づ個嘉ーツづーツ仰?づ淞づゥ\nll solve(int n,const int *G){\n\tvector<int> G2[1000]; // G ツづ個陛督づ個古シツつォツづーツ逆ツ転ツつオツつスツグツδ可フ\n\trep(u,n) if(G[u]!=-1) G2[G[u]].push_back(u);\n\n\t// ツδ仰ーツプツ個淞出\n\trep(u,n){\n\t\tint v=u;\n\t\tbool vis[1000]={};\n\t\twhile(G[v]!=-1 && !vis[v]){\n\t\t\tvis[v]=true;\n\t\t\tv=G[v];\n\t\t}\n\t\tif(v==u){ // ツδ仰ーツプorツ債ェツつェツ個ゥツづつつゥツづ?つス\n\t\t\tll res=1;\n\t\t\tint v=u;\n\t\t\tdo{\n\t\t\t\t// ツδ仰ーツプツ湘」ツづ個各ツ陳クツ点ツづーツ債ェツづ?つキツづゥツ姪伉づ可づつつ「ツづ?督堋つヲツづーツ仰?づ淞づ? ツつサツづェツづァツづーツつゥツつッツつ?づュツつケツづゥ\n\t\t\t\trep(i,G2[v].size()){\n\t\t\t\t\tint w=G2[v][i];\n\t\t\t\t\tif(!vis[w]) res=res*dfs(w,G2)%M;\n\t\t\t\t}\n\t\t\t\tv=G[v];\n\t\t\t}while(v!=u);\n\t\t\treturn (res+1)%M; // ツづ?づェツづ?選ツづ篠づ按つ「ツづ?つ「ツつ、ツ嘉ーツつェツつ?づゥツづ個づ?+1\n\t\t}\n\t}\n\tfor(;;);\n\tassert(0);\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tint to[1000];\n\trep(u,n) to[u]=-1;\n\trep(i,m){\n\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\tto[u]=v;\n\t\tif(u==v) for(;;);\n\t}\n\tvector<int> G[1000]; // ツ鳴ウツ古シツグツδ可フ\n\trep(u,n) if(to[u]!=-1) {\n\t\tint v=to[u];\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\n\tll ans=1;\n\tbool vis[1000]={};\n\trep(u,n) if(!vis[u]) {\n\t\tvis[u]=true;\n\n\t\tvector<int> cc;\n\t\tqueue<int> Q; Q.push(u);\n\t\twhile(!Q.empty()){ // ツ偲」ツ連ツ個仰青ャツ閉ェツつイツづ?づ可陳イツづ猟づゥ\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\tcc.push_back(u);\n\t\t\trep(i,G[u].size()){\n\t\t\t\tint v=G[u][i];\n\t\t\t\tif(!vis[v]) vis[v]=true, Q.push(v);\n\t\t\t}\n\t\t}\n\n\t\tint N=cc.size();\n\t\tint D[1000]; // ツ偲」ツ連ツ個仰づ按有ツ古シツグツδ可フ\n\t\trep(i,N) D[i]=-1;\n\t\trep(i,N) rep(j,N) {\n\t\t\tint u=cc[i],v=cc[j];\n\t\t\tif(to[u]==v) D[i]=j;\n\t\t}\n\t\tans=ans*solve(N,D)%M;\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nstruct SCC\n{\n\tvector<vector<int> > G;\n\tvector<vector<int> > rG;\n\tvector<int> vs;\n\tvector<bool> used;\n\tvector<int> cmp;\n\tint sz,newsz;\n\tSCC(int n):G(n),rG(n),used(n,false),cmp(n){sz = n;}\n\t\n\tvoid add_edge(int from,int to)\n\t{\n\t\tG[from].PB(to);\n\t\trG[to].PB(from);\n\t}\n\t\n\tvoid dfs(int v)\n\t{\n\t\tused[v] = true;\n\t\tREP(i,G[v].size())\n\t\t{\n\t\t\tif(!used[G[v][i]])dfs(G[v][i]);\n\t\t}\n\t\tvs.PB(v);\n\t}\n\t\n\tvoid rdfs(int v,int k)\n\t{\n\t\tused[v] = false;\n\t\tcmp[v] = k;\n\t\tREP(i,rG[v].size())\n\t\t{\n\t\t\tif(used[rG[v][i]])rdfs(rG[v][i],k);\n\t\t}\n\t}\n\t\n\tint reMake()\n\t{\n\n\t\tvs.clear();\n\t\tREP(i,sz)if(!used[i])dfs(i);\n\t\tint k = 0;\n\t\tfor(int i = sz-1;i >= 0;i--)\n\t\t{\n\t\t\tif(used[vs[i]])\n\t\t\t{\n\t\t\t\trdfs(vs[i],k++);\n\t\t\t}\n\t\t}\n\t\treturn newsz = k;\n\t}\n\t\n\t\n\t\n\tvoid makeList(vector<vector<int> > &v)\n\t{\n\t\tREP(i,sz)\n\t\t{\n\t\t\tREP(j,G[i].size())\n\t\t\t{\n\t\t\t\tif(cmp[i] == cmp[G[i][j]])continue;\n\t\t\t\tv[cmp[i]].PB(cmp[G[i][j]]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid makeReverseList(vector<vector<int> > &v)\n\t{\n\t\tREP(i,sz)\n\t\t{\n\t\t\tREP(j,G[i].size())\n\t\t\t{\n\t\t\t\tif(cmp[i] == cmp[G[i][j]])continue;\n\t\t\t\tv[cmp[G[i][j]]].PB(cmp[i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint scc_node(int n)\n\t{\n\t\treturn cmp[n];\n\t}\n};\n\n\n#define MOD 1000000007 \n\nvector<vector<int> > v(1000);\nvector<vector<int> > rv(1000);\n\nbool check[10001];\nll dp[1111];\n\nvoid dfs(int n)\n{\n\tcheck[n] = true;\n\t\n\tif(rv[n].size() == 0)\n\t{\n\t\tdp[n] = 1;\n\t\treturn;\n\t}\n\t\n\tREP(i,rv[n].size())\n\t{\n\t\tdfs(rv[n][i]);\n\t}\n\n\tll tmpa = 1;\n\tll tmpb = 1;\t\n\tREP(i,rv[n].size())\n\t{\n\t\ttmpa = (tmpa * ((1+dp[rv[n][i]])%MOD))%MOD;\n\t}\n\tdp[n] = tmpa;\n\t\n\treturn;\n}\n\t\n\nint main()\n{\n\tint n,m;cin >> n >> m;\n\t\n\tSCC scc(n);\n\tREP(i,m)\n\t{\n\t\tint a,b;cin >> a >> b;\n\t\ta--;b--;\n\t\tscc.add_edge(a,b);\n\t}\n\t\n\tscc.reMake();\n\tscc.makeList(v);\n\tscc.makeReverseList(rv);\n\t\n\t\n\tll ans = 1;\n\tREP(i,scc.newsz)\n\t{\n\t\tif(v[i].size() == 0 && !check[i])\n\t\t{\n\t\t\tdfs(i);\n\t\t\tans = (ans * (1+dp[i]))%MOD;\n\t\t}\n\t}\t\t\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\n#define mod 100000007LL\n\n\ntemplate<typename T>\nclass UF {\npublic:\n\tUF() {\n\t\tsize = 0;\n\t}\n\n\t//???????????\\??????\n\tvoid push( T a ) {\n\t\tM[a] = size;\n\t\tV.push_back( size );\n\t\trank.push_back( 0 );\n\t\tC.push_back( 1 );\n\t\tsize++;\n\t}\n\n\t//????????°??????????????????\n\tvoid unite( T a, T b ) {\n\t\tlong long int x = find( M[a] );\n\t\tlong long int y = find( M[b] );\n\t\tif( x == y )return;\n\t\tif( rank[x] < rank[y] ) {\n\t\t\tV[x] = y;\n\t\t\tC[y] += C[x];\n\t\t} else {\n\t\t\tV[y] = x;\n\t\t\tC[x] += C[y];\n\t\t\tif( rank[x] == rank[y] )rank[x]++;\n\t\t}\n\t}\n\n\tvoid merge( T a, T b ) {\n\t\tunite( a, b );\n\t}\n\n\t//????????°??????????????????????????????????????????\n\tbool same( T a, T b ) {\n\t\treturn find( M[a] ) == find( M[b] );\n\t}\n\n\t//????????°????????????????????°?????????\n\tlong long int group() {\n\t\tset<long long int>S;\n\t\tfor( long long int i = 0; i < V.size(); i++ ) {\n\t\t\tS.insert( find( V[i] ) );\n\t\t}\n\t\treturn S.size();\n\t}\n\n\t//??°?????????????±???????????????°?????????\n\tlong long int count( T a ) {\n\t\treturn C[find( M[a] )];\n\t}\n\n\t//????±???????????????°????????????ID?????????\n\tlong long int groupID( T a ) {\n\t\treturn find( M[a] );\n\t}\n\n\t//????????°?????????????????????????????????\n\tvector<T>friendList( T a ) {\n\t\tlong long int inputID = find( M[a] );\n\t\tvector<T>ret;\n\t\tfor( auto now : M ) {\n\t\t\tif( find( now.second ) == inputID ) {\n\t\t\t\tret.emplace_back( now.first );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\nprivate:\n\tvector<long long int>C, V, rank;\n\tmap < T, long long int>M;\n\tlong long int size;\n\n\t//?\\?????????§?????????\n\tlong long int find( long long int x ) {\n\t\tif( V[x] == x )return x;\n\t\telse return V[x] = find( V[x] );\n\t}\n};\n\n\n\nint main() {\n\tlong long int N, M;\n\tcin >> N >> M;\n\tUF<long long int>uf;\n\tfor( size_t i = 0; i < N; i++ ) {\n\t\tuf.push( i );\n\t}\n\tvector<vector<long long int>>D( N );\n\tvector<vector<long long int>>F( N );\n\tfor( size_t i = 0; i < M; i++ ) {\n\t\tlong long int x, y;\n\t\tcin >> x >> y;\n\t\tx--; y--;\n\t\tD[x].push_back( y );\n\t\tF[y].push_back( x );\n\t\tuf.merge( x, y );\n\t}\n\n\tfunction<long long int( long long int )> f = [&]( long long int idx )->long long int {\n\t\t//cout << idx << endl;\n\t\tlong long int ret = 1;\n\t\tfor( auto x : F[idx] ) {\n\t\t\tret *= f( x );\n\t\t\tret %= mod;\n\t\t}\n\t\treturn ret + 1;\n\t};\n\tlong long int ans = 1;\n\tset<long long int>checked;\n\tvector<bool>checkbool( N );\n\tfor( size_t i = 0; i < N; i++ ) {\n\t\tif( !checked.count( uf.groupID( i ) ) ) {\n\t\t\tchecked.insert( uf.groupID( i ) );\n\t\t\tauto group = uf.friendList( i );\n\n\t\t\tlong long int now = i;\n\t\t\twhile( !checkbool[now] && D[now].size() ) {\n\t\t\t\tnow = D[now][0];\n\t\t\t\tcheckbool[now] = true;\n\t\t\t}\n\n\n\t\t\tif( D[now].size() ) {\n\t\t\t\tauto now_ = D[now][0];\n\t\t\t\tset<long long int>SLL;\n\t\t\t\tSLL.insert( now );\n\t\t\t\tlong long int prev;\n\t\t\t\twhile( now_ != now ) {\n\t\t\t\t\tSLL.insert( now_ );\n\t\t\t\t\tprev = now_;\n\t\t\t\t\tfor( auto x : F[now_] ) {\n\t\t\t\t\t\tif( x != prev ) {\n\t\t\t\t\t\t\tF[now].push_back( x );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnow_ = D[now_][0];\n\t\t\t\t}\n\t\t\t\tF[now].erase( remove_if( F[now].begin(), F[now].end(), [&]( auto i ) { return SLL.count( i ); } ), F[now].end() );\n\t\t\t\tnow_ = D[now][0];\n\n\t\t\t}\n\t\t\tans *= f( now );\n\t\t\tans %= mod;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n \ntypedef long long ll;\nint const inf = 1<<29;\n \nconstexpr int MOD = 1e9+7;\n \nnamespace graph { // not verified\n \nconstexpr int MaxV = 1010;\n \nstruct scc {\n \n  int V = MaxV;\n  vector<int> G[MaxV];\n  vector<int> rG[MaxV];\n  vector<int> vs;\n  vector<bool> used;\n  vector<int> comp;\n  int SCCGraphSize;\n \n  scc(): V(MaxV) { comp.resize(MaxV); }\n  scc(int V_): V(V_) { comp.resize(MaxV); }\n \n  void add_edge(int from, int to) {\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  }\n \n  void dfs(int v) {\n    used[v] = 1;\n    for(auto e: G[v]) {\n      if(!used[e]) dfs(e);\n    }\n    vs.push_back(v);\n  }\n \n  void rdfs(int v, int k) {\n    used[v] = 1;\n    comp[v] = k;\n    for(auto e: rG[v]) {\n      if(!used[e]) rdfs(e, k);\n    }\n  }\n \n  void solve() {\n    used.clear(); used.resize(MaxV);\n    vs.clear();\n    for(int i = 0; i < V; i++) {\n      if(!used[i]) dfs(i);\n    }\n    used.clear(); used.resize(MaxV);\n    int k = 0;\n    for(int i = vs.size() - 1; i >= 0; i--) {\n      if(!used[vs[i]]) rdfs(vs[i], k++);\n    }\n    SCCGraphSize = k;\n  }\n \n};\n \n}\n \nvector<vector<int>> tree;\nll dp[1010];\n \nll solve(int curr, int par) {\n  ll& ret = dp[curr];\n  if(ret + 1) return ret;\n  ret = 1;\n  for(auto e: tree[curr]) {\n    if(e == par) continue;\n    ret *= solve(e, curr);\n    ret %= MOD;\n  }\n  (ret += 1) %= MOD;\n  return ret;\n}\n \nint main() {\n \n  int N, M; cin >> N >> M;\n  graph::scc scc_graph(N);\n  rep(i, M) {\n    int S, D; cin >> S >> D; S --, D --;\n    scc_graph.add_edge(S, D);\n  }\n \n  scc_graph.solve();\n \n  auto& K = scc_graph.SCCGraphSize;\n  auto& g = scc_graph.G;\n  auto& comp = scc_graph.comp;\n \n  tree.resize(K);\n  int deg[1010] = {};\n \n  rep(i, N) {\n    for(auto e: g[i]) {\n      if(comp[i] == comp[e]) continue;\n      tree[comp[e]].push_back(comp[i]);\n      deg[comp[i]] ++;\n    }\n  }\n \n  rep(i, K) {\n    sort(tree[i].begin(), tree[i].end());\n    tree[i].erase(unique(tree[i].begin(), tree[i].end()), tree[i].end());\n  }\n \n  minus(dp);\n \n  ll ans = 1;\n \n  rep(i, K) if(deg[i] == 0 && dp[i] < 0) {\n    ans *= solve(i, -1);\n    ans %= MOD;\n  }\n \n  cout << ans << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <functional>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define whole(f, x, ...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\nusing ll = long long;\nusing namespace std;\n\nvector<vector<int> > opposite_graph(vector<vector<int> > const & g) {\n    int n = g.size();\n    vector<vector<int> > h(n);\n    repeat (i, n) for (int j : g[i]) h[j].push_back(i);\n    return h;\n}\npair<int, vector<int> > decompose_to_strongly_connected_components(vector<vector<int> > const & g, vector<vector<int> > const & g_rev) {\n    int n = g.size();\n    vector<int> acc(n); {\n        vector<bool> used(n);\n        function<void (int)> dfs = [&](int i) {\n            used[i] = true;\n            for (int j : g[i]) if (not used[j]) dfs(j);\n            acc.push_back(i);\n        };\n        repeat (i,n) if (not used[i]) dfs(i);\n        whole(reverse, acc);\n    }\n    int size = 0;\n    vector<int> component_of(n); {\n        vector<bool> used(n);\n        function<void (int)> rdfs = [&](int i) {\n            used[i] = true;\n            component_of[i] = size;\n            for (int j : g_rev[i]) if (not used[j]) rdfs(j);\n        };\n        for (int i : acc) if (not used[i]) {\n            rdfs(i);\n            ++ size;\n        }\n    }\n    return { size, move(component_of) };\n}\nvector<vector<int> > decomposed_graph(int size, vector<int> const & component_of, vector<vector<int> > const & g) {\n    int n = g.size();\n    vector<vector<int> > h(size);\n    repeat (i, n) for (int j : g[i]) {\n        if (component_of[i] != component_of[j]) {\n            h[component_of[i]].push_back(component_of[j]);\n        }\n    }\n    repeat (k, size) {\n        whole(sort, h[k]);\n        h[k].erase(whole(unique, h[k]), h[k].end());\n    }\n    return h;\n}\n\nconstexpr int mod = 1e9+7;\nint main() {\n    int n, m; scanf(\"%d%d\", &n, &m);\n    vector<vector<int> > g(n);\n    repeat (i, m) {\n        int s, d; scanf(\"%d%d\", &s, &d); -- s; -- d;\n        g[s].push_back(d);\n    }\n    int size; vector<int> component_of; tie(size, component_of) = decompose_to_strongly_connected_components(g, opposite_graph(g));\n    vector<vector<int> > h = decomposed_graph(size, component_of, g);\n    vector<vector<int> > h_rev = opposite_graph(h);\n    int result = 1;\n    function<int (int)> go = [&](int i) {\n        int acc = 1;\n        for (int j : h_rev[i]) {\n            acc = acc *(ll) go(j) % mod;\n        }\n        return acc + 1;\n    };\n    repeat (i, size) {\n        if (h[i].empty()) {\n            result = result *(ll) go(i) % mod;\n        }\n    }\n    printf(\"%d\\n\", result);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nconst int MOD=1000000007;\nint V;\nvector<int> G[1000],rG[1000];\nvector<int> vs;\nbool used[1000];\nint cmp[1000];\n\nset<int> D[1000];\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    if(!used[G[v][i]]){\n      dfs(G[v][i]);\n    }\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++){\n    int n=rG[v][i];\n    if(used[n]){\n      if(cmp[n]!=k){\n\tD[k].insert(cmp[n]);\n      }\n    }else{\n      rdfs(n,k);\n    }\n  }\n}\n\nlong long sdfs(int v){\n  used[v]=true;\n  long long r=1;\n  for(auto e:D[v]){\n    r=(r*sdfs(e))%MOD;\n  }\n  return (r+1)%MOD;\n}\n\nint main(){\n  int N,M;\n  cin>>N>>M;\n  V=N;\n  while(M--){\n    int s,d;\n    cin>>s>>d;\n    add_edge(s-1,d-1);\n  }\n  fill(begin(used),end(used),false);\n  for(int v=0;v<V;v++){\n    if(!used[v]){\n      dfs(v);\n    }\n  }\n  fill(begin(used),end(used),false);\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!used[vs[i]]){\n      rdfs(vs[i],k++);\n    }\n  }\n  fill(begin(used),end(used),false);\n  long long a=1;\n  for(int i=k-1;i>=0;i--){\n    if(!used[i]){\n      a=(a*sdfs(i))%MOD;\n    }\n  }\n  cout<<a<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n\nconst int MAXN=1100;\nconst int MAXE=2100;\n\nint node,road;\n\nstruct Edge\n{\n\tint next,to;\n};\nEdge edge[MAXE];\nint countedge;\nint head[MAXN];\n\nvoid addedge(const int& start,const int& end)\n{\n\tedge[countedge].to=end;\n\tedge[countedge].next=head[start];\n\thead[start]=countedge;\n\tcountedge++;\n}\n\nint ind;\nint dfn[MAXN],low[MAXN];\nbool instack[MAXN];\n\nint stack[MAXN];\nint top;\n\nint belong[MAXN];\nint cnt;\n\nvoid dfs(int u)\n{\n\tdfn[u]=low[u]=++ind;\n\tinstack[u]=true;\n\tstack[++top]=u;\n\t\n\tint temp,to;\n\tfor(temp=head[u];temp!=-1;temp=edge[temp].next)\n\t{\n\t\tto=edge[temp].to;\n\t\tif(!dfn[to])\n\t\t{\n\t\t\tdfs(to);\n\t\t\tlow[u]=min(low[u],low[to]);\n\t\t}\n\t\telse if(instack[to])\n\t\t{\n\t\t\tlow[u]=min(low[u],dfn[to]);\n\t\t}\n\t}\n\t\n\tif(dfn[u]==low[u])\n\t{\n\t\tcnt++;\n\t\tdo\n\t\t{\n\t\t\tto=stack[top--];\n\t\t\tinstack[to]=false;\n\t\t\tbelong[to]=cnt;\n\t\t}\n\t\twhile(to!=u);\n\t}\n}\n\n//譛牙?荳ェ霑樣?蝮?\nint val[MAXN];\nint totalval;\n\nvoid solve()\n{\n\ttop=ind=cnt=0;//cnt?夂シゥ螳悟錘逧?せ謨ー \n\tint i;\n\tmemset(dfn,0,sizeof(dfn));\n\tmemset(low,0,sizeof(low));\n\tfor(i=1;i<=node;i++)\n\t{\n\t\tif(!dfn[i])dfs(i);\n\t}\n}\n\nint s[MAXE],e[MAXE];\nbool map[MAXN][MAXN];\nint height[MAXN];\nint in[MAXN];\n\nint que[MAXN];\nint front,rear;\nint cal[MAXN][MAXN];\n\nbool vis[MAXN];\nvoid Bfs(int ind)\n{\n\tint i;\n\tint u;\n\twhile(front<rear)\n\t{\n\t\tu=que[front++];\n\t\tfor(i=1;i<=cnt;i++)\n\t\t{\n\t\t\tif(map[u][i]&&!vis[i])\n\t\t\t{\n\t\t\t\tvis[i]=true;\n\t\t\t\tque[rear++]=i;\n\t\t\t\theight[i]=height[u]+1;\n\t\t\t\tcal[ind][height[i]]++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long pow2[1100];\n\nint main()\n{\n\tpow2[0]=1;\n\tint i,j;\n\tfor(i=1;i<=1000;i++)\n\t{\n\t\tpow2[i]=2*pow2[i-1]%1000000007;\n\t}\n\t\n\tscanf(\"%d%d\",&node,&road);\n\t\n\t\n\tcountedge=0;\n\tmemset(head,-1,sizeof(head));\n\tmemset(belong,-1,sizeof(belong));\n\t\n\tfor(i=0;i<road;i++)\n\t{\n\t\tscanf(\"%d%d\",&s[i],&e[i]);\n\t\taddedge(s[i],e[i]);\n\t}\n\tsolve();\n\t//printf(\"cnt:%d\\n\",cnt);\n\t\n\tint from,to;\n\ttotalval=0;\n\tfor(i=0;i<road;i++)\n\t{\n\t\tfrom=belong[s[i]];\n\t\tto=belong[e[i]];\n\t\tif(from==to)continue;\n\t\tin[to]++;\n\t\tmap[from][to]=true;\n\t\tif(val[from]==0&&val[to]==0)\n\t\t{\n\t\t\ttotalval++;\n\t\t\tval[from]=val[to]=totalval;\n\t\t}\n\t\telse if(val[from]==0)val[from]=val[to];\n\t\telse if(val[to]==0)val[to]=val[from];\n\t}\n\tfor(i=1;i<=cnt;i++)\n\t{\n\t\tif(!val[belong[i]])\n\t\t{\n\t\t\ttotalval++;\n\t\t\tval[belong[i]]=totalval;\n\t\t}\n\t}\n\t/*\n\tfor(i=1;i<=cnt;i++)\n\t{\n\t\tprintf(\"%d %d\\n\",val[i],in[i]);\n\t}\n\tprintf(\"\\n\");*/\n\t\n\t//printf(\"totalval:%d\\n\",totalval); \n\t\n\tlong long ret=1;\n\tfor(i=1;i<=totalval;i++)\n\t{\n\t\tlong long temp=0;\n\t\tfront=rear=0;\n\t\tfor(j=1;j<=cnt;j++)\n\t\t{\n\t\t\tif(in[j]==0&&val[j]==i)\n\t\t\t{\n\t\t\t\t//隨ャi荳ェ霑樣?蝮?\n\t\t\t\tcal[i][1]++;\n\t\t\t\theight[j]=1;\n\t\t\t\tque[rear++]=j;\n\t\t\t}\n\t\t}\n\t\tBfs(i);\n\t\tj=1;\n\t\twhile(cal[i][j])\n\t\t{\n\t\t\t//printf(\"%d %d %d\\n\",i,j,cal[i][j]);\n\t\t\tif(j>1)temp+=pow2[cal[i][j]-1];\n\t\t\telse temp+=pow2[cal[i][j]];\n\t\t\ttemp%=1000000007;\n\t\t\tj++;\n\t\t}\n\t\tret*=temp;\n\t\tret%=1000000007;\n\t}\n\t\n\tprintf(\"%lld\\n\",ret);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstruct SCC{\n  int V;\n  vector<vector<int> > G,rG;\n  vector<int> vs,used,cmp;\n  SCC(){}\n  SCC(int sz):V(sz),G(sz),rG(sz),used(sz),cmp(sz){}\n  void add(int from,int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  } \n  void dfs(int v){\n    used[v]=1;\n    for(int i=0;i<G[v].size();i++)\n      if(!used[G[v][i]])dfs(G[v][i]);\n    vs.push_back(v);\n  }\n  void rdfs(int v,int k){\n    used[v]=1;\n    cmp[v]=k;\n    for(int i=0;i<rG[v].size();i++)\n      if(!used[rG[v][i]])rdfs(rG[v][i],k);\n  }\n  int build(){\n    fill(used.begin(),used.end(),0);\n    vs.clear();\n    for(int v=0;v<V;v++)\n      if(!used[v])dfs(v);\n    fill(used.begin(),used.end(),0);\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--)\n      if(!used[vs[i]])rdfs(vs[i],k++);\n    return k;\n  }\n  int be(int x){\n    return cmp[x];\n  }\n  bool same(int x,int y){\n    return cmp[x]==cmp[y];\n  }\n};\n\n\n// 連結成分分解　（連結成分ごとにグラフを再構築、Sはグラフの集合）\nstruct CC{\n  int n;\n  vector<vector<int> >G,rG;\n  vector<int>used;\n  vector<vector<vector<int> > >S;\n  CC(int sz):n(sz),G(sz),rG(sz),used(sz){}\n  void add(int from,int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  }\n  void CC_dfs1(int x,int &cnt,map<int,int>& m){\n    m[x]=cnt++;\n    used[x]=1;\n    for(int i=0;i<G[x].size();i++){\n      if(used[G[x][i]])continue;\n      CC_dfs1(G[x][i],cnt,m);\n    }\n    for(int i=0;i<rG[x].size();i++){\n      if(used[rG[x][i]])continue;\n      CC_dfs1(rG[x][i],cnt,m);\n    }\n  }\n  void CC_dfs2(int x,vector<vector<int> > &v,map<int,int>& m,vector<int> &vis){\n    vis[m[x]]=1;\n    for(int i=0;i<G[x].size();i++){\n      v[m[x]].push_back(m[G[x][i]]);\n      if(vis[m[G[x][i]]])continue;\n      CC_dfs2(G[x][i],v,m,vis);\n    }\n    for(int i=0;i<rG[x].size();i++){\n      if(vis[m[rG[x][i]]])continue;\n      CC_dfs2(rG[x][i],v,m,vis);\n    }\n  }\n  void build(){\n    for(int i=0;i<n;i++)used[i]=0;\n    for(int i=0;i<n;i++){\n      if(used[i])continue;\n      int cnt=0;\n      map<int,int>M;\n      CC_dfs1(i,cnt,M);\n      vector<vector<int> >v(cnt);\n      vector<int>U(cnt,0);\n      CC_dfs2(i,v,M,U);\n      S.push_back(v);\n    }\n  }\n};\nint mod=1000000007;\nint n,m,a[10002],b[10002];\nint dp[1002][2];\nsigned main(){\n  set<int>st;\n  cin>>n>>m;\n  CC C(n);\n  r(i,m){\n    cin>>b[i]>>a[i];\n    b[i]--;a[i]--;\n    st.insert(b[i]);\n    st.insert(a[i]);\n    C.add(b[i],a[i]);\n  }\n  C.build();\n  int ans=1,sum=0;\n  for(int i=0;i<C.S.size();i++){\n    memset(dp,0,sizeof(dp));\n    vector<vector<int> >A=C.S[i];\n    int N=A.size();\n    SCC S(N);\n    r(i,N){\n      r(j,A[i].size()){\n        S.add(i,A[i][j]);\n      }\n    }\n    S.build();\n    set<int>SS;\n    int c=0;\n    for(int j=N-1;j>=0;j--){  // ここに連結成分無いのDPをかく\n      int x=S.vs[j];\n      SS.insert(S.cmp[x]);\n      //cout<<S.rG[x].size()<<endl;\n      if(S.rG[x].size()==0){\n        dp[x][0]=dp[x][1]=1;c++;//cout<<\"a\"<<j<<endl;\n      }\n      else{\n        dp[x][0]=dp[x][1]=1;\n        for(int k=0;k<S.rG[x].size();k++){\n          int to=S.rG[x][k];\n          if(S.same(x,to)){\n            //dp[to][0]=dp[x][0];\n            //dp[to][1]=dp[x][1];\n          }\n          else{//cout<<to<<endl;\n            dp[x][1]*=dp[to][0]+dp[to][1];\n            dp[x][0]*=dp[to][0];\n            dp[x][1]%=mod;\n            //cout<<dp[to][1]<<' '<<dp[to][0]<<endl;\n          }\n        }\n      } \n      int X=1;\n      if(j==0){\n        if(c==0){\n          ans*=2;\n          ans%=mod;\n          break;\n        }\n        r(k,N){\n          int K=S.vs[k];\n          if(S.same(x,K)){\n            //X+=dp[K][0];\n            X*=dp[K][1];\n           // cout<<X<<endl;\n          }\n        }\n        X++;\n        X%=mod;\n        //cout<<X<<endl;\n        ans*=X;\n        ans%=mod;\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 1000;\nconst int MAX_M = 1000;\n\nconst long long MOD = 1000000007;\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef set<int> si;\ntypedef long long ll;\n\n/* global variables */\n\nint n, m, nsc;\nint scc[MAX_N];\nvi nbrs[MAX_N], rnbrs[MAX_N];\nsi srnbrs[MAX_N];\nbool used[MAX_N], roots[MAX_N];\nstack<int> st;\nll dp[MAX_N][2];\n\n/* subroutines */\n\nvoid dfs0(int u) {\n  used[u] = true;\n  vi& nbru = nbrs[u];\n  for (vi::iterator vit = nbru.begin(); vit != nbru.end(); vit++)\n    if (! used[*vit]) dfs0(*vit);\n  st.push(u);\n}\n\nvoid dfs1(int u) {\n  used[u] = true;\n  scc[u] = nsc;\n  vi& rnbru = rnbrs[u];\n  for (vi::iterator vit = rnbru.begin(); vit != rnbru.end(); vit++)\n    if (! used[*vit]) dfs1(*vit);\n}\n\nvoid dfs2(int u) {\n  dp[u][0] = dp[u][1] = 1;\n  si& srnbr = srnbrs[u];\n\n  for (si::iterator vit = srnbr.begin(); vit != srnbr.end(); vit++) {\n    int v = *vit;\n    roots[v] = false;\n    if (dp[v][0] < 0) dfs2(v);\n\n    dp[u][0] = (dp[u][0] * (dp[v][0] + dp[v][1])) % MOD;\n    dp[u][1] = (dp[u][1] * dp[v][1]) % MOD;\n  }\n}\n\n/* main */\n\nint main() {\n  cin >> n >> m;\n\n  for (int i = 0; i < m; i++) {\n    int s, d;\n    cin >> s >> d;\n    s--, d--;\n    nbrs[s].push_back(d);\n    rnbrs[d].push_back(s);\n  }\n\n  memset(used, false, sizeof(used));\n  \n  for (int u = 0; u < n; u++)\n    if (! used[u]) dfs0(u);\n\n  memset(used, false, sizeof(used));\n  nsc = 0;\n\n  while (! st.empty()) {\n    int u = st.top(); st.pop();\n    if (! used[u]) {\n      dfs1(u);\n      nsc++;\n    }\n  }\n  //cout << nsc << endl;\n  //for (int i = 0; i < n; i++) printf(\"%d \", scc[i]); putchar ('\\n');\n\n  for (int u = 0; u < n; u++) {\n    si& srnbr = srnbrs[scc[u]];\n    vi& rnbru = rnbrs[u];\n    for (vi::iterator vit = rnbru.begin(); vit != rnbru.end(); vit++) {\n      int v = scc[*vit];\n      if (v != scc[u]) srnbr.insert(v);\n    }\n  }\n\n  for (int u = 0; false && u < nsc; u++) {\n    printf(\"srnbrs[%d]:\", u);\n    for (si::iterator vit = srnbrs[u].begin(); vit != srnbrs[u].end(); vit++)\n      printf(\" %d\", *vit);\n    putchar('\\n');\n  }\n\n    memset(roots, true, sizeof(roots));\n  memset(dp, -1, sizeof(dp));\n\n  for (int u = 0; u < nsc; u++)\n    if (dp[u][0] < 0) dfs2(u);\n\n  ll d = 1;\n  for (int u = 0; u < nsc; u++) {\n    //printf(\"dp[%d] = %lld,%lld\\n\", u, dp[u][0], dp[u][1]);\n    if (roots[u]) d = (d * (dp[u][0] + dp[u][1])) % MOD;\n  }\n\n  cout << d << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define ef emplace_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = std::uint32_t;\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing ld = long double;\n\ntemplate<typename T, size_t H, size_t W>\nusing matrix = std::array<std::array<T, W>, H>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nconst int dy[] = {0, -1, 0, 1, -1, 1, -1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline void chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(all(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(all(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ sort(c); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n\nint n, m;\nint s[1000], d[1000];\nvector<int> g[1000], rg[1000];\nint cmp[1000];\nbool used[1000];\nvector<int> vs;\nvector<int> h[1000];\nint dp[1000];\n\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor (int to : g[v]){\n\t\tif (!used[to]) dfs(to);\n\t}\n\tvs.pb(v);\n}\n\nvoid rdfs(int v, int k)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rg[v]){\n\t\tif (!used[to]) rdfs(to, k);\n\t}\n}\n\nint scc()\n{\n\tmemset(used, 0, sizeof(used));\n\trep(i, n){\n\t\tif (!used[i]) dfs(i);\n\t}\n\n\tmemset(used, 0, sizeof(used));\n\tint k = 0;\n\trrep(i, n){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++);\n\t}\n\n\treturn k;\n}\n\nint main()\n{\n\tcin >> n >> m;\n\trep(i, m){\n\t\tcin >> s[i] >> d[i], s[i]--, d[i]--;\n\t\tg[s[i]].pb(d[i]);\n\t\trg[d[i]].pb(s[i]);\n\t}\n\t\n\tint c = scc();\n\t\n\trep(i, n){\n\t\tif (cmp[s[i]] == cmp[d[i]]) continue;\n\t\tassert(cmp[s[i]] < cmp[d[i]]);\n\t\th[cmp[s[i]]].pb(cmp[d[i]]);\n\t}\n\n\trep(i, c) unique(h[i]);\n\t\n\tint res = 1;\n\trep(i, c) dp[i] = 1;\n\trep(i, c){\n\t\tif (h[i].empty()){\n\t\t\tres = (ll)res * (1 + dp[i]) % MOD;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int j : h[i]){\n\t\t\tdp[j] = (ll)dp[j] * (1 + dp[i]) % MOD;\n\t\t}\n\t}\n\t\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<n;++i)\n#define FOR(i, a, b) for(int i=a;i<b;++i)\n#define RREP(i, n) for(int i=n-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=b-1;i>=a;--i)\n\n#define all(x) begin(x),end(x)\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\n// edit\nclass Mint {\n    using u64 = std::uint_fast64_t;\n    u64 Modulus = MOD;\n\npublic:\n    u64 a;\n\n    constexpr Mint(const u64 x = 0) noexcept : a(x % Modulus) {}\n\n    constexpr u64 &value() noexcept { return a; }\n\n    constexpr const u64 &value() const noexcept { return a; }\n\n    constexpr Mint operator+(const Mint rhs) const noexcept {\n        return Mint(*this) += rhs;\n    }\n\n    constexpr Mint operator-(const Mint rhs) const noexcept {\n        return Mint(*this) -= rhs;\n    }\n\n    constexpr Mint operator*(const Mint rhs) const noexcept {\n        return Mint(*this) *= rhs;\n    }\n\n    constexpr Mint operator/(const Mint rhs) const noexcept {\n        return Mint(*this) /= rhs;\n    }\n\n    constexpr Mint &operator+=(const Mint rhs) noexcept {\n        a += rhs.a;\n        if (a >= Modulus) {\n            a -= Modulus;\n        }\n        return *this;\n    }\n\n    constexpr Mint &operator-=(const Mint rhs) noexcept {\n        if (a < rhs.a) {\n            a += Modulus;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n\n    constexpr Mint &operator*=(const Mint rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n\n    constexpr Mint &operator/=(Mint rhs) noexcept {\n        u64 exp = Modulus - 2;\n        while (exp) {\n            if (exp % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            exp /= 2;\n        }\n        return *this;\n    }\n\n    constexpr Mint &pow(int rhs) noexcept {\n        u64 exp = static_cast<u64>(rhs);\n        Mint base(a);\n        a = 1;\n        while (exp) {\n            if (exp % 2) {\n                *this *= base;\n            }\n            base *= base;\n            exp /= 2;\n        }\n        return *this;\n    }\n\n};\n\nostream &operator<<(ostream &os, Mint x) {\n    os << x.value();\n    return os;\n}\n\n\nstruct SCC {\n    int V;\n    vector<vector<int> > G;//グラフの隣接リスト表現\n    vector<vector<int> > rG;//変の向きを逆にしたグラフ\n    vector<int> vs;//帰りがけ順の並び\n    vector<bool> used;//既に調べたか\n    vector<int> cmp;//属する共連結成分のトポロジカル順序\n\n    SCC(int v) {\n        V = v;\n        G.resize(V);\n        rG.resize(V);\n        used.resize(V);\n        cmp.resize(V);\n    }\n\n    /**\n     * 辺を貼る\n     * @param from 辺の元\n     * @param to 辺の先\n     */\n    void add_edge(int from, int to) {\n        G[from].push_back(to);\n        rG[to].push_back(from);\n    }\n\n    void dfs(int v) {\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); i++) {\n            if (!used[G[v][i]]) dfs(G[v][i]);\n        }\n        vs.push_back(v);\n    }\n\n\n    void rdfs(int v, int k) {\n        used[v] = true;\n        cmp[v] = k;\n        for (int i = 0; i < rG[v].size(); i++) {\n            if (!used[rG[v][i]]) rdfs(rG[v][i], k);\n        }\n    }\n\n    int scc() {\n        fill(used.begin(), used.end(), false);\n        vs.clear();\n        for (int v = 0; v < V; v++) {\n            if (!used[v]) dfs(v);\n        }\n        fill(used.begin(), used.end(), false);\n        int k = 0;\n        for (int i = vs.size() - 1; i >= 0; i--) {\n            if (!used[vs[i]]) rdfs(vs[i], k++);\n        }\n        return k;\n    }\n};\n\n\nvector<vector<int>> G;\nvector<vector<int>> rG;\nvector<bool> visited;\n\nMint dfs(int v) {\n    if (rG[v].empty()) return Mint(2);\n\n    Mint ret = 1;\n    for (auto e : rG[v]) {\n        ret *= dfs(e);\n    }\n    ret += 1;\n\n    return ret;\n}\n\nvoid solve() {\n    int N, M;\n    cin >> N >> M;\n    SCC scc(N);\n    REP(i, M) {\n        int s, d;\n        cin >> s >> d;\n        s--, d--;\n        scc.add_edge(s, d);\n    }\n\n    int k = scc.scc();\n    G.resize(k);\n    rG.resize(k);\n    visited.resize(k, false);\n\n    set<pair<int, int>> used;\n\n    for (int i = 0; i < N; ++i) {\n        int ci = scc.cmp[i];\n        for (auto e : scc.G[i]) {\n            int j = e;\n            int cj = scc.cmp[j];\n            if (used.count(make_pair(ci, cj))) {\n                continue;\n            }\n            if (ci == cj) continue;\n\n            used.insert(make_pair(ci, cj));\n            G[ci].push_back(cj);\n            rG[cj].push_back(ci);\n        }\n    }\n\n    Mint ans = 1;\n    REP(i, k) {\n//        if (visited[i]) continue;\n        if (G[i].size() > 0) continue;\n//        visited[i] = true;\n        Mint tmp = dfs(i);\n        ans *= tmp;\n    }\n\n    cout << ans << endl;\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n//    std::ifstream in(\"input.txt\");\n//    std::cin.rdbuf(in.rdbuf());\n\n    solve();\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\n#include <vector>\n#include <queue>\n#include <stack>;\n#define mod 1000000007\n#define INF 10000\nusing namespace std;\nvestor <int>point[100000];\nstruct brige\n{\n  int str,end;\n};\nvector <brige> a[1000000];\nint end;\nint n;\nint lead[1000000];\nint level[1000000];\nint queue[1000000];\nint size;\nvector <int> qus[1000000][2];\nstack <int>zhan[2];\nint dfs(int now,int Lev)\n{\n   if(level[now]>Lev)\n   {\n       end=now;\n       return 0;\n   }\n      return 1;\n   level[now]=Lev;\n   queue[size++]=Lve;\n   for(int i=0;i<point[now].size();i++)\n    if(level[point[now][i]]!=Lev)\n     if(dfs(point[now][i],Lev))\n       return 1;\n   size--;\n   level[now]=0;\n   return 0;\n}\nvoid restrat(int n)\n{\n  size=0;\n  for(int i=0;i<=n;i++)\n  {\n    level[i]=0;\n    a[i].clear();\n    qus[i][0].clear();\n    qus[i][1].claer();\n    point[i].clear();\n  }\n}\nint main()\n{\n    while(cin>>n)\n    {\n    int k;\n    for(int i=0;i<n;i++)\n    {\n      int u,v;\n      cin>>u>>v;\n      point[u].push_back(v);\n      point[v].push_back(u);\n    }\n    level[1]=n+1;\n    level[2]=n+1;\n    for(int i=1;i<=n;i++)\n    if(level[i] && dfs(i,n-i+1))\n    {\n      zhan[0].clear();\n      zhan[1].clear();\n      zhan[0].push(i);\n      zhan[1].push(i);\n      for(int j=0;j<size;j++)\n       {\n         int mi=queue[j];\n          while(zhan[0].size()>1 && zhan[0].top<queue[j])\n           {  \n              mi=min(zhan[1].top(),mi); \n              zhan[0].pop();\n              zhan[1].pop();\n           }\n           mi=min(zhan[1].top(),mi);\n           zhan[1],pop();\n           zhan[1].push(mi);\n           brige u;\n           u.str=queue[j];\n           u.end=zhan[0].top();\n           a[mi].push(u);\n           zhan[0].push(queue[j]);\n           zhan[1].push(queue[j]);\n       }\n      zhan[0].clear();\n      zhan[1].clear();\n      zhan[0].push(end);\n      zhan[1].push(end);\n      for(int j=size-1;j>=0;j--)\n       {\n         int mi=queue[j];\n          while(zhan[0].size()>1 && zhan[0].top<queue[j])\n           {  \n              mi=min(zhan[1].top(),mi); \n              zhan[0].pop();\n              zhan[1].pop();\n           }\n           mi=min(zhan[1].top(),mi);\n           zhan[1],pop();\n           zhan[1].push(mi);\n           brige u;\n           u.str=queue[j];\n           u.end=zhan[0].top();\n           a[mi].push(u);\n           zhan[0].push(queue[j]);\n           zhan[1].push(queue[j]);\n       }\n      size=0;\n    }\n    cin>>k;\n    for(int i=0;i<k;i++)\n    {\n       int l,r;\n       cin>>l>>r;\n       qus[l][0].push_back(r);\n       qus[l][1].push_back(i);\n    } \n    int ans[100000];\n    for(int i=n;i>1;i--)\n    {\n       add(i,n,1);\n       lead[i]=n+1;\n       for(int j=0;j<a[i].size();i++)\n       if(a[i].end<lead[a[i].str])\n       {\n          add(a[i].str,lead[a[i].str]-1,-1); \n          lead[a[i].str]=0;\n          if(a[i].end>a[i].str)\n          {\n          add(a[i].str,a[i].end,-1);  \n          lead[a[i].str]=a[i].end;\n          }\n       }\n       for(int j=0;j<que[i][0].size();j++)\n       ans[que[i][1][j]]=find(que[i][0][j]);\n    }  \n    for(int i=0;i<k;i++)\n     cout<<ans[i]<<\" \";\n    cout<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n \ntypedef long long ll;\nint const inf = 1<<29;\n \nconstexpr int MOD = 1e9+7;\n \nnamespace graph { // not verified\n \nconstexpr int MaxV = 1010;\n \nstruct scc {\n \n  int V = MaxV;\n  vector<int> G[MaxV];\n  vector<int> rG[MaxV];\n  vector<int> vs;\n  vector<bool> used;\n  vector<int> comp;\n  int SCCGraphSize;\n \n  scc(): V(MaxV) { comp.resize(MaxV); }\n  scc(int V_): V(V_) { comp.resize(MaxV); }\n \n  void add_edge(int from, int to) {\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  }\n \n  void dfs(int v) {\n    used[v] = 1;\n    for(auto e: G[v]) {\n      if(!used[e]) dfs(e);\n    }\n    vs.push_back(v);\n  }\n \n  void rdfs(int v, int k) {\n    used[v] = 1;\n    comp[v] = k;\n    for(auto e: rG[v]) {\n      if(!used[e]) rdfs(e, k);\n    }\n  }\n \n  void solve() {\n    used.clear(); used.resize(MaxV);\n    vs.clear();\n    for(int i = 0; i < V; i++) {\n      if(!used[i]) dfs(i);\n    }\n    used.clear(); used.resize(MaxV);\n    int k = 0;\n    for(int i = vs.size() - 1; i >= 0; i--) {\n      if(!used[vs[i]]) rdfs(vs[i], k++);\n    }\n    SCCGraphSize = k;\n  }\n \n};\n \n}\n \nvector<vector<int>> tree;\n \nll solve(int curr, int par) {\n  ret = 1;\n  for(auto e: tree[curr]) {\n    if(e == par) continue;\n    ret *= solve(e, curr);\n    ret %= MOD;\n  }\n  return ret;\n}\n \nint main() {\n \n  int N, M; cin >> N >> M;\n  graph::scc scc_graph(N);\n  rep(i, M) {\n    int S, D; cin >> S >> D; S --, D --;\n    scc_graph.add_edge(S, D);\n  }\n \n  scc_graph.solve();\n \n  auto& K = scc_graph.SCCGraphSize;\n  auto& g = scc_graph.G;\n  auto& comp = scc_graph.comp;\n \n  tree.resize(K);\n  int deg[1010] = {};\n \n  rep(i, N) {\n    for(auto e: g[i]) {\n      if(comp[i] == comp[e]) continue;\n      tree[comp[e]].push_back(comp[i]);\n      deg[comp[i]] ++;\n    }\n  }\n \n  rep(i, K) {\n    sort(tree[i].begin(), tree[i].end());\n    tree[i].erase(unique(tree[i].begin(), tree[i].end()), tree[i].end());\n  }\n \n  ll ans = 1;\n \n  rep(i, K) if(deg[i] == 0 && dp[i] < 0) {\n    ans *= solve(i, -1);\n    ans %= MOD;\n  }\n \n  cout << ans << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstruct SCC{\n  int V;\n  vector<vector<int> > G,rG;\n  vector<int> vs,used,cmp;\n  SCC(){}\n  SCC(int sz):V(sz),G(sz),rG(sz),used(sz),cmp(sz){}\n  void add(int from,int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  } \n  void dfs(int v){\n    used[v]=1;\n    for(int i=0;i<G[v].size();i++)\n      if(!used[G[v][i]])dfs(G[v][i]);\n    vs.push_back(v);\n  }\n  void rdfs(int v,int k){\n    used[v]=1;\n    cmp[v]=k;\n    for(int i=0;i<rG[v].size();i++)\n      if(!used[rG[v][i]])rdfs(rG[v][i],k);\n  }\n  int build(){\n    fill(used.begin(),used.end(),0);\n    vs.clear();\n    for(int v=0;v<V;v++)\n      if(!used[v])dfs(v);\n    fill(used.begin(),used.end(),0);\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--)\n      if(!used[vs[i]])rdfs(vs[i],k++);\n    return k;\n  }\n  int be(int x){\n    return cmp[x];\n  }\n  bool same(int x,int y){\n    return cmp[x]==cmp[y];\n  }\n};\n\n\n// 連結成分分解　（連結成分ごとにグラフを再構築、Sはグラフの集合）\nstruct CC{\n  int n;\n  vector<vector<int> >G,rG;\n  vector<int>used;\n  vector<vector<vector<int> > >S;\n  CC(int sz):n(sz),G(sz),rG(sz),used(sz){}\n  void add(int from,int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  }\n  void CC_dfs1(int x,int &cnt,map<int,int>& m){\n    m[x]=cnt++;\n    used[x]=1;\n    for(int i=0;i<G[x].size();i++){\n      if(used[G[x][i]])continue;\n      CC_dfs1(G[x][i],cnt,m);\n    }\n    for(int i=0;i<rG[x].size();i++){\n      if(used[rG[x][i]])continue;\n      CC_dfs1(rG[x][i],cnt,m);\n    }\n  }\n  void CC_dfs2(int x,vector<vector<int> > &v,map<int,int>& m,vector<int> &vis){\n    vis[m[x]]=1;\n    for(int i=0;i<G[x].size();i++){\n      v[m[x]].push_back(m[G[x][i]]);\n      if(vis[m[G[x][i]]])continue;\n      CC_dfs2(G[x][i],v,m,vis);\n    }\n    for(int i=0;i<rG[x].size();i++){\n      if(vis[m[rG[x][i]]])continue;\n      CC_dfs2(rG[x][i],v,m,vis);\n    }\n  }\n  void build(){\n    for(int i=0;i<n;i++)used[i]=0;\n    for(int i=0;i<n;i++){\n      if(used[i])continue;\n      int cnt=0;\n      map<int,int>M;\n      CC_dfs1(i,cnt,M);\n      vector<vector<int> >v(cnt);\n      vector<int>U(cnt,0);\n      CC_dfs2(i,v,M,U);\n      S.push_back(v);\n    }\n  }\n};\nint mod=1000000007;\nint n,m,a[10002],b[10002];\nint dp[1002][2];\nsigned main(){\n  set<int>st;\n  cin>>n>>m;\n  CC C(n);\n  r(i,m){\n    cin>>b[i]>>a[i];\n    b[i]--;a[i]--;\n    st.insert(b[i]);\n    st.insert(a[i]);\n    C.add(b[i],a[i]);\n  }\n  C.build();\n  int ans=1,sum=0;\n  for(int i=0;i<C.S.size();i++){\n    memset(dp,0,sizeof(dp));\n    vector<vector<int> >A=C.S[i];\n    int N=A.size();\n    SCC S(N);\n    r(i,N){\n      r(j,A[i].size()){\n        S.add(i,A[i][j]);\n      }\n    }\n    S.build();\n    set<int>SS;\n    for(int j=N-1;j>=0;j--){  // ここに連結成分無いのDPをかく\n      int x=S.vs[j];\n      SS.insert(S.cmp[x]);\n      if(dp[x][0]==0&&dp[x][1]==0){\n        dp[x][0]=dp[x][1]=1;\n      }\n      for(int k=0;k<S.G[x].size();k++){\n        int to=S.G[x][k];\n        if(S.same(x,to)){\n          dp[to][0]=dp[x][0];\n          dp[to][1]=dp[x][1];\n        }\n        else{\n          dp[to][0]+=dp[x][0];\n          dp[to][1]+=dp[x][0];\n          dp[to][1]+=dp[x][1];\n        }\n      }\n    }\n    int X=0;\n    for(int j=N-1;j>=0;j--){\n      int x=S.vs[j];\n      if(S.rG[x].size()==0){\n        X+=dp[x][0];\n        X+=dp[x][1];\n      }\n    }\n    /*cout<<N<<endl;\n    r(j,N){\n      cout<<S.G[j].size()<<endl;\n      cout<<dp[j][0]<<' '<<dp[j][1]<<endl;\n    }cout<<endl;*/\n    if(!X)X+=2;\n    if(SS.size()>1)X++;\n    X%=mod;\n    ans*=X;\n    ans%=mod;\n    //cout<<X<<endl;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <numeric>\nusing namespace std;\n\ntypedef long long LL;\nconst LL MOD = 1000000007;\n\nvector<vector<int> > G, rG;\nvector<int> vs;\nvector<char> used;\nvector<int> cmp;\nvector<vector<char> > con;\n\nvoid add_edge(int f, int t){\n\tG[f].push_back(t);\n\trG[t].push_back(f);\n}\n\nvoid dfs(int v){\n\tused[v] = 1;\n\tfor(size_t i = 0; i < G[v].size(); ++i){\n\t\tif(!used[G[v][i]]){\n\t\t\tdfs(G[v][i]);\n\t\t}\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n\tused[v] = 1;\n\tcmp[v] = k;\n\tfor(size_t i = 0; i < rG[v].size(); ++i){\n\t\tif(!used[rG[v][i]]){\n\t\t\trdfs(rG[v][i], k);\n\t\t}\n\t}\n}\n\nint scc(){\n\tused.assign(G.size(), 0);\n\tcmp.assign(G.size(), 0);\n\tvs.clear();\n\tfor(size_t v = 0; v < G.size(); ++v){\n\t\tif(!used[v]){\n\t\t\tdfs(v);\n\t\t}\n\t}\n\tused.assign(G.size(), 0);\n\tint k = 0;\n\tfor(size_t i = vs.size(); i--; ){\n\t\tif(!used[vs[i]]){\n\t\t\trdfs(vs[i], k);\n\t\t\t++k;\n\t\t}\n\t}\n\treturn k;\n}\n\nLL solve(int u){\n\tLL res = 1;\n\tfor(size_t v = 0; v < con.size(); ++v){\n\t\tif(con[v][u]){\n\t\t\tLL ret = solve(v);\n\t\t\tres = res * ret % MOD;\n\t\t}\n\t}\n\t++res;\n\treturn res;\n}\n\nint main(){\n\tint n, m, s, d;\n\tscanf(\"%d%d\", &n, &m);\n\tG.resize(n);\n\trG.resize(n);\n\tfor(int i = 0; i < m; ++i){\n\t\tscanf(\"%d%d\", &s, &d);\n\t\tadd_edge(s - 1, d - 1);\n\t}\n\t\n\tint c = scc();\n\tcon.assign(c, vector<char>(c));\n\tfor(int i = 0; i < n; ++i)\n\tfor(size_t j = 0; j < G[i].size(); ++j){\n\t\tcon[cmp[i]][cmp[G[i][j]]] = 1;\n\t}\n\tfor(int i = 0; i < c; ++i){\n\t\tcon[i][i] = 0;\n\t}\n\n\tLL ans = 1;\n\tfor(int i = 0; i < c; ++i){\n\t\tint cnt = accumulate(con[i].begin(), con[i].end(), 0);\n\t\tif(!cnt){\n\t\t\tLL ret = solve(i);\n\t\t\tans = ans * ret % MOD;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 1002;\n\nint n,m;\nvector<int> G[MAX_N];\nvector<int> rG[MAX_N];\nvector<int> vs; //??°?????????????????????\nbool used[MAX_N]; //?????§????????????????????????\nint cmp[MAX_N];\t//?±????????????£????????????????????????????????????\nvector<int> GG[MAX_N];\nvector<int> rGG[MAX_N];\nbool flag[MAX_N];\nvector<ll> ts;\nll dp[MAX_N];\n\nvoid add_edge(int from,int to)\n{\n\tG[from].push_back(to);\n\trG[to].push_back(from);\n}\n\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!used[G[v][i]]){\n\t\t\tdfs(G[v][i]);\n\t\t}\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v,int k)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor(int i=0;i<rG[v].size();i++){\n\t\tif(!used[rG[v][i]]){\n\t\t\trdfs(rG[v][i],k);\n\t\t}\n\t}\n}\n\nint scc(int n,int m)\t//?????£??????????????°?????????\n{\n\tfill(used,used+n,0);\n\tvs.clear();\n\tfor(int v=0;v<n;v++){\n\t\tif(!used[v]){\n\t\t\tdfs(v);\n\t\t}\n\t}\n\tfill(used,used+n,0);\n\tint k=0;\n\tfor(int i=vs.size()-1;i>=0;i--){\n\t\tif(!used[vs[i]]){\n\t\t\trdfs(vs[i],k++);\n\t\t}\n\t}\n\treturn k;\n}\n\nvoid rdfsdp(int u)\n{\n    flag[u] = true;\n    if(rGG[u].size() == 0){\n        dp[u] = 1;\n        return;\n    }\n    ll hoge = 1;\n    rep(i,rGG[u].size()){\n        rdfsdp(rGG[u][i]);\n        hoge = (hoge*(dp[rGG[u][i]]+1)) % MOD;\n    }\n    dp[u] = hoge;\n    return;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,m){\n\t\tint a,b;\n        scanf(\"%d%d\",&a,&b);\n        add_edge(a-1,b-1);\n\t}\n    int cnt = scc(n,m);\n    rep(i,n){\n        rep(j,G[i].size()){\n            if(cmp[i] != cmp[G[i][j]]){\n                GG[cmp[i]].push_back(cmp[G[i][j]]);\n                rGG[cmp[G[i][j]]].push_back(cmp[i]);\n            }\n        }\n    }\n    rep(i,cnt){\n        flag[i] = false;\n    }\n    rep(i,cnt){\n        if(!flag[i] && GG[i].size() == 0){\n            rdfsdp(i);\n            ts.push_back(dp[i]+1);\n        }\n    }\n    ll ans = 1;\n    rep(i,ts.size()){\n        ans = ans * ts[i] % MOD;\n    }\n    printf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define int long long\n#define MOD 1000000007\nusing namespace std;\n\nvector<int> G[1000];\nbool cflag[1000];\nint mark[1000];\n\nint dfs(int v){\n\tint res = 1;\n\tmark[v] = 0;\n\tfor(int to : G[v]) res = res * dfs(to) % MOD;\n\treturn (res + 1) % MOD;\n}\n\nbool cyc(int v,int par){\n\tmark[v] = par;\n\tfor(int to : G[v]){\n\t\tif(mark[to] == par) return cflag[v] = true;\n\t\telse if(mark[to] != -1) continue;\n\t\tif(cyc(to,par)) return cflag[v] = true;\n\t}\n\treturn false;\n}\n\nsigned main(){\n\tint n,m,ans = 1;\n\tbool in[1000] = {};\n\tcin >> n >> m;\n\tfor(int i = 0;i < n;i++) mark[i] = -1;\n\tfor(int i = 0;i < m;i++){\n\t\tint a,b;\n\t\tcin >> a >> b; a--;b--;\n\t\tin[a] = true;\n\t\tG[b].push_back(a);\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tif(!in[i]) ans = ans * dfs(i) % MOD;\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tif(mark[i] == -1){\n\t\t\tfor(int j = 0;j < n;j++) cflag[j] = false;\n\t\t\tint res = 1;\n\t\t\tif(!cyc(i,i)) continue;\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tif(cflag[j]){\n\t\t\t\t\tfor(int to : G[j]){\n\t\t\t\t\t\tif(!cflag[to]) res = res * dfs(to) % MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = ans * (res + 1) % MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "class in{struct It{int it;const bool rev;explicit constexpr It(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(It& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const It i,n;public:explicit constexpr in(int n):i(0),n(n<0?0:n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const It& begin(){return i;}const It& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint Scc(const vector<vector<int>>& adj, vector<int>& color) {\n    const int n = adj.size();\n    vector<int> num(n, 0), low(n, 0), sta;\n    color.assign(n, 0);\n    vector<bool> inS(n, 0);\n    int t = 0, colnum = 0;\n    function<void(int)> visit = [&](int cur) {\n        low[cur] = num[cur] = ++t;\n        sta.emplace_back(cur); inS[cur] = 1;\n        for(int nxt : adj[cur]) {\n            if(num[nxt] == 0) {\n                visit(nxt);\n                low[cur] = min(low[cur], low[nxt]);\n            } else if(inS[nxt])\n              low[cur] = min(low[cur], num[nxt]);\n        }\n        if(low[cur] == num[cur]) {\n            while(true) {\n                int nxt = sta.back(); sta.pop_back(); inS[nxt] = false;\n                color[nxt] = colnum;\n                if(cur == nxt) break;\n            }\n            ++colnum;\n        }\n    };\n    for(int v : in(n))\n      if(num[v] == 0)\n        visit(v);\n    return colnum;\n}\n\nusing i64 = long long;\nconst i64 MOD = 1e9 + 7;\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> __adj(n);\n    for(int _ : in(m)) {\n        int u, v;\n        cin >> u >> v;\n        --u; --v;\n        __adj[u].emplace_back(v);\n    }\n    vector<int> color;\n    int col = Scc(__adj, color);\n    vector<vector<int>> radj(col);\n    vector<int> deg(col, 0);\n    for(int v : in(n))\n      for(int u : __adj[v])\n        if(color[v] != color[u])\n          radj[color[u]].emplace_back(color[v]), ++deg[color[v]];\n    for(auto& a : radj) {\n        sort(a.begin(), a.end());\n        a.erase(unique(a.begin(), a.end()), a.end());\n    }\n    vector<i64> dp(col, -1LL);\n    i64 ans = 1LL;\n    function<i64(int)> dfs = [&](int v) {\n        assert(v != -1);\n        i64& res = dp[v];\n        if(res != -1LL) return res;\n        res = 1LL;\n        for(int u : radj[v])\n          res = res * dfs(u) % MOD;\n        return ++res;\n    };\n    for(int v : in(col)) {\n        if(dp[v] != -1LL || deg[v] != 0) continue;\n        ans = ans * dfs(v) % MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 1005\nusing namespace std;\n\nint V; //????????°\nvector<int> G[MAX_V]; //??°???????????£??\\??????????????¨???\nvector<int> rG[MAX_V];//?????????????????????????????°??????\nvector<int> vs;       //??°?????????????????????\nbool used[MAX_V];     //?????§???????????????\nint cmp[MAX_V];       //?±????????????£?????????????????????????????????\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  \n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\nint ans[MAX_V];\n\nvoid dfs2(int x){\n  if(used[x])return;\n  used[x]=true;\n  for(int i=0;i<G[x].size();i++){\n    int nx=G[x][i];\n    if(cmp[x]!=cmp[nx])ans[cmp[nx]]*=(ans[cmp[x]]+1);\n    dfs2(nx);\n  }\n}\n\nint main(){\n  int n,m,s,d;\n  int start[MAX_V],goal[MAX_V];\n  cin>>n>>m;\n  V=n;\n  for(int i=0;i<n;i++)\n    ans[i]=start[i]=goal[i]=1;\n  for(int i=0;i<m;i++){\n    cin>>s>>d;\n    s--; d--;\n    add_edge(s,d);\n  }\n  int k=scc();\n  for(int i=0;i<n;i++)\n    for(int j=0;j<G[i].size();j++){\n      int x=G[i][j];\n      if(cmp[i]!=cmp[x])\n\tgoal[cmp[i]]=start[cmp[x]]=0;\n    }\n  for(int i=0;i<n;i++){\n    if(start[cmp[i]]){\n      memset(used,0,sizeof(used));\n      dfs2(i);\n    }\n    start[cmp[i]]=0;\n  }\n  int cnt=1;\n  for(int i=0;i<k;i++)\n    if(goal[i])cnt*=(ans[i]+1);\n  cout<<cnt<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\nusing namespace std;\ntypedef vector<int> vi;\ntypedef long long ll;\nconst ll mod = 1000000007;\n\nvi g[1010],rg[1010], vs;\nbool use[1010];\nint ord[1010];\nint n,m;\n\nvoid fdfs(int v){\n  use[v] = 1;\n  for(int u : g[v])if(!use[u])fdfs(u);\n  vs.pb(v);\n}\n\nvoid rdfs(int v,int k){\n  use[v] = 1; ord[v] = k;\n  for(int u : rg[v])if(!use[u])rdfs(u,k);\n}\n\nint scc(){\n  memset(use,0,sizeof(use));\n  vs.clear();\n  rep(i,n)if(!use[i])fdfs(i);\n\n  memset(use,0,sizeof(use));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!use[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint main(){\n  cin >> n >> m;\n  rep(i,m){\n    int a,b;\n    cin >> a >> b; a--; b--;\n    g[a].pb(b);\n    rg[b].pb(a);\n  }\n  int k = scc();\n\n  vector< vi > ng(k);\n  rep(v,n)for(int u : g[v]){\n    if(ord[v]!=ord[u])ng[ord[v]].pb(ord[u]);\n  }\n\n  vi deg(k,0);\n  rep(v,k){\n    sort(all(ng[v]));\n    ng[v].erase(unique(all(ng[v])),ng[v].end());\n    for(int u : ng[v])deg[u]++;\n  }\n\n  queue<int> q;\n  rep(v,k)if(deg[v]==0)q.push(v);\n  vector<int> to;\n\n  while(q.size()){\n    int v = q.front(); q.pop();\n    to.pb(v);\n    for(int u : ng[v]){\n      deg[u]--;\n      if(deg[u]==0)q.push(u);\n    }\n  }\n  \n  vector<ll> dp0(k,1), dp1(k,1);\n  ll ans = 1;\n  rep(i,k){\n    int v = to[i];\n    for(int u : ng[v]){\n      (dp0[u] *= dp0[v]) %= mod;\n      (dp1[u] *= dp0[v] + dp1[v]) %= mod;\n    }\n    if(ng[v].empty()) (ans *= dp0[v] + dp1[v]) %= mod;\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long mo = 1e9+7;\n\n/***********************/\n// ??±?????¨???\n/***********************/\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntypedef long long Weight;\nconst Weight INF = 1e18;\n\nstruct Edge {\n    ll src, dst;\n    Weight weight;\n    Edge(ll src, ll dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid addDirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); }\nvoid addUndirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); g[dst].push_back(Edge(dst, src, weight)); }\nvoid addDirected(Graph& g, ll src, ll dst) { addDirected(g, src, dst, 1); }\nvoid addUndirected(Graph& g, ll src, ll dst) { addUndirected(g, src, dst, 1); }\nvoid printGraph(Graph& g) {\n    rep(i, g.size()) {\n        if (!g[i].size())\n            continue;\n        rep(j, g[i].size()) \n            cout << \"(\" << i << \", \" << g[i][j].dst << \"), \";\n        cout << endl;\n    }\n}\n\n// ?????£???????§£\n// O(V+E)\n// const Graph& g               ????????°??????\n// vector< vector<ll> >& scc   ??°??????????????£?????????\nvoid visitStronglyConnectedComponents(const Graph &g, ll v, vector< vector<ll> >& scc,\n        stack<ll> &S, vector<bool> &inS,\n        vector<ll> &low, vector<ll> &num, ll& time) {\n    low[v] = num[v] = ++time;\n    S.push(v); inS[v] = true;\n    FOR(e, g[v]) {\n        ll w = e->dst;\n        if (num[w] == 0) {\n            visitStronglyConnectedComponents(g, w, scc, S, inS, low, num, time);\n            low[v] = min(low[v], low[w]);\n        } else if (inS[w])\n            low[v] = min(low[v], num[w]);\n    }\n    if (low[v] == num[v]) {\n        scc.push_back(vector<ll>());\n        while (1) {\n            ll w = S.top(); S.pop(); inS[w] = false;\n            scc.back().push_back(w);\n            if (v == w) break;\n        }\n    }\n}\nvoid stronglyConnectedComponents(const Graph& g, vector< vector<ll> >& scc) {\n    const ll n = g.size();\n    vector<ll> num(n), low(n);\n    stack<ll> S;\n    vector<bool> inS(n);\n    ll time = 0;\n    rep(u, n) if (num[u] == 0)\n        visitStronglyConnectedComponents(g, u, scc, S, inS, low, num, time);\n}\n\n// ???????????????????????????\n// ????????????????????? u ??§?????£??????u[i] ?????? u[j] ??????????????? => i < j ?????????????????????????????????\n//\n// const Graph &g\n// ??°?????????\n// vector<int> &order\n// ???????????????????????????????????????????????¨??§??£??\\???????????????????????????????????? true ?????¨???????????????\n// ?????????\n// ????????????????????????????????????????????????\n//\n// O(V+E)\nbool visitT(const Graph &g, ll v, vector<ll> &order, vector<ll> &color) {\n    color[v] = 1;\n    FOR(e, g[v]) {\n        if (color[e->dst] == 2) continue;\n        if (color[e->dst] == 1) return false;\n        if (!visitT(g, e->dst, order, color)) return false;\n    }\n    order.push_back(v); color[v] = 2;\n    return true;\n}\nbool topologicalSort(const Graph &g, vector<ll> &order) {\n    ll n = g.size();\n    vector<ll> color(n);\n    rep(u, n) if (!color[u] && !visitT(g, u, order, color))\n        return false;\n    reverse(all(order));\n    return true;\n}\n\n// ???????????°???????????????\nvoid reverseGraph(Graph& g_dst, Graph& g_src) { /*g_dst??????graph?????????*/\n    g_dst = Graph(g_src.size());\n    rep(i, g_src.size()) {\n        rep(j, g_src[i].size()) {\n            addDirected(g_dst, g_src[i][j].dst, g_src[i][j].src, g_src[i][j].weight);\n        }\n    }\n}\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, m; cin >> n >> m;\n    Graph g = Graph(n);\n    rep(i, m) {\n        ll u, v; cin >> u >> v; u--, v--;\n        addDirected(g, u, v);\n    }\n\n    // ??????????????°?????????????????????\n    vector<vector<ll>> scc;\n    stronglyConnectedComponents(g, scc);\n\n    // ?????????????????????SCC????±????????????????\n    vector<ll> scc_inv(g.size());\n    rep(i, scc.size()) rep(j, scc[i].size()) scc_inv[scc[i][j]] = i;\n\n    // ??°??????DAG?????°????????????\n    // ??°??????dag?????????i??????????????????(vector<ll> scc[i])???????????¨???????????????\n    Graph dag(scc.size());\n    rep(from, g.size()) rep(to, g[from].size()) if (scc_inv[from] != scc_inv[g[from][to].dst]) {\n        addDirected(dag, scc_inv[from], scc_inv[g[from][to].dst]);\n    }\n\n    // ????????????????????????????????????\n    // ????????????????????¨??§????????¢????????°??§?????????????????????\n    vector<ll> order;\n    topologicalSort(dag, order);\n    reverse(all(order));\n\n    // ??????????????????????????????????????????????????????\n    // ?????????????????????????????????????????????????????????????????\\??????????????§????????°??????????§??????????\n    Graph dag_rev;\n    reverseGraph(dag_rev, dag);\n\n    // dp[i]: ??????i???????????¨?????????????????????????????????????????????\n    vll dp(dag.size(), -1);\n    function<ll(ll)> f = [&](ll i){\n        if (dp[i] != -1)\n            return dp[i];\n        dp[i] = 1;\n        rep(j, dag_rev[i].size()) {\n            (dp[i] *= f(dag_rev[i][j].dst) + 1) %= mo;\n        }\n        return dp[i];\n    };\n\n    // ??????????????????????????????????????????????????§???\n    // ???????????????????????£?????????????????????????????????????????£???????????????????????¨?????????\n    ll ret = 1;\n    rep(i, dag.size()) {\n        if (dp[order[i]] != -1) \n            continue;\n        (ret *= f(order[i]) + 1) %= mo;\n    }\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n\n#include <iostream>\n#include <algorithm>\n\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstring>\n#include <string>\n#include <utility>\n#include <array>\n#include <complex>\n#include <valarray>\n\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double,int> pdi;\ntypedef pair<long double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll INFLL = 1LL<<62;\nconst long double EPS = 1e-12;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst long double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n#define inside(y, x, h, w) (0 <= (y) && (y) < (h) && 0 <= (x) && (x) < (w)) ? true : false\n\n//debug\n#define DEBUG\n\n#define DUMPOUT cout\n\n#ifdef DEBUG\n#define dump(...) DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__FUNCTION__<<\":\"<<__LINE__<<\"]\"<<endl; DUMPOUT<<\"    \"; dump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\nvoid dump_func() {DUMPOUT << endl;};\n\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) == 0) DUMPOUT << \" \";\n    else DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n\n//ostream\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n    os << \"[\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"]\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, map<T, U>& map_var) {\n    os << \"[\";\n    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n        os << \"(\" << itr->first << \", \" << itr->second << \")\"; itr++;  if(itr != map_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate<typename T> ostream& operator << (ostream& os, set<T>& set_var) {\n    os << \"[\";\n    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n        os << *itr; ++itr; if(itr != set_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\nint n, m;\nint indeg[3005], outdeg[3005], s[1005], d[1005];\nint dp[3005][2];\nvector<int> vs;\nvector<vector<int>> g(3000 + 3), rg(3000 + 3);\nbool visited[3000 + 3];\nint v[1000 + 5];\nint cnt;\n\nvoid dfs(int now, int &cv, int &loopv) {\n  visited[now] = true;\n  for (auto nx : g[now]) {\n    if (v[nx] >= n) return;//nx in loop\n    nx = v[nx];\n    if (visited[nx]) {\n      loopv = nx;\n      cv = cnt;\n      v[now] = cv;\n      cnt++;\n      return;\n    }\n    dfs(nx, cv, loopv);\n    if (cv == -1) return;\n    else {\n      v[now] = cv;\n      if (now == loopv) {\n        cv = -1;\n        loopv = -1;\n        return;\n      }\n    }\n  }\n  return;\n}\n\nvoid dpdfs(int now) {\n  for (auto nx : rg[now]) {\n    dpdfs(nx);\n    dp[now][1] = dp[now][1] * (dp[nx][0] + dp[nx][1]) % mod;\n  }\n}\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> n >> m;\n  rep(i, n) v[i] = i;\n  cnt = n;\n  rep(i, m) {\n    cin >> s[i] >> d[i];\n    s[i]--; d[i]--;\n    g[s[i]].push_back(d[i]);\n    rg[d[i]].push_back(s[i]);\n    indeg[d[i]]++;\n    outdeg[s[i]]++;\n  }\n  rep(i, n) {\n    int now = i;\n    int cv = -1;\n    int loopv = -1;\n    dfs(now, cv, loopv);\n    rep(j, n) visited[j] = false;\n  }\n\n  rep(i, n) {\n    if (v[i] != i) {\n      for (auto prev : rg[i]) {\n        if (v[prev] == prev) {\n          g[prev].erase(g[prev].begin());\n          g[prev].push_back(v[i]);\n          rg[v[i]].push_back(prev);\n        }\n      }\n    }\n  }\n  rep(i, 3000 + 1)rep(j, 2) dp[i][j] = 1;\n  //not loop (== line)\n  rep(i, n) {\n    if (outdeg[i] != 0) continue;\n    if (i != v[i]) continue;//vertex_i in loop\n    dpdfs(i);\n    vs.push_back(i);\n  }\n  //loop\n  rep2(i, n, cnt) {\n    dpdfs(i);\n    vs.push_back(i);\n  }\n  int ans = 1;\n  sort(all(vs));\n  vs.erase(unique(all(vs)),vs.end());\n  for (auto i : vs) {\n    ans = (ans * (dp[i][0] + dp[i][1])) % mod;\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n \ntypedef long long ll;\nint const inf = 1<<29;\n \nconstexpr int MOD = 1e9+7;\n \nnamespace graph { // not verified\n \nconstexpr int MaxV = 1010;\n \nstruct scc {\n \n  int V = MaxV;\n  vector<int> G[MaxV];\n  vector<int> rG[MaxV];\n  vector<int> vs;\n  vector<bool> used;\n  vector<int> comp;\n  int SCCGraphSize;\n \n  scc(): V(MaxV) { comp.resize(MaxV); }\n  scc(int V_): V(V_) { comp.resize(MaxV); }\n \n  void add_edge(int from, int to) {\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  }\n \n  void dfs(int v) {\n    used[v] = 1;\n    for(auto e: G[v]) {\n      if(!used[e]) dfs(e);\n    }\n    vs.push_back(v);\n  }\n \n  void rdfs(int v, int k) {\n    used[v] = 1;\n    comp[v] = k;\n    for(auto e: rG[v]) {\n      if(!used[e]) rdfs(e, k);\n    }\n  }\n \n  void solve() {\n    used.clear(); used.resize(MaxV);\n    vs.clear();\n    for(int i = 0; i < V; i++) {\n      if(!used[i]) dfs(i);\n    }\n    used.clear(); used.resize(MaxV);\n    int k = 0;\n    for(int i = vs.size() - 1; i >= 0; i--) {\n      if(!used[vs[i]]) rdfs(vs[i], k++);\n    }\n    SCCGraphSize = k;\n  }\n \n};\n \n}\n \nvector<vector<int>> tree;\n \nll solve(int curr, int par, vector<int>& vis) {\n  ll ret = 1;\n  vis[curr] = 1\n  for(auto e: tree[curr]) {\n    if(e == par) continue;\n    ret *= solve(e, curr);\n    ret %= MOD;\n  }\n  return ret;\n}\n \nint main() {\n \n  int N, M; cin >> N >> M;\n  graph::scc scc_graph(N);\n  rep(i, M) {\n    int S, D; cin >> S >> D; S --, D --;\n    scc_graph.add_edge(S, D);\n  }\n \n  scc_graph.solve();\n \n  auto& K = scc_graph.SCCGraphSize;\n  auto& g = scc_graph.G;\n  auto& comp = scc_graph.comp;\n \n  tree.resize(K);\n  int deg[1010] = {};\n \n  rep(i, N) {\n    for(auto e: g[i]) {\n      if(comp[i] == comp[e]) continue;\n      tree[comp[e]].push_back(comp[i]);\n      deg[comp[i]] ++;\n    }\n  }\n \n  rep(i, K) {\n    sort(tree[i].begin(), tree[i].end());\n    tree[i].erase(unique(tree[i].begin(), tree[i].end()), tree[i].end());\n  }\n \n  ll ans = 1;\n  vector<bool> vis(N);\n  rep(i, K) if(deg[i] == 0 && !vis[i]) {\n    vis[i] = 1;\n    ans *= solve(i, -1, vis);\n    ans %= MOD;\n  }\n \n  cout << ans << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "ｋ\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nvector<list<int>> child,rchild;\nvector<bool> isSearched,isRSearched;\nvector<int> order,del;\n\nint dfs(int a,int count){\n  isSearched[a]=true;\n  for(auto itr=child[a].begin();itr!=child[a].end();itr++){\n    if(!isSearched[(*itr)]) count=dfs((*itr),count);\n  }\n  order[count]=a;\n  return count+1;\n}\n\nvoid rdfs(int a,int d){\n  //cout << a << \" \" << d << endl;\n  isRSearched[a]=true;\n  del[a]=d;\n  for(auto itr=rchild[a].begin();itr!=rchild[a].end();itr++){\n    if(!isRSearched[(*itr)]) rdfs((*itr),d);\n  }\n  if(a!=d){\n    for(auto itr=child[a].begin();itr!=child[a].end();itr++){\n      if(del[(*itr)]!=d) child[d].push_back((*itr));\n    }\n  }\n  return;\n}\n\nLL ansdfs(int a){\n  //cout << a << endl;\n  LL ans=1;\n  for(auto itr=child[a].begin();itr!=child[a].end();itr++){\n    ans=ans*ansdfs((*itr))%1000000007;\n  }\n  return ans+1;\n}\n\nint main(){\n  int n,m;\n  cin >> n >> m;\n  child=vector<list<int>>(n,list<int>());\n  rchild=vector<list<int>>(n,list<int>());\n  isSearched=vector<bool>(n,false);\n  isRSearched=vector<bool>(n,false);\n  order=vector<int>(n,-1);\n  del=vector<int>(n,-1);\n  vector<bool> isRoot(n,true);\n  int s,d;\n  for(int i=0;i<m;i++){\n    cin >> s >> d;\n    s--;\n    d--;\n    child[d].push_back(s);\n    rchild[s].push_back(d);\n  }\n  int count=0;\n  for(int i=0;i<n;i++){\n    if(!isSearched[i]){\n      count=dfs(i,count);\n    }\n  }\n  // for(int i=0;i<n;i++){\n  //   cout << order[i] << \" \";\n  // }\n  // cout << endl;\n  for(int i=0;i<n;i++){\n    if(!isRSearched[order[n-i-1]]){\n      rdfs(order[n-i-1],order[n-i-1]);\n    }\n  }\n  for(int i=0;i<n;i++){\n    if(del[i]==i){\n      for(auto itr=child[i].begin();itr!=child[i].end();itr++){\n        if(del[i]==del[(*itr)]){\n          itr=child[i].erase(itr);\n          itr--;\n        }else{\n          (*itr)=del[(*itr)];\n          isRoot[(*itr)]=false;\n        }\n      }\n    }\n  }\n  // for(int i=0;i<n;i++){\n  //   cout << i << \":   \";\n  //   for(auto itr=child[i].begin();itr!=child[i].end();itr++){\n  //     cout << (*itr) << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  LL ans=1;\n  for(int i=0;i<n;i++){\n    if(isRoot[i]&&del[i]==i){\n      ans=ans*ansdfs(i)%1000000007;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define MAX (1003)\n#define MOD (1000000007LL)\n\nint V;\nvector<int> G[MAX];\nvector<int> rG[MAX];\nvector<int> nG[MAX];//?????£???????§£????????£???????????°????????°?????? \nvector<int> nrG[MAX];\nvector<int> vs;\nbool used[MAX];\nint cmp[MAX]; //?±????????????£????????????????????????????????????\n \nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n \nvoid dfs(int v){\n  used[v] = true;\n  for(int i = 0 ; i < G[v].size() ; i++){\n    if(!used[G[v][i]]) dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\n \nvoid rdfs(int v,int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i = 0 ; i < rG[v].size() ; i++){\n    if(!used[rG[v][i]]) rdfs(rG[v][i],k);\n  }\n}\n \nint scc(){ //?????£?????????????§£????????????\n  memset(used, 0, sizeof(used));\n  vs.clear();\n  for(int v = 0 ; v < V ; v++){\n    if(!used[v]) dfs(v);\n  }   \n  memset(used, 0, sizeof(used));\n  int k = 1;\n  for(int i = vs.size() - 1 ; i >= 0 ; i--){\n    if(!used[vs[i]]) rdfs(vs[i],k++);\n  }\n\n  for(int i=0;i<V;i++){\n    int v = cmp[i];\n    for(int j=0;j<(int)G[i].size();j++){\n      int to = cmp[G[i][j]];\n      if( to != v ) {\n\tnG[v].push_back(to);\n\tnrG[to].push_back(v);\n      }\n    }\n  }\n  return k;\n}\n\nvoid dfs2(int id,bool *flag){\n  if( flag[id] ) return;\n  flag[id] = true;\n  for(int i=0;i<(int)nrG[id].size();i++)\n    dfs2(nrG[id][i],flag);\n}\n\t\t \n\nint M;\nll dp[MAX];\n\nbool ch[MAX];\n\n\nvoid view(int id,vector<int> Gs[50]){\n  cout << \"vertex : \" << id << endl;\n  for(int j=0;j<(int)Gs[id].size();j++)\n    cout << \" -> \" << Gs[id][j] << endl;;\n}\n\nint main(){\n\n  cin >> V >> M;\n  for(int i=0;i<M;i++){\n    int s,d;\n    cin >> s >> d;\n    --s; --d;\n    add_edge(s,d);\n  }\n\n  int K = scc();\n  for(int i=1;i<K;i++){\n\n    sort(nG[i].begin(),nG[i].end());\n    nG[i].erase(unique(nG[i].begin(),nG[i].end()),nG[i].end());\n\n    sort(nrG[i].begin(),nrG[i].end());\n    nrG[i].erase(unique(nrG[i].begin(),nrG[i].end()),nrG[i].end());\n\n    dp[i] = 1LL;\n  }\n  ll ret = 1;\n  for(int i=1;i<K;i++){\n    /*\n    cout << \"vertex : \" << i << \" dp = \" << dp[i] << endl;\n    for(int j=0;j<(int)nG[i].size();j++)\n      cout << \" -> \" << nG[i][j] << endl;;\n    */\n    /*\n    memset(used,0,sizeof(used));\n    dfs2(i,used);\n    for(int j=0;j<K;j++)\n      if( used[j] ) \n\tfor(int k=0;k<(int)nG[j].size();k++)\n\t  if( !used[nG[j][k]] ) dp[nG[j][k]] = (dp[nG[j][k]] + dp[i])%MOD;\n    */\n\n    for(int j=0;j<(int)nG[i].size();j++){\n      dp[nG[i][j]] = (dp[nG[i][j]] * (dp[i]+1LL))%MOD;\n    }\n    if( nG[i].empty() )\n      ret  =  ( ret * (dp[i]+1LL) ) % MOD;\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<deque>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<queue>\n#include<cassert>\n#include<climits>\n\n#define MOD (1000000007)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 2000\n\nusing namespace std;\n\ntypedef long long ull;\ntypedef pair<int,int> ii;\n\nstruct Data{\n  int  to,cost;\n  Data(int to=IINF,int cost=IINF):to(to),cost(cost){}\n};\n\n// Library - topological sort - begin \n\ntemplate<typename T>\nbool visit(const T& G,int v,vector<int>& order,vector<int>& color)\n{\n  color[v] = 1;\n  for(__typeof((G[v]).begin()) e = G[v].begin();e != G[v].end();e++)\n    {\n      if(color[e->to] == 2)continue;//このvisit以外のvisitで訪れた\n      if(color[e->to] == 1)return false;//このvisitで訪れた\n      if(!visit(G,e->to,order,color))return false;\n    }\n  order.push_back(v);\n  color[v] = 2;\n  return true;\n}\n\ntemplate<typename T>\nbool topologicalSort(const T& G,vector<int>& order)\n{\n  int SizeG = G.size();\n  vector<int> color(SizeG); \n  for(int u=0;u<SizeG;u++)\n    if(!color[u] && !visit(G,u,order,color))\n      return false;\n  reverse(order.begin(),order.end());\n  return true;\n}\n\n// Library - topological sort - end\n\nint V,E,S,D;\nvector<vector<Data> > tmp_G,tmp_rG;\nvector<int>  G[MAX];\nvector<int> rG[MAX];\nvector<int> vs;\nbool used[MAX];\nint cmp[MAX];\null dp[MAX];\n\ninline void add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k = 0;\n  for(int i = vs.size(); i >= 0 ; i-- )if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nint main(){\n\n  cin >> V >> E;\n  map<int,int> Index;\n  int dex = 0;\n  rep(i,E){\n    cin >> S >> D;\n    if(Index.find(S) == Index.end())Index[S] = dex++;\n    if(Index.find(D) == Index.end())Index[D] = dex++;\n    int s = Index[S];\n    int d = Index[D];\n    add_edge(s,d);\n  }\n  int nV = scc();\n  rep(i,nV)dp[i] = -1;\n\n  set<int> OUT_counter[nV];\n  rep(i,V)rep(j,G[i].size()){\n    if(cmp[i] == cmp[G[i][j]])continue;\n    OUT_counter[cmp[i]].insert(cmp[G[i][j]]);\n  }\n\n  tmp_G.clear(),tmp_rG.clear();\n  tmp_G.resize(nV),tmp_rG.resize(nV);\n  rep(i,nV)for(int j : OUT_counter[i]){\n    tmp_G[i].push_back(j);\n    tmp_rG[j].push_back(i);\n  }\n\n  vector<int> order;\n  topologicalSort(tmp_G,order);\n\n  rep(i,nV)if(tmp_rG[order[i]].empty())dp[order[i]] = 2ULL;\n\n  ull ans = 1;\n\n  rep(i,nV){\n    int cur = order[i];\n    ull cost = 1;\n    rep(j,tmp_rG[cur].size()){\n      int prev = tmp_rG[cur][j].to;\n      cost = ( cost * dp[prev] ) % MOD;\n    }\n    if(!tmp_rG[cur].empty()){\n      assert(dp[cur] == -1);\n      dp[cur] = ( cost + 1ULL ) % MOD;\n    }\n    if(tmp_G[cur].empty())ans = ( ans * dp[cur] ) % MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nstruct SCC {\n    int V;\n    vector<vi> G, rG;\n    vector<int> vs, used, cmp;\n    SCC(const vector<vi>& g) : V(g.size()), G(g), rG(V), used(V), cmp(V) {\n        for (int i = 0; i < V; i++) for (int u : G[i]) rG[u].push_back(i);\n    }\n    void dfs(int v) {\n        used[v] = 1;\n        for (int u : G[v]) if (!used[u]) dfs(u);\n        vs.push_back(v);\n    }\n    void rdfs(int v, int k) {\n        used[v] = 1;\n        cmp[v] = k;\n        for (int u : rG[v]) if (!used[u]) rdfs(u, k);\n    }\n    int calc() {\n        fill(used.begin(), used.end(), 0);\n        vs.clear();\n        for (int v = 0; v < V; v++) {\n            if (!used[v]) dfs(v);\n        }\n        fill(used.begin(), used.end(), 0);\n        int k = 0;\n        for (int i = vs.size()-1; i >= 0; i--) {\n            if (!used[vs[i]]) rdfs(vs[i], k++);\n        }\n        return k;\n    }\n};\n\nbool visit(const vector<vi>& g, int v, vector<int>& order, vector<int>& color) {\n    color[v] = 1;\n    for (int u : g[v]) {\n        if (color[u]==2) continue;\n        if (color[u]==1) return false;\n        if (!visit(g, u, order, color)) return false;\n    }\n    order.push_back(v); color[v] = 2;\n    return true;\n}\n\n// ?????????????????????????????????\n// ???????????? true ???????????????????????????(false ?????´????????????)\nbool TopologicalSort(const vector<vi>& g, vector<int>& order) {\n    int n = g.size();\n    vector<int> color(n);\n    for (int u = 0; u < n; u++) if (!color[u] && !visit(g, u, order, color)) return false;\n    reverse(order.begin(), order.end());\n    return true;\n}\n\n\nconst int MOD = 1e9+7;\nll dp[1111][2];\n\nll dfs(int v, int flag, const vector<vi>& g) {\n    ll& ret = dp[v][flag];\n    if (ret >= 0) return ret;\n    if (flag == 0) return ret = 1;\n    // v ??? 1 ???????????´???\n    ret = 1;\n    for (int ch : g[v]) {\n        ll tmp = dfs(ch, 0, g) + dfs(ch, 1, g);\n        (ret *= tmp%MOD) %= MOD;\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, M;\n    cin >> N >> M;\n    vector<vi> G(N);\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        G[v].push_back(u);\n    }\n    SCC scc(G);\n    int sz = scc.calc();\n    vector<vi> g(sz);\n    {\n        vector<set<int> > S(sz);\n        for (int i = 0; i < N; i++) {\n            for (int j : G[i]) {\n                S[scc.cmp[i]].insert(scc.cmp[j]);\n            }\n        }\n        for (int i = 0; i < sz; i++) {\n            for (int j : S[i]) if (j != i) {\n                g[i].push_back(j);\n            }\n        }\n    }\n    vector<int> order;\n    TopologicalSort(g, order);\n    // for (int i = 0; i < sz; i++) \n    //     cout << order[i] << \" \";\n    // cout << endl;\n    memset(dp, -1, sizeof(dp));\n    ll ans = 1;\n    for (int i = 0; i < sz; i++) {\n        int v = order[i];\n        if (dp[v][0] == -1) {\n            ll tmp = dfs(v, 0, g) + dfs(v, 1, g);\n            (ans *= tmp%MOD) %= MOD;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MAX 1005\nll mod=1e9+7;\nint n,m,a,b;\nvector<int> G[MAX],g[MAX];\nint p[MAX];\nbool flg[MAX];\n \nint update(int x){\n  flg[x]=true;\n  if(p[x]==x)return x;\n  return p[x]=update(p[x]);\n}\n \nint find(int x){\n  if(p[x]==x)return x;\n  return find(p[x]);\n}\n \nll dfs(int pos){\n  ll res=1;\n  for(int i=0;i<(int)g[pos].size();i++)\n    res=mul(res,dfs(g[pos][i]));  \n  return (res+1LL)%mod;\n}\n \nint main(){\n  cin>>n>>m;\n    for(int i=1;i<=n;i++)p[i]=i;\n    for(int i=0;i<m;i++){\n      cin>>a>>b;\n      G[b].push_back(a);\n      if(find(b)==a)update(b);\n      else p[a]=b;\n    }\n    for(int i=1;i<=n;i++){\n      for(int j=0;j<(int)G[i].size();j++){\n        int w=G[i][j];\n        if(flg[w])continue;\n        if(flg[i])g[p[i]].push_back(w);\n        else g[i].push_back(w);\n      }\n    }\n    ll ans=1;\n    for(int i=1;i<=n;i++)if(p[i]==i)ans=ans*dfs(i)%mod;\n    cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<deque>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<queue>\n#include<cassert>\n#include<climits>\n\n#define MOD (1000000007)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 2000\n\nusing namespace std;\n\ntypedef long long ull;\ntypedef pair<int,int> ii;\n\nstruct Data{\n  int  to,cost;\n  Data(int to=IINF,int cost=IINF):to(to),cost(cost){}\n};\n\n// Library - topological sort - begin \n\ntemplate<typename T>\nbool visit(const T& G,int v,vector<int>& order,vector<int>& color)\n{\n  color[v] = 1;\n  for(__typeof((G[v]).begin()) e = G[v].begin();e != G[v].end();e++)\n    {\n      if(color[e->to] == 2)continue;//このvisit以外のvisitで訪れた\n      if(color[e->to] == 1)return false;//このvisitで訪れた\n      if(!visit(G,e->to,order,color))return false;\n    }\n  order.push_back(v);\n  color[v] = 2;\n  return true;\n}\n\ntemplate<typename T>\nbool topologicalSort(const T& G,vector<int>& order)\n{\n  int SizeG = G.size();\n  vector<int> color(SizeG); \n  for(int u=0;u<SizeG;u++)\n    if(!color[u] && !visit(G,u,order,color))\n      return false;\n  reverse(order.begin(),order.end());\n  return true;\n}\n\n// Library - topological sort - end\n\nint V,E,S,D;\nvector<vector<Data> > tmp_G,tmp_rG;\nvector<int>  G[MAX];\nvector<int> rG[MAX];\nvector<int> vs;\nbool used[MAX];\nint cmp[MAX];\null dp[MAX];\n\ninline void add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k = 0;\n  for(int i = vs.size(); i >= 0 ; i-- )if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nint main(){\n\n  cin >> V >> E;\n  rep(i,E){\n    cin >> S >> D;\n    assert(1 <= S && S <= V);\n    assert(1 <= D && D <= V);\n    add_edge(S-1,D-1);\n  }\n  int nV = scc();\n  rep(i,nV)dp[i] = -1;\n\n  set<int> OUT_counter[nV];\n  rep(i,V)rep(j,G[i].size()){\n    if(cmp[i] == cmp[G[i][j]])continue;\n    OUT_counter[cmp[i]].insert(cmp[G[i][j]]);\n  }\n\n  tmp_G.clear(),tmp_rG.clear();\n  tmp_G.resize(nV),tmp_rG.resize(nV);\n  rep(i,nV)for(int j : OUT_counter[i]){\n    tmp_G[i].push_back(j);\n    tmp_rG[j].push_back(i);\n  }\n\n  vector<int> order;\n  topologicalSort(tmp_G,order);\n\n  rep(i,nV)if(tmp_rG[order[i]].empty())dp[order[i]] = 2ULL;\n\n  ull ans = 1;\n\n  rep(i,nV){\n    int cur = order[i];\n    ull cost = 1;\n    rep(j,tmp_rG[cur].size()){\n      int prev = tmp_rG[cur][j].to;\n      assert(dp[prev] != -1);\n      cost = ( cost * dp[prev] ) % MOD;\n    }\n    if(!tmp_rG[cur].empty()){\n      assert(dp[cur] == -1);\n      dp[cur] = ( cost + 1ULL ) % MOD;\n    }\n    if(tmp_G[cur].empty())ans = ( ans * dp[cur] ) % MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nstruct Edge { int from, to; };\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to) {\n\tg[from].push_back(Edge{ from, to });\n}\n\nvoid dfs(const Graph& g, int v, vector<bool>& used, vi& vs)\n{\n\tused[v] = true;\n\tfor (auto i : g[v])\n\t{\n\t\tif (!used[i.to]) dfs(g, i.to, used, vs);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(const Graph& rg, int v, vector<bool>& used, int k, vi& cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (auto i : rg[v])\n\t{\n\t\tif (!used[i.to]) rdfs(rg, i.to, used, k, cmp);\n\t}\n}\n\nint strongly_connected_component(Graph graph, vi& cmp)\n{\n\tint V = graph.size();\n\tGraph g(V), rg(V);\n\tvector<bool> used(V);\n\tvi vs;\n\tcmp.resize(V);\n\tREP(i, V)\n\t{\n\t\tfor (auto e : graph[i])\n\t\t{\n\t\t\tadd_edge(g, i, e.to);\n\t\t\tadd_edge(rg, e.to, i);\n\t\t}\n\t}\n\tREP(i, V)\n\t{\n\t\tif (!used[i]) dfs(g, i, used, vs);\n\t}\n\tused = vector<bool>(V);\n\treverse(ALL(vs));\n\tint k = 0;\n\tfor (auto i : vs)\n\t{\n\t\tif (!used[i]) rdfs(rg, i, used, k++, cmp);\n\t}\n\treturn k;\n}\n\nGraph buildGraph(const Graph& g, const vi& cmp, int K)\n{\n\tint V = g.size();\n\tvector<set<int>> s(K);\n\tGraph res(K);\n\tREP(i, V)\n\t{\n\t\tfor (auto e : g[i]) s[cmp[i]].insert(cmp[e.to]);\n\t}\n\tREP(i, K)\n\t{\n\t\tfor (auto j : s[i]) if (i != j) add_edge(res, i, j);\n\t}\n\treturn res;\n}\n\nll solve(const vector<vi>& tree, int v)\n{\n\tll res = 1, tmp = 1;\n\tREP(i, tree[v].size())\n\t{\n\t\ttmp *= solve(tree, tree[v][i]);\n\t\ttmp %= MOD;\n\t}\n\tres += tmp;\n\treturn res;\n}\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tGraph g(n);\n\tREP(i, m)\n\t{\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tadd_edge(g, a, b);\n\t}\n\tvi cmp;\n\tint k = strongly_connected_component(g, cmp);\n\tGraph dag = buildGraph(g, cmp, k);\n\tvector<vi> tree(n);\n\tvi root;\n\tREP(i, dag.size())\n\t{\n\t\tif (dag[i].size() == 0) root.push_back(i);\n\t\tfor (auto e : dag[i])\n\t\t{\n\t\t\ttree[e.to].push_back(e.from);\n\t\t}\n\t}\n\tll ans = 1;\n\tREP(i, root.size())\n\t{\n\t\tans *= solve(tree, root[i]);\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <cstring>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\nint n,m;\nvector<int> G[1501];\nvector<int> rG[1501];\nvector<int> vs;\nvector<int> Group[1501];\nbool used[1501];\nint cmp[1501];\nvector<int> rGroup[1501];\nll dp[1501][2];\n\nvoid dfs(int v){\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!used[G[v][i]])dfs(G[v][i]);\n\t}\n\tvs.push_back(v);\n}\n\nint ddfs(int v){\n\tused[v]=true;\n\tint res=cmp[v];\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!used[G[v][i]])res=max(ddfs(G[v][i]),res);\n\t}\n\tfor(int i=0;i<rG[v].size();i++){\n\t\tif(!used[rG[v][i]])res=max(ddfs(rG[v][i]),res);\n\t}\n\treturn res;\n}\n\nvoid rdfs(int v,int k){\n\tused[v]=true;\n\tcmp[v]=k;\n\tGroup[k].push_back(v);\n\tfor(int i=0;i<rG[v].size();i++){\n\t\tif(!used[rG[v][i]])rdfs(rG[v][i],k);\n\t}\n}\n\nint scc(){\n\tmemset(used,false,sizeof(used));\n\tvs.clear();\n\tfor(int v=0;v<n;v++){\n\t\tif(!used[v])dfs(v);\n\t}\n\tmemset(used,false,sizeof(used));\n\tint k=0;\n\tfor(int i=vs.size()-1;i>=0;i--){\n\t\tif(!used[vs[i]])rdfs(vs[i],k++);\n\t}\n\treturn k;\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<m;i++){\n\t\tint f,t;\n\t\tscanf(\"%d%d\",&f,&t);\n\t\tf--;\n\t\tt--;\n\t\tG[f].push_back(t);\n\t\trG[t].push_back(f);\n\t}\n\tint k=scc();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<rG[i].size();j++){\n\t\t\tif(cmp[i]!=cmp[rG[i][j]])rGroup[cmp[i]].push_back(cmp[rG[i][j]]);\n\t\t}\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tdp[i][0]=1;\n\t\tdp[i][1]=1;\n\t\tfor(int j=0;j<rGroup[i].size();j++){\n\t\t\tint u=rGroup[i][j];\n\t\t\tdp[i][1]=(dp[i][1]*((dp[u][0]+dp[u][1])%MOD))%MOD;\n\t\t}\n\t}\n\tmemset(used,false,sizeof(used));\n\tll res=1;\n\tfor(int i=0;i<k;i++){\n\t\tfor(int j=0;j<Group[i].size();j++){\n\t\t\tif(!used[Group[i][j]]){\n\t\t\t\tint b=ddfs(Group[i][j]);\n\t\t\t\tres=(res*((dp[b][0]+dp[b][1])%MOD))%MOD;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-12L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\n// geometry library\n\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < eps) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < eps);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist + eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n            (aa * target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\nll gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor() {\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a) {\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this->data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this->data[i][0]) * (obj.data[0][q]);\n                for (int t = 1; t < obj.data[i].size(); ++t) {\n                    hoge += this->data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix& operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\n\nstruct Fraction {\n    ll a;\n    ll b;\n    Fraction() :a(0LL), b(1LL) {\n\n    }\n    Fraction(ll c, ll d) {\n        int hoge = gcd(llabs(c), llabs(d));\n        c /= hoge;\n        d /= hoge;\n        if (d < 0) {\n            d *= -1;\n            c *= -1;\n        }\n        a = c;\n        b = d;\n    }\n    bool operator <(Fraction rhs) const {\n        return a * rhs.b < rhs.a * b;\n    }\n};\n\ntemplate <std::uint_fast64_t mod>\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    modint() :value(0LL) {\n\n    }\n    modint(ll a) : value(((a% mod) + 2 * mod) % mod) {\n\n    }\n\n    constexpr modint operator+(const modint rhs) const {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint& operator+=(const modint rhs) {\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    constexpr modint& operator-=(const modint rhs) {\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    constexpr modint& operator*=(const modint rhs) {\n        value = (value * rhs.value) % mod;\n        return *this;\n    }\n    constexpr modint& operator/=(modint rhs) {\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    bool operator <(modint rhs) const {\n        return value < rhs.value;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nclass Dice {\npublic:\n    vector<ll> vertexs;\n    //Up: 0,Left: 1,Center: 2,Right: 3,Adj: 4, Down: 5\n    Dice(vector<ll> init) :vertexs(init) {\n\n    }\n    //Look from Center\n    void RtoL() {\n        for (int q = 1; q < 4; ++q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void LtoR() {\n        for (int q = 3; q >= 1; --q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void UtoD() {\n        swap(vertexs[5], vertexs[4]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[0], vertexs[2]);\n    }\n    void DtoU() {\n        swap(vertexs[0], vertexs[2]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[5], vertexs[4]);\n    }\n    bool ReachAble(Dice now) {\n        set<Dice> hoge;\n        queue<Dice> next;\n        next.push(now);\n        hoge.insert(now);\n        while (next.empty() == false) {\n            Dice seeing = next.front();\n            next.pop();\n            if (seeing == *this) return true;\n            seeing.RtoL();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.LtoR();\n            seeing.LtoR();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.RtoL();\n            seeing.UtoD();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.DtoU();\n            seeing.DtoU();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n        }\n        return false;\n    }\n    bool operator ==(const Dice& a) {\n        for (int q = 0; q < 6; ++q) {\n            if (a.vertexs[q] != (*this).vertexs[q]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool operator <(const Dice& a) const {\n        return (*this).vertexs < a.vertexs;\n    }\n};\n\npair<Dice, Dice> TwoDimDice(int center, int up) {\n    int target = 1;\n    while (true) {\n        if (center != target && 7 - center != target && up != target && 7 - up != target) {\n            break;\n        }\n        target++;\n    }\n    return mp(Dice(vector<ll>{up, target, center, 7 - target, 7 - center, 7 - up}), Dice(vector<ll>{up, 7 - target, center, target, 7 - center, 7 - up}));\n}\n\ntuple<Dice, Dice, Dice, Dice> OneDimDice(int center) {\n    int bo = min(center, 7 - center);\n    pair<int, int> goa;\n    if (bo == 1) {\n        goa = mp(2, 3);\n    }\n    else if (bo == 2) {\n        goa = mp(1, 3);\n    }\n    else if (bo == 3) {\n        goa = mp(1, 2);\n    }\n    tuple<Dice, Dice, Dice, Dice> now = make_tuple(Dice(vector<ll>{goa.first, goa.second, center, 7 - goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{goa.first, 7 - goa.second, center, goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{7 - goa.first, goa.second, center, 7 - goa.second, 7 - center, goa.first}),\n        Dice(vector<ll>{7 - goa.first, 7 - goa.second, center, goa.second, 7 - center, goa.first}));\n    return now;\n}\n\ntemplate<typename A, typename B>\nclass Dijkstra {\npublic:\n    vector<vector<pair<int, A>>> vertexs;\n    B Cost_Function;\n    Dijkstra(int n, B cost) : Cost_Function(cost) {\n        vertexs = vector<vector<pair<int, A>>>(n, vector<pair<int, A>>{});\n    }\n    ~Dijkstra() {\n        vertexs.clear();\n    }\n    void add_edge(int a, int b, A c) {\n        vertexs[a].push_back(mp(b, c));\n    }\n    vector<ll> build_result(int StartPoint) {\n        vector<ll> dist(vertexs.size(), 2e18);\n        dist[StartPoint] = 0;\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> next;\n        next.push(make_pair(0, StartPoint));\n        while (next.empty() == false) {\n            pair<ll, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (auto x : vertexs[now.second]) {\n                ll now_cost = now.first + Cost_Function(x.second);\n                if (dist[x.first] > now_cost) {\n                    dist[x.first] = now_cost;\n                    next.push(mp(now_cost, x.first));\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nclass Dinic {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n    vector<vector<edge>> Graph;\n    vector<int> level;\n    vector<int> itr;\n    Dinic(int n) {\n        Graph = vector<vector<edge>>(n, vector<edge>());\n    }\n    void add_edge(int a, int b, int cap) {\n        Graph[a].push_back(edge{ b, cap ,(int)Graph[b].size() });\n        Graph[b].push_back(edge{ a,0,(int)Graph[a].size() - 1 });\n    }\n    void bfs(int s) {\n        level = vector<int>(Graph.size(), -1);\n        level[s] = 0;\n        queue<int> next;\n        next.push(s);\n        while (next.empty() == false) {\n            int now = next.front();\n            next.pop();\n            for (auto x : Graph[now]) {\n                if (x.cap == 0) continue;\n                if (level[x.to] == -1) {\n                    level[x.to] = level[now] + 1;\n                    next.push(x.to);\n                }\n            }\n        }\n    }\n    int dfs(int now, int goal, int val) {\n        if (goal == now) return val;\n        for (int& i = itr[now]; i < (int)Graph[now].size(); ++i) {\n            edge& target = Graph[now][i];\n            if (target.cap > 0 && level[now] < level[target.to]) {\n                int d = dfs(target.to, goal, min(val, target.cap));\n                if (d > 0) {\n                    target.cap -= d;\n                    Graph[target.to][target.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int run(int s, int t) {\n        int ans = 0;\n        int f = 0;\n        while (bfs(s), level[t] >= 0) {\n            itr = vector<int>(Graph.size(), 0);\n            while ((f = dfs(s, t, 1e9)) > 0) {\n                ans += f;\n            }\n        }\n        return ans;\n    }\n};\n\n\nclass HLDecomposition {\npublic:\n    vector<vector<int>> vertexs;\n    vector<int> depth;\n    vector<int> backs;\n    vector<int> connections;\n    vector<int> zip, unzip;\n    HLDecomposition(int n) {\n        vertexs = vector<vector<int>>(n, vector<int>());\n        depth = vector<int>(n);\n        zip = vector<int>(n);\n        unzip = zip;\n    }\n    void add_edge(int a, int b) {\n        vertexs[a].push_back(b);\n        vertexs[b].push_back(a);\n    }\n    int depth_dfs(int now, int back) {\n        depth[now] = 0;\n        for (auto x : vertexs[now]) {\n            if (x == back) continue;\n            depth[now] = max(depth[now], 1 + depth_dfs(x, now));\n        }\n        return depth[now];\n    }\n    void dfs(int now, int backing) {\n        zip[now] = backs.size();\n        unzip[backs.size()] = now;\n        backs.push_back(backing);\n        int now_max = -1;\n        int itr = -1;\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (now_max < depth[x]) {\n                now_max = depth[x];\n                itr = x;\n            }\n        }\n        if (itr == -1) return;\n        connections.push_back(connections.back());\n        dfs(itr, backing);\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (x == itr) continue;\n            connections.push_back(zip[now]);\n            dfs(x, backs.size());\n        }\n        return;\n    }\n    void build() {\n        depth_dfs(0, -1);\n        connections.push_back(-1);\n        dfs(0, -1);\n    }\n    vector<pair<int, int>> query(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        vector<pair<int, int>> ans;\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            ans.push_back(mp(backs[a], a + 1));\n            a = connections[a];\n        }\n        if (a > b) swap(a, b);\n        ans.push_back(mp(a, b + 1));\n        return ans;\n    }\n    int lca(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            a = connections[a];\n        }\n        return unzip[min(a, b)];\n    }\n};\n//by ei1333\n//https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz + 1, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n    using G = function< Monoid(Monoid, OperatorMonoid) >;\n    using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n\n    int sz, height;\n    vector< Monoid > data;\n    vector< OperatorMonoid > lazy;\n    const F f;\n    const G g;\n    const H h;\n    const Monoid M1;\n    const OperatorMonoid OM0;\n\n\n    LazySegmentTree(int n, const F f, const G g, const H h,\n        const Monoid& M1, const OperatorMonoid OM0)\n        : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n        sz = 1;\n        height = 0;\n        while (sz < n) sz <<= 1, height++;\n        data.assign(2 * sz, M1);\n        lazy.assign(2 * sz, OM0);\n    }\n\n    void set(int k, const Monoid& x) {\n        data[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n        }\n    }\n\n    inline void propagate(int k) {\n        if (lazy[k] != OM0) {\n            lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n            data[k] = reflect(k);\n            lazy[k] = OM0;\n        }\n    }\n\n    inline Monoid reflect(int k) {\n        return lazy[k] == OM0 ? data[k] : g(data[k], lazy[k]);\n    }\n\n    inline void recalc(int k) {\n        while (k >>= 1) data[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n    }\n\n    inline void thrust(int k) {\n        for (int i = height; i > 0; i--) propagate(k >> i);\n    }\n\n    void update(int a, int b, const OperatorMonoid& x) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) lazy[l] = h(lazy[l], x), ++l;\n            if (r & 1) --r, lazy[r] = h(lazy[r], x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n\n    Monoid query(int a, int b) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        Monoid L = M1, R = M1;\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) L = f(L, reflect(l++));\n            if (r & 1) R = f(reflect(--r), R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) {\n        return query(k, k + 1);\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            propagate(a);\n            Monoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, reflect(1)))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        thrust(a + sz);\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, reflect(a));\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(reflect(1), R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        thrust(b + sz - 1);\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(reflect(--b), R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\nclass KMP {\npublic:\n    vector<ll> table;\n    vector<ll> Pattern;\n    KMP(vector<ll> a) {\n        build(a);\n    }\n    void build(vector<ll> a) {\n        Pattern = a;\n        table = vector<ll>(a.size() + 1, -1);\n        int j = -1;\n        for (int i = 0; i < a.size(); ++i) {\n            while (j >= 0 && Pattern[i] != Pattern[j]) {\n                j = table[j];\n            }\n            table[i + 1] = ++j;\n        }\n        return;\n    }\n    vector<ll> search(vector<ll> a) {\n        vector<ll> ans;\n        for (int i = 0, k = 0; i < a.size(); ++i) {\n            while (k >= 0 && a[i] != Pattern[k]) k = table[k];\n            ++k;\n            if (k >= Pattern.size()) {\n                ans.push_back(i - Pattern.size() + 1);\n                k = table[k];\n            }\n        }\n        return ans;\n    }\n};\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n#define int ll\nvector<int> vertexs[2000];\nint ut[2000];\nint uf(int a) {\n    if (ut[a] == a) return a;\n    return ut[a] = uf(ut[a]);\n}\nint um(int a, int b) {\n    a = uf(a);\n    b = uf(b);\n    if (a == b) return 0;\n    ut[a] = b;\n    return 1;\n}\nint visited[2000];\nint Fdfs(int now,stack<int> &bo) {\n    visited[now] = 1;\n    for (auto x : vertexs[now]) {\n        if (visited[x] == 1) continue;\n        Fdfs(x, bo);\n    }\n    bo.push(now);\n    return 0;\n}\nint Sdfs(int now) {\n    visited[now] = 1;\n    for (auto x : vertexs[now]) {\n        if (visited[x] == 1) continue;\n        um(now, x);\n        Sdfs(x);\n    }\n    return 0;\n}\npair<modint<MAX_MOD>, modint<MAX_MOD>> dp(int now, int back) {\n    pair<modint<MAX_MOD>, modint<MAX_MOD>> ans = mp(1, 1);\n    visited[now] = 1;\n    for (auto& x : vertexs[now]) {\n        if (x == back) continue;\n        pair<modint<MAX_MOD>, modint<MAX_MOD>> tmp = dp(x, now);\n        ans.first *= tmp.first;\n        ans.second *= tmp.first + tmp.second;\n    }\n    return ans;\n}\nvoid solve(){\n    int n, m;\n    cin >> n >> m;\n    vector<pair<int, int>> edges;\n    REP(i, m) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        edges.push_back(mp(b, a));\n        vertexs[b].push_back(a);\n    }\n    stack<int> go;\n    REP(i, n) {\n        if (visited[i]) continue;\n        Fdfs(i, go);\n    }\n    REP(i, n) {\n        visited[i] = 0;\n        vertexs[i].clear();\n        ut[i] = i;\n    }\n    REP(i, edges.size()) {\n        vertexs[edges[i].second].push_back(edges[i].first);\n    }\n    while (!go.empty()) {\n        int now = go.top();\n        go.pop();\n        if (visited[now]) continue;\n        Sdfs(now);\n    }\n    REP(i, edges.size()) {\n        edges[i].first = uf(edges[i].first);\n        edges[i].second = uf(edges[i].second);\n    }\n    REP(i, n) {\n        visited[i] = 0;\n        vertexs[i].clear();\n    }\n    REP(i, edges.size()) {\n        if (edges[i].first != edges[i].second) {\n            vertexs[edges[i].first].push_back(edges[i].second);\n            visited[edges[i].second] = 1;\n        }\n    }\n    modint<MAX_MOD> ans(1);\n    REP(i, n) {\n        if (visited[i]) continue;\n        if (uf(i) != i) continue;\n        pair<modint<MAX_MOD>, modint<MAX_MOD>> tmp = dp(i, -1);\n        ans *= tmp.first + tmp.second;\n    }\n    cout << ans << endl;\n}\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define All(A) A.begin(),A.end()\n#define RAll(A) A.rbegin(),A.rend()\ntypedef long long LL;\nconst LL mod=1e9+7;\nconst LL LINF=1LL<<62;\nconst LL INF=1<<30;\n \n \n \ntemplate< typename G >\nstruct StronglyConnectedComponents {\n    const G &g;\n    G gg, rg;\n    vector< int > comp, order, used;\n \n    StronglyConnectedComponents(G &g) : g(g), gg(g.size()), rg(g.size()), comp(g.size(), -1), used(g.size()) {\n        for(int i = 0; i < g.size(); i++) {\n            for(auto e : g[i]) {\n                gg[i].emplace_back((int) e);\n                rg[(int) e].emplace_back(i);\n            }\n        }\n    }\n \n    int operator[](int k) {\n        return (comp[k]);\n    }\n \n    void dfs(int idx) {\n        if(used[idx]) return;\n        used[idx] = true;\n        for(int to : gg[idx]) dfs(to);\n        order.push_back(idx);\n    }\n \n    void rdfs(int idx, int cnt) {\n        if(comp[idx] != -1) return;\n        comp[idx] = cnt;\n        for(int to : rg[idx]) rdfs(to, cnt);\n    }\n \n    void build(G &t) {\n        for(int i = 0; i < gg.size(); i++) dfs(i);\n        reverse(begin(order), end(order));\n        int ptr = 0;\n        for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n        t.resize(ptr);\n        for(int i = 0; i < g.size(); i++) {\n            for(auto &to : g[i]) {\n                int x = comp[i], y = comp[to];\n                if(x == y) continue;\n                t[x].push_back(y);\n            }\n        }\n    }\n};\n \nint main(){\n    int N,M;\n    cin >> N >> M;\n    vector<vector<int>> G(N);\n    for(int i=0;i<M;i++){\n        int u,v;\n        cin >> u >> v;\n        u--;v--;\n        G[u].pb(v);\n    }\n    StronglyConnectedComponents<vector<vector<int>>> scc(G);\n    vector<vector<int>> h;\n    scc.build(h);\n    vector<LL> dp(h.size(),0);\n    LL ans=1;\n    for(int i=0;i<h.size();i++){\n        if(!dp[i]) dp[i]=1;\n        if(h[i].size()){\n            if(dp[h[i][0]]) dp[h[i][0]]=(dp[h[i][0]]*(dp[i]+1))%mod;\n            else dp[h[i][0]]=(dp[h[i][0]]+dp[i]+1)%mod;\n        }\n        else{\n            ans=(ans*(dp[i]+1))%mod;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define MAX_V 100000\n#define N MAX_V\nusing namespace std;\ntypedef long long ll;\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\nint n,m;\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[G[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  \n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\n\nvoid mk_G(){\n  int k=scc();\n  vector <int> tmp[N],rtmp[N];\n  for(int i=0;i<n;i++){\n    for(int j=0;j<G[i].size();j++)\n      if(cmp[i]!=cmp[G[i][j]]) tmp[cmp[i]].push_back(cmp[G[i][j]]);\n    for(int j=0;j<rG[i].size();j++)\n      if(cmp[i]!=cmp[rG[i][j]]) rtmp[cmp[i]].push_back(cmp[rG[i][j]]);\n    G[i].clear();\n    rG[i].clear();\n  }\n  n=k;\n  for(int i=0;i<k;i++) G[i]=tmp[i],rG[i]=rtmp[i];\n}\n \nll calc(int pos){\n  if(used[pos]) return 1;\n  used[pos]=1;\n  ll res=1;\n  for(int i=0;i<rG[pos].size();i++)res=res*calc(rG[pos][i])%mod;\n  return (res+1)%mod;\n}\n \n\nint main(){\n  cin>>n>>m;\n  V=n;\n  for(int i=0,a,b;i<m;i++)cin>>a>>b,add_edge(a-1,b-1);\n  mk_G();\n  ll ans=1;\n  memset(used,0,sizeof(used));\n  for(int i=0;i<n;i++) if(!G[i].size())ans=ans*calc(i)%mod;\n  cout <<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstruct SCC{\n  int V;\n  vector<vector<int> > G,rG;\n  vector<int> vs,used,cmp;\n  SCC(){}\n  SCC(int sz):V(sz),G(sz),rG(sz),used(sz),cmp(sz){}\n  void add(int from,int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  } \n  void dfs(int v){\n    used[v]=1;\n    for(int i=0;i<G[v].size();i++)\n      if(!used[G[v][i]])dfs(G[v][i]);\n    vs.push_back(v);\n  }\n  void rdfs(int v,int k){\n    used[v]=1;\n    cmp[v]=k;\n    for(int i=0;i<rG[v].size();i++)\n      if(!used[rG[v][i]])rdfs(rG[v][i],k);\n  }\n  int build(){\n    fill(used.begin(),used.end(),0);\n    vs.clear();\n    for(int v=0;v<V;v++)\n      if(!used[v])dfs(v);\n    fill(used.begin(),used.end(),0);\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--)\n      if(!used[vs[i]])rdfs(vs[i],k++);\n    return k;\n  }\n  int be(int x){\n    return cmp[x];\n  }\n  bool same(int x,int y){\n    return cmp[x]==cmp[y];\n  }\n};\n\n\n// 連結成分分解　（連結成分ごとにグラフを再構築、Sはグラフの集合）\nstruct CC{\n  int n;\n  vector<vector<int> >G,rG;\n  vector<int>used;\n  vector<vector<vector<int> > >S;\n  CC(int sz):n(sz),G(sz),rG(sz),used(sz){}\n  void add(int from,int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  }\n  void CC_dfs1(int x,int &cnt,map<int,int>& m){\n    m[x]=cnt++;\n    used[x]=1;\n    for(int i=0;i<G[x].size();i++){\n      if(used[G[x][i]])continue;\n      CC_dfs1(G[x][i],cnt,m);\n    }\n    for(int i=0;i<rG[x].size();i++){\n      if(used[rG[x][i]])continue;\n      CC_dfs1(rG[x][i],cnt,m);\n    }\n  }\n  void CC_dfs2(int x,vector<vector<int> > &v,map<int,int>& m,vector<int> &vis){\n    vis[m[x]]=1;\n    for(int i=0;i<G[x].size();i++){\n      v[m[x]].push_back(m[G[x][i]]);\n      if(vis[m[G[x][i]]])continue;\n      CC_dfs2(G[x][i],v,m,vis);\n    }\n    for(int i=0;i<rG[x].size();i++){\n      if(vis[m[rG[x][i]]])continue;\n      CC_dfs2(rG[x][i],v,m,vis);\n    }\n  }\n  void build(){\n    for(int i=0;i<n;i++)used[i]=0;\n    for(int i=0;i<n;i++){\n      if(used[i])continue;\n      int cnt=0;\n      map<int,int>M;\n      CC_dfs1(i,cnt,M);\n      vector<vector<int> >v(cnt);\n      vector<int>U(cnt,0);\n      CC_dfs2(i,v,M,U);\n      S.push_back(v);\n    }\n  }\n};\nint mod=1000000007;\nint n,m,a[10002],b[10002];\nint dp[1002][2];\nsigned main(){\n  set<int>st;\n  cin>>n>>m;\n  CC C(n);\n  r(i,m){\n    cin>>b[i]>>a[i];\n    b[i]--;a[i]--;\n    st.insert(b[i]);\n    st.insert(a[i]);\n    C.add(b[i],a[i]);\n  }\n  C.build();\n  int ans=1,sum=0;\n  for(int i=0;i<C.S.size();i++){\n    memset(dp,0,sizeof(dp));\n    vector<vector<int> >A=C.S[i];\n    int N=A.size();\n    SCC S(N);\n    r(i,N){\n      r(j,A[i].size()){\n        S.add(i,A[i][j]);\n      }\n    }\n    S.build();\n    set<int>SS;\n    int c=0;\n    for(int j=N-1;j>=0;j--){  // ここに連結成分無いのDPをかく\n      int x=S.vs[j];\n      SS.insert(S.cmp[x]);\n      //cout<<S.rG[x].size()<<endl;\n      if(S.rG[x].size()==0){\n        dp[x][0]=dp[x][1]=1;c++;//cout<<\"a\"<<j<<endl;\n      }\n      else{\n        dp[x][0]=dp[x][1]=1;\n        for(int k=0;k<S.rG[x].size();k++){\n          int to=S.rG[x][k];\n          if(S.same(x,to)){\n            //dp[to][0]=dp[x][0];\n            //dp[to][1]=dp[x][1];\n          }\n          else{//cout<<to<<endl;\n            dp[x][1]*=dp[to][0]+dp[to][1];\n            dp[x][0]*=dp[to][0];\n            dp[x][1]%=mod;\n            //cout<<dp[to][1]<<' '<<dp[to][0]<<endl;\n          }\n        }\n      } \n      int X=1;\n      if(j==0){\n        if(c==0){\n          ans*=2;\n          ans%=mod;\n          break;\n        }\n        r(k,N){\n          int K=S.vs[k];\n          if(S.same(x,K)){\n            X*=dp[K][1];\n            X%=mod;\n          }\n        }\n        X++;\n        X%=mod;\n        ans*=X;\n        ans%=mod;\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <set>\n#define X first\n#define Y second\n#define sqr(x) (x)*(x)\nusing namespace std;\nconst double PI = acos(-1.0);\nmap<int,int>::iterator it;\ntypedef long long LL ;\n#pragma comment(linker,\"/STACK:102400000,102400000\")\n\nconst int N = 1005;\nconst int M = 20000006;\nstruct edge\n{\n    int u,v,pre;\n} E1[M],E2[M];\nint head[N],hd[N],nedge,cnt,dfn[N],low[N],instack[N],belong[N];\nint n,m,tsp,qlen;\nvector<int> qlt[N];\nstack<int> S;\n\nvoid init()\n{\n    for(int i=0; i<N; ++i)qlt[i].clear();\n    memset(hd,-1,sizeof(hd));\n    memset(head,-1,sizeof(head));\n    memset(dfn,-1,sizeof(dfn));\n    memset(instack,0,sizeof(instack));\n    nedge=0;\n    cnt=0;\n    tsp=0;\n    qlen=0;\n    while(!S.empty())S.pop();\n}\nvoid add_edge(int u,int v)\n{\n    E1[nedge].u=u;\n    E1[nedge].v=v;\n    E1[nedge].pre=head[u];\n    head[u]=nedge++;\n}\nvoid add_edge2(int u,int v)\n{\n    E2[cnt].u=u;\n    E2[cnt].v=v;\n    E2[cnt].pre=hd[u];\n    hd[u]=cnt++;\n}\nvoid dfs(int u)\n{\n    //printf(\"u=%d\\n\",u);\n    dfn[u]=low[u]=++tsp;\n    S.push(u);\n    instack[u]=1;\n    //puts(\"ok\");\n    for(int e=head[u]; ~e; e=E1[e].pre)\n    {\n        //printf(\"e=%d\\n\",e);\n        int v = E1[e].v;\n        //printf(\"v=%d\\n\",v);\n        if(dfn[v]==-1)\n        {\n            dfs(v);\n            low[u]=min(low[v],low[u]);\n        }\n        else if(instack[v])\n        {\n            low[u]=min(low[u],dfn[v]);\n        }\n    }\n    //printf(\"u=%d\\n\",u);\n    if(dfn[u]==low[u])\n    {\n        int p = u;\n        while(S.top()!=p)\n        {\n            qlt[qlen].push_back(S.top());\n            belong[S.top()]=qlen;\n            instack[S.top()]=0;\n            S.pop();\n        }\n        qlt[qlen].push_back(p);\n        belong[p]=qlen++;\n        instack[p]=0;\n        S.pop();\n    }\n}\nLL dp[N];\nint ind[N];\nbool vis[N];\nLL res;\nLL mod = 1000000007LL;\nvoid dfs2(int u)\n{\n    bool dfsed=false;\n    dp[u]=1;\n    for(int e=hd[u]; ~e; e=E2[e].pre)\n    {\n        int v = E2[e].v;\n        dfs2(v);\n        dp[u]*=dp[v];\n        dfsed=true;\n    }\n    ++dp[u];\n}\nvoid gao()\n{\n    memset(vis,0,sizeof(vis));\n    memset(dp,0,sizeof(dp));\n    memset(ind,0,sizeof(ind));\n    for(int i=0; i<nedge; ++i)\n    {\n        if(belong[ E1[i].u ]!=belong[ E1[i].v ])\n        {\n            ind[ belong[ E1[i].u ] ]++;\n            add_edge2(belong[ E1[i].v ],belong[ E1[i].u ]);\n        }\n    }\n    res=1;\n    for(int i=0; i<qlen; ++i)\n    {\n        if(ind[i]==0)\n        {\n            dfs2(i);\n            res *= dp[i];\n            res %= mod;\n        }\n    }\n}\nint main()\n{\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        init();\n        for(int i=0; i<m; ++i)\n        {\n            int u,v;\n            scanf(\"%d%d\",&u,&v);\n            add_edge(u,v);\n        }\n        for(int i=1; i<=n; ++i)if(dfn[i]==-1)dfs(i);\n        gao();\n        //for(int i=0; i<qlen; ++i)printf(\"%d: %lld %lld\\n\",i,dp[i][0],dp[i][1]);\n\n        printf(\"%lld\\n\",res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nconst int mod=1000000007;\nint x[1005],y[1005];\nint QKpower(int a,int k)\n{\n    int ans=1;\n    while(k)\n    {\n        if(k%2)ans=ans*a%mod;\n        a=a*a%mod;\n        k/=2;\n    }\n    return ans;\n}\nint main()\n{\n    int a,k;\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    int i,j;\n    for(i=0; i<m; i++) scanf(\"%d%d\",x+i,y+i);\n    int ans;\n    //printf(\"sum :%d\\n\",QKpower(2,n));\n    ans=QKpower(2,n)-m*QKpower(2,n-2);\n    for(i=0; i<m; i++)\n    {\n        for(j=i+1; j<m; j++)\n        {\n            if(x[i]==x[j]&&y[i]==y[j])\n            {\n                ans=(ans+QKpower(2,n-2))%mod;\n            }\n            else if((x[i]==x[j]&&y[i]!=y[j])||(x[i]!=x[j]&&y[i]==y[j]))\n                ans=(ans+QKpower(2,n-3))%mod;\n            else if(x[i]!=x[j]&&x[i]!=y[j]&&y[i]!=x[j]&&y[i]!=y[j])\n            {\n                ans=(ans+QKpower(2,n-4))%mod;\n            }\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "class in{struct It{int it;const bool rev;explicit constexpr It(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(It& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const It i,n;public:explicit constexpr in(int n):i(0),n(n<0?0:n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const It& begin(){return i;}const It& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\npair<vector<int>, int> Scc(const vector<vector<int>>& adj) {\n    const int n = adj.size();\n    vector<int> num(n, 0), low(n, 0), color(n, 0);\n    vector<int> sta;\n    vector<bool> inS(n, 0);\n    int t = 0, colnum = 0;\n    function<void(int)> visit = [&](int cur) {\n        low[cur] = num[cur] = ++t;\n        sta.emplace_back(cur); inS[cur] = 1;\n        for(int nxt : adj[cur]) {\n            if(num[nxt] == 0) {\n                visit(nxt);\n                low[cur] = min(low[cur], low[nxt]);\n            } else if(inS[nxt])\n              low[cur] = min(low[cur], num[nxt]);\n        }\n        if(low[cur] == num[cur]) {\n            while(true) {\n                int nxt = sta.back(); sta.pop_back(); inS[nxt] = false;\n                color[nxt] = colnum;\n                if(cur == nxt) break;\n            }\n            ++colnum;\n        }\n    };\n    for(int v : in(n))\n      if(num[v] == 0)\n        visit(v);\n    return make_pair(color, colnum);\n}\n\nvector<int> topologicalSort(const vector<vector<int>>& adj) {\n    int N = adj.size();\n    vector<int> deg(N);//??\\?¬???°\n    for(int i = 0; i < N; ++i)\n      for(int nv : adj[i])\n        ++deg[nv];\n    vector<int> ord(N, -1);\n    int t = 0;\n    for(int v = 0; v < N; ++v) \n      if(deg[v] == 0)\n        ord[t++] = v;\n    for(int h = 0; h < t; ++h) {\n        int v = ord[h];\n        for(int nv : adj[v]) {\n            --deg[nv];\n            if(deg[nv] == 0)\n              ord[t++] = nv;\n        }\n    }\n    return ord;\n}\n\nusing i64 = long long;\nconst i64 MOD = 1e9 + 7;\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> __adj(n);\n    for(int _ : in(m)) {\n        int u, v;\n        cin >> u >> v;\n        --u; --v;\n        __adj[u].emplace_back(v);\n    }\n    vector<int> color; int col;\n    tie(color, col) = Scc(__adj);\n    vector<vector<int>> adj(col);\n    for(int v : in(n))\n      for(int u : __adj[v])\n        if(color[u] != color[v])\n          adj[color[u]].emplace_back(color[v]);\n    for(auto& a : adj) {\n        sort(a.begin(), a.end());\n        a.erase(unique(a.begin(), a.end()), a.end());\n    }\n    vector<int> ord = topologicalSort(adj);\n    vector<i64> dp(n, -1LL);\n    i64 ans = 1LL;\n    function<i64(int)> dfs = [&](int v) {\n        i64& res = dp[v];\n        if(res != -1LL) return res;\n        res = 1LL;\n        for(int nxt : adj[v]) {\n            int u = ord[nxt];\n            res = res * dfs(u) % MOD;\n        }\n        ++res;\n        return res;\n    };\n    for(int v : ord) {\n        if(dp[v] != -1LL) continue;\n//        cout << v << ' ' << dfs(v) << endl;\n        ans = ans * dfs(v) % MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\n#include <iomanip>\n#include <fstream>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid visit(const Graph &g, int v, vector< vector<int> >& scc,\n    stack<int> &S, vector<bool> &inS,\n    vector<int> &low, vector<int> &num, int& time) {\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  FOR(e, g[v]) {\n    int w = e->dst;\n    if (num[w] == 0) {\n      visit(g, w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\nvoid stronglyConnectedComponents(const Graph& g,\n    vector< vector<int> >& scc) {\n  const int n = g.size();\n  vector<int> num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  REP(u, n) if (num[u] == 0)\n    visit(g, u, scc, S, inS, low, num, time);\n}\nbool visit(const Graph &g, int v, vector<int> &order, vector<int> &color) {\n  color[v] = 1;\n  FOR(e, g[v]) {\n    if (color[e->dst] == 2) continue;\n    if (color[e->dst] == 1) return false;\n    if (!visit(g, e->dst, order, color)) return false;\n  }\n  order.push_back(v); color[v] = 2;\n  return true;\n}\nbool topologicalSort(const Graph &g, vector<int> &order) {\n  int n = g.size();\n  vector<int> color(n);\n  REP(u, n) if (!color[u] && !visit(g, u, order, color))\n    return false;\n  reverse(ALL(order));\n  return true;\n}\n\nll dp[1000][2];\n\nint main() {\n  int n,m;\n  while(cin >> n >> m) {\n    Graph g(n);\n    REP(i,m) {\n      int a, b; cin >> a >> b;\n      a--;b--;\n      g[a].push_back(Edge(a,b,1));\n    }\n    vector<vector<int> > scc;\n    stronglyConnectedComponents(g, scc);\n    vector<int> cmp(n);\n    REP(i,scc.size())FOR(jt, scc[i])\n      cmp[*jt] = i;\n    Graph g2(scc.size());\n    map<pii, bool> mp;\n    REP(i,n) {\n      int a = cmp[i];\n      FOR(it,g[i]) {\n        int b = cmp[it->dst];\n        if (a != b) {\n          if (mp.count(pii(a,b)) == 0) {\n            mp[pii(a,b)] = 1;\n            g2[a].push_back(Edge(a,b,1));\n          }\n        }\n      }\n    }\n    vector<int> order;\n    topologicalSort(g2, order);\n    REP(i,n) dp[i][0]=dp[i][1]=1;\n    ll res = 1;\n    const ll MOD = 1e9+7;\n    FOR(it, order) {\n      if (g2[*it].size() == 0) {\n        (res *= dp[*it][0] + dp[*it][1]) %= MOD;\n      }\n      FOR(e, g2[*it]) {\n        int b = e->dst;\n        (dp[b][0] *= dp[*it][0]) %= MOD;\n        (dp[b][1] *= dp[*it][0]+dp[*it][1]) %= MOD;\n      }\n    }\n    cout << res << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n \ntypedef long long ll;\nint const inf = 1<<29;\n \nconstexpr int MOD = 1e9+7;\n \nnamespace graph { // not verified\n \nconstexpr int MaxV = 1010;\n \nstruct scc {\n \n  int V = MaxV;\n  vector<int> G[MaxV];\n  vector<int> rG[MaxV];\n  vector<int> vs;\n  vector<bool> used;\n  vector<int> comp;\n  int SCCGraphSize;\n \n  scc(): V(MaxV) { comp.resize(MaxV); }\n  scc(int V_): V(V_) { comp.resize(MaxV); }\n \n  void add_edge(int from, int to) {\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  }\n \n  void dfs(int v) {\n    used[v] = 1;\n    for(auto e: G[v]) {\n      if(!used[e]) dfs(e);\n    }\n    vs.push_back(v);\n  }\n \n  void rdfs(int v, int k) {\n    used[v] = 1;\n    comp[v] = k;\n    for(auto e: rG[v]) {\n      if(!used[e]) rdfs(e, k);\n    }\n  }\n \n  void solve() {\n    used.clear(); used.resize(MaxV);\n    vs.clear();\n    for(int i = 0; i < V; i++) {\n      if(!used[i]) dfs(i);\n    }\n    used.clear(); used.resize(MaxV);\n    int k = 0;\n    for(int i = vs.size() - 1; i >= 0; i--) {\n      if(!used[vs[i]]) rdfs(vs[i], k++);\n    }\n    SCCGraphSize = k;\n  }\n \n};\n \n}\n \nvector<vector<int>> tree;\n \nll solve(int curr, int par) {\n  ll ret = 1;\n  for(auto e: tree[curr]) {\n    if(e == par) continue;\n    ret *= solve(e, curr);\n    ret %= MOD;\n  }\n  return ret;\n}\n \nint main() {\n \n  int N, M; cin >> N >> M;\n  graph::scc scc_graph(N);\n  rep(i, M) {\n    int S, D; cin >> S >> D; S --, D --;\n    scc_graph.add_edge(S, D);\n  }\n \n  scc_graph.solve();\n \n  auto& K = scc_graph.SCCGraphSize;\n  auto& g = scc_graph.G;\n  auto& comp = scc_graph.comp;\n \n  tree.resize(K);\n  int deg[1010] = {};\n \n  rep(i, N) {\n    for(auto e: g[i]) {\n      if(comp[i] == comp[e]) continue;\n      tree[comp[e]].push_back(comp[i]);\n      deg[comp[i]] ++;\n    }\n  }\n \n  rep(i, K) {\n    sort(tree[i].begin(), tree[i].end());\n    tree[i].erase(unique(tree[i].begin(), tree[i].end()), tree[i].end());\n  }\n \n  ll ans = 1;\n \n  rep(i, K) if(deg[i] == 0 && dp[i] < 0) {\n    ans *= solve(i, -1);\n    ans %= MOD;\n  }\n \n  cout << ans << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nstruct uf {\nprivate:\n\tvector<int> par, ran;\npublic:\n\tvoid init(int n) {\n\t\tpar.resize(n, 0);\n\t\tran.resize(n, 0);\n\t\trep(i, n) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (ran[x] == ran[y])ran[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nstruct graph {\nprivate:\n\tint n;\n\tvector<vector<int>> G, rG;\n\tvector<bool> used;\n\tvector<int> vs;\n\n\tint mk;\n\tvector<vector<int>> fG;\n\tvector<int> par;\n\tvector<vector<int>> ori;\n\tvector<int> trans;\npublic:\n\tgraph(int sz) {\n\t\tn = sz;\n\t\tG.resize(n);\n\t\trG.resize(n);\n\t\tused.resize(n);\n\n\t\tfG.resize(n);\n\t\ttrans.resize(n, -1);\n\t\tori.resize(n);\n\t\tpar.resize(n,-1);\n\t}\n\tvoid add_edge(int a, int b) {\n\t\tG[a].push_back(b);\n\t\trG[b].push_back(a);\n\t}\n\tvoid dfs(int v) {\n\t\tused[v] = true;\n\t\trep(i, G[v].size()) {\n\t\t\tif (!used[G[v][i]])dfs(G[v][i]);\n\t\t}\n\t\tvs.push_back(v);\n\t}\n\tvoid rdfs(int v, int k) {\n\t\tused[v] = true;\n\t\tqueue<int> q; q.push(v);\n\t\tvector<int> c;\n\t\twhile (!q.empty()) {\n\t\t\tint id = q.front(); q.pop();\n\t\t\tori[k].push_back(id);\n\t\t\trep(j, rG[id].size()) {\n\t\t\t\tint to = rG[id][j];\n\t\t\t\tif (used[to]) {\n\t\t\t\t\tif (trans[to] >= 0)c.push_back(trans[to]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tused[to] = true; q.push(to);\n\t\t\t}\n\t\t}\n\t\tsort(c.begin(), c.end());\n\t\tint len = unique(c.begin(), c.end()) - c.begin();\n\t\trep(i, len) {\n\t\t\tfG[c[i]].push_back(k);\n\t\t\tpar[k] = c[i];\n\t\t}\n\t\trep(i, ori[k].size()) {\n\t\t\ttrans[ori[k][i]] = k;\n\t\t}\n\t}\n\tvoid scc() {\n\t\tfill(used.begin(), used.end(), false);\n\t\trep(i, n) {\n\t\t\tif (!used[i])dfs(i);\n\t\t}\n\t\tfill(used.begin(), used.end(), false);\n\t\tint k = 0;\n\t\tper(i, (int)vs.size()) {\n\t\t\tif (!used[vs[i]]) {\n\t\t\t\trdfs(vs[i], k); k++;\n\t\t\t}\n\t\t}\n\t\tmk = k;\n\t}\n\tLP cdfs(int id) {\n\t\tvector<LP> v;\n\t\trep(j, fG[id].size()) {\n\t\t\tint to = fG[id][j];\n\t\t\tv.push_back(cdfs(to));\n\t\t}\n\t\tll sal = 1, ss = 1;\n\t\trep(i, v.size()) {\n\t\t\tsal = sal * (v[i].first + v[i].second) % mod;\n\t\t\tss = ss * v[i].first%mod;\n\t\t}\n\t\treturn { ss,sal };\n\t}\n\tll query(int id) {\n\t\t\n\t\tid = trans[id];\n\t\twhile (par[id] >= 0)id = par[id];\n\t\tLP p = cdfs(id);\n\t\tll ret = p.first + p.second; if (ret >= mod)ret -= mod;\n\t\t//cout << ret << endl;\n\t\treturn ret;\n\t}\n\n};\nvoid solve() {\n\tint n, m; cin >> n >> m;\n\tgraph g(n);\n\tuf u; u.init(n + 1);\n\trep(i, m) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tg.add_edge(b, a);\n\t\tu.unite(a, b);\n\t}\n\tg.scc();\n\tll ans = 1;\n\trep(i, n) {\n\t\tif (u.same(i, n))continue;\n\t\tans = ans * g.query(i) % mod;\n\t\tu.unite(i, n);\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_V 5000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst long long int MOD = 1000000007;\nconst long long int INF = 10000000000000000;\n\nint n, m;\nvector<int> e[1000], r[1000];\nint id[1000];\nbool saw[1000];\nll ans = 1;\n\nbool check(int v, int p){\n    bool ret = true;\n    if(saw[v]) return true;\n    saw[v] = true;\n    rep(i,e[v].size()){\n        if(e[v][i] == p){\n            ret = false;\n            break;\n        }\n        ret = check(e[v][i],p);\n    }\n    if(!ret) id[v] = p;\n    return ret;\n}\n\nll dfs(int v){\n    v = id[v];\n    ll ret = 1;\n    if(r[v].size() == 0){\n        return 2;\n    }\n    rep(i,r[v].size()){\n        ret += dfs(r[v][i]);\n    }\n    return ret;\n}\n\nint main(){\n    cin >> n >> m;\n    rep(i,n) id[i] = i;\n    rep(i,m){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        e[a].push_back(b);\n        r[b].push_back(a);\n    }\n    rep(i,n){\n        memset(saw,0,sizeof(saw));\n        if(id[i] != i) continue;\n        check(i,i);\n    }\n    rep(i,n){\n        if(id[i] != i){\n            copy(e[i].begin(),e[i].end(),back_inserter(e[id[i]]));\n            copy(r[i].begin(),r[i].end(),back_inserter(r[id[i]]));\n            sort(e[id[i]].begin(),e[id[i]].end());\n            e[id[i]].erase(unique(e[id[i]].begin(),e[id[i]].end()),e[id[i]].end());\n            sort(r[id[i]].begin(),r[id[i]].end());\n            r[id[i]].erase(unique(r[id[i]].begin(),r[id[i]].end()),r[id[i]].end());\n        }\n    }\n    rep(i,n){\n        vector<int> z;\n        if(id[i] != i) continue;\n        rep(j,e[i].size()){\n            if(id[e[i][j]] != i) z.push_back(e[i][j]);\n        }\n        e[i] = z;\n        z.clear();\n        rep(j,r[i].size()){\n            if(id[r[i][j]] != i) z.push_back(r[i][j]);\n        }\n        r[i] = z;\n       \n    }\n    rep(i,n){\n        if(e[i].size() > 0) continue;\n        ans = ans*dfs(i)%MOD;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define llint long long\n#define mod 1000000007\n#define rep(x, s, t) for(llint x = s; x <= t; x++)\n\nusing namespace std;\n\nllint n, m;\nvector<llint> G[1005], revG[1005];\nbool used[1005], cycle[1005];\nllint pre[1005];\nbool out[1005];\nllint dp[1005];\nvector<llint> cvec, tvec;\n\nllint dfs(llint v){\n\tused[v] = true;\n\tllint u = G[v][0];\n\tif(used[u]){\n\t\tcycle[v] = true;\n\t\tcvec.push_back(v);\n\t\tif(u == v) return -1;\n\t\treturn u;\n\t}\n\tllint res = dfs(u);\n\tif(res != -1) cycle[v] = true, cvec.push_back(v);\n\tif(res == v) res = -1;\n\treturn res;\n}\n\nllint id;\nvoid dfs2(llint v)\n{\n\tused[v] = true;\n\ttvec.push_back(v); \n\tpre[v] = id, id++;\n\trep(i, 0, (int)revG[v].size()-1){\n\t\tllint u = revG[v][i];\n\t\tif(G[v][0] == u) continue;\n\t\tif(cycle[u]) continue;\n\t\tdfs2(u);\n\t}\n\tout[id] = true;\n\ttvec.push_back(v); id++;\n\t\n}\n\nllint calc(llint v)\n{\n\ttvec.clear();\n\ttvec.push_back(0), id = 1;\n\tdfs2(v);\n\t\n\tllint n = (int)tvec.size()-1;\n\trep(i, 0, n) dp[i] = 0;\n\tdp[0] = 1;\n\t\n\trep(i, 1, n){\n\t\tllint u = tvec[i];\n\t\tif(out[i]){\n\t\t\tdp[i] = dp[pre[u]] + dp[i-1];\n\t\t\tdp[i] %= mod;\n\t\t}\n\t\telse dp[i] = dp[i-1];\n\t}\n\tdp[n] += mod-1, dp[n] %= mod;\n\treturn dp[n];\n}\n\nllint solve(llint r)\n{\n\tcvec.clear();\n\tdfs(r);\n\t\n\t//rep(i, 0, (int)cvec.size()-1) cout << cvec[i] << ' '; cout << endl;\n\t\n\tllint ret = 1;\n\trep(i, 0, (int)cvec.size()-1){\n\t\tret *= calc(cvec[i]), ret %= mod;\n\t}\n\tret += 1, ret %= mod;\n\t//cout << r << ' ' << ret << endl;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> n >> m;\n\tllint u, v;\n\trep(i, 1, m){\n\t\tcin >> u >> v;\n\t\tG[u].push_back(v);\n\t\trevG[v].push_back(u);\n\t}\n\trep(i, 1, n){\n\t\tif(G[i].size() == 0) G[i].push_back(i);\n\t}\n\t\n\tllint ans = 1;\n\trep(i, 1, n){\n\t\tif(!used[i]) ans *= solve(i), ans %= mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nconst int mod = 1e9 + 7;\n\nconst int N = 11111;\n\nint n, m;\nint edge[N], in[N], out[N], length[N];\nbool visit[N];\n\nint main(void) {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= m; ++i) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tedge[x] = y;\n\t\t\n\t\tin[y]++;\n\t\tout[x]++;\n\t}\n\t\n\tfor (int i = 1; i <= n; ++i) {\n\t\tlength[i] = 1;\n\t}\n\t\n\tstd::vector<int> queue;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (in[i] == 0) {\n\t\t\tqueue.push_back(i);\n\t\t}\n\t}\n\tfor (int head = 0; head < (int)queue.size(); ++head) {\n\t\tint x = queue[head];\n\t\tvisit[x] = true;\n\n\t\tint y = edge[x];\n\t\tlength[y] = length[x] + 1;\n\t\tlength[y] %= mod;\n\t\t\n\t\tif ((--in[y]) == 0) {\n\t\t\tqueue.push_back(y);\n\t\t}\n\t}\n\t\n\tlong long answer = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (out[i] == 0) {\n\t\t\tvisit[i] = true;\n\t\t\tanswer *= length[i] + 1;\n\t\t\tanswer %= mod;\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (!visit[i]) {\n\t\t\tlong long counter = 1;\n\t\t\tfor (int j = i; !visit[j]; j = edge[j]) {\n\t\t\t\tvisit[j] = true;\n\t\t\t\tcounter *= length[j];\n\t\t\t\tcounter %= mod;\n\t\t\t}\n\t\t\tanswer *= counter + 1;\n\t\t\tanswer %= mod;\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", (int)answer);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\n#define REP(i, b, n) for(int i = b; i < (int)n; i++)\n#define rep(i, n) REP(i, 0, n)\n\nusing namespace std;\n\ntypedef unsigned long long ll;\n\nconst int N = 1000;\nconst ll MOD = 1000000007;\n\n\nint V, cmp[N];\nvector<int> G[N], rG[N], vs;\nbool used[N];\nvoid init(){\n  rep(i, N){\n    G[i].clear();\n    rG[i].clear();\n  }\n  vs.clear();\n}\n\nvoid add_edge(int from, int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v] = true;\n  rep(i, G[v].size()){\n    if(!used[G[v][i]])dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n  used[v] = true;\n  cmp[v] = k;\n  rep(i, rG[v].size()){\n    if(!used[rG[v][i]])rdfs(rG[v][i], k);\n  }\n}\n\nint scc(){\n  rep(i, N)used[i] = false;\n  vs.clear();\n  rep(v, V){\n    if(!used[v])dfs(v);\n  }\n  rep(i, N)used[i] = false;\n  int k = 0;\n  for(int i = vs.size() -1; i>=0; i--){\n    if(!used[vs[i]])rdfs(vs[i], k++);\n  }\n  return k;\n}\n\n\npair<ll, ll> dp[N];\nvector<int> edge[N];\n\n\npair<ll, ll> solve(int id){\n  if(dp[id].first > 0 )return dp[id];\n  pair<ll, ll> ret = make_pair(1, 1);\n  rep(i, edge[id].size()){\n    ll next = edge[id][i];\n    pair<ll, ll> result = solve(next);\n    ret.first *= (result.first + result.second)%MOD;\n    ret.second *= result.second;\n    ret.first %= MOD;\n    ret.second %= MOD;\n  }\n  return ret;\n}\n\nint main(){\n  int n, m;\n  bool first = true;\n  while(cin >> n >> m){\n    assert(first);\n    first = false;\n    if(n == 0 && m == 0)break;\n    V = n;\n    init();\n    vector<pair<int, int> > INPUT;\n    rep(i, m){\n      int from, to;\n      cin >> from >> to;\n      INPUT.push_back(make_pair(to-1,from-1));\n      add_edge(to-1, from-1);\n    }\n    int cnt = scc();\n    bool root[N];\n    rep(i, N)root[i] = true;\n    rep(i, N)edge[i].clear();\n    rep(i, INPUT.size()){\n      if(cmp[INPUT[i].first] == cmp[INPUT[i].second])continue;\n      edge[cmp[INPUT[i].first]]\t.push_back(cmp[INPUT[i].second]);\n      root[cmp[INPUT[i].second]] = false;\n    }\n    \n    rep(i, N)dp[i] = make_pair(0, 0);\n    \n    ll ans = 1;\n    rep(i, cnt){\n      if(root[i] == true){\n\tpair<ll, ll> ret = solve(i);\n\tans *= (ret.first + ret.second)%MOD;\n\tans %= MOD;\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\n#define abs(x) ((x)>=0?(x):-(x))\n#define i64 long long\n#define u32 unsigned int\n#define u64 unsigned long long\n#define clr(x,y) memset(x,y,sizeof(x))\n#define PI acos(-1.0)\n#define sqr(x) ((x)*(x))\n#define mod 1000000007\n#define maxn 2005\n\nstruct node\n{\n  int v,next;\n};\nnode e[maxn * 2 ];\nint head[maxn];\nint cnt;\nint ind[maxn];\nvoid init()\n{\n  memset(head,-1,sizeof(head));\n  cnt = 0;\n}\nvoid add(int u ,int v  )\n{\n  e[cnt].v = v ;\n  e[cnt].next = head[u];\n  head[u] = cnt ++ ;\n\n  return ;\n}\nint col[maxn];\nint dfn[maxn],low[maxn];\nint st[maxn];\nint top;\nint scnt;\nint dep ;\nbool instack[maxn];\nint mp[maxn][maxn];\n\nvoid tarjan(int u)\n{\n  //printf(\"u = %d\\n\",u);\n  dfn[u]=low[u]=dep++;\n  st[++top]=u;\n  instack[u]=true;\n  int v;\n  for(int i = head[u]; i != -1; i = e[i].next)\n  {\n    v = e[i].v;\n    if (dfn[v]==-1)\n    {\n      tarjan(v);\n      low[u]=min(low[u],low[v]);\n    }\n    else if (instack[v]) low[u]=min(low[u],dfn[v]);\n  }\n  if (dfn[u]==low[u])\n  {\n    int x;\n    do\n    {\n      x=st[top--];\n      instack[x]=false;\n      col[x]=scnt;\n    }\n    while (x != u);\n    scnt++;\n  }\n  return ;\n}\nint n,m;\nvoid base()\n{\n  memset(dfn,-1,sizeof(dfn));\n  memset(instack,0,sizeof(instack));\n  top = 0 ;\n  scnt = 1 ;\n  dep = 0 ;\n  for(int i = 1 ; i <= n ; i ++ )\n  {\n    if(dfn[i] == -1)\n    {\n      tarjan(i);\n    }\n  }\n  memset(mp,0,sizeof(mp));\n  memset(ind,0,sizeof(ind));\n  for(int i = 1 ; i <= n ; i ++ )\n  {\n    for(int j = head[i] ; j != -1 ; j = e[j].next)\n    if(col[e[j].v] != col[i])\n    {\n      ind[col[i]] ++ ;\n      mp[col[e[j].v]][col[i]] = 1 ;\n     // printf(\"%d %d\\n\",col[e[j].v],col[i]);\n    }\n  }\n}\ni64 dfs(int u )\n{\n  i64 res,tmp;\n  res = 1 ;\n  for(int i = 1 ; i <  scnt ; i ++ )\n    if(mp[u][i] == 1 )\n    {\n      tmp = dfs(i);\n      res = (res * tmp) % mod;\n    }\n  res = (res + 1 ) % mod ;\n  return res ;\n}\nint main()\n{\n  int u,v;\n  while(scanf(\"%d%d\",&n,&m)!=EOF)\n  {\n    init();\n    for(int i = 0; i < m; i ++ )\n    {\n      scanf(\"%d%d\",&u,&v);\n      add(u,v);\n    }\n    base();\n    i64 ans ,tmp;\n    ans = 1 ;\n    for(int i = 1; i < scnt ; i ++ )\n    if(ind[i] == 0)\n    {\n      tmp = dfs(i);\n      //printf(\"tmp = %d\\n\",tmp);\n      ans = (ans * tmp) % mod ;\n    }\n    printf(\"%I64d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\n#define mod 100000007LL\n\n\ntemplate<typename T>\nclass UF {\npublic:\n\tUF() {\n\t\tsize = 0;\n\t}\n\n\t//???????????\\??????\n\tvoid push( T a ) {\n\t\tM[a] = size;\n\t\tV.push_back( size );\n\t\trank.push_back( 0 );\n\t\tC.push_back( 1 );\n\t\tsize++;\n\t}\n\n\t//????????°??????????????????\n\tvoid unite( T a, T b ) {\n\t\tlong long int x = find( M[a] );\n\t\tlong long int y = find( M[b] );\n\t\tif( x == y )return;\n\t\tif( rank[x] < rank[y] ) {\n\t\t\tV[x] = y;\n\t\t\tC[y] += C[x];\n\t\t} else {\n\t\t\tV[y] = x;\n\t\t\tC[x] += C[y];\n\t\t\tif( rank[x] == rank[y] )rank[x]++;\n\t\t}\n\t}\n\n\tvoid merge( T a, T b ) {\n\t\tunite( a, b );\n\t}\n\n\t//????????°??????????????????????????????????????????\n\tbool same( T a, T b ) {\n\t\treturn find( M[a] ) == find( M[b] );\n\t}\n\n\t//????????°????????????????????°?????????\n\tlong long int group() {\n\t\tset<long long int>S;\n\t\tfor( long long int i = 0; i < V.size(); i++ ) {\n\t\t\tS.insert( find( V[i] ) );\n\t\t}\n\t\treturn S.size();\n\t}\n\n\t//??°?????????????±???????????????°?????????\n\tlong long int count( T a ) {\n\t\treturn C[find( M[a] )];\n\t}\n\n\t//????±???????????????°????????????ID?????????\n\tlong long int groupID( T a ) {\n\t\treturn find( M[a] );\n\t}\n\n\t//????????°?????????????????????????????????\n\tvector<T>friendList( T a ) {\n\t\tlong long int inputID = find( M[a] );\n\t\tvector<T>ret;\n\t\tfor( auto now : M ) {\n\t\t\tif( find( now.second ) == inputID ) {\n\t\t\t\tret.emplace_back( now.first );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\nprivate:\n\tvector<long long int>C, V, rank;\n\tmap < T, long long int>M;\n\tlong long int size;\n\n\t//?\\?????????§?????????\n\tlong long int find( long long int x ) {\n\t\tif( V[x] == x )return x;\n\t\telse return V[x] = find( V[x] );\n\t}\n};\n\n\n\nint main() {\n\tlong long int N, M;\n\tcin >> N >> M;\n\tUF<long long int>uf;\n\tfor( size_t i = 0; i < N; i++ ) {\n\t\tuf.push( i );\n\t}\n\tvector<vector<long long int>>D( N );\n\tvector<vector<long long int>>F( N );\n\tfor( size_t i = 0; i < M; i++ ) {\n\t\tlong long int x, y;\n\t\tcin >> x >> y;\n\t\tx--; y--;\n\t\tD[x].push_back( y );\n\t\tF[y].push_back( x );\n\t\tuf.merge( x, y );\n\t}\n\n\tlong long int ans = 1;\n\tset<long long int>checked;\n\tvector<bool>checkbool( N );\n\tfor( size_t i = 0; i < N; i++ ) {\n\t\tif( !checked.count( uf.groupID( i ) ) ) {\n\t\t\tchecked.insert( uf.groupID( i ) );\n\t\t\tauto group = uf.friendList( i );\n\n\t\t\tlong long int now = i;\n\t\t\twhile( !checkbool[now] && D[now].size() ) {\n\t\t\t\tnow = D[now][0];\n\t\t\t\tcheckbool[now] = true;\n\t\t\t}\n\n\n\t\t\tfunction<long long int( long long int )> f = [&]( long long int idx )->long long int {\n\t\t\t\t//cout << idx << endl;\n\t\t\t\tlong long int ret = 1;\n\t\t\t\tfor( auto x : F[idx] ) {\n\t\t\t\t\tret *= f( x );\n\t\t\t\t\tret %= mod;\n\t\t\t\t}\n\t\t\t\treturn ret + 1;\n\t\t\t};\n\t\t\tif( D[now].size() ) {\n\t\t\t\tauto now_ = D[now][0];\n\t\t\t\twhile( now_ != now ) {\n\t\t\t\t\tauto prev = now_;\n\t\t\t\t\tfor( auto x : F[now_] ) {\n\t\t\t\t\t\tif( x != prev ) {\n\t\t\t\t\t\t\tF[now].push_back( x );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnow_ = D[now_][0];\n\t\t\t\t}\n\t\t\t\tnow_ = D[now][0];\n\t\t\t\tF[now].erase( remove_if( F[now].begin(), F[now].end(), [&]( auto i ) { return i == now; } ), F[now].end() );\n\t\t\t\twhile( now_ != now ) {\n\t\t\t\t\tF[now].erase( remove_if( F[now].begin(), F[now].end(), [&]( auto i ) { return i == now_; } ), F[now].end() );\n\t\t\t\t\tnow_ = D[now_][0];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans *= f( now );\n\t\t\tans %= mod;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<deque>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<queue>\n#include<cassert>\n#include<climits>\n\n#define MOD (1000000007)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 2000\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef pair<int,int> ii;\n\nstruct Data{\n  int  to,cost;\n  Data(int to=IINF,int cost=IINF):to(to),cost(cost){}\n};\n\n// Library - topological sort - begin \n\ntemplate<typename T>\nbool visit(const T& G,int v,vector<int>& order,vector<int>& color)\n{\n  color[v] = 1;\n  for(__typeof((G[v]).begin()) e = G[v].begin();e != G[v].end();e++)\n    {\n      if(color[e->to] == 2)continue;//このvisit以外のvisitで訪れた\n      if(color[e->to] == 1)return false;//このvisitで訪れた\n      if(!visit(G,e->to,order,color))return false;\n    }\n  order.push_back(v);\n  color[v] = 2;\n  return true;\n}\n\ntemplate<typename T>\nbool topologicalSort(const T& G,vector<int>& order)\n{\n  int SizeG = G.size();\n  vector<int> color(SizeG); \n  for(int u=0;u<SizeG;u++)\n    if(!color[u] && !visit(G,u,order,color))\n      return false;\n  reverse(order.begin(),order.end());\n  return true;\n}\n\n// Library - topological sort - end\n\nint V,E,S,D;\nvector<vector<Data> > tmp_G,tmp_rG;\nvector<int>  G[MAX];\nvector<int> rG[MAX];\nvector<int> vs;\nbool used[MAX];\nint cmp[MAX];\null dp[MAX];\n\ninline void add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k = 0;\n  for(int i = vs.size(); i >= 0 ; i-- )if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nint main(){\n\n  cin >> V >> E;\n  rep(i,E){\n    cin >> S >> D;\n    add_edge(S-1,D-1);\n  }\n  int nV = scc();\n  rep(i,nV)dp[i] = 0;\n\n  set<int> OUT_counter[nV];\n  rep(i,V)rep(j,G[i].size()){\n    if(cmp[i] == cmp[G[i][j]])continue;\n    OUT_counter[cmp[i]].insert(cmp[G[i][j]]);\n  }\n\n  tmp_G.clear(),tmp_rG.clear();\n  tmp_G.resize(nV),tmp_rG.resize(nV);\n  rep(i,nV)for(int j : OUT_counter[i]){\n    tmp_G[i].push_back(j);\n    tmp_rG[j].push_back(i);\n  }\n\n  vector<int> order;\n  topologicalSort(tmp_G,order);\n\n  rep(i,nV)if(tmp_rG[order[i]].empty())dp[order[i]] = 2ULL;\n\n  ull ans = 1;\n\n  rep(i,nV){\n    int cur = order[i];\n    ull cost = 1;\n    rep(j,tmp_rG[cur].size()){\n      int prev = tmp_rG[cur][j].to;\n      cost = ( cost * dp[prev] ) % MOD;\n    }\n    if(!tmp_rG[cur].empty())dp[cur] = ( dp[cur] + cost + 1ULL ) % MOD;\n    if(tmp_G[cur].empty())ans = ( ans * dp[cur] ) % MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n \ntypedef long long ll;\nint const inf = 1<<29;\n \nconstexpr int MOD = 1e9+7;\n \nnamespace graph { // not verified\n \nconstexpr int MaxV = 1010;\n \nstruct scc {\n \n  int V = MaxV;\n  vector<int> G[MaxV];\n  vector<int> rG[MaxV];\n  vector<int> vs;\n  vector<bool> used;\n  vector<int> comp;\n  int SCCGraphSize;\n \n  scc(): V(MaxV) { comp.resize(MaxV); }\n  scc(int V_): V(V_) { comp.resize(MaxV); }\n \n  void add_edge(int from, int to) {\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  }\n \n  void dfs(int v) {\n    used[v] = 1;\n    for(auto e: G[v]) {\n      if(!used[e]) dfs(e);\n    }\n    vs.push_back(v);\n  }\n \n  void rdfs(int v, int k) {\n    used[v] = 1;\n    comp[v] = k;\n    for(auto e: rG[v]) {\n      if(!used[e]) rdfs(e, k);\n    }\n  }\n \n  void solve() {\n    used.clear(); used.resize(MaxV);\n    vs.clear();\n    for(int i = 0; i < V; i++) {\n      if(!used[i]) dfs(i);\n    }\n    used.clear(); used.resize(MaxV);\n    int k = 0;\n    for(int i = vs.size() - 1; i >= 0; i--) {\n      if(!used[vs[i]]) rdfs(vs[i], k++);\n    }\n    SCCGraphSize = k;\n  }\n \n};\n \n}\n \nvector<vector<int>> tree;\n \nll solve(int curr, int par) {\n  ll ret = 1;\n  for(auto e: tree[curr]) {\n    if(e == par) continue;\n    ret *= solve(e, curr);\n    ret %= MOD;\n  }\n  return ret;\n}\n \nint main() {\n \n  int N, M; cin >> N >> M;\n  graph::scc scc_graph(N);\n  rep(i, M) {\n    int S, D; cin >> S >> D; S --, D --;\n    scc_graph.add_edge(S, D);\n  }\n \n  scc_graph.solve();\n \n  auto& K = scc_graph.SCCGraphSize;\n  auto& g = scc_graph.G;\n  auto& comp = scc_graph.comp;\n \n  tree.resize(K);\n  int deg[1010] = {};\n \n  rep(i, N) {\n    for(auto e: g[i]) {\n      if(comp[i] == comp[e]) continue;\n      tree[comp[e]].push_back(comp[i]);\n      deg[comp[i]] ++;\n    }\n  }\n \n  rep(i, K) {\n    sort(tree[i].begin(), tree[i].end());\n    tree[i].erase(unique(tree[i].begin(), tree[i].end()), tree[i].end());\n  }\n \n  ll ans = 1;\n \n  rep(i, K) if(deg[i] == 0) {\n    ans *= solve(i, -1);\n    ans %= MOD;\n  }\n \n  cout << ans << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto (itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// sccdしてcmpから新しいグラフを作る\n// dp[i][j]: 頂点iを塗らない/塗る(j)場合の数\n// iの子kに対して dp[i][0] = dp[k][0]+dp[k][1], dp[i][1] = dp[k][1]\n// 辺の向きは逆にしたほうがたぶん楽\n// 塗らない->その子は完全に自由 塗る->その子も全部塗るしかない\n\n// initで頂点数を指定してsccで成分分解を実行 返り値は強連結成分の個数==grpのサイズ\n// grp[i]:i番目の強連結成分に含まれる頂点一覧\n// cmp[i]:頂点iが属する強連結成分の番号 この番号も⇡のiもトポロジカル順\nclass SCC {\n\tpublic:\n\tstatic const int MV = 1010;\n\tvector<vector<int> > grp; int NV,cmp[MV];\n\tvector<int> E[MV], RE[MV], NUM; int vis[MV];\n\tvoid init(int NV) { this->NV=NV; for(int i=0;i<MV;i++) { E[i].clear(); RE[i].clear();}}\n\tvoid add(int x,int y) { E[x].push_back(y); RE[y].push_back(x); }\n\tvoid dfs(int cu) { vis[cu]=1; for(int i=0;i<E[cu].size();i++) if(!vis[E[cu][i]]) dfs(E[cu][i]); NUM.push_back(cu); }\n\tvoid revdfs(int cu, int ind) {vis[cu]=1; cmp[cu]=ind; grp[ind].push_back(cu);\n\t\tfor(int i=0;i<RE[cu].size();++i) if(!vis[RE[cu][i]]) revdfs(RE[cu][i],ind);}\n\tint scc() {\n\t\tint c=0; grp.clear(); grp.resize(MV); NUM.clear();\n\t\tmemset(vis,0,sizeof(vis)); for(int i=0;i<NV;i++) if(!vis[i]) dfs(i);\n\t\tmemset(vis,0,sizeof(vis)); for(int i=NUM.size()-1;i>=0;i--) if(!vis[NUM[i]])\n\t\t\t{ grp[c].clear(); revdfs(NUM[i],c); sort(grp[c].begin(),grp[c].end()); c++;}\n\t\tgrp.resize(c); return c;\n\t}\n};\n\nint n, m, a[1000], b[1000];\nbool us[1000];\nSCC scc;\nvi e[1000];\n\nll rec(int v) {\n\tus[v] = 1;\n\tll res = 1;\n\teach(i,e[v]) (res *= rec(i)) %= mod;\n\treturn res + 1;\n}\n\nsigned main() {\n\tcin >> n >> m;\n\tscc.init(n);\n\trep(i,m) {\n\t\tcin >> a[i] >> b[i];\n\t\ta[i]--, b[i]--;\n\t\tscc.add(a[i],b[i]);\n\t}\n\tint g = scc.scc();\n\trep(i,m) if (scc.cmp[b[i]]!=scc.cmp[a[i]]) e[scc.cmp[b[i]]].pb(scc.cmp[a[i]]);\n\tll res = 1;\n\trepr(i,g-1) if (!us[i]) (res *= rec(i)) %= mod;\n\tcout << res << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MAX 1005\nll mod=1e9+7;\nint n,m,a,b;\nvector<int> G[MAX],g[MAX];\nint p[MAX];\nbool flg[MAX];\n \nint update(int x){\n  flg[x]=true;\n  if(p[x]==x)return x;\n  return p[x]=update(p[x]);\n}\n \nint find(int x){\n  if(p[x]==x)return x;\n  return find(p[x]);\n}\n \nll dfs(int pos){\n  ll res=1;\n  for(int i=0;i<(int)g[pos].size();i++)\n    res=res*dfs(g[pos][i])%mod;\n  return res+1;\n}\n \nint main(){\n  cin>>n>>m;\n    for(int i=1;i<=n;i++)p[i]=i;\n    for(int i=0;i<m;i++){\n      cin>>a>>b;\n      G[b].push_back(a);\n      if(find(b)==a)update(b);\n      else p[a]=b;\n    }\n    for(int i=1;i<=n;i++){\n      for(int j=0;j<(int)G[i].size();j++){\n        int w=G[i][j];\n        if(flg[w])continue;\n        if(flg[i])g[p[i]].push_back(w);\n        else g[i].push_back(w);\n      }\n    }\n    ll ans=1;\n    for(int i=1;i<=n;i++)if(p[i]==i)ans=ans*dfs(i)%mod;\n    cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_V 5000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst long long int MOD = 1000000007;\nconst long long int INF = 10000000000000000;\n\nint n, m;\nint e[1000];\nvector<int> r[1000];\nint id[1000];\nbool saw[1000];\nll ans = 1;\n\nbool check(int v, int p){\n    if(saw[v]) return true;\n    if(e[v] == -1) return true;\n    \n    bool ret = true;\n    saw[v] = true;\n    if(e[v] == p){\n        ret = false;\n        id[v] = p;\n        return ret;\n    }\n    ret = check(e[v],p);\n    \n    if(!ret) id[v] = p;\n    return ret;\n}\n\nll dfs(int v){\n    v = id[v];\n    ll ret = 1;\n    if(r[v].size() == 0){\n        return 2;\n    }\n    rep(i,r[v].size()){\n        ret = (ret*dfs(r[v][i]))%MOD;\n    }\n    return (ret+1)%MOD;\n}\n\nint main(){\n    cin >> n >> m;\n    rep(i,n) id[i] = i;\n    memset(e,-1,sizeof(e));\n    rep(i,m){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        e[a] = b;\n        r[b].push_back(a);\n    }\n    rep(i,n){\n        memset(saw,0,sizeof(saw));\n        if(id[i] != i) continue;\n        check(i,i);\n    }\n    rep(i,n){\n        if(id[i] != i){\n            copy(r[i].begin(),r[i].end(),back_inserter(r[id[i]]));\n            sort(r[id[i]].begin(),r[id[i]].end());\n            r[id[i]].erase(unique(r[id[i]].begin(),r[id[i]].end()),r[id[i]].end());\n        }\n    }\n    rep(i,n){\n        if(id[i] != i) continue;\n        if(id[e[i]] == i) e[i] = -1;\n        vector<int> z;\n        rep(j,r[i].size()){\n            if(id[r[i][j]] != i) z.push_back(r[i][j]);\n        }\n        r[i] = z;\n       \n    }\n    rep(i,n){\n        if(e[i] != -1) continue;\n        if(id[i] != i) continue;\n        ans = ans*dfs(i)%MOD;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\n// ModInt begin\n\nusing ll = long long;\ntemplate<ll mod>\nstruct ModInt {\n    ll v;\n    ll mod_pow(ll x, ll n) const {\n        return (!n) ? 1 : (mod_pow((x*x)%mod,n/2) * ((n&1)?x:1)) % mod;\n    }\n    ModInt(ll a = 0) : v(a >= mod ? a % mod : a) {}\n    ModInt operator+ ( const ModInt& b ) const {\n        return (v + b.v >= mod ? ModInt(v + b.v - mod) : ModInt(v + b.v));\n    }\n    ModInt operator- () const {\n        return ModInt(-v);\n    }\n    ModInt operator- ( const ModInt& b ) const {\n        return (v - b.v < 0 ? ModInt(v - b.v + mod) : ModInt(v - b.v));\n    }\n    ModInt operator* ( const ModInt& b ) const {return (v * b.v) % mod;}\n    ModInt operator/ ( const ModInt& b ) const {return (v * mod_pow(b.v, mod-2)) % mod;}\n    \n    bool operator== ( const ModInt &b ) const {return v == b.v;}\n    ModInt& operator+= ( const ModInt &b ) {\n        v += b.v;\n        if(v >= mod) v -= mod;\n        return *this;\n    }\n    ModInt& operator-= ( const ModInt &b ) {\n        v -= b.v;\n        if(v < 0) v += mod;\n        return *this;\n    }\n    ModInt& operator*= ( const ModInt &b ) {\n        (v *= b.v) %= mod;\n        return *this;\n    }\n    ModInt& operator/= ( const ModInt &b ) {\n        (v *= mod_pow(b.v, mod-2)) %= mod;\n        return *this;\n    }\n    ModInt pow(ll x) { return ModInt(mod_pow(v, x)); }\n    // operator int() const { return int(v); }\n    // operator long long int() const { return v; }\n};\n\ntemplate<ll mod>\nostream& operator<< (ostream& out, ModInt<mod> a) {return out << a.v;}\ntemplate<ll mod>\nistream& operator>> (istream& in, ModInt<mod>& a) {\n    in >> a.v;\n    return in;\n}\n\n// ModInt end\n\n// 移動元と行先と辺のコストを記録する構造体\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int s, T d) : to(s), cost(d) {}\n    Edge(int f, int s, T d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n\ntemplate <typename T>\nusing Graph = vector< vector< Edge<T> > >;\n\n// 強連結成分分解\n// Verified: AOJ GRL_3_C (Strongly Connected Components)\n// Verified: ARC030 C (有向グラフ) ← 強連結を潰したグラフの構築の検証\n\n// これは 2 回の DFS によって実現できる。\n// はじめに普通の DFS をするが、その時に帰りがけ順に頂点番号の配列を作る。\n// 次に、元のグラフの逆辺のみで構成されたグラフに対して、\n// 帰りがけ順が遅かったものから順に DFS を行う。\n// 帰りかけが遅かった頂点ほど、 DAG の先頭の強連結成分に属しているため、\n// 辺を逆向きにすると、先頭の強連結成分から外に出られなくなることを利用している。\n\ntemplate <typename T>\nstruct GraphSCC {\npublic:\n    const int n;\n    vector<bool> isthrough;\n    vector<int> vs, cmp;\n    vector< vector< Edge<T> > > G, rG;\n    vector< vector<int> > H;\n\n    GraphSCC(vector< vector< Edge<T> > > &_G) :\n        n(_G.size()), isthrough(n, false), cmp(n, 0), G(_G), rG(n) {\n            // 逆辺グラフ\n            for(int i=0; i<n; i++) for(size_t j=0; j<G[i].size(); j++)\n                rG[ G[i][j].to ].push_back(Edge<T>(i, G[i][j].cost));\n        }\n\n    void SCC_dfsone(int cur) {\n        isthrough[cur] = true;\n        for(size_t i=0; i<G[cur].size(); i++) {\n            if(!isthrough[G[cur][i].to]) {\n                SCC_dfsone(G[cur][i].to);\n            }\n        }\n        vs.push_back(cur);\n    }\n\n    void SCC_dfstwo(vector<int> &vec, int cur, int k) {\n        cmp[cur] = k;\n        isthrough[cur] = true;\n        vec.push_back(cur);\n        for(size_t i=0; i<rG[cur].size(); i++) {\n            if(!isthrough[rG[cur][i].to]) {\n                SCC_dfstwo(vec, rG[cur][i].to, k);\n            }\n        }\n    }\n\n    pair<vector<int>, int> scc() {\n        // 1回めのDFS\n        for(int i=0; i<n; i++)\n            if(!isthrough[i]) SCC_dfsone(i);\n\n        fill(isthrough.begin(), isthrough.end(), false);\n        reverse(vs.begin(), vs.end());\n        int k = 0; vector< vector<int> > S;\n\n        // 2回めのDFS\n        for(size_t i=0; i<vs.size(); i++) {\n            if(!isthrough[vs[i]]) {\n                S.push_back(vector<int>());\n                SCC_dfstwo(S.back(), vs[i], k++);\n            }\n        }\n\n        H.resize(k);\n        fill(isthrough.begin(), isthrough.end(), false);\n        for(size_t i=0; i<k; i++) {\n            for(size_t j=0; j<S[i].size(); j++) {\n                int v = S[i][j];\n                for(size_t x=0; x<G[v].size(); x++) {\n                    int u = G[v][x].to;\n                    if(isthrough[cmp[u]] || cmp[v] == cmp[u]) continue;\n                    isthrough[cmp[u]] = true;\n                    H[cmp[v]].push_back(cmp[u]);\n                }\n            }\n            for(size_t j=0; j<H[i].size(); j++) isthrough[ H[i][j] ] = false;\n        }\n        return make_pair(cmp, k);\n    }\n};\n\nusing mint = ModInt<MOD>;\nmint dp[100010][2];\nsigned main() {\n    int N, M; cin >> N >> M;\n    Graph<int> G(N);\n    for(int i=0; i<M; i++) {\n        int s, d; cin >> s >> d;\n        s--; d--;\n        G[s].push_back(Edge<int>(d, 1));\n    }\n\n    GraphSCC<int> sc(G);\n    sc.scc();\n\n    vector< vector<int> > C = sc.H;\n    N = C.size();\n    vector<int> deg(N);\n    for(int i=0; i<N; i++) {\n        for(auto to : C[i]) deg[to]++;\n    }\n\n    queue<int> que;\n    for(int i=0; i<N; i++) {\n        if(deg[i] == 0) {\n            que.push(i);\n        }\n    }\n    fill(dp[0], dp[N], mint(1));\n\n    mint ans(1);\n    while(que.size()) {\n        int cur = que.front(); que.pop();\n        bool term = true;\n        for(auto to : C[cur]) {\n            term = false;\n            dp[to][1] *= dp[cur][0] + dp[cur][1];\n            dp[to][0] *= dp[cur][0];\n            if(--deg[to] == 0) que.push(to);\n        }\n        if(term) ans *= (dp[cur][0] + dp[cur][1]);\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct Edge{int from, to; ll cost;};\n\nconst ll MOD = 1000000007;\nconst long double EPS = 10e-10;\nconst int MAX_V = 1000;\n\nvector<int> G[MAX_V], rG[MAX_V], vs;\nint component[MAX_V];\nbool used[MAX_V];\nll dp[MAX_V];\nint V,E;\n\nvoid add_edge(int s, int t){\n    G[s].push_back(t);\n    rG[t].push_back(s);\n}\n\nvoid dfs(int node){\n    used[node] = true;\n    for(int next: G[node]){\n        if(!used[next]) dfs(next);\n    }\n    vs.push_back(node);\n}\n\nvoid rdfs(int node, int k){\n    used[node] = true;\n    component[node] = k;\n    for(int next: rG[node]){\n        if(!used[next]) rdfs(next, k);\n    }\n}\n\nvoid scc(){\n    memset(used, false, sizeof(used));\n    rep(V){\n        if(!used[i]) dfs(i);\n    }\n    memset(used, false, sizeof(used));\n    int k = 0;\n    reverse(all(vs));\n    for(int i: vs){\n        if(!used[i]) rdfs(i, k++);\n    }\n}\n\nvector<int> topological_sort(int N){\n    vector<int> ret, indeg(N, 0);\n    vector<bool> used(N, false);\n    set<int> st;\n    rep(N) for(int to: G[i]) indeg[to]++;\n    rep(N) if(indeg[i] == 0) st.insert(i);\n\n    while(!st.empty()){\n        int node = *st.begin();\n        st.erase(node);\n        ret.push_back(node);\n        used[node] = true;\n        for(int next: G[node]){\n            indeg[next]--;\n            if(!used[next] && indeg[next] == 0) st.insert(next);\n        }\n    }\n\n    return ret;\n}\n\nint main(){\n    std::ios::sync_with_stdio(0); cin.tie(0);\n\n    int s, d;\n    cin >> V >> E;\n    Pii edges[E];\n    rep(E){\n        cin >> s >> d;\n        s--; d--;\n        add_edge(s, d);\n        edges[i] = Pii(s, d);\n    }\n\n    scc();\n\n    rep(V){\n        G[i].clear();\n        rG[i].clear();\n    }\n    V = *max_element(component, component+V) + 1;\n    rep(E){\n        s = edges[i].first;\n        d = edges[i].second;\n        if(component[s] != component[d]){\n            add_edge(component[s], component[d]);\n        }\n    }\n\n    vector<int> sorted_v = topological_sort(V);\n    fill(dp, dp+V, 1LL);\n    for(int s: sorted_v){\n        if(!rG[s].size()){\n            if(!G[s].size()){\n                dp[s] = 1;\n            }else{\n                dp[s] = 2;\n            }\n        }\n        for(int d: G[s]){\n            (dp[d] *= dp[s]) %= MOD;\n        }\n    }\n    ll ans = 1LL;\n    for(int v: sorted_v){\n        if(!G[v].size()) (ans *= (dp[v]+1)) %= MOD;\n    }\n\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll M=1000000007;\n\nll dfs(int u,const vector<int> *T){\n\tif(T[u].empty()) return 2;\n\tll res=1;\n\trep(i,T[u].size()){\n\t\tint v=T[u][i];\n\t\tres=res*dfs(v,T)%M;\n\t}\n\treturn (res+1)%M;\n}\n\n// ツ出ツ篠淞青板つェツ債つ々 1 ツづ?つ「ツつ、ツ青ァツ姪アツつゥツづァ, ツ連ツ個仰青ャツ閉ェツづ債δ仰ーツプツづ可姪伉つェツつュツづ?づつつ「ツつスツ形ツづ可づ按づゥ\n// ツつアツづ個連ツ個仰青ャツ閉ェツづ可づつつ「ツづ?づ個嘉ーツづーツ仰?づ淞づゥ\nll solve(int n,const int *G){\n\tvector<int> G2[1000]; // G ツづ個陛督づ個古シツつォツづーツ逆ツ転ツつオツつスツグツδ可フ\n\trep(u,n) if(G[u]!=-1) G2[G[u]].push_back(u);\n\n\t// ツδ仰ーツプツ個淞出\n\trep(u,n){\n\t\tint v=u;\n\t\tbool vis[1000]={};\n\t\twhile(G[v]!=-1 && !vis[v]){\n\t\t\tvis[v]=true;\n\t\t\tv=G[v];\n\t\t}\n\t\tif(v==u){ // ツδ仰ーツプorツ債ェツつェツ個ゥツづつつゥツづ?つス\n\t\t\tll res=1;\n\t\t\tint v=u;\n\t\t\tdo{\n\t\t\t\t// ツδ仰ーツプツ湘」ツづ個各ツ陳クツ点ツづーツ債ェツづ?つキツづゥツ姪伉づ可づつつ「ツづ?督堋つヲツづーツ仰?づ淞づ? ツつサツづェツづァツづーツつゥツつッツつ?づュツつケツづゥ\n\t\t\t\trep(i,G2[v].size()){\n\t\t\t\t\tint w=G2[v][i];\n\t\t\t\t\tif(!vis[w]) res=res*dfs(w,G2)%M;\n\t\t\t\t}\n\t\t\t\tv=G[v];\n\t\t\t}while(v!=u);\n\t\t\treturn (res+1)%M; // ツづ?づェツづ?選ツづ篠づ按つ「ツづ?つ「ツつ、ツ嘉ーツつェツつ?づゥツづ個づ?+1\n\t\t}\n\t}\n\treturn 0;\n\tassert(0);\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tint to[1000];\n\trep(u,n) to[u]=-1;\n\trep(i,m){\n\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\tto[u]=v;\n\t}\n\tvector<int> G[1000]; // ツ鳴ウツ古シツグツδ可フ\n\trep(u,n) if(to[u]!=-1) {\n\t\tint v=to[u];\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\n\tll ans=1;\n\tbool vis[1000]={};\n\trep(u,n) if(!vis[u]) {\n\t\tvis[u]=true;\n\n\t\tvector<int> cc;\n\t\tqueue<int> Q; Q.push(u);\n\t\twhile(!Q.empty()){ // ツ偲」ツ連ツ個仰青ャツ閉ェツつイツづ?づ可陳イツづ猟づゥ\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\tcc.push_back(u);\n\t\t\trep(i,G[u].size()){\n\t\t\t\tint v=G[u][i];\n\t\t\t\tif(!vis[v]) vis[v]=true, Q.push(v);\n\t\t\t}\n\t\t}\n\n\t\tint N=cc.size();\n\t\tint D[1000]; // ツ偲」ツ連ツ個仰づ按有ツ古シツグツδ可フ\n\t\trep(i,N) D[i]=-1;\n\t\trep(i,N) rep(j,N) {\n\t\t\tint u=cc[i],v=cc[j];\n\t\t\tif(to[u]==v) D[i]=j;\n\t\t}\n\t\tans=ans*solve(N,D)%M;\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nstruct SCC\n{\n\tvector<vector<int> > G;\n\tvector<vector<int> > rG;\n\tvector<int> vs;\n\tvector<bool> used;\n\tvector<int> cmp;\n\tint sz,newsz;\n\tSCC(int n):G(n),rG(n),used(n,false),cmp(n){sz = n;}\n\t\n\tvoid add_edge(int from,int to)\n\t{\n\t\tG[from].PB(to);\n\t\trG[to].PB(from);\n\t}\n\t\n\tvoid dfs(int v)\n\t{\n\t\tused[v] = true;\n\t\tREP(i,G[v].size())\n\t\t{\n\t\t\tif(!used[G[v][i]])dfs(G[v][i]);\n\t\t}\n\t\tvs.PB(v);\n\t}\n\t\n\tvoid rdfs(int v,int k)\n\t{\n\t\tused[v] = false;\n\t\tcmp[v] = k;\n\t\tREP(i,rG[v].size())\n\t\t{\n\t\t\tif(used[rG[v][i]])rdfs(rG[v][i],k);\n\t\t}\n\t}\n\t\n\tint reMake()\n\t{\n\n\t\tvs.clear();\n\t\tREP(i,sz)if(!used[i])dfs(i);\n\t\tint k = 0;\n\t\tfor(int i = sz-1;i >= 0;i--)\n\t\t{\n\t\t\tif(used[vs[i]])\n\t\t\t{\n\t\t\t\trdfs(vs[i],k++);\n\t\t\t}\n\t\t}\n\t\treturn newsz = k;\n\t}\n\t\n\t\n\t\n\tvoid makeList(vector<vector<int> > &v)\n\t{\n\t\tREP(i,sz)\n\t\t{\n\t\t\tREP(j,G[i].size())\n\t\t\t{\n\t\t\t\tif(cmp[i] == cmp[G[i][j]])continue;\n\t\t\t\tv[cmp[i]].PB(cmp[G[i][j]]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid makeReverseList(vector<vector<int> > &v)\n\t{\n\t\tREP(i,sz)\n\t\t{\n\t\t\tREP(j,G[i].size())\n\t\t\t{\n\t\t\t\tif(cmp[i] == cmp[G[i][j]])continue;\n\t\t\t\tv[cmp[G[i][j]]].PB(cmp[i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint scc_node(int n)\n\t{\n\t\treturn cmp[n];\n\t}\n};\n\n\n#define MOD 1000000007 \n\nvector<vector<int> > v(1000);\nvector<vector<int> > rv(1000);\n\nbool check[10001];\nint dp[1111][2];\n\nvoid dfs(int n)\n{\n\tcheck[n] = true;\n\t\n\tif(rv[n].size() == 0)\n\t{\n\t\tdp[n][0] = 1;\n\t\tdp[n][1] = 1;\n\t\treturn;\n\t}\n\t\n\tREP(i,rv[n].size())\n\t{\n\t\tdfs(rv[n][i]);\n\t}\n\n\tll tmpa = 1;\n\tll tmpb = 1;\t\n\tREP(i,rv[n].size())\n\t{\n\t\ttmpa = (tmpa * ((dp[rv[n][i]][0]+dp[rv[n][1]][1])%MOD))%MOD;\n\t\ttmpb = (tmpb * dp[rv[n][i]][0])%MOD;\n\t}\t\n\tdp[n][0] = tmpb;\n\tdp[n][1] = tmpa;\n}\n\t\n\nint main()\n{\n\tint n,m;cin >> n >> m;\n\t\n\tSCC scc(n);\n\tREP(i,m)\n\t{\n\t\tint a,b;cin >> a >> b;\n\t\ta--;b--;\n\t\tscc.add_edge(a,b);\n\t}\n\t\n\tscc.reMake();\n\tscc.makeList(v);\n\tscc.makeReverseList(rv);\n\t\n\t//cout << scc.newsz << endl;\n\tll ans = 1;\n\tREP(i,scc.newsz)\n\t{\n\t\tif(v[i].size() == 0 && !check[i])\n\t\t{\n\t\t\tdfs(i);\n\t\t\tans = (ans * (dp[i][0]+dp[i][1]))%MOD;\n\t\t}\n\t}\t\t\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstruct SCC{\n  int V;\n  vector<vector<int> > G,rG;\n  vector<int> vs,used,cmp;\n  SCC(){}\n  SCC(int sz):V(sz),G(sz),rG(sz),used(sz),cmp(sz){}\n  void add(int from,int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  } \n  void dfs(int v){\n    used[v]=1;\n    for(int i=0;i<G[v].size();i++)\n      if(!used[G[v][i]])dfs(G[v][i]);\n    vs.push_back(v);\n  }\n  void rdfs(int v,int k){\n    used[v]=1;\n    cmp[v]=k;\n    for(int i=0;i<rG[v].size();i++)\n      if(!used[rG[v][i]])rdfs(rG[v][i],k);\n  }\n  int build(){\n    fill(used.begin(),used.end(),0);\n    vs.clear();\n    for(int v=0;v<V;v++)\n      if(!used[v])dfs(v);\n    fill(used.begin(),used.end(),0);\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--)\n      if(!used[vs[i]])rdfs(vs[i],k++);\n    return k;\n  }\n  int be(int x){\n    return cmp[x];\n  }\n  bool same(int x,int y){\n    return cmp[x]==cmp[y];\n  }\n};\n\n\n// 連結成分分解　（連結成分ごとにグラフを再構築、Sはグラフの集合）\nstruct CC{\n  int n;\n  vector<vector<int> >G,rG;\n  vector<int>used;\n  vector<vector<vector<int> > >S;\n  CC(int sz):n(sz),G(sz),rG(sz),used(sz){}\n  void add(int from,int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  }\n  void CC_dfs1(int x,int &cnt,map<int,int>& m){\n    m[x]=cnt++;\n    used[x]=1;\n    for(int i=0;i<G[x].size();i++){\n      if(used[G[x][i]])continue;\n      CC_dfs1(G[x][i],cnt,m);\n    }\n    for(int i=0;i<rG[x].size();i++){\n      if(used[rG[x][i]])continue;\n      CC_dfs1(rG[x][i],cnt,m);\n    }\n  }\n  void CC_dfs2(int x,vector<vector<int> > &v,map<int,int>& m,vector<int> &vis){\n    vis[m[x]]=1;\n    for(int i=0;i<G[x].size();i++){\n      v[m[x]].push_back(m[G[x][i]]);\n      if(vis[m[G[x][i]]])continue;\n      CC_dfs2(G[x][i],v,m,vis);\n    }\n    for(int i=0;i<rG[x].size();i++){\n      if(vis[m[rG[x][i]]])continue;\n      CC_dfs2(rG[x][i],v,m,vis);\n    }\n  }\n  void build(){\n    for(int i=0;i<n;i++)used[i]=0;\n    for(int i=0;i<n;i++){\n      if(used[i])continue;\n      int cnt=0;\n      map<int,int>M;\n      CC_dfs1(i,cnt,M);\n      vector<vector<int> >v(cnt);\n      vector<int>U(cnt,0);\n      CC_dfs2(i,v,M,U);\n      S.push_back(v);\n    }\n  }\n};\nint mod=1000000007;\nint n,m,a[10002],b[10002];\nint dp[1002][2];\nsigned main(){\n  set<int>st;\n  cin>>n>>m;\n  CC C(n);\n  r(i,m){\n    cin>>b[i]>>a[i];\n    b[i]--;a[i]--;\n    st.insert(b[i]);\n    st.insert(a[i]);\n    C.add(b[i],a[i]);\n  }\n  C.build();\n  int ans=1,sum=0;\n  for(int i=0;i<C.S.size();i++){\n    memset(dp,0,sizeof(dp));\n    vector<vector<int> >A=C.S[i];\n    int N=A.size();\n    SCC S(N);\n    r(i,N){\n      r(j,A[i].size()){\n        S.add(i,A[i][j]);\n      }\n    }\n    S.build();\n    set<int>SS;\n    int c=0;\n    for(int j=N-1;j>=0;j--){  // ここに連結成分無いのDPをかく\n      int x=S.vs[j];\n      SS.insert(S.cmp[x]);\n      //cout<<S.rG[x].size()<<endl;\n      if(S.rG[x].size()==0){\n        dp[x][1]=2;c++;//cout<<\"a\"<<j<<endl;\n      }\n      else{\n        dp[x][0]=dp[x][1]=1;\n        for(int k=0;k<S.rG[x].size();k++){\n          int to=S.rG[x][k];\n          if(S.same(x,to)){\n            //dp[to][0]=dp[x][0];\n            //dp[to][1]=dp[x][1];\n          }\n          else{//cout<<to<<endl;\n            dp[x][1]*=dp[to][0]+dp[to][1];\n            dp[x][0]*=1;\n            dp[x][1]%=mod;\n            //cout<<dp[to][1]<<' '<<dp[to][0]<<endl;\n          }\n        }\n      } \n      int X=1;\n      if(j==0){\n        if(c==0){\n          ans*=2;\n          ans%=mod;\n          break;\n        }\n        r(k,N){\n          int K=S.vs[k];\n          if(S.same(x,K)){\n            X*=dp[K][1];\n            X%=mod;\n          }\n        }\n        X++;\n        X%=mod;\n        ans*=X;\n        ans%=mod;\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <cstring>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\nint n,m;\nvector<int> G[1001];\nvector<int> rG[1001];\nvector<int> vs;\nvector<int> Group[1001];\nbool used[1001];\nint cmp[1001];\nvector<int> rGroup[1001];\nll dp[1001][2];\n\nvoid dfs(int v){\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!used[G[v][i]])dfs(G[v][i]);\n\t}\n\tvs.push_back(v);\n}\n\nvoid ddfs(int v){\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!used[G[v][i]])ddfs(G[v][i]);\n\t}\n\tfor(int i=0;i<rG[v].size();i++){\n\t\tif(!used[rG[v][i]])ddfs(rG[v][i]);\n\t}\n}\n\nvoid rdfs(int v,int k){\n\tused[v]=true;\n\tcmp[v]=k;\n\tGroup[k].push_back(v);\n\tfor(int i=0;i<rG[v].size();i++){\n\t\tif(!used[rG[v][i]])rdfs(rG[v][i],k);\n\t}\n}\n\nint scc(){\n\tmemset(used,false,sizeof(used));\n\tvs.clear();\n\tfor(int v=0;v<n;v++){\n\t\tif(!used[v])dfs(v);\n\t}\n\tmemset(used,false,sizeof(used));\n\tint k=0;\n\tfor(int i=vs.size()-1;i>=0;i--){\n\t\tif(!used[vs[i]])rdfs(vs[i],k++);\n\t}\n\treturn k;\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<m;i++){\n\t\tint f,t;\n\t\tscanf(\"%d%d\",&f,&t);\n\t\tf--;\n\t\tt--;\n\t\tG[f].push_back(t);\n\t\trG[t].push_back(f);\n\t}\n\tint k=scc();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<rG[i].size();j++){\n\t\t\tif(cmp[i]!=cmp[rG[i][j]])rGroup[cmp[i]].push_back(cmp[rG[i][j]]);\n\t\t}\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tdp[i][0]=1;\n\t\tdp[i][1]=1;\n\t\tfor(int j=0;j<rGroup[i].size();j++){\n\t\t\tint u=rGroup[i][j];\n\t\t\tdp[i][0]=(dp[i][0]*dp[u][0])%MOD;\n\t\t\tdp[i][1]=(dp[i][1]*(dp[u][0]+dp[u][1]))%MOD;\n\t\t}\n\t}\n\tmemset(used,false,sizeof(used));\n\tll res=1;\n\tfor(int i=0;i<k;i++){\n\t\tfor(int j=0;j<Group[i].size();j++){\n\t\t\tif(!used[Group[i][j]]){\n\t\t\t\tddfs(Group[i][j]);\n\t\t\t\tif(i>0){\n\t\t\t\t\tres=(res*(dp[i-1][0]+dp[i-1][1]))%MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tres=(res*(dp[k-1][0]+dp[k-1][1]))%MOD;\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nstruct SCC{\n    int V;\n    vector<vector<int>> G, rG;\n    vector<int> vs; // 帰りがけ順の並び\n    vector<int> cmp; //属する強連結成分トポロジカル順序\n    vector<bool> used;\n\n    SCC(){}\n    SCC(int n){\n        V = n;\n        G = vector<vector<int>>(n);\n        rG = vector<vector<int>>(n);\n    }\n\n    void add_edge(int from, int to){\n        G[from].push_back(to);\n        rG[to].push_back(from);\n    }\n\n    void dfs(int v){\n        used[v] = true;\n        rep(i,G[v].size())if(!used[G[v][i]]) dfs(G[v][i]);\n        vs.push_back(v);\n    }\n\n    void rdfs(int v, int k){\n        used[v]=true;\n        cmp[v]=k;\n        rep(i,rG[v].size())if(!used[rG[v][i]]) rdfs(rG[v][i],k);\n    }\n\n    int scc(){\n        used = vector<bool>(V,false);\n        vs.clear();\n        rep(i,V)if(!used[i]) dfs(i);\n\n        used = vector<bool>(V,false);\n        cmp = vector<int>(V);\n        int num_scc = 0;\n        for(int i=vs.size()-1; i>=0; --i)if(!used[vs[i]]) rdfs(vs[i],num_scc++);\n        return num_scc;\n    }\n};\n\nconst ll mod = 1e9+7;\n\nint main(){\n    int n,m;\n    scanf(\" %d %d\", &n, &m);\n\n    SCC s(n);\n\n    vector<int> u(m),v(m);\n    rep(i,m){\n        scanf(\" %d %d\", &u[i], &v[i]);\n        --u[i];\n        --v[i];\n        s.add_edge(u[i],v[i]);\n    }\n\n    int sz = s.scc();\n    vector<vector<int>> dag(sz), r_dag(sz);\n    rep(i,m){\n        int U = s.cmp[u[i]], V = s.cmp[v[i]];\n        if(U != V){\n            dag[U].pb(V);\n            r_dag[V].pb(U);\n        }\n    }\n\n    ll ans = 1;\n    vector<vector<ll>> dp(sz, vector<ll>(2,1));\n    rep(i,sz){\n        for(int j:r_dag[i]){\n            (dp[i][0] *= dp[j][0]) %= mod;\n            (dp[i][1] *= dp[j][0]+dp[j][1]) %= mod;\n        }\n\n        // leaf\n        if(dag[i].size() == 0){\n            (ans *= dp[i][0]+dp[i][1]) %= mod;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint N,M;\nconst int mod=1000000007;\nconst int MAX_V=1001;\ntypedef long long ll;\n\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nbool used[MAX_V];\nint cmp[MAX_V];\nvector<int> vs;\nvector<int> cG[MAX_V];\nint in[1001];\n\nvoid dfs(int s){\n  used[s]=true;\n  for(int i=0;i<G[s].size();i++){\n    int to=G[s][i];\n    if(!used[to])dfs(to);\n  }\n  vs.push_back(s);\n}\n\nvoid rdfs(int s,int k){\n  used[s]=true;\n  cmp[s]=k;\n  for(int i=0;i<rG[s].size();i++){\n    int to=rG[s][i];\n    if(!used[to])rdfs(to,k);\n  }\n}\n\nvoid makeGraph(int s){\n  used[s]=true;\n  for(int i=0;i<G[s].size();i++){\n    int to=G[s][i];\n    // 異なる連結成分へ移動\n    if(cmp[to]!=cmp[s])\n      cG[cmp[to]].push_back(cmp[s]);\n    if(!used[to])makeGraph(to);\n  }\n}\n\nint dp[1001];\nint rec(int s){\n  if(dp[s]>=0)return dp[s];\n  ll res=1;\n  for(int i=0;i<cG[s].size();i++){\n    int to=cG[s][i];\n    res=(res*(1+rec(to)))%mod;\n  }\n  return dp[s]=res%mod;\n}\n\nint main(){\n  while(cin>>N>>M&&(N|M)){\n    int S,D;\n    for(int i=0;i<N;i++){\n      G[i].clear();rG[i].clear();\n      cG[i].clear();\n    }\n    for(int i=0;i<M;i++){\n      cin>>S>>D;\n      S--;D--;\n      G[S].push_back(D);\n      rG[D].push_back(S);\n    }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<N;i++)\n      if(!used[i])dfs(i);\n    memset(used,0,sizeof(used));\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--)\n      if(!used[vs[i]])rdfs(vs[i],k++);\n    // 連結成分を一つのノードとしたグラフを作成\n    memset(used,0,sizeof(used));\n    for(int i=0;i<N;i++)\n      if(!used[i])makeGraph(i);\n    memset(in,0,sizeof(in));\n    for(int i=0;i<k;i++)\n      for(int j=0;j<cG[i].size();j++)\n\tin[cG[i][j]]++;\n    // 入点が存在しないところそれぞれについて計算\n    memset(dp,-1,sizeof(dp));\n    ll res=1;\n    for(int i=0;i<k;i++)\n      if(in[i]==0)res=(res*(1+rec(i)))%mod;\n    cout<<res<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nclass UnionFind {\n    vector<int> par, h;\npublic:\n    UnionFind(int size) {\n        par.assign(size, 0);\n        h.assign(size, 0);\n        REP(i, size) par[i] = i;\n    }\n    void unite(int u, int v) {\n        u = root(u), v = root(v);\n        if (u == v) return;\n        if (h[u] > h[v]) {\n            par[v] = u;\n        }\n        else if (h[u] < h[v]) {\n            par[u] = v;\n        }\n        else {\n            ++h[u];\n            par[v] = u;\n        }\n    }\n    bool isUnited(int u, int v) {\n        return root(u) == root(v);\n    }\n    int root(int v) {\n        if (par[v] == v) return v;\n        return par[v] = root(par[v]);\n    }\n};\nvoid scc_dfs(ll v, vector<bool>& used, vector<ll>& vs, const vector< vector<ll> >& G) {\n    used[v] = true;\n    each(to, G[v]) {\n        if (!used[to]) scc_dfs(to, used, vs, G);\n    }\n    vs.pb(v);\n}\nvoid scc_rdfs(ll v, ll k, vector<bool>& used, vector<ll>& cmp, const vector< vector<ll> >& rG) {\n    used[v] = true;\n    cmp[v] = k;\n    each(to, rG[v]) {\n        if (!used[to]) scc_rdfs(to, k, used, cmp, rG);\n    }\n}\n// cmpが返る\n// 同じcmpは強連結成分\n// cmp[i] < cmp[j] なら j から i に行けない\nvector<ll> scc(const vector< vector<ll> >& G) {\n    const ll n = G.size();\n    vector<bool> used(n, false);\n    vector<ll> vs;\n    rep(i, n) {\n        if (!used[i]) scc_dfs(i, used, vs, G);\n    }\n    used.assign(n, false);\n    vector< vector<ll> > rG(n);\n    rep(i, n) {\n        each(to, G[i]) {\n            rG[to].pb(i);\n        }\n    }\n    vector<ll> res(n);\n    ll k = 0;\n    rrep(i, vs.size()) {\n        if (!used[vs[i]]) scc_rdfs(vs[i], k++, used, res, rG);\n    }\n    return res;\n}\nvector< vector<ll> > get_scc_graph(const vector<ll>& cmp, const vector< vector<ll> >& G) {\n    vector< vector<ll> > res(*max_element(all(cmp))+1);\n    rep(i, G.size()) {\n        each(to, G[i]) {\n            if (cmp[i] != cmp[to]) {\n                res[cmp[i]].pb(cmp[to]);\n            }\n        }\n    }\n    rep(i, res.size()) {\n        sort(all(res[i]));\n        res[i].erase(unique(all(res[i])), res[i].end());\n    }\n    return res;\n}\nconst ll mod = 1000000007;\nll mul(ll a, ll b) {\n    return a * b % mod;\n}\nll mul(initializer_list<ll> t) {\n    ll res = 1;\n    each(v, t) res = mul(res, v);\n    return res;\n}\nll add(ll a, ll b) {\n    return (a + b) % mod;\n}\nll add(initializer_list<ll> t) {\n    ll res = 0;\n    each(v, t) res = add(res, v);\n    return res;\n}\nll sub(ll a, ll b) {\n    return (a - b + mod) % mod;\n}\nll sub(initializer_list<ll> t) {\n    auto it = t.begin();\n    ll res = *(it++);\n    while (it != t.end()) {\n        res = sub(res, *(it++));\n    }\n    return res;\n}\nll power(ll x, ll n) {\n    ll res = 1;\n    for (ll i = 1; i <= n; i <<= 1) {\n        if (i & n) res = mul(res, x);\n        x = mul(x, x);\n    }\n    return res;\n}\nll inv(ll n) {\n    return power(n, mod-2);\n}\nll divi(ll a, ll b) {\n    return mul(a, inv(b));\n}\nll divi(initializer_list<ll> t) {\n    auto it = t.begin();\n    ll res = *(it++);\n    while (it != t.end()) {\n        res = divi(res, *(it++));\n    }\n    return res;\n}\nvector<ll> fact;\nvoid init_fact(ll n) {\n    fact.assign(n+1, 1);\n    FOR(i, 1, fact.size()) {\n        fact[i] = mul(fact[i-1], i);\n    }\n}\n\nll comb(ll n, ll r) {\n    if (r < 0) return 0;\n    if (r > n) return 0;\n    return divi(fact[n], mul(fact[r], fact[n-r]));\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n, m; cin >> n >> m;\n    vector<vector<ll>> G(n);\n    rep(i, m) {\n        ll a, b; cin >> a >> b; --a, --b;\n        G[a].pb(b);\n    }\n    vector<ll> cmp = scc(G);\n    G = get_scc_graph(cmp, G);\n    n = G.size();\n    vector<vector<ll>> rG(n);\n    rep(from, n) each(to, G[from]) {\n        rG[to].pb(from);\n    }\n    auto dfs = [&](ll v) {\n        ll res = 1;\n        while (G[v].size() > 0) {\n            assert(G[v].size() == 1);\n            v = G[v][0];\n            ++res;\n        }\n        return res;\n    };\n    ll ans = 1;\n    rep(i, n) if (G[i].size() == 0) {\n        ll ptn = 1;\n        each(j, rG[i]) {\n            ptn = mul(ptn, dfs(j));\n        }\n        ptn = add(ptn, 1);\n        // cout << i << \" \" << ptn << endl;\n        ans = mul(ans, ptn);\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\n\nint N, M;\nvector<vector<int>> G, rG;\nvector<bool> vis;\nvector<int> vs;\nvector<int> S;\nvector<vector<int>> s;\n\nvoid dfs(int v){\n    vis[v] = true;\n    for(int i=0; i<G[v].size(); i++)\n        if(!vis[G[v][i]]) dfs(G[v][i]);\n    vs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n    vis[v] = 1;\n    S[v] = k; s[k].push_back(v);\n    for(int i=0; i<rG[v].size(); i++)\n        if(!vis[rG[v][i]]) rdfs(rG[v][i],k);\n}\n\nvoid scc(){\n    for(int i=0; i<N; i++)if(!vis[i]) dfs(i);\n    for(int i=0; i<N; i++)\n        vis[i] = false;\n    \n    reverse(vs.begin(), vs.end());\n    \n    s.clear();\n    for(int i=0; i<N; i++) if(!vis[vs[i]]){\n        s.push_back(vector<int>());\n        rdfs(vs[i],s.size()-1);\n    }\n    vector<int> rs(N);\n    N = s.size();\n    for(int i=0; i<N; i++)\n        for(int v: s[i])\n            rs[v] = i;\n    \n    \n    vector<vector<int>> tG(N);\n    vector<vector<int>> trG(N);\n    for(int i=0; i<N; i++){\n        vector<bool> done(N);\n        for(int u: s[i]){\n            for(int v: G[u]) if(rs[v]!=i && !done[rs[v]]){\n                done[rs[v]] = true;\n                tG[i].push_back(rs[v]);\n            }\n            for(int v: rG[u]) if(rs[v]!=i && !done[rs[v]]){\n                done[rs[v]] = true;\n                trG[i].push_back(rs[v]);\n            }\n        }\n    }\n    G = tG;\n    rG = trG;\n}\n\nll tree(int u){\n    if(rG[u].size() == 0) //leaf\n        return 2;\n    \n    ll res = 1;\n    for(int v: rG[u])\n        res = (res + tree(v)) % MOD;\n    return res;\n}\n\nint main(){\n    cin >> N >> M;\n    G.resize(N); rG.resize(N);\n    vis.resize(N); S.resize(N);\n\n    for(int i=0; i<M; i++){\n        int s, d; cin >> s >> d; s--; d--;\n        G[s].push_back(d);\n        rG[d].push_back(s);\n    }\n    \n    scc();\n    \n    ll ans = 1;\n    for(int i=0; i<N; i++){\n        if(G[i].size() == 0)\n            ans = (ans * tree(i)) % MOD;\n    }\n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_V 5000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst long long int MOD = 1000000007;\nconst long long int INF = 10000000000000000;\n\nint n, m;\nvector<int> e[1000], r[1000];\nint id[1000];\nbool saw[1000];\nll ans = 1;\n\nbool check(int v, int p){\n    bool ret = true;\n    if(saw[v]) return true;\n    saw[v] = true;\n    rep(i,e[v].size()){\n        if(e[v][i] == p){\n            ret = false;\n            break;\n        }\n        ret = check(e[v][i],p);\n    }\n    if(!ret) id[v] = p;\n    return ret;\n}\n\nll dfs(int v){\n    v = id[v];\n    ll ret = 1;\n    if(r[v].size() == 0){\n        return 2;\n    }\n    rep(i,r[v].size()){\n        ret = (ret+dfs(r[v][i]))%MOD;\n    }\n    return ret;\n}\n\nint main(){\n    cin >> n >> m;\n    rep(i,n) id[i] = i;\n    rep(i,m){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        e[a].push_back(b);\n        r[b].push_back(a);\n    }\n    rep(i,n){\n        memset(saw,0,sizeof(saw));\n        if(id[i] != i) continue;\n        check(i,i);\n    }\n    rep(i,n){\n        if(id[i] != i){\n            copy(e[i].begin(),e[i].end(),back_inserter(e[id[i]]));\n            copy(r[i].begin(),r[i].end(),back_inserter(r[id[i]]));\n            sort(e[id[i]].begin(),e[id[i]].end());\n            e[id[i]].erase(unique(e[id[i]].begin(),e[id[i]].end()),e[id[i]].end());\n            sort(r[id[i]].begin(),r[id[i]].end());\n            r[id[i]].erase(unique(r[id[i]].begin(),r[id[i]].end()),r[id[i]].end());\n        }\n    }\n    rep(i,n){\n        vector<int> z;\n        if(id[i] != i) continue;\n        rep(j,e[i].size()){\n            if(id[e[i][j]] != i) z.push_back(e[i][j]);\n        }\n        e[i] = z;\n        z.clear();\n        rep(j,r[i].size()){\n            if(id[r[i][j]] != i) z.push_back(r[i][j]);\n        }\n        r[i] = z;\n       \n    }\n    rep(i,n){\n        if(e[i].size() > 0) continue;\n        ans = ans*dfs(i)%MOD;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nstruct SCC\n{\n\tvector<vector<int> > G;\n\tvector<vector<int> > rG;\n\tvector<int> vs;\n\tvector<bool> used;\n\tvector<int> cmp;\n\tint sz,newsz;\n\tSCC(int n):G(n),rG(n),used(n,false),cmp(n){sz = n;}\n\t\n\tvoid add_edge(int from,int to)\n\t{\n\t\tG[from].PB(to);\n\t\trG[to].PB(from);\n\t}\n\t\n\tvoid dfs(int v)\n\t{\n\t\tused[v] = true;\n\t\tREP(i,G[v].size())\n\t\t{\n\t\t\tif(!used[G[v][i]])dfs(G[v][i]);\n\t\t}\n\t\tvs.PB(v);\n\t}\n\t\n\tvoid rdfs(int v,int k)\n\t{\n\t\tused[v] = false;\n\t\tcmp[v] = k;\n\t\tREP(i,rG[v].size())\n\t\t{\n\t\t\tif(used[rG[v][i]])rdfs(rG[v][i],k);\n\t\t}\n\t}\n\t\n\tint reMake()\n\t{\n\n\t\tvs.clear();\n\t\tREP(i,sz)if(!used[i])dfs(i);\n\t\tint k = 0;\n\t\tfor(int i = sz-1;i >= 0;i--)\n\t\t{\n\t\t\tif(used[vs[i]])\n\t\t\t{\n\t\t\t\trdfs(vs[i],k++);\n\t\t\t}\n\t\t}\n\t\treturn newsz = k;\n\t}\n\t\n\t\n\t\n\tvoid makeList(vector<vector<int> > &v)\n\t{\n\t\tREP(i,sz)\n\t\t{\n\t\t\tREP(j,G[i].size())\n\t\t\t{\n\t\t\t\tif(cmp[i] == cmp[G[i][j]])continue;\n\t\t\t\tv[cmp[i]].PB(cmp[G[i][j]]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid makeReverseList(vector<vector<int> > &v)\n\t{\n\t\tREP(i,sz)\n\t\t{\n\t\t\tREP(j,G[i].size())\n\t\t\t{\n\t\t\t\tif(cmp[i] == cmp[G[i][j]])continue;\n\t\t\t\tv[cmp[G[i][j]]].PB(cmp[i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint scc_node(int n)\n\t{\n\t\treturn cmp[n];\n\t}\n};\n\n#define MOD 1000000007 \n\nvector<vector<int> > v(1000);\nvector<vector<int> > rv(1000);\n\nll kaijo[1000];\nbool check[10001];\n\nll dfs(int n)\n{\n\tcheck[n] = true;\n\tll ret = 1;\n\tint num = rv[n].size();\n\tif(num == 0)\n\t{\n\t\treturn ret;\n\t}\n\tif(num == 1)\n\t{\n\t\tret =(ret + dfs(rv[n][0]))% MOD;\n\t\treturn ret;\n\t}\n\tll kai = kaijo[num-2];\n\tvector<ll> tmp;\n\t\n\tREP(i,num)\n\t{\n\t\ttmp.PB(dfs(rv[n][i]));\n\t}\n\t\n\tREP(i,num)\n\t{\n\t\tret = (ret + tmp[i]) % MOD;\n\t}\n\t\n\tfor(int i = 0;i < num;i++)\n\t{\n\t\tfor(int j = i+1;j < num;j++)\n\t\t{\n\t\t\tret = (ret + (((tmp[i]*tmp[j])%MOD)*kai)%MOD)%MOD;\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nint main()\n{\n\tint n,m;cin >> n >> m;\n\t\n\tkaijo[0] = 1;\n\tfor(int i = 1;i < 1000;i++)\n\t{\n\t\tkaijo[i] = (kaijo[i-1]*2)%MOD;\n\t}\n\tSCC scc(n);\n\tREP(i,m)\n\t{\n\t\tint a,b;cin >> a >> b;\n\t\ta--;b--;\n\t\tscc.add_edge(a,b);\n\t}\n\t\n\tscc.reMake();\n\tscc.makeList(v);\n\tscc.makeReverseList(rv);\n\t\n\t//cout << scc.newsz << endl;\n\t\n\tll ans = 1;\n\tREP(i,scc.newsz)\n\t{\n\t\tif(v[i].size() == 0 && !check[i])\n\t\t{\n\t\t\tans = (ans * (dfs(i)+1LL)%MOD)%MOD;\n\t\t//\tcout << ans << endl;\n\t\t//cout << \"!\";\n\t\t}\n\t}\t\t\n\t\n\tcout << ans%MOD << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <complex>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\n\ntemplate <typename T, typename E>\nostream &operator<<(std::ostream &os, const std::pair<T, E> &p){\n  return os << \"(\" << p.first << \", \" << p.second << \")\";\n}\n\ntypedef long long ll;\n\nclass StrongConnectedComponent{\n  typedef std::vector<std::vector<int> > Graph; // adjacency list\nprivate:\n  size_t V;\n  size_t size_;\n  std::vector<bool> visit;\n  std::vector<int>  scc;\n    \n  void dfs(int v, std::vector<int> &vs, const Graph &G){\n    std::stack <int> to_visit;\n    std::vector<int> iters(V, 0);\n    to_visit .push(v);\n        \n    while (!to_visit.empty()){\n      int    v = to_visit.top(); to_visit.pop();\n      if (iters[v] == 0) visit[v] = true;\n      if (iters[v] == (int)G[v].size()){\n        vs.push_back(v);\n      } else {\n        int to = G[v][iters[v]];\n        to_visit.push(v);\n        iters[v]++;\n        if (!visit[to]) to_visit.push(to);\n      }\n    }\n  }\n    \n  void rbfs(int s, int id, const Graph &G){\n    std::queue<int> que;\n    que.push(s);\n    visit[s] = true;\n    scc[s]   = id;\n    while (!que.empty()){\n      int v = que.front(); que.pop();\n      for (auto to : G[v]){\n        if (!visit[to]){\n          visit[to] = true;\n          scc[to]   = id;\n          que.push(to);\n        }\n      }\n    }\n  }\n    \npublic:\n  StrongConnectedComponent(const Graph &G) : V(G.size()), size_(0){\n    visit .resize(V, false);\n    scc   .resize(V, -1);\n    Graph rG(V);\n    for (size_t v = 0; v < V; v++)\n      for (size_t i = 0; i < G[v].size(); i++)\n        rG[G[v][i]].push_back(v);\n    std::vector<int> vs;\n    for (size_t v = 0; v < V; v++) if (!visit[v]) dfs(v, vs, G);\n    assert(vs.size() == V);\n    std::reverse(vs.begin(), vs.end());\n    std::fill(visit.begin(), visit.end(), false);\n    for (size_t v = 0; v < V; v++) if (!visit[vs[v]]) rbfs(vs[v], size_++, rG);\n  }\n  int operator[](size_t idx) const { return scc[idx]; }\n  size_t size() const { return size_; };\n};\n\n\nint main(){\n  const ll mod = 1000 * 1000 * 1000 + 7;\n  ios::sync_with_stdio(false);\n\n  int N, M;\n  while (cin >> N >> M && N + M){\n    vector<vector<int> > G(N);\n    REP(i, M){\n      int s, d;\n      cin >> s >> d;\n      G[s - 1].push_back(d - 1);\n    }\n\n    StrongConnectedComponent scc(G);\n    \n    ll res = 1;\n    \n    vector<vector<int> > D(scc.size());\n    vector<vector<int> > R(scc.size());\n    vector<ll> dp(scc.size());\n    \n    REP(v, N) REP(i, G[v].size()){\n      int w = G[v][i];\n      if (scc[v] != scc[w]){\n        D[scc[v]].push_back(scc[w]);\n        R[scc[w]].push_back(scc[v]);\n      }\n    }\n    \n    REP(i, scc.size()){\n      sort(ALL(R[i]));\n      sort(ALL(D[i]));\n      R[i].erase(unique(ALL(R[i])), R[i].end());\n      D[i].erase(unique(ALL(D[i])), D[i].end());\n      \n      dp[i] = 1;\n      REP(j, R[i].size()){\n        dp[i] *= dp[R[i][j]];\n        dp[i] %= mod;\n      }\n      dp[i]++;\n      if (D[i].size() == 0){\n        res *= dp[i];\n        res %= mod;\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, M;\nvector<vector<int>> v, rv;\nvector<int> cmp, vs;\nbool used[10001];\nconst long long int MOD = 1e9+7LL;\n\nvoid dfs(int now) {\n    used[now] = true;\n\n    for (auto next: v[now]) {\n        if (!used[next]) dfs(next);\n    }\n\n    vs.push_back(now);\n}\n\nvoid rdfs(int now, int k) {\n    used[now] = true;\n    cmp[now] = k;\n\n    for (auto next: rv[now]) {\n        if (!used[next]) rdfs(next, k);\n    }\n}\n\nint scc() {\n    memset(used, 0, sizeof(used));\n    vs.clear();\n    for (int i = 0; i < N; i++)\n        if (!used[i]) dfs(i);\n\n    memset(used, 0, sizeof(used));\n    int k = 0;\n    for (int i = vs.size() - 1; i >= 0; i--) {\n        if (!used[vs[i]]) rdfs(vs[i], k++);\n    }\n\n    return k;\n}\n\nint main() {\n    cin >> N >> M;\n    v.resize(N), rv.resize(N), cmp.resize(N);\n\n    for (int i = 0; i < M; i++) {\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n\n        v[x].push_back(y);\n        rv[y].push_back(x);\n    }\n\n    int k = scc();\n    vector<int> next(k, -1);\n    for (int i = 0; i < N; i++) {\n        if (v[i].size())\n            next[cmp[i]] = cmp[v[i][0]];\n    }\n\n    vector<long long int> sum(k, 0);\n    memset(used, 0, sizeof(used));\n    long long int ans = 1LL;\n    for (int i = 0; i < k; i++) {\n        if (sum[i]) {\n            sum[i]++;\n        } else {\n            sum[i] = 2LL;\n        }\n\n        if (next[i] < 0 || next[i] == i) \n            ans = (ans * sum[i]) % MOD;\n        else if (sum[next[i]]) \n            sum[next[i]] = (sum[next[i]] * sum[i]) % MOD;\n        else \n            sum[next[i]] = (sum[next[i]] + sum[i]) % MOD;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = long long;\n\n#define fs first\n#define sc second\n\nconst LL MOD = 1e9+7;\n\nstruct StronglyConnectedComponents {\n    using G = vector<vector<int>>;\n    G g, rg, t;\n    vector<int> comp, order, used;\n\n    StronglyConnectedComponents(const G& g) :\n        g(g), rg(g.size()), comp(g.size(), -1), used(g.size())\n    {\n        for (int i = 0; i < g.size(); i++) {\n            for (int to : g[i]) {\n                rg[to].push_back(i);\n            }\n        }\n    }\n\n    void dfs(int idx) {\n        if (used[idx]) return;\n        used[idx] = true;\n        for (int to : g[idx]) dfs(to);\n        order.push_back(idx);\n    }\n\n    void rdfs(int idx, int cnt) {\n        if (comp[idx] != -1) return;\n        comp[idx] = cnt;\n        for (int to : rg[idx]) rdfs(to, cnt);\n    }\n\n    void build() {\n        for (int i = 0; i < g.size(); i++) dfs(i);\n        reverse(order.begin(), order.end());\n        int ptr = 0;\n        for (int i : order) if (comp[i] == -1) rdfs(i, ptr), ptr++;\n\n        t.resize(ptr);\n        for (int i = 0; i < g.size(); i++) {\n            for (int to : g[i]) {\n                int x = comp[i], y = comp[to];\n                if (x == y) continue;\n                t[x].push_back(y);\n            }\n        }\n    }\n};\n\nvector<int> topological_sort(const vector<vector<int>>& G)\n{\n    int n = G.size();\n    vector<int> num(n), ord;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < G[i].size(); ++j) {\n            ++num[G[i][j]];\n        }\n    }\n    stack<int> st;\n    for(int i = 0; i < num.size(); ++i) {\n        if (num[i] == 0) {\n            st.push(i);\n        }\n    }\n    while (!st.empty()) {\n        int i = st.top(); st.pop();\n        ord.push_back(i);\n        for(int j = 0; j < G[i].size(); ++j) {\n            --num[G[i][j]];\n            if (num[G[i][j]] == 0) {\n                st.push(G[i][j]);\n            }\n        }\n    }\n\n    return ord;\n}\n\n\ntemplate<LL mod>\nstruct modint {\n    LL val;\n    modint(LL val=0) : val(((val % mod) + mod) % mod) {}\n\n    const modint operator+() const { return *this; }\n    const modint operator-() const { return (-val + mod) % mod; }\n    const modint inv() const { return pow(mod-2); }\n\n    modint& operator+=(const modint& rhs) {\n        (val += rhs.val) %= mod;\n        return *this;\n    }\n    modint& operator-=(const modint& rhs) {\n        return *this += -rhs;\n    }\n    modint& operator*=(const modint& rhs) {\n        (val *= rhs.val) %= mod;\n        return *this;\n    }\n    modint& operator/=(const modint& rhs) {\n        return *this *= rhs.inv();\n    }\n\n    const modint operator+(const modint& rhs) const {\n        return modint(*this) += rhs;\n    }\n    const modint operator-(const modint& rhs) const {\n        return modint(*this) -= rhs;\n    }\n    const modint operator*(const modint& rhs) const {\n        return modint(*this) *= rhs;\n    }\n    const modint operator/(const modint& rhs) const {\n        return modint(*this) /= rhs;\n    }\n\n    const modint pow(LL n) const {\n        modint ret = 1, tmp = val;\n        while (n > 0) {\n            if (n & 1) ret *= tmp;\n            tmp *= tmp; n >>= 1;\n        }\n        return ret;\n    }\n\n    bool operator==(const modint& rhs) const { return val == rhs.val; }\n    bool operator!=(const modint& rhs) const { return !(*this == rhs); }\n\n    friend const modint operator+(const LL& lhs, const modint& rhs) {\n        return modint(lhs) + rhs;\n    }\n    friend const modint operator-(const LL& lhs, const modint& rhs) {\n        return modint(lhs) - rhs;\n    }\n    friend const modint operator*(const LL& lhs, const modint& rhs) {\n        return modint(lhs) * rhs;\n    }\n    friend const modint operator/(const LL& lhs, const modint& rhs) {\n        return modint(lhs) / rhs;\n    }\n\n    friend bool operator==(const LL& lhs, const modint& rhs) {\n        return modint(lhs) == rhs;\n    }\n    friend bool operator!=(const LL& lhs, const modint& rhs) {\n        return modint(lhs) != rhs;\n    }\n\n    friend ostream& operator<<(ostream& os, const modint& a) {\n        return os << a.val;\n    }\n    friend istream& operator>>(istream& is, modint& a) {\n        LL tmp; is >> tmp;\n        a = tmp;\n        return is;\n    }\n};\n\nusing Int = modint<MOD>;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int n, m; cin >> n >> m;\n    vector<vector<int>> G(n);\n    for (int i = 0; i < m; ++i) {\n        int u, v; cin >> u >> v; --u, --v;\n        G[v].push_back(u);\n    }\n\n    StronglyConnectedComponents scc(G);\n    scc.build();\n\n    auto ord = topological_sort(scc.t);\n    reverse(ord.begin(), ord.end());\n\n    auto dp = make_v<Int>(2, ord.size());\n\n    for (int i : ord) {\n        dp[0][i] = dp[1][i] = 1;\n        for (int to : scc.t[i]) {\n            dp[0][i] *= dp[0][to] + dp[1][to];\n            dp[1][i] *= dp[1][to];\n        }\n    }\n\n    vector<int> indeg(scc.t.size());\n    for (int i = 0; i < scc.t.size(); ++i) {\n        for (int to : scc.t[i]) {\n            ++indeg[to];\n        }\n    }\n\n    Int ans = 1;\n    for (int i = 0; i < scc.t.size(); ++i) {\n        if (indeg[i] != 0) continue;\n        ans *= (dp[0][i] + dp[1][i]);\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 1000000007;\n\nint dp[1000][2];\nchar edge[1000][1000];\nbool visited[1000];\nbool visited2[1000];\nint n, m;\n\nvoid check(int p, bool f){\n  if(f){\n    visited2[p] = true;\n  }\n  visited[p] = true;\n  for(int i=0;i<n;i++){\n    if(edge[p][i]){\n      if(f && visited2[i]) continue;\n      if(!f && visited[i]){\n        edge[p][i] = 2;\n        f = true;\n        check(i, true);\n      }\n      if(f && !visited2[i]){\n        edge[p][i] = 2;\n        check(i, true);\n      }\n      if(!f && !visited[i]) check(i, false);\n    }\n  }\n}\n\nmain(){\n  while(cin >> n >> m && n){\n    fill(edge[0], edge[1000], 0);\n    for(int i=0;i<m;i++){\n      int a, b;\n      cin >> a >> b;\n      a--;\n      b--;\n      edge[a][b] = 1;\n    }\n    for(int i=0;i<n;i++){\n      fill(visited, visited+n, false);\n      check(i, false);\n    }\n    dp[0][0] = 1;\n    dp[0][1] = 1;\n    for(int i=1;i<n;i++){\n      if(edge[i-1][i] == 2){\n        dp[i][0] = dp[i-1][0];\n        dp[i][1] = dp[i-1][1];\n      }else if(edge[i-1][i] && edge[i][i-1]){\n        dp[i][0] = dp[i-1][0];\n        dp[i][1] = dp[i-1][1];\n      }else if(edge[i-1][i]){\n        dp[i][0] = dp[i-1][0];\n        dp[i][1] = (dp[i-1][0] + dp[i-1][1])%N;\n      }else if(edge[i][i-1]){\n        dp[i][0] = (dp[i-1][0] + dp[i-1][1])%N;\n        dp[i][1] = dp[i-1][1];\n      }else{\n        dp[i][0] = (dp[i-1][0] + dp[i-1][1])%N;\n        dp[i][1] = (dp[i-1][0] + dp[i-1][1])%N;\n      }\n      //cout << dp[i][0] << ' ' << dp[i][1] << endl;\n    }\n    cout << (dp[n-1][0] + dp[n-1][1])%N << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//Decomposition of Strongly Connected Components\n//KYOURENKETSU SEIBUN BUNKAI\nclass SCC{\n    using VI=vector<int>;\n    using VVI=vector<VI>;\n    using EDGE=VVI;\nprivate:\n    EDGE e,r_e;\n    VI vs;\npublic:\n    int size;\n    VI comp,D;\n    VVI nodeset;\n    EDGE newedge;\nprivate:\n    void dfs(int v){\n\tcomp[v]=0;\n\tfor(auto& u : e[v])if(comp[u]==-1)dfs(u);\n\tvs.push_back(v);\n    }\n    void rdfs(int v,int k){\n\tcomp[v]=k;\n\tfor(auto& u : r_e[v])if(comp[u]==-1)rdfs(u,k);\n    }\n    void decomposition(){\n\tcomp.resize(size);\n\tfill(comp.begin(),comp.end(),-1);\n\tvs.clear();\n\tfor(int v = 0; v < size; v++)\n\t    if(comp[v]==-1)dfs(v);\n\treverse(vs.begin(),vs.end());\n\tfill(comp.begin(),comp.end(),-1);\n\tint k=0;\n\tfor(auto& v : vs)if(comp[v]==-1)rdfs(v,k++);\n\tnodeset.resize(k);\n\tnewedge.resize(k);\n\tD.resize(k);\n\tfill(D.begin(),D.end(),0);\n\tfor(int v = 0; v < size; v++){\n\t    nodeset[comp[v]].push_back(v);\n\t    for(auto& u : e[v])\n\t\tif(!isSameComponents(v,u)){\n\t\t    newedge[comp[v]].push_back(comp[u]);\n\t\t    D[comp[u]]++;\n\t\t}\n\t}\n\tsize=k;\n    }\npublic:\n    bool isSameComponents(int a,int b){\n\treturn comp[a]==comp[b];\n    }\n    SCC(int N,EDGE& edge):size(N){\n\te=edge;\n\tr_e.resize(size);\n\tfor(int v = 0; v < size; v++)\n\t    for(auto& u : e[v])\n\t\tr_e[u].push_back(v);\n\tdecomposition();\n    }\n    SCC(EDGE& edge):SCC(edge.size(),edge){}\n};\n\n\nstruct CWW{CWW(){ios::sync_with_stdio(false);cin.tie(0);}}cww;\n\n\ntypedef vector<int> V;\ntypedef vector<V> Graph;\ntypedef long long LL;\nconst LL MOD=1e9+7;\nLL dfs(int v,Graph& tree){\n    LL child=1;\n    for(auto &u:tree[v]){\n\t(child*=dfs(u,tree))%=MOD;\n    }\n    return (child+1)%MOD;\n\n}\nint main(){\n    int N,M;cin>>N>>M;\n    Graph g(N);\n    while(M--){\n\tint a,b;\n\tcin>>a>>b;\n\ta--,b--;\n\tg[b].push_back(a);\n    }\n    SCC scc(g);\n    int m=scc.D.size();\n    LL res=1;\n    for(int i=0;i<m;i++)if(scc.D[i]==0)(res*=dfs(i,scc.newedge))%=MOD;\n    cout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <set>\n#define X first\n#define Y second\n#define sqr(x) (x)*(x)\nusing namespace std;\nconst double PI = acos(-1.0);\nmap<int,int>::iterator it;\ntypedef long long LL ;\n#pragma comment(linker,\"/STACK:102400000,102400000\")\n\nconst int N = 1005;\nconst int M = 20000006;\nstruct edge\n{\n    int u,v,pre;\n} E1[M],E2[M];\nint head[N],hd[N],nedge,cnt,dfn[N],low[N],instack[N],belong[N];\nint n,m,tsp,qlen;\nvector<int> qlt[N];\nstack<int> S;\n\nvoid init()\n{\n    for(int i=0; i<N; ++i)qlt[i].clear();\n    memset(hd,-1,sizeof(hd));\n    memset(head,-1,sizeof(head));\n    memset(dfn,-1,sizeof(dfn));\n    memset(instack,0,sizeof(instack));\n    nedge=0;\n    cnt=0;\n    tsp=0;\n    qlen=0;\n    while(!S.empty())S.pop();\n}\nvoid add_edge(int u,int v)\n{\n    E1[nedge].u=u;\n    E1[nedge].v=v;\n    E1[nedge].pre=head[u];\n    head[u]=nedge++;\n}\nvoid add_edge2(int u,int v)\n{\n    E2[cnt].u=u;\n    E2[cnt].v=v;\n    E2[cnt].pre=hd[u];\n    hd[u]=cnt++;\n}\nvoid dfs(int u)\n{\n    //printf(\"u=%d\\n\",u);\n    dfn[u]=low[u]=++tsp;\n    S.push(u);\n    instack[u]=1;\n    //puts(\"ok\");\n    for(int e=head[u]; ~e; e=E1[e].pre)\n    {\n        //printf(\"e=%d\\n\",e);\n        int v = E1[e].v;\n        //printf(\"v=%d\\n\",v);\n        if(dfn[v]==-1)\n        {\n            dfs(v);\n            low[u]=min(low[v],low[u]);\n        }\n        else if(instack[v])\n        {\n            low[u]=min(low[u],dfn[v]);\n        }\n    }\n    //printf(\"u=%d\\n\",u);\n    if(dfn[u]==low[u])\n    {\n        int p = u;\n        while(S.top()!=p)\n        {\n            qlt[qlen].push_back(S.top());\n            belong[S.top()]=qlen;\n            instack[S.top()]=0;\n            S.pop();\n        }\n        qlt[qlen].push_back(p);\n        belong[p]=qlen++;\n        instack[p]=0;\n        S.pop();\n    }\n}\nLL dp[N];\nint ind[N];\nbool vis[N];\nLL res;\nLL mod = 1000000007LL;\nvoid dfs2(int u)\n{\n    bool dfsed=false;\n    dp[u]=1;\n    for(int e=hd[u]; ~e; e=E2[e].pre)\n    {\n        int v = E2[e].v;\n        dfs2(v);\n        dp[u]*=dp[v];\n        dp[u]%=mod;\n        dfsed=true;\n    }\n    ++dp[u];\n}\nvoid gao()\n{\n    memset(vis,0,sizeof(vis));\n    memset(dp,0,sizeof(dp));\n    memset(ind,0,sizeof(ind));\n    for(int i=0; i<nedge; ++i)\n    {\n        if(belong[ E1[i].u ]!=belong[ E1[i].v ])\n        {\n            ind[ belong[ E1[i].u ] ]++;\n            add_edge2(belong[ E1[i].v ],belong[ E1[i].u ]);\n        }\n    }\n    res=1;\n    for(int i=0; i<qlen; ++i)\n    {\n        if(ind[i]==0)\n        {\n            dfs2(i);\n            res *= dp[i];\n            res %= mod;\n        }\n    }\n}\nint main()\n{\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        init();\n        for(int i=0; i<m; ++i)\n        {\n            int u,v;\n            scanf(\"%d%d\",&u,&v);\n            add_edge(u,v);\n        }\n        for(int i=1; i<=n; ++i)if(dfn[i]==-1)dfs(i);\n        gao();\n        //for(int i=0; i<qlen; ++i)printf(\"%d: %lld %lld\\n\",i,dp[i][0],dp[i][1]);\n\n        printf(\"%lld\\n\",res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 1005\n#define M 1000000007\nusing namespace std;\ntypedef long long ll;\n\nint V; //????????°\nvector<int> G[MAX_V]; //??°???????????£??\\??????????????¨???\nvector<int> rG[MAX_V];//?????????????????????????????°??????\nvector<int> vs;       //??°?????????????????????\nbool used[MAX_V];     //?????§???????????????\nint cmp[MAX_V];       //?±????????????£?????????????????????????????????\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  \n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\nint used2[MAX_V];\n\nll dfs2(int x){\n  if(used[x])return 1;\n  used[x]=true;\n  ll res=1;\n  for(int i=0;i<rG[x].size();i++){\n    int nx=rG[x][i];\n    ll r=dfs2(nx);\n    if(cmp[x]==cmp[nx])r--;\n    res=(res*r)%M;\n  }\n  return res+1;\n}\n\nint main(){\n  int n,m,s,d;\n  int goal[MAX_V];\n  cin>>n>>m;\n  V=n;\n  for(int i=0;i<n;i++)goal[i]=1;\n  for(int i=0;i<m;i++){\n    cin>>s>>d;\n    s--; d--;\n    add_edge(s,d);\n  }\n  int k=scc();\n  for(int i=0;i<n;i++)\n    for(int j=0;j<G[i].size();j++){\n      int x=G[i][j];\n      if(cmp[i]!=cmp[x])\n\tgoal[cmp[i]]=0;\n    }\n  ll ans=1;\n  for(int i=0;i<n;i++){\n    if(!goal[cmp[i]])continue;\n    memset(used,0,sizeof(used));\n    ans=(ans*dfs2(i))%M;\n    goal[cmp[i]]=0;\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <tuple>\n#include <queue>\nusing namespace std;\nusing ll = long long int;\n\nstruct Edge {\n  int to, cost;\n  Edge(int a, int b) : to(a), cost(b) {}\n};\n\nstruct GraphSCC {\n  const int n;\n  vector<int> isthrough;\n  vector<int> vs, cmp;\n  vector< vector< Edge > > G, rG;\n  vector< vector<int> > H;\n\n  GraphSCC(vector< vector< Edge > > &g) :\n    n(g.size()), isthrough(g.size(), false), cmp(g.size(), 0), G(g), rG(g.size()) {\n    // fprintf(stderr, \"n = %d\\n\", n);\n    for(int i=0; i<n; i++) for(int j=0; j<G[i].size(); j++)\n                             rG[ G[i][j].to ].push_back(Edge(i, G[i][j].cost));\n  }\n\n  void SCC_dfsone(int cur) {\n    isthrough[cur] = true;\n    for(int i=0; i<G[cur].size(); i++) {\n      if(!isthrough[G[cur][i].to]) {\n        SCC_dfsone(G[cur][i].to);\n      }\n    }\n    vs.push_back(cur);\n  }\n\n  void SCC_dfstwo(vector<int> &vec, int cur, int k) {\n    cmp[cur] = k;\n    isthrough[cur] = true;\n    vec.push_back(cur);\n    for(int i=0; i<rG[cur].size(); i++) {\n      if(!isthrough[rG[cur][i].to]) {\n        SCC_dfstwo(vec, rG[cur][i].to, k);\n      }\n    }\n  }\n  pair< vector<int>, int > scc() {\n    for(int i=0; i<n; i++) {\n      if(!isthrough[i]) SCC_dfsone(i);\n    }\n\n    fill(isthrough.begin(), isthrough.end(), false);\n    reverse(vs.begin(), vs.end());\n    int k = 0; vector< vector<int> > S;\n\n    for(int i=0; i<vs.size(); i++) {\n      if(!isthrough[vs[i]]) {\n        S.push_back(vector<int>());\n        SCC_dfstwo(S.back(), vs[i], k++);\n      }\n    }\n    \n    H.resize(k);\n    fill(isthrough.begin(), isthrough.end(), false);\n    for(int i=0; i<k; i++) {\n      for(int j=0; j<S[i].size(); j++) {\n        int v = S[i][j];\n        for(int x=0; x<G[v].size(); x++) {\n          int u = G[v][x].to;\n          if(isthrough[cmp[u]] || cmp[v] == cmp[u]) continue;\n          isthrough[ cmp[u] ] = true;\n          H[ cmp[v] ].push_back(cmp[u]);\n        }\n      }\n      for(int j=0; j<H[i].size(); j++) isthrough[ H[i][j] ] = false;\n    }\n    return make_pair(cmp, k);\n  }\n};\n\nll dp[1010][2];\nconst ll MOD = 1000000007;\nusing Graph = vector< vector< Edge > >;\n\nint main() {\n  int N, M; cin >> N >> M;\n  Graph G(N);\n  for(int i=0; i<M; i++) {\n    int u, v; cin >> u >> v;\n    u--; v--;\n    G[u].push_back(Edge(v, 1));\n  }\n\n  GraphSCC compG(G);\n  compG.scc();\n  auto H = compG.H;\n\n  N = H.size();\n  vector<int> indeg(N), outdeg(N), visited(N), cnt(N);\n  for(int i=0; i<N; i++) {\n    for(auto e : H[i]) {\n      indeg[e]++;\n      outdeg[i]++;\n    }\n    dp[i][0] = dp[i][1] = 1;\n  }\n  \n  ll ans = 1;\n  queue<int> que;\n  for(int i=0; i<N; i++) {\n    if(indeg[i] == 0) {\n      que.push(i);\n      visited[i] = true;\n      dp[i][0] = dp[i][1] = 1;\n    }\n  }\n\n  while(que.size()) {\n    int cur = que.front(); que.pop();\n    for(auto to : H[cur]) {\n      (dp[to][0] *= dp[cur][0]) %= MOD;\n      (dp[to][1] *= (dp[cur][0] + dp[cur][1])) %= MOD;\n      cnt[to]++;\n      if(indeg[to] == cnt[to]) {\n        que.push(to);\n      }\n    }\n    if(outdeg[cur] == 0) {\n      (ans *= (dp[cur][0] + dp[cur][1])) %= MOD;\n    }\n  }\n\n  /*\n  cout << N << endl;\n  for(int i=0; i<N; i++) {\n    fprintf(stderr, \"dp[%d][0] = %lld, dp[%d][1] = %lld\\n\", i, dp[i][0], i, dp[i][1]);\n  }\n  */\n\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n\nconst int MAXN=1100;\nconst int MAXE=2100;\nconst long long MOD=1000000007;\n\nstruct Edge\n{\n\tint next,to;\n};\nEdge edge[MAXE];\nint head[MAXN];\nint countedge;\n\nvoid addedge(const int& start,const int& end)\n{\n\tedge[countedge].to=end;\n\tedge[countedge].next=head[start];\n\thead[start]=countedge;\n\tcountedge++;\n}\n\nint node,road;\n\nint low[MAXN],dfn[MAXN];\nint ind,cnt;\nint belong[MAXN];\n\nint stack[MAXN];\nint top;\nvoid dfs(int u)\n{\n\tdfn[u]=low[u]=++ind;\n\tstack[++top]=u;\n\tint temp;\n\tfor(temp=head[u];temp!=-1;temp=edge[temp].next)\n\t{\n\t\tif(!dfn[edge[temp].to])\n\t\t{\n\t\t\tdfs(edge[temp].to);\n\t\t\tlow[u]=min(low[u],low[edge[temp].to]);\n\t\t}\n\t\telse if(!belong[edge[temp].to])low[u]=min(low[u],dfn[edge[temp].to]);\n\t}\n\tif(low[u]==dfn[u])\n\t{\n\t\tint now=u;\n\t\tcnt++;\n\t\tdo\n\t\t{\n\t\t\tnow=stack[top--];\n\t\t\tbelong[now]=cnt;\n\t\t}\n\t\twhile(now!=u);\n\t}\n}\n\nvoid solve()\n{\n\tind=0,cnt=0,top=0;\n\tmemset(dfn,0,sizeof(dfn));\n\tmemset(belong,0,sizeof(belong));\n\tint i;\n\tfor(i=1;i<=node;i++)\n\t{\n\t\tif(!dfn[i]){dfs(i);}\n\t}\n}\n\nbool vis[MAXN];\nint s[MAXN],e[MAXN];\nint in[MAXN];\nlong long dp[MAXN][2];\nvoid gao(int u)\n{\n\tdp[u][0]=1;\n\tdp[u][1]=1;\n\t\n\tint temp;\n\tfor(temp=head[u];temp!=-1;temp=edge[temp].next)\n\t{\n\t\tgao(edge[temp].to);\n\t\tdp[u][1]*=(dp[edge[temp].to][0]+dp[edge[temp].to][1]);\n\t\tdp[u][1]%=MOD;\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&node,&road);\n\t\n\tcountedge=0;\n\tmemset(head,-1,sizeof(head));\n\t\n\tint i;\n\tint start,end;\n\tfor(i=0;i<road;i++)\n\t{\n\t\tscanf(\"%d%d\",&s[i],&e[i]);\n\t\taddedge(s[i],e[i]);\n\t}\n\tsolve();\n\t\n\tmemset(head,-1,sizeof(head));\n\tcountedge=0;\n\t\n\tmemset(vis,0,sizeof(vis));\n\tfor(i=0;i<road;i++)\n\t{\n\t\tint from=belong[e[i]];\n\t\tint to=belong[s[i]];\n\t\tif(from==to)continue;\n\t\taddedge(from,to);\n\t\tin[to]++;\n\t}\n\n\tlong long ret=1;\n\tfor(i=1;i<=cnt;i++)\n\t{\n\t\tif(in[i]==0)\n\t\t{\n\t\t\tgao(i);\n\t\t\tret*=(dp[i][0]+dp[i][1]);\n\t\t\tret%=MOD;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\",ret);\n\t\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nint N,M;\nvi g[1010],r[1010];\nint used[1010];\nint List[1010],l;\nint cycle[1010],c;\nint inCycle[1010];\n\nvoid dfs(int cur){\n\tif(used[cur]){\n\t\tint from = 0;\n\t\twhile(List[from] != cur) from++;\n\t\trep2(i,from,l){\n\t\t\tcycle[c++] = List[i];\n\t\t}\n\t\treturn;\n\t}\n\tused[cur] = 1;\n\tList[l++] = cur;\n\tif(sz(g[cur]) == 0){\n\t\tcycle[c++] = cur;\n\t\treturn;\n\t}\n\trep(i,sz(g[cur])){\n\t\tdfs(g[cur][i]);\n\t}\n}\n\nll solve(int v){\n\tll res = 1;\n\tused[v] = 1;\n\trep(i,sz(r[v])){\n\t\tres = res * solve(r[v][i]) % MOD;\n\t}\n\tres = (res+1) % MOD;\n\treturn res;\n}\n\nll f(int start){\n\tl=0;\n\tc=0;\n\tdfs(start);\n\tll res = 1;\n\trep(i,c)inCycle[cycle[i]] = 1;\n\trep(i,c)rep(j,sz(r[cycle[i]])){\n\t\tif(inCycle[r[cycle[i]][j]])continue;\n\t\tres = res * solve(r[cycle[i]][j]) % MOD;\n\t}\n\tres = (res+1) % MOD;\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>N>>M;\n\trep(i,M){\n\t\tint s,d;\n\t\tcin>>s>>d;\n\t\ts--;d--;\n\t\tg[s].pb(d);\n\t\tr[d].pb(s);\n\t}\n\n\tll ans = 1;\n\trep(i,N)if(!used[i]){\n\t\tans = ans * f(i) % MOD;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<58;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Graph{\n\tprivate:\n\tint V;\n\tvvi g;\n\tvi scc,Vec,used;\n\tvoid DFS(int v,int cnt){\n\t\tused[v]=1;\n\t\tfor(int i=0;i<g[v].size();i++){\n\t\t\tint u=g[v][i];\n\t\t\tif(!used[u]) DFS(u,cnt);\n\t\t}\n\t\tscc[v]=cnt;\n\t}\n\tvoid Order(int v){\n\t\tused[v]=1;\n\t\tfor(int i=0;i<g[v].size();i++){\n\t\t\tint u=g[v][i];\n\t\t\tif(!used[u]) Order(u);\n\t\t}\n\t\tVec.push_back(v);\n\t}\n\tGraph Rev(){\n\t\tGraph G(V);\n\t\tfor(int i=0;i<V;i++){\n\t\t\tfor(int j=0;j<g[i].size();j++){\n\t\t\t\tint v=g[i][j];\n\t\t\t\tG.g[v].push_back(i);\n\t\t\t}\n\t\t}\n\t\treturn G; \n\t}\n\tint SCC(){\n\t\tscc=used=vi(V);\n\t\tfor(int i=0;i<V;i++) if(!used[i]) Order(i);\n\t\tGraph RG=Rev();\n\t\tRG.used=vi(V,0);\n\t\tRG.scc=vi(V);\n\t\tint cnt=0;\n\t\twhile(!Vec.empty()){\n\t\t\tint v=Vec.back();\n\t\t\tVec.pop_back();\n\t\t\tif(!RG.used[v]){\n\t\t\t\tRG.DFS(v,cnt);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tscc=RG.scc;\n\t\treturn cnt;\n\t}\n\tll dfs(int v){\n\t\tused[v]=1;\n\t\tll res=1;\n\t\tfor(int i=0;i<g[v].size();i++) (res*=dfs(g[v][i]))%=mod;\n\t\treturn res+1;\n\t}\n\tpublic:\n\tGraph(int v){\n\t\tV=v;\n\t\tg=vvi(v);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tg[s].push_back(t);\n\t}\n\tll Solve(){\n\t\tll res=1;\n\t\tused=vi(V);\n\t\tvi in(V);\n\t\tfor(int i=0;i<V;i++) for(int j=0;j<g[i].size();j++) in[g[i][j]]++;\n\t\tfor(int i=0;i<V;i++) if(!used[i]) (res*=dfs(i))%=mod;\n\t\treturn res;\n\t}\n\tll solve(){\n\t\tint GV=SCC();\n\t\tGraph G(GV);\n\t\tfor(int i=0;i<V;i++) for(int j=0;j<g[i].size();j++){\n\t\t\tint v=g[i][j],su=scc[i],sv=scc[g[i][j]];\n\t\t\tif(su!=sv) G.add_edge(su,sv);\n\t\t}\n\t\treturn G.Solve();\n\t}\n};\n\nint n,m;\n\nint main(){\n\tcin>>n>>m;\n\tGraph g(n);\n\tfor(int i=0;i<m;i++){\n\t\tint t,s;\n\t\tcin>>t>>s;\n\t\tg.add_edge(s-1,t-1);\n\t}\n\tcout<<g.solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long mo = 1e9+7;\n\n/***********************/\n// ??±?????¨???\n/***********************/\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntypedef long long Weight;\nconst Weight INF = 1e18;\n\nstruct Edge {\n    ll src, dst;\n    Weight weight;\n    Edge(ll src, ll dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid addDirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); }\nvoid addUndirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); g[dst].push_back(Edge(dst, src, weight)); }\nvoid addDirected(Graph& g, ll src, ll dst) { addDirected(g, src, dst, 1); }\nvoid addUndirected(Graph& g, ll src, ll dst) { addUndirected(g, src, dst, 1); }\nvoid printGraph(Graph& g) {\n    rep(i, g.size()) {\n        if (!g[i].size())\n            continue;\n        rep(j, g[i].size()) \n            cout << \"(\" << i << \", \" << g[i][j].dst << \"), \";\n        cout << endl;\n    }\n}\n\n// ?????£???????§£\n// O(V+E)\n// const Graph& g               ????????°??????\n// vector< vector<ll> >& scc   ??°??????????????£?????????\nvoid visitStronglyConnectedComponents(const Graph &g, ll v, vector< vector<ll> >& scc,\n        stack<ll> &S, vector<bool> &inS,\n        vector<ll> &low, vector<ll> &num, ll& time) {\n    low[v] = num[v] = ++time;\n    S.push(v); inS[v] = true;\n    FOR(e, g[v]) {\n        ll w = e->dst;\n        if (num[w] == 0) {\n            visitStronglyConnectedComponents(g, w, scc, S, inS, low, num, time);\n            low[v] = min(low[v], low[w]);\n        } else if (inS[w])\n            low[v] = min(low[v], num[w]);\n    }\n    if (low[v] == num[v]) {\n        scc.push_back(vector<ll>());\n        while (1) {\n            ll w = S.top(); S.pop(); inS[w] = false;\n            scc.back().push_back(w);\n            if (v == w) break;\n        }\n    }\n}\nvoid stronglyConnectedComponents(const Graph& g, vector< vector<ll> >& scc) {\n    const ll n = g.size();\n    vector<ll> num(n), low(n);\n    stack<ll> S;\n    vector<bool> inS(n);\n    ll time = 0;\n    rep(u, n) if (num[u] == 0)\n        visitStronglyConnectedComponents(g, u, scc, S, inS, low, num, time);\n}\n\n// ???????????????????????????\n// ????????????????????? u ??§?????£??????u[i] ?????? u[j] ??????????????? => i < j ?????????????????????????????????\n//\n// const Graph &g\n// ??°?????????\n// vector<int> &order\n// ???????????????????????????????????????????????¨??§??£??\\???????????????????????????????????? true ?????¨???????????????\n// ?????????\n// ????????????????????????????????????????????????\n//\n// O(V+E)\nbool visitT(const Graph &g, ll v, vector<ll> &order, vector<ll> &color) {\n    color[v] = 1;\n    FOR(e, g[v]) {\n        if (color[e->dst] == 2) continue;\n        if (color[e->dst] == 1) return false;\n        if (!visitT(g, e->dst, order, color)) return false;\n    }\n    order.push_back(v); color[v] = 2;\n    return true;\n}\nbool topologicalSort(const Graph &g, vector<ll> &order) {\n    ll n = g.size();\n    vector<ll> color(n);\n    rep(u, n) if (!color[u] && !visitT(g, u, order, color))\n        return false;\n    reverse(all(order));\n    return true;\n}\n\n// ???????????°???????????????\nvoid reverseGraph(Graph& g_dst, Graph& g_src) { /*g_dst??????graph?????????*/\n    g_dst = Graph(g_src.size());\n    rep(i, g_src.size()) {\n        rep(j, g_src[i].size()) {\n            addDirected(g_dst, g_src[i][j].dst, g_src[i][j].src, g_src[i][j].weight);\n        }\n    }\n}\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, m; cin >> n >> m;\n    Graph g = Graph(n);\n    rep(i, m) {\n        ll u, v; cin >> u >> v; u--, v--;\n        addDirected(g, u, v);\n    }\n\n    // ??????????????°?????????????????????\n    vector<vector<ll>> scc;\n    stronglyConnectedComponents(g, scc);\n    /*\n    rep(i, scc.size()) {\n        rep(j, scc[i].size()) cout << scc[i][j] << \" \";\n        cout << endl;\n    }\n    */\n\n    // ?????????????????????SCC????±????????????????\n    vector<ll> scc_inv(g.size());\n    rep(i, scc.size()) rep(j, scc[i].size()) scc_inv[scc[i][j]] = i;\n//    cout << scc_inv << endl;\n\n    // ??°??????DAG?????°????????????\n    // ??°??????dag?????????i??????????????????(vector<ll> scc[i])???????????¨???????????????\n    Graph dag(scc.size());\n    rep(from, g.size()) rep(to, g[from].size()) if (scc_inv[from] != scc_inv[g[from][to].dst]) {\n        addDirected(dag, scc_inv[from], scc_inv[g[from][to].dst]);\n    }\n    /*\n    printGraph(dag);\n    */\n\n    vector<ll> order;\n    bool success = topologicalSort(dag, order);\n    /*\n    if (success) \n        cout << order << endl;\n    else \n        cout << \"NOT DAG\" << endl; // ??¶???DAG??????????????????\n    */\n    reverse(all(order));\n\n    Graph dag_rev;\n    reverseGraph(dag_rev, dag);\n    /*\n    printGraph(dag);\n    printGraph(dag_rev);\n    */\n\n    vll dp(dag.size(), -1);\n    function<ll(ll)> f = [&](ll i){\n        if (dp[i] != -1)\n            return dp[i];\n        dp[i] = 1;\n        rep(j, dag_rev[i].size()) {\n            (dp[i] *= f(dag_rev[i][j].dst) + 1) %= mo;\n        }\n        return dp[i];\n    };\n\n    ll ret = 1;\n    rep(i, dag.size()) {\n        if (dp[order[i]] != -1) \n            continue;\n        (ret *= f(order[i]) + 1) %= mo;\n    }\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\nconst LL MOD = 1000000007LL;\nvector<int> G[1000];\nvector<int> rG[1000];\nvector<int> cG[1000];\nvector<int> vs;\nbool used[1000];\nint cmp[1000];\nint in[1000];\nbool exist[1000][1000];\nint N, M;\nvoid dfs(int v) {\n\tused[v] = 1;\n\tfor (int to : G[v]) {\n\t\tif (!used[to]) dfs(to);\n\t}\n\tvs.push_back(v);\n}\nvoid rdfs(int v, int k) {\n\tused[v] = 1;\n\tcmp[v] = k;\n\tfor (int to : rG[v]) {\n\t\tif (!used[to]) rdfs(to, k);\n\t}\n}\nint scc() {\n\tmemset(used, 0, sizeof(used));\n\tvs.clear();\n\tfor (int v = 0; v < N; v++) {\n\t\tif (!used[v]) dfs(v);\n\t}\n\tmemset(used, 0, sizeof(used));\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--) {\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++);\n\t}\n\treturn k;\n}\nLL calc(int k) {\n\tLL ans = 1;\n\tLL tmp = 1;\n\tfor (int to : cG[k]) {\n\t\t(tmp *= calc(to)) %= MOD;\n\t}\n\t(ans += tmp) %= MOD;\n\treturn ans;\n}\nint main() {\n\tcin >> N >> M;\n\tfor (int i = 0; i < M; i++) {\n\t\tint S, D;\n\t\tcin >> S >> D;\n\t\tS--; D--;\n\t\tG[D].push_back(S);\n\t\trG[S].push_back(D);\n\t}\n\tint k = scc();\n\tfor (int v = 0; v < N; v++) {\n\t\tfor (int to : G[v]) {\n\t\t\tif (cmp[v] == cmp[to] || exist[cmp[v]][cmp[to]]) continue;\n\t\t\texist[cmp[v]][cmp[to]] = 1;\n\t\t\tin[cmp[to]]++;\n\t\t\tcG[cmp[v]].push_back(cmp[to]);\n\t\t}\n\t}\n\tmemset(used, 0, sizeof(used));\n\tLL ans = 1;\n\tfor (int i = 0; i < k; i++) {\n\t\tif (in[i]) continue;\n\t\t(ans *= calc(i)) %= MOD;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string> \n#include <stack>\n#include <utility>\n#include <set>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int search(int n,vector<vector<int>>& from) {\n\t//cout << n << endl;\n\tlong long int ret = 1;\n\tif (from[n].empty()) {\n\t\treturn 2;\n\t}\n\tfor (auto i : from[n]) {\n\t\tret += search(i, from);\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int>to(N + 1);\n\tvector<vector<int>>from(N + 1);\n\tfor (int i = 0; i < M; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tto[a] = b;\n\t\tfrom[b].push_back(a);\n\t}\n\tvector<bool>use(N + 1, true);\n\tvector<bool>ignore(N + 1);\n\tlong long int ans = 1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (!use[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tvector<bool>used(N + 1);\n\t\tqueue<int>Q;\n\t\tQ.push(i);\n\t\twhile (!Q.empty()) {\n\t\t\tint cn = Q.front();\n\t\t\tuse[cn] = false;\n\t\t\tused[cn] = true;\n\t\t\tQ.pop();\n\t\t\tif (to[cn]) {\n\t\t\t\tif (used[to[cn]]) {\n\t\t\t\t\tint nx = to[to[cn]];\n\t\t\t\t\tto[to[cn]] = 0;\n\t\t\t\t\tfor (int j = 0; j < from[to[cn]].size(); j++) {\n\t\t\t\t\t\tif (cn == from[to[cn]][j]) {\n\t\t\t\t\t\t\tswap(from[to[cn]][j], from[to[cn]][from[to[cn]].size() - 1]);\n\t\t\t\t\t\t\tfrom[to[cn]].pop_back();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\twhile (nx != to[cn]) {\n\t\t\t\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\t\t\t\tif (to[j] == nx) {\n\t\t\t\t\t\t\t\tto[j] = to[cn];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tignore[nx] = true;\n\t\t\t\t\t\tnx = to[nx];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tQ.push(to[cn]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tfrom[i].clear();\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (ignore[i])continue;\n\t\tfrom[to[i]].push_back(i);\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (ignore[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif(to[i]){\n\t\t\tcontinue;\n\t\t}\n\t\t//cout << i << \"start\" << endl;\n\t\tans *= search(i, from);\n\t\tans %= MOD;\n\t\t//cout << ans << endl;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\n#define abs(x) ((x)>=0?(x):-(x))\n#define i64 long long\n#define u32 unsigned int\n#define u64 unsigned long long\n#define clr(x,y) memset(x,y,sizeof(x))\n#define PI acos(-1.0)\n#define sqr(x) ((x)*(x))\n#define mod 1000000007\n#define maxn 2005\n\nstruct node\n{\n  int v,next;\n};\nnode e[maxn * 2 ];\nint head[maxn];\nint cnt;\nint ind[maxn];\nvoid init()\n{\n  memset(head,-1,sizeof(head));\n  cnt = 0;\n}\nvoid add(int u ,int v  )\n{\n  e[cnt].v = v ;\n  e[cnt].next = head[u];\n  head[u] = cnt ++ ;\n\n  return ;\n}\nint col[maxn];\nint dfn[maxn],low[maxn];\nint st[maxn];\nint top;\nint scnt;\nint dep ;\nbool instack[maxn];\nint mp[maxn][maxn];\n\nvoid tarjan(int u)\n{\n  //printf(\"u = %d\\n\",u);\n  dfn[u]=low[u]=dep++;\n  st[++top]=u;\n  instack[u]=true;\n  int v;\n  for(int i = head[u]; i != -1; i = e[i].next)\n  {\n    v = e[i].v;\n    if (dfn[v]==-1)\n    {\n      tarjan(v);\n      low[u]=min(low[u],low[v]);\n    }\n    else if (instack[v]) low[u]=min(low[u],dfn[v]);\n  }\n  if (dfn[u]==low[u])\n  {\n    int x;\n    do\n    {\n      x=st[top--];\n      instack[x]=false;\n      col[x]=scnt;\n    }\n    while (x != u);\n    scnt++;\n  }\n  return ;\n}\nint n,m;\nvoid base()\n{\n  memset(dfn,-1,sizeof(dfn));\n  memset(instack,0,sizeof(instack));\n  top = 0 ;\n  scnt = 1 ;\n  dep = 0 ;\n  for(int i = 1 ; i <= n ; i ++ )\n  {\n    if(dfn[i] == -1)\n    {\n      tarjan(i);\n    }\n  }\n  memset(mp,0,sizeof(mp));\n  memset(ind,0,sizeof(ind));\n  for(int i = 1 ; i <= n ; i ++ )\n  {\n    for(int j = head[i] ; j != -1 ; j = e[j].next)\n    if(col[e[j].v] != col[i])\n    {\n      ind[col[i]] ++ ;\n      mp[col[e[j].v]][col[i]] = 1 ;\n     // printf(\"%d %d\\n\",col[e[j].v],col[i]);\n    }\n  }\n}\ni64 dfs(int u )\n{\n  i64 res,tmp;\n  res = 1 ;\n  for(int i = 1 ; i <  scnt ; i ++ )\n    if(mp[u][i] == 1 && i != u  )\n    {\n      tmp = dfs(i);\n      res = (res * tmp) % mod;\n    }\n  res = (res + 1 ) % mod ;\n  return res ;\n}\nint main()\n{\n  int u,v;\n  //while(\n\n        scanf(\"%d%d\",&n,&m)\n        ;//!=EOF)\n  {\n    init();\n    for(int i = 0; i < m; i ++ )\n    {\n      scanf(\"%d%d\",&u,&v);\n      add(u,v);\n    }\n    base();\n    i64 ans ,tmp;\n    ans = 1 ;\n    for(int i = 1; i < scnt ; i ++ )\n    if(ind[i] == 0)\n    {\n      tmp = dfs(i);\n      //printf(\"tmp = %d\\n\",tmp);\n      ans = (ans * tmp) % mod ;\n    }\n    ans = ans % mod;\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<cassert>\n#include<climits>\n\n#define MOD (1000000007)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 2000\n\nusing namespace std;\n\ntypedef long long ull;\ntypedef pair<int,int> ii;\n\nstruct Data{\n  int  to,cost;\n  Data(int to=IINF,int cost=IINF):to(to),cost(cost){}\n};\n\n// Library - topological sort - begin \ntemplate<typename T>\nbool visit(const T& G,int v,vector<int>& order,vector<int>& color)\n{\n  color[v] = 1;\n  for(__typeof((G[v]).begin()) e = G[v].begin();e != G[v].end();e++)\n    {\n      if(color[e->to] == 2)continue;//このvisit以外のvisitで訪れた\n      if(color[e->to] == 1)return false;//このvisitで訪れた\n      if(!visit(G,e->to,order,color))return false;\n    }\n  order.push_back(v);\n  color[v] = 2;\n  return true;\n}\n\ntemplate<typename T>\nbool topologicalSort(const T& G,vector<int>& order)\n{\n  int SizeG = G.size();\n  vector<int> color(SizeG); \n  for(int u=0;u<SizeG;u++)\n    if(!color[u] && !visit(G,u,order,color))\n      return false;\n  reverse(order.begin(),order.end());\n  return true;\n}\n// Library - topological sort - end\n\nint V,E,S,D;\nvector<vector<Data> > tmp_G,tmp_rG;\nvector<int>  G[MAX];\nvector<int> rG[MAX];\nvector<int> vs;\nbool used[MAX];\nint cmp[MAX];\null dp[MAX];\n\ninline void add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k = 0;\n  for(int i = vs.size()-1; i >= 0 ; i-- )if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nint main(){\n  cin >> V >> E;\n  rep(i,E){\n    cin >> S >> D;\n    assert(1 <= S && S <= V);\n    assert(1 <= D && D <= V);\n    add_edge(S-1,D-1);\n  }\n  int nV = scc();\n  rep(i,nV)dp[i] = -1;\n  set<int> OUT_counter[nV];\n  rep(i,V)rep(j,G[i].size()){\n    if(cmp[i] == cmp[G[i][j]])continue;\n    OUT_counter[cmp[i]].insert(cmp[G[i][j]]);\n  }\n  tmp_G.clear(),tmp_rG.clear();\n  tmp_G.resize(nV),tmp_rG.resize(nV);\n  rep(i,nV)for(int j : OUT_counter[i]){\n    tmp_G[i].push_back(j);\n    tmp_rG[j].push_back(i);\n  }\n  vector<int> order;\n  topologicalSort(tmp_G,order);\n  rep(i,nV)if(tmp_rG[order[i]].empty())dp[order[i]] = 2ULL;\n  ull ans = 1;\n  rep(i,nV){\n    int cur = order[i];\n    ull cost = 1;\n    rep(j,tmp_rG[cur].size())cost = ( cost * dp[tmp_rG[cur][i].to] ) % MOD;\n    if(!tmp_rG[cur].empty())dp[cur] = ( cost + 1ULL ) % MOD;\n    if(tmp_G[cur].empty())ans = ( ans * dp[cur] ) % MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\ntypedef long long ll;\n\nusing namespace std;\n\nint e[1000];\nll dp[1000][2];\n\nint cycle[1000];\nint flag[1000];\nint in[1000];\n\nint n, m;\n\nconst int mod = 1000000007;\n\nint check(int i){\n  if(flag[i] == 2) return -1;\n  if(flag[i] == 1){\n    flag[i] = 2;\n    return i;\n  }\n\n  flag[i] = 1;\n\n  if(e[i] != -1){\n    int c = check(e[i]);\n    if(c != -1){\n      flag[i] = 2;\n      cycle[i] = c;\n      if(c == i) return -1;\n      else return c;\n    }\n  }\n  flag[i] = 2;\n\n  return -1;\n}\n\nint main(){\n  n = getInt();\n  m = getInt();\n\n  REP(i,n){\n    e[i] = -1;\n    cycle[i] = i;\n    dp[i][0] = dp[i][1] = 1;\n  }\n\n  REP(i,m){\n    int s = getInt() - 1;\n    int d = getInt() - 1;\n    e[s] = d;\n  }\n\n  REP(i,n) if(!flag[i])\n    check(i);\n\n  REP(i,n) if(cycle[i] == i && e[i] != -1 && cycle[e[i]] != i){\n    int ee = cycle[e[i]];\n    if(ee != -1) in[ee]++;\n  }\n\n  queue<int> que;\n  ll ans = 1;\n\n  REP(i,n) if(cycle[i] == i){\n    if(in[i] == 0) que.push(i);\n  }\n\n  while(que.size()){\n    int pos = que.front(); que.pop();\n    flag[pos] = 5;\n\n    if(e[pos] == -1 || cycle[e[pos]] == pos){\n      ans = (ans * ((dp[pos][0] + dp[pos][1]) % mod)) % mod;\n    }else{\n      int next = cycle[e[pos]];\n      dp[next][0] = (dp[next][0] * dp[pos][0]) % mod;\n      dp[next][1] = (dp[next][1] * ((dp[pos][0] + dp[pos][1]) % mod)) % mod;\n      if(--in[next] == 0)\n        que.push(next);\n    }\n  }\n\n  printf(\"%d\\n\", (int)ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef long long int lli;\nconst lli mod = 1e9 +7;\n\nvoid dfs(int node, vector<int> &ord, vector<bool> &used, vector<vector<int> > &adj){\n    if(used[node]) return;\n    used[node] = true;\n    for(int to: adj[node]){\n        dfs(to, ord, used, adj);\n    }\n    ord.push_back(node);\n}\n \nvector<vector<int> > scc_decomposition(vector<vector<int> > &adj){\n    int n = adj.size();\n    vector<vector<int> > revadj(n);\n    for(int i=0; i<n; i++){\n        for(int to: adj[i]){\n            revadj[to].push_back(i);\n        }\n    }\n     \n    vector<bool> used(n, false);\n    vector<int> ord;\n    for(int i=0; i<n; i++){\n        if(used[i]) continue;\n        dfs(i, ord, used, adj);\n    }\n    used = vector<bool>(n, false);\n    vector<vector<int> > res;\n    for(int i=n-1; i>=0; i--){\n        if(used[ord[i]]) continue;\n        res.emplace_back();\n        dfs(ord[i], res.back(), used, revadj);\n        sort(res.back().begin(), res.back().end());\n    }\n    return res;\n}\n\nlli solve(vector<vector<int> > &adj){\n    int n = adj.size();\n    vector<int> ord_in(n, 0);\n    for(vector<int> v: adj){\n        for(int i: v){\n            ord_in[i]++;\n        }\n    }\n\n    queue<int> wait;\n    for(int i=0; i<n; i++){\n        if(ord_in[i] == 0) wait.push(i);\n    }\n    lli ans = 1;\n    vector<lli> dp(n, 1);\n    while(!wait.empty()){\n        int cur = wait.front();\n        wait.pop();\n        for(int i: adj[cur]){\n            dp[i] *= dp[cur] +1;\n            dp[i] %= mod;\n            ord_in[i]--;\n            if(ord_in[i] == 0) wait.push(i);\n        }\n        if(adj[cur].empty()){\n            ans *= (dp[cur] +1);\n            ans %= mod;\n        }\n    }\n    return ans;\n}\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    vector<vector<int> > adj(n);\n    for(int i=0; i<m; i++){\n        int s,d;\n        cin >> s >> d;\n        s--; d--;\n        adj[s].push_back(d);\n    }\n\n    vector<vector<int> > scc = scc_decomposition(adj);\n    vector<int> conv(n);\n    for(int i=0; i<(int)scc.size(); i++){\n        for(int j: scc[i]){\n            conv[j] = i;\n        }\n    }\n\n    {\n        vector<vector<int> > newadj(scc.size());\n        for(int i=0; i<n; i++){\n            for(int j: adj[i]){\n                if(conv[i] == conv[j]) continue;\n                newadj[conv[i]].push_back(conv[j]);\n            }\n        }\n        for(vector<int> v: newadj){\n            sort(v.begin(), v.end());\n            v.erase(unique(v.begin(), v.end()), v.end());\n        }\n        adj = newadj;\n    }\n    \n    cout << solve(adj) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 1000000007;\nconst int SIZE = 1001;\n\nint dp[SIZE][2];\nchar edge[SIZE][SIZE];\nbool visited[SIZE];\nbool visited2[SIZE];\nint n, m;\n\nvoid check(int p, bool f){\n  if(f){\n    visited2[p] = true;\n  }\n  visited[p] = true;\n  for(int i=0;i<n;i++){\n    if(i == p) continue;\n    if(edge[p][i]){\n      if(f && visited2[i]) continue;\n      if(!f && visited[i]){\n        edge[p][i] = 2;\n        f = true;\n        check(i, true);\n      }\n      if(f && !visited2[i]){\n        edge[p][i] = 2;\n        check(i, true);\n      }\n      if(!f && !visited[i]) check(i, false);\n    }\n  }\n}\n\nmain(){\n  while(cin >> n >> m && n){\n    fill(edge[0], edge[SIZE], 0);\n    for(int i=0;i<m;i++){\n      int a, b;\n      cin >> a >> b;\n      a--;\n      b--;\n      edge[a][b] = 1;\n    }\n    for(int i=0;i<n;i++){\n      fill(visited, visited+n, false);\n      check(i, false);\n    }\n    dp[0][0] = 1;\n    dp[0][1] = 1;\n    for(int i=1;i<n;i++){\n      if(edge[i-1][i] == 2 || edge[i][i-1] == 2){\n        dp[i][0] = dp[i-1][0];\n        dp[i][1] = dp[i-1][1];\n      }else if(edge[i-1][i] == 1){\n        dp[i][0] = dp[i-1][0];\n        dp[i][1] = (dp[i-1][0] + dp[i-1][1])%N;\n      }else if(edge[i][i-1] == 1){\n        dp[i][0] = (dp[i-1][0] + dp[i-1][1])%N;\n        dp[i][1] = dp[i-1][1];\n      }else{\n        dp[i][0] = (dp[i-1][0] + dp[i-1][1])%N;\n        dp[i][1] = (dp[i-1][0] + dp[i-1][1])%N;\n      }\n      //cout << dp[i][0] << ' ' << dp[i][1] << endl;\n    }\n    cout << (dp[n-1][0] + dp[n-1][1])%N << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string> \n#include <stack>\n#include <utility>\n#include <set>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int search(int n,vector<vector<int>>& from) {\n\t//cout << n << endl;\n\tlong long int ret = 1;\n\tif (from[n].empty()) {\n\t\treturn 2;\n\t}\n\tfor (auto i : from[n]) {\n\t\tret *= search(i, from);\n\t\tret %= MOD;\n\t}\n\tret++;\n\tret %= MOD;\n\treturn ret;\n}\n\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int>to(N + 1);\n\tvector<vector<int>>from(N + 1);\n\tfor (int i = 0; i < M; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tto[a] = b;\n\t\tfrom[b].push_back(a);\n\t}\n\tvector<bool>use(N + 1, true);\n\tvector<bool>ignore(N + 1);\n\tlong long int ans = 1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (!use[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tvector<bool>used(N + 1);\n\t\tqueue<int>Q;\n\t\tQ.push(i);\n\t\twhile (!Q.empty()) {\n\t\t\tint cn = Q.front();\n\t\t\tuse[cn] = false;\n\t\t\tused[cn] = true;\n\t\t\tQ.pop();\n\t\t\tif (to[cn]) {\n\t\t\t\tif (used[to[cn]]) {\n\t\t\t\t\tint nx = to[to[cn]];\n\t\t\t\t\tto[to[cn]] = 0;\n\t\t\t\t\tfor (int j = 0; j < from[to[cn]].size(); j++) {\n\t\t\t\t\t\tif (cn == from[to[cn]][j]) {\n\t\t\t\t\t\t\tswap(from[to[cn]][j], from[to[cn]][from[to[cn]].size() - 1]);\n\t\t\t\t\t\t\tfrom[to[cn]].pop_back();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\twhile (nx != to[cn]) {\n\t\t\t\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\t\t\t\tif (to[j] == nx) {\n\t\t\t\t\t\t\t\tto[j] = to[cn];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tignore[nx] = true;\n\t\t\t\t\t\tnx = to[nx];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tQ.push(to[cn]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tfrom[i].clear();\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (ignore[i])continue;\n\t\tfrom[to[i]].push_back(i);\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (ignore[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif(to[i]){\n\t\t\tcontinue;\n\t\t}\n\t\t//cout << i << \"start\" << endl;\n\t\tans *= search(i, from);\n\t\tans %= MOD;\n\t\t//cout << ans << endl;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 1145\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst ll MOD = ((1e9) + 7);\n\nint N, cmp[MAX_V];\nbool used[MAX_V];\nvector<int> G[MAX_V], rG[MAX_V], vs;\n\nvoid add_edge(int from, int to)\n{\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid dfs(int v)\n{\n    used[v] = 1;\n    for (int i = 0; i < (int)G[v].size(); i++) {\n\tif (!used[G[v][i]]) {\n            dfs(G[v][i]);\n        }\n    }\n    vs.push_back(v);\n}\n\nvoid rdfs(int v, int k)\n{\n    used[v] = 1;\n    cmp[v] = k;\n    for (int i = 0; i < (int)rG[v].size(); i++) {\n\tif (!used[rG[v][i]]) {\n            rdfs(rG[v][i], k);\n        }\n    }\n}\n\nint scc()\n{\n    memset(used, 0, sizeof(used));\n    vs.clear();\n    for (int v = 0; v < N; v++) {\n\tif (!used[v]) {\n            dfs(v);\n        }\n    }\n    memset(used, 0, sizeof(used));\n    int k = 0;\n    for (int i = vs.size() - 1; i >= 0; i--) {\n\tif (!used[vs[i]]) {\n            rdfs(vs[i], k++);\n        }\n    }\n    return k;\n}\n\nvector<int> nG[MAX_V];\nll memo[MAX_V];\n\nll solve(int v)\n{\n    ll &res = memo[v];\n    if (res != -1) return res;\n    res = 1;\n    for (int i = 0; i < (int)nG[v].size(); i++) {\n        res *= solve(nG[v][i]);\n        res %= MOD;\n    }\n    res += 1;\n    return res % MOD;\n}\n\nint main()\n{\n    int M, a, b;\n    cin >> N >> M;\n    for (int i = 0; i < M; i++) {\n        cin >> a >> b; a--; b--;\n        add_edge(a, b);\n    }\n    \n    auto K = scc();\n    \n    set<pii> st;\n    int deg[MAX_V] = {};\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < (int)G[i].size(); j++) {\n            int from = cmp[i], to = cmp[G[i][j]];\n            if (from != to && st.count(pii(from, to)) == 0) {\n                st.insert(pii(from, to));\n                nG[to].push_back(from);\n                deg[from]++;\n            }\n        }\n    }\n    \n    memset(memo, -1, sizeof(memo));\n    ll res = 1;    \n    for (int i = 0; i < K; i++) {\n        if (deg[i] == 0) {\n            res *= solve(i);\n            res %= MOD;\n        }\n    }\n\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<string.h>\n#include<stdlib.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<iostream>\n#include<math.h>\ntypedef long long ll;\n#define eps 1e-8\n#define ms(a) memset(a,0,sizeof(a))\n#define pi acos(-1.0)\nusing namespace std;\nint set[100001];\nint findfa(int x)\n{\n    if(set[x]==x) return x;\n    return set[x]=findfa(set[x]);\n}\nint main()\n{\n   // freopen(\"f:\\\\in.txt\",\"r\",stdin);\n    int x,y;\n    while(~scanf(\"%d%d\",&x,&y))\n    {\n        if(x==-1&&y==-1)\n            break;\n        for(int i=1; i<=100000; i++)\n            set[i]=i;\n        int fx=findfa(x),fy=findfa(y);\n        set[fx]=fy;\n        int flag=1;\n        while(scanf(\"%d%d\",&x,&y)!=EOF)\n        {\n            if(x==0&&y==0)\n                break;\n            if(flag)\n            {\n                fx=findfa(x),fy=findfa(y);\n                if(fx==fy)\n                    flag=0;\n                else\n                set[fx]=fy;\n            }\n        }\n        if(flag) printf(\"Yes\\n\");\n        else\n        printf(\"No\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int Maxn = 3000, Mod = 1000000007;\n\nvector<int> nxt[Maxn];\n\nint fa[Maxn];\n\nint incircle[Maxn];\nint vis[Maxn];\n\nint circId;\n\nvector<int> stack;\n\nbool find(int x)\n{\n\tif(x == -1)\n\t\treturn false;\n\tif(vis[x] == circId)\n\t{\n\t\tfor(int i = (int)stack.size() - 1; i >= 0; --i)\n\t\t{\n\t\t\tincircle[stack[i]] = circId;\n\t\t\tif(stack[i] == x)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn true;\n\t}\n\tstack.push_back(x);\n\tif(vis[x]) return false;\n\tvis[x] = circId;\n\tbool ret = find(fa[x]);\n\tstack.pop_back();\n\treturn ret;\t\n}\n\nvector<int> S;\n\nlong long f[Maxn][2];\n\nlong long pre[Maxn];\n\nvoid dfs(int x)\n{\n\tf[x][0] = f[x][1] = 1;\n\tfor(int i = 0; i < nxt[x].size(); ++i)\n\t{\n\t\tint y = nxt[x][i];\n\t\tdfs(y);\n\t\tf[x][0] = f[x][0] * f[y][0] % Mod;\n\t}\n\tf[x][1] = f[x][0];\n\tlong long suf = 1;\n\tfor(int i = 0; i < nxt[x].size(); ++i)\n\t{\n\t\tint y = nxt[x][i];\n\t\tif(i == 0)\n\t\t\tpre[i] = f[y][0];\n\t\telse\n\t\t\tpre[i] = pre[i - 1] * f[y][0] % Mod;\n\t}\n\tfor(int i = (int)nxt[x].size() - 1; i >= 0; --i)\n\t{\n\t\tint y = nxt[x][i];\n\t\tif(i)\n\t\t\tf[x][1] = (f[x][1] + f[y][1] * suf % Mod * pre[i - 1] % Mod) % Mod;\n\t\telse\n\t\t\tf[x][1] = (f[x][1] + f[y][1] * suf % Mod) % Mod;\n\t\tsuf = suf * (f[y][0] + f[y][1]) % Mod;\n\t}\n}\n\nint n, m;\n\nint main()\n{\n\twhile(scanf(\"%d%d\", &n, &m) == 2)\n\t{\n\t\tfor(int i = 0; i <= n; ++i)\n\t\t\tfa[i] = -1, nxt[i].clear(), incircle[i] = 0, vis[i] = false;\n\t\tfor(int j = 0; j < m; ++j)\n\t\t{\n\t\t\tint s, d;\n\t\t\tscanf(\"%d%d\", &s, &d);\n\t\t\tif(s == d) continue;\n\t\t\tfa[s] = d;\n\t\t}\n\t\tcircId = n + 1;\n\t\tfor(int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tif(!vis[i])\n\t\t\t{\n\t\t\t\tcircId += find(i);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tint f = fa[i];\n\t\t\tif(f == -1) continue;\n\t\t\tif(incircle[i] && incircle[f]) continue;\n\t\t\tif(incircle[f])\n\t\t\t\tnxt[incircle[f]].push_back(i);\n\t\t\telse\n\t\t\t\tnxt[f].push_back(i);\n\t\t}\n\t\tfor(int i = 1; i <= n; ++i)\n\t\t\tif(incircle[i])\n\t\t\t\tS.push_back(incircle[i]);\n\t\t\telse\n\t\t\t\tS.push_back(i);\n\t\tsort(S.begin(), S.end());\n\t\tS.resize(unique(S.begin(), S.end()) - S.begin());\n\t\tstatic int deg[Maxn];\n\t\tfor(int i = 0; i < S.size(); ++i)\n\t\t\tdeg[S[i]] = 0;\n\t\tfor(int i = 0; i < S.size(); ++i)\n\t\t{\n\t\t\tint x = S[i];\n\t\t\tfor(int j = 0; j < nxt[x].size(); ++j)\n\t\t\t\tdeg[nxt[x][j]]++;\n\t\t}\n\t\tlong long ans = 1;\n\t\tfor(int i = 0; i < S.size(); ++i)\n\t\t{\n\t\t\tif(deg[S[i]] == 0)\n\t\t\t{\n\t\t\t\tdfs(S[i]);\n\t\t\t\tans = ans * (f[S[i]][0] + f[S[i]][1]) % Mod;\n\t\t\t}\n\t\t\tans %= Mod;\n\t\t}\n\t\tprintf(\"%d\\n\", (int)ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 10001\n#define f first\n#define s second\n#define mp make_pair\n#define mod 1000000007\n#define inf 1e8\nusing namespace std;\n\ntypedef long long ll;\n\nint V,m;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nvector<pair<int,int> > vpp;\nbool used[MAX_V]={};\nint cmp[MAX_V];\nll dp[MAX_V];\nvector<int> e[MAX_V];\n \nvoid add_edge(int from, int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n \nvoid dfs(int v){\n  used[v] = true;\n  for(int i = 0;i < G[v].size();i++){\n    if(!used[G[v][i]])dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\n \nvoid rdfs(int v,int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i = 0;i < rG[v].size();i++){\n    if(!used[rG[v][i]]) rdfs(rG[v][i],k);\n  }\n}\n \nvoid scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v = 0;v < V;v++){\n    if(!used[v]) dfs(v);\n  }\n  memset(used,0,sizeof(used));\n  int k = 0;\n  for(int i = vs.size() - 1;i >= 0;i--){\n    if(!used[vs[i]])rdfs(vs[i],k++);\n  }\n  return;\n}\n\nll rec(int v,int cm){\n  ll res=1;\n  int tmp=cmp[v];\n  if(tmp==cm)return 1;\n  if(dp[tmp]!=inf)return dp[tmp];\n  //  if(rG[v].size()==0)return dp[tmp]=2;\n\n  for(int i=0;i<e[tmp].size();i++){\n    int now=e[tmp][i];\n    for(int j=0;j<rG[now].size();j++){\n      int next=rG[now][j];\n      res*=rec(next,tmp);\n      res%=mod;\n    }\n  }\n  return dp[tmp]=res+1;\n}\n\nint main()\n{\n  int a,b,q;\n\n  cin>>V>>m;\n  for(int i=0;i<m;i++){\n    cin>>a>>b;\n    a--;b--;\n    add_edge(a,b);\n  }\n \n  scc();\n\n  for(int i=0;i<V;i++){\n    vpp.push_back(mp((-1)*cmp[i],i));\n  }\n  sort(vpp.begin(),vpp.end());\n\n  for(int i=0;i<V;i++)vpp[i].f=(-1)*vpp[i].f;\n\n  for(int i=0;i<vpp.size();i++)e[vpp[i].f].push_back(vpp[i].s);\n\n  for(int i=0;i<V;i++)dp[i]=inf;\n  ll ans=1;\n  for(int i=0;i<vpp.size();i++){\n    if(dp[vpp[i].f]==inf){\n      ans*=rec(vpp[i].s,inf);\n      ans%=mod;\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 1005\n#define M 1000000007\nusing namespace std;\ntypedef long long ll;\n\nint V; //????????°\nvector<int> G[MAX_V]; //??°???????????£??\\??????????????¨???\nvector<int> rG[MAX_V];//?????????????????????????????°??????\nvector<int> vs;       //??°?????????????????????\nbool used[MAX_V];     //?????§???????????????\nint cmp[MAX_V];       //?±????????????£?????????????????????????????????\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  \n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\nll ans[MAX_V];\n\nvoid dfs2(int x){\n  if(used[x])return;\n  used[x]=true;\n  for(int i=0;i<G[x].size();i++){\n    int nx=G[x][i];\n    if(cmp[x]!=cmp[nx])ans[cmp[nx]]*=(ans[cmp[x]]+1)%M;\n    dfs2(nx);\n  }\n}\n\nint main(){\n  int n,m,s,d;\n  int start[MAX_V],goal[MAX_V];\n  cin>>n>>m;\n  V=n;\n  for(int i=0;i<n;i++)\n    ans[i]=start[i]=goal[i]=1;\n  for(int i=0;i<m;i++){\n    cin>>s>>d;\n    s--; d--;\n    add_edge(s,d);\n  }\n  int k=scc();\n  for(int i=0;i<n;i++)\n    for(int j=0;j<G[i].size();j++){\n      int x=G[i][j];\n      if(cmp[i]!=cmp[x])\n\tgoal[cmp[i]]=start[cmp[x]]=0;\n    }\n  for(int i=0;i<n;i++){\n    if(start[cmp[i]]){\n      memset(used,0,sizeof(used));\n      dfs2(i);\n    }\n    start[cmp[i]]=0;\n  }\n  ll cnt=1;\n  for(int i=0;i<k;i++)\n    if(goal[i])cnt*=(ans[i]+1)%M;\n  cout<<cnt<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MAX 1005\nll mod=1e9+7;\nint n,m,a,b;\nvector<int> G[MAX],g[MAX];\nint p[MAX],flg[MAX];\n \nint update(int x){\n  flg[x]=1;\n  if(p[x]==x)return x;\n  return p[x]=update(p[x]);\n}\n \nint find(int x){\n  if(p[x]==x)return x;\n  return find(p[x]);\n}\n \nll dfs(int pos){\n  ll res=1;\n  for(int i=0;i<(int)g[pos].size();i++)\n    res=res*dfs(g[pos][i])%mod;\n  return res+1;\n}\n \nint main(){\n  cin>>n>>m;\n  for(int i=1;i<=n;i++)p[i]=i;\n  for(int i=0;i<m;i++){\n    cin>>a>>b;\n    G[b].push_back(a);\n    if(find(b)==a)update(b);\n    else p[a]=b;\n  }\n  for(int i=1;i<=n;i++){\n    for(int j=0;j<(int)G[i].size();j++){\n      int w=G[i][j];\n      if(flg[w])continue;\n      if(flg[i])g[p[i]].push_back(w);\n      else g[i].push_back(w);\n    }\n  }\n  ll ans=1;\n  for(int i=1;i<=n;i++)if(p[i]==i)ans=ans*dfs(i)%mod;\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 2050\n#define int long long\nint MOD=1000000007;\nint V;\nvector<int> G[MAX_V],rG[MAX_V],nG[MAX_V],vs,kv[MAX_V];\nbool used[MAX_V];\nint cmp[MAX_V];\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\nvoid dfs(int v){\n  used[v]=1;\n  for(int i=0;i<(int)G[v].size();i++){\n    if(!used[G[v][i]]) dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\nvoid rdfs(int v,int k){\n  used[v]=1;\n  cmp[v]=k;\n  kv[k].push_back(v);\n  for(int i=0;i<(int)rG[v].size();i++){\n    if(!used[rG[v][i]]) rdfs(rG[v][i],k);\n  }\n}\nint dfs2(int v,int f){\n  int res=0,tmp=1;\n  if(!f){\n    for(int i=0;i<(int)nG[v].size();i++) tmp=(tmp*dfs2(nG[v][i],0))%MOD;\n    res=tmp;tmp=1;\n  }\n  for(int i=0;i<(int)nG[v].size();i++) tmp=(tmp*dfs2(nG[v][i],1))%MOD;\n  //cout<<v<<\":\"<<f<<\"/\"<<res+tmp<<endl;\n  return (res+tmp)%MOD;\n}\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++){\n    if(!used[v]) dfs(v);\n  }\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!used[vs[i]]) rdfs(vs[i],k++);\n  }\n  memset(used,0,sizeof(used));\n  int ans=1;\n  for(int i=0;i<k;i++){\n    for(int j=0;j<(int)kv[i].size();j++){\n      for(int l=0;l<(int)rG[kv[i][j]].size();l++){\n\tif(i!=cmp[rG[kv[i][j]][l]]){\n\t  nG[i].push_back(cmp[rG[kv[i][j]][l]]);\n\t  used[cmp[rG[kv[i][j]][l]]]=1;\n\t}\n      }\n    }\n  }\n  for(int i=0;i<V;i++){\n    if(used[cmp[i]]) continue;\n    //cout<<i<<endl;\n    used[cmp[i]]=1;\n    ans=(ans*dfs2(i,0))%MOD;\n  }\n  return ans;\n}\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  V=n;\n  for(int i=0;i<m;i++){\n    int s,d;\n    cin>>s>>d;\n    add_edge(s-1,d-1);\n  }\n  cout<<scc()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto (itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// sccdしてcmpから新しいグラフを作る\n// dp[i][j]: 頂点iを塗らない/塗る(j)場合の数\n// iの子kに対して dp[i][0] = dp[k][0]+dp[k][1], dp[i][1] = dp[k][1]\n// 辺の向きは逆にしたほうがたぶん楽\n// 塗らない->その子は完全に自由 塗る->その子も全部塗るしかない\n\n// initで頂点数を指定してsccで成分分解を実行 返り値は強連結成分の個数==grpのサイズ\n// grp[i]:i番目の強連結成分に含まれる頂点一覧\n// cmp[i]:頂点iが属する強連結成分の番号 この番号も⇡のiもトポロジカル順\nclass SCC {\n\tpublic:\n\tstatic const int MV = 1010;\n\tvector<vector<int> > grp; int NV,cmp[MV];\n\tvector<int> E[MV], RE[MV], NUM; int vis[MV];\n\tvoid init(int NV) { this->NV=NV; for(int i=0;i<MV;i++) { E[i].clear(); RE[i].clear();}}\n\tvoid add(int x,int y) { E[x].push_back(y); RE[y].push_back(x); }\n\tvoid dfs(int cu) { vis[cu]=1; for(int i=0;i<E[cu].size();i++) if(!vis[E[cu][i]]) dfs(E[cu][i]); NUM.push_back(cu); }\n\tvoid revdfs(int cu, int ind) {vis[cu]=1; cmp[cu]=ind; grp[ind].push_back(cu);\n\t\tfor(int i=0;i<RE[cu].size();++i) if(!vis[RE[cu][i]]) revdfs(RE[cu][i],ind);}\n\tint scc() {\n\t\tint c=0; grp.clear(); grp.resize(MV); NUM.clear();\n\t\tmemset(vis,0,sizeof(vis)); for(int i=0;i<NV;i++) if(!vis[i]) dfs(i);\n\t\tmemset(vis,0,sizeof(vis)); for(int i=NUM.size()-1;i>=0;i--) if(!vis[NUM[i]])\n\t\t\t{ grp[c].clear(); revdfs(NUM[i],c); sort(grp[c].begin(),grp[c].end()); c++;}\n\t\tgrp.resize(c); return c;\n\t}\n};\n\nint n, m, a[1000], b[1000];\nbool us[1000];\nSCC scc;\nvi e[1000];\n\nll rec(int v) {\n\tus[v] = 1;\n\tll res = 1;\n\trep(i,e[v].size()) (res *= rec(e[v][i])) %= mod;\n\treturn res + 1;\n}\n\nsigned main() {\n\tcin >> n >> m;\n\tscc.init(n);\n\trep(i,m) {\n\t\tcin >> a[i] >> b[i];\n\t\ta[i]--, b[i]--;\n\t\tscc.add(a[i],b[i]);\n\t}\n\tint g = scc.scc();\n\trep(i,m) if (scc.cmp[b[i]]!=scc.cmp[a[i]]) e[scc.cmp[b[i]]].pb(scc.cmp[a[i]]);\n\tll res = 1;\n\trepr(i,g-1) if (!us[i]) (res *= rec(i)) %= mod;\n\tcout << res << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define YET 0\n#define HALFWAY 1\n#define DONE 2\n#define MOD 1000000007\n\ntypedef long long int LLI;\n\nint N;\nint M;\nint num_cycle;\nint state[1145];\nint dest[1145];\nvector<int> es[1145];\nvector<int> cycles[1145];\n\nLLI Pow(LLI base, LLI exp) {\n  if (exp == 0) return 1;\n\n  LLI res = Pow(base*base%MOD, exp/2);\n  if (exp%2 == 1) {\n    res = res*base%MOD;\n  }\n  return res;\n}\n\nLLI calc(int v, int prev) {\n  LLI ret = 1;\n  for (int u : es[v]) {\n    if (prev == u) continue;\n    ret = ret*calc(u, v)%MOD;\n  }\n  return (ret+1)%MOD;\n}\n\nbool dfs(int v, int u) {\n  if (state[v] == DONE) {\n    if (u != -1) es[v].emplace_back(u);\n    return false;\n  }\n\n  if (state[v] == HALFWAY) {\n    state[v] = DONE;\n    return true;\n  }\n\n  if (dest[v] == -1) {\n    state[v] = DONE;\n    if (u != -1) es[v].emplace_back(u);\n    cycles[num_cycle].emplace_back(v);\n    num_cycle++;\n    return false;\n  }\n\n  state[v] = HALFWAY;\n  bool ret = dfs(dest[v], v);\n  if (ret) {\n    auto &cycle = cycles[num_cycle];\n    cycle.emplace_back(v);\n    if (state[v] == DONE) {\n      reverse(cycle.begin(), cycle.end());\n      if (u != -1) es[v].emplace_back(u);\n      num_cycle++;\n      return false;\n    }\n  } else {\n    if (u != -1) es[v].emplace_back(u);\n  }\n  state[v] = DONE;\n  return ret;\n}\n\nint main() {\n  scanf(\"%d%d\", &N, &M);\n  fill(dest, dest+N, -1);\n  for (int i=0; i<M; i++) {\n    int s, t;\n    scanf(\"%d%d\", &s, &t);\n    --s;\n    --t;\n    dest[s] = t;\n  }\n\n  for (int i=0; i<N; i++) {\n    if (state[i] != DONE) dfs(i, -1);\n  }\n\n  LLI ans = 1;\n  for (int i=0; i<num_cycle; i++) {\n    LLI t = 1;\n    //printf(\"cycles[%d]: \", i);\n    for (int root : cycles[i]) {\n      //printf(\"%d \", root);\n      t = t*((MOD+calc(root, root)-1)%MOD)%MOD;\n    }\n    //puts(\"\");\n    t = (t+1)%MOD;\n    //printf(\"t: %lld\\n\", t);\n    ans = ans*t%MOD;\n  }\n  printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst ld eps = 1e-9;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n};\ntemplate<typename T>\nusing Graph = vector<vector<edge<T>>>;\ntemplate<typename T>\nstruct SCC {\n    int sz, cnt, num;\n    vi post, comp;\n    vector<pair<int, int>> vp;\n    vector<bool> sel;\n    Graph<T> revg;\n    SCC(int sz): sz(sz) {\n        cnt = 0;\n        num = 0;\n        post.resize(sz, -1);\n        comp.resize(sz, -1);\n        sel.resize(sz, false);\n        revg.resize(sz);\n    }\n    void build(const Graph<T> &g) {\n        for(int i=0;i<sz;++i) {\n            if(sel[i]) continue;\n            sel[i] = true;\n            dfs1(g, i);\n        }\n        rev(g, revg);\n        for(int i=0;i<sz;++i) {\n            vp.emplace_back(make_pair(post[i], i));\n        }\n        sort(vp.begin(), vp.end());\n        reverse(vp.begin(), vp.end());\n        sel.clear();\n        sel.resize(sz, false);\n        for(int i=0;i<sz;++i) {\n            if(sel[vp[i].second]) continue;\n            sel[vp[i].second] = true;\n            comp[vp[i].second] = num;\n            dfs2(revg, vp[i].second);\n            num++;\n        }\n    }\n    vi get_comp() {return comp;}\n    Graph<T> build_graph(const Graph<T> &g) {\n        build(g);\n        vector<set<int>> s(sz);\n        Graph<T> res(num);\n        for(int i=0;i<sz;++i) {\n            for(int j=0;j<(int)(g[i].size());++j) {\n                s[comp[i]].insert(comp[g[i][j].to]);\n            }\n        }\n        for(int i=0;i<sz;++i) {\n            for(auto j: s[i]) {\n                if(i != j) res[i].push_back(edge<int>({i, j, 1}));\n            }\n        }\n        return res;\n    }\n    void dfs1(const Graph<T> &g, int now) {\n        for(int i=0;i<(int)(g[now].size());++i) {\n            int nxt = g[now][i].to;\n            if(sel[nxt]) continue;\n            sel[nxt] = true;\n            dfs1(g, nxt);\n        }\n        post[now] = cnt;\n        cnt++;\n    }\n    void rev(const Graph<T> &g, Graph<T> &revg) {\n        for(int i=0;i<sz;++i) {\n            for(int j=0;j<(int)(g[i].size());++j) {\n                revg[g[i][j].to].push_back({\n                        g[i][j].to, g[i][j].src, g[i][j].cost});\n            }\n        }\n    }\n    void dfs2(const Graph<T> &revg, int now) {\n        for(int i=0;i<(int)(revg[now].size());++i) {\n            int nxt = revg[now][i].to;\n            if(sel[nxt]) continue;\n            sel[nxt] = true;\n            comp[nxt] = num;\n            dfs2(revg, nxt);\n        }\n    }\n};\nvoid topological_sort(const vector<vector<int>>& G, vi& ord)\n{\n    int n = G.size();\n    vector<int> num(n, 0);\n    ord.resize(n, 0);\n    for (int i = 0; i < n; ++i) {\n        for (auto u : G[i]) {\n            ++num[u];\n        }\n    }\n    stack<int> st;\n    for(int i = 0; i < n; ++i) {\n        if (num[i] == 0) {\n            st.push(i);\n        }\n    }\n    for (int k = 0; !st.empty(); ++k) {\n        int i = st.top(); st.pop();\n        ord[k] = i;\n        for (auto u : G[i]) {\n            if (--num[u] == 0) {\n                st.push(u);\n            }\n        }\n    }\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  int n, m; cin >> n >> m;\n  vi s(m), d(m);\n  for(int i=0;i<m;++i) {\n    cin >> s[i] >> d[i];\n    s[i]--;\n    d[i]--;\n  }\n  Graph<int> g(n);\n  for(int i=0;i<m;++i) {\n    g[s[i]].push_back({s[i], d[i], 1});\n  }\n  SCC<int> scc(n);\n  auto g2 = scc.build_graph(g);\n  vvi g3(scc.num);\n  for(int i=0;i<scc.num;++i) {\n    for(int j=0;j<(int)(g2[i].size());++j) {\n      g3[i].push_back(g2[i][j].to);\n    }\n  }\n  vi ord;\n  topological_sort(g3, ord);\n  int sz = (int)(ord.size());\n  vvll dp(n, vll(2, 1));\n  ll ans = 1;\n  for(int i=0;i<sz;++i) {\n    int now = ord[i];\n    if((int)(g3[now].size()) == 0) {\n      ans *= (dp[now][0] + dp[now][1]) % MOD;\n      ans %= MOD;\n      continue;\n    }\n    int nxt = g3[now][0];\n    dp[nxt][0] *= dp[now][0];\n    dp[nxt][0] %= MOD;\n    dp[nxt][1] *= (dp[now][0] + dp[now][1]) % MOD;\n    dp[nxt][1] %= MOD;\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\ntypedef int Weight;\nstruct Edge {\n  int src;\n  int dest;\n  Weight weight;\n  Edge(int src, int dest, Weight weight) : src(src), dest(dest), weight(weight) {;}\n  bool operator<(const Edge &rhs) const {\n    if (weight != rhs.weight) { return weight > rhs.weight; }\n    if (src != rhs.src) { return src < rhs.src; }\n    return dest < rhs.dest;\n  }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid printMatrix(const Matrix &matrix) {\n  for (int y = 0; y < (int)matrix.size(); y++) {\n    for (int x = 0; x < (int)matrix[y].size(); x++) {\n      printf(\"%d \", matrix[y][x]);\n    }\n    puts(\"\");\n  }\n}\n\nvoid SccDfs(const Graph &g, int from, vector<int> &visit, vector<int> &st) {\n  visit[from] = 1;\n  for (Edges::const_iterator it = g[from].begin(); it != g[from].end(); it++) {\n    if (visit[it->dest]) { continue; }\n    SccDfs(g, it->dest, visit, st);\n  }\n  st.push_back(from);\n}\n\nvector<vector<int> > Scc(const Graph &g) {\n  const int n = g.size();\n  vector<vector<int> > ret;\n  Graph revg(n);\n  for (int i = 0; i < n; i++) {\n    for (Edges::const_iterator it = g[i].begin(); it != g[i].end(); it++) {\n      revg[it->dest].push_back(Edge(it->dest, i, it->weight));\n    }\n  }\n  vector<int> st;\n  vector<int> visit(n, 0);\n  for (int i = 0; i < n; i++) {\n    if (visit[i]) { continue; }\n    SccDfs(g, i, visit, st);\n  }\n  visit = vector<int>(n, 0);\n  for (int i = n - 1; i >= 0; i--) {\n    int index = st[i];\n    if (visit[index]) { continue; }\n    vector<int> nret;\n    SccDfs(revg, index, visit, nret);\n    ret.push_back(nret);\n  }\n  return ret;\n}\n\n// select min weight edge\nGraph SccGraph(const Graph &g) {\n  vector<vector<int> > soc = Scc(g);\n  const int n = g.size();\n  const int m = soc.size();\n  vector<int> mapto(n);\n  for (int i = 0; i < (int)soc.size(); i++) {\n    for (int j = 0; j < (int)soc[i].size(); j++) {\n      mapto[soc[i][j]] = i;\n    }\n  }\n  Graph ret(m);\n  vector<int> indexs(m, -1);\n  for (int from = 0; from < m; from++) {\n    int e = 0;\n    for (int i = 0; i < (int)soc[from].size(); i++) {\n      for (Edges::const_iterator it = g[soc[from][i]].begin(); it != g[soc[from][i]].end(); it++) {\n        int to = mapto[it->dest];\n        if (from == to) { continue; } // loop back\n        if (indexs[to] == -1) {\n          ret[from].push_back(Edge(from, to, it->weight));\n          indexs[to] = e++;\n        } else {\n          // select edge\n          ret[from][indexs[to]].weight = min(ret[from][indexs[to]].weight, it->weight);\n        }\n      }\n    }\n    for (Edges::const_iterator it = ret[from].begin(); it != ret[from].end(); it++) {\n      indexs[it->dest] = -1;\n    }\n  }\n  return ret;\n}\n\nconst ll MOD = 1000000007;\nbool visit[1010];\n\nll dfs(const Graph &g, int from) {\n  ll ret = 1;\n  visit[from] = true;\n  FORIT(it, g[from]) {\n    assert(!visit[it->dest]);\n    ret = (ret * dfs(g, it->dest)) % MOD;\n  }\n  ret++;\n  return ret;\n}\n\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  Graph g(n);\n  REP(i, m) {\n    int f, t;\n    scanf(\"%d %d\", &f, &t);\n    f--; t--;\n    g[t].push_back(Edge(t, f, 0));\n  }\n  g = SccGraph(g);\n  MEMSET(visit, false);\n  ll ans = 1;\n  REP(i, g.size()) {\n    if (visit[i]) { continue; }\n    ans = (ans * dfs(g, i)) % MOD;\n  }\n  printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 100000\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\n\n\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\n\nvoid add_edge(int from, int to)\n{\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v)\n{\n  used[v] = 1;\n  for (int i = 0; i < (int)G[v].size(); i++) {\n    if (!used[G[v][i]]) dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v, int k)\n{\n  used[v] = 1;\n  cmp[v] = k;\n  for (int i = 0; i < (int)rG[v].size(); i++) {\n    if (!used[rG[v][i]]) rdfs(rG[v][i], k);\n  }\n}\n\nint scc()\n{\n  memset(used, 0, sizeof(used));\n  vs.clear();\n  for (int v = 0; v < V; v++) {\n    if (!used[v]) dfs(v);\n  }\n  \n  memset(used, 0, sizeof(used));\n  int k = 0;\n  for (int i = vs.size() - 1; i >= 0; i--) {\n    if (!used[vs[i]]) rdfs(vs[i], k++);\n  }\n  return k;\n}\n\ntypedef long long ll;\n\nll dp[1010];\nvector<int> g[1010];\nset<int> vis;\nconst int MOD = 1000000007;\n\n\nll sdfs(int curr, int par) {\n  ll& ret = dp[curr];\n  vis.insert(curr);\n  if(ret + 1) return ret;\n  ret = 1;\n  for(auto && e: g[curr]) {\n    if(e == par) continue;\n    ret *= sdfs(e, curr);\n    ret %= MOD;\n  }\n  return (ret + 1) % MOD;\n}\n\nint main()\n{\n  int M, a, b;\n  cin >> V >> M;\n  \n  for (int i = 0; i < M; i++) {\n    cin >> a >> b; a--; b--;\n    add_edge(a, b);\n  }\n\n  \n  int K = scc();\n  \n  int deg[1010] = {};\n  \n  rep(i, V) for(auto& e: G[i]) {\n    if(cmp[i] != cmp[e]) {\n      g[cmp[e]].push_back(cmp[i]);\n      deg[cmp[i]] ++;\n    }\n  }\n  \n  rep(i, K) {\n    sort(g[i].begin(), g[i].end());\n    g[i].erase(unique(g[i].begin(), g[i].end()), g[i].end());\n  }\n  \n  rep(i, 1010) dp[i] = -1;\n  \n  ll ans = 1;\n  \n  rep(i, K) {\n    if(deg[i] == 0) {\n      ans *= sdfs(i, -1);\n      ans %= MOD;\n    }\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nclass UnionFind {\n    vector<int> par, h;\npublic:\n    UnionFind(int size) {\n        par.assign(size, 0);\n        h.assign(size, 0);\n        REP(i, size) par[i] = i;\n    }\n    void unite(int u, int v) {\n        u = root(u), v = root(v);\n        if (u == v) return;\n        if (h[u] > h[v]) {\n            par[v] = u;\n        }\n        else if (h[u] < h[v]) {\n            par[u] = v;\n        }\n        else {\n            ++h[u];\n            par[v] = u;\n        }\n    }\n    bool isUnited(int u, int v) {\n        return root(u) == root(v);\n    }\n    int root(int v) {\n        if (par[v] == v) return v;\n        return par[v] = root(par[v]);\n    }\n};\nvoid scc_dfs(ll v, vector<bool>& used, vector<ll>& vs, const vector< vector<ll> >& G) {\n    used[v] = true;\n    each(to, G[v]) {\n        if (!used[to]) scc_dfs(to, used, vs, G);\n    }\n    vs.pb(v);\n}\nvoid scc_rdfs(ll v, ll k, vector<bool>& used, vector<ll>& cmp, const vector< vector<ll> >& rG) {\n    used[v] = true;\n    cmp[v] = k;\n    each(to, rG[v]) {\n        if (!used[to]) scc_rdfs(to, k, used, cmp, rG);\n    }\n}\n// cmpが返る\n// 同じcmpは強連結成分\n// cmp[i] < cmp[j] なら j から i に行けない\nvector<ll> scc(const vector< vector<ll> >& G) {\n    const ll n = G.size();\n    vector<bool> used(n, false);\n    vector<ll> vs;\n    rep(i, n) {\n        if (!used[i]) scc_dfs(i, used, vs, G);\n    }\n    used.assign(n, false);\n    vector< vector<ll> > rG(n);\n    rep(i, n) {\n        each(to, G[i]) {\n            rG[to].pb(i);\n        }\n    }\n    vector<ll> res(n);\n    ll k = 0;\n    rrep(i, vs.size()) {\n        if (!used[vs[i]]) scc_rdfs(vs[i], k++, used, res, rG);\n    }\n    return res;\n}\nvector< vector<ll> > get_scc_graph(const vector<ll>& cmp, const vector< vector<ll> >& G) {\n    vector< vector<ll> > res(*max_element(all(cmp))+1);\n    rep(i, G.size()) {\n        each(to, G[i]) {\n            if (cmp[i] != cmp[to]) {\n                res[cmp[i]].pb(cmp[to]);\n            }\n        }\n    }\n    rep(i, res.size()) {\n        sort(all(res[i]));\n        res[i].erase(unique(all(res[i])), res[i].end());\n    }\n    return res;\n}\nconst ll mod = 1000000007;\nll mul(ll a, ll b) {\n    return a * b % mod;\n}\nll mul(initializer_list<ll> t) {\n    ll res = 1;\n    each(v, t) res = mul(res, v);\n    return res;\n}\nll add(ll a, ll b) {\n    return (a + b) % mod;\n}\nll add(initializer_list<ll> t) {\n    ll res = 0;\n    each(v, t) res = add(res, v);\n    return res;\n}\nll sub(ll a, ll b) {\n    return (a - b + mod) % mod;\n}\nll sub(initializer_list<ll> t) {\n    auto it = t.begin();\n    ll res = *(it++);\n    while (it != t.end()) {\n        res = sub(res, *(it++));\n    }\n    return res;\n}\nll power(ll x, ll n) {\n    ll res = 1;\n    for (ll i = 1; i <= n; i <<= 1) {\n        if (i & n) res = mul(res, x);\n        x = mul(x, x);\n    }\n    return res;\n}\nll inv(ll n) {\n    return power(n, mod-2);\n}\nll divi(ll a, ll b) {\n    return mul(a, inv(b));\n}\nll divi(initializer_list<ll> t) {\n    auto it = t.begin();\n    ll res = *(it++);\n    while (it != t.end()) {\n        res = divi(res, *(it++));\n    }\n    return res;\n}\nvector<ll> fact;\nvoid init_fact(ll n) {\n    fact.assign(n+1, 1);\n    FOR(i, 1, fact.size()) {\n        fact[i] = mul(fact[i-1], i);\n    }\n}\n\nll comb(ll n, ll r) {\n    if (r < 0) return 0;\n    if (r > n) return 0;\n    return divi(fact[n], mul(fact[r], fact[n-r]));\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n, m; cin >> n >> m;\n    vector<vector<ll>> G(n);\n    rep(i, m) {\n        ll a, b; cin >> a >> b; --a, --b;\n        G[a].pb(b);\n    }\n    vector<ll> cmp = scc(G);\n    G = get_scc_graph(cmp, G);\n    n = G.size();\n    vector<vector<ll>> rG(n);\n    rep(from, n) each(to, G[from]) {\n        rG[to].pb(from);\n    }\n    function<ll(ll)> dfs = [&](ll v) {\n        // True\n        ll res = 1;\n        each(from, rG[v]) {\n            res = mul(res, dfs(from));\n        }\n        // All False\n        res = add(res, 1);\n        return res;\n    };\n    ll ans = 1;\n    rep(i, n) if (G[i].size() == 0) {\n        ll ptn = 1;\n        each(j, rG[i]) {\n            ptn = mul(ptn, dfs(j));\n        }\n        ptn = add(ptn, 1);\n        ans = mul(ans, ptn);\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define N 10001\nusing namespace std;\ntypedef long long ll;\nint n,m,cmp[N],used[N];\nvector <int> G[N],rG[N],vs;\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int pos){\n  used[pos]=1;\n  for(int i=0;i<G[pos].size();i++)\n    if(!used[G[pos][i]])dfs(G[pos][i]);\n  vs.push_back(pos);\n}\n\nvoid rdfs(int pos,int k){\n  used[pos]=1;\n  cmp[pos]=k;\n  for(int i=0;i<rG[pos].size();i++)if(!used[rG[pos][i]])rdfs(rG[pos][i],k);\n}\n\nint ssc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int i=0;i<n;i++) if(!used[i])dfs(i);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nll calc(int pos){\n  if(used[pos]) return 1;\n  used[pos]=1;\n  ll res=1;\n  for(int i=0;i<rG[pos].size();i++)res=res*calc(rG[pos][i])%mod;\n  return (res+1)%mod;\n}\n\n\nvoid mk_G(){\n  int k=ssc();\n  vector <int> tmp[N],rtmp[N];\n  for(int i=0;i<n;i++){\n    for(int j=0;j<G[i].size();j++)\n      if(cmp[i]!=cmp[G[i][j]]) tmp[cmp[i]].push_back(cmp[G[i][j]]);\n    for(int j=0;j<rG[i].size();j++)\n      if(cmp[i]!=cmp[rG[i][j]]) rtmp[cmp[i]].push_back(cmp[rG[i][j]]);\n    G[i].clear();\n    rG[i].clear();\n  }\n  n=k;\n  for(int i=0;i<k;i++) G[i]=tmp[i],rG[i]=rtmp[i];\n}\n\n\nint main(){\n  cin>>n>>m;\n  for(int i=0,a,b;i<m;i++)cin>>a>>b,add_edge(a-1,b-1);\n  mk_G();\n  ll ans=1;\n  memset(used,0,sizeof(used));\n  for(int i=0;i<n;i++) if(!G[i].size())ans=ans*calc(i)%mod;\n  cout <<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lli;\n\nconst lli MAX_V = 1000;\nconst lli M = 1000000007;\n\nlli V, E;\nvector<lli> G[MAX_V];\nvector<lli> rG[MAX_V];\nvector<lli> vs;\nbool used[MAX_V];\nlli cmp[MAX_V];\n\nvoid add_edge(lli from, lli to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(lli v){\n  used[v] = true;\n  for(lli i=0;i<G[v].size();i++){\n    if(!used[G[v][i]]) dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(lli v, lli k){\n  used[v] = true;\n  cmp[v] = k;\n  for(lli i=0;i<rG[v].size();i++){\n    if(!used[rG[v][i]]) rdfs(rG[v][i], k);\n  }\n}\n\nlli scc(){\n  fill(used, used+V, false);\n  vs.clear();\n  for(lli v = 0;v<V;v++){\n    if(!used[v]) dfs(v);\n  }\n  fill(used, used+V, false);\n  lli k = 0;\n  for(lli i=vs.size()-1;i>=0;i--){\n    if(!used[vs[i]]) rdfs(vs[i], k++);\n  }\n  return k;\n}\n\nlli V2;\nvector<lli> G2[MAX_V];\nlli dp[MAX_V];\n\nvoid make_graph(lli v){\n  used[v] = true;\n  for(lli i=0;i<G[v].size();i++){\n    lli to = G[v][i];\n    if(cmp[v] != cmp[to]) G2[cmp[v]].push_back(cmp[to]);\n    if(!used[to]) make_graph(to);\n  }\n}\n\nlli rec(lli v){\n  used[v] = true;\n  lli res = 1;\n  for(lli i=0;i<G2[v].size();i++){\n    lli to = G2[v][i];\n    if(!used[to]){\n      if(dp[to] != -1) res = (res * dp[to]) % M;\n      else res = (res * rec(to)) % M;\n    }\n  }\n  res = (res + 1) % M;\n  dp[v] = res;\n  return res;\n}\n\nmain(){\n  cin >> V >> E;\n  for(lli i=0;i<E;i++){\n    lli a, b;\n    cin >> a >> b;\n    add_edge(b-1, a-1);\n  }\n  V2 = scc();\n  for(lli i=0;i<V;i++) rG[i].clear();\n  fill(used, used+V, false);\n  for(lli i=0;i<V;i++) make_graph(i);\n  fill(used, used+V, false);\n  fill(dp, dp+V2, -1);\n  lli ans = 1;\n  for(lli i=0;i<V2;i++){\n    if(!used[i]) ans = (ans * rec(i)) % M;\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<deque>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<queue>\n#include<cassert>\n#include<climits>\n\n#define MOD (1000000007)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 2000\n\nusing namespace std;\n\ntypedef long long ull;\ntypedef pair<int,int> ii;\n\nstruct Data{\n  int  to,cost;\n  Data(int to=IINF,int cost=IINF):to(to),cost(cost){}\n};\n\n// Library - topological sort - begin \n\ntemplate<typename T>\nbool visit(const T& G,int v,vector<int>& order,vector<int>& color)\n{\n  color[v] = 1;\n  for(__typeof((G[v]).begin()) e = G[v].begin();e != G[v].end();e++)\n    {\n      if(color[e->to] == 2)continue;//このvisit以外のvisitで訪れた\n      if(color[e->to] == 1)return false;//このvisitで訪れた\n      if(!visit(G,e->to,order,color))return false;\n    }\n  order.push_back(v);\n  color[v] = 2;\n  return true;\n}\n\ntemplate<typename T>\nbool topologicalSort(const T& G,vector<int>& order)\n{\n  int SizeG = G.size();\n  vector<int> color(SizeG); \n  for(int u=0;u<SizeG;u++)\n    if(!color[u] && !visit(G,u,order,color))\n      return false;\n  reverse(order.begin(),order.end());\n  return true;\n}\n\n// Library - topological sort - end\n\nint V,E,S,D;\nvector<vector<Data> > tmp_G,tmp_rG;\nvector<int>  G[MAX];\nvector<int> rG[MAX];\nvector<int> vs;\nbool used[MAX];\nint cmp[MAX];\null dp[MAX];\n\ninline void add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k = 0;\n  for(int i = vs.size()-1; i >= 0 ; i-- )if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nint main(){\n\n  cin >> V >> E;\n  rep(i,E){\n    cin >> S >> D;\n    assert(1 <= S && S <= V);\n    assert(1 <= D && D <= V);\n    add_edge(S-1,D-1);\n  }\n  int nV = scc();\n  rep(i,nV)dp[i] = -1;\n\n  set<int> OUT_counter[nV];\n  rep(i,V)rep(j,G[i].size()){\n    if(cmp[i] == cmp[G[i][j]])continue;\n    OUT_counter[cmp[i]].insert(cmp[G[i][j]]);\n  }\n\n  tmp_G.clear(),tmp_rG.clear();\n  tmp_G.resize(nV),tmp_rG.resize(nV);\n  rep(i,nV)for(int j : OUT_counter[i]){\n    tmp_G[i].push_back(j);\n    tmp_rG[j].push_back(i);\n  }\n\n  vector<int> order;\n  topologicalSort(tmp_G,order);\n\n  rep(i,nV)if(tmp_rG[order[i]].empty())dp[order[i]] = 2ULL;\n\n  ull ans = 1;\n  /*\n  cout << \"k = \" << nV << endl;\n  rep(i,V){\n    cout << \"node \" << i << \" is \" << cmp[i] << endl;\n  }\n  */\n\n  rep(i,nV){\n    int cur = order[i];\n    ull cost = 1;\n    rep(j,tmp_rG[cur].size()){\n      int prev = tmp_rG[cur][j].to;\n      assert(dp[prev] != -1);\n      cost = ( cost * dp[prev] ) % MOD;\n    }\n    if(!tmp_rG[cur].empty()){\n      assert(dp[cur] == -1);\n      dp[cur] = ( cost + 1ULL ) % MOD;\n    }\n    if(tmp_G[cur].empty()){\n      ans = ( ans * dp[cur] ) % MOD;\n      //cout << \"cur = \" << cur << \", cost = \" << dp[cur] << endl;\n      //cout << \"ans = \" << ans << endl;\n\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n\nconst long long mod=1000000007;\nint du[1010];\n\nstruct EE\n{\n    int to,ne;\n}e[10010];\nint L,head[1010];\nvoid adde(int u,int v)\n{\n    e[L].to=v;\n    e[L].ne=head[u];\n    head[u]=L++;\n}\nlong long dp[1010][2];\nbool vis[1010];\nlong long ans;\nbool dfs(int u,int fa,int root)\n{\n    bool fg=false;\n    dp[u][0]=dp[u][1]=1;\n    vis[u]=true;\n    for (int i=head[u];i!=-1;i=e[i].ne)\n    {\n        int v=e[i].to;\n        if (v==root) {\n            fg=true;\n            continue;\n        }\n        if (v==fa) continue;\n        if (!vis[v])\n        {\n            if (dfs(v,u,root))\n            {\n                dp[u][0]=dp[u][0]*dp[v][0]%mod;\n                dp[u][1]=dp[u][1]*dp[v][1]%mod;\n                fg=true;\n            }\n            else\n            {\n                dp[u][1]=dp[u][1]*(dp[v][0]+dp[v][1])%mod;\n                dp[u][0]=dp[u][0]*dp[v][0]%mod;\n            }\n        }\n        else\n        {\n            dp[u][1]=dp[u][1]*(dp[v][0]+dp[v][1])%mod;\n            dp[u][0]=dp[u][0]*dp[v][0]%mod;\n        }\n    }\n    if (u==root && du[u]==0) ans=ans*(dp[u][0]+dp[u][1])%mod;\n    if (fg && u==root) ans=ans*(dp[u][0]+dp[u][1])%mod;\n    return fg;\n}\nint main()\n{\n    int n,m;\n    while (scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n        L=0;\n        for (int i=1;i<=n;i++)\n        {\n            du[i]=0;\n            head[i]=-1;\n            vis[i]=false;\n        }\n        for (int i=1;i<=m;i++)\n        {\n            int u,v;\n            scanf(\"%d%d\",&u,&v);\n            adde(v,u);\n            du[u]++;\n        }\n        ans=1;\n        for (int i=1;i<=n;i++)\n        if (!vis[i])\n        {\n            dfs(i,-1,i);\n          //  cout<<ans<<endl;\n        }\n        for (int i=1;i<=5;i++)\n        {\n         //    cout<<i<<\" \"<<dp[i][0]<<' '<<dp[i][1]<<endl;\n        }\n        printf(\"%d\\n\",(int)ans);\n    }\n}\n/*\n5 5\n1 2\n2 3\n3 4\n4 2\n5 4\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define int long long\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n#define all(x) x.begin(), x.end()\nusing pii = pair<int, int>;\nusing ll = long long;\nconst int INF = 1e9;\n\ntemplate <typename T> struct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n\n    operator int() const { return to; }\n};\n\ntemplate <typename T> using Edges = vector<edge<T> >;\ntemplate <typename T> using WeightedGraph = vector<Edges<T> >;\nusing UnWeightedGraph = vector<vector<int> >;\n\ntemplate <typename G> struct StronglyConnectedComponents {\n    const G &g;\n    UnWeightedGraph gg, rg;\n    vector<int> comp, order, used;\n\n    StronglyConnectedComponents(G &g) : g(g), gg(g.size()), rg(g.size()), comp(g.size(), -1), used(g.size()) {\n        for (int i = 0; i < g.size(); i++) {\n            for (auto e : g[i]) {\n                gg[i].emplace_back((int)e);\n                rg[(int)e].emplace_back(i);\n            }\n        }\n    }\n\n    int operator[](int k) { return comp[k]; }\n\n    void dfs(int idx) {\n        if (used[idx]) return;\n        used[idx] = true;\n        for (int to : gg[idx]) dfs(to);\n        order.push_back(idx);\n    }\n\n    void rdfs(int idx, int cnt) {\n        if (comp[idx] != -1) return;\n        comp[idx] = cnt;\n        for (int to : rg[idx]) rdfs(to, cnt);\n    }\n\n    void build(UnWeightedGraph &t) {\n        for (int i = 0; i < gg.size(); i++) dfs(i);\n        reverse(begin(order), end(order));\n        int ptr = 0;\n        for (int i : order)\n            if (comp[i] == -1) rdfs(i, ptr), ptr++;\n\n        t.resize(ptr);\n        for (int i = 0; i < g.size(); i++) {\n            for (auto &to : g[i]) {\n                int x = comp[i], y = comp[to];\n                if (x == y) continue;\n                t[x].push_back(y);\n            }\n        }\n    }\n};\nconstexpr int MOD = 1e9 + 7;\nint dfs(int n, UnWeightedGraph &T) {\n    if (T[n].size() == 0) return 2;\n    int ret = 1;\n    for (auto nxt : T[n]) {\n        ret *= dfs(nxt, T);\n        ret %= MOD;\n    }\n    return (ret + 1) % MOD;\n}\nbool solve() {\n    int N, M;\n    cin >> N >> M;\n    if (N == 0) return false;\n    UnWeightedGraph G(N), T;\n    REP(i, M) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        G[v].push_back(u);\n    }\n\n    StronglyConnectedComponents<UnWeightedGraph> scc(G);\n    scc.build(T);\n    int K = T.size();\n    vector<int> deg(K);\n    int root = 0;\n    REP(i, K) {\n        for (auto nxt : T[i]) {\n            deg[nxt]++;\n        }\n    }\n    ll ans = 1;\n    vector<int> roots;\n    REP(i, K) {\n        if (deg[i] == 0) roots.push_back(i);\n    }\n    for (auto root : roots) {\n        ans *= dfs(root, T);\n        ans %= MOD;\n    }\n    cout << ans << endl;\n    return true;\n}\n\nsigned main() {\n    solve();\n    // while (solve())\n    //     ;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct Edge{int from, to; ll cost;};\n\nconst ll MOD = 1000000007;\nconst long double EPS = 10e-10;\nconst int MAX_V = 1000;\n\nvector<int> G[MAX_V], rG[MAX_V], vs;\nint component[MAX_V];\nbool used[MAX_V];\nll dp[MAX_V][2];\nint V,E;\n\nvoid add_edge(int s, int t){\n    G[s].push_back(t);\n    rG[t].push_back(s);\n}\n\nvoid dfs(int node){\n    used[node] = true;\n    for(int next: G[node]){\n        if(!used[next]) dfs(next);\n    }\n    vs.push_back(node);\n}\n\nvoid rdfs(int node, int k){\n    used[node] = true;\n    component[node] = k;\n    for(int next: rG[node]){\n        if(!used[next]) rdfs(next, k);\n    }\n}\n\nvoid scc(){\n    memset(used, false, sizeof(used));\n    rep(V){\n        if(!used[i]) dfs(i);\n    }\n    memset(used, false, sizeof(used));\n    int k = 0;\n    reverse(all(vs));\n    for(int i: vs){\n        if(!used[i]) rdfs(i, k++);\n    }\n}\n\nvector<int> topological_sort(int N){\n    vector<int> ret, indeg(N, 0);\n    vector<bool> used(N, false);\n    set<int> st;\n    rep(N) for(int to: G[i]) indeg[to]++;\n    rep(N) if(indeg[i] == 0) st.insert(i);\n\n    while(!st.empty()){\n        int node = *st.begin();\n        st.erase(node);\n        ret.push_back(node);\n        used[node] = true;\n        for(int next: G[node]){\n            indeg[next]--;\n            if(!used[next] && indeg[next] == 0) st.insert(next);\n        }\n    }\n\n    return ret;\n}\n\nvoid rec(int node, int color){\n    if(color == 0) dp[node][0] = 1;\n    if(dp[node][color] >= 0) return;\n\n    dp[node][1] = 1LL;\n    for(int next: rG[node]){\n        dp[node][1] *= (dp[next][0] + dp[next][1]);\n        dp[node][1] %= MOD;\n    }\n    return;\n}\n\nint main(){\n    std::ios::sync_with_stdio(0); cin.tie(0);\n\n    int s, d;\n    cin >> V >> E;\n    Pii edges[E];\n    rep(E){\n        cin >> s >> d;\n        s--; d--;\n        add_edge(s, d);\n        edges[i] = Pii(s, d);\n    }\n\n    scc();\n\n    rep(V){\n        G[i].clear();\n        rG[i].clear();\n    }\n    V = *max_element(component, component+V) + 1;\n    rep(E){\n        s = edges[i].first;\n        d = edges[i].second;\n        if(component[s] != component[d]){\n            add_edge(component[s], component[d]);\n        }\n    }\n\n    vector<int> sorted_v = topological_sort(V);\n    fill(dp[0], dp[2], 1LL);\n    for(int s: sorted_v){\n        rec(s, 0); rec(s, 1);\n    }\n    ll ans = 1LL;\n    for(int v: sorted_v){\n        if(!rG[v].size()) (ans *= ((dp[v][0]+dp[v][1]) % MOD)) %= MOD;\n    }\n\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 1000000007;\n\nint dp[1000][2];\nchar edge[1000][1000];\nbool visited[1000];\nbool visited2[1000];\nint n, m;\n\nvoid check(int p, bool f){\n  if(f){\n    visited2[p] = true;\n  }\n  visited[p] = true;\n  for(int i=0;i<n;i++){\n    if(i == p) continue;\n    if(edge[p][i]){\n      if(f && visited2[i]) continue;\n      if(!f && visited[i]){\n        edge[p][i] = 2;\n        f = true;\n        check(i, true);\n      }\n      if(f && !visited2[i]){\n        edge[p][i] = 2;\n        check(i, true);\n      }\n      if(!f && !visited[i]) check(i, false);\n    }\n  }\n}\n\nmain(){\n  while(cin >> n >> m && n){\n    fill(edge[0], edge[1000], 0);\n    for(int i=0;i<m;i++){\n      int a, b;\n      cin >> a >> b;\n      a--;\n      b--;\n      edge[a][b] = 1;\n    }\n    for(int i=0;i<n;i++){\n      fill(visited, visited+n, false);\n      check(i, false);\n    }\n    dp[0][0] = 1;\n    dp[0][1] = 1;\n    for(int i=1;i<n;i++){\n      if(edge[i-1][i] == 2){\n        dp[i][0] = dp[i-1][0];\n        dp[i][1] = dp[i-1][1];\n      }else if(edge[i-1][i] == 1){\n        dp[i][0] = dp[i-1][0];\n        dp[i][1] = (dp[i-1][0] + dp[i-1][1])%N;\n      }else if(edge[i][i-1] == 1){\n        dp[i][0] = (dp[i-1][0] + dp[i-1][1])%N;\n        dp[i][1] = dp[i-1][1];\n      }else{\n        dp[i][0] = (dp[i-1][0] + dp[i-1][1])%N;\n        dp[i][1] = (dp[i-1][0] + dp[i-1][1])%N;\n      }\n      //cout << dp[i][0] << ' ' << dp[i][1] << endl;\n    }\n    cout << (dp[n-1][0] + dp[n-1][1])%N << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\nusing Graph = vector<vector<int>>;\n\n// O(|V| + |E|)\nstruct SCC\n{\n    int V, K;\n    Graph G, rG;\n    vector<int> vs;\n    vector<bool> used;\n    vector<int> cmp;\n    SCC(int _V) : V(_V), G(_V), rG(_V), used(_V, false), cmp(_V) {}\n    void add_edge(int from, int to)\n    {\n        G[from].push_back(to);\n        rG[to].push_back(from);\n    }\n    void dfs(int cur)\n    {\n        used[cur] = true;\n        for (const auto &v : G[cur])\n        {\n            if (!used[v])\n                dfs(v);\n        }\n        vs.push_back(cur);\n    }\n    void rdfs(int cur, int k)\n    {\n        used[cur] = true;\n        cmp[cur] = k;\n        for (const auto &v : rG[cur])\n        {\n            if (!used[v])\n                rdfs(v, k);\n        }\n    }\n    vector<int> scc()\n    {\n        for (int i = 0; i < V; i++)\n            used[i] = false;\n        vs.clear();\n        for (int v = 0; v < V; v++)\n        {\n            if (!used[v])\n                dfs(v);\n        }\n        for (int i = 0; i < V; i++)\n            used[i] = false;\n        int k = 0;\n        for (int i = (int)vs.size() - 1; i >= 0; i--)\n        {\n            if (!used[vs[i]])\n                rdfs(vs[i], k++);\n        }\n        K = k;\n        return cmp;\n    }\n    Graph buildGraph()\n    {\n        scc();\n        vector<set<int>> s(K);\n        Graph ret(K);\n        for (int v = 0; v < V; v++)\n        {\n            for (const auto to : G[v])\n            {\n                s[cmp[v]].insert(cmp[to]);\n            }\n        }\n        for (int i = 0; i < K; i++)\n        {\n            for (auto j : s[i])\n            {\n                if (i != j)\n                    ret[i].push_back(j);\n            }\n        }\n        return ret;\n    }\n};\n\nint N, M;\n\nll dfs(const Graph &g, int cur)\n{\n    ll res = 1;\n    for (const auto &v : g[cur])\n    {\n        res *= (dfs(g, v) + 1);\n        res %= MOD;\n    }\n    return res;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> N >> M;\n    SCC scc(N);\n    for (int i = 0; i < M; i++)\n    {\n        int s, d;\n        cin >> s >> d;\n        s--;\n        d--;\n        scc.add_edge(d, s);\n    }\n    Graph g = scc.buildGraph();\n    ll res = 1;\n    int K = g.size();\n    vector<int> in(K, 0);\n    for (int i = 0; i < K; i++)\n    {\n        for (const auto &v : g[i])\n        {\n            in[v]++;\n        }\n    }\n    for (int i = 0; i < K; i++)\n    {\n        if (in[i])\n            continue;\n        res *= (dfs(g, i) + 1LL);\n        res %= MOD;\n    }\n    cout << res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define int long long\n#define MOD 1000000007\nusing namespace std;\n\nvector<int> G[1000];\nbool cflag[1000];\nint mark[1000];\n\nint dfs(int v){\n\tint res = 1;\n\tmark[v] = 0;\n\tfor(int to : G[v]) res = res * dfs(to) % MOD;\n\treturn (res + 1) % MOD;\n}\n\nbool cyc(int v,int par){\n\tmark[v] = par;\n\tfor(int to : G[v]){\n\t\tif(mark[to] == par) return cflag[v] = true;\n\t\telse if(mark[to] != -1) continue;\n\t\tif(cyc(to,par)) return cflag[v] = true;\n\t}\n\treturn false;\n}\n\nsigned main(){\n\tint n,m,ans = 1;\n\tbool in[1000] = {};\n\tcin >> n >> m;\n\tfor(int i = 0;i < n;i++) mark[i] = -1;\n\tfor(int i = 0;i < m;i++){\n\t\tint a,b;\n\t\tcin >> a >> b; a--;b--;\n\t\tin[a] = true;\n\t\tG[b].push_back(a);\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tif(!in[i]) ans = ans * dfs(i) % MOD;\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tif(mark[i] == -1){\n\t\t\tfor(int j = 0;j < n;j++) cflag[j] = false;\n\t\t\tint res = 1;\n\t\t\tif(!cyc(i,i)) continue;\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tif(cflag[j]){\n\t\t\t\t\tfor(int to : G[j]){\n\t\t\t\t\t\tif(!cflag[to]) res = res * dfs(to) % MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = ans * (res + 1) % MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\n#include<stack>\nvector<vi> g;\nvoid visit(int v, vector< vector<int> >& scc,\n    stack<int> &S, vector<bool> &inS,\n    vector<int> &low, vector<int> &num, int& time) {\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  each(e, g[v]) {\n    int w = *e;\n    if (num[w] == 0) {\n      visit(w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\nvoid stronglyConnectedComponents(vector< vector<int> >& scc) {\n  const int n = g.size();\n  vector<int> num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  rep(u, n) if (num[u] == 0)\n    visit(u, scc, S, inS, low, num, time);\n}\n\nconst int mod = (int)1e9 + 7;\nint n, m, to[2000], deg[2000];\nll rec(const vector<vi> &e, int c){\n\tll res = 1;\n\teach(i, e[c]) (res *= rec(e, *i)) %= mod;\n\treturn res + 1;\n}\n\nint main(){\n\tcin >> n >> m;\n\tg.resize(n);\n\trep(i, m){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tg[b - 1].pb(a - 1);\n\t}\n\tvector<vi> scc;\n\tstronglyConnectedComponents(scc);\n\tset<pi> es;\n\tint N = scc.size();\n\tvector<vi> e(N + 1);\n\t\n\trep(i, N) each(j, scc[i]) to[*j] = i;\n\trep(i, n) each(j, g[i]){\n\t\tint a = to[i], b = to[*j];\n\t\tif(es.count(mp(a, b)) || a == b) continue;\n\t\tes.insert(mp(a, b));\n\t\te[a].pb(b);\n\t\tdeg[b]++;\n\t}\n\trep(i, N) if(deg[i] == 0) e[N].pb(i);\n\tcout << (rec(e, N) + mod - 1) % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\ntypedef long long ll;\n\nusing namespace std;\n\nint e[1000];\nll dp[1000][2];\n\nint cycle[1000];\nint flag[1000];\nint in[1000];\n\nint n, m;\n\nconst int mod = 1000000007;\n\nint check(int i){\n  if(flag[i] == 2) return -1;\n  if(flag[i] == 1){\n    flag[i] = 2;\n    return i;\n  }\n\n  flag[i] = 1;\n\n  if(e[i] != -1){\n    int c = check(e[i]);\n    if(c != -1){\n      flag[i] = 2;\n      cycle[i] = c;\n\n      if(c == i)\n        return -1;\n      else\n        return c;\n    }\n  }\n  flag[i] = 2;\n\n  return -1;\n}\n\nint main(){\n  n = getInt();\n  m = getInt();\n\n  REP(i,n){\n    e[i] = -1;\n    cycle[i] = i;\n    dp[i][0] = dp[i][1] = 1;\n  }\n\n  REP(i,m){\n    int s = getInt() - 1;\n    int d = getInt() - 1;\n    e[s] = d;\n  }\n\n  // detect cycle\n  REP(i,n) if(!flag[i])\n    check(i);\n\n  REP(i,n) if(cycle[i] == i && e[i] != -1){\n    int ee = cycle[e[i]];\n    if(ee != -1){\n      in[ee]++;\n    }\n  }\n\n  queue<int> que;\n  ll ans = 1;\n\n  REP(i,n) if(cycle[i] == i){\n    if(in[i] == 0) que.push(i);\n  }else if(in[cycle[i]] == 1){\n    if(flag[cycle[i]] == 2){\n      flag[cycle[i]] = 3;\n      ans = (ans * 2) % mod;\n    }\n  }\n\n  // REP(i,n) printf(\"%d \", cycle[i]); puts(\"\");\n  // REP(i,n) printf(\"%d \", in[i]); puts(\"\");\n\n\n  while(que.size()){\n    int pos = que.front(); que.pop();\n    // printf(\"pos: %d\\n\", pos);\n\n    if(e[pos] == -1){\n      ans = (ans * ((dp[pos][0] + dp[pos][1]) % mod)) % mod;\n    }else{\n      int next = cycle[e[pos]];\n      dp[next][0] = (dp[next][0] * dp[pos][0]) % mod;\n      dp[next][1] = (dp[next][1] * ((dp[pos][0] + dp[pos][1]) % mod)) % mod;\n      if(--in[next] == 0)\n        que.push(next);\n    }\n  }\n\n  printf(\"%d\\n\", (int)ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "struct EDGE\n{\n    int v,cap,next;\n}e[EM];\n\nint head[VM],cnt=0;\nint dis[VM],vn[VM];\nint source,sink,NV;\n\nvoid add(int u,int v,int c)\n{\n    e[cnt].v=v;e[cnt].cap=c;e[cnt].next=head[u];head[u]=cnt++;\n    e[cnt].v=u;e[cnt].cap=c;e[cnt].next=head[v];head[v]=cnt++;\n}\n\nvoid init()\n{\n    memset(head,-1,sizeof(head));\n    cnt=0;\n}\n\nint dfs(int cur,int cost)\n{\n    if(cur==sink)   return cost;\n    int leave=cost,Mind=NV,v;\n    for(int i=head[cur];i!=-1;i=e[i].next)\n    {\n        if(e[i].cap>0)\n        {\n            if(dis[v=e[i].v]+1==dis[cur])\n            {\n                int flow=dfs(v,min(leave,e[i].cap));\n                leave-=flow;\n                e[i].cap-=flow;\n                e[i^1].cap+=flow;\n                if(dis[source]>=NV) return cost-leave;\n                if(leave==0)    break;\n            }\n            if(dis[v]<Mind)\n                Mind=dis[v];\n        }\n    }\n    if(cost==leave)\n    {\n        if((--vn[dis[cur]])==0)dis[source]=NV;\n        dis[cur]=Mind+1;\n        vn[dis[cur]]++;\n    }\n    return cost-leave;\n}\n\nint Sap()\n{\n    int flag=0,f;\n    memset(dis,0,sizeof(dis));\n    memset(vn,0,sizeof(vn));\n    vn[0]=NV;\n    while(di[source]<NV)\n    {\n        flow+=dfs(source,Inf);\n    }\n    return flow;\n}"
  },
  {
    "language": "C++",
    "code": "class in{struct It{int it;const bool rev;explicit constexpr It(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(It& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const It i,n;public:explicit constexpr in(int n):i(0),n(n<0?0:n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const It& begin(){return i;}const It& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\npair<vector<int>, int> Scc(const vector<vector<int>>& adj) {\n    const int n = adj.size();\n    vector<int> num(n, 0), low(n, 0), color(n, 0);\n    vector<int> sta;\n    vector<bool> inS(n, 0);\n    int t = 0, colnum = 0;\n    function<void(int)> visit = [&](int cur) {\n        low[cur] = num[cur] = ++t;\n        sta.emplace_back(cur); inS[cur] = 1;\n        for(int nxt : adj[cur]) {\n            if(num[nxt] == 0) {\n                visit(nxt);\n                low[cur] = min(low[cur], low[nxt]);\n            } else if(inS[nxt])\n              low[cur] = min(low[cur], num[nxt]);\n        }\n        if(low[cur] == num[cur]) {\n            while(true) {\n                int nxt = sta.back(); sta.pop_back(); inS[nxt] = false;\n                color[nxt] = colnum;\n                if(cur == nxt) break;\n            }\n            ++colnum;\n        }\n    };\n    for(int v : in(n))\n      if(num[v] == 0)\n        visit(v);\n    return make_pair(color, colnum);\n}\n\nvector<int> topologicalSort(const vector<vector<int>>& adj) {\n    int N = adj.size();\n    vector<int> deg(N);//??\\?¬???°\n    for(int i = 0; i < N; ++i)\n      for(int nv : adj[i])\n        ++deg[nv];\n    vector<int> ord(N, -1);\n    int t = 0;\n    for(int v = 0; v < N; ++v) \n      if(deg[v] == 0)\n        ord[t++] = v;\n    for(int h = 0; h < t; ++h) {\n        int v = ord[h];\n        for(int nv : adj[v]) {\n            --deg[nv];\n            if(deg[nv] == 0)\n              ord[t++] = nv;\n        }\n    }\n    return ord;\n}\n\nusing i64 = long long;\nconst i64 MOD = 1e9 + 7;\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> __adj(n);\n    for(int _ : in(m)) {\n        int u, v;\n        cin >> u >> v;\n        --u; --v;\n        __adj[u].emplace_back(v);\n    }\n    vector<int> color; int col;\n    tie(color, col) = Scc(__adj);\n    vector<vector<int>> radj(col);\n    for(int v : in(n))\n      for(int u : __adj[v])\n        if(color[v] != color[u])\n          radj[color[u]].emplace_back(color[v]);\n    for(auto& a : radj) {\n        sort(a.begin(), a.end());\n        a.erase(unique(a.begin(), a.end()), a.end());\n    }\n    vector<int> ord = topologicalSort(radj);\n    vector<i64> dp(col, -1LL);\n    i64 ans = 1LL;\n    function<i64(int)> dfs = [&](int v) {\n        assert(v != -1);\n        i64& res = dp[v];\n        if(res != -1LL) return res;\n        res = 1LL;\n        for(int u : radj[v])\n          res = res * dfs(u) % MOD;\n        return ++res;\n    };\n    for(int v : ord) {\n        if(dp[v] != -1LL) continue;\n        ans = ans * dfs(v) % MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef long long ll;\nll mod=1e9+7;\nint N,M;\nvector<int> G[1000],rG[1000],vs;\nbool used[1000];\nint cmp[1000];\nvoid add_edge(int from,int to){\n\tG[from].pb(to);\n\trG[to].pb(from);\n}\nvoid dfs(int v){\n\tused[v]=1;\n\tfor(int a:G[v]) if(!used[a]) dfs(a);\n\tvs.pb(v);\n}\nvoid rdfs(int v,int k){\n\tused[v]=1;\n\tcmp[v]=k;\n\tfor(int a:rG[v]) if(!used[a]) rdfs(a,k);\n}\nint scc(){\n\tmemset(used,0,sizeof(used));\n\tvs.clear();\n\trep(v,N) if(!used[v]) dfs(v);\n\tmemset(used,0,sizeof(used));\n\tint k=0;\n\tfor(int i=vs.size()-1;i>=0;i--){\n\t\tif(!used[vs[i]]) rdfs(vs[i],k++);\n\t}\n\treturn k;\n}\nvector<int> gg[1000];\nbool vis[1000];\nint deg[1000];\nll ddfs(int i){\n\tll ret=1;\n\tfor(int v:gg[i]) ret=ret*ddfs(v)%mod;\n\treturn (ret+1)%mod;\n}\nint main(){\n\tcin>>N>>M;\n\trep(i,M){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tadd_edge(a-1,b-1);\n\t}\n\tint k=scc();\n\trep(i,N) for(int a:G[i]){\n\t\tif(cmp[i]!=cmp[a]){\n\t\t\tgg[cmp[a]].pb(cmp[i]);\n\t\t\tdeg[cmp[i]]++;\n\t\t}\n\t}\n\trep(i,k){\n\t\tsort(all(gg[i]));\n\t\tgg[i].erase(unique(all(gg[i])),gg[i].end());\n\t}\n\tll ans=1;\n\trep(i,k) if(deg[i]==0){\n\t\tans*=ddfs(i);\n\t\tans%=mod;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#define INF 100005\nusing namesapce std;\nchar str[INF];\nstruct acnode{\n\tint sum;\n\tancode *next[26];\n\tancode *fail;\n\tancode():sum(0),fail(NULL){\n\t\tfor(int i=0;i<26;i++){\n\t\t\tnext[i]=NULL;\n\t\t}\n\t}\n}root;\nvoid insrt(char *s){\n\tint len=strlen(s);\n\tancode *p=&root;\n\tfor(int i=0;i<len;++i){\n\t\tif(p->next[s[i]-'a']==NULL){\n\t\t\tancode *te=new ancode();\n\t\t\tp->next[s[i]-'a']=te;\n\t\t}\n\t\tp->next[s[i]-'a'];\n\t}\n\tp->sun++;\n}\nvoid getfail(){\n\tancode *p=&root;\n\tqueue<ancode*> que;\n\tfor(int i=0;i<26;i++){\n\t\tif(p->next[i]!=NULL){\n\t\t\tp->next[i]->fail=p;\n\t\t\tque.push(p->next[i]);\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tancode *h=que.front();\n\t\t\tfor(int i=0;i<26;i++){\n\t\t\t\tif(h->next[i]!=NULL){\n\t\t\t\t\tancode *te=h->fail;\n\t\t\t\t\twhile(te!=NULL){\n\t\t\t\t\t\tif(te->next[i]!=NULL){\n\t\t\t\t\t\t\th->next[i]->fail=te->next[i];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tte=te->fail;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(te==NULL)\n\t\t\t\t\t\t\th->next[i]->fail=&root;\n\t\t\t\t\t\t\tque.push(h->next[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tque.pop();\n\t\t\t}\n\t\t}\n\t} \n}\nint srarch(char *s){\n\tint ans=0;\n\tancode *p=&root;\n\tfor(int i=0;s[i];){\n\t\tif(p->next[s[i]-'a']!=NULL){\n\t\t\tancode *te=p->next[s[i]-'a'];\n\t\t\twhile(te!=&root){\n\t\t\t\tif(te->sum)\n\t\t\t\t\tans+=te->sum;\n\t\t\t\t\tte=te->fail; \n\t\t\t}\n\t\t\tp=p->next[s[i++]-'a'];\n\t\t}\n\t\telse{\n\t\t\tif(p->fail==NULL)\n\t\t\t\ti++;\n\t\t\telse\n\t\t\t{\n\t\t\t\tp=p->fail;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\nvoid acclear(ancode *p){\n\tfor(int u=0;i<26;i++){\n\t\tif(p->next[i]!=NULL){\n\t\t\tacclear(p->next[i]);\n\t\t\tif(p!=&root)\n\t\t\tfree(p);\n\t\t\telse\n\t\t\troot=ancode();\n\t\t}\n\t}\n}\nint main(){\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--){\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%s\",str);\n\t\t\tinsrt(str);\n\t\t}\n\t\tgetfail();\n\t\tscanf(\"%s\",str);\n\t\tprintf(\"%d\\n\",search(str));\n\t\taccelar(&root);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define MAX (1001)\n#define MOD (1000000007LL)\n\nint V;\nvector<int> G[MAX];\nvector<int> rG[MAX];\nvector<int> nG[MAX];//?????£???????§£????????£???????????°????????°?????? \nvector<int> nrG[MAX];\nvector<int> vs;\nbool used[MAX];\nint cmp[MAX]; //?±????????????£????????????????????????????????????\n \nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n \nvoid dfs(int v){\n  used[v] = true;\n  for(int i = 0 ; i < G[v].size() ; i++){\n    if(!used[G[v][i]]) dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\n \nvoid rdfs(int v,int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i = 0 ; i < rG[v].size() ; i++){\n    if(!used[rG[v][i]]) rdfs(rG[v][i],k);\n  }\n}\n \nint scc(){ //?????£?????????????§£????????????\n  memset(used, 0, sizeof(used));\n  vs.clear();\n  for(int v = 0 ; v < V ; v++){\n    if(!used[v]) dfs(v);\n  }   \n  memset(used, 0, sizeof(used));\n  int k = 1;\n  for(int i = vs.size() - 1 ; i >= 0 ; i--){\n    if(!used[vs[i]]) rdfs(vs[i],k++);\n  }\n\n  for(int i=0;i<k;i++){\n    int v = cmp[i];\n    for(int j=0;j<(int)G[i].size();j++){\n      int to = cmp[G[i][j]];\n      if( to != v ) {\n\tnG[v].push_back(to);\n\tnrG[to].push_back(v);\n      }\n    }\n  }\n  return k;\n}\n\nvoid dfs2(int id,bool *flag){\n  if( flag[id] ) return;\n  flag[id] = true;\n  for(int i=0;i<(int)nG[id].size();i++)\n    dfs2(nG[id][i],flag);\n}\n\t\t \n\nint M;\nll dp[MAX];\nll solve(int id){\n  if( used[id] ) return dp[id];\n  used[id] = true;\n\n  ll ret = 1;\n  for(int i=0;i<(int)nG[id].size();i++){\n    int to = nG[id][i];\n    ret *= solve( to );\n    ret %= MOD;\n  }\n  return ret + 1LL;\n}\n\nbool ch[MAX];\n\nint main(){\n\n  cin >> V >> M;\n  for(int i=0;i<M;i++){\n    int s,d;\n    cin >> s >> d;\n    --s; --d;\n    add_edge(s,d);\n  }\n\n  int K = scc();\n  for(int i=1;i<K;i++){\n    if( nrG[i].empty() ) {\n      nrG[i].push_back(0);\n      nG[0].push_back(i);\n    }\n    if( nG[i].empty() ){\n      nG[i].push_back(K);\n      nrG[K].push_back(i);\n    }\n  }\n  ll ret = 0;\n  dp[K] = 1LL;\n  for(int i=K;i>0;i--){\n    /*\n       cout << \"vertex : \" << i << \" dp = \" << dp[i] << endl;\n    for(int j=0;j<(int)nrG[i].size();j++)\n      cout << \" -> \" << nrG[i][j] << endl;;\n    */\n    memset(used,0,sizeof(used));\n    dfs2(i,used);\n    for(int j=0;j<=K;j++)\n      if( used[j] ) \n\tfor(int k=0;k<(int)nrG[j].size();k++)\n\t  if( !used[nrG[j][k]]  ) dp[nrG[j][k]] = (dp[nrG[j][k]] + dp[i])%MOD;\n    ret += dp[i];\n    ret %= MOD;\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst int MAX_N = 1010;\nint N, M;\nint Parent[MAX_N];\nint Flg[MAX_N];\nvector<int>Childs[MAX_N];\nll score[MAX_N];\nll ans = 1;\nll dp(int id){\n    if(Childs[id].size()==0)return 2;\n    ll tmp = 1;\n    for(int i=0;i<Childs[id].size();i++){\n        if(Flg[Childs[id][i]] || Childs[id][i]==id)continue;\n        tmp = tmp * dp(Childs[id][i]) % MOD;\n    }\n    return (tmp+1LL)%MOD;\n}\nint main(void){\n    // Your code here!\n    cin>>N>>M;\n    for(int i=0;i<M;i++){\n        int s, d;\n        cin>>s>>d;\n        Parent[s] = d;\n        Childs[d].push_back(s);\n    }\n    for(int i=1;i<=N;i++){\n        int flg = 0;\n        for(int tmp = i, cnt=0;Parent[tmp] && cnt < MAX_N;tmp=Parent[tmp], cnt++){\n            if(Parent[tmp]==i){\n                flg=1;\n                break;\n            }\n        }\n        if(flg==0)continue;\n        for(int tmp = Parent[i];tmp!=i;tmp=Parent[tmp]){\n            Flg[tmp]=1;\n            for(int j=0;j<Childs[tmp].size();j++){\n                Childs[i].push_back(Childs[tmp][j]);\n                Parent[Childs[tmp][j]] = i;\n            }\n        }\n        Parent[i]=0;\n    }\n    for(int i=1;i<=N;i++){\n        if(Parent[i])continue;\n        ans = ans * dp(i) % MOD;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nclass SCC{//cmp(0 - kk-1) is scc's return. Same number is group. The number is no relatoin.\npublic:\n  int n;\n  vvi G,rG,tG;\n  vector<bool>used;\n  vi vs,cmp;\n  SCC(int size){\n    n=size;\n    G=rG=vvi(n);\n    used=vector<bool>(n);\n    cmp=vi(n);\n    vs=vi(0);\n  }\n  void add_edge(int s,int t){\n    G[s].pb(t);\n    rG[t].pb(s);\n  }\n  void rdfs(int v,int k){\n    used[v]=true;\n    cmp[v]=k;\n    rep(i,rG[v].size())if(!used[rG[v][i]])rdfs(rG[v][i],k);\n  }\n  void dfs(int v){\n    used[v]=true;\n    rep(i,G[v].size())if(!used[G[v][i]])dfs(G[v][i]);\n    vs.pb(v);\n  }\n  int scc(){\n    rep(i,n)used[i]=false;\n    rep(v,n)if(!used[v])dfs(v);\n    rep(i,n)used[i]=false;\n    int kk=0;\n    for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],kk++);\n    return kk;\n  }\n  vvi make(){\n    int N=scc();\n    tG=vvi(N);\n    rep(i,n)rep(j,G[i].size())if(cmp[i]!=cmp[G[i][j]]){\n      tG[cmp[i]].pb(cmp[G[i][j]]);\n      //\ttG[cmp[G[i][j]]].pb(cmp[i]);\n    }\n    return tG;\n  }\n};\nclass TOPO{//out is tsort's return.\npublic:\n  vvi G;\n  vi out;\n  vector<bool>V;\n  vi indeg;\n  int n;\n  TOPO(int size){\n    n=size;\n    G=vvi(n);\n    out=vi(0);\n    V=vector<bool>(n);\n    indeg=vi(n);\n  }\n  void add_edge(int s,int t){\n    G[s].pb(t);\n  }\n  void bfs(int s){\n    queue<int>q;\n    q.push(s);\n    V[s]=true;\n    while(!q.empty()){\n      int u=q.front();q.pop();\n      out.pb(u);\n      rep(i,G[u].size()){\n\tint v=G[u][i];\n\tindeg[v]--;\n\tif(indeg[v]==0&&!V[v]){\n\t  V[v]=true;\n\t  q.push(v);\n\t}\n      }\n    }\n  }\n  vi tsort(){\n    rep(i,n)indeg[i]=0;\n    rep(i,n)rep(j,G[i].size()){\n      int v=G[i][j];\n      indeg[v]++;\n    }\n    rep(i,n)if(indeg[i]==0&&!V[i])bfs(i);\n    //\trep(i,n)cout<<out[i]<<endl;\n    return out;\n  }\n};\nint main(){\n  int n,m;\n  cin>>n>>m;\n  SCC scc(n);\n  rep(i,m){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    scc.add_edge(a,b);\n  }\n  vvi G=scc.make();\n  n=G.size();\n  vvi rG(n);\n  TOPO tp(n);\n  rep(i,n)rep(j,G[i].size()){\n    tp.add_edge(i,G[i][j]);\n    rG[G[i][j]].pb(i);\n  }\n  vi out=tp.tsort();\n  vp dp(n,{1,1});\n  ll MOD=1000000007;\n  rep(i,n){\n    int to=out[i];\n    rep(j,rG[out[i]].size()){\n      int from=rG[out[i]][j];\n      //      cout<<from<<\" \"<<to<<endl;\n      (dp[to].first*=(ll)(dp[from].first+dp[from].second)%MOD)%=MOD;\n      (dp[to].second*=(ll)dp[from].second)%=MOD;\n    }\n    //    if(rG[to].size()!=0)(dp[to].first+=MOD-dp[to].second)%=MOD;\n  }\n  ll sum=1;\n  rep(i,n)if(G[i].size()==0){\n    //    cout<<dp[i].first<<\" \"<<dp[i].second<<endl;\n    (sum*=(dp[i].first+dp[i].second)%MOD)%=MOD;\n  }\n  cout<<sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n\nconst ll MOD = 1e9+7;\n\n//verified AOJ GRL_3\n#define MAX_V 1000\nvector<int> G[MAX_V];   //辺\nvector<int> rG[MAX_V];  //逆辺\nvector<string> str;\n\nvoid add_edge(int from, int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid dfs(int v, bool used[MAX_V], vector<int> &vs){     //末端から遠いノードから順に、たどり着けるノードをvsに入れていく\n    used[v] = true;\n    rep(i,G[v].size()){\n        if(!used[G[v][i]])dfs(G[v][i],used,vs);\n    }\n    vs.push_back(v);\n}\n\nvoid rdfs(int v,int k,vector<int> &sccs, vector<int> &cmp, bool used[MAX_V]){   //逆辺を使って末端に近いノードから順にDFS\n    used[v] = true;\n    sccs.push_back(v);\n    cmp[v] = k;\n    rep(i,rG[v].size()){\n        if(!used[rG[v][i]])rdfs(rG[v][i],k,sccs,cmp,used);\n    }\n}\n\nint scc(int V, vector< vector<int> > &each_scc, vector<int> &cmp){\n    vector<int> vs;\n    bool used[MAX_V];\n    rep(i,MAX_V)used[i] = false;\n    vs.clear();\n    rep(v,V){\n        if(!used[v]) dfs(v, used, vs);\n    }\n    \n    rep(i,MAX_V) used[i] = false;\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--){\n        vector<int> sccs;\n        if(!used[vs[i]]){\n            rdfs(vs[i], k++, sccs, cmp, used);\n            each_scc.push_back(sccs);\n        }\n    }\n    return k;\n}\n\nvoid getSccedGraph(vector<vector<int>> each_scc, vector<int> cmp, vector<int> newGraph[MAX_V]){   //sccの結果からグラフを得る O(E)くらい？ verified ARC030-C\n    rep(i,each_scc.size()){\n        set<int> edges;\n        rep(j,each_scc[i].size()){\n            rep(k,G[each_scc[i][j]].size()){\n                int to = G[each_scc[i][j]][k];\n                if( cmp[to]!=i )edges.insert(cmp[to]);\n            }\n        }\n        for(auto &edge:edges)newGraph[i].pb(edge);\n    }\n}\n\nvector<int> nG[MAX_V], rnG[MAX_V];\n\nll dp[MAX_V];\nll dfs(int cur){\n    if(dp[cur]!=-1)return dp[cur];\n    if(rnG[cur].size()==0)return dp[cur] = 2;\n    \n    ll ret = 1;\n    for(auto e:rnG[cur]){\n        (ret *= dfs(e))%=MOD;\n    }\n    \n    return dp[cur] = (ret+1)%MOD;\n}\n\n\nint main(){\n    rep(i,MAX_V)dp[i] = -1;\n    int v,e;\n    cin>>v>>e;\n    \n    rep(i,e){\n        int s,t;\n        cin>>s>>t;\n        s--,t--;\n        \n        add_edge(s,t);\n    }\n    vector<vector<int>> each_scc;  //それぞれの強連結成分のリスト\n    vector<int> cmp(MAX_V);        //あるノードが属している強連結成分の番号( 多分each_sccに対応している )\n    int k = scc(v,each_scc,cmp);   //強連結成分の個数\n    \n    getSccedGraph(each_scc, cmp, nG);\n    \n    rep(i,MAX_V){\n        for(auto e:nG[i]){\n            rnG[e].pb(i);\n        }\n    }\n    \n    vector<int> zero_deg;\n    rep(i,k){\n        if(nG[i].size()==0)zero_deg.pb(i);\n    }\n    \n    \n    ll ans = 1;\n    for(auto elm:zero_deg){\n        (ans *= dfs(elm))%=MOD;\n    }\n    cout<<ans<<endl;\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Package: StandardCodeLibrary.Core\n * */\n//蠑戊ソ帛クク逕ィ逧?、エ譁?サカ蟷カ菴ソ逕ィstd蜷榊ュ礼ゥコ髣エ\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <utility>\n#include <vector>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <climits>\nusing namespace std;\n\n//逕ィ莠主?蟆台サ」遐??逧?ョ?#define lp for(;;)\n#define repf(i,a,b) for (int i=(a);i<(b);++i)\n#define rrepf(i,a,b) for (int i=(a)-1;i>=(b);--i)\n#define rep(i,n) repf(i,0,n)\n#define rrep(i,n) rrepf(i,n,0)\n#define ft(i,a,b) for (int i=(a);i<=(b);++i)\n#define fdt(i,a,b) for (int i=(a);i>=(b);--i)\n#define for_nonempty_subsets(subset,set) for (int subset=set;subset;subset=(subset-1)&(set))\n#define for_in_charset(i,charset) for (cstr i=(charset);*i;i++)\n#define whl while\n#define rtn return\n#define fl(x,y) memset((x),char(y),sizeof(x))\n#define clr(x) fl(x,char(0))\n#define cpy(x,y) memcpy(x,y,sizeof(x))\n#define sf scanf\n#define pf printf\n#define vec vector\n#define pr pair\n#define que queue\n#define prq priority_queue\n#define itr iterator\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define ins insert\n#define ers erase\n#define lb lower_bound\n#define ub upper_bound\n#define rnk order_of_key\n#define sel find_by_order\n#define sz(x) (int((x).size()))\n#define all(x) (x).begin(),(x).end()\n#define srt(x) sort(all(x))\n#define uniq(x) srt(x),(x).erase(unique(all(x)),(x).end())\n#define rev(x) reverse(all(x))\n#define shf(x) random_shuffle(all(x))\n#define nxtp(x) next_permutation(all(x))\n\n//隹?ッ慕嶌蜈ウ逧?ョ?//#ifndef DEBUG\n#define prt(x) (cerr)\n#define asrtWA(s) do if(!(s))exit(0);whl(0)\n#define asrtTLE(s) do if(!(s))whl(1);whl(0)\n#define asrtMLE(s) do if(!(s))whl(new int);whl(0)\n#define asrtOLE(s) do if(!(s))whl(1)puts(\"OLE\");whl(0)\n#define asrtRE(s) do if(!(s))*(int*)0=0;whl(0)\n#define runtime() (cerr)\n#define input(in) freopen(in,\"r\",stdin)\n#define output(out) freopen(out,\"w\",stdout)\n//#else\n//#define prt(x) cerr<<\"隨ャ\"<<__LINE__<<\"陦圭t: \"<<#x\"\\t=\"<<(x)<<endl\n//#define asrtWA(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n//#define asrtTLE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n//#define asrtMLE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n//#define asrtOLE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n//#define asrtRE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n//#define runtime() cerr<<\"Used: \"<<db(clock())/CLOCKS_PER_SEC<<\"s\"<<endl\n//#define input(in)\n//#define output(out)\n//#endif\n\n//蟶ク逕ィ謨ー謐ョ邀サ蝙?typedef long long int lli;\ntypedef double db;\ntypedef const char* cstr;\ntypedef string str;\ntypedef vec<int> vi;\ntypedef vec<vi> vvi;\ntypedef vec<bool> vb;\ntypedef vec<vb> vvb;\ntypedef vec<str> vs;\ntypedef pr<int,int> pii;\ntypedef pr<lli,lli> pll;\ntypedef pr<db,db> pdd;\ntypedef map<int,int> mii;\ntypedef map<str,int> msi;\ntypedef map<char,int> mci;\ntypedef set<int> si;\ntypedef set<str> ss;\ntypedef que<int> qi;\ntypedef vec<pii> vpii;\ntypedef vec<pdd> vpdd;\n\n//蟶ク逕ィ蟶ク驥?int逧?怙螟ァ蛟シ;lli逧?怙螟ァ蛟シ;db逧?ッッ蟾ョ逶ク蜈ウ蟶ク謨ー;谺ァ諡牙クク謨ー;蝨?捉邇?遘サ蜉ィ蜷鷹?;蜿匁ィ。菴ソ逕ィ逧?勁謨ー\nint oo=(~0u)>>1;\nlli ooll=(~0ull)>>1;\ndb inf=1e+10;\ndb eps=1e-10;\ndb gam=0.5772156649015328606;\ndb pi=acos(-1.0);\nint dx[]={1,0,-1,0,1,-1,-1,1,0};\nint dy[]={0,1,0,-1,1,1,-1,-1,0};\nint MOD=1000000007;\n\n//蟶ク逕ィ蜃ス謨ー:譛?、ァ譛?ー丞?譖エ譁ー;謨ー蟄ヲ逶ク蜈ウ蜃ス謨ー;霎灘?蜥瑚セ灘?;譬醍憾謨ー扈?蟷カ譟・髮?蜿ッ蜷亥ケカ蝣?\ntemplate<typename type>inline bool cmax(type& a,const type& b){rtn a<b?a=b,true:false;}\ntemplate<typename type>inline bool cmin(type& a,const type& b){rtn b<a?a=b,true:false;}\ntemplate<typename type>inline type sqr(const type& x){rtn x*x;}\ntemplate<typename type>inline type mod(const type& x){rtn x%MOD;}\ninline int sgn(const db& x){rtn (x>+eps)-(x<-eps);}\ninline int dbcmp(const db& a,const db& b){rtn sgn(a-b);}\ntemplate<typename type>inline pr<type,type> operator-(const pr<type,type>& x){rtn mp(-x.x,-x.y);}\ntemplate<typename type>inline pr<type,type> operator+(const pr<type,type>& a,const pr<type,type>& b){rtn mp(a.x+b.x,a.y+b.y);}\ntemplate<typename type>inline pr<type,type> operator-(const pr<type,type>& a,const pr<type,type>& b){rtn mp(a.x-b.x,a.y-b.y);}\ntemplate<typename type>inline pr<type,type> operator*(const pr<type,type>& a,const type& b){rtn mp(a.x*b,a.y*b);}\ntemplate<typename type>inline pr<type,type> operator/(const pr<type,type>& a,const type& b){rtn mp(a.x/b,a.y/b);}\ntemplate<typename type>inline pr<type,type>& operator-=(pr<type,type>& a,const pr<type,type>& b){rtn a=a-b;}\ntemplate<typename type>inline pr<type,type>& operator+=(pr<type,type>& a,const pr<type,type>& b){rtn a=a+b;}\ntemplate<typename type>inline pr<type,type>& operator*=(pr<type,type>& a,const type& b){rtn a=a*b;}\ntemplate<typename type>inline pr<type,type>& operator/=(pr<type,type>& a,const type& b){rtn a=a/b;}\ntemplate<typename type>inline type cross(const pr<type,type>& a,const pr<type,type>& b){rtn a.x*b.y-a.y*b.x;}\ntemplate<typename type>inline type dot(const pr<type,type>& a,const pr<type,type>& b){rtn a.x*b.x+a.y*b.y;}\ntemplate<typename type>inline type gcd(type a,type b){if(b)whl((a%=b)&&(b%=a));rtn a+b;}\ntemplate<typename type>inline type lcm(type a,type b){rtn a*b/gcd(a,b);}\ntemplate<typename istream,typename first_type,typename second_type>inline istream& operator>>(istream& cin,pr<first_type,second_type>& x){rtn cin>>x.x>>x.y;}\ntemplate<typename ostream,typename first_type,typename second_type>inline ostream& operator<<(ostream& cout,const pr<first_type,second_type>& x){rtn cout<<x.x<<\" \"<<x.y;}\ntemplate<typename istream,typename type>inline istream& operator>>(istream& cin,vec<type>& x){rep(i,sz(x))cin>>x[i];rtn cin;}\ntemplate<typename ostream,typename type>inline ostream& operator<<(ostream& cout,const vec<type>& x){rep(i,sz(x))cout<<x[i]<<(i+1==sz(x)?\"\":\" \");rtn cout;}\ninline ostream& pdb(int prcs,db x){rtn cout<<setprecision(prcs)<<fixed<<(sgn(x)?(x):0);}\ntemplate<typename type>inline void bit_inc(vec<type>& st,int x,type inc){whl(x<sz(st))st[x]+=inc,x|=x+1;}\ntemplate<typename type>inline type bit_sum(const vec<type>& st,int x){type s=0;whl(x>=0)s+=st[x],x=(x&(x+1))-1;rtn s;}\ntemplate<typename type>inline type bit_kth(const vec<type>& st,int k){int x=0,y=0,z=0;whl((1<<(++y))<=sz(st));fdt(i,y-1,0){if((x+=1<<i)>sz(st)||z+st[x-1]>k)x-=1<<i;else z+=st[x-1];}rtn x;}\ninline void make_set(vi& st){rep(i,sz(st))st[i]=i;}\ninline int find_set(vi& st,int x){int y=x,z;whl(y!=st[y])y=st[y];whl(x!=st[x])z=st[x],st[x]=y,x=z;rtn y;}\ninline bool union_set(vi& st,int a,int b){a=find_set(st,a),b=find_set(st,b);rtn a!=b?st[a]=b,true:false;}\ntemplate<typename type>inline void merge(type& a,type& b){if(sz(a)<sz(b))swap(a,b);whl(sz(b))a.ins(*b.begin()),b.ers(b.begin());}\n\n//蛻晏ァ句喧\nstruct Initializer\n{\n//#ifndef DEBUG\n\tInitializer(){ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);}\n//#else\n//\t~Initializer(){runtime();}\n//#endif\n}initializer;\n\n//髱樊?蜃?#define feach(e,s) for (__typeof__((s).begin()) e=(s).begin();e!=(s).end();++e)\n#include <ext/rope>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\nusing __gnu_cxx::rope;\ntemplate<typename key,typename value>class ext_map:public __gnu_pbds::tree<key,value,less<key>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>{};\n#define ctz __builtin_ctz\n#define clz __builtin_clz\n#define bc __builtin_popcount\n\nconst int MAXV=1000;\nconst int MAXE=1000000;\ntypedef struct struct_edge* edge;\nstruct struct_edge{int v;edge n;}pool[MAXE];\nedge top;\nint V;\nedge adj[MAXV];\nvoid build_graph(int v)\n{\n\ttop=pool,clr(adj);\n\tV=v;//轤ケ謨ー\n\t//add_edge(u,v);\n}\nvoid add_edge(int u,int v)\n{\n\ttop->v=v,top->n=adj[u],adj[u]=top++;\n}\nint ord;\nint dfn[MAXV];\nint low[MAXV];\nint stks;\nint stk[MAXV];\nbool ins[MAXV];\nint cnt;\nint bl[MAXV];\nvoid dfs(int u)\n{\n\tdfn[u]=low[u]=++ord;\n\tins[stk[stks++]=u]=true;\n\tfor (edge i=adj[u];i;i=i->n)\n\t\tif (!dfn[i->v]) dfs(i->v),cmin(low[u],low[i->v]);\n\t\telse if (ins[i->v]) cmin(low[u],dfn[i->v]);\n\tif (dfn[u]==low[u])\n\t{\n\t\tint v;\n\t\tdo ins[v=stk[--stks]]=false,bl[v]=cnt;\n\t\twhl(v!=u);\n\t\tcnt++;\n\t}\n}\nvoid tarjan()\n{\n\tord=0,clr(dfn),cnt=0;\n\trep(i,V) if (!dfn[i]) dfs(i);\n}\n\nint main()\n{\n\tint n,m;\n\tcin>>n>>m;\n\tbuild_graph(n);\n\trep(i,m)\n\t{\n\t\tint s,d;\n\t\tcin>>s>>d,--s,--d;\n\t\tadd_edge(s,d);\n\t}\n\ttarjan();\n\tvvi adj(cnt);\n\tvvi radj(cnt);\n\trep(i,V) for (edge e=::adj[i];e;e=e->n) if (bl[i]!=bl[e->v]) adj[bl[i]].pb(bl[e->v]);\n\trep(i,cnt) uniq(adj[i]);\n\tvi id(cnt);\n\trep(i,cnt) rep(j,sz(adj[i])) id[adj[i][j]]++;\n\tqi q;\n\tvec<pll> f(n);\n\trep(i,cnt) if (id[i]==0) q.push(i),f[i]=mp(1,1);\n\tlli ans=1;\n\twhl(sz(q))\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tif (!sz(adj[u])) ans=mod(ans*(f[u].x+f[u].y));\n\t\trep(i,sz(adj[u]))\n\t\t{\n\t\t\tint v=adj[u][i];\n\t\t\tradj[v].pb(u);\n\t\t\tif ((--id[v])==0)\n\t\t\t{\n\t\t\t\tq.push(v);\n\t\t\t\tf[v]=mp(1,1);\n\t\t\t\trep(j,sz(radj[v]))\n\t\t\t\t{\n\t\t\t\t\tint w=radj[v][j];\n\t\t\t\t\tf[v].x*=f[w].x+f[w].y;\n\t\t\t\t\tf[v].y*=f[w].y;\n\t\t\t\t\tf[v].x%=MOD;\n\t\t\t\t\tf[v].y%=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Edge{\n\tint src,dst;\n\tEdge(){}\n\tEdge(int s,int d):src(s),dst(d){}\n};\ntypedef vector<vector<Edge>> Graph;\n\nvoid DFS(const Graph& g,int v,vi& vis,vi& order)\n{\n\tif(vis[v]) return;\n\tvis[v]=1;\n\tfor(auto e:g[v]) DFS(g,e.dst,vis,order);\n\torder.push_back(v);\n}\n\nvvi SCC(const Graph& g)\n{\n\tint n=g.size();\n\tvi vis(n),order;\n\trep(i,n) DFS(g,i,vis,order);\n\tGraph t(n);\n\trep(i,n) for(auto e:g[i])\n\t\tt[e.dst].emplace_back(e.dst,e.src);\n\tfill(all(vis),0);\n\tvvi res;\n\tper(i,n) if(!vis[order[i]]){\n\t\tres.resize(res.size()+1);\n\t\tDFS(t,order[i],vis,res.back());\n\t}\n\treturn res;\n}\n\nint calc(const Graph& g,int v)\n{\n\tint res=1;\n\tfor(auto e:g[v])\n\t\tres=(ll(res)*calc(g,e.dst))%MOD;\n\treturn res+1;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint u,v; cin>>u>>v; u--,v--;\n\t\t\tg[u].emplace_back(u,v);\n\t\t}\n\t\t\n\t\tvvi scc=SCC(g);\n\t\tvi f(n);\n\t\trep(i,scc.size()) rep(j,scc[i].size())\n\t\t\tf[scc[i][j]]=i;\n\t\t\n\t\tGraph g2(scc.size());\n\t\t{\n\t\t\tset<pii> ps;\n\t\t\trep(i,n) for(auto e:g[i]) if(f[e.src]!=f[e.dst])\n\t\t\t\tps.emplace(f[e.dst],f[e.src]);\n\t\t\tfor(auto p:ps)\n\t\t\t\tg2[p.first].emplace_back(p.first,p.second);\n\t\t}\n\t\tvi deg(g2.size()); // 入次数\n\t\trep(i,g2.size()) for(auto e:g2[i])\n\t\t\tdeg[e.dst]++;\n\t\t\n\t\tint res=1;\n\t\trep(i,g2.size()) if(deg[i]==0)\n\t\t\tres=(ll(res)*calc(g2,i))%MOD;\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\n#define int long long\nconst int M = 1000000007;\n\nclass Scc{\n\tprivate:\n\t\tstatic const int MAX_V = 10000;\n\t\tvector<int> g[MAX_V]; //??°??????\n\t\tvector<int> rg[MAX_V]; //?????????????????£?????°??????\n\t\tvector<int> vs; //??°?????????????????????\n\t\tvector<pair<int, int>> edge;\n\t\tbool used[MAX_V];\n\n\t\tvoid rdfs(int v, int k){\n\t\t\tused[v] = true;\n\t\t\tcmp[v] = k;\n\t\t\trep(i,rg[v].size()){\n\t\t\t\tif(not used[rg[v][i]]) rdfs(rg[v][i], k);\n\t\t\t}\n\t\t}\n\t\tvoid dfs(int v){\n\t\t\tused[v] = true;\n\t\t\trep(i,g[v].size()){\n\t\t\t\tif(not used[g[v][i]]) dfs(g[v][i]);\n\t\t\t}\n\t\t\tvs.emplace_back(v);\n\t\t}\n\t\tvoid buildGraph(){\n\t\t\tfor(auto i : edge){\n\t\t\t\tif(cmp[i.first] == cmp[i.second]) continue;\n\t\t\t\tdag[ cmp[i.first] ].emplace_back(cmp[i.second]);\n\t\t\t\tcout << cmp[i.first] << ' ' << cmp[i.second] << endl;\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tvector<int> dag[MAX_V]; //?????£?????????????§£????????£?????????DAG??°??????\n\t\tint cmp[MAX_V]; //?±????????????£????????????????????????????????????\n\n\t\tvoid addEdge(int from, int to){\n\t\t\tedge.emplace_back(from,to);\n\t\t\tg[from].emplace_back(to);\n\t\t\trg[to].emplace_back(from);\n\t\t}\n\t\tint solve(int v){ //scc??????????????°?????????\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tvs.clear();\n\t\t\trep(i,v){\n\t\t\t\tif(not used[i]) dfs(i);\n\t\t\t}\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tint k = 0;\n\t\t\tfor(int i = vs.size() - 1; i >= 0; i--){\n\t\t\t\tif(not used[vs[i]]) rdfs(vs[i], k++);\n\t\t\t}\n\t\t\tbuildGraph();\n\t\t\treturn k;\n\t\t}\n};\n\npair<int, int> dfs(int cur, vector<bool>& used, Scc& scc){\n\tused[cur] = true;\n\tpair<int, int> res = make_pair(1,1);\n\tfor(auto to : scc.dag[cur]){\n\t\tif(used[to]) continue;\n\t\tpair<int, int> tmp = dfs(to, used, scc);\n\t\tres.first *= tmp.first + tmp.second;\n\t\tres.first %= M;\n\t}\n\treturn res;\n}\n\nsigned main(){\n\tint n, m;\n\tcin >> n >> m;\n\n\tScc scc;\n\trep(i,m){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tscc.addEdge(b,a);\n\t}\n\n\tint k = scc.solve(n);\n\n\tint ans = 1;\n\tvector<bool> used(n,0);\n\trep(i,k){\n\t\tif(used[i]) continue;\n\t\tpair<int, int> tmp = dfs(i, used, scc);\n\t\t//show(tmp.first + tmp.second)\n\t\tans *= tmp.first + tmp.second;\n\t\tans %= M;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, M;\nvector<vector<int>> v, rv;\nvector<int> cmp, vs;\nbool used[10001];\nconst long long int MOD = 1e9+7LL;\n\nvoid dfs(int now) {\n    used[now] = true;\n\n    for (auto next: v[now]) {\n        if (!used[next]) dfs(next);\n    }\n\n    vs.push_back(now);\n}\n\nvoid rdfs(int now, int k) {\n    used[now] = true;\n    cmp[now] = k;\n\n    for (auto next: rv[now]) {\n        if (!used[next]) rdfs(next, k);\n    }\n}\n\nint scc() {\n    memset(used, 0, sizeof(used));\n    vs.clear();\n    for (int i = 0; i < N; i++)\n        if (!used[i]) dfs(i);\n\n    memset(used, 0, sizeof(used));\n    int k = 0;\n    for (int i = vs.size() - 1; i >= 0; i--) {\n        if (!used[vs[i]]) rdfs(vs[i], k++);\n    }\n\n    return k;\n}\n\nint main() {\n    cin >> N >> M;\n    v.resize(N), rv.resize(N), cmp.resize(N);\n\n    for (int i = 0; i < M; i++) {\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n\n        v[x].push_back(y);\n        rv[y].push_back(x);\n    }\n\n    int k = scc();\n    vector<int> next(k, -1);\n    for (int i = 0; i < N; i++) {\n        if (v[i].size())\n            next[cmp[i]] = cmp[v[i][0]];\n    }\n\n    vector<long long int> sum(k);\n    memset(used, 0, sizeof(used));\n    long long int ans = 1LL;\n    for (int i = 0; i < k; i++) {\n        if (sum[i]) {\n            sum[i]++;\n        } else {\n            sum[i] = 2LL;\n        }\n\n        if (next[i] < 0 || next[i] == i) ans = (ans * sum[i]) % MOD;\n        else sum[next[i]] = (sum[next[i]] + sum[i]) % MOD;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define For(a,b,c) for(int a=b;a<=c;a++)\n#define M 1000000007\n#define ll long long\n\nstruct N\n{\n\tint v, next;\n\tvector<int>son;\n\tint fa;\n\tll sum[2];\n}fi[1001];\n\nint n, m;\n\nint find(int a)\n{\n\tif(fi[a].fa==a)\n\t\treturn a;\n\treturn find(fi[a].fa);\n}\n\nvoid add(int b, int a)\n{\n\tif(find(a)==b)\n\t{\n\t\tfor(int t=fi[a].fa; b!=a; t=fi[a].fa)\n\t\t{\n\t\t\tfi[a].fa=0;\n\t\t\tif(fi[a].son.size())\n\t\t\tFor(i,0,fi[a].son.size()-1)\n\t\t\t\tfi[b].son.push_back(fi[a].son[i]);\n\t\t\ta=t;\n\t\t}\n\t\treturn;\n\t}\n\tfi[b].fa=a;\n\tfi[a].son.push_back(b);\n}\n\nll solve(int a)\n{\n\tif(!fi[a].son.size())\n\t\treturn 2;\n\tll sum=1;\n\tFor(i,0,fi[a].son.size()-1)\n\t{\n\t\tint b=fi[a].son[i];\n\t\tif(!fi[b].fa)\n\t\t\tcontinue;\n\t\tsolve(b);\n\t\tll sum1=fi[b].sum[0], sum2=fi[b].sum[1]+sum1;\n\t\tfi[a].sum[0]*=sum1;\n\t\tsum*=sum2;\n\t\tsum%=M;\n\t\tfi[a].sum[0]%=M;\n\t}\n\tfi[a].sum[1]=sum-fi[a].sum[0]+1;\n\tif(fi[a].sum[1]<=0)\n\t\tfi[a].sum[1]+=M;\n\treturn fi[a].sum[0]+fi[a].sum[1];\n}\n\nint main()\n{\n\tcin >> n >> m;\n\tFor(i,1,n)\n\t{\n\t\tfi[i].fa=i;\n\t\tfi[i].sum[0] = fi[i].sum[1]=1;\n\t}\n\tFor(i,1,m)\n\t{\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tadd(a,b);\n\t}\n\tll ans = 1;\n\tFor(i,1,n)\n\t\tif(fi[i].fa==i)\n\t\t{\n\t\t\tans *=solve(i);\n\t\t\tans %= M;\n\t\t};\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define M 1000000007\nusing namespace std;\ntypedef long long ll;\nvector <int> G[1001];\nint n,m,used[1001],par[1001],no[1001];\n\nint dfs(int pos){\n  int res=-1;\n  if(used[pos]>=2)return pos;\n  used[pos]++;\n  for(int i=0,a;i<G[pos].size();i++)res=max(res,dfs(G[pos][i]));\n  return res;\n}\n\nvoid calc(int pos,int dep){\n  if(!G[pos].size()){\n    if(used[pos]==1)used[pos]=dep;\n    else used[pos]=(used[pos]-1)*(dep-1)+1;\n  }\n  else calc(G[pos][0],dep+1);\n}\n\nvoid mk_node(){\n  for(int i=0,res;i<n;i++){\n    if(used[i]||par[i]||(res=dfs(i))==-1)continue;\n    for(int j=0;j<n;j++)\n      if(used[j]/2)G[j].clear(),no[j]=(res!=j);\n      else if(G[j].size()&&used[G[j][0]]/2&&j!=res)G[j][0]=res;\n  }\n}\n\n\nint main(){\n  cin>>n>>m;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;\n    G[a-1].push_back(b-1);\n    par[b-1]=1;\n  }\n\n  mk_node();\n  memset(par,0,sizeof(par));\n  mk_node();\n\n  for(int i=0;i<n;i++){\n    par[i]+=no[i];\n    if(G[i].size())par[G[i][0]]=1;\n  }\n  \n  for(int i=0;i<n;i++) used[i]=1;\n  for(int i=0;i<n;i++)if(!par[i])calc(i,2);\n\n  ll ans=1;\n  for(int i=0;i<n;i++) ans=ans*used[i]%M;\n  cout <<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Package: StandardCodeLibrary.Core\n * */\n//蠑戊ソ帛クク逕ィ逧?、エ譁?サカ蟷カ菴ソ逕ィstd蜷榊ュ礼ゥコ髣エ\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <utility>\n#include <vector>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <climits>\nusing namespace std;\n\n//逕ィ莠主?蟆台サ」遐??逧?ョ?#define lp for(;;)\n#define repf(i,a,b) for (int i=(a);i<(b);++i)\n#define rrepf(i,a,b) for (int i=(a)-1;i>=(b);--i)\n#define rep(i,n) repf(i,0,n)\n#define rrep(i,n) rrepf(i,n,0)\n#define ft(i,a,b) for (int i=(a);i<=(b);++i)\n#define fdt(i,a,b) for (int i=(a);i>=(b);--i)\n#define for_nonempty_subsets(subset,set) for (int subset=set;subset;subset=(subset-1)&(set))\n#define for_in_charset(i,charset) for (cstr i=(charset);*i;i++)\n#define whl while\n#define rtn return\n#define fl(x,y) memset((x),char(y),sizeof(x))\n#define clr(x) fl(x,char(0))\n#define cpy(x,y) memcpy(x,y,sizeof(x))\n#define sf scanf\n#define pf printf\n#define vec vector\n#define pr pair\n#define que queue\n#define prq priority_queue\n#define itr iterator\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define ins insert\n#define ers erase\n#define lb lower_bound\n#define ub upper_bound\n#define rnk order_of_key\n#define sel find_by_order\n#define sz(x) (int((x).size()))\n#define all(x) (x).begin(),(x).end()\n#define srt(x) sort(all(x))\n#define uniq(x) srt(x),(x).erase(unique(all(x)),(x).end())\n#define rev(x) reverse(all(x))\n#define shf(x) random_shuffle(all(x))\n#define nxtp(x) next_permutation(all(x))\n\n//隹?ッ慕嶌蜈ウ逧?ョ?#ifndef DEBUG\n#define prt(x) (cerr)\n#define asrtWA(s) do if(!(s))exit(0);whl(0)\n#define asrtTLE(s) do if(!(s))whl(1);whl(0)\n#define asrtMLE(s) do if(!(s))whl(new int);whl(0)\n#define asrtOLE(s) do if(!(s))whl(1)puts(\"OLE\");whl(0)\n#define asrtRE(s) do if(!(s))*(int*)0=0;whl(0)\n#define runtime() (cerr)\n#define input(in) freopen(in,\"r\",stdin)\n#define output(out) freopen(out,\"w\",stdout)\n#else\n#define prt(x) cerr<<\"隨ャ\"<<__LINE__<<\"陦圭t: \"<<#x\"\\t=\"<<(x)<<endl\n#define asrtWA(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtTLE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtMLE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtOLE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtRE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define runtime() cerr<<\"Used: \"<<db(clock())/CLOCKS_PER_SEC<<\"s\"<<endl\n#define input(in)\n#define output(out)\n#endif\n\n//蟶ク逕ィ謨ー謐ョ邀サ蝙?typedef long long lli;\ntypedef double db;\ntypedef const char* cstr;\ntypedef string str;\ntypedef vec<int> vi;\ntypedef vec<vi> vvi;\ntypedef vec<bool> vb;\ntypedef vec<vb> vvb;\ntypedef vec<str> vs;\ntypedef pr<int,int> pii;\ntypedef pr<lli,lli> pll;\ntypedef pr<db,db> pdd;\ntypedef map<int,int> mii;\ntypedef map<str,int> msi;\ntypedef map<char,int> mci;\ntypedef set<int> si;\ntypedef set<str> ss;\ntypedef que<int> qi;\ntypedef vec<pii> vpii;\ntypedef vec<pdd> vpdd;\n\n//蟶ク逕ィ蟶ク驥?int逧?怙螟ァ蛟シ;lli逧?怙螟ァ蛟シ;db逧?ッッ蟾ョ逶ク蜈ウ蟶ク謨ー;谺ァ諡牙クク謨ー;蝨?捉邇?遘サ蜉ィ蜷鷹?;蜿匁ィ。菴ソ逕ィ逧?勁謨ー\nint oo=(~0u)>>1;\nlli ooll=(~0ull)>>1;\ndb inf=1e+10;\ndb eps=1e-10;\ndb gam=0.5772156649015328606;\ndb pi=acos(-1.0);\nint dx[]={1,0,-1,0,1,-1,-1,1,0};\nint dy[]={0,1,0,-1,1,1,-1,-1,0};\nint MOD=1000000007;\n\n//蟶ク逕ィ蜃ス謨ー:譛?、ァ譛?ー丞?譖エ譁ー;謨ー蟄ヲ逶ク蜈ウ蜃ス謨ー;霎灘?蜥瑚セ灘?;譬醍憾謨ー扈?蟷カ譟・髮?蜿ッ蜷亥ケカ蝣?\ntemplate<typename type>inline bool cmax(type& a,const type& b){rtn a<b?a=b,true:false;}\ntemplate<typename type>inline bool cmin(type& a,const type& b){rtn b<a?a=b,true:false;}\ntemplate<typename type>inline type sqr(const type& x){rtn x*x;}\ntemplate<typename type>inline type mod(const type& x){rtn x%MOD;}\ninline int sgn(const db& x){rtn (x>+eps)-(x<-eps);}\ninline int dbcmp(const db& a,const db& b){rtn sgn(a-b);}\ntemplate<typename type>inline pr<type,type> operator-(const pr<type,type>& x){rtn mp(-x.x,-x.y);}\ntemplate<typename type>inline pr<type,type> operator+(const pr<type,type>& a,const pr<type,type>& b){rtn mp(a.x+b.x,a.y+b.y);}\ntemplate<typename type>inline pr<type,type> operator-(const pr<type,type>& a,const pr<type,type>& b){rtn mp(a.x-b.x,a.y-b.y);}\ntemplate<typename type>inline pr<type,type> operator*(const pr<type,type>& a,const type& b){rtn mp(a.x*b,a.y*b);}\ntemplate<typename type>inline pr<type,type> operator/(const pr<type,type>& a,const type& b){rtn mp(a.x/b,a.y/b);}\ntemplate<typename type>inline pr<type,type>& operator-=(pr<type,type>& a,const pr<type,type>& b){rtn a=a-b;}\ntemplate<typename type>inline pr<type,type>& operator+=(pr<type,type>& a,const pr<type,type>& b){rtn a=a+b;}\ntemplate<typename type>inline pr<type,type>& operator*=(pr<type,type>& a,const type& b){rtn a=a*b;}\ntemplate<typename type>inline pr<type,type>& operator/=(pr<type,type>& a,const type& b){rtn a=a/b;}\ntemplate<typename type>inline type cross(const pr<type,type>& a,const pr<type,type>& b){rtn a.x*b.y-a.y*b.x;}\ntemplate<typename type>inline type dot(const pr<type,type>& a,const pr<type,type>& b){rtn a.x*b.x+a.y*b.y;}\ntemplate<typename type>inline type gcd(type a,type b){if(b)whl((a%=b)&&(b%=a));rtn a+b;}\ntemplate<typename type>inline type lcm(type a,type b){rtn a*b/gcd(a,b);}\ntemplate<typename istream,typename first_type,typename second_type>inline istream& operator>>(istream& cin,pr<first_type,second_type>& x){rtn cin>>x.x>>x.y;}\ntemplate<typename ostream,typename first_type,typename second_type>inline ostream& operator<<(ostream& cout,const pr<first_type,second_type>& x){rtn cout<<x.x<<\" \"<<x.y;}\ntemplate<typename istream,typename type>inline istream& operator>>(istream& cin,vec<type>& x){rep(i,sz(x))cin>>x[i];rtn cin;}\ntemplate<typename ostream,typename type>inline ostream& operator<<(ostream& cout,const vec<type>& x){rep(i,sz(x))cout<<x[i]<<(i+1==sz(x)?\"\":\" \");rtn cout;}\ninline ostream& pdb(int prcs,db x){rtn cout<<setprecision(prcs)<<fixed<<(sgn(x)?(x):0);}\ntemplate<typename type>inline void bit_inc(vec<type>& st,int x,type inc){whl(x<sz(st))st[x]+=inc,x|=x+1;}\ntemplate<typename type>inline type bit_sum(const vec<type>& st,int x){type s=0;whl(x>=0)s+=st[x],x=(x&(x+1))-1;rtn s;}\ntemplate<typename type>inline type bit_kth(const vec<type>& st,int k){int x=0,y=0,z=0;whl((1<<(++y))<=sz(st));fdt(i,y-1,0){if((x+=1<<i)>sz(st)||z+st[x-1]>k)x-=1<<i;else z+=st[x-1];}rtn x;}\ninline void make_set(vi& st){rep(i,sz(st))st[i]=i;}\ninline int find_set(vi& st,int x){int y=x,z;whl(y!=st[y])y=st[y];whl(x!=st[x])z=st[x],st[x]=y,x=z;rtn y;}\ninline bool union_set(vi& st,int a,int b){a=find_set(st,a),b=find_set(st,b);rtn a!=b?st[a]=b,true:false;}\ntemplate<typename type>inline void merge(type& a,type& b){if(sz(a)<sz(b))swap(a,b);whl(sz(b))a.ins(*b.begin()),b.ers(b.begin());}\n\n//蛻晏ァ句喧\nstruct Initializer\n{\n#ifndef DEBUG\n\tInitializer(){ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);}\n#else\n\t~Initializer(){runtime();}\n#endif\n}initializer;\n\n//髱樊?蜃?#define feach(e,s) for (__typeof__((s).begin()) e=(s).begin();e!=(s).end();++e)\n#include <ext/rope>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\nusing __gnu_cxx::rope;\ntemplate<typename key,typename value>class ext_map:public __gnu_pbds::tree<key,value,less<key>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>{};\n#define ctz __builtin_ctz\n#define clz __builtin_clz\n#define bc __builtin_popcount\n\nconst int MAXV=1000;\nconst int MAXE=1000000;\ntypedef struct struct_edge* edge;\nstruct struct_edge{int v;edge n;}pool[MAXE];\nedge top;\nint V;\nedge adj[MAXV];\nvoid build_graph(int v)\n{\n\ttop=pool,clr(adj);\n\tV=v;//轤ケ謨ー\n\t//add_edge(u,v);\n}\nvoid add_edge(int u,int v)\n{\n\ttop->v=v,top->n=adj[u],adj[u]=top++;\n}\nint ord;\nint dfn[MAXV];\nint low[MAXV];\nint stks;\nint stk[MAXV];\nbool ins[MAXV];\nint cnt;\nint bl[MAXV];\nvoid dfs(int u)\n{\n\tdfn[u]=low[u]=++ord;\n\tins[stk[stks++]=u]=true;\n\tfor (edge i=adj[u];i;i=i->n)\n\t\tif (!dfn[i->v]) dfs(i->v),cmin(low[u],low[i->v]);\n\t\telse if (ins[i->v]) cmin(low[u],dfn[i->v]);\n\tif (dfn[u]==low[u])\n\t{\n\t\tint v;\n\t\tdo ins[v=stk[--stks]]=false,bl[v]=cnt;\n\t\twhl(v!=u);\n\t\tcnt++;\n\t}\n}\nvoid tarjan()\n{\n\tord=0,clr(dfn),cnt=0;\n\trep(i,V) if (!dfn[i]) dfs(i);\n}\n\nint main()\n{\n\tint n,m;\n\tcin>>n>>m;\n\tbuild_graph(n);\n\trep(i,m)\n\t{\n\t\tint s,d;\n\t\tcin>>s>>d,--s,--d;\n\t\tadd_edge(s,d);\n\t}\n\ttarjan();\n\tvvi adj(cnt);\n\tvvi radj(cnt);\n\trep(i,V) for (edge e=::adj[i];e;e=e->n) if (bl[i]!=bl[e->v]) adj[bl[i]].pb(bl[e->v]);\n\trep(i,cnt) uniq(adj[i]);\n\tvi id(cnt);\n\trep(i,cnt) rep(j,sz(adj[i])) id[adj[i][j]]++;\n\tqi q;\n\tvec<pll> f(n);\n\trep(i,cnt) if (id[i]==0) q.push(i),f[i]=mp(1,1);\n\tlli ans=1;\n\twhl(sz(q))\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tif (!sz(adj[u])) ans=mod(ans*(f[u].x+f[u].y));\n\t\trep(i,sz(adj[u]))\n\t\t{\n\t\t\tint v=adj[u][i];\n\t\t\tradj[v].pb(u);\n\t\t\tif ((--id[v])==0)\n\t\t\t{\n\t\t\t\tq.push(v);\n\t\t\t\tf[v]=mp(1,1);\n\t\t\t\trep(j,sz(radj[v]))\n\t\t\t\t{\n\t\t\t\t\tint w=radj[v][j];\n\t\t\t\t\tf[v].x*=f[w].x+f[w].y;\n\t\t\t\t\tf[v].y*=f[w].y;\n\t\t\t\t\tf[v].x%=MOD;\n\t\t\t\t\tf[v].y%=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 2050\n#define int long long\nint MOD=1000000007;\nint V;\nvector<int> G[MAX_V],rG[MAX_V],nG[MAX_V],vs,kv[MAX_V];\nbool used[MAX_V];\nint cmp[MAX_V];\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\nvoid dfs(int v){\n  used[v]=1;\n  for(int i=0;i<(int)G[v].size();i++){\n    if(!used[G[v][i]]) dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\nvoid rdfs(int v,int k){\n  used[v]=1;\n  cmp[v]=k;\n  kv[k].push_back(v);\n  for(int i=0;i<(int)rG[v].size();i++){\n    if(!used[rG[v][i]]) rdfs(rG[v][i],k);\n  }\n}\nint dfs2(int v,int f){\n  int res=0,tmp=1;\n  if(!f){\n    for(int i=0;i<(int)nG[v].size();i++) tmp=(tmp*dfs2(nG[v][i],0))%MOD;\n    res=tmp;tmp=1;\n  }\n  for(int i=0;i<(int)nG[v].size();i++) tmp=(tmp*dfs2(nG[v][i],1))%MOD;\n  //cout<<v<<\":\"<<f<<\"/\"<<res+tmp<<endl;\n  return (res+tmp)%MOD;\n}\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++){\n    if(!used[v]) dfs(v);\n  }\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!used[vs[i]]) rdfs(vs[i],k++);\n  }\n  memset(used,0,sizeof(used));\n  int ans=1;\n  for(int i=0;i<k;i++){\n    for(int j=0;j<(int)kv[i].size();j++){\n      for(int l=0;l<(int)rG[kv[i][j]].size();l++){\n\tif(i!=cmp[rG[kv[i][j]][l]]){\n\t  nG[i].push_back(cmp[rG[kv[i][j]][l]]);\n\t  used[cmp[rG[kv[i][j]][l]]]=1;\n\t}\n      }\n    }\n  }\n  for(int i=0;i<V;i++){\n    if(used[cmp[i]]) continue;\n    //cout<<i<<\":\"<<ans<<endl;\n    used[cmp[i]]=1;\n    ans=(ans*dfs2(cmp[i],0))%MOD;\n  }\n  return ans;\n}\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  V=n;\n  for(int i=0;i<m;i++){\n    int s,d;\n    cin>>s>>d;\n    add_edge(s-1,d-1);\n  }\n  cout<<scc()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <cstring>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\n#define MAX_V 1024\n\nvector<int> g[MAX_V], rg[MAX_V], vs;\nbool used[MAX_V];\nint cmp[MAX_V];\n\nvoid add_edge(int from, int to) {\n  g[from].push_back(to);\n  rg[to].push_back(from);\n}\n\nvoid dfs(int v) {\n  used[v] = true;\n  for (int i : g[v]) if (!used[i]) dfs(i);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v, int k) {\n  used[v] = true; cmp[v] = k;\n  for (int i : rg[v]) if (!used[i]) rdfs(i, k);\n}\n\nint scc(int V) {\n  memset(used, 0, sizeof(used));\n  vs.clear();\n  REP(v, V) if (!used[v]) dfs(v);\n  memset(used, 0, sizeof(used));\n  reverse(ALL(vs));\n  int k = 0;\n  for (int i : vs) if (!used[i]) rdfs(i, k++);\n  return k;\n}\n\nvector<vector<int>> buildGraph(int V, int K) {\n  vector<set<int>> s(K);\n  vector<vector<int>> res(K,vector<int>(K));\n  REP(i,V) for (int j : g[i]) s[cmp[i]].insert(cmp[j]);\n  REP(i,K) for (int j : s[i]) ++res[i][j];\n  return res;\n}\n\nvoid dfs2(vector<vector<int>>& dag, int i, vector<int64_t>& dp, vector<bool>& vis) {\n  int n=dag.size();\n  vis[i] = true;\n  REP(j,n) {\n    if (dag[j][i]==0)continue;\n    if (j==i) continue;\n    if (!vis[j])\n      dfs2(dag, j, dp, vis);\n    dp[i] *= dp[j];\n    dp[i] %= 1000000007;\n  }\n  ++dp[i];\n  dp[i] %= 1000000007;\n}\n\nint main() {\n  int n,m;\n  cin>>n>>m;\n  REP(i,m){\n    int s,d;\n    cin>>s>>d;\n    --s;--d;\n    add_edge(s,d);\n  }\n  int k = scc(n);\n  auto dag = buildGraph(n, k);\n  vector<int64_t> dp(k, 1);\n  vector<bool> vis(k);\n  int64_t sum = 1;\n  REP(i,k) {\n    if(!vis[i]) {\n      bool ok = true;\n      REP(j,k){\n        if(j==i)continue;\n        if(dag[i][j] != 0){\n          ok=false;\n          break;\n        }\n      }\n      if (ok) {\n        dfs2(dag, i, dp, vis);\n        sum *= dp[i];\n        sum %= 1000000007;\n      }\n    }\n  }\n  cout<<sum<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 10000\n#define f first\n#define s second\n#define mp make_pair\n#define mod 1000000007\nusing namespace std;\n\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nbool visited[MAX_V];\nint cmp[MAX_V];\nvector<pair<int,int> > vpp;\n\nvoid add_edge(int from, int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v] = true;\n  for(int i = 0;i < G[v].size();i++){\n    if(!used[G[v][i]])dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i = 0;i < rG[v].size();i++){\n    if(!used[rG[v][i]]) rdfs(rG[v][i],k);\n  }\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v = 0;v < V;v++){\n    if(!used[v]) dfs(v);\n  }\n  memset(used,0,sizeof(used));\n  int k = 0;\n  for(int i = vs.size() - 1;i >= 0;i--){\n    if(!used[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint rec(int index,int cm){\n  int res=1;\n  int temp = vpp[index].f;\n  if(vpp[index].f==cm)return 1;\n  if(rG[vpp[index].s].size()==0)return 2;\n\n  for(int i=index;vpp[i].f==temp;i++){\n    int now = vpp[i].s;\n    for(int j=0;j<rG[now].size();j++){\n      if(!visited[rG[now][j]]){\n        visited[rG[now][j]]=true;\n        res*=rec(rG[now][j],vpp[i].f);\n        res%=mod;\n      }\n    }\n  }\n  return res+1;\n}\n\nint main()\n{\n  int a,b,m;\n\n  cin>>V>>m;\n\n  for(int i=0;i<m;i++){\n    cin>>a>>b;\n    a--;b--;\n    add_edge(a,b);\n  }\n  int sc=scc();\n\n  for(int i=0;i<V;i++){\n    vpp.push_back(mp((-1)*cmp[i],i));\n  }\n  sort(vpp.begin(),vpp.end());\n\n  int ans=1;\n  for(int i=0;i<vpp.size();i++){\n    if(!visited[i]){\n      visited[i]=true;\n      ans*=rec(i,mod);\n      ans%=mod;\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct Dscc {\npublic:\n\tpair<vector<vector<int>>,vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\t\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j:edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]){\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs,newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs2(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n\n}dscc;\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<int>>edges(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tint s, t; cin >> s >> t;\n\t\ts--; t--;\n\t\tedges[s].push_back(t);\n\t}\n\tpair<vector<vector<int>>, vector<vector<int>>> ds(dscc.get(edges));\n\tvector<vector<int>>newedges(ds.second);\n\tvector<vector<int>>revedges(newedges.size());\n\tvector<int>p_nums(newedges.size());\n\tfor (int i = 0; i < newedges.size(); ++i) {\n\t\tfor (auto j : newedges[i]) {\n\t\t\trevedges[j].push_back(i);\n\t\t\tp_nums[j]++;\n\t\t}\n\t}\n\tvector<int>anss(newedges.size());\n\tqueue<int>que;\n\tfor (int i = 0; i < newedges.size(); ++i) {\n\t\tif (p_nums[i] == 0) {\n\t\t\tque.push(i);\n\t\t}\n\t}\n\twhile (que.size()) {\n\t\t\n\t\tint atop(que.front());\n\t\tque.pop();\n\t\tif (revedges[atop].size() == 0) {\n\t\t\tanss[atop] = 2;\n\t\t}\n\t\telse {\n\t\t\tint ans = 1;\n\t\t\tfor (auto pa : revedges[atop]) {\n\t\t\t\tans += anss[pa];\n\t\t\t\t\n\t\t\t}\n\t\t\tanss[atop] = ans;\n\t\t\t\n\t\t}\n\t\tfor (auto pa : newedges[atop]) {\n\t\t\tp_nums[pa]--;\n\n\t\t\tif (!p_nums[pa])que.push(pa);\n\t\t}\n\t}\n\tMod finans = 1;\n\tfor (int i = 0; i < newedges.size(); ++i) {\n\t\tif (newedges[i].empty()) {\n\t\t\tfinans *= anss[i];\n\t\t}\n\t}\n\tcout << finans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nusing node=struct{int to;};\nusing G=vector<vector<node>>;\n\ntuple<vector<int>,G> scc(const G &graph){\n\tint n=graph.size(),k=0,m=0;\n\tvector<int> ord(n,-1),low(n),comp(n,-1),par(n);\n\tstack<int>s;\n\n\tfunction<void(int,int,int&,int&)> dfs=[&](int v,int p,int &k,int &m){\n\t\tord[v]=k++,low[v]=ord[v],par[v]=p;\n\t\ts.push(v);\n\n\t\tfor(auto &e:graph[v]){\n\t\t\tif(ord[e.to]==-1){\n\t\t\t\tdfs(e.to,v,k,m);\n\t\t\t\tchmin(low[v],low[e.to]);\n\t\t\t}else if(comp[e.to]==-1){\n\t\t\t\tchmin(low[v],ord[e.to]);\n\t\t\t}\n\t\t}\n\n\t\tif(ord[v]==low[v]){\n\t\t\twhile(1){\n\t\t\t\tint u=s.top();s.pop();\n\t\t\t\tcomp[u]=m;\n\t\t\t\tif(u==v) break;\n\t\t\t}\n\t\t\tm++;\n\t\t}\n\t};\n\n\trep(v,n) if(ord[v]==-1) dfs(v,-1,k,m);\n\tG dag(m);\n\trep(v,n) for(auto &e:graph[v]) if(comp[v]!=comp[e.to]) dag[comp[v]].push_back({comp[e.to]});\n\treturn make_tuple(comp,dag);\n}\n\nvector<int> topological_sort(const G &graph) {\n\tint n=graph.size();\n\tvector<int> order,used(n,false);\n\t\n\tfunction<void(int)> dfs=[&](int v){\n\t\tused[v]=true;\n\t\tfor(auto &e:graph[v]){\n\t\t\tif(!used[e.to])\n\t\t\t\tdfs(e.to);\n\t\t}\n\t\torder.push_back(v);\n\t};\n\n\trep(v,n) if(!used[v]) dfs(v);\n\treverse(_all(order));\n\treturn order;\n}\n\nusing ll=long long;\nconst ll mod=1000000007LL;\n\ninline ll ADD(const ll &a, const ll &b,const ll &mod) { return a+b<mod?a+b:a+b-mod;}\ninline ll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\n\nll dp[1010][2];\n\nint main(void){\n\tint n,m;\n\tcin >> n >> m;\n\n\tG graph(n);\n\trep(loop,m){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tgraph[a-1].push_back({b-1});\n\t}\n\n\tG dag;\n\tvector<int> comp,order;\n\ttie(comp,dag)=scc(graph);\n\torder=topological_sort(dag);\n\t\n\trep(v,n) dp[v][0]=dp[v][1]=1LL;\n\tll ans=1LL;\n\n\tfor(auto &v:order){\n\t\tvector<int> already(dag.size(),false);\n\t\tfor(auto &e:dag[v]){\n\t\t\tif(already[e.to]) continue;\n\t\t\talready[e.to]=true;\n\t\t\tdp[e.to][0]=MUL(dp[e.to][0],dp[v][0],mod);\n\t\t\tdp[e.to][1]=MUL(dp[e.to][1],ADD(dp[v][0],dp[v][1],mod),mod);\n\t\t}\n\t\tif(dag[v].empty()){\n\t\t\tll cur=ADD(dp[v][0],dp[v][1],mod);\n\t\t\tans=MUL(ans,cur,mod);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nconst ll MOD = 1e9+7;\n\nclass SCC {\npublic:\n    typedef int TYPE;\n    TYPE V;\n    vector<vector<TYPE>> G;\n    vector<vector<TYPE>> rG;\n    vector<vector<TYPE>> group_G;\n    vector<vector<TYPE>> group_rG;\n    vector<TYPE> group;\n    vector<TYPE> List;\n    \n    vector<int> visited;\n    int group_num;\n    \n    SCC(TYPE V) :V(V),group_num(0) {\n        G.resize(V); rG.resize(V);\n    }\n    \n    void init(TYPE V){\n        G.clear(); G.resize(V);\n        rG.clear(); rG.resize(V);\n    }\n    \n    void add_edge(TYPE u, TYPE v) {\n        G[u].emplace_back(v); rG[v].emplace_back(u);\n    }\n    \n    void dfs1(TYPE u) {\n        visited[u] = 1;\n        for (TYPE& next : G[u]){ if (visited[next] != 1) dfs1(next); }\n        List.emplace_back(u);\n    }\n    \n    void dfs2(TYPE u,TYPE group_num) {\n        visited[u] = 1; group[u] = group_num;\n        for (TYPE& next : rG[u]){ if (visited[next] != 1) dfs2(next, group_num); }\n    }\n    \n    void make_group() {\n        group.clear(); group.assign(V, -1);\n        visited.clear(); visited.assign(V, 0);\n        for (int i = 0; i < V;i++){ if (visited[i] != 1) dfs1(i); }\n        \n        reverse(List.begin(), List.end());\n        \n        visited.clear(); visited.assign(V, 0);\n        group_num = 0;\n        for (TYPE& v : List) { if (visited[v] != 1) dfs2(v, group_num++); }\n    }\n    \n    void make_group_graph(){\n        group_G.clear(); group_G.resize(group_num);\n        group_rG.clear(); group_rG.resize(group_num);\n        for(int u = 0; u < V;u++){\n            for(TYPE& v: G[u]){\n                if(!same(u,v)){\n                    group_G[group[u]].emplace_back(group[v]);\n                    group_rG[group[v]].emplace_back(group[u]);\n                }\n            }\n        }\n    }\n    \n    TYPE get_group(TYPE n){ return group[n]; }\n    bool same(TYPE u,TYPE v) {\n        return group[u] == group[v];\n    }\n    \n    vector<vector<TYPE>>& get_G() { return G; }\n    vector<vector<TYPE>>& get_rG() { return rG; }\n    vector<vector<TYPE>>& get_group_G() { return group_G; }\n    vector<vector<TYPE>>& get_group_rG() { return group_rG; }\n};\n\nll dfs(ll n,vector<vector<int>>& G){\n    ll ret = 1;\n    for(int i = 0; i < G[n].size();i++){\n        (ret *= dfs(G[n][i],G))%=MOD;\n    }\n    return (ret+1)%MOD;\n}\nll solve(){\n    ll res = 1;\n    int N,M; cin >> N >> M;\n    SCC scc(N);\n    vector<int> S(M),D(M);\n    for(int i = 0; i < M;i++){\n        cin >> S[i] >> D[i];\n        S[i]--; D[i]--;\n        scc.add_edge(S[i], D[i]);\n    }\n    scc.make_group();\n    scc.make_group_graph();\n    auto G = scc.get_group_G();\n    auto rG = scc.get_group_rG();\n    int num = scc.group_num;\n    \n    for(int i = 0; i < num; i++){\n        if(G[i].size() == 0) (res *= dfs(i,rG))%=MOD;\n    }\n\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_V = 1000;\nconst int M = 1000000007;\n\nint V, E;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\n\nvoid add_edge(int from, int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++){\n    if(!used[G[v][i]]) dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i=0;i<rG[v].size();i++){\n    if(!used[rG[v][i]]) rdfs(rG[v][i], k);\n  }\n}\n\nint scc(){\n  fill(used, used+V, false);\n  vs.clear();\n  for(int v = 0;v<V;v++){\n    if(!used[v]) dfs(v);\n  }\n  fill(used, used+V, false);\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!used[vs[i]]) rdfs(vs[i], k++);\n  }\n  return k;\n}\n\nint V2;\nvector<int> G2[MAX_V];\nint dp[MAX_V];\n\nvoid make_graph(int v){\n  //printf(\"v = %d\\n\", v);\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++){\n    int to = G[v][i];\n    if(cmp[v] != cmp[to]) G2[cmp[v]].push_back(cmp[to]);\n    if(!used[to]) make_graph(to);\n  }\n}\n\nint rec(int v){\n  used[v] = true;\n  int res = 1;\n  for(int i=0;i<G2[v].size();i++){\n    int to = G2[v][i];\n    //printf(\"v = %d, to = %d\\n\", v, to);\n    if(!used[to]){\n      if(dp[to] != -1) res = (res * dp[to]) % M;\n      else res = (res * rec(to)) % M;\n    }\n  }\n  res = (res + 1) % M;\n  dp[v] = res;\n  return res;\n}\n\nmain(){\n  cin >> V >> E;\n  for(int i=0;i<E;i++){\n    int a, b;\n    cin >> a >> b;\n    add_edge(b-1, a-1);\n  }\n  V2 = scc();\n  //for(int i=0;i<V;i++) printf(\"%d \", cmp[i]); puts(\"\");\n  for(int i=0;i<V;i++) rG[i].clear();\n  fill(used, used+V, false);\n  for(int i=0;i<V;i++) make_graph(i);\n  /*for(int i=0;i<V2;i++){\n    printf(\"i=%d:\", i);\n    for(int j=0;j<G2[i].size();j++){\n      printf(\"%d \", G2[i][j]);\n    }\n    puts(\"\");\n    }*/\n  fill(used, used+V, false);\n  fill(dp, dp+V2, -1);\n  int ans = 1;\n  for(int i=0;i<V2;i++){\n    if(!used[i]){\n      //printf(\"i = %d\\n\", i);\n      ans = (ans * rec(i)) % M;\n    }\n  }\n  //for(int i=0;i<V2;i++) printf(\"%d \", dp[i]); puts(\"\");\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Edge{\n\tint src,dst;\n\tEdge(){}\n\tEdge(int s,int d):src(s),dst(d){}\n};\ntypedef vector<vector<Edge>> Graph;\n\nvoid DFS(const Graph& g,int v,vi& vis,vi& order)\n{\n\tif(vis[v]) return;\n\tvis[v]=1;\n\tfor(auto e:g[v]) DFS(g,e.dst,vis,order);\n\torder.push_back(v);\n}\n\nvvi SCC(const Graph& g)\n{\n\tint n=g.size();\n\tvi vis(n),order;\n\trep(i,n) DFS(g,i,vis,order);\n\tGraph t(n);\n\trep(i,n) for(auto e:g[i])\n\t\tt[e.dst].emplace_back(e.dst,e.src);\n\tfill(all(vis),0);\n\tvvi res;\n\tper(i,n) if(!vis[order[i]]){\n\t\tres.resize(res.size()+1);\n\t\tDFS(t,order[i],vis,res.back());\n\t}\n\treturn res;\n}\n\nint calc(const Graph& g,int v)\n{\n\tint res=1;\n\tfor(auto e:g[v])\n\t\tres=(ll(res)*calc(g,e.dst))%MOD;\n\treturn res+1;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint u,v; cin>>u>>v; u--,v--;\n\t\t\tg[u].emplace_back(u,v);\n\t\t}\n\t\t\n\t\tvvi scc=SCC(g);\n\t\tvi f(n);\n\t\trep(i,scc.size()) rep(j,scc[i].size())\n\t\t\tf[scc[i][j]]=i;\n\t\t\n\t\tGraph g2(scc.size());\n\t\t{\n\t\t\tset<pii> ps;\n\t\t\trep(i,n) for(auto e:g[i]) if(f[e.src]!=f[e.dst])\n\t\t\t\tps.insert(mp(f[e.dst],f[e.src]));\n\t\t\tfor(auto p:ps)\n\t\t\t\tg2[p.first].emplace_back(p.first,p.second);\n\t\t}\n\t\tvi deg(g2.size()); // 入次数\n\t\trep(i,g2.size()) for(auto e:g2[i])\n\t\t\tdeg[e.dst]++;\n\t\t\n\t\tint res=1;\n\t\trep(i,g2.size()) if(deg[i]==0)\n\t\t\tres=(ll(res)*calc(g2,i))%MOD;\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\n#define CIN_ONLY if(1)\nstruct cww{cww(){\n    CIN_ONLY{\n        ios::sync_with_stdio(false);cin.tie(0);\n    }\n}}star;\n#define fin \"\\n\"\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define DEBUG if(0)\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l,T r)\n{bool a=l>r;if(a)l=r;return a;}\ntemplate <typename T>inline bool chmax(T &l,T r)\n{bool a=l<r;if(a)l=r;return a;}\ntemplate <typename T>\nistream& operator>>(istream &is,vector<T> &v){\n    for(auto &it:v)is>>it;\n    return is;\n}\ntypedef vector<int> V;\ntypedef vector<V> VV;\n//The number of outdegree of vertex in graph \"in\" is 1\nstruct sunny_graph{\n    int size;\n    VV g,in;\n    V S,R;\n    int getloop(int v){\n        return S[v];\n    }\n    int getroot(int v){\n        return R[v];\n    }\n    int dfs(int v,V& out,int id,V &loop){\n        S[v]=-2;\n        int u=out[v];\n        if(S[u]>=0){\n            S[v]=size;\n            return -1;\n        }\n        if(S[u]==-2||(u=dfs(u,out,id,loop))>=0){\n            S[v]=id;\n            R[v]=v;\n            loop.pb(v);\n            if(v==u)return -1;\n            else return u;\n        }\n        S[v]=size;\n        return -1;\n    }\n    void dfs2(int v){\n        for(auto &u:in[v]){\n            S[u]=S[v];\n            R[u]=R[v];\n            dfs2(u);\n        }            \n    }\n    sunny_graph(V out){\n        size=out.size();\n        in.resize(size);\n        S.resize(size,-1);\n        R.resize(size);\n        int id=0;\n        REP(v,size){\n            V L;\n            if(S[v]==-1)dfs(v,out,id,L);\n            if(L.size()){\n                g.pb(L);\n                id++;\n            }\n        }\n        REP(v,size)if(S[v]==size)in[out[v]].pb(v);\n        for(auto &s:g)for(auto &v:s)dfs2(v);\n    }\n};\nconst int mod=1e9+7;\nLL f(int v,VV &g){\n    LL res=1;\n    for(auto &u:g[v]){\n        res*=f(u,g);\n        res%=mod;\n    }\n    return (res+1)%mod;\n\n}\nint N,M;\nint main(){\n    cin>>N>>M;\n    V a(N);\n    REP(i,N)a[i]=i;\n    REP(i,M){\n        int x,y;\n        cin>>x>>y;\n        a[x-1]=y-1;\n    }\n    sunny_graph sg(a);\n    LL ans=1;\n    for(auto &it:sg.g){\n        LL res=1;\n        for(auto &v:it)\n            for(auto &u:sg.in[v])\n                (res*=f(u,sg.in))%=mod;\n        ans*=(res+1)%mod;\n        ans%=mod;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll M=1000000007;\n\nll dfs(int u,const vector<int> *T){\n\tif(T[u].empty()) return 2;\n\tll res=1;\n\trep(i,T[u].size()){\n\t\tint v=T[u][i];\n\t\tres=res*dfs(v,T)%M;\n\t}\n\treturn (res+1)%M;\n}\n\n// ツ出ツ篠淞青板つェツ債つ々 1 ツづ?つ「ツつ、ツ青ァツ姪アツつゥツづァ, ツ連ツ個仰青ャツ閉ェツづ債δ仰ーツプツづ可姪伉つェツつュツづ?づつつ「ツつスツ形ツづ可づ按づゥ\n// ツつアツづ個連ツ個仰青ャツ閉ェツづ可づつつ「ツづ?づ個嘉ーツづーツ仰?づ淞づゥ\nll solve(int n,const int *G){\n\tvector<int> G2[1000]; // G ツづ個陛督づ個古シツつォツづーツ逆ツ転ツつオツつスツグツδ可フ\n\trep(u,n) if(G[u]!=-1) G2[G[u]].push_back(u);\n\n\t// ツδ仰ーツプツ個淞出\n\trep(u,n){\n\t\tint v=u;\n\t\tbool vis[1000]={};\n\t\twhile(G[v]!=-1 && !vis[v]){\n\t\t\tvis[v]=true;\n\t\t\tv=G[v];\n\t\t}\n\t\tif(v==u){ // ツδ仰ーツプorツ債ェツつェツ個ゥツづつつゥツづ?つス\n\t\t\tll res=1;\n\t\t\tint v=u;\n\t\t\tdo{\n\t\t\t\t// ツδ仰ーツプツ湘」ツづ個各ツ陳クツ点ツづーツ債ェツづ?つキツづゥツ姪伉づ可づつつ「ツづ?督堋つヲツづーツ仰?づ淞づ? ツつサツづェツづァツづーツつゥツつッツつ?づュツつケツづゥ\n\t\t\t\trep(i,G2[v].size()){\n\t\t\t\t\tint w=G2[v][i];\n\t\t\t\t\tif(!vis[w]) res=res*dfs(w,G2)%M;\n\t\t\t\t}\n\t\t\t\tv=G[v];\n\t\t\t}while(v!=u && v!=-1);\n\t\t\treturn (res+1)%M; // ツづ?づェツづ?選ツづ篠づ按つ「ツづ?つ「ツつ、ツ嘉ーツつェツつ?づゥツづ個づ?+1\n\t\t}\n\t}\n\tfor(;;);\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tint to[1000];\n\trep(u,n) to[u]=-1;\n\trep(i,m){\n\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\tto[u]=v;\n\t}\n\tvector<int> G[1000]; // ツ鳴ウツ古シツグツδ可フ\n\trep(u,n) if(to[u]!=-1) {\n\t\tint v=to[u];\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\n\tll ans=1;\n\tbool vis[1000]={};\n\trep(u,n) if(!vis[u]) {\n\t\tvis[u]=true;\n\n\t\tvector<int> cc;\n\t\tqueue<int> Q; Q.push(u);\n\t\twhile(!Q.empty()){ // ツ偲」ツ連ツ個仰青ャツ閉ェツつイツづ?づ可陳イツづ猟づゥ\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\tcc.push_back(u);\n\t\t\trep(i,G[u].size()){\n\t\t\t\tint v=G[u][i];\n\t\t\t\tif(!vis[v]) vis[v]=true, Q.push(v);\n\t\t\t}\n\t\t}\n\n\t\tint N=cc.size();\n\t\tint D[1000]; // ツ偲」ツ連ツ個仰づ按有ツ古シツグツδ可フ\n\t\trep(i,N) D[i]=-1;\n\t\trep(i,N) rep(j,N) {\n\t\t\tint u=cc[i],v=cc[j];\n\t\t\tif(to[u]==v) D[i]=j;\n\t\t}\n\t\tans=ans*solve(N,D)%M;\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing graph = std::vector<vector<int>>;\n\nusing ll = long long;\nconstexpr ll MOD = 1e9+7;\n\nvoid add_edge(graph& g, int from, int to) {\n    g[from].push_back(to);\n}\n\nint scc(graph& g, std::vector<int>& cmp) {\n    int V = g.size();\n    std::vector<vector<int>> rg(V);\n    std::vector<bool> used(V, false);\n    std::vector<int> vs;\n    cmp.resize(V);\n    for(int i=0; i<V; ++i) {\n        for(auto to : g[i]) {\n            rg[to].push_back(i);\n        }\n    }\n    std::function<void(int)> dfs = [&g, &vs, &used, &dfs](int v) {\n        used[v] = true;\n        for(auto i : g[v]) {\n            if(!used[i]) {\n                dfs(i);\n            }\n        }\n        vs.push_back(v);\n    };\n    std::function<void(int, int)> rdfs = [&rg, &cmp, &used, &rdfs](int v, int k) {\n        used[v] = true;\n        cmp[v] = k;\n        for(int i : rg[v]) {\n            if(!used[i]) {\n                rdfs(i, k);\n            }\n        }\n    };\n    for(int v=0; v<V; ++v) {\n        if(!used[v]) {\n            dfs(v);\n        }\n    }\n    std::fill(used.begin(), used.end(), false);\n    int k = 0;\n    for(int i=vs.size()-1; i>=0; --i) {\n        if(!used[vs[i]]) {\n            rdfs(vs[i], k++);\n        }\n    }\n    return k;\n}\n\nvector<vector<int>> build_graph(graph const& g, vector<int> const& cmp, int K) {\n    int V = g.size();\n    std::vector<std::set<int>> s(K);\n    std::vector<std::vector<int>> res(K);\n    for(int i=0; i<V; ++i) {\n        for(auto to : g[i]) {\n            s[cmp[i]].insert(cmp[to]);\n        }\n    }\n    for(int i=0; i<K; ++i) {\n        for(auto j : s[i]) {\n            if(i != j) {\n                res[i].push_back(j);\n            }\n        }\n    }\n    return res;\n}\n\n\nll solve(int v, graph& g) {\n    if(g[v].size() == 0) {\n        return 2;\n    }\n    ll res = 1;\n    for(auto to : g[v]) {\n        res = (res*solve(to, g)) % MOD;\n    }\n    res += 1;\n    return res;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    graph g(N);\n    for(int i=0; i<M; ++i) {\n        int s, d;\n        cin >> s >> d;\n        s--; d--;\n        add_edge(g, s, d);\n    }\n    vector<int> cmp;\n    int K = scc(g, cmp);\n    g = build_graph(g, cmp, K);\n    graph rg(K);\n    for(int i=0; i<g.size(); ++i) {\n        for(int j=0; j<g[i].size(); ++j) {\n            rg[g[i][j]].push_back(i);\n        }\n    }\n    ll res = 1;\n    for(int i=0; i<K; ++i) {\n        if(g[i].size() == 0) {\n            res = (res*solve(i, rg)) % MOD;\n        }\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1000000007;\n\ntypedef VVI Graph;\n\nvoid visit(const Graph &g, int v, vector< vector<int> >& scc,\n\t\t   stack<int> &S, vector<bool> &inS,\n\t\t   vector<int> &low, vector<int> &num, int& time){\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  for(int w: g[v]) {\n    if (num[w] == 0) {\n      visit(g, w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\nvoid SCC(const Graph& g,\n\t\t vector< vector<int> >& scc) {\n  const int n = g.size();\n  vector<int> num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  REP(u, n) if (num[u] == 0)\n    visit(g, u, scc, S, inS, low, num, time);\n}\n\nLL dp[2][1010];\nLL dfs(int i, const VVI& G){\n  if(dp[1][i] >= 0) return (dp[0][i] + dp[1][i])%MOD;\n  dp[0][i] = dp[1][i] = 1;\n  for(int from: G[i]){\n\tdp[1][i] *= dfs(from, G);\n\tdp[1][i] %= MOD;\n\tdp[0][i] *= dp[0][from];\n\tdp[0][i] %= MOD;\n  }\n  return (dp[0][i] + dp[1][i]) % MOD;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M;\n  cin >> N >> M;\n  Graph G(N);\n  REP(i,M){\n\tint s, d; cin >> s >> d;\n\t--s, --d;\n\tG[s].PB(d);\n  }\n\n  VVI scc;\n  SCC(G, scc);\n\n  VI tab(N);\n  REP(i,SZ(scc))\n\tfor(int x: scc[i])\n\t  tab[x] = i;\n\n  vector<set<int>> mem(SZ(scc));\n  REP(i,N)\n\tfor(int x: G[i])\n\t  mem[tab[i]].insert(tab[x]);\n\n  N = SZ(scc);\n  VVI G_(N);\n  REP(i,N){\n\tfor(int x: mem[i])\n\t  if(x != i)\n\t\tG_[i].PB(x);\n  }\n\n  VVI in(N);\n  REP(i,N){\n\tfor(int to: G_[i]){\n\t  in[to].PB(i);\n\t}\n  }\n  \n  fill((LL*)dp, (LL*)dp+2*1010, -1);\n  LL ans = 1;\n  REP(i,N)\n\tif(G_[i].empty()){\n\t  ans *= dfs(i, in);\n\t  ans %= MOD;\n\t}\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define MAX (1001)\n#define MOD (1000000007LL)\n\nint V;\nvector<int> G[MAX];\nvector<int> rG[MAX];\nvector<int> nG[MAX];//?????£???????§£????????£???????????°????????°?????? \nvector<int> nrG[MAX];\nvector<int> vs;\nbool used[MAX];\nint cmp[MAX]; //?±????????????£????????????????????????????????????\n \nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n \nvoid dfs(int v){\n  used[v] = true;\n  for(int i = 0 ; i < G[v].size() ; i++){\n    if(!used[G[v][i]]) dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\n \nvoid rdfs(int v,int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i = 0 ; i < rG[v].size() ; i++){\n    if(!used[rG[v][i]]) rdfs(rG[v][i],k);\n  }\n}\n \nint scc(){ //?????£?????????????§£????????????\n  memset(used, 0, sizeof(used));\n  vs.clear();\n  for(int v = 0 ; v < V ; v++){\n    if(!used[v]) dfs(v);\n  }   \n  memset(used, 0, sizeof(used));\n  int k = 1;\n  for(int i = vs.size() - 1 ; i >= 0 ; i--){\n    if(!used[vs[i]]) rdfs(vs[i],k++);\n  }\n\n  for(int i=0;i<k;i++){\n    int v = cmp[i];\n    for(int j=0;j<(int)G[i].size();j++){\n      int to = cmp[G[i][j]];\n      if( to != v ) {\n\tnG[v].push_back(to);\n\tnrG[to].push_back(v);\n      }\n    }\n  }\n  return k;\n}\n\nvoid rdfs2(int id){\n  if( used[id] ) return;\n  used[id] = true;\n  for(int i=0;i<(int)nrG[id].size();i++)\n    rdfs2(nrG[id][i]);\n}\n\t\t \n\nint M;\nll dp[MAX];\nll solve(int id){\n  if( used[id] ) return dp[id];\n  used[id] = true;\n\n  ll ret = 1;\n  for(int i=0;i<(int)nG[id].size();i++){\n    int to = nG[id][i];\n    ret *= solve( to );\n    ret %= MOD;\n  }\n  return ret + 1LL;\n}\n\n\nint main(){\n\n  cin >> V >> M;\n  for(int i=0;i<M;i++){\n    int s,d;\n    cin >> s >> d;\n    --s; --d;\n    add_edge(d,s);\n  }\n\n  int K = scc();\n  for(int i=1;i<K;i++){\n    if( nrG[i].empty() ) {\n      nrG[i].push_back(0);\n      nG[0].push_back(i);\n    }\n  }\n  ll res = 0;\n  dp[0] = 1LL;\n  for(int i=0;i<K;i++){\n    memset(used,0,sizeof(used));\n    rdfs2(i);\n    for(int j=0;j<K;j++)\n      if( used[j] ) \n\tfor(int k=0;k<(int)nG[j].size();k++)\n\t  if( !used[nG[j][k]] ) dp[nG[j][k]] = (dp[nG[j][k]] + dp[i])%MOD;\n    res += dp[i];\n    res %= MOD;\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define MAX (1001)\n#define MOD (1000000007LL)\n\nint V;\nvector<int> G[MAX];\nvector<int> rG[MAX];\nvector<int> nG[MAX];//?????£???????§£????????£???????????°????????°?????? \nvector<int> nrG[MAX];\nvector<int> vs;\nbool used[MAX];\nint cmp[MAX]; //?±????????????£????????????????????????????????????\n \nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n \nvoid dfs(int v){\n  used[v] = true;\n  for(int i = 0 ; i < G[v].size() ; i++){\n    if(!used[G[v][i]]) dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\n \nvoid rdfs(int v,int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i = 0 ; i < rG[v].size() ; i++){\n    if(!used[rG[v][i]]) rdfs(rG[v][i],k);\n  }\n}\n \nint scc(){ //?????£?????????????§£????????????\n  memset(used, 0, sizeof(used));\n  vs.clear();\n  for(int v = 0 ; v < V ; v++){\n    if(!used[v]) dfs(v);\n  }   \n  memset(used, 0, sizeof(used));\n  int k = 1;\n  for(int i = vs.size() - 1 ; i >= 0 ; i--){\n    if(!used[vs[i]]) rdfs(vs[i],k++);\n  }\n\n  for(int i=0;i<k;i++){\n    int v = cmp[i];\n    for(int j=0;j<(int)G[i].size();j++){\n      int to = cmp[G[i][j]];\n      if( to != v ) {\n\tnG[v].push_back(to);\n\tnrG[to].push_back(v);\n      }\n    }\n  }\n  return k;\n}\n\nvoid rdfs2(int id,bool *flag){\n  if( flag[id] ) return;\n  flag[id] = true;\n  for(int i=0;i<(int)nrG[id].size();i++)\n    rdfs2(nrG[id][i],flag);\n}\n\t\t \n\nint M;\nll dp[MAX];\nll solve(int id){\n  if( used[id] ) return dp[id];\n  used[id] = true;\n\n  ll ret = 1;\n  for(int i=0;i<(int)nG[id].size();i++){\n    int to = nG[id][i];\n    ret *= solve( to );\n    ret %= MOD;\n  }\n  return ret + 1LL;\n}\n\nbool ch[MAX];\n\nint main(){\n\n  cin >> V >> M;\n  for(int i=0;i<M;i++){\n    int s,d;\n    cin >> s >> d;\n    --s; --d;\n    add_edge(s,d);\n  }\n\n  int K = scc();\n  for(int i=1;i<K;i++){\n    if( nrG[i].empty() ) {\n      nrG[i].push_back(0);\n      nG[0].push_back(i);\n    }\n    if( nG[i].empty() ){\n      nG[i].push_back(K);\n      nrG[K].push_back(i);\n    }\n    dp[i] = 1LL;\n  }\n  for(int i=1;i<K;i++){\n\n    /*   cout << \"vertex : \" << i << \" dp = \" << dp[i] << endl;\n    for(int j=0;j<(int)nG[i].size();j++)\n      cout << \" -> \" << nG[i][j] << endl;;\n    */\n    memset(used,0,sizeof(used));\n    memset(ch,0,sizeof(ch));\n    rdfs2(i,used);\n    for(int j=0;j<(int)nG[i].size();j++) rdfs2(nG[i][j],ch);\n    for(int j=0;j<K;j++)\n      if( used[j] && ch[j] ) \n\tfor(int k=0;k<(int)nG[j].size();k++)\n\t  if( !used[nG[j][k]] && ch[nG[j][k]]  ) dp[nG[j][k]] = (dp[nG[j][k]] + dp[i])%MOD;\n  }\n  cout << (dp[K]+1LL)%MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define MAX_V 100000\n#define N MAX_V\nusing namespace std;\ntypedef long long ll;\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\nint n,m;\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[G[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  \n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\n\nvoid mk_G(){\n  int k=scc();\n  vector <int> tmp[N],rtmp[N];\n  for(int i=0;i<n;i++){\n    for(int j=0;j<G[i].size();j++)\n      if(cmp[i]!=cmp[G[i][j]]) tmp[cmp[i]].push_back(cmp[G[i][j]]);\n    for(int j=0;j<rG[i].size();j++)\n      if(cmp[i]!=cmp[rG[i][j]]) rtmp[cmp[i]].push_back(cmp[rG[i][j]]);\n    G[i].clear();\n    rG[i].clear();\n  }\n  n=k;\n  for(int i=0;i<k;i++) G[i]=tmp[i],rG[i]=rtmp[i];\n}\n \nll calc(int pos){\n  if(used[pos]) return 1;\n  used[pos]=1;\n  ll res=1;\n  for(int i=0;i<rG[pos].size();i++)res=res*calc(rG[pos][i])%mod;\n  return (res+1)%mod;\n}\n \n\nint main(){\n  cin>>n>>m;\n  V=n;\n  for(int i=0,a,b;i<m;i++)cin>>a>>b,add_edge(a-1,b-1);\n  mk_G();\n  ll ans=1;\n  memset(used,0,sizeof(used));\n  for(int i=0;i<n;i++) if(!G[i].size())ans=ans*calc(i)%mod;\n  cout <<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct Dscc {\npublic:\n\tpair<vector<vector<int>>,vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\t\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j:edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]){\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs,newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs2(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n\n}dscc;\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<int>>edges(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tint s, t; cin >> s >> t;\n\t\ts--; t--;\n\t\tedges[s].push_back(t);\n\t}\n\tpair<vector<vector<int>>, vector<vector<int>>> ds(dscc.get(edges));\n\tvector<vector<int>>newedges(ds.second);\n\tvector<vector<int>>revedges(newedges.size());\n\tvector<int>p_nums(newedges.size());\n\tfor (int i = 0; i < newedges.size(); ++i) {\n\t\tfor (auto j : newedges[i]) {\n\t\t\trevedges[j].push_back(i);\n\t\t\tp_nums[j]++;\n\t\t}\n\t}\n\tvector<Mod>anss(newedges.size());\n\tqueue<int>que;\n\tfor (int i = 0; i < newedges.size(); ++i) {\n\t\tif (p_nums[i] == 0) {\n\t\t\tque.push(i);\n\t\t}\n\t}\n\twhile (que.size()) {\n\t\t\n\t\tint atop(que.front());\n\t\tque.pop();\n\t\t\n\t\t\tMod ans = 1;\n\t\t\tfor (auto pa : revedges[atop]) {\n\t\t\t\tans *= anss[pa];\n\t\t\t\t\n\t\t\t}\n\t\t\tans += 1;\n\t\t\tanss[atop] = ans;\n\t\t\t\n\t\t\n\t\tfor (auto pa : newedges[atop]) {\n\t\t\tp_nums[pa]--;\n\n\t\t\tif (!p_nums[pa])que.push(pa);\n\t\t}\n\t}\n\tMod finans = 1;\n\tfor (int i = 0; i < newedges.size(); ++i) {\n\t\tif (newedges[i].empty()) {\n\t\t\tfinans *= anss[i];\n\t\t}\n\t}\n\tcout << finans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long mo = 1e9+7;\n\n/***********************/\n// ??±?????¨???\n/***********************/\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntypedef long long Weight;\nconst Weight INF = 1e18;\n\nstruct Edge {\n    ll src, dst;\n    Weight weight;\n    Edge(ll src, ll dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid addDirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); }\nvoid addUndirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); g[dst].push_back(Edge(dst, src, weight)); }\nvoid addDirected(Graph& g, ll src, ll dst) { addDirected(g, src, dst, 1); }\nvoid addUndirected(Graph& g, ll src, ll dst) { addUndirected(g, src, dst, 1); }\nvoid printGraph(Graph& g) {\n    rep(i, g.size()) {\n        if (!g[i].size())\n            continue;\n        rep(j, g[i].size()) \n            cout << \"(\" << i << \", \" << g[i][j].dst << \"), \";\n        cout << endl;\n    }\n}\n\n// ?????£???????§£\n// O(V+E)\n// const Graph& g               ????????°??????\n// vector< vector<ll> >& scc   ??°??????????????£?????????\nvoid visitStronglyConnectedComponents(const Graph &g, ll v, vector< vector<ll> >& scc,\n        stack<ll> &S, vector<bool> &inS,\n        vector<ll> &low, vector<ll> &num, ll& time) {\n    low[v] = num[v] = ++time;\n    S.push(v); inS[v] = true;\n    FOR(e, g[v]) {\n        ll w = e->dst;\n        if (num[w] == 0) {\n            visitStronglyConnectedComponents(g, w, scc, S, inS, low, num, time);\n            low[v] = min(low[v], low[w]);\n        } else if (inS[w])\n            low[v] = min(low[v], num[w]);\n    }\n    if (low[v] == num[v]) {\n        scc.push_back(vector<ll>());\n        while (1) {\n            ll w = S.top(); S.pop(); inS[w] = false;\n            scc.back().push_back(w);\n            if (v == w) break;\n        }\n    }\n}\nvoid stronglyConnectedComponents(const Graph& g, vector< vector<ll> >& scc) {\n    const ll n = g.size();\n    vector<ll> num(n), low(n);\n    stack<ll> S;\n    vector<bool> inS(n);\n    ll time = 0;\n    rep(u, n) if (num[u] == 0)\n        visitStronglyConnectedComponents(g, u, scc, S, inS, low, num, time);\n}\n\n// ???????????????????????????\n// ????????????????????? u ??§?????£??????u[i] ?????? u[j] ??????????????? => i < j ?????????????????????????????????\n//\n// const Graph &g\n// ??°?????????\n// vector<int> &order\n// ???????????????????????????????????????????????¨??§??£??\\???????????????????????????????????? true ?????¨???????????????\n// ?????????\n// ????????????????????????????????????????????????\n//\n// O(V+E)\nbool visitT(const Graph &g, ll v, vector<ll> &order, vector<ll> &color) {\n    color[v] = 1;\n    FOR(e, g[v]) {\n        if (color[e->dst] == 2) continue;\n        if (color[e->dst] == 1) return false;\n        if (!visitT(g, e->dst, order, color)) return false;\n    }\n    order.push_back(v); color[v] = 2;\n    return true;\n}\nbool topologicalSort(const Graph &g, vector<ll> &order) {\n    ll n = g.size();\n    vector<ll> color(n);\n    rep(u, n) if (!color[u] && !visitT(g, u, order, color))\n        return false;\n    reverse(all(order));\n    return true;\n}\n\n// ???????????°???????????????\nvoid reverseGraph(Graph& g_dst, Graph& g_src) { /*g_dst??????graph?????????*/\n    g_dst = Graph(g_src.size());\n    rep(i, g_src.size()) {\n        rep(j, g_src[i].size()) {\n            addDirected(g_dst, g_src[i][j].dst, g_src[i][j].src, g_src[i][j].weight);\n        }\n    }\n}\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, m; cin >> n >> m;\n    Graph g = Graph(n);\n    rep(i, m) {\n        ll u, v; cin >> u >> v; u--, v--;\n        addDirected(g, u, v);\n    }\n\n    // ??????????????°?????????????????????\n    vector<vector<ll>> scc;\n    stronglyConnectedComponents(g, scc);\n    /*\n    rep(i, scc.size()) {\n        rep(j, scc[i].size()) cout << scc[i][j] << \" \";\n        cout << endl;\n    }\n    */\n\n    // ?????????????????????SCC????±????????????????\n    vector<ll> scc_inv(g.size());\n    rep(i, scc.size()) rep(j, scc[i].size()) scc_inv[scc[i][j]] = i;\n//    cout << scc_inv << endl;\n\n    // ??°??????DAG?????°????????????\n    // ??°??????dag?????????i??????????????????(vector<ll> scc[i])???????????¨???????????????\n    Graph dag(scc.size());\n    rep(from, g.size()) rep(to, g[from].size()) if (scc_inv[from] != scc_inv[g[from][to].dst]) {\n        addDirected(dag, scc_inv[from], scc_inv[g[from][to].dst]);\n    }\n    /*\n    printGraph(dag);\n    */\n\n    vector<ll> order;\n    bool success = topologicalSort(dag, order);\n    /*\n    if (success) \n        cout << order << endl;\n    else \n        cout << \"NOT DAG\" << endl; // ??¶???DAG??????????????????\n    */\n    reverse(all(order));\n\n    Graph dag_rev;\n    reverseGraph(dag_rev, dag);\n    /*\n    printGraph(dag);\n    printGraph(dag_rev);\n    */\n\n    vll dp(n, -1);\n    function<ll(ll)> f = [&](ll i){\n        if (dp[i] != -1)\n            return dp[i];\n        dp[i] = 1;\n        rep(j, dag_rev[i].size()) {\n            (dp[i] *= f(dag_rev[i][j].dst) + 1) %= mo;\n        }\n        return dp[i];\n    };\n\n    ll ret = 1;\n    rep(i, n) {\n        if (dp[order[i]] != -1) \n            continue;\n        (ret *= f(order[i]) + 1) %= mo;\n    }\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\ntypedef vector<vector<int>> graph;\n\n// SCC Strongly Connected Component 強連結成分分解\nstruct SCC {\n\tint V;\n\tint cV;\n\tgraph G;\n\tgraph cG;\n\tvector<int> cmp;\n\tvector<int> vs;\n\tvector<bool> used;\n\n\tSCC(int V_):V(V_), G(V_), cmp(V_), used(V_) {}\n\tSCC(const graph &G_):V(G_.size()), G(G_), cmp(V), used(V) {}\n\n\tvoid add_edge(int from, int to) {\n\t\tG[from].emplace_back(to);\n\t}\n\n\tvoid dfs(int v) {\n\t\tused[v] = true;\n\t\tfor(const auto &to : G[v]) {\n\t\t\tif(!used[to]) dfs(to);\n\t\t}\n\t\tvs.emplace_back(v);\n\t}\n\n\tvoid rdfs(int v, int k, graph &rG) {\n\t\tused[v] = true;\n\t\tcmp[v] = k;\n\t\tfor(const auto &to : rG[v]) {\n\t\t\tif(!used[to]) rdfs(to, k, rG);\n\t\t}\n\t}\n\n\tint scc() {\n\t\tvs.clear();\n\t\tfill(used.begin(), used.end(), false);\n\n\t\tfor(int v = 0; v < V; ++v) {\n\t\t\tif(!used[v]) dfs(v);\n\t\t}\n\n\t\tgraph rG(V);\n\t\tfor(int v = 0; v < V; ++v) {\n\t\t\tfor(const auto &to : G[v]) {\n\t\t\t\trG[to].emplace_back(v);\n\t\t\t}\n\t\t}\n\n\t\tfill(used.begin(), used.end(), false);\n\t\tint k = 0;\n\t\tfor(int i = static_cast<int>(vs.size()) - 1; i >= 0; --i) {\n\t\t\tif(!used[vs[i]]) rdfs(vs[i], k++, rG);\n\t\t}\n\t\treturn k;\n\t}\n\n\tvoid construct() {\n\t\tcV = scc();\n\t\tcG.clear();\n\t\tcG.resize(cV);\n\n\t\tfor(int v = 0; v < V; ++v) {\n\t\t\tfor(const auto &to : G[v]) {\n\t\t\t\tif(cmp[v] != cmp[to]) cG[cmp[v]].emplace_back(cmp[to]);\n\t\t\t}\n\t\t}\n\n\t\tfor(auto &es : cG) {\n\t\t\tsort(es.begin(), es.end());\n\t\t\tes.erase(unique(es.begin(), es.end()), es.end());\n\t\t}\n\t}\n};\n\nconstexpr long long mod = 1000000007;\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n, m;\n\tcin >> n >> m;\n\n\tSCC scc(n);\n\tfor(int i = 0; i < m; ++i) {\n\t\tint s, d;\n\t\tcin >> s >> d;\n\t\tscc.add_edge(s - 1, d - 1);\n\t}\n\n\tscc.construct();\n\n\tconst int V = scc.cV;\n\n\tvector<int> in(V, 0);\n\tfor(int v = 0; v < V; ++v) {\n\t\tfor(const auto &to : scc.cG[v]) {\n\t\t\t++in[to];\n\t\t}\n\t}\n\n\tqueue<int> que;\n\tfor(int v = 0; v < V; ++v) {\n\t\tif(in[v] == 0) que.push(v);\n\t}\n\n\tvector<long long> dp(V, 1);\n\tlong long ans = 1;\n\n\twhile(!que.empty()) {\n\t\tconst int v = que.front();\n\t\tque.pop();\n\n\t\t++dp[v];\n\n\t\tif(scc.cG[v].empty()) {\n\t\t\tans = (ans * dp[v]) % mod;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(const auto &to : scc.cG[v]) {\n\t\t\tdp[to] = (dp[to] * dp[v]) % mod;\n\t\t\tif(--in[to] == 0) que.push(to);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n\nusing namespace std;\n\nconst long long MAXN=11000;\nconst long long MAXE=21000;\n\nlong long node,road;\n\nstruct Edge\n{\n\tlong long next,to;\n};\nEdge edge[MAXE];\nlong long countedge;\nlong long head[MAXN];\n\nvoid addedge(const long long& start,const long long& end)\n{\n\tedge[countedge].to=end;\n\tedge[countedge].next=head[start];\n\thead[start]=countedge;\n\tcountedge++;\n}\n\nlong long ind;\nlong long dfn[MAXN],low[MAXN];\nbool instack[MAXN];\n\nlong long stack[MAXN];\nlong long top;\n\nlong long belong[MAXN];\nlong long cnt;\n\nvoid dfs(long long u)\n{\n\tdfn[u]=low[u]=++ind;\n\tinstack[u]=true;\n\tstack[++top]=u;\n\t\n\tlong long temp,to;\n\tfor(temp=head[u];temp!=-1;temp=edge[temp].next)\n\t{\n\t\tto=edge[temp].to;\n\t\tif(!dfn[to])\n\t\t{\n\t\t\tdfs(to);\n\t\t\tlow[u]=min(low[u],low[to]);\n\t\t}\n\t\telse if(instack[to])\n\t\t{\n\t\t\tlow[u]=min(low[u],dfn[to]);\n\t\t}\n\t}\n\t\n\tif(dfn[u]==low[u])\n\t{\n\t\tcnt++;\n\t\tdo\n\t\t{\n\t\t\tto=stack[top--];\n\t\t\tinstack[to]=false;\n\t\t\tbelong[to]=cnt;\n\t\t}\n\t\twhile(to!=u);\n\t}\n}\n\n//譛牙?荳ェ霑樣?蝮?\nlong long val[MAXN];\nlong long totalval;\n\nvoid solve()\n{\n\ttop=ind=cnt=0;//cnt?夂シゥ螳悟錘逧?せ謨ー \n\tlong long i;\n\tmemset(dfn,0,sizeof(dfn));\n\tmemset(low,0,sizeof(low));\n\tfor(i=1;i<=node;i++)\n\t{\n\t\tif(!dfn[i])dfs(i);\n\t}\n}\n\nlong long s[MAXE],e[MAXE];\nbool map[MAXN][MAXN];\nlong long height[MAXN];\nlong long in[MAXN];\n\nlong long que[MAXN];\nlong long front,rear;\nlong long cal[MAXN][MAXN];\n\nbool vis[MAXN];\nvoid Bfs(long long ind)\n{\n\tlong long i;\n\tlong long u;\n\twhile(front<rear)\n\t{\n\t\tu=que[front++];\n\t\tfor(i=1;i<=cnt;i++)\n\t\t{\n\t\t\tif(map[u][i]&&!vis[i])\n\t\t\t{\n\t\t\t\tvis[i]=true;\n\t\t\t\tque[rear++]=i;\n\t\t\t\theight[i]=height[u]+1;\n\t\t\t\tcal[ind][height[i]]++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long pow2[1100];\n\nint main()\n{\n\tpow2[0]=1;\n\tlong long i,j;\n\tfor(i=1;i<=1000;i++)\n\t{\n\t\tpow2[i]=2*pow2[i-1]%1000000007;\n\t}\n\t\n\tscanf(\"%lld%lld\",&node,&road);\n\t\n\t\n\tcountedge=0;\n\tmemset(head,-1,sizeof(head));\n\tmemset(belong,-1,sizeof(belong));\n\t\n\tfor(i=0;i<road;i++)\n\t{\n\t\tscanf(\"%lld%lld\",&s[i],&e[i]);\n\t\taddedge(s[i],e[i]);\n\t}\n\tsolve();\n\t//prlong longf(\"cnt:%d\\n\",cnt);\n\t\n\tlong long from,to;\n\ttotalval=0;\n\tfor(i=0;i<road;i++)\n\t{\n\t\tfrom=belong[s[i]];\n\t\tto=belong[e[i]];\n\t\tif(from==to)continue;\n\t\tin[to]++;\n\t\tmap[from][to]=true;\n\t\tif(val[from]==0&&val[to]==0)\n\t\t{\n\t\t\ttotalval++;\n\t\t\tval[from]=val[to]=totalval;\n\t\t}\n\t\telse if(val[from]==0)val[from]=val[to];\n\t\telse if(val[to]==0)val[to]=val[from];\n\t}\n\tfor(i=1;i<=cnt;i++)\n\t{\n\t\tif(!val[belong[i]])\n\t\t{\n\t\t\ttotalval++;\n\t\t\tval[belong[i]]=totalval;\n\t\t}\n\t}\n\t/*\n\tfor(i=1;i<=cnt;i++)\n\t{\n\t\tprlong longf(\"%d %d\\n\",val[i],in[i]);\n\t}\n\tprlong longf(\"\\n\");*/\n\t\n\t//prlong longf(\"totalval:%d\\n\",totalval); \n\t\n\tlong long ret=1;\n\tfor(i=1;i<=totalval;i++)\n\t{\n\t\tlong long temp=0;\n\t\tfront=rear=0;\n\t\tfor(j=1;j<=cnt;j++)\n\t\t{\n\t\t\tif(in[j]==0&&val[j]==i)\n\t\t\t{\n\t\t\t\t//隨ャi荳ェ霑樣?蝮?\n\t\t\t\tcal[i][1]++;\n\t\t\t\theight[j]=1;\n\t\t\t\tque[rear++]=j;\n\t\t\t}\n\t\t}\n\t\tBfs(i);\n\t\tj=1;\n\t\twhile(cal[i][j])\n\t\t{\n\t\t\t//prlong longf(\"%d %d %d\\n\",i,j,cal[i][j]);\n\t\t\tif(j>1)temp+=pow2[cal[i][j]-1];\n\t\t\telse temp+=pow2[cal[i][j]];\n\t\t\ttemp%=1000000007;\n\t\t\tj++;\n\t\t}\n\t\tret*=temp;\n\t\tret%=1000000007;\n\t}\n\t\n\tprintf(\"%lld\\n\",ret);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "class in{struct It{int it;const bool rev;explicit constexpr It(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(It& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const It i,n;public:explicit constexpr in(int n):i(0),n(n<0?0:n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const It& begin(){return i;}const It& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint Scc(const vector<vector<int>>& adj, vector<int>& color) {\n    const int n = adj.size();\n    vector<int> num(n, 0), low(n, 0), sta;\n    color.assign(n, 0);\n    bitset<1000> inS(n);\n    int t = 0, colnum = 0;\n    function<void(int)> visit = [&](int cur) {\n        low[cur] = num[cur] = ++t;\n        sta.emplace_back(cur); inS[cur] = 1;\n        for(int nxt : adj[cur]) {\n            if(num[nxt] == 0) {\n                visit(nxt);\n                low[cur] = min(low[cur], low[nxt]);\n            } else if(inS[nxt])\n              low[cur] = min(low[cur], num[nxt]);\n        }\n        if(low[cur] == num[cur]) {\n            while(true) {\n                int nxt = sta.back(); sta.pop_back(); inS[nxt] = false;\n                color[nxt] = colnum;\n                if(cur == nxt) break;\n            }\n            ++colnum;\n        }\n    };\n    for(int v : in(n))\n      if(num[v] == 0)\n        visit(v);\n    return colnum;\n}\n\nusing i64 = long long;\nconst i64 MOD = 1e9 + 7;\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> __adj(n);\n    for(int _ : in(m)) {\n        int u, v;\n        cin >> u >> v;\n        --u; --v;\n        __adj[u].emplace_back(v);\n    }\n    vector<int> color;\n    int col = Scc(__adj, color);\n    vector<vector<int>> radj(col);\n    vector<int> deg(col, 0);\n    vector<bitset<1000>> used(col, bitset<1000>(0));\n    for(int v : in(n))\n      for(int u : __adj[v])\n        if(color[v] != color[u] && used[color[u]][color[v]] == 0)\n          radj[color[u]].emplace_back(color[v]), ++deg[color[v]], used[color[u]][color[v]] = 1;\n    vector<i64> dp(col, -1LL);\n    i64 ans = 1LL;\n    function<i64(int)> dfs = [&](int v) {\n        i64& res = dp[v];\n        if(res != -1LL) return res;\n        res = 1LL;\n        for(int u : radj[v])\n          res = res * dfs(u) % MOD;\n        return ++res;\n    };\n    for(int v : in(col)) {\n        if(dp[v] != -1LL || deg[v] != 0) continue;\n        ans = ans * dfs(v) % MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\ntypedef long long ll;\n\nusing namespace std;\n\nint e[1000];\nll dp[1000];\nint cycle[1000];\nint flag[1000];\nint in[1000];\n\nint n, m;\n\nconst int mod = 1000000007;\n\nint check(int i){\n  if(flag[i] == 2) return -1;\n  if(flag[i] == 1){\n    flag[i] = 2;\n    return i;\n  }\n\n  flag[i] = 1;\n\n  if(e[i] != -1){\n    int c = check(e[i]);\n    if(c != -1){\n      flag[i] = 2;\n      cycle[i] = c;\n      if(c == i) return -1;\n      else return c;\n    }\n  }\n  flag[i] = 2;\n\n  return -1;\n}\n\nint main(){\n  n = getInt();\n  m = getInt();\n\n  REP(i,n){\n    e[i] = -1;\n    cycle[i] = i;\n    dp[i] = 1;\n  }\n\n  REP(i,m){\n    int s = getInt() - 1;\n    int d = getInt() - 1;\n    e[s] = d;\n  }\n\n  REP(i,n) if(!flag[i])\n    check(i);\n\n  REP(i,n) if(cycle[i] == i && e[i] != -1 && cycle[e[i]] != i)\n    in[cycle[e[i]]]++;\n\n  queue<int> que;\n  ll ans = 1;\n\n  REP(i,n) if(cycle[i] == i){\n    if(in[i] == 0) que.push(i);\n  }\n\n  while(que.size()){\n    int pos = que.front(); que.pop();\n    flag[pos] = 5;\n\n    if(e[pos] == -1 || cycle[e[pos]] == pos){\n      ans = ans * (1 + dp[pos]) % mod;\n    }else{\n      int next = cycle[e[pos]];\n      dp[next] = dp[next] * (1 + dp[pos]) % mod;\n      if(--in[next] == 0)\n        que.push(next);\n    }\n  }\n\n  printf(\"%d\\n\", (int)ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <functional>\n\nusing lint = long long;\nusing Graph = std::vector<std::vector<int>>;\n\nusing namespace std;\n\nstruct StronglyConnectedComponents {\n    Graph graph, rgraph;\n    vector<bool> visited;\n    vector<int> order;\n\n    // id[v] = 頂点vはgroups[id[v]]に属する\n    vector<int> id;\n    vector<vector<int>> groups;\n\n    void revinit() {\n        rgraph = Graph(graph.size());\n        for (int v = 0; v < graph.size(); ++v) {\n            for (int sv : graph[v]) {\n                rgraph[sv].push_back(v);\n            }\n        }\n    }\n\n    void dfs(int v) {\n        if (visited[v]) return;\n        visited[v] = true;\n        for (int sv : graph[v]) dfs(sv);\n        order.push_back(v);\n    }\n\n    void rdfs(int v) {\n        if (id[v] >= 0) return;\n        id[v] = groups.size() - 1;\n        groups.back().push_back(v);\n        for (int sv : rgraph[v]) rdfs(sv);\n    }\n\n    explicit StronglyConnectedComponents(const Graph& g)\n        : graph(g), visited(graph.size(), false), id(graph.size(), -1) {\n        revinit();\n\n        for (int v = 0; v < graph.size(); ++v) dfs(v);\n        reverse(order.begin(), order.end());\n\n        for (int v : order) {\n            if (id[v] < 0) {\n                groups.push_back(vector<int>());\n                rdfs(v);\n            }\n        }\n    }\n};\n\n\nconst lint MOD = 1e9 + 7;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    Graph graph(N);\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        graph[v].push_back(u);\n        // 後でDFSしやすいように逆向きに辺を張る\n    }\n\n    StronglyConnectedComponents scc(graph);\n    int V = scc.groups.size();\n\n    // 縮約したグラフ(根付き森)を作成\n    vector<int> in(V, 0);  // 入次数(根の判定に使う)\n    Graph ngraph(V);\n    for (int v = 0; v < N; ++v) {\n        for (int sv : graph[v]) {\n            if (scc.id[v] == scc.id[sv]) continue;\n            ngraph[scc.id[v]].push_back(scc.id[sv]);\n            ++in[scc.id[sv]];\n        }\n    }\n\n    function<lint(int, int)> dfs = [&](int v, int r) {\n        lint ret = 1;  // vを黒く塗る場合\n        for (int sv : ngraph[v]) {\n            if (sv == r) continue;\n            (ret *= dfs(sv, v)) %= MOD;\n        }\n\n        // vを白く塗る場合を追加\n        return (ret + 1) % MOD;\n    };\n\n    lint ans = 1;\n    for (int v = 0; v < V; ++v) {\n        if (in[v] == 0) (ans *= dfs(v, -1)) %= MOD;\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 10000\n#define f first\n#define s second\n#define mp make_pair\n#define mod 1000000007\n#define inf 1e8\nusing namespace std;\n\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nbool visited[MAX_V];\nint cmp[MAX_V];\nvector<pair<int,int> > vpp;\n\nvoid add_edge(int from, int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v] = true;\n  for(int i = 0;i < G[v].size();i++){\n    if(!used[G[v][i]])dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i = 0;i < rG[v].size();i++){\n    if(!used[rG[v][i]]) rdfs(rG[v][i],k);\n  }\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v = 0;v < V;v++){\n    if(!used[v]) dfs(v);\n  }\n  memset(used,0,sizeof(used));\n  int k = 0;\n  for(int i = vs.size() - 1;i >= 0;i--){\n    if(!used[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint rec(int index,int cm){\n  int res=1;\n  int temp = vpp[index].f;\n  if(vpp[index].f==cm)return 1;\n  if(rG[vpp[index].s].size()==0)return 2;\n\n  for(int i=index;vpp[i].f==temp;i++){\n    int now = vpp[i].s;\n    for(int j=0;j<rG[now].size();j++){\n      if(!visited[rG[now][j]]){\n        visited[rG[now][j]]=true;\n        res*=rec(rG[now][j],vpp[i].f);\n        res%=mod;\n      }\n    }\n  }\n  return res+1;\n}\n\nint main()\n{\n  int a,b,m;\n\n  cin>>V>>m;\n\n  for(int i=0;i<m;i++){\n    cin>>a>>b;\n    a--;b--;\n    add_edge(a,b);\n  }\n  int sc=scc();\n\n  for(int i=0;i<V;i++){\n    vpp.push_back(mp((-1)*cmp[i],i));\n  }\n  sort(vpp.begin(),vpp.end());\n\n  int ans=1;\n  for(int i=0;i<vpp.size();i++){\n    if(!visited[i]){\n      visited[i]=true;\n      ans*=rec(i,inf);\n      ans%=mod;\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 1145\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst ll MOD = ((1e9) + 7);\n\nint N, cmp[MAX_V];\nbool used[MAX_V];\nvector<int> G[MAX_V], rG[MAX_V], vs;\n\nvoid add_edge(int from, int to)\n{\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid dfs(int v)\n{\n    used[v] = 1;\n    for (int i = 0; i < (int)G[v].size(); i++) {\n\tif (!used[G[v][i]]) {\n            dfs(G[v][i]);\n        }\n    }\n    vs.push_back(v);\n}\n\nvoid rdfs(int v, int k)\n{\n    used[v] = 1;\n    cmp[v] = k;\n    for (int i = 0; i < (int)rG[v].size(); i++) {\n\tif (!used[rG[v][i]]) {\n            rdfs(rG[v][i], k);\n        }\n    }\n}\n\nint scc()\n{\n    memset(used, 0, sizeof(used));\n    vs.clear();\n    for (int v = 0; v < N; v++) {\n\tif (!used[v]) {\n            dfs(v);\n        }\n    }\n    memset(used, 0, sizeof(used));\n    int k = 0;\n    for (int i = vs.size() - 1; i >= 0; i--) {\n\tif (!used[vs[i]]) {\n            rdfs(vs[i], k++);\n        }\n    }\n    return k;\n}\n\nvector<int> nG[MAX_V];\n\nll solve(int v)\n{\n    ll res = 1;\n    for (int i = 0; i < (int)nG[v].size(); i++) {\n        res *= solve(nG[v][i]);\n        res %= MOD;\n    }\n    res += 1;\n    return res % MOD;\n}\n\nint main()\n{\n    int M, a, b;\n    cin >> N >> M;\n    for (int i = 0; i < M; i++) {\n        cin >> a >> b; a--; b--;\n        add_edge(a, b);\n    }\n    \n    auto K = scc();\n    \n    set<pii> st;\n    int deg[MAX_V] = {};\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < (int)G[i].size(); j++) {\n            int from = cmp[i], to = cmp[G[i][j]];\n            if (from != to && st.count(pii(from, to)) == 0) {\n                st.insert(pii(from, to));\n                nG[to].push_back(from);\n                deg[from]++;\n            }\n        }\n    }\n    \n    ll res = 1;    \n    for (int i = 0; i < K; i++) {\n        if (deg[i] == 0) {\n            res *= solve(i);\n            res %= MOD;\n        }\n    }\n\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\n#define int long long\nconst int M = 1000000007;\n\nclass Scc{\n\tprivate:\n\t\tstatic const int MAX_V = 10000;\n\t\tvector<int> g[MAX_V];\t//??°??????\n\t\tvector<int> rg[MAX_V];\t//?????????????????£?????°??????\n\t\tvector<int> vs;\t\t\t//??°?????????????????????\n\t\tvector<pair<int, int>> edge;\n\t\tbool used[MAX_V];\n\n\t\tvoid rdfs(int v, int k){\n\t\t\tused[v] = true;\n\t\t\tcmp[v] = k;\n\t\t\trep(i,rg[v].size()){\n\t\t\t\tif(not used[rg[v][i]]) rdfs(rg[v][i], k);\n\t\t\t}\n\t\t}\n\t\tvoid dfs(int v){\n\t\t\tused[v] = true;\n\t\t\trep(i,g[v].size()){\n\t\t\t\tif(not used[g[v][i]]) dfs(g[v][i]);\n\t\t\t}\n\t\t\tvs.emplace_back(v);\n\t\t}\n\t\tvoid buildGraph(){\n\t\t\tfor(auto i : edge){\n\t\t\t\tif(cmp[i.first] == cmp[i.second]) continue;\n\t\t\t\tdag[ cmp[i.first] ].emplace_back(cmp[i.second]);\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tvector<int> dag[MAX_V]; //?????£?????????????§£????????£?????????DAG??°??????\n\t\tint cmp[MAX_V]; //?±????????????£????????????????????????????????????\n\n\t\tvoid addEdge(int from, int to){\n\t\t\tedge.emplace_back(from,to);\n\t\t\tg[from].emplace_back(to);\n\t\t\trg[to].emplace_back(from);\n\t\t}\n\t\tint solve(int v){ //scc??????????????°?????????\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tvs.clear();\n\t\t\trep(i,v){\n\t\t\t\tif(not used[i]) dfs(i);\n\t\t\t}\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tint k = 0;\n\t\t\tfor(int i = vs.size() - 1; i >= 0; i--){\n\t\t\t\tif(not used[vs[i]]) rdfs(vs[i], k++);\n\t\t\t}\n\t\t\tbuildGraph();\n\t\t\treturn k;\n\t\t}\n};\n\npair<int, int> dfs(int cur, vector<bool>& used, Scc& scc){\n\tused[cur] = true;\n\tpair<int, int> res = make_pair(1,1);\n\tfor(auto to : scc.dag[cur]){\n\t\tif(used[to]) continue;\n\t\tpair<int, int> tmp = dfs(to, used, scc);\n\t\tres.first *= tmp.first + tmp.second;\n\t\tres.first %= M;\n\t}\n\treturn res;\n}\n\nsigned main(){\n\tint n, m;\n\twhile(cin >> n >> m){\n\t\tScc scc;\n\t\trep(i,m){\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tscc.addEdge(b,a);\n\t\t}\n\n\t\tint k = scc.solve(n);\n\n\t\tint ans = 1;\n\t\tvector<bool> used(n,0);\n\t\trep(i,k){\n\t\t\tif(used[i]) continue;\n\t\t\tpair<int, int> tmp = dfs(i, used, scc);\n\t\t\t//show(tmp.first + tmp.second)\n\t\t\tans *= tmp.first + tmp.second;\n\t\t\tans %= M;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll MOD = 1000000007;\n\nint N, M;\nvector<vector<int>> G, rG;\nvector<bool> vis;\nvector<int> vs;\nvector<int> S;\nvector<vector<int>> s;\n\nvoid dfs(int v){\n    vis[v] = true;\n    for(int i=0; i<G[v].size(); i++)\n        if(!vis[G[v][i]]) dfs(G[v][i]);\n    vs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n    vis[v] = 1;\n    S[v] = k; s[k].push_back(v);\n    for(int i=0; i<rG[v].size(); i++)\n        if(!vis[rG[v][i]]) rdfs(rG[v][i],k);\n}\n\nvoid scc(){\n    for(int i=0; i<N; i++)if(!vis[i]) dfs(i);\n    for(int i=0; i<N; i++)\n        vis[i] = false;\n    \n    reverse(vs.begin(), vs.end());\n    \n    s.clear();\n    for(int i=0; i<N; i++) if(!vis[vs[i]]){\n        s.push_back(vector<int>());\n        rdfs(vs[i],s.size()-1);\n    }\n    vector<int> rs(N);\n    N = s.size();\n    for(int i=0; i<N; i++)\n        for(int v: s[i])\n            rs[v] = i;\n    \n    \n    vector<vector<int>> tG(N);\n    vector<vector<int>> trG(N);\n    for(int i=0; i<N; i++){\n        vector<bool> done(N);\n        for(int u: s[i]){\n            for(int v: G[u]) if(rs[v]!=i && !done[rs[v]]){\n                done[rs[v]] = true;\n                tG[i].push_back(rs[v]);\n            }\n            for(int v: rG[u]) if(rs[v]!=i && !done[rs[v]]){\n                done[rs[v]] = true;\n                trG[i].push_back(rs[v]);\n            }\n        }\n    }\n    G = tG;\n    rG = trG;\n}\n\nll tree(int u){\n    if(rG[u].size() == 0) //leaf\n        return 2;\n    \n    ll res = 1;\n    for(int v: rG[u])\n        res = (res * tree(v)) % MOD;\n    return res + 1;\n}\n\nint main(){\n    cin >> N >> M;\n    G.resize(N); rG.resize(N);\n    vis.resize(N); S.resize(N);\n\n    for(int i=0; i<M; i++){\n        int s, d; cin >> s >> d; s--; d--;\n        G[s].push_back(d);\n        rG[d].push_back(s);\n    }\n    \n    scc();\n    \n    ll ans = 1;\n    for(int i=0; i<N; i++){\n        if(G[i].size() == 0) //root\n            ans = (ans * tree(i)) % MOD;\n    }\n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i, n) for (int i = 0, loop##i=(int)(n); i < loop##i; ++i)\n#define FORE(x, y) for (auto &x : y)\n#define ALL(x) x.begin(), x.end()\n#define SZ(x) ((int)(x).size())\ntemplate <class T, class U>\nbool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T, class U>\nbool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\n\nconstexpr int MOD = 1'000'000'007;\nsigned main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int> p(N, -1);\n\tvector<vector<int>> ch(N);\n\tREP(i, M) {\n\t\tint s, d;\n\t\tcin >> s >> d;\n\t\ts--, d--;\n\t\tp[s] = d;\n\t\tch[d].push_back(s);\n\t}\n\n\tvector<bool> on_cycle(N);\n\t{\n\t\tvector<int> label(N, -1);\n\t\tREP(i, N) {\n\t\t\tif (label[i] == -1) {\n\t\t\t\tint cur = i, prv = -1;\n\t\t\t\twhile (cur != -1) {\n\t\t\t\t\tif (on_cycle[cur]) break;\n\t\t\t\t\tif (label[cur] != -1 && label[cur] < i) break;\n\t\t\t\t\tif (label[cur] == i) {\n\t\t\t\t\t\t// cycle\n\t\t\t\t\t\tint endpoint = cur;\n\t\t\t\t\t\tcur = p[cur];\n\t\t\t\t\t\twhile (cur != endpoint) {\n\t\t\t\t\t\t\ton_cycle[cur] = true;\n\t\t\t\t\t\t\tcur = p[cur];\n\t\t\t\t\t\t}\n\t\t\t\t\t\ton_cycle[endpoint] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tlabel[cur] = i;\n\t\t\t\t\tprv = cur;\n\t\t\t\t\tcur = p[cur];\n\t\t\t\t}\n\t\t\t\tif (cur == -1) {\n\t\t\t\t\ton_cycle[prv] = true;  // root\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<bool> vis(N, false);\n\tauto dfs = [&](auto f, int v) -> int {\n\t\tint ret = 1;\n\t\tFORE(w, ch[v]) {\n\t\t\tif (on_cycle[w]) continue;\n\t\t\tret *= f(f, w);\n\t\t\tret %= MOD;\n\t\t}\n\t\tret++;\n\t\treturn ret;\n\t};\n\tint ans = 1;\n\tREP(i, N) {\n\t\tif (!vis[i] && on_cycle[i]) {\n\t\t\tint tmp = 1;\n\t\t\tint cur = i;\n\t\t\twhile (cur != -1) {\n\t\t\t\tvis[cur] = true;\n\t\t\t\tFORE(w, ch[cur]) {\n\t\t\t\t\tif (on_cycle[w]) continue;\n\t\t\t\t\ttmp *= dfs(dfs, w);\n\t\t\t\t\ttmp %= MOD;\n\t\t\t\t}\n\t\t\t\tcur = p[cur];\n\t\t\t\tif (cur == i) break;\n\t\t\t}\n\t\t\ttmp++;\n\t\t\tans *= tmp;\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\n#define mod 100000007LL\n\n\ntemplate<typename T>\nclass UF {\npublic:\n\tUF() {\n\t\tsize = 0;\n\t}\n\n\t//???????????\\??????\n\tvoid push( T a ) {\n\t\tM[a] = size;\n\t\tV.push_back( size );\n\t\trank.push_back( 0 );\n\t\tC.push_back( 1 );\n\t\tsize++;\n\t}\n\n\t//????????°??????????????????\n\tvoid unite( T a, T b ) {\n\t\tlong long int x = find( M[a] );\n\t\tlong long int y = find( M[b] );\n\t\tif( x == y )return;\n\t\tif( rank[x] < rank[y] ) {\n\t\t\tV[x] = y;\n\t\t\tC[y] += C[x];\n\t\t} else {\n\t\t\tV[y] = x;\n\t\t\tC[x] += C[y];\n\t\t\tif( rank[x] == rank[y] )rank[x]++;\n\t\t}\n\t}\n\n\tvoid merge( T a, T b ) {\n\t\tunite( a, b );\n\t}\n\n\t//????????°??????????????????????????????????????????\n\tbool same( T a, T b ) {\n\t\treturn find( M[a] ) == find( M[b] );\n\t}\n\n\t//????????°????????????????????°?????????\n\tlong long int group() {\n\t\tset<long long int>S;\n\t\tfor( long long int i = 0; i < V.size(); i++ ) {\n\t\t\tS.insert( find( V[i] ) );\n\t\t}\n\t\treturn S.size();\n\t}\n\n\t//??°?????????????±???????????????°?????????\n\tlong long int count( T a ) {\n\t\treturn C[find( M[a] )];\n\t}\n\n\t//????±???????????????°????????????ID?????????\n\tlong long int groupID( T a ) {\n\t\treturn find( M[a] );\n\t}\n\n\t//????????°?????????????????????????????????\n\tvector<T>friendList( T a ) {\n\t\tlong long int inputID = find( M[a] );\n\t\tvector<T>ret;\n\t\tfor( auto now : M ) {\n\t\t\tif( find( now.second ) == inputID ) {\n\t\t\t\tret.emplace_back( now.first );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\nprivate:\n\tvector<long long int>C, V, rank;\n\tmap < T, long long int>M;\n\tlong long int size;\n\n\t//?\\?????????§?????????\n\tlong long int find( long long int x ) {\n\t\tif( V[x] == x )return x;\n\t\telse return V[x] = find( V[x] );\n\t}\n};\n\n\n\nint main() {\n\tlong long int N, M;\n\tcin >> N >> M;\n\tUF<long long int>uf;\n\tfor( size_t i = 0; i < N; i++ ) {\n\t\tuf.push( i );\n\t}\n\tvector<vector<long long int>>D( N );\n\tvector<vector<long long int>>F( N );\n\tfor( size_t i = 0; i < M; i++ ) {\n\t\tlong long int x, y;\n\t\tcin >> x >> y;\n\t\tx--; y--;\n\t\tD[x].push_back( y );\n\t\tF[y].push_back( x );\n\t\tuf.merge( x, y );\n\t}\n\n\tlong long int ans = 1;\n\tset<long long int>checked;\n\tvector<bool>checkbool( N );\n\tfor( size_t i = 0; i < N; i++ ) {\n\t\tif( !checked.count( uf.groupID( i ) ) ) {\n\t\t\tchecked.insert( uf.groupID( i ) );\n\t\t\tauto group = uf.friendList( i );\n\n\t\t\tlong long int now = i;\n\t\t\twhile( !checkbool[now] && D[now].size() ) {\n\t\t\t\tnow = D[now][0];\n\t\t\t\tcheckbool[now] = true;\n\t\t\t}\n\n\n\t\t\tfunction<long long int( long long int )> f = [&]( long long int idx )->long long int {\n\t\t\t\t//cout << idx << endl;\n\t\t\t\tlong long int ret = 1;\n\t\t\t\tfor( auto x : F[idx] ) {\n\t\t\t\t\tret *= f( x );\n\t\t\t\t\tret %= mod;\n\t\t\t\t}\n\t\t\t\treturn ret + 1;\n\t\t\t};\n\t\t\tif( D[now].size() ) {\n\t\t\t\tauto now_ = D[now][0];\n\t\t\t\tset<long long int>SLL;\n\t\t\t\tSLL.insert( now );\n\t\t\t\twhile( now_ != now ) {\n\t\t\t\t\tSLL.insert(now_);\n\t\t\t\t\tauto prev = now_;\n\t\t\t\t\tfor( auto x : F[now_] ) {\n\t\t\t\t\t\tif( x != prev ) {\n\t\t\t\t\t\t\tF[now].push_back( x );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnow_ = D[now_][0];\n\t\t\t\t}\n\t\t\t\tnow_ = D[now][0];\n\t\t\t\tF[now].erase( remove_if( F[now].begin(), F[now].end(), [&]( auto i ) { return SLL.count(i); } ), F[now].end() );\n\t\t\t\t\n\t\t\t}\n\t\t\tans *= f( now );\n\t\t\tans %= mod;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>g[1100];\nvector<int>rev[1100];\nint num;\nint v[1100];\nint tmp[1100];\nint g2[1100][1100];\nvoid dfs(int a){\n\tv[a]=1;\n\tfor(int i=0;i<g[a].size();i++)if(!~v[g[a][i]])dfs(g[a][i]);\n\ttmp[num++]=a;\n}\nvoid dfs2(int a){\n\tv[a]=num;\n\tfor(int i=0;i<rev[a].size();i++)if(!~v[rev[a][i]])dfs2(rev[a][i]);\n}\nlong long mod=1000000007;\nlong long dp[1100][2];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<b;i++){\n\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\tp--;q--;\n\t\tg[p].push_back(q);\n\t\trev[q].push_back(p);\n\t}\n\tfor(int i=0;i<a;i++)v[i]=-1;\n\tfor(int i=0;i<a;i++){\n\t\tif(!~v[i]){\n\t\t\tdfs(i);\n\t\t}\n\t}\n\tnum=0;\n\tfor(int i=0;i<a;i++)v[i]=-1;\n\tfor(int i=a-1;i>=0;i--){\n\t\tif(!~v[tmp[i]]){\n\t\t\tdfs2(tmp[i]);\n\t\t\tnum++;\n\t\t}\n\t}\n\t//for(int i=0;i<a;i++)printf(\"%d\\n\",v[i]);\n\tint n=num;\n\tfor(int i=0;i<a;i++)for(int j=0;j<g[i].size();j++)if(v[i]!=v[g[i][j]])g2[v[i]][v[g[i][j]]]=1;\n\t//for(int i=0;i<n;i++)for(int j=0;j<n;j++)if(g2[i][j])printf(\"%d %d\\n\",i,j);\n\tfor(int i=0;i<n;i++){\n\t\tlong long t1=1;\n\t\tlong long t2=1;\n\t\tfor(int j=0;j<n;j++)if(g2[j][i]){\n\t\t\tt1=t1*(dp[j][0]+dp[j][1])%mod;\n\t\t\tt2=t2*dp[j][1]%mod;\n\t\t}\n\t\t//t1=t1*2%mod;\n\t\t//t1=(t1+t2)%mod;\n\t\tdp[i][0]=t1;\n\t\tdp[i][1]=t2;\n\t//\tprintf(\"%d: %lld %lld\\n\",i,t1,t2);\n\t}\n\tlong long ret=1;\n\tfor(int i=0;i<n;i++){\n\t\tbool ok=true;\n\t\tfor(int j=0;j<n;j++)if(g2[i][j])ok=false;\n\t\tif(ok)ret=ret*(dp[i][0]+dp[i][1])%mod;\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nconst ll MOD=1e9+7;\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    vector<int> to(n,-1);\n    for(int i=0;i<m;i++){\n        int s,d;\n        cin>>s>>d;\n        s--,d--;\n        to[s]=d;\n    } \n    int k=0;\n    vector<int> t(n,-1);\n    vector<int> real(n);\n    iota(real.begin(),real.end(),0);\n    int x=-1;\n    function<bool(int)> dfs=[&](int v){\n        t[v]=k;\n        if(to[v]==-1) return true;\n        if(t[to[v]]==-1){\n            bool ret=dfs(to[v]);\n            if(ret) return true;\n            else{\n                real[v]=x;\n                if(v==x){\n                    x=-1;\n                    return true;\n                }\n                return false;\n            }\n        }\n        else{\n            if(t[to[v]]==k){\n                x=to[v];\n                real[v]=x;\n                return false;\n            }\n            else{\n                return true;\n            }\n        }\n    };\n    for(int i=0;i<n;i++){\n        if(t[i]==-1) dfs(i),k++;\n    }\n    for(int i=0;i<n;i++){\n        if(real[i]==i && to[i]!=-1){\n            if(real[to[i]]==i) to[i]=-1;\n            else to[i]=real[to[i]];\n        }\n    }\n    vector<vector<int>> rg(n);\n    for(int i=0;i<n;i++){\n        if(real[i]==i && to[i]!=-1){\n            rg[to[i]].push_back(i);\n        }\n    }\n    function<pair<ll,ll>(int)> dfs2=[&](int v){\n        pair<ll,ll> res={1,1};\n        for(auto &to:rg[v]){\n            auto tmp=dfs2(to);\n            res.first*=tmp.first;\n            res.second*=(tmp.first+tmp.second);\n            res.first%=MOD;\n            res.second%=MOD;\n        }\n        return res;\n    };\n    ll res=1;\n    for(int i=0;i<n;i++){\n        if(real[i]==i && to[i]==-1){\n            auto tmp=dfs2(i);\n            res*=(tmp.first+tmp.second);\n            res%=MOD;\n        }\n    }\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lli;\n\nconst lli MAX_V = 1000;\nconst lli M = 1000000007;\n\nlli V, E;\nvector<lli> G[MAX_V];\nvector<lli> rG[MAX_V];\nvector<lli> vs;\nbool used[MAX_V];\nlli cmp[MAX_V];\n\nvoid add_edge(lli from, lli to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(lli v){\n  used[v] = true;\n  for(lli i=0;i<G[v].size();i++){\n    if(!used[G[v][i]]) dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(lli v, lli k){\n  used[v] = true;\n  cmp[v] = k;\n  for(lli i=0;i<rG[v].size();i++){\n    if(!used[rG[v][i]]) rdfs(rG[v][i], k);\n  }\n}\n\nlli scc(){\n  fill(used, used+V, false);\n  vs.clear();\n  for(lli v = 0;v<V;v++){\n    if(!used[v]) dfs(v);\n  }\n  fill(used, used+V, false);\n  lli k = 0;\n  for(lli i=vs.size()-1;i>=0;i--){\n    if(!used[vs[i]]) rdfs(vs[i], k++);\n  }\n  return k;\n}\n\nlli V2;\nvector<lli> G2[MAX_V];\nlli dp[MAX_V];\n\nvoid make_graph(lli v){\n  used[v] = true;\n  for(lli i=0;i<G[v].size();i++){\n    lli to = G[v][i];\n    if(cmp[v] != cmp[to]) G2[cmp[v]].push_back(cmp[to]);\n    if(!used[to]) make_graph(to);\n  }\n}\n\nlli rec(lli v){\n  used[v] = true;\n  lli res = 1;\n  for(lli i=0;i<G2[v].size();i++){\n    lli to = G2[v][i];\n    //prllif(\"v = %d, to = %d\\n\", v, to);\n    if(!used[to]){\n      if(dp[to] != -1) res = (res * dp[to]) % M;\n      else res = (res * rec(to)) % M;\n    }\n  }\n  res = (res + 1) % M;\n  dp[v] = res;\n  return res;\n}\n\nmain(){\n  cin >> V >> E;\n  for(lli i=0;i<E;i++){\n    lli a, b;\n    cin >> a >> b;\n    add_edge(b-1, a-1);\n  }\n  V2 = scc();\n  //for(lli i=0;i<V;i++) prllif(\"%d \", cmp[i]); puts(\"\");\n  for(lli i=0;i<V;i++) rG[i].clear();\n  fill(used, used+V, false);\n  for(lli i=0;i<V;i++) make_graph(i);\n  /*for(lli i=0;i<V2;i++){\n    prllif(\"i=%d:\", i);\n    for(lli j=0;j<G2[i].size();j++){\n      prllif(\"%d \", G2[i][j]);\n    }\n    puts(\"\");\n    }*/\n  fill(used, used+V, false);\n  fill(dp, dp+V2, -1);\n  lli ans = 1;\n  for(lli i=0;i<V2;i++){\n    if(!used[i]){\n      //prllif(\"i = %d\\n\", i);\n      ans = (ans * rec(i)) % M;\n    }\n  }\n  //for(lli i=0;i<V2;i++) prllif(\"%d \", dp[i]); puts(\"\");\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#include <time.h>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nconst long long Mod = 1000000007LL;\nlong long dp[1010][2];\nvector <int> g[1010],g2[1010];\nint use[1010];\nint in[1010];\nint u[1010],v[1010];\nvoid f(int x)\n{\n    dp[x][0]=1;\n    dp[x][1]=1;\n    for (int i=0;i<g[x].size();i++)\n    {\n        int y=g[x][i];\n        f(y);\n        dp[x][0]=dp[x][0]*dp[y][0]%Mod;\n        dp[x][1]=dp[x][1]*(dp[y][0]+dp[y][1])%Mod;\n    }\n}\nint lea[1010];\nint from[1010],tStamp;\nvoid dfs(int x)\n{\n    use[x]=1;\n    for (int i=0;i<g[x].size();i++)\n    {\n        int v=g[x][i];\n        if (use[v]) continue;\n        dfs(v);\n    }\n    lea[tStamp++]=x;\n}\nvoid dfs2(int x,int col)\n{\n    from[x]=col;\n    use[x]=1;\n    for (int i=0;i<g2[x].size();i++)\n    {\n        int v=g2[x][i];\n        if (use[v]) continue;\n        dfs2(v,col);\n    }\n}\nint main()\n{\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    for (int i=0;i<m;i++)\n    {\n        scanf(\"%d%d\",&u[i],&v[i]);\n        g[u[i]].push_back(v[i]);\n        g2[v[i]].push_back(u[i]);\n    }\n    memset(use,0,sizeof(use));\n    tStamp=0;\n    for (int i=1;i<=n;i++)\n    {\n        if (use[i]) continue;\n        dfs(i);\n    }\n    int col=0;\n    memset(use,0,sizeof(use));\n    for (int i=tStamp-1;i>=0;i--)\n    {\n        int u=lea[i];\n        if (use[u]) continue;\n        dfs2(u,col++);\n    }\n    for (int i=1;i<=n;i++)\n        g[i].clear();\n    memset(in,0,sizeof(in));\n    for (int i=0;i<m;i++)\n    {\n        int pu=from[u[i]];\n        int pv=from[v[i]];\n        if (pu==pv) continue;\n        g[pv].push_back(pu);\n        in[pu]++;\n    }\n    long long ans=1;\n    for (int i=0;i<col;i++)\n    {\n        if (in[i]!=0) continue;\n        f(i);\n        ans=ans*(dp[i][0]+dp[i][1])%Mod;\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nstruct scc{\n    vector<vector<int>> graph,rgraph;\n    vector<bool> done;\n    vector<int> vs,cmp;\n    const int size;\n    int cnt;\n    scc(vector<vector<int>> &graph):size(graph.size()),graph(graph),rgraph(graph.size()),done(graph.size()),cmp(graph.size()),cnt(0){\n        //rep(v,0,size){\n        for(int v=0; v<size; ++v){\n            for(int u:graph[v]) rgraph[u].push_back(v);\n        }\n        //rep(v,0,size)\n        for(int v=0; v<size; ++v){\n            if(done[v]) continue;\n            dfs(v);\n        }\n        fill(done.begin(),done.end(),false);\n        for(int i=vs.size()-1; i>=0; --i){\n            if(done[vs[i]]) continue;\n            rdfs(vs[i],cnt);\n            ++cnt;\n        }\n    }\n    void dfs(int v){\n        if(done[v]) return;\n        done[v]=true;\n        for(int u:graph[v]) dfs(u);\n        vs.push_back(v);\n    }\n    void rdfs(int v,int k){\n        if(done[v]) return;\n        done[v]=true;\n        cmp[v]=k;\n        for(int u:rgraph[v]) rdfs(u,k);\n    }\n};\n\nvoid solve(){\n    int n,m;\n    cin >> n >> m;\n    vector<vector<int>> graph1(n);\n    rep(i,0,m){\n        int s,d;\n        cin >> s >> d;\n        --s;\n        --d;\n        graph1[s].push_back(d);\n    }\n\n    scc scc_(graph1);\n    int cnt=scc_.cnt;\n    vector<vector<int>> graph2(cnt);\n    vector<int> cnt_in(cnt);\n    rep(i,0,n) for(int j:graph1[i]){\n        int a=scc_.cmp[i],b=scc_.cmp[j];\n        if(a==b) continue;\n        graph2[b].push_back(a);\n        ++cnt_in[a];\n    }\n\n    ll mod=1000000007;\n    vector<ll> memo(cnt);\n    vector<bool> done(cnt);\n    function<ll(int)> rec=[&](int v){\n        ll &res=memo[v];\n        if(done[v]) return res;\n        done[v]=true;\n        res=1;\n        if(graph2[v].size()>0){\n            ll tmp=1;\n            for(int u:graph2[v]) tmp=tmp*(rec(u)+1)%mod;\n            --tmp;\n            res=(res+tmp)%mod;\n        }\n        return res;\n    };\n    rep(i,0,cnt) rec(i);\n    ll ans=1;\n    rep(i,0,cnt){\n        if(cnt_in[i]>0) continue;\n        ans=ans*(memo[i]+1)%mod;\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n\n#define REP(i, b, n) for(int i = b; i < (int)n; i++)\n#define rep(i, n) REP(i, 0, n)\n\nusing namespace std;\n\ntypedef unsigned long long ll;\n\nconst int N = 1000;\nconst ll MOD = 1000000007;\n\n\nint V, cmp[N];\nvector<int> G[N], rG[N], vs;\nbool used[N];\nvoid init(){\n  rep(i, N){\n    G[i].clear();\n    rG[i].clear();\n  }\n  vs.clear();\n}\n\nvoid add_edge(int from, int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v] = true;\n  rep(i, G[v].size()){\n    if(!used[G[v][i]])dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n  used[v] = true;\n  cmp[v] = k;\n  rep(i, rG[v].size()){\n    if(!used[rG[v][i]])rdfs(rG[v][i], k);\n  }\n}\n\nint scc(){\n  rep(i, N)used[i] = false;\n  vs.clear();\n  rep(v, V){\n    if(!used[v])dfs(v);\n  }\n  rep(i, N)used[i] = false;\n  int k = 0;\n  for(int i = vs.size() -1; i>=0; i--){\n    if(!used[vs[i]])rdfs(vs[i], k++);\n  }\n  return k;\n}\n\n\npair<ll, ll> dp[N];\nvector<int> edge[N];\n\n\npair<ll, ll> solve(int id){\n  if(dp[id].first > 0 )return dp[id];\n  pair<ll, ll> ret = make_pair(1, 1);\n  rep(i, edge[id].size()){\n    ll next = edge[id][i];\n    pair<ll, ll> result = solve(next);\n    ret.first *= (result.first + result.second)%MOD;\n    ret.second *= result.second;\n    ret.first %= MOD;\n    ret.second %= MOD;\n  }\n  return ret;\n}\n\nint main(){\n  int n, m;\n  bool first = true;\n  while(cin >> n >> m){\n    assert(first);\n    first = false;\n    if(n == 0 && m == 0)break;\n    V = n;\n    init();\n    vector<pair<int, int> > INPUT;\n    rep(i, m){\n      int from, to;\n      cin >> from >> to;\n      INPUT.push_back(make_pair(to-1,from-1));\n      add_edge(to-1, from-1);\n    }\n    int cnt = scc();\n    bool root[N];\n    rep(i, N)root[i] = true;\n    rep(i, N)edge[i].clear();\n    rep(i, INPUT.size()){\n      if(cmp[INPUT[i].first] == cmp[INPUT[i].second])continue;\n      edge[cmp[INPUT[i].first]]\t.push_back(cmp[INPUT[i].second]);\n      root[cmp[INPUT[i].second]] = false;\n    }\n    \n    rep(i, N)dp[i] = make_pair(0, 0);\n    \n    ll ans = 1;\n    rep(i, cnt){\n      if(root[i] == true){\n\tpair<ll, ll> ret = solve(i);\n\tans *= (ret.first + ret.second)%MOD;\n\tans %= MOD;\n      }\n    }\n    cout << ans << endl;\n  }\n}\n/*0 1 1\n1 1 1\n4 1 1\n3 4 1\n2 10 1\n176*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nnamespace SCC{\n    void visit(const vector<vector<int>>&G,vector<int>&vs,vector<int>&used,int v){\n        used[v]=true;\n        for(auto u:G[v]){\n            if(!used[u])visit(G,vs,used,u);\n        }\n        vs.push_back(v);\n    }\n\n    void visit2(const vector<vector<int>>&T,vector<int>&used,vector<int>&comp,vector<int>&vec,int k,int v){\n        comp[v]=k;\n        used[v]=true;\n        vec.push_back(v);\n\n        for(auto u:T[v]){\n            if(!used[u])visit2(T,used,comp,vec,k,u);\n        }\n    }\n\n    //G:?????£?????????????§£???????????°??????\n    //H:?????£??????????????°??????1???????????????????´?????????°??????\n    //comp:G????????????????????????H?????????????±????????????????\n    void decompose(const vector<vector<int>>&G,vector<vector<int>>&H,vector<int>&comp){\n        vector<vector<int>>T(G.size());\n        for(int i=0;i<G.size();i++){\n            for(auto v:G[i]){\n                T[v].push_back(i);\n            }\n        }\n        comp.resize(G.size());\n\n        vector<int>vs(G.size());\n        vector<int>used(G.size());\n        for(int i=0;i<G.size();i++){\n            if(!used[i])visit(G,vs,used,i);\n        }\n        reverse(vs.begin(),vs.end());\n        fill(used.begin(),used.end(),0);\n\n        int K=0;\n        vector<vector<int>>S;\n        for(auto v:vs){\n            if(!used[v]){\n                S.push_back(vector<int>());\n                visit2(T,used,comp,S.back(),K++,v);\n            }\n        }\n\n        H.resize(K);\n        fill(used.begin(),used.end(),0);\n        for(int i=0;i<K;i++){\n            for(auto v:S[i]){\n                for(auto u:G[v]){\n                    if(used[comp[u]]||comp[v]==comp[u])continue;\n                    used[comp[u]]=true;\n                    H[comp[v]].push_back(comp[u]);\n                }\n            }\n            for(auto v:H[i])used[v]=true;\n        }\n\n    }\n}\n\nint N,M;\nvector<vector<int>>H;\nconst int mod=1000000007;\n\nint dp[1000];\nvoid dfs(int v){\n    dp[v]=1;\n    for(auto u:H[v]){\n        dfs(u);\n        dp[v]=dp[v]*(dp[u]+1)%mod;\n    }\n}\n\nsigned main(){\n    scanf(\"%lld%lld\",&N,&M);\n    vector<vector<int>>G(N);\n    rep(i,M){\n        int a,b;\n        scanf(\"%lld%lld\",&a,&b);\n        a--;b--;\n        G[b].push_back(a);\n    }\n\n    vector<int>comp;\n\n    SCC::decompose(G,H,comp);\n    int ans=1;\n    int deg[1000]={};\n    rep(i,H.size())for(auto v:H[i])deg[v]++;\n    rep(i,H.size()){\n        if(deg[i]==0){\n            dfs(i);\n            ans=ans*(dp[i]+1)%mod;\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nstruct Edge{ ll src, dest; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, ll from, ll to) {\n\tg[from].push_back((Edge){from, to});\n}\n\nll scc(Graph &graph, vector<ll> &cmp) {\n\tll V = graph.size();\n\tvector<vector<ll>> g(V), rg(V);\n\tvector<ll> vs;\n\tvector<bool> used(V, false);\n\tcmp.resize(V);\n\tREP(i,V) {\n\t\tfor (Edge e: graph[i]) {\n\t\t\tg[i].push_back(e.dest);\n\t\t\trg[e.dest].push_back(i);\n\t\t}\n\t}\n\tfunction<void(ll)> dfs = [&g, &vs, &used, &dfs](ll v) {\n\t\tused[v] = true;\n\t\tfor (ll i: g[v]) if (!used[i]) dfs(i);\n\t\tvs.push_back(v);\n\t};\n\tfunction<void(ll,ll)> rdfs = [&rg, &cmp, &used, &rdfs](ll v, ll k) {\n\t\tused[v] = true; cmp[v] = k;\n\t\tfor (ll i: rg[v]) if (!used[i]) rdfs(i, k);\n\t};\n\tREP(v,V) if (!used[v]) dfs(v);\n\tused = vector<bool>(V, false);\n\treverse(ALL(vs));\n\tll k = 0;\n\tfor (ll i: vs) if (!used[i]) rdfs(i, k++);\n\treturn k;\n}\n\nvector<vector<ll>> buildGraph(const Graph &g, const vector<ll> &cmp, ll K) {\n\tll V = g.size();\n\tvector<set<ll>> s(K);\n\tvector<vector<ll>> res(K);\n\tREP(i,V) for (Edge e: g[i]) s[cmp[i]].insert(cmp[e.dest]);\n\tREP(i,K) for (ll j: s[i]) if (i != j) res[i].push_back(j);\n\treturn res;\n}\n\nll dfs(ll pos, ll par, const vector<vector<ll>> &g) {\n\tll ret=1;\n\tREP(i,g[pos].size()) {\n\t\tif(g[pos][i]!=par) {\n\t\t\tret*=dfs(g[pos][i],pos,g);\n\t\t\tret%=MOD;\n\t\t}\n\t}\n\treturn (ret+1)%MOD;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, m;\n\tcin>>n>>m;\n\tGraph g(n);\n\tREP(i,m) {\n\t\tll s,d;\n\t\tcin>>s>>d;\n\t\ts--; d--;\n\t\tadd_edge(g,s,d);\n\t}\n\tvector<ll> cmp;\n\tll k=scc(g,cmp);\n\tvector<vector<ll>> _g=buildGraph(g,cmp,k);\n\tvector<ll> root;\n\tREP(i,_g.size()) if(_g[i].empty()) root.pb(i);\n\tREP(i,_g.size()) REP(j,_g[i].size()) _g[_g[i][j]].pb(i);\n\tll ans=1;\n\tREP(i,root.size()) {\n\t\tans*=dfs(root[i],-1,_g);\n\t\tans%=MOD;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <climits>\n#include <bitset>\n#include <cassert>\n#include <random>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define UNIQUE(v) (v).erase(unique(ALL(v)), (v).end())\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int N = 310;\nint dist[N][N];\n\nstruct SCC{\n\tint n, k;\n\tvector<vector<int>> G, RevG;\n\tvector<int> vs, used, cmp;\n\n\tSCC(int _n) :n(_n){\n\t\tG = RevG = vector<vector<int>>(n);\n\t\tused = cmp = vector<int>(n);\n\t\tk = -1;\n\t}\n\n\tvoid add_edge(int s, int t){\n\t\tG[s].push_back(t);\n\t\tRevG[t].push_back(s);\n\t}\n\n\tvoid dfs(int v){\n\t\tused[v] = 1;\n\t\tfor (auto to : G[v]){\n\t\t\tif (!used[to]) dfs(to);\n\t\t}\n\t\tvs.push_back(v);\n\t}\n\n\tvoid rdfs(int v, int k){\n\t\tused[v] = 1;\n\t\tcmp[v] = k;\n\t\tfor (auto to : RevG[v]){\n\t\t\tif (!used[to]) rdfs(to, k);\n\t\t}\n\t}\n\n\tint calcSCC(){\n\t\tfill(used.begin(), used.end(), 0);\n\t\tvs.clear();\n\t\tfor (int i = 0; i < n; ++i) if(!used[i]) dfs(i);\n\t\tfill(used.begin(), used.end(), 0);\n\t\tk = 0;\n\t\tfor (int i = n - 1; i >= 0; --i) if(!used[vs[i]]) rdfs(vs[i], k++);\n\n\t\treturn k;\n\t}\n};\n\nvector<vector<int>> make_DAG(SCC &scc){\n\tif (scc.k < 0) scc.calcSCC();\n\tconst auto &G = scc.G;\n\tconst auto &cmp = scc.cmp;\n\tconst int k = scc.k;\n\n\tvector<vector<int>> DAG(k);\n\tint n = G.size();\n\tfor (int i = 0; i < n; ++i){\n\t\tfor (auto to : G[i]){\n\t\t\tif(cmp[i] != cmp[to]) DAG[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\n\tfor (auto &v : DAG){\n\t\tsort(v.begin(), v.end());\n\t\tv.erase(unique(v.begin(), v.end()), v.end());\n\t}\n\treturn DAG;\n}\n\nvector<vector<int>> G;\n\nconst ll mod = 1e9 + 7;\nint used[1010];\n\nll dfs(int v){\n\tused[v] = 1;\n\tll res = 1;\n\tfor (auto to : G[v]){\n\t\tres *= dfs(to);\n\t\tres %= mod;\n\t}\n\treturn res + 1;\n}\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n, m;\n\tcin >> n >> m;\n\tSCC scc(n);\n\trep(i, m){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tscc.add_edge(b - 1, a - 1);\n\t}\n\n\tscc.calcSCC();\n\tG = make_DAG(scc);\n\n\tll ans = 1;\n\tfor (int i = 0; i < G.size(); ++i){\n\t\tif (used[i]) continue;\n\t\tans *= dfs(i);\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nconstexpr int MOD = 1e9+7;\n\nnamespace graph { // not verified\n\nconstexpr int MaxV = 1010;\n\nstruct scc {\n\n  int V = MaxV;\n  vector<int> G[MaxV];\n  vector<int> rG[MaxV];\n  vector<int> vs;\n  vector<bool> used;\n  vector<int> comp;\n  int SCCGraphSize;\n\n  scc(): V(MaxV) { comp.resize(MaxV); }\n  scc(int V_): V(V_) { comp.resize(MaxV); }\n\n  void add_edge(int from, int to) {\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  }\n\n  void dfs(int v) {\n    used[v] = 1;\n    for(auto e: G[v]) {\n      if(!used[e]) dfs(e);\n    }\n    vs.push_back(v);\n  }\n\n  void rdfs(int v, int k) {\n    used[v] = 1;\n    comp[v] = k;\n    for(auto e: rG[v]) {\n      if(!used[e]) rdfs(e, k);\n    }\n  }\n\n  void solve() {\n    used.clear(); used.resize(MaxV);\n    vs.clear();\n    for(int i = 0; i < V; i++) {\n      if(!used[i]) dfs(i);\n    }\n    used.clear(); used.resize(MaxV);\n    int k = 0;\n    for(int i = vs.size() - 1; i >= 0; i--) {\n      if(!used[vs[i]]) rdfs(vs[i], k++);\n    }\n    SCCGraphSize = k;\n  }\n\n};\n\n}\n\nvector<vector<int>> tree;\nll dp[1010];\n\nll solve(int curr, int par) {\n  ll& ret = dp[curr];\n  if(ret + 1) return ret;\n  ret = 1;\n  for(auto e: tree[curr]) {\n    if(e == par) continue;\n    ret *= solve(e, curr);\n    ret %= MOD;\n  }\n  return (ret + 1) % MOD;\n}\n\nint main() {\n\n  int N, M; cin >> N >> M;\n  graph::scc scc_graph(N);\n  rep(i, M) {\n    int S, D; cin >> S >> D; S --, D --;\n    scc_graph.add_edge(S, D);\n  }\n\n  scc_graph.solve();\n\n  auto& K = scc_graph.SCCGraphSize;\n  auto& g = scc_graph.G;\n  auto& comp = scc_graph.comp;\n\n  tree.resize(K);\n  int deg[1010] = {};\n\n  rep(i, N) {\n    for(auto e: g[i]) {\n      if(comp[i] == comp[e]) continue;\n      tree[comp[e]].push_back(comp[i]);\n      deg[comp[i]] ++;\n    }\n  }\n\n  rep(i, K) {\n    sort(tree[i].begin(), tree[i].end());\n    tree[i].erase(unique(tree[i].begin(), tree[i].end()), tree[i].end());\n  }\n\n  minus(dp);\n\n  ll ans = 1;\n\n  rep(i, K) if(deg[i] == 0 && dp[i] < 0) {\n    ans *= solve(i, -1);\n    ans %= MOD;\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,x,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n \n// ----------------------------\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\nint n;             // |V|\nvvi edge;          // ????????°??????\nvvi r_edge;        // ?????????????????????????????°??????\nvi vs;             // ??°????????????\nvector<bool> used; // ??¢???????????????\nvi cmp;            // ?±????????????£????????????????????????????????????\n\nvoid add_edge(int from, int to){\n    edge[from].push_back(to);\n    r_edge[to].push_back(from);\n}\n\nvoid dfs(int v){\n    used[v] = true;\n    for(auto & nv : edge[v]){\n        if(not used[nv]) dfs(nv);\n    }\n    vs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n    used[v] = true;\n    cmp[v] = k;\n    for(auto & nv : r_edge[v]){\n        if(not used[nv]) rdfs(nv, k);\n    }\n}\n\nint scc(){\n    used = vector<bool>(n);\n    vs.clear();\n    rep(v, n){\n        if(not used[v]) dfs(v);\n    }\n\n    used = vector<bool>(n);\n    int k = 0;\n    rrep(i, vs.size()){\n        if(not used[vs[i]]) rdfs(vs[i], k++);\n    }\n\n    return k;\n}\n// ----------------------------\n\nint main(void){\n    int m;\n    cin >> n >> m;\n\n    edge = r_edge = vvi(n);\n    cmp = vi(n);\n\n    rep(loop, m){\n        int a, b; cin >> a >> b;\n        a--, b--;\n\n        add_edge(a, b);\n    }\n\n    int nn = scc();\n    int res = 1;\n\n    vector<set<int>> edges(nn);\n    rep(v, n){\n        for(auto & u : edge[v]){\n            if(cmp[v] == cmp[u]) continue;\n            edges[cmp[v]].insert(cmp[u]);\n        }\n    }\n\n    vi dp(nn, 1);\n    rep(v, nn){\n        for(auto & nv : edges[v]){\n            dp[nv] = MUL(dp[nv], dp[v] + 1, mod);\n        }\n\n        if(edges[v].size() == 0){\n            res = MUL(res, dp[v] + 1, mod);\n        }\n    }\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\nvector<vector<int> > g,rg;\n\n\n\nint done1[1010];\nint done2[1010];\nint numb[1010];\nvector<int> tpr;\nint dfs(int x){\n\tif( done1[x]++ ) return 0;\n\tfor(int i = 0 ; i < g[x].size() ; i++)\n\t\tdfs(g[x][i]);\n\ttpr.push_back(x);\n}\nint rdfs(int x,int k){\n\tif( done2[x]++ ) return 0;\n\tfor(int i = 0 ; i < rg[x].size() ; i++)\n\t\trdfs(rg[x][i],k);\n\tnumb[x] = k;\n}\n\nint field[1010][1010];\nint in[1010];\n\nvector<vector<int> >  newg;\nint scc(){\n\tfor(int i = 0 ; i < g.size() ; i++){\n\t\tdfs(i);\n\t}\n\treverse(tpr.begin(),tpr.end());\n\tint cnt = 0;\n\tfor(int i = 0 ; i < tpr.size() ; i++){\n\t\tint x = tpr[i];\n\t\tif( done2[x] == 0 ){\n\t\t\trdfs(x,cnt++);\n\t\t}\n\t}\n\tint n = tpr.size();\n\t\n\tfor(int i = 0 ; i < n ; i++){\n\t\tfor(int j = 0 ; j < g[i].size() ; j++){\n\t\t\tint to = g[i][j];\n\t\t\tfield[numb[i]][numb[to]] = true; \n\t\t}\n\t}\n\tnewg.resize(cnt);\n\tfor(int i = 0 ; i < cnt ; i++){\n\t\tfor(int j = 0 ; j < cnt ; j++){\n\t\t\tif( i != j && field[i][j] ) newg[i].push_back(j) , in[j]++;\n\t\t\t\n\t\t}\n\t}\n\treturn -1;\n}\n#define MOD (1000000007)\n\nlong long memdfs(int x){\n\tlong long ans = 1;\n\tfor(int i = 0 ; i < newg[x].size() ; i++){\n\t\tans *= memdfs(newg[x][i]);\n\t\tans %= MOD;\n\t}\n\treturn (ans + 1)%MOD;\n}\n\nint main(){\n\tint N,M;\n\tcin >> N >> M;\n\tg.resize(N);\n\trg.resize(N);\n\tfor(int i = 0 ; i < M ; i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\ta--,b--;\n\t\tg[b].push_back(a);\n\t\trg[a].push_back(b);\n\t}\n\tscc();\n\tlong long ans = 1;\n\tfor(int i = 0 ; i < newg.size() ; i++){\n\t\tif( in[i] == 0 ){\n\t\t\tans *= memdfs(i);\n\t\t\tans %= 1000000007;\n\t\t}\n\t}\n\tcout << ans % MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\ntypedef vector< vector<int> > graph;\nconst int MOD = 1000000007;\n\nint root[1000];\nint getRoot(int v){ return root[v]==-1 ? v : root[v] = getRoot(root[v]); }\nint group[1000];\nvoid visit(int pos, const graph& g, vector<int>& order, int key, bool first){\n\tif(group[pos] != -1) return;\n\tgroup[pos] = key;\n\tfor(int i=0;i<g[pos].size();i++)\n\t\tvisit(g[pos][i], g, order, key, first);\n\tif(first) order.push_back(pos);\n}\n\nvoid calcSCC(const graph& g){\n\tint n = g.size();\n\tgraph h(n);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<g[i].size();j++)\n\t\t\th[g[i][j]].push_back(i);\n\t}\n\tvector<int> order;\n\tmemset(group, -1, sizeof(group));\n\tfor(int i=0;i<n;i++) visit(i, g, order, i, true);\n\tmemset(group, -1, sizeof(group));\n\tfor(int i=0;i<n;i++) visit(order[n-1-i], h, order, i, false);\n}\n\nlong long search(const graph& g, int pos){\n\tlong long res = 1;\n\tfor(int i=0;i<g[pos].size();i++){\n\t\tres *= search(g, g[pos][i]);\n\t\tres %= MOD;\n\t}\n\treturn res+1;\n}\n\nint main(){\n\tint N, M;\n\twhile(cin >> N >> M){\n\t\tgraph g(N);\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint a, b; cin >> a >> b;\n\t\t\tg[a-1].push_back(b-1);\n\t\t}\n\t\tcalcSCC(g);\n\t\tmemset(root, -1, sizeof(root));\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=i+1;j<N;j++){\n\t\t\t\tif(group[i]==group[j]){\n\t\t\t\t\tint p = getRoot(i);\n\t\t\t\t\tint q = getRoot(j);\n\t\t\t\t\tif(p != q) root[q] = p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgraph h(N), g2(N);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<g[i].size();j++){\n\t\t\t\tint p = getRoot(i);\n\t\t\t\tint q = getRoot(g[i][j]);\n\t\t\t\tif(p != q){\n\t\t\t\t\th[q].push_back(p);\n\t\t\t\t\tg2[p].push_back(q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long res = 1;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(getRoot(i) == i && g2[i].size() == 0){\n\t\t\t\tres *= search(h, i);\n\t\t\t\tres %= MOD;\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n#define mod 1000000007\n\nint n;\nvector<int> g[1111],rg[1111],ng[1111];\nvector<int> vs;\nbool used[1111];\nint cmp[1111];\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int nv: g[v]){\n    if(!used[nv])dfs(nv);\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int nv: rg[v]){\n    if(!used[nv])rdfs(nv,k);\n  }\n}\n\nint m,k;\nll mem[1111][3];\n\nll rec(int v,int c){\n  if(mem[v][c]!=-1)return mem[v][c];\n  ll res=1;\n  for(int nv:ng[v]){\n    if(c==0){\n      res=(res*(rec(nv,0)+rec(nv,1)))%mod;\n    }else{\n      res=(res*rec(nv,1))%mod;\n    }\n  }\n  return mem[v][c]=res;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>n>>m;\n  rep(i,m){\n    int s,t;\n    cin>>s>>t;\n    s--; t--;\n    g[t].push_back(s); rg[s].push_back(t);\n  }\n  memset(used,0,sizeof(used));\n  vs.clear();\n  rep(i,n){\n    if(!used[i])dfs(i);\n  }\n  memset(used,0,sizeof(used));\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!used[vs[i]])rdfs(vs[i],k++);\n  }\n  rep(i,n){\n    for(int v: g[i]){\n      if(cmp[i]<cmp[v]&&!exist(ng[cmp[i]],cmp[v]))ng[cmp[i]].push_back(cmp[v]);\n    }\n  }\n  ll res=1;\n  memset(mem,-1,sizeof(mem));\n  rep(i,k){\n    if(mem[i][0]==-1){\n      res=(res*(rec(i,0)+rec(i,1)))%mod;\n    }\n    //dbg(rec(i,0)); dbg(rec(i,1));\n  }\n  cout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\n#define REP(i, b, n) for(int i = b; i < (int)n; i++)\n#define rep(i, n) REP(i, 0, n)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 1000;\nconst ll MOD = 1000000007;\n\n\nint V, cmp[N];\nvector<int> G[N], rG[N], vs;\nbool used[N];\nvoid init(){\n  rep(i, N){\n    G[i].clear();\n    rG[i].clear();\n  }\n  vs.clear();\n}\n\nvoid add_edge(int from, int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v] = true;\n  rep(i, G[v].size()){\n    if(!used[G[v][i]])dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n  used[v] = true;\n  cmp[v] = k;\n  rep(i, rG[v].size()){\n    if(!used[rG[v][i]])rdfs(rG[v][i], k);\n  }\n}\n\nint scc(){\n  rep(i, N)used[i] = false;\n  vs.clear();\n  rep(v, V){\n    if(!used[v])dfs(v);\n  }\n  rep(i, N)used[i] = false;\n  int k = 0;\n  for(int i = vs.size() -1; i>=0; i--){\n    if(!used[vs[i]])rdfs(vs[i], k++);\n  }\n  return k;\n}\n\n\npair<ll, ll> dp[N];\nbool visited[N];\nvector<int> edge[N];\n\n\npair<ll, ll> solve(int id){\n  if(dp[id].first >= 0 )return dp[id];\n  if(visited[id])return make_pair(1, 1);\n  \n  visited[id] = true;\n  pair<ll, ll> ret = make_pair(1, 1);\n  rep(i, edge[id].size()){\n    ll next = edge[id][i];\n    pair<ll, ll> result = solve(next);\n    ret.first *= (result.first + result.second);\n    ret.second *= result.second;\n    ret.first %= MOD;\n    ret.second %= MOD;;\n  }\n  return ret;\n}\n\nint main(){\n  int n, m;\n  while(cin >> n >> m){\n    if(n == 0 && m == 0)break;\n    V = n;\n    init();\n    vector<pair<int, int> > INPUT;\n    rep(i, m){\n      int from, to;\n      cin >> from >> to;\n      INPUT.push_back(make_pair(to-1,from-1));\n      add_edge(to-1, from-1);\n    }\n    int cnt = scc();\n    bool root[N];\n    rep(i, N)root[i] = true;\n    rep(i, N)edge[i].clear();\n    rep(i, INPUT.size()){\n      if(cmp[INPUT[i].first] == cmp[INPUT[i].second])continue;\n      edge[cmp[INPUT[i].first]]\t.push_back(cmp[INPUT[i].second]);\n      root[cmp[INPUT[i].second]] = false;\n    }\n    \n    rep(i, N)dp[i] = make_pair(-1, -1);\n    \n    ll ans = 1;\n    rep(i, cnt){\n      if(root[i] == true){\n\tpair<ll, ll> ret = solve(i);\n\tans *= (ret.first + ret.second)%MOD;\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nint N,M;\nvi g[1010],r[1010];\nint used[1010];\nint List[1010],l;\nint cycle[1010],c;\nint inCycle[1010];\nll dp[1010];\n\nvoid dfs(int cur){\n\tif(used[cur]){\n\t\tint from = 0;\n\t\twhile(List[from] != cur) from++;\n\t\trep2(i,from,l){\n\t\t\tcycle[c++] = List[i];\n\t\t}\n\t\treturn;\n\t}\n\tused[cur] = 1;\n\tList[l++] = cur;\n\tif(sz(g[cur]) == 0){\n\t\tcycle[c++] = cur;\n\t\treturn;\n\t}\n\trep(i,sz(g[cur])){\n\t\tdfs(g[cur][i]);\n\t}\n}\n\nll solve(int v){\n\tll& res=dp[v];\n\tif(res != -1)return res;\n\tused[v] = 1;\n\tres = 1;\n\trep(i,sz(r[v])){\n\t\tres = res * solve(r[v][i]) % MOD;\n\t}\n\tres = (res+1) % MOD;\n\treturn res;\n}\n\nll f(int start){\n\tl=0;\n\tc=0;\n\tdfs(start);\n\tll res = 1;\n\trep(i,c)inCycle[cycle[i]] = 1;\n\trep(i,c)rep(j,sz(r[cycle[i]])){\n\t\tif(inCycle[r[cycle[i]][j]])continue;\n\t\tres = res * solve(r[cycle[i]][j]) % MOD;\n\t}\n\tres = (res+1) % MOD;\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>N>>M;\n\trep(i,M){\n\t\tint s,d;\n\t\tcin>>s>>d;\n\t\ts--;d--;\n\t\tg[s].pb(d);\n\t\tr[d].pb(s);\n\t}\n\n\tmemset(dp,-1,sizeof(dp));\n\tll ans = 1;\n\trep(i,N)if(!used[i]){\n\t\tans = ans * f(i) % MOD;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i, b, e) for ( int i = b; i < (int)e; i++ )\n#define rep(i, n) REP(i, 0, n)\nstatic const int MAX = 10000;\n\npair<int, int> P[MAX];\nvector<pair<int, double> > G[MAX];\nint N, M;\n\ndouble getDist(double x1, double y1, double x2, double y2){\n  return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\n}\n\ndouble prim(){\n  double sum = 0.0;\n  priority_queue<pair<double, int> > PQ;\n  bool V[MAX];\n  rep(i, N) V[i] = false;\n\n  rep(s, N){\n    if ( V[s] ) continue;\n    PQ.push(make_pair(0, s));\n    pair<double, int> u;\n    while( !PQ.empty() ){\n      u = PQ.top(); PQ.pop();\n      if ( V[u.second] ) continue;\n      V[u.second] = true;\n      sum += u.first;\n      rep(i, G[u.second].size()){\n\tint v = G[u.second][i].first;\n\tdouble c = G[u.second][i].second;\n\tif ( V[v] ) continue;\n\tPQ.push(make_pair(c, v));\n      }\n    }\n  }\n  return sum;\n}\n\nmain(){\n  int s, t;\n  double sum = 0;\n  cin >> N >> M;\n  rep(i, N) cin >> P[i].first >> P[i].second;\n  rep(i, N) G[i].clear();\n  rep(i, M){\n    cin >> s >> t;\n    s--; t--;\n    double d = getDist(P[s].first, P[s].second, P[t].first, P[t].second);\n    sum += d;\n    G[s].push_back(make_pair(t, d));\n    G[t].push_back(make_pair(s, d));\n  }\n  printf(\"%.8lf\\n\", sum - prim());\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 10001\n#define f first\n#define s second\n#define mp make_pair\n#define mod 1000000007\n#define inf 1e8\nusing namespace std;\n \nint V,m;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nvector<pair<int,int> > vpp;\nbool used[MAX_V]={};\nint cmp[MAX_V];\nint dp[MAX_V];\nvector<int> e[MAX_V];\n \nvoid add_edge(int from, int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n \nvoid dfs(int v){\n  used[v] = true;\n  for(int i = 0;i < G[v].size();i++){\n    if(!used[G[v][i]])dfs(G[v][i]);\n  }\n  vs.push_back(v);\n}\n \nvoid rdfs(int v,int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i = 0;i < rG[v].size();i++){\n    if(!used[rG[v][i]]) rdfs(rG[v][i],k);\n  }\n}\n \nvoid scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v = 0;v < V;v++){\n    if(!used[v]) dfs(v);\n  }\n  memset(used,0,sizeof(used));\n  int k = 0;\n  for(int i = vs.size() - 1;i >= 0;i--){\n    if(!used[vs[i]])rdfs(vs[i],k++);\n  }\n  return;\n}\n\nint rec(int v,int cm){\n  int res=1;\n  int tmp=cmp[v];\n  if(cmp[v]==cm)return 1;\n  if(dp[cmp[v]]!=inf)return dp[cmp[v]];\n  if(rG[v].size()==0)return dp[cmp[v]]=2;\n\n  for(int i=0;i<e[tmp].size();i++){\n    int now=e[tmp][i];\n    for(int j=0;j<rG[now].size();j++){\n      int next=rG[now][j];\n      res*=rec(next,tmp);\n      res%=mod;\n    }\n  }\n  return dp[tmp]=res+1;\n}\n\nint main()\n{\n  int a,b,q;\n\n  cin>>V>>m;\n  for(int i=0;i<m;i++){\n    cin>>a>>b;\n    a--;b--;\n    add_edge(a,b);\n  }\n \n  scc();\n\n  for(int i=0;i<V;i++)vpp.push_back(mp((-1)*cmp[i],i));\n  sort(vpp.begin(),vpp.end());\n\n  for(int i=0;i<V;i++)vpp[i].f=(-1)*vpp[i].f;\n\n  for(int i=0;i<vpp.size();i++)e[vpp[i].f].push_back(vpp[i].s);\n\n  for(int i=0;i<V;i++)dp[i]=inf;\n  int ans=1;\n  for(int i=0;i<vpp.size();i++){\n    if(dp[vpp[i].f]==inf){\n      ans*=rec(vpp[i].s,inf);\n      ans%=mod;\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll M=1000000007;\n\nll dfs(int u,const vector<int> *T){\n\tif(T[u].empty()) return 2;\n\tll res=1;\n\trep(i,T[u].size()){\n\t\tint v=T[u][i];\n\t\tres=res*dfs(v,T)%M;\n\t}\n\treturn (res+1)%M;\n}\n\n// ツ出ツ篠淞青板つェツ債つ々 1 ツづ?つ「ツつ、ツ青ァツ姪アツつゥツづァ, ツ連ツ個仰青ャツ閉ェツづ債δ仰ーツプツづ可姪伉つェツつュツづ?づつつ「ツつスツ形ツづ可づ按づゥ\n// ツつアツづ個連ツ個仰青ャツ閉ェツづ可づつつ「ツづ?づ個嘉ーツづーツ仰?づ淞づゥ\nll solve(int n,const int *G){\n\tvector<int> G2[1000]; // G ツづ個陛督づ個古シツつォツづーツ逆ツ転ツつオツつスツグツδ可フ\n\trep(u,n) if(G[u]!=-1) G2[G[u]].push_back(u);\n\n\t// ツδ仰ーツプツ個淞出\n\trep(u,n){\n\t\tint v=u;\n\t\tbool vis[1000]={};\n\t\twhile(G[v]!=-1 && !vis[v]){\n\t\t\tvis[v]=true;\n\t\t\tv=G[v];\n\t\t}\n\t\tif(v==u){ // ツδ仰ーツプorツ債ェツつェツ個ゥツづつつゥツづ?つス\n\t\t\tll res=1;\n\t\t\tint v=u;\n\t\t\tdo{\n\t\t\t\t// ツδ仰ーツプツ湘」ツづ個各ツ陳クツ点ツづーツ債ェツづ?つキツづゥツ姪伉づ可づつつ「ツづ?督堋つヲツづーツ仰?づ淞づ? ツつサツづェツづァツづーツつゥツつッツつ?づュツつケツづゥ\n\t\t\t\trep(i,G2[v].size()){\n\t\t\t\t\tint w=G2[v][i];\n\t\t\t\t\tif(!vis[w]) res=res*dfs(w,G2)%M;\n\t\t\t\t}\n\t\t\t\tv=G[v];\n\t\t\t}while(v!=u);\n\t\t\treturn (res+1)%M; // ツづ?づェツづ?選ツづ篠づ按つ「ツづ?つ「ツつ、ツ嘉ーツつェツつ?づゥツづ個づ?+1\n\t\t}\n\t}\n\tassert(0);\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tint to[1000];\n\trep(u,n) to[u]=-1;\n\trep(i,m){\n\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\tto[u]=v;\n\t}\n\tvector<int> G[1000]; // ツ鳴ウツ古シツグツδ可フ\n\trep(u,n) if(to[u]!=-1) {\n\t\tint v=to[u];\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\n\tll ans=1;\n\tbool vis[1000]={};\n\trep(u,n) if(!vis[u]) {\n\t\tvis[u]=true;\n\n\t\tvector<int> cc;\n\t\tqueue<int> Q; Q.push(u);\n\t\twhile(!Q.empty()){ // ツ偲」ツ連ツ個仰青ャツ閉ェツつイツづ?づ可陳イツづ猟づゥ\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\tcc.push_back(u);\n\t\t\trep(i,G[u].size()){\n\t\t\t\tint v=G[u][i];\n\t\t\t\tif(!vis[v]) vis[v]=true, Q.push(v);\n\t\t\t}\n\t\t}\n\n\t\tint N=cc.size();\n\t\tint D[1000]; // ツ偲」ツ連ツ個仰づ按有ツ古シツグツδ可フ\n\t\trep(i,N) D[i]=-1;\n\t\trep(i,N) rep(j,N) {\n\t\t\tint u=cc[i],v=cc[j];\n\t\t\tif(to[u]==v) D[i]=j;\n\t\t}\n\t\tans=ans*solve(N,D)%M;\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\n#define mod 100000007LL\n\n\ntemplate<typename T>\nclass UF {\npublic:\n\tUF() {\n\t\tsize = 0;\n\t}\n\n\t//???????????\\??????\n\tvoid push( T a ) {\n\t\tM[a] = size;\n\t\tV.push_back( size );\n\t\trank.push_back( 0 );\n\t\tC.push_back( 1 );\n\t\tsize++;\n\t}\n\n\t//????????°??????????????????\n\tvoid unite( T a, T b ) {\n\t\tlong long int x = find( M[a] );\n\t\tlong long int y = find( M[b] );\n\t\tif( x == y )return;\n\t\tif( rank[x] < rank[y] ) {\n\t\t\tV[x] = y;\n\t\t\tC[y] += C[x];\n\t\t} else {\n\t\t\tV[y] = x;\n\t\t\tC[x] += C[y];\n\t\t\tif( rank[x] == rank[y] )rank[x]++;\n\t\t}\n\t}\n\n\tvoid merge( T a, T b ) {\n\t\tunite( a, b );\n\t}\n\n\t//????????°??????????????????????????????????????????\n\tbool same( T a, T b ) {\n\t\treturn find( M[a] ) == find( M[b] );\n\t}\n\n\t//????????°????????????????????°?????????\n\tlong long int group() {\n\t\tset<long long int>S;\n\t\tfor( long long int i = 0; i < V.size(); i++ ) {\n\t\t\tS.insert( find( V[i] ) );\n\t\t}\n\t\treturn S.size();\n\t}\n\n\t//??°?????????????±???????????????°?????????\n\tlong long int count( T a ) {\n\t\treturn C[find( M[a] )];\n\t}\n\n\t//????±???????????????°????????????ID?????????\n\tlong long int groupID( T a ) {\n\t\treturn find( M[a] );\n\t}\n\n\t//????????°?????????????????????????????????\n\tvector<T>friendList( T a ) {\n\t\tlong long int inputID = find( M[a] );\n\t\tvector<T>ret;\n\t\tfor( auto now : M ) {\n\t\t\tif( find( now.second ) == inputID ) {\n\t\t\t\tret.emplace_back( now.first );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\nprivate:\n\tvector<long long int>C, V, rank;\n\tmap < T, long long int>M;\n\tlong long int size;\n\n\t//?\\?????????§?????????\n\tlong long int find( long long int x ) {\n\t\tif( V[x] == x )return x;\n\t\telse return V[x] = find( V[x] );\n\t}\n};\n\n\n\nint main() {\n\tlong long int N, M;\n\tcin >> N >> M;\n\tUF<long long int>uf;\n\tfor( size_t i = 0; i < N; i++ ) {\n\t\tuf.push( i );\n\t}\n\tvector<vector<long long int>>D( N );\n\tvector<vector<long long int>>F( N );\n\tfor( size_t i = 0; i < M; i++ ) {\n\t\tlong long int x, y;\n\t\tcin >> x >> y;\n\t\tx--; y--;\n\t\tD[x].push_back( y );\n\t\tF[y].push_back( x );\n\t\tuf.merge( x, y );\n\t}\n\n\tfunction<long long int( long long int )> f = [&]( long long int idx )->long long int {\n\t\tlong long int ret = 1;\n\t\tfor( auto x : F[idx] ) {\n\t\t\tret *= f( x );\n\t\t\tret %= mod;\n\t\t}\n\t\treturn ret + 1;\n\t};\n\tlong long int ans = 1;\n\tset<long long int>checked;\n\tvector<bool>checkbool( N );\n\tfor( size_t i = 0; i < N; i++ ) {\n\t\tif( !checked.count( uf.groupID( i ) ) ) {\n\t\t\tchecked.insert( uf.groupID( i ) );\n\t\t\tauto group = uf.friendList( i );\n\n\t\t\tlong long int now = i;\n\t\t\twhile( !checkbool[now] && D[now].size() ) {\n\t\t\t\tcheckbool[now] = true;\n\t\t\t\tnow = D[now][0];\n\t\t\t}\n\n\t\t\tif( D[now].size() ) {\n\t\t\t\tauto now_ = D[now][0];\n\t\t\t\tset<long long int>SLL;\n\t\t\t\tSLL.insert( now );\n\t\t\t\tlong long int prev;\n\t\t\t\twhile( now_ != now ) {\n\t\t\t\t\tSLL.insert( now_ );\n\t\t\t\t\tprev = now_;\n\t\t\t\t\tfor( auto x : F[now_] ) {\n\t\t\t\t\t\tif( x != prev ) {\n\t\t\t\t\t\t\tF[now].push_back( x );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnow_ = D[now_][0];\n\t\t\t\t}\n\t\t\t\tF[now].erase( remove_if( F[now].begin(), F[now].end(), [&]( auto i ) { return SLL.count( i ); } ), F[now].end() );\n\t\t\t\tnow_ = D[now][0];\n\n\t\t\t}\n\t\t\tans *= f( now );\n\t\t\tans %= mod;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MOD 1000000007\n\nvector< vector<int> > G(1010);\nvector< vector<int> > rG(1010);\nvector< vector<int> > cG(1010);\nvector<int> post;\nint cmp[1010];\nbool used[1010];\nbool edge[1010][1010];\n\nint N, M;\n\nvoid dfs(int v)\n{\n  used[v] = true;\n  for(int i = 0; i < G[v].size(); i++){\n    if(!used[G[v][i]]) dfs(G[v][i]);\n  }\n  post.push_back(v);\n}\n\nvoid rdfs(int v, int k)\n{\n  used[v] = true;\n  cmp[v] = k;\n  for(int i = 0; i < rG[v].size(); i++){\n    if(!used[rG[v][i]]) rdfs(rG[v][i], k);\n  }\n}\n\nint scc()\n{\n  int k = 0;\n  memset(used, false, sizeof(used));\n  for(int i = 0; i < N; i++){\n    if(!used[i]) dfs(i);\n  }\n  memset(used, false, sizeof(used));\n  reverse(post.begin(), post.end());\n  for(int i = 0; i < post.size(); i++){\n    if(!used[post[i]]) rdfs(post[i], k++);\n  }\n  return k;\n}\n\nint solve(int v)\n{\n  int ret = 1;\n  for(int i = 0; i < cG[v].size(); i++){\n    ret = ret * solve(cG[v][i]) % MOD;\n  }\n  return (ret + 1) % MOD;\n}\n\nint main()\n{\n  cin >> N >> M;\n  G.resize(N);\n  rG.resize(N);\n  for(int i = 0; i < M; i++){\n    int S, D;\n    cin >> S >> D;\n    --S, --D;\n    G[S].push_back(D);\n    rG[D].push_back(S);\n  }\n  int L = scc();\n  cG.resize(L);\n  memset(edge, false, sizeof(edge));\n  for(int i = 0; i < 1010; i++) edge[i][i] = true;\n  for(int i = 0; i < N; i++){\n    for(int j = 0; j < G[i].size(); j++){\n      if(!edge[cmp[i]][cmp[G[i][j]]]){\n\tedge[cmp[i]][cmp[G[i][j]]] = true;\n\tcG[cmp[G[i][j]]].push_back(cmp[i]);\n      }\n    }\n  }\n  int ans = 1;\n  for(int i = 0; i < L; i++){\n    bool flag = false;\n    for(int j = 0; j < L; j++) if(i != j) flag |= edge[i][j];\n    if(!flag) ans = ans * solve(i) % MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 1005\n#define M 1000000007\nusing namespace std;\ntypedef long long ll;\n\nint V; //????????°\nvector<int> G[MAX_V]; //??°???????????£??\\??????????????¨???\nvector<int> rG[MAX_V];//?????????????????????????????°??????\nvector<int> vs;       //??°?????????????????????\nbool used[MAX_V];     //?????§???????????????\nint cmp[MAX_V];       //?±????????????£?????????????????????????????????\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  \n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\nint used2[MAX_V];\n\nll dfs2(int x){\n  if(used[x])return 1;\n  used[x]=true;\n  ll res=1;\n  for(int i=0;i<rG[x].size();i++){\n    int nx=rG[x][i];\n    ll r=dfs2(nx);\n    if(cmp[x]==cmp[nx])r--;\n    if(!r)r=1;\n    res=(res*r)%M;\n  }\n  return res+1;\n}\n\nint main(){\n  int n,m,s,d;\n  int goal[MAX_V];\n  cin>>n>>m;\n  V=n;\n  for(int i=0;i<n;i++)goal[i]=1;\n  for(int i=0;i<m;i++){\n    cin>>s>>d;\n    s--; d--;\n    add_edge(s,d);\n  }\n  int k=scc();\n  for(int i=0;i<n;i++)\n    for(int j=0;j<G[i].size();j++){\n      int x=G[i][j];\n      if(cmp[i]!=cmp[x])\n\tgoal[cmp[i]]=0;\n    }\n  ll ans=1;\n  for(int i=0;i<n;i++){\n    if(!goal[cmp[i]])continue;\n    memset(used,0,sizeof(used));\n    ans=(ans*dfs2(i))%M;\n    goal[cmp[i]]=0;\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntypedef vector<vector<int>> UnWeightedGraph;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\nconst ll mod = 1000000007;\ntemplate< typename G >\nstruct StronglyConnectedComponents {\n  const G &g;\n  UnWeightedGraph gg, rg;\n  vector< int > comp, order, used;\n\n  StronglyConnectedComponents(G &g) : g(g), gg(g.size()), rg(g.size()), comp(g.size(), -1), used(g.size()) {\n    for(int i = 0; i < g.size(); i++) {\n      for(auto e : g[i]) {\n        gg[i].emplace_back((int) e);\n        rg[(int) e].emplace_back(i);\n      }\n    }\n  }\n\n  int operator[](int k) {\n    return (comp[k]);\n  }\n\n  void dfs(int idx) {\n    if(used[idx]) return;\n    used[idx] = true;\n    for(int to : gg[idx]) dfs(to);\n    order.push_back(idx);\n  }\n\n  void rdfs(int idx, int cnt) {\n    if(comp[idx] != -1) return;\n    comp[idx] = cnt;\n    for(int to : rg[idx]) rdfs(to, cnt);\n  }\n\n  void build(UnWeightedGraph &t) {\n    for(int i = 0; i < gg.size(); i++) dfs(i);\n    reverse(begin(order), end(order));\n    int ptr = 0;\n    for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n\n    t.resize(ptr);\n    for(int i = 0; i < g.size(); i++) {\n      for(auto &to : g[i]) {\n        int x = comp[i], y = comp[to];\n        if(x == y) continue;\n        t[x].push_back(y);\n      }\n    }\n  }\n};\n\nvector<ll> dp[2];\nvector<int> visited;\nUnWeightedGraph t;\nbool Root[1001];\n\nvoid dfs(int now) {\n    if(visited[now]) return;\n    visited[now] = 1;\n    sort(t[now].begin(), t[now].end());\n    t[now].erase(unique(t[now].begin(), t[now].end()), t[now].end());\n    dp[1][now] = 1;\n    dp[0][now] = 1;\n    for(auto to : t[now]) {\n        Root[to] = false;\n        dfs(to);\n        dp[1][now] *= (dp[0][to] + dp[1][to]);\n        dp[1][now] %= mod;\n    }\n}\n\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N, M;\n    cin >> N >> M;\n    dp[0].resize(N);\n    dp[1].resize(N);\n    visited.resize(N);\n    UnWeightedGraph g(N);\n    for(int i = 0; i < M; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        g[b].push_back(a);\n    }\n    StronglyConnectedComponents<UnWeightedGraph> SCC(g);\n    SCC.build(t);\n    for(int i = 0; i < t.size(); i++) {\n        Root[i] = true;\n    }\n    for(int i = 0; i < t.size(); i++) {\n        dfs(i);\n    }\n    ll ans = 1;\n    for(int i = 0; i < t.size(); i++) {\n        if(Root[i]) {\n            ans *= (dp[0][i] + dp[1][i]);\n            ans %= mod;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Package: StandardCodeLibrary.Core\n * */\n//蠑戊ソ帛クク逕ィ逧?、エ譁?サカ蟷カ菴ソ逕ィstd蜷榊ュ礼ゥコ髣エ\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <utility>\n#include <vector>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <climits>\nusing namespace std;\n\n//逕ィ莠主?蟆台サ」遐??逧?ョ?//#define lp for(;;)\n//#define repf(i,a,b) for (int i=(a);i<(b);++i)\n//#define rrepf(i,a,b) for (int i=(a)-1;i>=(b);--i)\n//#define rep(i,n) repf(i,0,n)\n//#define rrep(i,n) rrepf(i,n,0)\n//#define ft(i,a,b) for (int i=(a);i<=(b);++i)\n//#define fdt(i,a,b) for (int i=(a);i>=(b);--i)\n//#define for_nonempty_subsets(subset,set) for (int subset=set;subset;subset=(subset-1)&(set))\n//#define for_in_charset(i,charset) for (cstr i=(charset);*i;i++)\n//#define while while\n//#define return return\n//#define fl(x,y) memset((x),char(y),sizeof(x))\n//#define clr(x) fl(x,char(0))\n//#define cpy(x,y) memcpy(x,y,sizeof(x))\n//#define sf scanf\n//#define pf printf\n//#define vec vector\n//#define pr pair\n//#define que queue\n//#define prq priority_queue\n//#define itr iterator\n//#define x first\n//#define y second\n//#define pb push_back\n//#define mp make_pair\n//#define ins insert\n//#define ers erase\n//#define lb lower_bound\n//#define ub upper_bound\n//#define rnk order_of_key\n//#define sel find_by_order\n//#define sz(x) (int((x).size()))\n//#define all(x) (x).begin(),(x).end()\n//#define srt(x) sort(all(x))\n//#define uniq(x) srt(x),(x).erase(unique(all(x)),(x).end())\n//#define rev(x) reverse(all(x))\n//#define shf(x) random_shuffle(all(x))\n//#define nxtp(x) next_permutation(all(x))\n\n//隹?ッ慕嶌蜈ウ逧?ョ?//#ifndef DEBUG\n//#define prt(x) (cerr)\n//#define asrtWA(s) do if(!(s))exit(0);while(0)\n//#define asrtTLE(s) do if(!(s))while(1);while(0)\n//#define asrtMLE(s) do if(!(s))while(new int);while(0)\n//#define asrtOLE(s) do if(!(s))while(1)puts(\"OLE\");while(0)\n//#define asrtRE(s) do if(!(s))*(int*)0=0;while(0)\n//#define runtime() (cerr)\n//#define input(in) freopen(in,\"r\",stdin)\n//#define output(out) freopen(out,\"w\",stdout)\n//#else\n//#define prt(x) cerr<<\"隨ャ\"<<__LINE__<<\"陦圭t: \"<<#x\"\\t=\"<<(x)<<endl\n//#define asrtWA(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;while(0)\n//#define asrtTLE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;while(0)\n//#define asrtMLE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;while(0)\n//#define asrtOLE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;while(0)\n//#define asrtRE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;while(0)\n//#define runtime() cerr<<\"Used: \"<<db(clock())/CLOCKS_PER_SEC<<\"s\"<<endl\n//#define input(in)\n//#define output(out)\n//#endif\n\n//蟶ク逕ィ謨ー謐ョ邀サ蝙?typedef long long int lli;\ntypedef double db;\ntypedef const char* cstr;\ntypedef string str;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<str> vs;\ntypedef pair<int,int> pii;\ntypedef pair<lli,lli> pll;\ntypedef pair<db,db> pdd;\ntypedef map<int,int> mii;\ntypedef map<str,int> msi;\ntypedef map<char,int> mci;\ntypedef set<int> si;\ntypedef set<str> ss;\ntypedef queue<int> qi;\ntypedef vector<pii> vpii;\ntypedef vector<pdd> vpdd;\n\n//蟶ク逕ィ蟶ク驥?int逧?怙螟ァ蛟シ;lli逧?怙螟ァ蛟シ;db逧?ッッ蟾ョ逶ク蜈ウ蟶ク謨ー;谺ァ諡牙クク謨ー;蝨?捉邇?遘サ蜉ィ蜷鷹?;蜿匁ィ。菴ソ逕ィ逧?勁謨ー\nint oo=(~0u)>>1;\nlli ooll=(~0ull)>>1;\ndb inf=1e+10;\ndb eps=1e-10;\ndb gam=0.5772156649015328606;\ndb pi=acos(-1.0);\nint dx[]={1,0,-1,0,1,-1,-1,1,0};\nint dy[]={0,1,0,-1,1,1,-1,-1,0};\nint MOD=1000000007;\n\n//蟶ク逕ィ蜃ス謨ー:譛?、ァ譛?ー丞?譖エ譁ー;謨ー蟄ヲ逶ク蜈ウ蜃ス謨ー;霎灘?蜥瑚セ灘?;譬醍憾謨ー扈?蟷カ譟・髮?蜿ッ蜷亥ケカ蝣?\ntemplate<typename type>inline bool cmax(type& a,const type& b){return a<b?a=b,true:false;}\ntemplate<typename type>inline bool cmin(type& a,const type& b){return b<a?a=b,true:false;}\n\n//蛻晏ァ句喧\nstruct Initializer\n{\n//#ifndef DEBUG\n\tInitializer(){ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);}\n//#else\n//\t~Initializer(){runtime();}\n//#endif\n}initializer;\n//\n////髱樊?蜃?//#define feach(e,s) for (__typeof__((s).begin()) e=(s).begin();e!=(s).end();++e)\n//#include <ext/rope>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//#include <ext/pb_ds/tag_and_trait.hpp>\n//using __gnu_cxx::rope;\n//template<typename key,typename value>class ext_map:public __gnu_pbds::tree<key,value,less<key>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>{};\n//#define ctz __builtin_ctz\n//#define clz __builtin_clz\n//#define bc __builtin_popcount\n\nconst int MAXV=1000;\nconst int MAXE=1000000;\ntypedef struct struct_edge* edge;\nstruct struct_edge{int v;edge n;}pool[MAXE];\nedge top;\nint V;\nedge adj[MAXV];\nvoid build_graph(int v)\n{\n\ttop=pool,memset(adj,0,sizeof adj);\n\tV=v;//轤ケ謨ー\n\t//add_edge(u,v);\n}\nvoid add_edge(int u,int v)\n{\n\ttop->v=v,top->n=adj[u],adj[u]=top++;\n}\nint ord;\nint dfn[MAXV];\nint low[MAXV];\nint stks;\nint stk[MAXV];\nbool ins[MAXV];\nint cnt;\nint bl[MAXV];\nvoid dfs(int u)\n{\n\tdfn[u]=low[u]=++ord;\n\tins[stk[stks++]=u]=true;\n\tfor (edge i=adj[u];i;i=i->n)\n\t\tif (!dfn[i->v]) dfs(i->v),cmin(low[u],low[i->v]);\n\t\telse if (ins[i->v]) cmin(low[u],dfn[i->v]);\n\tif (dfn[u]==low[u])\n\t{\n\t\tint v;\n\t\tdo ins[v=stk[--stks]]=false,bl[v]=cnt;\n\t\twhile(v!=u);\n\t\tcnt++;\n\t}\n}\nvoid tarjan()\n{\n\tord=0,memset(dfn,0,sizeof dfn),cnt=0;\n\tfor(int i=0;i<V;i++) if (!dfn[i]) dfs(i);\n}\n\nint main()\n{\n\tint n,m;\n\tcin>>n>>m;\n\tbuild_graph(n);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint s,d;\n\t\tcin>>s>>d,--s,--d;\n\t\tadd_edge(s,d);\n\t}\n\ttarjan();\n\tvvi adj(cnt);\n\tvvi radj(cnt);\n\tfor(int i=0;i<V;i++) for (edge e=::adj[i];e;e=e->n) if (bl[i]!=bl[e->v]) adj[bl[i]].push_back(bl[e->v]);\n\tfor(int i=0;i<cnt;i++) sort(adj[i].begin(),adj[i].end()),unique(adj[i].begin(),adj[i].end());\n\tvi id(cnt);\n\tfor(int i=0;i<cnt;i++) for (int j=0;j<adj[i].size();j++) id[adj[i][j]]++;\n\tqi q;\n\tvector<pll> f(n);\n\tfor(int i=0;i<cnt;i++) if (id[i]==0) q.push(i),f[i]=make_pair(1,1);\n\tlli ans=1;\n\twhile(q.size())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tif (!adj[u].size()) ans=(ans*(f[u].first+f[u].second))%MOD;\n\t\tfor(int i=0;i<adj[u].size();i++)\n\t\t{\n\t\t\tint v=adj[u][i];\n\t\t\tradj[v].push_back(u);\n\t\t\tif ((--id[v])==0)\n\t\t\t{\n\t\t\t\tq.push(v);\n\t\t\t\tf[v]=make_pair(1,1);\n\t\t\t\tfor (int j=0;j<radj[v].size();j++)\n\t\t\t\t{\n\t\t\t\t\tint w=radj[v][j];\n\t\t\t\t\tf[v].first*=f[w].first+f[w].second;\n\t\t\t\t\tf[v].second*=f[w].second;\n\t\t\t\t\tf[v].first%=MOD;\n\t\t\t\t\tf[v].second%=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nstruct SCC\n{\n\tvector<vector<int> > G;\n\tvector<vector<int> > rG;\n\tvector<int> vs;\n\tvector<bool> used;\n\tvector<int> cmp;\n\tint sz,newsz;\n\tSCC(int n):G(n),rG(n),used(n,false),cmp(n){sz = n;}\n\t\n\tvoid add_edge(int from,int to)\n\t{\n\t\tG[from].PB(to);\n\t\trG[to].PB(from);\n\t}\n\t\n\tvoid dfs(int v)\n\t{\n\t\tused[v] = true;\n\t\tREP(i,G[v].size())\n\t\t{\n\t\t\tif(!used[G[v][i]])dfs(G[v][i]);\n\t\t}\n\t\tvs.PB(v);\n\t}\n\t\n\tvoid rdfs(int v,int k)\n\t{\n\t\tused[v] = false;\n\t\tcmp[v] = k;\n\t\tREP(i,rG[v].size())\n\t\t{\n\t\t\tif(used[rG[v][i]])rdfs(rG[v][i],k);\n\t\t}\n\t}\n\t\n\tint reMake()\n\t{\n\n\t\tvs.clear();\n\t\tREP(i,sz)if(!used[i])dfs(i);\n\t\tint k = 0;\n\t\tfor(int i = sz-1;i >= 0;i--)\n\t\t{\n\t\t\tif(used[vs[i]])\n\t\t\t{\n\t\t\t\trdfs(vs[i],k++);\n\t\t\t}\n\t\t}\n\t\treturn newsz = k;\n\t}\n\t\n\t\n\t\n\tvoid makeList(vector<vector<int> > &v)\n\t{\n\t\tREP(i,sz)\n\t\t{\n\t\t\tREP(j,G[i].size())\n\t\t\t{\n\t\t\t\tif(cmp[i] == cmp[G[i][j]])continue;\n\t\t\t\tv[cmp[i]].PB(cmp[G[i][j]]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid makeReverseList(vector<vector<int> > &v)\n\t{\n\t\tREP(i,sz)\n\t\t{\n\t\t\tREP(j,G[i].size())\n\t\t\t{\n\t\t\t\tif(cmp[i] == cmp[G[i][j]])continue;\n\t\t\t\tv[cmp[G[i][j]]].PB(cmp[i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint scc_node(int n)\n\t{\n\t\treturn cmp[n];\n\t}\n};\n\n#define MOD 1000000007\n\nvector<vector<int> > v(1000);\nvector<vector<int> > rv(1000);\n\nll kaijo[1000];\nbool check[10001];\n\nll dfs(int n)\n{\n\tcheck[n] = true;\n\tll ret = 1;\n\tint num = rv[n].size();\n\t//cout << n << \"'s num is \" << num << endl;\n\tif(num == 0)\n\t{\n\t//\tcout << ' ' << ret << endl;\n\t\treturn ret;\n\t}\n\tif(num == 1)\n\t{\n\t\tret =(ret + dfs(rv[n][0]))% MOD;\n\t//cout << ' ' << ret << endl;\n\t\treturn ret;\n\t}\n\tll kai = kaijo[num-2];\n\tret = (kaijo[num] + MOD)%MOD;\n\t//cout << \"    \" << ret << endl;\n\tvector<ll> tmp;\n\t\n\tREP(i,num)\n\t{\n\t\ttmp.PB(dfs(rv[n][i]));\n\t}\n\t\n\tfor(int i = 0;i < num;i++)\n\t{\n\t\tfor(int j = i+1;j < num;j++)\n\t\t{\n\t\t\tret = (ret + (((tmp[i]*tmp[j] - 1LL)%MOD)*kai)%MOD)%MOD;\n\t\t}\n\t}\n\t//cout << ' ' << ret << endl;\n\t\n\treturn ret;\n}\n\nint main()\n{\n\tint n,m;cin >> n >> m;\n\t\n\tkaijo[0] = 1;\n\tfor(int i = 1;i < 1000;i++)\n\t{\n\t\tkaijo[i] = (kaijo[i-1]*2)%MOD;\n\t}\n\tSCC scc(n);\n\tREP(i,m)\n\t{\n\t\tint a,b;cin >> a >> b;\n\t\ta--;b--;\n\t\tscc.add_edge(a,b);\n\t}\n\t\n\tscc.reMake();\n\tscc.makeList(v);\n\tscc.makeReverseList(rv);\n\t\n\t//cout << scc.newsz << endl;\n\t\n\tll ans = 1;\n\tREP(i,scc.newsz)\n\t{\n\t\tif(v[i].size() == 0 && !check[i])\n\t\t{\n\t\t\tans = (ans * (dfs(i)+1LL)%MOD)%MOD;\n\t\t//\tcout << ans << endl;\n\t\t//cout << \"!\";\n\t\t}\n\t}\t\t\n\t\n\tcout << ans%MOD << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\n\n//Strong Connected Component Decomposition\nvector<int> g[1010];\nvector<int> rg[1010];\nvector<int> vs;\nbool use[1010];\nint ord[1010];\nint n,m;\n\nvoid fdfs(int v){\n  use[v] = true;\n  for(int u : g[v]){\n    if(!use[u])fdfs(u);\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  use[v] = true;\n  ord[v] = k;\n  \n  for(int u : rg[v]){\n    if(!use[u])rdfs(u,k);\n  }\n}\n\nint scc(){\n  memset(use,0,sizeof(use));\n  vs.clear();\n  rep(i,n){\n    if(!use[i])fdfs(i);\n  }\n\n  memset(use,0,sizeof(use));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!use[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint main(){\n  cin >> n >> m;\n  rep(i,m){\n    int a,b;\n    cin >> a >> b; a--; b--;\n    g[a].push_back(b);\n    rg[b].push_back(a);\n  }\n  int k = scc();\n\n  vector< vector<int> > ng(k);\n  rep(v,n){\n    for(int u : g[v]){\n      if(ord[v]!=ord[u])ng[ord[v]].push_back(ord[u]);\n    }\n  }\n\n  vector<int> deg(k,0);\n  rep(v,k){\n    sort(all(ng[v]));\n    ng[v].erase(unique(all(ng[v])),ng[v].end());\n    for(int u : ng[v])deg[u]++;\n  }\n\n  queue<int> q;\n  rep(v,k)if(deg[v]==0)q.push(v);\n  vector<int> to;\n\n  while(q.size()){\n    int v = q.front(); q.pop();\n    to.push_back(v);\n    for(int u : ng[v]){\n      deg[u]--;\n      if(deg[u]==0)q.push(u);\n    }\n  }\n  \n  vector<ll> dp0(k,1), dp1(k,1);\n  ll ans = 1;\n  rep(i,k){\n    int v = to[i];\n    for(int u : ng[v]){\n      (dp0[u] *= dp0[v]) %= mod;\n      (dp1[u] *= dp0[v] + dp1[v]) %= mod;\n    }\n    if(ng[v].empty()) (ans *= dp0[v] + dp1[v]) %= mod;\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define MAX_V 100000\n#define N MAX_V\nusing namespace std;\ntypedef long long ll;\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\nint n,m;\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  \n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\nvoid mk_G(){\n  int k=scc();\n  vector <int> tmp[N],rtmp[N];\n  for(int i=0;i<n;i++){\n    for(int j=0;j<G[i].size();j++)\n      if(cmp[i]!=cmp[G[i][j]]) tmp[cmp[i]].push_back(cmp[G[i][j]]);\n    for(int j=0;j<rG[i].size();j++)\n      if(cmp[i]!=cmp[rG[i][j]]) rtmp[cmp[i]].push_back(cmp[rG[i][j]]);\n    G[i].clear();\n    rG[i].clear();\n  }\n  n=k;\n  for(int i=0;i<k;i++) G[i]=tmp[i],rG[i]=rtmp[i];\n}\n \nll calc(int pos){\n  if(used[pos]) return 1;\n  used[pos]=1;\n  ll res=1;\n  for(int i=0;i<rG[pos].size();i++)res=res*calc(rG[pos][i])%mod;\n  return (res+1)%mod;\n}\n \n\nint main(){\n  cin>>n>>m;\n  V=n;\n  for(int i=0,a,b;i<m;i++)cin>>a>>b,add_edge(a-1,b-1);\n  mk_G();\n  ll ans=1;\n  memset(used,0,sizeof(used));\n  for(int i=0;i<n;i++) if(!G[i].size())ans=ans*calc(i)%mod;\n  cout <<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\n#define mod 1000000007LL\n\n\ntemplate<typename T>\nclass UF {\npublic:\n\tUF() {\n\t\tsize = 0;\n\t}\n\n\t//???????????\\??????\n\tvoid push( T a ) {\n\t\tM[a] = size;\n\t\tV.push_back( size );\n\t\trank.push_back( 0 );\n\t\tC.push_back( 1 );\n\t\tsize++;\n\t}\n\n\t//????????°??????????????????\n\tvoid unite( T a, T b ) {\n\t\tlong long int x = find( M[a] );\n\t\tlong long int y = find( M[b] );\n\t\tif( x == y )return;\n\t\tif( rank[x] < rank[y] ) {\n\t\t\tV[x] = y;\n\t\t\tC[y] += C[x];\n\t\t} else {\n\t\t\tV[y] = x;\n\t\t\tC[x] += C[y];\n\t\t\tif( rank[x] == rank[y] )rank[x]++;\n\t\t}\n\t}\n\n\tvoid merge( T a, T b ) {\n\t\tunite( a, b );\n\t}\n\n\t//????????°??????????????????????????????????????????\n\tbool same( T a, T b ) {\n\t\treturn find( M[a] ) == find( M[b] );\n\t}\n\n\t//????????°????????????????????°?????????\n\tlong long int group() {\n\t\tset<long long int>S;\n\t\tfor( long long int i = 0; i < V.size(); i++ ) {\n\t\t\tS.insert( find( V[i] ) );\n\t\t}\n\t\treturn S.size();\n\t}\n\n\t//??°?????????????±???????????????°?????????\n\tlong long int count( T a ) {\n\t\treturn C[find( M[a] )];\n\t}\n\n\t//????±???????????????°????????????ID?????????\n\tlong long int groupID( T a ) {\n\t\treturn find( M[a] );\n\t}\n\n\t//????????°?????????????????????????????????\n\tvector<T>friendList( T a ) {\n\t\tlong long int inputID = find( M[a] );\n\t\tvector<T>ret;\n\t\tfor( auto now : M ) {\n\t\t\tif( find( now.second ) == inputID ) {\n\t\t\t\tret.emplace_back( now.first );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\nprivate:\n\tvector<long long int>C, V, rank;\n\tmap < T, long long int>M;\n\tlong long int size;\n\n\t//?\\?????????§?????????\n\tlong long int find( long long int x ) {\n\t\tif( V[x] == x )return x;\n\t\telse return V[x] = find( V[x] );\n\t}\n};\n\n\n\nint main() {\n\tlong long int N, M;\n\tcin >> N >> M;\n\tUF<long long int>uf;\n\tfor( size_t i = 0; i < N; i++ ) {\n\t\tuf.push( i );\n\t}\n\tvector<vector<long long int>>D( N );\n\tvector<vector<long long int>>F( N );\n\tfor( size_t i = 0; i < M; i++ ) {\n\t\tlong long int x, y;\n\t\tcin >> x >> y;\n\t\tx--; y--;\n\t\tD[x].push_back( y );\n\t\tF[y].push_back( x );\n\t\tuf.merge( x, y );\n\t}\n\n\tfunction<long long int( long long int )> f = [&]( long long int idx )->long long int {\n\t\tlong long int ret = 1;\n\t\tfor( auto x : F[idx] ) {\n\t\t\tret *= f( x );\n\t\t\tret %= mod;\n\t\t}\n\t\treturn ret + 1;\n\t};\n\tlong long int ans = 1;\n\tset<long long int>checked;\n\tvector<bool>checkbool( N );\n\tfor( size_t i = 0; i < N; i++ ) {\n\t\tif( !checked.count( uf.groupID( i ) ) ) {\n\t\t\tchecked.insert( uf.groupID( i ) );\n\t\t\tauto group = uf.friendList( i );\n\n\t\t\tlong long int now = i;\n\t\t\twhile( !checkbool[now] && D[now].size() ) {\n\t\t\t\tcheckbool[now] = true;\n\t\t\t\tnow = D[now][0];\n\t\t\t}\n\n\t\t\tif( D[now].size() ) {\n\t\t\t\tauto now_ = D[now][0];\n\t\t\t\tset<long long int>SLL;\n\t\t\t\tSLL.insert( now );\n\t\t\t\tlong long int prev;\n\t\t\t\twhile( now_ != now ) {\n\t\t\t\t\tSLL.insert( now_ );\n\t\t\t\t\tprev = now_;\n\t\t\t\t\tfor( auto x : F[now_] ) {\n\t\t\t\t\t\tif( x != prev ) {\n\t\t\t\t\t\t\tF[now].push_back( x );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnow_ = D[now_][0];\n\t\t\t\t}\n\t\t\t\tF[now].erase( remove_if( F[now].begin(), F[now].end(), [&]( auto i ) { return SLL.count( i ); } ), F[now].end() );\n\t\t\t\tnow_ = D[now][0];\n\n\t\t\t}\n\t\t\tans *= f( now );\n\t\t\tans %= mod;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvoid stronglyConnectedComponents(const vector<vector<int> >& edges1, vector<vector<int> >& nodes, vector<vector<int> >& edges2)\n{\n    const int n = edges1.size();\n\n    class Func{\n        vector<int> num, low;\n        vector<bool> isStk;\n        stack<int> stk;\n        int time;\n    public:\n        Func(int n){\n            num.assign(n, 0);\n            low.assign(n, 0);\n            isStk.assign(n, false);\n            time = 0;\n        }\n        void visit(const vector<vector<int> >& edges, int v, vector<vector<int> >& nodes){\n            if(num[v] != 0)\n                return;\n            num[v] = low[v] = ++ time;\n            stk.push(v);\n            isStk[v] = true;\n            for(unsigned i=0; i<edges[v].size(); ++i){\n                int w = edges[v][i];\n                visit(edges, w, nodes);\n                if(isStk[w])\n                    low[v] = min(low[v], low[w]);\n            }\n            if(low[v] == num[v]){\n                nodes.push_back(vector<int>());\n                for(;;){\n                    int w = stk.top();\n                    stk.pop();\n                    isStk[w] = false;\n                    nodes.back().push_back(w);\n                    if(v == w)\n                        break;\n                }\n            }\n        }\n    }func(n);\n\n    nodes.clear();\n    for(int i=0; i<n; ++i)\n        func.visit(edges1, i, nodes);\n    reverse(nodes.begin(), nodes.end()); // DAGにするために反転させる\n\n    const int m = nodes.size();\n    vector<int> index(n); // 元のグラフの各頂点のDAGにおける頂点\n    for(int i=0; i<m; ++i){\n        for(unsigned j=0; j<nodes[i].size(); ++j)\n            index[nodes[i][j]] = i;\n    }\n    edges2.assign(m, vector<int>());\n    vector<vector<bool> > check(m, vector<bool>(m, false));\n    for(int i=0; i<n; ++i){\n        for(unsigned j=0; j<edges1[i].size(); ++j){\n            int v = index[i];\n            int w = index[edges1[i][j]];\n            if(v != w && !check[v][w]){\n                edges2[v].push_back(w);\n                check[v][w] = true;\n            }\n        }\n    }\n}\n\nconst int MOD = 1000000007;\n\nlong long solve(const vector<vector<int> >& edges, int curr)\n{\n    long long ret = 1;\n    for(unsigned i=0; i<edges[curr].size(); ++i){\n        ret *= solve(edges, edges[curr][i]);\n        ret %= MOD;\n    }\n    ++ ret;\n    ret %= MOD;\n\n    return ret;\n}\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int> > edges0(n);\n    for(int i=0; i<m; ++i){\n        int s, d;\n        cin >> s >> d;\n        edges0[d-1].push_back(s-1);\n    }\n\n    vector<vector<int> > edges, nodes;\n    stronglyConnectedComponents(edges0, nodes, edges);\n    n = edges.size();\n\n    vector<bool> check(n, false);\n    for(int i=0; i<n; ++i){\n        for(unsigned j=0; j<edges[i].size(); ++j){\n            check[edges[i][j]] = true;\n        }\n    }\n\n    long long ret = 1;\n    for(int i=0; i<n; ++i){\n        if(!check[i]){\n            ret *= solve(edges, i);\n            ret %= MOD;\n        }\n    }\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll M=1000000007;\n\nll dfs(int u,const vector<int> *T){\n\tif(T[u].empty()) return 2;\n\tll res=1;\n\trep(i,T[u].size()){\n\t\tint v=T[u][i];\n\t\tres=res*dfs(v,T)%M;\n\t}\n\treturn (res+1)%M;\n}\n\n// 出次数が高々 1 という制約から, 連結成分はループに木がくっついた形になる\n// この連結成分についての解を求める\nll solve(int n,const int *G){\n\tvector<int> G2[1000]; // G の辺の向きを逆転したグラフ\n\trep(u,n) if(G[u]!=-1) G2[G[u]].push_back(u);\n\n\t// ループ検出\n\trep(u,n){\n\t\tint v=u;\n\t\tbool vis[1000]={};\n\t\twhile(G[v]!=-1 && !vis[v]){\n\t\t\tvis[v]=true;\n\t\t\tv=G[v];\n\t\t}\n\t\tif(v==u){ // ループor根が見つかった\n\t\t\tll res=1;\n\t\t\tint v=u;\n\t\t\tdo{\n\t\t\t\t// ループ上の各頂点を根とする木について答えを求めて, それらをかけあわせる\n\t\t\t\trep(i,G2[v].size()){\n\t\t\t\t\tint w=G2[v][i];\n\t\t\t\t\tif(!vis[w]) res=res*dfs(w,G2)%M;\n\t\t\t\t}\n\t\t\t\tv=G[v];\n\t\t\t}while(v!=u && v!=-1);\n\t\t\treturn (res+1)%M; // どれも選ばないという解があるので +1\n\t\t}\n\t}\n\tfor(;;);\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tint to[1000];\n\trep(u,n) to[u]=-1;\n\trep(i,m){\n\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\tto[u]=v;\n\t}\n\tvector<int> G[1000]; // 無向グラフ\n\trep(u,n) if(to[u]!=-1) {\n\t\tint v=to[u];\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\n\tll ans=1;\n\tbool vis[1000]={};\n\trep(u,n) if(!vis[u]) {\n\t\tvis[u]=true;\n\n\t\tvector<int> cc;\n\t\tqueue<int> Q; Q.push(u);\n\t\twhile(!Q.empty()){ // 弱連結成分ごとに調べる\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\tcc.push_back(u);\n\t\t\trep(i,G[u].size()){\n\t\t\t\tint v=G[u][i];\n\t\t\t\tif(!vis[v]) vis[v]=true, Q.push(v);\n\t\t\t}\n\t\t}\n\n\t\tint N=cc.size();\n\t\tint D[1000]; // 弱連結な有向グラフ\n\t\trep(i,N) D[i]=-1;\n\t\trep(i,N) rep(j,N) {\n\t\t\tint u=cc[i],v=cc[j];\n\t\t\tif(to[u]==v) D[i]=j;\n\t\t}\n\t\tans=ans*solve(N,D)%M;\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <set>\n#define X first\n#define Y second\n#define sqr(x) (x)*(x)\nusing namespace std;\nconst double PI = acos(-1.0);\nmap<int,int>::iterator it;\ntypedef long long LL ;\n#pragma comment(linker,\"/STACK:102400000,102400000\")\n\nconst int N = 1005;\nconst int M = 20000006;\nstruct edge\n{\n    int u,v,pre;\n} E1[M],E2[M];\nint head[N],hd[N],nedge,cnt,dfn[N],low[N],instack[N],belong[N];\nint n,m,tsp,qlen;\nvector<int> qlt[N];\nstack<int> S;\n\nvoid init()\n{\n    for(int i=0; i<N; ++i)qlt[i].clear();\n    memset(hd,-1,sizeof(hd));\n    memset(head,-1,sizeof(head));\n    memset(dfn,-1,sizeof(dfn));\n    memset(instack,0,sizeof(instack));\n    nedge=0;\n    cnt=0;\n    tsp=0;\n    qlen=0;\n    while(!S.empty())S.pop();\n}\nvoid add_edge(int u,int v)\n{\n    E1[nedge].u=u;\n    E1[nedge].v=v;\n    E1[nedge].pre=head[u];\n    head[u]=nedge++;\n}\nvoid add_edge2(int u,int v)\n{\n    E2[cnt].u=u;\n    E2[cnt].v=v;\n    E2[cnt].pre=hd[u];\n    hd[u]=cnt++;\n}\nvoid dfs(int u)\n{\n    //printf(\"u=%d\\n\",u);\n    dfn[u]=low[u]=++tsp;\n    S.push(u);\n    instack[u]=1;\n    //puts(\"ok\");\n    for(int e=head[u]; ~e; e=E1[e].pre)\n    {\n        //printf(\"e=%d\\n\",e);\n        int v = E1[e].v;\n        //printf(\"v=%d\\n\",v);\n        if(dfn[v]==-1)\n        {\n            dfs(v);\n            low[u]=min(low[v],low[u]);\n        }\n        else if(instack[v])\n        {\n            low[u]=min(low[u],dfn[v]);\n        }\n    }\n    //printf(\"u=%d\\n\",u);\n    if(dfn[u]==low[u])\n    {\n        int p = u;\n        while(S.top()!=p)\n        {\n            qlt[qlen].push_back(S.top());\n            belong[S.top()]=qlen;\n            instack[S.top()]=0;\n            S.pop();\n        }\n        qlt[qlen].push_back(p);\n        belong[p]=qlen++;\n        instack[p]=0;\n        S.pop();\n    }\n}\nLL dp[N][2];\nint ind[N];\nbool vis[N];\nLL res;\nLL mod = 1000000007LL;\nvoid dfs2(int u)\n{\n    bool dfsed=false;\n    if(hd[u]==-1)\n    {\n        dp[u][0]=1;\n        dp[u][1]=1;\n        return ;\n    }\n    for(int e=hd[u]; ~e; e=E2[e].pre)\n    {\n        int v = E2[e].v;\n        dfs2(v);\n        dp[u][1]+=dp[v][0];\n        dp[u][1]+=dp[v][1];\n        dp[u][1]%=mod;\n        dfsed=true;\n    }\n    ++dp[u][0];\n}\nvoid gao()\n{\n    memset(vis,0,sizeof(vis));\n    memset(dp,0,sizeof(dp));\n    memset(ind,0,sizeof(ind));\n    for(int i=0; i<nedge; ++i)\n    {\n        if(belong[ E1[i].u ]!=belong[ E1[i].v ])\n        {\n            ind[ belong[ E1[i].u ] ]++;\n            add_edge2(belong[ E1[i].v ],belong[ E1[i].u ]);\n        }\n    }\n    res=1;\n    for(int i=0; i<qlen; ++i)\n    {\n        if(ind[i]==0)\n        {\n            dfs2(i);\n            res *= (dp[i][0]+dp[i][1]);\n            res %= mod;\n        }\n    }\n}\nint main()\n{\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        init();\n        for(int i=0; i<m; ++i)\n        {\n            int u,v;\n            scanf(\"%d%d\",&u,&v);\n            add_edge(u,v);\n        }\n        for(int i=1; i<=n; ++i)if(dfn[i]==-1)dfs(i);\n        gao();\n        //for(int i=0; i<qlen; ++i)printf(\"%d: %lld %lld\\n\",i,dp[i][0],dp[i][1]);\n\n        printf(\"%lld\\n\",res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll M=1000000007;\n\nll dfs(int u,const vector<int> *T){\n\tif(T[u].empty()) return 2;\n\tll res=1;\n\trep(i,T[u].size()){\n\t\tint v=T[u][i];\n\t\tres=res*dfs(v,T)%M;\n\t}\n\treturn (res+1)%M;\n}\n\n// ツ出ツ篠淞青板つェツ債つ々 1 ツづ?つ「ツつ、ツ青ァツ姪アツつゥツづァ, ツ連ツ個仰青ャツ閉ェツづ債δ仰ーツプツづ可姪伉つェツつュツづ?づつつ「ツつスツ形ツづ可づ按づゥ\n// ツつアツづ個連ツ個仰青ャツ閉ェツづ可づつつ「ツづ?づ個嘉ーツづーツ仰?づ淞づゥ\nll solve(int n,const int *G){\n\tvector<int> G2[1000]; // G ツづ個陛督づ個古シツつォツづーツ逆ツ転ツつオツつスツグツδ可フ\n\trep(u,n) if(G[u]!=-1) G2[G[u]].push_back(u);\n\n\t// ツδ仰ーツプツ個淞出\n\trep(u,n){\n\t\tint v=u;\n\t\tbool vis[1000]={};\n\t\twhile(G[v]!=-1 && !vis[v]){\n\t\t\tvis[v]=true;\n\t\t\tv=G[v];\n\t\t}\n\t\tif(v==u){ // ツδ仰ーツプorツ債ェツつェツ個ゥツづつつゥツづ?つス\n\t\t\tll res=1;\n\t\t\tint v=u;\n\t\t\tdo{\n\t\t\t\t// ツδ仰ーツプツ湘」ツづ個各ツ陳クツ点ツづーツ債ェツづ?つキツづゥツ姪伉づ可づつつ「ツづ?督堋つヲツづーツ仰?づ淞づ? ツつサツづェツづァツづーツつゥツつッツつ?づュツつケツづゥ\n\t\t\t\trep(i,G2[v].size()){\n\t\t\t\t\tint w=G2[v][i];\n\t\t\t\t\tif(!vis[w]) res=res*dfs(w,G2)%M;\n\t\t\t\t}\n\t\t\t\tv=G[v];\n\t\t\t}while(v!=u);\n\t\t\treturn (res+1)%M; // ツづ?づェツづ?選ツづ篠づ按つ「ツづ?つ「ツつ、ツ嘉ーツつェツつ?づゥツづ個づ?+1\n\t\t}\n\t}\n\tfor(;;);\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\nif(n==0 || n>1000 || m>1000) for(;;);\n\tint to[1000];\n\trep(u,n) to[u]=-1;\n\trep(i,m){\n\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\nif(u<0 || v<0 || n<=u || n<=v) for(;;);\n\t\tto[u]=v;\n\t}\n\tvector<int> G[1000]; // ツ鳴ウツ古シツグツδ可フ\n\trep(u,n) if(to[u]!=-1) {\n\t\tint v=to[u];\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\n\tll ans=1;\n\tbool vis[1000]={};\n\trep(u,n) if(!vis[u]) {\n\t\tvis[u]=true;\n\n\t\tvector<int> cc;\n\t\tqueue<int> Q; Q.push(u);\n\t\twhile(!Q.empty()){ // ツ偲」ツ連ツ個仰青ャツ閉ェツつイツづ?づ可陳イツづ猟づゥ\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\tcc.push_back(u);\n\t\t\trep(i,G[u].size()){\n\t\t\t\tint v=G[u][i];\n\t\t\t\tif(!vis[v]) vis[v]=true, Q.push(v);\n\t\t\t}\n\t\t}\n\n\t\tint N=cc.size();\n\t\tint D[1000]; // ツ偲」ツ連ツ個仰づ按有ツ古シツグツδ可フ\n\t\trep(i,N) D[i]=-1;\n\t\trep(i,N) rep(j,N) {\n\t\t\tint u=cc[i],v=cc[j];\n\t\t\tif(to[u]==v) D[i]=j;\n\t\t}\n\t\tans=ans*solve(N,D)%M;\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nstruct SCC\n{\n\tvector<vector<int> > G;\n\tvector<vector<int> > rG;\n\tvector<int> vs;\n\tvector<bool> used;\n\tvector<int> cmp;\n\tint sz,newsz;\n\tSCC(int n):G(n),rG(n),used(n,false),cmp(n){sz = n;}\n\t\n\tvoid add_edge(int from,int to)\n\t{\n\t\tG[from].PB(to);\n\t\trG[to].PB(from);\n\t}\n\t\n\tvoid dfs(int v)\n\t{\n\t\tused[v] = true;\n\t\tREP(i,G[v].size())\n\t\t{\n\t\t\tif(!used[G[v][i]])dfs(G[v][i]);\n\t\t}\n\t\tvs.PB(v);\n\t}\n\t\n\tvoid rdfs(int v,int k)\n\t{\n\t\tused[v] = false;\n\t\tcmp[v] = k;\n\t\tREP(i,rG[v].size())\n\t\t{\n\t\t\tif(used[rG[v][i]])rdfs(rG[v][i],k);\n\t\t}\n\t}\n\t\n\tint reMake()\n\t{\n\n\t\tvs.clear();\n\t\tREP(i,sz)if(!used[i])dfs(i);\n\t\tint k = 0;\n\t\tfor(int i = sz-1;i >= 0;i--)\n\t\t{\n\t\t\tif(used[vs[i]])\n\t\t\t{\n\t\t\t\trdfs(vs[i],k++);\n\t\t\t}\n\t\t}\n\t\treturn newsz = k;\n\t}\n\t\n\t\n\t\n\tvoid makeList(vector<vector<int> > &v)\n\t{\n\t\tREP(i,sz)\n\t\t{\n\t\t\tREP(j,G[i].size())\n\t\t\t{\n\t\t\t\tif(cmp[i] == cmp[G[i][j]])continue;\n\t\t\t\tv[cmp[i]].PB(cmp[G[i][j]]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid makeReverseList(vector<vector<int> > &v)\n\t{\n\t\tREP(i,sz)\n\t\t{\n\t\t\tREP(j,G[i].size())\n\t\t\t{\n\t\t\t\tif(cmp[i] == cmp[G[i][j]])continue;\n\t\t\t\tv[cmp[G[i][j]]].PB(cmp[i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint scc_node(int n)\n\t{\n\t\treturn cmp[n];\n\t}\n};\n\n\n#define MOD 1000000007 \n\nvector<vector<int> > v(1000);\nvector<vector<int> > rv(1000);\n\nbool check[10001];\nll dp[1111][2];\n\nvoid dfs(int n)\n{\n\tcheck[n] = true;\n\t\n\tif(rv[n].size() == 0)\n\t{\n\t\tdp[n][0] = 1;\n\t\tdp[n][1] = 1;\n\t\treturn;\n\t}\n\t\n\tREP(i,rv[n].size())\n\t{\n\t\tdfs(rv[n][i]);\n\t}\n\n\tll tmpa = 1;\n\tll tmpb = 1;\t\n\tREP(i,rv[n].size())\n\t{\n\t\ttmpa = (tmpa * ((dp[rv[n][i]][0]+dp[rv[n][i]][1])%MOD))%MOD;\n\t\ttmpb = (tmpb * dp[rv[n][i]][0])%MOD;\n\t}\n\tdp[n][0] = tmpb;\n\tdp[n][1] = tmpa;\n\t\n\treturn;\n}\n\t\n\nint main()\n{\n\tint n,m;cin >> n >> m;\n\t\n\tSCC scc(n);\n\tREP(i,m)\n\t{\n\t\tint a,b;cin >> a >> b;\n\t\ta--;b--;\n\t\tscc.add_edge(a,b);\n\t}\n\t\n\tscc.reMake();\n\tscc.makeList(v);\n\tscc.makeReverseList(rv);\n\t\n\t\n\tll ans = 1;\n\tREP(i,scc.newsz)\n\t{\n\t\tif(v[i].size() == 0 && !check[i])\n\t\t{\n\t\t\tdfs(i);\n\t\t\tans = (ans * (dp[i][0]+dp[i][1]))%MOD;\n\t\t}\n\t}\t\t\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2222 Alien's Counting\n// 2018.4.25 bal4u\n\n#include <stdio.h>\n#include <malloc.h>\n#include <string.h>\n\n#define MAX_V 1002\nint  V;    // 頂点数\nint  *to[MAX_V], hi[MAX_V], lim[MAX_V];\nint  *r_to[MAX_V], r_hi[MAX_V], r_lim[MAX_V];\nint  vs[MAX_V], vsz;\nchar used[MAX_V];\nint  cmp[MAX_V];    // 属する強連結成分のトポロジカル順序\n\nvoid check_lim(int a)\n{\n\tif (hi[a] < lim[a]) return;\n\tif (lim[a] == 0) {\n\t\tlim[a] = 8, hi[a] = 0;\n\t\tto[a] = malloc(sizeof(int) *lim[a]);\n\t} else if (hi[a] == lim[a]) {\n\t\tint k = lim[a];\n\t\tif (k > 256) k = 256;\n\t\tlim[a] += k;\n\t\tto[a] = realloc(to[a], sizeof(int) *lim[a]);\n\t}\n}\n\nvoid check_r_lim(int a)\n{\n\tif (r_hi[a] < r_lim[a]) return;\n\tif (r_lim[a] == 0) {\n\t\tr_lim[a] = 8, r_hi[a] = 0;\n\t\tr_to[a] = malloc(sizeof(int) *r_lim[a]);\n\t} else if (r_hi[a] == r_lim[a]) {\n\t\tint k = r_lim[a];\n\t\tif (k > 256) k = 256;\n\t\tr_lim[a] += k;\n\t\tr_to[a] = realloc(r_to[a], sizeof(int) *r_lim[a]);\n\t}\n}\n\nvoid add_edge(int _from, int _to)\n{\n\tcheck_lim(_from), check_r_lim(_to);\n\tto[_from][hi[_from]++] = _to;\n\tr_to[_to][r_hi[_to]++] = _from;\n}\n\nvoid dfs(int v)\n{\n\tint i;\n\tused[v] = 1;\n\tfor (i = 0; i < hi[v]; i++) {\n\t\tif (!used[to[v][i]]) dfs(to[v][i]);\n\t}\n\tvs[vsz++] = v;\n}\n\nvoid rdfs(int v, int k)\n{\n\tint i;\n\tused[v] = 1;\n\tcmp[v] = k;\n\tfor (i = 0; i < r_hi[v]; i++) {\n\t\tif (!used[r_to[v][i]]) rdfs(r_to[v][i], k);\n\t}\n}\n\nvoid init(int n)\n{\n\tV = n;\n\tmemset(  lim, 0, V<<2), memset(  hi, 0, V<<2);\n\tmemset(r_lim, 0, V<<2), memset(r_hi, 0, V<<2);\n}\n\n// 強連結成分への分解\nint scc()\n{\n\tint v, i, k;\n\tmemset(used, 0, V);\n\tvsz = 0;\n\tfor (v = 0; v < V; v++) if (!used[v]) dfs(v);\n\tmemset(used, 0, V);\n\tk = 0;\n\tfor (i = vsz-1; i >= 0; i--) if (!used[vs[i]]) {\n\n\t\trdfs(vs[i], k++);\n\t}\n\treturn k;\t\t// 得られた強連結成分の数\n}\n\n// バッファを経ずstdinから数値を得る\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\n#define MOD 1000000007\nint  dp[1002], nx[1002];\nchar mk[1002];\n\nint main()\n{\n\tint N, M, s, d, i, k;\n\tlong long ans;\n\n\tV = N = in(), M = in();\n//\tinit(N);\n\twhile (M--) {\n\t\ts = in()-1, d = in()-1;\n\t\tadd_edge(s, d);\n\t}\n\n\tk = scc();\n\tmemset(nx, -1, sizeof(int)*k);\n\tfor (i = 0; i < N; i++) if (hi[i]) nx[cmp[i]] = cmp[to[i][0]];\n\n\tans = 1;\n    for (i = 0; i < k; i++) {\n        if (dp[i]) dp[i]++; else dp[i] = 2;\n        if (nx[i] < 0 || nx[i] == i) ans = ans*dp[i] % MOD;\n        else if (dp[nx[i]]) dp[nx[i]] = (long long)dp[nx[i]]*dp[i] % MOD;\n        else                dp[nx[i]] = dp[i];\n    }\n\tprintf(\"%d\\n\", (int)ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Alien's Counting\npublic class Main{\n\n\tSet<Integer>[] e, rev, in, out;\n\tint N, M;\n\tlong MOD = 1000000007;\n\t\n\tint[] scc;\n\tboolean[] u;\n\tList<Integer> list;\n\t\n\tlong[][] dp;\n\t\n\tvoid dfs(int k){\n\t\tu[k] = true;\n\t\tfor(int v:e[k])if(!u[v])dfs(v);\n\t\tlist.add(k);\n\t}\n\tvoid rdfs(int k, int id){\n\t\tu[k] = true;\n\t\tscc[k] = id;\n\t\tfor(int v:rev[k])if(!u[v])rdfs(v, id);\n\t}\n\n\tlong get(int k){\n\t\tif(dp[k][0]!=-1)return (dp[k][0]+dp[k][1])%MOD;\n\t\tif(out[k].isEmpty()){\n\t\t\tdp[k][0] = dp[k][1] = 1;\n\t\t\treturn 2;\n\t\t}\n\t\tdp[k][0] = dp[k][1] = 1;\n\t\tfor(int v:out[k]){\n\t\t\tdp[k][1]*=get(v);\n\t\t\tdp[k][1]%=MOD;\n\t\t\tdp[k][0]*=dp[v][0];\n\t\t\tdp[k][0]%=MOD;\n\t\t}\n//\t\tdp[k][1] = (dp[k][1]+dp[k][0])%MOD;\n\t\treturn (dp[k][0]+dp[k][1])%MOD;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\te = new Set[N];\n\t\trev = new Set[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\te[i] = new HashSet<Integer>();\n\t\t\trev[i] = new HashSet<Integer>();\n\t\t}\n\t\twhile(M--!=0){\n\t\t\tint s = sc.nextInt()-1, t = sc.nextInt()-1;\n\t\t\te[s].add(t);\n\t\t\trev[t].add(s);\n\t\t}\n\t\tlist = new ArrayList<Integer>();\n\t\tu = new boolean[N];\n\t\tfor(int i=0;i<N;i++)if(!u[i])dfs(i);\n\t\tArrays.fill(u, false);\n\t\tint ID = 0;\n\t\tscc = new int[N];\n\t\tfor(int i=list.size()-1;i>=0;i--){\n\t\t\tint j = list.get(i);\n\t\t\tif(u[j])continue;\n\t\t\trdfs(j, ID);\n\t\t\tID++;\n\t\t}\n\t\tin = new Set[ID];\n\t\tout = new Set[ID];\n\t\tfor(int i=0;i<ID;i++){\n\t\t\tin[i] = new HashSet<Integer>();\n\t\t\tout[i] = new HashSet<Integer>();\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int v:rev[i]){\n\t\t\t\tif(scc[i]==scc[v])continue;\n\t\t\t\tout[scc[i]].add(scc[v]);\n\t\t\t\tin[scc[v]].add(scc[i]);\n\t\t\t}\n\t\t}\n//\t\tdebug(scc);\n//\t\tSystem.out.println(\"ID:\"+ID);\n//\t\tfor(int i=0;i<ID;i++){\n//\t\t\tSystem.out.print(\"i:\"+i+\" in:\"+in[i].size()+\" outs:\");\n//\t\t\tfor(int o:out[i])System.out.print(\" \"+o);\n//\t\t\t\t\tSystem.out.println();\n//\t\t}\n\t\t\n\t\t\n\t\tdp = new long[ID][2];\n\t\tfor(long[]d:dp)Arrays.fill(d, -1);\n\t\tlong res = 1;\n\t\tfor(int i=0;i<ID;i++)if(in[i].isEmpty()){\n\t\t\tres*=get(i);\n\t\t\tres%=MOD;\n\t\t}\n//\t\tSystem.out.println(\"get(2):\"+get(2)+\" 0:\"+dp[2][0]+\" 1:\"+dp[2][1]);\n//\t\tSystem.out.println(\"get(3):\"+get(3)+\" 0:\"+dp[3][0]+\" 1:\"+dp[3][1]);\n\t\tSystem.out.println(res);\n\t\t\n//\t\tdebug(dp);\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\", \"unused\" })\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();// the number of fingers\n\t\tint m = sc.nextInt();// the number of rules\n\t\tArrayList<Integer>[] e = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\te[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint v = sc.nextInt() - 1;\n\t\t\tint u = sc.nextInt() - 1;\n\t\t\te[v].add(u);\n\t\t}\n\t\tint[] scc = stronglyConnectedComponets(e);\n\t\tArrayList<Integer>[] dag = new ArrayList[NOW];\n\t\tfor (int i = 0; i < NOW; i++) {\n\t\t\tdag[i] = new ArrayList();\n\t\t}\n\t\tfor (int v = 0; v < n; v++) {\n\t\t\tfor (int u : e[v]) {\n\t\t\t\tif (scc[v] != scc[u]) {\n\t\t\t\t\tif (!dag[scc[v]].contains(scc[u])) {\n\t\t\t\t\t\tdag[scc[v]].add(scc[u]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArrayDeque<Integer> tsort = topological_sort(dag);\n\t\tArrayList<Integer>[] dag_rev = reverseGraph(dag);\n\t\tlong[] dp = new long[dag.length];\n\n\t\tf = new boolean[dag.length];\n\t\tArrays.fill(f, false);\n\t\tlong ans = 1;\n\t\tfor (int i = 0; i < dag.length; i++) {\n\t\t\tint d = ord.pollLast();\n\t\t\tif (!f[d]) {\n\t\t\t\tans = (ans * dfs_dp(dag_rev, d, -1)) % MOD;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tboolean[] f;\n\n\tlong dfs_dp(ArrayList<Integer>[] e, int v, int p) {\n\t\tlong ans = 1;\n\t\tfor (int u : e[v]) {\n\t\t\tif (u != p) {\n\t\t\t\tans *= dfs_dp(e, u, v);\n\t\t\t}\n\t\t}\n\t\tf[v] = true;\n\t\treturn ans + 1;\n\t}\n\n\tint[] dfsnum;\n\tint[] low;\n\tArrayDeque<Integer> S = new ArrayDeque<>();\n\tArrayList<Integer> T = new ArrayList<>();\n\tint N = 0;\n\tboolean[] used;\n\tint[] ret;\n\n\tint[] stronglyConnectedComponets(ArrayList<Integer> e[]) {\n\t\tint n = e.length;\n\t\tdfsnum = new int[n];\n\t\tlow = new int[n];\n\t\tused = new boolean[n];\n\t\tret = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (used[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (dfsnum[i] == 0) {\n\t\t\t\tdfs(e, i);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint NOW = 0;\n\n\tvoid dfs(ArrayList<Integer>[] e, int i) {\n\t\tS.addFirst(i);\n\t\tdfsnum[i] = N;\n\t\tN++;\n\t\tlow[i] = dfsnum[i];\n\t\tfor (int j : e[i]) {\n\t\t\tif (used[j]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!T.contains(j)) {\n\t\t\t\tT.add(j);\n\t\t\t\tdfs(e, j);\n\t\t\t\tlow[i] = Math.min(low[i], low[j]);\n\t\t\t} else {\n\t\t\t\tlow[i] = Math.min(dfsnum[j], low[i]);\n\t\t\t}\n\t\t}\n\t\tif (low[i] == dfsnum[i]) {\n\t\t\tint v;\n\t\t\tdo {\n\t\t\t\tv = S.removeFirst();\n\t\t\t\tret[v] = NOW;\n\t\t\t\tused[v] = true;\n\t\t\t} while (v != i);\n\t\t\tNOW++;\n\t\t}\n\t\treturn;\n\t}\n\n\tArrayDeque<Integer> ord = new ArrayDeque<>();\n\tboolean[] visit;\n\n\tArrayDeque<Integer> topological_sort(ArrayList<Integer>[] e) {\n\t\tvisit = new boolean[e.length];\n\t\tfor (int i = 0; i < e.length; i++) {\n\t\t\tif (!visit[i]) {\n\t\t\t\tdfs2(e, i);\n\t\t\t}\n\t\t}\n\t\treturn ord;\n\t}\n\n\tvoid dfs2(ArrayList<Integer>[] e, int i) {\n\t\tvisit[i] = true;\n\t\tfor (int j : e[i]) {\n\t\t\tif (!visit[j]) {\n\t\t\t\tdfs(e, j);\n\t\t\t}\n\t\t}\n\t\tord.addFirst(i);\n\t}\n\n\tArrayList<Integer>[] reverseGraph(ArrayList<Integer>[] e) {\n\t\tint n = e.length;\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tArrayList<Integer>[] rev_e = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\trev_e[i]=new ArrayList<>();\n\t\t}\n\t\tfor (int src = 0; src < n; src++) {\n\t\t\tfor (int dst : e[src]) {\n\t\t\t\trev_e[dst].add(src);\n\t\t\t}\n\t\t}\n\t\treturn rev_e;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();// the number of fingers\n\t\tint m = sc.nextInt();// the number of rules\n\t\tArrayList<Integer>[] e = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\te[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint v = sc.nextInt() - 1;\n\t\t\tint u = sc.nextInt() - 1;\n\t\t\te[v].add(u);\n\t\t}\n\t\tint[] scc = stronglyConnectedComponets(e);\n\t\tArrayList<Integer>[] dag = new ArrayList[NOW];\n\t\tfor (int i = 0; i < NOW; i++) {\n\t\t\tdag[i] = new ArrayList();\n\t\t}\n\t\tfor (int v = 0; v < n; v++) {\n\t\t\tfor (int u : e[v]) {\n\t\t\t\tif (scc[v] != scc[u]) {\n\t\t\t\t\tif (!dag[scc[v]].contains(scc[u])) {\n\t\t\t\t\t\tdag[scc[v]].add(scc[u]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArrayDeque<Integer> tsort = topological_sort(dag);\n\t\tArrayList<Integer>[] dag_rev = reverseGraph(dag);\n\t\tlong[] dp = new long[dag.length];\n\n\t\tf = new boolean[dag.length];\n\t\tArrays.fill(f, false);\n\t\tlong ans = 1;\n\t\tfor (int i = 0; i < dag.length; i++) {\n\t\t\tint d = ord.pollLast();\n\t\t\tif (!f[d]) {\n\t\t\t\tans = (ans * dfs_dp(dag_rev, d, -1)) % MOD;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tboolean[] f;\n\n\tlong dfs_dp(ArrayList<Integer>[] e, int v, int p) {\n\t\tlong ans = 1;\n\t\tfor (int u : e[v]) {\n\t\t\tif (u != p) {\n\t\t\t\tans *= dfs_dp(e, u, v);\n\t\t\t}\n\t\t}\n\t\tf[v] = true;\n\t\treturn ans + 1;\n\t}\n\n\tint[] dfsnum;\n\tint[] low;\n\tArrayDeque<Integer> S = new ArrayDeque<>();\n\tArrayList<Integer> T = new ArrayList<>();\n\tint N = 0;\n\tboolean[] used;\n\tint[] ret;\n\n\tint[] stronglyConnectedComponets(ArrayList<Integer> e[]) {\n\t\tint n = e.length;\n\t\tdfsnum = new int[n];\n\t\tlow = new int[n];\n\t\tused = new boolean[n];\n\t\tret = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (used[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (dfsnum[i] == 0) {\n\t\t\t\tdfs(e, i);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint NOW = 0;\n\n\tvoid dfs(ArrayList<Integer>[] e, int i) {\n\t\tS.addFirst(i);\n\t\tdfsnum[i] = N;\n\t\tN++;\n\t\tlow[i] = dfsnum[i];\n\t\tfor (int j : e[i]) {\n\t\t\tif (used[j]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!T.contains(j)) {\n\t\t\t\tT.add(j);\n\t\t\t\tdfs(e, j);\n\t\t\t\tlow[i] = Math.min(low[i], low[j]);\n\t\t\t} else {\n\t\t\t\tlow[i] = Math.min(dfsnum[j], low[i]);\n\t\t\t}\n\t\t}\n\t\tif (low[i] == dfsnum[i]) {\n\t\t\tint v;\n\t\t\tdo {\n\t\t\t\tv = S.removeFirst();\n\t\t\t\tret[v] = NOW;\n\t\t\t\tused[v] = true;\n\t\t\t} while (v != i);\n\t\t\tNOW++;\n\t\t}\n\t\treturn;\n\t}\n\n\tArrayDeque<Integer> ord = new ArrayDeque<>();\n\tboolean[] visit;\n\n\tArrayDeque<Integer> topological_sort(ArrayList<Integer>[] e) {\n\t\tvisit = new boolean[e.length];\n\t\tfor (int i = 0; i < e.length; i++) {\n\t\t\tif (!visit[i]) {\n\t\t\t\tdfs2(e, i);\n\t\t\t}\n\t\t}\n\t\treturn ord;\n\t}\n\n\tvoid dfs2(ArrayList<Integer>[] e, int i) {\n\t\tvisit[i] = true;\n\t\tfor (int j : e[i]) {\n\t\t\tif (!visit[j]) {\n\t\t\t\tdfs(e, j);\n\t\t\t}\n\t\t}\n\t\tord.addFirst(i);\n\t}\n\n\tArrayList<Integer>[] reverseGraph(ArrayList<Integer>[] e) {\n\t\tint n = e.length;\n\t\tArrayList<Integer>[] rev_e = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\trev_e[i]=new ArrayList<>();\n\t\t}\n\t\tfor (int src = 0; src < n; src++) {\n\t\t\tfor (int dst : e[src]) {\n\t\t\t\trev_e[dst].add(src);\n\t\t\t}\n\t\t}\n\t\treturn rev_e;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tpublic static int MOD = 1000000007;\n\tpublic static void main(String[] args) {\n\t\tIO io = new IO();\n\t\tint n = io.nextInt();\n\t\tint m = io.nextInt();\n\t\tGraph g = new Graph(n);\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tint s = io.nextInt() - 1;\n\t\t\tint d = io.nextInt() - 1;\n\t\t\tg.addEdge(d, s, 1);\n\t\t}\n\t\tGraph f = g.noSCCGraph(); //根付き森になる\n\t\tint n2 = f.n;\n\t\tboolean[] used = new boolean[n2];\n\t\tlong ans = 1;\n\t\tfor(int i=n2-1;i>=0;i--) {\n\t\t\tif (used[i]) continue;\n\t\t\tans = ans * count(i,f,used) % MOD;\n\t\t}\n//\t\tSystem.err.println(f);\n\t\tio.println(ans);\n\t\tio.flush();\n\t}\n\n\tpublic static long count(int v, Graph f, boolean[] used) {\n\t\tused[v] = true;\n\t\tlong res = 1;\n\t\tfor(Graph.Edge e: f.graph[v]) {\n\t\t\tres = res * count(e.to, f, used) % MOD;\n\t\t}\n\t\tres++;\n\t\tif (res >= MOD) res -= MOD;\n\t\treturn res;\n\t}\n\n}\nclass Graph {\n\tpublic static final int INF = 1<<29;\n\tint n;\n\tArrayList<Edge>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Graph(int n) {\n\t\tthis.n = n;\n\t\tthis.graph = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tgraph[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\n\tpublic void addBidirectionalEdge(int from,int to,int cost) {\n\t\taddEdge(from,to,cost);\n\t\taddEdge(to,from,cost);\n\t}\n\tpublic void addEdge(int from,int to,int cost) {\n\t\tgraph[from].add(new Edge(to, cost));\n\t}\n\n\tpublic ArrayList<ArrayList<Integer>> stronglyConnectedComponents() {\n\t\tArrayList<ArrayList<Integer>> scc = new ArrayList<ArrayList<Integer>>();\n\t\tint[] num = new int[n];\n\t\tint[] low = new int[n];\n\t\tint[] time = new int[1];\n\t\tArrayDeque<Integer> s = new ArrayDeque<Integer>();\n\t\tboolean[] inS = new boolean[n];\n\t\tfor(int u=0;u<n;u++) {\n\t\t\tif (num[u] == 0) {\n\t\t\t\tvisitSCC(u,scc,s,inS,low,num,time);\n\t\t\t}\n\t\t}\n\t\treturn scc;\n\t}\n\tprivate void visitSCC(int v, ArrayList<ArrayList<Integer>> scc,\n\t\t\tArrayDeque<Integer> s, boolean[] inS, int[] low, int[] num, int[] time) {\n\t\tlow[v] = num[v] = ++time[0];\n\t\ts.push(v);\n\t\tinS[v] = true;\n\t\tfor(Edge e:graph[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (num[w] == 0) {\n\t\t\t\tvisitSCC(w,scc,s,inS,low,num,time);\n\t\t\t\tlow[v] = Math.min(low[v],low[w]);\n\t\t\t}else if (inS[w]) {\n\t\t\t\tlow[v] = Math.min(low[v],num[w]);\n\t\t\t}\n\t\t}\n\t\tif (low[v] == num[v]) {\n\t\t\tArrayList<Integer> scc1 = new ArrayList<Integer>();\n\t\t\twhile(true) {\n\t\t\t\tint w = s.poll();\n\t\t\t\tinS[w] = false;\n\t\t\t\tscc1.add(w);\n\t\t\t\tif (v == w) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscc.add(scc1);\n\t\t}\n\t}\n\n\tpublic Graph mergedGraph(ArrayList<ArrayList<Integer>> scc) {\n\t\tint[] map = new int[n];\n\t\tint m = scc.size();\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tArrayList<Integer> l = scc.get(i);\n\t\t\tfor(int v: l) {\n\t\t\t\tmap[v] = i;\n\t\t\t}\n\t\t}\n\t\tGraph g2 = new Graph(m);\n\t\tHashSet<Long> edge = new HashSet<Long>();\n\t\tfor(int u=0;u<n;u++) {\n\t\t\tfor(Edge e:graph[u]) {\n\t\t\t\tint v = e.to;\n\t\t\t\tif (map[u] == map[v]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tedge.add(((long) map[u]<<32) + map[v]);\n\t\t\t}\n\t\t}\n\t\tfor(long e:edge) {\n\t\t\tg2.addEdge((int) (e>>32), (int) (e & 0xffff), 1);\n\t\t}\n\t\treturn g2;\n\t}\n\n\tpublic Graph noSCCGraph() {\n\t\treturn mergedGraph(stronglyConnectedComponents());\n\t}\n\n\tclass Edge {\n\t\tint to;\n\t\tint cost;\n\t\tpublic Edge(int to,int cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(Edge e: graph[i]) {\n\t\t\t\tsb.append(\"(\" + i + \",\" + e.to + \")\");\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Alien's Counting\npublic class Main{\n\n\tlong MOD = 1000000007, res;\n\tint n, m, ID;\n\tList<Integer>[] e, rev, vs;\n\tList<Integer> visit;\n\tboolean[] u;\n\tint[] scc, out;\n\t\n\tvoid dfs(int k){\n\t\tif(u[k])return;\n\t\tu[k] = true;\n\t\tfor(int x:e[k])dfs(x);\n//\t\tSystem.out.println(\"ORDER:\"+k);\n\t\tvisit.add(k);\n\t}\n\tvoid rdfs(int k){\n\t\tif(u[k])return;\n\t\tu[k] = true;\n\t\tscc[k] = ID;\n\t\tvs[ID].add(k);\n\t\tfor(int x:rev[k])rdfs(x);\n\t}\n\tlong modpow(long x, long n, long MOD){\n\t\tlong res = 1, v = x;\n\t\twhile(n>0){\n\t\t\tif((n&1)>0)res = res*v%MOD;\n\t\t\tv = v*v%MOD;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tlong f(int k){\n\t\tu[k] = true;\n\t\tlong r = 2;\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tfor(int x:vs[k])for(int y:rev[x]){\n\t\t\tif(u[scc[y]])continue;\n\t\t\tu[scc[y]] = true;\n\t\t\tl.add(scc[y]);\n\t\t}\n\t\twhile(!l.isEmpty()){\n\t\t\tr+=((modpow(2, l.size(), MOD)-1+MOD)%MOD);\n\t\t\tr%=MOD;\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int v:l){\n\t\t\t\tfor(int x:vs[v])for(int y:rev[x]){\n\t\t\t\t\tif(u[scc[y]])continue;\n\t\t\t\t\tu[scc[y]] = true;\n\t\t\t\t\tnext.add(scc[y]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tl = next;\n\t\t}\n//\t\tSystem.out.println(\"K:\"+k+\" r:\"+r);\n\t\treturn r;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt(); m = sc.nextInt();\n\t\te = new List[n]; rev = new List[n]; vs = new List[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\te[i] = new ArrayList<Integer>(); rev[i] = new ArrayList<Integer>(); vs[i] = new ArrayList<Integer>();\n\t\t}\n\t\twhile(m--!=0){\n\t\t\tint s =  sc.nextInt()-1, d = sc.nextInt()-1;\n\t\t\te[s].add(d); rev[d].add(s);\n\t\t}\n\t\tvisit = new ArrayList<Integer>();\n\t\tu = new boolean[n];\n\t\tfor(int i=0;i<n;i++)dfs(i);\n\t\tscc = new int[n];\n\t\tID = 0;\n\t\tArrays.fill(u, false);\n\t\tfor(int i=n-1;i>=0;i--){\n\t\t\tint x = visit.get(i);\n//\t\t\tSystem.out.println(\"X:\"+x);\n\t\t\tif(u[x])continue;\n\t\t\trdfs(x);\n\t\t\tID++;\n\t\t}\n//\t\tSystem.out.println(ID);\n\t\tres = 1;\n\t\tout = new int[ID];\n\t\tfor(int i=0;i<ID;i++)for(int x:vs[i])for(int y:e[x])if(scc[x]!=scc[y])out[i]++;\n//\t\tdebug(scc); debug(out);\n\t\tArrays.fill(u, false);\n\t\tfor(int i=0;i<ID;i++)if(out[i]==0)res=res*f(i)%MOD;\n\t\tSystem.out.println(res);\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Alien's Counting\npublic class Main{\n\n\tSet<Integer>[] e, rev, in, out;\n\tint N, M;\n\tlong MOD = 1000000007;\n\t\n\tint[] scc;\n\tboolean[] u;\n\tList<Integer> list;\n\t\n\tlong[][] dp;\n\t\n\tvoid dfs(int k){\n\t\tu[k] = true;\n\t\tfor(int v:e[k])if(!u[v])dfs(v);\n\t\tlist.add(k);\n\t}\n\tvoid rdfs(int k, int id){\n\t\tu[k] = true;\n\t\tscc[k] = id;\n\t\tfor(int v:rev[k])if(!u[v])rdfs(v, id);\n\t}\n\n\tlong get(int k){\n\t\tif(dp[k][0]!=-1)return (dp[k][0]+dp[k][1])%MOD;\n\t\tdp[k][0] = dp[k][1] = 1;\n\t\tfor(int v:out[k]){\n\t\t\tdp[k][1]*=get(v);\n\t\t\tdp[k][1]%=MOD;\n\t\t\tdp[k][0]*=dp[v][0];\n\t\t\tdp[k][0]%=MOD;\n\t\t}\n\t\treturn (dp[k][0]+dp[k][1])%MOD;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\te = new Set[N];\n\t\trev = new Set[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\te[i] = new HashSet<Integer>();\n\t\t\trev[i] = new HashSet<Integer>();\n\t\t}\n\t\twhile(M--!=0){\n\t\t\tint s = sc.nextInt()-1, t = sc.nextInt()-1;\n\t\t\te[s].add(t);\n\t\t\trev[t].add(s);\n\t\t}\n\t\tlist = new ArrayList<Integer>();\n\t\tu = new boolean[N];\n\t\tfor(int i=0;i<N;i++)if(!u[i])dfs(i);\n\t\tArrays.fill(u, false);\n\t\tint ID = 0;\n\t\tscc = new int[N];\n\t\tfor(int i=list.size()-1;i>=0;i--){\n\t\t\tint j = list.get(i);\n\t\t\tif(u[j])continue;\n\t\t\trdfs(j, ID);\n\t\t\tID++;\n\t\t}\n\t\tin = new Set[ID];\n\t\tout = new Set[ID];\n\t\tfor(int i=0;i<ID;i++){\n\t\t\tin[i] = new HashSet<Integer>();\n\t\t\tout[i] = new HashSet<Integer>();\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int v:rev[i]){\n\t\t\t\tif(scc[i]==scc[v])continue;\n\t\t\t\tout[scc[i]].add(scc[v]);\n\t\t\t\tin[scc[v]].add(scc[i]);\n\t\t\t}\n\t\t}\n\t\tdp = new long[ID][2];\n\t\tfor(long[]d:dp)Arrays.fill(d, -1);\n\t\tlong res = 1;\n\t\tfor(int i=0;i<ID;i++)if(in[i].isEmpty()){\n\t\t\tres*=get(i);\n\t\t\tres%=MOD;\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\", \"unused\" })\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();// the number of fingers\n\t\tint m = sc.nextInt();// the number of rules\n\t\tArrayList<Integer>[] e = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\te[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint v = sc.nextInt() - 1;\n\t\t\tint u = sc.nextInt() - 1;\n\t\t\te[v].add(u);\n\t\t}\n\t\tint[] scc = stronglyConnectedComponets(e);\n\t\tArrayList<Integer>[] dag = new ArrayList[NOW];\n\t\tfor (int i = 0; i < NOW; i++) {\n\t\t\tdag[i] = new ArrayList();\n\t\t}\n\t\tfor (int v = 0; v < n; v++) {\n\t\t\tfor (int u : e[v]) {\n\t\t\t\tif (scc[v] != scc[u]) {\n\t\t\t\t\tif (!dag[scc[v]].contains(scc[u])) {\n\t\t\t\t\t\tdag[scc[v]].add(scc[u]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArrayDeque<Integer> tsort = topological_sort(dag);\n\t\tArrayList<Integer>[] dag_rev = reverseGraph(dag);\n\t\tlong[] dp = new long[dag.length];\n\n\t\tf = new boolean[dag.length];\n\t\tArrays.fill(f, false);\n\t\tlong ans = 1;\n\t\tfor (int i = 0; i < dag.length; i++) {\n\t\t\tint d = ord.pollLast();\n\t\t\tif (!f[d]) {\n\t\t\t\tans = (ans * dfs_dp(dag_rev, d, -1)) % MOD;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tboolean[] f;\n\n\tlong dfs_dp(ArrayList<Integer>[] e, int v, int p) {\n\t\tlong ans = 1;\n\t\tfor (int u : e[v]) {\n\t\t\tif (u != p) {\n\t\t\t\tans *= dfs_dp(e, u, v);\n\t\t\t}\n\t\t}\n\t\tf[v] = true;\n\t\treturn ans + 1;\n\t}\n\n\tint[] dfsnum;\n\tint[] low;\n\tArrayDeque<Integer> S = new ArrayDeque<>();\n\tArrayList<Integer> T = new ArrayList<>();\n\tint N = 0;\n\tboolean[] used;\n\tint[] ret;\n\n\tint[] stronglyConnectedComponets(ArrayList<Integer> e[]) {\n\t\tint n = e.length;\n\t\tdfsnum = new int[n];\n\t\tlow = new int[n];\n\t\tused = new boolean[n];\n\t\tret = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (used[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (dfsnum[i] == 0) {\n\t\t\t\tdfs(e, i);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint NOW = 0;\n\n\tvoid dfs(ArrayList<Integer>[] e, int i) {\n\t\tS.addFirst(i);\n\t\tdfsnum[i] = N;\n\t\tN++;\n\t\tlow[i] = dfsnum[i];\n\t\tfor (int j : e[i]) {\n\t\t\tif (used[j]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!T.contains(j)) {\n\t\t\t\tT.add(j);\n\t\t\t\tdfs(e, j);\n\t\t\t\tlow[i] = Math.min(low[i], low[j]);\n\t\t\t} else {\n\t\t\t\tlow[i] = Math.min(dfsnum[j], low[i]);\n\t\t\t}\n\t\t}\n\t\tif (low[i] == dfsnum[i]) {\n\t\t\tint v;\n\t\t\tdo {\n\t\t\t\tv = S.removeFirst();\n\t\t\t\tret[v] = NOW;\n\t\t\t\tused[v] = true;\n\t\t\t} while (v != i);\n\t\t\tNOW++;\n\t\t}\n\t\treturn;\n\t}\n\n\tArrayDeque<Integer> ord = new ArrayDeque<>();\n\tboolean[] visit;\n\n\tArrayDeque<Integer> topological_sort(ArrayList<Integer>[] e) {\n\t\tvisit = new boolean[e.length];\n\t\tfor (int i = 0; i < e.length; i++) {\n\t\t\tif (!visit[i]) {\n\t\t\t\tdfs2(e, i);\n\t\t\t}\n\t\t}\n\t\treturn ord;\n\t}\n\n\tvoid dfs2(ArrayList<Integer>[] e, int i) {\n\t\tvisit[i] = true;\n\t\tfor (int j : e[i]) {\n\t\t\tif (!visit[j]) {\n\t\t\t\tdfs(e, j);\n\t\t\t}\n\t\t}\n\t\tord.addFirst(i);\n\t}\n\n\tArrayList<Integer>[] reverseGraph(ArrayList<Integer>[] e) {\n\t\tint n = e.length;\n\t\tArrayList<Integer>[] rev_e = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\trev_e[i]=new ArrayList<>();\n\t\t}\n\t\tfor (int src = 0; src < n; src++) {\n\t\t\tfor (int dst : e[src]) {\n\t\t\t\trev_e[dst].add(src);\n\t\t\t}\n\t\t}\n\t\treturn rev_e;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Alien's Counting\npublic class Main{\n\n\tSet<Integer>[] e, rev, in, out;\n\tint N, M;\n\tlong MOD = 1000000007;\n\t\n\tint[] scc;\n\tboolean[] u;\n\tList<Integer> list;\n\t\n\tlong[][] dp;\n\t\n\tvoid dfs(int k){\n\t\tu[k] = true;\n\t\tfor(int v:e[k])if(!u[v])dfs(v);\n\t\tlist.add(k);\n\t}\n\tvoid rdfs(int k, int id){\n\t\tu[k] = true;\n\t\tscc[k] = id;\n\t\tfor(int v:rev[k])if(!u[v])rdfs(v, id);\n\t}\n\n\tlong get(int k){\n\t\tif(dp[k][0]!=-1)return (dp[k][0]+dp[k][1])%MOD;\n\t\tif(out[k].isEmpty()){\n\t\t\tdp[k][0] = dp[k][1] = 1;\n\t\t\treturn 2;\n\t\t}\n\t\tdp[k][0] = dp[k][1] = 1;\n\t\tfor(int v:out[k]){\n\t\t\tdp[k][1]*=get(v);\n\t\t\tdp[k][1]%=MOD;\n\t\t\tdp[k][0]*=dp[v][0];\n\t\t\tdp[k][0]%=MOD;\n\t\t}\n\t\treturn (dp[k][0]+dp[k][1])%MOD;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\te = new Set[N];\n\t\trev = new Set[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\te[i] = new HashSet<Integer>();\n\t\t\trev[i] = new HashSet<Integer>();\n\t\t}\n\t\twhile(M--!=0){\n\t\t\tint s = sc.nextInt()-1, t = sc.nextInt()-1;\n\t\t\te[s].add(t);\n\t\t\trev[t].add(s);\n\t\t}\n\t\tlist = new ArrayList<Integer>();\n\t\tu = new boolean[N];\n\t\tfor(int i=0;i<N;i++)if(!u[i])dfs(i);\n\t\tArrays.fill(u, false);\n\t\tint ID = 0;\n\t\tscc = new int[N];\n\t\tfor(int i=list.size()-1;i>=0;i--){\n\t\t\tint j = list.get(i);\n\t\t\tif(u[j])continue;\n\t\t\trdfs(j, ID);\n\t\t\tID++;\n\t\t}\n\t\tin = new Set[ID];\n\t\tout = new Set[ID];\n\t\tfor(int i=0;i<ID;i++){\n\t\t\tin[i] = new HashSet<Integer>();\n\t\t\tout[i] = new HashSet<Integer>();\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int v:rev[i]){\n\t\t\t\tif(scc[i]==scc[v])continue;\n\t\t\t\tout[scc[i]].add(scc[v]);\n\t\t\t\tin[scc[v]].add(scc[i]);\n\t\t\t}\n\t\t}\n\t\tdp = new long[ID][2];\n\t\tfor(long[]d:dp)Arrays.fill(d, -1);\n\t\tlong res = 1;\n\t\tfor(int i=0;i<ID;i++)if(in[i].isEmpty()){\n\t\t\tres*=get(i);\n\t\t\tres%=MOD;\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\", \"unused\" })\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();// the number of fingers\n\t\tint m = sc.nextInt();// the number of rules\n\t\tArrayList<Integer>[] e = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\te[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint v = sc.nextInt() - 1;\n\t\t\tint u = sc.nextInt() - 1;\n\t\t\te[v].add(u);\n\t\t}\n\t\tint[] scc = stronglyConnectedComponets(e);\n\t\tArrayList<Integer>[] dag = new ArrayList[NOW];\n\t\tfor (int i = 0; i < NOW; i++) {\n\t\t\tdag[i] = new ArrayList();\n\t\t}\n\t\tfor (int v = 0; v < n; v++) {\n\t\t\tfor (int u : e[v]) {\n\t\t\t\tif (scc[v] != scc[u]) {\n\t\t\t\t\tif (!dag[scc[v]].contains(scc[u])) {\n\t\t\t\t\t\tdag[scc[v]].add(scc[u]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArrayDeque<Integer> tsort = topological_sort(dag);\n\t\tArrayList<Integer>[] dag_rev = reverseGraph(dag);\n\t\tlong[] dp = new long[dag.length];\n\n\t\tf = new boolean[dag.length];\n\t\tArrays.fill(f, false);\n\t\tlong ans = 1;\n\t\tfor (int i = 0; i < dag.length; i++) {\n\t\t\tint d = ord.pollLast();\n\t\t\tif (!f[d]) {\n\t\t\t\tans = (ans * dfs_dp(dag_rev, d, -1)) % MOD;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tboolean[] f;\n\n\tlong dfs_dp(ArrayList<Integer>[] e, int v, int p) {\n\t\tlong ans = 1;\n\t\tfor (int u : e[v]) {\n\t\t\tif (u != p) {\n\t\t\t\tans *= dfs_dp(e, u, v);\n\t\t\t\tans%=MOD;\n\t\t\t}\n\t\t}\n\t\tf[v] = true;\n\t\treturn ans + 1;\n\t}\n\n\tint[] dfsnum;\n\tint[] low;\n\tArrayDeque<Integer> S = new ArrayDeque<>();\n\tArrayList<Integer> T = new ArrayList<>();\n\tint N = 0;\n\tboolean[] used;\n\tint[] ret;\n\n\tint[] stronglyConnectedComponets(ArrayList<Integer> e[]) {\n\t\tint n = e.length;\n\t\tdfsnum = new int[n];\n\t\tlow = new int[n];\n\t\tused = new boolean[n];\n\t\tret = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (used[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (dfsnum[i] == 0) {\n\t\t\t\tdfs(e, i);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint NOW = 0;\n\n\tvoid dfs(ArrayList<Integer>[] e, int i) {\n\t\tS.addFirst(i);\n\t\tdfsnum[i] = N;\n\t\tN++;\n\t\tlow[i] = dfsnum[i];\n\t\tfor (int j : e[i]) {\n\t\t\tif (used[j]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!T.contains(j)) {\n\t\t\t\tT.add(j);\n\t\t\t\tdfs(e, j);\n\t\t\t\tlow[i] = Math.min(low[i], low[j]);\n\t\t\t} else {\n\t\t\t\tlow[i] = Math.min(dfsnum[j], low[i]);\n\t\t\t}\n\t\t}\n\t\tif (low[i] == dfsnum[i]) {\n\t\t\tint v;\n\t\t\tdo {\n\t\t\t\tv = S.removeFirst();\n\t\t\t\tret[v] = NOW;\n\t\t\t\tused[v] = true;\n\t\t\t} while (v != i);\n\t\t\tNOW++;\n\t\t}\n\t\treturn;\n\t}\n\n\tArrayDeque<Integer> ord = new ArrayDeque<>();\n\tboolean[] visit;\n\n\tArrayDeque<Integer> topological_sort(ArrayList<Integer>[] e) {\n\t\tvisit = new boolean[e.length];\n\t\tfor (int i = 0; i < e.length; i++) {\n\t\t\tif (!visit[i]) {\n\t\t\t\tdfs2(e, i);\n\t\t\t}\n\t\t}\n\t\treturn ord;\n\t}\n\n\tvoid dfs2(ArrayList<Integer>[] e, int i) {\n\t\tvisit[i] = true;\n\t\tfor (int j : e[i]) {\n\t\t\tif (!visit[j]) {\n\t\t\t\tdfs(e, j);\n\t\t\t}\n\t\t}\n\t\tord.addFirst(i);\n\t}\n\n\tArrayList<Integer>[] reverseGraph(ArrayList<Integer>[] e) {\n\t\tint n = e.length;\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tArrayList<Integer>[] rev_e = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\trev_e[i]=new ArrayList<>();\n\t\t}\n\t\tfor (int src = 0; src < n; src++) {\n\t\t\tfor (int dst : e[src]) {\n\t\t\t\trev_e[dst].add(src);\n\t\t\t}\n\t\t}\n\t\treturn rev_e;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing Point = System.Numerics.Complex;\nusing Number = System.Int64;\n\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n            var m = ri;\n            var f = new int[m];\n            var t = new int[m];\n            var deg = new int[n];\n            var outdeg = new int[n];\n            for (int i = 0; i < m; i++)\n            {\n                f[i] = ri - 1;\n                t[i] = ri - 1;\n                deg[f[i]]++; deg[t[i]]++;\n                outdeg[f[i]]++;\n            }\n            bool[] isCycle = pre(n, f, t);\n            var set = new DisjointSet(n);\n            for (int i = 0; i < m; i++)\n                if (isCycle[f[i]] && isCycle[t[i]]) set.Unite(f[i], t[i]);\n            var T = Enumerate(n, x => new List<int>());\n            for (int i = 0; i < m; i++)\n                if (set[f[i]] != set[t[i]])\n                    T[set[t[i]]].Add(set[f[i]]);\n\n            const long M = (long)1e9 + 7;\n            Func<int, int, long> dfs = null;\n            dfs = (pre, cur) =>\n            {\n                //Debug.WriteLine($\"{pre} {cur}\");\n                var v = 1L;\n                foreach (var to in T[cur]) v = v * dfs(cur, to) % M;\n                return (v + 1) % M;\n            };\n            var ans = 1L;\n            for (int i = 0; i < n; i++)\n            {\n                //cycle\n                if (set[i] == i && isCycle[i]) ans = ans * dfs(-1, i) % M;\n                //isolated vertex\n                if (deg[i] == 0) ans = ans * 2 % M;\n                //end point\n                if (T[i].Count != 0 && outdeg[i] == 0) ans = ans * dfs(-1, i) % M;\n\n\n            }\n            Console.WriteLine(ans);\n        }\n\n        bool[] pre(int n, int[] f, int[] t) {\n            var g = Enumerate(n, x => new List<int>());\n            var ret = Enumerate(n, x => true);\n            var indeg = new int[n];\n            for (int i = 0; i < f.Length; i++)\n            {\n                g[f[i]].Add(t[i]);\n                indeg[t[i]]++;\n            }\n            var q = new Queue<int>();\n            for (int i = 0; i < n; i++)\n                if (indeg[i] == 0) q.Enqueue(i);\n            while (q.Any())\n            {\n                var p = q.Dequeue();\n                ret[p] = false;\n                foreach (var to in g[p])\n                {\n                    indeg[to]--;\n                    if (indeg[to] == 0) q.Enqueue(to);\n                }\n            }\n\n            return ret;\n        }\n\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n\nclass DisjointSet {\n    int[] par;\n    public DisjointSet(int n) {\n        par = new int[n];\n        for (int i = 0; i < n; i++)\n            par[i] = i;\n    }\n    public void Unite(int i, int j) {\n        i = this[i];\n        j = this[j];\n        par[j] = i;\n\n    }\n    public int this[int index] {\n        get {\n            if (index == par[index]) return index;\n            else return par[index] = this[par[index]];\n        }\n    }\n}\n"
  },
  {
    "language": "Ruby",
    "code": "require 'tsort'\nrequire 'set'\n\nn, m = gets.split.map(&:to_i)\n\nclass Hash\n    include TSort\n    alias :tsort_each_node :each_key\n    def tsort_each_child(i)\n        self[i].each{|j| yield j}\n    end\nend\n\norig_graph = {}\n(1..n).each { |i| orig_graph[i] = Set.new }\nedges = (1..m).map { gets.split.map(&:to_i) }\nedges.each { |i, j| orig_graph[j] << i }\n\ngc = {}\ndec = orig_graph.strongly_connected_components\ndec.each_with_index do |a, i|\n    a.each { |j| gc[j] = i }\nend\n\ngraph = {}\n(0..dec.size-1).each {|i| graph[i] = Set.new }\nedges.each do |i, j|\n    graph[gc[j]] << gc[i] unless gc[i] == gc[j]\nend\n\nroots = Set[*graph.keys]\ngraph.each { |_, children| roots -= children }\n\ndef f(graph, i)\n    s = 1 + graph[i].map{|j| f(graph, j)}.inject(1, :*)\n    s % 1_000_000_007\nend\n\np roots.map{|i| f(graph, i)}.inject(1, :*) % 1_000_000_007"
  },
  {
    "language": "Ruby",
    "code": "module Memoizable\n\tdef memoize(name)\n\t\toriginal = \"__original_#{name}__\"\n\t\t([Class, Module].include?(self.class) ? self : self.class).class_eval {\n\t\t\talias_method(original, name)\n\t\t\tprivate(original)\n\t\t\tcache = {}\n\t\t\tdefine_method(name){|*args|\n\t\t\t\tcache[args] ||= send(original, *args)\n\t\t\t}\n\t\t}\n\tend \nend\n\ninclude Memoizable\n\nrequire 'tsort'\nrequire 'set'\n\nn, m = gets.split.map &:to_i\n\ng = {}\n(1..n).each{|i| g[i] = []}\n\nm.times do\n\ti, j = gets.split.map &:to_i\n\tg[i] << j\nend\n\nclass Hash\n\tinclude TSort\n\talias tsort_each_node each_key\n\tdef tsort_each_child(i)\n\t\tself[i].each{|j| yield(j)}\n\tend\nend\n\ncomponent = {}\nscc = g.strongly_connected_components.reverse\nscc.each_with_index do |a, i|\n\ta.each do |j|\n\t\tcomponent[j] = i\n\tend\nend\n\n$c_g = {}\n(0..scc.size-1).each{|i| $c_g[i] = Set.new}\n\ng.each do |from, tos|\n\tc1 = component[from]\n\ttos.each do |to|\n\t\tc2 = component[to]\n\t\t$c_g[c1] << c2 if c1 != c2\n\tend\nend\n\ndef f(state, i, n)\n\treturn 1 if i == n\n\tsum = f(state>>1, i+1, n)\n\treturn sum if state[0] == 1\n\n\tstack = [i]\n\treached = {i => 1}\n\tuntil stack.empty?\n\t\tj = stack.pop\n\t\tnext if !$c_g[j]\n\t\t$c_g[j].each do |k|\n\t\t\tnext if reached[k]\n\t\t\treached[k] = 1\n\t\t\tstate |= (1 << k-i)\n\t\t\tstack << k\n\t\tend\n\tend\n\n\tsum += f(state>>1, i+1, n)\nend\n\nmemoize :f\n\np f(0, 0, scc.size) "
  },
  {
    "language": "Python",
    "code": "n,m = map(int, input().split(\" \"))\ns = [0 for i in range(m)]\nd = [0 for i in range(m)]\nsum = 2**n\nfor i in range(m):\n    s[i],d[i] = map(int, input().split(\" \"))\nif n >= 3:\n    for i in range(m):\n        sum -= 2**(n-2)\n        for j in range(m):\n            if i == j:\n                continue\n            if s[i] == s[j] or d[i] == d[j]:\n                sum += 2**(n-4)\n            if s[i] != s[j] and s[i] != d[j] and d[i] != s[j] and d[i] != d[j]:\n                sum += 2**(n-5)\nif n == 2:\n    if m == 0:\n        sum = 4\n    if m == 1:\n        sum = 3\n    if m >= 2:\n        sum = 2\nprint(int(sum%1000000007))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef func(d, S, D):\n    if S[d] == []:\n        return 2, [d]\n    else:\n        tmp = 1\n        used=[d]\n        for k in S[d]:\n            ret = func(k,S,D)\n            tmp *= ret[0]\n            used += ret[1]\n        return tmp+1 , used\n\nsys.setrecursionlimit(100000)\nN,M=map(int,raw_input().split())\nS=[[] for i in range(N)]\nD=[-1 for i in range(N)]\nfor i in range(M):\n    s,d=map(lambda x: int(x)-1 ,raw_input().split())\n    D[s] = d\n    S[d].append(s)\n\nunevaled=range(N)\nbans=[]\nwhile(len(unevaled)>0):\n    #find root\n    tmp=unevaled[0]\n    T=[tmp]\n    while (1):\n        if D[tmp]==-1:\n            root=tmp\n            break\n        elif D[tmp] in T:\n            root=D[tmp]\n            D[root]=-1\n            rebase=T[ T.index(root) : ]\n            Stmp=[]\n            for r in rebase:\n                for rs in S[r]:\n                    if rs not in rebase:\n                        D[rs]=root\n                        Stmp.append(rs)\n                if r!=root:\n                    unevaled.remove(r)\n            S[root]=Stmp[:]\n            break\n        else:\n            tmp=D[tmp]\n            T.append(tmp)\n    b = func(root, S, D)\n    bans.append(b[0])\n    for r in b[1]:\n        unevaled.remove(r)\nans = reduce(lambda x,y: x*y, bans)\nprint ans%1000000007\n\n"
  },
  {
    "language": "Python",
    "code": "def combi(n):\n    if n == 1:\n        return [[1],[0]]\n    else:\n        s = combi(n-1)\n        ret = [[t] + x for x in s for t in [1, 0]]\n        return ret\n\nN, M = map(int, input().split())\nwhole = combi(N)\n\n\nfor i in range(M):\n    select = []\n    s, d = map(int, input().split())\n    for c in whole:\n        if c[s-1] == 1 and c[d-1] ==0:\n            select.append(c)\n    for c in select:\n        whole.remove(c)\n\nprint(len(whole))"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\nsys.setrecursionlimit(10**6)\ndef scc(N, G, RG):\n    order = []\n    used = [0]*N\n    group = [None]*N\n    def dfs(s):\n        used[s] = 1\n        for t in G[s]:\n            if not used[t]:\n                dfs(t)\n        order.append(s)\n    def rdfs(s, col):\n        group[s] = col\n        used[s] = 1\n        for t in RG[s]:\n            if not used[t]:\n                rdfs(t, col)\n    for i in range(N):\n        if not used[i]:\n            dfs(i)\n    used = [0]*N\n    label = 0\n    for s in reversed(order):\n        if not used[s]:\n            rdfs(s, label)\n            label += 1\n    return label, group\n\ndef construct(N, G, label, group):\n    G0 = [set() for i in range(label)]\n    GP = [[] for i in range(label)]\n    for v in range(N):\n        lbs = group[v]\n        for w in G[v]:\n            lbt = group[w]\n            if lbs == lbt:\n                continue\n            G0[lbs].add(lbt)\n        GP[lbs].append(v)\n    return G0, GP\n\nN, M = map(int, readline().split())\nG = [[] for i in range(N)]\nRG = [[] for i in range(N)]\nfor i in range(M):\n    s, d = map(int, readline().split()); s -= 1; d -= 1\n    G[d].append(s)\n    RG[s].append(d)\n\nN0, group = scc(N, G, RG)\nG0, GP = construct(N, G, N0, group)\n\ndeg = [0]*N0\nfor v in range(N0):\n    for w in G0[v]:\n        deg[w] += 1\nMOD = 10**9 + 7\ndef dfs(v):\n    r = 1\n    for w in G0[v]:\n        r = r * dfs(w) % MOD\n    return r + 1\nans = 1\nfor v in range(N0):\n    if deg[v] == 0:\n        ans = ans * dfs(v) % MOD\nwrite(\"%d\\n\" % ans)\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    def f(n,m):\n        a = [LI_() for _ in range(m)]\n        p = collections.defaultdict(list)\n        c = collections.defaultdict(list)\n        for s,d in a:\n            p[s].append(d)\n            c[d].append(s)\n\n        v = collections.defaultdict(int)\n        d = collections.defaultdict(lambda: -1)\n        b = collections.defaultdict(set)\n        def _f(i):\n            # print('_f',i)\n            if v[i] == 2:\n                return -1\n            if v[i] == 1:\n                d[i] = i\n                b[i].add(i)\n                return i\n            v[i] = 1\n            for j in p[i]:\n                r = _f(j)\n                if r < 0:\n                    continue\n                d[i] = r\n                b[r].add(i)\n            v[i] = 2\n            if d[i] == i:\n                return -1\n            return d[i]\n\n        for i in range(n):\n            _f(i)\n\n        def g(i):\n            # print('g',i)\n            if d[i] >= 0 and d[i] != i:\n                return 1\n            cs = set(c[i])\n            if d[i] == i:\n                for j in b[i]:\n                    cs |= set(c[j])\n            r = 1\n            # print('cs',i,cs)\n            for j in cs:\n                if j in b[i]:\n                    continue\n                gr = g(j)\n                # print('jgr',j,gr)\n                r *= gr\n                r %= mod\n            r += 1\n            return r\n\n        r = 1\n        for i in range(n):\n            if d[i] == i or len(p[i]) == 0:\n                gr = g(i)\n                # print('igr',i,gr)\n                r *= gr\n                r %= mod\n\n        return r\n\n    while 1:\n        n,m = LI()\n        if n == 0:\n            break\n        rr.append(f(n,m))\n        break\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "n,m = map(int, input().split(\" \"))\ns = [0 for i in range(m)]\nd = [0 for i in range(m)]\nsum = 2**n\nfor i in range(m):\n    s[i],d[i] = map(int, input().split(\" \"))\nfor i in range(m):\n    sum -= 2**(n-2)\n    sum %= 1000000007\n    sum += 1000000007\n    for j in range(m):\n        if i == j:\n            continue\n        if s[i] == s[j] or d[i] == d[j]:\n            sum += 2**(n-4)\n        if s[i] != s[j] and s[i] != d[j] and d[i] != s[j] and d[i] != d[j]:\n            sum += 2**(n-5)\nprint(sum%1000000007)\n"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::fmt;\nuse std::cmp::{Ordering, min, max};\nuse std::fmt::{Display, Error, Formatter};\nuse std::f32::MAX;\nuse std::ops::{Add, Sub, Mul, Div, Neg, Index, IndexMut};\nuse std::collections::{BTreeMap, VecDeque, BinaryHeap};\n\nfn show<T: Display>(vec: &Vec<T>) {\n    if vec.is_empty() {\n        println!(\"[]\");\n    }else {\n        print!(\"[{}\", vec[0]);\n        for i in 1 .. vec.len() {\n            print!(\", {}\", vec[i]);\n        }\n        println!(\"]\");\n    }\n}\nfn show2<T: Display>(vec: &Vec<Vec<T>>) {\n    if vec.is_empty() {\n        println!(\"[]\");\n    }else {\n        for l in vec {\n            show(l);\n        }\n    }\n}\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\nmacro_rules! read_value{\n    () => {\n        read_line!().trim().parse().ok().unwrap()\n    }\n}\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\nmacro_rules! let_mut_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let mut $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\n\nfn main() {\n    const MOD: i64 = 1000000007;\n    let_all!(n: usize, m: usize);\n    let mut fingers = vec![0; n + 1];\n    let mut constraint_count = vec![0; n + 1];\n    constraint_count[0] = n + 1;\n    for _ in 0 .. m {\n        let_all!(s: usize, d: usize);\n        fingers[s] = d;\n        constraint_count[d] += 1;\n    }\n    let mut stack = VecDeque::new();\n    let mut patterns = vec![1_i64; n + 1];\n    for i in 1 .. constraint_count.len() {\n        if constraint_count[i] == 0 {\n            stack.push_back(i);\n        }\n    }\n    while let Some(current) = stack.pop_back() {\n        patterns[current] = (patterns[current] + 1) % MOD;\n        patterns[fingers[current]] = (patterns[fingers[current]] * patterns[current]) % MOD;\n        constraint_count[fingers[current]] -= 1;\n        if constraint_count[fingers[current]] == 0 {\n            stack.push_back(fingers[current]);\n        }\n    }\n    for i in 1 .. constraint_count.len() {\n        if constraint_count[i] == 1 {\n            constraint_count[i] -= 1;\n            stack.push_back(fingers[i]);\n            while let Some(current) = stack.pop_back() {\n                constraint_count[current] -= 1;\n                patterns[fingers[current]] = (patterns[current] * patterns[fingers[current]]) % MOD;\n                if constraint_count[fingers[current]] == 1 {\n                    stack.push_back(fingers[current]);\n                }\n            }\n            patterns[0] = (patterns[0] * (patterns[i] + 1)) % MOD;\n        }\n    }\n    println!(\"{}\", patterns[0]);\n}\n"
  }
]