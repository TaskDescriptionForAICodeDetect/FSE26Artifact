[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char **words;\n    int *lengths;\n    int count;\n} WordList;\n\nWordList split_words(const char *text) {\n    WordList list;\n    list.count = 0;\n    list.words = NULL;\n    list.lengths = NULL;\n\n    const char *start = text;\n    while (*text) {\n        if (*text == ' ') {\n            if (start != text) {\n                list.count++;\n                list.words = realloc(list.words, list.count * sizeof(char *));\n                list.lengths = realloc(list.lengths, list.count * sizeof(int));\n                list.words[list.count - 1] = malloc(text - start + 1);\n                strncpy(list.words[list.count - 1], start, text - start);\n                list.words[list.count - 1][text - start] = '\\0';\n                list.lengths[list.count - 1] = text - start;\n            }\n            start = text + 1;\n        }\n        text++;\n    }\n    if (start != text) {\n        list.count++;\n        list.words = realloc(list.words, list.count * sizeof(char *));\n        list.lengths = realloc(list.lengths, list.count * sizeof(int));\n        list.words[list.count - 1] = malloc(text - start + 1);\n        strncpy(list.words[list.count - 1], start, text - start);\n        list.words[list.count - 1][text - start] = '\\0';\n        list.lengths[list.count - 1] = text - start;\n    }\n\n    return list;\n}\n\nvoid free_word_list(WordList *list) {\n    for (int i = 0; i < list->count; i++) {\n        free(list->words[i]);\n    }\n    free(list->words);\n    free(list->lengths);\n}\n\nvoid print_line(char **words, int *lengths, int word_count, int W) {\n    if (word_count == 0) return;\n\n    int total_length = 0;\n    for (int i = 0; i < word_count; i++) {\n        total_length += lengths[i];\n    }\n\n    int total_spaces = W - total_length;\n    int gaps = word_count - 1;\n\n    if (gaps == 0) {\n        printf(\"%s\", words[0]);\n        for (int i = lengths[0]; i < W; i++) {\n            printf(\" \");\n        }\n        printf(\"\\n\");\n        return;\n    }\n\n    int base_space = total_spaces / gaps;\n    int extra_spaces = total_spaces % gaps;\n\n    for (int i = 0; i < word_count; i++) {\n        printf(\"%s\", words[i]);\n        if (i < gaps) {\n            for (int j = 0; j < base_space; j++) {\n                printf(\" \");\n            }\n            if (i < extra_spaces) {\n                printf(\" \");\n            }\n        }\n    }\n    printf(\"\\n\");\n}\n\nvoid layout_text(const char *text, int W) {\n    WordList list = split_words(text);\n    int start = 0;\n\n    while (start < list.count) {\n        int end = start;\n        int line_length = 0;\n\n        while (end < list.count) {\n            int new_length = line_length + (end > start ? 1 : 0) + list.lengths[end];\n            if (new_length > W) break;\n            line_length = new_length;\n            end++;\n        }\n\n        if (end == list.count) {\n            for (int i = start; i < end; i++) {\n                printf(\"%s\", list.words[i]);\n                if (i < end - 1) {\n                    printf(\" \");\n                }\n            }\n            printf(\"\\n\");\n        } else {\n            print_line(list.words + start, list.lengths + start, end - start, W);\n        }\n\n        start = end;\n    }\n\n    free_word_list(&list);\n}\n\nint main() {\n    char text[1000];\n    int W;\n\n    fgets(text, sizeof(text), stdin);\n    text[strcspn(text, \"\\n\")] = '\\0';\n    scanf(\"%d\", &W);\n\n    layout_text(text, W);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:53:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> fullJustify(vector<string>& words, int maxWidth) {\n    vector<string> result;\n    int n = words.size();\n    int i = 0;\n    \n    while (i < n) {\n        int j = i, lineLength = 0;\n        while (j < n && lineLength + words[j].size() + (j - i) <= maxWidth) {\n            lineLength += words[j].size();\n            j++;\n        }\n        \n        int numWords = j - i;\n        int totalSpaces = maxWidth - lineLength;\n        \n        string line;\n        if (numWords == 1 || j == n) {\n            line = words[i];\n            for (int k = i + 1; k < j; k++) {\n                line += \" \" + words[k];\n            }\n            line += string(maxWidth - line.size(), ' ');\n        } else {\n            int spacesBetween = totalSpaces / (numWords - 1);\n            int extraSpaces = totalSpaces % (numWords - 1);\n            \n            line = words[i];\n            for (int k = i + 1; k < j; k++) {\n                int spaces = spacesBetween + (extraSpaces-- > 0 ? 1 : 0);\n                line += string(spaces, ' ') + words[k];\n            }\n        }\n        \n        result.push_back(line);\n        i = j;\n    }\n    \n    return result;\n}",
    "timestamp": "2025-08-05 20:53:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class TextJustification {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        List<String> result = new ArrayList<>();\n        int index = 0;\n        while (index < words.length) {\n            int count = words[index].length();\n            int last = index + 1;\n            while (last < words.length) {\n                if (words[last].length() + count + 1 > maxWidth) break;\n                count += words[last].length() + 1;\n                last++;\n            }\n            \n            StringBuilder builder = new StringBuilder();\n            int diff = last - index - 1;\n            if (last == words.length || diff == 0) {\n                for (int i = index; i < last; i++) {\n                    builder.append(words[i]);\n                    if (i < last - 1) builder.append(\" \");\n                }\n                for (int i = builder.length(); i < maxWidth; i++) {\n                    builder.append(\" \");\n                }\n            } else {\n                int spaces = (maxWidth - count) / diff;\n                int r = (maxWidth - count) % diff;\n                for (int i = index; i < last; i++) {\n                    builder.append(words[i]);\n                    if (i < last - 1) {\n                        for (int j = 0; j <= (spaces + ((i - index) < r ? 1 : 0)); j++) {\n                            builder.append(\" \");\n                        }\n                    }\n                }\n            }\n            result.add(builder.toString());\n            index = last;\n        }\n        return result;\n    }\n}",
    "timestamp": "2025-08-05 20:53:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TextLayout {\n    public static String layoutText(String text, int W) {\n        String[] words = text.split(\"\\\\s+\");\n        List<String> lines = new ArrayList<>();\n        \n        int currentLineLength = 0;\n        List<String> currentLineWords = new ArrayList<>();\n        \n        for (String word : words) {\n            if (currentLineLength + word.length() + (currentLineWords.isEmpty() ? 0 : 1) <= W) {\n                currentLineWords.add(word);\n                currentLineLength += word.length() + (currentLineWords.size() > 1 ? 1 : 0);\n            } else {\n                lines.add(justifyLine(currentLineWords, W));\n                currentLineWords = new ArrayList<>();\n                currentLineWords.add(word);\n                currentLineLength = word.length();\n            }\n        }\n        \n        if (!currentLineWords.isEmpty()) {\n            lines.add(leftJustifyLine(currentLineWords, W));\n        }\n        \n        return String.join(\"\\n\", lines);\n    }\n    \n    private static String justifyLine(List<String> words, int W) {\n        if (words.size() == 1) {\n            return leftJustifyLine(words, W);\n        }\n        \n        int totalWordLength = words.stream().mapToInt(String::length).sum();\n        int spaces = W - totalWordLength;\n        int gaps = words.size() - 1;\n        \n        int[] spaceDistribution = new int[gaps];\n        for (int i = 0; i < gaps; i++) {\n            spaceDistribution[i] = spaces / gaps;\n        }\n        \n        int remainder = spaces % gaps;\n        for (int i = 0; i < remainder; i++) {\n            spaceDistribution[i]++;\n        }\n        \n        StringBuilder line = new StringBuilder();\n        for (int i = 0; i < words.size(); i++) {\n            line.append(words.get(i));\n            \n            if (i < gaps) {\n                for (int j = 0; j < spaceDistribution[i]; j++) {\n                    line.append(\" \");\n                }\n            }\n        }\n        \n        return line.toString();\n    }\n    \n    private static String leftJustifyLine(List<String> words, int W) {\n        StringBuilder line = new StringBuilder();\n        for (int i = 0; i < words.size(); i++) {\n            line.append(words.get(i));\n            \n            if (i < words.size() - 1) {\n                line.append(\" \");\n            }\n        }\n        \n        while (line.length() < W) {\n            line.append(\" \");\n        }\n        \n        return line.toString();\n    }\n}",
    "timestamp": "2025-08-05 20:53:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_WORDS 1000\n#define MAX_WORD_LENGTH 100\n#define MAX_GRID_WIDTH 1000\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nvoid justify_line(char **words, int *word_lengths, int num_words, int width, char *line) {\n    int total_word_length = 0;\n    for (int i = 0; i < num_words; i++) {\n        total_word_length += word_lengths[i];\n    }\n    \n    int total_spaces = width - total_word_length;\n    int spaces_between = num_words > 1 ? total_spaces / (num_words - 1) : 0;\n    int extra_spaces = num_words > 1 ? total_spaces % (num_words - 1) : 0;\n    \n    int pos = 0;\n    for (int i = 0; i < num_words; i++) {\n        strcpy(line + pos, words[i]);\n        pos += word_lengths[i];\n        \n        if (i < num_words - 1) {\n            int current_spaces = spaces_between + (extra_spaces > 0);\n            for (int j = 0; j < current_spaces; j++) {\n                line[pos++] = ' ';\n            }\n            if (extra_spaces > 0) extra_spaces--;\n        }\n    }\n    line[pos] = '\\0';\n}\n\nvoid text_layout(char **words, int *word_lengths, int num_words, int width) {\n    char **grid = malloc(num_words * sizeof(char*));\n    for (int i = 0; i < num_words; i++) {\n        grid[i] = malloc((width + 1) * sizeof(char));\n    }\n    \n    int current_line = 0;\n    int current_line_words = 0;\n    int current_line_length = 0;\n    int line_start_index = 0;\n    \n    for (int i = 0; i < num_words; i++) {\n        if (current_line_length + word_lengths[i] + \n            (current_line_words > 0 ? 1 : 0) > width) {\n            \n            int line_words[MAX_WORDS];\n            char *line_word_ptrs[MAX_WORDS];\n            int line_word_lengths[MAX_WORDS];\n            \n            for (int j = 0; j < current_line_words; j++) {\n                line_words[j] = line_start_index + j;\n                line_word_ptrs[j] = words[line_start_index + j];\n                line_word_lengths[j] = word_lengths[line_start_index + j];\n            }\n            \n            justify_line(line_word_ptrs, line_word_lengths, \n                         current_line_words, width, grid[current_line]);\n            \n            current_line++;\n            current_line_words = 0;\n            current_line_length = 0;\n            line_start_index = i;\n        }\n        \n        current_line_words++;\n        current_line_length += word_lengths[i] + \n            (current_line_length > 0 ? 1 : 0);\n    }\n    \n    if (current_line_words > 0) {\n        int line_words[MAX_WORDS];\n        char *line_word_ptrs[MAX_WORDS];\n        int line_word_lengths[MAX_WORDS];\n        \n        for (int j = 0; j < current_line_words; j++) {\n            line_words[j] = line_start_index + j;\n            line_word_ptrs[j] = words[line_start_index + j];\n            line_word_lengths[j] = word_lengths[line_start_index + j];\n        }\n        \n        justify_line(line_word_ptrs, line_word_lengths, \n                     current_line_words, width, grid[current_line]);\n        current_line++;\n    }\n    \n    for (int i = 0; i < current_line; i++) {\n        printf(\"%s\\n\", grid[i]);\n    }\n    \n    for (int i = 0; i < num_words; i++) {\n        free(grid[i]);\n    }\n    free(grid);\n}\n\nint main() {\n    int num_words, width;\n    scanf(\"%d %d\", &num_words, &width);\n    \n    char **words = malloc(num_words * sizeof(char*));\n    int *word_lengths = malloc(num_words * sizeof(int));\n    \n    for (int i = 0; i < num_words; i++) {\n        words[i] = malloc((MAX_WORD_LENGTH + 1) * sizeof(char));\n        scanf(\"%s\", words[i]);\n        word_lengths[i] = strlen(words[i]);\n    }\n    \n    text_layout(words, word_lengths, num_words, width);\n    \n    for (int i = 0; i < num_words; i++) {\n        free(words[i]);\n    }\n    free(words);\n    free(word_lengths);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:54:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint calculateSpacesScore(const vector<string>& line, int W) {\n    int totalWordLength = 0;\n    for (const string& word : line) {\n        totalWordLength += word.length();\n    }\n    \n    int spacesNeeded = line.size() - 1;\n    int totalSpaces = W - totalWordLength;\n    \n    if (spacesNeeded == 0) return 0;\n    \n    int baseSpaces = totalSpaces / spacesNeeded;\n    int extraSpaces = totalSpaces % spacesNeeded;\n    \n    int maxSpaceLength = baseSpaces + (extraSpaces > 0 ? 1 : 0);\n    return maxSpaceLength;\n}\n\nvector<vector<string>> layoutText(const vector<string>& words, int W) {\n    vector<vector<string>> layout;\n    vector<string> currentLine;\n    int currentLineLength = 0;\n    \n    for (const string& word : words) {\n        if (currentLineLength + word.length() + (currentLine.empty() ? 0 : 1) > W) {\n            layout.push_back(currentLine);\n            currentLine.clear();\n            currentLineLength = 0;\n        }\n        \n        currentLine.push_back(word);\n        currentLineLength += word.length() + (currentLine.size() > 1 ? 1 : 0);\n    }\n    \n    if (!currentLine.empty()) {\n        layout.push_back(currentLine);\n    }\n    \n    return layout;\n}\n\nvector<vector<string>> optimizeLayout(const vector<string>& words, int W) {\n    vector<vector<string>> bestLayout;\n    int minMaxSpaces = INT_MAX;\n    \n    for (int startIndex = 0; startIndex < words.size(); ++startIndex) {\n        vector<vector<string>> currentLayout;\n        vector<string> currentLine;\n        int currentLineLength = 0;\n        int maxSpaceScore = 0;\n        \n        for (int i = startIndex; i < words.size(); ++i) {\n            const string& word = words[i];\n            \n            if (currentLineLength + word.length() + (currentLine.empty() ? 0 : 1) > W) {\n                int spaceScore = calculateSpacesScore(currentLine, W);\n                maxSpaceScore = max(maxSpaceScore, spaceScore);\n                currentLayout.push_back(currentLine);\n                currentLine.clear();\n                currentLineLength = 0;\n            }\n            \n            currentLine.push_back(word);\n            currentLineLength += word.length() + (currentLine.size() > 1 ? 1 : 0);\n        }\n        \n        if (!currentLine.empty()) {\n            currentLayout.push_back(currentLine);\n        }\n        \n        int finalSpaceScore = calculateSpacesScore(currentLayout.back(), W);\n        maxSpaceScore = max(maxSpaceScore, finalSpaceScore);\n        \n        if (maxSpaceScore < minMaxSpaces) {\n            minMaxSpaces = maxSpaceScore;\n            bestLayout = currentLayout;\n        }\n    }\n    \n    return bestLayout;\n}\n\nint main() {\n    int W;\n    string text;\n    \n    getline(cin, text);\n    cin >> W;\n    \n    istringstream iss(text);\n    vector<string> words;\n    string word;\n    \n    while (iss >> word) {\n        words.push_back(word);\n    }\n    \n    vector<vector<string>> result = optimizeLayout(words, W);\n    \n    for (const auto& line : result) {\n        for (size_t i = 0; i < line.size(); ++i) {\n            cout << line[i];\n            if (i < line.size() - 1) cout << \" \";\n        }\n        cout << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:54:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def layout_text(text, W):\n    def format_line(selected_words, spaces_needed, width):\n        if len(selected_words) == 1:\n            return selected_words[0] + ' ' * (width - len(selected_words[0]))\n        total_space = spaces_needed - ((len(selected_words) - 1) * spaces_needed // (len(selected_words) - 1))\n        gaps = len(selected_words) - 1\n        spaces = [spaces_needed // gaps] * gaps\n        \n        for i in range(total_space):\n            spaces[i] += 1\n        \n        line = ''\n        for i, word in enumerate(selected_words):\n            line += word\n            if i < len(spaces):\n                line += ' ' * spaces[i]\n        return line\n\n    words = text.split()\n    lines = []\n    index = 0\n\n    while index < len(words):\n        line = []\n        current_length = 0\n\n        while index < len(words) and current_length + len(words[index]) + len(line) <= W:\n            line.append(words[index])\n            current_length += len(words[index])\n            index += 1\n\n        spaces_needed = W - current_length\n        if index < len(words):\n            lines.append(format_line(line, spaces_needed, W))\n        else:\n            lines.append(' '.join(line).ljust(W))\n    \n    return '\\n'.join(lines)\n\n# Example usage\ntext = \"Your task is to layout words from a given text into a grid with W columns while adhering to several formatting rules.\"\nW = 30\nformatted_text = layout_text(text, W)\nprint(formatted_text)",
    "timestamp": "2025-08-13 03:59:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class TextJustifier {\n    public List<String> justifyWords(String text, int W) {\n        String[] words = text.split(\"\\\\s+\");\n        List<String> result = new ArrayList<>();\n        int n = words.length;\n        int index = 0;\n        \n        while (index < n) {\n            int totalChars = words[index].length();\n            int last = index + 1;\n            while (last < n) {\n                if (totalChars + 1 + words[last].length() > W) break;\n                totalChars += 1 + words[last].length();\n                last++;\n            }\n            \n            int gapCount = last - index - 1;\n            StringBuilder builder = new StringBuilder();\n            \n            if (last == n || gapCount == 0) {\n                for (int i = index; i < last; ++i) {\n                    builder.append(words[i]);\n                    if (i != last - 1) builder.append(' ');\n                }\n                while (builder.length() < W) {\n                    builder.append(' ');\n                }\n            } else {\n                int spaces = (W - totalChars) / gapCount;\n                int extraSpaces = (W - totalChars) % gapCount;\n                \n                for (int i = index; i < last; ++i) {\n                    builder.append(words[i]);\n                    if (i != last - 1) {\n                        int spacesToApply = spaces + ((i - index) < extraSpaces ? 1 : 0);\n                        for (int j = 0; j <= spacesToApply; ++j) {\n                            builder.append(' ');\n                        }\n                    }\n                }\n            }\n            result.add(builder.toString());\n            index = last;\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        TextJustifier justifier = new TextJustifier();\n        List<String> justifiedText = justifier.justifyWords(\"This is an example of text justification.\", 16);\n        for (String line : justifiedText) {\n            System.out.println(line);\n        }\n    }\n}",
    "timestamp": "2025-08-13 04:00:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid justifyLine(char** words, int wordCount, int W, char* result) {\n    int totalChars = 0;\n    for (int i = 0; i < wordCount; ++i) {\n        totalChars += strlen(words[i]);\n    }\n\n    int totalSpaces = W - totalChars;\n    int minSpacesBetweenWords = wordCount > 1 ? totalSpaces / (wordCount - 1) : totalSpaces;\n    int extraSpaces = wordCount > 1 ? totalSpaces % (wordCount - 1) : 0;\n\n    result[0] = '\\0';\n    for (int i = 0; i < wordCount; ++i) {\n        strcat(result, words[i]);\n        if (i < wordCount - 1) {\n            for (int j = 0; j < minSpacesBetweenWords; ++j) {\n                strcat(result, \" \");\n            }\n            if (i < extraSpaces) {\n                strcat(result, \" \");\n            }\n        }\n    }\n}\n\nvoid layoutText(char* text, int W) {\n    char** words = (char**)malloc(sizeof(char*) * strlen(text));\n    int wordCount = 0;\n    char* token = strtok(text, \" \");\n    while (token != NULL) {\n        words[wordCount++] = token;\n        token = strtok(NULL, \" \");\n    }\n    \n    char** result = (char**)malloc(sizeof(char*) * (wordCount + 1));\n    int currentWord = 0;\n    while (currentWord < wordCount) {\n        int lineWordCount = 0;\n        int lineChars = -1; // To account for minimum one space between words\n        while (currentWord + lineWordCount < wordCount && lineChars + strlen(words[currentWord + lineWordCount]) + 1 <= W) {\n            lineChars += strlen(words[currentWord + lineWordCount]) + 1;\n            ++lineWordCount;\n        }\n        \n        if (currentWord + lineWordCount == wordCount || lineWordCount == 1) { // Last line or single word\n            result[currentWord] = (char*)malloc(sizeof(char) * (lineChars + 1));\n            result[currentWord][0] = '\\0';\n            for (int i = 0; i < lineWordCount; ++i) {\n                strcat(result[currentWord], words[currentWord + i]);\n                if (i < lineWordCount - 1) {\n                    strcat(result[currentWord], \" \");\n                }\n            }\n        } else {\n            result[currentWord] = (char*)malloc(sizeof(char) * (W + 1));\n            justifyLine(&words[currentWord], lineWordCount, W, result[currentWord]);\n        }\n        \n        currentWord += lineWordCount;\n    }\n\n    for (int i = 0; i < currentWord; ++i) {\n        printf(\"%s\\n\", result[i]);\n        free(result[i]);\n    }\n\n    free(words);\n    free(result);\n}\n\nint main() {\n    char text[] = \"Your task is to layout words from a given text into a grid\";\n    int W = 25;\n    layoutText(text, W);\n    return 0;\n}",
    "timestamp": "2025-08-13 04:00:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def layout_text(text, W):\n    words = text.split()\n    lines = []\n    current_line = []\n    current_width = 0\n\n    for word in words:\n        if current_width + len(word) + len(current_line) <= W:\n            current_line.append(word)\n            current_width += len(word)\n        else:\n            lines.append(current_line)\n            current_line = [word]\n            current_width = len(word)\n\n    if current_line:\n        lines.append(current_line)\n\n    formatted_lines = []\n    for line_idx, line in enumerate(lines):\n        if len(line) == 1:\n            formatted_line = line[0] + ' ' * (W - len(line[0]))\n        else:\n            total_word_length = sum(len(word) for word in line)\n            total_spaces = W - total_word_length\n            gaps = len(line) - 1\n            base_space = total_spaces // gaps\n            extra_spaces = total_spaces % gaps\n\n            formatted_line = line[0]\n            for i in range(1, len(line)):\n                space_count = base_space + (1 if i <= extra_spaces else 0)\n                formatted_line += ' ' * space_count + line[i]\n\n        formatted_lines.append(formatted_line)\n\n    return formatted_lines",
    "timestamp": "2025-08-13 04:00:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def text_layout(text, W):\n    words = text.split()\n    if not words:\n        return []\n    \n    lines = []\n    current_line = []\n    current_length = 0\n    \n    for word in words:\n        if current_line:\n            # Adding a space before the next word\n            if current_length + 1 + len(word) <= W:\n                current_line.append(word)\n                current_length += 1 + len(word)\n            else:\n                lines.append(current_line)\n                current_line = [word]\n                current_length = len(word)\n        else:\n            if len(word) <= W:\n                current_line.append(word)\n                current_length = len(word)\n            else:\n                # Handle words longer than W (though problem says it's not possible per rules)\n                pass\n    \n    if current_line:\n        lines.append(current_line)\n    \n    justified_lines = []\n    for i in range(len(lines)):\n        line = lines[i]\n        if i == len(lines) - 1:\n            # Last line: left-justified\n            justified_line = ' '.join(line)\n            justified_lines.append(justified_line)\n        else:\n            if len(line) == 1:\n                justified_line = line[0].ljust(W)\n                justified_lines.append(justified_line)\n            else:\n                total_spaces = W - sum(len(word) for word in line)\n                gaps = len(line) - 1\n                base_space = total_spaces // gaps\n                extra_spaces = total_spaces % gaps\n                \n                spaces = [base_space] * gaps\n                for j in range(extra_spaces):\n                    spaces[j] += 1\n                \n                justified_line = []\n                for k in range(len(line)):\n                    justified_line.append(line[k])\n                    if k < len(spaces):\n                        justified_line.append(' ' * spaces[k])\n                justified_line = ''.join(justified_line)\n                justified_lines.append(justified_line)\n    \n    return justified_lines",
    "timestamp": "2025-08-13 04:00:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nstd::vector<std::string> justifyText(const std::string& text, int W) {\n    std::vector<std::string> result;\n    std::istringstream iss(text);\n    std::vector<std::string> words;\n    std::string word;\n    \n    while (iss >> word) {\n        words.push_back(word);\n    }\n    \n    size_t n = words.size();\n    int start = 0;\n    \n    while (start < n) {\n        int length = words[start].size();\n        int end = start + 1;\n        \n        while (end < n && length + words[end].size() + (end - start) <= W) {\n            length += words[end].size();\n            ++end;\n        }\n        \n        int space_slots = end - start - 1;\n        int total_spaces = W - length;\n        \n        std::string line = words[start];\n        if (end == n || space_slots == 0) {\n            for (int i = start + 1; i < end; ++i) {\n                line += \" \" + words[i];\n            }\n            line += std::string(W - line.size(), ' ');\n        } else {\n            int min_spacing = total_spaces / space_slots;\n            int extra_spaces = total_spaces % space_slots;\n            \n            for (int i = start + 1; i < end; ++i) {\n                int spaces = min_spacing + (i - start <= extra_spaces ? 1 : 0);\n                line += std::string(spaces, ' ') + words[i];\n            }\n        }\n        \n        result.push_back(line);\n        start = end;\n    }\n    \n    return result;\n}\n\nint main() {\n    std::string text = \"Your sample text input here\";\n    int width = 20;\n    std::vector<std::string> output = justifyText(text, width);\n    \n    for (const std::string& line : output) {\n        std::cout << \"'\" << line << \"'\" << std::endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:16:18"
  }
]