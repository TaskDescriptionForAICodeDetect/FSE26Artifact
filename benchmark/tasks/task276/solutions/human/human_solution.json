[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\nint W,N,x[50000],sum[50001];\nbool can(int x){\n\tbool dp[50001]={};\n\tint imos[50002]={};\n\tdp[0]=true;\n\timos[1]=1;\n\tfor(int i=2;i<=N;i++){\n\t\tint lb=1,ub=i+1;\n\t\twhile(ub-lb>1){\n\t\t\tint m=(ub+lb)/2;\n\t\t\tif(W-(sum[i]-sum[i-m])>=m-1) lb=m;\n\t\t\telse ub=m;\n\t\t}\n\t\tint r=lb;\n\t\tlb=1,ub=i+1;\n\t\twhile(ub-lb>1){\n\t\t\tint m=(lb+ub)/2;\n\t\t\tif(W-(sum[i]-sum[i-m])<=(long long)(m-1)*x) ub=m;\n\t\t\telse lb=m;\n\t\t}\n\t\tint l=ub;\n\t\tif(imos[i-l+1]-imos[i-r]>0) dp[i]=true;\n\t\timos[i+1]=imos[i]+(dp[i]?1:0);\n\t}\n\tfor(int i=N;i>=0;i--){\n\t\tif(sum[N]-sum[i]+(N-1-i)>W) break;\n\t\tif(dp[i]) return true;\n\t}\n\treturn false;\n}\nint main(){\n\twhile(true){\n\t\tscanf(\"%d%d\",&W,&N);\n\t\tif(W==0) return 0;\n\t\trep(i,N) scanf(\"%d\",x+i);\n\t\trep1(i,N) sum[i]=sum[i-1]+x[i-1];\n\t\tint ub=W/2,lb=0;\n\t\twhile(ub-lb>1){\n\t\t\tint m=(ub+lb)/2;\n\t\t\tif(can(m)) ub=m;\n\t\t\telse lb=m;\n\t\t}\n\t\tcout<<ub<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint main()\n{\n  int W, N, x[50000] = {};\n  int dp[50000];\n\n  while(scanf(\"%d %d\", &W, &N), W) {\n    for(int i = 1; i <= N; i++) {\n      scanf(\"%d\", x + i);\n      x[i] += x[i - 1];\n    }\n\n    auto getSpace = [&](int l, int r)\n    {\n      if(x[r] - x[l] + r - l - 1 > W) return (INF);\n      if(r == N) return (1);\n      if(l + 1 >= r) return (-INF);\n      return ((W + x[l] + r - x[r] - l - 2) / (r - l - 1));\n    };\n\n    fill_n(dp, N + 1, INF);\n    dp[0] = 0;\n    for(int i = 1; i <= N; i++) {\n      for(int j = i - 1; j >= 0; j--) {\n        int vv = getSpace(j, i);\n        if(vv == -INF) continue;\n        if(vv == INF) break;\n        dp[i] = min(dp[i], max(dp[j], getSpace(j, i)));\n      }\n    }\n\n    printf(\"%d\\n\", dp[N]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\nconst int maxn=50000+10;\nint sum[maxn],num[maxn],N,W,R[maxn];\n\ninline int len(int l,int r)\n{\n    if (l>=r) return 0;\n    if (sum[r]-sum[l-1]+r-l>W) return -1;\n    return (W-(sum[r]-sum[l-1])+(r-l-1))/(r-l);\n}\n\nbool solve(int can)\n{\n    int now=1,st,ed,l,r,maxs=0;\n    memset(num,0,(N+2)*sizeof(int));\n    num[1]=-1;\n    l=2;\n    for(int i=0;i<=maxs;i++)\n    {\n        now+=num[i];\n        if (now<=0||len(i+1,R[i+1])>can) continue;\n        if (l<i+2) l=i+2;\n        while(len(i+1,l)>can) l++;\n        r=R[i+1];\n        num[l]++;\n        num[r+1]--;\n        if (r>maxs) maxs=r;\n        if (sum[N]-sum[r]+N-r<=W) return 1;\n    }\n    return 0;\n}\n\nint main()\n{\n    while(scanf(\"%d%d\",&W,&N)==2)\n    {\n        if (W==0&&N==0) break;\n        sum[0]=0;\n        for(int i=1;i<=N;i++) scanf(\"%d\",&sum[i]),sum[i]+=sum[i-1];\n        int st=1,ed=W/2+1;\n        if (sum[N]+N-1<=W) ed=1;\n        int j=N;\n        for(int i=N-1;i>=1;i--)\n        {\n            while(sum[j]-sum[i-1]+j-i>W) j--;\n            R[i]=j;\n        }\n        while(st<ed)\n        {\n            int mid=(st+ed)>>1;\n            if (solve(mid)) ed=mid;\n            else st=mid+1;\n        }\n        printf(\"%d\\n\",st);\n    }\n    return 0;\n}\n/*\n11 4\n4 2 1 3\n5 7\n1 1 1 2 2 1 2\n11 7\n3 1 3 1 3 3 4\n100 3\n30 30 39\n30 3\n2 5 3\n0 0\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<string>\n#include<cstring>\n#include<map>\n#include<numeric>\n#include<sstream>\n#include<cmath>\nusing namespace std;\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define pb push_back\n#define f(i,x,y) for(int i = x; i<y; i++ )\n#define FORV(it,A) for(vector<int>::iterator it = A.begin(); it!= A.end(); it++)\n#define FORS(it,A) for(set<int>::iterator it = A.begin(); it!= A.end(); it++)\n#define quad(x) (x) * (x)\n#define mp make_pair\n#define clr(x, y) memset(x, y, sizeof x)\n#define fst first\n#define snd second\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\n\n#define N 100000\nll S[N], v[N];\nint pd[N];\nint W, n;\n\n\ninline ll teto (ll a, ll b){\n\treturn ((a-1)/b)+1;\n\t//if (a%b == 0) return a/b;\n\t//return a/b+1;\n}\n\n/*int solve (int E){\n\tpd[n] = 0;\n\tpd[n-1] = 1;\n\tfor (int i = n-2; i >= 0; i--){\n\t\tint ini = i, fim = n-1;\n\t\twhile (ini < fim-1){\n\t\t\tint mid = ((ini+fim)>>1);\n\t\t\tll s = S[mid];\n\t\t\tif (i != 0) s -= S[i-1];\n\t\t\tif (s+mid-i <= W) ini = mid;\n\t\t\telse fim = mid-1;\n\t\t}\n\t\tint y;\n\t\tll s = S[fim];\n\t\tif (i != 0) s -= S[i-1];\n\t\tif (s+fim-i <= W) y = fim;\n\t\telse y = ini;\n\t\tini = i+1, fim = y;\n\t\twhile (ini < fim){\n\t\t\tint mid = ((ini+fim)>>1);\n\t\t\tll s = S[mid];\n\t\t\tif (i != 0) s -= S[i-1];\n\t\t\tif (teto(W-s, mid-i) <= E) fim = mid; //TODO\n\t\t\telse ini = mid+1;\n\t\t}\n\t\ts = S[y];\n\t\tif (i != 0) s -= S[i-1];\n\t\tint soma;\n\t\tif (teto(W-s, y-i) > E) soma = 0; //TODO\n\t\telse soma = pd[ini+1]-pd[y+2];\n\t\tif (y == n-1) soma = 1;\n\t\tpd[i] = pd[i+1];\n\t\tif (soma != 0) pd[i]++;\n\t}\n\treturn pd[0]-pd[1];\n}*/\n\n\nll V (int a, int b){\n\tll s = S[b];\n\tif (a != 0) s -= S[a-1];\n\treturn teto(W-s, b-a);\n}\n\nbool cabe (int a, int b){\n\tint mid = b, i = a;\n\tll s = S[mid];\n\tif (i != 0) s -= S[i-1];\n\treturn (s+mid-i <= W);\n}\n\nint solve (int E){\n\tpd[n] = 0;\n\tpd[n-1] = 1;\n    int ini = n-1, fim = n-1;\n    for (int i = n-2; i >= 0; i--){\n        while (fim >= i){\n            if (cabe(i, fim)) break;\n            fim--;\n        }\n        int s;\n        ini = min(ini,fim);\n        if (V(i, fim) > E) s = 0;\n        else{\n            while (ini > i){\n                if (ini == i+1 || V(i, ini-1) > E) break;\n                ini--;\n            }\n            s = pd[ini+1]-pd[fim+2];\n        }\n        pd[i] = pd[i+1];\n        if (fim == n-1) s = 1;\n        if (s) pd[i]++;\n        //printf(\"->i = %d ini = %d fim = %d s = %d %d\\n\", i,ini, fim, s, pd[i]);\n    }\n    return pd[0]-pd[1];\n}\n\n\nint main (){\n\twhile (1){\n\t\tcin >> W >> n;\n\t\tif (W+n == 0) break;\n\t\tf (i, 0, n) cin >> S[i];\n\t\tf (i, 1, n) S[i] += S[i-1];\n\t\tint ini = 1, fim = W/2+1;\n        //cout << solve(1) << endl; break;\n\t\twhile (ini < fim){\n\t\t\tint mid = (ini+fim)/2;\n\t\t\tif (solve(mid)) fim = mid;\n\t\t\telse ini = mid+1;\n\t\t}\n\t\tprintf(\"%d\\n\", ini);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\ntypedef long long LL;\nint a[100000];\nLL sum[100000];\nint n,m;\nint bo1[50001],bo2[50001],f[50001];\n\nint check(int ans){\n\tmemset(bo1,0,sizeof(bo1));\n\tmemset(bo2,0,sizeof(bo2));\n\tmemset(f,0,sizeof(f));\n\tf[0]=1;\n\tint p1=0,p2=0,ans1=0;\n\tfor (int i=1; i<=n; ++i){\n\t\twhile (p1<i && sum[i]+(LL)i*ans>=sum[p1]+(LL)p1*ans+m+ans){\n\t\t\tbo1[p1]=1;\n\t\t\tif (bo1[p1] && !bo2[p1] && f[p1]) ++ans1; \n\t\t\t++p1;\n\t\t}\n\t\twhile (p2<i && sum[i]+i>sum[p2]+p2+1+m) {\n\t\t\tbo2[p2]=1;\n\t\t\tif (bo1[p2] && f[p2]) --ans1;\n\t\t\t++p2;\n\t\t}\n\t\tif (ans1) f[i]=1;\n\t}\n\tfor (int i=0; i<=n; ++i)\n\t\tif (f[i] && (sum[n]-sum[i]+n-i-1)<=m) return 1;\n\treturn 0;\n}\n\nint main(){\n\twhile (scanf(\"%d%d\",&m,&n), n>0 || m>0){\n\t\tfor (int i=1; i<=n; ++i) scanf(\"%d\",&a[i]);\n\t\tmemset(sum,0,sizeof(sum));\n\t\tfor (int i=1; i<=n; ++i) sum[i]=sum[i-1]+a[i];\n\t\tint head=0,tail=m;\n\t\twhile (head<tail-1){\n\t\t\tint mid=(head+tail)>>1;\n\t\t\tif (check(mid)) tail=mid;\n\t\t\telse head=mid;\n\t\t\t//printf(\"%d %d\\n\",head,tail);\n\t\t}\n\t\tprintf(\"%d\\n\",tail);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <ctime>\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\n#include <valarray>\n\nusing namespace std;\ntypedef long long ll;\n\n#define ALL(c) (c).begin(),(c).end()\n#define FOR(i,l,r) for(int i=(int)l;i<(int)r;++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORr(i,l,r) for(int i=(int)r-1;i>=(int)l;--i)\n#define REPr(i,n) FORr(i,0,n)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\ntemplate<typename T,typename U> T pmod(T x,U M){return (x%M+M)%M;}\n\n\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\n\n\n\nnamespace Fenwicks{\n  template<typename T> class Fenwick{\n  public:\n    int size;vector<T> bit;\n    Fenwick():Fenwick(0){}\n    Fenwick(int n):size(n){bit = vector<T>(n+1);}\n    T sum(int n){// [0,n)\n      T s=0;\n      while(n>0){\n        s+=bit[n];\n        n-=n&-n;//low\n      }\n      return s;\n    }\n    void add(int i,T x){//[0,...i...,n)\n      i++;\n      while(i<=size){\n        bit[i]+=x;\n        i+=i & -i;//next\n      }\n    }\n    \n    //lib\n    T sum(int a,int b){// [a,b)\n      return sum(b)-sum(a);\n    }\n  };\n}\nusing namespace Fenwicks;\n\n\ntemplate <typename T,typename Func> T satisfy_min(T l ,T r,Func P){\n  l--;\n  while(r-l>1)(P((l+r)/2)?r:l)=(l+r)/2;\n  return r;\n}\n\n// max{i∈[l,r) | P(i)}．存在しない時、 l-1．\ntemplate <typename T,typename Func> T satisfy_max(T l ,T r,Func P){\n  l--;\n  while(r-l>1)(P((l+r)/2)?l:r)=(l+r)/2;\n  return l;\n}\n\n\nint W,N;\nvector<int> xs;\n\nvector<ll> xsum,wsum;\n\nint _i,_spM;\nbool satL(int ml){\n  ll spc=ml-_i-1,sp=(W-(xsum[ml]-xsum[_i]) + spc-1)/spc;\n  return sp<=_spM;\n}\n\nvector<int> rs;\n\nint can(int spM){\n  Fenwick<int> fen(N);\n  vector<bool> ok(N);\n  //last\n  FORr(i,0,N)if(wsum[N]-wsum[i]-1<=W)fen.add(i,1),ok[i]=true;\n\n  //back \"[i,N)がok\" =def \"1区間 [i,m)がok\" かつ \"*区間 [m,N)がok\"\n  FORr(i,0,N-1)if(!ok[i]){\n    //[i,l)\n    // int l=satisfy_min(i+2,N,[&](int ml)->bool{\n    //   ll spc=ml-i-1,sp=(W-(xsum[ml]-xsum[i]) + spc-1)/spc;\n    //   return sp<=spM;\n    // });\n    _i=i;_spM=spM;\n    int l=satisfy_min(i+2,N,satL);\n    \n    //[i,r)\n    // int r=satisfy_max(i+2,N,[&](int mr)->bool{\n    //     return wsum[mr]-wsum[i]-1<=W;\n    // });\n    if(l<=rs[i] && fen.sum(l,rs[i]+1)>0)fen.add(i,1),ok[i]=true;\n  }\n  return ok[0];\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n  ifstream cin( \"in\" );\n  ofstream cout( \"out\" );\n\tcerr << fixed <<setprecision(20);\n\tcout << fixed <<setprecision(20);\n\n  while (true) {\n    cin >> W>> N;if(N==0)break;\n    xs=vector<int>(N);REP(i,N)cin >> xs[i];\n\n    xsum=vector<ll>(N+1);\n    FOR(i,1,N+1)xsum[i]=xsum[i-1]+xs[i-1];\n    wsum=vector<ll>(N+1);\n    FOR(i,1,N+1)wsum[i]=wsum[i-1]+1+xs[i-1];\n\n    rs=vector<int>(N);\n    REP(i,N) rs[i]=satisfy_max(i+2,N,[&](int mr)->bool{return wsum[mr]-wsum[i]-1<=W;});\n    \n    int res=satisfy_min(1,100000,[&](int m){\n      return can(m);\n    });\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Union_Find_Tree{\n\tpublic:\n\tvi Par;\n\tUnion_Find_Tree(int n){\n\t\tPar=vi(n);\n\t\tfor(int i=0;i<n;i++) Par[i]=i;\n\t}\n\tint Find_Par(int x){\n\t\tif(Par[x]==x) return x;\n\t\treturn Par[x]=Find_Par(Par[x]);\n\t}\n\tbool Unite(int x,int y){\n\t\tx=Find_Par(x);\n\t\ty=Find_Par(y);\n\t\tif(x==y) return 0;\n\t\tPar[x]=y;\n\t\treturn 1;\n\t}\n};\n\nint w,n;\nvi a;\n\nbool f(int x){\n    vi L(n),R(n);\n    int li=1,ri=1,ls=a[0],rs=a[0];\n    for(int i=0;i<n;i++){\n        ls-=(i?a[i-1]+x:0);\n        while(li<n&&ls<w){\n            ls+=x+a[li];\n            li++;\n        }\n        rs-=(i?a[i-1]+1:0);\n        while(ri<n&&rs<=w){\n            rs+=1+a[ri];\n            ri++;\n        }\n        if(rs<=w&&ri==n){\n            ri++;\n        }\n        L[i]=li;\n        R[i]=ri;\n    }\n\tUnion_Find_Tree uft(n+1);\n    queue<int> q;\n    q.push(0);\n    while(!q.empty()){\n        int p=q.front();\n        q.pop();\n        if(R[p]==n+1) return 1;\n\t\tint i=uft.Find_Par(L[p]);\n\t\twhile(i<R[p]){\n\t\t\tq.push(i);\n\t\t\tuft.Unite(i,i+1);\n\t\t\ti=uft.Find_Par(i);\n\t\t}\n    }\n    return 0;\n}\n\nint main(){\n    while(1){\n        cin>>w>>n;\n        if(!w) break;\n        a=vi(n);\n        for(int i=0;i<n;i++) cin>>a[i];\n        int l=0,r=w;\n        while(r-l>1){\n            int m=(l+r)/2;\n            if(f(m)) r=m;\n            else l=m;\n        }\n        cout<<r<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = (1<<29);\nint W,N;\nvector<int> x;\nint dp[50005];\nint S[50005];\n\nint getn(int sm,int k){\n  if( k == 0 ){\n    if( sm != W ) return INF;\n    return 0;\n  }\n  return (W - sm + k - 1 )/k + 1;\n}\n\nint solve(){\n  memset( dp,0,sizeof( dp ) );\n  S[0] = 0;\n  for(int i=0;i<N;i++)\n    S[i+1] = S[i] + x[i];\n  dp[0] = 0;\n  int pc = 0;\n  for(int i=1;i<=N;i++){\n    int rt = INF;\n    pc = 0;\n    for(;pc<i;pc++){\n      int a = S[i] - S[pc] + i - pc - 1;\n      int b = dp[pc];\n      if( a > W ) continue;\n      if( i - pc - 1 == 0 ){\n        if( a == W ) rt = 0;\n        break;\n      }\n      a = getn( a, i - pc - 1 );\n      rt = min( rt, max( a, b ) );     \n      if( b == 0 ) break;\n    }\n    dp[i] = rt;    \n    //  cout << i << \": \" << dp[i] << endl;\n  }\n\n  \n  int res = dp[N];\n  int sm = 0;\n  for(int i=N-1;i>0;i--){\n    sm += x[i];\n    if( sm > W ) break;\n    res = min( res, dp[i] );\n    sm++;\n  }\n  return max(1,res);\n}\n\nint main(){\n  while( cin >> W >> N && (W||N) ){\n    x = vector<int>(N);\n    int sm = 0;\n    bool f = false;\n    for(int i=0;i<N;i++){\n      cin >> x[i];\n      sm += x[i];\n      if( sm > W ) f = true;      \n      sm++;\n    }\n    if( f ) {\n      cout << solve() << endl;\n    } else {\n      cout << 1 << endl;\n    }\n     \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<string>\n#include<cstring>\n#include<map>\n#include<numeric>\n#include<sstream>\n#include<cmath>\nusing namespace std;\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define pb push_back\n#define f(i,x,y) for(int i = x; i<y; i++ )\n#define FORV(it,A) for(vector<int>::iterator it = A.begin(); it!= A.end(); it++)\n#define FORS(it,A) for(set<int>::iterator it = A.begin(); it!= A.end(); it++)\n#define quad(x) (x) * (x)\n#define mp make_pair\n#define clr(x, y) memset(x, y, sizeof x)\n#define fst first\n#define snd second\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\n\n#define N 100000\nll S[N], v[N];\nint pd[N];\nint W, n;\n\n\nll teto (ll a, ll b){\n\tif (a%b == 0) return a/b;\n\treturn a/b+1;\n}\n\nint solve (int E){\n\tpd[n] = 0;\n\tpd[n-1] = 1;\n\tfor (int i = n-2; i >= 0; i--){\n\t\tint ini = i, fim = n-1;\n\t\twhile (ini < fim-1){\n\t\t\tint mid = (ini+fim)/2;\n\t\t\tll s = S[mid];\n\t\t\tif (i != 0) s -= S[i-1];\n\t\t\tif (s+mid-i <= W) ini = mid;\n\t\t\telse fim = mid-1;\n\t\t}\n\t\tint y;\n\t\tll s = S[fim];\n\t\tif (i != 0) s -= S[i-1];\n\t\tif (s+fim-i <= W) y = fim;\n\t\telse y = ini;\n\t\tini = i+1, fim = y;\n\t\twhile (ini < fim){\n\t\t\tint mid = (ini+fim)/2;\n\t\t\tll s = S[mid];\n\t\t\tif (i != 0) s -= S[i-1];\n\t\t\tif (teto(W-s, mid-i) <= E) fim = mid; //TODO\n\t\t\telse ini = mid+1;\n\t\t}\n\t\ts = S[y];\n\t\tif (i != 0) s -= S[i-1];\n\t\tint soma;\n\t\tif (teto(W-s, y-i) > E) soma = 0; //TODO\n\t\telse soma = pd[ini+1]-pd[y+2];\n\t\tif (y == n-1) soma = 1;\n\t\tpd[i] = pd[i+1];\n\t\tif (soma != 0) pd[i]++;\n\t}\n\treturn pd[0]-pd[1];\n}\n\nint main (){\n\twhile (1){\n\t\tcin >> W >> n;\n\t\tif (W+n == 0) break;\n\t\tf (i, 0, n) cin >> S[i];\n\t\tf (i, 1, n) S[i] += S[i-1];\n\t\tint ini = 1, fim = W;\n\t\twhile (ini < fim){\n\t\t\tint mid = (ini+fim)/2;\n\t\t\tif (solve(mid)) fim = mid;\n\t\t\telse ini = mid+1;\n\t\t}\n\t\tprintf(\"%d\\n\", ini);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<functional>\nusing namespace std;\nint x[100000], dat[100000], n, W, dp[100000], nex[100000];\npriority_queue<pair<int, int>, vector<pair<int, int>>, less<pair<int, int>>>Q;\nvoid add(int p, int q) {\n\twhile (p <= n) {\n\t\tdat[p] += q;\n\t\tp += p&-p;\n\t}\n}\nint sum(int p) {\n\tint sum2 = 0;\n\twhile (p >= 1) {\n\t\tsum2 += dat[p];\n\t\tp -= p&-p;\n\t}\n\treturn sum2;\n}\nint Rangesum(int W1, int W2) {\n\treturn sum(W2) - sum(W1 - 1);\n}\nint hantei(int L1, int R1) {\n\tif (L1 == 0)return 2147000000;\n\tint E = Rangesum(L1, R1);\n\tE += (R1 - L1);\n\treturn E;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> W >> n; for (int i = 0; i < 100000; i++) { dat[i] = 0; dp[i] = 999999999; nex[i] = -2; }\n\t\tif (n == 0 && W == 0)break;\n\t\tfor (int i = 1; i <= n; i++)cin >> x[i]; add(1, x[1]); dp[0] = 1;\n\t\twhile (!Q.empty())Q.pop(); Q.push(make_pair(99999999, 1)); Q.push(make_pair(0, 0));\n\n\t\tfor (int i = 2; i <= n - 1; i++) {\n\t\t\tadd(i, x[i]);\n\t\t\tint L = 1, R = i, M = 0;\n\t\t\twhile (true) {\n\t\t\t\tM = (L + R) / 2;\n\t\t\t\tint V1 = hantei(M, i);\n\t\t\t\tint V2 = hantei(M - 1, i);\n\t\t\t\tif (V1 <= W && V2 > W) {\n\t\t\t\t\tint j = M;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tint KO = i - j;\n\t\t\t\t\t\tint V1 = hantei(j, i);\n\t\t\t\t\t\tdp[i] = min(dp[i], max(dp[j - 1], ((W - V1) + KO - 1) / KO + 1));\n\t\t\t\t\t\tj = nex[j - 1] + 1; if (j == -1 || j >= i)break;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (V1 > W)L = M;\n\t\t\t\tif (V2 <= W)R = M;\n\t\t\t}\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tif (dp[i] < Q.top().first) { nex[Q.top().second] = i; Q.pop(); }\n\t\t\t\telse { break; }\n\t\t\t}\n\t\t\tQ.push(make_pair(dp[i], i));\n\t\t}\n\t\tadd(n, x[n]); int minx = 999999999;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (Rangesum(i + 1, n) + (n - (i + 1)) <= W)minx = min(minx, dp[i]);\n\t\t}\n\t\tcout << minx << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int INF = 80010;\n\nint w,n,a[50010],s[50010],dp[50010];\n\nbool check(int x){\n\tdp[1] = 1;\n\tint l = 0,r = 0;\n\tfor(int i = 1;i <= n;i++){\n\t\twhile(i > l && s[i] - s[l] + (i - l - 1) > w) l++;\n\t\twhile(i > r && s[i] - s[r] + (i - r - 1) * x >= w) r++;\n\t\tdp[i + 1] = dp[i] + !!(dp[r] - dp[l]);\n\t}\n\tl = n;\n\twhile(l >= 0 && s[n] - s[l] + n - l - 1 < w) l--;\n\treturn dp[n + 1] - dp[l + 1];\n}\n\nvoid solve(){\n\tfor(int i = 0;i < n;i++){\n\t\tscanf(\"%lld\",&a[i]);\n\t\ts[i + 1] = s[i] + a[i];\n\t}\n\tint ng = 0,ok = INF;\n\twhile(ok - ng > 1){\n\t\tint mid = (ok + ng) / 2;\n\t\tif(check(mid)) ok = mid;\n\t\telse ng = mid;\n\t}\n\tprintf(\"%lld\\n\",ok);\n}\n\nsigned main(){\n\twhile(cin >> w >> n,n) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\ninline bool check(int w, int limit, const vector<int> &x, const vector<int> &sum) {\n\tconst int n = x.size();\n\n\tint mn_next = n;\n\tint mx_next = n;\n\tint cnt = 0;\n\tvector<bool> dp(n + 1, false);\n\tdp[n] = true;\n\n\tfor(int i = n - 1; i >= 0; --i) {\n\t\tif(sum[n] - sum[i] + 1 * (mn_next - i - 1) <= w) {\n\t\t\tdp[i] = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile(sum[mn_next - 1] - sum[i] + 1 * (mn_next - i - 2) > w) {\n\t\t\tif(dp[--mn_next]) --cnt;\n\t\t}\n\n\t\twhile(sum[mx_next - 1] - sum[i] + limit * (mx_next - i - 2) >= w) {\n\t\t\tif(dp[--mx_next]) ++cnt;\n\t\t}\n\n\t\tif(cnt) dp[i] = true;\n\t}\n\n\treturn dp[0];\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int w, n; cin >> w >> n && w;) {\n\t\tvector<int> x(n);\n\t\tfor(auto &e : x) cin >> e;\n\n\t\tvector<int> sum(n + 1);\n\t\tpartial_sum(begin(x), end(x), sum.begin() + 1);\n\n\t\tint L = 0, R = w;\n\t\twhile(L + 1 < R) {\n\t\t\tconst int M = (L + R) / 2;\n\t\t\tif(check(w, M, x, sum)) {\n\t\t\t\tR = M;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tL = M;\n\t\t\t}\n\t\t}\n\n\t\tcout << R << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint x[100000], dat[100000], n, W, dp[80000];\nvoid add(int p, int q) {\n\twhile (p <= n) {\n\t\tdat[p] += q;\n\t\tp += p&-p;\n\t}\n}\nint sum(int p) {\n\tint sum2 = 0;\n\twhile (p >= 1) {\n\t\tsum2 += dat[p];\n\t\tp -= p&-p;\n\t}\n\treturn sum2;\n}\nint Rangesum(int W1, int W2) {\n\treturn sum(W2) - sum(W1 - 1);\n}\nint hantei(int L1, int R1) {\n\tif (L1 == 0)return 2147000000;\n\tint E = Rangesum(L1, R1);\n\tE += (R1 - L1);\n\treturn E;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> W >> n; for (int i = 0; i < 100000; i++) { dat[i] = 0; dp[i] = 999999999; }\n\t\tif (n == 0 && W == 0)break;\n\t\tfor (int i = 1; i <= n; i++)cin >> x[i]; add(1, x[1]); dp[0] = 1;\n\t\tfor (int i = 2; i <= n - 1; i++) {\n\t\t\tadd(i, x[i]);\n\t\t\tint L = 1, R = i, M = 0;\n\t\t\twhile (true) {\n\t\t\t\tM = (L + R) / 2;\n\t\t\t\tint V1 = hantei(M, i);\n\t\t\t\tint V2 = hantei(M - 1, i);\n\t\t\t\tif (V1 <= W && V2 > W) {\n\t\t\t\t\tfor (int j = M; j < i; j++) {\n\t\t\t\t\t\tif (j != M && dp[j - 1] < dp[j])break;\n\t\t\t\t\t\tint KO = i - j;\n\t\t\t\t\t\tint V1 = hantei(j, i);\n\t\t\t\t\t\tdp[i] = min(dp[i], max(dp[j - 1], ((W - V1) + KO - 1) / KO + 1));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (V1 > W)L = M;\n\t\t\t\tif (V2 <= W)R = M;\n\t\t\t}\n\t\t}\n\t\tadd(n, x[n]); int minx = 999999999;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (Rangesum(i + 1, n) + (n - (i + 1)) <= W)minx = min(minx, dp[i]);\n\t\t}\n\t\tcout << minx << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXW = 80008;\nconst int MAXN = 50005;\n\nint W, N;\nint x[MAXN];\nbool dp[MAXN];\n\nbool test(int w) {\n  int a, b;\n  int sumA, numA, sumB, numB;\n  fill(dp, dp+MAXN, false);\n  dp[0] = true;\n  a = b = 0;\n  sumA = numA = sumB = numB = 0;\n  //cout << \"w=\" << w << endl;\n  for(int i = 0; i < N; ++i) {\n    for(; a < N && W-sumA > w*(numA-1); ++numA, sumA += x[a++]);\n    for(; b < N && W-sumB >= (numB-1); ++numB, sumB += x[b++]);\n    if(!(W-sumB >= numB)) {\n      sumB -= x[--b]; --numB;\n    }\n\n    if(dp[i]) {\n      for(int j = a; j <= b; ++j) {\n        dp[j] = true;\n      }\n    }\n\n    sumA -= x[i];\n    sumB -= x[i];\n    numA -= 1;\n    numB -= 1;\n  }\n  return dp[N];\n}\n\nint main() {\n  while(cin >> W >> N && (W|N)) {\n    for(int i = 0; i < N; ++i) cin >> x[i];\n    int l, r;\n    l = 1;\n    r = W+1;\n    while(r-l) {\n      int m = (l+r)/2;\n      if(test(m)) {\n        r = m;\n      } else {\n        l = m+1;\n      }\n    }\n    cout << l << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\ninline int f(int n, int i, int L, const vector<int>& sum_rev){\n    return (sum_rev[i - n] - sum_rev[i]) + L * (n - 1);\n}\n\nint main(){\n    int W, N;\n    while(cin >> W >> N && N){\n        vector<int> x(N);\n        REP(i, N) cin >> x[i];\n\n        vector<int> sum_rev(N + 1);\n        sum_rev[N] = 0;\n        for(int i = N - 1; i >= 0; i--){\n            sum_rev[i] = sum_rev[i + 1] + x[i];\n        }\n\n        int lb_L = 0, ub_L = W/2; // ub\n        while(ub_L - lb_L > 1){\n            int L = (lb_L + ub_L) / 2;\n            vector<int> dp(N, 0);\n            vector<int> sum_dp(N + 1, 0);\n            dp[0] = 1;\n            dp[1] = 0;\n            sum_dp[1] = 1;\n            sum_dp[2] = 1;\n\n            for(int i = 2; i < N; i++){\n                sum_dp[i] = sum_dp[i - 1] + dp[i - 1];\n\n                int lb = 1, ub = i; // ub \n                while(ub - lb > 1){\n                    int n = (ub + lb) / 2;\n                    if(f(n, i, L, sum_rev) >= W){\n                        ub = n;\n                    }else{\n                        lb = n;\n                    }\n                }\n                int begin_n = ub;\n\n                //printf(\"dp[%d] : begin %d \\n\", i, begin_n);\n                if(!(f(begin_n, i, L, sum_rev) >= W)){\n                    continue;\n                }\n\n                lb = 2, ub = i + 1; // lb\n                while(ub - lb > 1){\n                    int n = (ub + lb) / 2;\n                    if(f(n, i, 1, sum_rev) <= W){\n                        lb = n;\n                    }else{\n                        ub = n;\n                    }\n                }\n                int end_n = lb; \n\n                //printf(\"dp[%d] : end %d \\n\", i, end_n);\n                if(!(f(end_n, i, 1, sum_rev) <= W)) {\n                    continue;\n                }\n\n                int begin = i - end_n;\n                int end = i - begin_n;\n                // [begin, end]\n                if(sum_dp[end + 1] - sum_dp[begin] > 0){\n                    dp[i] = 1;\n                }\n                //printf(\"dp[%d] : [dp[%d], dp[%d]] (%d) -> %d\\n\", i, begin, end, sum_dp[end + 1] - sum_dp[begin], dp[i]);\n            }\n\n            bool ok = false;\n            for(int i = 0; i < N; i++) {\n                int n = N - i;\n                //printf(\"n - 1 + sum_rev[%d] = %d\\n\", i, n - 1 + sum_rev[i]);\n                if(dp[i] && (n - 1) + sum_rev[i] <= W){\n                    ok = true;\n                }\n            }\n            //printf(\"L %d  is %d\\n\", L, ok);\n\n            if(ok){\n                ub_L = L;\n            }else{\n                lb_L = L;\n            }\n        }\n\n        cout << ub_L << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_N 50000\n#define INF 100000000\n#define MOD 1000000007\n#define RANK 1000000000\n#define EPS 1e-10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> IP;\n\nint w, n;\nint bit[MAX_N+1];\nint x[MAX_N];\nint sum[MAX_N+1];\n\nint bsum(int i){\n\tint s = 0;\n\twhile(i > 0){\n\t\ts += bit[i];\n\t\ti -= i&-i;\n\t}\n\treturn s;\n}\n\nvoid add(int i){\n\twhile(i <= n){\n\t\tbit[i]++;\n\t\ti += i&-i;\n\t}\n}\n\nbool check(int le){\n    memset(bit,0,sizeof(bit));\n    \n    int prest = -1;\n    int s, e, mid;\n    int st, en;\n    int v, q;\n    \n    for(int i = 1; i < n; i++){\n        s = prest; e = i;\n        while(e-s > 1){\n            mid = (s+e)/2;\n            if(sum[i+1]-sum[mid]-1 > w){\n                s = mid;\n            } else{\n                e = mid;\n            }\n        }\n        st = e;\n        prest = st-1;\n        if(i == n-1){\n            en = i;\n        } else{\n            s = -1; e = i;\n            while(e-s > 1){\n                mid = (s+e)/2;\n                if((w+i-mid-sum[i+1]+sum[mid])/(i-mid)+1 > le){\n                    e = mid;\n                } else{\n                    s = mid;\n                }\n            }\n            en = s;\n        }\n        if(st > en) continue;\n        if(st == 0) q = 1;\n        else q = bsum(en)-bsum(st-1);\n        if(q){\n            add(i+1);\n            if(i == n-1) return true;\n        }\n    }\n    return false;\n}\n\nint solve(){\n    rep(i,n) scanf(\"%d\",x+i);\n    rep(i,n){\n        if(i == 0){\n            sum[i+1] = x[i]+1;\n        } else{\n            sum[i+1] = sum[i]+x[i]+1;\n        }\n    }\n    int ss = 0, ee = w, mid;\n    while(ee-ss > 1){\n        mid = (ss+ee)/2;\n        if(check(mid)){\n            ee = mid;\n        } else{\n            ss = mid;\n        }\n    }\n    printf(\"%d\\n\",ee);\n}\n\nint main(){\n    while(scanf(\"%d%d\",&w,&n)){\n        if(w == 0 && n == 0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_N 50000\n#define INF 100000000\n#define MOD 1000000007\n#define RANK 1000000000\n#define EPS 1e-10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> IP;\n\nint w, n;\nint bit[MAX_N+1];\nint x[MAX_N];\nint sum[MAX_N+1];\n\nint bsum(int i){\n\tint s = 0;\n\twhile(i > 0){\n\t\ts += bit[i];\n\t\ti -= i&-i;\n\t}\n\treturn s;\n}\n\nvoid add(int i, int x){\n\twhile(i <= n){\n\t\tbit[i] += x;\n\t\ti += i&-i;\n\t}\n}\n\nbool check(int le){\n    memset(bit,0,sizeof(bit));\n    \n    int prest = -1;\n    int s, e, mid;\n    int st, en;\n    int v, q;\n    \n    for(int i = 1; i < n; i++){\n        s = prest; e = i;\n        while(e-s > 1){\n            mid = (s+e)/2;\n            if(sum[i+1]-sum[mid]-1 > w){\n                s = mid;\n            } else{\n                e = mid;\n            }\n        }\n        st = e;\n        prest = st-1;\n        if(i == n-1){\n            en = i;\n        } else{\n            s = -1; e = i;\n            while(e-s > 1){\n                mid = (s+e)/2;\n                v = sum[i+1]-sum[mid]-1;\n                if((w+i-mid-sum[i+1]+sum[mid])/(i-mid)+1 > le){\n                    e = mid;\n                } else{\n                    s = mid;\n                }\n            }\n            en = s;\n        }\n        if(st > en) continue;\n        if(st == 0) q = 1;\n        else q = bsum(en)-bsum(st-1);\n        if(q != 0){\n            add(i+1,1);\n            if(i == n-1) return true;\n        }\n    }\n    return false;\n}\n\nint solve(){\n    rep(i,n) cin >> x[i];\n    rep(i,n){\n        if(i == 0){\n            sum[i+1] = x[i]+1;\n        } else{\n            sum[i+1] = sum[i]+x[i]+1;\n        }\n    }\n    int ss = 0, ee = w, mid;\n    while(ee-ss > 1){\n        mid = (ss+ee)/2;\n        if(check(mid)){\n            ee = mid;\n        } else{\n            ss = mid;\n        }\n    }\n    cout << ee << endl;\n}\n\nint main(){\n    while(cin >> w >> n){\n        if(w == 0 && n == 0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <array>\n#include <set>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <unordered_set>\n#include <unordered_map>\n#include <functional>\n#include <cassert>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_from(i, m, n) for (int i = (m); (i) < int(n); ++(i))\n#define repeat_reverse(i, n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i, m, n) for (int i = (n)-1; (i) >= int(m); --(i))\n#define whole(f, x, ...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\n#define unittest_name_helper(counter) unittest_ ## counter\n#define unittest_name(counter) unittest_name_helper(counter)\n#define unittest __attribute__((constructor)) void unittest_name(__COUNTER__) ()\nusing ll = long long;\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\ntemplate <class T> inline void setmin(T & a, T const & b) { a = min(a, b); }\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\nbool is_suffix(string const & a, string const & b) {\n    if (a.length() > b.length()) return false;\n    return b.compare(b.length() - a.length(), b.length(), a) == 0;\n}\nvoid setshort(string & a, string const & b) {\n    if (a.empty() or b.length() < a.length() or (a.length() == b.length() and b < a)) {\n        a = b;\n    }\n}\n\nconstexpr int inf = 1e9+7;\nint main() {\n    while (true) {\n        // input\n        int n; cin >> n;\n        if (n == 0) break;\n        vector<string> word(n); repeat (i, n) cin >> word[i];\n        // solve\n        vector<string> dp(1 << n);\n        function<void (string const &, int)> go = [&](string const & s, int used) {\n            setshort(dp[used], s);\n            repeat (i, n) if (not (used & (1 << i))) {\n                if (s.find(word[i]) != string::npos) {\n                    used |= 1 << i;\n                }\n            }\n            repeat (i, n) if (not (used & (1 << i))) {\n                repeat_from (sep, 1, word[i].length()) {\n                    if (is_suffix(word[i].substr(0, sep), s)) {\n                        go(s + word[i].substr(sep), used | (1 << i));\n                    }\n                }\n            }\n        };\n        repeat (i, n) {\n            go(word[i], 1 << i);\n        }\n        repeat (a, 1 << n) if (not dp[a].empty()) {\n            repeat (b, 1 << n) if (not dp[b].empty() and not (a & b)) {\n                setshort(dp[a | b], dp[a] + dp[b]);\n                setshort(dp[a | b], dp[b] + dp[a]);\n            }\n        }\n        // output\n        cout << dp[(1 << n) - 1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\n\nusing namespace std;\n\nint main(){\n  for(int W,N;cin>>W>>N,W|N;){\n    int x[52345];\n    for(int i=0;i<N;i++){\n      cin>>x[i];\n    }\n    int l=0,h=1e9;\n    while(h-l>1){\n      int m=(h+l)/2;\n      vector<pair<int,int> > v[52345];\n      bool p[52345]={};\n      v[0].emplace_back(0,1);\n      for(int i=0;i<N;i++){\n\tbool f=false;\n\tfor(auto e:v[i]){\n\t  p[i]|=e.first+x[i]<=W;\n\t  int nl=e.first+x[i]+1;\n\t  if(nl<W){\n\t    int nh=min(W,e.second+x[i]+m);\n\t    if(!v[i+1].empty()&&v[i+1].back().second>=nl){\n\t      v[i+1].back().second=nh;\n\t    }else{\n\t      v[i+1].emplace_back(nl,nh);\n\t    }\n\t  }\n\t  f|=e.first<=W-x[i]&&W-x[i]<e.second;\n\t}\n\tif(f){\n\t  v[i+1].insert(v[i+1].begin(),make_pair(0,1));\n\t}\n      }\n      (!p[N-1]?l:h)=m;\n    }\n    cout<<h<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\narray<int,(int)(1e5)> ok;\narray<int,(int)(1e5)> oksum;\n\nbool check(int w,int n,vector<ll> &sumx,ll sp,vector<int> &ubs){\n    fill(ok.begin(),ok.begin()+n+1,false);\n    fill(oksum.begin(),oksum.begin()+n+2,false);\n    ok[n]=true;\n    ok[n-1]=true;\n    oksum[n+1]=0;\n    oksum[n]=1;\n    oksum[n-1]=2;\n    for(int i=n-2;i>=0;i--){\n        //cerr<<\"1check\"<<i<<endl;\n        int j=ubs[i];\n        int lb=i+1; //[i,lb)de tarinai\n        int ub=j;\n        while(ub-lb>1){\n            int mid=((lb+ub)>>1);\n            ll mot=w-(sumx[mid]-sumx[i]);\n            ll chi=mid-i-1;\n            if((mot+chi-1)/chi>sp){\n                lb=mid;\n            }\n            else{\n                ub=mid;\n            }\n        }\n        //cerr<<\"2check\"<<i<<endl;\n        int b=ub;\n        //check [b,j)\n        if(j==n+1 || oksum[b]-oksum[j]>0){\n            ok[i]=true;\n        }\n        else{\n            ok[i]=false;\n        }   \n        //cerr<<\"#\"<<i<<\" \"<<b<<\" \"<<j<<\" \"<<ok[i]<<endl;\n        oksum[i]=oksum[i+1]+ok[i];\n    }\n    //cerr<<sp<<endl;\n    //string buf;\n    //cin>>buf;\n    \n    return ok[0];\n}\n\nint solve(int w,int n){\n    \n    vector<ll> x(n);\n    for(int i=0;i<n;i++) cin>>x[i];\n    vector<ll> sumx(n+1);\n    for(int i=0;i<n;i++){\n        sumx[i+1]=sumx[i]+x[i];\n    }\n    vector<int> ubs(n);\n    for(int i=n-2;i>=0;i--){\n        int lb=i;\n        int ub=n+1;\n        //cerr<<\"check\"<<i<<endl;\n        //[i,lb) is ok\n        //w-(sumx[lb]-sumx[i])>=lb-i-1\n        //w+i+1>=sumx[lb]-sumx[i]+lb\n        while(ub-lb>1){\n            int mid=(lb+ub)/2;\n            ll sux=sumx[mid]-sumx[i]+mid;\n        //cerr<<\"#\"<<mid<<\" \"<<sux<<\" \"<<w+i+1<<endl;\n            if(w+i+1>=sux){\n                lb=mid;\n            }\n            else{\n                ub=mid;\n            }\n        }\n        ubs[i]=ub;\n    }\n    int lb=0;   \n    int ub=w;\n    //cerr<<\"End summation\"<<endl;\n    while(ub-lb>1){\n        int mid=(lb+ub)/2;\n        if(!check(w,n,sumx,mid,ubs)){\n            lb=mid;\n        }\n        else{\n            ub=mid;\n        }\n    }\n    return ub;\n}\n\nint main(){\n    int w,n;\n    while(cin>>w>>n,w){\n        cout<<solve(w,n)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string.h>\nusing namespace std;\nint c[51000];\nchar segtree[131072];\nint sz;\ninline int query(int a){\n\ta+=sz;\n\twhile(a){\n\t\tif(segtree[a])return 1;\n\t\ta/=2;\n\t}\n\treturn 0;\n}\ninline void add(int a,int b,int c,int d,int e){\n\tif(d<a||b<c)return;\n\tif(c<=a&&b<=d){\n\t\tsegtree[e]++;\n\t\treturn;\n\t}\n\tadd(a,(a+b)/2,c,d,e*2);\n\tadd((a+b)/2+1,b,c,d,e*2+1);\n}\nint sum[51000];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tsz=1;\n\t\twhile(sz<b+1)sz*=2;\n\t\tfor(int i=0;i<b;i++)scanf(\"%d\",c+i);\n\t\tfor(int i=0;i<b;i++)sum[i+1]=sum[i]+c[i];\n\t\tint L=0;\n\t\tint R=a/2;\n\t\twhile(L+1<R){\n\t\t\tint M=(L+R)/2;\n\t\t\tmemset(segtree,0,sz*2);\n\t\t\t//for(int i=0;i<sz*2;i++)segtree[i]=0;\n\t\t\tadd(0,sz-1,0,0,1);\n\t\t\tfor(int i=0;i<b;i++){\n\t\t\t\tif(!query(i))continue;\n\t\t\t\tif(sum[b]-sum[i]+b-i-1<=a){\n\t\t\t\t\tadd(0,sz-1,b,b,1);break;\n\t\t\t\t}\n\t\t\t\tint l=i;\n\t\t\t\tint r=b;\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tint m=(l+r)/2;\n\t\t\t\t\tif(M*(m-i-1)>=a-(sum[m]-sum[i]))r=m;\n\t\t\t\t\telse l=m;\n\t\t\t\t}\n\t\t\t\tint v1=r;\n\t\t\t\tl=i-1;\n\t\t\t\tr=b;\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tint m=(l+r)/2;\n\t\t\t\t\tif(m-i-1>a-(sum[m]-sum[i]))r=m;\n\t\t\t\t\telse l=m;\n\t\t\t\t}\n\t\t\t\tint v2=l;\n\t\t\t\tif(v1<=v2)add(0,sz-1,v1,v2,1);\n\t\t\t}\n\t\t\tif(query(b))R=M;\n\t\t\telse L=M;\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nll w;\nint n;\nll x[50010];\nll s[50010];\nll s2[50010];\nint ok[50010];\nint oks[50010];\nint main()\n{\n    while(1){\n        cin>>w>>n;\n        if(w==0) return 0;\n        for(int i=0; i<n; i++){\n            cin>>x[i];\n        }\n        s[n]=0;\n        for(int i=n-1; i>=0; i--){\n            s[i]=s[i+1]+x[i]+1;\n        }\n        ll d1=0, d2=w-1;\n        while(d2-d1>1){\n            ll d=(d1+d2)/2;\n            fill(ok, ok+n, 0);\n            s2[n]=0;\n            for(int i=n-1; i>=0; i--){\n                if(s[i]<=w+1) ok[i]=1;\n                s2[i]=s2[i+1]+x[i]+d;\n            }\n            oks[n]=oks[n+1]=0;\n            for(int i=n-1; i>=0; i--){\n                if(ok[i]){\n                    oks[i]=oks[i+1]+1;\n                    continue;\n                }\n                int l=lower_bound(s2, s2+n+1, s2[i]-w-d, greater<ll>())-s2;\n                int r=lower_bound(s, s+n+1, s[i]-w-2, greater<ll>())-s;\n                if(oks[l]-oks[r]>0) ok[i]=1;\n                oks[i]=oks[i+1]+ok[i];\n            }\n            if(ok[0]) d2=d;\n            else d1=d;\n        }\n        cout<<d2<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nint f(int n, int i, int L, vector<int>& sum_rev){\n    int k = i - n;\n    int len = sum_rev[k] - sum_rev[i];\n    return len + L * (n - 1);\n}\nint main(){\n    int W, N;\n    while(cin >> W >> N && N){\n        vector<int> x(N);\n        REP(i, N) cin >> x[i];\n\n        vector<int> sum_rev(N + 1);\n        sum_rev[N] = 0;\n        for(int i = N - 1; i >= 0; i--){\n            sum_rev[i] = sum_rev[i + 1] + x[i];\n        }\n\n        int lb_L = 0, ub_L = W; // ub\n        while(ub_L - lb_L > 1){\n            int L = (lb_L + ub_L) / 2;\n            vector<int> dp(N, 0);\n            vector<int> sum_dp(N + 1, 0);\n            dp[0] = 1;\n            dp[1] = 0;\n            sum_dp[1] = 1;\n            sum_dp[2] = 1;\n\n            for(int i = 2; i < N; i++){\n                sum_dp[i] = sum_dp[i - 1] + dp[i - 1];\n\n                int lb = 1, ub = i; // ub \n                while(ub - lb > 1){\n                    int n = (ub + lb) / 2;\n                    if(f(n, i, L, sum_rev) >= W){\n                        ub = n;\n                    }else{\n                        lb = n;\n                    }\n                }\n                int begin_n = ub;\n\n                //printf(\"dp[%d] : begin %d \\n\", i, begin_n);\n                if(!(f(begin_n, i, L, sum_rev) >= W)){\n                    continue;\n                }\n\n                lb = 2, ub = i + 1; // lb\n                while(ub - lb > 1){\n                    int n = (ub + lb) / 2;\n                    if(f(n, i, 1, sum_rev) <= W){\n                        lb = n;\n                    }else{\n                        ub = n;\n                    }\n                }\n                int end_n = lb; \n\n                //printf(\"dp[%d] : end %d \\n\", i, end_n);\n                if(!(f(end_n, i, 1, sum_rev) <= W)) {\n                    continue;\n                }\n\n                int begin = i - end_n;\n                int end = i - begin_n;\n                // [begin, end]\n                if(sum_dp[end + 1] - sum_dp[begin] > 0){\n                    dp[i] = 1;\n                }else{\n                    dp[i] = 0;\n                }\n                //printf(\"dp[%d] : [dp[%d], dp[%d]] (%d) -> %d\\n\", i, begin, end, sum_dp[end + 1] - sum_dp[begin], dp[i]);\n            }\n\n            bool ok = false;\n            for(int i = 0; i < N; i++) {\n                int n = N - i;\n                //printf(\"n - 1 + sum_rev[%d] = %d\\n\", i, n - 1 + sum_rev[i]);\n                if(dp[i] && (n - 1) + sum_rev[i] <= W){\n                    ok = true;\n                }\n            }\n            //printf(\"L %d  is %d\\n\", L, ok);\n\n            if(ok){\n                ub_L = L;\n            }else{\n                lb_L = L;\n            }\n        }\n\n        cout << ub_L << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <stdio.h>\n\nusing namespace std;\n\n#define fo(i,n) for(int i=0; i<(int)n; i++)\n#define rep(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#define mp(a,b) make_pair(a,b)\n#define pb(x) push_back(x)\n#define pii pair<int,int>\n\nint w,n;\nint x[51000];\n\nint main() {\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n\twhile (scanf(\"%d%d\",&w,&n) && w!=0) {\n\t\tfor (int i=0; i<n; i++) scanf(\"%d\",x+i);\n\t\t\n\t\tint l = 0;\n\t\t\n\t\tint j = 0;\n\t\tint ans = 1000000;\n\t\tbool done = 0;\n\t\tfor (int s=1; s<=w; s++) {\n\t\t\tj = 0;\n\t\t\tl = 0;\n\t\t\twhile (true) {\n\t\t\t\tint sum = 0;\n\t\t\t\tint t = 0;\n\t\t\t\tif (j==n-1) break;\n\t\t\t\tsum = x[j++];\n\t\t\t\tt++;\n\t\t\t\twhile (j<n && sum+s+x[j]<=w) {\n\t\t\t\t\tj++;\n\t\t\t\t\tsum += x[j-1];\n\t\t\t\t\tif (t>0) sum+=s;\n\t\t\t\t\tt++;\n\t\t\t\t}\n\t\t\t\tif (j==n) {\n\t\t\t\t\tif (t>1) l = max(l,1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (t!=1) l = max(l, (w - (sum -s*(t-1)) - 1)/(t-1) + 1);\n\t\t\t\telse {\n\t\t\t\t\tl = max(l, w - sum);\n\t\t\t\t\tdone = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = min(ans,l);\n\t\t\tif (done) break;\n\t\t}\n\t\t\n\t\tcout<<ans<<endl;\n\t}\n\t\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\nstruct aa {\n\tint next;\n\tint sum;\n};\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<int>nums(M);\n\t\tvector<aa>as;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tas.push_back(aa{ -1,-1 });\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tcin >> nums[i];\n\t\t}\n\t\tint ans = -1;\n\t\tfor (int i = N - 2; i >= 1; --i) {\n\t\t\t\n\t\t\tbool ok = true;\n\t\t\tint now = 0;\n\t\t\twhile (now!=M) {\n\t\t\t\tint sum = 0;\n\t\t\t\tint start;\n\t\t\t\tif (as[now].next == -1) {\n\t\t\t\t\tstart = now;\n\t\t\t\t\tsum = nums[now];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstart = as[now].next;\n\t\t\t\t\tsum = as[now].sum + (as[now].next - now)*i;\n\t\t\t\t}\n\t\t\t\tint anow = start;\n\t\t\t\twhile (anow +1 != M) {\n\t\t\t\t\tsum += i + nums[anow + 1];\n\t\t\t\t\tif (sum == N) {\n\t\t\t\t\t\tas[now].next = anow+1;\n\t\t\t\t\t\tas[now].sum = sum - (anow - now+1)*i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (sum > N) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tas[now].next = anow;\n\t\t\t\t\t\tas[now].sum = sum - (i + nums[anow + 1]) - (anow - now)*i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tanow++;\n\t\t\t\t}\n\t\t\t\tif (anow + 1 == M) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (!ok) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnow = anow + 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tans = i;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nint w,n;\n\nbool ok1(vi& sm,int st,int cri)\n{\n    int diff = sm[st+cri]-sm[st]+cri-1;\n    return diff <= w;\n}\n\nbool ok2(vi& sm,int st,int cri,int d)\n{\n    int diff = sm[st+cri]-sm[st]+(cri-1)*d;\n    return w <= diff;\n}\n\nbool possible(vi& sm,int d)\n{\n    vi dp(n+5,0);\n    dp[0] += 1;\n    dp[1] += -1;\n    int nw = 0;\n    int last;\n    rep(i,n){\n        nw += dp[i];\n        if(nw){\n            last = i;\n            int lb,rb;\n            if(ok1(sm,i,n-i)){\n                lb = n;\n            }else{\n                int l = 2,r = n-i;\n                while(r-l>1){\n                    int mid = (l+r)/2;\n                    if(ok1(sm,i,mid)){\n                        l = mid;\n                    }else{\n                        r = mid;\n                    }\n                }\n                lb = i+l;\n            }\n            if(ok2(sm,i,2,d)){\n                rb = i+2;\n            }else{\n                int l = 2,r = n-i;\n                while(r-l>1){\n                    int mid = (l+r)/2;\n                    if(ok2(sm,i,mid,d)){\n                        r = mid;\n                    }else{\n                        l = mid;\n                    }\n                }\n                rb = i+r;\n            }\n            if(rb <= lb){\n                dp[rb] += 1;\n                dp[lb+1] -= 1;\n            }\n        }\n    }\n    if(nw+dp[n]){\n        return true;\n    }\n    if(sm[n]-sm[last]+(n-last-1) <= w){\n        return true;\n    }else{\n        return false;\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        cin >> w >> n;\n        if(w + n == 0){\n            break;\n        }\n        vi vec(n),sm(n+1);\n        rep(i,n){\n            cin >> vec[i];\n        }\n        sm[0] = 0;\n        rep(i,n){\n            sm[i+1] = sm[i] + vec[i];\n        }\n        // possible(sm,1);\n        int l = 0,r = w;\n        while(r-l>1){\n            int mid = (l+r)/2;\n            if(possible(sm,mid)){\n                r = mid;\n            }else{\n                l = mid;\n            }\n        }\n        cout << r << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<set>\n\nusing namespace std;\nconst int maxn = 5e4 + 10;\nint x[maxn], dp[maxn], s[maxn];\nint w, n;\nbool ok(int m){\n    memset(dp, 0, sizeof(dp));\n    dp[0] = 1;\n    int k = 0;\n    for(int i = 1; i <= n; i++) if(dp[i - 1]){\n        for(int j = k; j <= n; j++){\n            if(j <= i) continue;\n            int sp = w - (s[j] - s[i - 1]);\n            if(sp < (j - i)) break;\n            int d = sp / (j - i);\n            if(sp % (j - i)) d++;\n            if(d <= m){\n                dp[j] = 1; k = j;\n            }\n        }\n    }\n    return n == k || s[n] - s[k] + n - k - 1 <= w;\n}\nint main(){\n    //int w, n;\n    while(~scanf(\"%d%d\", &w, &n), w + n){\n        s[0] = 0;\n        for(int i = 1; i <= n; i++){\n            scanf(\"%d\", &x[i]);\n            s[i] = s[i - 1] + x[i];\n        }\n        int l = 1, r = w - 2, m;\n        while(r > l){\n            m = (l + r) / 2;\n            if(ok(m)) r = m;\n            else l = m + 1;\n        }\n\n        printf(\"%d\\n\", l);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\n\nstruct SegmentTree\n{\n  vector< int > seg;\n  int sz;\n\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (min(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  int rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, sz));\n  }\n\n  void update(int k, int x)\n  {\n    k += sz - 1;\n    seg[k] = x;\n    while(k > 0) {\n      k = (k - 1) >> 1;\n      seg[k] = min(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n};\n\nint main()\n{\n  int W, N, x[50001] = {};\n\n  while(scanf(\"%d %d\", &W, &N), W) {\n    for(int i = 1; i <= N; i++) {\n      scanf(\"%d\", x + i);\n      x[i] += x[i - 1];\n    }\n\n    auto getSpace = [&](int l, int r)\n    {\n      if(l + 1 >= r) {\n        cout << l << \" \" << r << endl;\n\n        puts(\"foo\");\n        return (114514);\n      }\n      if(x[r] - x[l] + r - l - 1 > W) return (INF);\n      return ((W + x[l] + r - x[r] - l - 2) / (r - l - 1));\n    };\n\n    int low = 1, high = W;\n    while(high - low > 0) {\n      int limit = (low + high) >> 1;\n\n      int left = 0, right = 0;\n      SegmentTree dp(N);\n      dp.update(0, limit);\n      for(int i = 2; i < N; i++) {\n        while(i - left >= 2 && getSpace(left, i) == INF) ++left;\n        while(i - right >= 2 && (getSpace(right, i) == INF || getSpace(right, i) <= limit))++right;\n        dp.update(i, dp.rmq(left, right));\n      }\n      int tail = N - 2;\n      bool flag = dp.rmq(N - 1, N) <= limit;\n      while(tail >= 0 && getSpace(tail, N) != INF) {\n        flag |= dp.rmq(tail, tail + 1) <= limit;\n        --tail;\n      }\n      if(flag)high = limit;\n      else low = limit + 1;\n    }\n    printf(\"%d\\n\", low);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXW = 80008;\nconst int MAXN = 50005;\n\nint W, N;\nint x[MAXN];\n\nbool test(int w) {\n  bool dp[MAXN];\n  int a, b;\n  int sumA, numA, sumB, numB;\n  fill(dp, dp+MAXN, false);\n  dp[0] = true;\n  a = b = 0;\n  sumA = numA = sumB = numB = 0;\n  //cout << \"w=\" << w << endl;\n  for(int i = 0; i < N; ++i) {\n    for(; a < N && W-sumA > w*(numA-1); ++numA, sumA += x[a++]);\n    for(; b < N && W-sumB >= (numB-1); ++numB, sumB += x[b++]);\n    if(!(W-sumB >= numB)) {\n      sumB -= x[--b]; --numB;\n    }\n    //cout << i << endl;\n    //cout << a << \", \" << sumA << \", \" << numA << endl;\n    //cout << b << \", \" << sumB << \", \" << numB << endl;\n    for(int j = a; j <= b; ++j) {\n      dp[j] |= dp[i];\n    }\n\n    sumA -= x[i];\n    sumB -= x[i];\n    numA -= 1;\n    numB -= 1;\n  }\n  return dp[N];\n}\n\nint main() {\n  while(cin >> W >> N && (W|N)) {\n    for(int i = 0; i < N; ++i) cin >> x[i];\n    int l, r;\n    l = 1;\n    r = W+1;\n    while(r-l) {\n      int m = (l+r)/2;\n      if(test(m)) {\n        r = m;\n      } else {\n        l = m+1;\n      }\n    }\n    cout << l << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint main()\n{\n  int W, N, x[50000] = {};\n  int dp[50000];\n\n  while(scanf(\"%d %d\", &W, &N), W) {\n    for(int i = 1; i <= N; i++) {\n      scanf(\"%d\", x + i);\n      x[i] += x[i - 1];\n    }\n\n    auto getSpace = [&](int l, int r)\n    {\n      if(x[r] - x[l] + r - l - 1 > W) return (INF);\n      return ((W + x[l] + r - x[r] - l - 2) / (r - l - 1));\n    };\n\n    fill_n(dp, N + 1, INF);\n    dp[0] = 0;\n    for(int i = 1; i < N; i++) {\n      for(int j = i - 2; j >= 0; j--) {\n        int vv = getSpace(j, i);\n        if(vv == INF) break;\n        if(dp[j] > dp[i]) break;\n        dp[i] = min(dp[i], max(dp[j], getSpace(j, i)));\n      }\n    }\n\n    int ret = dp[N - 1], tail = N - 2;\n    while(tail >= 0 && getSpace(tail, N) != INF) {\n      ret = min(ret, dp[tail]);\n      --tail;\n    }\n    printf(\"%d\\n\", max(1, ret));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string.h>\nusing namespace std;\nint c[51000];\nchar segtree[131072];\nint sz;\ninline int query(int a){\n\ta+=sz;\n\twhile(a){\n\t\tif(segtree[a])return 1;\n\t\ta/=2;\n\t}\n\treturn 0;\n}\nvoid add(int a,int b,int c,int d,int e){\n\tif(d<a||b<c)return;\n\tif(c<=a&&b<=d){\n\t\tsegtree[e]=1;\n\t\treturn;\n\t}\n\tadd(a,(a+b)/2,c,d,e*2);\n\tadd((a+b)/2+1,b,c,d,e*2+1);\n}\nint sum[51000];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tsz=1;\n\t\twhile(sz<b+1)sz*=2;\n\t\tfor(int i=0;i<b;i++)scanf(\"%d\",c+i);\n\t\tfor(int i=0;i<b;i++)sum[i+1]=sum[i]+c[i];\n\t\tint L=0;\n\t\tint R=a/2;\n\t\twhile(L+1<R){\n\t\t\tint M=(L+R)/2;\n\t\t\tmemset(segtree,0,sz*2);\n\t\t\t//for(int i=0;i<sz*2;i++)segtree[i]=0;\n\t\t\tadd(0,sz-1,0,0,1);\n\t\t\tfor(int i=0;i<b;i++){\n\t\t\t\tif(!query(i))continue;\n\t\t\t\tif(sum[b]-sum[i]+b-i-1<=a){\n\t\t\t\t\tadd(0,sz-1,b,b,1);break;\n\t\t\t\t}\n\t\t\t\tint l=i;\n\t\t\t\tint r=b;\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tint m=(l+r)/2;\n\t\t\t\t\tif(M*(m-i-1)>=a-(sum[m]-sum[i]))r=m;\n\t\t\t\t\telse l=m;\n\t\t\t\t}\n\t\t\t\tint v1=r;\n\t\t\t\tif(v1-i-1>a-(sum[v1]-sum[i]))continue;\n\t\t\t\tl=i-1;\n\t\t\t\tr=b;\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tint m=(l+r)/2;\n\t\t\t\t\tif(m-i-1>a-(sum[m]-sum[i]))r=m;\n\t\t\t\t\telse l=m;\n\t\t\t\t}\n\t\t\t\tint v2=l;\n\t\t\t\tif(v1<=v2)add(0,sz-1,v1,v2,1);\n\t\t\t}\n\t\t\tif(query(b))R=M;\n\t\t\telse L=M;\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nbool ok(int w,int n,const int* sum,int sp)\n{\n\t//int n=sum.size()-1;\n\t\n\t//vi dp(n+1); dp[0]=1;\n\tstatic int dp[50001];\n\tdp[0]=1;\n\t\n\tint l=0,r=0,cnt=0;\n\trep(i,n){\n\t\tfor(;l<i;cnt-=!!dp[l++]) if(sum[i+1]-sum[l]+(i-l)<=w) break;\n\t\tfor(;r<i;cnt+=!!dp[r++]) if(sum[i+1]-sum[r]+(i-r)*sp<w) break;\n\t\tdp[i+1]=!!cnt;\n\t}\n\t\n\tint res=dp[n];\n\tfor(int i=n;i--;){\n\t\tif(sum[n]-sum[i]+(n-i-1)>w) break;\n\t\tres|=dp[i];\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\tfor(int w,n;~scanf(\"%d%d\",&w,&n) && w|n;){\n\t\tvi xs(n);\n\t\trep(i,n) scanf(\"%d\",&xs[i]);\n\t\t\n\t\tvi sum(n+1);\n\t\trep(i,n) sum[i+1]=sum[i]+xs[i];\n\t\t\n\t\tint lo=1,hi=w;\n\t\twhile(lo<hi){\n\t\t\tint mi=(lo+hi)/2;\n\t\t\tif(ok(w,n,sum.data(),mi))\n\t\t\t\thi=mi;\n\t\t\telse\n\t\t\t\tlo=mi+1;\n\t\t}\n\t\tprintf(\"%d\\n\",lo);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(ll i=0;i<(n);++i)\n#define rep1(i,n) for(ll i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\ntypedef long long ll;\nll W,N,x[50000],sum[50001],rr[50002];\nbool can(ll x){\n\tbool dp[50001]={};\n\tint imos[50002]={};\n\tdp[0]=true;\n\timos[1]=1;\n\tfor(int i=2;i<=N;i++){\n\t\tll lb=1,ub=i+1;\n\t\twhile(ub-lb>1){\n\t\t\tll m=(ub+lb)/2;\n\t\t\tif(W-(sum[i]-sum[i-m])>=m-1) lb=m;\n\t\t\telse ub=m;\n\t\t}\n\t\tll r=rr[i];\n\t\tlb=1,ub=i+1;\n\t\twhile(ub-lb>1){\n\t\t\tll m=(lb+ub)/2;\n\t\t\tif(W-(sum[i]-sum[i-m])<=(m-1)*x) ub=m;\n\t\t\telse lb=m;\n\t\t}\n\t\tll l=ub;\n\t\tif(imos[i-l+1]-imos[i-r]>0) dp[i]=true;\n\t\timos[i+1]=imos[i]+(dp[i]?1:0);\n\t}\n\tfor(int i=N;i>=0;i--){\n\t\tif(sum[N]-sum[i]+(N-1-i)>W) break;\n\t\tif(dp[i]) return true;\n\t}\n\treturn false;\n}\nvoid calcrr(){\n\tfor(int i=2;i<=N;i++){\n\t\tll lb=1,ub=i+1;\n\t\twhile(ub-lb>1){\n\t\t\tll m=(ub+lb)/2;\n\t\t\tif(W-(sum[i]-sum[i-m])>=m-1) lb=m;\n\t\t\telse ub=m;\n\t\t}\n\t\trr[i]=lb;\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin>>W>>N;\n\t\tif(W==0) return 0;\n\t\trep(i,N) cin>>x[i];\n\t\trep1(i,N) sum[i]=sum[i-1]+x[i-1];\n\t\tll ub=W,lb=0;\n\t\tcalcrr();\n\t\twhile(ub-lb>1){\n\t\t\tll m=(ub+lb)/2;\n\t\t\tif(can(m)) ub=m;\n\t\t\telse lb=m;\n\t\t}\n\t\tcout<<ub<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll W, N;\nll x[50000];\nll xsum[50010];\nint dp[50010];\nint trueSum[50010];\n\n// [l, r]\nll minw(int l, int r){\n\tll sum = xsum[r + 1] - xsum[l] + (r - l);\n\tif(sum > W) return -1;\n\tll rem = W - (xsum[r + 1] - xsum[l]);\n\treturn (rem + (r - l - 1)) / (r - l);\n}\n\nbool check(int w){\n\tmemset(trueSum, 0, sizeof trueSum);\n\ttrueSum[1] = 1;\n\tmemset(dp, 0, sizeof dp);\n\tdp[0] = 1;\n\tint L = 0, R = 0;\n\tfor(int i = 1; i < N; i++){\n\t\t/*int L, R;\n\t\t{\n\t\t\tint ng = -1, ok = i - 1;\n\t\t\twhile(abs(ng - ok) > 1){\n\t\t\t\tint mid = (ng + ok) / 2;\n\t\t\t\tint mw = minw(mid, i);\n\t\t\t\tif(mw != -1) ok = mid;\n\t\t\t\telse ng = mid;\n\t\t\t}\n\t\t\tL = ok;\n\t\t\tif(minw(L, i) > w){\n\t\t\t\ttrueSum[i + 2] = trueSum[i + 1];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint ok = L, ng = i;\n\t\t\twhile(abs(ng - ok) > 1){\n\t\t\t\tint mid = (ng + ok) / 2;\n\t\t\t\tint mw = minw(mid, i);\n\t\t\t\tif(mw <= w) ok = mid;\n\t\t\t\telse ng = mid;\n\t\t\t}\n\t\t\tR = ok;\n\t\t}*/\n\t\twhile(L < i && minw(L, i) == -1) L++;\n\t\twhile(R + 1 < i && minw(R + 1, i) <= w) R++;\n\t\tint res1 = minw(L, i), res2 = minw(R, i);\n\t\tif(R < L || res1 == -1 || res1 > w || res2 == -1 || res2 > w){\n\t\t\ttrueSum[i + 2] = trueSum[i + 1];\n\t\t\tcontinue;\n\t\t}\n\t\t//assert(minw(L, i) <= w && minw(R, i) <= w);\n\t\tint s = trueSum[R + 1] - trueSum[L];\n\t\tif(s >= 1){\n\t\t\tdp[i + 1] = 1;\n\t\t\ttrueSum[i + 2] = trueSum[i + 1] + 1;\n\t\t\t// ???????????????????????????????????°ok\n\t\t\tll sum = xsum[N] - xsum[i + 1] + (N - i - 2);\n\t\t\tif(sum <= W) return true;\n\t\t}\n\t\telse{\n\t\t\ttrueSum[i + 2] = trueSum[i + 1];\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\twhile(cin >> W >> N, W + N){\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> x[i];\n\t\t\txsum[i + 1] = xsum[i] + x[i];\n\t\t}\n\n\t\tll sum = xsum[N] + N - 1;\n\t\tif(sum <= W){\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint ng = 0, ok = W;\n\t\twhile(abs(ng - ok) > 1){\n\t\t\tint mid = (ng + ok) / 2;\n\t\t\tif(check(mid)) ok = mid;\n\t\t\telse ng = mid;\n\t\t}\n\t\tcout << ok << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\nbool FLG;\nint N,W;\nint table[50005];\nbool check[50005];\n\nvoid recursive(int id,int loc,int limit,int pre_space_num){\n\n\tif(FLG)return;\n\tif(id == N){\n\t\tFLG = true;\n\t\treturn;\n\t}\n\n\tif(loc != 0 && pre_space_num < limit && loc+1+table[id]-1 <= W-1){\n\t\trecursive(id,loc+1,limit,pre_space_num+1);\n\t}\n\n\tif(loc != 0 && pre_space_num == 0)return;\n\n\tif(loc+table[id]-1 >= W)return;\n\n\tif(loc+table[id]-1 == W-1){ //ぴったり行が終了\n\t\tif(check[id])return; //検索済\n\t\tcheck[id] = true;\n\t\tif(!FLG){\n\t\t\trecursive(id+1,0,limit,0);\n\t\t}\n\t}else{\n\t\tif(!FLG){\n\t\t\trecursive(id+1,loc+table[id],limit,0);\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d\",&table[i]);\n\t}\n\n\tint left = 0,right = W,m = (left+right)/2;\n\tint ans = W;\n\n\twhile(left <= right){\n\t\tFLG = false;\n\t\tfor(int i = 0; i < N; i++)check[i] = false;\n\t\trecursive(0,0,m,0);\n\t\tif(FLG){\n\t\t\tans = m;\n\t\t\tright = m-1;\n\t\t}else{\n\t\t\tleft = m+1;\n\t\t}\n\t\tm = (left+right)/2;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&N);\n\t\tif(W == 0 && N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct RMQ{\n  int n;\n  vector<int> dat;\n  const int def=0;\n  RMQ(){}\n  RMQ(int n_){init(n_);}\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,def);\n  }\n  void update(int k,int a){\n    k+=n-1;\n    dat[k]=a;\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  int query(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l) return def;\n    if(a<=l&&r<=b) return dat[k];\n    int vl=query(a,b,k*2+1,l,(l+r)/2);\n    int vr=query(a,b,k*2+2,(l+r)/2,r);\n    return max(vl,vr);\n  }\n  int query(int a,int b){\n    return query(a,b,0,0,n);\n  }\n};\nint dp[114514];\nint sum[114514];\nint x[114514];\ntypedef pair<int,int> P;\nint mceil(int p,int q){\n  return (p+q-1)/q;\n}\nsigned main(){\n  int w,n;\n  while(cin>>w>>n,w||n){\n    for(int i=0;i<n;i++) cin>>x[i];\n    fill(dp,dp+114514,w);\n    priority_queue<P,vector<P>,greater<P> > q;\n    q.push(P(0,0));\n    dp[0]=0;\n    sum[0]=0;\n    for(int i=0;i<n;i++) sum[i+1]=sum[i]+x[i];\n    RMQ rmq(n+1);\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      int s=p.first,k=p.second;\n      if(dp[k]<s) continue;\n      if(k==n) break;\n      int y=max(k,rmq.query(0,k)),z=0;\n      for(int i=y;i<n;i++){\n\tint tmp=sum[i+1]-sum[k];\n\tif(i!=n-1&&i==k) continue;\n\tif(w<tmp+i-k) break;\n\tint res;\n\tif(i==n-1) res=max(s,1LL);\n\telse res=max(s,mceil(w-tmp,i-k));\n\t//cout<<i<<\":\"<<res<<endl;\n\tif(res<dp[i+1]&&res<dp[n]){\n\t  dp[i+1]=res;\n\t  q.push(P(dp[i+1],i+1));\n\t}\n\tz=i;\n      }\n      rmq.update(k,z);\n    }\n    //for(int i=0;i<n;i++) cout<<i<<\" \"<<dp[i]<<endl;\n    cout<<dp[n]<<endl;;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int w,n;cin>>w>>n && w|n;){\n\t\tvi xs(n);\n\t\trep(i,n) cin>>xs[i];\n\t\t\n\t\tvi dp(n+1,INF);\n\t\tdp[0]=1;\n\t\trep(i,n){\n\t\t\tint xsum=xs[i];\n\t\t\trepi(j,i+1,n){\n\t\t\t\txsum+=xs[j];\n\t\t\t\tif(xsum+(j-i)>w) break;\n\t\t\t\tint wsum=w-xsum;\n\t\t\t\tint wmax=(wsum+(j-i)-1)/(j-i);\n\t\t\t\tdp[j+1]=min(dp[j+1],max(dp[i],wmax));\n\t\t\t\tif(j==n) dp[j+1]=min(dp[j+1],dp[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res=dp[n],sum=0;\n\t\tper(i,n){\n\t\t\tsum+=xs[i];\n\t\t\tif(sum+(n-i-1)>w) break;\n\t\t\tres=min(res,dp[i]);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\ninline int f(int n, int i, int L, const vector<int>& sum_rev){\n    return (sum_rev[i - n] - sum_rev[i]) + L * (n - 1);\n}\n\nint dp[50010];\nint sum_dp[50010];\n\nint main(){\n    int W, N;\n    while(cin >> W >> N && N){\n        vector<int> x(N);\n        REP(i, N) cin >> x[i];\n\n        vector<int> sum_rev(N + 1);\n        sum_rev[N] = 0;\n        for(int i = N - 1; i >= 0; i--){\n            sum_rev[i] = sum_rev[i + 1] + x[i];\n        }\n\n        int lb_L = 0, ub_L = W; // ub\n        while(ub_L - lb_L > 1){\n            int L = (lb_L + ub_L) / 2;\n            memset(dp, 0, sizeof(dp));\n            memset(sum_dp, 0, sizeof(sum_dp));\n            dp[0] = 1;\n            dp[1] = 0;\n            sum_dp[1] = 1;\n            sum_dp[2] = 1;\n\n            for(int i = 2; i < N; i++){\n                sum_dp[i] = sum_dp[i - 1] + dp[i - 1];\n\n                int lb = 1, ub = i; // ub \n                while(ub - lb > 1){\n                    int n = (ub + lb) / 2;\n                    if(f(n, i, L, sum_rev) >= W){\n                        ub = n;\n                    }else{\n                        lb = n;\n                    }\n                }\n                int begin_n = ub;\n\n                //printf(\"dp[%d] : begin %d \\n\", i, begin_n);\n                if(f(begin_n, i, L, sum_rev) < W){\n                    continue;\n                }\n\n                lb = begin_n, ub = i + 1; // lb\n                while(ub - lb > 1){\n                    int n = (ub + lb) / 2;\n                    if(f(n, i, 1, sum_rev) <= W){\n                        lb = n;\n                    }else{\n                        ub = n;\n                    }\n                }\n                int end_n = lb; \n\n                //printf(\"dp[%d] : end %d \\n\", i, end_n);\n                if(f(end_n, i, 1, sum_rev) > W) {\n                    continue;\n                }\n\n                int begin = i - end_n;\n                int end = i - begin_n;\n                // [begin, end]\n                if(sum_dp[end + 1] - sum_dp[begin] > 0){\n                    dp[i] = 1;\n                }\n                //printf(\"dp[%d] : [dp[%d], dp[%d]] (%d) -> %d\\n\", i, begin, end, sum_dp[end + 1] - sum_dp[begin], dp[i]);\n            }\n\n            bool ok = false;\n            for(int n = 1; n <= N && (n - 1) + sum_rev[N - n] <= W; n++) {\n                //printf(\"n - 1 + sum_rev[%d] = %d\\n\", i, n - 1 + sum_rev[i]);\n                if(dp[N - n]){\n                    ok = true;\n                    break;\n                }\n            }\n            //printf(\"L %d  is %d\\n\", L, ok);\n\n            if(ok){\n                ub_L = L;\n            }else{\n                lb_L = L;\n            }\n        }\n\n        cout << ub_L << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll W, N;\nll x[50000];\nll xsum[50010];\nint dp[50010];\nint trueSum[50010];\n\n// [l, r]\nll minw(int l, int r){\n\tll sum = xsum[r + 1] - xsum[l] + (r - l);\n\tif(sum > W) return -1;\n\tll rem = W - (xsum[r + 1] - xsum[l]);\n\treturn (rem + (r - l - 1)) / (r - l);\n}\n\nbool check(int w){\n\tmemset(trueSum, 0, sizeof trueSum);\n\ttrueSum[1] = 1;\n\tmemset(dp, 0, sizeof dp);\n\tdp[0] = 1;\n\tint L = 0, R = 0;\n\tfor(int i = 1; i < N; i++){\n\t\t/*int L, R;\n\t\t{\n\t\t\tint ng = -1, ok = i - 1;\n\t\t\twhile(abs(ng - ok) > 1){\n\t\t\t\tint mid = (ng + ok) / 2;\n\t\t\t\tint mw = minw(mid, i);\n\t\t\t\tif(mw != -1) ok = mid;\n\t\t\t\telse ng = mid;\n\t\t\t}\n\t\t\tL = ok;\n\t\t\tif(minw(L, i) > w){\n\t\t\t\ttrueSum[i + 2] = trueSum[i + 1];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint ok = L, ng = i;\n\t\t\twhile(abs(ng - ok) > 1){\n\t\t\t\tint mid = (ng + ok) / 2;\n\t\t\t\tint mw = minw(mid, i);\n\t\t\t\tif(mw <= w) ok = mid;\n\t\t\t\telse ng = mid;\n\t\t\t}\n\t\t\tR = ok;\n\t\t}*/\n\t\twhile(L < i && minw(L, i) == -1) L++;\n\t\twhile(R + 1 < i && minw(R + 1, i) <= w) R++;\n\t\tif(R < L) continue;\n\t\tint res1 = minw(L, i), res2 = minw(R, i);\n\t\tif(res1 == -1 || res1 > w || res2 == -1 || res2 > w) continue;\n\t\t//assert(minw(L, i) <= w && minw(R, i) <= w);\n\t\tint s = trueSum[R + 1] - trueSum[L];\n\t\tif(s >= 1){\n\t\t\tdp[i + 1] = 1;\n\t\t\ttrueSum[i + 2] = trueSum[i + 1] + 1;\n\t\t\t// ???????????????????????????????????°ok\n\t\t\tll sum = xsum[N] - xsum[i + 1] + (N - i - 2);\n\t\t\tif(sum <= W) return true;\n\t\t}\n\t\telse{\n\t\t\ttrueSum[i + 2] = trueSum[i + 1];\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\twhile(cin >> W >> N, W + N){\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> x[i];\n\t\t\txsum[i + 1] = xsum[i] + x[i];\n\t\t}\n\n\t\tll sum = xsum[N] + N - 1;\n\t\tif(sum <= W){\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint ng = 0, ok = W;\n\t\twhile(abs(ng - ok) > 1){\n\t\t\tint mid = (ng + ok) / 2;\n\t\t\tif(check(mid)) ok = mid;\n\t\t\telse ng = mid;\n\t\t}\n\t\tcout << ok << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\nint N,W;\nint table[50005],ruisekiwa[50005];\nbool check[50005];\n\nbool one_line_check(int left,int right){ //left～rightの単語を一行に詰め込めるか\n\n\tif(ruisekiwa[right]-ruisekiwa[left-1]+(right-left) <= W){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nbool put_check(int left,int right,int limit){\n\n\tif(right == N)return true; //最終文字は、右端に詰めなくて良い\n\n\tif(ruisekiwa[right]-ruisekiwa[left-1]+limit*(right-left) >= W){\n\t\treturn true;\n\t}else{ //★★各幅を全てlimitにしても、一行の文字数に足りない→少なくとも一か所、limit+1以上のスペースを入れなければならない!!\n\t\treturn false;\n\t}\n}\n\n\nbool is_OK(int limit){\n\n\tif(one_line_check(1,N))return true;\n\n\tcheck[0] = true;\n\tbool FLG;\n\n\tfor(int right_id = 1; right_id <= N; right_id++){ //右端のループ\n\t\tFLG = false;\n\t\tfor(int left_id = 1; left_id <= right_id; left_id++){\n\t\t\tif(check[left_id-1] == true && one_line_check(left_id,right_id) == true && put_check(left_id,right_id,limit) == true){\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!put_check(left_id,right_id,limit))break; //文字数が足りない\n\t\t}\n\t\tcheck[right_id] = FLG;\n\t\tif(check[right_id]){\n\t\t\tif(one_line_check(right_id+1,N)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nvoid func(){\n\n\truisekiwa[0] = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\",&table[i]);\n\t\truisekiwa[i] = table[i];\n\t\truisekiwa[i] += ruisekiwa[i-1];\n\t}\n\n\tint left = 1,right = W,m = (left+right)/2;\n\tint ans = W;\n\n\twhile(left <= right){\n\t\tif(is_OK(m)){\n\t\t\tans = m;\n\t\t\tright = m-1;\n\t\t}else{\n\t\t\tleft = m+1;\n\t\t}\n\t\tm = (left+right)/2;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&N);\n\t\tif(W == 0 && N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = (1<<29);\nint W,N;\nvector<int> x;\nint dp[50005];\nint S[50005];\n\nint getn(int sm,int k){\n  if( k == 0 ){\n    if( sm != W ) return INF;\n    return 0;\n  }\n  return (W - sm + k - 1 )/k + 1;\n}\n\nint solve(){\n  memset( dp,0,sizeof( dp ) );\n  S[0] = 0;\n  for(int i=0;i<N;i++)\n    S[i+1] = S[i] + x[i];\n  dp[0] = 0;\n  int pc = 0;\n  for(int i=1;i<=N;i++){\n    int rt = INF;\n    pc = 0;\n    for(;pc<i;pc++){\n      int a = S[i] - S[pc] + i - pc - 1;\n      int b = dp[pc];\n      if( a > W ) continue;\n      if( i - pc - 1 == 0 ){\n        if( a == W ) rt = 0;\n        break;\n      }\n      a = getn( a, i - pc - 1 );\n      rt = min( rt, max( a, b ) );     \n      if( a >= b ) break;\n    }\n    dp[i] = rt;    \n    //  cout << i << \": \" << dp[i] << endl;\n  }\n\n  \n  int res = dp[N];\n  int sm = 0;\n  for(int i=N-1;i>0;i--){\n    sm += x[i];\n    if( sm > W ) break;\n    res = min( res, dp[i] );\n    sm++;\n  }\n  return max(1,res);\n}\n\nint main(){\n  while( cin >> W >> N && (W||N) ){\n    x = vector<int>(N);\n    int sm = 0;\n    bool f = false;\n    for(int i=0;i<N;i++){\n      cin >> x[i];\n      sm += x[i];\n      if( sm > W ) f = true;      \n      sm++;\n    }\n    if( f ) {\n      cout << solve() << endl;\n    } else {\n      cout << 1 << endl;\n    }\n     \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n\nbool check(int w,int n,vector<ll> &sumx,int sp){\n    vector<int> ok(n+1,false);\n    vector<int> oksum(n+2,0); //sum of ok[i,n+1)\n    ok[n]=true;\n    ok[n-1]=true;\n    oksum[n+1]=0;\n    oksum[n]=1;\n    oksum[n-1]=2;\n    for(int i=n-2;i>=0;i--){\n        int lb=i;\n        int ub=n+1;\n        //cerr<<\"check\"<<i<<endl;\n        //[i,lb) is ok\n        //w-(sumx[lb]-sumx[i])>=lb-i-1\n        //w+i+1>=sumx[lb]-sumx[i]+lb\n        while(ub-lb>1){\n            int mid=(lb+ub)/2;\n            ll sux=sumx[mid]-sumx[i]+mid;\n            //cerr<<\"#\"<<mid<<\" \"<<sux<<\" \"<<w+i+1<<endl;\n            if(w+i+1>=sux){\n                lb=mid;\n            }\n            else{\n                ub=mid;\n            }\n        }\n        //cerr<<\"1check\"<<i<<endl;\n        int j=ub;\n        lb=i+1; //[i,lb)de tarinai\n        ub=j;\n        while(ub-lb>1){\n            int mid=(lb+ub)/2;\n            ll mot=w-(sumx[mid]-sumx[i]);\n            ll chi=mid-i-1;\n            if(mot/chi+(int)(mot%chi!=0)>sp){\n                lb=mid;\n            }\n            else{\n                ub=mid;\n            }\n        }\n        //cerr<<\"2check\"<<i<<endl;\n        int b=ub;\n        //check [b,j)\n        if(j==n+1 || oksum[b]-oksum[j]>0){\n            ok[i]=true;\n        }\n        else{\n            ok[i]=false;\n        }   \n        //cerr<<\"#\"<<i<<\" \"<<b<<\" \"<<j<<\" \"<<ok[i]<<endl;\n        \n        oksum[i]=oksum[i+1]+ok[i];\n    }\n    //cerr<<sp<<endl;\n    //string buf;\n    //cin>>buf;\n    \n    return ok[0];\n}\n\nint solve(int w,int n){\n    vector<ll> x(n);\n    for(int i=0;i<n;i++) cin>>x[i];\n    vector<ll> sumx(n+1);\n    for(int i=0;i<n;i++){\n        sumx[i+1]=sumx[i]+x[i];\n    }\n    \n    int lb=0;   \n    int ub=w;\n    //cerr<<\"End summation\"<<endl;\n    while(ub-lb>1){\n        int mid=(lb+ub)/2;\n        if(!check(w,n,sumx,mid)){\n            lb=mid;\n        }\n        else{\n            ub=mid;\n        }\n    }\n    return ub;\n}\n\nint main(){\n    int w,n;\n    while(cin>>w>>n,w){\n        cout<<solve(w,n)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string.h>\nusing namespace std;\nint c[51000];\nint bit[51000];\nint getsum(int a,int b){\n\tif(a)return getsum(0,b)-getsum(0,a-1);\n\tint ret=0;\n\tfor(;b>=0;b=(b&(b+1))-1)ret+=bit[b];\n\treturn ret;\n}\nvoid add(int a,int b){\n\tfor(;a<51000;a|=a+1)bit[a]+=b;\n}\nint sum[51000];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<b;i++)scanf(\"%d\",c+i);\n\t\tfor(int i=0;i<b;i++)sum[i+1]=sum[i]+c[i];\n\t\tint L=0;\n\t\tint R=a/2;\n\t\twhile(L+1<R){\n\t\t\tint M=(L+R)/2;\n\t\t\tfor(int i=0;i<=b+1;i++)bit[i]=0;\n\t\t\tadd(0,1);\n\t\t\tadd(1,-1);\n\t\t\tfor(int i=0;i<b;i++){\n\t\t\t\tif(!getsum(0,i))continue;\n\t\t\t\tif(sum[b]-sum[i]+b-i-1<=a){\n\t\t\t\t\tadd(b,1);break;\n\t\t\t\t}\n\t\t\t\tint l=i;\n\t\t\t\tint r=b;\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tint m=(l+r)/2;\n\t\t\t\t\tif(M*(m-i-1)>=a-(sum[m]-sum[i]))r=m;\n\t\t\t\t\telse l=m;\n\t\t\t\t}\n\t\t\t\tint v1=r;\n\t\t\t\tif(v1-i-1>a-(sum[v1]-sum[i]))continue;\n\t\t\t\tl=i-1;\n\t\t\t\tr=b;\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tint m=(l+r)/2;\n\t\t\t\t\tif(m-i-1>a-(sum[m]-sum[i]))r=m;\n\t\t\t\t\telse l=m;\n\t\t\t\t}\n\t\t\t\tint v2=l;\n\t\t\t\tif(v1<=v2){\n\t\t\t\t\tadd(v1,1);\n\t\t\t\t\tadd(v2+1,-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(getsum(0,b))R=M;\n\t\t\telse L=M;\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_N 50000\n#define INF 100000000\n#define MOD 1000000007\n#define RANK 1000000000\n#define EPS 1e-10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> IP;\n\nint w, n;\nint bit[MAX_N+1];\nint x[MAX_N];\nint sum[MAX_N+1];\n\nint bsum(int i){\n\tint s = 0;\n\twhile(i > 0){\n\t\ts += bit[i];\n\t\ti -= i&-i;\n\t}\n\treturn s;\n}\n\nvoid add(int i){\n\twhile(i <= n){\n\t\tbit[i]++;\n\t\ti += i&-i;\n\t}\n}\n\nbool check(int le){\n    memset(bit,0,sizeof(bit));\n    \n    int prest = -1;\n    int s, e, mid;\n    int st, en;\n    int v, q;\n    \n    for(int i = 1; i < n; i++){\n        s = prest; e = i;\n        while(e-s > 1){\n            mid = (s+e)/2;\n            if(sum[i+1]-sum[mid]-1 > w){\n                s = mid;\n            } else{\n                e = mid;\n            }\n        }\n        st = e;\n        prest = st-1;\n        if(i == n-1){\n            en = i;\n        } else{\n            s = -1; e = i;\n            while(e-s > 1){\n                mid = (s+e)/2;\n                if(w-sum[i+1]+sum[mid]+1 > (le-1)*(i-mid)){\n                    e = mid;\n                } else{\n                    s = mid;\n                }\n            }\n            en = s;\n        }\n        if(st > en) continue;\n        if(st == 0) q = 1;\n        else q = bsum(en)-bsum(st-1);\n        if(q){\n            add(i+1);\n            if(i == n-1) return true;\n        }\n    }\n    return false;\n}\n\nint solve(){\n    rep(i,n) scanf(\"%d\",x+i);\n    rep(i,n){\n        if(i == 0){\n            sum[i+1] = x[i]+1;\n        } else{\n            sum[i+1] = sum[i]+x[i]+1;\n        }\n    }\n    int ss = 0, ee = w, mid;\n    while(ee-ss > 1){\n        mid = (ss+ee)/2;\n        if(check(mid)){\n            ee = mid;\n        } else{\n            ss = mid;\n        }\n    }\n    printf(\"%d\\n\",ee);\n}\n\nint main(){\n    while(scanf(\"%d%d\",&w,&n)){\n        if(w == 0 && n == 0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_N (1<<17)\n#define INF 100000000\n#define MOD 1000000007\n#define RANK 1000000000\n#define EPS 1e-10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> IP;\n\nstruct segtree{\n    int n, dat[2*MAX_N-1]; //(1<<17) = 130000\n\n    void init(int n_){\n        n = 1;\n        while(n < n_) n *= 2;\n        for(int i = 0; i < 2*n-1; i++) dat[i] = INF;\n    }\n\n    void update(int k, int a){\n        k += n-1;\n        dat[k] = a;\n        while(k > 0){\n            k = (k-1)/2;\n            dat[k] = min(dat[k*2+1], dat[k*2+2]);\n        }\n    }\n\n    //(a,b,0,0,seg.n)??§?????¶\n    int query(int a, int b, int k, int l, int r){\n        if(r <= a || b <= l) return INF;\n        if(a <= l && r <= b) return dat[k];\n        else{\n            int vl = query(a,b,k*2+1,l,(l+r)/2);\n            int vr = query(a,b,k*2+2,(l+r)/2,r);\n            return min(vl, vr);\n        }\n    }\n};\n\nint w, n;\nint x[50000];\nll sum[50001];\nsegtree seg;\n\nbool check(int le){\n    seg.init(n);\n    \n    for(int i = 1; i < n; i++){\n        int s = -1, e = i, mid;\n        int st, en;\n        ll v;\n        while(e-s > 1){\n            mid = (s+e)/2;\n            if(mid != 0) v = sum[i]-sum[mid-1]-1;\n            else v = sum[i]-1;\n            if(v > w){\n                s = mid;\n            } else{\n                e = mid;\n            }\n        }\n        st = e;\n        s = -1; e = i;\n        while(e-s > 1){\n            mid = (s+e)/2;\n            if(mid != 0) v = sum[i]-sum[mid-1]-1;\n            else v = sum[i]-1;\n            if((w-v+i-mid-1)/(i-mid)+1 > le){\n                e = mid;\n            } else{\n                s = mid;\n            }\n            //cout << v << \" \" << w-v+i-mid-1 << \" \" << mid << \" \" << s << \" \" << e << endl;\n        }\n        if(i == n-1){\n            en = i;\n        } else{\n            en = s;\n        }\n        if(st > en) continue;\n        int q;\n        if(st == 0) q = 0;\n        else q = seg.query(st-1,en,0,0,seg.n);\n        //cout << \" \" << i << \" \" << q << \" \" << st << \" \" << en << endl;\n        if(q != INF){\n            seg.update(i,0);\n            if(i == n-1) return true;\n        }\n    }\n    return false;\n}\n\nint solve(){\n    rep(i,n) cin >> x[i];\n    rep(i,n){\n        if(i == 0){\n            sum[i] = x[i]+1;\n        } else{\n            sum[i] = sum[i-1]+x[i]+1;\n        }\n    }\n    int ss = 0, ee = w, mid;\n    while(ee-ss > 1){\n        mid = (ss+ee)/2;\n        //cout << \"===\" << mid << endl;\n        if(check(mid)){\n            ee = mid;\n        } else{\n            ss = mid;\n        }\n    }\n    cout << ee << endl;\n}\n\nint main(){\n    while(cin >> w >> n){\n        if(w == 0 && n == 0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = (1<<29);\nint W,N;\nvector<int> x;\nint dp[50005];\nint S[50005];\n\nint getn(int sm,int k){\n  return (W - sm + k - 1 )/k + 1;\n}\n\nint solve(){\n  memset( dp,0,sizeof( dp ) );\n  S[0] = 0;\n  for(int i=0;i<N;i++)\n    S[i+1] = S[i] + x[i];\n  dp[0] = 0;\n  int pc = 0;\n  int k = 0;\n  for(int i=1;i<=N;i++){\n    int rt = INF;\n    pc = k;\n    for(;pc<i;pc++){\n      int a = S[i] - S[pc] + i - pc - 1;\n      int b = dp[pc];\n      if( a > W ) continue;\n      if( i - pc - 1 == 0 ){\n        if( a == W ) rt = 0;\n        break;\n      }\n      a = getn( a, i - pc - 1 );\n      if( rt > max(a,b) ) {\n        rt = max( a, b ); k = pc;\n      }\n      if( a >= b ) break;\n    }\n    dp[i] = rt;    \n    //  cout << i << \": \" << dp[i] << endl;\n  }\n\n  \n  int res = dp[N];\n  int sm = 0;\n  for(int i=N-1;i>0;i--){\n    sm += x[i];\n    if( sm > W ) break;\n    res = min( res, dp[i] );\n    sm++;\n  }\n  return max(1,res);\n}\n\nint main(){\n  while( cin >> W >> N && (W||N) ){\n    x = vector<int>(N);\n    int sm = 0;\n    bool f = false;\n    for(int i=0;i<N;i++){\n      cin >> x[i];\n      sm += x[i];\n      if( sm > W ) f = true;      \n      sm++;\n    }\n    if( f ) {\n      cout << solve() << endl;\n    } else {\n      cout << 1 << endl;\n    }\n     \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\nint main(){\n    int W, N;\n    while(cin >> W >> N && N){\n        vector<int> x(N);\n        REP(i, N) cin >> x[i];\n        int dp[50010] = {};\n        dp[0] = 1;\n        for(int i = 0; i < N; i++){\n            dp[i + 1] = INF;\n            int s = x[i];\n            for(int j = i - 1, b = 1; j >= 0; j--, b++){\n                s += x[j];\n                if(W - s < b) continue;\n                dp[i + 1] = min(dp[i + 1], max(dp[j], (W - s + b - 1) / b));\n            }\n            //cout << dp[i + 1] << \" \";\n        }\n        //cout << endl;\n        int ans = dp[N];\n        int s = 0;\n        for(int i = N - 1; i >= 0; i--){\n            s += x[i] + (i == N - 1 ? 0 : 1);\n            if(s > W) break;\n            ans = min(ans, dp[i]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint w, n;\nint x[50000];\n\nint dp[50001];\n\nint dfs(int begin, int space)\n{\n\tif (~dp[begin]) return dp[begin];\n\tif (begin >= n - 1) return dp[begin] = true;\n\tint sum = x[begin];\n\tfor (int i = begin + 1; i < n; i++){\n\t\tsum += x[i];\n\t\tint l = sum + (i - begin);\n\t\tint r = sum + (i - begin) * space;\n\t\tif (l > w) break;\n\t\tif (i == n - 1) return true;\n\t\tif (r < w) continue;\n\t\tif (dfs(i + 1, space)) return dp[begin] = true;\n\t}\n\treturn dp[begin] = false;\n}\n\nint solve()\n{\n\tint left = 0, right = w;\n\twhile (left + 1 < right){\n\t\tint mid = (left + right) / 2;\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tif (dfs(0, mid)) right = mid;\n\t\telse left = mid;\n\t}\n\treturn right;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &w, &n), w){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tscanf(\"%d\", x + i);\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define TIMES(i, n) for(int i = 0; i < (n); ++i)\n\ntemplate<class Pred>\nint binsearch(const Pred &pred) {\n    int val = 0;\n    for(int bit = 20; bit >= 0; --bit) {\n        const int next = val + (1<<bit);\n        val = pred(next) ? next : val;\n    }\n    return val;\n}\n\nbool solve() {\n    int W, N;\n    cin >> W >> N;\n    if(!W && !N) return false;\n\n    vector<int> sum(N+2, 0);\n    TIMES(i, N) {\n        cin >> sum[i+1];\n        sum[i+1] += sum[i];\n    }\n    sum[N+1] = sum[N];\n\n    vector<int> dp(N+3, 0);\n    int ans = binsearch([&](int x) {\n        if(x > W) return false;\n        fill(dp.begin(), dp.end(), 0);\n        dp[N+2] = 0;\n        dp[N+1] = 1;\n        dp[N] = 2;\n        for(int i = N-1; i > 0; --i) {\n            bool valid = false;\n            const int mink = binsearch([&](int k) {\n                if(i+k > N+1) return false;\n                const int sp = W - (sum[i+k] - sum[i-1]);\n                if(sp < k) return false;\n                const int ns = (sp + k-1) / k;\n                valid = valid || (ns <= x);\n                return ns > x;\n            }) + 1;\n            const int maxk = binsearch([&](int k) {\n                if(i+k > N+1) return false;\n                const int sp = W - (sum[i+k] - sum[i-1]);\n                if(sp < k) return false;\n                return true;\n            });\n            //cout << x << ' ' << i << ' ' << mink << ' ' << maxk << endl;\n            if(mink <= maxk && i+maxk <= N) dp[i] = valid && (dp[i+mink] - dp[i+maxk+2]) > 0;\n            {\n                const int sp = W - (sum[N] - sum[i-1]);\n                if(sp >= N-i) dp[i] = 1;\n            }\n            //cout << dp[i] << endl;\n            dp[i] += dp[i+1];\n        }\n        return dp[1] - dp[2] == 0;\n    }) + 1;\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  int w,n;\n  while(cin>>w>>n,w||n){\n    int x[n];\n    for(int i=0;i<n;i++) cin>>x[i];\n    int s[n+1];\n    s[0]=0;\n    for(int i=0;i<n;i++) s[i+1]=s[i]+x[i];\n    int dp[n+1];\n    memset(dp,-1,sizeof(dp));\n    dp[0]=0;\n    for(int i=0;i<n;i++){\n      if(dp[i]<0) continue;\n      for(int j=i+1;j<n;j++){\n\tint z=w-(s[j+1]-s[i])-(j-i),p=max(dp[i],z/(j-i)+1);\n\tif(z<0) break;\n\tif(dp[j+1]<0||dp[j+1]>p) dp[j+1]=p;\n\tif(j+1==n) {\n\t  int q=max(dp[i],1);\n\t  //cout<<i<<\":\"<<dp[i]<<\" \"<<dp[n]<<endl;\n\t  if(dp[n]<0||dp[n]>q) dp[n]=q;\n\t}\n      }\n    }\n    //for(int i=0;i<=n;i++) cout<<i<<\":\"<<dp[i]<<endl;\n    int ans=dp[n]<0?1<<25:dp[n];\n    for(int i=n-1;i>=0;i--){\n      if(dp[i]<0) continue;\n      int z=w-(s[n]-s[i])-(n-1-i);\n      if(z<0) break;\n      ans=min(ans,dp[i]);\n    }\n    cout<<(ans?ans:1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint W, N, x[50009], dp[50009];\nbool solve(int m) {\n\tint pl = 0, pr = 0;\n\tdp[1] = dp[2] = 1;\n\tfor (int j = 2; j <= N; j++) {\n\t\twhile (x[j] - x[pl] > W - (j - pl - 1)) pl++;\n\t\twhile (j != pr + 1 && x[j] - x[pr] > W - (j - pr - 1) * m) pr++;\n\t\tdp[j + 1] = dp[j] + (dp[pr] > dp[pl] ? 1 : 0);\n\t}\n\tfor (int j = 0; j <= N; j++) {\n\t\tif (dp[j] != dp[j + 1] && x[N] - x[j] + N - j - 1 <= W) return true;\n\t}\n\treturn false;\n}\nint main() {\n\twhile (scanf(\"%d %d\", &W, &N), W) {\n\t\tfor (int i = 0; i < N; i++) scanf(\"%d\", &x[i + 1]), x[i + 1] += x[i];\n\t\tint l = 1, r = W + 1;\n\t\twhile (r - l > 1) {\n\t\t\tint m = (l + r) >> 1;\n\t\t\tif (solve(m)) r = m;\n\t\t\telse l = m;\n\t\t}\n\t\twhile (!solve(l)) l++;\n\t\tprintf(\"%d\\n\", l);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include<cstring>\nusing namespace std;\nint n,w, len[51111],psum[51111];\nstruct SegTree{\n\tint n, seg[401111];\n\tvoid init(int _n){\n\t\tn=_n;\n\t\tfill(seg,seg+8*n,0);\n\t}\n\tvoid set(int i, int x){\n\t\t// printf(\"[%d] = %d\\n\",i,x);\n\t\tset(i,x,0,n,0);\n\t}\n\tint qmax(int l, int r){\n\t\t// printf(\"%d - %d:  %d\\n\",l,r,qmax(l,r,0,n,0));\n\t\treturn qmax(l,r,0,n,0);\n\t}\n\tvoid set(int i, int x, int sl, int sr, int sid){\n\t\tif(sr<=i || i<sl)return;\n\t\tif(sr-sl<=1){\n\t\t\tseg[sid]=x; return;\n\t\t}\n\t\tset(i, x, sl, (sl+sr)/2, sid*2+1);\n\t\tset(i, x, (sl+sr)/2, sr, sid*2+2);\n\t\tseg[sid] = max(seg[sid*2+1], seg[sid*2+2]);\n\t}\n\tint qmax(int l, int r, int sl, int sr, int sid){\n\t\tif(sr<=l || r<=sl)return 0;\n\t\tif(l<=sl && sr<=r)return seg[sid];\n\t\treturn max(qmax(l, r, sl, (sl+sr)/2, sid*2+1), qmax(l, r, (sl+sr)/2, sr, sid*2+2));\n\t}\n}st;\nint ceiling(int x, int y){\n\tif(y==0){\n\t\tprintf(\"QQ %d %d\\n\",x,y);\n\t\twhile(1);\n\t}\n\treturn (x-1)/y+1;\n}\nbool check(int d){\n\t// printf(\"\\t\\t\\td = %d\\n\",d);\n\tstatic int dp[51111];\n\t// memset(dp,0,sizeof(dp));\n\tfill(dp,dp+n,0);\n\tst.init(n);\n\n\tfor(int i=1; i<n; i++){\n\t\t// printf(\" i= %d\\n\",i);\n\t\tint lb=-1, ub=i-1, b, a;\n\t\twhile(1<ub-lb){\n\t\t\tint md=(lb+ub)/2;\n\t\t\tif(ceiling(w-psum[i+1]+psum[md+1], i-md-1)<=d)\n\t\t\t\tlb=md;\n\t\t\telse\n\t\t\t\tub=md;\n\t\t}\n\t\tb=lb;\n\t\tlb=-1, ub=i;\n\t\twhile(1<ub-lb){\n\t\t\tint md=(lb+ub)/2;\n\t\t\tif(psum[i+1]-psum[md+1]+i-md-1<=w)\n\t\t\t\tub=md;\n\t\t\telse\n\t\t\t\tlb=md;\n\t\t}\n\t\ta= ub;\n\t\t// printf(\"%d - %d\\n\",a,b);\n\t\tif(psum[i+1]+i<=w && ceiling(w-psum[i+1], i)<=d)dp[i]=1;\n\t\t// printf(\"%d<=%d && %d/%d<=%d\\n\", psum[i+1]+i,w, w-psum[i+1], i, d);\n\t\tif(a<=b)\n\t\t\tdp[i] = st.qmax(a,b+1);\n\t\tst.set(i,dp[i]);\n\t\t// printf(\"dp(%d) = %d\\n\",i,dp[i]);\n\t}\n\tint res=0;\n\tfor(int i=0; i<n-1; i++){\n\t\tif(psum[n]-psum[i+1]+n-i-1<=w)\n\t\t\tres = max(res, dp[i]);\n\t}\n\n\treturn res || dp[n-1] || psum[n]+n-1<=w;\n\n}\nint main(){\n\twhile(scanf(\"%d%d\",&w,&n)&&(n+w>0)){\n\t\tfor(int i=0; i<n; i++)scanf(\"%d\",&len[i]);\n\t\tpsum[0]=0;\n\t\tfor(int i=0; i<n; i++)psum[i+1] = psum[i]+len[i];\n\t\tint lb=0, ub=w;\n\t\twhile(1<ub-lb){\n\t\t\tint md=(lb+ub)/2;\n\t\t\tif(check(md))\n\t\t\t\tub=md;\n\t\t\telse\n\t\t\t\tlb=md;\n\t\t}\n\t\tprintf(\"%d\\n\",ub);\n\t}\n}\n\n/*\n\n11 4\n4 2 1 3\n5 7\n1 1 1 2 2 1 2\n11 7\n3 1 3 1 3 3 4\n100 3\n30 30 39\n30 3\n2 5 3\n0 0\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e18;\nconst long double PI = acos(-1.0L);\n//const ll mod = 1000000007;\nll W, N;\nll x[60000];\nll xsum[2][60000];\nll imos[60000];\nbool f(int border) {\n    //cerr << \"---------\" << border << \"------\" << endl;\n    for(int i = 0; i < 60000; i++) {\n        imos[i] = 0;\n    }\n    xsum[0][0] = 0;\n    xsum[1][0] = 0;\n    for(int i = 0; i < N; i++) {\n        xsum[0][i+1] = xsum[0][i] + x[i] + 1;\n        xsum[1][i+1] = xsum[1][i] + x[i] + border;\n    }\n    imos[0] = 1;\n    imos[1] = -1;\n    ll now = 0;\n    for(int idx = 0; idx < N; idx++) {\n        now += imos[idx];\n        if(now == 0) continue;\n        //cerr << \"-\" << idx << \"-\" << endl;\n        if(xsum[0][N] - xsum[0][idx] <= W + 1) return true;\n        int ok = N + 1;\n        int ng = idx;\n        while(abs(ok - ng) > 1) {\n            int mid = (ok + ng) / 2;\n            if(xsum[1][mid] - xsum[1][idx] >= W + border) ok = mid;\n            else ng = mid;\n        }\n        imos[ok]++;\n        ng = idx;\n        ok = N + 1;\n        while(abs(ok - ng) > 1) {\n            int mid = (ok + ng) / 2;\n            if(xsum[0][mid] - xsum[0][idx] > W + 1) ok = mid;\n            else ng = mid;\n        }\n        imos[ok]--;\n    }\n    return false;\n}\n\n\nvoid solve() {\n    for(int i = 0; i < N; i++) {\n        cin >> x[i];\n    }\n    int ok = W;\n    int ng = 0;\n    while(abs(ok - ng) > 1) {\n        int mid = (ok + ng) / 2;\n        if(f(mid)) {\n            ok = mid;\n        } else ng = mid;\n    }\n    cout << ok << endl;\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> W >> N) {\n        if(W == 0) break;\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_N 50000\n#define INF 100000000\n#define MOD 1000000007\n#define RANK 1000000000\n#define EPS 1e-10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> IP;\n\nint w, n;\nint bit[MAX_N+1];\nint x[MAX_N];\nll sum[MAX_N+1];\n\nint bsum(int i){\n\tint s = 0;\n\twhile(i > 0){\n\t\ts += bit[i];\n\t\ti -= i&-i;\n\t}\n\treturn s;\n}\n\nvoid add(int i, int x){\n\twhile(i <= n){\n\t\tbit[i] += x;\n\t\ti += i&-i;\n\t}\n}\n\nbool check(int le){\n    memset(bit,0,sizeof(bit));\n    \n    for(int i = 1; i < n; i++){\n        int s = -1, e = i, mid;\n        int st, en;\n        ll v;\n        while(e-s > 1){\n            mid = (s+e)/2;\n            if(mid != 0) v = sum[i]-sum[mid-1]-1;\n            else v = sum[i]-1;\n            if(v > w){\n                s = mid;\n            } else{\n                e = mid;\n            }\n        }\n        st = e;\n        s = -1; e = i;\n        while(e-s > 1){\n            mid = (s+e)/2;\n            if(mid != 0) v = sum[i]-sum[mid-1]-1;\n            else v = sum[i]-1;\n            if((w-v+i-mid-1)/(i-mid)+1 > le){\n                e = mid;\n            } else{\n                s = mid;\n            }\n            //cout << v << \" \" << w-v+i-mid-1 << \" \" << mid << \" \" << s << \" \" << e << endl;\n        }\n        if(i == n-1){\n            en = i;\n        } else{\n            en = s;\n        }\n        if(st > en) continue;\n        int q;\n        if(st == 0) q = 1;\n        else q = bsum(en)-bsum(st-1);\n        //cout << \" \" << i << \" \" << q << \" \" << st << \" \" << en << endl;\n        if(q != 0){\n            add(i+1,1);\n            if(i == n-1) return true;\n        }\n    }\n    return false;\n}\n\nint solve(){\n    rep(i,n) cin >> x[i];\n    rep(i,n){\n        if(i == 0){\n            sum[i] = x[i]+1;\n        } else{\n            sum[i] = sum[i-1]+x[i]+1;\n        }\n    }\n    int ss = 0, ee = w, mid;\n    while(ee-ss > 1){\n        mid = (ss+ee)/2;\n        //cout << \"===\" << mid << endl;\n        if(check(mid)){\n            ee = mid;\n        } else{\n            ss = mid;\n        }\n    }\n    cout << ee << endl;\n}\n\nint main(){\n    while(cin >> w >> n){\n        if(w == 0 && n == 0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ninline bool ok(int w,const vi& sum,int sp)\n{\n\tint n=sum.size()-1;\n\t\n\tvi dp(n+1); dp[0]=1;\n\tint l=0,r=0,cnt=0;\n\trep(i,n){\n\t\tfor(;l<i;cnt-=!!dp[l++]) if(sum[i+1]-sum[l]+(i-l)<=w) break;\n\t\tfor(;r<i;cnt+=!!dp[r++]) if(sum[i+1]-sum[r]+(i-r)*sp<w) break;\n\t\tdp[i+1]=!!cnt;\n\t}\n\t\n\tint res=dp[n];\n\tfor(int i=n;i--;){\n\t\tif(sum[n]-sum[i]+(n-i-1)>w) break;\n\t\tres|=dp[i];\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int w,n;~scanf(\"%d%d\",&w,&n) && w|n;){\n\t\tvi xs(n);\n\t\trep(i,n) scanf(\"%d\",&xs[i]);\n\t\t\n\t\tvi sum(n+1);\n\t\trep(i,n) sum[i+1]=sum[i]+xs[i];\n\t\t\n\t\tint lo=1,hi=w;\n\t\twhile(lo<hi){\n\t\t\tint mi=(lo+hi)/2;\n\t\t\tif(ok(w,sum,mi))\n\t\t\t\thi=mi;\n\t\t\telse\n\t\t\t\tlo=mi+1;\n\t\t}\n\t\tprintf(\"%d\\n\",lo);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstdlib>\nusing namespace std;\nconst int N = 50000+10;\nint w,n;\nint x[N];\nint s[N];\nstruct BIT{\n    int c[N];\n    int lowbit(int x) {\n        return x & -x;\n    }\n    void init() {\n        memset(c,0,sizeof(c));\n    }\n    void add(int x,int v) {\n        for (int i = x; i < N; i += lowbit(i)){\n            c[i] += v;\n        }\n    }\n    int sum(int x) {\n        int ret = 0;\n        for (int i =x; i > 0; i -= lowbit(i)) {\n            ret += c[i];\n        }\n        return ret;\n    }\n}H;\nvoid init() {\n    s[0] = 0;\n    for (int i = 1; i <= n; i++) s[i] = s[i-1] + x[i];\n}\nint findl(int id,int up) {\n    int l = 0,r = id;\n    int ret = r;\n    while (r >= l) {\n        int m = (l + r) >> 1;\n        if (s[id] - s[m] + (id - m - 1) * up >= w && s[id] - s[m] + id - m -1<= w) {\n            ret = m;\n            r = m-1;\n        }else l = m+1;\n    }\n    return ret;\n}\nint findr(int id,int up) {\n    int l = 0, r = id;\n    int ret = 0;\n    while (r >= l) {\n        int m = (l + r) >> 1;\n        if (s[id] - s[m] + (id - m - 1) * up >= w && s[id] - s[m] + id - m - 1 <= w) {\n            ret = m;\n            l = m+1;\n        }else {\n            r = m-1;\n        }\n    }\n    return ret;\n}\nint dp[N],c[N];\nint find(int id,int up) {\n    int l = findl(id,up);\n    int r = findr(id,up);\n    if (r < l) return 0;\n    int t;\n    if (l == 0) t = 0;\n    else t = c[l-1];\n    int s = c[r] - t;\n    if (s > 0) return 1;\n}\n\nint check(int up) {\n    memset(c,0,sizeof(c));\n    memset(dp,0,sizeof(dp));\n    dp[0] = 1;\n    c[0] = 1;c[1] = 1;\n    int fg = n+1;\n    for (int i = 2; i <= n; i++) {\n        if (s[i] - s[0] + i-1 <= w && s[i] - s[0] + (i-1) * up >= w){\n            dp[i] = 1;\n            c[i] = c[i-1] + 1;\n            fg = i;\n            break;\n        }else {\n            dp[i] = 0;\n            c[i] = c[i-1];\n        }\n    }\n    for (int i = fg + 1; i <= n; i++) {\n        if (find(i,up)) {\n            dp[i] = 1;\n            c[i] = c[i-1] + 1;\n        }else c[i] = c[i-1];\n    }\n    for (int i = n; i >= 0; i--) {\n        if (dp[i]) {\n            if (s[n] - s[i] + n - i - 1 <= w) return 1;\n            break;\n        }\n    }\n    return 0;\n}\nvoid solve(){\n    init();\n    int l = 1, r = w;\n    int ret = 1;\n    while (r >= l) {\n        int m = (l + r) >> 1;\n        if (check(m)) {\n            ret = m;\n            r = m - 1;\n        }else l = m + 1;\n    }\n    printf(\"%d\\n\",ret);\n}\nint main(){\n    while (~scanf(\"%d%d\",&w,&n),w+n) {\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\",x+i);\n        }\n        solve();\n    }\n}\n/*\n100 3\n30 30 39\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nusing namespace std;\nusing ll = long long;\n\nstruct Sum {\n    using T = int;\n    T operator()(const T& a, const T& b) const\n    {\n        return a + b;\n    }\n    T inv(const T& a) const\n    {\n        return -a;\n    }\n    static constexpr T identity()\n    {\n        return 0;\n    }\n};\n\ntemplate <typename Base>\nclass BinaryIndexedTree\n{\npublic:\n    using T = typename Base::T;\n    using AbelGroup = Base;\n\n    BinaryIndexedTree(const int n) : data_num(n), size(1 << (__lg(2 * data_num - 1))), value(size + 1, AbelGroup::identity()) { assert(n > 0); }\n    BinaryIndexedTree(const vector<T>& val) : data_num(val.size()), size(1 << (__lg(2 * data_num - 1))), value(size + 1, AbelGroup::identity())\n    {\n        for (int i = 1; i <= data_num; i++) {\n            value[i] = val[i - 1];\n        }\n        for (int x = 1; x < size; x++) {\n            value[x + (x & -x)] = op(value[x + (x & -x)], value[x]);\n        }\n    }\n\n    T accumulate(const int a) const\n    {\n        assert(0 <= a and a < data_num);\n        int ind = a + 1;\n        T sum = AbelGroup::identity();\n        while (ind > 0) {\n            sum = op(sum, value[ind]);\n            ind &= ind - 1;\n        }\n        return sum;\n    }\n    T accumulate(const int l, const int r) const  // [l,r)\n    {\n        assert(0 <= l and l < r and r <= data_num);\n        return op(accumulate(r - 1), op.inv(l == 0 ? AbelGroup::identity() : accumulate(l - 1)));\n    }\n\n    void add(const int a, const T& val)\n    {\n        assert(0 <= a and a < data_num);\n        int ind = a + 1;\n        while (ind <= size) {\n            value[ind] = op(value[ind], val);\n            ind += ind & (-ind);\n        }\n    }\n\n    T get(const int a) const\n    {\n        assert(0 <= a and a < data_num);\n        return accumulate(a, a + 1);\n    }\n\nprivate:\n    const int data_num;\n    const int size;\n    const AbelGroup op{};\n    vector<T> value;\n};\n\nint main()\n{\n    while (true) {\n        int W, N;\n        cin >> W >> N;\n        if (W == 0 and N == 0) {\n            break;\n        }\n        W++;\n        auto getsum = [](const vector<ll>& accum, const int inf, const int sup) {\n            return accum[sup] - accum[inf];\n        };\n        vector<ll> S(N + 1, 0);\n        for (int i = 1; i <= N; i++) {\n            cin >> S[i];\n            S[i]++;\n        }\n        for (int i = 1; i <= N; i++) {\n            S[i] += S[i - 1];\n        }\n        int inf = -1;\n        int sup = W;\n        while (sup - inf > 1) {\n            const int L = (sup + inf) / 2;\n            vector<ll> T(N + 1, 0);\n            for (int i = 1; i <= N; i++) {\n                T[i] = S[i] + L * i;\n            }\n            BinaryIndexedTree<Sum> dp(N + 1);\n            dp.add(N, 1);\n            for (int i = N - 1; i >= 0; i--) {\n                if (getsum(S, i, N) <= W) {\n                    dp.add(i, 1);\n                } else {\n                    const ll sobj = W + getsum(S, 0, i);\n                    const ll tobj = W + L + getsum(T, 0, i);\n                    const int lower = max((int)(lower_bound(T.begin(), T.end(), tobj) - T.begin()), i + 2);\n                    const int upper = upper_bound(S.begin(), S.end(), sobj) - S.begin();\n                    if (lower < upper and dp.accumulate(lower, upper) > 0) {\n                        dp.add(i, 1);\n                    }\n                }\n            }\n            if (dp.get(0)) {\n                sup = L;\n            } else {\n                inf = L;\n            }\n        }\n        cout << sup + 1 << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <vector>\n#define INF 999999999\nusing namespace std;\n\n\nint lxd=0;\n\nstruct S{\nint len,id;\n\nbool operator<(const S &p) const\n{\n    lxd++;\n\n    if(lxd>1000) return id<p.id;\n\n    if(len==p.len) return id<p.id;\n\n    return len>p.len;\n}\n\n}t;\n\nint num[50005],vis[50005];\n\nint main()\n{\n    int n,m,i,j,cnt,sum,temp;\n\n    while(~scanf(\"%d%d\",&n,&m) && n+m)\n    {\n        lxd=0;\n        \n        for(i=0;i<m;i++) scanf(\"%d\",&num[i]);\n\n        for(i=0;i<=m;i++) vis[i]=INF;\n\n        priority_queue<S>que;\n\n        cnt=sum=0;\n\n        for(i=0;i<m;i++)\n        {\n            sum+=num[i];\n            cnt++;\n\n            if(cnt>=2)\n            {\n                if(n-sum>=cnt-1)\n                {\n                    if(i<m-1)\n                    {\n                        t.len=(n-sum)/(cnt-1);\n\n                        if((n-sum)%t.len) t.len++;\n\n                        t.id=cnt;\n\n                        if(t.len<vis[t.id])\n                        {\n                            que.push(t);\n\n                            vis[t.id]=t.len;\n                        }\n                    }\n                    else\n                    {\n                        t.len=1;\n\n                        t.id=m;\n\n                        if(t.len<vis[t.id])\n                        {\n                            que.push(t);\n\n                            vis[t.id]=t.len;\n                        }\n                    }\n\n                }\n                else break;\n            }\n            else if(i==m-1)\n            {\n                t.len=1;\n\n                t.id=m;\n\n                if(t.len<vis[t.id])\n                {\n                    que.push(t);\n\n                    vis[t.id]=t.len;\n                }\n            }\n        }\n\n        while(!que.empty())\n        {\n            t=que.top();\n\n            if(t.id==m)\n            {\n                printf(\"%d\\n\",t.len);\n\n                break;\n            }\n\n            que.pop();\n\n            cnt=sum=0;\n\n            int olen=t.len;\n            int oid=t.id;\n\n            for(i=t.id;i<m;i++)\n            {\n                sum+=num[i];\n                cnt++;\n\n                if(cnt>=2)\n                {\n                    if(n-sum>=cnt-1)\n                    {\n                        if(i<m-1)\n                        {\n                            temp=(n-sum)/(cnt-1);\n\n                            if((n-sum)%temp) temp++;\n\n                            t.len=max(temp,olen);\n                            t.id=oid+cnt;\n\n                            if(t.len<vis[t.id])\n                            {\n                                que.push(t);\n\n                                vis[t.id]=t.len;\n                            }\n                        }\n                        else\n                        {\n                            t.len=max(1,olen);\n                            t.id=oid+cnt;\n\n                            if(t.len<vis[t.id])\n                            {\n                                que.push(t);\n\n                                vis[t.id]=t.len;\n                            }\n                        }\n                    }\n                }\n                else if(i==m-1)\n                {\n                    t.len=max(1,olen);\n                    t.id=oid+cnt;\n\n                    if(t.len<vis[t.id])\n                    {\n                        que.push(t);\n\n                        vis[t.id]=t.len;\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_N 50000\n#define INF 100000000\n#define MOD 1000000007\n#define RANK 1000000000\n#define EPS 1e-10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> IP;\n\nint w, n;\nint bit[MAX_N+1];\nint x[MAX_N];\nint sum[MAX_N+1];\n\nint bsum(int i){\n\tint s = 0;\n\twhile(i > 0){\n\t\ts += bit[i];\n\t\ti -= i&-i;\n\t}\n\treturn s;\n}\n\nvoid add(int i, int x){\n\twhile(i <= n){\n\t\tbit[i] += x;\n\t\ti += i&-i;\n\t}\n}\n\nbool check(int le){\n    memset(bit,0,sizeof(bit));\n    \n    int prest = -1;\n    int s, e, mid;\n    int st, en;\n    int v;\n    \n    for(int i = 1; i < n; i++){\n        s = prest; e = i;\n        while(e-s > 1){\n            mid = (s+e)/2;\n            v = sum[i+1]-sum[mid]-1;\n            if(v > w){\n                s = mid;\n            } else{\n                e = mid;\n            }\n        }\n        st = e;\n        prest = st-1;\n        if(i == n-1){\n            en = i;\n        } else{\n            s = -1; e = i;\n            while(e-s > 1){\n                mid = (s+e)/2;\n                v = sum[i+1]-sum[mid]-1;\n                if((w-v+i-mid-1)/(i-mid)+1 > le){\n                    e = mid;\n                } else{\n                    s = mid;\n                }\n            }\n            en = s;\n        }\n        if(st > en) continue;\n        int q;\n        if(st == 0) q = 1;\n        else q = bsum(en)-bsum(st-1);\n        if(q != 0){\n            add(i+1,1);\n            if(i == n-1) return true;\n        }\n    }\n    return false;\n}\n\nint solve(){\n    rep(i,n) cin >> x[i];\n    rep(i,n){\n        if(i == 0){\n            sum[i+1] = x[i]+1;\n        } else{\n            sum[i+1] = sum[i]+x[i]+1;\n        }\n    }\n    int ss = 0, ee = w, mid;\n    while(ee-ss > 1){\n        mid = (ss+ee)/2;\n        if(check(mid)){\n            ee = mid;\n        } else{\n            ss = mid;\n        }\n    }\n    cout << ee << endl;\n}\n\nint main(){\n    while(cin >> w >> n){\n        if(w == 0 && n == 0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint w,n;\nvi a;\n\nbool f(int x){\n\tvi L(n),R(n);\n\tint li=1,ri=1,ls=a[0],rs=a[0];\n\tfor(int i=0;i<n;i++){\n\t\tls-=(i?a[i-1]+x:0);\n\t\twhile(li<n&&ls<w){\n\t\t\tls+=x+a[li];\n\t\t\tli++;\n\t\t}\n\t\trs-=(i?a[i-1]+1:0);\n\t\twhile(ri<n&&rs<=w){\n\t\t\trs+=1+a[ri];\n\t\t\tri++;\n\t\t}\n\t\tif(rs<=w&&ri==n){\n\t\t\tri++;\n\t\t}\n\t\tL[i]=li;\n\t\tR[i]=ri;\n\t}\n\tvi used(n+1);\n\tused[0]=1;\n\tqueue<int> q;\n\tq.push(0);\n\twhile(!q.empty()){\n\t\tint p=q.front();\n\t\tq.pop();\n\t\tif(R[p]==n+1) return 1;\n\t\tfor(int i=L[p];i<R[p];i++) if(!used[i]){\n\t\t\tused[i]=1;\n\t\t\tq.push(i);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>w>>n;\n\t\tif(!w) break;\n\t\ta=vi(n);\n\t\tfor(int i=0;i<n;i++) cin>>a[i];\n\t\tint l=0,r=w;\n\t\twhile(r-l>1){\n\t\t\tint m=(l+r)/2;\n\t\t\tif(f(m)) r=m;\n\t\t\telse l=m;\n\t\t}\n\t\tcout<<r<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define llint long long\n\nusing namespace std;\n\nllint W, N;\nllint x[50005];\nllint sumx[50005];\nbool dp[50005];\nvector<llint> vec;\n\nbool check(llint m)\n{\n\tvec.clear();\n\tvec.push_back(0);\n\tfor(int i = 1; i <= N; i++) dp[i] = false;\n\tdp[0] = true;\n\t\n\tfor(int i = 1; i < N; i++){\n\t\tllint ub = i, lb = 0, mid;\n\t\twhile(ub - lb > 1){\n\t\t\tmid = (ub + lb) / 2;\n\t\t\tif(sumx[i]-sumx[mid-1]+(i-mid) <= W) ub = mid;\n\t\t\telse lb = mid;\n\t\t}\n\t\tauto p = lower_bound(vec.begin(), vec.end(), lb);\n\t\tif(p == vec.end()) continue;\n\t\tif(*p <= i-2){\n\t\t\tllint cost = (W - (sumx[i]-sumx[*p]) + (i-*p-2)) / (i-*p-1);\n\t\t\tif(cost <= m){\n\t\t\t\tdp[i] = true;\n\t\t\t\tvec.push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tllint ub = N, lb = 0, mid;\n\t\twhile(ub - lb > 1){\n\t\t\tmid = (ub + lb) / 2;\n\t\t\tif(sumx[N]-sumx[mid-1]+(N-mid) <= W) ub = mid;\n\t\t\telse lb = mid;\n\t\t}\n\t\tauto p = lower_bound(vec.begin(), vec.end(), lb);\n\t\tif(p != vec.end() && *p < N){\n\t\t\tdp[N] = true;\n\t\t\tvec.push_back(N);\n\t\t}\n\t}\n\t\n\treturn dp[N];\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> W >> N;\n\t\tif(W == 0 && N == 0) break;\n\t\tfor(int i = 1; i <= N; i++) cin >> x[i];\n\t\tfor(int i = 1; i <= N; i++) sumx[i] = sumx[i-1] + x[i];\n\t\t\n\t\tllint ub = W, lb = 0, mid;\n\t\twhile(ub - lb > 1){\n\t\t\tmid = (ub + lb) / 2;\n\t\t\tif(check(mid)) ub = mid;\n\t\t\telse lb = mid;\n\t\t}\n\t\tcout << ub << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_N 50000\n#define INF 100000000\n#define MOD 1000000007\n#define RANK 1000000000\n#define EPS 1e-10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> IP;\n\nint w, n;\nint bit[MAX_N+1];\nint x[MAX_N];\nint sum[MAX_N+1];\n\nint bsum(int i){\n\tint s = 0;\n\twhile(i > 0){\n\t\ts += bit[i];\n\t\ti -= i&-i;\n\t}\n\treturn s;\n}\n\nvoid add(int i, int x){\n\twhile(i <= n){\n\t\tbit[i] += x;\n\t\ti += i&-i;\n\t}\n}\n\nbool check(int le){\n    memset(bit,0,sizeof(bit));\n    \n    int prest = -1;\n    int s, e, mid;\n    int st, en;\n    int v;\n    \n    for(int i = 1; i < n; i++){\n        s = prest; e = i;\n        while(e-s > 1){\n            mid = (s+e)/2;\n            if(mid != 0) v = sum[i]-sum[mid-1]-1;\n            else v = sum[i]-1;\n            if(v > w){\n                s = mid;\n            } else{\n                e = mid;\n            }\n        }\n        st = e;\n        prest = st-1;\n        if(i == n-1){\n            en = i;\n        } else{\n            s = -1; e = i;\n            while(e-s > 1){\n                mid = (s+e)/2;\n                if(mid != 0) v = sum[i]-sum[mid-1]-1;\n                else v = sum[i]-1;\n                if((w-v+i-mid-1)/(i-mid)+1 > le){\n                    e = mid;\n                } else{\n                    s = mid;\n                }\n            }\n            en = s;\n        }\n        if(st > en) continue;\n        int q;\n        if(st == 0) q = 1;\n        else q = bsum(en)-bsum(st-1);\n        if(q != 0){\n            add(i+1,1);\n            if(i == n-1) return true;\n        }\n    }\n    return false;\n}\n\nint solve(){\n    rep(i,n) cin >> x[i];\n    rep(i,n){\n        if(i == 0){\n            sum[i] = x[i]+1;\n        } else{\n            sum[i] = sum[i-1]+x[i]+1;\n        }\n    }\n    int ss = 0, ee = w, mid;\n    while(ee-ss > 1){\n        mid = (ss+ee)/2;\n        if(check(mid)){\n            ee = mid;\n        } else{\n            ss = mid;\n        }\n    }\n    cout << ee << endl;\n}\n\nint main(){\n    while(cin >> w >> n){\n        if(w == 0 && n == 0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#define maxn 600000\nusing namespace std;\nint w,n;\nlong long x[maxn],sum[maxn];\nint Left[maxn],Right[maxn];\nint ok[maxn];\ninline bool check(int mid){\n       int cnt = 0;\n       ok[cnt++] = 0;\n       Right[1] = 0;\n      // cout<<\"mid=\"<<mid<<endl;\n       for(int i = 2;i<=n;++i){\n               Right[i] = max(0, Right[i-1]);\n        //       cout<<i<<\" \"<<Right[i]<<\" \"<<sum[i]-sum[Right[i]]<<\" \"<<(long long)w<<endl;\n               while((Right[i]<i)&&(sum[i]-sum[Right[i]]+(long long)(i-Right[i]-1)*mid>=(long long)w)){ ++Right[i];}\n               --Right[i];\n               if(Left[i]<=Right[i]){\n                    int pos = lower_bound(ok,ok+cnt,Left[i])-ok;\n                    if((pos<cnt)&&ok[pos]<=Right[i]){\n                         ok[cnt++] = i;\n                    }\n               }\n       }\n   //    for(int i = 1;i<=n;++i)\n     //          cout<<Right[i]<<\" \";\n       //cout<<endl;\n       if(sum[n]-sum[ok[cnt-1]]+n-ok[cnt-1]-1<=w)return true;\n       return false;\n}\nint main()\n{\n    while((cin>>w>>n)&&(w||n)){\n        for(int i = 1;i<=n;++i)\n                cin>>x[i];\n        sum[0] = 0LL;\n        for(int i = 1;i<=n;++i)\n                sum[i] = sum[i-1]+x[i];\n        Left[1] = 0;\n        for(int i = 2;i<=n;++i){\n                Left[i] = Left[i-1];\n                while((Left[i]<i)&&(sum[i]-sum[Left[i]]+(long long)(i-Left[i]-1)>(long long)w))++Left[i];\n        }\n    //    for(int i = 1;i<=n;++i)\n      //          cout<<Left[i]<<\" \";\n      //  cout<<endl;\n        int l = 1,r = w;\n        while(l<r){\n             int mid = (l+r)/2;\n             if(check(mid))r = mid;\n             else l = mid+1;\n           //  break;\n        }\n        cout<<r<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint x[100000], dat[100000], n, W, dp[80000];\nvoid add(int p, int q) {\n\twhile (p <= n) {\n\t\tdat[p] += q;\n\t\tp += p&-p;\n\t}\n}\nint sum(int p) {\n\tint sum2 = 0;\n\twhile (p >= 1) {\n\t\tsum2 += dat[p];\n\t\tp -= p&-p;\n\t}\n\treturn sum2;\n}\nint Rangesum(int W1, int W2) {\n\treturn sum(W2) - sum(W1 - 1);\n}\nint hantei(int L1, int R1) {\n\tif (L1 == 0)return 2147000000;\n\tint E = Rangesum(L1, R1);\n\tE += (R1 - L1);\n\treturn E;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> W >> n; for (int i = 0; i < 100000; i++) { dat[i] = 0; dp[i] = 999999999; }\n\t\tif (n == 0 && W == 0)break;\n\t\tfor (int i = 1; i <= n; i++)cin >> x[i]; add(1, x[1]); dp[0] = 1;\n\t\tfor (int i = 2; i <= n - 1; i++) {\n\t\t\tadd(i, x[i]);\n\t\t\tint L = 1, R = i, M = 0;\n\t\t\twhile (true) {\n\t\t\t\tM = (L + R) / 2;\n\t\t\t\tint V1 = hantei(M, i);\n\t\t\t\tint V2 = hantei(M - 1, i);\n\t\t\t\tif (V1 <= W && V2 > W) {\n\t\t\t\t\tint KO = i - M;\n\t\t\t\t\tdp[i] = max(dp[M - 1], ((W - V1) + KO - 1) / KO + 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (V1 > W)L = M;\n\t\t\t\tif (V2 <= W)R = M;\n\t\t\t}\n\t\t}\n\t\tadd(n, x[n]); int minx = 999999999;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (Rangesum(i + 1, n) + (n - (i + 1)) <= W)minx = min(minx, dp[i]);\n\t\t}\n\t\tcout << minx << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstdlib>\nusing namespace std;\ntypedef long long LL;\nconst int N = 50000+10;\nint w,n;\nint x[N];\nLL s[N];\nvoid init() {\n    s[0] = 0;\n    for (int i = 1; i <= n; i++) s[i] = s[i-1] + x[i];\n}\nint findl(int id,int up) {\n    int l = 0,r = id;\n    int ret = r;\n    while (r >= l) {\n        int m = (l + r) >> 1;\n        if (s[id] - s[m] + (LL)(id - m - 1) * up >= w && s[id] - s[m] + id - m -1<= w) {\n            ret = m;\n            r = m-1;\n        }else l = m+1;\n    }\n    return ret;\n}\nint findr(int id,int up) {\n    int l = 0, r = id;\n    int ret = 0;\n    while (r >= l) {\n        int m = (l + r) >> 1;\n        if (s[id] - s[m] + (LL)(id - m - 1) * up >= w && s[id] - s[m] + id - m - 1 <= w) {\n            ret = m;\n            l = m+1;\n        }else {\n            r = m-1;\n        }\n    }\n    return ret;\n}\nint dp[N],c[N];\nint find(int id,int up) {\n    int l = findl(id,up);\n    int r = findr(id,up);\n    if (r < l) return 0;\n    int t;\n    if (l == 0) t = 0;\n    else t = c[l-1];\n    int s = c[r] - t;\n    if (s > 0) return 1;\n}\n\nint check(int up) {\n    memset(c,0,sizeof(c));\n    memset(dp,0,sizeof(dp));\n    dp[0] = 1;\n    c[0] = 1;c[1] = 1;\n    int fg = n+1;\n    for (int i = 2; i <= n; i++) {\n        if (s[i] - s[0] + i-1 <= w && s[i] - s[0] + (LL)(i-1) * up >= w){\n            dp[i] = 1;\n            c[i] = c[i-1] + 1;\n            fg = i;\n            break;\n        }else {\n            dp[i] = 0;\n            c[i] = c[i-1];\n        }\n    }\n    for (int i = fg + 1; i <= n; i++) {\n        if (find(i,up)) {\n            dp[i] = 1;\n            c[i] = c[i-1] + 1;\n        }else c[i] = c[i-1];\n    }\n    for (int i = n; i >= 0; i--) {\n        if (dp[i]) {\n            if (s[n] - s[i] + n - i - 1 <= w) return 1;\n            break;\n        }\n    }\n    return 0;\n}\nvoid solve(){\n    init();\n    int l = 0, r = w;\n    int ret = 1;\n    while (r >= l) {\n        int m = (l + r) >> 1;\n        if (check(m)) {\n            ret = m;\n            r = m - 1;\n        }else l = m + 1;\n    }\n    printf(\"%d\\n\",ret);\n}\nint main(){\n    while (~scanf(\"%d%d\",&w,&n),w+n) {\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\",x+i);\n        }\n        solve();\n    }\n}\n/*\n100 3\n30 30 39\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = (1<<29);\nint W,N;\nvector<int> x;\nint dp[50005];\nint S[50005];\n\nint getn(int sm,int k){\n  if( k == 0 ){\n    if( sm != W ) return INF;\n    return 0;\n  }\n  return (W - sm + k - 1 )/k + 1;\n}\n\nint solve(){\n  memset( dp,0,sizeof( dp ) );\n  S[0] = 0;\n  for(int i=0;i<N;i++)\n    S[i+1] = S[i] + x[i];\n  dp[0] = 0;\n  int pc = 0;\n  for(int i=1;i<=N;i++){\n    int rt = INF;\n    for(;pc<i;pc++){\n      int a = S[i] - S[pc] + i - pc - 1;\n      int b = dp[pc];\n      if( a > W ) continue;\n      if( i - pc - 1 == 0 ){\n        if( a == W ) rt = 0;\n        break;\n      }\n      a = getn( a, i - pc - 1 );\n      rt = min( rt, max( a, b ) );     \n      if( a >= b ) break;\n    }\n    dp[i] = rt;    \n    //  cout << i << \": \" << dp[i] << endl;\n  }\n\n  \n  int res = dp[N];\n  int sm = 0;\n  for(int i=N-1;i>0;i--){\n    sm += x[i];\n    if( sm > W ) break;\n    res = min( res, dp[i] );\n    sm++;\n  }\n  return max(1,res);\n}\n\nint main(){\n  while( cin >> W >> N && (W||N) ){\n    x = vector<int>(N);\n    int sm = 0;\n    bool f = false;\n    for(int i=0;i<N;i++){\n      cin >> x[i];\n      sm += x[i];\n      if( sm > W ) f = true;      \n      sm++;\n    }\n    if( f ) {\n      cout << solve() << endl;\n    } else {\n      cout << 1 << endl;\n    }\n     \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\n\nusing namespace std;\n\nint main(){\n  for(int W,N;cin>>W>>N,W|N;){\n    int x[52345];\n    for(int i=0;i<N;i++){\n      cin>>x[i];\n    }\n    int l=0,h=1e9;\n    while(h-l>1){\n      int m=(h+l)/2;\n      vector<pair<int,int> > v[52345];\n      bool p[52345]={};\n      v[0].emplace_back(0,1);\n      for(int i=0;i<N;i++){\n\tv[i+1].reserve(v[i].size());\n\tbool f=false;\n\tfor(auto e:v[i]){\n\t  p[i]|=e.first+x[i]<=W;\n\t  int nl=e.first+x[i]+1;\n\t  if(nl<W){\n\t    int nh=min(W,e.second+x[i]+m);\n\t    if(!v[i+1].empty()&&v[i+1].back().second>=nl){\n\t      v[i+1].back().second=nh;\n\t    }else{\n\t      v[i+1].emplace_back(nl,nh);\n\t    }\n\t  }\n\t  f|=e.first<=W-x[i]&&W-x[i]<e.second;\n\t}\n\tif(f){\n\t  v[i+1].insert(v[i+1].begin(),make_pair(0,1));\n\t}\n      }\n      (!p[N-1]?l:h)=m;\n    }\n    cout<<h<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll W, N;\nll x[50000];\nll xsum[50010];\nint dp[50010];\nint trueSum[50010];\n\n// [l, r]\nll minw(int l, int r){\n\tll sum = xsum[r + 1] - xsum[l] + (r - l);\n\tif(sum > W) return -1;\n\tll rem = W - (xsum[r + 1] - xsum[l]);\n\treturn (rem + (r - l - 1)) / (r - l);\n}\n\nbool check(int w){\n\tmemset(trueSum, 0, sizeof trueSum);\n\ttrueSum[1] = 1;\n\tmemset(dp, 0, sizeof dp);\n\tdp[0] = 1;\n\tint L = 0, R = 0;\n\tfor(int i = 1; i < N; i++){\n\t\t/*int L, R;\n\t\t{\n\t\t\tint ng = -1, ok = i - 1;\n\t\t\twhile(abs(ng - ok) > 1){\n\t\t\t\tint mid = (ng + ok) / 2;\n\t\t\t\tint mw = minw(mid, i);\n\t\t\t\tif(mw != -1) ok = mid;\n\t\t\t\telse ng = mid;\n\t\t\t}\n\t\t\tL = ok;\n\t\t\tif(minw(L, i) > w){\n\t\t\t\ttrueSum[i + 2] = trueSum[i + 1];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint ok = L, ng = i;\n\t\t\twhile(abs(ng - ok) > 1){\n\t\t\t\tint mid = (ng + ok) / 2;\n\t\t\t\tint mw = minw(mid, i);\n\t\t\t\tif(mw <= w) ok = mid;\n\t\t\t\telse ng = mid;\n\t\t\t}\n\t\t\tR = ok;\n\t\t}*/\n\t\twhile(L < i && minw(L, i) == -1) L++;\n\t\twhile(R + 1 < i && minw(R + 1, i) <= w) R++;\n\t\tint res1 = minw(L, i), res2 = minw(R, i);\n\t\tif(R < L || res1 == -1 || res1 > w || res2 == -1 || res2 > w){\n\t\t\ttrueSum[i + 2] = trueSum[i + 1];\n\t\t\tcontinue;\n\t\t}\n\t\t//assert(minw(L, i) <= w && minw(R, i) <= w);\n\t\tint s = trueSum[R + 1] - trueSum[L];\n\t\tif(s >= 1){\n\t\t\tdp[i + 1] = 1;\n\t\t\ttrueSum[i + 2] = trueSum[i + 1] + 1;\n\t\t\t// ???????????????????????????????????°ok\n\t\t\tll sum = xsum[N] - xsum[i + 1] + max(0LL, N - i - 2);\n\t\t\tif(sum <= W) return true;\n\t\t}\n\t\telse{\n\t\t\ttrueSum[i + 2] = trueSum[i + 1];\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\twhile(cin >> W >> N, W + N){\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> x[i];\n\t\t\txsum[i + 1] = xsum[i] + x[i];\n\t\t}\n\n\t\tll sum = xsum[N] + N - 1;\n\t\tif(sum <= W){\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint ng = 0, ok = W;\n\t\twhile(abs(ng - ok) > 1){\n\t\t\tint mid = (ng + ok) / 2;\n\t\t\tif(check(mid)) ok = mid;\n\t\t\telse ng = mid;\n\t\t}\n\t\tcout << ok << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string.h>\nusing namespace std;\nint c[51000];\nint bit[51000];\nint getsum(int a,int b){\n\tif(a)return getsum(0,b)-getsum(0,a-1);\n\tint ret=0;\n\tfor(;b>=0;b=(b&(b+1))-1)ret+=bit[b];\n\treturn ret;\n}\nvoid add(int a,int b){\n\tfor(;a<51000;a|=a+1)bit[a]+=b;\n}\nint sum[51000];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<b;i++)scanf(\"%d\",c+i);\n\t\tfor(int i=0;i<b;i++)sum[i+1]=sum[i]+c[i];\n\t\tint L=0;\n\t\tint R=a/2;\n\t\twhile(L+1<R){\n\t\t\tint M=(L+R)/2;\n\t\t\tfor(int i=0;i<=b;i++)bit[i]=0;\n\t\t\tadd(0,1);\n\t\t\tadd(1,-1);\n\t\t\tfor(int i=0;i<b;i++){\n\t\t\t\tif(!getsum(0,i))continue;\n\t\t\t\tif(sum[b]-sum[i]+b-i-1<=a){\n\t\t\t\t\tadd(b,1);break;\n\t\t\t\t}\n\t\t\t\tint l=i;\n\t\t\t\tint r=b;\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tint m=(l+r)/2;\n\t\t\t\t\tif(M*(m-i-1)>=a-(sum[m]-sum[i]))r=m;\n\t\t\t\t\telse l=m;\n\t\t\t\t}\n\t\t\t\tint v1=r;\n\t\t\t\tif(v1-i-1>a-(sum[v1]-sum[i]))continue;\n\t\t\t\tl=i-1;\n\t\t\t\tr=b;\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tint m=(l+r)/2;\n\t\t\t\t\tif(m-i-1>a-(sum[m]-sum[i]))r=m;\n\t\t\t\t\telse l=m;\n\t\t\t\t}\n\t\t\t\tint v2=l;\n\t\t\t\tif(v1<=v2){\n\t\t\t\t\tadd(v1,1);\n\t\t\t\t\tadd(v2+1,-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(getsum(0,b))R=M;\n\t\t\telse L=M;\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint x[100000], dat[100000], n, W, dp[100000];\nvoid add(int p, int q) {\n\twhile (p <= n) {\n\t\tdat[p] += q;\n\t\tp += p&-p;\n\t}\n}\nint sum(int p) {\n\tint sum2 = 0;\n\twhile (p >= 1) {\n\t\tsum2 += dat[p];\n\t\tp -= p&-p;\n\t}\n\treturn sum2;\n}\nint Rangesum(int W1, int W2) {\n\treturn sum(W2) - sum(W1 - 1);\n}\nint hantei(int L1, int R1) {\n\tif (L1 == 0)return 2147000000;\n\tint E = Rangesum(L1, R1);\n\tE += (R1 - L1);\n\treturn E;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> W >> n; for (int i = 0; i < 100000; i++) { dat[i] = 0; dp[i] = 999999999; }\n\t\tif (n == 0 && W == 0)break;\n\t\tfor (int i = 1; i <= n; i++)cin >> x[i]; add(1, x[1]); dp[0] = 1;\n\t\tfor (int i = 2; i <= n - 1; i++) {\n\t\t\tadd(i, x[i]);\n\t\t\tint L = 1, R = i, M = 0;\n\t\t\twhile (true) {\n\t\t\t\tM = (L + R) / 2;\n\t\t\t\tint V1 = hantei(M, i);\n\t\t\t\tint V2 = hantei(M - 1, i);\n\t\t\t\tif (V1 <= W && V2 > W) {\n\t\t\t\t\tfor (int j = M; j < i; j++) {\n\t\t\t\t\t\tif (j != M && dp[j - 2] < dp[j - 1])break;\n\t\t\t\t\t\tif (j != M && dp[j - 2] == dp[j - 1])continue;\n\t\t\t\t\t\tint KO = i - j;\n\t\t\t\t\t\tint V1 = hantei(j, i);\n\t\t\t\t\t\tdp[i] = min(dp[i], max(dp[j - 1], ((W - V1) + KO - 1) / KO + 1));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (V1 > W)L = M;\n\t\t\t\tif (V2 <= W)R = M;\n\t\t\t}\n\t\t}\n\t\tadd(n, x[n]); int minx = 999999999;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (Rangesum(i + 1, n) + (n - (i + 1)) <= W)minx = min(minx, dp[i]);\n\t\t}\n\t\tcout << minx << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\nbool FLG;\nint N,W;\nint table[50005];\n\nvoid recursive(int id,int loc,int limit,int pre_space_num){\n\n\tif(FLG)return;\n\tif(id == N){\n\t\tFLG = true;\n\t\treturn;\n\t}\n\n\tif(loc != 0 && pre_space_num < limit && loc+1+table[id]-1 <= W-1){\n\t\trecursive(id,loc+1,limit,pre_space_num+1);\n\t}\n\n\tif(loc != 0 && pre_space_num == 0)return;\n\n\tif(loc+table[id]-1 >= W)return;\n\n\tif(loc+table[id]-1 == W-1){ //ぴったり行が終了\n\t\trecursive(id+1,0,limit,0);\n\t}else{\n\t\trecursive(id+1,loc+table[id],limit,0);\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d\",&table[i]);\n\t}\n\n\tint left = 0,right = W,m = (left+right)/2;\n\tint ans = W;\n\n\twhile(left <= right){\n\t\tFLG = false;\n\t\trecursive(0,0,m,0);\n\t\tif(FLG){\n\t\t\tans = m;\n\t\t\tright = m-1;\n\t\t}else{\n\t\t\tleft = m+1;\n\t\t}\n\t\tm = (left+right)/2;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&N);\n\t\tif(W == 0 && N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <vector>\n#define INF 999999999\nusing namespace std;\n\nstruct S{\nint len,id;\n\nbool operator<(const S &p) const\n{\n    return len>p.len;\n}\n\n}t;\n\nint num[50005],vis[50005];\n\nint main()\n{\n    int n,m,i,j,cnt,sum,temp;\n\n    while(~scanf(\"%d%d\",&n,&m) && n+m)\n    {\n        for(i=0;i<m;i++) scanf(\"%d\",&num[i]);\n\n        for(i=0;i<m;i++) vis[i]=INF;\n\n        priority_queue<S>que;\n\n        cnt=sum=0;\n\n        for(i=0;i<m;i++)\n        {\n            sum+=num[i];\n            cnt++;\n\n            if(cnt>=2)\n            {\n                if(n-sum>=cnt-1)\n                {\n                    if(i<m-1)\n                    {\n                        t.len=(n-sum)/(cnt-1);\n\n                        if((n-sum)%t.len) t.len++;\n\n                        t.id=cnt;\n\n                        if(t.len<vis[t.id])\n                        {\n                            que.push(t);\n\n                            vis[t.id]=t.len;\n                        }\n                    }\n                    else\n                    {\n                        t.len=1;\n\n                        t.id=m;\n\n                        if(t.len<vis[t.id])\n                        {\n                            que.push(t);\n\n                            vis[t.id]=t.len;\n                        }\n                    }\n\n                }\n                else break;\n            }\n            else if(i==m-1)\n            {\n                t.len=1;\n\n                t.id=m;\n\n                if(t.len<vis[t.id])\n                {\n                    que.push(t);\n\n                    vis[t.id]=t.len;\n                }\n            }\n        }\n//printf(\"size=%d\\n\",que.size());\n        while(!que.empty())\n        {\n            t=que.top();\n//printf(\"  id=%d,len=%d,vis=%d\\n\",t.id,t.len,vis[t.id]);\n            if(t.id==m)\n            {\n                printf(\"%d\\n\",t.len);\n\n                break;\n            }\n\n            que.pop();\n\n            cnt=sum=0;\n\n            int olen=t.len;\n            int oid=t.id;\n\n            for(i=t.id;i<m;i++)\n            {\n                sum+=num[i];\n                cnt++;\n//printf(\"i=%d\\n\");\n                if(cnt>=2)\n                {\n                    if(n-sum>=cnt-1)\n                    {\n                        if(i<m-1)\n                        {\n                            temp=(n-sum)/(cnt-1);\n\n                            if((n-sum)%temp) temp++;\n\n                            t.len=max(temp,olen);\n                            t.id=oid+cnt;\n\n                            if(t.len<vis[t.id])\n                            {\n                                que.push(t);\n//puts(\"fff\");\n                                vis[t.id]=t.len;\n                            }\n                        }\n                        else\n                        {\n                            t.len=max(1,olen);\n                            t.id=oid+cnt;\n\n                            //if(t.len<vis[t.id])\n                            {\n                                que.push(t);\n//puts(\"fff\");\n                                vis[t.id]=t.len;\n                            }\n                        }\n                    }\n                }\n                else if(i==m-1)\n                {\n                    t.len=max(1,olen);\n                    t.id=oid+cnt;\n//printf(\"   t.id=%d,vis[t.id]=%d\\n\",t.id,vis[t.id]);\n                    //if(t.len<vis[t.id])\n                    {\n                        que.push(t);\n//puts(\"fff\");\n                        vis[t.id]=t.len;\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nint main(){\n    int w,n;\n    while(cin >>w >>n,w){\n        vector<int> x(n+1);\n        rep(i,n) cin >>x[i+1];\n\n        vector<ll> pre(n+1);\n        for(int i=1; i<=n; ++i) pre[i] = pre[i-1]+x[i];\n\n        auto check = [&](ll m){\n            vector<int> dp(n+2);\n            dp[1] = 1;\n\n            int ct = 0;\n            int L=1,R=1;\n            // 右端i\n            for(int i=2; i<=n; ++i){\n                while(1){\n                    if(R==i) break;\n                    ll t = pre[i]-pre[R-1]+m*(i-R);\n                    if(t>=w){\n                        ct += dp[R];\n                        ++R;\n                    }\n                    else break;\n                }\n\n                while(1){\n                    if(L==i) break;\n                    ll t = pre[i]-pre[L-1]+(i-L);\n                    if(t>w){\n                        ct -= dp[L];\n                        ++L;\n                    }\n                    else break;\n                }\n\n                dp[i+1] = (ct>0);\n            }\n\n            if(dp[n+1]) return true;\n            for(int i=n; i>0; --i){\n                // dbg(i);\n                ll t = pre[n]-pre[i-1]+n-i;\n                if(t<=w && dp[i]) return true;\n            }\n            return false;\n        };\n\n        int l=0, r=w;\n        while(r-l>1){\n            int m = (l+r)/2;\n            if(check(m)) r = m;\n            else l = m;\n        }\n        printf(\"%d\\n\",r);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint W, N, x[50009], dp[50009];\nbool solve(int m) {\n\tint pl = 0, pr = 0;\n\tdp[1] = dp[2] = 1;\n\tfor (int j = 2; j <= N; j++) {\n\t\twhile (x[j] - x[pl] > W - (j - pl - 1)) pl++;\n\t\twhile (j != pr + 1 && x[j] - x[pr] >= W - (j - pr - 1) * m) pr++;\n\t\tdp[j + 1] = dp[j] + (dp[pr] > dp[pl] ? 1 : 0);\n\t}\n\tfor (int j = 0; j <= N; j++) {\n\t\tif (dp[j] != dp[j + 1] && x[N] - x[j] + N - j - 1 <= W) return true;\n\t}\n\treturn false;\n}\nint main() {\n\twhile (scanf(\"%d %d\", &W, &N), W) {\n\t\tfor (int i = 0; i < N; i++) scanf(\"%d\", &x[i + 1]), x[i + 1] += x[i];\n\t\tint l = 0, r = W + 1;\n\t\twhile (r - l > 1) {\n\t\t\tint m = (l + r) >> 1;\n\t\t\tif (solve(m)) r = m;\n\t\t\telse l = m;\n\t\t}\n\t\tprintf(\"%d\\n\", r);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct BIT{\n  int size;\n  ll t[100000];\n  void init(int n){\n    size=n+5;\n    for(int i=0;i<=size;i++)t[i]=0;\n  }\n  \n  ll sum(int i){\n    ll res=0;\n    while(0<i){\n      res+=t[i];\n      i-=(i&-i);\n    }\n    return res;\n  }\n  ll sum(int a,int b){\n    if(a>b)return 0;\n    if(a<=1)return sum(b);\n    else return sum(b)-sum(a-1);\n  }\n  void add(int i,ll x){\n    while(i<size){\n      t[i]+=x;\n      i+=(i&-i);\n    }\n  }\n};\n\nll W,N;\nBIT X,DP;\n\nint judge(int l,int r,ll M){\n  if(l==r)return -1;\n  ll d=X.sum(l,r);\n  if(d+(r-l)>W)return 1;\n  if(d+(ll)(r-l)*M<W)return -1;\n  return 0;\n}\n\nbool check(int M){\n  DP.init(N+1);\n  DP.add(N+1,1);\n  int fi=N,se=N;\n  for(int i=N;i>=1;i--){\n    if(X.sum(i,N)+N-i<=W){\n      DP.add(i,1);\n      continue;\n    }\n    while(judge(i,fi-1,M)>=0)fi--;\n    while(judge(i,se,M)==1)se--;\n    \n    if(DP.sum(fi+1,se+1)>0)DP.add(i,1);\n  }\n  return (DP.sum(1)==1);\n}\n\nint main(){\n  while(1){\n    scanf(\"%lld %lld\",&W,&N);\n    if(W==0&&N==0)break;\n    X.init(N+5);\n    for(int i=1;i<=N;i++){\n      ll x;\n      scanf(\"%lld\",&x);\n      X.add(i,x);\n    }\n    int L=1,R=W-2,M;\n    while(L<R){\n      M=(L+R)/2;\n      if(check(M))R=M;\n      else L=M+1;\n    }\n    printf(\"%d\\n\",L);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\ninline int f(int n, int i, int L, const vector<int>& sum_rev){\n    return (sum_rev[i - n] - sum_rev[i]) + L * (n - 1);\n}\n\nint dp[50010];\nint sum_dp[50010];\n\nint main(){\n    int W, N;\n    while(cin >> W >> N && N){\n        vector<int> x(N);\n        REP(i, N) cin >> x[i];\n\n        vector<int> sum_rev(N + 1);\n        sum_rev[N] = 0;\n        for(int i = N - 1; i >= 0; i--){\n            sum_rev[i] = sum_rev[i + 1] + x[i];\n        }\n\n        int lb_L = 0, ub_L = W; // ub\n        while(ub_L - lb_L > 1){\n            int L = (lb_L + ub_L) / 2;\n            dp[0] = 1;\n            dp[1] = 0;\n            sum_dp[1] = 1;\n            sum_dp[2] = 1;\n\n            for(int i = 2; i < N; i++){\n                dp[i] = 0;\n                sum_dp[i] = sum_dp[i - 1] + dp[i - 1];\n\n                int lb = 1, ub = i; // ub \n                while(ub - lb > 1){\n                    int n = (ub + lb) / 2;\n                    if(f(n, i, L, sum_rev) >= W){\n                        ub = n;\n                    }else{\n                        lb = n;\n                    }\n                }\n                int begin_n = ub;\n\n                //printf(\"dp[%d] : begin %d \\n\", i, begin_n);\n                if(f(begin_n, i, L, sum_rev) < W){\n                    continue;\n                }\n\n                lb = begin_n, ub = i + 1; // lb\n                while(ub - lb > 1){\n                    int n = (ub + lb) / 2;\n                    if(f(n, i, 1, sum_rev) <= W){\n                        lb = n;\n                    }else{\n                        ub = n;\n                    }\n                }\n                int end_n = lb; \n\n                //printf(\"dp[%d] : end %d \\n\", i, end_n);\n                if(f(end_n, i, 1, sum_rev) > W) {\n                    continue;\n                }\n\n                int begin = i - end_n;\n                int end = i - begin_n;\n                // [begin, end]\n                if(sum_dp[end + 1] - sum_dp[begin] > 0){\n                    dp[i] = 1;\n                }\n                //printf(\"dp[%d] : [dp[%d], dp[%d]] (%d) -> %d\\n\", i, begin, end, sum_dp[end + 1] - sum_dp[begin], dp[i]);\n            }\n\n            bool ok = false;\n            for(int n = 1; n <= N && (n - 1) + sum_rev[N - n] <= W; n++) {\n                //printf(\"n - 1 + sum_rev[%d] = %d\\n\", i, n - 1 + sum_rev[i]);\n                if(dp[N - n]){\n                    ok = true;\n                    break;\n                }\n            }\n            //printf(\"L %d  is %d\\n\", L, ok);\n\n            if(ok){\n                ub_L = L;\n            }else{\n                lb_L = L;\n            }\n        }\n\n        cout << ub_L << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\nbool FLG;\nint N,W;\nint table[50005],ruisekiwa[50005];\nbool right_check[50005];\n\nbool one_line_check(int left,int right){ //left～rightの単語を一行に詰め込めるか\n\n\tif(ruisekiwa[right]-ruisekiwa[left-1]+(right-left) <= W){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nbool put_check(int left,int right,int limit){\n\n\tif(right == N)return true; //最終文字は、右端に詰めなくて良い\n\n\tif(ruisekiwa[right]-ruisekiwa[left-1]+limit*(right-left) >= W){\n\t\treturn true;\n\t}else{ //★★各幅を全てlimitにしても、一行の文字数に足りない→少なくとも一か所、limit+1以上のスペースを入れなければならない!!\n\t\treturn false;\n\t}\n}\n\nvoid recursive(int start_id,int limit){\n\n\tif(FLG)return;\n\tif(start_id >= N){\n\t\tFLG = true;\n\t\treturn;\n\t}\n\n\tfor(int right_id = start_id+1; right_id <= N; right_id++){\n\t\tif(!one_line_check(start_id,right_id))break;\n\t\tif(right_check[right_id])continue; //検索済ならSKIP\n\n\t\t//printf(\"%d～%dは一行に詰め込める\\n\",start_id,right_id);\n\n\t\tif(put_check(start_id,right_id,limit)){ //start_id～right_idまでを、最大スペースlimitで置ける場合\n\t\t\tright_check[right_id] = true;\n\t\t\trecursive(right_id+1,limit);\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\truisekiwa[0] = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\",&table[i]);\n\t\truisekiwa[i] = table[i];\n\t\truisekiwa[i] += ruisekiwa[i-1];\n\t}\n\n\tint left = 1,right = W,m = (left+right)/2;\n\tint ans = W;\n\n\twhile(left <= right){\n\t\tFLG = false;\n\t\tfor(int i = 1; i <= N; i++)right_check[i] = false;\n\t\trecursive(1,m);\n\t\tif(FLG){\n\t\t\tans = m;\n\t\t\tright = m-1;\n\t\t}else{\n\t\t\tleft = m+1;\n\t\t}\n\t\tm = (left+right)/2;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&N);\n\t\tif(W == 0 && N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint w, n;\nint x[50000];\n\nint dp[50001];\n\nint dfs(int begin, int space)\n{\n\tif (~dp[begin]) return dp[begin];\n\tif (begin >= n - 1) return dp[begin] = true;\n\tint sum = x[begin];\n\tfor (int i = begin + 1; i < n; i++){\n\t\tsum += x[i];\n\t\tint l = sum + (i - begin);\n\t\tint r = sum + (i - begin) * space;\n\t\tif (l > w) break;\n\t\tif (i == n - 1) return dp[begin] = true;\n\t\tif (r < w) continue;\n\t\tif (dfs(i + 1, space)) return dp[begin] = true;\n\t}\n\treturn dp[begin] = false;\n}\n\nint solve()\n{\n\tint left = 0, right = w;\n\twhile (left + 1 < right){\n\t\tint mid = (left + right) / 2;\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tif (dfs(0, mid)) right = mid;\n\t\telse left = mid;\n\t}\n\treturn right;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &w, &n), w){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tscanf(\"%d\", x + i);\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\nint W,N,x[50000],sum[50001];\nbool can(int x){\n\tbool dp[50001]={};\n\tint imos[50002]={};\n\tdp[0]=true;\n\timos[1]=1;\n\tfor(int i=2;i<=N;i++){\n\t\tint lb=1,ub=i+1;\n\t\twhile(ub-lb>1){\n\t\t\tint m=(ub+lb)/2;\n\t\t\tif(W-(sum[i]-sum[i-m])>=m-1) lb=m;\n\t\t\telse ub=m;\n\t\t}\n\t\tint r=lb;\n\t\tlb=1,ub=i+1;\n\t\twhile(ub-lb>1){\n\t\t\tint m=(lb+ub)/2;\n\t\t\tif(W-(sum[i]-sum[i-m])<=(long long)(m-1)*x) ub=m;\n\t\t\telse lb=m;\n\t\t}\n\t\tint l=ub;\n\t\tif(imos[i-l+1]-imos[i-r]>0) dp[i]=true;\n\t\timos[i+1]=imos[i]+(dp[i]?1:0);\n\t}\n\tfor(int i=N;i>=0;i--){\n\t\tif(sum[N]-sum[i]+(N-1-i)>W) break;\n\t\tif(dp[i]) return true;\n\t}\n\treturn false;\n}\nint main(){\n\twhile(true){\n\t\tscanf(\"%d%d\",&W,&N);\n\t\tif(W==0) return 0;\n\t\trep(i,N) scanf(\"%d\",x+i);\n\t\trep1(i,N) sum[i]=sum[i-1]+x[i-1];\n\t\tint ub=W/2,lb=0;\n\t\twhile(ub-lb>1){\n\t\t\tint m=(ub+lb)/2;\n\t\t\tif(can(m)) ub=m;\n\t\t\telse lb=m;\n\t\t}\n\t\tcout<<ub<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\nbool FLG;\nint N,W;\nint table[50005],ruisekiwa[50005];\nbool right_check[50005];\n\nbool one_line_check(int left,int right){ //left～rightの単語を一行に詰め込めるか\n\n\tif(ruisekiwa[right]-ruisekiwa[left-1]+(right-left) <= W){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nbool put_check(int left,int right,int limit){\n\n\tif(right == N)return true; //最終文字は、右端に詰めなくて良い\n\n\tif(ruisekiwa[right]-ruisekiwa[left-1]+limit*(right-left) >= W){\n\t\treturn true;\n\t}else{ //★★各幅を全てlimitにしても、一行の文字数に足りない→少なくとも一か所、limit+1以上のスペースを入れなければならない!!\n\t\treturn false;\n\t}\n}\n\nvoid recursive(int start_id,int limit){\n\n\tif(FLG)return;\n\tif(start_id >= N){\n\t\tFLG = true;\n\t\treturn;\n\t}\n\n\tfor(int right_id = start_id+1; right_id <= N; right_id++){\n\t\tif(!one_line_check(start_id,right_id))break;\n\t\t//if(right_check[right_id])continue; //検索済ならSKIP\n\n\t\t//printf(\"%d～%dは一行に詰め込める\\n\",start_id,right_id);\n\n\t\tif(put_check(start_id,right_id,limit)){ //start_id～right_idまでを、最大スペースlimitで置ける場合\n\t\t\t//right_check[right_id] = true;\n\t\t\trecursive(right_id+1,limit);\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\truisekiwa[0] = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\",&table[i]);\n\t\truisekiwa[i] = table[i];\n\t\truisekiwa[i] += ruisekiwa[i-1];\n\t}\n\n\tint left = 1,right = W,m = (left+right)/2;\n\tint ans = W;\n\n\twhile(left <= right){\n\t\tFLG = false;\n\t\t//for(int i = 1; i <= N; i++)right_check[i] = false;\n\t\trecursive(1,m);\n\t\tif(FLG){\n\t\t\tans = m;\n\t\t\tright = m-1;\n\t\t}else{\n\t\t\tleft = m+1;\n\t\t}\n\t\tm = (left+right)/2;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&N);\n\t\tif(W == 0 && N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nbool ok(int w,const vi& xs,int sp)\n{\n\tint n=xs.size();\n\tvi sum(n+1);\n\trep(i,n) sum[i+1]=sum[i]+xs[i];\n\t\n\tvi dp(n+1); dp[0]=1;\n\tint l=0,r=0,cnt=0;\n\trep(i,n){\n\t\tfor(;l<i;cnt-=!!dp[l++]) if(sum[i+1]-sum[l]+(i-l)<=w) break;\n\t\tfor(;r<i;cnt+=!!dp[r++]) if(sum[i+1]-sum[r]+(i-r)*sp<w) break;\n\t\tdp[i+1]=!!cnt;\n\t}\n\t\n\tint res=dp[n];\n\tfor(int i=n;i--;){\n\t\tif(sum[n]-sum[i]+(n-i-1)>w) break;\n\t\tres|=dp[i];\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int w,n;~scanf(\"%d%d\",&w,&n) && w|n;){\n\t\tvi xs(n);\n\t\trep(i,n) scanf(\"%d\",&xs[i]);\n\t\t\n\t\tint lo=1,hi=w;\n\t\twhile(lo<hi){\n\t\t\tint mi=(lo+hi)/2;\n\t\t\tif(ok(w,xs,mi))\n\t\t\t\thi=mi;\n\t\t\telse\n\t\t\t\tlo=mi+1;\n\t\t}\n\t\tprintf(\"%d\\n\",lo);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <vector>\n#define INF 999999999\nusing namespace std;\n\nstruct S{\nint len,id;\n\nbool operator<(const S &p) const\n{\n    return len>p.len;\n}\n\n}t;\n\nint num[50005],vis[50005];\n\nint main()\n{\n    int n,m,i,j,cnt,sum,temp;\n\n    while(~scanf(\"%d%d\",&n,&m) && n+m)\n    {\n        for(i=0;i<m;i++) scanf(\"%d\",&num[i]);\n\n        for(i=0;i<=m;i++) vis[i]=INF;\n\n        priority_queue<S>que;\n\n        cnt=sum=0;\n\n        for(i=0;i<m;i++)\n        {\n            sum+=num[i];\n            cnt++;\n\n            if(cnt>=2)\n            {\n                if(n-sum>=cnt-1)\n                {\n                    if(i<m-1)\n                    {\n                        t.len=(n-sum)/(cnt-1);\n\n                        if((n-sum)%t.len) t.len++;\n\n                        t.id=cnt;\n\n                        if(t.len<vis[t.id])\n                        {\n                            que.push(t);\n\n                            vis[t.id]=t.len;\n                        }\n                    }\n                    else\n                    {\n                        t.len=1;\n\n                        t.id=m;\n\n                        if(t.len<vis[t.id])\n                        {\n                            que.push(t);\n\n                            vis[t.id]=t.len;\n                        }\n                    }\n\n                }\n                else break;\n            }\n            else if(i==m-1)\n            {\n                t.len=1;\n\n                t.id=m;\n\n                if(t.len<vis[t.id])\n                {\n                    que.push(t);\n\n                    vis[t.id]=t.len;\n                }\n            }\n        }\n//printf(\"size=%d\\n\",que.size());\n        while(!que.empty())\n        {\n            t=que.top();\n//printf(\"  id=%d,len=%d,vis=%d\\n\",t.id,t.len,vis[t.id]);\n            if(t.id==m)\n            {\n                printf(\"%d\\n\",t.len);\n\n                break;\n            }\n\n            que.pop();\n\n            cnt=sum=0;\n\n            int olen=t.len;\n            int oid=t.id;\n\n            for(i=t.id;i<m;i++)\n            {\n                sum+=num[i];\n                cnt++;\n//printf(\"i=%d\\n\");\n                if(cnt>=2)\n                {\n                    if(n-sum>=cnt-1)\n                    {\n                        if(i<m-1)\n                        {\n                            temp=(n-sum)/(cnt-1);\n\n                            if((n-sum)%temp) temp++;\n\n                            t.len=max(temp,olen);\n                            t.id=oid+cnt;\n\n                            if(t.len<vis[t.id])\n                            {\n                                que.push(t);\n//puts(\"fff\");\n                                vis[t.id]=t.len;\n                            }\n                        }\n                        else\n                        {\n                            t.len=max(1,olen);\n                            t.id=oid+cnt;\n\n                            if(t.len<vis[t.id])\n                            {\n                                que.push(t);\n//puts(\"fff\");\n                                vis[t.id]=t.len;\n                            }\n                        }\n                    }\n                }\n                else if(i==m-1)\n                {\n                    t.len=max(1,olen);\n                    t.id=oid+cnt;\n//printf(\"   t.id=%d,vis[t.id]=%d\\n\",t.id,vis[t.id]);\n                    if(t.len<vis[t.id])\n                    {\n                        que.push(t);\n//puts(\"fff\");\n                        vis[t.id]=t.len;\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <vector>\n#define INF 999999999\nusing namespace std;\n\nstruct S{\nint len,id;\n\nbool operator<(const S &p) const\n{\n    if(len==p.len) return id<p.id;\n\n    return len>p.len;\n}\n\n}t;\n\nint num[50005],vis[50005];\n\nint main()\n{\n    int n,m,i,j,cnt,sum,temp;\n\n    int lxd;\n\n    while(~scanf(\"%d%d\",&n,&m) && n+m)\n    {\n        for(i=0;i<m;i++) scanf(\"%d\",&num[i]);\n\n        for(i=0;i<=m;i++) vis[i]=INF;\n\n        priority_queue<S>que;\n\n        cnt=sum=0;\n\n        for(i=0;i<m;i++)\n        {\n            sum+=num[i];\n            cnt++;\n\n            if(cnt>=2)\n            {\n                if(n-sum>=cnt-1)\n                {\n                    if(i<m-1)\n                    {\n                        t.len=(n-sum)/(cnt-1);\n\n                        if((n-sum)%t.len) t.len++;\n\n                        t.id=cnt;\n\n                        if(t.len<vis[t.id])\n                        {\n                            que.push(t);\n\n                            vis[t.id]=t.len;\n                        }\n                    }\n                    else\n                    {\n                        t.len=1;\n\n                        t.id=m;\n\n                        if(t.len<vis[t.id])\n                        {\n                            que.push(t);\n\n                            vis[t.id]=t.len;\n                        }\n                    }\n\n                }\n                else break;\n            }\n            else if(i==m-1)\n            {\n                t.len=1;\n\n                t.id=m;\n\n                if(t.len<vis[t.id])\n                {\n                    que.push(t);\n\n                    vis[t.id]=t.len;\n                }\n            }\n        }\n\n        lxd=0;\n\n        while(!que.empty())\n        {\n            lxd++;\n\n            t=que.top();\n\n            if(t.id==m || lxd==1100+log(n))\n            {\n                printf(\"%d\\n\",t.len);\n\n                break;\n            }\n\n            que.pop();\n\n            cnt=sum=0;\n\n            int olen=t.len;\n            int oid=t.id;\n\n            for(i=t.id;i<m;i++)\n            {\n                sum+=num[i];\n                cnt++;\n\n                if(cnt>=2)\n                {\n                    if(n-sum>=cnt-1)\n                    {\n                        if(i<m-1)\n                        {\n                            temp=(n-sum)/(cnt-1);\n\n                            if((n-sum)%temp) temp++;\n\n                            t.len=max(temp,olen);\n                            t.id=oid+cnt;\n\n                            if(t.len<vis[t.id])\n                            {\n                                que.push(t);\n\n                                vis[t.id]=t.len;\n                            }\n                        }\n                        else\n                        {\n                            t.len=max(1,olen);\n                            t.id=oid+cnt;\n\n                            if(t.len<vis[t.id])\n                            {\n                                que.push(t);\n\n                                vis[t.id]=t.len;\n                            }\n                        }\n                    }\n                }\n                else if(i==m-1)\n                {\n                    t.len=max(1,olen);\n                    t.id=oid+cnt;\n\n                    if(t.len<vis[t.id])\n                    {\n                        que.push(t);\n\n                        vis[t.id]=t.len;\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\narray<int,(int)(1e5)> ok;\narray<int,(int)(1e5)> oksum;\n\nbool check(int w,int n,vector<ll> &sumx,ll sp,vector<int> &ubs){\n    fill(ok.begin(),ok.begin()+n+1,false);\n    fill(oksum.begin(),oksum.begin()+n+2,false);\n    ok[n]=true;\n    ok[n-1]=true;\n    oksum[n+1]=0;\n    oksum[n]=1;\n    oksum[n-1]=2;\n    for(int i=n-2;i>=0;i--){\n        //cerr<<\"1check\"<<i<<endl;\n        int j=ubs[i];\n        int lb=i+1; //[i,lb)de tarinai\n        int ub=j;\n        while(ub-lb>1){\n            int mid=((lb+ub)>>1);\n            ll mot=w-(sumx[mid]-sumx[i]);\n            ll chi=mid-i-1;\n            if((mot+chi-1)/chi>sp){\n                lb=mid;\n            }\n            else{\n                ub=mid;\n            }\n        }\n        //cerr<<\"2check\"<<i<<endl;\n        int b=ub;\n        //check [b,j)\n        if(j==n+1 || oksum[b]-oksum[j]>0){\n            ok[i]=true;\n        }\n        else{\n            ok[i]=false;\n        }   \n        //cerr<<\"#\"<<i<<\" \"<<b<<\" \"<<j<<\" \"<<ok[i]<<endl;\n        oksum[i]=oksum[i+1]+ok[i];\n    }\n    //cerr<<sp<<endl;\n    //string buf;\n    //cin>>buf;\n    \n    return ok[0];\n}\n\nint solve(int w,int n){\n    \n    vector<ll> x(n);\n    for(int i=0;i<n;i++) cin>>x[i];\n    vector<ll> sumx(n+1);\n    for(int i=0;i<n;i++){\n        sumx[i+1]=sumx[i]+x[i];\n    }\n    vector<int> ubs(n);\n    for(int i=n-2;i>=0;i--){\n        int lb=i;\n        int ub=n+1;\n        //cerr<<\"check\"<<i<<endl;\n        //[i,lb) is ok\n        //w-(sumx[lb]-sumx[i])>=lb-i-1\n        //w+i+1>=sumx[lb]-sumx[i]+lb\n        while(ub-lb>1){\n            int mid=(lb+ub)/2;\n            ll sux=sumx[mid]-sumx[i]+mid;\n        //cerr<<\"#\"<<mid<<\" \"<<sux<<\" \"<<w+i+1<<endl;\n            if(w+i+1>=sux){\n                lb=mid;\n            }\n            else{\n                ub=mid;\n            }\n        }\n        ubs[i]=ub;\n    }\n    int lb=0;   \n    int ub=w;\n    //cerr<<\"End summation\"<<endl;\n    while(ub-lb>1){\n        int mid=(lb+ub)/2;\n        if(!check(w,n,sumx,mid,ubs)){\n            lb=mid;\n        }\n        else{\n            ub=mid;\n        }\n    }\n    return ub;\n}\n\nint main(){\n    int w,n;\n    while(cin>>w>>n,w){\n        cout<<solve(w,n)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXW = 80008;\nconst int MAXN = 50005;\n\nint W, N;\nint x[MAXN];\nbool dp[MAXN];\n\nbool test(int w) {\n  int a, b;\n  int sumA, numA, sumB, numB;\n  fill(dp, dp+MAXN, false);\n  dp[0] = true;\n  a = b = 0;\n  sumA = numA = sumB = numB = 0;\n  //cout << \"w=\" << w << endl;\n  for(int i = 0; i < N; ++i) {\n    for(; a < N && W-sumA > w*(numA-1); ++numA, sumA += x[a++]);\n    for(; b < N && W-sumB >= (numB-1); ++numB, sumB += x[b++]);\n    if(!(W-sumB >= numB)) {\n      sumB -= x[--b]; --numB;\n    }\n\n    if(dp[i]) {\n      for(int j = a; j <= b; ++j) {\n        dp[j] = true;\n      }\n      a = b;\n    }\n\n    sumA -= x[i];\n    sumB -= x[i];\n    numA -= 1;\n    numB -= 1;\n  }\n  return dp[N];\n}\n\nint main() {\n  while(cin >> W >> N && (W|N)) {\n    for(int i = 0; i < N; ++i) cin >> x[i];\n    int l, r;\n    l = 1;\n    r = W+1;\n    while(r-l) {\n      int m = (l+r)/2;\n      if(test(m)) {\n        r = m;\n      } else {\n        l = m+1;\n      }\n    }\n    cout << l << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nclass segtree{\npublic:\n\tstatic const int N=1<<16;\n\tint dp[1<<17];\n\tint lazy[1<<17];\n\tsegtree(){\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(lazy,0,sizeof(lazy));\n\t}\n\tvoid init(){\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(lazy,0,sizeof(lazy));\n\t}\n\n\tvoid lazy_eval(int k){\n\t\tdp[k]+=lazy[k];\n\t\tif(k<N-1){\n\t\t\tlazy[k*2+1]+=lazy[k];\n\t\t\tlazy[k*2+2]+=lazy[k];\n\t\t}\n\t\tlazy[k]=0;\n\t}\n\tvoid lazy_upd(int k){\n\t\tdp[k]=min(dp[k*2+1],dp[k*2+2]);\n\t}\n\tvoid update(int a,int b,int v,int k=0,int l=0,int r=N){\n\t\tlazy_eval(k);\n\t\tif(b<=l || r<=a)return;\n\t\tif(a<=l && r<=b){\n\t\t\tlazy[k]+=v;\n\t\t\tlazy_eval(k);\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)/2;\n\t\tupdate(a,b,v,k*2+1,l,mid);\n\t\tupdate(a,b,v,k*2+2,mid,r);\n\t\tlazy_upd(k);\n\t}\n\n\tint query(int a,int b,int k=0,int l=0,int r=N){\n\t\tlazy_eval(k);\n\t\tif(b<=l || r<=a)return 514514;\n\t\tif(a<=l && r<=b)return dp[k];\n\t\tint mid=(l+r)/2;\n\t\tint vl=query(a,b,k*2+1,l,mid);\n\t\tint vr=query(a,b,k*2+2,mid,r);\n\t\tlazy_upd(k);\n\t\treturn min(vl,vr);\n\t}\n};\n\nint w,n;\nint x[50005];\nsegtree wmax,wmin;\nbool dp[50005];\n\nbool C(int v){\n\twmax.init();\n\twmin.init();\n\tmemset(dp,false,sizeof(dp));\n\tdp[0]=true;\n\tint l=0,r=0;\n\tint cnt=0;\n\tfor(int i=0;i<n;i++){\n\t\twhile(r<=i && wmax.query(r,r+1)+x[i]>=w){\n\t\t\tif(dp[r])cnt++;\n\t\t\tr++;\n\t\t}\n\t\tif(i==(n-1)){\n\t\t\twhile(r<=i){\n\t\t\t\tif(dp[r])cnt++;\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t\twhile(l<r && wmin.query(l,l+1)+x[i]>w){\n\t\t\tif(dp[l])cnt--;\n\t\t\tl++;\n\t\t}\n\t\twmin.update(0,i+1,x[i]+1);\n\t\twmax.update(0,i+1,x[i]+v);\n\t\tif(cnt>0){\n\t\t\tdp[i+1]=true;\n\t\t}\n\t}\n\treturn dp[n];\n}\n\nvoid solve(){\n\tint l=0,r=w;\n\twhile(l+1<r){\n\t\tint mid=(l+r)/2;\n\t\tif(C(mid))r=mid;\n\t\telse l=mid;\n\t}\n\tprintf(\"%d\\n\",r);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&w,&n);\n\t\tif(w==0 && n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&x[i]);\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint x[100000], dat[100000], n, W, dp[80000];\nvoid add(int p, int q) {\n\twhile (p <= n) {\n\t\tdat[p] += q;\n\t\tp += p&-p;\n\t}\n}\nint sum(int p) {\n\tint sum2 = 0;\n\twhile (p >= 1) {\n\t\tsum2 += dat[p];\n\t\tp -= p&-p;\n\t}\n\treturn sum2;\n}\nint Rangesum(int W1, int W2) {\n\treturn sum(W2) - sum(W1 - 1);\n}\nint hantei(int L1, int R1) {\n\tif (L1 == 0)return 2147000000;\n\tint E = Rangesum(L1, R1);\n\tE += (R1 - L1);\n\treturn E;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> W >> n; for (int i = 0; i < 100000; i++) { dat[i] = 0; dp[i] = 999999999; }\n\t\tif (n == 0 && W == 0)break;\n\t\tfor (int i = 1; i <= n; i++)cin >> x[i]; add(1, x[1]); dp[0] = 1;\n\t\tfor (int i = 2; i <= n - 1; i++) {\n\t\t\tadd(i, x[i]);\n\t\t\tint L = 1, R = i, M = 0;\n\t\t\twhile (true) {\n\t\t\t\tM = (L + R) / 2;\n\t\t\t\tint V1 = hantei(M, i);\n\t\t\t\tint V2 = hantei(M - 1, i);\n\t\t\t\tif (V1 <= W && V2 > W) {\n\t\t\t\t\tfor (int j = M; j < i; j++) {\n\t\t\t\t\t\tif (j != M && dp[j - 1] < dp[j])break;\n\t\t\t\t\t\tint KO = i - j;\n\t\t\t\t\t\tdp[i] = min(dp[i], max(dp[j - 1], ((W - V1) + KO - 1) / KO + 1));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (V1 > W)L = M;\n\t\t\t\tif (V2 <= W)R = M;\n\t\t\t}\n\t\t}\n\t\tadd(n, x[n]); int minx = 999999999;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (Rangesum(i + 1, n) + (n - (i + 1)) <= W)minx = min(minx, dp[i]);\n\t\t}\n\t\tcout << minx << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\nbool FLG;\nint N,W;\nint table[50005];\nbool check[50005];\n\nvoid recursive(int id,int loc,int limit,int pre_space_num){\n\n\tif(FLG)return;\n\tif(id == N){\n\t\tFLG = true;\n\t\treturn;\n\t}\n\n\tif(loc != 0 && pre_space_num < limit && loc+1+table[id]-1 <= W-1){\n\t\trecursive(id,loc+1,limit,pre_space_num+1);\n\t}\n\n\tif(loc != 0 && pre_space_num == 0)return;\n\n\tif(loc+table[id]-1 >= W)return;\n\n\tif(loc+table[id]-1 == W-1){ //ぴったり行が終了\n\t\tif(check[id])return; //検索済\n\t\tcheck[id] = true;\n\t\trecursive(id+1,0,limit,0);\n\t}else{\n\t\trecursive(id+1,loc+table[id],limit,0);\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d\",&table[i]);\n\t}\n\n\tint left = 0,right = W,m = (left+right)/2;\n\tint ans = W;\n\n\twhile(left <= right){\n\t\tFLG = false;\n\t\tfor(int i = 0; i < N; i++)check[i] = false;\n\t\trecursive(0,0,m,0);\n\t\tif(FLG){\n\t\t\tans = m;\n\t\t\tright = m-1;\n\t\t}else{\n\t\t\tleft = m+1;\n\t\t}\n\t\tm = (left+right)/2;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&N);\n\t\tif(W == 0 && N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nbool ok(int w,const vi& xs,int sp)\n{\n\tint n=xs.size();\n\tvi sum(n+1);\n\trep(i,n) sum[i+1]=sum[i]+xs[i];\n\t\n\tvi dp(n+1); dp[0]=1;\n\tint l=0,r=0,cnt=0;\n\trep(i,n){\n\t\tfor(;l<i;cnt-=!!dp[l++]) if(sum[i+1]-sum[l]+(i-l)<=w) break;\n\t\tfor(;r<i;cnt+=!!dp[r++]) if(sum[i+1]-sum[r]+(i-r)*sp<w) break;\n\t\tdp[i+1]=!!cnt;\n\t}\n\t\n\tint res=dp[n];\n\tfor(int i=n;i--;){\n\t\tif(sum[n]-sum[i]+(n-i-1)>w) break;\n\t\tres|=dp[i];\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int w,n;~scanf(\"%d%d\",&w,&n) && w|n;){\n\t\tvi xs(n);\n\t\trep(i,n) scanf(\"%d\",&xs[i]);\n\t\t\n\t\tint lo=1,hi=w;\n\t\t//while(lo<hi){\n\t\t//\tint mi=(lo+hi)/2;\n\t\t//\tif(ok(w,xs,mi))\n\t\t//\t\thi=mi;\n\t\t//\telse\n\t\t//\t\tlo=mi+1;\n\t\t//}\n\t\tprintf(\"%d\\n\",lo);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\n\nusing namespace std;\n\nint main(){\n  for(int W,N;cin>>W>>N,W|N;){\n    int x[52345];\n    for(int i=0;i<N;i++){\n      cin>>x[i];\n    }\n    int l=0,h=1e9;\n    while(h-l>1){\n      int m=(h+l)/2;\n      vector<pair<int,int> > v[52345];\n      bool p[52345]={};\n      v[0].emplace_back(0,1);\n      for(int i=0;i<N;i++){\n\tbool f=false;\n\tfor(auto e:v[i]){\n\t  p[i]|=e.first+x[i]<=W;\n\t  int nl=e.first+x[i]+1;\n\t  if(nl<W){\n\t    int nh=min(W,e.second+x[i]+m);\n\t    if(!v[i+1].empty()&&v[i+1].back().second>=nl){\n\t      v[i+1].back().second=nh;\n\t    }else{\n\t      v[i+1].emplace_back(nl,nh);\n\t    }\n\t  }\n\t  f|=e.first<=W-x[i]&&W-x[i]<e.second;\n\t}\n\tif(f){\n\t  v[i+1].insert(v[i+1].begin(),make_pair(0,1));\n\t}\n      }\n      (!p[N-1]?l:h)=m;\n    }\n    cout<<h<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string.h>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <stdio.h>\n\nusing namespace std;\n\n#define fo(i,n) for(int i=0; i<(int)n; i++)\n#define rep(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#define mp(a,b) make_pair(a,b)\n#define pb(x) push_back(x)\n#define pii pair<int,int>\n\nint w,n;\nint v[50100];\nint f[50100];\n\nbool check(int x) {\n    for(int i=0; i<=n+1; i++) f[i] = 0;\n    int l = 1, r = 1;\n    int suml = v[0], sumr = v[0];\n    f[0] = 1;\n    f[1] = -1;\n\n    for (int i=0; i<n; i++) {\n        f[i+1] += f[i];\n        if (f[i]>0) {\n            while (l<n && suml<=w) {\n                suml += 1 + v[l];\n                l++;\n            }\n            while (r<n && sumr<=w) {\n                sumr += x + v[r];\n                r++;\n            }\n            f[l]--;\n            f[r]++;\n            if (l==n && suml<=w) f[n]++;\n        }\n        suml -= 1+v[i];\n        sumr -= x+v[i];\n    }\n    return f[n]>0;\n}\n\nint main() {\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n    while (cin>>w>>n && w!=0) {\n        for (int i=0; i<n; i++) scanf(\"%d\",v+i);\n\n        int lo = 1;\n        int hi = w;\n        while (lo<hi) {\n            int mi = (lo+hi)/2;\n            if (check(mi)) hi = mi;\n            else lo = mi+1;\n        }\n\n        cout<<lo<<\"\\n\";\n    }\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-12;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nbool solve(void){\n\t\n\tint w,n,i;cin>>w>>n;\n\tif(w==0){return 0;}\n\tvector<int>x(n);\n\tfor(i=0;i<n;i++){cin>>x[i];}\n\tllint bmin=0,bmax=w;\n\twhile(bmax-bmin>1){\n\t\tvector<int>table(n+1);\n\t\tllint bgen=(bmax+bmin)/2;\n\t\tvector<llint> Lwa(n+1),Rwa(n+1);\n\t\tfor(i=0;i<n;i++){\n\t\t\tLwa[i+1]=Lwa[i]+x[i]+bgen;\n\t\t\tRwa[i+1]=Rwa[i]+x[i]+1;\n\t\t}\n\t\t//cerr<<\"bgen=\"<<bgen<<endl;\n\t\tbool can=false;\n\t\tfor(i=0;i<n;i++){\n\t\t\tif(table[i]<i){continue;}//不可能\n\t\t\tmaxeq(table[i+1],table[i]);\n\t\t\tllint L=LBI(Lwa,Lwa[i]+w+bgen);\n\t\t\tllint R=UBI(Rwa,Rwa[i]+w+1)-1;\n\t\t\tif(n<=R){can=true;break;}\n\t\t\t//cerr<<\"i=\"<<i<<\"L=\"<<L<<\"R=\"<<R<<endl;\n\t\t\tmaxeq(table[L],R);\n\t\t}\n\t\tif(can){bmax=bgen;}\n\t\telse{bmin=bgen;}\n\t}\n\tcout<<bmax<<endl;\n\treturn 1;\n}\n\nint main(void){\n\tcout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);\n\twhile(solve()){}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string.h>\nusing namespace std;\nint c[51000];\nchar segtree[131072];\nint sz;\ninline int query(int a){\n\ta+=sz;\n\twhile(a){\n\t\tif(segtree[a])return 1;\n\t\ta/=2;\n\t}\n\treturn 0;\n}\nvoid add(int a,int b,int c,int d,int e){\n\tif(d<a||b<c)return;\n\tif(c<=a&&b<=d){\n\t\tsegtree[e]++;\n\t\treturn;\n\t}\n\tadd(a,(a+b)/2,c,d,e*2);\n\tadd((a+b)/2+1,b,c,d,e*2+1);\n}\nint sum[51000];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tsz=1;\n\t\twhile(sz<b+1)sz*=2;\n\t\tfor(int i=0;i<b;i++)scanf(\"%d\",c+i);\n\t\tfor(int i=0;i<b;i++)sum[i+1]=sum[i]+c[i];\n\t\tint L=0;\n\t\tint R=a/2;\n\t\twhile(L+1<R){\n\t\t\tint M=(L+R)/2;\n\t\t\tmemset(segtree,0,sz*2);\n\t\t\t//for(int i=0;i<sz*2;i++)segtree[i]=0;\n\t\t\tadd(0,sz-1,0,0,1);\n\t\t\tfor(int i=0;i<b;i++){\n\t\t\t\tif(!query(i))continue;\n\t\t\t\tif(sum[b]-sum[i]+b-i-1<=a){\n\t\t\t\t\tadd(0,sz-1,b,b,1);break;\n\t\t\t\t}\n\t\t\t\tint l=i;\n\t\t\t\tint r=b;\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tint m=(l+r)/2;\n\t\t\t\t\tif(M*(m-i-1)>=a-(sum[m]-sum[i]))r=m;\n\t\t\t\t\telse l=m;\n\t\t\t\t}\n\t\t\t\tint v1=r;\n\t\t\t\tl=i-1;\n\t\t\t\tr=b;\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tint m=(l+r)/2;\n\t\t\t\t\tif(m-i-1>a-(sum[m]-sum[i]))r=m;\n\t\t\t\t\telse l=m;\n\t\t\t\t}\n\t\t\t\tint v2=l;\n\t\t//\t\tprintf(\"%d %d %d %d\\n\",M,i,v1,v2);\n\t\t\t\tif(v1<=v2)add(0,sz-1,v1,v2,1);\n\t\t\t}\n\t\t\tif(query(b))R=M;\n\t\t\telse L=M;\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\n\nint W, N;\nint x[50010], sum[50010];\n\nbool dp[50010]; // dp[i+1] = xi?????§?????????sp??\\?????§????????????????????????\n\n// ?????????\nbool isIn(int l, int r)\n{\n  return sum[r] - sum[l] + r - l - 1 <= W;\n}\n\n// ??¢??????\nbool isOver(int l, int r, int sp)\n{\n  return sum[r] - sum[l] + (r - l - 1) * sp >= W;\n}\n\nbool check(int sp)\n{\n  if(isIn(0, N)) return true;\n  memset(dp, false, sizeof(dp)); dp[0] = true;\n  // [l,i]??§??????1??\\?????§1????????§????????????????????????word?????\\??????\n  // [r,i]??§??????sp??\\?????§1????????§?????????????°???????word?????\\??????\n  int l = 0, r = 0, cnt = 0; // [l,r)????????????????????????i??????  \n  // ??????????????????????????????????????????????????§?°?????????£????????§?????????\n  for(int i = 1; i <= N; i++) {\n    while(l <= i && !isIn(l, i)) cnt -= dp[l], l++; \n    while(r <= i && isOver(r, i, sp)) cnt += dp[r], r++;\n    dp[i] = cnt > 0;\n    if(dp[i] && isIn(i, N)) return true;\n  }\n  return false;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n  while(cin >> W >> N, W) {\n    sum[0] = 0;\n    rep(i, N) cin >> x[i], sum[i+1] = sum[i] + x[i]; // ??¨?????????????´???????\n    // ?????§???????°??????????????????¶????????£??????\n    int l = 0, r = W;\n    while(l + 1 < r) {\n      int m = (l + r) / 2;\n      if(check(m)) r = m;\n      else l = m;\n    }\n    cout << r << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\narray<int,(int)(1e5)> ok;\narray<int,(int)(1e5)> oksum;\narray<ll,100000> ubs;\narray<ll,100000> sumx;\n\nbool check(int w,int n,ll sp){\n    fill(ok.begin(),ok.begin()+n+1,false);\n    fill(oksum.begin(),oksum.begin()+n+2,false);\n    ok[n]=true;\n    ok[n-1]=true;\n    oksum[n+1]=0;\n    oksum[n]=1;\n    oksum[n-1]=2;\n    for(int i=n-2;i>=0;i--){\n        //cerr<<\"1check\"<<i<<endl;\n        int j=ubs[i];\n        int lb=i+1; //[i,lb)de tarinai\n        int ub=j;\n        while(ub-lb>1){\n            int mid=((lb+ub)>>1);\n            ll mot=w-(sumx[mid]-sumx[i]);\n            ll chi=mid-i-1;\n            if((mot+chi-1)/chi>sp){\n                lb=mid;\n            }\n            else{\n                ub=mid;\n            }\n        }\n        //cerr<<\"2check\"<<i<<endl;\n        int b=ub;\n        //check [b,j)\n        if(j==n+1 || oksum[b]-oksum[j]>0){\n            ok[i]=true;\n        }\n        else{\n            ok[i]=false;\n        }   \n        //cerr<<\"#\"<<i<<\" \"<<b<<\" \"<<j<<\" \"<<ok[i]<<endl;\n        oksum[i]=oksum[i+1]+ok[i];\n    }\n    //cerr<<sp<<endl;\n    //string buf;\n    //cin>>buf;\n    \n    return ok[0];\n}\n\nint solve(int w,int n){\n    vector<ll> x(n);\n    for(int i=0;i<n;i++) cin>>x[i];\n    for(int i=0;i<n;i++){\n        sumx[i+1]=sumx[i]+x[i];\n    }\n    for(int i=n-2;i>=0;i--){\n        int lb=i;\n        int ub=n+1;\n        //cerr<<\"check\"<<i<<endl;\n        //[i,lb) is ok\n        //w-(sumx[lb]-sumx[i])>=lb-i-1\n        //w+i+1>=sumx[lb]-sumx[i]+lb\n        while(ub-lb>1){\n            int mid=(lb+ub)/2;\n            ll sux=sumx[mid]-sumx[i]+mid;\n        //cerr<<\"#\"<<mid<<\" \"<<sux<<\" \"<<w+i+1<<endl;\n            if(w+i+1>=sux){\n                lb=mid;\n            }\n            else{\n                ub=mid;\n            }\n        }\n        ubs[i]=ub;\n    }\n    int lb=0;   \n    int ub=w;\n    //cerr<<\"End summation\"<<endl;\n    while(ub-lb>1){\n        int mid=(lb+ub)/2;\n        if(!check(w,n,mid)){\n            lb=mid;\n        }\n        else{\n            ub=mid;\n        }\n    }\n    return ub;\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    int w,n;\n    while(cin>>w>>n,w){\n        cout<<solve(w,n)<<\"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\ninline int f(int n, int i, int L, const vector<int>& sum_rev){\n    return (sum_rev[i - n] - sum_rev[i]) + L * (n - 1);\n}\n\nint dp[50010];\nint sum_dp[50010];\n\nint main(){\n    int W, N;\n    while(cin >> W >> N && N){\n        vector<int> x(N);\n        REP(i, N) cin >> x[i];\n\n        vector<int> sum_rev(N + 1);\n        sum_rev[N] = 0;\n        for(int i = N - 1; i >= 0; i--){\n            sum_rev[i] = sum_rev[i + 1] + x[i];\n        }\n\n        int lb_L = 0, ub_L = W; // ub\n        while(ub_L - lb_L > 1){\n            int L = (lb_L + ub_L) / 2;\n            dp[0] = 1;\n            dp[1] = 0;\n            sum_dp[1] = 1;\n            sum_dp[2] = 1;\n\n            for(int i = 2; i < N; i++){\n                dp[i] = 0;\n                sum_dp[i] = sum_dp[i - 1] + dp[i - 1];\n \n                int lb = 1, ub = min(i, (W + L)/(L + 1)); // ub  true ??\n                while(ub - lb > 1){\n                    int n = (ub + lb) / 2;\n                    if(f(n, i, L, sum_rev) >= W){\n                        ub = n;\n                    }else{\n                        lb = n;\n                    }\n                }\n                int begin_n = ub;\n\n                //printf(\"dp[%d] : begin %d \\n\", i, begin_n);\n                if(f(begin_n, i, L, sum_rev) < W){\n                    continue;\n                }\n\n                lb = begin_n, ub = i + 1; // lb\n                while(ub - lb > 1){\n                    int n = (ub + lb) / 2;\n                    if(f(n, i, 1, sum_rev) <= W){\n                        lb = n;\n                    }else{\n                        ub = n;\n                    }\n                }\n                int end_n = lb; \n\n                //printf(\"dp[%d] : end %d \\n\", i, end_n);\n                if(f(end_n, i, 1, sum_rev) > W) {\n                    continue;\n                }\n\n                int begin = i - end_n;\n                int end = i - begin_n;\n                // [begin, end]\n                if(sum_dp[end + 1] - sum_dp[begin] > 0){\n                    dp[i] = 1;\n                }\n                //printf(\"dp[%d] : [dp[%d], dp[%d]] (%d) -> %d\\n\", i, begin, end, sum_dp[end + 1] - sum_dp[begin], dp[i]);\n            }\n\n            bool ok = false;\n            for(int n = 1; n <= N && (n - 1) + sum_rev[N - n] <= W; n++) {\n                //printf(\"n - 1 + sum_rev[%d] = %d\\n\", i, n - 1 + sum_rev[i]);\n                if(dp[N - n]){\n                    ok = true;\n                    break;\n                }\n            }\n            //printf(\"L %d  is %d\\n\", L, ok);\n\n            if(ok){\n                ub_L = L;\n            }else{\n                lb_L = L;\n            }\n        }\n\n        cout << ub_L << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\narray<int,(int)(1e5)> ok;\narray<int,(int)(1e5)> oksum;\n\nbool check(int w,int n,vector<ll> &sumx,ll sp,vector<int> &ubs){\n    fill(ok.begin(),ok.begin()+n+1,false);\n    fill(oksum.begin(),oksum.begin()+n+2,false);\n    ok[n]=true;\n    ok[n-1]=true;\n    oksum[n+1]=0;\n    oksum[n]=1;\n    oksum[n-1]=2;\n    for(int i=n-2;i>=0;i--){\n        //cerr<<\"1check\"<<i<<endl;\n        int j=ubs[i];\n        int lb=i+1; //[i,lb)de tarinai\n        int ub=j;\n        while(ub-lb>1){\n            int mid=((lb+ub)>>1);\n            ll mot=w-(sumx[mid]-sumx[i]);\n            ll chi=mid-i-1;\n            if(mot+chi-1>sp*chi){\n                lb=mid;\n            }\n            else{\n                ub=mid;\n            }\n        }\n        //cerr<<\"2check\"<<i<<endl;\n        int b=ub;\n        //check [b,j)\n        if(j==n+1 || oksum[b]-oksum[j]>0){\n            ok[i]=true;\n        }\n        else{\n            ok[i]=false;\n        }   \n        //cerr<<\"#\"<<i<<\" \"<<b<<\" \"<<j<<\" \"<<ok[i]<<endl;\n        oksum[i]=oksum[i+1]+ok[i];\n    }\n    //cerr<<sp<<endl;\n    //string buf;\n    //cin>>buf;\n    \n    return ok[0];\n}\n\nint solve(int w,int n){\n    \n    vector<ll> x(n);\n    for(int i=0;i<n;i++) cin>>x[i];\n    vector<ll> sumx(n+1);\n    for(int i=0;i<n;i++){\n        sumx[i+1]=sumx[i]+x[i];\n    }\n    vector<int> ubs(n);\n    for(int i=n-2;i>=0;i--){\n        int lb=i;\n        int ub=n+1;\n        //cerr<<\"check\"<<i<<endl;\n        //[i,lb) is ok\n        //w-(sumx[lb]-sumx[i])>=lb-i-1\n        //w+i+1>=sumx[lb]-sumx[i]+lb\n        while(ub-lb>1){\n            int mid=(lb+ub)/2;\n            ll sux=sumx[mid]-sumx[i]+mid;\n        //cerr<<\"#\"<<mid<<\" \"<<sux<<\" \"<<w+i+1<<endl;\n            if(w+i+1>=sux){\n                lb=mid;\n            }\n            else{\n                ub=mid;\n            }\n        }\n        ubs[i]=ub;\n    }\n    int lb=0;   \n    int ub=w;\n    //cerr<<\"End summation\"<<endl;\n    while(ub-lb>1){\n        int mid=(lb+ub)/2;\n        if(!check(w,n,sumx,mid,ubs)){\n            lb=mid;\n        }\n        else{\n            ub=mid;\n        }\n    }\n    return ub;\n}\n\nint main(){\n    int w,n;\n    while(cin>>w>>n,w){\n        cout<<solve(w,n)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\ninline int f(int n, int i, int L, const vector<int>& sum_rev){\n    int k = i - n;\n    int len = sum_rev[k] - sum_rev[i];\n    return len + L * (n - 1);\n}\nint main(){\n    int W, N;\n    while(cin >> W >> N && N){\n        vector<int> x(N);\n        REP(i, N) cin >> x[i];\n\n        vector<int> sum_rev(N + 1);\n        sum_rev[N] = 0;\n        for(int i = N - 1; i >= 0; i--){\n            sum_rev[i] = sum_rev[i + 1] + x[i];\n        }\n\n        int lb_L = 0, ub_L = W - 1; // ub\n        while(ub_L - lb_L > 1){\n            int L = (lb_L + ub_L) / 2;\n            vector<int> dp(N, 0);\n            vector<int> sum_dp(N + 1, 0);\n            dp[0] = 1;\n            dp[1] = 0;\n            sum_dp[1] = 1;\n            sum_dp[2] = 1;\n\n            for(int i = 2; i < N; i++){\n                sum_dp[i] = sum_dp[i - 1] + dp[i - 1];\n\n                int lb = 1, ub = i; // ub \n                while(ub - lb > 1){\n                    int n = (ub + lb) / 2;\n                    if(f(n, i, L, sum_rev) >= W){\n                        ub = n;\n                    }else{\n                        lb = n;\n                    }\n                }\n                int begin_n = ub;\n\n                //printf(\"dp[%d] : begin %d \\n\", i, begin_n);\n                if(!(f(begin_n, i, L, sum_rev) >= W)){\n                    continue;\n                }\n\n                lb = 2, ub = i + 1; // lb\n                while(ub - lb > 1){\n                    int n = (ub + lb) / 2;\n                    if(f(n, i, 1, sum_rev) <= W){\n                        lb = n;\n                    }else{\n                        ub = n;\n                    }\n                }\n                int end_n = lb; \n\n                //printf(\"dp[%d] : end %d \\n\", i, end_n);\n                if(!(f(end_n, i, 1, sum_rev) <= W)) {\n                    continue;\n                }\n\n                int begin = i - end_n;\n                int end = i - begin_n;\n                // [begin, end]\n                if(sum_dp[end + 1] - sum_dp[begin] > 0){\n                    dp[i] = 1;\n                }else{\n                    dp[i] = 0;\n                }\n                //printf(\"dp[%d] : [dp[%d], dp[%d]] (%d) -> %d\\n\", i, begin, end, sum_dp[end + 1] - sum_dp[begin], dp[i]);\n            }\n\n            bool ok = false;\n            for(int i = 0; i < N; i++) {\n                int n = N - i;\n                //printf(\"n - 1 + sum_rev[%d] = %d\\n\", i, n - 1 + sum_rev[i]);\n                if(dp[i] && (n - 1) + sum_rev[i] <= W){\n                    ok = true;\nbreak;\n                }\n            }\n            //printf(\"L %d  is %d\\n\", L, ok);\n\n            if(ok){\n                ub_L = L;\n            }else{\n                lb_L = L;\n            }\n        }\n\n        cout << ub_L << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint main()\n{\n  int W, N, x[50000] = {};\n  int dp[50000];\n\n  while(scanf(\"%d %d\", &W, &N), W) {\n    for(int i = 1; i <= N; i++) {\n      scanf(\"%d\", x + i);\n      x[i] += x[i - 1];\n    }\n\n    auto getSpace = [&](int l, int r)\n    {\n      if(x[r] - x[l] + r - l - 1 > W) return (INF);\n      if(r == N) return (1);\n      if(l + 1 >= r) return (INF);\n      return ((W + x[l] + r - x[r] - l - 2) / (r - l - 1));\n    };\n\n    fill_n(dp, N + 1, INF);\n    dp[0] = 0;\n    for(int i = 1; i <= N; i++) {\n      for(int j = i - 1; j >= 0; j--) {\n        if(getSpace(j, i) == INF) break;\n        dp[i] = min(dp[i], max(dp[j], getSpace(j, i)));\n      }\n    }\n\n    printf(\"%d\\n\", dp[N]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nconst ll M = 1000000007;\n\nint main(){\n\twhile(1){\n\t\tint w,n;\n\t\tint x[50010];\n\t\tscanf(\"%d%d\",&w,&n); if(w == 0 && n == 0)break;\n\t\trep1(i,n){\n\t\t\tscanf(\"%d\",&x[i]);\n\t\t\tx[i] += x[i-1];\n\t\t}\n\t\t/*rep(i,n+1){\n\t\t\tprintf(\"%d \",x[i]);\n\t\t}\n\t\tputs(\"\");*/\n\t\t\n\t\tint l = 1 , r = w;\n\t\twhile(l < r){\n\t\t\tint m = (l+r)/2;\n\t\t\tint dp[50010] = {};\n\t\t\tdp[0] = 1; dp[1] = -1;\n\t\t\tint s = 0 , t = 0 , ret = 0;\n\t\t\t//cout << \"m = \" << m << endl;\n\t\t\trep(i,n){\n\t\t\t\tif(i > 0)dp[i] += dp[i-1];\n\t\t\t\tif(dp[i] == 0)continue;\n\t\t\t\twhile(s < i+2 || x[s]-x[i]+(s-i-1)*m < w)s ++;\n\t\t\t\twhile((t <= n) && (t < s || x[t]-x[i]+(t-i-1) <= w))t ++;\n\t\t\t\t//cout << t << \" \" << x[n]-x[i]+(n-i-1) << endl;\n\t\t\t\tif(t == n+1){ ret = 1; break; }\n\t\t\t\tdp[s] ++;\n\t\t\t\tdp[t] --;\n\t\t\t\t//printf(\"%d:%d %d %d\\n\",i,dp[i],s,t);\n\t\t\t}\n\t\t\t//puts(\"--------\");\n\t\t\tif(ret == 1)r = m;\n\t\t\telse l = m+1;\n\t\t}\n\t\t\n\t\tcout << l << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include<cstring>\nusing namespace std;\nint n,w, len[51111],psum[51111];\nstruct SegTree{\n\tint n, seg[401111];\n\tvoid init(int _n){\n\t\tn=_n;\n\t\tmemset(seg,0,sizeof(seg));\n\t}\n\tvoid set(int i, int x){\n\t\t// printf(\"[%d] = %d\\n\",i,x);\n\t\tset(i,x,0,n,0);\n\t}\n\tint qmax(int l, int r){\n\t\t// printf(\"%d - %d:  %d\\n\",l,r,qmax(l,r,0,n,0));\n\t\treturn qmax(l,r,0,n,0);\n\t}\n\tvoid set(int i, int x, int sl, int sr, int sid){\n\t\tif(sr<=i || i<sl)return;\n\t\tif(sr-sl<=1){\n\t\t\tseg[sid]=x; return;\n\t\t}\n\t\tset(i, x, sl, (sl+sr)/2, sid*2+1);\n\t\tset(i, x, (sl+sr)/2, sr, sid*2+2);\n\t\tseg[sid] = max(seg[sid*2+1], seg[sid*2+2]);\n\t}\n\tint qmax(int l, int r, int sl, int sr, int sid){\n\t\tif(sr<=l || r<=sl)return 0;\n\t\tif(l<=sl && sr<=r)return seg[sid];\n\t\treturn max(qmax(l, r, sl, (sl+sr)/2, sid*2+1), qmax(l, r, (sl+sr)/2, sr, sid*2+2));\n\t}\n}st;\nint ceiling(int x, int y){\n\tif(y==0){\n\t\tprintf(\"QQ %d %d\\n\",x,y);\n\t\twhile(1);\n\t}\n\treturn (x-1)/y+1;\n}\nbool check(int d){\n\t// printf(\"\\t\\t\\td = %d\\n\",d);\n\tstatic int dp[51111];\n\tmemset(dp,0,sizeof(dp));\n\tst.init(n);\n\n\tfor(int i=1; i<n; i++){\n\t\t// printf(\" i= %d\\n\",i);\n\t\tint lb=-1, ub=i-1, b, a;\n\t\twhile(1<ub-lb){\n\t\t\tint md=(lb+ub)/2;\n\t\t\tif(ceiling(w-psum[i+1]+psum[md+1], i-md-1)<=d)\n\t\t\t\tlb=md;\n\t\t\telse\n\t\t\t\tub=md;\n\t\t}\n\t\tb=lb;\n\t\tlb=-1, ub=i;\n\t\twhile(1<ub-lb){\n\t\t\tint md=(lb+ub)/2;\n\t\t\tif(psum[i+1]-psum[md+1]+i-md-1<=w)\n\t\t\t\tub=md;\n\t\t\telse\n\t\t\t\tlb=md;\n\t\t}\n\t\ta= ub;\n\t\t// printf(\"%d - %d\\n\",a,b);\n\t\tif(psum[i+1]+i<=w && ceiling(w-psum[i+1], i)<=d)dp[i]=1;\n\t\t// printf(\"%d<=%d && %d/%d<=%d\\n\", psum[i+1]+i,w, w-psum[i+1], i, d);\n\t\tif(a<=b)\n\t\t\tdp[i] = st.qmax(a,b+1);\n\t\tst.set(i,dp[i]);\n\t\t// printf(\"dp(%d) = %d\\n\",i,dp[i]);\n\t}\n\tint res=0;\n\tfor(int i=0; i<n-1; i++){\n\t\tif(psum[n]-psum[i+1]+n-i-1<=w)\n\t\t\tres = max(res, dp[i]);\n\t}\n\n\treturn res || dp[n-1] || psum[n]+n-1<=w;\n\n}\nint main(){\n\twhile(scanf(\"%d%d\",&w,&n)&&(n+w>0)){\n\t\tfor(int i=0; i<n; i++)scanf(\"%d\",&len[i]);\n\t\tpsum[0]=0;\n\t\tfor(int i=0; i<n; i++)psum[i+1] = psum[i]+len[i];\n\t\tint lb=0, ub=w;\n\t\twhile(1<ub-lb){\n\t\t\tint md=(lb+ub)/2;\n\t\t\tif(check(md))\n\t\t\t\tub=md;\n\t\t\telse\n\t\t\t\tlb=md;\n\t\t}\n\t\tprintf(\"%d\\n\",ub);\n\t}\n}\n\n/*\n\n11 4\n4 2 1 3\n5 7\n1 1 1 2 2 1 2\n11 7\n3 1 3 1 3 3 4\n100 3\n30 30 39\n30 3\n2 5 3\n0 0\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct BIT{\n  vector<ll> t;\n  void init(int n){\n    t.clear();\n    t.resize(n+1);\n  }\n  \n  ll sum(int i){\n    ll res=0;\n    while(0<i){\n      res+=t[i];\n      i-=(i&-i);\n    }\n    return res;\n  }\n  ll sum(int a,int b){\n    if(a==1)return sum(b);\n    else return sum(b)-sum(a-1);\n  }\n  void add(int i,ll x){\n    while(i<(int)t.size()){\n      t[i]+=x;\n      i+=(i&-i);\n    }\n  }\n};\n\n#define MAX_N 50005\nint W,N;\nll x[MAX_N];\nBIT X,DP;\n\nint judge(int l,int r,int M){\n  if(l==r)return -1;\n  \n  ll d=X.sum(l,r);\n  if(d+(r-l)>W)return 1;\n  if(d+(r-l)*M<W)return -1;\n  return 0;\n}\n\nint getlower(int i,int M){\n  int left=i+1,right=N,mid;\n  while(left<right){\n    mid=(left+right)/2;\n    if(judge(i,mid,M)==-1)left=mid+1;\n    else right=mid;\n  }\n  return left;\n}\n\nint getupper(int i,int M){\n  int left=i+1,right=N+1,mid;\n  while(right-left>1){\n    mid=(left+right)/2;\n    if(judge(i,mid,M)<=0)left=mid;\n    else right=mid;\n  }\n  return left;\n}\n\nbool check(int M){\n  DP.init(N+1);\n  DP.add(N+1,1);\n  \n  for(int i=N;i>=1;i--){\n\n    if(X.sum(i,N)+N-i<=W){\n      DP.add(i,1);\n      continue;\n    }\n\n    int fi=getlower(i,M);\n    int se=getupper(i,M);\n    if( DP.sum(fi+1,se+1) > 0 )\n      DP.add(i,1);\n\n    //    cout<<i<<' '<<DP.sum(i,i)<<endl;\n  }\n  return (DP.sum(1)==1);\n}\n\nint main(){\n  while(1){\n    scanf(\"%d %d\",&W,&N);\n    if(W==0&&N==0)break;\n    X.init(N+5);\n    for(int i=1;i<=N;i++){\n      scanf(\"%lld\",&x[i]);\n      X.add(i,x[i]);\n    }\n\n    \n    \n    \n    int L=1,R=W-2,M;\n    while(L<R){\n      M=(L+R)/2;\n      if(check(M))R=M;\n      else L=M+1;\n    }\n\n    printf(\"%d\\n\",L);\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint c[51000];\nint segtree[131072];\nint query(int a){\n\ta+=65536;\n\twhile(a){\n\t\tif(segtree[a])return 1;\n\t\ta/=2;\n\t}\n\treturn 0;\n}\nvoid add(int a,int b,int c,int d,int e,int f){\n\tif(d<a||b<c)return;\n\tif(c<=a&&b<=d){\n\t\tsegtree[e]+=f;\n\t\treturn;\n\t}\n\tadd(a,(a+b)/2,c,d,e*2,f);\n\tadd((a+b)/2+1,b,c,d,e*2+1,f);\n}\nint sum[51000];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<b;i++)scanf(\"%d\",c+i);\n\t\tfor(int i=0;i<b;i++)sum[i+1]=sum[i]+c[i];\n\t\tint L=0;\n\t\tint R=a/2;\n\t\twhile(L+1<R){\n\t\t\tint M=(L+R)/2;\n\t\t\tfor(int i=0;i<131072;i++)segtree[i]=0;\n\t\t\tadd(0,65535,0,0,1,1);\n\t\t\tfor(int i=0;i<b;i++){\n\t\t\t\tif(!query(i))continue;\n\t\t\t\tif(sum[b]-sum[i]+b-i-1<=a){\n\t\t\t\t\tadd(0,65535,b,b,1,1);break;\n\t\t\t\t}\n\t\t\t\tint l=i;\n\t\t\t\tint r=b;\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tint m=(l+r)/2;\n\t\t\t\t\tif(M*(m-i-1)>=a-(sum[m]-sum[i]))r=m;\n\t\t\t\t\telse l=m;\n\t\t\t\t}\n\t\t\t\tint v1=r;\n\t\t\t\tl=i-1;\n\t\t\t\tr=b;\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tint m=(l+r)/2;\n\t\t\t\t\tif(m-i-1>a-(sum[m]-sum[i]))r=m;\n\t\t\t\t\telse l=m;\n\t\t\t\t}\n\t\t\t\tint v2=l;\n\t\t//\t\tprintf(\"%d %d %d %d\\n\",M,i,v1,v2);\n\t\t\t\tif(v1<=v2)add(0,65535,v1,v2,1,1);\n\t\t\t}\n\t\t\tif(query(b))R=M;\n\t\t\telse L=M;\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint c[51000];\nint segtree[131072];\nint sz;\ninline int query(int a){\n\ta+=sz;\n\twhile(a){\n\t\tif(segtree[a])return 1;\n\t\ta/=2;\n\t}\n\treturn 0;\n}\nvoid add(int a,int b,int c,int d,int e,int f){\n\tif(d<a||b<c)return;\n\tif(c<=a&&b<=d){\n\t\tsegtree[e]+=f;\n\t\treturn;\n\t}\n\tadd(a,(a+b)/2,c,d,e*2,f);\n\tadd((a+b)/2+1,b,c,d,e*2+1,f);\n}\nint sum[51000];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tsz=1;\n\t\twhile(sz<b+1)sz*=2;\n\t\tfor(int i=0;i<b;i++)scanf(\"%d\",c+i);\n\t\tfor(int i=0;i<b;i++)sum[i+1]=sum[i]+c[i];\n\t\tint L=0;\n\t\tint R=a/2;\n\t\twhile(L+1<R){\n\t\t\tint M=(L+R)/2;\n\t\t\tfor(int i=0;i<sz*2;i++)segtree[i]=0;\n\t\t\tadd(0,sz-1,0,0,1,1);\n\t\t\tfor(int i=0;i<b;i++){\n\t\t\t\tif(!query(i))continue;\n\t\t\t\tif(sum[b]-sum[i]+b-i-1<=a){\n\t\t\t\t\tadd(0,sz-1,b,b,1,1);break;\n\t\t\t\t}\n\t\t\t\tint l=i;\n\t\t\t\tint r=b;\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tint m=(l+r)/2;\n\t\t\t\t\tif(M*(m-i-1)>=a-(sum[m]-sum[i]))r=m;\n\t\t\t\t\telse l=m;\n\t\t\t\t}\n\t\t\t\tint v1=r;\n\t\t\t\tl=i-1;\n\t\t\t\tr=b;\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tint m=(l+r)/2;\n\t\t\t\t\tif(m-i-1>a-(sum[m]-sum[i]))r=m;\n\t\t\t\t\telse l=m;\n\t\t\t\t}\n\t\t\t\tint v2=l;\n\t\t//\t\tprintf(\"%d %d %d %d\\n\",M,i,v1,v2);\n\t\t\t\tif(v1<=v2)add(0,sz-1,v1,v2,1,1);\n\t\t\t}\n\t\t\tif(query(b))R=M;\n\t\t\telse L=M;\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string.h>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <stdio.h>\n\nusing namespace std;\n\n#define fo(i,n) for(int i=0; i<(int)n; i++)\n#define rep(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#define mp(a,b) make_pair(a,b)\n#define pb(x) push_back(x)\n#define pii pair<int,int>\n\nint w,n;\nint v[50100];\n\nbool check(int x) {\n    int sum = v[0];\n    int tmp = 0;\n    for (int i=1; i<n; i++) {\n        if (sum+1+v[i]<=w) {\n            sum += 1+v[i];\n            tmp++;\n        }\n        else {\n            int rest = w - sum;\n            if (rest>0) tmp = (rest-1)/tmp + 1;\n            else tmp = 0;\n            tmp++;\n            if (tmp>x) return false;\n            sum = v[i];\n        }\n    }\n    return true;\n}\n\nint main() {\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n    while (cin>>w>>n && w!=0) {\n        for (int i=0; i<n; i++) scanf(\"%d\",v+i);\n\n        int lo = 1;\n        int hi = w;\n        while (lo<hi) {\n            int mi = (lo+hi)/2;\n            if (check(mi)) hi = mi;\n            else lo = mi+1;\n        }\n\n        cout<<lo<<\"\\n\";\n    }\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint w, n, x[50000], dp[50010];\nll s[50010];\n\nint cost(int i, int j){\n\tif(i + 1 == j) return inf;\n\tll len = s[j] - s[i];\n\tif(len + j - i - 1 > w) return inf;\n\treturn (w - len + j - i - 2) / (j - i - 1);\n}\n\nint main(){\n\twhile(cin >> w >> n, w){\n\t\trep(i, n){\n\t\t\tcin >> x[i];\n\t\t\ts[i + 1] = s[i] + x[i];\n\t\t\tdp[i + 1] = inf;\n\t\t}\n\t\t\n\t\tdp[0] = 1;\n\t\tint j = 0, ans = inf;\n\t\trep(i, n){\n\t\t\tif(i >= n - 2 || cost(i, n) < inf){\n\t\t\t\tans = min(ans, dp[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile(j <= i + 1) j++;\n\t\t\twhile(j <= n){\n\t\t\t\tif(cost(i, j) >= inf) break;\n\t\t\t\tdp[j] = min(dp[j], max(dp[i], cost(i, j)));\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nbool ok(int w,const vi& xs,int sp)\n{\n\tint n=xs.size();\n\tvi sum(n+1);\n\trep(i,n) sum[i+1]=sum[i]+xs[i];\n\t\n\tvi dp(n+1); dp[0]=1;\n\tint l=0,r=0,cnt=0;\n\trep(i,n){\n\t\tfor(;l<i;cnt-=!!dp[l++]) if(sum[i+1]-sum[l]+(i-l)<=w) break;\n\t\tfor(;r<i;cnt+=!!dp[r++]) if(sum[i+1]-sum[r]+(i-r)*sp<w) break;\n\t\tdp[i+1]=!!cnt;\n\t}\n\t\n\tint res=dp[n];\n\tfor(int i=n;i--;){\n\t\tif(sum[n]-sum[i]+(n-i-1)>w) break;\n\t\tres|=dp[i];\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int w,n;cin>>w>>n && w|n;){\n\t\tvi xs(n);\n\t\trep(i,n) cin>>xs[i];\n\t\t\n\t\tint lo=1,hi=w;\n\t\twhile(lo<hi){\n\t\t\tint mi=(lo+hi)/2;\n\t\t\tif(ok(w,xs,mi))\n\t\t\t\thi=mi;\n\t\t\telse\n\t\t\t\tlo=mi+1;\n\t\t}\n\t\tcout<<lo<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <vector>\n#define INF 999999999\nusing namespace std;\n\nstruct S{\nint len,id;\n\nbool operator<(const S &p) const\n{\n    if(len==p.len) return id<p.id;\n\n    return len>p.len;\n}\n\n}t;\n\nint num[50005],vis[50005];\n\nint main()\n{\n    int n,m,i,j,cnt,sum,temp;\n\n    int lxd;\n\n    while(~scanf(\"%d%d\",&n,&m) && n+m)\n    {\n        for(i=0;i<m;i++) scanf(\"%d\",&num[i]);\n\n        for(i=0;i<=m;i++) vis[i]=INF;\n\n        priority_queue<S>que;\n\n        cnt=sum=0;\n\n        for(i=0;i<m;i++)\n        {\n            sum+=num[i];\n            cnt++;\n\n            if(cnt>=2)\n            {\n                if(n-sum>=cnt-1)\n                {\n                    if(i<m-1)\n                    {\n                        t.len=(n-sum)/(cnt-1);\n\n                        if((n-sum)%t.len) t.len++;\n\n                        t.id=cnt;\n\n                        if(t.len<vis[t.id])\n                        {\n                            que.push(t);\n\n                            vis[t.id]=t.len;\n                        }\n                    }\n                    else\n                    {\n                        t.len=1;\n\n                        t.id=m;\n\n                        if(t.len<vis[t.id])\n                        {\n                            que.push(t);\n\n                            vis[t.id]=t.len;\n                        }\n                    }\n\n                }\n                else break;\n            }\n            else if(i==m-1)\n            {\n                t.len=1;\n\n                t.id=m;\n\n                if(t.len<vis[t.id])\n                {\n                    que.push(t);\n\n                    vis[t.id]=t.len;\n                }\n            }\n        }\n\n        lxd=0;\n\n        while(!que.empty())\n        {\n            lxd++;\n\n            t=que.top();\n\n            if(t.id==m || lxd==5000)\n            {\n                printf(\"%d\\n\",t.len);\n\n                break;\n            }\n\n            que.pop();\n\n            cnt=sum=0;\n\n            int olen=t.len;\n            int oid=t.id;\n\n            for(i=t.id;i<m;i++)\n            {\n                sum+=num[i];\n                cnt++;\n\n                if(cnt>=2)\n                {\n                    if(n-sum>=cnt-1)\n                    {\n                        if(i<m-1)\n                        {\n                            temp=(n-sum)/(cnt-1);\n\n                            if((n-sum)%temp) temp++;\n\n                            t.len=max(temp,olen);\n                            t.id=oid+cnt;\n\n                            if(t.len<vis[t.id])\n                            {\n                                que.push(t);\n\n                                vis[t.id]=t.len;\n                            }\n                        }\n                        else\n                        {\n                            t.len=max(1,olen);\n                            t.id=oid+cnt;\n\n                            if(t.len<vis[t.id])\n                            {\n                                que.push(t);\n\n                                vis[t.id]=t.len;\n                            }\n                        }\n                    }\n                }\n                else if(i==m-1)\n                {\n                    t.len=max(1,olen);\n                    t.id=oid+cnt;\n\n                    if(t.len<vis[t.id])\n                    {\n                        que.push(t);\n\n                        vis[t.id]=t.len;\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\n\nstruct RangeBoolQuery\n{\n    using type = bool;\n    static type id() { return false; }\n    static type op(const type &l, const type &r) { return l || r; }\n};\n\ntemplate <typename M>\nclass SegmentTree\n{\n    using T = typename M::type;\n    int n;\n    std::vector<T> node;\n\npublic:\n    // v を基に初期化\n    SegmentTree(const std::vector<T> &v)\n    {\n        // n は v.size() 以上の最小の2冪\n        n = 1;\n        while (n < int(v.size()))\n            n *= 2;\n        node.resize(2 * n, M::id());\n\n        // i の子 -> 2*i+1, 2*i+2 , 親 -> (i-1)/2\n        for (int i = 0; i < int(v.size()); i++)\n            node[i + n] = v[i];\n        for (int i = n - 1; i >= 0; i--)\n            node[i] = M::op(node[2 * i], node[2 * i + 1]);\n    }\n    // Monoid::id 初期化\n    SegmentTree(int _n)\n    {\n        // n は v.size() 以上の最小の2冪\n        n = 1;\n        while (n < _n)\n            n *= 2;\n        node.resize(2 * n, M::id());\n    }\n    // x 番目を val に更新\n    void update(int x, T val)\n    {\n        x += n;\n        node[x] = val;\n        while (x >>= 1)\n        {\n            node[x] = M::op(node[2 * x], node[2 * x + 1]);\n        }\n    }\n    // v[x] を M::op(v[x], val) に更新\n    void operation(int x, T val)\n    {\n        x += n;\n        node[x] = M::op(node[x], val);\n        while (x >>= 1)\n        {\n            node[x] = M::op(node[2 * x], node[2 * x + 1]);\n        }\n    }\n    // [a, b) の op\n    T query(int l, int r)\n    {\n        l += n;\n        r += n;\n        T retl = M::id(), retr = M::id();\n        while (l < r)\n        {\n            if (l & 1)\n                retl = M::op(retl, node[l++]);\n            if (r & 1)\n                retr = M::op(node[--r], retr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return M::op(retl, retr);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll w, n;\n    while (cin >> w >> n, w || n)\n    {\n        vector<ll> x(n + 1, 0), sum(n + 1, 0);\n        for (int i = 1; i <= n; i++)\n        {\n            cin >> x[i];\n            sum[i] = sum[i - 1] + x[i];\n        }\n        ll lb = 1e5, ub = 0;\n        while (lb - ub > 1)\n        {\n            ll m = (lb + ub) / 2;\n            // dp[i] := i を行の最後に置けるか\n            SegmentTree<RangeBoolQuery> dp(n + 1);\n            dp.update(0, true);\n            // x[l]...x[i] を1行に置ける\n            // x[r]...x[i] をm個以下のスペースで置ける\n            ll l = 1, r = 1;\n            for (ll i = 1; i <= n; i++)\n            {\n                if (sum[i] + m * (i - 1) < w)\n                    continue;\n                while (l < i)\n                {\n                    if (sum[i] - sum[l - 1] + (i - l) <= w)\n                        break;\n                    l++;\n                }\n                while (r < i)\n                {\n                    if (r == i - 1)\n                        break;\n                    if (sum[i] - sum[r] + m * (i - r - 1) < w)\n                        break;\n                    r++;\n                }\n                if (l > r || i <= l)\n                    continue;\n                auto ret = dp.query(l - 1, r);\n                dp.update(i, ret);\n            }\n            bool f = false;\n            for (int i = 0; i < n; i++)\n            {\n                if (!dp.query(i, i + 1))\n                    continue;\n                if (sum[n] - sum[i] + (n - i - 1) <= w)\n                    f = true;\n            }\n            if (f)\n                lb = m;\n            else\n                ub = m;\n        }\n        cout << lb << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <ctime>\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\n#include <valarray>\n\nusing namespace std;\ntypedef long long ll;\n\n#define ALL(c) (c).begin(),(c).end()\n#define FOR(i,l,r) for(int i=(int)l;i<(int)r;++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORr(i,l,r) for(int i=(int)r-1;i>=(int)l;--i)\n#define REPr(i,n) FORr(i,0,n)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\ntemplate<typename T,typename U> T pmod(T x,U M){return (x%M+M)%M;}\n\n\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\n\n\n\nnamespace Fenwicks{\n  template<typename T> class Fenwick{\n  public:\n    int size;vector<T> bit;\n    Fenwick():Fenwick(0){}\n    Fenwick(int n):size(n){bit = vector<T>(n+1);}\n    T sum(int n){// [0,n)\n      T s=0;\n      while(n>0){\n        s+=bit[n];\n        n-=n&-n;//low\n      }\n      return s;\n    }\n    void add(int i,T x){//[0,...i...,n)\n      i++;\n      while(i<=size){\n        bit[i]+=x;\n        i+=i & -i;//next\n      }\n    }\n    \n    //lib\n    T sum(int a,int b){// [a,b)\n      return sum(b)-sum(a);\n    }\n  };\n}\nusing namespace Fenwicks;\n\n\ntemplate <typename T,typename Func> T satisfy_min(T l ,T r,Func P){\n  l--;\n  while(r-l>1)(P((l+r)/2)?r:l)=(l+r)/2;\n  return r;\n}\n\n// max{i∈[l,r) | P(i)}．存在しない時、 l-1．\ntemplate <typename T,typename Func> T satisfy_max(T l ,T r,Func P){\n  l--;\n  while(r-l>1)(P((l+r)/2)?l:r)=(l+r)/2;\n  return l;\n}\n\n\nint W,N;\nvector<int> xs;\n\nvector<ll> xsum,wsum;\n\nint _i,_spM;\nbool satL(int ml){\n  ll spc=ml-_i-1,sp=(W-(xsum[ml]-xsum[_i]) + spc-1)/spc;\n  return sp<=_spM;\n}\n\nvector<int> rs;\n\nint can(int spM){\n  Fenwick<int> fen(N);\n  vector<bool> ok(N);\n  //last\n  FORr(i,0,N)if(wsum[N]-wsum[i]-1<=W)fen.add(i,1),ok[i]=true;\n\n  //back \"[i,N)がok\" =def \"1区間 [i,m)がok\" かつ \"*区間 [m,N)がok\"\n  FORr(i,0,N-1)if(!ok[i]){\n    //[i,l)\n    // int l=satisfy_min(i+2,N,[&](int ml)->bool{\n    //   ll spc=ml-i-1,sp=(W-(xsum[ml]-xsum[i]) + spc-1)/spc;\n    //   return sp<=spM;\n    // });\n    _i=i;_spM=spM;\n    int l=satisfy_min(i+2,N,satL);\n    \n    //[i,r)\n    // int r=satisfy_max(i+2,N,[&](int mr)->bool{\n    //     return wsum[mr]-wsum[i]-1<=W;\n    // });\n    if(l<=rs[i] && fen.sum(l,rs[i]+1)>0)fen.add(i,1),ok[i]=true;\n  }\n  return ok[0];\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n  // ifstream cin( \"in\" );\n  // ofstream cout( \"out\" );\n\tcerr << fixed <<setprecision(20);\n\tcout << fixed <<setprecision(20);\n\n  while (true) {\n    cin >> W>> N;if(N==0)break;\n    xs=vector<int>(N);REP(i,N)cin >> xs[i];\n\n    xsum=vector<ll>(N+1);\n    FOR(i,1,N+1)xsum[i]=xsum[i-1]+xs[i-1];\n    wsum=vector<ll>(N+1);\n    FOR(i,1,N+1)wsum[i]=wsum[i-1]+1+xs[i-1];\n\n    rs=vector<int>(N);\n    REP(i,N) rs[i]=satisfy_max(i+2,N,[&](int mr)->bool{return wsum[mr]-wsum[i]-1<=W;});\n    \n    int res=satisfy_min(1,100000,[&](int m){\n      return can(m);\n    });\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\ninline int f(int n, int i, int L, const vector<int>& sum_rev){\n    return (sum_rev[i - n] - sum_rev[i]) + L * (n - 1);\n}\n\nint dp[50010];\nint sum_dp[50010];\n\nint main(){\n    int W, N;\n    while(cin >> W >> N && N){\n        vector<int> x(N);\n        REP(i, N) cin >> x[i];\n\n        vector<int> sum_rev(N + 1);\n        sum_rev[N] = 0;\n        for(int i = N - 1; i >= 0; i--){\n            sum_rev[i] = sum_rev[i + 1] + x[i];\n        }\n\n        int lb_L = 0, ub_L = W; // ub\n        while(ub_L - lb_L > 1){\n            int L = (lb_L + ub_L) / 2;\n            dp[0] = 1;\n            dp[1] = 0;\n            sum_dp[1] = 1;\n            sum_dp[2] = 1;\n\n            for(int i = 2; i < N; i++){\n                dp[i] = 0;\n                sum_dp[i] = sum_dp[i - 1] + dp[i - 1];\n \n                int lb = 1, ub = min(i, (W + L)/(L + 1) + 1); // ub  true ??\n                while(ub - lb > 1){\n                    int n = (ub + lb) / 2;\n                    if(f(n, i, L, sum_rev) >= W){\n                        ub = n;\n                    }else{\n                        lb = n;\n                    }\n                }\n                int begin_n = ub;\n\n                //printf(\"dp[%d] : begin %d \\n\", i, begin_n);\n                if(f(begin_n, i, L, sum_rev) < W){\n                    continue;\n                }\n\n                lb = begin_n, ub = min(i + 1, W + 2); // lb\n                while(ub - lb > 1){\n                    int n = (ub + lb) / 2;\n                    if(f(n, i, 1, sum_rev) <= W){\n                        lb = n;\n                    }else{\n                        ub = n;\n                    }\n                }\n                int end_n = lb; \n\n                //printf(\"dp[%d] : end %d \\n\", i, end_n);\n                if(f(end_n, i, 1, sum_rev) > W) {\n                    continue;\n                }\n\n                int begin = i - end_n;\n                int end = i - begin_n;\n                // [begin, end]\n                if(sum_dp[end + 1] - sum_dp[begin] > 0){\n                    dp[i] = 1;\n                }\n                //printf(\"dp[%d] : [dp[%d], dp[%d]] (%d) -> %d\\n\", i, begin, end, sum_dp[end + 1] - sum_dp[begin], dp[i]);\n            }\n\n            bool ok = false;\n            for(int n = 1; n <= N && (n - 1) + sum_rev[N - n] <= W; n++) {\n                //printf(\"n - 1 + sum_rev[%d] = %d\\n\", i, n - 1 + sum_rev[i]);\n                if(dp[N - n]){\n                    ok = true;\n                    break;\n                }\n            }\n            //printf(\"L %d  is %d\\n\", L, ok);\n\n            if(ok){\n                ub_L = L;\n            }else{\n                lb_L = L;\n            }\n        }\n\n        cout << ub_L << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <ctime>\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\n#include <valarray>\n\nusing namespace std;\ntypedef long long ll;\n\n#define ALL(c) (c).begin(),(c).end()\n#define FOR(i,l,r) for(int i=(int)l;i<(int)r;++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORr(i,l,r) for(int i=(int)r-1;i>=(int)l;--i)\n#define REPr(i,n) FORr(i,0,n)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\ntemplate<typename T,typename U> T pmod(T x,U M){return (x%M+M)%M;}\n\n\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\n\n\n\nnamespace Fenwicks{\n  template<typename T> class Fenwick{\n  public:\n    int size;vector<T> bit;\n    Fenwick():Fenwick(0){}\n    Fenwick(int n):size(n){bit = vector<T>(n+1);}\n    T sum(int n){// [0,n)\n      T s=0;\n      while(n>0){\n        s+=bit[n];\n        n-=n&-n;//low\n      }\n      return s;\n    }\n    void add(int i,T x){//[0,...i...,n)\n      i++;\n      while(i<=size){\n        bit[i]+=x;\n        i+=i & -i;//next\n      }\n    }\n    \n    //lib\n    T sum(int a,int b){// [a,b)\n      return sum(b)-sum(a);\n    }\n  };\n}\nusing namespace Fenwicks;\n\n\ntemplate <typename T,typename Func> T satisfy_min(T l ,T r,Func P){\n  l--;\n  while(r-l>1)(P((l+r)/2)?r:l)=(l+r)/2;\n  return r;\n}\n\n// max{i∈[l,r) | P(i)}．存在しない時、 l-1．\ntemplate <typename T,typename Func> T satisfy_max(T l ,T r,Func P){\n  l--;\n  while(r-l>1)(P((l+r)/2)?l:r)=(l+r)/2;\n  return l;\n}\n\n\nint W,N;\nvector<int> xs;\n\nvector<ll> xsum,wsum;\nint can(int spM){\n  Fenwick<int> fen(N);\n  vector<bool> ok(N);\n  //last\n  FORr(i,0,N)if(wsum[N]-wsum[i]-1<=W)fen.add(i,1),ok[i]=true;\n\n  //back \"[i,N)がok\" =def \"1区間 [i,m)がok\" かつ \"*区間 [m,N)がok\"\n  FORr(i,0,N-1)if(!ok[i]){\n    //[i,l)\n    int l=satisfy_min(i+2,N,[&](int ml)->bool{\n      ll spc=ml-i-1,sp=(W-(xsum[ml]-xsum[i]) + spc-1)/spc;\n      return sp<=spM;\n    });\n    //[i,r)\n    int r=satisfy_max(i+2,N,[&](int mr)->bool{\n        return wsum[mr]-wsum[i]-1<=W;\n    });\n    if(l<=r && fen.sum(l,r+1)>0)fen.add(i,1),ok[i]=true;\n  }\n  return ok[0];\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n  // ofstream cout( \"out\" );\n\tcerr << fixed <<setprecision(20);\n\tcout << fixed <<setprecision(20);\n\n  while (true) {\n    cin >> W>> N;if(N==0)break;\n    xs=vector<int>(N);REP(i,N)cin >> xs[i];\n\n    xsum=vector<ll>(N+1);\n    FOR(i,1,N+1)xsum[i]=xsum[i-1]+xs[i-1];\n    wsum=vector<ll>(N+1);\n    FOR(i,1,N+1)wsum[i]=wsum[i-1]+1+xs[i-1];\n\n    int res=satisfy_min(1,100000,[&](int m){\n      return can(m);\n    });\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll W, N;\nll x[50000];\nll xsum[50010];\nint dp[50010];\n\n// [l, r]\nll minw(int l, int r){\n\tll sum = xsum[r + 1] - xsum[l] + (r - l);\n\tif(sum > W) return -1;\n\tll rem = W - (xsum[r + 1] - xsum[l]);\n\treturn (rem + (r - l - 1)) / (r - l);\n}\n\nbool check(int w){\n\tmemset(dp, 0, sizeof dp);\n\tdp[0] = 1;\n\tint cnt = 0;\n\tint L = 0, R = 0;\n\tfor(int i = 1; i < N; i++){\n\t\twhile(L < i && minw(L, i) == -1){\n\t\t\tif(dp[L]) cnt--;\n\t\t\tL++;\n\t\t}\n\t\twhile(R < i && minw(R, i) <= w){\n\t\t\tif(dp[R]) cnt++;\n\t\t\tR++;\n\t\t}\n\t\t//assert(minw(L, i) <= w && minw(R, i) <= w);\n\t\tif(cnt){\n\t\t\tdp[i + 1] = 1;\n\t\t\t// ???????????????????????????????????°ok\n\t\t\tll sum = xsum[N] - xsum[i + 1] + max(0LL, N - i - 2);\n\t\t\tif(i == N - 1 || sum <= W) return true;\n\t\t}\n\t\telse{\n\t\t\tdp[i + 1] = 0;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\twhile(cin >> W >> N, W + N){\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> x[i];\n\t\t\txsum[i + 1] = xsum[i] + x[i];\n\t\t}\n\n\t\tll sum = xsum[N] + N - 1;\n\t\tif(sum <= W){\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint ng = 0, ok = W;\n\t\twhile(abs(ng - ok) > 1){\n\t\t\tint mid = (ng + ok) / 2;\n\t\t\tif(check(mid)) ok = mid;\n\t\t\telse ng = mid;\n\t\t}\n\t\tcout << ok << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint w, n, x[50000], dp[50010];\nll s[50010];\n\nint cost(int i, int j){\n\tif(i + 1 == j) return inf;\n\tll len = s[j] - s[i];\n\tif(len + j - i - 1 > w) return inf;\n\treturn (w - len + j - i - 2) / (j - i - 1);\n}\n\nint main(){\n\twhile(cin >> w >> n, w){\n\t\trep(i, n){\n\t\t\tcin >> x[i];\n\t\t\ts[i + 1] = s[i] + x[i];\n\t\t\tdp[i + 1] = inf;\n\t\t}\n\t\t\n\t\tdp[0] = 1;\n\t\tint j = 0, ans = inf;\n\t\trep(i, n){\n\t\t\tif(i >= n - 1 || cost(i, n) < inf){\n\t\t\t\tans = min(ans, dp[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile(j <= i + 1) j++;\n\t\t\twhile(j <= n){\n\t\t\t\tif(cost(i, j) >= inf) break;\n\t\t\t\tdp[j] = min(dp[j], max(dp[i], cost(i, j)));\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\nint N,W;\nint table[50005],ruisekiwa[50005];\nbool check[50005];\n\nbool one_line_check(int left,int right){ //left～rightの単語を一行に詰め込めるか\n\n\tif(ruisekiwa[right]-ruisekiwa[left-1]+(right-left) <= W){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nbool put_check(int left,int right,int limit){\n\n\tif(right == N)return true; //最終文字は、右端に詰めなくて良い\n\n\tif(ruisekiwa[right]-ruisekiwa[left-1]+limit*(right-left) >= W){\n\t\treturn true;\n\t}else{ //★★各幅を全てlimitにしても、一行の文字数に足りない→少なくとも一か所、limit+1以上のスペースを入れなければならない!!\n\t\treturn false;\n\t}\n}\n\n\nbool is_OK(int limit){\n\n\tif(one_line_check(1,N))return true;\n\n\tcheck[0] = true;\n\tbool FLG;\n\n\tint left_start = 1,next_start;\n\n\tfor(int right_id = 1; right_id <= N; right_id++){ //右端のループ\n\t\twhile(one_line_check(left_start,right_id) == false || check[left_start-1] == false)left_start++;\n\t\tFLG = false;\n\t\tfor(int left_id = left_start; left_id <= right_id; left_id++){\n\t\t\tif(check[left_id-1] == false)continue;\n\t\t\tif(put_check(left_id,right_id,limit) == true){\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcheck[right_id] = FLG;\n\t\tif(check[right_id]){\n\t\t\tif(right_id == N || one_line_check(right_id+1,N) == true){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nvoid func(){\n\n\truisekiwa[0] = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\",&table[i]);\n\t\truisekiwa[i] = table[i];\n\t\truisekiwa[i] += ruisekiwa[i-1];\n\t}\n\n\tint left = 1,right = W,m = (left+right)/2;\n\tint ans = W;\n\n\twhile(left <= right){\n\t\tif(is_OK(m)){\n\t\t\tans = m;\n\t\t\tright = m-1;\n\t\t}else{\n\t\t\tleft = m+1;\n\t\t}\n\t\tm = (left+right)/2;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&N);\n\t\tif(W == 0 && N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct BIT{\n  int size;\n  ll t[100000];\n  void init(int n){\n    size=n+5;\n    for(int i=0;i<=size;i++)t[i]=0;\n  }\n  \n  ll sum(int i){\n    ll res=0;\n    while(0<i){\n      res+=t[i];\n      i-=(i&-i);\n    }\n    return res;\n  }\n  ll sum(int a,int b){\n    if(a>b)return 0;\n    if(a<=1)return sum(b);\n    else return sum(b)-sum(a-1);\n  }\n  void add(int i,ll x){\n    while(i<size){\n      t[i]+=x;\n      i+=(i&-i);\n    }\n  }\n};\n\nll W,N;\nBIT X,DP;\n\nint judge(int l,int r,ll M){\n  if(l==r)return -1;\n  ll d=X.sum(l,r);\n  if(d+(r-l)>W)return 1;\n  if(d+(ll)(r-l)*M<W)return -1;\n  return 0;\n}\n\nint getlower(int i,ll M){\n  int left=i+1,right=N,mid;\n  while(left<right){\n    mid=(left+right)/2;\n    if(judge(i,mid,M)==-1)left=mid+1;\n    else right=mid;\n  }\n  return left;\n}\n\nint getupper(int i,ll M){\n  int left=i+1,right=N+1,mid;\n  while(right-left>1){\n    mid=(left+right)/2;\n    if(judge(i,mid,M)<=0)left=mid;\n    else right=mid;\n  }\n  return left;\n}\n\nbool check(int M){\n  DP.init(N+1);\n  DP.add(N+1,1);\n  int fi=N;\n  int se=N;\n  \n  for(int i=N;i>=1;i--){\n    if(X.sum(i,N)+N-i<=W){\n      DP.add(i,1);\n      continue;\n    }\n    while(judge(i,fi-1,M)>=0)fi--;\n    while(judge(i,se,M)==1)se--;\n    \n    if(DP.sum(fi+1,se+1)>0)DP.add(i,1);\n  }\n  return (DP.sum(1)==1);\n}\n\nint main(){\n  while(1){\n    scanf(\"%lld %lld\",&W,&N);\n    if(W==0&&N==0)break;\n    X.init(N+5);\n    for(int i=1;i<=N;i++){\n      ll x;\n      scanf(\"%lld\",&x);\n      X.add(i,x);\n    }\n    \n    int L=1,R=W-2,M;\n    while(L<R){\n      M=(L+R)/2;\n      if(check(M))R=M;\n      else L=M+1;\n    }\n    printf(\"%d\\n\",L);\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n \ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n \n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n\n#define F first\n#define S second\n\n\n\nconst int M = 5 * ten(4) + 100;\nconst int inf = ten(8);\n\nint w, n, x[M];\nint sum_x[M];\n\n// [i, j]\nbool can_place_in_line(int i, int j)\n{\n    int rem_space = w - (sum_x[j + 1] - sum_x[i]);\n    int num_interval = j - i;\n    return num_interval > 0 && rem_space >= num_interval;\n}\n// [i, j]\nint max_space(int i, int j)\n{\n    int rem_space = w - (sum_x[j + 1] - sum_x[i]);\n    int num_interval = j - i;\n    if (num_interval > 0 && rem_space >= num_interval)\n        return (rem_space + (num_interval - 1)) / num_interval;\n    else\n        return inf;\n}\nbool can_place_in_last(int i)\n{\n    int rem_space = w - (sum_x[n] - sum_x[i]);\n    int num_interval = n - i - 1;\n    return rem_space >= num_interval;\n}\nbool check(int upper_space)\n{\n    int dp[M]; // can place i in beginning if sum_x[i=0..i](dp[i]) > 0\n    fill_n(dp, n + 1, 0);\n    dp[0] = 1;\n    dp[1] = -1;\n\n    int left = 0, right = 0;\n    rep(i, n)\n    {\n        if (dp[i] > 0)\n        {\n            // can place [i..j](j = [left..right)) in one line\n            chmax(left, i + 1);\n            while (left < n && can_place_in_line(i, left) && max_space(i, left) > upper_space)\n                ++left;\n\n            chmax(right, left + 1);\n            while (right < n && can_place_in_line(i, right) && max_space(i, right) <= upper_space)\n                ++right;\n\n            if (max_space(i, left) <= upper_space)\n            {\n                ++dp[left + 1];\n                --dp[right + 1];\n            }\n        }\n\n        dp[i + 1] += dp[i];\n    }\n\n    rep(i, n)\n        if (dp[i] && can_place_in_last(i))\n            return true;\n    return false;\n}\nint main()\n{\n    while (scanf(\"%d%d\", &w, &n), n)\n    {\n        rep(i, n)\n            scanf(\"%d\", x + i);\n\n        sum_x[0] = 0;\n        rep(i, n)\n            sum_x[i + 1] = sum_x[i] + x[i];\n\n        int low = 0, high = w - 2;\n        while (high - low > 1)\n        {\n            int mid = (low + high) / 2;\n            if (check(mid))\n                high = mid;\n            else\n                low = mid;\n        }\n        printf(\"%d\\n\", high);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint x[100000], dat[100000], n, W, dp[100000];\nvoid add(int p, int q) {\n\twhile (p <= n) {\n\t\tdat[p] += q;\n\t\tp += p&-p;\n\t}\n}\nint sum(int p) {\n\tint sum2 = 0;\n\twhile (p >= 1) {\n\t\tsum2 += dat[p];\n\t\tp -= p&-p;\n\t}\n\treturn sum2;\n}\nint Rangesum(int W1, int W2) {\n\treturn sum(W2) - sum(W1 - 1);\n}\nint hantei(int L1, int R1) {\n\tif (L1 == 0)return 2147000000;\n\tint E = Rangesum(L1, R1);\n\tE += (R1 - L1);\n\treturn E;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> W >> n; for (int i = 0; i < 100000; i++) { dat[i] = 0; dp[i] = 999999999; }\n\t\tif (n == 0 && W == 0)break;\n\t\tfor (int i = 1; i <= n; i++)cin >> x[i]; add(1, x[1]); dp[0] = 1;\n\t\tfor (int i = 2; i <= n - 1; i++) {\n\t\t\tadd(i, x[i]);\n\t\t\tint L = 1, R = i, M = 0;\n\t\t\twhile (true) {\n\t\t\t\tM = (L + R) / 2;\n\t\t\t\tint V1 = hantei(M, i);\n\t\t\t\tint V2 = hantei(M - 1, i);\n\t\t\t\tif (V1 <= W && V2 > W) {\n\t\t\t\t\tfor (int j = M; j < i; j++) {\n\t\t\t\t\t\tif (j != M && dp[j - 1] <= dp[j])break;\n\t\t\t\t\t\tint KO = i - j;\n\t\t\t\t\t\tint V1 = hantei(j, i);\n\t\t\t\t\t\tdp[i] = min(dp[i], max(dp[j - 1], ((W - V1) + KO - 1) / KO + 1));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (V1 > W)L = M;\n\t\t\t\tif (V2 <= W)R = M;\n\t\t\t}\n\t\t}\n\t\tadd(n, x[n]); int minx = 999999999;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (Rangesum(i + 1, n) + (n - (i + 1)) <= W)minx = min(minx, dp[i]);\n\t\t}\n\t\tcout << minx << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint w,n;\nint x[50005];\nbool dp[50005];\n\nbool C(int v){\n\tmemset(dp,false,sizeof(dp));\n\tdp[0]=true;\n\tint l=0,r=0;\n\tint cnt=0;\n\tint wmax=0,wmin=0;\n\tfor(int i=0;i<n;i++){\n\t\twhile(r<i && wmax+x[i]>=w){\n\t\t\tif(dp[r])cnt++;\n\t\t\twmax-=x[r]+v;\n\t\t\tr++;\n\t\t}\n\t\tif(i==(n-1)){\n\t\t\twhile(r<=i){\n\t\t\t\tif(dp[r])cnt++;\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t\twhile(l<r && wmin+x[i]>w){\n\t\t\tif(dp[l])cnt--;\n\t\t\twmin-=x[l]+1;\n\t\t\tl++;\n\t\t}\n\t\twmax+=x[i]+v;\n\t\twmin+=x[i]+1;\n\t\tif(cnt>0){\n\t\t\tdp[i+1]=true;\n\t\t}\n\t}\n\treturn (dp[n] || dp[n-1]);\n}\n\nvoid solve(){\n\tint l=0,r=w;\n\twhile(l+1<r){\n\t\tint mid=(l+r)/2;\n\t\tif(C(mid))r=mid;\n\t\telse l=mid;\n\t}\n\tprintf(\"%d\\n\",r);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&w,&n);\n\t\tif(w==0 && n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&x[i]);\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\nint W,N,x[50000],sum[50001];\nbool can(int x){\n\tbool dp[50001]={};\n\tint imos[50002]={};\n\tdp[0]=true;\n\timos[1]=1;\n\tfor(int i=2;i<=N;i++){\n\t\tint lb=1,ub=i+1;\n\t\twhile(ub-lb>1){\n\t\t\tint m=(ub+lb)/2;\n\t\t\tif(W-(sum[i]-sum[i-m])>=m-1) lb=m;\n\t\t\telse ub=m;\n\t\t}\n\t\tint r=lb;\n\t\tlb=1,ub=i+1;\n\t\twhile(ub-lb>1){\n\t\t\tint m=(lb+ub)/2;\n\t\t\tif(W-(sum[i]-sum[i-m])<=(long long)(m-1)*x) ub=m;\n\t\t\telse lb=m;\n\t\t}\n\t\tint l=ub;\n\t\tif(imos[i-l+1]-imos[i-r]>0) dp[i]=true;\n\t\timos[i+1]=imos[i]+(dp[i]?1:0);\n\t}\n\tfor(int i=N;i>=0;i--){\n\t\tif(sum[N]-sum[i]+(N-1-i)>W) break;\n\t\tif(dp[i]) return true;\n\t}\n\treturn false;\n}\nint main(){\n\twhile(true){\n\t\tcin>>W>>N;\n\t\tif(W==0) return 0;\n\t\trep(i,N) cin>>x[i];\n\t\trep1(i,N) sum[i]=sum[i-1]+x[i-1];\n\t\tint ub=W,lb=0;\n\t\twhile(ub-lb>1){\n\t\t\tint m=(ub+lb)/2;\n\t\t\tif(can(m)) ub=m;\n\t\t\telse lb=m;\n\t\t}\n\t\tcout<<ub<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll W, N;\nll x[50000];\nll xsum[50010];\nint dp[50010];\nint trueSum[50010];\n\n// [l, r]\nll minw(int l, int r){\n\tll sum = xsum[r + 1] - xsum[l] + (r - l);\n\tif(sum > W) return -1;\n\tll rem = W - (xsum[r + 1] - xsum[l]);\n\treturn (rem + (r - l - 1)) / (r - l);\n}\n\nbool check(int w){\n\tmemset(trueSum, 0, sizeof trueSum);\n\ttrueSum[1] = 1;\n\tmemset(dp, 0, sizeof dp);\n\tdp[0] = 1;\n\tint L = 0, R = 0;\n\tfor(int i = 1; i < N; i++){\n\t\t/*int L, R;\n\t\t{\n\t\t\tint ng = -1, ok = i - 1;\n\t\t\twhile(abs(ng - ok) > 1){\n\t\t\t\tint mid = (ng + ok) / 2;\n\t\t\t\tint mw = minw(mid, i);\n\t\t\t\tif(mw != -1) ok = mid;\n\t\t\t\telse ng = mid;\n\t\t\t}\n\t\t\tL = ok;\n\t\t\tif(minw(L, i) > w){\n\t\t\t\ttrueSum[i + 2] = trueSum[i + 1];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint ok = L, ng = i;\n\t\t\twhile(abs(ng - ok) > 1){\n\t\t\t\tint mid = (ng + ok) / 2;\n\t\t\t\tint mw = minw(mid, i);\n\t\t\t\tif(mw <= w) ok = mid;\n\t\t\t\telse ng = mid;\n\t\t\t}\n\t\t\tR = ok;\n\t\t}*/\n\t\twhile(L < i && minw(L, i) == -1) L++;\n\t\twhile(R + 1 < i && minw(R + 1, i) <= R) R++;\n\t\tif(R < L) continue;\n\t\tif(minw(L, i) > w || minw(R, i) > w) continue;\n\t\tassert(minw(L, i) <= w && minw(R, i) <= w);\n\t\tint s = trueSum[R + 1] - trueSum[L];\n\t\tif(s >= 1){\n\t\t\tdp[i + 1] = 1;\n\t\t\ttrueSum[i + 2] = trueSum[i + 1] + 1;\n\t\t\t// ???????????????????????????????????°ok\n\t\t\tll sum = xsum[N] - xsum[i + 1] + (N - i - 2);\n\t\t\tif(sum <= W) return true;\n\t\t}\n\t\telse{\n\t\t\ttrueSum[i + 2] = trueSum[i + 1];\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\twhile(cin >> W >> N, W + N){\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> x[i];\n\t\t\txsum[i + 1] = xsum[i] + x[i];\n\t\t}\n\n\t\tll sum = xsum[N] + N - 1;\n\t\tif(sum <= W){\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint ng = 0, ok = W;\n\t\twhile(abs(ng - ok) > 1){\n\t\t\tint mid = (ng + ok) / 2;\n\t\t\tif(check(mid)) ok = mid;\n\t\t\telse ng = mid;\n\t\t}\n\t\tcout << ok << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint dat[2 * (1 << 17) - 1]; // = 131072\nclass SegT{\nprivate:\n  int NN;\n\npublic:\n  SegT(int n_){\n\tNN = 1;\n\twhile(NN < n_) NN <<= 1;\n\tfor(int i=0;i<2*NN-1;++i) dat[i] = 0;\n  }\n\n  void update(int idx, int a){\n\tidx += NN - 1;\n\tdat[idx] += a;\n\twhile(idx > 0){\n\t  idx = (idx - 1) / 2;\n\t  dat[idx] = dat[idx*2+1] + dat[idx*2+2];\n\t}\n  }\n\n  int query(int a, int b, int k, int l, int r){\n\tif(r <= a || b <= l) return 0;\n\tif(a <= l && r <= b) return dat[k];\n\telse{\n\t  int vl = query(a, b, k*2+1, l, (l+r)/2);\n\t  int vr = query(a, b, k*2+2, (l+r)/2, r);\n\t  return vl + vr;\n\t}\n  }\n  int query(int a, int b){\n\tif(a >= b) return 0;\n\treturn query(a, b, 0, 0, NN);\n  }\n  int read(int i){\n\treturn dat[NN-1+i];\n  }\n};\n\nLL W, N;\nint fub(int i, VL& acc){\n  int lb = i+1, ub = N+1;\n  while(ub-lb>1){\n\tint m = (lb+ub)/2;\n\tif(acc[m] - acc[i] + (m-i-1) <= W)\n\t  lb = m;\n\telse\n\t  ub = m;\n  }\n  return lb;\n}\n\nint xs[50010];\nLL acc[50010];\nint main(){\n  while(scanf(\"%lld%lld\", &W, &N),N){\n\tVI xs(N);\n\tVL acc(N+1);\n\tREP(i,N){\n\t  scanf(\"%d\", &xs[i]);\n\t  acc[i+1] = acc[i] + xs[i];\n\t}\n\n\tVI lbu(N);\n\tREP(i,N) lbu[i] = fub(i, acc);\n\tVI ubl(N);\n\t\n\tSegT seg(N+10);\n\tfor(int i=N;i>=0;--i){\n\t  LL sp = W - (acc[N] - acc[i]);\n\t  if(N-1-i <= sp)\n\t\tseg.update(i, 1);\n\t  else{\n\t\tbreak;\n\t  }\n\t}\n\t\n\tint lb = 0, ub = W;\n\tVI rev;\n\twhile(ub-lb>1){\n\t  LL L = (lb + ub)/2;\n\n\t  int r = N;\n\t  for(int i=N-1;i>=0;--i){\n\t\twhile(r >= 0 && (acc[r] - acc[i] + (r-i-1)*L >= W)) --r;\n\t\tif(seg.read(i)) continue;\n\n\t\tint ubl = r+1;\n\t\tif(seg.query(ubl, lbu[i]+1)){\n\t\t  seg.update(i, 1);\n\t\t  rev.PB(i);\n\t\t}\n\t  }\n\t  if(seg.read(0)){\n\t\tub = L;\n\n\t\tfor(int x: rev)\n\t\t  seg.update(x, -1);\n\t\trev.clear();\n\t  }\n\t  else{\n\t\tlb = L;\n\t  }\n\t}\n\tprintf(\"%d\\n\", ub);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll W, N;\nll x[50000];\nll xsum[50010];\nint dp[50010];\nint trueSum[50010];\n\n// [l, r]\nll minw(int l, int r){\n\tll sum = xsum[r + 1] - xsum[l] + (r - l);\n\tif(sum > W) return -1;\n\tll rem = W - (xsum[r + 1] - xsum[l]);\n\treturn (rem + (r - l - 1)) / (r - l);\n}\n\nbool check(int w){\n\tmemset(trueSum, 0, sizeof trueSum);\n\ttrueSum[1] = 1;\n\tmemset(dp, 0, sizeof dp);\n\tdp[0] = 1;\n\tfor(int i = 1; i < N; i++){\n\t\tint L, R;\n\t\t{\n\t\t\tint ng = -1, ok = i - 1;\n\t\t\twhile(abs(ng - ok) > 1){\n\t\t\t\tint mid = (ng + ok) / 2;\n\t\t\t\tint mw = minw(mid, i);\n\t\t\t\tif(mw != -1) ok = mid;\n\t\t\t\telse ng = mid;\n\t\t\t}\n\t\t\tL = ok;\n\t\t\tif(minw(L, i) > w){\n\t\t\t\ttrueSum[i + 2] = trueSum[i + 1];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint ok = L, ng = i;\n\t\t\twhile(abs(ng - ok) > 1){\n\t\t\t\tint mid = (ng + ok) / 2;\n\t\t\t\tint mw = minw(mid, i);\n\t\t\t\tif(mw <= w) ok = mid;\n\t\t\t\telse ng = mid;\n\t\t\t}\n\t\t\tR = ok;\n\t\t}\n\t\tassert(minw(L, i) <= w && minw(R, i) <= w);\n\t\tint s = trueSum[R + 1] - trueSum[L];\n\t\tif(s >= 1){\n\t\t\tdp[i + 1] = 1;\n\t\t\ttrueSum[i + 2] = trueSum[i + 1] + 1;\n\t\t\t// ???????????????????????????????????°ok\n\t\t\tll sum = xsum[N] - xsum[i + 1] + (N - i - 2);\n\t\t\tif(sum <= W) return true;\n\t\t}\n\t\telse{\n\t\t\ttrueSum[i + 2] = trueSum[i + 1];\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\twhile(cin >> W >> N, W + N){\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> x[i];\n\t\t\txsum[i + 1] = xsum[i] + x[i];\n\t\t}\n\n\t\tll sum = xsum[N] + N - 1;\n\t\tif(sum <= W){\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint ng = 0, ok = W;\n\t\twhile(abs(ng - ok) > 1){\n\t\t\tint mid = (ng + ok) / 2;\n\t\t\tif(check(mid)) ok = mid;\n\t\t\telse ng = mid;\n\t\t}\n\t\tcout << ok << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint x[100000], dat[100000], n, W, dp[100000];\nvoid add(int p, int q) {\n\twhile (p <= n) {\n\t\tdat[p] += q;\n\t\tp += p&-p;\n\t}\n}\nint sum(int p) {\n\tint sum2 = 0;\n\twhile (p >= 1) {\n\t\tsum2 += dat[p];\n\t\tp -= p&-p;\n\t}\n\treturn sum2;\n}\nint Rangesum(int W1, int W2) {\n\treturn sum(W2) - sum(W1 - 1);\n}\nint hantei(int L1, int R1) {\n\tif (L1 == 0)return 2147000000;\n\tint E = Rangesum(L1, R1);\n\tE += (R1 - L1);\n\treturn E;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> W >> n; for (int i = 0; i < 100000; i++) { dat[i] = 0; dp[i] = 999999999; }\n\t\tif (n == 0 && W == 0)break;\n\t\tfor (int i = 1; i <= n; i++)cin >> x[i]; add(1, x[1]); dp[0] = 1;\n\t\tfor (int i = 2; i <= n - 1; i++) {\n\t\t\tadd(i, x[i]);\n\t\t\tint L = 1, R = i, M = 0;\n\t\t\twhile (true) {\n\t\t\t\tM = (L + R) / 2;\n\t\t\t\tint V1 = hantei(M, i);\n\t\t\t\tint V2 = hantei(M - 1, i);\n\t\t\t\tif (V1 <= W && V2 > W) {\n\t\t\t\t\tint ret = dp[M - 1];\n\t\t\t\t\tfor (int j = M; j < i; j++) {\n\t\t\t\t\t\tif (j != M && ret <= dp[j - 1])continue;\n\t\t\t\t\t\tint KO = i - j;\n\t\t\t\t\t\tint V1 = hantei(j, i);\n\t\t\t\t\t\tdp[i] = min(dp[i], max(dp[j - 1], ((W - V1) + KO - 1) / KO + 1));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (V1 > W)L = M;\n\t\t\t\tif (V2 <= W)R = M;\n\t\t\t}\n\t\t}\n\t\tadd(n, x[n]); int minx = 999999999;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (Rangesum(i + 1, n) + (n - (i + 1)) <= W)minx = min(minx, dp[i]);\n\t\t}\n\t\tcout << minx << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\nstruct aa {\n\tlong long int next;\n\tlong long int sum;\n};\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<long long int>nums(M);\n\t\tvector<aa>as;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tas.push_back(aa{ -1,-1 });\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tcin >> nums[i];\n\t\t}\n\t\tlong long int ans = -1;\n\t\tfor (int i = N - 2; i >= 1; --i) {\n\t\t\t\n\t\t\tbool ok = true;\n\t\t\tint now = 0;\n\t\t\twhile (now!=M) {\n\t\t\t\tint sum = 0;\n\t\t\t\tint start;\n\t\t\t\tif (as[now].next == -1) {\n\t\t\t\t\tstart = now;\n\t\t\t\t\tsum = nums[now];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstart = as[now].next;\n\t\t\t\t\tsum = as[now].sum + (as[now].next - now)*i;\n\t\t\t\t}\n\t\t\t\tint anow = start;\n\t\t\t\twhile (anow +1 != M) {\n\t\t\t\t\tsum += i + nums[anow + 1];\n\t\t\t\t\tif (sum == N) {\n\t\t\t\t\t\tas[now].next = anow+1;\n\t\t\t\t\t\tas[now].sum = sum - (anow - now+1)*i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (sum > N) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tas[now].next = anow;\n\t\t\t\t\t\tas[now].sum = sum - (i + nums[anow + 1]) - (anow - now)*i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tanow++;\n\t\t\t\t}\n\t\t\t\tif (anow + 1 == M) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (!ok) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnow = anow + 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tans = i;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\n\nint W, N;\nint X[50010];\nint f[50010], s[50010];\n\nvoid read();\nvoid soups_on();\nbool yee_haw(int);\n\nint main() {\n  ios::sync_with_stdio(false);\n  while (cin >> W >> N, W + N)\n    read(), soups_on();\n\n  return 0;\n}\n\nvoid read() {\n  X[0] = W, X[N + 1] = W;\n  for (int i = 1; i <= N; ++i)\n    cin >> X[i];\n  partial_sum(X, X + (N + 2), X);\n}\n\nvoid soups_on() {\n  int low = 1, up = W, mid;\n\n  while (low < up) {\n    mid = (low + up) / 2;\n    if (yee_haw(mid))\n      up = mid;\n    else\n      low = mid + 1;\n  }\n\n  cout << low << \"\\n\";\n}\n\nbool yee_haw(int lm) {\n  int lb, ub, sum = 0, p;\n\n  fill(&f[0], &f[N + 2], 0), lb = ub = 0;\n  for (int i = 0; i <= N; ++i) {\n    sum += f[i], s[i] = sum;\n    if (i == 0 || sum > 0) {\n      lb = max(lb, i + 1);\n      while (lb <= N && (X[lb] - X[i]) + lm * (lb - i - 1) < W)\n        ++lb;\n      ub = max(ub, i + 1);\n      while (ub <= N && (X[ub] - X[i]) + (ub - i - 1) <= W)\n        ++ub;\n      ++f[lb], --f[ub];\n    }\n  }\n\n  p = 0, s[0] = 1;\n  for (int i = N; i >= 0 && p <= W; --i) {\n    if (s[i] > 0)\n      return true;\n    p = (X[N] - X[i - 1]) + (N - i);\n  }\n\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint w, n, x[50000], dp[50010];\nll s[50010];\n\nint cost(int i, int j){\n\tassert(i + 1 < j);\n\t//if(i + 1 == j) return inf;\n\tll len = s[j] - s[i];\n\tif(len + j - i - 1 > w) return inf;\n\treturn (w - len + j - i - 2) / (j - i - 1);\n}\n\nint main(){\n\twhile(cin >> w >> n, w){\n\t\trep(i, n){\n\t\t\tcin >> x[i];\n\t\t\ts[i + 1] = s[i] + x[i];\n\t\t\tdp[i + 1] = inf;\n\t\t}\n\t\t\n\t\tdp[0] = 1;\n\t\tint j = 0, ans = inf;\n\t\trep(i, n){\n\t\t\tif(i >= n - 1 || cost(i, n) < inf){\n\t\t\t\tans = min(ans, dp[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile(j <= i + 1) j++;\n\t\t\twhile(j <= n){\n\t\t\t\tif(cost(i, j) >= inf) break;\n\t\t\t\tdp[j] = min(dp[j], max(dp[i], cost(i, j)));\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include<cstring>\nusing namespace std;\nint n,w, len[51111],psum[51111];\nstruct SegTree{\n\tint n, seg[401111];\n\tvoid init(int _n){\n\t\tn=_n;\n\t\tfill(seg,seg+8*n,0);\n\t}\n\tvoid set(int i, int x){\n\t\t// printf(\"[%d] = %d\\n\",i,x);\n\t\tset(i,x,0,n,0);\n\t}\n\tint qmax(int l, int r){\n\t\t// printf(\"%d - %d:  %d\\n\",l,r,qmax(l,r,0,n,0));\n\t\treturn qmax(l,r,0,n,0);\n\t}\n\tvoid set(int i, int x, int sl, int sr, int sid){\n\t\tif(sr<=i || i<sl)return;\n\t\tif(sr-sl<=1){\n\t\t\tseg[sid]=x; return;\n\t\t}\n\t\tset(i, x, sl, (sl+sr)/2, sid*2+1);\n\t\tset(i, x, (sl+sr)/2, sr, sid*2+2);\n\t\tseg[sid] = max(seg[sid*2+1], seg[sid*2+2]);\n\t}\n\tint qmax(int l, int r, int sl, int sr, int sid){\n\t\tif(sr<=l || r<=sl)return 0;\n\t\tif(l<=sl && sr<=r)return seg[sid];\n\t\treturn max(qmax(l, r, sl, (sl+sr)/2, sid*2+1), qmax(l, r, (sl+sr)/2, sr, sid*2+2));\n\t}\n}st;\nint ceiling(int x, int y){\n\tif(y==0){\n\t\tprintf(\"QQ %d %d\\n\",x,y);\n\t\t// while(1);\n\t}\n\treturn (x-1)/y+1;\n}\nbool check(int d){\n\t// printf(\"\\t\\t\\td = %d\\n\",d);\n\tstatic int dp[51111];\n\t// memset(dp,0,sizeof(dp));\n\tfill(dp,dp+n,0);\n\tst.init(n);\n\n\tfor(int i=1; i<n; i++){\n\t\t// printf(\" i= %d\\n\",i);\n\t\tint lb=-1, ub=i-1, b, a;\n\t\twhile(1<ub-lb){\n\t\t\tint md=(lb+ub)/2;\n\t\t\tif(ceiling(w-psum[i+1]+psum[md+1], i-md-1)<=d)\n\t\t\t\tlb=md;\n\t\t\telse\n\t\t\t\tub=md;\n\t\t}\n\t\tb=lb;\n\t\tlb=-1, ub=i;\n\t\twhile(1<ub-lb){\n\t\t\tint md=(lb+ub)/2;\n\t\t\tif(psum[i+1]-psum[md+1]+i-md-1<=w)\n\t\t\t\tub=md;\n\t\t\telse\n\t\t\t\tlb=md;\n\t\t}\n\t\ta= ub;\n\t\t// printf(\"%d - %d\\n\",a,b);\n\t\tif(psum[i+1]+i<=w && ceiling(w-psum[i+1], i)<=d)dp[i]=1;\n\t\t// printf(\"%d<=%d && %d/%d<=%d\\n\", psum[i+1]+i,w, w-psum[i+1], i, d);\n\t\tif(a<=b)\n\t\t\tdp[i] = st.qmax(a,b+1);\n\t\tst.set(i,dp[i]);\n\t\t// printf(\"dp(%d) = %d\\n\",i,dp[i]);\n\t}\n\tint res=0;\n\tfor(int i=0; i<n-1; i++){\n\t\tif(psum[n]-psum[i+1]+n-i-1<=w)\n\t\t\tres = max(res, dp[i]);\n\t}\n\n\treturn res || dp[n-1] || psum[n]+n-1<=w;\n\n}\nint main(){\n\twhile(scanf(\"%d%d\",&w,&n)&&(n+w>0)){\n\t\tfor(int i=0; i<n; i++)scanf(\"%d\",&len[i]);\n\t\tpsum[0]=0;\n\t\tfor(int i=0; i<n; i++)psum[i+1] = psum[i]+len[i];\n\t\tint lb=0, ub=w;\n\t\twhile(1<ub-lb){\n\t\t\tint md=(lb+ub)/2;\n\t\t\tif(check(md))\n\t\t\t\tub=md;\n\t\t\telse\n\t\t\t\tlb=md;\n\t\t}\n\t\tprintf(\"%d\\n\",ub);\n\t}\n}\n\n/*\n\n11 4\n4 2 1 3\n5 7\n1 1 1 2 2 1 2\n11 7\n3 1 3 1 3 3 4\n100 3\n30 30 39\n30 3\n2 5 3\n0 0\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <map>\n#include <stack>\n#include <vector>\n#include <set>\n#include <queue>\n#define maxn 50005\n#define MAXN 200005\n#define mod 1000000007\n#define INF 0x3f3f3f3f\n#define eps 1e-6\nconst double pi=acos(-1.0);\ntypedef long long ll;\nusing namespace std;\n\nint n,w;\nint len[maxn],sum[maxn];\nbool dp[maxn];\n\nbool isok(int mid)\n{\n    int i,j,last=0;\n    memset(dp,0,sizeof(dp));\n    dp[0]=1;\n    if(sum[n]+n-1<=w) return true ;\n    for(i=0; i<n-1; i++)\n    {\n        if(!dp[i]) continue ;\n        for(j=max(i+2,last); j<=n; j++)\n        {\n            if(w<sum[j]-sum[i]+j-i-1) break ;\n            if(w>sum[j]-sum[i]+ll(j-i-1)*mid) continue ;\n            last=j;\n            dp[j]=1;\n            if(sum[n]-sum[j]+n-j-1<=w) return true ;\n        }\n    }\n    return false ;\n}\nvoid solve()\n{\n    int i,j,le=1,ri=w,mid,ans;\n    while(le<=ri)\n    {\n        mid=(le+ri)>>1;\n        if(isok(mid))\n        {\n            ans=mid;\n            ri=mid-1;\n        }\n        else le=mid+1;\n    }\n    printf(\"%d\\n\",ans);\n}\nint main()\n{\n    int i,j;\n    while(~scanf(\"%d%d\",&w,&n))\n    {\n        if(w==0&&n==0) break ;\n        sum[0]=0;\n        for(i=1; i<=n; i++)\n        {\n            scanf(\"%d\",&len[i]);\n            sum[i]=sum[i-1]+len[i];\n        }\n        solve();\n    }\n    return 0;\n}\n/*\n11 4\n4 2 1 3\n5 7\n1 1 1 2 2 1 2\n11 7\n3 1 3 1 3 3 4\n100 3\n30 30 39\n30 3\n2 5 3\n0 0\n*/"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for(auto i = (c).begin(); i != (c).end(); ++i)\n#define BIT(n, m) (((n) >> (m)) & 1)\n\ntypedef long long ll;\ntypedef pair<int, int> PI;\n\nconst ll inf = 1e15;\nconst ll mod = 1000 * 1000 * 1000 + 7;\nconst double eps = 1e-9;\n\ntemplate <typename S, typename T> ostream &operator<<(ostream &out, const pair<S, T> &p) {\n  out << \"(\" << p.first << \", \" << p.second << \")\";\n  return out;\n}\n\ntemplate <typename T> ostream &operator<<(ostream &out, const vector<T> &v) {\n  out << \"[\";\n  REP(i, v.size()){\n    if (i > 0) out << \", \";\n    out << v[i];\n  }\n  out << \"]\";\n  return out;\n}\n\nbool check(const vector<int> &V, ll W, ll L){\n  vector<ll> sum1(V.size() + 1);\n  vector<ll> sumL(V.size() + 1);\n  REP(i, V.size()){\n    sum1[i + 1] = sum1[i] + V[i] + 1;\n    sumL[i + 1] = sumL[i] + V[i] + L;\n  }\n  \n  vector<int> dp(V.size() + 1); // dp[i] = V[0..i)???valid?????????\n  dp[0] = 0;\n  dp[1] = 1;\n  dp[2] = 1;\n  \n  REP2(i, 2, V.size()){\n    // int llb = -1;\n    // int lub =\n    // find max x s.t. sum of V[i - x, i) + (x - 1) <= W\n    int left  = i - 2;\n    int right = i - 1;\n    {\n      int  lb = -1;\n      int &ub = left;\n      while (ub - lb > 1){\n        int mb = (ub + lb) >> 1;\n        ll  sum = sum1[i] - sum1[mb] - 1;\n        // cout << sum << endl;\n        if (sum <= W) ub = mb;\n        else lb = mb;\n      }\n    }\n\n    {\n      int  lb = 0;\n      int &ub = right;\n      while (ub - lb > 1){\n        int mb = (lb + ub) >> 1;\n        ll  sum = sumL[i] - sumL[mb] - L;\n        if (sum < W) ub = mb;\n        else lb = mb;\n      }\n    }\n    // find min x s.t. sum of V[i - x, i) + L * (x - 1) < W\n    // cout << i << \" \" <<  L << \"  \" << left << \" \" << right << endl;\n    if (right > left && dp[right] > dp[left] && sumL[i] - L >= W){\n      dp[i + 1] = dp[i] + 1;\n    } else {\n      dp[i + 1] = dp[i];\n    }\n  } \n\n  bool res = false;\n  REP(i, V.size()){\n    ll sum = sum1[V.size()] - sum1[i] - 1;\n    if (sum <= W) res = res || dp[i + 1] > dp[i];\n  }\n  return res;\n}\n\nint main(){\n  int W, N;\n  while (cin >> W >> N && W){\n    vector<int> V(N);\n    REP(i, N) cin >> V[i];\n\n    int ub = W;\n    int lb = 0;\n    // cout << check(V, W, 1) << endl;\n    while (ub - lb > 1){\n      int mb = (ub + lb) >> 1;\n      if (check(V, W, mb)) ub = mb;\n      else lb = mb;\n    }\n    cout << ub << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename V> class segtree {\nprivate:\n    int n,sz; vector<V> node, lazy; vector<bool> lazyFlag;\npublic:\n    segtree(vector<V>& v) {\n        sz = (int)v.size(); n = 1;\n        while(n < sz) n *= 2;\n        node.resize(2*n-1); lazy.resize(2*n-1); lazyFlag.resize(2*n-1,false);\n        rep(i,sz) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = min(node[i*2+1],node[i*2+2]);\n    }\n    void eval(int k, int l, int r) {\n        if(lazyFlag[k]){\n            node[k] = lazy[k];\n            if(r - l > 1) {\n                lazy[k*2+1] = lazy[k*2+2] = lazy[k]; lazyFlag[k*2+1] = lazyFlag[k*2+2] = true;\n            }\n            lazyFlag[k] = false;\n        }\n    }\n    void range(int a, int b, V x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b){\n            lazy[k] = x; lazyFlag[k] = true; eval(k, l, r);\n        }else{\n            range(a, b, x, 2*k+1, l, (l+r)/2); range(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = min(node[2*k+1],node[2*k+2]);\n        }\n    }\n    V query(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return numeric_limits<V>::max();\n        if(a <= l && r <= b) return node[k];\n        V vl = query(a, b, 2*k+1, l, (l+r)/2), vr = query(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl,vr);\n    }\n    void print(){rep(i,sz)cout<<query(i,i+1)<< \" \";cout<<endl;}\n};\n\nint w,n;\n\nbool ok1(vi& sm,int st,int cri)\n{\n    int diff = sm[st+cri]-sm[st]+cri-1;\n    return diff <= w;\n}\n\nbool ok2(vi& sm,int st,int cri,int d)\n{\n    int diff = sm[st+cri]-sm[st]+(cri-1)*d;\n    return w <= diff;\n}\n\nbool possible(vi& sm,int d)\n{\n    vi dp(n+1,0);\n    dp[0] = 1;\n    segtree<int> sg(dp);\n    rep(i,n){\n        if(sg.query(i,i+1)){\n            int lb,rb;\n            if(ok1(sm,i,n-i)){\n                lb = n;\n            }else{\n                int l = 2,r = n-i;\n                while(r-l>1){\n                    int mid = (l+r)/2;\n                    if(ok1(sm,i,mid)){\n                        l = mid;\n                    }else{\n                        r = mid;\n                    }\n                }\n                lb = i+l;\n            }\n            if(ok2(sm,i,2,d)){\n                rb = i+2;\n            }else{\n                int l = 2,r = n-i;\n                while(r-l>1){\n                    int mid = (l+r)/2;\n                    if(ok2(sm,i,mid,d)){\n                        r = mid;\n                    }else{\n                        l = mid;\n                    }\n                }\n                rb = i+r;\n            }\n            if(rb <= lb){\n                sg.range(rb,lb+1,1);\n            }\n        }\n    }\n    if(sg.query(n,n+1)){\n        return true;\n    }\n    rrep(i,n){\n        if(sg.query(i,i+1)){\n            if(sm[n]-sm[i]+(n-i-1) <= w){\n                return true;\n            }else{\n                return false;\n            }\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        cin >> w >> n;\n        if(w + n == 0){\n            break;\n        }\n        vi vec(n),sm(n+1);\n        rep(i,n){\n            cin >> vec[i];\n        }\n        sm[0] = 0;\n        rep(i,n){\n            sm[i+1] = sm[i] + vec[i];\n        }\n        // possible(sm,1);\n        int l = 0,r = w;\n        while(r-l>1){\n            int mid = (l+r)/2;\n            if(possible(sm,mid)){\n                r = mid;\n            }else{\n                l = mid;\n            }\n        }\n        cout << r << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\narray<int,(int)(1e5)> ok;\narray<int,(int)(1e5)> oksum;\narray<ll,100000> ubs;\narray<ll,100000> sumx;\n\nbool check(int w,int n,ll sp){\n    fill(ok.begin(),ok.begin()+n+1,false);\n    fill(oksum.begin(),oksum.begin()+n+2,false);\n    ok[n]=true;\n    ok[n-1]=true;\n    oksum[n+1]=0;\n    oksum[n]=1;\n    oksum[n-1]=2;\n    for(int i=n-2;i>=0;i--){\n        //cerr<<\"1check\"<<i<<endl;\n        int j=ubs[i];\n        int lb=i+1; //[i,lb)de tarinai\n        int ub=j;\n        while(ub-lb>1){\n            int mid=((lb+ub)>>1);\n            ll mot=w-(sumx[mid]-sumx[i]);\n            ll chi=mid-i-1;\n            //floor((mot+chi-1)/chi)>sp\n            //\n            if(mot>sp*chi){\n                lb=mid;\n            }\n            else{\n                ub=mid;\n            }\n        }\n        //cerr<<\"2check\"<<i<<endl;\n        int b=ub;\n        //check [b,j)\n        if(j==n+1 || oksum[b]-oksum[j]>0){\n            ok[i]=true;\n        }\n        else{\n            ok[i]=false;\n        }   \n        //cerr<<\"#\"<<i<<\" \"<<b<<\" \"<<j<<\" \"<<ok[i]<<endl;\n        oksum[i]=oksum[i+1]+ok[i];\n    }\n    //cerr<<sp<<endl;\n    //string buf;\n    //cin>>buf;\n    \n    return ok[0];\n}\n\nint solve(int w,int n){\n    vector<ll> x(n);\n    for(int i=0;i<n;i++) cin>>x[i];\n    for(int i=0;i<n;i++){\n        sumx[i+1]=sumx[i]+x[i];\n    }\n    for(int i=n-2;i>=0;i--){\n        int lb=i;\n        int ub=n+1;\n        //cerr<<\"check\"<<i<<endl;\n        //[i,lb) is ok\n        //w-(sumx[lb]-sumx[i])>=lb-i-1\n        //w+i+1>=sumx[lb]-sumx[i]+lb\n        while(ub-lb>1){\n            int mid=(lb+ub)/2;\n            ll sux=sumx[mid]-sumx[i]+mid;\n        //cerr<<\"#\"<<mid<<\" \"<<sux<<\" \"<<w+i+1<<endl;\n            if(w+i+1>=sux){\n                lb=mid;\n            }\n            else{\n                ub=mid;\n            }\n        }\n        ubs[i]=ub;\n    }\n    int lb=0;   \n    int ub=w;\n    //cerr<<\"End summation\"<<endl;\n    while(ub-lb>1){\n        int mid=(lb+ub)/2;\n        if(!check(w,n,mid)){\n            lb=mid;\n        }\n        else{\n            ub=mid;\n        }\n    }\n    return ub;\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    int w,n;\n    while(cin>>w>>n,w){\n        cout<<solve(w,n)<<\"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\nint N,W;\nint table[50005],ruisekiwa[50005];\nbool check[50005];\n\nbool one_line_check(int left,int right){ //left～rightの単語を一行に詰め込めるか\n\n\tif(ruisekiwa[right]-ruisekiwa[left-1]+(right-left) <= W){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nbool put_check(int left,int right,int limit){\n\n\tif(right == N)return true; //最終文字は、右端に詰めなくて良い\n\n\tif(ruisekiwa[right]-ruisekiwa[left-1]+limit*(right-left) >= W){\n\t\treturn true;\n\t}else{ //★★各幅を全てlimitにしても、一行の文字数に足りない→少なくとも一か所、limit+1以上のスペースを入れなければならない!!\n\t\treturn false;\n\t}\n}\n\n\nbool is_OK(int limit){\n\n\tif(one_line_check(1,N))return true;\n\n\tcheck[0] = true;\n\tbool FLG;\n\n\tint left_start = 1;\n\n\tfor(int right_id = 1; right_id <= N; right_id++){ //右端のループ\n\t\twhile(left_start <= right_id && one_line_check(left_start,right_id) == false || check[left_start-1] == false)left_start++;\n\t\tFLG = false;\n\t\tfor(int left_id = left_start; left_id <= right_id; left_id++){\n\t\t\tif(check[left_id-1] == false)continue;\n\t\t\tif(put_check(left_id,right_id,limit) == true){\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcheck[right_id] = FLG;\n\t\tif(check[right_id]){\n\t\t\tif(right_id == N || one_line_check(right_id+1,N) == true){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nvoid func(){\n\n\truisekiwa[0] = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\",&table[i]);\n\t\truisekiwa[i] = table[i];\n\t\truisekiwa[i] += ruisekiwa[i-1];\n\t}\n\n\tint left = 1,right = W,m = (left+right)/2;\n\tint ans = W;\n\n\twhile(left <= right){\n\t\tif(is_OK(m)){\n\t\t\tans = m;\n\t\t\tright = m-1;\n\t\t}else{\n\t\t\tleft = m+1;\n\t\t}\n\t\tm = (left+right)/2;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&N);\n\t\tif(W == 0 && N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define TIMES(i, n) for(int i = 0; i < (n); ++i)\n\ntemplate<class Pred>\nint binsearch(Pred pred) {\n    int val = 0;\n    for(int bit = 20; bit >= 0; --bit) {\n        const int next = val + (1<<bit);\n        val = pred(next) ? next : val;\n    }\n    return val;\n}\n\nbool solve() {\n    int W, N;\n    cin >> W >> N;\n    if(!W && !N) return false;\n\n    vector<int> sum(N+2, 0);\n    TIMES(i, N) {\n        cin >> sum[i+1];\n        sum[i+1] += sum[i];\n    }\n    sum[N+1] = sum[N];\n\n    int ans = binsearch([&](int x) {\n        if(x > W) return false;\n        vector<int> dp(N+3, 0);\n        dp[N+2] = 0;\n        dp[N+1] = 1;\n        dp[N] = 2;\n        for(int i = N-1; i > 0; --i) {\n            bool valid = false;\n            const int mink = binsearch([&](int k) {\n                if(i+k > N+1) return false;\n                const int sp = W - (sum[i+k] - sum[i-1]);\n                if(sp < k) return false;\n                const int ns = (sp + k-1) / k;\n                valid = valid || (ns <= x);\n                return ns > x;\n            }) + 1;\n            const int maxk = binsearch([&](int k) {\n                if(i+k > N+1) return false;\n                const int sp = W - (sum[i+k] - sum[i-1]);\n                if(sp < k) return false;\n                return true;\n            });\n            //cout << x << ' ' << i << ' ' << mink << ' ' << maxk << endl;\n            if(mink <= maxk && i+maxk <= N) dp[i] = valid && (dp[i+mink] - dp[i+maxk+2]) > 0;\n            {\n                const int sp = W - (sum[N] - sum[i-1]);\n                if(sp >= N-i) dp[i] = 1;\n            }\n            //cout << dp[i] << endl;\n            dp[i] += dp[i+1];\n        }\n        return dp[1] - dp[2] == 0;\n    }) + 1;\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = (1<<29);\nint W,N;\nvector<int> x;\nint dp[50005];\nint S[50005];\n\nint getn(int sm,int k){\n  if( k == 0 ){\n    if( sm != W ) return INF;\n    return 0;\n  }\n  return (W - sm + k - 1 )/k + 1;\n}\n\nint solve(){\n  memset( dp,0,sizeof( dp ) );\n  S[0] = 0;\n  for(int i=0;i<N;i++)\n    S[i+1] = S[i] + x[i];\n  dp[0] = 0;\n  int pc = 0;\n  for(int i=1;i<=N;i++){\n    int rt = INF;\n    pc = 0;\n    for(;pc<i;pc++){\n      int a = S[i] - S[pc] + i - pc - 1;\n      int b = dp[pc];\n      if( a > W ) continue;\n      if( i - pc - 1 == 0 ){\n        if( a == W ) rt = 0;\n        break;\n      }\n      a = getn( a, i - pc - 1 );\n      rt = min( rt, max( a, b ) );     \n    }\n    dp[i] = rt;    \n    //  cout << i << \": \" << dp[i] << endl;\n  }\n\n  \n  int res = dp[N];\n  int sm = 0;\n  for(int i=N-1;i>0;i--){\n    sm += x[i];\n    if( sm > W ) break;\n    res = min( res, dp[i] );\n    sm++;\n  }\n  return max(1,res);\n}\n\nint main(){\n  while( cin >> W >> N && (W||N) ){\n    x = vector<int>(N);\n    int sm = 0;\n    bool f = false;\n    for(int i=0;i<N;i++){\n      cin >> x[i];\n      sm += x[i];\n      if( sm > W ) f = true;      \n      sm++;\n    }\n    if( f ) {\n      cout << solve() << endl;\n    } else {\n      --sm;\n      --N;\n      cout << getn( sm , N ) << endl;\n    }\n     \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll W, N;\nll x[50000];\nll xsum[50010];\nint dp[50010];\nint trueSum[50010];\n\n// [l, r]\nll minw(int l, int r){\n\tll sum = xsum[r + 1] - xsum[l] + (r - l);\n\tif(sum > W) return -1;\n\tll rem = W - (xsum[r + 1] - xsum[l]);\n\treturn (rem + (r - l - 1)) / (r - l);\n}\n\nbool check(int w){\n\tmemset(trueSum, 0, sizeof trueSum);\n\ttrueSum[1] = 1;\n\tmemset(dp, 0, sizeof dp);\n\tdp[0] = 1;\n\tint L = 0, R = 0;\n\tfor(int i = 1; i < N; i++){\n\t\t/*int L, R;\n\t\t{\n\t\t\tint ng = -1, ok = i - 1;\n\t\t\twhile(abs(ng - ok) > 1){\n\t\t\t\tint mid = (ng + ok) / 2;\n\t\t\t\tint mw = minw(mid, i);\n\t\t\t\tif(mw != -1) ok = mid;\n\t\t\t\telse ng = mid;\n\t\t\t}\n\t\t\tL = ok;\n\t\t\tif(minw(L, i) > w){\n\t\t\t\ttrueSum[i + 2] = trueSum[i + 1];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint ok = L, ng = i;\n\t\t\twhile(abs(ng - ok) > 1){\n\t\t\t\tint mid = (ng + ok) / 2;\n\t\t\t\tint mw = minw(mid, i);\n\t\t\t\tif(mw <= w) ok = mid;\n\t\t\t\telse ng = mid;\n\t\t\t}\n\t\t\tR = ok;\n\t\t}*/\n\t\twhile(L < i && minw(L, i) == -1) L++;\n\t\twhile(R + 1 < i && minw(R + 1, i) <= w) R++;\n\t\tif(R < L) continue;\n\t\tif(minw(L, i) > w || minw(R, i) > w) continue;\n\t\tassert(minw(L, i) <= w && minw(R, i) <= w);\n\t\tint s = trueSum[R + 1] - trueSum[L];\n\t\tif(s >= 1){\n\t\t\tdp[i + 1] = 1;\n\t\t\ttrueSum[i + 2] = trueSum[i + 1] + 1;\n\t\t\t// ???????????????????????????????????°ok\n\t\t\tll sum = xsum[N] - xsum[i + 1] + (N - i - 2);\n\t\t\tif(sum <= W) return true;\n\t\t}\n\t\telse{\n\t\t\ttrueSum[i + 2] = trueSum[i + 1];\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\twhile(cin >> W >> N, W + N){\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> x[i];\n\t\t\txsum[i + 1] = xsum[i] + x[i];\n\t\t}\n\n\t\tll sum = xsum[N] + N - 1;\n\t\tif(sum <= W){\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint ng = 0, ok = W;\n\t\twhile(abs(ng - ok) > 1){\n\t\t\tint mid = (ng + ok) / 2;\n\t\t\tif(check(mid)) ok = mid;\n\t\t\telse ng = mid;\n\t\t}\n\t\tcout << ok << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\nbool check(int w, const vector<int> &x, int mls){\n\tint n = x.size() - 1;\n\n\tvector<int> tbl(n + 3);\n\tint wsum = 0;\n\tint ssum = 0;\n\tint i;\n\tfor(i = n; i > 0; --i){\n\t\tssum += x[i] + mls;\n\t\twsum += x[i] + 1;\n\t\tif(wsum - 1 > w) break;\n\t\ttbl[i] = tbl[i+1] + 1;\n\t}\n\tint wlim = n, slim = n;\n\twhile(i > 0){\n\t\twhile(ssum - mls >= w){\n\t\t\tssum -= x[slim--] + mls;\n\t\t}\n\t\twhile(wsum - 1 > w){\n\t\t\twsum -= x[wlim--] + 1;\n\t\t}\n\t\t//end at (slim, wlim]\n\t\ttbl[i] = tbl[i+1] + (tbl[slim+2] > tbl[wlim+2]);\n\n\t\t--i;\n\t\tssum += x[i] + mls;\n\t\twsum += x[i] + 1;\n\t}\n\n\treturn tbl[1] > tbl[2];\n}\n\n\nint main(){\n\tint w, n;\n\twhile(scanf(\"%d%d\", &w, &n), n){\n\t\tvector<int> x(n + 1);\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tscanf(\"%d\", &x[i]);\n\t\t}\n\n\t\tint lt = 1, rt = w;\n\t\twhile(lt < rt){\n\t\t\tint md = (lt + rt) / 2;\n\t\t\tif(check(w, x, md)){\n\t\t\t\trt = md;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlt = md + 1;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", lt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint x[100000], dat[100000], n, W, dp[100000];\nvoid add(int p, int q) {\n\twhile (p <= n) {\n\t\tdat[p] += q;\n\t\tp += p&-p;\n\t}\n}\nint sum(int p) {\n\tint sum2 = 0;\n\twhile (p >= 1) {\n\t\tsum2 += dat[p];\n\t\tp -= p&-p;\n\t}\n\treturn sum2;\n}\nint Rangesum(int W1, int W2) {\n\treturn sum(W2) - sum(W1 - 1);\n}\nint hantei(int L1, int R1) {\n\tif (L1 == 0)return 2147000000;\n\tint E = Rangesum(L1, R1);\n\tE += (R1 - L1);\n\treturn E;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> W >> n; for (int i = 0; i < 100000; i++) { dat[i] = 0; dp[i] = 999999999; }\n\t\tif (n == 0 && W == 0)break;\n\t\tfor (int i = 1; i <= n; i++)cin >> x[i]; add(1, x[1]); dp[0] = 1;\n\t\tfor (int i = 2; i <= n - 1; i++) {\n\t\t\tadd(i, x[i]);\n\t\t\tint L = 1, R = i, M = 0;\n\t\t\twhile (true) {\n\t\t\t\tM = (L + R) / 2;\n\t\t\t\tint V1 = hantei(M, i);\n\t\t\t\tint V2 = hantei(M - 1, i);\n\t\t\t\tif (V1 <= W && V2 > W) {\n\t\t\t\t\tfor (int j = M; j < i; j++) {\n\t\t\t\t\t\tif (j != M && dp[j - 2] < dp[j - 1])break;\n\t\t\t\t\t\tif (j != M && dp[j - 2] == dp[j - 1])continue;\n\t\t\t\t\t\tint KO = i - j;\n\t\t\t\t\t\tint V1 = hantei(j, i);\n\t\t\t\t\t\tdp[i] = min(dp[i], max(dp[j - 1], ((W - V1) + KO - 1) / KO + 1));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (V1 > W)L = M;\n\t\t\t\tif (V2 <= W)R = M;\n\t\t\t}\n\t\t}\n\t\tadd(n, x[n]); int minx = 999999999;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (Rangesum(i + 1, n) + (n - (i + 1)) <= W)minx = min(minx, dp[i]);\n\t\t}\n\t\tcout << minx << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint x[100000], dat[100000], n, W, dp[100000];\nvoid add(int p, int q) {\n\twhile (p <= n) {\n\t\tdat[p] += q;\n\t\tp += p&-p;\n\t}\n}\nint sum(int p) {\n\tint sum2 = 0;\n\twhile (p >= 1) {\n\t\tsum2 += dat[p];\n\t\tp -= p&-p;\n\t}\n\treturn sum2;\n}\nint Rangesum(int W1, int W2) {\n\treturn sum(W2) - sum(W1 - 1);\n}\nint hantei(int L1, int R1) {\n\tif (L1 == 0)return 2147000000;\n\tint E = Rangesum(L1, R1);\n\tE += (R1 - L1);\n\treturn E;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> W >> n; for (int i = 0; i < 100000; i++) { dat[i] = 0; dp[i] = 999999999; }\n\t\tif (n == 0 && W == 0)break;\n\t\tfor (int i = 1; i <= n; i++)cin >> x[i]; add(1, x[1]); dp[0] = 1;\n\t\tfor (int i = 2; i <= n - 1; i++) {\n\t\t\tadd(i, x[i]);\n\t\t\tint L = 1, R = i, M = 0;\n\t\t\twhile (true) {\n\t\t\t\tM = (L + R) / 2;\n\t\t\t\tint V1 = hantei(M, i);\n\t\t\t\tint V2 = hantei(M - 1, i);\n\t\t\t\tif (V1 <= W && V2 > W) {\n\t\t\t\t\tfor (int j = M; j < i; j++) {\n\t\t\t\t\t\tif (j != M && dp[j - 1] < dp[j])break;\n\t\t\t\t\t\tint KO = i - j;\n\t\t\t\t\t\tint V1 = hantei(j, i);\n\t\t\t\t\t\tdp[i] = min(dp[i], max(dp[j - 1], ((W - V1) + KO - 1) / KO + 1));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (V1 > W)L = M;\n\t\t\t\tif (V2 <= W)R = M;\n\t\t\t}\n\t\t}\n\t\tadd(n, x[n]); int minx = 999999999;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (Rangesum(i + 1, n) + (n - (i + 1)) <= W)minx = min(minx, dp[i]);\n\t\t}\n\t\tcout << minx << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<class Tuple, unsigned Index>\nvoid print_tuple(ostream& os, const Tuple& t) {}\n\ntemplate<class Tuple, unsigned Index, class Type, class... Types>\nvoid print_tuple(ostream& os, const Tuple& t) {\n\tif(Index > 0) os << \", \";\n\tos << get<Index>(t);\n\tprint_tuple<Tuple, Index + 1, Types...>(os, t);\n}\n\ntemplate<class... Types>\nostream& operator<<(ostream& os, const tuple<Types...>& t) {\n\tos << '(';\n\tprint_tuple<tuple<Types...>, 0, Types...>(os, t);\n\treturn os << ')';\n}\n\ntemplate<class Iterator>\nostream& dump_range(ostream&, Iterator, const Iterator&);\n\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T> c) {\n\treturn dump_range(os, c.cbegin(), c.cend());\n}\n\ntemplate<class Iterator>\nostream& dump_range(ostream& os, Iterator first, const Iterator& last) {\n\tos << '[';\n\tfor(int i = 0; first != last; ++i, ++first) {\n\t\tif(i) os << \", \";\n\t\tos << *first;\n\t}\n\treturn os << ']';\n}\n\nconstexpr int INF = 0xfffffff;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int w, n; cin >> w >> n && w;) {\n\t\tvector<int> words(n);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> words[i];\n\t\t}\n\n\t\tvector<int> sum(n + 1, 0);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tsum[i + 1] = sum[i] + words[i];\n\t\t}\n\n\t\tvector<int> dp(n + 1, INF);\n\t\tdp[0] = 1;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = i + 2; j <= n; ++j) {\n\t\t\t\tconst int rest = w - sum[j] + sum[i];\n\t\t\t\tconst int num_space = j - i - 1;\n\t\t\t\tif(rest <  num_space) break;\n\n\t\t\t\tchmin(dp[j], max<int>(dp[i], ceil((double)rest / num_space)));\n\t\t\t}\n\n\t\t\tconst int rest = w - sum[n] + sum[i];\n\t\t\tconst int num_space = n - i - 1;\n\t\t\tif(rest < num_space) continue;\n\t\t\tchmin(dp[n], dp[i]);\n\t\t}\n\n\t\tcout << dp[n] << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string.h>\nusing namespace std;\nint c[51000];\nint bit[51000];\nint getsum(int a,int b){\n\tif(a)return getsum(0,b)-getsum(0,a-1);\n\tint ret=0;\n\tfor(;b>=0;b=(b&(b+1))-1)ret+=bit[b];\n\treturn ret;\n}\nvoid add(int a,int b){\n\tfor(;a<51000;a|=a+1)bit[a]+=b;\n}\nint sum[51000];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<b;i++)scanf(\"%d\",c+i);\n\t\tfor(int i=0;i<b;i++)sum[i+1]=sum[i]+c[i];\n\t\tint L=0;\n\t\tint R=a;\n\t\twhile(L+1<R){\n\t\t\tint M=(L+R)/2;\n\t\t\tfor(int i=0;i<=b+1;i++)bit[i]=0;\n\t\t\tadd(0,1);\n\t\t\tadd(1,-1);\n\t\t\tfor(int i=0;i<b;i++){\n\t\t\t\tif(!getsum(0,i))continue;\n\t\t\t\tif(sum[b]-sum[i]+b-i-1<=a){\n\t\t\t//\t\tprintf(\"%d %d\\n\",M,i);\n\t\t\t\t\tadd(b,1);break;\n\t\t\t\t}\n\t\t\t\tint l=i;\n\t\t\t\tint r=b;\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tint m=(l+r)/2;\n\t\t\t\t\tif(M*(m-i-1)>=a-(sum[m]-sum[i]))r=m;\n\t\t\t\t\telse l=m;\n\t\t\t\t}\n\t\t\t\tint v1=r;\n\t\t\t//\tif(v1-i-1>a-(sum[v1]-sum[i]))continue;\n\t\t\t\tl=i-1;\n\t\t\t\tr=b;\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tint m=(l+r)/2;\n\t\t\t\t\tif(m-i-1>a-(sum[m]-sum[i]))r=m;\n\t\t\t\t\telse l=m;\n\t\t\t\t}\n\t\t\t\tint v2=l;\n\t\t\t//\tprintf(\"%d %d %d %d\\n\",M,i,v1,v2);\n\t\t\t\tif(v1<=v2){\n\t\t\t\t\tadd(v1,1);\n\t\t\t\t\tadd(v2+1,-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(getsum(0,b))R=M;\n\t\t\telse L=M;\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string.h>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <stdio.h>\n\nusing namespace std;\n\n#define fo(i,n) for(int i=0; i<(int)n; i++)\n#define rep(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#define mp(a,b) make_pair(a,b)\n#define pb(x) push_back(x)\n#define pii pair<int,int>\n\nint w,n;\nint v[50100];\nint f[50100];\n\nbool check(int x) {\n    for(int i=0; i<=n+1; i++) f[i] = 0;\n    int l = 1, r = 1;\n    int suml = v[0], sumr = v[0];\n    f[0] = 1;\n    f[1] = -1;\n\n    for (int i=0; i<n; i++) {\n        f[i+1] += f[i];\n        if (f[i]>0) {\n            while (l<n && suml<=w) {\n                suml += 1 + v[l];\n                l++;\n            }\n            while (r<n && sumr+x+v[r]<w) {\n                sumr += x + v[r];\n                r++;\n            }\n            f[l]--;\n            f[r]++;\n            if (l==n && suml<=w) f[n]++;\n        }\n        suml -= 1+v[i];\n        sumr -= x+v[i];\n    }\n    return f[n]>0;\n}\n\nint main() {\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n    while (cin>>w>>n && w!=0) {\n        for (int i=0; i<n; i++) scanf(\"%d\",v+i);\n\n        int lo = 1;\n        int hi = w;\n        while (lo<hi) {\n            int mi = (lo+hi)/2;\n            if (check(mi)) hi = mi;\n            else lo = mi+1;\n        }\n\n        cout<<lo<<\"\\n\";\n    }\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\n//const int max_n = 1 << 22;\n//modint fact[max_n], factinv[max_n];\n//void init_f() {\n//\tfact[0] = modint(1);\n//\tfor (int i = 0; i < max_n - 1; i++) {\n//\t\tfact[i + 1] = fact[i] * modint(i + 1);\n//\t}\n//\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n//\tfor (int i = max_n - 2; i >= 0; i--) {\n//\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n//\t}\n//}\n//modint comb(int a, int b) {\n//\tif (a < 0 || b < 0 || a < b)return 0;\n//\treturn fact[a] * factinv[b] * factinv[a - b];\n//}\n\nint w, n;\nvoid solve() {\n\tvector<int> x(n);\n\tvector<ll> rx(n + 1);\n\trep(i, n)cin >> x[i];\n\trep(i, n)rx[i + 1] = rx[i] + x[i];\n\tint le = 0, ri = w;\n\twhile (ri - le > 1) {\n\t\tll m = (le + ri) / 2;\n\t\tvector<int> exi(n + 2, 0);\n\t\texi[0] = 1; exi[1] = -1;\n\t\trep(i, n) {\n\t\t\texi[i + 1] += exi[i];\n\t\t\tif (exi[i]) {\n\t\t\t\t{\n\t\t\t\t\tll sum = rx[n] - rx[i];\n\t\t\t\t\tll rest = w - sum;\n\t\t\t\t\tll cnt = n - i;\n\t\t\t\t\tif (cnt <= rest) {\n\t\t\t\t\t\texi[n] = true; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint memol, memor;\n\t\t\t\t//leftside\n\t\t\t\tint l = i-1, r = n + 1;\n\t\t\t\twhile (r - l > 1) {\n\t\t\t\t\tint mid = (l + r) / 2;\n\t\t\t\t\tll sum = rx[mid] - rx[i];\n\t\t\t\t\tll rest = w - sum;\n\n\t\t\t\t\tll cnt = mid - i;\n\t\t\t\t\tif (rest > (cnt - 1)*m)l = mid;\n\t\t\t\t\telse r = mid;\n\t\t\t\t}\n\t\t\t\tmemol = r;\n\t\t\t\t//rightside\n\t\t\t\tl = i, r = n + 1;\n\t\t\t\twhile (r - l > 1) {\n\t\t\t\t\tint mid = (l + r) / 2;\n\t\t\t\t\tll sum = rx[mid] - rx[i];\n\t\t\t\t\tll rest = w - sum;\n\t\t\t\t\tll cnt = mid - i;\n\t\t\t\t\tif (rest < (cnt - 1))r = mid;\n\t\t\t\t\telse l = mid;\n\t\t\t\t}\n\t\t\t\tmemor = l;\n\t\t\t\tif (memol <= memor) {\n\t\t\t\t\texi[memol]++;\n\t\t\t\t\texi[memor + 1]--;\n\t\t\t\t}\n\t\t\t\t//cout << m << \"! \" << i << \" \" << memol << \" \" << memor << endl;\n\t\t\t}\n\t\t}\n\t\tif (exi[n]) {\n\t\t\tri = m;\n\t\t}\n\t\telse le = m;\n\t}\n\t//cout << \"ans is \";\n\tcout << ri << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(12);\n\t//init_f();\n\t//int t; cin >> t; rep(i, t)solve();\n\twhile (cin >> w >> n, w | n)solve();\n\t//solve();\n\tstop\n\t\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#pragma warning(disable : 4996)\nint W, N, x[50009], dp[50009];\nbool solve(int m) {\n\tint pl = 0, pr = 0;\n\tdp[1] = dp[2] = 1;\n\tfor (int j = 2; j <= N; j++) {\n\t\twhile (x[j] - x[pl] > W - (j - pl - 1)) pl++;\n\t\twhile (j != pr + 1 && x[j] - x[pr] > W - (j - pr - 1) * m) pr++;\n\t\tdp[j + 1] = dp[j] + (dp[pr] > dp[pl] ? 1 : 0);\n\t}\n\tfor (int j = 0; j <= N; j++) {\n\t\tif (dp[j] != dp[j + 1] && x[N] - x[j] + N - j - 1 <= W) return true;\n\t}\n\treturn false;\n}\nint main() {\n\twhile (scanf(\"%d %d\", &W, &N), W) {\n\t\tfor (int i = 0; i < N; i++) scanf(\"%d\", &x[i + 1]), x[i + 1] += x[i];\n\t\tint l = 1, r = W + 1;\n\t\twhile (r - l > 1) {\n\t\t\tint m = (l + r) >> 1;\n\t\t\tif (solve(m)) r = m;\n\t\t\telse l = m;\n\t\t}\n\t\twhile (l >= 2 && solve(l)) l--;\n\t\twhile (!solve(l)) l++;\n\t\tprintf(\"%d\\n\", l);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\n#include <iomanip>\n#include <fstream>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int MAX_N = 50010;\n\nstruct SegSum {\n  int bit[MAX_N], n;\n  void init(int _n) {\n    n = _n;\n    memset(bit, 0, sizeof(bit));\n  }\n  int sum(int i) {              // [1,i]テ」ツ?ョテ・ツ陳?\n    int s = 0;\n    while(i > 0) {\n      s += bit[i];\n      i -= i & -i;\n    }\n    return s;\n  }\n  int sum2(int a, int b) {      // [a,b]テ」ツ?ョテ・ツ陳?\n    return sum(b)-sum(a-1);\n  }\n  void add(int i, int x) {      // i(>=1)テ」ツ?ォxティツカツウテ」ツ??\n    while(i <= n) {\n      bit[i] += x;\n      i += i & -i;\n    }\n  }\n  void addSeg(int a, int b, int x) {   // [a,b]テ」ツつ遅テ・ツ?凝・ツ環?」ツ?暗」ツつ?\n    add(a, x);\n    add(b+1, -x);\n  }\n} dp;\n\nint x[50000];\nint sum[50001];\nint w,n;\n\nbool ok2(int a, int b) { // [a,b]テ」ツつ津」ツ?偲」ツつ甘」ツ?偲」ツつ甘」ツ?ァティツゥツーテ」ツつ?」ツ?淌」ツ?ィテ」ツ?購テ」ツ?ォテ・ツ?・テ」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ??\n  int num = b-a+1;\n  int space = num-1;\n  // cout << \"ok2 \" << a << \":\" << b << \":\" << sum[b+1]-sum[a]+space << endl;\n  return sum[b+1]-sum[a] + space <= w;\n}\n\nint maxnum(int i, int m) {      // テ・ツ債佚ィツェツ枴テ」ツ?セテ」ツ?ァテ」ツつ津・ツケツ?テ、ツサツ・テ、ツクツ凝」ツ?ァテ・ツ淞凝」ツつ?」ツつ凝」ツ?ィテ」ツ?催」ツ?ォ1ティツ。ツ古」ツ?ォテ・ツ?・テ」ツつ凝・ツ債佚ィツェツ榲」ツ?ョテヲツ閉ーテ」ツ?ョテヲツ慊?・ツ、ツァ\n  int low = 0, high = i+1;\n  while(low+1<high) {\n    int mid = (low+high)/2;\n    int a = i-mid;\n    int b = i;\n    if (ok2(a,b)) low = mid;\n    else high = mid;\n  }\n  return low;\n}\n\nbool ok3(int a, int b, int m) {        // [a,b]テ」ツつ津、ツスツ凖ィツ」ツ陛」ツつ津ヲツ個?」ツ?」テ」ツ?ヲティツゥツーテ」ツつ?」ツ?淌」ツ?ィテ」ツ?催・ツケツ?テ、ツサツ・テ、ツクツ凝」ツ?ァwテ」ツつ津・ツ淞凝」ツつ?」ツつ古」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ??\n  int num = b-a+1;\n  int space = (num-1) * m;\n  // cout << a << \":\" << b << \":\" << sum[b+1]-sum[a]+space << endl;\n  return sum[b+1]-sum[a]+space >= w;\n}\n\nint minnum(int i, int m) {\n  int low = 0, high = i+1;\n  while(low+1<high) {\n    int mid = (low+high)/2;\n    int a = i-mid;\n    int b = i;\n    if (ok3(a,b,m)) high = mid;\n    else low = mid;\n  }\n  return high;\n}\n\nbool ok(int m) {\n  if (ok2(0,n-1)) return 1;\n  dp.init(n+2);\n  dp.add(1,1);\n  // cout << \"m = \" << m << endl;\n  REP(i,n) {\n    int ma = maxnum(i,m);\n    int mi = minnum(i,m);\n    // cout << i << \" \" << i-ma << \" \" << i-mi << endl;\n    if (dp.sum2(i+1-ma,i+1-mi)) {\n      dp.add(i+2,1);\n      // cout << \"ADD!! \" << i << \" \" << ok2(i+1,n-1) << endl;\n      if (ok2(i+1, n-1)) return 1;\n    }\n  }\n  return dp.sum2(n+1,n+1);\n}\n\n\nint main() {\n  while(cin>>w>>n,w||n) {\n    REP(i,n) cin >> x[i];\n    REP(i,n) sum[i+1] = sum[i] + x[i];\n    int low=0,high=w;\n    while(low+1<high) {\n      int mid = (low + high) / 2;\n      if (ok(mid)) high = mid;\n      else low = mid;\n    }\n    cout << high << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nbool ok(int w,const vi& sum,int sp)\n{\n\tint n=sum.size()-1;\n\t\n\tvi dp(n+1); dp[0]=1;\n\tint l=0,r=0,cnt=0;\n\trep(i,n){\n\t\tfor(;l<i;cnt-=!!dp[l++]) if(sum[i+1]-sum[l]+(i-l)<=w) break;\n\t\tfor(;r<i;cnt+=!!dp[r++]) if(sum[i+1]-sum[r]+(i-r)*sp<w) break;\n\t\tdp[i+1]=!!cnt;\n\t}\n\t\n\tint res=dp[n];\n\tfor(int i=n;i--;){\n\t\tif(sum[n]-sum[i]+(n-i-1)>w) break;\n\t\tres|=dp[i];\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\tfor(int w,n;~scanf(\"%d%d\",&w,&n) && w|n;){\n\t\tvi xs(n);\n\t\trep(i,n) scanf(\"%d\",&xs[i]);\n\t\t\n\t\tvi sum(n+1);\n\t\trep(i,n) sum[i+1]=sum[i]+xs[i];\n\t\t\n\t\tint lo=1,hi=w;\n\t\twhile(lo<hi){\n\t\t\tint mi=(lo+hi)/2;\n\t\t\tif(ok(w,sum,mi))\n\t\t\t\thi=mi;\n\t\t\telse\n\t\t\t\tlo=mi+1;\n\t\t}\n\t\tprintf(\"%d\\n\",lo);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[114514];\nint x[114514];\ntypedef pair<int,int> P;\nint mceil(int p,int q){\n  return (p+q-1)/q;\n}\nint main(){\n  int w,n;\n  while(cin>>w>>n,w||n){\n    for(int i=0;i<n;i++) cin>>x[i];\n    fill(dp,dp+114514,w);\n    priority_queue<P,vector<P>,greater<P> > q;\n    q.push(P(0,0));\n    dp[0]=0;\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      int s=p.first,k=p.second;\n      if(dp[k]<s) continue;\n      int tmp=0;\n      for(int i=k;i<n;i++){\n\ttmp+=x[i];\n\tif(i!=n-1&&i==k) continue;\n\tif(w<tmp+i-k) break;\n\tint res=max(s,mceil(w-tmp,i-k));\n\tif(i==n-1) res=max(s,1);\n\t//cout<<i<<\":\"<<res<<endl;\n\tif(res<dp[i+1]){\n\t  dp[i+1]=res;\n\t  q.push(P(dp[i+1],i+1));\n\t}\n      }\n    }\n    //for(int i=0;i<n;i++) cout<<i<<\" \"<<dp[i]<<endl;\n    cout<<dp[n]<<endl;;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ------ lib ------ //\n\n#include <cstdio>\n#include <string>\n\n#pragma warning(disable: 4996)\n\nusing namespace std;\nstring ID = \"1\";\n\nFILE *in = freopen((\"./in\" + ID + \".txt\").c_str(), \"r\", stdin);\nFILE *out = freopen((\"./out\" + ID + \".txt\").c_str(), \"w\", stdout);\n\n// ------ end ------ //\n\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint x[100000], dat[100000], n, W, dp[100000];\nvoid add(int p, int q) {\n\twhile (p <= n) {\n\t\tdat[p] += q;\n\t\tp += p&-p;\n\t}\n}\nint sum(int p) {\n\tint sum2 = 0;\n\twhile (p >= 1) {\n\t\tsum2 += dat[p];\n\t\tp -= p&-p;\n\t}\n\treturn sum2;\n}\nint Rangesum(int W1, int W2) {\n\treturn sum(W2) - sum(W1 - 1);\n}\nint hantei(int L1, int R1) {\n\tif (L1 == 0)return 2147000000;\n\tint E = Rangesum(L1, R1);\n\tE += (R1 - L1);\n\treturn E;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> W >> n; for (int i = 0; i < 100000; i++) { dat[i] = 0; dp[i] = 999999999; }\n\t\tif (n == 0 && W == 0)break;\n\t\tfor (int i = 1; i <= n; i++)cin >> x[i]; add(1, x[1]); dp[0] = 1;\n\t\tfor (int i = 2; i <= n - 1; i++) {\n\t\t\tadd(i, x[i]);\n\t\t\tint L = 1, R = i, M = 0;\n\t\t\twhile (true) {\n\t\t\t\tM = (L + R) / 2;\n\t\t\t\tint V1 = hantei(M, i);\n\t\t\t\tint V2 = hantei(M - 1, i);\n\t\t\t\tif (V1 <= W && V2 > W) {\n\t\t\t\t\tint ret = dp[M - 1];\n\t\t\t\t\tfor (int j = M; j < i; j++) {\n\t\t\t\t\t\tif (j != M && ret <= dp[j - 1])continue;\n\t\t\t\t\t\tint KO = i - j;\n\t\t\t\t\t\tint V1 = hantei(j, i);\n\t\t\t\t\t\tdp[i] = min(dp[i], max(dp[j - 1], ((W - V1) + KO - 1) / KO + 1));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (V1 > W)L = M;\n\t\t\t\tif (V2 <= W)R = M;\n\t\t\t}\n\t\t}\n\t\tadd(n, x[n]); int minx = 999999999;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (Rangesum(i + 1, n) + (n - (i + 1)) <= W)minx = min(minx, dp[i]);\n\t\t}\n\t\tcout << minx << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\nbool FLG;\nint N,W;\nint table[50005],ruisekiwa[50005];\nbool right_check[50005];\n\nbool one_line_check(int left,int right){ //left～rightの単語を一行に詰め込めるか\n\n\tif(ruisekiwa[right]-ruisekiwa[left-1]+(right-left) <= W){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nbool put_check(int left,int right,int limit){\n\n\tif(right == N)return true; //最終文字は、右端に詰めなくて良い\n\n\tif(ruisekiwa[right]-ruisekiwa[left-1]+limit*(right-left) >= W){\n\t\treturn true;\n\t}else{ //★★各幅を全てlimitにしても、一行の文字数に足りない→少なくとも一か所、limit+1以上のスペースを入れなければならない!!\n\t\treturn false;\n\t}\n}\n\nvoid recursive(int start_id,int limit){\n\n\tif(FLG)return;\n\tif(start_id >= N){\n\t\tFLG = true;\n\t\treturn;\n\t}\n\n\tfor(int right_id = start_id+1; right_id <= N; right_id++){\n\t\tif(right_check[right_id])continue; //検索済ならSKIP\n\t\tif(!one_line_check(start_id,right_id))break;\n\t\t\n\n\t\t//printf(\"%d～%dは一行に詰め込める\\n\",start_id,right_id);\n\n\t\tif(put_check(start_id,right_id,limit)){ //start_id～right_idまでを、最大スペースlimitで置ける場合\n\t\t\tright_check[right_id] = true;\n\t\t\trecursive(right_id+1,limit);\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\truisekiwa[0] = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d\",&table[i]);\n\t\truisekiwa[i] = table[i];\n\t\truisekiwa[i] += ruisekiwa[i-1];\n\t}\n\n\tint left = 1,right = W,m = (left+right)/2;\n\tint ans = W;\n\n\twhile(left <= right){\n\t\tFLG = false;\n\t\tfor(int i = 1; i <= N; i++)right_check[i] = false;\n\t\trecursive(1,m);\n\t\tif(FLG){\n\t\t\tans = m;\n\t\t\tright = m-1;\n\t\t}else{\n\t\t\tleft = m+1;\n\t\t}\n\t\tm = (left+right)/2;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&N);\n\t\tif(W == 0 && N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 100010\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nint w,sum[N];\nint Sum(int l,int r){return sum[r] - sum[l];}\n\nint canPut(int i,int j){return Sum(i,j) + (j - i) - 1 <= w;}\n\nsigned main(){\n  while(1){\n    int n;\n    cin>>w>>n;\n    if(!w && !n) return 0;\n\n    memset(sum,0,sizeof(sum));\n    for(int i=0;i<n;i++) cin>>sum[i+1];\n    for(int i=1;i<=n;i++) sum[i] += sum[i-1];\n    \n    vector<int> dp(n+1,INF);\n    dp[0] = 0;\n    for(int i=0;i<n;i++){\n      if(canPut(i,n)){ Min(dp[n],max(dp[i],1LL));continue; }\n      for(int j=i+2;j<=n;j++){\n        if(!canPut(i,j)) continue;\n        int num = j - i;\n        int ch = Sum(i,j);\n        int spaces = w - ch;\n        int cost = spaces/(num-1) + (spaces%(num-1) != 0);\n        Min(dp[j],max(dp[i],cost));\n      }\n    }\n    cout<<dp[n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[114514];\nint x[114514];\ntypedef pair<int,int> P;\nint mceil(int p,int q){\n  return (p+q-1)/q;\n}\nint main(){\n  int w,n;\n  while(cin>>w>>n,w||n){\n    for(int i=0;i<n;i++) cin>>x[i];\n    fill(dp,dp+114514,w);\n    priority_queue<P,vector<P>,greater<P> > q;\n    q.push(P(0,0));\n    dp[0]=0;\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      int s=p.first,k=p.second;\n      if(dp[k]<s) continue;\n      if(k==n) break;\n      int tmp=0;\n      for(int i=k;i<n;i++){\n\ttmp+=x[i];\n\tif(i!=n-1&&i==k) continue;\n\tif(w<tmp+i-k) break;\n\tint res=max(s,mceil(w-tmp,i-k));\n\tif(i==n-1) res=max(s,1);\n\t//cout<<i<<\":\"<<res<<endl;\n\tif(res<dp[i+1]){\n\t  dp[i+1]=res;\n\t  q.push(P(dp[i+1],i+1));\n\t}\n      }\n    }\n    //for(int i=0;i<n;i++) cout<<i<<\" \"<<dp[i]<<endl;\n    cout<<dp[n]<<endl;;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\nint W,N,x[50000],sum[50001];\nbool can(int x){\n\tbool dp[50001]={};\n\tint imos[50002]={};\n\tdp[0]=true;\n\timos[1]=1;\n\tfor(int i=2;i<=N;i++){\n\t\tint lb=1,ub=i+1;\n\t\twhile(ub-lb>1){\n\t\t\tint m=(ub+lb)/2;\n\t\t\tif(W-(sum[i]-sum[i-m])>=m-1) lb=m;\n\t\t\telse ub=m;\n\t\t}\n\t\tint r=lb;\n\t\tlb=1,ub=i+1;\n\t\twhile(ub-lb>1){\n\t\t\tint m=(lb+ub)/2;\n\t\t\tif(W-(sum[i]-sum[i-m])<=(long long)(m-1)*x) ub=m;\n\t\t\telse lb=m;\n\t\t}\n\t\tint l=ub;\n\t\tif(imos[i-l+1]-imos[i-r]>0) dp[i]=true;\n\t\timos[i+1]=imos[i]+(dp[i]?1:0);\n\t}\n\tfor(int i=N;i>=0;i--){\n\t\tif(sum[N]-sum[i]+(N-1-i)>W) break;\n\t\tif(dp[i]) return true;\n\t}\n\treturn false;\n}\nint main(){\n\twhile(true){\n\t\tscanf(\"%d%d\",&W,&N);\n\t\tif(W==0) return 0;\n\t\trep(i,N) scanf(\"%d\",x+i);\n\t\trep1(i,N) sum[i]=sum[i-1]+x[i-1];\n\t\tint ub=W/2,lb=0;\n\t\twhile(ub-lb>1){\n\t\t\tint m=(ub+lb)/2;\n\t\t\tif(can(m)) ub=m;\n\t\t\telse lb=m;\n\t\t}\n\t\tcout<<ub<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint w, n, x[50000], dp[50010];\nll s[50010];\n\ninline int cost(int i, int j){\n\tassert(i + 1 < j);\n\tll len = s[j] - s[i];\n\tif(len + j - i - 1 > w) return inf;\n\treturn (w - len + j - i - 2) / (j - i - 1);\n}\nconst int MX = 65536;\nint dat[2 * MX], same[2 * MX];\n\ninline int query(int a, int b, int k, int l, int r){\n\tif(b <= l || a >= r) return inf;\n\tif(a <= l && r <= b) return dat[k];\n\tif(same[k]){\n\t\tsame[k] = 0;\n\t\tsame[2 * k + 1] = same[2 * k + 2] = 1;\n\t\tdat[2 * k + 1] = min(dat[2 * k + 1], dat[k]);\n\t\tdat[2 * k + 2] = min(dat[2 * k + 2], dat[k]);\n\t}\n\treturn min(query(a, b, k * 2 + 1, l, (l + r) / 2),\n\t\tquery(a, b, k * 2 + 2, (l + r) / 2, r));\n}\ninline void fix(int a, int b, int k, int l, int r, int x){\n\tif(b <= l || a >= r) return;\n\tif(a <= l && r <= b){\n\t\tsame[k] = 1;\n\t\tdat[k] = min(dat[k], x);\n\t\treturn;\n\t}\n\tif(same[k]){\n\t\tsame[k] = 0;\n\t\tsame[2 * k + 1] = same[2 * k + 2] = 1;\n\t\tdat[2 * k + 1] = min(dat[2 * k + 1], dat[k]);\n\t\tdat[2 * k + 2] = min(dat[2 * k + 2], dat[k]);\n\t}\n\tfix(a, b, k * 2 + 1, l, (l + r) / 2, x);\n\tfix(a, b, k * 2 + 2, (l + r) / 2, r, x);\n}\nint main(){\n\tint cs = 0;\n\twhile(cin >> w >> n, w){\n\t\trep(i, n){\n\t\t\tcin >> x[i];\n\t\t\ts[i + 1] = s[i] + x[i];\n\t\t\tdp[i + 1] = inf;\n\t\t}\n\t\trep(i, MX * 2) dat[i] = inf, same[i] = 1;\n\t\t\n\t\tdp[0] = 1;\n\t\tint j = 0, ans = inf, co;\n\t\trep(i, n){\n\t\t\tdp[i] = min(dp[i], query(i, i + 1, 0, 0, MX));\n\t\t\t\n\t\t\tif(i >= n - 1 || cost(i, n) < inf){\n\t\t\t\tans = min(ans, dp[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile(j <= i + 1) j++;\n\t\t\t\n\t\t\tint lo = j - 1, hi = n + 1, mid;\n\t\t\twhile(lo + 1 < hi){\n\t\t\t\tmid = (lo + hi) / 2;\n\t\t\t\tif(cost(i, mid) < inf) lo = mid;\n\t\t\t\telse hi = mid;\n\t\t\t}\n\t\t\twhile(j <= n){\n\t\t\t\tif((co = cost(i, j)) >= inf) break;\n\t\t\t\tif(co < dp[i]) break;\n\t\t\t\tdp[j] = min(dp[j], max(dp[i], co));\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tfix(j, hi, 0, 0, MX, dp[i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(ll i=0;i<(n);++i)\n#define rep1(i,n) for(ll i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\ntypedef long long ll;\nll W,N,x[50000],sum[50001];\nbool can(ll x){\n\tbool dp[50001]={};\n\tint imos[50002]={};\n\tdp[0]=true;\n\timos[1]=1;\n\tfor(int i=2;i<=N;i++){\n\t\tll lb=1,ub=i+1;\n\t\twhile(ub-lb>1){\n\t\t\tll m=(ub+lb)/2;\n\t\t\tif(W-(sum[i]-sum[i-m])>=m-1) lb=m;\n\t\t\telse ub=m;\n\t\t}\n\t\tll r=lb;\n\t\tlb=1,ub=i+1;\n\t\twhile(ub-lb>1){\n\t\t\tll m=(lb+ub)/2;\n\t\t\tif(W-(sum[i]-sum[i-m])<=(m-1)*x) ub=m;\n\t\t\telse lb=m;\n\t\t}\n\t\tll l=ub;\n\t\tif(imos[i-l+1]-imos[i-r]>0) dp[i]=true;\n\t\timos[i+1]=imos[i]+(dp[i]?1:0);\n\t}\n\tfor(int i=N;i>=0;i--){\n\t\tif(sum[N]-sum[i]+(N-1-i)>W) break;\n\t\tif(dp[i]) return true;\n\t}\n\treturn false;\n}\nint main(){\n\twhile(true){\n\t\tcin>>W>>N;\n\t\tif(W==0) return 0;\n\t\trep(i,N) cin>>x[i];\n\t\trep1(i,N) sum[i]=sum[i-1]+x[i-1];\n\t\tll ub=W,lb=0;\n\t\twhile(ub-lb>1){\n\t\t\tll m=(ub+lb)/2;\n\t\t\tif(can(m)) ub=m;\n\t\t\telse lb=m;\n\t\t}\n\t\tcout<<ub<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\ninline bool check(int w, int limit, const vector<int> &x, const vector<int> &sum) {\n\tconst int n = x.size();\n\n\tint mn_next = n;\n\tint mx_next = n;\n\tint cnt = 0;\n\tvector<bool> dp(n, false);\n\n\tfor(int i = n - 1; i >= 0; --i) {\n\t\tif(sum[n] - sum[i] + 1 * (mn_next - i - 1) <= w) {\n\t\t\tdp[i] = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile(sum[mn_next - 1] - sum[i] + 1 * (mn_next - i - 2) > w) {\n\t\t\tif(dp[--mn_next]) --cnt;\n\t\t}\n\n\t\twhile(sum[mx_next - 1] - sum[i] + limit * (mx_next - i - 2) >= w) {\n\t\t\tif(dp[--mx_next]) ++cnt;\n\t\t}\n\n\t\tif(cnt) dp[i] = true;\n\t}\n\n\treturn dp[0];\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int w, n; cin >> w >> n && w;) {\n\t\tvector<int> x(n);\n\t\tfor(auto &e : x) cin >> e;\n\n\t\tvector<int> sum(n + 1);\n\t\tpartial_sum(begin(x), end(x), begin(sum) + 1);\n\n\t\tint L = 0, R = w;\n\t\twhile(L + 1 < R) {\n\t\t\tconst int M = (L + R) / 2;\n\t\t\tif(check(w, M, x, sum)) {\n\t\t\t\tR = M;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tL = M;\n\t\t\t}\n\t\t}\n\n\t\tcout << R << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\nstruct aa {\n\tint next;\n\tint sum;\n};\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<int>nums(M);\n\t\tvector<aa>as;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tas.push_back(aa{ -1,-1 });\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tcin >> nums[i];\n\t\t}\n\t\tint ans = -1;\n\t\tfor (int i = N - 2; i >= 0; --i) {\n\t\t\t\n\t\t\tbool ok = true;\n\t\t\tint now = 0;\n\t\t\twhile (1) {\n\t\t\t\tint sum = 0;\n\t\t\t\tint start;\n\t\t\t\tif (as[now].next == -1) {\n\t\t\t\t\tstart = now;\n\t\t\t\t\tsum = nums[now];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstart = as[now].next;\n\t\t\t\t\tsum = as[now].sum + (as[now].next - now - 1)*i;\n\t\t\t\t}\n\t\t\t\tint anow = start;\n\t\t\t\twhile (anow +1 != M) {\n\t\t\t\t\tsum += i + nums[anow + 1];\n\t\t\t\t\tif (sum == N) {\n\t\t\t\t\t\tas[now].next = anow+1;\n\t\t\t\t\t\tas[now].sum = sum - (anow - now)*i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (sum > N) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tas[now].next = anow;\n\t\t\t\t\t\tas[now].sum = sum - (i + nums[anow + 1]) - (anow - now)*i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tanow++;\n\t\t\t\t}\n\t\t\t\tif (now + 1 == M) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (!ok) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnow = anow + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tans = i;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = (1<<29);\nint W,N;\nvector<int> x;\nint dp[50005];\nint S[50005];\n\nint getn(int sm,int k){\n  return (W - sm + k - 1 )/k + 1;\n}\n\nint solve(){\n  memset( dp,0,sizeof( dp ) );\n  S[0] = 0;\n  for(int i=0;i<N;i++)\n    S[i+1] = S[i] + x[i];\n  dp[0] = 0;\n  int pc = 0;\n  int k = 0;\n  for(int i=1;i<=N;i++){\n    int rt = INF;\n    pc = k;\n    for(;pc<i;pc++){\n      int a = S[i] - S[pc] + i - pc - 1;\n      int b = dp[pc];\n      if( a > W ) continue;\n      if( i - pc - 1 == 0 ){\n        if( a == W ) rt = 0;\n        break;\n      }\n      a = getn( a, i - pc - 1 );\n      if( rt > max(a,b) ) {\n        rt = max( a, b ); k = pc;\n      }\n      if( a >= b || a > rt ) break;\n    }\n    dp[i] = rt;    \n    //  cout << i << \": \" << dp[i] << endl;\n  }\n\n  \n  int res = dp[N];\n  int sm = 0;\n  for(int i=N-1;i>0;i--){\n    sm += x[i];\n    if( sm > W ) break;\n    res = min( res, dp[i] );\n    sm++;\n  }\n  return max(1,res);\n}\n\nint main(){\n  while( cin >> W >> N && (W||N) ){\n    x = vector<int>(N);\n    int sm = 0;\n    bool f = false;\n    for(int i=0;i<N;i++){\n      cin >> x[i];\n      sm += x[i];\n      if( sm > W ) f = true;      \n      sm++;\n    }\n    if( f ) {\n      cout << solve() << endl;\n    } else {\n      cout << 1 << endl;\n    }\n     \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 50005;\n\nint W, N;\nint x[MAXN];\nbool dp[MAXN];\n\nbool test(int w) {\n  int a, b;\n  int sumA, numA, sumB, numB;\n  fill(dp, dp+MAXN, false);\n  dp[0] = true;\n  a = b = 0;\n  sumA = numA = sumB = numB = 0;\n\n  for(int i = 0; i < N; ++i) {\n    for(; a < N && W-sumA > w*(numA-1); ++numA, sumA += x[a++]);\n    for(; b < N && W-sumB >= (numB-1); ++numB, sumB += x[b++]);\n    if(!(W-sumB >= numB)) {\n      sumB -= x[--b]; --numB;\n    }\n\n    if(dp[i]) {\n      for(int j = a; j <= b; ++j) {\n        dp[j] = true;\n      }\n      a = b;\n      sumA = sumB;\n      numA = numB;\n    }\n\n    sumA -= x[i];\n    sumB -= x[i];\n    numA -= 1;\n    numB -= 1;\n  }\n  return dp[N];\n}\n\nint main() {\n  while(cin >> W >> N && (W|N)) {\n    for(int i = 0; i < N; ++i) cin >> x[i];\n    int l, r;\n    l = 1;\n    r = W+1;\n    while(r-l) {\n      int m = (l+r)/2;\n      if(test(m)) {\n        r = m;\n      } else {\n        l = m+1;\n      }\n    }\n    cout << l << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for(auto i = (c).begin(); i != (c).end(); ++i)\n#define BIT(n, m) (((n) >> (m)) & 1)\n\ntypedef long long ll;\ntypedef pair<int, int> PI;\n\nconst ll inf = 1e15;\nconst ll mod = 1000 * 1000 * 1000 + 7;\nconst double eps = 1e-9;\n\ntemplate <typename S, typename T> ostream &operator<<(ostream &out, const pair<S, T> &p) {\n  out << \"(\" << p.first << \", \" << p.second << \")\";\n  return out;\n}\n\ntemplate <typename T> ostream &operator<<(ostream &out, const vector<T> &v) {\n  out << \"[\";\n  REP(i, v.size()){\n    if (i > 0) out << \", \";\n    out << v[i];\n  }\n  out << \"]\";\n  return out;\n}\n\n#ifndef GUARD_SEGMENT_TREE\n#define GUARD_SEGMENT_TREE\n\n#include <algorithm>\n#include <vector>\n#include <limits>\n\ntemplate <typename T> class SegTree{\n  struct node_t{\n    T   min;\n    T   sum;\n    T   add;\n    int pos;\n  };\n    \n  int                 N;\n  std::vector<T>      A;\n  std::vector<node_t> data;\n\n  inline void eval(int k, int l, int r){\n    if(data[k].add == 0) return;\n    \n    if(r - l > 1){\n      data[2 * k + 1].add += data[k].add;\n      data[2 * k + 2].add += data[k].add;\n    }\n    \n    data[k].sum += data[k].add * (r - l);\n    data[k].min += data[k].add;\n    data[k].add  = 0;\n  }\n  \n  inline void merge(int k){\n    int chl  = k * 2 + 1;\n    int chr  = k * 2 + 2;\n    T   lmin = data[chl].min;\n    T   rmin = data[chr].min;\n    data[k].sum = data[chl].sum + data[chr].sum;\n    data[k].min = std::min(lmin, rmin);\n    data[k].pos = lmin < rmin ? data[chl].pos : data[chr].pos;\n  }\n    \n  void build(int k, int l, int r){\n    if(r - l == 1){\n      data[k].min = A[l];\n      data[k].sum = A[l];\n      data[k].pos = l;\n      data[k].add = 0;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = 2 * k + 1;\n      int chr = 2 * k + 2;\n      build(chl, l, m);\n      build(chr, m, r);\n      merge(k);\n    }\n  }\n  \n  void add(int a, int b, T x, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return;\n    }else if(a <= l && r <= b){\n      data[k].add += x;\n      eval(k, l, r);\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      add(a, b, x, chl, l, m);\n      add(a, b, x, chr, m, r);\n      merge(k);\n    }\n  }\n  \n  T min(int a, int b, int &pos, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return std::numeric_limits<T>::max();\n    }else if(a <= l && r <= b){\n      pos = data[k].pos;\n      return data[k].min;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      int lpos = -1, rpos = -1;\n      T lmin = min(a, b, lpos, chl, l, m);\n      T rmin = min(a, b, rpos, chr, m, r);\n      merge(k);\n      pos = lmin < rmin ? lpos : rpos;\n      return std::min(lmin, rmin);\n    }\n  }\n  \n  T sum(int a, int b, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return 0;\n    }else if(a <= l && r <= b){\n      return data[k].sum;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      T   vl  = sum(a, b, chl, l, m);\n      T   vr  = sum(a, b, chr, m, r);\n      merge(k);\n      return vl + vr;\n    }\n  }\n  \npublic:\n  SegTree(size_t N) : N(N), A(std::vector<T>(N, 0)){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  SegTree(const std::vector<T> &A) : N(A.size()), A(A){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  void add(int l, int r, T x) {add(l, r, x, 0, 0, N);}\n  T min(int l, int r, int &pos){pos = -1; return min(l, r, pos, 0, 0, N);}\n  T min(int l, int r){int tmp;return min(l, r, tmp);}\n  T sum(int l, int r){return sum(l, r, 0, 0, N);}\n};\n\n#endif\n\nbool check(const vector<int> &V, int W, int L){\n  vector<int> sum1(V.size() + 1);\n  vector<int> sumL(V.size() + 1);\n  REP(i, V.size()){\n    sum1[i + 1] = sum1[i] + V[i] + 1;\n    sumL[i + 1] = sumL[i] + V[i] + L;\n  }\n  \n  SegTree<int> dp(V.size() + 1); // dp[i] = V[0..i)???valid?????????\n  dp.add(0, 1, 1);\n\n  REP2(i, 2, V.size()) if (sumL[i] - L >= W){\n    // int llb = -1;\n    // int lub =\n    \n    // find max x s.t. sum of V[i - x, i) + (x - 1) <= W\n    int left  = i - 2;\n    int right = i - 1;\n    {\n      int  lb = -1;\n      int &ub = left;\n      while (ub - lb > 1){\n        int mb = (ub + lb) >> 1;\n        int sum = sum1[i] - sum1[mb] - 1;\n        // cout << sum << endl;\n        if (sum <= W) ub = mb;\n        else lb = mb;\n      }\n    }\n\n    {\n      int  lb = 0;\n      int &ub = right;\n      while (ub - lb > 1){\n        int mb = (lb + ub) >> 1;\n        int sum = sumL[i] - sumL[mb] - L;\n        if (sum < W) ub = mb;\n        else lb = mb;\n      }\n    }\n    // find min x s.t. sum of V[i - x, i) + L * (x - 1) < W\n    // cout << i << \" \" <<  L << \"  \" << left << \" \" << right << endl;\n    if (right > left && dp.sum(left, right) > 0){\n      dp.add(i, i + 1, 1);\n    }\n  }\n\n  bool res = false;\n  REP(i, V.size()){\n    int sum = sum1[V.size()] - sum1[i] - 1;\n    if (sum <= W) res = res || dp.sum(i, i + 1) > 0;\n  }\n  return res;\n}\n\nint main(){\n  int W, N;\n  while (cin >> W >> N && W){\n    vector<int> V(N);\n    REP(i, N) cin >> V[i];\n\n    int ub = W;\n    int lb = 0;\n    // cout << check(V, W, 1) << endl;\n    while (ub - lb > 1){\n      int mb = (ub + lb) >> 1;\n      if (check(V, W, mb)) ub = mb;\n      else lb = mb;\n    }\n    cout << ub << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <map>\n#include <stack>\n#include <vector>\n#include <set>\n#include <queue>\n#define maxn 50005\n#define MAXN 200005\n#define mod 1000000007\n#define INF 0x3f3f3f3f\n#define eps 1e-6\nconst double pi=acos(-1.0);\ntypedef long long ll;\nusing namespace std;\n\nint n,w;\nint len[maxn],sum[maxn];\nbool dp[maxn];\n\nbool isok(int mid)\n{\n    int i,j,last=0;\n    bool flg;\n    memset(dp,0,sizeof(dp));\n    dp[0]=1;\n    if(sum[n]+n-1<=w) return true ;\n    for(i=0; i<n-1; i++)\n    {\n        if(!dp[i]) continue ;\n        flg=0;\n        for(j=max(i+2,last); j<=n; j++)\n        {\n            if(w<sum[j]-sum[i]+j-i-1) break ;\n            if(w>sum[j]-sum[i]+ll(j-i-1)*mid) continue ;\n            if(flg==0) flg=1,last=j;\n            dp[j]=1;\n            if(sum[n]-sum[j]+n-j-1<=w) return true ;\n        }\n    }\n    return false ;\n}\nvoid solve()\n{\n    int i,j,le=1,ri=w,mid,ans;\n    while(le<=ri)\n    {\n        mid=(le+ri)>>1;\n        if(isok(mid))\n        {\n            ans=mid;\n            ri=mid-1;\n        }\n        else le=mid+1;\n    }\n    printf(\"%d\\n\",ans);\n}\nint main()\n{\n    int i,j;\n    while(~scanf(\"%d%d\",&w,&n))\n    {\n        if(w==0&&n==0) break ;\n        sum[0]=0;\n        for(i=1; i<=n; i++)\n        {\n            scanf(\"%d\",&len[i]);\n            sum[i]=sum[i-1]+len[i];\n        }\n        solve();\n    }\n    return 0;\n}\n/*\n11 4\n4 2 1 3\n5 7\n1 1 1 2 2 1 2\n11 7\n3 1 3 1 3 3 4\n100 3\n30 30 39\n30 3\n2 5 3\n0 0\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,a,b) for(int i=(int)(a); i<(int)(b); i++)\n#define FORR(i,a,b) for(int i=(int)(b)-1; i>=(int)(a); i--)\n\nusing ll = long long;\nusing pii = pair<int,int>;\nusing pid = pair<int,double>;\n\nint w,n;\nll x[52525];\nll s[52525];\n\nint imos[52525];\n\nint main(){\n  while(true){\n    scanf(\"%d%d\",&w,&n);\n    if(w+n==0)break;\n    REP(i,n)scanf(\"%lld\",x+i);\n    REP(i,n)s[i+1] = s[i] + x[i];\n    int ok = w, ng = 0;\n    while(abs(ok-ng)>1){\n      int L = (ok+ng)/2;\n      fill(imos,imos+n+1,0);\n      imos[0] = 1; imos[1] = -1;\n      bool go = false;\n      REP(i,n){\n        imos[i+1] += imos[i];\n        if(imos[i] == 0)continue;\n        if(s[n]-s[i]+n-i-1 <= w){\n          go = true;\n          break;\n        }\n        int ok2 = i+1, ng2 = n+1;\n        while(abs(ok2-ng2)>1){\n          int r = (ok2+ng2)/2;\n          (s[r]-s[i]+r-i-1 <= w ? ok2 : ng2) = r;\n        }\n        int lb = ok2;\n        ok2 = n, ng2 = i;\n        while(abs(ok2-ng2)>1){\n          int r = (ok2+ng2)/2;\n          (s[r]-s[i]+1ll*L*(r-i-1)>=w ? ok2 : ng2) = r;\n        }\n        int ub = ok2;\n        // printf(\"L=%d, i=%d: ub=%d, lb=%d\\n\",L,i,ub,lb);\n        if(ub <= lb){\n          imos[ub]++;\n          imos[lb+1]--;\n        }\n      }\n      (go ? ok : ng) = L;\n    }\n    printf(\"%d\\n\", ok);\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_from(i, m, n) for (int i = (m); (i) < int(n); ++(i))\nusing namespace std;\ntemplate <class T> inline void setmin(T & a, T const & b) { a = min(a, b); }\n\nint main() {\n    while (true) {\n        // input\n        int w, n; scanf(\"%d%d\", &w, &n);\n        if (w == 0) break;\n        vector<int> x(n); repeat (i, n) scanf(\"%d\", &x[i]);\n        // solve\n        const int inf = w;\n        vector<int> dp(n + 1, inf);\n        dp[0] = 1;\n        repeat (i, n) {\n            int acc = x[i];\n            repeat_from (j, i + 1, n + 1) {\n                if (j == n) {\n                    setmin(dp[j], dp[i]);\n                } else {\n                    acc += x[j];\n                    int k = j - i;\n                    if (w < acc + k) break;\n                    setmin(dp[j + 1], max(dp[i], (w - acc + (k - 1)) / k));\n                }\n            }\n        }\n        // output\n        printf(\"%d\\n\", dp[n]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string.h>\nusing namespace std;\nint c[51000];\nint segtree[131072];\nint sz;\ninline int query(int a){\n\ta+=sz;\n\twhile(a){\n\t\tif(segtree[a])return 1;\n\t\ta/=2;\n\t}\n\treturn 0;\n}\nvoid add(int a,int b,int c,int d,int e){\n\tif(d<a||b<c)return;\n\tif(c<=a&&b<=d){\n\t\tsegtree[e]++;\n\t\treturn;\n\t}\n\tadd(a,(a+b)/2,c,d,e*2);\n\tadd((a+b)/2+1,b,c,d,e*2+1);\n}\nint sum[51000];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tsz=1;\n\t\twhile(sz<b+1)sz*=2;\n\t\tfor(int i=0;i<b;i++)scanf(\"%d\",c+i);\n\t\tfor(int i=0;i<b;i++)sum[i+1]=sum[i]+c[i];\n\t\tint L=0;\n\t\tint R=a/2;\n\t\twhile(L+1<R){\n\t\t\tint M=(L+R)/2;\n\t\t\tmemset(segtree,0,sz*8);\n\t\t\t//for(int i=0;i<sz*2;i++)segtree[i]=0;\n\t\t\tadd(0,sz-1,0,0,1);\n\t\t\tfor(int i=0;i<b;i++){\n\t\t\t\tif(!query(i))continue;\n\t\t\t\tif(sum[b]-sum[i]+b-i-1<=a){\n\t\t\t\t\tadd(0,sz-1,b,b,1);break;\n\t\t\t\t}\n\t\t\t\tint l=i;\n\t\t\t\tint r=b;\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tint m=(l+r)/2;\n\t\t\t\t\tif(M*(m-i-1)>=a-(sum[m]-sum[i]))r=m;\n\t\t\t\t\telse l=m;\n\t\t\t\t}\n\t\t\t\tint v1=r;\n\t\t\t\tl=i-1;\n\t\t\t\tr=b;\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tint m=(l+r)/2;\n\t\t\t\t\tif(m-i-1>a-(sum[m]-sum[i]))r=m;\n\t\t\t\t\telse l=m;\n\t\t\t\t}\n\t\t\t\tint v2=l;\n\t\t//\t\tprintf(\"%d %d %d %d\\n\",M,i,v1,v2);\n\t\t\t\tif(v1<=v2)add(0,sz-1,v1,v2,1);\n\t\t\t}\n\t\t\tif(query(b))R=M;\n\t\t\telse L=M;\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define llint long long\n\nusing namespace std;\n\nllint W, N;\nllint x[50005];\nllint sumx[50005];\nbool dp[50005];\nvector<llint> vec;\n\nbool check(llint m)\n{\n\tvec.clear();\n\tvec.push_back(0);\n\tfor(int i = 1; i <= N; i++) dp[i] = false;\n\tdp[0] = true;\n\t\n\tfor(int i = 1; i < N; i++){\n\t\tllint ub = i, lb = 0, mid;\n\t\twhile(ub - lb > 1){\n\t\t\tmid = (ub + lb) / 2;\n\t\t\tif(sumx[i]-sumx[mid-1]+(i-mid) <= W) ub = mid;\n\t\t\telse lb = mid;\n\t\t}\n\t\tauto p = lower_bound(vec.begin(), vec.end(), lb);\n\t\tif(p == vec.end()) continue;\n\t\tif(*p <= i-2){\n\t\t\tllint cost = (W - (sumx[i]-sumx[*p]) + (i-*p-2)) / (i-*p-1);\n\t\t\tif(cost <= m){\n\t\t\t\tdp[i] = true;\n\t\t\t\tvec.push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tllint ub = N, lb = 0, mid;\n\t\twhile(ub - lb > 1){\n\t\t\tmid = (ub + lb) / 2;\n\t\t\tif(sumx[N]-sumx[mid-1]+(N-mid) <= W) ub = mid;\n\t\t\telse lb = mid;\n\t\t}\n\t\tauto p = lower_bound(vec.begin(), vec.end(), lb);\n\t\tif(p != vec.end() && *p < N){\n\t\t\tdp[N] = true;\n\t\t\tvec.push_back(N);\n\t\t}\n\t}\n\t\n\treturn dp[N];\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> W >> N;\n\t\tif(W == 0 && N == 0) break;\n\t\tfor(int i = 1; i <= N; i++) cin >> x[i];\n\t\tfor(int i = 1; i <= N; i++) sumx[i] = sumx[i-1] + x[i];\n\t\t\n\t\tllint ub = W, lb = 0, mid;\n\t\twhile(ub - lb > 1){\n\t\t\tmid = (ub + lb) / 2;\n\t\t\tif(check(mid)) ub = mid;\n\t\t\telse lb = mid;\n\t\t}\n\t\tcout << ub << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\nint W,N,x[50000],sum[50001];\nbool can(int x){\n\tbool dp[50001]={};\n\tint imos[50002]={};\n\tdp[0]=true;\n\timos[1]=1;\n\tfor(int i=2;i<=N;i++){\n\t\tint lb=1,ub=i+1;\n\t\twhile(ub-lb>1){\n\t\t\tint m=(ub+lb)/2;\n\t\t\tif(W-(sum[i]-sum[i-m])>=m-1) lb=m;\n\t\t\telse ub=m;\n\t\t}\n\t\tint r=lb;\n\t\tlb=1,ub=i+1;\n\t\twhile(ub-lb>1){\n\t\t\tint m=(lb+ub)/2;\n\t\t\tif(W-(sum[i]-sum[i-m])<=(long long)(m-1)*x) ub=m;\n\t\t\telse lb=m;\n\t\t}\n\t\tint l=ub;\n\t\tif(imos[i-l+1]-imos[i-r]>0) dp[i]=true;\n\t\timos[i+1]=imos[i]+(dp[i]?1:0);\n\t}\n\tfor(int i=N;i>=0;i--){\n\t\tif(sum[N]-sum[i]+(N-1-i)>W) break;\n\t\tif(dp[i]) return true;\n\t}\n\treturn false;\n}\nint main(){\n\twhile(true){\n\t\tscanf(\"%d%d\",&W,&N);\n\t\tif(W==0) return 0;\n\t\trep(i,N) scanf(\"%d\",x+i);\n\t\trep1(i,N) sum[i]=sum[i-1]+x[i-1];\n\t\tint ub=W,lb=0;\n\t\twhile(ub-lb>1){\n\t\t\tint m=(ub+lb)/2;\n\t\t\tif(can(m)) ub=m;\n\t\t\telse lb=m;\n\t\t}\n\t\tcout<<ub<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ninline bool ok(int w,const vi& xs,int sp)\n{\n\tint n=xs.size();\n\tvi sum(n+1);\n\trep(i,n) sum[i+1]=sum[i]+xs[i];\n\t\n\tvi dp(n+1); dp[0]=1;\n\tint l=0,r=0,cnt=0;\n\trep(i,n){\n\t\tfor(;l<i;cnt-=!!dp[l++]) if(sum[i+1]-sum[l]+(i-l)<=w) break;\n\t\tfor(;r<i;cnt+=!!dp[r++]) if(sum[i+1]-sum[r]+(i-r)*sp<w) break;\n\t\tdp[i+1]=!!cnt;\n\t}\n\t\n\tint res=dp[n];\n\tfor(int i=n;i--;){\n\t\tif(sum[n]-sum[i]+(n-i-1)>w) break;\n\t\tres|=dp[i];\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int w,n;~scanf(\"%d%d\",&w,&n) && w|n;){\n\t\tvi xs(n);\n\t\trep(i,n) scanf(\"%d\",&xs[i]);\n\t\t\n\t\tint lo=1,hi=w;\n\t\twhile(lo<hi){\n\t\t\tint mi=(lo+hi)/2;\n\t\t\tif(ok(w,xs,mi))\n\t\t\t\thi=mi;\n\t\t\telse\n\t\t\t\tlo=mi+1;\n\t\t}\n\t\tprintf(\"%d\\n\",lo);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n\nbool check(int w,int n,vector<ll> &sumx,int sp,vector<int> &ubs){\n    vector<int> ok(n+1,false);\n    vector<int> oksum(n+2,0); //sum of ok[i,n+1)\n    ok[n]=true;\n    ok[n-1]=true;\n    oksum[n+1]=0;\n    oksum[n]=1;\n    oksum[n-1]=2;\n    for(int i=n-2;i>=0;i--){\n\n        //cerr<<\"1check\"<<i<<endl;\n        int j=ubs[i];\n        int lb=i+1; //[i,lb)de tarinai\n        int ub=j;\n        while(ub-lb>1){\n            int mid=((lb+ub)>>1);\n            ll mot=w-(sumx[mid]-sumx[i]);\n            ll chi=mid-i-1;\n            if((mot+chi-1)/chi>sp){\n                lb=mid;\n            }\n            else{\n                ub=mid;\n            }\n        }\n        //cerr<<\"2check\"<<i<<endl;\n        int b=ub;\n        //check [b,j)\n        if(j==n+1 || oksum[b]-oksum[j]>0){\n            ok[i]=true;\n        }\n        else{\n            ok[i]=false;\n        }   \n        //cerr<<\"#\"<<i<<\" \"<<b<<\" \"<<j<<\" \"<<ok[i]<<endl;\n        oksum[i]=oksum[i+1]+ok[i];\n    }\n    //cerr<<sp<<endl;\n    //string buf;\n    //cin>>buf;\n    \n    return ok[0];\n}\n\nint solve(int w,int n){\n\n    vector<ll> x(n);\n    for(int i=0;i<n;i++) cin>>x[i];\n    vector<ll> sumx(n+1);\n    for(int i=0;i<n;i++){\n        sumx[i+1]=sumx[i]+x[i];\n    }\n    vector<int> ubs(n);\n    for(int i=n-2;i>=0;i--){\n        int lb=i;\n        int ub=n+1;\n        //cerr<<\"check\"<<i<<endl;\n        //[i,lb) is ok\n        //w-(sumx[lb]-sumx[i])>=lb-i-1\n        //w+i+1>=sumx[lb]-sumx[i]+lb\n        while(ub-lb>1){\n            int mid=(lb+ub)/2;\n            ll sux=sumx[mid]-sumx[i]+mid;\n        //cerr<<\"#\"<<mid<<\" \"<<sux<<\" \"<<w+i+1<<endl;\n            if(w+i+1>=sux){\n                lb=mid;\n            }\n            else{\n                ub=mid;\n            }\n        }\n        ubs[i]=ub;\n    }\n    int lb=0;   \n    int ub=w;\n    //cerr<<\"End summation\"<<endl;\n    while(ub-lb>1){\n        int mid=(lb+ub)/2;\n        if(!check(w,n,sumx,mid,ubs)){\n            lb=mid;\n        }\n        else{\n            ub=mid;\n        }\n    }\n    return ub;\n}\n\nint main(){\n    int w,n;\n    while(cin>>w>>n,w){\n        cout<<solve(w,n)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MN = 50500;\n\nint w, n;\nint x[MN];\nint sum[MN];\n\nint res[MN], dp[MN];\nbool calc(int k) {\n    dp[n] = 0;\n    res[n-1] = 1;\n    dp[n-1] = 1;\n    for (int i = n-2; i >= 0; i--) {\n        if (sum[n]-sum[i]+n-i-1 <= w) {\n            res[i] = 1;\n            dp[i] = res[i] + dp[i+1];\n            continue;\n        }\n        int x, y;\n        int l = i+1, r = n;\n        while (r-l > 1) {\n            int md = (l+r)/2;\n            if (sum[md]-sum[i]+k*(md-i-1) < w) {\n                l = md;\n            } else {\n                r = md;\n            }\n        }\n        x = r;\n        l = i+1, r = n;\n        while (r-l > 1) {\n            int md = (l+r)/2;\n            if (sum[md]-sum[i]+md-i-1 <= w) {\n                l = md;\n            } else {\n                r = md;\n            }\n        }\n        y = r;\n        if (dp[x]-dp[y] >= 1) res[i] = 1;\n        else res[i] = 0;\n        dp[i] = res[i] + dp[i+1];\n    }\n    return res[0];\n}\n\nbool solve() {\n    scanf(\"%d %d\", &w, &n);\n    if (!w && !n) return false;\n    sum[0] = 0;\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", x+i);\n        sum[i+1] = sum[i] + x[i];\n    }\n    for (int i = 1; i <= w; i++) {\n//        printf(\"calc %d %d\\n\", i, calc(i));\n    }\n    int l = 0, r = w;\n    while (r-l > 1) {\n        int md = (l+r)/2;\n        if (calc(md)) {\n            r = md;\n        } else {\n            l = md;\n        }\n    }\n    printf(\"%d\\n\", r);\n    return true;\n}\n\nvoid main2() {\n    while(solve()) {}\n}\n\nll eord, enew;\nint main() {\n    const int SZ = 120*1024*1024;\n    void *p = malloc(SZ);\n    enew = (long long)p + SZ - 1;\n\n//    __asm__(\"mov %rsp, eord\");\n//    __asm__(\"mov enew, %rsp\");\n\n    main2();\n\n//    __asm__(\"mov eord, %rsp\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\nint W,N,x[50000],sum[50001];\nbool can(int x){\n\tbool dp[50001]={};\n\tint imos[50002]={};\n\tdp[0]=true;\n\timos[1]=1;\n\tfor(int i=2;i<=N;i++){\n\t\tint lb=1,ub=i+1;\n\t\twhile(ub-lb>1){\n\t\t\tint m=(ub+lb)/2;\n\t\t\tif(W-(sum[i]-sum[i-m])>=m-1) lb=m;\n\t\t\telse ub=m;\n\t\t}\n\t\tint r=lb;\n\t\tlb=1,ub=i+1;\n\t\twhile(ub-lb>1){\n\t\t\tint m=(lb+ub)/2;\n\t\t\tif(W-(sum[i]-sum[i-m])<=(m-1)*x) ub=m;\n\t\t\telse lb=m;\n\t\t}\n\t\tint l=ub;\n\t\tif(imos[i-l+1]-imos[i-r]>0) dp[i]=true;\n\t\timos[i+1]=imos[i]+(dp[i]?1:0);\n\t}\n\tfor(int i=N;i>=0;i--){\n\t\tif(sum[N]-sum[i]+(N-1-i)>W) break;\n\t\tif(dp[i]) return true;\n\t}\n\treturn false;\n}\nint main(){\n\twhile(true){\n\t\tcin>>W>>N;\n\t\tif(W==0) return 0;\n\t\trep(i,N) cin>>x[i];\n\t\trep1(i,N) sum[i]=sum[i-1]+x[i-1];\n\t\tint ub=W,lb=0;\n\t\twhile(ub-lb>1){\n\t\t\tint m=(ub+lb)/2;\n\t\t\tif(can(m)) ub=m;\n\t\t\telse lb=m;\n\t\t}\n\t\tcout<<ub<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <ctime>\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\n#include <valarray>\n \nusing namespace std;\ntypedef long long ll;\n \n#define ALL(c) (c).begin(),(c).end()\n#define FOR(i,l,r) for(int i=(int)l;i<(int)r;++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORr(i,l,r) for(int i=(int)r-1;i>=(int)l;--i)\n#define REPr(i,n) FORr(i,0,n)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n \ntemplate<typename T,typename U> T pmod(T x,U M){return (x%M+M)%M;}\n \n \ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\n \n \n \nnamespace Fenwicks{\n  template<typename T> class Fenwick{\n  public:\n    int size;vector<T> bit;\n    Fenwick():Fenwick(0){}\n    Fenwick(int n):size(n){bit = vector<T>(n+1);}\n    T sum(int n){// [0,n)\n      T s=0;\n      while(n>0){\n        s+=bit[n];\n        n-=n&-n;//low\n      }\n      return s;\n    }\n    void add(int i,T x){//[0,...i...,n)\n      i++;\n      while(i<=size){\n        bit[i]+=x;\n        i+=i & -i;//next\n      }\n    }\n     \n    //lib\n    T sum(int a,int b){// [a,b)\n      return sum(b)-sum(a);\n    }\n  };\n}\nusing namespace Fenwicks;\n \n \ntemplate <typename T,typename Func> T satisfy_min(T l ,T r,Func P){\n  l--;\n  while(r-l>1)(P((l+r)/2)?r:l)=(l+r)/2;\n  return r;\n}\n\n\n// max{i∈[l,r) | P(i)}．存在しない時、 l-1．\ntemplate <typename T,typename Func> T satisfy_max(T l ,T r,Func P){\n  l--;\n  while(r-l>1)(P((l+r)/2)?l:r)=(l+r)/2;\n  return l;\n}\n\n//P(v)を満たす最小のindexまで減少\ntemplate <typename T,typename Func> T low_sliding_min(T l,T& v,Func P){\n  while(v-1>=l && P(v-1))v--;return v;\n}\n//P(v)を満たす最大のindexまで減少\ntemplate <typename T,typename Func> T low_sliding_max(T l,T& v,Func P){\n  while(v-1>=l && !P(v))v--;return v;\n}\n\ntemplate <typename T,typename Func> T sliding_up(T r,T v,Func P){\n  while(v+1<r && P(v+1))v++;return v;\n}\n\n\nint W,N;\nvector<int> xs;\n \nvector<ll> xsum,wsum;\nint can(int spM){\n  Fenwick<int> fen(N);\n  //last\n  FORr(i,0,N)if(wsum[N]-wsum[i]-1<=W)fen.add(i,1);\n \n  //back \"[i,N)がok\" =def \"1区間 [i,m)がok\" かつ \"*区間 [m,N)がok\"\n  int l=N,r=N;\n  FORr(i,0,N-1)if(!fen.sum(i,i+1)){\n    low_sliding_min(i+2,l,[&](int ml)->bool{\n      ll spc=ml-i-1,sp=(W-(xsum[ml]-xsum[i]) + spc-1)/spc;\n      return sp<=spM;\n    });\n\n    low_sliding_max(i+2,r,[&](int mr)->bool{\n        return wsum[mr]-wsum[i]-1<=W;\n    });\n    // cerr <<spM<<\" \" << i<<\" \"<< l <<\" \" << r <<endl;\n    // //[i,l)\n    // int l=satisfy_min(i+2,N,[&](int ml)->bool{\n    //   ll spc=ml-i-1,sp=(W-(xsum[ml]-xsum[i]) + spc-1)/spc;\n    //   return sp<=spM;\n    // });\n    // //[i,r)\n    // int r=satisfy_max(i+2,N,[&](int mr)->bool{\n    //     return wsum[mr]-wsum[i]-1<=W;\n    // });\n    if(l<=r && fen.sum(l,r+1)>0)fen.add(i,1);\n  }\n  return fen.sum(0,1)==1;\n}\n \n \nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  // ifstream cin( \"in\" );\n  // ofstream cout( \"out\" );\n  \n  while (true) {\n    cin >> W>> N;if(N==0)break;\n    xs=vector<int>(N);REP(i,N)cin >> xs[i];\n \n    xsum=vector<ll>(N+1);\n    FOR(i,1,N+1)xsum[i]=xsum[i-1]+xs[i-1];\n    wsum=vector<ll>(N+1);\n    FOR(i,1,N+1)wsum[i]=wsum[i-1]+1+xs[i-1];\n \n    int res=satisfy_min(1,100000,[&](int m){\n      return can(m);\n    });\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\n\nint w, n;\nvector<int> x, lsum, tbl;\n\ninline int roundup(int a, int b){\n\treturn (a + b - 1) / b;\n}\n\ntemplate <class F>\nint binsearch(int lt, int rt, F func){\n\twhile(lt < rt){\n\t\tint md = (lt + rt) / 2;\n\t\tif(func(md)){\n\t\t\trt = md;\n\t\t}\n\t\telse{\n\t\t\tlt = md + 1;\n\t\t}\n\t}\n\treturn lt;\n}\n\n\nstruct spchecker{\n\tint msp, from;\n\tspchecker(int msp, int from): from(from), msp(msp) {}\n\t\n\tbool operator() (int to){\n\t\tint xsum = lsum[to] - lsum[from-1];\n\t\tint dif = to - from;\n\t\tint sp = (w - xsum + dif - 1) / dif;\n\t\treturn sp <= msp;\n\t}\n};\n\nbool solve(int sp){\n\ttbl.assign(n + 3, 0);\n\tint s = -1;\n\tint i;\n\tfor(i = n; i > 0; --i){\n\t\ts += 1 + x[i];\n\t\tif(s > w) break;\n\t\ttbl[i] = tbl[i+1] + 1;\n\t}\n\tint t = n;\n\n\tfor(; i > 0; s += x[--i] + 1){\n\t\twhile(s > w){\n\t\t\ts -= x[t--] + 1;\n\t\t}\n\t\tint k = binsearch(i + 1, n + 1, spchecker(sp, i));\n\t\ttbl[i] = tbl[i+1] + (tbl[k+1] > tbl[t+2]);\n\t}\n\treturn tbl[1] > tbl[2];\n}\n\n\nint main(){\n\twhile(scanf(\"%d%d\", &w, &n), n){\n\t\tx.resize(n + 3);\n\t\tlsum.resize(n + 3);\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tscanf(\"%d\", &x[i]);\n\t\t\tlsum[i] = lsum[i-1] + x[i];\n\t\t}\n\t\tlsum[n + 1] = lsum[n + 2] = lsum[n];\n\t\tprintf(\"%d\\n\", binsearch(1, w, solve));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct BIT{\n  int size;\n  ll t[100000];\n  void init(int n){\n    size=n+5;\n    for(int i=0;i<=size;i++)t[i]=0;\n  }\n  \n  ll sum(int i){\n    ll res=0;\n    while(0<i){\n      res+=t[i];\n      i-=(i&-i);\n    }\n    return res;\n  }\n  ll sum(int a,int b){\n    if(a>b)return 0;\n    if(a<=1)return sum(b);\n    else return sum(b)-sum(a-1);\n  }\n  void add(int i,ll x){\n    while(i<size){\n      t[i]+=x;\n      i+=(i&-i);\n    }\n  }\n};\n\n#define MAX_N 50005\nll W,N;\nBIT X,DP;\n\nint judge(int l,int r,ll M){\n  if(l==r)return -1;\n  ll d=X.sum(l,r);\n  if(d+(r-l)>W)return 1;\n  if(d+(ll)(r-l)*M<W)return -1;\n  return 0;\n}\n\nint getlower(int i,ll M){\n  int left=i+1,right=N,mid;\n  while(left<right){\n    mid=(left+right)/2;\n    if(judge(i,mid,M)==-1)left=mid+1;\n    else right=mid;\n  }\n  return left;\n}\n\nint getupper(int i,ll M){\n  int left=i+1,right=N+1,mid;\n  while(right-left>1){\n    mid=(left+right)/2;\n    if(judge(i,mid,M)<=0)left=mid;\n    else right=mid;\n  }\n  return left;\n}\n\nbool check(int M){\n  DP.init(N+1);\n  DP.add(N+1,1);\n  \n  for(int i=N;i>=1;i--){\n    if(X.sum(i,N)+N-i<=W){\n      DP.add(i,1);\n      continue;\n    }\n    int fi=getlower(i,M);\n    int se=getupper(i,M);\n    if(DP.sum(fi+1,se+1)>0)DP.add(i,1);\n  }\n  return (DP.sum(1)==1);\n}\n\nint main(){\n  while(1){\n    scanf(\"%lld %lld\",&W,&N);\n    if(W==0&&N==0)break;\n    X.init(N+5);\n    for(int i=1;i<=N;i++){\n      ll x;\n      scanf(\"%lld\",&x);\n      X.add(i,x);\n    }\n    \n    int L=1,R=W-2,M;\n    while(L<R){\n      M=(L+R)/2;\n      if(check(M))R=M;\n      else L=M+1;\n    }\n    printf(\"%d\\n\",L);\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\nusing namespace std;\nconst int maxn=50000+10;\nint n;\nlong long w;\nint data[maxn];\nlong long sum[maxn];\nint len;\nint low,high,mid;\nbool mark[maxn];\n\nstruct Tree {\n    int a[maxn], n;\n    void init(int m) {\n        memset(a, 0, sizeof(a));\n        n = m;\n    }\n    int lowbit(int x) {\n        return x & (-x);\n    }\n    void insert(int x, int y) {\n        while (x <= n) {\n            a[x] += y;\n            x += lowbit(x);\n        }\n    }\n    int sum(int x) {\n        int ret = 0;\n        while (x) {\n            ret += a[x];\n            x -= lowbit(x);\n        }\n        return ret;\n    }\n}F;\n\nbool check(int ans)\n{\n    memset(mark,0,sizeof(mark));\n    mark[0]=1;\n    int p=1,q=0;\n    int tot=0;\n    for (int i=2;i<=n;i++)\n    {\n        while (w-(sum[i]-sum[p-1])<i-p) {if (mark[p-1]) tot--;p++;}\n        while (w-(sum[i]-sum[q])<=ans*(i-q-1) && q + 1 != i) {if (mark[q])tot++;q++;}\n//        if (ans==1) cout<<p<<' '<<q<<' '<<tot<<endl;\n        if (p<=q && tot>0) mark[i]=1;\n    }\n/*\n    cout<<ans<<endl;\n    for (int i=1;i<=n;i++) cout<<mark[i]<<' ';\n    cout<<endl;\n    */\n    for (int i=n;i>=0;i--)\n    {\n        if (mark[i] && (w-(sum[n]-sum[i])>=n-i)) return 1;\n    }\n    return 0;\n}\n\nvoid init()\n{\n    memset(sum,0,sizeof(sum));\n    for (int i=1;i<=n;i++) sum[i]=sum[i-1]+data[i];\n}\n\nvoid work()\n{\n    for (int i=1;i<=n;i++) scanf(\"%d\",&data[i]);\n    init();\n    low=0;high=w;\n    int tot=0;\n    while (low+1<high)\n    {\n        mid=(low+high)/2;\n\n        ++tot;\n        if (check(mid)) high=mid; else low=mid;\n    }\n    printf(\"%d\\n\",high);\n}\n\nint main() {\n    while (scanf(\"%lld%d\",&w,&n)!=EOF && (w!=0 || n!=0)) work();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\nint dp[55555];\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint w, n;\n\twhile (cin >> w >> n, w)\n\t{\n\t\tvi x(n); cin >> x;\n\t\tvi s(n + 1);\n\t\tREP(i, n) s[i + 1] = s[i] + x[i];\n\t\tint lb = 0, ub = w;\n\t\twhile (ub - lb > 1)\n\t\t{\n\t\t\tint k = (ub + lb) / 2;\n\t\t\tMS(dp, 0);\n\t\t\tdeque<int> que;\n\t\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t\t{\n\t\t\t\tif (s[n] - s[i] + (n - i - 1) <= w)\n\t\t\t\t{\n\t\t\t\t\tdp[i] = 1;\n\t\t\t\t\tque.push_back(i);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t\t{\n\t\t\t\tif (dp[i]) continue;\n\t\t\t\twhile (!que.empty())\n\t\t\t\t{\n\t\t\t\t\tint t = que.front();\n\t\t\t\t\tif (t == i + 1) break;\n\t\t\t\t\tif (s[t] - s[i] + (t - i - 1) > w)\n\t\t\t\t\t{\n\t\t\t\t\t\tque.pop_front();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (auto t : que)\n\t\t\t\t{\n\t\t\t\t\tif (t == i + 1) continue;\n\t\t\t\t\tint sp = w - (s[t] - s[i]);\n\t\t\t\t\tif (ceil(ld(sp) / (t - i - 1)) <= k)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i] = true;\n\t\t\t\t\t\tque.push_back(i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dp[0]) ub = k;\n\t\t\telse lb = k;\n\t\t}\n\t\tcout << ub << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nbool ok(int w,const vi& sum,int sp)\n{\n\tint n=sum.size()-1;\n\t\n\t//vi dp(n+1); dp[0]=1;\n\tstatic int dp[50001];\n\tdp[0]=1;\n\t\n\tint l=0,r=0,cnt=0;\n\trep(i,n){\n\t\tfor(;l<i;cnt-=!!dp[l++]) if(sum[i+1]-sum[l]+(i-l)<=w) break;\n\t\tfor(;r<i;cnt+=!!dp[r++]) if(sum[i+1]-sum[r]+(i-r)*sp<w) break;\n\t\tdp[i+1]=!!cnt;\n\t}\n\t\n\tint res=dp[n];\n\tfor(int i=n;i--;){\n\t\tif(sum[n]-sum[i]+(n-i-1)>w) break;\n\t\tres|=dp[i];\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\tfor(int w,n;~scanf(\"%d%d\",&w,&n) && w|n;){\n\t\tvi xs(n);\n\t\trep(i,n) scanf(\"%d\",&xs[i]);\n\t\t\n\t\tvi sum(n+1);\n\t\trep(i,n) sum[i+1]=sum[i]+xs[i];\n\t\t\n\t\tint lo=1,hi=w;\n\t\twhile(lo<hi){\n\t\t\tint mi=(lo+hi)/2;\n\t\t\tif(ok(w,sum,mi))\n\t\t\t\thi=mi;\n\t\t\telse\n\t\t\t\tlo=mi+1;\n\t\t}\n\t\tprintf(\"%d\\n\",lo);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\n\nint W, N;\nint X[50010];\nint f[50010], s[50010];\n\nvoid read();\nvoid soups_on();\nbool yee_haw(int);\n\nint main() {\n  while (cin >> W >> N, W + N)\n    read(), soups_on();\n\n  return 0;\n}\n\nvoid read() {\n  X[0] = W, X[N + 1] = W;\n  for (int i = 1; i <= N; ++i)\n    cin >> X[i];\n  partial_sum(X, X + (N + 2), X);\n}\n\nvoid soups_on() {\n  int low = 1, up = W, mid;\n\n  while (low < up) {\n    mid = (low + up) / 2;\n    if (yee_haw(mid))\n      up = mid;\n    else\n      low = mid + 1;\n  }\n\n  cout << low << \"\\n\";\n}\n\nbool yee_haw(int lm) {\n  int lb, ub, low, up, mid, sum = 0, p;\n\n  fill(&f[0], &f[N + 2], 0);\n  for (int i = 0; i <= N; ++i) {\n    sum += f[i], s[i] = sum;\n    if (i == 0 || sum > 0) {\n      low = i + 1, up = N + 1;\n      while (low < up) {\n        mid = (low + up) / 2;\n        if ((X[mid] - X[i]) + lm * (mid - i - 1) < W)\n          low = mid + 1;\n        else\n          up = mid;\n      }\n      lb = low;\n\n      low = i + 1, up = N + 1;\n      while (low < up) {\n        mid = (low + up) / 2;\n        if ((X[mid] - X[i]) + (mid - i - 1) <= W)\n          low = mid + 1;\n        else\n          up = mid;\n      }\n      ub = low;\n      ++f[lb], --f[ub];\n    }\n  }\n\n  p = 0, s[0] = 1;\n  for (int i = N; i >= 0 && p <= W; --i) {\n    if (s[i] > 0)\n      return true;\n    p = (X[N] - X[i - 1]) + (N - i);\n  }\n\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define TIMES(i, n) for(int i = 0; i < (n); ++i)\n\ntemplate<class Pred>\nint binsearch(Pred pred) {\n    int val = 0;\n    for(int bit = 20; bit >= 0; --bit) {\n        const int next = val + (1<<bit);\n        val = pred(next) ? next : val;\n    }\n    return val;\n}\n\nbool solve() {\n    int W, N;\n    cin >> W >> N;\n    if(!W && !N) return false;\n\n    vector<int> sum(N+2, 0);\n    TIMES(i, N) {\n        cin >> sum[i+1];\n        sum[i+1] += sum[i];\n    }\n    sum[N+1] = sum[N];\n\n    vector<int> dp(N+3, 0);\n    int ans = binsearch([&](int x) {\n        if(x > W) return false;\n        fill(dp.begin(), dp.end(), 0);\n        dp[N+2] = 0;\n        dp[N+1] = 1;\n        dp[N] = 2;\n        for(int i = N-1; i > 0; --i) {\n            bool valid = false;\n            const int mink = binsearch([&](int k) {\n                if(i+k > N+1) return false;\n                const int sp = W - (sum[i+k] - sum[i-1]);\n                if(sp < k) return false;\n                const int ns = (sp + k-1) / k;\n                valid = valid || (ns <= x);\n                return ns > x;\n            }) + 1;\n            const int maxk = binsearch([&](int k) {\n                if(i+k > N+1) return false;\n                const int sp = W - (sum[i+k] - sum[i-1]);\n                if(sp < k) return false;\n                return true;\n            });\n            //cout << x << ' ' << i << ' ' << mink << ' ' << maxk << endl;\n            if(mink <= maxk && i+maxk <= N) dp[i] = valid && (dp[i+mink] - dp[i+maxk+2]) > 0;\n            {\n                const int sp = W - (sum[N] - sum[i-1]);\n                if(sp >= N-i) dp[i] = 1;\n            }\n            //cout << dp[i] << endl;\n            dp[i] += dp[i+1];\n        }\n        return dp[1] - dp[2] == 0;\n    }) + 1;\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1333>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nint W,N;\nbool C(int m,vector<int>& sum){\n    vector<int> dp(N+1);\n    int lim = N,r = N;\n    int cnt = 0;\n    for(int i = N-1; i>= 0;i--){\n        while(W - (sum[lim] - sum[i]) - (lim - i - 1) < 0){\n            cnt -= dp[lim--];\n        }\n        while((r > lim || r - i - 1> 0) && (W - (sum[r] - sum[i]) + r - i - 2)/(r - i - 1) <= m){\n            cnt += dp[r--];\n        }\n        dp[i] = lim == N || cnt > 0;\n    }\n    return dp[0] == 1;\n}\nint solve(){\n    int res = INF;\n    vector<int> x(N),sum(N+1);\n    for(int i = 0; i < N;i++) cin >> x[i];\n    for(int i = 0; i < N;i++) sum[i+1] = sum[i] + x[i];\n    int l = 0, r = W;\n    while(r - l > 1){\n        int m = (l+r)/2;\n        if(C(m,sum)){\n            r = m;\n        }else{\n            l = m;\n        }\n    }\n    res = r;\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> W >> N, W|N){\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct BIT{\n  vector<ll> t;\n  void init(int n){\n    t.clear();\n    t.resize(n+1);\n  }\n  \n  ll sum(int i){\n    ll res=0;\n    while(0<i){\n      res+=t[i];\n      i-=(i&-i);\n    }\n    return res;\n  }\n  ll sum(int a,int b){\n    if(a<=1)return sum(b);\n    else return sum(b)-sum(a-1);\n  }\n  void add(int i,ll x){\n    while(i<(int)t.size()){\n      t[i]+=x;\n      i+=(i&-i);\n    }\n  }\n};\n\n#define MAX_N 50005\nint W,N;\nll x[MAX_N];\nBIT X,DP;\n\nint judge(int l,int r,int M){\n  if(l==r)return -1;\n  \n  ll d=X.sum(l,r);\n  if(d+(r-l)>W)return 1;\n  if(d+(r-l)*M<W)return -1;\n  return 0;\n}\n\nint getlower(int i,int M){\n  int left=i+1,right=N,mid;\n  int cc=0;\n  while(left<right && ++cc<30){\n    mid=(left+right)/2;\n    if(judge(i,mid,M)==-1)left=mid+1;\n    else right=mid;\n  }\n  return left;\n}\n\nint getupper(int i,int M){\n  int left=i+1,right=N+1,mid;\n  int cc=0;\n  while(right-left>1 && ++cc<30){\n    mid=(left+right)/2;\n    if(judge(i,mid,M)<=0)left=mid;\n    else right=mid;\n  }\n  return left;\n}\n\nbool check(int M){\n  DP.init(N+1);\n  DP.add(N+1,1);\n  \n  for(int i=N;i>=1;i--){\n\n    if(X.sum(i,N)+N-i<=W){\n      DP.add(i,1);\n      continue;\n    }\n\n    int fi=getlower(i,M);\n    int se=getupper(i,M);\n    if( DP.sum(fi+1,se+1) > 0 )\n      DP.add(i,1);\n\n    //    cout<<i<<' '<<DP.sum(i,i)<<endl;\n  }\n  return (DP.sum(1)==1);\n}\n\nint main(){\n  while(1){\n    scanf(\"%d %d\",&W,&N);\n    if(W==0&&N==0)break;\n    X.init(N+5);\n    for(int i=1;i<=N;i++){\n      scanf(\"%lld\",&x[i]);\n      X.add(i,x[i]);\n    }\n\n    \n    \n    \n    int L=1,R=W-2,M;\n    while(L<R){\n      M=(L+R)/2;\n      if(check(M))R=M;\n      else L=M+1;\n    }\n\n    printf(\"%d\\n\",L);\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define N (1<<16)\n#include <bits/stdc++.h>\nusing namespace std;\n\nint dp[N];\nint w,n,x,sum[N];\n\nbool solve(int x)\n{\n\tmemset(dp,0,sizeof(dp));\n\tdp[0]=0,dp[1]=1;\n\n\tfor(int i=1,j=0,k=0;i<n;i++)\n\t{\n\t\tfor(;w-(sum[i]-sum[j])<i-j-1;j++);\n\t\tfor(int u=0,v=0;u=w-(sum[i]-sum[k]),v=i-k-1,v?u/v+!!(u%v)<=x:!u;k++);\n\t\tdp[i+1]=dp[i]+(dp[k]-dp[j]>0);\n\t}\n\n\tfor(int i=n-1;i>=0;i--)\n\t{\n\t\tif(w-(sum[n]-sum[i])<n-i-1) return 0;\n\t\tif(dp[i+1]-dp[i]) return 1;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tfor(;cin>>w>>n,w;)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tscanf(\"%d\",&x),sum[i]=sum[i-1]+x;\n\t\tint Left=1,Right=w-1;\n\t\tfor(;Left<Right;)\n\t\t{\n\t\t\tint mid=(Left+Right)>>1;\n\t\t\tif(solve(mid))\n\t\t\t\tRight=mid;\n\t\t\telse\n\t\t\t\tLeft=mid+1;\n\t\t}\n\t\tcout<<Left<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 50005;\n\nint W, N;\nint x[MAXN];\nbool dp[MAXN];\n\nbool test(int w) {\n  int a, b;\n  int sumA, numA, sumB, numB;\n  fill(dp, dp+MAXN, false);\n  dp[0] = true;\n  a = b = 0;\n  sumA = numA = sumB = numB = 0;\n\n  for(int i = 0; i < N; ++i) {\n    for(; a < N && W-sumA > w*(numA-1); ++numA, sumA += x[a++]);\n    for(; b < N && W-sumB >= (numB-1); ++numB, sumB += x[b++]);\n    if(!(W-sumB >= (numB-1))) {\n      sumB -= x[--b]; --numB;\n    }\n\n    if(dp[i]) {\n      for(int j = a; j <= b; ++j) {\n        dp[j] = true;\n      }\n      a = b;\n      sumA = sumB;\n      numA = numB;\n    }\n\n    sumA -= x[i];\n    sumB -= x[i];\n    numA -= 1;\n    numB -= 1;\n  }\n  return dp[N];\n}\n\nint main() {\n  while(cin >> W >> N && (W|N)) {\n    for(int i = 0; i < N; ++i) cin >> x[i];\n    int l, r;\n    l = 1;\n    r = W+1;\n    while(r-l) {\n      int m = (l+r)/2;\n      if(test(m)) {\n        r = m;\n      } else {\n        l = m+1;\n      }\n    }\n    cout << l << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_N 50000\n#define INF 100000000\n#define MOD 1000000007\n#define RANK 1000000000\n#define EPS 1e-10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> IP;\n\nint w, n;\nint bit[MAX_N+1];\nint x[MAX_N];\nint sum[MAX_N+1];\n\nint bsum(int i){\n\tint s = 0;\n\twhile(i > 0){\n\t\ts += bit[i];\n\t\ti -= i&-i;\n\t}\n\treturn s;\n}\n\nvoid add(int i, int x){\n\twhile(i <= n){\n\t\tbit[i] += x;\n\t\ti += i&-i;\n\t}\n}\n\nbool check(int le){\n    memset(bit,0,sizeof(bit));\n    \n    for(int i = 1; i < n; i++){\n        int s = -1, e = i, mid;\n        int st, en;\n        int v;\n        while(e-s > 1){\n            mid = (s+e)/2;\n            if(mid != 0) v = sum[i]-sum[mid-1]-1;\n            else v = sum[i]-1;\n            if(v > w){\n                s = mid;\n            } else{\n                e = mid;\n            }\n        }\n        st = e;\n        s = -1; e = i;\n        while(e-s > 1){\n            mid = (s+e)/2;\n            if(mid != 0) v = sum[i]-sum[mid-1]-1;\n            else v = sum[i]-1;\n            if((w-v+i-mid-1)/(i-mid)+1 > le){\n                e = mid;\n            } else{\n                s = mid;\n            }\n            //cout << v << \" \" << w-v+i-mid-1 << \" \" << mid << \" \" << s << \" \" << e << endl;\n        }\n        if(i == n-1){\n            en = i;\n        } else{\n            en = s;\n        }\n        if(st > en) continue;\n        int q;\n        if(st == 0) q = 1;\n        else q = bsum(en)-bsum(st-1);\n        //cout << \" \" << i << \" \" << q << \" \" << st << \" \" << en << endl;\n        if(q != 0){\n            add(i+1,1);\n            if(i == n-1) return true;\n        }\n    }\n    return false;\n}\n\nint solve(){\n    rep(i,n) cin >> x[i];\n    rep(i,n){\n        if(i == 0){\n            sum[i] = x[i]+1;\n        } else{\n            sum[i] = sum[i-1]+x[i]+1;\n        }\n    }\n    int ss = 0, ee = w, mid;\n    while(ee-ss > 1){\n        mid = (ss+ee)/2;\n        //cout << \"===\" << mid << endl;\n        if(check(mid)){\n            ee = mid;\n        } else{\n            ss = mid;\n        }\n    }\n    cout << ee << endl;\n}\n\nint main(){\n    while(cin >> w >> n){\n        if(w == 0 && n == 0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint c[51000];\nint segtree[131072];\nint sz;\ninline int query(int a){\n\ta+=sz;\n\twhile(a){\n\t\tif(segtree[a])return 1;\n\t\ta/=2;\n\t}\n\treturn 0;\n}\nvoid add(int a,int b,int c,int d,int e){\n\tif(d<a||b<c)return;\n\tif(c<=a&&b<=d){\n\t\tsegtree[e]++;\n\t\treturn;\n\t}\n\tadd(a,(a+b)/2,c,d,e*2);\n\tadd((a+b)/2+1,b,c,d,e*2+1);\n}\nint sum[51000];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tsz=1;\n\t\twhile(sz<b+1)sz*=2;\n\t\tfor(int i=0;i<b;i++)scanf(\"%d\",c+i);\n\t\tfor(int i=0;i<b;i++)sum[i+1]=sum[i]+c[i];\n\t\tint L=0;\n\t\tint R=a/2;\n\t\twhile(L+1<R){\n\t\t\tint M=(L+R)/2;\n\t\t\tfor(int i=0;i<sz*2;i++)segtree[i]=0;\n\t\t\tadd(0,sz-1,0,0,1);\n\t\t\tfor(int i=0;i<b;i++){\n\t\t\t\tif(!query(i))continue;\n\t\t\t\tif(sum[b]-sum[i]+b-i-1<=a){\n\t\t\t\t\tadd(0,sz-1,b,b,1);break;\n\t\t\t\t}\n\t\t\t\tint l=i;\n\t\t\t\tint r=b;\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tint m=(l+r)/2;\n\t\t\t\t\tif(M*(m-i-1)>=a-(sum[m]-sum[i]))r=m;\n\t\t\t\t\telse l=m;\n\t\t\t\t}\n\t\t\t\tint v1=r;\n\t\t\t\tl=i-1;\n\t\t\t\tr=b;\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tint m=(l+r)/2;\n\t\t\t\t\tif(m-i-1>a-(sum[m]-sum[i]))r=m;\n\t\t\t\t\telse l=m;\n\t\t\t\t}\n\t\t\t\tint v2=l;\n\t\t//\t\tprintf(\"%d %d %d %d\\n\",M,i,v1,v2);\n\t\t\t\tif(v1<=v2)add(0,sz-1,v1,v2,1);\n\t\t\t}\n\t\t\tif(query(b))R=M;\n\t\t\telse L=M;\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint W,N;\nint x[100001];\nint sum[100001];\n\nbool ok(int mx){\n  rep(i,N)sum[i+1]=sum[i]+x[i];\n  vector<bool> dp(N+1,false);\n  dp[0]=true;\n  int l=0,r=0;\n  int cnt=0;\n  repl(i,1,N+1){\n    while(r<i-1&&(W-(sum[i]-sum[r])+(i-2-r))/(i-1-r)<=mx){\n      cnt+=dp[r];\n      r++;\n    }\n    while(sum[i]-sum[l]+(i-1-l)>W){\n      cnt-=dp[l];\n      l++;\n    }\n    dp[i]=cnt>0;\n  }\n  bool ok=false;\n  for(int i=N;i>=0&&sum[N]-sum[i]+(N-1-i)<=W;i--)ok|=dp[i];\n  return ok;\n}\n\nint main(){\n  while(1){\n    cin>>W>>N;\n    if(W==0)break;\n    rep(i,N)cin>>x[i];\n    int lb=0,ub=W;\n    while(ub-lb>1){\n      int mid=(lb+ub)/2;\n      if(ok(mid))ub=mid;\n      else lb=mid;\n    }\n    cout<<ub<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<utility>\n#include<deque>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint N,W;\nint x[50500];\nint sum[50500];\n\nP get(int id,int s){\n\tP res;\n\tint lb=id,ub=N;\n\twhile(ub-lb>1){\n\t\tint mid=(ub+lb)/2;\n\t\tint n=mid-id+1;\n\t\tlong long tmp=(long long)(sum[mid]-sum[id-1])+(long long)s*(n-1);\n\t\tif(tmp<W) lb=mid;\n\t\telse ub=mid;\n\t}\n\tres.first=ub+1;\n\tlb=id+1,ub=N+1;\n\twhile(ub-lb>1){\n\t\tint mid=(ub+lb)/2;\n\t\tint n=mid-id+1;\n\t\tlong long tmp=(long long)(sum[mid]-sum[id-1])+(n-1);\n\t\tif(tmp>W) ub=mid;\n\t\telse lb=mid;\n\t}\n\tres.second=lb+1;\n\treturn res;\n}\n\nbool check2(int i,int s){\n\tint x=sum[N]-sum[i-1]+(N-i+1);\n\tif(x<=W) return true;\n\treturn false;\n}\n\nbool ok[50500];\n\nbool check(int s){\n\tdeque<P> deq;\n\tdeq.push_back(P(1,1));\n\tbool flg=false;\n\tfor(int i=1;i<=N;i++) ok[i]=false;\n\twhile(!deq.empty()){\n\t\tP p=deq.front();\n\t\tint id=p.first;\n\t\tif(id==N+1) return true;\n\t\tok[id]=true;\n\t\tif(p.first==p.second) deq.pop_front();\n\t\telse deq[0].first++;\n\t\tP nxt=get(id,s);\n\t\tif(nxt.first>nxt.second) continue;\n\t\tif(deq.empty()||deq.back().second<nxt.first-1) deq.push_back(nxt);\n\t\telse deq.back().second=nxt.second;\n\t}\n\tfor(int i=1;i<=N;i++) if(ok[i]){\n\t\tif(check2(i,s)) return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\twhile(true){\n\t\tscanf(\"%d%d\",&W,&N);\n\t\tif(N==0&&W==0) break;\n\t\tfor(int i=1;i<=N;i++) scanf(\"%d\",x+i);\n\t\tsum[0]=0;\n\t\tfor(int i=1;i<=N;i++) sum[i]=sum[i-1]+x[i];\n\t\tint lb=0,ub=W;\n\t\twhile(ub-lb>1){\n\t\t\tint mid=(ub+lb)/2;\n\t\t\tif(check(mid)) ub=mid;\n\t\t\telse lb=mid;\n\t\t}\n\t\tprintf(\"%d\\n\",ub);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct BIT{\n  vector<ll> t;\n  void init(int n){\n    t.clear();\n    t.resize(n+1);\n  }\n  \n  ll sum(int i){\n    ll res=0;\n    while(0<i){\n      res+=t[i];\n      i-=(i&-i);\n    }\n    return res;\n  }\n  ll sum(int a,int b){\n    if(a<=1)return sum(b);\n    else return sum(b)-sum(a-1);\n  }\n  void add(int i,ll x){\n    while(i<(int)t.size()){\n      t[i]+=x;\n      i+=(i&-i);\n    }\n  }\n};\n\n#define MAX_N 50005\nint W,N;\nll x[MAX_N];\nBIT X,DP;\n\nint judge(int l,int r,int M){\n  if(l==r)return -1;\n  \n  ll d=X.sum(l,r);\n  if(d+(r-l)>W)return 1;\n  if(d+(r-l)*M<W)return -1;\n  return 0;\n}\n\nint getlower(int i,int M){\n  int left=i+1,right=N,mid;\n  int cc=0;\n  while(left<right && ++cc<30){\n    mid=(left+right)/2;\n    if(judge(i,mid,M)==-1)left=mid+1;\n    else right=mid;\n  }\n  return left;\n}\n\nint getupper(int i,int M){\n  int left=i+1,right=N+1,mid;\n  int cc=0;\n  while(right-left>1 && ++cc<30){\n    mid=(left+right)/2;\n    if(judge(i,mid,M)<=0)left=mid;\n    else right=mid;\n  }\n  return left;\n}\n\nbool check(int M){\n  DP.init(N+1);\n  DP.add(N+1,1);\n  \n  for(int i=N;i>=1;i--){\n\n    if(X.sum(i,N)+N-i<=W){\n      DP.add(i,1);\n      continue;\n    }\n\n    int fi=getlower(i,M);\n    int se=getupper(i,M);\n    if( DP.sum(fi+1,se+1) > 0 )\n      DP.add(i,1);\n\n    //    cout<<i<<' '<<DP.sum(i,i)<<endl;\n  }\n  return (DP.sum(1)==1);\n}\n\nint main(){\n  while(1){\n    scanf(\"%d %d\",&W,&N);\n    if(W==0&&N==0)break;\n    X.init(N+5);\n    for(int i=1;i<=N;i++){\n      scanf(\"%lld\",&x[i]);\n      X.add(i,x[i]);\n    }\n    \n    int L=1,R=W-2,M;\n    int cc=0;\n    while(L<R && ++cc<30){\n      M=(L+R)/2;\n      if(check(M))R=M;\n      else L=M+1;\n    }\n\n    printf(\"%d\\n\",L);\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string.h>\nusing namespace std;\nint c[51000];\nchar segtree[131072];\nint sz;\ninline int query(int a){\n\ta+=sz;\n\twhile(a){\n\t\tif(segtree[a])return 1;\n\t\ta/=2;\n\t}\n\treturn 0;\n}\nvoid add(int a,int b,int c,int d,int e){\n\tif(d<a||b<c)return;\n\tif(c<=a&&b<=d){\n\t\tsegtree[e]=1;\n\t\treturn;\n\t}\n\tadd(a,(a+b)/2,c,d,e*2);\n\tadd((a+b)/2+1,b,c,d,e*2+1);\n}\nint sum[51000];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tsz=1;\n\t\twhile(sz<b+1)sz*=2;\n\t\tfor(int i=0;i<b;i++)scanf(\"%d\",c+i);\n\t\tfor(int i=0;i<b;i++)sum[i+1]=sum[i]+c[i];\n\t\tint L=0;\n\t\tint R=a/2;\n\t\twhile(L+1<R){\n\t\t\tint M=(L+R)/2;\n\t\t\tmemset(segtree,0,sz*2);\n\t\t\t//for(int i=0;i<sz*2;i++)segtree[i]=0;\n\t\t\tadd(0,sz-1,0,0,1);\n\t\t\tfor(int i=0;i<b;i++){\n\t\t\t\tif(!query(i))continue;\n\t\t\t\tif(sum[b]-sum[i]+b-i-1<=a){\n\t\t\t\t\tadd(0,sz-1,b,b,1);break;\n\t\t\t\t}\n\t\t\t\tint l=i;\n\t\t\t\tint r=b;\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tint m=(l+r)/2;\n\t\t\t\t\tif(M*(m-i-1)>=a-(sum[m]-sum[i]))r=m;\n\t\t\t\t\telse l=m;\n\t\t\t\t}\n\t\t\t\tint v1=r;\n\t\t\t\tl=i-1;\n\t\t\t\tr=b;\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tint m=(l+r)/2;\n\t\t\t\t\tif(m-i-1>a-(sum[m]-sum[i]))r=m;\n\t\t\t\t\telse l=m;\n\t\t\t\t}\n\t\t\t\tint v2=l;\n\t\t\t\tif(v1<=v2)add(0,sz-1,v1,v2,1);\n\t\t\t}\n\t\t\tif(query(b))R=M;\n\t\t\telse L=M;\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\ninline int f(int n, int i, int L, const vector<int>& sum_rev){\n    return (sum_rev[i - n] - sum_rev[i]) + L * (n - 1);\n}\n\nint dp[50010];\nint sum_dp[50010];\n\nint main(){\n    int W, N;\n    while(cin >> W >> N && N){\n        vector<int> x(N);\n        REP(i, N) cin >> x[i];\n\n        vector<int> sum_rev(N + 1);\n        sum_rev[N] = 0;\n        for(int i = N - 1; i >= 0; i--){\n            sum_rev[i] = sum_rev[i + 1] + x[i];\n        }\n\n        int lb_L = 0, ub_L = W; // ub\n        while(ub_L - lb_L > 1){\n            int L = (lb_L + ub_L) / 2;\n            dp[0] = 1;\n            dp[1] = 0;\n            sum_dp[1] = 1;\n            sum_dp[2] = 1;\n\n            for(int i = 2; i < N; i++){\n                dp[i] = 0;\n                sum_dp[i] = sum_dp[i - 1] + dp[i - 1];\n \n                int lb = 1, ub = min(i, (W + L)/(L + 1) + 2); // ub  true ??\n                while(ub - lb > 1){\n                    int n = (ub + lb) / 2;\n                    if(f(n, i, L, sum_rev) >= W){\n                        ub = n;\n                    }else{\n                        lb = n;\n                    }\n                }\n                int begin_n = ub;\n\n                //printf(\"dp[%d] : begin %d \\n\", i, begin_n);\n                if(f(begin_n, i, L, sum_rev) < W){\n                    continue;\n                }\n\n                lb = begin_n, ub = i + 1; // lb\n                while(ub - lb > 1){\n                    int n = (ub + lb) / 2;\n                    if(f(n, i, 1, sum_rev) <= W){\n                        lb = n;\n                    }else{\n                        ub = n;\n                    }\n                }\n                int end_n = lb; \n\n                //printf(\"dp[%d] : end %d \\n\", i, end_n);\n                if(f(end_n, i, 1, sum_rev) > W) {\n                    continue;\n                }\n\n                int begin = i - end_n;\n                int end = i - begin_n;\n                // [begin, end]\n                if(sum_dp[end + 1] - sum_dp[begin] > 0){\n                    dp[i] = 1;\n                }\n                //printf(\"dp[%d] : [dp[%d], dp[%d]] (%d) -> %d\\n\", i, begin, end, sum_dp[end + 1] - sum_dp[begin], dp[i]);\n            }\n\n            bool ok = false;\n            for(int n = 1; n <= N && (n - 1) + sum_rev[N - n] <= W; n++) {\n                //printf(\"n - 1 + sum_rev[%d] = %d\\n\", i, n - 1 + sum_rev[i]);\n                if(dp[N - n]){\n                    ok = true;\n                    break;\n                }\n            }\n            //printf(\"L %d  is %d\\n\", L, ok);\n\n            if(ok){\n                ub_L = L;\n            }else{\n                lb_L = L;\n            }\n        }\n\n        cout << ub_L << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\nint W,N,x[50000],sum[50001];\nbool dp[50001];\nint imos[50002];\nbool can(int x){\n\trep(i,N+1) dp[i]=false;\n\tdp[0]=true;\n\timos[1]=1;\n\tfor(int i=1;i<=N;i++){\n\t\tint lb=1,ub=i+1;\n\t\twhile(ub-lb>1){\n\t\t\tint m=(ub+lb)/2;\n\t\t\tif(W-(sum[i]-sum[i-m])>=m-1) lb=m;\n\t\t\telse ub=m;\n\t\t}\n\t\tint r=lb;\n\t\tlb=1,ub=i+1;\n\t\twhile(ub-lb>1){\n\t\t\tint m=(lb+ub)/2;\n\t\t\tif(W-(sum[i]-sum[i-m])<=(long long)(m-1)*x) ub=m;\n\t\t\telse lb=m;\n\t\t}\n\t\tint l=ub;\n\t\tif(imos[i-l+1]-imos[i-r]>0) dp[i]=true;\n\t\timos[i+1]=imos[i]+(dp[i]?1:0);\n\t}\n\tfor(int i=N;i>=0;i--){\n\t\tif(sum[N]-sum[i]+(N-1-i)>W) break;\n\t\tif(dp[i]) return true;\n\t}\n\treturn false;\n}\nint main(){\n\twhile(true){\n\t\tscanf(\"%d%d\",&W,&N);\n\t\tif(W==0) return 0;\n\t\trep(i,N) scanf(\"%d\",x+i);\n\t\trep1(i,N) sum[i]=sum[i-1]+x[i-1];\n\t\tint ub=W/2+1,lb=0;\n\t\twhile(ub-lb>1){\n\t\t\tint m=(ub+lb)/2;\n\t\t\tif(can(m)) ub=m;\n\t\t\telse lb=m;\n\t\t}\n\t\tcout<<ub<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <array>\n#include <set>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <unordered_set>\n#include <unordered_map>\n#include <functional>\n#include <cassert>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_from(i, m, n) for (int i = (m); (i) < int(n); ++(i))\n#define repeat_reverse(i, n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i, m, n) for (int i = (n)-1; (i) >= int(m); --(i))\n#define whole(f, x, ...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\n#define unittest_name_helper(counter) unittest_ ## counter\n#define unittest_name(counter) unittest_name_helper(counter)\n#define unittest __attribute__((constructor)) void unittest_name(__COUNTER__) ()\nusing ll = long long;\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\ntemplate <class T> inline void setmin(T & a, T const & b) { a = min(a, b); }\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\ntemplate <typename UnaryPredicate>\nll binsearch(ll l, ll r, UnaryPredicate p) { // [l, r), p is monotone\n    assert (l < r);\n    -- l;\n    while (r - l > 1) {\n        ll m = (l + r) / 2;\n        (p(m) ? r : l) = m;\n    }\n    return r; // = min { x in [l, r) | p(x) }, or r\n}\n\ntemplate <class OperatorMonoid>\nstruct dual_segment_tree {\n    typedef OperatorMonoid monoid_type;\n    typedef typename OperatorMonoid::underlying_type operator_type;\n    typedef typename OperatorMonoid::target_type underlying_type;\n    int n;\n    vector<operator_type> f;\n    vector<underlying_type> a;\n    OperatorMonoid op;\n    dual_segment_tree() = default;\n    dual_segment_tree(int a_n, underlying_type initial_value, OperatorMonoid const & a_op = OperatorMonoid()) : op(a_op) {\n        n = 1; while (n < a_n) n *= 2;\n        a.resize(n, initial_value);\n        f.resize(n-1, op.unit());\n    }\n    underlying_type point_get(int i) { // 0-based\n        underlying_type acc = a[i];\n        for (i = (i+n)/2; i > 0; i /= 2) { // 1-based\n            acc = op.apply(f[i-1], acc);\n        }\n        return acc;\n    }\n    void range_apply(int l, int r, operator_type z) { // 0-based, [l, r)\n        assert (0 <= l and l <= r and r <= n);\n        range_apply(0, 0, n, l, r, z);\n    }\n    void range_apply(int i, int il, int ir, int l, int r, operator_type z) {\n        if (l <= il and ir <= r) { // 0-based\n            if (i < f.size()) {\n                f[i] = op.append(z, f[i]);\n            } else {\n                a[i-n+1] = op.apply(z, a[i-n+1]);\n            }\n        } else if (ir <= l or r <= il) {\n            // nop\n        } else {\n            range_apply(2*i+1, il, (il+ir)/2, 0, n, f[i]);\n            range_apply(2*i+2, (il+ir)/2, ir, 0, n, f[i]);\n            f[i] = op.unit();\n            range_apply(2*i+1, il, (il+ir)/2, l, r, z);\n            range_apply(2*i+2, (il+ir)/2, ir, l, r, z);\n        }\n    }\n};\n\nstruct min_operator_t {\n    typedef int underlying_type;\n    typedef int target_type;\n    int unit() const { return INT_MAX; }\n    int append(int a, int b) const { return min(a, b); }\n    int apply(int a, int b) const { return min(a, b); }\n};\n\nint main() {\n    while (true) {\n        // input\n        int w, n; scanf(\"%d%d\", &w, &n);\n        if (w == 0) break;\n        vector<ll> x(n); repeat (i, n) scanf(\"%lld\", &x[i]);\n        // solve\n        vector<ll> acc(n + 1); whole(partial_sum, x, acc.begin() + 1);\n        const int inf = w;\n        vector<int> dp(n + 1, inf);\n        dual_segment_tree<min_operator_t> segtree(n + 1, inf);\n        dp[0] = 1;\n        repeat (l, n) {\n            setmin(dp[l], segtree.point_get(l));\n            int r = l + 2;\n            for (; r < n + 1; ++ r) {\n                int used = acc[r] - acc[l];\n                int k = r - l - 1;\n                if (w < used + k) break;\n                int it = (w - used + (k - 1)) / k;\n                if (it <= dp[l]) break;\n                setmin(dp[r], max(dp[l], it));\n            }\n            if (r < n + 1) {\n                int rr = binsearch(r, n + 1, [&](int r) {\n                    int used = acc[r] - acc[l];\n                    int k = r - l - 1;\n                    return w < used + k;\n                });\n                segtree.range_apply(r, rr, dp[l]);\n            }\n            if (acc[n] - acc[l] + n - l - 1 <= w) {\n                setmin(dp[n], dp[l]);\n            }\n        }\n        // output\n        printf(\"%d\\n\", dp[n]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint main()\n{\n  int W, N, x[50000] = {};\n  int dp[50000];\n\n  while(scanf(\"%d %d\", &W, &N), W) {\n    for(int i = 1; i <= N; i++) {\n      scanf(\"%d\", x + i);\n      x[i] += x[i - 1];\n    }\n\n    auto getSpace = [&](int l, int r)\n    {\n      if(x[r] - x[l] + r - l - 1 > W) return (INF);\n      if(r == N) return (1);\n      if(l + 1 >= r) return (INF);\n      return ((W + x[l] + r - x[r] - l - 2) / (r - l - 1));\n    };\n\n    fill_n(dp, N + 1, INF);\n    dp[0] = 0;\n    for(int i = 1; i <= N; i++) {\n      for(int j = i - 1; j >= 0; j--) {\n        dp[i] = min(dp[i], max(dp[j], getSpace(j, i)));\n      }\n    }\n\n    printf(\"%d\\n\", dp[N]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint main()\n{\n  int W, N, x[50000] = {};\n  int dp[50000];\n\n  while(scanf(\"%d %d\", &W, &N), W) {\n    for(int i = 1; i <= N; i++) {\n      scanf(\"%d\", x + i);\n      x[i] += x[i - 1];\n    }\n\n    auto getSpace = [&](int l, int r)\n    {\n      if(x[r] - x[l] + r - l - 1 > W) return (INF);\n      return ((W + x[l] + r - x[r] - l - 2) / (r - l - 1));\n    };\n\n    fill_n(dp, N + 1, INF);\n    dp[0] = 0;\n    for(int i = 1; i < N; i++) {\n      for(int j = i - 2; j >= 0; j--) {\n        int vv = getSpace(j, i);\n        if(vv == INF) break;\n        dp[i] = min(dp[i], max(dp[j], getSpace(j, i)));\n      }\n    }\n\n    int ret = dp[N - 1], tail = N - 2;\n    while(tail >= 0 && getSpace(tail, N) != INF) {\n      ret = min(ret, dp[tail]);\n      --tail;\n    }\n    printf(\"%d\\n\", max(1, ret));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define TIMES(i, n) for(int i = 0; i < (n); ++i)\n\ntemplate<class Pred>\nint binsearch(const Pred &pred) {\n    int val = 0;\n    for(int bit = 20; bit >= 0; --bit) {\n        const int next = val + (1<<bit);\n        val = pred(next) ? next : val;\n    }\n    return val;\n}\n\nbool solve() {\n    int W, N;\n    scanf(\"%d %d\", &W, &N);\n    if(!W && !N) return false;\n\n    vector<int> sum(N+2, 0);\n    TIMES(i, N) {\n        int v;\n        scanf(\"%d\", &v);\n        sum[i+1] = v;\n        sum[i+1] += sum[i];\n    }\n    sum[N+1] = sum[N];\n\n    vector<int> dp(N+3, 0);\n    int ans = binsearch([&](int x) {\n        if(x > W) return false;\n        fill(dp.begin(), dp.end(), 0);\n        dp[N+2] = 0;\n        dp[N+1] = 1;\n        dp[N] = 2;\n        for(int i = N-1; i > 0; --i) {\n            bool valid = false;\n            const int mink = binsearch([&](int k) {\n                if(i+k > N+1) return false;\n                const int sp = W - (sum[i+k] - sum[i-1]);\n                if(sp < k) return false;\n                const int ns = (sp + k-1) / k;\n                valid = valid || (ns <= x);\n                return ns > x;\n            }) + 1;\n            const int maxk = binsearch([&](int k) {\n                if(i+k > N+1) return false;\n                const int sp = W - (sum[i+k] - sum[i-1]);\n                if(sp < k) return false;\n                return true;\n            });\n            //cout << x << ' ' << i << ' ' << mink << ' ' << maxk << endl;\n            if(mink <= maxk && i+maxk <= N) dp[i] = valid && (dp[i+mink] - dp[i+maxk+2]) > 0;\n            {\n                const int sp = W - (sum[N] - sum[i-1]);\n                if(sp >= N-i) dp[i] = 1;\n            }\n            //cout << dp[i] << endl;\n            dp[i] += dp[i+1];\n        }\n        return dp[1] - dp[2] == 0;\n    }) + 1;\n    printf(\"%d\\n\", ans);\n    return true;\n}\n\nint main() {\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int W, N;\n    while(cin >> W >> N, W) {\n        vector<int> x(N), sum(N + 1);\n        for(int i = 0; i < N; ++i) {\n            cin >> x[i];\n            sum[i + 1] = sum[i] + x[i];\n        }\n\n        auto check = [&](int space) {\n            vector<int> dp(N + 1);\n            int limit_r = N, ok_r = N;\n            int ok_cnt = 0;\n            for(int i = N - 1; i >= 0; --i) {\n                while(W - (sum[limit_r] - sum[i]) - (limit_r - i - 1) < 0) {\n                    ok_cnt -= dp[limit_r--];\n                }\n                while(ok_r > limit_r || ok_r - i - 1 > 0 && (W - (sum[ok_r] - sum[i]) + ok_r - i - 2) / (ok_r - i - 1) <= space) {\n                    ok_cnt += dp[ok_r--];\n                }\n\n                dp[i] = limit_r == N || ok_cnt > 0;\n            }\n\n            return dp[0] == 1;\n        };\n\n        int lb = 0, ub = W;\n        while(ub - lb > 1) {\n            const int mid = (ub + lb) / 2;\n            if(check(mid)) {\n                ub = mid;\n            } else {\n                lb = mid;\n            }\n        }\n\n        cout << ub << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint n,w, len[51111],psum[51111];\nstruct SegTree{\n\tint n, seg[401111];\n\tvoid init(int _n){\n\t\tn=_n;\n\t\tmemset(seg,0,sizeof(seg));\n\t}\n\tvoid set(int i, int x){\n\t\t// printf(\"[%d] = %d\\n\",i,x);\n\t\tset(i,x,0,n,0);\n\t}\n\tint qmax(int l, int r){\n\t\t// printf(\"%d - %d:  %d\\n\",l,r,qmax(l,r,0,n,0));\n\t\treturn qmax(l,r,0,n,0);\n\t}\n\tvoid set(int i, int x, int sl, int sr, int sid){\n\t\tif(sr<=i || i<sl)return;\n\t\tif(sr-sl<=1){\n\t\t\tseg[sid]=x; return;\n\t\t}\n\t\tset(i, x, sl, (sl+sr)/2, sid*2+1);\n\t\tset(i, x, (sl+sr)/2, sr, sid*2+2);\n\t\tseg[sid] = max(seg[sid*2+1], seg[sid*2+2]);\n\t}\n\tint qmax(int l, int r, int sl, int sr, int sid){\n\t\tif(sr<=l || r<=sl)return 0;\n\t\tif(l<=sl && sr<=r)return seg[sid];\n\t\treturn max(qmax(l, r, sl, (sl+sr)/2, sid*2+1), qmax(l, r, (sl+sr)/2, sr, sid*2+2));\n\t}\n}st;\nint ceiling(int x, int y){\n\tif(y==0){\n\t\tprintf(\"QQ %d %d\\n\",x,y);\n\t\twhile(1);\n\t}\n\treturn (x-1)/y+1;\n}\nbool check(int d){\n\t// printf(\"\\t\\t\\td = %d\\n\",d);\n\tstatic int dp[51111];\n\tmemset(dp,0,sizeof(dp));\n\tst.init(n);\n\n\tfor(int i=1; i<n; i++){\n\t\t// printf(\" i= %d\\n\",i);\n\t\tint lb=-1, ub=i-1, b, a;\n\t\twhile(1<ub-lb){\n\t\t\tint md=(lb+ub)/2;\n\t\t\tif(ceiling(w-psum[i+1]+psum[md+1], i-md-1)<=d)\n\t\t\t\tlb=md;\n\t\t\telse\n\t\t\t\tub=md;\n\t\t}\n\t\tb=lb;\n\t\tlb=-1, ub=i;\n\t\twhile(1<ub-lb){\n\t\t\tint md=(lb+ub)/2;\n\t\t\tif(psum[i+1]-psum[md+1]+i-md-1<=w)\n\t\t\t\tub=md;\n\t\t\telse\n\t\t\t\tlb=md;\n\t\t}\n\t\ta= ub;\n\t\t// printf(\"%d - %d\\n\",a,b);\n\t\tif(psum[i+1]+i<=w && ceiling(w-psum[i+1], i)<=d)dp[i]=1;\n\t\t// printf(\"%d<=%d && %d/%d<=%d\\n\", psum[i+1]+i,w, w-psum[i+1], i, d);\n\t\tif(a<=b)\n\t\t\tdp[i] = st.qmax(a,b+1);\n\t\tst.set(i,dp[i]);\n\t\t// printf(\"dp(%d) = %d\\n\",i,dp[i]);\n\t}\n\tint res=0;\n\tfor(int i=0; i<n-1; i++){\n\t\tif(psum[n]-psum[i+1]+n-i-1<=w)\n\t\t\tres = max(res, dp[i]);\n\t}\n\n\treturn res || dp[n-1] || psum[n]+n-1<=w;\n\n}\nint main(){\n\twhile(scanf(\"%d%d\",&w,&n)&&(n+w>0)){\n\t\tfor(int i=0; i<n; i++)scanf(\"%d\",&len[i]);\n\t\tpsum[0]=0;\n\t\tfor(int i=0; i<n; i++)psum[i+1] = psum[i]+len[i];\n\t\tint lb=0, ub=w;\n\t\twhile(1<ub-lb){\n\t\t\tint md=(lb+ub)/2;\n\t\t\tif(check(md))\n\t\t\t\tub=md;\n\t\t\telse\n\t\t\t\tlb=md;\n\t\t}\n\t\tprintf(\"%d\\n\",ub);\n\t}\n}\n\n/*\n\n11 4\n4 2 1 3\n5 7\n1 1 1 2 2 1 2\n11 7\n3 1 3 1 3 3 4\n100 3\n30 30 39\n30 3\n2 5 3\n0 0\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define TIMES(i, n) for(int i = 0; i < (n); ++i)\n\ntemplate<class Pred>\nint binsearch(const Pred &pred) {\n    int val = 0;\n    for(int bit = 17; bit >= 0; --bit) {\n        const int next = val + (1<<bit);\n        val = pred(next) ? next : val;\n    }\n    return val;\n}\n\nbool solve() {\n    int W, N;\n    scanf(\"%d %d\", &W, &N);\n    if(!W && !N) return false;\n\n    vector<long long> sum(N+2, 0);\n    TIMES(i, N) {\n        int v;\n        scanf(\"%d\", &v);\n        sum[i+1] = v;\n        sum[i+1] += sum[i];\n    }\n    sum[N+1] = sum[N];\n\n    vector<int> dp(N+3, 0);\n    int ans = binsearch([&](long long x) {\n        if(x > W) return false;\n        fill(dp.begin(), dp.end(), 0);\n        dp[N+2] = 0;\n        dp[N+1] = 1;\n        for(int i = N; i > 0; --i) {\n            const int mink = binsearch([&](int k) {\n                if(i+k > N) return false;\n                const long long len = (sum[i+k] - sum[i-1]) + k*x;\n                return len < W;\n            }) + 2;\n            const int maxk = binsearch([&](int k) {\n                if(i+k > N) return false;\n                const long long len = (sum[i+k] - sum[i-1]) + k;\n                return len <= W;\n            }) + 1;\n            //cout << x << ' ' << i << ' ' << mink << ' ' << maxk << endl;\n            dp[i] = (i+maxk == N+1) || (mink <= maxk && dp[i+mink] - dp[i+maxk+1] > 0);\n            //cout << dp[i] << endl;\n            dp[i] += dp[i+1];\n        }\n        return dp[1] - dp[2] == 0;\n    }) + 1;\n    printf(\"%d\\n\", ans);\n    return true;\n}\n\nint main() {\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<string>\n#include<cstring>\n#include<map>\n#include<numeric>\n#include<sstream>\n#include<cmath>\nusing namespace std;\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define pb push_back\n#define f(i,x,y) for(int i = x; i<y; i++ )\n#define FORV(it,A) for(vector<int>::iterator it = A.begin(); it!= A.end(); it++)\n#define FORS(it,A) for(set<int>::iterator it = A.begin(); it!= A.end(); it++)\n#define quad(x) (x) * (x)\n#define mp make_pair\n#define clr(x, y) memset(x, y, sizeof x)\n#define fst first\n#define snd second\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\n\n#define N 100000\nll S[N], v[N];\nint pd[N];\nint W, n;\n\n\ninline ll teto (ll a, ll b){\n\treturn ((a-1)/b)+1;\n\t//if (a%b == 0) return a/b;\n\t//return a/b+1;\n}\n\nint solve (int E){\n\tpd[n] = 0;\n\tpd[n-1] = 1;\n\tfor (int i = n-2; i >= 0; i--){\n\t\tint ini = i, fim = n-1;\n\t\twhile (ini < fim-1){\n\t\t\tint mid = ((ini+fim)>>1);\n\t\t\tll s = S[mid];\n\t\t\tif (i != 0) s -= S[i-1];\n\t\t\tif (s+mid-i <= W) ini = mid;\n\t\t\telse fim = mid-1;\n\t\t}\n\t\tint y;\n\t\tll s = S[fim];\n\t\tif (i != 0) s -= S[i-1];\n\t\tif (s+fim-i <= W) y = fim;\n\t\telse y = ini;\n\t\tini = i+1, fim = y;\n\t\twhile (ini < fim){\n\t\t\tint mid = ((ini+fim)>>1);\n\t\t\tll s = S[mid];\n\t\t\tif (i != 0) s -= S[i-1];\n\t\t\tif (teto(W-s, mid-i) <= E) fim = mid; //TODO\n\t\t\telse ini = mid+1;\n\t\t}\n\t\ts = S[y];\n\t\tif (i != 0) s -= S[i-1];\n\t\tint soma;\n\t\tif (teto(W-s, y-i) > E) soma = 0; //TODO\n\t\telse soma = pd[ini+1]-pd[y+2];\n\t\tif (y == n-1) soma = 1;\n\t\tpd[i] = pd[i+1];\n\t\tif (soma != 0) pd[i]++;\n\t}\n\treturn pd[0]-pd[1];\n}\n\nint main (){\n\twhile (1){\n\t\tcin >> W >> n;\n\t\tif (W+n == 0) break;\n\t\tf (i, 0, n) cin >> S[i];\n\t\tf (i, 1, n) S[i] += S[i-1];\n\t\tint ini = 1, fim = W/2+1;\n\t\twhile (ini < fim){\n\t\t\tint mid = (ini+fim)/2;\n\t\t\tif (solve(mid)) fim = mid;\n\t\t\telse ini = mid+1;\n\t\t}\n\t\tprintf(\"%d\\n\", ini);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\narray<int,(int)(1e5)> ok;\narray<int,(int)(1e5)> oksum;\n\nbool check(int w,int n,vector<ll> &sumx,ll sp,vector<int> &ubs){\n    fill(ok.begin(),ok.begin()+n+1,false);\n    fill(oksum.begin(),oksum.begin()+n+2,false);\n    ok[n]=true;\n    ok[n-1]=true;\n    oksum[n+1]=0;\n    oksum[n]=1;\n    oksum[n-1]=2;\n    for(int i=n-2;i>=0;i--){\n        //cerr<<\"1check\"<<i<<endl;\n        int j=ubs[i];\n        int lb=i+1; //[i,lb)de tarinai\n        int ub=j;\n        while(ub-lb>1){\n            int mid=((lb+ub)>>1);\n            ll mot=w-(sumx[mid]-sumx[i]);\n            ll chi=mid-i-1;\n            if(mot+chi-1>sp*chi){\n                lb=mid;\n            }\n            else{\n                ub=mid;\n            }\n        }\n        //cerr<<\"2check\"<<i<<endl;\n        int b=ub;\n        //check [b,j)\n        if(j==n+1 || oksum[b]-oksum[j]>0){\n            ok[i]=true;\n        }\n        else{\n            ok[i]=false;\n        }   \n        //cerr<<\"#\"<<i<<\" \"<<b<<\" \"<<j<<\" \"<<ok[i]<<endl;\n        oksum[i]=oksum[i+1]+ok[i];\n    }\n    //cerr<<sp<<endl;\n    //string buf;\n    //cin>>buf;\n    \n    return ok[0];\n}\n\nint solve(int w,int n){\n\n    vector<ll> x(n);\n    for(int i=0;i<n;i++) cin>>x[i];\n    vector<ll> sumx(n+1);\n    for(int i=0;i<n;i++){\n        sumx[i+1]=sumx[i]+x[i];\n    }\n    vector<int> ubs(n);\n    for(int i=n-2;i>=0;i--){\n        int lb=i;\n        int ub=n+1;\n        //cerr<<\"check\"<<i<<endl;\n        //[i,lb) is ok\n        //w-(sumx[lb]-sumx[i])>=lb-i-1\n        //w+i+1>=sumx[lb]-sumx[i]+lb\n        while(ub-lb>1){\n            int mid=(lb+ub)/2;\n            ll sux=sumx[mid]-sumx[i]+mid;\n        //cerr<<\"#\"<<mid<<\" \"<<sux<<\" \"<<w+i+1<<endl;\n            if(w+i+1>=sux){\n                lb=mid;\n            }\n            else{\n                ub=mid;\n            }\n        }\n        ubs[i]=ub;\n    }\n    int lb=0;   \n    int ub=w;\n    //cerr<<\"End summation\"<<endl;\n    while(ub-lb>1){\n        int mid=(lb+ub)/2;\n        if(!check(w,n,sumx,mid,ubs)){\n            lb=mid;\n        }\n        else{\n            ub=mid;\n        }\n    }\n    return ub;\n}\n\nint main(){\n    int w,n;\n    while(cin>>w>>n,w){\n        cout<<solve(w,n)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_N 50000\n#define INF 100000000\n#define MOD 1000000007\n#define RANK 1000000000\n#define EPS 1e-10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> IP;\n\nint w, n;\nint bit[MAX_N+1];\nint x[MAX_N];\nint sum[MAX_N+1];\n\nint bsum(int i){\n\tint s = 0;\n\twhile(i > 0){\n\t\ts += bit[i];\n\t\ti -= i&-i;\n\t}\n\treturn s;\n}\n\nvoid add(int i){\n\twhile(i <= n){\n\t\tbit[i]++;\n\t\ti += i&-i;\n\t}\n}\n\nbool check(int le){\n    memset(bit,0,sizeof(bit));\n    \n    int prest = -1;\n    int s, e, mid;\n    int st, en;\n    int v, q;\n    \n    for(int i = 1; i < n; i++){\n        s = prest; e = i;\n        while(e-s > 1){\n            mid = (s+e)/2;\n            if(sum[i+1]-sum[mid]-1 > w){\n                s = mid;\n            } else{\n                e = mid;\n            }\n        }\n        st = e;\n        prest = st-1;\n        if(i == n-1){\n            en = i;\n        } else{\n            s = -1; e = i;\n            while(e-s > 1){\n                mid = (s+e)/2;\n                if((w+i-mid-sum[i+1]+sum[mid])/(i-mid)+1 > le){\n                    e = mid;\n                } else{\n                    s = mid;\n                }\n            }\n            en = s;\n        }\n        if(st > en) continue;\n        if(st == 0) q = 1;\n        else q = bsum(en)-bsum(st-1);\n        if(q){\n            add(i+1);\n            if(i == n-1) return true;\n        }\n    }\n    return false;\n}\n\nint solve(){\n    rep(i,n) scanf(\"%d\",x+i);\n    rep(i,n){\n        if(i == 0){\n            sum[i+1] = x[i]+1;\n        } else{\n            sum[i+1] = sum[i]+x[i]+1;\n        }\n    }\n    int ss = 0, ee = w, mid;\n    while(ee-ss > 1){\n        mid = (ss+ee)/2;\n        if(check(mid)){\n            ee = mid;\n        } else{\n            ss = mid;\n        }\n    }\n    printf(\"%d\\n\",ee);\n}\n\nint main(){\n    while(scanf(\"%d%d\",&w,&n)){\n        if(w == 0 && n == 0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\nconst int maxn=50000+10;\nint sum[maxn],num[maxn],N,W,R[maxn];\n\ninline int len(int l,int r)\n{\n    if (l>=r) return 0;\n    if (sum[r]-sum[l-1]+r-l>W) return -1;\n    return (W-(sum[r]-sum[l-1])+(r-l-1))/(r-l);\n}\n\nbool solve(int can)\n{\n    int now=1,st,ed,l,r,maxs=0;\n    memset(num,0,(N+2)*sizeof(int));\n    num[1]=-1;\n    int j=2;\n    for(int i=0;i<=N-2;i++)\n    {\n        now+=num[i];\n        if (now<=0||len(i+1,R[i+1])>can) continue;\n        while(j<=N&&len(i+1,j)>can) j++;\n        l=j;r=R[i+1];\n        num[l]++;\n        num[r+1]--;\n        if (r>maxs) maxs=r;\n        if (sum[N]-sum[r]+N-r<=W) return 1;\n    }\n    return 0;\n}\n\nint main()\n{\n    while(scanf(\"%d%d\",&W,&N)==2)\n    {\n        if (W==0&&N==0) break;\n        sum[0]=0;\n        for(int i=1;i<=N;i++) scanf(\"%d\",&sum[i]),sum[i]+=sum[i-1];\n        int st=1,ed=W/2+1;\n        if (sum[N]+N-1<=W) ed=1;\n        int j=N;\n        for(int i=N-1;i>=1;i--)\n        {\n            while(sum[j]-sum[i-1]+j-i>W) j--;\n            R[i]=j;\n        }\n        while(st<ed)\n        {\n            int mid=(st+ed)>>1;\n            if (solve(mid)) ed=mid;\n            else st=mid+1;\n        }\n        printf(\"%d\\n\",st);\n    }\n    return 0;\n}\n/*\n11 4\n4 2 1 3\n5 7\n1 1 1 2 2 1 2\n11 7\n3 1 3 1 3 3 4\n100 3\n30 30 39\n30 3\n2 5 3\n0 0\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n \ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n \n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n\n#define F first\n#define S second\n\n\n\nconst int M = 5 * ten(4) + 100;\nconst int inf = ten(8);\n\nint w, n, x[M];\nint sum_x[M];\n\n// [i, j]\nbool can_place_in_line(int i, int j)\n{\n    int rem_space = w - (sum_x[j + 1] - sum_x[i]);\n    int num_interval = j - i;\n    return num_interval > 0 && rem_space >= num_interval;\n}\n// [i, j]\nint max_space(int i, int j)\n{\n    int rem_space = w - (sum_x[j + 1] - sum_x[i]);\n    int num_interval = j - i;\n    if (num_interval > 0 && rem_space >= num_interval)\n        return (rem_space + (num_interval - 1)) / num_interval;\n    else\n        return inf;\n}\nbool can_place_in_last(int i)\n{\n    int rem_space = w - (sum_x[n] - sum_x[i]);\n    int num_interval = n - i - 1;\n    return rem_space >= num_interval;\n}\nbool check(int upper_space)\n{\n    int dp[M]; // can place i in beginning if sum[i=0..i](dp[i]) > 0\n    fill_n(dp, n + 1, 0);\n    dp[0] = 1;\n    dp[1] = -1;\n\n    int left = 0, right = 0;\n    rep(i, n)\n    {\n        if (dp[i] > 0)\n        {\n            // can place [i..j]( j = [left..right) ) in one line\n            chmax(left, i + 1);\n            while (left < n && can_place_in_line(i, left) && max_space(i, left) > upper_space)\n                ++left;\n\n            chmax(right, left + 1);\n            while (right < n && can_place_in_line(i, right) && max_space(i, right) <= upper_space)\n                ++right;\n\n            if (can_place_in_line(i, left))\n            {\n                // can place [(left + 1)..right] in beginning\n                ++dp[left + 1];\n                --dp[right + 1];\n            }\n        }\n\n        dp[i + 1] += dp[i];\n    }\n\n    rep(i, n)\n        if (dp[i] && can_place_in_last(i))\n            return true;\n    return false;\n}\nint main()\n{\n    while (scanf(\"%d%d\", &w, &n), n)\n    {\n        rep(i, n)\n            scanf(\"%d\", x + i);\n\n        sum_x[0] = 0;\n        rep(i, n)\n            sum_x[i + 1] = sum_x[i] + x[i];\n\n        int low = 0, high = w - 2;\n        while (high - low > 1)\n        {\n            int mid = (low + high) / 2;\n            if (check(mid))\n                high = mid;\n            else\n                low = mid;\n        }\n        printf(\"%d\\n\", high);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\ninline int f(int n, int i, int L, const vector<int>& sum_rev){\n    return (sum_rev[i - n] - sum_rev[i]) + L * (n - 1);\n}\n\nint dp[50010];\nint sum_dp[50010];\n\nint main(){\n    int W, N;\n    while(cin >> W >> N && N){\n        vector<int> x(N);\n        REP(i, N) cin >> x[i];\n\n        vector<int> sum_rev(N + 1);\n        sum_rev[N] = 0;\n        for(int i = N - 1; i >= 0; i--){\n            sum_rev[i] = sum_rev[i + 1] + x[i];\n        }\n\n        int lb_L = 0, ub_L = W; // ub\n        while(ub_L - lb_L > 1){\n            int L = (lb_L + ub_L) / 2;\n            dp[0] = 1;\n            dp[1] = 0;\n            sum_dp[1] = 1;\n            sum_dp[2] = 1;\n\n            for(int i = 2; i < N; i++){\n                dp[i] = 0;\n                sum_dp[i] = sum_dp[i - 1] + dp[i - 1];\n \n                int lb = 1, ub = min(i, (W + L)/(L + 1) + 1); // ub  true ??\n                while(ub - lb > 1){\n                    int n = (ub + lb) / 2;\n                    if(f(n, i, L, sum_rev) >= W){\n                        ub = n;\n                    }else{\n                        lb = n;\n                    }\n                }\n                int begin_n = ub;\n\n                //printf(\"dp[%d] : begin %d \\n\", i, begin_n);\n                if(f(begin_n, i, L, sum_rev) < W){\n                    continue;\n                }\n\n                lb = begin_n, ub = i + 1; // lb\n                while(ub - lb > 1){\n                    int n = (ub + lb) / 2;\n                    if(f(n, i, 1, sum_rev) <= W){\n                        lb = n;\n                    }else{\n                        ub = n;\n                    }\n                }\n                int end_n = lb; \n\n                //printf(\"dp[%d] : end %d \\n\", i, end_n);\n                if(f(end_n, i, 1, sum_rev) > W) {\n                    continue;\n                }\n\n                int begin = i - end_n;\n                int end = i - begin_n;\n                // [begin, end]\n                if(sum_dp[end + 1] - sum_dp[begin] > 0){\n                    dp[i] = 1;\n                }\n                //printf(\"dp[%d] : [dp[%d], dp[%d]] (%d) -> %d\\n\", i, begin, end, sum_dp[end + 1] - sum_dp[begin], dp[i]);\n            }\n\n            bool ok = false;\n            for(int n = 1; n <= N && (n - 1) + sum_rev[N - n] <= W; n++) {\n                //printf(\"n - 1 + sum_rev[%d] = %d\\n\", i, n - 1 + sum_rev[i]);\n                if(dp[N - n]){\n                    ok = true;\n                    break;\n                }\n            }\n            //printf(\"L %d  is %d\\n\", L, ok);\n\n            if(ok){\n                ub_L = L;\n            }else{\n                lb_L = L;\n            }\n        }\n\n        cout << ub_L << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string.h>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <stdio.h>\n\nusing namespace std;\n\n#define fo(i,n) for(int i=0; i<(int)n; i++)\n#define rep(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#define mp(a,b) make_pair(a,b)\n#define pb(x) push_back(x)\n#define pii pair<int,int>\n\nint w,n;\nint v[50100];\nint f[50100];\n\nbool check(int x) {\n    for(int i=0; i<=n+1; i++) f[i] = 0;\n    int l = 1, r = 1;\n    int suml = v[0], sumr = v[0];\n    f[0] = 1;\n    f[1] = -1;\n\n    for (int i=0; i<n; i++) {\n        f[i+1] += f[i];\n        if (f[i]>0) {\n            while (l<n && suml<=w) {\n                suml += 1 + v[l];\n                l++;\n            }\n            while (r<n && sumr<w) {\n                sumr += x + v[r];\n                r++;\n            }\n            f[l]--;\n            f[r]++;\n            if (l==n && suml<=w) f[n]++;\n        }\n        suml -= 1+v[i];\n        sumr -= x+v[i];\n    }\n    return f[n]>0;\n}\n\nint main() {\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n    while (cin>>w>>n && w!=0) {\n        for (int i=0; i<n; i++) scanf(\"%d\",v+i);\n\n        int lo = 1;\n        int hi = w;\n        while (lo<hi) {\n            int mi = (lo+hi)/2;\n            if (check(mi)) hi = mi;\n            else lo = mi+1;\n        }\n\n        cout<<lo<<\"\\n\";\n    }\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint W, N, x[50009], dp[50009];\nint main() {\n\twhile (scanf(\"%d %d\", &W, &N), W) {\n\t\tfor (int i = 0; i < N; i++) scanf(\"%d\", &x[i + 1]), x[i + 1] += x[i];\n\t\tint l = 1, r = W + 1;\n\t\twhile (r - l > 1) {\n\t\t\tint m = (l + r) >> 1, pl = 0, pr = 0;\n\t\t\tdp[1] = dp[2] = 1;\n\t\t\tfor (int j = 2; j <= N; j++) {\n\t\t\t\twhile (x[j] - x[pl] > W - (j - pl - 1)) pl++;\n\t\t\t\twhile (j != pr + 1 && x[j] - x[pr] > W - (j - pr - 1) * m) pr++;\n\t\t\t\tdp[j + 1] = dp[j] + (dp[pr] > dp[pl] ? 1 : 0);\n\t\t\t}\n\t\t\tbool flag = false;\n\t\t\tfor (int j = 0; j <= N; j++) {\n\t\t\t\tif (dp[j] != dp[j + 1] && x[N] - x[j] + N - j - 1 <= W) flag = true;\n\t\t\t}\n\t\t\tif (flag) r = m;\n\t\t\telse l = m;\n\t\t}\n\t\tprintf(\"%d\\n\", l);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\n#include <iomanip>\n#include <fstream>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int MAX_N = 50010;\n\nbool dp[MAX_N];\n\nint x[50000];\nint sum[50001];\nint w,n;\n\ninline bool ok2(int a, int b) { // [a,b]をぎりぎりで詰めたときwに入るかどうか\n  int num = b-a+1;\n  int space = num-1;\n  // cout << \"ok2 : \" << a << \",\" << b << \" : \" << sum[b+1]-sum[a]+space << endl;\n  return sum[b+1]-sum[a] + space <= w;\n}\n\ninline bool ok3(int a, int b, int m) {        // [a,b]を余裕を持って詰めたとき幅m以下でwを埋めれるかどうか\n  int num = b-a+1;\n  int space = (num-1) * m;\n  // cout << \"ok3 : \" << a << \",\" << b << \" : \" << sum[b+1]-sum[a]+space << endl;\n  return sum[b+1]-sum[a]+space >= w;\n}\n\nbool ok(int m) {\n  if (ok2(0,n-1)) return 1;\n  int a = 0, b = 0;\n  int cnt = 0;\n  // REP(i,n+1)dp[i]=0;\n  // memset(dp,0,sizeof(dp));\n  // cout << \"m = \" << m << endl;\n  dp[0] = 1;\n  REP(i,n) {\n    while(a<=i&&!ok2(a,i)) {\n      if (dp[a]) cnt--;\n      a++;\n    }\n    while(b<=i&&ok3(b,i,m)) {\n      if (dp[b]) cnt++;\n      b++;\n    }\n    // cout <<  i << \" : \" << a << \" \" << b << \" \"  << cnt << endl;\n    if (cnt) {\n      dp[i+1] = 1;\n      if (ok2(i+1,n-1)) return 1;\n    } else {\n      dp[i+1] = 0;\n    }\n  }\n  return 0;\n}\n\nint main() {\n  while(scanf(\"%d%d\",&w,&n),w||n) {\n    REP(i,n) scanf(\"%d\",x+i);\n    REP(i,n) sum[i+1] = sum[i] + x[i];\n    int low=0,high=w;\n    while(low+1<high) {\n      int mid = (low + high) / 2;\n      if (ok(mid)) high = mid;\n      else low = mid;\n    }\n    cout << high << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[114514];\nint x[114514];\ntypedef pair<int,int> P;\nint mceil(int p,int q){\n  return (p+q-1)/q;\n}\nint main(){\n  int w,n;\n  while(cin>>w>>n,w||n){\n    for(int i=0;i<n;i++) cin>>x[i];\n    fill(dp,dp+114514,w);\n    priority_queue<P,vector<P>,greater<P> > q;\n    q.push(P(0,0));\n    dp[0]=0;\n    while(!q.empty()){\n      P p=q.top();q.pop();\n      int s=p.first,k=p.second;\n      if(dp[k]<s) continue;\n      if(k==n) break;\n      int tmp=0;\n      for(int i=k;i<n;i++){\n\ttmp+=x[i];\n\tif(i!=n-1&&i==k) continue;\n\tif(w<tmp+i-k) break;\n\tint res;\n\tif(i==n-1) res=max(s,1);\n\telse res=max(s,mceil(w-tmp,i-k));\n\t//cout<<i<<\":\"<<res<<endl;\n\tif(res<dp[i+1]&&res<dp[n]){\n\t  dp[i+1]=res;\n\t  q.push(P(dp[i+1],i+1));\n\t}\n      }\n    }\n    //for(int i=0;i<n;i++) cout<<i<<\" \"<<dp[i]<<endl;\n    cout<<dp[n]<<endl;;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define TIMES(i, n) for(int i = 0; i < (n); ++i)\n\ntemplate<class Pred>\nint binsearch(const Pred &pred) {\n    int val = 0;\n    for(int bit = 20; bit >= 0; --bit) {\n        const int next = val + (1<<bit);\n        val = pred(next) ? next : val;\n    }\n    return val;\n}\n\nbool solve() {\n    int W, N;\n    scanf(\"%d %d\", &W, &N);\n    if(!W && !N) return false;\n\n    vector<long long> sum(N+2, 0);\n    TIMES(i, N) {\n        int v;\n        scanf(\"%d\", &v);\n        sum[i+1] = v;\n        sum[i+1] += sum[i];\n    }\n    sum[N+1] = sum[N];\n\n    vector<int> dp(N+3, 0);\n    int ans = binsearch([&](long long x) {\n        if(x > W) return false;\n        fill(dp.begin(), dp.end(), 0);\n        dp[N+2] = 0;\n        dp[N+1] = 1;\n        for(int i = N; i > 0; --i) {\n            const int mink = binsearch([&](int k) {\n                if(i+k > N) return false;\n                const long long len = (sum[i+k] - sum[i-1]) + k*x;\n                return len < W;\n            }) + 2;\n            const int maxk = binsearch([&](int k) {\n                if(i+k > N) return false;\n                const long long len = (sum[i+k] - sum[i-1]) + k;\n                return len <= W;\n            }) + 1;\n            //cout << x << ' ' << i << ' ' << mink << ' ' << maxk << endl;\n            dp[i] = (i+maxk == N+1) || (mink <= maxk && dp[i+mink] - dp[i+maxk+1] > 0);\n            //cout << dp[i] << endl;\n            dp[i] += dp[i+1];\n        }\n        return dp[1] - dp[2] == 0;\n    }) + 1;\n    printf(\"%d\\n\", ans);\n    return true;\n}\n\nint main() {\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <ctime>\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\n#include <valarray>\n\nusing namespace std;\ntypedef long long ll;\n\n#define ALL(c) (c).begin(),(c).end()\n#define FOR(i,l,r) for(int i=(int)l;i<(int)r;++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORr(i,l,r) for(int i=(int)r-1;i>=(int)l;--i)\n#define REPr(i,n) FORr(i,0,n)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\ntemplate<typename T,typename U> T pmod(T x,U M){return (x%M+M)%M;}\n\n\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\n\n\n\nnamespace Fenwicks{\n  template<typename T> class Fenwick{\n  public:\n    int size;vector<T> bit;\n    Fenwick():Fenwick(0){}\n    Fenwick(int n):size(n){bit = vector<T>(n+1);}\n    T sum(int n){// [0,n)\n      T s=0;\n      while(n>0){\n        s+=bit[n];\n        n-=n&-n;//low\n      }\n      return s;\n    }\n    void add(int i,T x){//[0,...i...,n)\n      i++;\n      while(i<=size){\n        bit[i]+=x;\n        i+=i & -i;//next\n      }\n    }\n    \n    //lib\n    T sum(int a,int b){// [a,b)\n      return sum(b)-sum(a);\n    }\n  };\n}\nusing namespace Fenwicks;\n\n\ntemplate <typename T,typename Func> T satisfy_min(T l ,T r,Func P){\n  l--;\n  while(r-l>1)(P((l+r)/2)?r:l)=(l+r)/2;\n  return r;\n}\n\n// max{i∈[l,r) | P(i)}．存在しない時、 l-1．\ntemplate <typename T,typename Func> T satisfy_max(T l ,T r,Func P){\n  l--;\n  while(r-l>1)(P((l+r)/2)?l:r)=(l+r)/2;\n  return l;\n}\n\n\nint W,N;\nvector<int> xs;\n\nvector<ll> xsum,wsum;\nint can(int spM){\n  Fenwick<int> fen(N);\n  //last\n  FORr(i,0,N)if(wsum[N]-wsum[i]-1<=W)fen.add(i,1);\n\n  //back \"[i,N)がok\" =def \"1区間 [i,m)がok\" かつ \"*区間 [m,N)がok\"\n  FORr(i,0,N-1)if(!fen.sum(i,i+1)){\n    //[i,l)\n    int l=satisfy_min(i+2,N,[&](int ml)->bool{\n      ll spc=ml-i-1,sp=(W-(xsum[ml]-xsum[i]) + spc-1)/spc;\n      return sp<=spM;\n    });\n    //[i,r)\n    int r=satisfy_max(i+2,N,[&](int mr)->bool{\n        return wsum[mr]-wsum[i]-1<=W;\n    });\n    if(l<=r && fen.sum(l,r+1)>0)fen.add(i,1);\n  }\n  return fen.sum(0,1)==1;\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n  // ofstream cout( \"out\" );\n\tcerr << fixed <<setprecision(20);\n\tcout << fixed <<setprecision(20);\n\n  while (true) {\n    cin >> W>> N;if(N==0)break;\n    xs=vector<int>(N);REP(i,N)cin >> xs[i];\n\n    xsum=vector<ll>(N+1);\n    FOR(i,1,N+1)xsum[i]=xsum[i-1]+xs[i-1];\n    wsum=vector<ll>(N+1);\n    FOR(i,1,N+1)wsum[i]=wsum[i-1]+1+xs[i-1];\n\n    int res=satisfy_min(1,100000,[&](int m){\n      return can(m);\n    });\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint c[51000];\nint segtree[131072];\nint sz;\ninline int query(int a){\n\ta+=sz;\n\twhile(a){\n\t\tif(segtree[a])return 1;\n\t\ta/=2;\n\t}\n\treturn 0;\n}\nvoid add(int a,int b,int c,int d,int e,int f){\n\tif(d<a||b<c)return;\n\tif(c<=a&&b<=d){\n\t\tsegtree[e]+=f;\n\t\treturn;\n\t}\n\tadd(a,(a+b)/2,c,d,e*2,f);\n\tadd((a+b)/2+1,b,c,d,e*2+1,f);\n}\nint sum[51000];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tsz=1;\n\t\twhile(sz<b+1)sz*=2;\n\t\tfor(int i=0;i<b;i++)scanf(\"%d\",c+i);\n\t\tfor(int i=0;i<b;i++)sum[i+1]=sum[i]+c[i];\n\t\tint L=0;\n\t\tint R=a/2;\n\t\twhile(L+1<R){\n\t\t\tint M=(L+R)/2;\n\t\t\tfor(int i=0;i<sz*2;i++)segtree[i]=0;\n\t\t\tadd(0,sz-1,0,0,1,1);\n\t\t\tfor(int i=0;i<b;i++){\n\t\t\t\tif(!query(i))continue;\n\t\t\t\tif(sum[b]-sum[i]+b-i-1<=a){\n\t\t\t\t\tadd(0,sz-1,b,b,1,1);break;\n\t\t\t\t}\n\t\t\t\tint l=i;\n\t\t\t\tint r=b;\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tint m=(l+r)/2;\n\t\t\t\t\tif(M*(m-i-1)>=a-(sum[m]-sum[i]))r=m;\n\t\t\t\t\telse l=m;\n\t\t\t\t}\n\t\t\t\tint v1=r;\n\t\t\t\tl=i-1;\n\t\t\t\tr=b;\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tint m=(l+r)/2;\n\t\t\t\t\tif(m-i-1>a-(sum[m]-sum[i]))r=m;\n\t\t\t\t\telse l=m;\n\t\t\t\t}\n\t\t\t\tint v2=l;\n\t\t//\t\tprintf(\"%d %d %d %d\\n\",M,i,v1,v2);\n\t\t\t\tif(v1<=v2)add(0,sz-1,v1,v2,1,1);\n\t\t\t}\n\t\t\tif(query(b))R=M;\n\t\t\telse L=M;\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1333\nTitle Beautiful Spacing\n*/\n#include <stdio.h>\n#include <string.h>\n#define min(x,y) (((x)<(y))?(x):(y))\n#define max(x,y) (((x)>(y))?(x):(y))\n//Global data section\nint W,N;\nint x[50000];\nint space[50000];\n//\nint my_ceil(int a,int b)\n{\n        int ret;\n\n        ret=a/b+((a%b)?1:0);\n        return(ret);\n}\nint solve(int start,int depth,int caller)\n{\n        int sum,cnt,i;\n        int ret=0,ret1,xx;\n        int gyoutou=1;\n        int min_sp,max_sp;\n        char * color;\n#ifdef DEBUG\n        if(depth==0)\n                color=\"\\x1b[31m\";\n        else if(depth==1)\n                color=\"\\x1b[32m\";\n        else if(depth==2)\n                color=\"\\x1b[33m\";\n        else if(depth==3)\n                color=\"\\x1b[34m\";\n        else if(depth==4)\n                color=\"\\x1b[35m\";\n        else if(depth==5)\n                color=\"\\x1b[36m\";\n        else\n                color=\"\\x1b[37m\";\n        for(i=0;i<depth;i++)\n                printf(\":\");\n        printf(\"%s start=%d dp=%d cal=%d\\x1b[37m\\n\",\n               color,\n               start,depth,caller);\n#endif\n        if((ret=space[start])>0)\n        {\n#ifdef DEBUG\n                printf(\"DIRECT[%d] %d\\n\",start,ret);\n#endif\n                goto FIN;\n        }\n        cnt=0;sum=0;max_sp=0,min_sp=W;\n        for(i=start;i<N;i++)\n        {\n                cnt++;\n                \n                sum += x[i];\n\n                if(sum + (cnt-1)>W)\n                        break;\n\n                if(cnt==1)\n                        continue;     // wrong :ret=W-sum;\n                else\n                        ret=my_ceil(W-sum,cnt-1);\n#ifdef DEBUG\n                printf(\"s=%d x[%d]=%d  r=%d\\n\",sum,i,x[i],ret);\n#endif\n                //printf(\"SOVLE\\n\");\n                ret1=solve(i+1,1+depth,start);\n#ifdef DEBUG\n                printf(\"*ret=%d ret1=%d\\n\",ret,ret1);\n#endif\n                max_sp=max(ret,ret1);\n#ifdef DEBUG2\n                printf(\":max_sp=%d min_sp=%d\\n\",max_sp,min_sp);\n#endif\n                min_sp=min(min_sp,max_sp);\n#ifdef DEBUG2\n                printf(\"max_sp=%d min_sp=%d\\n\",max_sp,min_sp);\n#endif\n        }\n        ret=min_sp;\nFIN:\n#ifdef DEBUG\n        for(i=0;i<depth;i++)\n                printf(\":\");\n        printf(\"%s ret[%d]=%d \\x1b[37m\\n\",color,start,ret);\n#endif\n        if(space[start]==0)\n                space[start]=ret;\n        return(ret);\n}\nvoid init()\n{\n        int i,sum;\n\n        sum=x[N-1];\n        space[N-1]=1;\n        i=N-2;\n        while(1)\n        {\n                if(sum + 1 + x[i] > W)\n                        return;\n                sum += (1+x[i]);\n                space[i]=1;\n                i--;\n        }\n}\ndump()\n{\n        int i;\n        for(i=0;i<N;i++)\n                printf(\"%d:\",x[i]);\n        printf(\"\\n\");\n        for(i=0;i<N;i++)\n                printf(\"%d:\",space[i]);\n        printf(\"\\n\");\n}\nmain()\n{\n        int i,ret;\n\n        while(EOF!=scanf(\"%d %d\",&W,&N) && (W||N))\n        {\n                for(i=0;i<N;i++)\n                        scanf(\"%d \",&x[i]);\n                memset(&space[0],0,sizeof(int)*5000);\n                init();\n\n                ret=solve(0,0,0);\n\n                printf(\"%d\\n\",ret);\n\n\n        }\n        return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1333\nTitle Beautiful Spacing\n*/\n#include <stdio.h>\n#include <string.h>\n#define min(x,y) (((x)<(y))?(x):(y))\n#define max(x,y) (((x)>(y))?(x):(y))\n//Global data section\nint W,N;\nint x[50000];\nint space[50000];\n//\nint my_ceil(int a,int b)\n{\n        int ret;\n\n        ret=a/b+((a%b)?1:0);\n        return(ret);\n}\nint solve(int start,int depth,int caller)\n{\n        int sum,cnt,i;\n        int ret=0,ret1,xx;\n        int gyoutou=1;\n        int min_sp,max_sp;\n        char * color;\n        if((ret=space[start])>0)\n        {\n                goto FIN;\n        }\n        cnt=0;sum=0;max_sp=0,min_sp=W;\n        for(i=start;i<N;i++)\n        {\n                cnt++;\n                \n                sum += x[i];\n\n                if(sum + (cnt-1)>W)\n                        break;\n\n                if(cnt==1)\n                        ret=W-sum;\n                else\n                        ret=my_ceil(W-sum,cnt-1);\n                ret1=solve(i+1,1+depth,start);\n                max_sp=max(ret,ret1);\n                min_sp=min(min_sp,max_sp);\n        }\n        ret=min_sp;\nFIN:\n        if(space[start]==0)\n                space[start]=ret;\n        return(ret);\n}\nvoid init()\n{\n        int i,sum;\n\n        sum=x[N-1];\n        space[N-1]=1;\n        i=N-2;\n        while(i>=0)\n        {\n                if(sum + 1 + x[i] > W)\n                        return;\n                sum += (1+x[i]);\n                space[i]=1;\n                i--;\n        }\n}\ndump()\n{\n        int i;\n        for(i=0;i<N;i++)\n                printf(\"%d:\",x[i]);\n        printf(\"\\n\");\n        for(i=0;i<N;i++)\n                printf(\"%d:\",space[i]);\n        printf(\"\\n\");\n}\nmain()\n{\n        int i,ret;\n\n        while(EOF!=scanf(\"%d %d\",&W,&N) && (W||N))\n        {\n                for(i=0;i<N;i++)\n                        scanf(\"%d \",&x[i]);\n                memset(&space[0],0,sizeof(int)*5000);\n                init();\n\n                ret=solve(0,0,0);\n\n                printf(\"%d\\n\",ret);\n        }\n        return(0);\n}"
  },
  {
    "language": "C",
    "code": "n[1];main(i){for(n[1]=*n=1,n[2]=2;i-29;n[i+2]=n[i-1]+n[i]+n[++i]);for(;scanf(\"%d\",&i)*i;printf(\"%d\\n\",(n[i]+3649)/3650));}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1333\n  Title:Beautiful Spacing\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\n\nint w,n,x[50000],memo[50000];\n\nmy_ceil(int x,int y)\n{\n  int ret=x/y;\n  if(x % y)\n    return(ret+1);\n  else\n    return(ret);\n}\n\nint check_last_line(int start)\n{\n  int i,col;\n  \n  for(i=start,col=0;i<n;i++)\n    {\n      col += x[i];\n      if(col > w)\n\treturn(0);\n      col++;\n    }\n  return(-1);\n}\n\nint solve(int start)\n{\n  int col,i,words,ret,ret2;\n#ifdef DEBUG\n  printf(\"s=%d\\n\",start);\n#endif\n  col=0;\n\n  if((ret=memo[start]))\n    return(ret);\n  if(check_last_line(start))  //LAST LINE => 1 SPACE\n    ret2=1;\n  else\n    {\n      ret2=w;\n      col=x[start]+1;\n      words=2;\n\n      for(i=start+1;i<n;i++)\n\t{\n\t  col += x[i];\n\t  if(col > w)\n\t    break;\n\t  ret=1+my_ceil(w-col,words-1);\n\t  ret=max(solve(i+1),ret);\n\t  ret2=min(ret,ret2);\n\t  col++;\n\t  words++;\n\t}\n    }\n RET:\n  memo[start]=ret2;\n  return(ret2);\n}\nmain()\n{\n  int i,ret;\n\n\n  while(scanf(\"%d %d\",&w,&n) && (w||n))\n    {\n      memset(memo,0,sizeof(int)*5000);\n      for(i=0;i<n;i++)\n\tscanf(\"%d\",&x[i]);\n      for(i=n-1;i>=0;i--)\n\t  ret=solve(i);\n\n      printf(\"%d\\n\",memo[0]);\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1333\n  Title:Beautiful Spacing\n  @kankichi573\n  10/7 TLE\n*/\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\n\nint w,n,x[50000],memo[50000];\n\nint my_ceil(int x,int y)\n{\n  int ret=x/y;\n  if(x % y)\n    return(ret+1);\n  else\n    return(ret);\n}\n\nvoid check_last_line()\n{\n  int i,col;\n  \n  for(i=n-1,col=0;i>=0;i--)\n    {\n      col += x[i];\n      if(col > w)\n        return;\n      memo[i]=1;\n      col++;\n    }\n}\n\nint solve(int start)\n{\n  int col,i,words,ret,ret2;\n#ifdef DEBUG\n  printf(\"s=%d\\n\",start);\n#endif\n  col=0;\n\n  if((ret=memo[start]))\n    return(ret);\n  else\n    {\n      ret2=w;\n      col=x[start]+1;\n      words=2;\n\n      for(i=start+1;i<n;i++)\n\t{\n\t  col += x[i];\n\t  if(col > w)\n\t    break;\n\t  ret=1+my_ceil(w-col,words-1);\n\t  ret=max(solve(i+1),ret);\n\t  ret2=min(ret,ret2);\n\t  col++;\n\t  words++;\n\t}\n    }\n RET:\n  memo[start]=ret2;\n  return(ret2);\n}\nmain()\n{\n  int i,ret;\n\n\n  while(scanf(\"%d %d\",&w,&n) && (w||n))\n    {\n      memset(memo,0,sizeof(int)*5000);\n      for(i=0;i<n;i++)\n\tscanf(\"%d\",&x[i]);\n      check_last_line();\n      for(i=n-1;i>=0;i--)\n\t  ret=solve(i);\n\n      printf(\"%d\\n\",memo[0]);\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1333 Beautiful Spacing\n// 2018.4.5 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\nint  w, n;\nint  s[50002];\nchar dp[50002];\n\nint check(int x)\n{\n\tint i, lim, f, cnt;\n\n\tlim = f = n, cnt = 0;\n\tmemset(dp, 0, n);\n\ti = n; while (i--) {\n\t\twhile (w-(s[lim]-s[i]) < lim-i-1) cnt -= dp[lim--];\n\t\twhile (f > lim || f > i+1 && (w-(s[f]-s[i])+f-i-2) / (f-i-1) <= x)\n\t\t\tcnt += dp[f--];\n\t\tdp[i] = cnt > 0 || lim == n;\n\t}\n\treturn dp[0];\n}\n\nint main()\n{\n\tint i, lo, mi, hi;\n\n\twhile (w = in()) {\n\t\tn = in();\n\t\tfor (i = 1; i <= n; i++) s[i] = s[i-1] + in();\n\t\tlo = 0, hi = w;\n\t\twhile (lo + 1 < hi) {\n\t\t\tmi = (lo + hi) >> 1;\n\t\t\tif (check(mi)) hi = mi; else lo = mi;\n\t\t}\n\t\tprintf(\"%d\\n\", hi);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tsolver();\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw=new PrintWriter(System.out);\n\t\twhile (true) {\n\t\t\tint W = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif (W == 0 && n == 0)\n\t\t\t\tbreak;\n\t\t\tlong[] accum = new long[n + 1];\n\t\t\tint[] x = new int[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\taccum[i + 1] = accum[i] + x[i];\n\t\t\t}\n\t\t\tint lack = 0;\n\t\t\tint gap = 1;\n\t\t\touter: for (int i = 15; i >= -1; --i) {\n\t\t\t\tint ngap = gap + (i >= 0 ? (1 << i) : 0);\n\t\t\t\tint[] vis = new int[n + 1];\n\t\t\t\tvis[0] = 1;\n\t\t\t\tvis[1] = -1;\n\t\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\t\tvis[j] += (j > 0 ? vis[j - 1] : 0);\n\t\t\t\t\tif (vis[j] > 0) {\n\t\t\t\t\t\tif (accum[n] - accum[j] + (n - j - 1) <= W) {\n\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint left = j;\n\t\t\t\t\t\tint right = n;\n\t\t\t\t\t\twhile (right - left > 1) {\n\t\t\t\t\t\t\tint middle = (right + left) / 2;\n\t\t\t\t\t\t\tif (accum[middle] - accum[j] + (middle - j - 1) <= W) {\n\t\t\t\t\t\t\t\tleft = middle;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tright = middle;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint dmax = left;\n\n\t\t\t\t\t\tleft = j;\n\t\t\t\t\t\tright = n;\n\t\t\t\t\t\twhile (right - left > 1) {\n\t\t\t\t\t\t\tint middle = (right + left) / 2;\n\t\t\t\t\t\t\tif (W <= accum[middle] - accum[j] + (long) ngap * (middle - j - 1)) {\n\t\t\t\t\t\t\t\tright = middle;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tleft = middle;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint dmin = right;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (dmin > dmax)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t++vis[dmin];\n\t\t\t\t\t\t--vis[dmax + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++lack;\n\t\t\t\tgap = ngap;\n\t\t\t}\n\t\t\tif (lack > 0)\n\t\t\t\t++gap;\n\t\t\tpw.println(gap);\n\t\t}\n\t\tpw.close();\n\t\tsc.close();\n\t}\n\n\t\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.PrintWriter;\nimport java.util.*;\n\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tsolver();\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw=new PrintWriter(System.out);\n\t\twhile (true) {\n\t\t\tint W =Integer.parseInt(sc.next());\n\t\t\tint n = Integer.parseInt(sc.next());\n\t\t\tif (W == 0 && n == 0)\n\t\t\t\tbreak;\n\t\t\tlong[] accum = new long[n + 1];\n\t\t\tint[] x = new int[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tx[i] = Integer.parseInt(sc.next());\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\taccum[i + 1] = accum[i] + x[i];\n\t\t\t}\n\t\t\tint lack = 0;\n\t\t\tint gap = 1;\n\t\t\touter: for (int i = 15; i >= -1; --i) {\n\t\t\t\tint ngap = gap + (i >= 0 ? (1 << i) : 0);\n\t\t\t\tint[] vis = new int[n + 1];\n\t\t\t\tvis[0] = 1;\n\t\t\t\tvis[1] = -1;\n\t\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\t\tvis[j] += (j > 0 ? vis[j - 1] : 0);\n\t\t\t\t\tif (vis[j] > 0) {\n\t\t\t\t\t\tif (accum[n] - accum[j] + (n - j - 1) <= W) {\n\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint left = j;\n\t\t\t\t\t\tint right = n;\n\t\t\t\t\t\twhile (right - left > 1) {\n\t\t\t\t\t\t\tint middle = (right + left) / 2;\n\t\t\t\t\t\t\tif (accum[middle] - accum[j] + (middle - j - 1) <= W) {\n\t\t\t\t\t\t\t\tleft = middle;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tright = middle;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint dmax = left;\n\n\t\t\t\t\t\tleft = j;\n\t\t\t\t\t\tright = n;\n\t\t\t\t\t\twhile (right - left > 1) {\n\t\t\t\t\t\t\tint middle = (right + left) / 2;\n\t\t\t\t\t\t\tif (W <= accum[middle] - accum[j] + (long) ngap * (middle - j - 1)) {\n\t\t\t\t\t\t\t\tright = middle;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tleft = middle;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint dmin = right;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (dmin > dmax)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t++vis[dmin];\n\t\t\t\t\t\t--vis[dmax + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++lack;\n\t\t\t\tgap = ngap;\n\t\t\t}\n\t\t\tif (lack > 0)\n\t\t\t\t++gap;\n\t\t\tpw.println(gap);\n\t\t}\n\t\tpw.close();\n\t\tsc.close();\n\t}\n\n\t\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tsolver();\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint W = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif (W == 0 && n == 0)\n\t\t\t\tbreak;\n\t\t\tlong[] accum = new long[n + 1];\n\t\t\tint[] x = new int[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\taccum[i + 1] = accum[i] + x[i];\n\t\t\t}\n\t\t\tint lack = 0;\n\t\t\tint gap = 1;\n\t\t\touter: for (int i = 14; i >= -1; --i) {\n\t\t\t\t// gap+i???????????????????????????\n\t\t\t\tint ngap = gap + (i >= 0 ? (1 << i) : 0);\n\t\t\t\tint[] vis = new int[n + 1];\n\t\t\t\tvis[0] = 1;\n\t\t\t\tvis[1] = -1;\n\t\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\t\tvis[j] += (j > 0 ? vis[j - 1] : 0);\n\t\t\t\t\tif (vis[j] > 0) {\n\t\t\t\t\t\tif (accum[n] - accum[j] + (n - j - 1) <= W) {\n\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint left = j;// 0\n\t\t\t\t\t\tint right = n;// 5\n\t\t\t\t\t\twhile (right - left > 1) {\n\t\t\t\t\t\t\tint middle = (right + left) / 2;\n\t\t\t\t\t\t\tif (accum[middle] - accum[j] + (middle - j - 1) <= W) {\n\t\t\t\t\t\t\t\tleft = middle;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tright = middle;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint dmax = left;\n\n\t\t\t\t\t\tleft = j;\n\t\t\t\t\t\tright = n;\n\t\t\t\t\t\twhile (right - left > 1) {\n\t\t\t\t\t\t\tint middle = (right + left) / 2;\n\t\t\t\t\t\t\tif (W <= accum[middle] - accum[j] + (long) ngap * (middle - j - 1)) {\n\t\t\t\t\t\t\t\tright = middle;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tleft = middle;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint dmin = right;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (dmin > dmax)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t++vis[dmin];\n\t\t\t\t\t\t--vis[dmax + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++lack;\n\t\t\t\tgap = ngap;\n\t\t\t}\n\t\t\tif (lack > 0)\n\t\t\t\t++gap;\n\t\t\tSystem.out.println(gap);\n\t\t}\n\t}\n\n\t\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tsolver();\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw=new PrintWriter(System.out);\n\t\twhile (true) {\n\t\t\tint W = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif (W == 0 && n == 0)\n\t\t\t\tbreak;\n\t\t\tlong[] accum = new long[n + 1];\n\t\t\tint[] x = new int[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\taccum[i + 1] = accum[i] + x[i];\n\t\t\t}\n\t\t\tint lack = 0;\n\t\t\tint gap = 1;\n\t\t\touter: for (int i = 15; i >= -1; --i) {\n\t\t\t\tint ngap = gap + (i >= 0 ? (1 << i) : 0);\n\t\t\t\tint[] vis = new int[n + 1];\n\t\t\t\tvis[0] = 1;\n\t\t\t\tvis[1] = -1;\n\t\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\t\tvis[j] += (j > 0 ? vis[j - 1] : 0);\n\t\t\t\t\tif (vis[j] > 0) {\n\t\t\t\t\t\tif (accum[n] - accum[j] + (n - j - 1) <= W) {\n\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint left = j;\n\t\t\t\t\t\tint right = n;\n\t\t\t\t\t\twhile (right - left > 1) {\n\t\t\t\t\t\t\tint middle = (right + left) / 2;\n\t\t\t\t\t\t\tif (accum[middle] - accum[j] + (middle - j - 1) <= W) {\n\t\t\t\t\t\t\t\tleft = middle;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tright = middle;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint dmax = left;\n\n\t\t\t\t\t\tleft = j;\n\t\t\t\t\t\tright = n;\n\t\t\t\t\t\twhile (right - left > 1) {\n\t\t\t\t\t\t\tint middle = (right + left) / 2;\n\t\t\t\t\t\t\tif (W <= accum[middle] - accum[j] + (long) ngap * (middle - j - 1)) {\n\t\t\t\t\t\t\t\tright = middle;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tleft = middle;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint dmin = right;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (dmin > dmax)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t++vis[dmin];\n\t\t\t\t\t\t--vis[dmax + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++lack;\n\t\t\t\tgap = ngap;\n\t\t\t}\n\t\t\tif (lack > 0)\n\t\t\t\t++gap;\n\t\t\tpw.println(gap);\n\t\t}\n\t\tpw.close();\n\t\tsc.close();\n\t}\n\n\t\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nINF = 1 << 30\n\n### main\n\nloop do\n  w, n = gets.split.map(&:to_i)\n  break if (w | n) == 0\n\n  wls = gets.split.map(&:to_i)\n  #p wls\n\n  msps = Array.new(n + 1){INF}\n  msps[n - 1] = msps[n] = 0\n\n  i = n - 1\n  wsum = wls[i]\n  loop do\n    i -= 1\n    break if i < 0\n    wsum += 1 + wls[i]\n    #puts \"i=#{i},wsum=#{wsum}\"\n    break if wsum > w\n    msps[i] = 1\n  end\n\n  while i >= 0\n    #puts \"i=#{i}\"\n    spsum = w - wls[i]\n    k = 1\n    while i + k < n\n      spsum -= wls[i + k]\n      break if spsum < k\n      csp = (spsum + k - 1) / k\n      k += 1\n      sp = (csp >= msps[i + k]) ? csp : msps[i + k]\n      #puts \"  k=#{k},spsum=#{spsum},csp=#{csp},sp=#{sp}\"\n      msps[i] = sp if msps[i] > sp\n    end\n\n    i -= 1\n  end\n\n  #p msps\n  puts msps[0]\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    w, n = gets.split.map(&:to_i)\n    break if w == 0\n    xs = gets.split.map(&:to_i)\n\n    min_max_space = [Float::INFINITY] * n\n\n    s = xs[0]\n\n    k = 1\n    loop do\n        s += xs[k]\n        break if (w - s) / k < 1\n        min_max_space[k] = ((w - s).to_f / k).ceil\n        k += 1\n        break if k >= n\n    end\n\n    if k >= n\n        puts 1\n        break\n    end\n\n    while k < n\n        s = xs[k]\n        i = k - 1\n        l = 1\n        loop do\n            s += xs[i]\n            break if (w - s) / l < 1\n            mms = [((w - s).to_f / l).ceil, min_max_space[i-1]].max\n            min_max_space[k] = mms if mms < min_max_space[k]\n            i -= 1\n            break if i == 1\n            l += 1\n        end\n        k += 1\n    end\n\n    ans = Float::INFINITY\n    s = -1\n    (n-1).downto(0) do |i|\n        mms = min_max_space[i]\n        ans = mms if mms < ans\n        s += 1 + xs[i]\n        break if s > w\n    end\n\n    p ans\nend"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef check(W, N, k, su, s):\n    vs = [0]*(N+2)\n    vs[1] = r = 1\n    p = q = 0\n    for i in range(N):\n        while (su[i+1] - su[p]) + (i - p)*s >= W:\n            p += 1\n        while (su[i+1] - su[q]) + (i - q) > W:\n            q += 1\n        vs[i+2] = r = r + (vs[p] > vs[q])\n        if r == vs[q]:\n            return k < i+2 and r - vs[k]\n    return vs[N+1] - vs[k]\ndef solve():\n    W, N = map(int, readline().split())\n    if W == N == 0:\n        return False\n    *X, = map(int, readline().split())\n    su = [0]*(N+1)\n    for i in range(N):\n        su[i+1] = su[i] + X[i]\n    k = N\n    while k > 0 and su[N] - su[k-1] + (N-k+1) <= W:\n        k -= 1\n\n    ma = 0\n    cu = X[0]; c = 1\n    for i in range(1, N):\n        if cu + c + X[i] > W:\n            ma = max(ma, (W - cu + c-2) // (c-1))\n            cu = X[i]\n            c = 1\n        else:\n            cu += X[i]\n            c += 1\n\n    left = 0; right = ma+1\n    while left+1 < right:\n        mid = (left + right) >> 1\n        if check(W, N, k, su, mid):\n            right = mid\n        else:\n            left = mid\n    write(\"%d\\n\" % right)\n    return True\nwhile solve():\n    ...\n"
  },
  {
    "language": "Python",
    "code": "while 1:\n    W, N = map(int, input().split())\n    if W == N == 0:\n        break\n    *X, = map(int, input().split())\n    def solve(l):\n        lower = 0; upper = 0\n        for x in X:\n            lower += x + 1\n            upper += x + l\n            if l + W <= upper:\n                if not lower <= W + 1:\n                    return 0\n                lower = upper = 0\n        return 1\n    left = 0; right = W\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid):\n            right = mid\n        else:\n            left = mid\n    print(right)"
  }
]