[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nlong long factorial(int n) {\n    long long result = 1;\n    for (int i = 2; i <= n; i++) {\n        result = (result * i) % MOD;\n    }\n    return result;\n}\n\nlong long calculate_arrangements(int x_wins, int y_wins, int total_matches) {\n    long long denominator = 1;\n    denominator = (factorial(x_wins) * factorial(y_wins)) % MOD;\n    denominator = (denominator * factorial(total_matches - x_wins - y_wins)) % MOD;\n    \n    long long arrangements = factorial(total_matches);\n    arrangements = (arrangements * modular_inverse(denominator)) % MOD;\n    \n    return arrangements;\n}\n\nlong long modular_inverse(long long a) {\n    long long m = MOD;\n    long long y = 0, x = 1;\n    \n    while (a > 1) {\n        long long q = a / m;\n        long long t = m;\n        \n        m = a % m;\n        a = t;\n        t = y;\n        \n        y = x - q * y;\n        x = t;\n    }\n    \n    if (x < 0) x += MOD;\n    return x;\n}\n\nint main() {\n    int x_total, y_total, total_matches;\n    \n    while (1) {\n        scanf(\"%d %d %d\", &x_total, &y_total, &total_matches);\n        \n        if (x_total == 0 && y_total == 0 && total_matches == 0) {\n            break;\n        }\n        \n        long long possible_arrangements = calculate_arrangements(x_total, y_total, total_matches);\n        printf(\"%lld\\n\", possible_arrangements);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:57:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAX 2000\n\nlong long comb[MAX + 1][MAX + 1];\nlong long fact[MAX * 2 + 1];\n\nvoid precompute() {\n    // Combinations\n    for (int i = 0; i <= MAX; i++) {\n        comb[i][0] = 1;\n        for (int j = 1; j <= i; j++) {\n            comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;\n        }\n    }\n    // Factorials\n    fact[0] = 1;\n    for (int i = 1; i <= MAX * 2; i++) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n}\n\nint main() {\n    precompute();\n    int X, Y, Sx, Sy, D;\n    while (1) {\n        scanf(\"%d %d %d %d %d\", &X, &Y, &Sx, &Sy, &D);\n        if (X == 0 && Y == 0 && Sx == 0 && Sy == 0 && D == 0) break;\n        long long total = 0;\n        for (int d = 0; d <= D; d++) {\n            int x = X - d;\n            int y = Y - d;\n            if (x < 0 || y < 0) continue;\n            long long c = comb[X + Y + d][d] * comb[X + Y][x] % MOD;\n            total = (total + c) % MOD;\n        }\n        printf(\"%lld\\n\", total);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:57:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst long long MOD = 1000000007;\n\nlong long mod_pow(long long base, long long exp, long long mod) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return result;\n}\n\nlong long mod_inverse(long long a, long long mod) {\n    return mod_pow(a, mod - 2, mod);\n}\n\nvector<long long> fact, inv_fact;\n\nvoid precompute_factorials(int max_n) {\n    fact.resize(max_n + 1);\n    inv_fact.resize(max_n + 1);\n    fact[0] = 1;\n    for (int i = 1; i <= max_n; ++i) {\n        fact[i] = (fact[i - 1] * i) % MOD;\n    }\n    inv_fact[max_n] = mod_inverse(fact[max_n], MOD);\n    for (int i = max_n - 1; i >= 0; --i) {\n        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD;\n    }\n}\n\nlong long comb(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return (fact[n] * inv_fact[k] % MOD) * inv_fact[n - k] % MOD;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    const int MAX_M = 2000;\n    precompute_factorials(2 * MAX_M);\n\n    while (true) {\n        int N, M, X, Y, Z;\n        cin >> N >> M >> X >> Y >> Z;\n        if (N == 0 && M == 0 && X == 0 && Y == 0 && Z == 0) break;\n\n        long long total = 0;\n        for (int k = 0; k <= M; ++k) {\n            int x = X - (M - k);\n            int y = Y - (M - k);\n            if (x < 0 || y < 0) continue;\n            if (x % 2 != 0 || y % 2 != 0) continue;\n            int a = x / 2;\n            int b = y / 2;\n            if (a < 0 || b < 0) continue;\n            if (a + b > k) continue;\n            int c = k - a - b;\n            if (c < 0) continue;\n            long long ways = comb(M, k) * comb(k, a) % MOD;\n            ways = ways * comb(k - a, b) % MOD;\n            ways = ways * comb(M, M - k) % MOD;\n            total = (total + ways) % MOD;\n        }\n        cout << total << '\\n';\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:58:46"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class BaseballScores {\n    private static final int MOD = 1_000_000_007;\n    private static long[][] comb = new long[2002][2002];\n    private static long[] fact = new long[2002];\n    private static long[] invFact = new long[2002];\n\n    static {\n        comb[0][0] = 1;\n        for (int i = 1; i <= 2001; i++) {\n            comb[i][0] = 1;\n            for (int j = 1; j <= i; j++) {\n                comb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD;\n            }\n        }\n\n        fact[0] = 1;\n        for (int i = 1; i <= 2001; i++) {\n            fact[i] = fact[i-1] * i % MOD;\n        }\n\n        invFact[2001] = pow(fact[2001], MOD-2);\n        for (int i = 2000; i >= 0; i--) {\n            invFact[i] = invFact[i+1] * (i+1) % MOD;\n        }\n    }\n\n    private static long pow(long a, long b) {\n        long res = 1;\n        while (b > 0) {\n            if ((b & 1) == 1) {\n                res = res * a % MOD;\n            }\n            a = a * a % MOD;\n            b >>= 1;\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            int xWin = scanner.nextInt();\n            int yWin = scanner.nextInt();\n            int xScore = scanner.nextInt();\n            int yScore = scanner.nextInt();\n            int draw = scanner.nextInt();\n\n            if (xWin == 0 && yWin == 0 && xScore == 0 && yScore == 0 && draw == 0) {\n                break;\n            }\n\n            long res = 0;\n            int totalMatches = xWin + yWin + draw;\n            for (int d = 0; d <= draw; d++) {\n                int xTotal = xScore - (xWin + d);\n                int yTotal = yScore - (yWin + d);\n                if (xTotal < 0 || yTotal < 0) {\n                    continue;\n                }\n\n                long waysX = comb[xWin + xTotal - 1][xWin - 1];\n                long waysY = comb[yWin + yTotal - 1][yWin - 1];\n                long waysDraw = comb[draw][d];\n                long waysPerm = fact[totalMatches];\n                waysPerm = waysPerm * invFact[xWin] % MOD;\n                waysPerm = waysPerm * invFact[yWin] % MOD;\n                waysPerm = waysPerm * invFact[d] % MOD;\n                waysPerm = waysPerm * invFact[draw - d] % MOD;\n\n                long total = waysX * waysY % MOD;\n                total = total * waysDraw % MOD;\n                total = total * waysPerm % MOD;\n                res = (res + total) % MOD;\n            }\n            System.out.println(res);\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:59:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class BaseballArrangements {\n    static final int MOD = 1_000_000_007;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        while (true) {\n            int totalMatches = scanner.nextInt();\n            int xWins = scanner.nextInt();\n            int yWins = scanner.nextInt();\n            int xScore = scanner.nextInt();\n            int yScore = scanner.nextInt();\n\n            if (totalMatches == 0 && xWins == 0 && yWins == 0 && xScore == 0 && yScore == 0) {\n                break;\n            }\n\n            long result = calculateArrangements(totalMatches, xWins, yWins, xScore, yScore);\n            System.out.println(result);\n        }\n\n        scanner.close();\n    }\n\n    static long calculateArrangements(int totalMatches, int xWins, int yWins, int xScore, int yScore) {\n        long[][][] dp = new long[totalMatches + 1][xWins + 1][yWins + 1];\n        dp[0][0][0] = 1;\n\n        for (int matches = 0; matches < totalMatches; matches++) {\n            for (int x = 0; x <= xWins; x++) {\n                for (int y = 0; y <= yWins; y++) {\n                    if (dp[matches][x][y] == 0) continue;\n\n                    // X wins\n                    if (x < xWins) {\n                        dp[matches + 1][x + 1][y] = (dp[matches + 1][x + 1][y] + dp[matches][x][y]) % MOD;\n                    }\n\n                    // Y wins\n                    if (y < yWins) {\n                        dp[matches + 1][x][y + 1] = (dp[matches + 1][x][y + 1] + dp[matches][x][y]) % MOD;\n                    }\n\n                    // Draw\n                    dp[matches + 1][x][y] = (dp[matches + 1][x][y] + dp[matches][x][y]) % MOD;\n                }\n            }\n        }\n\n        return dp[totalMatches][xWins][yWins];\n    }\n}",
    "timestamp": "2025-08-05 21:59:23"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nlong long countArrangements(int x_wins, int y_wins, int total_matches) {\n    vector<vector<vector<long long>>> dp(total_matches + 1, \n        vector<vector<long long>>(x_wins + 1, \n            vector<long long>(y_wins + 1, 0)));\n    \n    dp[0][0][0] = 1;\n    \n    for (int match = 0; match < total_matches; match++) {\n        for (int x = 0; x <= x_wins; x++) {\n            for (int y = 0; y <= y_wins; y++) {\n                if (dp[match][x][y] == 0) continue;\n                \n                // X wins\n                if (x < x_wins) {\n                    dp[match+1][x+1][y] = (dp[match+1][x+1][y] + dp[match][x][y]) % MOD;\n                }\n                \n                // Y wins\n                if (y < y_wins) {\n                    dp[match+1][x][y+1] = (dp[match+1][x][y+1] + dp[match][x][y]) % MOD;\n                }\n                \n                // Draw\n                dp[match+1][x][y] = (dp[match+1][x][y] + dp[match][x][y]) % MOD;\n            }\n        }\n    }\n    \n    return dp[total_matches][x_wins][y_wins];\n}\n\nint main() {\n    int x_wins, y_wins, total_matches;\n    \n    while (true) {\n        cin >> total_matches >> x_wins >> y_wins;\n        \n        if (total_matches == 0 && x_wins == 0 && y_wins == 0) {\n            break;\n        }\n        \n        long long result = countArrangements(x_wins, y_wins, total_matches);\n        cout << result << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:59:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_possible_arrangements():\n    import sys\n    MOD = 1_000_000_007\n    \n    def factorial(n, mod):\n        result = [1] * (n + 1)\n        for i in range(2, n + 1):\n            result[i] = (result[i - 1] * i) % mod\n        return result\n\n    factorials = factorial(100, MOD)  # assuming reasonable upper bound for matches\n\n    for line in sys.stdin:\n        w_x, w_y, d, s_x, s_y = map(int, line.split())\n        if w_x == w_y == d == s_x == s_y == 0:\n            break\n\n        total_matches = w_x + w_y + d\n\n        # We have total_matches slots to fill with w_x 'X wins', w_y 'Y wins', and d 'Draws'.\n        if total_matches > 100:\n            print(0)\n            continue\n\n        # Using combinatorics to count arrangements\n        #\n        # The number of ways to arrange matches is the number of permutations of the multiset\n        # {w_x X's, w_y Y's, d draws}, which is:\n        # C(total_matches, w_x, w_y, d) = total_matches! / (w_x! * w_y! * d!)\n\n        def mod_inv(a, mod):\n            # Fermat's little theorem: a^(mod-1) ≡ 1 (mod mod), so a^(mod-2) ≡ a^(-1) (mod mod)\n            return pow(a, mod - 2, mod)\n\n        ways = (factorials[total_matches] * mod_inv(factorials[w_x], MOD) % MOD *\n                mod_inv(factorials[w_y], MOD) % MOD * mod_inv(factorials[d], MOD) % MOD)\n\n        print(ways)\n\ncount_possible_arrangements()",
    "timestamp": "2025-08-13 08:17:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class BaseballScoreArrangements {\n\n    private static final int MOD = 1_000_000_007;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        while (true) {\n            int winsX = scanner.nextInt();\n            int winsY = scanner.nextInt();\n            int draws = scanner.nextInt();\n            int totalScoreX = scanner.nextInt();\n            int totalScoreY = scanner.nextInt();\n\n            if (winsX == 0 && winsY == 0 && draws == 0 && totalScoreX == 0 && totalScoreY == 0) {\n                break;\n            }\n\n            int result = calculateArrangements(winsX, winsY, draws);\n            System.out.println(result);\n        }\n    }\n\n    private static int calculateArrangements(int winsX, int winsY, int draws) {\n        int totalMatches = winsX + winsY + draws;\n\n        if (totalMatches == 0) return 1;\n\n        long[] factorial = new long[totalMatches + 1];\n        factorial[0] = 1;\n        for (int i = 1; i <= totalMatches; i++) {\n            factorial[i] = factorial[i - 1] * i % MOD;\n        }\n\n        long arrangements = factorial[totalMatches];\n        arrangements = arrangements * modInverse(factorial[winsX], MOD) % MOD;\n        arrangements = arrangements * modInverse(factorial[winsY], MOD) % MOD;\n        arrangements = arrangements * modInverse(factorial[draws], MOD) % MOD;\n\n        return (int) arrangements;\n    }\n\n    private static long modInverse(long a, int mod) {\n        return powMod(a, mod - 2, mod);\n    }\n\n    private static long powMod(long base, long exp, int mod) {\n        long result = 1;\n        while (exp > 0) {\n            if ((exp & 1) == 1) {\n                result = result * base % mod;\n            }\n            base = base * base % mod;\n            exp >>= 1;\n        }\n        return result;\n    }\n}",
    "timestamp": "2025-08-13 08:18:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MOD 1000000007\n\ntypedef long long ll;\n\nll factorial(int n) {\n    ll f = 1;\n    for (int i = 2; i <= n; ++i) {\n        f = (f * i) % MOD;\n    }\n    return f;\n}\n\nll modular_pow(ll base, ll exp, ll mod) {\n    ll result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        base = (base * base) % mod;\n        exp = exp / 2;\n    }\n    return result;\n}\n\nll modular_inverse(ll a, ll mod) {\n    return modular_pow(a, mod - 2, mod);\n}\n\nll binomial_coefficient(int n, int k) {\n    if (k > n) return 0;\n    \n    ll num = factorial(n);\n    ll denom = (factorial(k) * factorial(n - k)) % MOD;\n    return (num * modular_inverse(denom, MOD)) % MOD;\n}\n\nint main() {\n    int x_wins, y_wins, draws, x_score, y_score;\n    \n    while (scanf(\"%d %d %d %d %d\", &x_wins, &y_wins, &draws, &x_score, &y_score) == 5) {\n        if (x_wins == 0 && y_wins == 0 && draws == 0 && x_score == 0 && y_score == 0) {\n            break;\n        }\n        \n        int matches = x_wins + y_wins + draws;\n        ll arrangements = binomial_coefficient(matches, x_wins);\n        arrangements = (arrangements * binomial_coefficient(matches - x_wins, y_wins)) % MOD;\n\n        printf(\"%lld\\n\", arrangements);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 08:18:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef count_arrangements(x_wins, y_wins, total_matches):\n    def factorial(n):\n        result = 1\n        for i in range(1, n + 1):\n            result = (result * i) % MOD\n        return result\n\n    def combination(n, k):\n        return (factorial(n) * pow(factorial(k) * factorial(n - k), MOD - 2, MOD)) % MOD\n\n    arrangements = combination(total_matches, x_wins)\n    arrangements = (arrangements * factorial(x_wins)) % MOD\n    arrangements = (arrangements * factorial(y_wins)) % MOD\n\n    return arrangements\n\ndef main():\n    while True:\n        total_matches, x_wins, y_wins, x_score, y_score = map(int, input().split())\n        \n        if total_matches == 0 and x_wins == 0 and y_wins == 0 and x_score == 0 and y_score == 0:\n            break\n\n        if x_wins + y_wins > total_matches or x_score + y_score > total_matches:\n            print(0)\n            continue\n\n        arrangements = count_arrangements(x_wins, y_wins, total_matches)\n        print(arrangements)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 08:18:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 10**9 + 7\n\ndef precompute_factorials(max_n, MOD):\n    fact = [1] * (max_n + 1)\n    inv_fact = [1] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        fact[i] = fact[i-1] * i % MOD\n    inv_fact[max_n] = pow(fact[max_n], MOD-2, MOD)\n    for i in range(max_n - 1, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n    return fact, inv_fact\n\nmax_possible = 2 * 10**5  # Adjust based on constraints\nfact, inv_fact = precompute_factorials(max_possible, MOD)\n\ndef solve():\n    input_lines = sys.stdin.read().splitlines()\n    for line in input_lines:\n        N, M, T, P, Q = map(int, line.split())\n        if N == 0 and M == 0 and T == 0 and P == 0 and Q == 0:\n            break\n        X_wins = P\n        Y_wins = Q\n        draws = T - P - Q\n        if draws < 0 or X_wins < 0 or Y_wins < 0:\n            print(0)\n            continue\n        total_matches = X_wins + Y_wins + draws\n        if total_matches != T:\n            print(0)\n            continue\n        if N != X_wins + draws or M != Y_wins + draws:\n            print(0)\n            continue\n        \n        # Compute the number of ways to arrange the sequence\n        # The matches can be arranged in (total_matches)! / (X_wins! Y_wins! draws!)\n        numerator = fact[total_matches]\n        denominator = fact[X_wins] * fact[Y_wins] % MOD\n        denominator = denominator * fact[draws] % MOD\n        res = numerator * pow(denominator, MOD-2, MOD) % MOD\n        print(res)\n\nsolve()",
    "timestamp": "2025-08-13 08:18:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nconst int MOD = 1000000007;\n\nint factorial(int n) {\n    long long result = 1;\n    for (int i = 2; i <= n; ++i) {\n        result = (result * i) % MOD;\n    }\n    return result;\n}\n\nint modInverse(int a) {\n    int exponent = MOD - 2;\n    long long result = 1;\n    long long base = a;\n    while (exponent > 0) {\n        if (exponent % 2 == 1) {\n            result = (result * base) % MOD;\n        }\n        base = (base * base) % MOD;\n        exponent /= 2;\n    }\n    return result;\n}\n\nint arrangements(int winsX, int winsY, int draws) {\n    int totalMatches = winsX + winsY + draws;\n    int totalArrangements = factorial(totalMatches);\n    totalArrangements = (totalArrangements * modInverse(factorial(winsX))) % MOD;\n    totalArrangements = (totalArrangements * modInverse(factorial(winsY))) % MOD;\n    totalArrangements = (totalArrangements * modInverse(factorial(draws))) % MOD;\n    return totalArrangements;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    while (true) {\n        int winsX, scoreX, winsY, scoreY, draws;\n        std::cin >> winsX >> scoreX >> winsY >> scoreY >> draws;\n        if (winsX == 0 && scoreX == 0 && winsY == 0 && scoreY == 0 && draws == 0) {\n            break;\n        }\n        std::cout << arrangements(winsX, winsY, draws) << '\\n';\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:44:44"
  }
]