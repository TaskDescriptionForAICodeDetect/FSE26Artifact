[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n//ａをbで割る\nlong long mod_div(ll a,ll b){\n\tif(a % b == 0)return a/b;\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n \n#define MAX_K 3333333\nvector<long long> kaijo(MAX_K);\nlong long combination(long long n, long long r){\n    if(n < r || n < 0 || r < 0)\n        return 0;\n\tif(kaijo[0] != 1){\n\t\tkaijo[0] = 1;\n\t\tfor(long long i = 1;i < MAX_K;i++)kaijo[i] = (kaijo[i-1] * i) % MOD;\n\t}\n    long long ret = kaijo[n];\n\tlong long tmp = (kaijo[r] * kaijo[n-r]) % MOD;\n    return mod_div(ret,tmp);\n}\n\nint main(){\n\tll a,b,c,x,y;\n\t\n\twhile(cin >> a >> b >> c >> x >> y,a+b+c+x+y){\n\t\t\n\t\tll ans = 0;\n\t\tfor(ll i = 0;i <= min(x,y);i++){\n\t\t\tll X = x-i-a;\n\t\t\tll Y = y-i-b;\n\t\t\tif(X < 0 || y < 0)continue;\n\t\t\tif(a == 0 && X > 0)continue;\n\t\t\tif(b == 0 && Y > 0)continue;\n\t\t\tll tmp = 1;\n\t\t\ttmp = (tmp * combination(a+b+c,c)) % MOD;\n\t\t\ttmp = (tmp * combination(a+b,b)) % MOD;\n\t\t\tif(a+b+c+i-1 >= i)tmp = (tmp * combination(a+b+c+i-1,i)) % MOD;\n\t\t\tif(a+X-1 >= X)tmp = (tmp * combination(a+X-1,X)) % MOD;\n\t\t\tif(b+Y-1 >= Y)tmp = (tmp * combination(b+Y-1,Y)) % MOD;\n\t\t\tans = (ans+tmp) % MOD;\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef ___CLASS_MODINT\n#define ___CLASS_MODINT\n\n#include <cstdint>\n\ntemplate<std::uint32_t mod>\nclass modint {\nprivate:\n\tstd::uint32_t n;\npublic:\n\tmodint() : n(0) {};\n\tmodint(std::uint64_t n_) : n(n_ % mod) {};\n\tbool operator==(const modint& m) const { return n == m.n; }\n\tbool operator!=(const modint& m) const { return n != m.n; }\n\tstd::uint32_t get() const { return n; }\n\tmodint& operator+=(const modint& m) { n += m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator-=(const modint& m) { n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator*=(const modint& m) { n = std::uint64_t(n) * m.n % mod; return *this; }\n\tmodint operator+(const modint& m) const { return modint(*this) += m; }\n\tmodint operator-(const modint& m) const { return modint(*this) -= m; }\n\tmodint operator*(const modint& m) const { return modint(*this) *= m; }\n\tmodint binpow(std::uint64_t b) const {\n\t\tmodint ans = 1, m = modint(*this);\n\t\twhile (b) {\n\t\t\tif (b & 1) ans *= m;\n\t\t\tm *= m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\tmodint inv() { return (*this).binpow(mod - 2); }\n};\n\n#endif // ___CLASS_MODINT\n\n#include <vector>\n#include <iostream>\n#include <functional>\nusing namespace std;\nconst int lim = 4000000;\nconst int mod = 1000000007;\nusing modulo = modint<mod>;\nint main() {\n\tvector<modulo> fact(lim + 1), inv(lim + 1), factinv(lim + 1);\n\tfact[0] = 1; inv[1] = 1; factinv[0] = 1;\n\tfor (int i = 1; i <= lim; ++i) fact[i] = fact[i - 1] * i;\n\tfor (int i = 2; i <= lim; ++i) inv[i] = inv[mod % i] * (mod - mod / i);\n\tfor (int i = 1; i <= lim; ++i) factinv[i] = factinv[i - 1] * inv[i];\n\tfunction<modulo(int, int)> comb = [&](int n, int m) {\n\t\tif (m < 0 || n < m) return modulo(0);\n\t\treturn fact[n] * factinv[m] * factinv[n - m];\n\t};\n\tint A, B, C, SX, SY;\n\twhile (cin >> A >> B >> C >> SX >> SY, A + B + C) {\n\t\tmodulo ans = 0;\n\t\tfor (int i = 0; i <= SX && i <= SY; ++i) {\n\t\t\tmodulo sub = comb(A + B + C + i - 1, i);\n\t\t\tif (A > 0) sub *= comb(SX - i - 1, A - 1);\n\t\t\telse if (SX - i > 0) sub = 0;\n\t\t\tif(B > 0) sub *= comb(SY - i - 1, B - 1);\n\t\t\telse if (SY - i > 0) sub = 0;\n\t\t\tans += sub;\n\t\t}\n\t\tans *= fact[A + B + C] * factinv[A] * factinv[B] * factinv[C];\n\t\tcout << ans.get() << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\nll add(ll a,ll b){return (a+b)%mod;}\nll mul(ll a,ll b){return (a*b)%mod;}\n\nll mpow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mpow( mul(a,a) , b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\nll divi(ll a,ll b){\n  return mul(a, mpow(b,mod-2) );\n}\n\nll fact[2000000];\nll Fact[2000000];\ntypedef pair<ll,ll> P;\n\nunordered_map< ll , ll  > mem;\n\nll base=10000000000LL;\n\nll nCr(ll n,ll r){\n  \n  if(mem.count(n*base+r))\n    return mem[n*base+r];\n  \n  return mem[n*base+r]=mul(fact[n], mul(Fact[r],Fact[n-r]) );\n}\n\nll nHr(ll n,ll r){\n  if(r==0)return 1;\n  return nCr(n+r-1,r-1);\n}\n\nll nBr(ll n,ll r){\n  if(n<r)return 0;\n  return nHr(n-r,r);\n}\n\nll A,B,C,D,E;\n\n\nint main(){\n  fact[0]=1;\n  for(ll i=1;i<2000000;i++){\n    fact[i]=mul(fact[i-1],i);\n  }\n  for(ll i=0;i<2000000;i++)Fact[i]=divi(1,fact[i]);\n  \n  while(1){\n    mem.clear();\n    \n    cin>>A>>B>>C>>D>>E;\n    if(A==0&&B==0&&C==0&&D==0&&E==0)break;\n    \n    ll ans=0;\n    for(ll i=max(A,B+D-E);i<=D;i++){\n      ll j=-(D-E-i);\n      //      if(i<A)continue;\n      if(A==0&&i>0)continue;\n      //      if(i>D)continue;\n      //      if(j<B)continue;\n      if(B==0&&j>0)break;\n      if(j>E)break;\n      ll L=nBr(i,A);\n      ll R=nBr(j,B);\n      ll tmp=mul(L,R);\n      tmp=mul(tmp, nCr(A+B,A) );\n      tmp=mul(tmp, nCr(A+B+C,C) );\n      assert( D-i == E-j );\n      tmp=mul(tmp, nHr(D-i,A+B+C) );\n      ans=add(ans,tmp);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n//ａをbで割る\nlong long mod_div(ll a,ll b){\n\tif(a % b == 0)return a/b;\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n \n#define MAX_K 6666666\nvector<long long> kaijo(MAX_K);\nlong long combination(long long n, long long r){\n    if(n < r || n < 0 || r < 0)\n        return 0;\n\tif(kaijo[0] != 1){\n\t\tkaijo[0] = 1;\n\t\tfor(long long i = 1;i < MAX_K;i++)kaijo[i] = (kaijo[i-1] * i) % MOD;\n\t}\n    long long ret = kaijo[n];\n\tlong long tmp = (kaijo[r] * kaijo[n-r]) % MOD;\n    return mod_div(ret,tmp);\n}\n\nint main(){\n\tint a,b,c,x,y;\n\t\n\twhile(cin >> a >> b >> c >> x >> y,a+b+c+x+y){\n\t\t\n\t\tll ans = 0;\n\t\tfor(int i = 0;i <= min(x,y);i++){\n\t\t\tint X = x-i-a;\n\t\t\tint Y = y-i-b;\n\t\t\tif(X < 0 && y < 0)continue;\n\t\t\tll tmp = 1;\n\t\t\ttmp = (tmp * combination(a+b+c,c)) % MOD;\n\t\t\ttmp = (tmp * combination(a+b,b)) % MOD;\n\t\t\ttmp = (tmp * combination(a+b+c+i-1,i)) % MOD;\n\t\t\ttmp = (tmp * combination(a+X-1,X)) % MOD;\n\t\t\ttmp = (tmp * combination(b+Y-1,Y)) % MOD;\n\t\t\tans = (ans+tmp) % MOD;\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n#define MOD 1000000007\n#define MAX_N 100000\n#define MAX_P 5114514\nInt fact[MAX_P],inv[MAX_P],finv[MAX_P];\nInt extgcd(Int a,Int b,Int& x,Int& y){\n  Int d=a;\n  if(b!=0){\n    d=extgcd(b,a%b,y,x);\n    y-=(a/b)*x;\n  }else{\n    x=1;y=0;\n  }\n  return d;\n}\nInt mod_inverse(Int a,Int mod){\n  Int x,y;\n  extgcd(a,mod,x,y);\n  return (mod+x%mod)%mod;\n}\nInt euler_phi(Int n){\n  Int res=n;\n  for(Int i=2;i*i<=n;i++){\n    if(n%i==0){\n      res=res/i*(i-1);\n      for(;n%i==0;n/=i);\n    }\n  }\n  if(n!=1) res=res/n*(n-1);\n  return res;\n}\n\nInt euler[MAX_N];\n\nvoid euler_phi2(){\n  for(Int i=0;i<MAX_N;i++) euler[i]=i;\n  for(Int i=2;i<MAX_N;i++){\n    if(euler[i]==i){\n      for(Int j=i;j<MAX_N;j+=i) euler[j]=euler[j]/i*(i-1);\n    }\n  }\n}\n\nInt mod_pow(Int x,Int n,Int mod){\n  Int res=1;\n  while(n){\n    if(n&1) (res*=x)%=mod;\n    (x*=x)%=mod;\n    n>>=1;\n  }\n  return res;\n}\n\nInt mod_inverse2(Int a,Int mod){\n  return mod_pow(a,mod-2,mod);\n}\n\nvoid init(Int mod){\n  fact[0]=1;\n  for(Int i=1;i<MAX_P;i++)\n    fact[i]=(fact[i-1]*i)%mod;\n\n  inv[1]=1;\n  for(Int i=2;i<MAX_P;i++)\n    inv[i]=inv[mod%i]*(mod-mod/i)%mod;\n\n  finv[0]=1;\n  for(Int i=1;i<MAX_P;i++)\n    finv[i]=(finv[i-1]*inv[i])%mod;\n}\n\nInt mod_fact(Int n,Int mod,Int& e){\n  e=0;\n  if(n==0) return 1;\n  Int res=mod_fact(n/mod,mod,e);\n  e+=n/mod;\n  if(n/mod%2!=0)return res*(mod-fact[n%mod]) %mod;\n  return res*fact[n%mod]%mod;\n}\n\nInt mod_comb(Int n,Int k,Int mod){\n  if(n==k||k==0) return 1;\n  Int e1,e2,e3;\n  Int a1=mod_fact(n,mod,e1),a2=mod_fact(k,mod,e2),a3=mod_fact(n-k,mod,e3);\n  if(e1>e2+e3) return 0;\n  return a1*mod_inverse(a2*a3%mod,mod)%mod;\n}\n\nInt mod_comb2(Int n,Int k,Int mod){\n  Int res=1;\n  for(Int i=0;i<k;i++){\n    res*=(n-i)%mod;\n    res%=mod;\n    res*=mod_inverse(i+1,mod);\n    res%=mod;\n  }\n  return res;\n}\n\nInt mod_comb3(Int n,Int k,Int mod){\n  if(n==k||k==0) return 1;\n  if(n<0||k<0||n<k) return 0;\n  return (((fact[n]*finv[k])%mod)*finv[n-k])%mod;\n}\n\nInt montmort(Int n,Int mod){\n  Int res=0,inv=1;\n  for(Int k=2;k<=n;k++){\n    (inv*=mod_inverse(k,mod))%=mod;\n    if(k%2) (res+=mod-inv)%=mod;\n    else (res+=inv)%=mod;\n  }\n  for(Int i=1;i<=n;i++)\n    (res*=i)%=mod;\n  return res;\n}\n\nsigned main(){\n  init(MOD);\n  Int a,b,c,x,y;\n  while(cin>>a>>b>>c>>x>>y,a+b+c){\n    Int ans=0;\n    x-=a;y-=b;\n    if(x<0||y<0){\n      cout<<ans<<endl;\n      continue;\n    }\n    \n    for(Int i=0;i<=min(x,y);i++){\n      Int tmp=mod_comb(a+b+c+i-1,i,MOD);\n      (tmp*=mod_comb(a+(x-i)-1,x-i,MOD))%=MOD;\n      (tmp*=mod_comb(b+(y-i)-1,y-i,MOD))%=MOD;\n      (ans+=tmp)%=MOD;\n    }\n    \n    (ans*=fact[a+b+c])%=MOD;\n    (ans*=finv[a])%=MOD;\n    (ans*=finv[b])%=MOD;\n    (ans*=finv[c])%=MOD;\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nlong long fact[2000009], factinv[2000009], mod = 1000000007;\n\nlong long mul3(long long a, long long b, long long c) {\n\treturn ((a*b)%mod)*c%mod;\n}\nlong long mul2(long long a, long long b) {\n\treturn (a*b) % mod;\n}\nlong long modpow(long long a, long long b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (int i = 0; i < 60; i++) {\n\t\tif ((b / (1LL << i)) % 2 == 1) { p *= q; p %= m; }\n\t\tq *= q; q %= m;\n\t}\n\treturn p;\n}\nlong long Div(long long a, long long b, long long m) {\n\treturn (a*modpow(b, m - 2, m)) % m;\n}\nlong long ncr(long long n, long long r) {\n\tif (r < 0 || n < r) return 0;\n\treturn mul3(fact[n], factinv[n - r], factinv[r]);\n}\nvoid init() {\n\tfact[0] = 1; for (int i = 1; i <= 2000000; i++) fact[i] = (fact[i - 1] * i) % mod;\n\tfor (int i = 0; i <= 2000000; i++) factinv[i] = Div(1, fact[i], mod);\n}\nlong long comb(long long a, long long b) {\n\tif (b == 0) {\n\t\tif (a == 0) return 1;\n\t\treturn 0;\n\t}\n\treturn ncr(a - 1, b - 1);\n}\n\nlong long X, Y, A, B, C;\n\nint main() {\n\tinit();\n\twhile (true) {\n\t\tcin >> A >> B >> C >> X >> Y; if (A + B + C + X + Y == 0) break;\n\n\t\tlong long sum = 0;\n\t\tfor (int i = 0; i <= min(X, Y); i++) {\n\t\t\tlong long V1 = ncr(A + B, B)*ncr(A + B + C, C); V1 %= mod;\n\t\t\tlong long V2 = comb(i + A + B + C, A + B + C);\n\t\t\tlong long V3 = comb(X - i, A);\n\t\t\tlong long V4 = comb(Y - i, B);\n\t\t\tsum += mul2(mul2(V1, V2), mul2(V3, V4)); sum %= mod;\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define mod 1000000007\nll f[5000005];\nll modpow(ll a,ll n){\n    ll ret = 1LL,t = a;\n    while(n){\n        if(n%2 == 1) ret = ret*t%mod;\n        t = t*t%mod; n/=2;\n    }\n    return ret;\n}\nll C(int a,int b){\n    return f[a] * modpow(f[b],mod-2) % mod * modpow(f[a-b],mod-2) % mod;\n}\nint main(){\n    f[0] = 1LL;\n    for(int i=1;i<5000005;i++){\n        f[i] = f[i-1]*1LL*i%mod;\n    }\n    while(1){\n        int a,b,c,s1,s2;\n        cin >> a >> c >> b >> s1 >> s2;\n        if(a+b+c == 0) return 0;\n        int S = min(s1,s2);\n        ll ret = 0;\n        for(int i=0;i<=S;i++){\n            //s1-i???a???????????? & s2-i???c???????????? & i???a+b+c?????????\n            if(s1-i < a || s2-i < c) continue;\n            ll p = (a?C(s1-i-1,a-1):1); if(a == 0 && s1-i != 0) continue;\n            ll q = (c?C(s2-i-1,c-1):1); if(c == 0 && s2-i != 0) continue;\n            ret += p * q % mod * C(i+a+b+c-1,i) % mod;\n        }\n        ret %= mod;\n        ret = ret * (C(a+b+c,a) * C(b+c,b) % mod) % mod;\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\nll add(ll a,ll b){return (a+b)%mod;}\nll mul(ll a,ll b){return (a*b)%mod;}\n\nll mpow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mpow( mul(a,a) , b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\nll divi(ll a,ll b){\n  return mul(a, mpow(b,mod-2) );\n}\n\nll fact[3000000];\n\nll nCr(ll n,ll r){\n  return divi(fact[n], mul(fact[r],fact[n-r]) );\n}\n\nll nHr(ll n,ll r){\n  if(r==0)return 1;\n  return nCr(n+r-1,r-1);\n}\n\nll nBr(ll n,ll r){\n  if(n<r)return 0;\n  return nHr(n-r,r);\n}\n\nll A,B,C,D,E;\n\n\nint main(){\n  fact[0]=1;\n  for(ll i=1;i<3000000;i++)\n    fact[i]=mul(fact[i-1],i);\n  \n  while(1){\n    cin>>A>>B>>C>>D>>E;\n    if(A==0&&B==0&&C==0&&D==0&&E==0)break;\n    \n    ll ans=0;\n    if(D-A<E-B){\n      for(ll i=A;i<=D;i++){\n        ll j=-(D-E-i);\n        if(i<A)continue;\n        if(A==0&&i>0)continue;\n        if(i>D)continue;\n        if(j<B)continue;\n        if(B==0&&j>0)break;\n        if(j>E)break;\n        ll L=nBr(i,A);\n        ll R=nBr(j,B);\n        ll tmp=mul(L,R);\n        tmp=mul(tmp, nCr(A+B,A) );\n        tmp=mul(tmp, nCr(A+B+C,C) );\n        assert( D-i == E-j );\n        tmp=mul(tmp, nHr(D-i,A+B+C) );\n        ans=add(ans,tmp);\n      }\n    }else{\n      for(ll j=B;j<=E;j++){\n        ll i=(D-E+j);\n        if(i<A)continue;\n        if(A==0&&i>0)continue;\n        if(i>D)continue;\n        if(j<B)continue;\n        if(B==0&&j>0)continue;\n        if(j>E)continue;\n        ll L=nBr(i,A);\n        ll R=nBr(j,B);\n        ll tmp=mul(L,R);\n        tmp=mul(tmp, nCr(A+B,A) );\n        tmp=mul(tmp, nCr(A+B+C,C) );\n        assert( D-i == E-j );\n        tmp=mul(tmp, nHr(D-i,A+B+C) );\n        ans=add(ans,tmp);\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n//ａをbで割る\nlong long mod_div(ll a,ll b){\n\tif(a % b == 0)return a/b;\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n \n#define MAX_K 3333333\nvector<long long> kaijo(MAX_K);\nlong long combination(long long n, long long r){\n    if(n < r || n < 0 || r < 0)\n        return 0;\n\tif(kaijo[0] != 1){\n\t\tkaijo[0] = 1;\n\t\tfor(long long i = 1;i < MAX_K;i++)kaijo[i] = (kaijo[i-1] * i) % MOD;\n\t}\n    long long ret = kaijo[n];\n\tlong long tmp = (kaijo[r] * kaijo[n-r]) % MOD;\n    return mod_div(ret,tmp);\n}\n\nint main(){\n\tll a,b,c,x,y;\n\t\n\twhile(cin >> a >> b >> c >> x >> y,a+b+c+x+y){\n\t\t\n\t\tll ans = 0;\n\t\tll seica = combination(a+b+c,c) * combination(a+b,b) % MOD;\n\t\tfor(ll i = 0;i <= min(x,y);i++){\n\t\t\tll X = x-i-a;\n\t\t\tll Y = y-i-b;\n\t\t\tif(X < 0 || y < 0)continue;\n\t\t\tif(a == 0 && X > 0)continue;\n\t\t\tif(b == 0 && Y > 0)continue;\n\t\t\tll tmp = seica;\n\t\t\tif(a+b+c+i-1 >= i)tmp = (tmp * combination(a+b+c+i-1,i)) % MOD;\n\t\t\tif(a+X-1 >= X)tmp = (tmp * combination(a+X-1,X)) % MOD;\n\t\t\tif(b+Y-1 >= Y)tmp = (tmp * combination(b+Y-1,Y)) % MOD;\n\t\t\tans = (ans+tmp) % MOD;\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int mod = (int)(1e9 + 7)>\nstruct ModInt {\n  int x;\n  ModInt() : x(0) {}\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n  ModInt &operator+=(const ModInt &p) {\n    if ((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n  ModInt &operator-=(const ModInt &p) {\n    if ((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n  ModInt &operator*=(const ModInt &p) {\n    x = (int)(1LL * x * p.x % mod);\n    return *this;\n  }\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n  ModInt operator-() const { return ModInt(-x); }\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n  bool operator==(const ModInt &p) const { return x == p.x; }\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while (b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n  ModInt pow(int64_t n) const {\n    ModInt res(1), mul(x);\n    while (n) {\n      if (n & 1) res *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return res;\n  }\n  friend ostream &operator<<(ostream &os, const ModInt &p) { return os << p.x; }\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt<mod>(t);\n    return (is);\n  }\n  static int get_mod() { return mod; }\n};\n\nstruct Combination {\n  vector<ModInt<>> _fact, _rfact, _inv;\n  Combination(long long nsize = 5000000)\n      : _fact(nsize + 1), _rfact(nsize + 1), _inv(nsize + 1) {\n    _fact[0] = _rfact[nsize] = _inv[0] = 1;\n    for (int i = 1; i <= nsize; i++) _fact[i] = _fact[i - 1] * i;\n    _rfact[nsize] /= _fact[nsize];\n    for (int i = nsize - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n    for (int i = 1; i <= nsize; i++) _inv[i] = _rfact[i] * _fact[i - 1];\n  }\n  inline ModInt<> fact(int k) const { return _fact[k]; }\n\n  inline ModInt<> rfact(int k) const { return _rfact[k]; }\n\n  inline ModInt<> inv(int k) const { return _inv[k]; }\n\n  ModInt<> P(int n, int r) const {\n    if (r < 0 || n < r) return 0;\n    return fact(n) * rfact(n - r);\n  }\n\n  ModInt<> C(int p, int q) const {\n    if (q < 0 || p < q) return 0;\n    return fact(p) * rfact(q) * rfact(p - q);\n  }\n  // n types,choose r\n  ModInt<> H(int n, int r) const {\n    if (n < 0 || r < 0) return (0);\n    return r == 0 ? 1 : C(n + r - 1, r);\n  }\n};\n\nlong long a, b, c, x, y;\nCombination com;\n\nModInt<> solve();\n\nint main() {\n  while (1) {\n    cin >> a >> b >> c >> x >> y;\n    if (a + b + c + x + y == 0) break;\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nModInt<> solve() {\n  long long sum = a + b + c;\n  ModInt<> res = 0;\n  for (int i = 0; i <= min(x, y); ++i) {\n    ModInt<> now = com.H(sum, i);\n    now *= com.H(a, x - i - a);\n    now *= com.H(b, y - i - b);\n    res += now;\n  }\n  return res * com.fact(sum) * com.rfact(a) * com.rfact(b) * com.rfact(c);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\nint fact[6666666];\nint inv[6666666];\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nsigned main(){\n    fact[0]=1;\n    for(int i=1;i<6666666;i++)fact[i]=fact[i-1]*i%mod;\n    inv[6666666-1]=mpow(fact[6666666-1],mod-2);\n    for(int i=6666666-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n\n    int a,b,c,x,y;\n    while(cin>>a>>b>>c>>x>>y,a||b||c||x||y){\n        int n=a+b+c;\n        int t=min(x,y);\n        int ans=0;\n        for(int i=0;i<=t;i++){\n            int w=C(i+n-1,i);\n            w=w*C(n,a)%mod*C(n-a,b)%mod;\n            int xx=x-i-a;\n            int yy=y-i-b;\n            if(xx<0||yy<0)continue;\n            if(a)w=w*C(xx+a-1,xx)%mod;\n            else if(xx>0)continue;\n            if(b)w=w*C(yy+b-1,yy)%mod;\n            else if(yy>0)continue;\n            ans=(ans+w)%mod;\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n//nCr mod m\n#define MOD 1000000007\n#define M 4000010\nvector<ll> fact;\nbool h=false;\nvoid init(){\n\th=true;\n\tfact=vector<ll>(M);\n\tfact[0]=fact[1]=1;\n\tloop(i,2,M)fact[i]=fact[i-1]*i%MOD;\n}\n// a^b mod MOD\nll powmod(ll a,ll b,ll m=MOD){\n\tll out=1;\n\tll p=a%m;\n\twhile(b){\n\t\tif(b&1)out=out*p%m;\n\t\tp=p*p%m;\n\t\tb>>=1;\n\t}\n\treturn out;\n}\n//nCr\nll nCr(ll n,ll r,ll m=MOD){\n\tif(!h)init();\n\tif(n<0||r<0||n<r)return 0;//??????\n\tll out=fact[n]*powmod(fact[r]*fact[n-r]%m,m-2,m)%m;\n\treturn out;\n}\nint main(){\n\tll a,b,c,d,e;\n\twhile(cin>>a>>b>>c>>d>>e,a+b+c+d+e){\n\t\tll out=0;\n\t\tll A=nCr(a+b+c,a),B=nCr(b+c,b);\n\t\trep(s,d+1){//勝ち試合の点数合計\n\t\t\tint t=e-d+s;\n\t\t\tif(t<0||t>e)continue;\n\t\t\tll w=1;\n\t\t\tif(s||a)(w*=nCr(s-1,a-1)*A%MOD)%=MOD;\n//\t\t\tcout<<w<<\" \";\n\t\t\tif(t||b)(w*=nCr(t-1,b-1)*B%MOD)%=MOD;\n//\t\t\tcout<<w<<\" \";\n\t\t\t(w*=nCr(d-s+a+b+c-1,a+b+c-1))%=MOD;\n//\t\t\tcout<<w<<endl;\n\t\t\t(out+=w)%=MOD;\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "以外の点数を適当に配置\n            ll add = combination_duplicate(S, free_pt);\n\n            // 引き分けの位置\n            (add *= combination_array(S, C)) %= MOD;\n\n            // 勝ちの位置\n            (add *= combination_array(A+B, A)) %= MOD;\n\n            // P, Q の計算 (それぞれ A 以上・B 以上でなければならない)\n            int P = X - free_pt, Q = Y - free_pt;\n\n            if(P < A || Q < B) continue;\n            if(A == 0 && P > 0) continue;\n            if(B == 0 && Q > 0) continue;\n            P -= A, Q -= B;\n            if(A > 0) (add *= combination_duplicate(A, P)) %= MOD;\n            if(B > 0) (add *= combination_duplicate(B, Q)) %= MOD;\n\n            (ans += add) %= MOD;\n            // printf(\"D = %d, add = %lld\\n\", D, add);\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\nlong M=1e9+7;\nlong fac[1<<20],invfac[1<<20];\nlong pow(long a,long b){return b?pow(a*a%M,b/2)*(b%2?a:1)%M:1;}\nlong C(long a,long b)\n{\n\treturn fac[a]*invfac[a-b]%M*invfac[b]%M;\n}\nlong H(long a,long b)\n{\n\treturn a==0&&b==0?1:C(a+b-1,b);\n}\nlong a,b,c,sx,sy;\nmain()\n{\n\tfac[0]=fac[1]=1;\n\tfor(long i=2;i<1<<20;i++)fac[i]=fac[i-1]*i%M;\n\tfor(long i=0;i<1<<20;i++)invfac[i]=pow(fac[i],M-2);\n\twhile(cin>>a>>b>>c>>sx>>sy,a+b+c)\n\t{\n\t\tlong ans=0;\n\t\tfor(long i=0;i<=sx-a&&i<=sy-b;i++)\n\t\t{\n\t\t\tif(sx-i>0&&a==0||sy-i>0&&b==0)continue;\n\t\t\tans=(ans+H(a,sx-i-a)*C(a+b+c,a)%M*H(b,sy-i-b)%M*C(b+c,b)%M*H(a+b+c,i)%M)%M;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\nll add(ll a,ll b){return (a+b)%mod;}\nll mul(ll a,ll b){return (a*b)%mod;}\n\nll mpow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mpow( mul(a,a) , b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\nll divi(ll a,ll b){\n  return mul(a, mpow(b,mod-2) );\n}\n\nll fact[3000000];\n\nll nCr(ll n,ll r){\n  return divi(fact[n], mul(fact[r],fact[n-r]) );\n}\n\nll nHr(ll n,ll r){\n  if(r==0)return 1;\n  return nCr(n+r-1,r-1);\n}\n\nll nBr(ll n,ll r){\n  if(n<r)return 0;\n  return nHr(n-r,r);\n}\n\nll A,B,C,D,E;\n\n\nint main(){\n  fact[0]=1;\n  for(ll i=1;i<3000000;i++)\n    fact[i]=mul(fact[i-1],i);\n  \n  while(1){\n    cin>>A>>B>>C>>D>>E;\n    if(A==0&&B==0&&C==0&&D==0&&E==0)break;\n    \n    ll ans=0;\n    for(ll i=0;i<=1000000;i++){\n      ll j=-(D-E-i);\n      if(i<A)continue;\n      if(A==0&&i>0)continue;\n      if(i>D)continue;\n      if(j<B)continue;\n      if(B==0&&j>0)continue;\n      if(j>E)continue;\n      \n      //      cout<<i<<' '<<j<<endl;\n        \n      ll L=nBr(i,A);\n      ll R=nBr(j,B);\n      ll tmp=mul(L,R);\n      //      cout<<L<<' '<<R<<' '<<tmp<<endl;\n      tmp=mul(tmp, nCr(A+B,A) );\n      tmp=mul(tmp, nCr(A+B+C,C) );\n      assert( D-i == E-j );\n      tmp=mul(tmp, nHr(D-i,A+B+C) );\n      ans=add(ans,tmp);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\nusing ll = long long;\nconst ll mod = 1000000007LL;\n\nconst int limit = 5000000;\nll F[limit+10],IF[limit+10];\n\nll inv(ll a){\n\tll b = 1LL;\n\tll n = mod -2;\n\twhile(n){\n\t\tif(n&1) b = b * a % mod;\n\t\ta = a * a % mod;\n\t\tn >>= 1;\n\t}\n\treturn b;\n}\n\ninline ll C(int n,int k){\n\tif(n < 0 or k < 0 or n-k < 0) return 0LL;\n\treturn F[n] * IF[k] % mod * IF[n-k] %mod;\n}\n\ninline ll H(int n,int k){\n\tif(n == 0 and k == 0) return 1;\n\tn += k - 1;\n\treturn C(n,k);\n}\n\nint main(void){\n\tF[0] = 1LL;\n\tfor(ll i=1LL;i<=limit;++i) F[i] = i * F[i-1] %mod;\n\tIF[limit] = inv(F[limit]);\n\tfor(ll i=limit;i>=1;--i) IF[i-1] = i * IF[i] %mod;\n\t\t\n\tll a,b,c,sx,sy;\n\twhile(cin >> a >> b >> c >> sx >> sy){\n\t\tif(a+b+c+sx+sy==0) break;\n\t\tll ans = 0LL;\n\n\t\tfor(ll wa = a; wa <= sx; ++ wa){\n\t\t\tconst ll draw = sx - wa;\n\t\t\tconst ll wb = sy - draw; \n\t\t\tif(draw < 0 or wb < b) continue;\n\t\t\t//cerr << wa << \" \" << wb << \" \" << draw << endl;\n\t\t\tll cur = 1LL;\n\t\t\tcur = cur * H(a,wa-a) % mod;\n\t\t\tcur = cur * H(b,wb-b) % mod;\n\t\t\tcur = cur * H(a+b+c,draw) % mod;\n\t\t\tans = (ans + cur) % mod;\n\t\t}\n\n\t\tans = ans * C(a+b+c,a) % mod * C(b+c,b) % mod;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 3000100\n\nll fac[SIZE];\nll fac_in_memo[SIZE];\n\nvoid factorial_init(int n){\n  fac[0] = 1;\n  for(int i=1;i<=n;i++) fac[i] = (i * fac[i-1])%mod;\n}\n\nll factorial(int n,int M){\n  ll ret=1;\n  if(n<=1) return 1;\n  return fac[n];\n  \n  for(int i=1;i<=n;i++){\n    ret = (ret*i)%M;\n  }\n  \n  return ret;\n}\n\nll power(int k,int n,int M){\n  if(n==0) return 1;\n  if(n==1) return (ll)k;\n  \n  ll ret = power(k,n/2,M);\n  \n  ret=(ret*ret)%M;\n  \n  if(n%2==1)\n    ret=(ret*k)%M;\n  \n  return ret;\n}\n\nll fac_in(int k, int n, int M){\n  if(fac_in_memo[k]) return fac_in_memo[k];\n  return fac_in_memo[k] = power(k,n,M);\n}\n\n//nCm nPm nHm (mod M)\n\n/*Combination*/\nint C(int n,int m,int M){\n  if(n<m) return 0;\n  if(m==0 || n==m) return 1;\n  \n  ll chi = factorial(n,M);\n  ll mot = (factorial(m,M) * factorial(n-m,M))%M;\n  \n  mot = power((int)mot,M-2,M);\n  \n  ll ret = (chi*mot)%M;\n  \n  return (int)ret;\n}\n/*Permutation*/\nint P(int n,int m,int M){\n  if(n<m) return 0;\n  if(m==0) return 1;\n  \n  ll chi = factorial(n,M);\n  ll mot = factorial(n-m,M);\n  \n  \n  mot = power((int)mot, M-2,M);\n  \n  ll ret = (chi*mot)%M;\n  \n  return (int)ret;\n}\n/*Combination with Repetitions*/\nint H(int n,int m,int M){\n  if(n==0 && m==0) return 1;\n  return C(n+m-1,m,M);\n}\n\n\n\nbool solve(){\n  int a,b,c,sx,sy;\n\n  scanf(\"%d%d%d%d%d\",&a,&b,&c,&sx,&sy);\n\n  if(a +b + c == 0) return false;\n  \n  if(sx < sy){\n    swap(sx,sy);\n    swap(a,b);\n  }\n\n  ll ans_sum = 0;\n  \n  for(int i=sx-sy;i<=sx;i++){\n    int p = i;\n    int q = i - (sx-sy);\n\n    if(p < a || q < b || (a==0 && p>0) || (b==0 && q > 0)) continue;\n\n    ll ans = 1;\n\n    ans = (ans * C(p-1,a-1,mod))%mod;\n    ans = (ans * C(q-1,b-1,mod))%mod;\n    ans = (ans * C(sx-i+(c+b+a-1),c+b+a-1,mod))%mod;\n    \n    ans_sum = (ans_sum + ans)%mod;\n  }\n  \n  ans_sum = (ans_sum * factorial(a+b+c,mod))%mod;\n  ans_sum = (ans_sum * power(factorial(a,mod),mod-2,mod))%mod;\n  ans_sum = (ans_sum * power(factorial(b,mod),mod-2,mod))%mod;\n  ans_sum = (ans_sum * power(factorial(c,mod),mod-2,mod))%mod;\n\n  printf(\"%lld\\n\",ans_sum);\n\n  return true;\n}\n\nint main(){\n\n  factorial_init(3000000);\n  \n  while(solve());\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n//ａをbで割る\nlong long mod_div(ll a,ll b){\n\tif(a % b == 0)return a/b;\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n \n#define MAX_K 6666666\nvector<long long> kaijo(MAX_K);\nlong long combination(long long n, long long r){\n    if(n < r || n < 0 || r < 0)\n        return 0;\n\tif(kaijo[0] != 1){\n\t\tkaijo[0] = 1;\n\t\tfor(long long i = 1;i < MAX_K;i++)kaijo[i] = (kaijo[i-1] * i) % MOD;\n\t}\n    long long ret = kaijo[n];\n\tlong long tmp = (kaijo[r] * kaijo[n-r]) % MOD;\n    return mod_div(ret,tmp);\n}\n\nint main(){\n\tll a,b,c,x,y;\n\t\n\twhile(cin >> a >> b >> c >> x >> y,a+b+c+x+y){\n\t\t\n\t\tll ans = 0;\n\t\tfor(ll i = 0;i <= min(x,y);i++){\n\t\t\tll X = x-i-a;\n\t\t\tll Y = y-i-b;\n\t\t\tif(X <= 0 || y <= 0)continue;\n\t\t\tll tmp = 1;\n\t\t\ttmp = (tmp * combination(a+b+c,c)) % MOD;\n\t\t\ttmp = (tmp * combination(a+b,b)) % MOD;\n\t\t\ttmp = (tmp * combination(a+b+c+i-1,i)) % MOD;\n\t\t\tif(a > 0)tmp = (tmp * combination(a+X-1,X)) % MOD;\n\t\t\tif(b > 0)tmp = (tmp * combination(b+Y-1,Y)) % MOD;\n\t\t\tans = (ans+tmp) % MOD;\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nll mod = 1e9+7;\n\nconst int N = 4000004;\nll f[N], inv_f[N];\n\ninline ll mod_pow(ll x, ll n)\n{\n    ll r = 1;\n    while(n)\n    {\n        if(n&1) (r*=x)%=mod;\n        (x*=x)%=mod;\n        n>>=1;\n    }\n    return r;\n}\n\ninline ll mod_inv(ll x)\n{\n    return mod_pow(x,mod-2);\n}\n\n\ninline ll C(int n, int r)\n{\n    if(n<0 || r<0 || n-r<0) return 0;\n    ll ret = f[n];\n    (ret*=inv_f[r])%=mod;\n    (ret*=inv_f[n-r])%=mod;\n    return ret;\n}\n\ninline ll H(int n, int r)\n{\n    if(n==0 && r==0) return 1;\n    return C(n+r-1,r);\n}\n\nint main()\n{\n    f[0]=1;\n    for(int i=1; i<N; ++i) f[i]=(f[i-1]*i)%mod;\n\n    inv_f[N-1] = mod_inv(f[N-1]);\n    for(int i=N-2; i>=0; --i) inv_f[i] = (inv_f[i+1]*(i+1))%mod;\n\n    int a,b,c,sx,sy;\n    while(cin >>a >>b >>c >>sx >>sy)\n    {\n        if(a+b+c+sx+sy==0) break;\n        ll ans = 0;\n        rep(i,sx+1)\n        {\n            ll add = 1;\n            int j = sy-sx+i;\n            (add*=H(a,i-a))%=mod;\n            (add*=H(b,j-b))%=mod;\n            (add*=H(a+b+c,sx-i))%=mod;\n\n            (ans += add)%=mod;\n        }\n        (ans*=C(a+b+c,a))%=mod;\n        (ans*=C(b+c,b))%=mod;\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n//ａをbで割る\nlong long mod_div(ll a,ll b){\n\tif(a % b == 0)return a/b;\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n \n#define MAX_K 6666666\nvector<long long> kaijo(MAX_K);\nlong long combination(long long n, long long r){\n    if(n < r || n < 0 || r < 0)\n        return 0;\n\tif(kaijo[0] != 1){\n\t\tkaijo[0] = 1;\n\t\tfor(long long i = 1;i < MAX_K;i++)kaijo[i] = (kaijo[i-1] * i) % MOD;\n\t}\n    long long ret = kaijo[n];\n\tlong long tmp = (kaijo[r] * kaijo[n-r]) % MOD;\n    return mod_div(ret,tmp);\n}\n\nint main(){\n\tint a,b,c,x,y;\n\t\n\twhile(cin >> a >> b >> c >> x >> y,a+b+c+x+y){\n\t\t\n\t\tll ans = 0;\n\t\tfor(int i = 1;i <= min(x,y);i++){\n\t\t\tint X = x-i-a;\n\t\t\tint Y = y-i-b;\n\t\t\tif(X < 0 || y < 0)continue;\n\t\t\tll tmp = 1;\n\t\t\ttmp = (tmp * combination(a+b+c,c)) % MOD;\n\t\t\ttmp = (tmp * combination(a+b,b)) % MOD;\n\t\t\ttmp = (tmp * combination(a+b+c+i-1,i)) % MOD;\n\t\t\ttmp = (tmp * combination(a+X-1,X)) % MOD;\n\t\t\ttmp = (tmp * combination(b+Y-1,Y)) % MOD;\n\t\t\tans = (ans+tmp) % MOD;\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n//nCr mod m\n#define MOD 1000000007\n#define M 4000010\nvector<ll> fact;\nbool h=false;\nvoid init(){\n\th=true;\n\tfact=vector<ll>(M);\n\tfact[0]=fact[1]=1;\n\tloop(i,2,M)fact[i]=fact[i-1]*i%MOD;\n}\n// a^b mod MOD\nll powmod(ll a,ll b,ll m=MOD){\n\tll out=1;\n\tll p=a%m;\n\twhile(b){\n\t\tif(b&1)out=out*p%m;\n\t\tp=p*p%m;\n\t\tb>>=1;\n\t}\n\treturn out;\n}\n//nCr\nll nCr(ll n,ll r,ll m=MOD){\n\tif(!h)init();\n\tif(n<0||r<0||n<r)return 0;//??????\n\tll out=fact[n]*powmod(fact[r]*fact[n-r]%m,m-2,m)%m;\n\treturn out;\n}\nint main(){\n\tll a,b,c,d,e;\n\twhile(cin>>a>>b>>c>>d>>e,a+b+c+d+e){\n\t\tif(d>e)swap(a,b),swap(d,e);\n\t\tll out=0;\n\t\tll A=nCr(a+b+c,a),B=nCr(b+c,b);\n\t\trep(s,d+1){\n\t\t\tll t=e-d+s;\n\t\t\tif(t<0||t>e)continue;\n\t\t\tll w=1;\n\t\t\tif(s||a)(w*=nCr(s-1,a-1)*A%MOD)%=MOD;\n\t\t\tif(t||b)(w*=nCr(t-1,b-1)*B%MOD)%=MOD;\n\t\t\t(w*=nCr(d-s+a+b+c-1,a+b+c-1))%=MOD;\n\t\t\t(out+=w)%=MOD;\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n//nCr mod m\n#define MOD 1000000007\n#define M 3000010\nvector<ll> fact;\nbool h=false;\nvoid init(){\n\th=true;\n\tfact=vector<ll>(M);\n\tfact[0]=fact[1]=1;\n\tloop(i,2,M)fact[i]=fact[i-1]*i%MOD;\n}\n// a^b mod MOD\nll powmod(ll a,ll b,ll m=MOD){\n\tll out=1;\n\tll p=a%m;\n\twhile(b){\n\t\tif(b&1)out=out*p%m;\n\t\tp=p*p%m;\n\t\tb>>=1;\n\t}\n\treturn out;\n}\n//nCr\nll nCr(ll n,ll r,ll m=MOD){\n\tif(!h)init();\n\tif(n<0||r<0||n<r)return 0;//??????\n\tll out=fact[n]*powmod(fact[r]*fact[n-r]%m,m-2,m)%m;\n\treturn out;\n}\nint main(){\n\tll a,b,c,d,e;\n\twhile(cin>>a>>b>>c>>d>>e,a+b+c+d+e){\n\t\tll out=0;\n\t\tll A=nCr(a+b+c,a),B=nCr(b+c,b);\n\t\trep(s,d+1){//勝ち試合の点数合計\n\t\t\tint t=e-d+s;\n\t\t\tif(t<0||t>e)continue;\n\t\t\tll w=1;\n\t\t\tif(s||a)(w*=nCr(s-1,a-1)*A%MOD)%=MOD;\n//\t\t\tcout<<w<<\" \";\n\t\t\tif(t||b)(w*=nCr(t-1,b-1)*B%MOD)%=MOD;\n//\t\t\tcout<<w<<\" \";\n\t\t\t(w*=nCr(d-s+a+b+c-1,a+b+c-1))%=MOD;\n//\t\t\tcout<<w<<endl;\n\t\t\t(out+=w)%=MOD;\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nll mod = 1e9+7;\n\nconst int N = 5000000;\nll f[N], inv_f[N];\n\nll mod_pow(ll x, ll n)\n{\n    ll r = 1;\n    while(n)\n    {\n        if(n&1) (r*=x)%=mod;\n        (x*=x)%=mod;\n        n>>=1;\n    }\n    return r;\n}\n\nll mod_inv(ll x)\n{\n    return mod_pow(x,mod-2);\n}\n\n\nll C(int n, int r)\n{\n    if(n<0 || r<0 || n-r<0) return 0;\n    ll ret = f[n];\n    (ret*=inv_f[r])%=mod;\n    (ret*=inv_f[n-r])%=mod;\n    return ret;\n}\n\nll H(int n, int r)\n{\n    if(n==0 && r==0) return 1;\n    return C(n+r-1,r);\n}\n\nint main()\n{\n    f[0]=1;\n    for(int i=1; i<N; ++i) f[i]=(f[i-1]*i)%mod;\n\n    inv_f[N-1] = mod_inv(f[N-1]);\n    for(int i=N-2; i>=0; --i) inv_f[i] = (inv_f[i+1]*(i+1))%mod;\n\n    int a,b,c,sx,sy;\n    while(cin >>a >>b >>c >>sx >>sy)\n    {\n        if(a+b+c+sx+sy==0) break;\n        ll ans = 0;\n        rep(i,sx+1)\n        {\n            ll add = 1;\n            int j = sy-sx+i;\n            (add*=H(a,i-a))%=mod;\n            (add*=H(b,j-b))%=mod;\n            (add*=H(a+b+c,sx-i))%=mod;\n\n            (ans += add)%=mod;\n        }\n        (ans*=C(a+b+c,a))%=mod;\n        (ans*=C(b+c,b))%=mod;\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n//ａをbで割る\nlong long mod_div(ll a,ll b){\n\tif(a % b == 0)return a/b;\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n \n#define MAX_K 6666666\nvector<long long> kaijo(MAX_K);\nlong long combination(long long n, long long r){\n    if(n < r || n < 0 || r < 0)\n        return 0;\n\tif(kaijo[0] != 1){\n\t\tkaijo[0] = 1;\n\t\tfor(long long i = 1;i < MAX_K;i++)kaijo[i] = (kaijo[i-1] * i) % MOD;\n\t}\n    long long ret = kaijo[n];\n\tlong long tmp = (kaijo[r] * kaijo[n-r]) % MOD;\n    return mod_div(ret,tmp);\n}\n\nint main(){\n\tint a,b,c,x,y;\n\t\n\twhile(cin >> a >> b >> c >> x >> y,a+b+c+x+y){\n\t\t\n\t\tll ans = 0;\n\t\tfor(int i = 0;i <= x+y;i++){\n\t\t\tint X = x-i-a;\n\t\t\tint Y = y-i-b;\n\t\t\tif(X < 0 && y < 0)continue;\n\t\t\tll tmp = 1;\n\t\t\ttmp = (tmp * combination(a+b+c,c)) % MOD;\n\t\t\ttmp = (tmp * combination(a+b,b)) % MOD;\n\t\t\ttmp = (tmp * combination(a+b+c+i-1,i)) % MOD;\n\t\t\ttmp = (tmp * combination(a+X-1,X)) % MOD;\n\t\t\ttmp = (tmp * combination(b+Y-1,Y)) % MOD;\n\t\t\tans = (ans+tmp) % MOD;\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T> T power(T a, long long n) {\n  assert(n >= 0);\n  T res = 1;\n  while (n) {\n    if (n & 1) res *= a;\n    if (n >>= 1) a *= a;\n  }\n  return res;\n}\n\ntemplate <unsigned M> struct modular {\n  using m = modular;\n  unsigned v;\n  modular(long long a = 0) : v((a %= M) < 0 ? a + M : a) {}\n  m operator-() const { return m() -= *this; }\n  m& operator+=(m r) { if ((v += r.v) >= M) v -= M; return *this; }\n  m& operator-=(m r) { if (v < r.v) v += M; v -= r.v; return *this; }\n  m& operator*=(m r) { v = (uint64_t)v * r.v % M; return *this; }\n  m& operator/=(m r) { return *this *= power(r, M - 2); }\n  friend m operator+(m l, m r) { return l += r; }\n  friend m operator-(m l, m r) { return l -= r; }\n  friend m operator*(m l, m r) { return l *= r; }\n  friend m operator/(m l, m r) { return l /= r; }\n  friend bool operator==(m l, m r) { return l.v == r.v; }\n};\n\nconstexpr long long mod = 1e9 + 7;\nusing mint = modular<mod>;\n\nvector<mint> fact, inv_fact, minv;\nvoid prepare(int n) {\n  fact.resize(n + 1), inv_fact.resize(n + 1), minv.resize(n + 1);\n  for (int i = 0; i <= n; ++i) fact[i] = i ? i * fact[i - 1] : 1;\n  inv_fact[n] = power(fact[n], mod - 2);\n  for (int i = n; i; --i) inv_fact[i - 1] = i * inv_fact[i];\n  for (int i = 1; i <= n; ++i) minv[i] = inv_fact[i] * fact[i - 1];\n}\nmint binom(int n, int k) {\n  if (k < 0 or k > n) return 0;\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}\ntemplate<> mint& mint::operator/=(mint r) {\n  return *this *= r.v < minv.size() ? minv[r.v] : power(r, mod - 2);\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int a, b, c, s, t;\n  prepare(5e6);\n  auto fn = [](int n, int k) -> mint {\n    if (k == 0) return n == 0;\n    return binom(n + k - 1, n);\n  };\n  while (cin >> a >> b >> c >> s >> t, a + b + c) {\n    mint res;\n    for (int x = 0; x <= min(s, t); ++x) {\n      int p = s - x - a, q = t - x - b;\n      if (p < 0 or q < 0) {\n        continue;\n      }\n      res += fn(p, a) * fn(q, b) * fn(x, a + b + c);\n    }\n    res *= fact[a + b + c] * inv_fact[a] * inv_fact[b] * inv_fact[c];\n    cout << res.v << '\\n';\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\nll add(ll a,ll b){return (a+b)%mod;}\nll mul(ll a,ll b){return (a*b)%mod;}\n\nll mpow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mpow( mul(a,a) , b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\nll divi(ll a,ll b){\n  return mul(a, mpow(b,mod-2) );\n}\n\nll fact[3000000];\nll Fact[3000000];\ntypedef pair<ll,ll> P;\n\nunordered_map< ll , ll  > mem;\n\nll base=10000000000LL;\n\nll nCr(ll n,ll r){\n  \n  if(mem.count(n*base+r))\n    return mem[n*base+r];\n  \n  return mem[n*base+r]=mul(fact[n], mul(Fact[r],Fact[n-r]) );\n}\n\nll nHr(ll n,ll r){\n  if(r==0)return 1;\n  return nCr(n+r-1,r-1);\n}\n\nll nBr(ll n,ll r){\n  if(n<r)return 0;\n  return nHr(n-r,r);\n}\n\nll A,B,C,D,E;\n\n\nint main(){\n  fact[0]=1;\n  for(ll i=1;i<3000000;i++){\n    fact[i]=mul(fact[i-1],i);\n  }\n  for(ll i=0;i<3000000;i++)Fact[i]=divi(1,fact[i]);\n  \n  while(1){\n    mem.clear();\n    \n    cin>>A>>B>>C>>D>>E;\n    if(A==0&&B==0&&C==0&&D==0&&E==0)break;\n    \n    ll ans=0;\n    for(ll i=max(A,B+D-E);i<=D;i++){\n      ll j=-(D-E-i);\n      //      if(i<A)continue;\n      if(A==0&&i>0)continue;\n      //      if(i>D)continue;\n      //      if(j<B)continue;\n      if(B==0&&j>0)break;\n      if(j>E)break;\n      ll L=nBr(i,A);\n      ll R=nBr(j,B);\n      ll tmp=mul(L,R);\n      tmp=mul(tmp, nCr(A+B,A) );\n      tmp=mul(tmp, nCr(A+B+C,C) );\n      assert( D-i == E-j );\n      tmp=mul(tmp, nHr(D-i,A+B+C) );\n      ans=add(ans,tmp);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\nll add(ll a,ll b){return (a+b)%mod;}\nll mul(ll a,ll b){return (a*b)%mod;}\n\nll mpow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mpow( mul(a,a) , b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\nll divi(ll a,ll b){\n  return mul(a, mpow(b,mod-2) );\n}\n\nll fact[3000000];\ntypedef pair<ll,ll> P;\n\nunordered_map< ll , ll  > mem;\n\nll base=10000000000LL;\n\nll nCr(ll n,ll r){\n  \n  if(mem.count(n*base+r))\n    return mem[n*base+r];\n  \n  return mem[n*base+r]=divi(fact[n], mul(fact[r],fact[n-r]) );\n}\n\nll nHr(ll n,ll r){\n  if(r==0)return 1;\n  return nCr(n+r-1,r-1);\n}\n\nll nBr(ll n,ll r){\n  if(n<r)return 0;\n  return nHr(n-r,r);\n}\n\nll A,B,C,D,E;\n\n\nint main(){\n  fact[0]=1;\n  for(ll i=1;i<3000000;i++)\n    fact[i]=mul(fact[i-1],i);\n  \n  while(1){\n    mem.clear();\n    \n    cin>>A>>B>>C>>D>>E;\n    if(A==0&&B==0&&C==0&&D==0&&E==0)break;\n    \n    ll ans=0;\n    if(D-A<E-B){\n      for(ll i=A;i<=D;i++){\n        ll j=-(D-E-i);\n        if(i<A)continue;\n        if(A==0&&i>0)continue;\n        if(i>D)continue;\n        if(j<B)continue;\n        if(B==0&&j>0)break;\n        if(j>E)break;\n        ll L=nBr(i,A);\n        ll R=nBr(j,B);\n        ll tmp=mul(L,R);\n        tmp=mul(tmp, nCr(A+B,A) );\n        tmp=mul(tmp, nCr(A+B+C,C) );\n        assert( D-i == E-j );\n        tmp=mul(tmp, nHr(D-i,A+B+C) );\n        ans=add(ans,tmp);\n      }\n    }else{\n      for(ll j=B;j<=E;j++){\n        ll i=(D-E+j);\n        if(i<A)continue;\n        if(A==0&&i>0)continue;\n        if(i>D)continue;\n        if(j<B)continue;\n        if(B==0&&j>0)continue;\n        if(j>E)continue;\n        ll L=nBr(i,A);\n        ll R=nBr(j,B);\n        ll tmp=mul(L,R);\n        tmp=mul(tmp, nCr(A+B,A) );\n        tmp=mul(tmp, nCr(A+B+C,C) );\n        assert( D-i == E-j );\n        tmp=mul(tmp, nHr(D-i,A+B+C) );\n        ans=add(ans,tmp);\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n//nCr mod m\n#define MOD 1000000007\n#define M 4000010\nvector<ll> fact,inv;\nbool h=false;\nll A,B;\n// a^b mod MOD\nll powmod(ll a,ll b,ll m=MOD){\n\tll out=1;\n\tll p=a%m;\n\twhile(b){\n\t\tif(b&1)out=out*p%m;\n\t\tp=p*p%m;\n\t\tb>>=1;\n\t}\n\treturn out;\n}\nvoid init(){\n\th=true;\n\tfact=vector<ll>(M);\n\tfact[0]=fact[1]=1;\n\tloop(i,2,M)fact[i]=fact[i-1]*i%MOD;\n\tinv=vector<ll>(M);\n\trep(i,M)inv[i]=powmod(fact[i],MOD-2,MOD);\n}\n//nCr\nll nCr(ll n,ll r,ll m=MOD){\n\tif(!h)init();\n\tif(n<0||r<0||n<r)return 0;//??????\n\tll out=fact[n]*inv[r]%m*inv[n-r]%m;\n\treturn out;\n}\nvoid f(ll n,ll r,ll m=MOD){\n\tif(n<0||r<0||n<r){\n\t\tA=0;\n\t\treturn;\n\t}\n\t(A*=fact[n])%=MOD;\n\t(B*=fact[r]*fact[n-r]%MOD)%=MOD;\n\treturn;\n}\nint main(){\n\tll a,b,c,d,e;\n\twhile(cin>>a>>b>>c>>d>>e,a+b+c+d+e){\n\t\tll out=0;\n\t\tll aa=nCr(a+b+c,a),bb=nCr(b+c,b);\n\t\trep(s,d+1){\n\t\t\tA=B=1;\n\t\t\tll t=e-d+s;\n\t\t\tif(t<0||t>e)continue;\n\t\t\tll w=1;\n\t\t\tif(s||a){\n\t\t\t\tf(s-1,a-1);\n\t\t\t\t(A*=aa)%=MOD;\n\t\t\t}\n\t\t\tif(t||b){\n\t\t\t\tf(t-1,b-1);\n\t\t\t\t(A*=bb)%=MOD;\n\t\t\t}\n\t\t\tf(d-s+a+b+c-1,a+b+c-1);\n\t\t\t(out+=A*powmod(B,MOD-2,MOD))%=MOD;\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\nusing ll = long long int;\nconst ll MOD = 1000000007;\n\nll mod_pow(ll x, ll n) {\n    if(n == 0) return 1;\n    ll res = mod_pow((x * x) % MOD, n / 2);\n    if(n & 1) res = (res * x) % MOD;\n    return res;\n}\n\n// 階乗 mod p\nvector<ll> fact;\nvoid fact_mod(int n) {\n    fact.resize(n+1);\n    fact[0] = 1;\n    for(int i=0; i<n; i++) {\n        fact[i+1] = (fact[i] * (i+1)) % MOD;\n    }\n}\n\n// 階乗の逆元 mod p\nvector<ll> finv;\nvoid fact_inv(int n) {\n    finv.resize(n+1);\n    finv[n] = mod_pow(fact[n], MOD-2);\n    for(int i=n-1; i>=0; i--) {\n        finv[i] = (finv[i+1] * (i+1)) % MOD;\n    }\n}\n\n// fact, finv を使って組み合わせを出す\n// 基本的にはこれを使ったほうがいい\nll combination_array(int n, int r) {\n    if(n < 0 || r < 0 || n < r) return 0;\n    ll x = fact[n];\n    ll y = (finv[r] * finv[n-r]) % MOD;\n\n    return (x * y) % MOD;\n}\n\nll combination_duplicate(int x, int y) {\n    return combination_array(x+y-1, y);\n}\n\nconst int M = 6000010;\nint main() {\n    fact_mod(M);\n    fact_inv(M);\n\n    while(1) {\n        ll A, B, C, X, Y; scanf(\"%lld%lld%lld%lld%lld\", &A, &B, &C, &X, &Y);\n        if(A + B + C + X + Y == 0) break;\n\n        ll ans = 0;\n        // diff を決め打ち\n        for(int D = 0; D <= X+Y; D++) {\n            int free_pt = (X+Y-D) / 2, S = A+B+C;\n            if( (X+Y-D) % 2 == 1 ) continue;\n            if(free_pt > X || free_pt > Y) continue;\n\n            // 差分以外の点数を適当に配置\n            ll add = combination_duplicate(S, free_pt);\n\n            // 引き分けの位置\n            (add *= combination_array(S, C)) %= MOD;\n\n            // 勝ちの位置\n            (add *= combination_array(A+B, A)) %= MOD;\n\n            // P, Q の計算 (それぞれ A 以上・B 以上でなければならない)\n            int P = X - free_pt, Q = Y - free_pt;\n\n            if(P < A || Q < B) continue;\n            if(A == 0 && P > 0) continue;\n            if(B == 0 && Q > 0) continue;\n            P -= A, Q -= B;\n            if(A > 0) (add *= combination_duplicate(A, P)) %= MOD;\n            if(B > 0) (add *= combination_duplicate(B, Q)) %= MOD;\n\n            (ans += add) %= MOD;\n            // printf(\"D = %d, add = %lld\\n\", D, add);\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 4000005\n\nll fact[NUM];\n\nll extgcd(ll a,ll b,ll &x,ll &y){\n\tll d = a;\n\tif(b != 0){\n\t\td = extgcd(b,a%b,y,x);\n\t\ty -= (a/b)*x;\n\t}else{\n\t\tx = 1;\n\t\ty = 0;\n\t}\n\treturn d;\n}\n\nll mod_inverse(ll a,ll m){\n    ll x,y;\n    extgcd(a,m,x,y);\n    return (m+x%m)%m;\n}\n\nll mod_fact(ll n,ll p,ll &e){\n\te = 0;\n\tif(n == 0)return 1;\n\n\tint res = mod_fact(n/p,p,e);\n\te += n/p;\n\n\tif(n/p%2 != 0)return res*(p-fact[n%p])%p;\n\treturn res*fact[n%p]%p;\n}\n\nll nCm(ll n,ll m,ll p){\n   if(n < m) return 0;\n   ll e1,e2,e3;\n    ll a1 = mod_fact(n,p,e1),a2 = mod_fact(m,p,e2),a3 = mod_fact(n-m,p,e3);\n    if(e1 > e2+e3)return 0;\n    return a1 * mod_inverse(a2*a3%p,p)%p;\n}\n\nll A,B,C,S_X,S_Y;\n\nvoid func(){\n\n\tll ans = 0,alloc_A,alloc_B,tmp;\n\tll S_diff = S_X-S_Y;\n\n\tfor(ll lead_X = A; lead_X <= S_X; lead_X++){\n\t\tll lead_Y = lead_X-S_diff;\n\t\tif(lead_Y < B)continue;\n\n\t\tif(lead_X == 0){\n\t\t\talloc_A = 1;\n\t\t}else{\n\t\t\talloc_A = nCm(lead_X-1,lead_X-A,MOD);\n\t\t}\n\n\t\tif(lead_Y == 0){\n\t\t\talloc_B = 1;\n\t\t}else{\n\t\t\talloc_B = nCm(lead_Y-1,lead_Y-B,MOD);\n\t\t}\n\n\t\ttmp = alloc_A*alloc_B;\n\t\ttmp %= MOD;\n\n\t\ttmp *= nCm(S_X-lead_X+(A+B+C)-1,A+B+C-1,MOD);\n\t\ttmp %= MOD;\n\n\t\tans += tmp;\n\t\tans %= MOD;\n\t}\n\n\tans *= nCm(A+B+C,A,MOD);\n\tans %= MOD;\n\tans *= nCm(B+C,B,MOD);\n\tans %= MOD;\n\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\n\tfact[0] = 1;\n\tfor(ll i = 1;i < NUM; i++){\n\t\tfact[i] = fact[i-1]*i%MOD;\n\t}\n\n\twhile(true){\n\t\tscanf(\"%lld %lld %lld %lld %lld\",&A,&B,&C,&S_X,&S_Y);\n\t\tif(A == 0 && B == 0 && C == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long int lli;\nconstexpr lli mod = 1e9+7;\n\nlli ExGCD(lli a, lli b, lli &x, lli &y){\n    lli d=a;\n    x=1; y=0;\n    if(b!=0){ d=ExGCD(b, a%b, y, x); y-=a/b*x; }\n    return d;\n}\nlli inverse(lli a){\n    lli x,y;\n    ExGCD(a, mod, x, y);\n    return x>0? x: mod+x;\n}\n\nconstexpr int arrmax=3000001;\nlli fact[arrmax];\nlli inv[arrmax];\nvoid maketable(){\n    fact[0] = 1;\n    for(int i=0; i<arrmax-1; i++){\n        fact[i+1] = fact[i]*(i+1) %mod;\n    }\n    inv[arrmax-1] = inverse(fact[arrmax-1]);\n    for(int i=arrmax-1; i>0; i--){\n        inv[i-1] = inv[i]*i %mod;\n    }\n}\nlli combination(lli n, lli r){\n    return fact[n] *inv[n-r] %mod *inv[r] %mod;\n}\n\nint main(){\n    maketable();\n    while(1){\n        int a,b,c,sx,sy;\n        cin >> a >> b >> c >> sx >> sy;\n        int n = a+b+c;\n        if(n == 0) break;\n\n        lli ans = 0;\n        lli winpos = fact[n] *inv[a] %mod *inv[b] %mod *inv[c] %mod;\n        for(int base=0; sx-base>=a and sy-base>=b; base++){\n            if(sx-base > 0 and a==0) continue;\n            if(sy-base > 0 and b==0) continue;\n            lli sub = winpos;\n            sub *= combination(n-1 +base, n-1);\n            sub %= mod;\n            if(a > 0){\n                sub *= combination(sx-base-1, a-1);\n                sub %= mod;\n            }\n            if(b > 0){\n                sub *= combination(sy-base-1, b-1);\n                sub %= mod;\n            }\n            ans += sub;\n            ans %= mod;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\n//\n// nCk mod m\n//\n// Complexity:\n//     preprocessing: O(max{n,k} log max{n,k}) time\n//     query: O(1) time\n//\n\nconst int MAX_N = 6000000;\nconst int MOD = 1000000007;\nlong long inv[MAX_N + 1], fac[MAX_N + 1], finv[MAX_N + 1];\n\nvoid init() {\n    inv[1] = fac[0] = fac[1] = finv[0] = finv[1] = 1;\n    for (int i = 2; i <= MAX_N; ++i) {\n        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n        fac[i] = fac[i - 1] * i % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\nlong long nPk(int n, int k) {\n    if (n < k || n < 0 || k < 0) return 0;\n    return fac[n] * finv[n - k] % MOD;\n}\n\nlong long nCk(int n, int k) {\n    if (n < k || n < 0 || k < 0) return 0;\n    return nPk(n, k) * finv[k] % MOD;\n}\n\nlong long nHk(int n, int k) {\n    if (n < 0 || k < 0) return 0;\n    return nCk(n + k - 1, k);\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    init();\n    int A, B, C, Sx, Sy;\n    while (cin >> A >> B >> C >> Sx >> Sy, A + B + C) {\n        int sum = 0, lim = (A == 0 ? 0 : Sx + 1);\n        FOR (i, A, lim + 1) {\n            int sub = 1, j = Sy - Sx + i;\n            if (B > 0 && j < B) continue;\n            if (B == 0 && j != 0) continue;\n            if (A) (sub *= nHk(A, i - A)) %= MOD;\n            if (B) (sub *= nHk(B, j - B)) %= MOD;\n            (sub *= nHk(A + B + C, Sx - i)) %= MOD;\n            (sum += sub) %= MOD;\n        }\n        cout << sum * nCk(A + B + C, A) % MOD * nCk(B + C, B) % MOD << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n//ａをbで割る\nlong long mod_div(ll a,ll b){\n\tif(a % b == 0)return a/b;\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n \n#define MAX_K 3333333\nvector<long long> kaijo(MAX_K);\nlong long combination(long long n, long long r){\n    if(n < r || n < 0 || r < 0)\n        return 0;\n\tif(kaijo[0] != 1){\n\t\tkaijo[0] = 1;\n\t\tfor(long long i = 1;i < MAX_K;i++)kaijo[i] = (kaijo[i-1] * i) % MOD;\n\t}\n    long long ret = kaijo[n];\n\tlong long tmp = (kaijo[r] * kaijo[n-r]) % MOD;\n    return mod_div(ret,tmp);\n}\n\nint main(){\n\tll a,b,c,x,y;\n\t\n\twhile(cin >> a >> b >> c >> x >> y,a+b+c+x+y){\n\t\t\n\t\tll ans = 0;\n\t\tfor(ll i = 0;i <= min(x,y);i++){\n\t\t\tll X = x-i-a;\n\t\t\tll Y = y-i-b;\n\t\t\tif(X < 0 || y < 0)continue;\n\t\t\tll tmp = 1;\n\t\t\ttmp = (tmp * combination(a+b+c,c)) % MOD;\n\t\t\ttmp = (tmp * combination(a+b,b)) % MOD;\n\t\t\tif(a+b+c+i-1 >= 0)tmp = (tmp * combination(a+b+c+i-1,i)) % MOD;\n\t\t\tif(a+X-1 >= 0)tmp = (tmp * combination(a+X-1,X)) % MOD;\n\t\t\tif(b+Y-1 >= 0)tmp = (tmp * combination(b+Y-1,Y)) % MOD;\n\t\t\tans = (ans+tmp) % MOD;\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconstexpr ll MOD = 1000000007;\ntemplate <ll mod = MOD>\nclass ModCombination\n{\npublic:\n    ModCombination(const int n) : fact(n + 1, 1), inv(n + 1, 1), inv_fact(n + 1, 1)\n    {\n        for (ll i = 2; i <= n; i++) { fact[i] = (fact[i - 1] * i) % mod, inv[i] = ((mod - (mod / i)) * inv[mod % i]) % mod, inv_fact[i] = (inv_fact[i - 1] * inv[i]) % mod; }\n    }\n    ll combination(const int n, const int k) const { return n == -1 and k == -1 ? 1LL : 0 <= k and k <= n ? (((fact[n] * inv_fact[k]) % mod) * inv_fact[n - k]) % mod : 0LL; }\n\nprivate:\n    vector<ll> fact, inv, inv_fact;\n};\nint main()\n{\n    const ModCombination<> mod(6000000);\n    while (true) {\n        int A, B, C, SX, SY;\n        cin >> A >> B >> C >> SX >> SY;\n        if (A == 0 and B == 0 and C == 0 and SX == 0 and SY == 0) { break; }\n        const int ADV = SX - SY;\n        if ((SX + SY + ADV) % 2 == 1) {\n            cout << 0 << endl;\n            continue;\n        }\n        ll ans = 0;\n        for (int a = max({A, B + ADV}); a <= SX; a++) {\n            const int b = a - ADV;\n            const int r = (SX + SY - a - b) / 2, c = A + B + C;\n            (ans += (mod.combination(a - 1, A - 1) * mod.combination(b - 1, B - 1) % MOD) * mod.combination(r + c - 1, c - 1) % MOD) %= MOD;\n        }\n        cout << (ans * mod.combination(A + B + C, A) % MOD) * mod.combination(B + C, B) % MOD << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3,Ofast\")\n#pragma GCC target(\"tune=native\")\nusing namespace std;\n\nvector<int> sl, sr;\nint solve(vector<int>& s, vector<int>& d) {\n  int ans = 1e9;\n  int n = s.size();\n  int m = d.size();\n  if (n <= 1) {\n    int hoge = 0;\n    for (int i = 0; i < m; i++) {\n      hoge += min(d[i], max(d[i] - s[0], s[0] - d[i]));\n    }\n    return hoge;\n  }\n\n  int comb = (1 << (n / 2)) - 1;\n  while (comb < 1 << n) {\n    sl.clear();\n    sr.clear();\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n      if (comb & (1 << i)) {\n        sl.push_back(s[i]);\n        sum += s[i];\n      } else {\n        sr.push_back(s[i]);\n      }\n    }\n    vector<int> dl, dr;\n    for (int i = 0; i < m; i++) {\n      if (d[i] < sum) {\n        dl.push_back(d[i]);\n      } else {\n        dr.push_back(d[i] - sum);\n      }\n    }\n    ans = min(ans, solve(sl, dl) + solve(sr, dr));\n    //\n    int x = comb & -comb, y = comb + x;\n    comb = ((comb & ~y) / x >> 1) | y;\n  }\n  return ans;\n}\n\nint main() {\n  int n, m;\n  while (1) {\n    cin >> n >> m;\n    if (n == 0) { return 0; }\n    vector<int> s, d;\n    for (int i = 0; i < n; i++) {\n      int x; cin >> x; s.push_back(x);\n    }\n    for (int i = 0; i < m; i++) {\n      int x; cin >> x; d.push_back(x);\n    }\n    // sort(d.begin(), d.end());\n    cout << solve(s, d) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n//nCr mod m\n#define MOD 1000000007\n#define M 4000010\nvector<ll> fact;\nbool h=false;\nll A,B;\nvoid init(){\n\th=true;\n\tfact=vector<ll>(M);\n\tfact[0]=fact[1]=1;\n\tloop(i,2,M)fact[i]=fact[i-1]*i%MOD;\n}\n// a^b mod MOD\nll powmod(ll a,ll b,ll m=MOD){\n\tll out=1;\n\tll p=a%m;\n\twhile(b){\n\t\tif(b&1)out=out*p%m;\n\t\tp=p*p%m;\n\t\tb>>=1;\n\t}\n\treturn out;\n}\n//nCr\nll nCr(ll n,ll r,ll m=MOD){\n\tif(!h)init();\n\tif(n<0||r<0||n<r)return 0;//??????\n\tll out=fact[n]*powmod(fact[r]*fact[n-r]%m,m-2,m)%m;\n\treturn out;\n}\nvoid f(ll n,ll r,ll m=MOD){\n\tif(n<0||r<0||n<r){\n\t\tA=0;\n\t\treturn;\n\t}\n\t(A*=fact[n])%=MOD;\n\t(B*=fact[r]*fact[n-r]%MOD)%=MOD;\n\treturn;\n}\nint main(){\n\tll a,b,c,d,e;\n\twhile(cin>>a>>b>>c>>d>>e,a+b+c+d+e){\n\t\tll out=0;\n\t\tll aa=nCr(a+b+c,a),bb=nCr(b+c,b);\n\t\trep(s,d+1){\n\t\t\tA=B=1;\n\t\t\tll t=e-d+s;\n\t\t\tif(t<0||t>e)continue;\n\t\t\tll w=1;\n\t\t\tif(s||a){\n\t\t\t\tf(s-1,a-1);\n\t\t\t\t(A*=aa)%=MOD;\n\t\t\t}\n\t\t\tif(t||b){\n\t\t\t\tf(t-1,b-1);\n\t\t\t\t(A*=bb)%=MOD;\n\t\t\t}\n\t\t\tf(d-s+a+b+c-1,a+b+c-1);\n\t\t\t(out+=A*powmod(B,MOD-2,MOD))%=MOD;\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n//ａをbで割る\nlong long mod_div(ll a,ll b){\n\tif(a % b == 0)return a/b;\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n \n#define MAX_K 6666666\nvector<long long> kaijo(MAX_K);\nlong long combination(long long n, long long r){\n    if(n < r || n < 0 || r < 0)\n        return 0;\n\tif(kaijo[0] != 1){\n\t\tkaijo[0] = 1;\n\t\tfor(long long i = 1;i < MAX_K;i++)kaijo[i] = (kaijo[i-1] * i) % MOD;\n\t}\n    long long ret = kaijo[n];\n\tlong long tmp = (kaijo[r] * kaijo[n-r]) % MOD;\n    return mod_div(ret,tmp);\n}\n\nint main(){\n\tint a,b,c,x,y;\n\t\n\twhile(cin >> a >> b >> c >> x >> y,a+b+c+x+y){\n\t\t\n\t\tll ans = 0;\n\t\tfor(int i = 0;i <= min(x+y);i++){\n\t\t\tint X = x-i-a;\n\t\t\tint Y = y-i-b;\n\t\t\tif(X < 0 && y < 0)continue;\n\t\t\tll tmp = 1;\n\t\t\ttmp = (tmp * combination(a+b+c,c)) % MOD;\n\t\t\ttmp = (tmp * combination(a+b,b)) % MOD;\n\t\t\ttmp = (tmp * combination(a+b+c+i-1,i)) % MOD;\n\t\t\ttmp = (tmp * combination(a+X-1,X)) % MOD;\n\t\t\ttmp = (tmp * combination(b+Y-1,Y)) % MOD;\n\t\t\tans = (ans+tmp) % MOD;\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n//nCr mod m\n#define MOD 1000000007\n#define M 4000010\nvector<ll> fact,inv;\nbool h=false;\nll A,B;\n// a^b mod MOD\nll powmod(ll a,ll b,ll m=MOD){\n\tll out=1;\n\tll p=a%m;\n\twhile(b){\n\t\tif(b&1)out=out*p%m;\n\t\tp=p*p%m;\n\t\tb>>=1;\n\t}\n\treturn out;\n}\nvoid init(){\n\th=true;\n\tfact=vector<ll>(M);\n\tfact[0]=fact[1]=1;\n\tloop(i,2,M)fact[i]=fact[i-1]*i%MOD;\n\tinv=vector<ll>(M);\n\trep(i,M)inv[i]=powmod(fact[i],MOD-2,MOD);\n}\n//nCr\nll nCr(ll n,ll r,ll m=MOD){\n\tif(!h)init();\n\tif(n<0||r<0||n<r)return 0;//??????\n\tll out=fact[n]*inv[r]%m*inv[n-r]%m;\n\treturn out;\n}\nvoid f(ll n,ll r,ll m=MOD){\n\tif(n<0||r<0||n<r){\n\t\tA=0;\n\t\treturn;\n\t}\n\t(A*=fact[n])%=MOD;\n\t(B*=fact[r]*fact[n-r]%MOD)%=MOD;\n\treturn;\n}\nint main(){\n\tll a,b,c,d,e;\n\twhile(cin>>a>>b>>c>>d>>e,a+b+c+d+e){\n\t\tll out=0;\n\t\tll aa=nCr(a+b+c,a),bb=nCr(b+c,b);\n\t\trep(s,d+1){\n\t\t\tA=B=1;\n\t\t\tll t=e-d+s;\n\t\t\tif(t<0||t>e)continue;\n\t\t\tll w=1;\n\t\t\tif(s||a){\n\t\t\t\tf(s-1,a-1);\n\t\t\t\t(A*=aa)%=MOD;\n\t\t\t}\n\t\t\tif(t||b){\n\t\t\t\tf(t-1,b-1);\n\t\t\t\t(A*=bb)%=MOD;\n\t\t\t}\n\t\t\tf(d-s+a+b+c-1,a+b+c-1);\n\t\t\t(out+=A*powmod(B,MOD-2,MOD))%=MOD;\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\nll add(ll a,ll b){return (a+b)%mod;}\nll mul(ll a,ll b){return (a*b)%mod;}\n\nll mpow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mpow( mul(a,a) , b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\nll divi(ll a,ll b){\n  return mul(a, mpow(b,mod-2) );\n}\n\nll fact[3000000];\n\nll nCr(ll n,ll r){\n  return divi(fact[n], mul(fact[r],fact[n-r]) );\n}\n\nll nHr(ll n,ll r){\n  if(r==0)return 1;\n  return nCr(n+r-1,r-1);\n}\n\nll nBr(ll n,ll r){\n  if(n<r)return 0;\n  return nHr(n-r,r);\n}\n\nll A,B,C,D,E;\n\n\nint main(){\n  fact[0]=1;\n  for(ll i=1;i<3000000;i++)\n    fact[i]=mul(fact[i-1],i);\n  \n  while(1){\n    cin>>A>>B>>C>>D>>E;\n    if(A==0&&B==0&&C==0&&D==0&&E==0)break;\n    \n    ll ans=0;\n    for(ll i=0;i<=D;i++){\n      ll j=-(D-E-i);\n      if(i<A)continue;\n      if(A==0&&i>0)continue;\n      if(i>D)continue;\n      if(j<B)continue;\n      if(B==0&&j>0)continue;\n      if(j>E)continue;\n      \n      //      cout<<i<<' '<<j<<endl;\n        \n      ll L=nBr(i,A);\n      ll R=nBr(j,B);\n      ll tmp=mul(L,R);\n      //      cout<<L<<' '<<R<<' '<<tmp<<endl;\n      tmp=mul(tmp, nCr(A+B,A) );\n      tmp=mul(tmp, nCr(A+B+C,C) );\n      assert( D-i == E-j );\n      tmp=mul(tmp, nHr(D-i,A+B+C) );\n      ans=add(ans,tmp);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 1000100\n\nll fac[SIZE];\n\nvoid factorial_init(int n){\n  fac[0] = 1;\n  for(int i=1;i<=n;i++) fac[i] = (i * fac[i-1])%mod;\n}\n\nll factorial(int n,int M){\n  ll ret=1;\n  if(n<=1) return 1;\n  return fac[n];\n  \n  for(int i=1;i<=n;i++){\n    ret = (ret*i)%M;\n  }\n  \n  return ret;\n}\n\nll power(int k,int n,int M){\n  if(n==0) return 1;\n  if(n==1) return (ll)k;\n  \n  ll ret = power(k,n/2,M);\n  \n  ret=(ret*ret)%M;\n  \n  if(n%2==1)\n    ret=(ret*k)%M;\n  \n  return ret;\n}\n\n\n//nCm nPm nHm (mod M)\n\n/*Combination*/\nint C(int n,int m,int M){\n  if(n<m) return 0;\n  if(m==0 || n==m) return 1;\n  \n  ll chi = factorial(n,M);\n  ll mot = (factorial(m,M) * factorial(n-m,M))%M;\n  \n  mot = power((int)mot,M-2,M);\n  \n  ll ret = (chi*mot)%M;\n  \n  return (int)ret;\n}\n/*Permutation*/\nint P(int n,int m,int M){\n  if(n<m) return 0;\n  if(m==0) return 1;\n  \n  ll chi = factorial(n,M);\n  ll mot = factorial(n-m,M);\n  \n  \n  mot = power((int)mot, M-2,M);\n  \n  ll ret = (chi*mot)%M;\n  \n  return (int)ret;\n}\n/*Combination with Repetitions*/\nint H(int n,int m,int M){\n  if(n==0 && m==0) return 1;\n  return C(n+m-1,m,M);\n}\n\n\n\nbool solve(){\n  int a,b,c,sx,sy;\n\n  scanf(\"%d%d%d%d%d\",&a,&b,&c,&sx,&sy);\n\n  if(a +b + c == 0) return false;\n  \n  if(sx < sy){\n    swap(sx,sy);\n    swap(a,b);\n  }\n\n  ll ans_sum = 0;\n  \n  for(int i=sx-sy;i<=sx;i++){\n    int p = i;\n    int q = i - (sx-sy);\n\n    if(p < a || q < b || (a==0 && p>0) || (b==0 && q > 0)) continue;\n    \n    ll ans = 1;\n\n    ans = (ans * C(p-1,a-1,mod))%mod;\n    ans = (ans * C(q-1,b-1,mod))%mod;\n    ans = (ans * C(sx-i+(c+b+a-1),c+b+a-1,mod))%mod;\n    \n    ans = (ans * factorial(a+b+c,mod))%mod;\n    \n    ans = (ans * power(factorial(a,mod),mod-2,mod))%mod;\n    ans = (ans * power(factorial(b,mod),mod-2,mod))%mod;\n    ans = (ans * power(factorial(c,mod),mod-2,mod))%mod;\n    \n    ans_sum = (ans_sum + ans)%mod;\n  }\n\n  printf(\"%lld\\n\",ans_sum);\n\n  return true;\n}\n\nint main(){\n\n  factorial_init(1000000);\n  \n  while(solve());\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\nusing ll = long long;\nconst ll mod = 1000000007LL;\n\nconst int limit = 5000000;\nll F[limit+10],IF[limit+10];\n\nll inv(ll a){\n\tll b = 1LL;\n\tll n = mod -2;\n\twhile(n){\n\t\tif(n&1) b = b * a % mod;\n\t\ta = a * a % mod;\n\t\tn >>= 1;\n\t}\n\treturn b;\n}\n\ninline ll C(int n,int k){\n\tif(n < 0 or k < 0 or n-k < 0) return 0;\n\treturn F[n] * IF[k] % mod * IF[n-k] %mod;\n}\n\ninline ll H(int n,int k){\n\tn += k - 1;\n\treturn C(n,k);\n}\n\nint main(void){\n\tF[0] = 1LL;\n\tfor(ll i=1LL;i<=limit;++i) F[i] = i * F[i-1] %mod;\n\tIF[limit] = inv(F[limit]);\n\tfor(ll i=limit;i>=1;--i) IF[i-1] = i * IF[i] %mod;\n\t\t\n\tll a,b,c,sx,sy;\n\twhile(cin >> a >> b >> c >> sx >> sy,a+b+c){\n\t\t\n\t\tll ans = 0LL;\n\n\t\tfor(ll wa = 0LL; wa <= sx; ++ wa){\n\t\t\tconst ll draw = sx -wa;\n\t\t\tconst ll wb = sy - draw; \n\t\t\tif(draw < 0 or wb < 0) continue;\n\t\t\t//cerr << wa << \" \" << wb << \" \" << draw << endl;\n\t\t\tll cur = 1LL;\n\t\t\tcur = cur * H(a,wa-a) % mod;\n\t\t\tcur = cur * H(b,wb-b) % mod;\n\t\t\tcur = cur * H(a+b+c,draw) % mod;\n\t\t\tans = (ans + cur) % mod;\n\t\t}\n\n\t\tans = ans * C(a+b+c,a) % mod * C(b+c,b) % mod;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n//ａをbで割る\nlong long mod_div(ll a,ll b){\n\tif(a % b == 0)return a/b;\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n \n#define MAX_K 3333333\nvector<long long> kaijo(MAX_K);\nlong long combination(long long n, long long r){\n    if(n < r || n < 0 || r < 0)\n        return 0;\n\tif(kaijo[0] != 1){\n\t\tkaijo[0] = 1;\n\t\tfor(long long i = 1;i < MAX_K;i++)kaijo[i] = (kaijo[i-1] * i) % MOD;\n\t}\n    long long ret = kaijo[n];\n\tlong long tmp = (kaijo[r] * kaijo[n-r]) % MOD;\n    return mod_div(ret,tmp);\n}\n\nint main(){\n\tll a,b,c,x,y;\n\t\n\twhile(cin >> a >> b >> c >> x >> y,a+b+c+x+y){\n\t\t\n\t\tll ans = 0;\n\t\tfor(ll i = 0;i <= min(x,y);i++){\n\t\t\tll X = x-i-a;\n\t\t\tll Y = y-i-b;\n\t\t\tif(X < 0 || y < 0)continue;\n\t\t\tll tmp = 1;\n\t\t\ttmp = (tmp * combination(a+b+c,c)) % MOD;\n\t\t\ttmp = (tmp * combination(a+b,b)) % MOD;\n\t\t\ttmp = (tmp * combination(a+b+c+i-1,i)) % MOD;\n\t\t\tif(a+X-1 >= 0)tmp = (tmp * combination(a+X-1,X)) % MOD;\n\t\t\tif(b+Y-1 >= 0)tmp = (tmp * combination(b+Y-1,Y)) % MOD;\n\t\t\tans = (ans+tmp) % MOD;\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\nll add(ll a,ll b){return (a+b)%mod;}\nll mul(ll a,ll b){return (a*b)%mod;}\n\nll mpow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mpow( mul(a,a) , b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\nll divi(ll a,ll b){\n  return mul(a, mpow(b,mod-2) );\n}\n\nll fact[3000000];\ntypedef pair<ll,ll> P;\n\nunordered_map< ll , ll  > mem;\n\nll base=10000000000LL;\n\nll nCr(ll n,ll r){\n  \n  if(mem.count(n*base+r))\n    return mem[n*base+r];\n  \n  return mem[n*base+r]=divi(fact[n], mul(fact[r],fact[n-r]) );\n}\n\nll nHr(ll n,ll r){\n  if(r==0)return 1;\n  return nCr(n+r-1,r-1);\n}\n\nll nBr(ll n,ll r){\n  if(n<r)return 0;\n  return nHr(n-r,r);\n}\n\nll A,B,C,D,E;\n\n\nint main(){\n  fact[0]=1;\n  for(ll i=1;i<3000000;i++)\n    fact[i]=mul(fact[i-1],i);\n  \n  while(1){\n    cin>>A>>B>>C>>D>>E;\n    if(A==0&&B==0&&C==0&&D==0&&E==0)break;\n    \n    ll ans=0;\n    if(D-A<E-B){\n      for(ll i=A;i<=D;i++){\n        ll j=-(D-E-i);\n        if(i<A)continue;\n        if(A==0&&i>0)continue;\n        if(i>D)continue;\n        if(j<B)continue;\n        if(B==0&&j>0)break;\n        if(j>E)break;\n        ll L=nBr(i,A);\n        ll R=nBr(j,B);\n        ll tmp=mul(L,R);\n        tmp=mul(tmp, nCr(A+B,A) );\n        tmp=mul(tmp, nCr(A+B+C,C) );\n        assert( D-i == E-j );\n        tmp=mul(tmp, nHr(D-i,A+B+C) );\n        ans=add(ans,tmp);\n      }\n    }else{\n      for(ll j=B;j<=E;j++){\n        ll i=(D-E+j);\n        if(i<A)continue;\n        if(A==0&&i>0)continue;\n        if(i>D)continue;\n        if(j<B)continue;\n        if(B==0&&j>0)continue;\n        if(j>E)continue;\n        ll L=nBr(i,A);\n        ll R=nBr(j,B);\n        ll tmp=mul(L,R);\n        tmp=mul(tmp, nCr(A+B,A) );\n        tmp=mul(tmp, nCr(A+B+C,C) );\n        assert( D-i == E-j );\n        tmp=mul(tmp, nHr(D-i,A+B+C) );\n        ans=add(ans,tmp);\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\nusing ll = long long;\nconst ll mod = 1000000007LL;\n\nconst int limit = 5000000;\nll F[limit+10],IF[limit+10];\n\nll inv(ll a){\n\tll b = 1LL;\n\tll n = mod -2;\n\twhile(n){\n\t\tif(n&1) b = b * a % mod;\n\t\ta = a * a % mod;\n\t\tn >>= 1;\n\t}\n\treturn b;\n}\n\ninline ll C(int n,int k){\n\tif(n < 0 or k < 0 or n-k < 0) return 0;\n\treturn F[n] * IF[k] % mod * IF[n-k] %mod;\n}\n\ninline ll H(int n,int k){\n\tn += k - 1;\n\treturn C(n,k);\n}\n\nint main(void){\n\tF[0] = 1LL;\n\tfor(ll i=1LL;i<=limit;++i) F[i] = i * F[i-1] %mod;\n\tIF[limit] = inv(F[limit]);\n\tfor(ll i=limit;i>=1;--i) IF[i-1] = i * IF[i] %mod;\n\t\t\n\tll a,b,c,sx,sy;\n\twhile(cin >> a >> b >> c >> sx >> sy){\n\t\tif(a+b+c+sx+sy==0) break;\n\t\tll ans = 0LL;\n\n\t\tfor(ll wa = 0LL; wa <= sx; ++ wa){\n\t\t\tconst ll draw = sx -wa;\n\t\t\tconst ll wb = sy - draw; \n\t\t\tif(draw < 0 or wb < 0) continue;\n\t\t\t//cerr << wa << \" \" << wb << \" \" << draw << endl;\n\t\t\tll cur = 1LL;\n\t\t\tcur = cur * H(a,wa-a) % mod;\n\t\t\tcur = cur * H(b,wb-b) % mod;\n\t\t\tcur = cur * H(a+b+c,draw) % mod;\n\t\t\tans = (ans + cur) % mod;\n\t\t}\n\n\t\tans = ans * C(a+b+c,a) % mod * C(b+c,b) % mod;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nll mod = 1000000007;\n\nll kai[3000010];\nll inv_kai[3000010];\n\nll beki(ll x, ll a)\n{\n\tif(x==0) return 0;\n\tif(a==0) return 1;\n\tif(a==1) return x;\n\tll tmp=beki(x, a/2);\n\ttmp=tmp*tmp%mod;\n\tif(a%2==0) return tmp;\n\telse return tmp*x%mod;\n}\n\nll inv(ll x)\n{\n\treturn beki(x, mod-2);\n}\n\nll cb(ll s, ll t)\n{\n\tif(s==t) return 1;\n\tif(t==-1) return 0;\n\tll tmp=kai[(int)s];\n\ttmp=(tmp*inv_kai[(int)t])%mod;\n\treturn tmp*inv_kai[(int)s-(int)t]%mod;\n}\n\nint main() {\n\tkai[0]=1;\n\tinv_kai[0]=1;\n\tfor(int i=1; i<=3000005; i++)\n\t{\n\t\tkai[i]=kai[i-1]*(ll)i%mod;\n\t\tinv_kai[i]=inv(kai[i]);\n\t}\n\t//cout << \"aaaaaaa\" << cb(0, 0) << endl;\n\twhile (true) {\n\t\tll a, b, c, sx, sy;\n\t\tcin >> a >> b >> c >> sx >> sy;\n\t\tif(a+b+c==0) break;\n\n\t\tll ans=0;\n\t\tfor(ll x=a; x<=sx; x++)\n\t\t{\n\t\t\tll y=sy-(sx-x);\n\t\t\tif(y>=b)\n\t\t\t{\n\t\t\t\tll tmp=1;\n\t\t\t\ttmp=(tmp*cb(x-1, a-1))%mod;\n\t\t\t\ttmp=(tmp*cb(y-1, b-1))%mod;\n\t\t\t\ttmp=(tmp*cb(sx-x+a+b+c-1, a+b+c-1))%mod;\n\t\t\t\tans=(ans+tmp)%mod;\n\t\t\t}\n\t\t}\n\t\tans=(ans*cb(a+b+c, a))%mod;\n\t\tcout << ans*cb(b+c, b)%mod << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\nll add(ll a,ll b){return (a+b)%mod;}\nll mul(ll a,ll b){return (a*b)%mod;}\n\nll mpow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mpow( mul(a,a) , b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\nll divi(ll a,ll b){\n  return mul(a, mpow(b,mod-2) );\n}\n\nll fact[3000000];\n\nll nCr(ll n,ll r){\n  return divi(fact[n], mul(fact[r],fact[n-r]) );\n}\n\nll nHr(ll n,ll r){\n  if(r==0)return 1;\n  return nCr(n+r-1,r-1);\n}\n\nll nBr(ll n,ll r){\n  if(n<r)return 0;\n  return nHr(n-r,r);\n}\n\nll A,B,C,D,E;\n\n\nint main(){\n  fact[0]=1;\n  for(ll i=1;i<3000000;i++)\n    fact[i]=mul(fact[i-1],i);\n  \n  while(1){\n    cin>>A>>B>>C>>D>>E;\n    if(A==0&&B==0&&C==0&&D==0&&E==0)break;\n    \n    ll ans=0;\n    for(ll i=A;i<=D;i++){\n      \n      ll j=-(D-E-i);\n      if(i<A)continue;\n      if(A==0&&i>0)continue;\n      if(i>D)continue;\n      if(j<B)continue;\n      if(B==0&&j>0)continue;\n      if(j>E)continue;\n      \n      //      cout<<i<<' '<<j<<endl;\n        \n      ll L=nBr(i,A);\n      ll R=nBr(j,B);\n      ll tmp=mul(L,R);\n      //      cout<<L<<' '<<R<<' '<<tmp<<endl;\n      tmp=mul(tmp, nCr(A+B,A) );\n      tmp=mul(tmp, nCr(A+B+C,C) );\n      assert( D-i == E-j );\n      tmp=mul(tmp, nHr(D-i,A+B+C) );\n      ans=add(ans,tmp);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\nlong M=1e9+7;\nlong fac[3<<20],inv[3<<20],invfac[3<<20];\nlong pow(long a,long b){return b?pow(a*a%M,b/2)*(b%2?a:1)%M:1;}\nlong C(long a,long b)\n{\n\treturn fac[a]*invfac[a-b]%M*invfac[b]%M;\n}\nlong H(long a,long b)\n{\n\treturn a==0&&b==0?1:C(a+b-1,b);\n}\nlong a,b,c,sx,sy;\nmain()\n{\n\tfac[0]=fac[1]=inv[1]=invfac[0]=invfac[1]=1;\n\tfor(long i=2;i<3<<20;i++)\n\t{\n\t\tfac[i]=fac[i-1]*i%M;\n\t\tinv[i]=(M-M/i*inv[M%i]%M);\n\t\tinvfac[i]=invfac[i-1]*inv[i]%M;\n\t}\n\twhile(cin>>a>>b>>c>>sx>>sy,a+b+c)\n\t{\n\t\tlong ans=0;\n\t\tfor(long i=0;i<=sx-a&&i<=sy-b;i++)\n\t\t{\n\t\t\tif(sx-i>0&&a==0||sy-i>0&&b==0)continue;\n\t\t\tans=(ans+H(a,sx-i-a)*C(a+b+c,a)%M*H(b,sy-i-b)%M*C(b+c,b)%M*H(a+b+c,i)%M)%M;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\nll add(ll a,ll b){return (a+b)%mod;}\nll mul(ll a,ll b){return (a*b)%mod;}\n\nll mpow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mpow( mul(a,a) , b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\nll divi(ll a,ll b){\n  return mul(a, mpow(b,mod-2) );\n}\n\nll fact[3000000];\nll Fact[3000000];\ntypedef pair<ll,ll> P;\n\nunordered_map< ll , ll  > mem;\n\nll base=10000000000LL;\n\nll nCr(ll n,ll r){\n  \n  if(mem.count(n*base+r))\n    return mem[n*base+r];\n  \n  return mem[n*base+r]=mul(fact[n], mul(Fact[r],Fact[n-r]) );\n}\n\nll nHr(ll n,ll r){\n  if(r==0)return 1;\n  return nCr(n+r-1,r-1);\n}\n\nll nBr(ll n,ll r){\n  if(n<r)return 0;\n  return nHr(n-r,r);\n}\n\nll A,B,C,D,E;\n\n\nint main(){\n  fact[0]=1;\n  for(ll i=1;i<3000000;i++){\n    fact[i]=mul(fact[i-1],i);\n  }\n  for(ll i=0;i<3000000;i++)Fact[i]=divi(1,fact[i]);\n  \n  while(1){\n    mem.clear();\n    \n    cin>>A>>B>>C>>D>>E;\n    if(A==0&&B==0&&C==0&&D==0&&E==0)break;\n    \n    ll ans=0;\n    for(ll i=max(A,B+D-E);i<=D;i++){\n      ll j=-(D-E-i);\n      //      if(i<A)continue;\n      if(A==0&&i>0)continue;\n      //      if(i>D)continue;\n      //      if(j<B)continue;\n      if(B==0&&j>0)break;\n      if(j>E)break;\n      ll L=nBr(i,A);\n      ll R=nBr(j,B);\n      ll tmp=mul(L,R);\n      tmp=mul(tmp, nCr(A+B,A) );\n      tmp=mul(tmp, nCr(A+B+C,C) );\n      assert( D-i == E-j );\n      tmp=mul(tmp, nHr(D-i,A+B+C) );\n      ans=add(ans,tmp);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\nll add(ll a,ll b){return (a+b)%mod;}\nll mul(ll a,ll b){return (a*b)%mod;}\n\nll mpow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mpow( mul(a,a) , b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\nll divi(ll a,ll b){\n  return mul(a, mpow(b,mod-2) );\n}\n\nll fact[3000000];\ntypedef pair<ll,ll> P;\n\nunordered_map< ll , ll  > mem;\n\nll base=10000000000LL;\n\nll nCr(ll n,ll r){\n  \n  if(mem.count(n*base+r))\n    return mem[n*base+r];\n  \n  return mem[n*base+r]=divi(fact[n], mul(fact[r],fact[n-r]) );\n}\n\nll nHr(ll n,ll r){\n  if(r==0)return 1;\n  return nCr(n+r-1,r-1);\n}\n\nll nBr(ll n,ll r){\n  if(n<r)return 0;\n  return nHr(n-r,r);\n}\n\nll A,B,C,D,E;\n\n\nint main(){\n  fact[0]=1;\n  for(ll i=1;i<3000000;i++)\n    fact[i]=mul(fact[i-1],i);\n  \n  while(1){\n    mem.clear();\n    \n    cin>>A>>B>>C>>D>>E;\n    if(A==0&&B==0&&C==0&&D==0&&E==0)break;\n    \n    ll ans=0;\n    for(ll i=max(A,B+D-E);i<=D;i++){\n      ll j=-(D-E-i);\n      //      if(i<A)continue;\n      if(A==0&&i>0)continue;\n      //      if(i>D)continue;\n      //      if(j<B)continue;\n      if(B==0&&j>0)break;\n      if(j>E)break;\n      ll L=nBr(i,A);\n      ll R=nBr(j,B);\n      ll tmp=mul(L,R);\n      tmp=mul(tmp, nCr(A+B,A) );\n      tmp=mul(tmp, nCr(A+B+C,C) );\n      assert( D-i == E-j );\n      tmp=mul(tmp, nHr(D-i,A+B+C) );\n      ans=add(ans,tmp);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nll P = 1000000007;\nclass C {\npublic:\n  int n;\n  vector<ll> fac, inv, facInv;\n  ll power(ll e, ll x) {\n    if (x == 0)\n      return 1;\n    if (x == 1)\n      return e;\n    if (x % 2 == 0)\n      return power((e * e) % P, x / 2);\n    return (e * power(e, x - 1)) % P;\n  }\n  C(int n_) {\n    n = n_;\n    fac.resize(n);\n    inv.resize(n);\n    facInv.resize(n);\n    fac[0] = fac[1] = 1;\n    for (int i = 2; i <= n; i++)\n      fac[i] = (i * fac[i - 1]) % P;\n    inv[0] = inv[1] = 1;\n    for (int i = 2; i <= n; i++)\n      inv[i] = power(i, P - 2);\n    facInv[0] = facInv[1] = 1;\n    for (int i = 2; i <= n; i++)\n      facInv[i] = (inv[i] * facInv[i - 1]) % P;\n  }\n  ll comb(ll N, ll K) {\n    if (N < K || K < 0 || N < 0)\n      return 0;\n    if (N == 0 || K == 0 || K == N)\n      return 1;\n    return ((fac[N] * facInv[K]) % P * facInv[N - K]) % P;\n  }\n  ll hcomb(ll N, ll K) {\n    if (N == 0 && K == 0)\n      return 1;\n    return comb(N + K - 1, K);\n  }\n};\n\nC comb(6010101);\n\nint main() {\n  while (true) {\n    ll a, b, c, x, y;\n    cin >> a >> b >> c >> x >> y;\n    if (a == 0 && b == 0 && c == 0)\n      break;\n    ll ans = 0;\n    for (int i = 0; i <= min(x - a, y - b); i++) {\n      ll sa = x - i;\n      ll sb = y - i;\n      ll com = (comb.comb(a + b + c, a) * comb.comb(b + c, b)) % P;\n      com *= comb.hcomb(a + b + c, i);\n      com %= P;\n      com *= comb.hcomb(a, sa - a);\n      com %= P;\n      com *= comb.hcomb(b, sb - b);\n      com %= P;\n      ans += com;\n      ans %= P;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n//ａをbで割る\nlong long mod_div(ll a,ll b){\n\tif(a % b == 0)return a/b;\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n \n#define MAX_K 6666666\nvector<long long> kaijo(MAX_K);\nlong long combination(long long n, long long r){\n    if(n < r || n < 0 || r < 0)\n        return 0;\n\tif(kaijo[0] != 1){\n\t\tkaijo[0] = 1;\n\t\tfor(long long i = 1;i < MAX_K;i++)kaijo[i] = (kaijo[i-1] * i) % MOD;\n\t}\n    long long ret = kaijo[n];\n\tlong long tmp = (kaijo[r] * kaijo[n-r]) % MOD;\n    return mod_div(ret,tmp);\n}\n\nint main(){\n\tll a,b,c,x,y;\n\t\n\twhile(cin >> a >> b >> c >> x >> y,a+b+c+x+y){\n\t\t\n\t\tll ans = 0;\n\t\tfor(ll i = 0;i <= min(x,y);i++){\n\t\t\tll X = x-i-a;\n\t\t\tll Y = y-i-b;\n\t\t\tif(X <= 0 || y <= 0)continue;\n\t\t\tll tmp = 1;\n\t\t\ttmp = (tmp * combination(a+b+c,c)) % MOD;\n\t\t\ttmp = (tmp * combination(a+b,b)) % MOD;\n\t\t\ttmp = (tmp * combination(a+b+c+i-1,i)) % MOD;\n\t\t\ttmp = (tmp * combination(a+X-1,X)) % MOD;\n\t\t\ttmp = (tmp * combination(b+Y-1,Y)) % MOD;\n\t\t\tans = (ans+tmp) % MOD;\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong M=1e9+7;\nlong fac[1<<20];\nlong pow(long a,long b){return b?pow(a*a%M,b/2)*(b%2?a:1)%M:1;}\nlong C(long a,long b)\n{\n\treturn fac[a]*pow(fac[a-b],M-2)%M*pow(fac[b],M-2)%M;\n}\nlong H(long a,long b)\n{\n\treturn a==0&&b==0?1:C(a+b-1,b);\n}\nlong a,b,c,sx,sy;\nmain()\n{\n\tfac[0]=fac[1]=1;\n\tfor(long i=2;i<1<<20;i++)fac[i]=fac[i-1]*i%M;\n\twhile(cin>>a>>b>>c>>sx>>sy,a+b+c)\n\t{\n\t\tlong ans=0;\n\t\tfor(long i=0;i<=sx-a&&i<=sy-b;i++)\n\t\t{\n\t\t\tif(sx-i>0&&a==0||sy-i>0&&b==0)continue;\n\t\t\tans=(ans+H(a,sx-i-a)*C(a+b+c,a)%M*H(b,sy-i-b)%M*C(b+c,b)%M*H(a+b+c,i)%M)%M;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int M = 1000000007;\n\nlong long perm[3100000], inv[3100000];\nlong long powmod(long long a, long long b) {\n    if (a >= M) return powmod(a % M, b);\n    if (b == 0) return 1;\n    if (b & 1) return powmod(a, b - 1) * a % M;\n    else return powmod(a * a % M, b / 2);\n}\nlong long comb(long long n, long long k) {\n    if (n == k) return 1;\n    if (k < 0 || n < k) return 0;\n    return perm[n] * inv[k] % M * inv[n - k] % M;\n}\n\nint main() {\n    perm[0] = 1;\n    inv[0] = 1;\n    for (int i = 1; i < 3100000; ++i) {\n        perm[i] = perm[i - 1] * i % M;\n        inv[i] = powmod(perm[i], M - 2);\n    }\n    while (1) {\n        int a, b, c, sx, sy;\n        cin >> a >> b >> c >> sx >> sy;\n        if (a + b + c == 0) return 0;\n\n        long long ans = 0;\n        for (int i = max(a, sx - sy + b); i <= sx; ++i) {\n            int j = i - sx + sy;\n            int k = sx - i;\n            ans = (ans + comb(i - 1, a - 1) * comb(j - 1, b - 1) % M * comb(a + b + c, a) % M * comb(b + c, b) % M * comb(a + b + c + k - 1, k) % M) % M;\n        }\n        cout << ans << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 22;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nint a, b, c, sx, sy;\nvoid solve() {\n\tint n = a + b + c;\n\tmodint ans = 0;\n\trep(x, min(sx, sy) + 1) {\n\t\tmodint s = comb(x + n - 1, x);\n\t\tint rl = sx - x-a;\n\t\tint rr = sy - x-b;\n\t\tmodint cl = comb(rl+a-1, rl);\n\t\tif (a == 0) {\n\t\t\tif (rl == 0)cl = 1;\n\t\t\telse cl = 0;\n\t\t}\n\t\tmodint cr = comb(rr+b - 1, rr);\n\t\tif (b == 0) {\n\t\t\tif (rr == 0)cr = 1;\n\t\t\telse cr = 0;\n\t\t}\n\t\tans += s * cl*cr;\n\t}\n\tans = ans * fact[n] * factinv[a] * factinv[b] * factinv[c];\n\tcout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(12);\n\tinit_f();\n\t//int t; cin >> t; rep(i, t)solve();\n\twhile (cin >> a >> b >> c >> sx >> sy, a | b | c | sx | sy)solve();\n\t//solve();\n\tstop\n\t\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nll extgcd(ll a,ll b,ll& x,ll& y){\n\tll d=a;\n\tif(b!=0LL){\n\t\td=extgcd(b,a%b,y,x);\n\t\ty-=(a/b)*x;\n\t}else{\n\t\tx=1;\n\t\ty=0;\n\t}\n\treturn d;\n}\n\nll mod_inverse(ll a,ll m){\n\tll x,y;\n\textgcd(a,m,x,y);\n\treturn (m+x%m)%m;\n}\n\nll fact[5000001];\n\nll mod_fact(ll n,ll p,ll& e){\n\te=0;\n\tif(n==0)return 1;\n\tll res=mod_fact(n/p,p,e);\n\te+=n/p;\n\tif(n/p%2!=0){\n\t\treturn res*(p-fact[n%p])%p;\n\t}\n\treturn res*fact[n%p]%p;\n}\n\nll mod_comb(ll n,ll k,ll p){\n\tif(n<0 || k<0 || n<k)return 0;\n\tll e1,e2,e3;\n\tll a1=mod_fact(n,p,e1),a2=mod_fact(k,p,e2),a3=mod_fact(n-k,p,e3);\n\tif(e1>e2+e3)return 0;\n\treturn a1*mod_inverse(a2*a3%p,p)%p;\n}\n\nll a,b,c,sx,sy;\n\nvoid solve(){\n\tll ans=0;\n\tfor(int i=0;i<=1000000;i++){\n\t\tll ao=sx-i-a;\n\t\tll bo=sy-i-b;\n\t\tif(ao<0 || bo<0)break;\n\t\tif(a==0 && ao>0)continue;\n\t\tif(b==0 && bo>0)continue;\n\t\tll val=a>0?mod_comb(ao+a-1LL,a-1LL,MOD):1;\n\t\tif(b>0)val=val*mod_comb(bo+b-1LL,b-1LL,MOD)%MOD;\n\t\tval=val*mod_comb(i+a+b+c-1LL,a+b+c-1LL,MOD)%MOD;\n\t\tans=(ans+val)%MOD;\n\t}\n\tans=ans*mod_comb(a+b+c,a,MOD)%MOD;\n\tans=ans*mod_comb(b+c,b,MOD)%MOD;\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(void){\n\tfact[0]=1;\n\tfor(ll i=1;i<=5000000;i++){\n\t\tfact[i]=fact[i-1]*i%MOD;\n\t}\n\twhile(1){\n\t\tscanf(\"%lld%lld%lld%lld%lld\",&a,&b,&c,&sx,&sy);\n\t\tif(a==0 && b==0 && c==0)break;\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\nll add(ll a,ll b){return (a+b)%mod;}\nll mul(ll a,ll b){return (a*b)%mod;}\n\nll mpow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mpow( mul(a,a) , b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\nll divi(ll a,ll b){\n  return mul(a, mpow(b,mod-2) );\n}\n\nll fact[3000005];\nll Fact[3000005];\ntypedef pair<ll,ll> P;\n\nunordered_map< ll , ll  > mem;\n\nll base=10000000000LL;\n\nll nCr(ll n,ll r){\n  \n  if(mem.count(n*base+r))\n    return mem[n*base+r];\n  \n  return mem[n*base+r]=mul(fact[n], mul(Fact[r],Fact[n-r]) );\n}\n\nll nHr(ll n,ll r){\n  if(r==0)return 1;\n  return nCr(n+r-1,r-1);\n}\n\nll nBr(ll n,ll r){\n  if(n<r)return 0;\n  return nHr(n-r,r);\n}\n\nll A,B,C,D,E;\n\n\nint main(){\n  fact[0]=1;\n  for(ll i=1;i<3000005;i++){\n    fact[i]=mul(fact[i-1],i);\n  }\n  for(ll i=0;i<3000005;i++)Fact[i]=divi(1,fact[i]);\n  \n  while(1){\n    mem.clear();\n    \n    cin>>A>>B>>C>>D>>E;\n    if(A==0&&B==0&&C==0&&D==0&&E==0)break;\n    \n    ll ans=0;\n    for(ll i=0;i<=1000000;i++){\n      ll j=-(D-E-i);\n      if(i<A)continue;\n      if(A==0&&i>0)continue;\n      if(i>D)continue;\n      if(j<B)continue;\n      if(B==0&&j>0)continue;\n      if(j>E)continue;\n      ll L=nBr(i,A);\n      ll R=nBr(j,B);\n      ll tmp=mul(L,R);\n      tmp=mul(tmp, nCr(A+B,A) );\n      tmp=mul(tmp, nCr(A+B+C,C) );\n      assert( D-i == E-j );\n      tmp=mul(tmp, nHr(D-i,A+B+C) );\n      ans=add(ans,tmp);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nll mod_pow(ll a,ll n){\n  ll res=1;\n  while(n>0){\n    if(n&1)res=res*a%mod;\n    a=a*a%mod;\n    n>>=1;\n  }\n  return res;\n}\n\nll f[3000010],finv[3000010];\n\nll comb(ll n,ll r){\n  if(n<0||r<0||n<r)return 0;\n  return (f[n]*finv[r]%mod)*finv[n-r]%mod;\n}\n\nll A,B,C;\nll SX,SY;\n\nint main(){\n  f[0]=1;\n  rep(i,3000001)f[i+1]=f[i]*(i+1)%mod;\n  rep(i,3000001)finv[i]=mod_pow(f[i],mod-2);\n  while(1){\n    cin>>A>>B>>C>>SX>>SY;\n    if(A+B+C==0)break;\n    ll res=0;\n    rep(i,SX+1){\n      ll j=SY-SX+i;\n      if(i<A||j<0)continue;\n      ll b1=0;\n      if(i>0) b1=comb(i-1,A-1);\n      else b1=(A==0?1:0);\n      ll b2=0;\n      if(j>0) b2=comb(j-1,B-1);\n      else b2=(B==0?1:0);\n      ll k=(((finv[A]*finv[B])%mod)*finv[C]%mod)*f[A+B+C]%mod;\n      ll p=(b1*b2%mod)*k%mod;\n      ll b3=comb(SX-i+A+B+C-1,A+B+C-1);\n      (res+=p*b3%mod)%=mod;\n    }\n    cout<<res<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n//ａをbで割る\nlong long mod_div(ll a,ll b){\n\tif(a % b == 0)return a/b;\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n \n#define MAX_K 6666666\nvector<long long> kaijo(MAX_K);\nlong long combination(long long n, long long r){\n    if(n < r || n < 0 || r < 0)\n        return 0;\n\tif(kaijo[0] != 1){\n\t\tkaijo[0] = 1;\n\t\tfor(long long i = 1;i < MAX_K;i++)kaijo[i] = (kaijo[i-1] * i) % MOD;\n\t}\n    long long ret = kaijo[n];\n\tlong long tmp = (kaijo[r] * kaijo[n-r]) % MOD;\n    return mod_div(ret,tmp);\n}\n\nint main(){\n\tint a,b,c,x,y;\n\t\n\twhile(cin >> a >> b >> c >> x >> y,a+b+c+x+y){\n\t\t\n\t\tll ans = 0;\n\t\tfor(int i = 0;i <= min(x,y);i++){\n\t\t\tint X = x-i-a;\n\t\t\tint Y = y-i-b;\n\t\t\tif(X < 0 || y < 0)continue;\n\t\t\tll tmp = 1;\n\t\t\ttmp = (tmp * combination(a+b+c,c)) % MOD;\n\t\t\ttmp = (tmp * combination(a+b,b)) % MOD;\n\t\t\ttmp = (tmp * combination(a+b+c+i-1,i)) % MOD;\n\t\t\ttmp = (tmp * combination(a+X-1,X)) % MOD;\n\t\t\ttmp = (tmp * combination(b+Y-1,Y)) % MOD;\n\t\t\tans = (ans+max(0LL,tmp)) % MOD;\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\nll add(ll a,ll b){return (a+b)%mod;}\nll mul(ll a,ll b){return (a*b)%mod;}\n\nll mpow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mpow( mul(a,a) , b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\nll divi(ll a,ll b){\n  return mul(a, mpow(b,mod-2) );\n}\n\nll fact[3000000];\ntypedef pair<ll,ll> P;\n\nunordered_map< ll , ll  > mem;\n\nll base=10000000000LL;\n\nll nCr(ll n,ll r){\n  \n  if(mem.count(n*base+r))\n    return mem[n*base+r];\n  \n  return mem[n*base+r]=divi(fact[n], mul(fact[r],fact[n-r]) );\n}\n\nll nHr(ll n,ll r){\n  if(r==0)return 1;\n  return nCr(n+r-1,r-1);\n}\n\nll nBr(ll n,ll r){\n  if(n<r)return 0;\n  return nHr(n-r,r);\n}\n\nll A,B,C,D,E;\n\n\nint main(){\n  fact[0]=1;\n  for(ll i=1;i<3000000;i++)\n    fact[i]=mul(fact[i-1],i);\n  \n  while(1){\n    cin>>A>>B>>C>>D>>E;\n    if(A==0&&B==0&&C==0&&D==0&&E==0)break;\n    \n    ll ans=0;\n    if(D-A<E-B){\n      for(ll i=A;i<=D;i++){\n        ll j=-(D-E-i);\n        if(i<A)continue;\n        if(A==0&&i>0)continue;\n        if(i>D)continue;\n        if(j<B)continue;\n        if(B==0&&j>0)break;\n        if(j>E)break;\n        ll L=nBr(i,A);\n        ll R=nBr(j,B);\n        ll tmp=mul(L,R);\n        tmp=mul(tmp, nCr(A+B,A) );\n        tmp=mul(tmp, nCr(A+B+C,C) );\n        assert( D-i == E-j );\n        tmp=mul(tmp, nHr(D-i,A+B+C) );\n        ans=add(ans,tmp);\n      }\n    }else{\n      for(ll j=B;j<=E;j++){\n        ll i=(D-E+j);\n        if(i<A)continue;\n        if(A==0&&i>0)continue;\n        if(i>D)continue;\n        if(j<B)continue;\n        if(B==0&&j>0)continue;\n        if(j>E)continue;\n        ll L=nBr(i,A);\n        ll R=nBr(j,B);\n        ll tmp=mul(L,R);\n        tmp=mul(tmp, nCr(A+B,A) );\n        tmp=mul(tmp, nCr(A+B+C,C) );\n        assert( D-i == E-j );\n        tmp=mul(tmp, nHr(D-i,A+B+C) );\n        ans=add(ans,tmp);\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\nll add(ll a,ll b){return (a+b)%mod;}\nll mul(ll a,ll b){return (a*b)%mod;}\n\nll mpow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mpow( mul(a,a) , b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\nll divi(ll a,ll b){\n  return mul(a, mpow(b,mod-2) );\n}\n\nll fact[3000000];\ntypedef pair<ll,ll> P;\n\nunordered_map< ll , ll  > mem;\n\nll base=10000000000LL;\n\nll nCr(ll n,ll r){\n  \n  if(mem.count(n*base+r))\n    return mem[n*base+r];\n  \n  return mem[n*base+r]=divi(fact[n], mul(fact[r],fact[n-r]) );\n}\n\nll nHr(ll n,ll r){\n  if(r==0)return 1;\n  return nCr(n+r-1,r-1);\n}\n\nll nBr(ll n,ll r){\n  if(n<r)return 0;\n  return nHr(n-r,r);\n}\n\nll A,B,C,D,E;\n\n\nint main(){\n  fact[0]=1;\n  for(ll i=1;i<3000000;i++)\n    fact[i]=mul(fact[i-1],i);\n  \n  while(1){\n    mem.clear();\n    \n    cin>>A>>B>>C>>D>>E;\n    if(A==0&&B==0&&C==0&&D==0&&E==0)break;\n    \n    ll ans=0;\n    for(ll i=max(A,B+D-E);i<=D;i++){\n      ll j=-(D-E-i);\n      //      if(i<A)continue;\n      if(A==0&&i>0)continue;\n      //      if(i>D)continue;\n      //      if(j<B)continue;\n      if(B==0&&j>0)break;\n      if(j>E)break;\n      ll L=nBr(i,A);\n      ll R=nBr(j,B);\n      ll tmp=mul(L,R);\n      tmp=mul(tmp, nCr(A+B,A) );\n      tmp=mul(tmp, nCr(A+B+C,C) );\n      assert( D-i == E-j );\n      tmp=mul(tmp, nHr(D-i,A+B+C) );\n      ans=add(ans,tmp);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\nusing namespace std;\n#define MOD 1000000007\n\n\nlong long kaijo[5000001];\nlong long inv[5000001];\n\n\n\nlong long mul(long long x,long long y){\n    return (x*y)%MOD;\n}\n\nlong long bekijo(long long x,long long n){\n    if(n==0)return 1;\n    if(n%2==1)return mul(x,bekijo(x,n-1));\n    return mul(bekijo(x,n/2),bekijo(x,n/2));\n}\n\nlong long nCk(int n,int k){\n    if(k==-1)return n==k?1:0;\n    return mul(kaijo[n],mul(inv[k],inv[n-k]));\n}\n\nint main(void){\n    kaijo[0]=1;\n    for(long long i=1;i<=5000000;i++){\n        kaijo[i]=mul(kaijo[i-1],i);\n    }\n    \n    inv[5000000]=bekijo(kaijo[5000000],MOD-2);\n    for(long long i=5000000-1;i>=0;i--){\n        inv[i]=mul(inv[i+1],i+1);\n    }\n    \n    while(1){\n        long long int A,B,C,Sx,Sy;\n        scanf(\"%lld%lld%lld%lld%lld\",&A,&B,&C,&Sx,&Sy);\n        if(A+B+C==0)break;\n        \n        /*引き分けた総得点をi点とするとチームXがA回の試合で合計Sx-i点勝ってYがB回の試合でSy-i点勝った*/\n        /*Sx-i>=AかつSy-i>=Bのときのみ考える、つまりiの範囲は0からmin(Sx-A,Sy-B)*/\n        /*勝ち点の振り分け方はSx-i点をA個の箱に全部最低1個ずつ振り分ける方法なので(Sx-i-1)C(A-1)*/\n        /*同様に負け点の振り分けは(Sy-i-1)C(B-1)*/\n        /*引き分け点の振り分けはA+B+C個の箱に(0個も許して)分ける方法なので(i+1)H(A+B+C-1)=(i+A+B+C-1)C(A+B+C-1)*/\n        /*さらに勝った試合AをA+B+C個のどこに置き、BをB+Cのどこに置くかで(A+B+C)CA * (B+C)CB通り*/\n        \n        long long ans=0;\n        for(int i=0;i<=min(Sx-A,Sy-B);i++){\n            long long po=1;\n            po=mul(po,nCk(Sx-i-1,A-1));\n            po=mul(po,nCk(Sy-i-1,B-1));\n            po=mul(po,nCk(i+A+B+C-1,A+B+C-1));\n            po=mul(po,nCk(A+B+C,A));\n            po=mul(po,nCk(B+C,B));\n            ans+=po;\n            ans%=MOD;\n        }\n        printf(\"%lld\\n\",ans);\n        \n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\nusing ll = long long int;\nconst ll MOD = 1000000007;\n\nll mod_pow(ll x, ll n) {\n    if(n == 0) return 1;\n    ll res = mod_pow((x * x) % MOD, n / 2);\n    if(n & 1) res = (res * x) % MOD;\n    return res;\n}\n\n// 髫惹ｹ\u001a mod p\nvector<ll> fact;\nvoid fact_mod(int n) {\n    fact.resize(n+1);\n    fact[0] = 1;\n    for(int i=0; i<n; i++) {\n        fact[i+1] = (fact[i] * (i+1)) % MOD;\n    }\n}\n\n// 髫惹ｹ励�騾�� mod p\nvector<ll> finv;\nvoid fact_inv(int n) {\n    finv.resize(n+1);\n    finv[n] = mod_pow(fact[n], MOD-2);\n    for(int i=n-1; i>=0; i--) {\n        finv[i] = (finv[i+1] * (i+1)) % MOD;\n    }\n}\n\n// fact, finv 繧剃ｽｿ縺｣縺ｦ邨�∩蜷医ｏ縺帙ｒ蜃ｺ縺\u001a\n// 蝓ｺ譛ｬ逧�↓縺ｯ縺薙ｌ繧剃ｽｿ縺｣縺溘⊇縺�′縺�＞\nll combination_array(int n, int r) {\n    if(n < 0 || r < 0 || n < r) return 0;\n    ll x = fact[n];\n    ll y = (finv[r] * finv[n-r]) % MOD;\n\n    return (x * y) % MOD;\n}\n\nll combination_duplicate(int x, int y) {\n    return combination_array(x+y-1, y);\n}\n\nconst int M = 6000010;\nint main() {\n    fact_mod(M);\n    fact_inv(M);\n\n    while(1) {\n        ll A, B, C, X, Y; scanf(\"%lld%lld%lld%lld%lld\", &A, &B, &C, &X, &Y);\n        if(A + B + C + X + Y == 0) break;\n\n        ll ans = 0;\n        // diff 繧呈ｱｺ繧∵遠縺｡\n        for(int D = 0; D <= X+Y; D++) {\n            int free_pt = (X+Y-D) / 2, S = A+B+C;\n            if( (X+Y-D) % 2 == 1 ) continue;\n            if(free_pt > X || free_pt > Y) continue;\n\n            // 蟾ｮ蛻�ｻ･螟悶�轤ｹ謨ｰ繧帝←蠖薙↓驟咲ｽｮ\n            ll add = combination_duplicate(S, free_pt);\n\n            // 蠑輔″蛻�￠縺ｮ菴咲ｽｮ\n            (add *= combination_array(S, C)) %= MOD;\n\n            // 蜍昴■縺ｮ菴咲ｽｮ\n            (add *= combination_array(A+B, A)) %= MOD;\n\n            // P, Q 縺ｮ險育ｮ\u001a (縺昴ｌ縺槭ｌ A 莉･荳翫�B 莉･荳翫〒縺ｪ縺代ｌ縺ｰ縺ｪ繧峨↑縺\u001a)\n            int P = X - free_pt, Q = Y - free_pt;\n\n            if(P < A || Q < B) continue;\n            if(A == 0 && P > 0) continue;\n            if(B == 0 && Q > 0) continue;\n            P -= A, Q -= B;\n            if(A > 0) (add *= combination_duplicate(A, P)) %= MOD;\n            if(B > 0) (add *= combination_duplicate(B, Q)) %= MOD;\n\n            (ans += add) %= MOD;\n            // printf(\"D = %d, add = %lld\\n\", D, add);\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 3000100\n\nll fac[SIZE];\nll fac_in_memo[SIZE];\n\nvoid factorial_init(int n){\n  fac[0] = 1;\n  for(int i=1;i<=n;i++) fac[i] = (i * fac[i-1])%mod;\n}\n\nll factorial(int n,int M){\n  ll ret=1;\n  if(n<=1) return 1;\n  return fac[n];\n  \n  for(int i=1;i<=n;i++){\n    ret = (ret*i)%M;\n  }\n  \n  return ret;\n}\n\nll power(int k,int n,int M){\n  if(n==0) return 1;\n  if(n==1) return (ll)k;\n  \n  ll ret = power(k,n/2,M);\n  \n  ret=(ret*ret)%M;\n  \n  if(n%2==1)\n    ret=(ret*k)%M;\n  \n  return ret;\n}\n\nll fac_in(int k, int n, int M){\n  if(fac_in_memo[k]) return fac_in_memo[k];\n  return fac_in_memo[k] = power(k,n,M);\n}\n\n//nCm nPm nHm (mod M)\n\n/*Combination*/\nint C(int n,int m,int M){\n  if(n<m) return 0;\n  if(m==0 || n==m) return 1;\n  \n  ll chi = factorial(n,M);\n  ll mot = (factorial(m,M) * factorial(n-m,M))%M;\n  \n  mot = power((int)mot,M-2,M);\n  \n  ll ret = (chi*mot)%M;\n  \n  return (int)ret;\n}\n/*Permutation*/\nint P(int n,int m,int M){\n  if(n<m) return 0;\n  if(m==0) return 1;\n  \n  ll chi = factorial(n,M);\n  ll mot = factorial(n-m,M);\n  \n  \n  mot = power((int)mot, M-2,M);\n  \n  ll ret = (chi*mot)%M;\n  \n  return (int)ret;\n}\n/*Combination with Repetitions*/\nint H(int n,int m,int M){\n  if(n==0 && m==0) return 1;\n  return C(n+m-1,m,M);\n}\n\n\n\nbool solve(){\n  int a,b,c,sx,sy;\n\n  scanf(\"%d%d%d%d%d\",&a,&b,&c,&sx,&sy);\n\n  if(a +b + c == 0) return false;\n  \n  if(sx < sy){\n    swap(sx,sy);\n    swap(a,b);\n  }\n\n  ll ans_sum = 0;\n  \n  for(int i=sx-sy;i<=sx;i++){\n    int p = i;\n    int q = i - (sx-sy);\n\n    if(p < a || q < b || (a==0 && p>0) || (b==0 && q > 0)) continue;\n    \n    ll ans = 1;\n\n    ans = (ans * C(p-1,a-1,mod))%mod;\n    ans = (ans * C(q-1,b-1,mod))%mod;\n    ans = (ans * C(sx-i+(c+b+a-1),c+b+a-1,mod))%mod;\n    \n    ans = (ans * factorial(a+b+c,mod))%mod;\n    \n    ans = (ans * power(factorial(a,mod),mod-2,mod))%mod;\n    ans = (ans * power(factorial(b,mod),mod-2,mod))%mod;\n    ans = (ans * power(factorial(c,mod),mod-2,mod))%mod;\n    \n    ans_sum = (ans_sum + ans)%mod;\n  }\n\n  printf(\"%lld\\n\",ans_sum);\n\n  return true;\n}\n\nint main(){\n\n  factorial_init(3000000);\n  \n  while(solve());\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\nll add(ll a,ll b){return (a+b)%mod;}\nll mul(ll a,ll b){return (a*b)%mod;}\n\nll mpow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mpow( mul(a,a) , b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\nll divi(ll a,ll b){\n  return mul(a, mpow(b,mod-2) );\n}\n\nll fact[2000000];\nll Fact[2000000];\ntypedef pair<ll,ll> P;\n\nunordered_map< ll , ll  > mem;\n\nll base=10000000000LL;\n\nll nCr(ll n,ll r){\n  \n  if(mem.count(n*base+r))\n    return mem[n*base+r];\n  \n  return mem[n*base+r]=mul(fact[n], mul(Fact[r],Fact[n-r]) );\n}\n\nll nHr(ll n,ll r){\n  if(r==0)return 1;\n  return nCr(n+r-1,r-1);\n}\n\nll nBr(ll n,ll r){\n  if(n<r)return 0;\n  return nHr(n-r,r);\n}\n\nll A,B,C,D,E;\n\n\nint main(){\n  fact[0]=1;\n  for(ll i=1;i<2000000;i++){\n    fact[i]=mul(fact[i-1],i);\n  }\n  for(ll i=0;i<2000000;i++)Fact[i]=divi(1,fact[i]);\n  \n  while(1){\n    mem.clear();\n    \n    cin>>A>>B>>C>>D>>E;\n    if(A==0&&B==0&&C==0&&D==0&&E==0)break;\n    \n    ll ans=0;\n    for(ll i=max(A,B+D-E);i<=D;i++){\n      ll j=-(D-E-i);\n      //      if(i<A)continue;\n      if(A==0&&i>0)continue;\n      //      if(i>D)continue;\n      //      if(j<B)continue;\n      if(B==0&&j>0)break;\n      if(j>E)break;\n      ll L=nBr(i,A);\n      ll R=nBr(j,B);\n      ll tmp=mul(L,R);\n      tmp=mul(tmp, nCr(A+B,A) );\n      tmp=mul(tmp, nCr(A+B+C,C) );\n      assert( D-i == E-j );\n      tmp=mul(tmp, nHr(D-i,A+B+C) );\n      ans=add(ans,tmp);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nll mod = 1e9+7;\n\nconst int N = 5000000;\nll f[N], inv_f[N];\n\ninline ll mod_pow(ll x, ll n)\n{\n    ll r = 1;\n    while(n)\n    {\n        if(n&1) (r*=x)%=mod;\n        (x*=x)%=mod;\n        n>>=1;\n    }\n    return r;\n}\n\ninline ll mod_inv(ll x)\n{\n    return mod_pow(x,mod-2);\n}\n\n\ninline ll C(int n, int r)\n{\n    if(n<0 || r<0 || n-r<0) return 0;\n    ll ret = f[n];\n    (ret*=inv_f[r])%=mod;\n    (ret*=inv_f[n-r])%=mod;\n    return ret;\n}\n\ninline ll H(int n, int r)\n{\n    if(n==0 && r==0) return 1;\n    return C(n+r-1,r);\n}\n\nint main()\n{\n    f[0]=1;\n    for(int i=1; i<N; ++i) f[i]=(f[i-1]*i)%mod;\n\n    inv_f[N-1] = mod_inv(f[N-1]);\n    for(int i=N-2; i>=0; --i) inv_f[i] = (inv_f[i+1]*(i+1))%mod;\n\n    int a,b,c,sx,sy;\n    while(cin >>a >>b >>c >>sx >>sy)\n    {\n        if(a+b+c+sx+sy==0) break;\n        ll ans = 0;\n        rep(i,sx+1)\n        {\n            ll add = 1;\n            int j = sy-sx+i;\n            (add*=H(a,i-a))%=mod;\n            (add*=H(b,j-b))%=mod;\n            (add*=H(a+b+c,sx-i))%=mod;\n\n            (ans += add)%=mod;\n        }\n        (ans*=C(a+b+c,a))%=mod;\n        (ans*=C(b+c,b))%=mod;\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define REP(i,n) for(ll i=0;i<ll(n);i++)\n#define ALL(v) v.begin(),v.end()\n\n\nconst ll MOD=(int)(1e9)+7;\nvector<ll> fact;\nvector<ll> invfact;\n\nconst int SIZE=4*(int)(1e6);\n\nll powm(ll x,ll k){\n  ll res=1;\n  while(k){\n    if(k&1) res*=x;\n    res%=MOD;\n    x*=x;\n    x%=MOD;\n    k>>=1;\n  }\n  return res;\n}\n\nll mod_inverse(ll x){\n  return powm(x,MOD-2);\n}\n\nvoid init(){\n  fact.assign(SIZE,0);\n  fact[0]=1;\n  for(int i=0;i+1<SIZE;i++){\n    fact[i+1]=(i+1)*fact[i];\n    fact[i+1]%=MOD;\n  }\n  invfact.assign(SIZE,0);\n  for(int i=0;i<SIZE;i++){\n    invfact[i]=mod_inverse(fact[i]);\n  }\n  return;\n}\n\n\nll comb(ll n,ll k){\n  return (((fact[n]*invfact[n-k])%MOD)*invfact[k])%MOD;\n}\nll bunpai(ll x,ll n){\n  if(n==0){\n    assert(x==0);\n    return 1;\n  }\n  return comb(x+n-1,n-1);\n}\n\nll solve(ll a,ll b,ll c,ll sx,ll sy){\n  ll n=a+b+c;\n  ll res=0;\n\n  for(ll buf=0;buf<=min(sx-a,sy-b);buf++){\n    ll bufcomb=bunpai(buf,n);\n    if(a==0 && sx-buf-a>0) continue;\n    ll acomb=bunpai(sx-buf-a,a);\n    if(b==0 && sy-buf-b>0) continue;\n    ll bcomb=bunpai(sy-buf-b,b);\n    res+=(((bufcomb*acomb)%MOD)*bcomb)%MOD;\n    res%=MOD;\n  }\n\n  ll ord=fact[n];\n  ord*=invfact[a];\n  ord%=MOD;\n  ord*=invfact[b];\n  ord%=MOD;\n  ord*=invfact[c];\n  ord%=MOD;\n  res*=ord;\n  res%=MOD;\n  return res;\n\n}\n\nint main(){\n  init();\n  ll a,b,c,sx,sy;\n  while(cin>>a>>b>>c>>sx>>sy,!(a==0 && b==0 && c==0 )){\n    cout<<solve(a,b,c,sx,sy)<<endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n//nCr mod m\n#define MOD 1000000007\n#define M 4000010\nvi fact;\nbool h=false;\nvoid init(){\n\th=true;\n\tfact=vi(M);\n\tfact[0]=fact[1]=1;\n\tloop(i,2,M)fact[i]=(ll)fact[i-1]*i%MOD;\n}\n// a^b mod MOD\nll powmod(ll a,ll b,ll m=MOD){\n\tll out=1;\n\tll p=a%m;\n\twhile(b){\n\t\tif(b&1)out=out*p%m;\n\t\tp=p*p%m;\n\t\tb>>=1;\n\t}\n\treturn out;\n}\n//nCr\nll nCr(ll n,ll r,ll m=MOD){\n\tif(!h)init();\n\tif(n<0||r<0||n<r)return 0;//??????\n\tll out=(ll)fact[n]*powmod((ll)fact[r]*fact[n-r]%m,m-2,m)%m;\n\treturn out;\n}\nint main(){\n\tll a,b,c,d,e;\n\twhile(cin>>a>>b>>c>>d>>e,a+b+c+d+e){\n\t\tif(d>e)swap(a,b),swap(d,e);\n\t\tll out=0;\n\t\tll A=nCr(a+b+c,a),B=nCr(b+c,b);\n\t\trep(s,d+1){\n\t\t\tll t=e-d+s;\n\t\t\tif(t<0||t>e)continue;\n\t\t\tll w=1;\n\t\t\tif(s||a)(w*=nCr(s-1,a-1)*A%MOD)%=MOD;\n\t\t\tif(t||b)(w*=nCr(t-1,b-1)*B%MOD)%=MOD;\n\t\t\t(w*=nCr(d-s+a+b+c-1,a+b+c-1))%=MOD;\n\t\t\t(out+=w)%=MOD;\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nlong long fact[5000009], factinv[5000009], mod = 1000000007;\n\nlong long mul3(long long a, long long b, long long c) {\n\treturn ((a*b)%mod)*c%mod;\n}\nlong long mul2(long long a, long long b) {\n\treturn (a*b) % mod;\n}\nlong long modpow(long long a, long long b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (int i = 0; i < 60; i++) {\n\t\tif ((b / (1LL << i)) % 2 == 1) { p *= q; p %= m; }\n\t\tq *= q; q %= m;\n\t}\n\treturn p;\n}\nlong long Div(long long a, long long b, long long m) {\n\treturn (a*modpow(b, m - 2, m)) % m;\n}\nlong long ncr(long long n, long long r) {\n\tif (r < 0 || n < r) return 0;\n\treturn mul3(fact[n], factinv[n - r], factinv[r]);\n}\nvoid init() {\n\tfact[0] = 1; for (int i = 1; i <= 5000000; i++) fact[i] = (fact[i - 1] * i) % mod;\n\tfor (int i = 0; i <= 5000000; i++) factinv[i] = Div(1, fact[i], mod);\n}\nlong long comb(long long a, long long b) {\n\tif (b == 0) {\n\t\tif (a == 0) return 1;\n\t\treturn 0;\n\t}\n\treturn ncr(a - 1, b - 1);\n}\n\nlong long X, Y, A, B, C;\n\nint main() {\n\tinit();\n\twhile (true) {\n\t\tcin >> A >> B >> C >> X >> Y; if (A + B + C + X + Y == 0) break;\n\n\t\tlong long sum = 0;\n\t\tfor (int i = 0; i <= min(X, Y); i++) {\n\t\t\tlong long V1 = ncr(A + B, B)*ncr(A + B + C, C); V1 %= mod;\n\t\t\tlong long V2 = comb(i + A + B + C, A + B + C);\n\t\t\tlong long V3 = comb(X - i, A);\n\t\t\tlong long V4 = comb(Y - i, B);\n\t\t\tsum += mul2(mul2(V1, V2), mul2(V3, V4)); sum %= mod;\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 3000100\n\nll fac[SIZE];\nll inv[SIZE];\n\nll factorial(int n,int M){\n  ll ret=1;\n  if(n<=1) return 1;\n  return fac[n];\n  \n  for(int i=1;i<=n;i++){\n    ret = (ret*i)%M;\n  }\n  \n  return ret;\n}\n\nll power(int k,int n,int M){\n  if(n==0) return 1;\n  if(n==1) return (ll)k;\n  \n  ll ret = power(k,n/2,M);\n  \n  ret=(ret*ret)%M;\n  \n  if(n%2==1)\n    ret=(ret*k)%M;\n  \n  return ret;\n}\n\nvoid factorial_init(int n){\n  fac[0] = 1;\n  for(int i=1;i<=n;i++) fac[i] = (i * fac[i-1])%mod;\n\n  inv[n] = power(fac[n],mod-2,mod);\n  for(int i=n;i>=1;i--) inv[i-1] = (i*inv[i])%mod;\n}\n\n//nCm nPm nHm (mod M)\n\n/*Combination*/\nint C(int n,int m,int M){\n  if(n<m) return 0;\n  if(m==0 || n==m) return 1;\n  \n  ll chi = factorial(n,M);\n  ll mot = (inv[m] * inv[n-m])%M;  \n  ll ret = (chi*mot)%M;\n  \n  return (int)ret;\n}\n\n/*Combination with Repetitions*/\nint H(int n,int m,int M){\n  if(n==0 && m==0) return 1;\n  return C(n+m-1,m,M);\n}\n\n\n\nbool solve(){\n  int a,b,c,sx,sy;\n\n  scanf(\"%d%d%d%d%d\",&a,&b,&c,&sx,&sy);\n\n  if(a +b + c == 0) return false;\n  \n  if(sx < sy){\n    swap(sx,sy);\n    swap(a,b);\n  }\n\n  ll ans_sum = 0;\n  \n  for(int i=sx-sy;i<=sx;i++){\n    int p = i;\n    int q = i - (sx-sy);\n\n    if(p < a || q < b || (a==0 && p>0) || (b==0 && q > 0)) continue;\n\n    ll ans = 1;\n\n    ans = (ans * C(p-1,a-1,mod))%mod;\n    ans = (ans * C(q-1,b-1,mod))%mod;\n    ans = (ans * C(sx-i+(c+b+a-1),c+b+a-1,mod))%mod;\n    \n    ans_sum = (ans_sum + ans)%mod;\n  }\n  \n  ans_sum = (ans_sum * factorial(a+b+c,mod))%mod;\n  ans_sum = (ans_sum * inv[a])%mod;\n  ans_sum = (ans_sum * inv[b])%mod;\n  ans_sum = (ans_sum * inv[c])%mod;\n\n  printf(\"%lld\\n\",ans_sum);\n\n  return true;\n}\n\nint main(){\n\n  factorial_init(3000000);\n  \n  while(solve());\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 3000100\n\nll fac[SIZE];\nll fac_in_memo[SIZE];\n\nvoid factorial_init(int n){\n  fac[0] = 1;\n  for(int i=1;i<=n;i++) fac[i] = (i * fac[i-1])%mod;\n}\n\nll factorial(int n,int M){\n  ll ret=1;\n  if(n<=1) return 1;\n  return fac[n];\n  \n  for(int i=1;i<=n;i++){\n    ret = (ret*i)%M;\n  }\n  \n  return ret;\n}\n\nll power(int k,int n,int M){\n  if(n==0) return 1;\n  if(n==1) return (ll)k;\n  \n  ll ret = power(k,n/2,M);\n  \n  ret=(ret*ret)%M;\n  \n  if(n%2==1)\n    ret=(ret*k)%M;\n  \n  return ret;\n}\n\nll fac_in(int k, int n, int M){\n  if(fac_in_memo[k]) return fac_in_memo[k];\n  return fac_in_memo[k] = power(k,n,M);\n}\n\n//nCm nPm nHm (mod M)\n\n/*Combination*/\nint C(int n,int m,int M){\n  if(n<m) return 0;\n  if(m==0 || n==m) return 1;\n  \n  ll chi = factorial(n,M);\n  ll mot = (factorial(m,M) * factorial(n-m,M))%M;\n  \n  mot = power((int)mot,M-2,M);\n  \n  ll ret = (chi*mot)%M;\n  \n  return (int)ret;\n}\n/*Permutation*/\nint P(int n,int m,int M){\n  if(n<m) return 0;\n  if(m==0) return 1;\n  \n  ll chi = factorial(n,M);\n  ll mot = factorial(n-m,M);\n  \n  \n  mot = power((int)mot, M-2,M);\n  \n  ll ret = (chi*mot)%M;\n  \n  return (int)ret;\n}\n/*Combination with Repetitions*/\nint H(int n,int m,int M){\n  if(n==0 && m==0) return 1;\n  return C(n+m-1,m,M);\n}\n\n\n\nbool solve(){\n  int a,b,c,sx,sy;\n\n  scanf(\"%d%d%d%d%d\",&a,&b,&c,&sx,&sy);\n\n  if(a +b + c == 0) return false;\n  \n  if(sx < sy){\n    swap(sx,sy);\n    swap(a,b);\n  }\n\n  ll ans_sum = 0;\n  \n  for(int i=sx-sy;i<=sx;i++){\n    int p = i;\n    int q = i - (sx-sy);\n\n    if(p < a || q < b || (a==0 && p>0) || (b==0 && q > 0)) continue;\n\n    ll ans = 1;\n\n    ans = (ans * C(p-1,a-1,mod))%mod;\n    ans = (ans * C(q-1,b-1,mod))%mod;\n    ans = (ans * C(sx-i+(c+b+a-1),c+b+a-1,mod))%mod;\n    \n    ans_sum = (ans_sum + ans)%mod;\n  }\n  \n  ans_sum = (ans_sum * factorial(a+b+c,mod))%mod;\n  ans_sum = (ans_sum * power(factorial(a,mod),mod-2,mod))%mod;\n  ans_sum = (ans_sum * power(factorial(b,mod),mod-2,mod))%mod;\n  ans_sum = (ans_sum * power(factorial(c,mod),mod-2,mod))%mod;\n\n  printf(\"%lld\\n\",ans_sum);\n\n  return true;\n}\n\nint main(){\n\n  factorial_init(3000000);\n  \n  while(solve());\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\nll add(ll a,ll b){return (a+b)%mod;}\nll mul(ll a,ll b){return (a*b)%mod;}\n\nll mpow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mpow( mul(a,a) , b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\nll divi(ll a,ll b){\n  return mul(a, mpow(b,mod-2) );\n}\n\nll fact[3000005];\nll Fact[3000005];\ntypedef pair<ll,ll> P;\n\nunordered_map< ll , ll  > mem;\n\nll base=10000000000LL;\n\nll nCr(ll n,ll r){\n  \n  if(mem.count(n*base+r))\n    return mem[n*base+r];\n  \n  return mem[n*base+r]=mul(fact[n], mul(Fact[r],Fact[n-r]) );\n}\n\nll nHr(ll n,ll r){\n  if(r==0)return 1;\n  return nCr(n+r-1,r-1);\n}\n\nll nBr(ll n,ll r){\n  if(n<r)return 0;\n  return nHr(n-r,r);\n}\n\nll A,B,C,D,E;\n\n\nint main(){\n  fact[0]=1;\n  for(ll i=1;i<3000005;i++){\n    fact[i]=mul(fact[i-1],i);\n  }\n  for(ll i=0;i<3000005;i++)Fact[i]=divi(1,fact[i]);\n  \n  while(1){\n    mem.clear();\n    \n    cin>>A>>B>>C>>D>>E;\n    if(A==0&&B==0&&C==0&&D==0&&E==0)break;\n    \n    ll ans=0;\n    for(ll i=0;i<=1000000;i++){\n      ll j=-(D-E-i);\n      if(i<A)continue;\n      if(A==0&&i>0)continue;\n      if(i>D)continue;\n      if(j<B)continue;\n      if(B==0&&j>0)continue;\n      if(j>E)continue;\n      ll L=nBr(i,A);\n      ll R=nBr(j,B);\n      ll tmp=mul(L,R);\n      tmp=mul(tmp, nCr(A+B,A) );\n      tmp=mul(tmp, nCr(A+B+C,C) );\n      assert( D-i == E-j );\n      tmp=mul(tmp, nHr(D-i,A+B+C) );\n      ans=add(ans,tmp);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\nll add(ll a,ll b){return (a+b)%mod;}\nll mul(ll a,ll b){return (a*b)%mod;}\n\nll mpow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mpow( mul(a,a) , b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\nll divi(ll a,ll b){\n  return mul(a, mpow(b,mod-2) );\n}\n\nll fact[3000000];\ntypedef pair<ll,ll> P;\n\nunordered_map< ll , ll  > mem;\n\nll base=10000000000LL;\n\nll nCr(ll n,ll r){\n  \n  if(mem.count(n*base+r))\n    return mem[n*base+r];\n  \n  return mem[n*base+r]=divi(fact[n], mul(fact[r],fact[n-r]) );\n}\n\nll nHr(ll n,ll r){\n  if(r==0)return 1;\n  return nCr(n+r-1,r-1);\n}\n\nll nBr(ll n,ll r){\n  if(n<r)return 0;\n  return nHr(n-r,r);\n}\n\nll A,B,C,D,E;\n\n\nint main(){\n  fact[0]=1;\n  for(ll i=1;i<3000000;i++)\n    fact[i]=mul(fact[i-1],i);\n  \n  while(1){\n    mem.clear();\n    \n    cin>>A>>B>>C>>D>>E;\n    if(A==0&&B==0&&C==0&&D==0&&E==0)break;\n    \n    ll ans=0;\n    if(D-A<E-B){\n      for(ll i=A;i<=D;i++){\n        ll j=-(D-E-i);\n        if(i<A)continue;\n        if(A==0&&i>0)continue;\n        if(i>D)continue;\n        if(j<B)continue;\n        if(B==0&&j>0)break;\n        if(j>E)break;\n        ll L=nBr(i,A);\n        ll R=nBr(j,B);\n        ll tmp=mul(L,R);\n        tmp=mul(tmp, nCr(A+B,A) );\n        tmp=mul(tmp, nCr(A+B+C,C) );\n        assert( D-i == E-j );\n        tmp=mul(tmp, nHr(D-i,A+B+C) );\n        ans=add(ans,tmp);\n      }\n    }else{\n      for(ll j=B;j<=E;j++){\n        ll i=(D-E+j);\n        if(i<A)continue;\n        if(A==0&&i>0)continue;\n        if(i>D)continue;\n        if(j<B)continue;\n        if(B==0&&j>0)continue;\n        if(j>E)continue;\n        ll L=nBr(i,A);\n        ll R=nBr(j,B);\n        ll tmp=mul(L,R);\n        tmp=mul(tmp, nCr(A+B,A) );\n        tmp=mul(tmp, nCr(A+B+C,C) );\n        assert( D-i == E-j );\n        tmp=mul(tmp, nHr(D-i,A+B+C) );\n        ans=add(ans,tmp);\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\nusing ll = long long;\nconst ll mod = 1000000007LL;\n\nconst int limit = 5000000;\nll F[limit+10],IF[limit+10];\n\nll inv(ll a){\n\tll b = 1LL;\n\tll n = mod -2;\n\twhile(n){\n\t\tif(n&1) b = b * a % mod;\n\t\ta = a * a % mod;\n\t\tn >>= 1;\n\t}\n\treturn b;\n}\n\ninline ll C(int n,int k){\n\tif(n < 0 or k < 0 or n-k < 0) return 0;\n\treturn F[n] * IF[k] % mod * IF[n-k] %mod;\n}\n\ninline ll H(int n,int k){\n\tn += k - 1;\n\treturn C(n,k);\n}\n\nint main(void){\n\tF[0] = 1LL;\n\tfor(ll i=1LL;i<=limit;++i) F[i] = i * F[i-1] %mod;\n\tIF[limit] = inv(F[limit]);\n\tfor(ll i=limit;i>=1;--i) IF[i-1] = i * IF[i] %mod;\n\t\t\n\tll a,b,c,sx,sy;\n\twhile(cin >> a >> b >> c >> sx >> sy){\n\t\tif(a+b+c+sx+sy==0) break;\n\t\tll ans = 0LL;\n\n\t\tfor(ll wa = a; wa <= sx; ++ wa){\n\t\t\tconst ll draw = sx - wa;\n\t\t\tconst ll wb = sy - draw; \n\t\t\tif(draw < 0 or wb < b) continue;\n\t\t\t//cerr << wa << \" \" << wb << \" \" << draw << endl;\n\t\t\tll cur = 1LL;\n\t\t\tcur = cur * H(a,wa-a) % mod;\n\t\t\tcur = cur * H(b,wb-b) % mod;\n\t\t\tcur = cur * H(a+b+c,draw) % mod;\n\t\t\tans = (ans + cur) % mod;\n\t\t}\n\n\t\tans = ans * C(a+b+c,a) % mod * C(b+c,b) % mod;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e18;\nconst long double PI = acos(-1.0L);\nconst ll mod = 1000000007;\nll A, B, C, Sx, Sy;\nll ans;\nll inv[10000100];\nll FactorialInv[10000100];\nll Factorial[10000100];\nll beki(ll a, ll b){\n    if(b == 0){\n        return 1;\n    }\n    ll ans = beki(a, b / 2);\n    ans = ans * ans % mod;\n    if(b % 2 == 1){\n        ans = ans * a % mod;\n    }\n    return ans;\n}\nvoid init_combination(){\n    const int MAX = 10000002;\n    Factorial[0] = 1;\n    inv[0] = 1;\n    for(int i = 1; i <= MAX; i++){\n        Factorial[i] = Factorial[i - 1] * i % mod;\n    }\n    FactorialInv[MAX] = beki(Factorial[MAX], mod - 2);\n    for(ll i = MAX - 1; i >= 0; i--) {\n        FactorialInv[i] = FactorialInv[i+1] * (i+1) % mod;\n    }\n    for(int i = 1; i <= MAX; i++) {\n        inv[i] = FactorialInv[i] * Factorial[i-1] % mod;\n    }\n}\nll combination(ll a, ll b){\n    if((a == b) || (b == 0)){\n        return 1;\n    }\n    if(a < b) return 0;\n    ll ans = Factorial[a] * FactorialInv[b] % mod;\n    ans = ans * FactorialInv[a - b] % mod;\n    return ans;\n}\n\n\nvoid solve() {\n    ans = 0;\n    for(ll overx = A; overx <= 1e6; overx++) {\n        ll overy = Sy - Sx + overx;\n        if(overy < B) continue;\n        ll now = 1;\n        ll tmp = overx - A;\n        now *= combination(A - 1 + tmp, tmp);\n        tmp = overy - B;\n        now *= combination(B - 1 + tmp, tmp);\n        now %= mod;\n        ll rest = Sx - overx;\n        if(rest < 0) continue;\n        now *= combination(A + B + C - 1 + rest, rest);\n        now %= mod;\n        now *= combination(A + B + C, A);\n        now %= mod;\n        now *= combination(B + C, B);\n        now %= mod;\n        ans += now;\n        ans %= mod;\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    init_combination();\n    while(cin >> A >> B >> C >> Sx >> Sy) {\n        if(A==0 and B==0 and C==0) break;\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MX 5000000\nll fact[MX+8];\nll rfact[MX+8];\nll i,j,k,l,a,b;\nll mod = 1000000007ll;\n\nll rui(ll a,ll b){\n\tif(b == 0){\n\t\treturn 1;\n\t}else if(b == 1){\n\t\treturn a;\n\t}else{\n\t\tif(b % 2 == 1){\n\t\t\tll ans = a * rui(a,b-1);\n\t\t\tans %= mod;\n\t\t\treturn ans;\n\t\t}else{\n\t\t\tll ans = rui(a,b/2);\n\t\t\tans *= ans;\n\t\t\tans %= mod;\n\t\t\treturn ans;\n\t\t}\n\t}\n}\n\n\nvoid c3_init(){\n\tfact[0] = 1;\n\tfor(int i=1;i<=MX;i++){\n\t\tfact[i] = fact[i-1] * i;\n\t\tfact[i] %= mod;\n\t}\n\trfact[MX] = rui(fact[MX],mod-2);\n\tfor(i=MX-1;i>=0;i--){\n\t\trfact[i] = rfact[i+1] * (i+1);\n\t\trfact[i] %= mod;\n\t}\n}\n\n\n\nll suma[MX+100],sumb[MX+100];\n\nll c3(ll n,ll r){\n\t//nCrwomotomeru\n\tif(n == 0){\n\t\treturn 1;\n\t}\n\tif(r > n || n < 0 || r < 0){\n\t\tif(r > n)cout << \"r > n\" << endl;\n\t\tif(n < 0)cout << \"n < 0\" << endl;\n\t\tif(r < 0)cout << \"r < 0\" << endl;\n\t\t//cout << \" !!! \" << endl;\n\t}\n\tif(r == 0){\n\t\treturn 1;\n\t}\n\treturn (((fact[n] * rfact[r]) % mod) * rfact[n-r]) % mod;\n}\n\nbool solve(){\n\tll a,b,c,sx,sy;\n\tcin >> a >> b >> c >> sx >> sy;\n\tif(a + b + c == 0)return false;\n\tif(sx < sy){\n\t\tswap(a,b);\n\t\tswap(sx,sy);\n\t}\n\t//sx > sy \n\tfor(int i=0;i<=sx;i++){\n\t\tif(a == 0){\n\t\t\tif(i == 0){\n\t\t\t\tsuma[i] = 1;\n\t\t\t}else{\n\t\t\t\tsuma[i] = 0;\n\t\t\t}\n\t\t}else{\n\t\t\tif(i == 0){\n\t\t\t\tsuma[i] = 0;\n\t\t\t}else{\n\t\t\t\tif(i < a){\n\t\t\t\t\tsuma[i] = 0;\n\t\t\t\t}else{\n\t\t\t\t\tsuma[i] = c3(i-1,a-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=sy;i++){\n\t\tif(b == 0){\n\t\t\tif(i == 0){\n\t\t\t\tsumb[i] = 1;\n\t\t\t}else{\n\t\t\t\tsumb[i] = 0;\n\t\t\t}\n\t\t}else{\n\t\t\tif(i == 0){\n\t\t\t\tsumb[i] = 0;\n\t\t\t}else{\n\t\t\t\tif(i < b){\n\t\t\t\t\tsumb[i] = 0;\n\t\t\t\t}else{\n\t\t\t\t\tsumb[i] = c3(i-1,b-1);\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 1;\n\tll sum = 0;\n\tfor(int i=0;i<=sy;i++){\n\t\t//cout << suma[i + sx - sy] * sumb[i] << endl;\n\t\tsum += (((suma[i + sx - sy] * sumb[i]) % mod) * c3(a+b+c-1+sy - i,sy - i) % mod);\n\t\tsum %= mod;\n\t}\n\t//cout << suma[29] << \" \" << sumb[0] << endl;\n\tans = c3(a+b+c,a) * c3(b+c,b);\n\tans %= mod;\n\tans *= sum;\n\tans %= mod;\n\t//ans *= c3(a+b+c-1+sy,sy);\n\tans %= mod;\n\tcout << ans << endl;\n\treturn true;\n}\n\nint main(){\n\t\n\tc3_init();\n\twhile(solve()){}\n\t\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define MAX_N 3000003\n\ninline int modPow(int x, int n) {\n  if(n == 0) return 1;\n  int res = modPow(x, n/2);\n  (res *= res) %= mod;\n  if(n&1) (res *= x) %= mod;\n  return res;\n}\ninline int modInv(int a) {\n  return modPow(a, mod-2);\n}\ninline int modComb(int n, int r) {\n  static int fact[MAX_N], inv[MAX_N];\n  if(fact[0] == 0) {\n    fact[0] = inv[0] = 1;\n    reps(i, 1, MAX_N) {\n      fact[i] = fact[i-1]*i % mod;\n      inv[i] = modInv(fact[i]);\n    }\n  }\n  if(r < 0 || n < r) return 0;\n  return fact[n]*inv[r]%mod*inv[n-r]%mod;\n}\ninline int Homo(int n, int r) {\n  return modComb(n+r-1, r);\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int A, B, C, Sx, Sy;\n  while(cin >> A >> B >> C >> Sx >> Sy, A || B || C || Sx || Sy) {\n    if(Sx < Sy || (Sx == Sy && A < B)) swap(Sx, Sy), swap(A, B);\n    int diff = Sx - Sy;\n    int game = modComb(A+B+C, A)*modComb(B+C, B)%mod; // ????????????????????´????????°\n    int score = 0; // ?????°????????????????????´????????°\n    if(A == 0) {\n      if(B == 0 && Sx == Sy) score = Homo(C, Sx);\n    } else if(B == 0) {\n      score = Homo(A, diff-A)*Homo(A+B+C, Sy)%mod; // Y????????????????????????????????????+1?????\\???\n    } else {\n      reps(i, max(A, diff+B), Sx+1) {\n\tscore += Homo(A, i-A)*Homo(B, i-diff-B)%mod*Homo(A+B+C, Sx-i)%mod;\n\tscore %= mod;\n      }\n    }\n    cout << game*score%mod << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\ntemplate <int MOD>\nstruct ModInt {\n    using lint = long long;\n    int val;\n\n    // constructor\n    ModInt(lint v = 0) : val(v % MOD) {\n        if (val < 0) val += MOD;\n    };\n\n    // unary operator\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const { return this->pow(MOD - 2); }\n\n    // arithmetic\n    ModInt operator+(const ModInt& x) const { return ModInt(*this) += x; }\n    ModInt operator-(const ModInt& x) const { return ModInt(*this) -= x; }\n    ModInt operator*(const ModInt& x) const { return ModInt(*this) *= x; }\n    ModInt operator/(const ModInt& x) const { return ModInt(*this) /= x; }\n    ModInt pow(lint n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n\n    // compound assignment\n    ModInt& operator+=(const ModInt& x) {\n        if ((val += x.val) >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(const ModInt& x) {\n        if ((val -= x.val) < 0) val += MOD;\n        return *this;\n    }\n    ModInt& operator*=(const ModInt& x) {\n        val = lint(val) * x.val % MOD;\n        return *this;\n    }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n\n    // compare\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n\n    // I/O\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\n\ntemplate <class T>\nstruct Combination {\n    int max_n;\n    std::vector<T> f, invf;\n\n    explicit Combination(int n)\n        : max_n(n), f(n + 1), invf(n + 1) {\n        f[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            f[i] = f[i - 1] * i;\n        }\n\n        invf[max_n] = f[max_n].inv();\n        for (int i = max_n - 1; i >= 0; --i) {\n            invf[i] = invf[i + 1] * (i + 1);\n        }\n    }\n\n    T fact(int n) const { return f[n]; }\n    T invfact(int n) const { return invf[n]; }\n    T perm(int a, int b) const {\n        return a < b || b < 0 ? T(0) : f[a] * invf[a - b];\n    }\n    T comb(int a, int b) const {\n        return a == b ? 1 : a < b || b < 0 ? T(0) : f[a] * invf[a - b] * invf[b];\n    }\n};\n\nconstexpr int MOD = 1e9 + 7;\nusing mint = ModInt<MOD>;\n\nCombination<mint> C(4000000);\n\nbool solve() {\n    int a, b, c, x, y;\n    std::cin >> a >> b >> c >> x >> y;\n\n    int s = a + b + c;\n    if (s == 0) return false;\n\n    mint ans = 0;\n    for (int l = 0; l <= x; ++l) {\n        int d = x - l;\n        int r = y - d;\n        auto pat = C.comb(l - 1, a - 1) * C.comb(r - 1, b - 1) *\n                   C.comb(d + s - 1, d);\n\n        ans += pat;\n    }\n\n    ans *= C.comb(s, a) * C.comb(s - a, b);\n\n    std::cout << ans << std::endl;\n    return true;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    while (solve()) {}\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\ntemplate <int M, bool IsPrime = false>\nclass modulo {\n    using ll = long long;\npublic:\n    modulo() : n(0) {}\n    modulo(int m) : n(m) {\n        if(n >= M) {\n            n %= M;\n        } else if(n < 0) {\n            n = (n % M + M) % M;\n        }\n    }\n    modulo(ll m) {\n        if(m >= M) {\n            m %= M;\n        } else if(m < 0) {\n            m = (m % M + M) % M;\n        }\n        n = m;\n    }\n\n    explicit operator int() const {\n        return n;\n    }\n    explicit operator ll() const {\n        return n;\n    }\n    bool operator==(modulo const& a) const {\n        return n == a.n;\n    }\n\n    modulo& operator+=(modulo const& a) {\n        n += a.n;\n        if(n >= M) {\n            n -= M;\n        }\n        return *this;\n    }\n    modulo& operator-=(modulo const& a) {\n        n -= a.n;\n        if(n < 0) {\n            n += M;\n        }\n        return *this;\n    }\n    modulo& operator*=(modulo const& a) {\n        n = (ll(n) * a.n) % M;\n        return *this;\n    }\n    modulo operator^(int n) const {\n        if(n == 0) {\n            return modulo(1);\n        }\n        const modulo a = *this;\n        modulo res = (a * a) ^ (n / 2);\n        return n % 2 ? res * a : res;\n    }\n\n    // for C++11, enable_if_t -> typename enable_if::type\n    typename std::enable_if<IsPrime, modulo>::type operator/(modulo const& a) const {\n        return *this * modulo(inv(ll(a), M));\n    }\n\nprivate:\n    ll n;\n    static typename std::enable_if<IsPrime, ll>::type inv(ll a, ll p) {\n        return (a == 1 ? 1 : (1 - p*inv(p%a, a))/a + p);\n    }\n};\n\ntemplate <int M, bool IsPrime>\nmodulo<M, IsPrime> operator+(modulo<M, IsPrime> lhs, modulo<M, IsPrime> const& rhs) {\n    lhs += rhs;\n    return lhs;\n}\ntemplate <int M, bool IsPrime>\nmodulo<M, IsPrime> operator-(modulo<M, IsPrime> lhs, modulo<M, IsPrime> const& rhs) {\n    lhs -= rhs;\n    return lhs;\n}\ntemplate <int M, bool IsPrime>\nmodulo<M, IsPrime> operator*(modulo<M, IsPrime> lhs, modulo<M, IsPrime> const& rhs) {\n    lhs *= rhs;\n    return lhs;\n}\n\n// sw == false -> inv\ntemplate <int M>\nmodulo<M, true> fact(int n, bool sw = true) {\n    static std::vector<modulo<M, true>> v1 = {1}, v2 = {1};\n    if(n >= (int)v1.size()) {\n        const int from = v1.size(), to = n + 1024;\n        v1.reserve(to);\n        v2.reserve(to);\n        for(int i=from; i<to; ++i) {\n            v1.push_back(v1.back() * modulo<M, true>(i));\n            v2.push_back(v2.back() / modulo<M, true>(i));\n        }\n    }\n    return sw ? v1[n] : v2[n];\n}\n\ntemplate <int M>\nmodulo<M, true> comb(int a, int b) {\n    if(b < 0 || b > a) {\n        return fact<M>(0);\n    }\n    return fact<M>(a, true) * fact<M>(b, false) * fact<M>(a-b, false);\n}\n\n\nusing ll = long long;\n\nconst int MOD = 1000000007;\nusing mod = modulo<MOD, true>;\n\n\nint main() {\n    ll A, B, C, X, Y;\n    while(cin >> A >> B >> C >> X >> Y, A + B + C > 0) {\n        ll const match = A + B + C;\n        mod res;\n        ll const lim = min(X - A, Y - B);\n        for(ll draw = 0; draw <= lim; ++draw) {\n            ll x_win_point = X - draw;\n            ll y_win_point = Y - draw;\n            mod t = 1;\n            t *= comb<MOD>(match + draw - 1, draw);\n            if(x_win_point > 0 && A == 0 || x_win_point - A < 0) {\n                t = 0;\n            }\n            if(y_win_point > 0 && B == 0 || y_win_point - B < 0) {\n                t = 0;\n            }\n            t *= comb<MOD>(x_win_point - 1, A - 1) * comb<MOD>(match, A);\n            t *= comb<MOD>(y_win_point - 1, B - 1) * comb<MOD>(match - A, B);\n\n            res += t;\n        }\n        cout << (ll)res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 3000100\n\nll fac[SIZE];\n\nvoid factorial_init(int n){\n  fac[0] = 1;\n  for(int i=1;i<=n;i++) fac[i] = (i * fac[i-1])%mod;\n}\n\nll factorial(int n,int M){\n  ll ret=1;\n  if(n<=1) return 1;\n  return fac[n];\n  \n  for(int i=1;i<=n;i++){\n    ret = (ret*i)%M;\n  }\n  \n  return ret;\n}\n\nll power(int k,int n,int M){\n  if(n==0) return 1;\n  if(n==1) return (ll)k;\n  \n  ll ret = power(k,n/2,M);\n  \n  ret=(ret*ret)%M;\n  \n  if(n%2==1)\n    ret=(ret*k)%M;\n  \n  return ret;\n}\n\n\n//nCm nPm nHm (mod M)\n\n/*Combination*/\nint C(int n,int m,int M){\n  if(n<m) return 0;\n  if(m==0 || n==m) return 1;\n  \n  ll chi = factorial(n,M);\n  ll mot = (factorial(m,M) * factorial(n-m,M))%M;\n  \n  mot = power((int)mot,M-2,M);\n  \n  ll ret = (chi*mot)%M;\n  \n  return (int)ret;\n}\n/*Permutation*/\nint P(int n,int m,int M){\n  if(n<m) return 0;\n  if(m==0) return 1;\n  \n  ll chi = factorial(n,M);\n  ll mot = factorial(n-m,M);\n  \n  \n  mot = power((int)mot, M-2,M);\n  \n  ll ret = (chi*mot)%M;\n  \n  return (int)ret;\n}\n/*Combination with Repetitions*/\nint H(int n,int m,int M){\n  if(n==0 && m==0) return 1;\n  return C(n+m-1,m,M);\n}\n\n\n\nbool solve(){\n  int a,b,c,sx,sy;\n\n  scanf(\"%d%d%d%d%d\",&a,&b,&c,&sx,&sy);\n\n  if(a +b + c == 0) return false;\n  \n  if(sx < sy){\n    swap(sx,sy);\n    swap(a,b);\n  }\n\n  ll ans_sum = 0;\n  \n  for(int i=sx-sy;i<=sx;i++){\n    int p = i;\n    int q = i - (sx-sy);\n\n    if(p < a || q < b || (a==0 && p>0) || (b==0 && q > 0)) continue;\n    \n    ll ans = 1;\n\n    ans = (ans * C(p-1,a-1,mod))%mod;\n    ans = (ans * C(q-1,b-1,mod))%mod;\n    ans = (ans * C(sx-i+(c+b+a-1),c+b+a-1,mod))%mod;\n    \n    ans = (ans * factorial(a+b+c,mod))%mod;\n    \n    ans = (ans * power(factorial(a,mod),mod-2,mod))%mod;\n    ans = (ans * power(factorial(b,mod),mod-2,mod))%mod;\n    ans = (ans * power(factorial(c,mod),mod-2,mod))%mod;\n    \n    ans_sum = (ans_sum + ans)%mod;\n  }\n\n  printf(\"%lld\\n\",ans_sum);\n\n  return true;\n}\n\nint main(){\n\n  factorial_init(3000000);\n  \n  while(solve());\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n//ａをbで割る\nlong long mod_div(ll a,ll b){\n\tif(a % b == 0)return a/b;\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n \n#define MAX_K 6666666\nvector<long long> kaijo(MAX_K);\nlong long combination(long long n, long long r){\n    if(n < r || n < 0 || r < 0)\n        return 0;\n\tif(kaijo[0] != 1){\n\t\tkaijo[0] = 1;\n\t\tfor(long long i = 1;i < MAX_K;i++)kaijo[i] = (kaijo[i-1] * i) % MOD;\n\t}\n    long long ret = kaijo[n];\n\tlong long tmp = (kaijo[r] * kaijo[n-r]) % MOD;\n    return mod_div(ret,tmp);\n}\n\nint main(){\n\tint a,b,c,x,y;\n\t\n\twhile(cin >> a >> b >> c >> x >> y,a+b+c+x+y){\n\t\t\n\t\tll ans = 0;\n\t\tfor(int i = 0;i <= min(x,y);i++){\n\t\t\tint X = x-i-a;\n\t\t\tint Y = y-i-b;\n\t\t\tif(X < 0 || y < 0)continue;\n\t\t\tll tmp = 1;\n\t\t\ttmp = (tmp * combination(a+b+c,c)) % MOD;\n\t\t\ttmp = (tmp * combination(a+b,b)) % MOD;\n\t\t\ttmp = (tmp * combination(a+b+c+i-1,i)) % MOD;\n\t\t\ttmp = (tmp * combination(a+X-1,X)) % MOD;\n\t\t\ttmp = (tmp * combination(b+Y-1,Y)) % MOD;\n\t\t\tans = (ans+tmp) % MOD;\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n//ａをbで割る\nlong long mod_div(ll a,ll b){\n\tif(a % b == 0)return a/b;\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n \n#define MAX_K 6666666\nvector<long long> kaijo(MAX_K);\nlong long combination(long long n, long long r){\n    if(n < r || n < 0 || r < 0)\n        return 0;\n\tif(kaijo[0] != 1){\n\t\tkaijo[0] = 1;\n\t\tfor(long long i = 1;i < MAX_K;i++)kaijo[i] = (kaijo[i-1] * i) % MOD;\n\t}\n    long long ret = kaijo[n];\n\tlong long tmp = (kaijo[r] * kaijo[n-r]) % MOD;\n    return mod_div(ret,tmp);\n}\n\nint main(){\n\tint a,b,c,x,y;\n\t\n\twhile(cin >> a >> b >> c >> x >> y,a+b+c+x+y){\n\t\t\n\t\tll ans = 0;\n\t\tfor(int i = 0;i <= min(x+y);i++){\n\t\t\tint X = x-i-a;\n\t\t\tint Y = y-i-b;\n\t\t\tif(X < 0 && y < 0)continue;\n\t\t\tll tmp = 1;\n\t\t\ttmp = (tmp * combination(a+b+c,c)) % MOD;\n\t\t\ttmp = (tmp * combination(a+b,b)) % MOD;\n\t\t\ttmp = (tmp * combination(a+b+c+i-1,i)) % MOD;\n\t\t\ttmp = (tmp * combination(a+X-1,X)) % MOD;\n\t\t\ttmp = (tmp * combination(b+Y-1,Y)) % MOD;\n\t\t\tans = (ans+tmp) % MOD;\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2751 Baseball\n// 2018.2.2 bal4u\n\n#include <stdio.h>\n\n#define M 1000000007\n#define N 4000000\n\nint fact[N+2], inv[N+2], factinv[N+2];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint comb(int n, int k)\n{\n\tif (n < 0 || k < 0) return 0;\n\treturn (int)((long long)fact[n] * factinv[k] % M * factinv[n-k] % M);\n}\n\nint H(int n, int k)\n{\n\tif (!n && !k) return 1;\n    return comb(n+k-1, k);\n}\n\nint main()\n{\n\tint a, b, c, sx, sy, i;\n\tlong long ans, t;\n\n\tfact[0] = 1; for (i = 1; i <= N; i++)\n\t\tfact[i] = (long long)fact[i-1] * i % M;\n\tinv[1] = 1; for (i = 2; i <= N; i++)\n\t\tinv[i] = M - (M / i) * (long long)inv[M % i] % M;\n\tfactinv[0] = 1; for (i = 1; i <= N; i++)\n\t\tfactinv[i] = (long long)factinv[i-1] * inv[i] % M;\n\n\twhile (1) {\n\t\ta = in(), b = in(), c = in(), sx = in(), sy = in();\n\t\tif ((a|b|c|sx|sy) == 0) break;\n\n\t\tans = 0;\n\t\tfor (i = 0; i <= sx; i++) {\n\t\t\tt = H(a, i-a);\n\t\t\tt = t * H(b, sy-sx+i-b) % M;\n\t\t\tt = t * H(a+b+c, sx-i) % M;\n\t\t\tans += t;\n\t\t\tif (ans >= M) ans -= M;\n\t\t}\n\t\tans = ans * comb(a+b+c, a) % M;\n\t\tans = ans * comb(b+c, b) % M;\n\t\tprintf(\"%d\\n\", (int)ans);\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2751 Baseball\n// 2018.2.2 bal4u\n\n#include <stdio.h>\n\n#define M 1000000007\n#define N 4000000\n\nint fact[N+2], inv[N+2], factinv[N+2];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint comb(int n, int k)\n{\n\tif (n < 0 || k < 0) return 0;\n\treturn (int)((long long)fact[n] * factinv[k] % M * factinv[n-k] % M);\n}\n\nint H(int n, int k)\n{\n\tif (!n && !k) return 1;\n    return comb(n+k-1, k);\n}\n\nint main()\n{\n\tint a, b, c, sx, sy, i;\n\tlong long ans, t;\n\n\tfact[0] = 1; for (i = 1; i <= N; i++)\n\t\tfact[i] = (long long)fact[i-1] * i % M;\n\tinv[1] = 1; for (i = 2; i <= N; i++)\n\t\tinv[i] = M - (M / i) * (long long)inv[M % i] % M;\n\tfactinv[0] = 1; for (i = 1; i <= N; i++)\n\t\tfactinv[i] = (long long)factinv[i-1] * inv[i] % M;\n\n\twhile (1) {\n\t\ta = in(), b = in(), c = in(), sx = in(), sy = in();\n\t\tif ((a|b|c|sx|sy) == 0) break;\n\n\t\tans = 0;\n\t\tfor (i = a; i <= sx; i++) {\n\t\t\tt = H(a, i-a);\n\t\t\tt = t * H(b, sy-sx+i-b) % M;\n\t\t\tt = t * H(a+b+c, sx-i) % M;\n\t\t\tans += t;\n\t\t\tif (ans >= M) ans -= M;\n\t\t}\n\t\tans = ans * comb(a+b+c, a) % M;\n\t\tans = ans * comb(b+c, b) % M;\n\t\tprintf(\"%d\\n\", (int)ans);\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define M 5000000\n#define MOD 1000000007\nint inv[M],fact[M],factr[M];\nint comb(int n,int k){\n\tif(k<0||n<k)return 0;\n\treturn (long long)fact[n]*factr[k]%MOD*factr[n-k]%MOD;\n}\nint h(int n,int k){return comb(n+k-1,k);}\nint main(){\n\tint a,b,c,sx,sy,i,d,w,r;\n\tfor(i=0;i<M;i++)inv[i]=fact[i]=factr[i]=1;\n\tfor(i=2;i<M;i++){\n\t\tinv[i]=(long long)(MOD-MOD/i)*inv[MOD%i]%MOD;\n\t\tfact[i]=(long long)fact[i-1]*i%MOD;\n\t\tfactr[i]=(long long)inv[i]*factr[i-1]%MOD;\n\t}\n\tfor(;scanf(\"%d%d%d%d%d\",&a,&b,&c,&sx,&sy),a+b+c;){\n\t\tif(sx<sy || (sx==sy&&a<b)){\n\t\t\ta^=b,b^=a,a^=b;\n\t\t\tsx^=sy,sy^=sx,sx^=sy;\n\t\t}\n\t\td=sx-sy,r=0;\n\t\tif(a==0){\n\t\t\t//x??????????????????????????????????????????????????§???x??????????????????0????????°y??????????????????0??§???????????°?????????\n\t\t\tr=(b>0||sx!=sy) ? 0 : h(c,sx);\n\t\t}else if(b==0){\n\t\t\tr=h(a,d-a)*h(a+b+c,sx-d);\n\t\t}else{\n\t\t\tfor(w=a>d+b?a:d+b;w<=sx;w++){\n\t\t\t\tr=((long long)h(a,w-a)*h(b,w-d-b)%MOD*h(a+b+c,sx-w)+r)%MOD;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",(int)((long long)r*comb(a+b+c,a)%MOD*comb(b+c,b)%MOD));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2751 Baseball\n// 2018.2.2 bal4u\n\n#include <stdio.h>\n\n#define M 1000000007\n#define N1 4000000\n#define N2 2999999\n\nint fact[N1+2], inv[N2+2], factinv[N2+2];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint comb(int n, int k)\n{\n\tif (n < 0 || k < 0) return 0;\n\treturn (int)((long long)fact[n] * factinv[k] % M * factinv[n-k] % M);\n}\n\nint H(int n, int k)\n{\n\tif (!n && !k) return 1;\n    return comb(n+k-1, k);\n}\n\nint main()\n{\n\tint a, b, c, sx, sy, i;\n\tlong long ans, t;\n\n\tfact[0] = 1; for (i = 1; i <= N1; i++)\n\t\tfact[i] = (long long)fact[i-1] * i % M;\n\tinv[1] = 1; for (i = 2; i <= N2; i++)\n\t\tinv[i] = M - (M / i) * (long long)inv[M % i] % M;\n\tfactinv[0] = 1; for (i = 1; i <= N2; i++)\n\t\tfactinv[i] = (long long)factinv[i-1] * inv[i] % M;\n\n\twhile (1) {\n\t\ta = in(), b = in(), c = in(), sx = in(), sy = in();\n\t\tif ((a|b|c|sx|sy) == 0) break;\n\n\t\tans = 0;\n\t\tfor (i = a; i <= sx; i++) {\n\t\t\tt = H(a, i-a);\n\t\t\tt = t * H(b, sy-sx+i-b) % M;\n\t\t\tt = t * H(a+b+c, sx-i) % M;\n\t\t\tans += t;\n\t\t\tif (ans >= M) ans -= M;\n\t\t}\n\t\tans = ans * comb(a+b+c, a) % M;\n\t\tans = ans * comb(b+c, b) % M;\n\t\tprintf(\"%d\\n\", (int)ans);\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\nM=5000000\nMOD=1000000007\ninv=[1]*M\nfact=[1]*M\nfactr=[1]*M\n2.upto(M-1){|i|\n\tinv[i]=(MOD-MOD/i)*inv[MOD%i]%MOD\n\tfact[i]=i*fact[i-1]%MOD\n\tfactr[i]=inv[i]*factr[i-1]%MOD\n}\ncomb=->n,k{\n\treturn 0 if k<0||n<k\n\tfact[n]*factr[k]*factr[n-k]%MOD\n}\nh=->n,k{comb[n+k-1,k]}\n\nloop{\n\ta,b,c,sx,sy=gets.split.map(&:to_i)\n\tbreak if a+b+c==0\n\tif sx<sy || (sx==sy&&a<b)\n\t\ta,b=b,a\n\t\tsx,sy=sy,sx\n\tend\n\td=sx-sy\n\tr=0\n\tif a==0 # x??????????????????????????????????????????????????§???x??????????????????0????????°y??????????????????0??§???????????°?????????\n\t\tif b>0 || sx!=sy\n\t\t\tr=0\n\t\telse\n\t\t\tr=h[c,sx]\n\t\tend\n\telsif b==0\n\t\tr=z=h[a,d-a]*h[a+b+c,sx-d]\n\telse\n\t\t([a,d+b].max..sx).each{|w|\n\t\t\tr=(r+h[a,w-a]*h[b,w-d-b]*h[a+b+c,sx-w])%MOD\n\t\t}\n\tend\n\tp r*comb[a+b+c,a]*comb[b+c,b]%MOD\n}"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\nMOD = 10**9 + 7\n\nL = 4 * 10**6\nfact = [1]*(L+1)\nrfact = [1]*(L+1)\nr = 1\nfor i in range(1, L+1):\n  fact[i] = r = r * i % MOD\nrfact[L] = r = pow(fact[L], MOD-2, MOD)\nfor i in range(L, 0, -1):\n  rfact[i-1] = r = r * i % MOD\n\ndef solve():\n    A, B, C, Sx, Sy = map(int, readline().split())\n    if A+B+C == 0:\n        return False\n    if not Sx > Sy:\n        A, B = B, A\n        Sx, Sy = Sy, Sx\n    Sd = Sx - Sy\n    K = Sy\n    zero = False\n    if A == 0:\n        if B > 0 or Sd != 0:\n            zero = True\n        else:\n            K = 0\n    elif B == 0:\n        K = 0\n\n    if zero:\n        write(\"0\\n\")\n        return True\n\n    res = 0\n    for k in range(K+1):\n        if Sd+k < A or k < B:\n            continue\n        r = fact[Sd + k-1] * rfact[Sd + k - A] % MOD\n        r = r * (fact[k-1] * rfact[k - B] % MOD) % MOD\n        r = r * (fact[Sy-k + A+B+C-1] * rfact[Sy-k] % MOD) % MOD\n        res += r\n    res %= MOD\n    res = res * (fact[A+B+C] * rfact[A] % MOD) % MOD\n    res = res * (rfact[B] * rfact[C] % MOD) % MOD\n    res = res * (rfact[A-1] * rfact[B-1] % MOD) % MOD\n    res = res * rfact[A+B+C-1] % MOD\n    write(\"%d\\n\" % res)\n    return True\nwhile solve():\n    ...\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Read, Write, BufWriter};\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\nconst MOD: i64 = 1_000_000_007;\n/// Refers external ::MOD.\n/// Verified by: https://beta.atcoder.jp/contests/arc099/submissions/2893648\nmod mod_int {\n    use ::MOD;\n    use std::ops::*;\n    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt { pub x: i64 }\n    impl ModInt {\n        fn check_integrity(self) {\n            debug_assert!(self.x >= 0);\n            debug_assert!(self.x < MOD);\n        }\n        // x >= 0\n        pub fn new<T: Into<i64>>(x: T) -> Self { ModInt { x: x.into() % MOD } }\n        #[allow(dead_code)]\n        pub fn mul_fast(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            ModInt { x: self.x * other.x % MOD }\n        }\n        #[allow(dead_code)]\n        pub fn mul_slow(self, other: Self) -> Self {\n            // Naive multiplication in order to avoid overflow\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = ModInt::new(0);\n            let mut cur = self;\n            let mut e = other.x;\n            if self.x < other.x {\n                cur = other;\n                e = self.x;\n            }\n            while e > 0 {\n                if e % 2 == 1 {\n                    sum = sum + cur;\n                }\n                cur = cur + cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            self.check_integrity();\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new(1);\n            let mut cur = ModInt::new(self.x);\n            while e > 0 {\n                if e % 2 != 0 {\n                    sum = sum * cur;\n                }\n                cur = cur * cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn inv(self) -> Self { self.pow(MOD - 2) }\n    }\n    impl Add for ModInt {\n        type Output = Self;\n        fn add(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x + other.x;\n            if sum >= MOD { sum -= MOD; }\n            ModInt { x: sum }\n        }\n    }\n    impl Sub for ModInt {\n        type Output = Self;\n        fn sub(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += MOD; }\n            ModInt { x: sum }\n        }\n    }\n    impl Mul for ModInt {\n        type Output = Self;\n        fn mul(self, other: Self) -> Self {\n            self.mul_fast(other)\n        }\n    }\n    impl AddAssign for ModInt {\n        fn add_assign(&mut self, rhs: ModInt) { *self = *self + rhs; }\n    }\n    impl SubAssign for ModInt {\n        fn sub_assign(&mut self, rhs: ModInt) { *self = *self - rhs; }\n    }\n    impl MulAssign for ModInt {\n        fn mul_assign(&mut self, rhs: ModInt) { *self = *self * rhs; }\n    }\n    impl ::std::fmt::Display for ModInt {\n        fn fmt(&self, f: &mut::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n} // mod mod_int\n\nuse mod_int::*;\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($format:expr) => (write!(out,$format).unwrap());\n        ($format:expr, $($args:expr),+) => (write!(out,$format,$($args),*).unwrap())\n    }\n    const N: usize = 4000000;\n    let mut fac = [ModInt::new(1); N];\n    let mut invfac = [ModInt::new(0); N];\n    for i in 1 .. N {\n        fac[i] = fac[i - 1] * ModInt::new(i as i64);\n    }\n    invfac[N - 1] = fac[N - 1].inv();\n    for i in (0 .. N - 1).rev() {\n        invfac[i] = invfac[i + 1] * ModInt::new(i as i64 + 1);\n    }\n    macro_rules! distr {\n        ($a: expr, $b: expr) => {{\n            let a = $a as usize;\n            let b = $b as usize;\n            if b == 0 {\n                ModInt::new(if a == 0 { 1 } else { 0 })\n            } else {\n                fac[a + b - 1] * invfac[a] * invfac[b - 1]\n            }\n        }};\n    }\n    loop {\n        let a: i64 = get();\n        let b: i64 = get();\n        let c: i64 = get();\n        let mut sx: i64 = get();\n        let mut sy: i64 = get();\n        if a == 0 && b == 0 && c == 0 { break; }\n        let mut ans = ModInt::new(0);\n        sx -= a;\n        sy -= b;\n        if sx >= 0 && sy >= 0 {\n            for u in 0 .. min(sx, sy) + 1 {\n                let mut tmp = distr!(sx - u, a);\n                tmp *= distr!(sy - u, b);\n                tmp *= distr!(u, a + b + c);\n                ans += tmp;\n            }\n        }\n        let a = a as usize;\n        let b = b as usize;\n        let c = c as usize;\n        ans *= fac[a + b + c] * invfac[a] * invfac[b] * invfac[c];\n        puts!(\"{}\\n\", ans);\n    }\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n\n"
  }
]