[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MOD 998244353\n\nint main() {\n    int N, i, j, k;\n    scanf(\"%d\", &N);\n    \n    int* x = malloc(N * sizeof(int));\n    int* y = malloc(N * sizeof(int));\n    \n    for (i = 0; i < N; i++) {\n        scanf(\"%d %d\", &x[i], &y[i]);\n    }\n    \n    long long total = 0;\n    \n    for (i = 0; i < (1 << N); i++) {\n        if (i == 0) continue;\n        \n        int minx = INT_MAX, maxx = INT_MIN;\n        int miny = INT_MAX, maxy = INT_MIN;\n        int count = 0;\n        \n        for (j = 0; j < N; j++) {\n            if (i & (1 << j)) {\n                minx = (x[j] < minx) ? x[j] : minx;\n                maxx = (x[j] > maxx) ? x[j] : maxx;\n                miny = (y[j] < miny) ? y[j] : miny;\n                maxy = (y[j] > maxy) ? y[j] : maxy;\n                count++;\n            }\n        }\n        \n        total += count;\n    }\n    \n    printf(\"%lld\\n\", total % MOD);\n    \n    free(x);\n    free(y);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:45:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MOD 998244353\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint compareX(const void *a, const void *b) {\n    Point *p1 = (Point *)a;\n    Point *p2 = (Point *)b;\n    return p1->x - p2->x;\n}\n\nint compareY(const void *a, const void *b) {\n    Point *p1 = (Point *)a;\n    Point *p2 = (Point *)b;\n    return p1->y - p2->y;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Point *points = (Point *)malloc(N * sizeof(Point));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &points[i].x, &points[i].y);\n    }\n\n    // Precompute powers of 2 modulo MOD\n    long long *pow2 = (long long *)malloc((N + 1) * sizeof(long long));\n    pow2[0] = 1;\n    for (int i = 1; i <= N; i++) {\n        pow2[i] = (pow2[i - 1] * 2) % MOD;\n    }\n\n    // Sort points by x and y coordinates\n    Point *sortedX = (Point *)malloc(N * sizeof(Point));\n    Point *sortedY = (Point *)malloc(N * sizeof(Point));\n    for (int i = 0; i < N; i++) {\n        sortedX[i] = points[i];\n        sortedY[i] = points[i];\n    }\n    qsort(sortedX, N, sizeof(Point), compareX);\n    qsort(sortedY, N, sizeof(Point), compareY);\n\n    long long total = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = i; j < N; j++) {\n            for (int k = 0; k < N; k++) {\n                for (int l = k; l < N; l++) {\n                    int minX = sortedX[i].x;\n                    int maxX = sortedX[j].x;\n                    int minY = sortedY[k].y;\n                    int maxY = sortedY[l].y;\n                    int cnt = 0;\n                    for (int m = 0; m < N; m++) {\n                        if (points[m].x >= minX && points[m].x <= maxX &&\n                            points[m].y >= minY && points[m].y <= maxY) {\n                            cnt++;\n                        }\n                    }\n                    if (cnt > 0) {\n                        total = (total + pow2[cnt - 1]) % MOD;\n                    }\n                }\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", total);\n    free(points);\n    free(pow2);\n    free(sortedX);\n    free(sortedY);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:45:33"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cassert>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<pair<int, int>> points(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> points[i].first >> points[i].second;\n    }\n\n    sort(points.begin(), points.end());\n    vector<int> x(N), y(N);\n    for (int i = 0; i < N; ++i) {\n        x[i] = points[i].first;\n        y[i] = points[i].second;\n    }\n\n    vector<int> order(N);\n    for (int i = 0; i < N; ++i) {\n        order[i] = i;\n    }\n    sort(order.begin(), order.end(), [&](int i, int j) {\n        return y[i] < y[j];\n    });\n\n    vector<int> rank(N);\n    for (int i = 0; i < N; ++i) {\n        rank[order[i]] = i;\n    }\n\n    long long total = 0;\n    for (int l = 0; l < N; ++l) {\n        for (int r = l; r < N; ++r) {\n            int min_x = x[l];\n            int max_x = x[r];\n            int min_y = y[l];\n            int max_y = y[r];\n            for (int i = l; i <= r; ++i) {\n                min_y = min(min_y, y[i]);\n                max_y = max(max_y, y[i]);\n            }\n\n            int cnt = 0;\n            for (int i = 0; i < N; ++i) {\n                if (x[i] >= min_x && x[i] <= max_x && y[i] >= min_y && y[i] <= max_y) {\n                    cnt++;\n                }\n            }\n\n            long long subsets = 1;\n            for (int i = 0; i < cnt; ++i) {\n                subsets = (subsets * 2) % MOD;\n            }\n            subsets = (subsets - 1 + MOD) % MOD;\n            total = (total + subsets) % MOD;\n        }\n    }\n\n    cout << total << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:45:54"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final long MOD = 998244353;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int N = Integer.parseInt(br.readLine());\n        int[][] points = new int[N][2];\n        for (int i = 0; i < N; i++) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            points[i][0] = Integer.parseInt(st.nextToken());\n            points[i][1] = Integer.parseInt(st.nextToken());\n        }\n        \n        Arrays.sort(points, (a, b) -> Integer.compare(a[0], b[0]));\n        int[] x = new int[N];\n        int[] y = new int[N];\n        for (int i = 0; i < N; i++) {\n            x[i] = points[i][0];\n            y[i] = points[i][1];\n        }\n        \n        long[] pow2 = new long[N + 1];\n        pow2[0] = 1;\n        for (int i = 1; i <= N; i++) {\n            pow2[i] = pow2[i - 1] * 2 % MOD;\n        }\n        \n        long total = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = i; j < N; j++) {\n                int minX = x[i];\n                int maxX = x[j];\n                int minY = y[i];\n                int maxY = y[i];\n                for (int k = i; k <= j; k++) {\n                    if (y[k] < minY) minY = y[k];\n                    if (y[k] > maxY) maxY = y[k];\n                }\n                \n                int cnt = 0;\n                int left = 0, right = N - 1;\n                while (left <= right) {\n                    int mid = (left + right) / 2;\n                    if (x[mid] >= minX) {\n                        right = mid - 1;\n                    } else {\n                        left = mid + 1;\n                    }\n                }\n                int Lx = left;\n                left = 0; right = N - 1;\n                while (left <= right) {\n                    int mid = (left + right) / 2;\n                    if (x[mid] <= maxX) {\n                        left = mid + 1;\n                    } else {\n                        right = mid - 1;\n                    }\n                }\n                int Rx = right;\n                \n                List<Integer> ysInRange = new ArrayList<>();\n                for (int k = Lx; k <= Rx; k++) {\n                    if (y[k] >= minY && y[k] <= maxY) {\n                        ysInRange.add(y[k]);\n                    }\n                }\n                Collections.sort(ysInRange);\n                minY = ysInRange.get(0);\n                maxY = ysInRange.get(ysInRange.size() - 1);\n                \n                int Ly = 0, Ry = ysInRange.size() - 1;\n                for (int k = 0; k < ysInRange.size(); k++) {\n                    if (ysInRange.get(k) >= minY) {\n                        Ly = k;\n                        break;\n                    }\n                }\n                for (int k = ysInRange.size() - 1; k >= 0; k--) {\n                    if (ysInRange.get(k) <= maxY) {\n                        Ry = k;\n                        break;\n                    }\n                }\n                \n                cnt = Ry - Ly + 1;\n                int m = cnt;\n                int k = j - i + 1;\n                int a = 0;\n                for (int p = i; p <= j; p++) {\n                    if (y[p] >= minY && y[p] <= maxY) {\n                        a++;\n                    }\n                }\n                int b = 0;\n                for (int p = 0; p < N; p++) {\n                    if (x[p] >= minX && x[p] <= maxX && y[p] >= minY && y[p] <= maxY) {\n                        b++;\n                    }\n                }\n                m = b;\n                \n                long subsets = (pow2[m] - 1 + MOD) % MOD;\n                total = (total + subsets) % MOD;\n            }\n        }\n        System.out.println(total);\n    }\n}",
    "timestamp": "2025-08-05 22:46:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    static final int MOD = 998244353;\n\n    public static void solve(int[] x, int[] y, int n) {\n        long ans = 0;\n        Arrays.sort(x);\n        Arrays.sort(y);\n\n        for (int mask = 1; mask < (1 << n); mask++) {\n            int minX = Integer.MAX_VALUE, maxX = Integer.MIN_VALUE;\n            int minY = Integer.MAX_VALUE, maxY = Integer.MIN_VALUE;\n\n            for (int i = 0; i < n; i++) {\n                if ((mask & (1 << i)) > 0) {\n                    minX = Math.min(minX, x[i]);\n                    maxX = Math.max(maxX, x[i]);\n                    minY = Math.min(minY, y[i]);\n                    maxY = Math.max(maxY, y[i]);\n                }\n            }\n\n            ans += (long)(maxX - minX + 1) * (maxY - minY + 1);\n            ans %= MOD;\n        }\n\n        System.out.println(ans);\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n\n        int[] x = new int[n];\n        int[] y = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            st = new StringTokenizer(br.readLine());\n            x[i] = Integer.parseInt(st.nextToken());\n            y[i] = Integer.parseInt(st.nextToken());\n        }\n\n        solve(x, y, n);\n    }\n}",
    "timestamp": "2025-08-05 22:46:32"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<int> x(N), y(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> x[i] >> y[i];\n    }\n    \n    long long total_sum = 0;\n    \n    for (int mask = 1; mask < (1 << N); ++mask) {\n        int min_x = INT_MAX, max_x = INT_MIN;\n        int min_y = INT_MAX, max_y = INT_MIN;\n        \n        for (int j = 0; j < N; ++j) {\n            if (mask & (1 << j)) {\n                min_x = min(min_x, x[j]);\n                max_x = max(max_x, x[j]);\n                min_y = min(min_y, y[j]);\n                max_y = max(max_y, y[j]);\n            }\n        }\n        \n        int points_in_rect = __builtin_popcount(mask);\n        total_sum += points_in_rect;\n    }\n    \n    cout << total_sum % MOD << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:46:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import combinations\n\ndef sum_of_f(S):\n    mod = 998244353\n    N = len(S)\n    total_sum = 0\n\n    for subset_size in range(1, N + 1):\n        for subset in combinations(S, subset_size):\n            xmin = min(p[0] for p in subset)\n            xmax = max(p[0] for p in subset)\n            ymin = min(p[1] for p in subset)\n            ymax = max(p[1] for p in subset)\n            \n            count = sum(1 for p in S if xmin <= p[0] <= xmax and ymin <= p[1] <= ymax)\n            total_sum = (total_sum + count) % mod\n\n    return total_sum\n\n# Example usage:\n# S = [(1, 3), (2, 5), (4, 8)]\n# print(sum_of_f(S))",
    "timestamp": "2025-08-13 12:27:11"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class PointsSubsetSum {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        \n        // Read the points\n        Point[] points = new Point[N];\n        for (int i = 0; i < N; i++) {\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n            points[i] = new Point(x, y);\n        }\n        \n        // Sort points by x-coordinate\n        Arrays.sort(points, Comparator.comparingInt(p -> p.x));\n        \n        // Precompute powers of 2 modulo 998244353\n        long[] pow2 = new long[N + 1];\n        pow2[0] = 1;\n        for (int i = 1; i <= N; ++i) {\n            pow2[i] = pow2[i - 1] * 2 % 998244353;\n        }\n        \n        // Calculate sum of f(T) over all non-empty subsets T\n        long sumF = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = i; j < N; j++) {\n                // Determine the bounding rectangle for points[i] to points[j]\n                int minY = Integer.MAX_VALUE, maxY = Integer.MIN_VALUE;\n                for (int k = i; k <= j; k++) {\n                    minY = Math.min(minY, points[k].y);\n                    maxY = Math.max(maxY, points[k].y);\n                }\n                \n                // Calculate number of points in the range\n                int count = j - i + 1;\n                \n                // Number of valid subsets T within the range\n                long numSubsets = pow2[j - i + 1] - 1;\n                \n                // Add to the sumF\n                sumF = (sumF + count * numSubsets % 998244353) % 998244353;\n            }\n        }\n        \n        // Print the result\n        System.out.println(sumF);\n    }\n    \n    static class Point {\n        int x, y;\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n}",
    "timestamp": "2025-08-13 12:27:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MOD 998244353\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint compareX(const void* a, const void* b) {\n    return ((Point*)a)->x - ((Point*)b)->x;\n}\n\nint compareY(const void* a, const void* b) {\n    return ((Point*)a)->y - ((Point*)b)->y;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Point points[N];\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &points[i].x, &points[i].y);\n    }\n    \n    qsort(points, N, sizeof(Point), compareX);\n    long long pow2[N];\n    pow2[0] = 1;\n    for (int i = 1; i < N; i++) {\n        pow2[i] = (pow2[i - 1] * 2) % MOD;\n    }\n    \n    long long result = 0;\n    for (int lx = 0; lx < N; lx++) {\n        for (int rx = lx; rx < N; rx++) {\n            int ly_idx = 0, ry_idx = 0;\n            Point temp[rx - lx + 1];\n            for (int i = lx; i <= rx; i++) {\n                temp[i - lx] = points[i];\n            }\n            qsort(temp, rx - lx + 1, sizeof(Point), compareY);\n            \n            while (ry_idx < rx - lx + 1) {\n                while (ly_idx <= ry_idx) {\n                    int num_points = ry_idx - ly_idx + 1;\n                    result = (result + (pow2[lx] * pow2[N - rx - 1] % MOD) * (pow2[ly_idx] * pow2[N - ry_idx - 1] % MOD) % MOD * num_points % MOD) % MOD;\n                    ly_idx++;\n                }\n                ry_idx++;\n                ly_idx = 0;\n            }\n        }\n    }\n    \n    printf(\"%lld\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-13 12:27:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function sumOfF(S) {\n    const MOD = 998244353;\n    const N = S.length;\n    let sum = 0;\n    \n    S.sort((a, b) => a[0] - b[0]);\n    const xSorted = S.map(p => p[0]);\n    const xRank = new Map(xSorted.map((x, i) => [x, i]));\n\n    S.sort((a, b) => a[1] - b[1]);\n    const ySorted = S.map(p => p[1]);\n    const yRank = new Map(ySorted.map((y, i) => [y, i]));\n\n    const powerOfTwo = new Array(N + 1);\n    powerOfTwo[0] = 1;\n    for (let i = 1; i <= N; i++) {\n        powerOfTwo[i] = (powerOfTwo[i - 1] * 2) % MOD;\n    }\n\n    for (let {0:x, 1:y} of S) {\n        const l = xRank.get(x);\n        const r = xRank.size - l - 1;\n        const d = yRank.get(y);\n        const u = yRank.size - d - 1;\n\n        const leftSubsets = (powerOfTwo[l] - 1 + MOD) % MOD;\n        const rightSubsets = (powerOfTwo[r] - 1 + MOD) % MOD;\n        const downSubsets = (powerOfTwo[d] - 1 + MOD) % MOD;\n        const upSubsets = (powerOfTwo[u] - 1 + MOD) % MOD;\n\n        const count = (leftSubsets * rightSubsets % MOD) * \n                      (downSubsets * upSubsets % MOD) % MOD;\n\n        sum = (sum + count) % MOD;\n    }\n\n    return sum;\n}\n\n// Example usage\nconst S = [[1, 2], [2, 3], [3, 1], [4, 4]];\nconsole.log(sumOfF(S)); // Output: result",
    "timestamp": "2025-08-13 12:27:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(N, points):\n    MOD = 998244353\n    points.sort()\n    \n    result = 0\n    for mask in range(1, 1 << N):\n        subset = []\n        for j in range(N):\n            if mask & (1 << j):\n                subset.append(points[j])\n        \n        min_x = min(p[0] for p in subset)\n        max_x = max(p[0] for p in subset)\n        min_y = min(p[1] for p in subset)\n        max_y = max(p[1] for p in subset)\n        \n        rectangle_points = (max_x - min_x + 1) * (max_y - min_y + 1)\n        result = (result + rectangle_points) % MOD\n    \n    return result\n\ndef main():\n    N = int(input())\n    points = []\n    for _ in range(N):\n        x, y = map(int, input().split())\n        points.append((x, y))\n    \n    print(solve(N, points))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 12:27:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(points) {\n    const n = points.length;\n    const mod = 998244353;\n    let totalSum = 0n;\n\n    for (let mask = 1; mask < (1 << n); mask++) {\n        let minX = Infinity, maxX = -Infinity;\n        let minY = Infinity, maxY = -Infinity;\n\n        for (let i = 0; i < n; i++) {\n            if (mask & (1 << i)) {\n                minX = Math.min(minX, points[i][0]);\n                maxX = Math.max(maxX, points[i][0]);\n                minY = Math.min(minY, points[i][1]);\n                maxY = Math.max(maxY, points[i][1]);\n            }\n        }\n\n        const rectangleArea = (maxX - minX + 1) * (maxY - minY + 1);\n        totalSum += BigInt(rectangleArea);\n    }\n\n    return Number(totalSum % BigInt(mod));\n}",
    "timestamp": "2025-08-13 12:28:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 998244353\n\ndef solve():\n    N = int(sys.stdin.readline())\n    points = []\n    for _ in range(N):\n        x, y = map(int, sys.stdin.readline().split())\n        points.append((x, y))\n    \n    points.sort()\n    x_coords = [x for x, y in points]\n    y_coords = [y for x, y in points]\n    \n    # Precompute factorial, inverse factorial for combinations\n    max_n = N\n    fact = [1] * (max_n + 1)\n    inv_fact = [1] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        fact[i] = fact[i-1] * i % MOD\n    inv_fact[max_n] = pow(fact[max_n], MOD-2, MOD)\n    for i in range(max_n - 1, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n    \n    def comb(n, k):\n        if n < 0 or k < 0 or k > n:\n            return 0\n        return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD\n    \n    total = 0\n    \n    # Precompute for x and y\n    for i in range(N):\n        for j in range(i, N):\n            x_min = x_coords[i]\n            x_max = x_coords[j]\n            y_sorted = []\n            for k in range(N):\n                if x_coords[k] >= x_min and x_coords[k] <= x_max:\n                    y_sorted.append(y_coords[k])\n            y_sorted.sort()\n            m = len(y_sorted)\n            for a in range(m):\n                for b in range(a, m):\n                    y_min = y_sorted[a]\n                    y_max = y_sorted[b]\n                    cnt = 0\n                    for k in range(N):\n                        if (x_coords[k] >= x_min and x_coords[k] <= x_max and\n                            y_coords[k] >= y_min and y_coords[k] <= y_max):\n                            cnt += 1\n                    if cnt > 0:\n                        total = (total + cnt * pow(2, N - cnt, MOD)) % MOD\n    \n    print(total)\n\nsolve()",
    "timestamp": "2025-08-13 12:28:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 998244353;\n\nfunction solve() {\n    const readline = require('readline');\n    const rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout\n    });\n\n    let N = 0;\n    let points = [];\n\n    rl.on('line', (line) => {\n        if (N === 0) {\n            N = parseInt(line.trim(), 10);\n        } else {\n            const [x, y] = line.trim().split(' ').map(Number);\n            points.push({ x, y });\n            if (points.length === N) {\n                rl.close();\n            }\n        }\n    });\n\n    rl.on('close', () => {\n        points.sort((a, b) => a.x - b.x);\n        const xIndices = new Array(N);\n        for (let i = 0; i < N; i++) {\n            xIndices[i] = i + 1;\n        }\n\n        points.sort((a, b) => a.y - b.y);\n        const yIndices = new Array(N);\n        for (let i = 0; i < N; i++) {\n            yIndices[i] = i + 1;\n        }\n\n        points.sort((a, b) => a.x - b.x);\n        const xCoords = points.map(p => p.x);\n        const yCoords = points.map(p => p.y);\n\n        let total = 0;\n        const pow2 = new Array(N + 1);\n        pow2[0] = 1;\n        for (let i = 1; i <= N; i++) {\n            pow2[i] = (pow2[i - 1] * 2) % MOD;\n        }\n\n        for (let i = 0; i < N; i++) {\n            for (let j = i; j < N; j++) {\n                for (let k = 0; k < N; k++) {\n                    for (let l = k; l < N; l++) {\n                        const minX = xCoords[i];\n                        const maxX = xCoords[j];\n                        const minY = yCoords[k];\n                        const maxY = yCoords[l];\n                        let count = 0;\n                        for (let m = 0; m < N; m++) {\n                            if (xCoords[m] >= minX && xCoords[m] <= maxX && yCoords[m] >= minY && yCoords[m] <= maxY) {\n                                count++;\n                            }\n                        }\n                        if (count > 0) {\n                            total = (total + pow2[count - 1]) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n\n        console.log(total);\n    });\n}\n\nsolve();",
    "timestamp": "2025-08-13 12:28:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nconst int MOD = 998244353;\n\nint main() {\n    int N;\n    std::cin >> N;\n    \n    std::vector<int> x(N), y(N);\n    for (int i = 0; i < N; ++i) {\n        std::cin >> x[i] >> y[i];\n    }\n    \n    std::sort(x.begin(), x.end());\n    std::sort(y.begin(), y.end());\n    \n    std::vector<long long> pow2(N + 1, 1);\n    for (int i = 1; i <= N; ++i) {\n        pow2[i] = pow2[i - 1] * 2 % MOD;\n    }\n    \n    long long sumX = 0, sumY = 0;\n    for (int i = 0; i < N; ++i) {\n        sumX = (sumX + x[i] * (pow2[i] - pow2[N - 1 - i])) % MOD;\n        sumY = (sumY + y[i] * (pow2[i] - pow2[N - 1 - i])) % MOD;\n    }\n    \n    long long result = sumX * sumY % MOD;\n    if (result < 0) result += MOD;\n    \n    std::cout << result << std::endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 14:34:41"
  }
]