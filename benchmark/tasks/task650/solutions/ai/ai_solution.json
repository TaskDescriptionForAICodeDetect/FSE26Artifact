[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_N 200\n#define MAX_K 100000\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n\n    int C[MAX_N + 1];\n    int P[MAX_N + 1];\n\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &C[i]);\n    }\n\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &P[i]);\n    }\n\n    int max_score = 0;\n\n    for (int start = 1; start <= N; start++) {\n        int visited[MAX_N + 1];\n        memset(visited, 0, sizeof(visited));\n\n        int current = start;\n        int score = 0;\n        int moves = 0;\n        int cycle_found = 0;\n\n        while (moves < K) {\n            if (visited[current]) {\n                cycle_found = 1;\n                break;\n            }\n\n            visited[current] = 1;\n            score += C[current];\n            current = P[current];\n            moves++;\n        }\n\n        if (cycle_found) {\n            int cycle_length = 0;\n            int temp = current;\n            do {\n                cycle_length++;\n                temp = P[temp];\n            } while (temp != current);\n\n            int remaining_moves = K - moves;\n            int cycle_score = 0;\n            temp = current;\n            for (int i = 0; i < cycle_length; i++) {\n                cycle_score += C[temp];\n                temp = P[temp];\n            }\n\n            int full_cycles = remaining_moves / cycle_length;\n            int extra_moves = remaining_moves % cycle_length;\n\n            score += full_cycles * cycle_score;\n\n            temp = current;\n            for (int i = 0; i < extra_moves; i++) {\n                score += C[temp];\n                temp = P[temp];\n            }\n        }\n\n        if (score > max_score) {\n            max_score = score;\n        }\n    }\n\n    printf(\"%d\\n\", max_score);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:25:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 5000\n\nlong long max(long long a, long long b) {\n    return (a > b) ? a : b;\n}\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n    int P[MAX_N + 1];\n    long long C[MAX_N + 1];\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &P[i]);\n    }\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%lld\", &C[i]);\n    }\n\n    long long max_score = LLONG_MIN;\n\n    for (int start = 1; start <= N; start++) {\n        int current_pos = start;\n        long long cycle_sum = 0;\n        int cycle_length = 0;\n\n        // Calculate cycle sum and length\n        while (1) {\n            current_pos = P[current_pos];\n            cycle_sum += C[current_pos];\n            cycle_length++;\n            if (current_pos == start) break;\n        }\n\n        long long current_score = 0;\n        current_pos = start;\n        long long path_score = 0;\n\n        for (int move = 1; move <= cycle_length; move++) {\n            if (move > K) break;\n            current_pos = P[current_pos];\n            path_score += C[current_pos];\n            long long remaining_moves = K - move;\n            if (cycle_sum > 0) {\n                long long full_cycles = remaining_moves / cycle_length;\n                current_score = path_score + full_cycles * cycle_sum;\n            } else {\n                current_score = path_score;\n            }\n            max_score = max(max_score, current_score);\n        }\n    }\n\n    printf(\"%lld\\n\", max_score);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:26:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    vector<int> P(N + 1), C(N + 1);\n    for (int i = 1; i <= N; ++i) cin >> P[i];\n    for (int i = 1; i <= N; ++i) cin >> C[i];\n\n    long long max_score = -1e18;\n\n    for (int start = 1; start <= N; ++start) {\n        int current = start;\n        long long cycle_sum = 0;\n        int cycle_len = 0;\n        vector<long long> scores;\n\n        while (true) {\n            current = P[current];\n            cycle_sum += C[current];\n            scores.push_back(C[current]);\n            cycle_len++;\n            if (current == start) break;\n        }\n\n        long long current_max = -1e18;\n        long long partial_sum = 0;\n\n        for (int i = 0; i < cycle_len; ++i) {\n            if (i + 1 > K) break;\n            partial_sum += scores[i];\n            current_max = max(current_max, partial_sum);\n            if (cycle_sum > 0) {\n                long long full_cycles = (K - (i + 1)) / cycle_len;\n                current_max = max(current_max, partial_sum + full_cycles * cycle_sum);\n            }\n        }\n\n        max_score = max(max_score, current_max);\n    }\n\n    cout << max_score << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:26:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int K = sc.nextInt();\n        int[] P = new int[N + 1];\n        int[] C = new int[N + 1];\n        for (int i = 1; i <= N; i++) P[i] = sc.nextInt();\n        for (int i = 1; i <= N; i++) C[i] = sc.nextInt();\n\n        long maxScore = Long.MIN_VALUE;\n\n        for (int start = 1; start <= N; start++) {\n            int current = start;\n            long cycleSum = 0;\n            int cycleLength = 0;\n            List<Integer> cycle = new ArrayList<>();\n\n            while (true) {\n                current = P[current];\n                cycle.add(C[current]);\n                cycleSum += C[current];\n                cycleLength++;\n                if (current == start) break;\n            }\n\n            long currentMax = Long.MIN_VALUE;\n            long pathSum = 0;\n\n            for (int i = 0; i < cycleLength; i++) {\n                if (i + 1 > K) break;\n                pathSum += cycle.get(i);\n                long candidate = pathSum;\n                if (cycleSum > 0) {\n                    long fullCycles = (K - (i + 1)) / cycleLength;\n                    candidate += fullCycles * cycleSum;\n                }\n                if (candidate > currentMax) {\n                    currentMax = candidate;\n                }\n            }\n\n            if (currentMax > maxScore) {\n                maxScore = currentMax;\n            }\n        }\n\n        System.out.println(maxScore);\n    }\n}",
    "timestamp": "2025-08-05 22:26:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        int N = Integer.parseInt(st.nextToken());\n        int K = Integer.parseInt(st.nextToken());\n        \n        int[] C = new int[N + 1];\n        int[] P = new int[N + 1];\n        \n        st = new StringTokenizer(br.readLine());\n        for (int i = 1; i <= N; i++) {\n            C[i] = Integer.parseInt(st.nextToken());\n        }\n        \n        st = new StringTokenizer(br.readLine());\n        for (int i = 1; i <= N; i++) {\n            P[i] = Integer.parseInt(st.nextToken());\n        }\n        \n        int maxScore = 0;\n        \n        for (int start = 1; start <= N; start++) {\n            int[][] dp = new int[K + 1][N + 1];\n            \n            for (int k = 0; k <= K; k++) {\n                for (int pos = 1; pos <= N; pos++) {\n                    if (pos == start && k == 0) {\n                        dp[k][pos] = C[pos];\n                    }\n                    \n                    if (k > 0 && dp[k - 1][pos] > 0) {\n                        int nextPos = P[pos];\n                        dp[k][nextPos] = Math.max(dp[k][nextPos], dp[k - 1][pos] + C[nextPos]);\n                    }\n                    \n                    maxScore = Math.max(maxScore, dp[k][pos]);\n                }\n            }\n        }\n        \n        System.out.println(maxScore);\n    }\n}",
    "timestamp": "2025-08-05 22:26:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    \n    vector<int> C(N + 1);\n    for (int i = 1; i <= N; i++) {\n        cin >> C[i];\n    }\n    \n    vector<int> P(N + 1);\n    for (int i = 1; i <= N; i++) {\n        cin >> P[i];\n    }\n    \n    int maxScore = 0;\n    \n    for (int start = 1; start <= N; start++) {\n        vector<bool> visited(N + 1, false);\n        int currentScore = 0;\n        int current = start;\n        \n        for (int move = 0; move < K; move++) {\n            if (visited[current]) break;\n            \n            visited[current] = true;\n            currentScore += C[current];\n            current = P[current];\n        }\n        \n        maxScore = max(maxScore, currentScore);\n    }\n    \n    cout << maxScore << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:26:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_score(N, K, C, P):\n    def get_cycle_score_and_length(start):\n        visited = set()\n        cycle = []\n        current = start\n        while current not in visited:\n            visited.add(current)\n            cycle.append(current)\n            current = P[current - 1]\n        cycle_score = sum(C[i - 1] for i in cycle)\n        return cycle_score, len(cycle)\n\n    max_possible_score = float('-inf')\n\n    for start in range(1, N + 1):\n        cycle_score, cycle_length = get_cycle_score_and_length(start)\n        current_score = 0\n        current_position = start\n\n        if cycle_score > 0:\n            full_cycles = K // cycle_length\n            remaining_moves = K % cycle_length\n            current_score += full_cycles * cycle_score\n\n            for _ in range(remaining_moves):\n                current_position = P[current_position - 1]\n                current_score += C[current_position - 1]\n                max_possible_score = max(max_possible_score, current_score)\n\n            # Considering if we stop earlier at some position within a full cycle\n            temp_score = 0\n            current_position = start\n            for j in range(min(K, cycle_length)):\n                current_position = P[current_position - 1]\n                temp_score += C[current_position - 1]\n                max_possible_score = max(max_possible_score, temp_score)\n\n            current_score += temp_score\n            max_possible_score = max(max_possible_score, current_score)\n        else:\n            current_position = start\n            temp_score = 0\n            for _ in range(min(K, cycle_length)):\n                current_position = P[current_position - 1]\n                temp_score += C[current_position - 1]\n                max_possible_score = max(max_possible_score, temp_score)\n\n    return max_possible_score\n\n# Example usage:\n# N = 6\n# K = 4\n# C = [3, 2, -3, 5, -5, 10]\n# P = [2, 3, 4, 3, 1, 6]\n# print(max_score(N, K, C, P))  # Output: 12",
    "timestamp": "2025-08-13 10:46:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int N = scanner.nextInt();\n        int K = scanner.nextInt();\n        int[] C = new int[N];\n        int[] P = new int[N];\n\n        for (int i = 0; i < N; i++) {\n            C[i] = scanner.nextInt();\n        }\n        for (int i = 0; i < N; i++) {\n            P[i] = scanner.nextInt() - 1;\n        }\n\n        long maxScore = Long.MIN_VALUE;\n\n        for (int i = 0; i < N; i++) {\n            long score = 0;\n            int currentPosition = i;\n            long cycleScore = 0;\n            int cycleLength = 0;\n            Set<Integer> visited = new HashSet<>();\n\n            while (!visited.contains(currentPosition) && cycleLength < K) {\n                visited.add(currentPosition);\n                currentPosition = P[currentPosition];\n                cycleScore += C[currentPosition];\n                cycleLength++;\n            }\n\n            if (cycleScore > 0 && K > cycleLength) {\n                long completeCycles = (K - cycleLength) / cycleLength;\n                score += completeCycles * cycleScore;\n                long remainingMoves = K - completeCycles * cycleLength;\n\n                for (int j = 0; j < remainingMoves; j++) {\n                    currentPosition = P[currentPosition];\n                    score += C[currentPosition];\n                }\n            } else {\n                long tempScore = 0;\n                currentPosition = i;\n                for (int j = 0; j < K; j++) {\n                    currentPosition = P[currentPosition];\n                    tempScore += C[currentPosition];\n                    score = Math.max(score, tempScore);\n                }\n            }\n\n            maxScore = Math.max(maxScore, score);\n        }\n\n        System.out.println(maxScore);\n    }\n}",
    "timestamp": "2025-08-13 10:46:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define ll long long\n\nll max(ll a, ll b) {\n    return a > b ? a : b;\n}\n\nll findMaxScore(int N, int K, int C[], int P[]) {\n    ll maxScore = 0;\n\n    for (int start = 0; start < N; ++start) {\n        int current = start;\n        ll totalScore = 0;\n        ll cycleScore = 0;\n        int cycleLength = 0;\n\n        int visited[N];\n        for (int i = 0; i < N; ++i) {\n            visited[i] = 0;\n        }\n\n        while (!visited[current]) {\n            visited[current] = 1;\n            current = P[current] - 1;\n            cycleScore += C[current];\n            cycleLength++;\n            if (cycleLength >= K) break;\n        }\n\n        ll sum = 0;\n        for (int i = 0, position = start; i < K && i < cycleLength; ++i) {\n            position = P[position] - 1;\n            sum += C[position];\n            maxScore = max(maxScore, sum);\n        }\n\n        if (cycleLength > 1 && K >= cycleLength) {\n            ll iter = K / cycleLength - 1;\n            ll remainingK = K % cycleLength;\n            totalScore = iter * cycleScore;\n            sum = 0;\n            for (int i = 0, position = start; i < cycleLength + remainingK; ++i) {\n                position = P[position] - 1;\n                sum += C[position];\n                totalScore = max(totalScore, iter * cycleScore + sum);\n            }\n            maxScore = max(maxScore, totalScore);\n        }\n    }\n\n    return maxScore;\n}\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n\n    int C[N];\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%d\", &C[i]);\n    }\n\n    int P[N];\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%d\", &P[i]);\n    }\n\n    ll result = findMaxScore(N, K, C, P);\n    printf(\"%lld\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:46:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function maxScore(N, K, C, P) {\n    let maxScore = Number.NEGATIVE_INFINITY;\n\n    // Iterate over each starting position\n    for (let start = 0; start < N; start++) {\n        let currentScore = 0;\n        let currentIndex = start;\n        let visited = Array(N).fill(false);\n        let cycle = [];\n        \n        // Follow the permutation\n        while (!visited[currentIndex] && cycle.length < K) {\n            visited[currentIndex] = true;\n            currentIndex = P[currentIndex] - 1;\n            cycle.push(currentIndex);\n            currentScore += C[currentIndex];\n        }\n\n        // Check score using all K possible moves\n        if (cycle.length <= K) {\n            maxScore = Math.max(maxScore, currentScore);\n        }\n\n        // Consider cycle additions\n        let cycleSum = cycle.reduce((acc, idx) => acc + C[idx], 0);\n        if (cycleSum > 0) {\n            let fullCycles = Math.floor((K - cycle.length) / cycle.length);\n            currentScore += fullCycles * cycleSum;\n            maxScore = Math.max(maxScore, currentScore);\n        }\n\n        // Explore remaining moves from cycle\n        let remainingMoves = (K - cycle.length) % cycle.length;\n        for (let i = 0; i < remainingMoves; i++) {\n            currentIndex = cycle[i % cycle.length];\n            currentScore += C[currentIndex];\n            maxScore = Math.max(maxScore, currentScore);\n        }\n    }\n\n    return maxScore;\n}",
    "timestamp": "2025-08-13 10:46:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_score(N, K, C, P):\n    # Memoization to store maximum score for each state\n    dp = {}\n    \n    def dfs(curr, moves_left, visited):\n        # Create a state key\n        state = (curr, moves_left, tuple(sorted(visited)))\n        \n        # If state already computed, return memoized result\n        if state in dp:\n            return dp[state]\n        \n        # If no moves left, return 0\n        if moves_left == 0:\n            return 0\n        \n        max_score = 0\n        \n        # Try moving to P[curr-1]\n        next_square = P[curr-1]\n        \n        # If next square not already visited, move and get score\n        if next_square not in visited:\n            new_visited = visited.copy()\n            new_visited.add(next_square)\n            \n            # Recursive call with updated state\n            score = C[next_square-1] + dfs(next_square, moves_left-1, new_visited)\n            max_score = max(max_score, score)\n        \n        # Store and return max score for this state\n        dp[state] = max_score\n        return max_score\n    \n    # Try starting from each square\n    overall_max = 0\n    for start in range(1, N+1):\n        score = dfs(start, K, {start})\n        overall_max = max(overall_max, score)\n    \n    return overall_max\n\n# Read input\nN, K = map(int, input().split())\nC = list(map(int, input().split()))\nP = list(map(int, input().split()))\n\n# Print maximum score\nprint(max_score(N, K, C, P))",
    "timestamp": "2025-08-13 10:46:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function maxScore(N, K, C, P) {\n    let maxScoreResult = 0;\n    \n    for (let start = 1; start <= N; start++) {\n        let visited = new Set();\n        let currentSquare = start;\n        let currentScore = 0;\n        let moves = 0;\n        \n        while (moves < K && !visited.has(currentSquare)) {\n            visited.add(currentSquare);\n            currentScore += C[currentSquare - 1];\n            currentSquare = P[currentSquare - 1];\n            moves++;\n        }\n        \n        maxScoreResult = Math.max(maxScoreResult, currentScore);\n    }\n    \n    return maxScoreResult;\n}",
    "timestamp": "2025-08-13 10:46:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    N, K = map(int, sys.stdin.readline().split())\n    P = list(map(int, sys.stdin.readline().split()))\n    C = list(map(int, sys.stdin.readline().split()))\n    \n    P = [x-1 for x in P]  # converting to 0-based index\n    max_score = -10**18\n    \n    for start in range(N):\n        current_pos = start\n        total = 0\n        path = []\n        # Find the cycle\n        while True:\n            current_pos = P[current_pos]\n            path.append(current_pos)\n            total += C[current_pos]\n            if current_pos == start:\n                break\n        cycle_len = len(path)\n        # Compute the maximum score for this cycle\n        current_max = -10**18\n        current_sum = 0\n        for i in range(cycle_len):\n            if i >= K:\n                break\n            current_sum += C[path[i]]\n            current_max = max(current_max, current_sum)\n            # Consider multiple cycles if beneficial\n            if total > 0:\n                cycles = (K - (i + 1)) // cycle_len\n                current_max = max(current_max, current_sum + total * cycles)\n        max_score = max(max_score, current_max)\n    \n    print(max_score)\n\nsolve()",
    "timestamp": "2025-08-13 10:46:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const input = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    const [N, K] = input[0].split(' ').map(Number);\n    const P = input[1].split(' ').map(x => Number(x) - 1); // converting to 0-based index\n    const C = input[2].split(' ').map(Number);\n    \n    let maxScore = -Infinity;\n    \n    for (let start = 0; start < N; start++) {\n        let currentPos = start;\n        let totalScore = 0;\n        let totalSteps = 0;\n        let cycleScore = 0;\n        let cycleLength = 0;\n        let visited = new Array(N).fill(false);\n        let pathScores = [];\n        \n        // Detect the cycle\n        while (!visited[currentPos]) {\n            visited[currentPos] = true;\n            currentPos = P[currentPos];\n            cycleLength++;\n            cycleScore += C[currentPos];\n            pathScores.push(C[currentPos]);\n        }\n        \n        currentPos = start;\n        let currentMax = -Infinity;\n        let currentSum = 0;\n        \n        if (cycleScore > 0) {\n            let fullCycles = Math.floor(K / cycleLength);\n            let remainingSteps = K % cycleLength;\n            let maxPartial = 0;\n            \n            // Calculate max score for full cycles and remaining steps\n            currentSum = 0;\n            let tempMax = -Infinity;\n            for (let i = 0; i < cycleLength; i++) {\n                currentSum += pathScores[i];\n                if (i < remainingSteps) {\n                    tempMax = Math.max(tempMax, fullCycles * cycleScore + currentSum);\n                }\n                tempMax = Math.max(tempMax, (fullCycles - 1) * cycleScore + currentSum);\n            }\n            currentMax = tempMax;\n        } else {\n            // If cycleScore is <= 0, only consider up to cycleLength steps\n            currentSum = 0;\n            let tempMax = -Infinity;\n            for (let i = 0; i < Math.min(cycleLength, K); i++) {\n                currentSum += pathScores[i];\n                tempMax = Math.max(tempMax, currentSum);\n            }\n            currentMax = tempMax;\n        }\n        \n        maxScore = Math.max(maxScore, currentMax);\n    }\n    \n    console.log(maxScore);\n}\n\nsolve();",
    "timestamp": "2025-08-13 10:47:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nusing ll = long long;\n\nll solve(int N, int K, const vector<int>& C, const vector<int>& P) {\n    vector<bool> visited(N + 1, false);\n    ll max_score = -1e18;\n    \n    for (int start = 1; start <= N; ++start) {\n        if (visited[start]) continue;\n        \n        vector<int> cycle;\n        int current = start;\n        \n        while (!visited[current]) {\n            visited[current] = true;\n            cycle.push_back(current);\n            current = P[current - 1];\n        }\n        \n        int cycle_size = cycle.size();\n        ll cycle_sum = 0;\n        vector<ll> prefix_sum(cycle_size + 1, 0);\n        \n        for (int i = 0; i < cycle_size; ++i) {\n            cycle_sum += C[cycle[i] - 1];\n            prefix_sum[i + 1] = prefix_sum[i] + C[cycle[i] - 1];\n        }\n        \n        for (int length = 1; length <= min(cycle_size, K); ++length) {\n            for (int start_index = 0; start_index < cycle_size; ++start_index) {\n                int end_index = start_index + length;\n                ll score = prefix_sum[end_index] - prefix_sum[start_index];\n                \n                if (K >= cycle_size) {\n                    ll times = (K - length) / cycle_size;\n                    if (cycle_sum > 0) {\n                        score += times * cycle_sum;\n                    }\n                }\n                \n                max_score = max(max_score, score);\n            }\n        }\n    }\n    \n    return max_score;\n}\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    vector<int> C(N), P(N);\n    \n    for (int i = 0; i < N; ++i) {\n        cin >> C[i];\n    }\n    \n    for (int i = 0; i < N; ++i) {\n        cin >> P[i];\n    }\n    \n    cout << solve(N, K, C, P) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 12:00:37"
  }
]