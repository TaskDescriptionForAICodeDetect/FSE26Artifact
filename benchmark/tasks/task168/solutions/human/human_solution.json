[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nusing pint = pair<int,int>;\n\nint main() {\n    int N, M; cin >> N >> M;\n    vector<pint> pic(N);\n    for (int i = 0; i < N; ++i) cin >> pic[i].second >> pic[i].first;\n    sort(pic.begin(), pic.end(), greater<pint>());\n    vector<int> gaku(M);\n    for (int i = 0; i < M; ++i) cin >> gaku[i];\n    sort(gaku.begin(), gaku.end(), greater<int>());\n\n    int i = 0, j = 0;\n    for (; i < gaku.size(); ++i, ++j) {\n        while (j < pic.size() && pic[j].second > gaku[i]) ++j;\n        if (j == pic.size()) break;\n    }\n    cout << i << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\npair < ll, ll> p[100001];\nll c[100001];\n\nint main() {\n\tint n, m;\n\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%lld%lld\", &p[i].second,&p[i].first);\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%lld\",&c[i]);\n\t}\n\n\tsort(c, c + m);\n\tsort(p, p + n);\n\n\tll ans = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (ans >= m) break;\n\t\tif (c[m - ans - 1] >= p[i].second) {\n\t\t\tans++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (T& x : v) is >> x;\n    return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    if (!v.empty()) {\n        os << v.front();\n        for (int i = 1; i < v.size(); ++i) os << ' ' << v[i];\n    }\n    return os;\n}\n\nint main() {\n#ifdef LBT\n    freopen(\"test.in\", \"r\", stdin);\n    int nol_cl = clock();\n#endif\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m;\n    cin >> n >> m;\n    vector<pair<int, int>> paint(n);\n    for (int i = 0; i < n; ++i) cin >> paint[i].second >> paint[i].first;\n    vector<int> c(m);\n    cin >> c;\n    sort(c.begin(), c.end(), greater<int>());\n    sort(paint.begin(), paint.end(), greater<pair<int, int>>());\n    int ans = 0;\n    for (auto pr : paint){\n        int v,s;tie(v,s)=pr;\n        if (ans < m && s <= c[ans])\n            ++ans;\n    }\n    cout << ans << '\\n';\n\n#ifdef LBT\n    LOG(\"Time: %dms\\n\", int((clock() - nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Template Headers {{{\nusing pii = pair<int, int>; using vpii = vector<pii>;\nusing vi = vector<int>; using vvi = vector<vi>;\nusing ll = long long; using vll = vector<long long>;\ntemplate <class T> using min_queue = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> istream &operator>>(istream &, vector<T> &);\ntemplate <class T> ostream &operator<<(ostream &, const vector<T> &);\ntemplate <class T, class U> istream &operator>>(istream &, pair<T, U> &);\ntemplate <class T, class U> ostream &operator<<(ostream &, const pair<T, U> &);\ntemplate <class T> struct Inf { static constexpr T inf() { return std::numeric_limits<T>::has_infinity() ? std::numeric_limits<T>::infinty() : std::numeric_limits<T>::max(); } };\ntemplate <> struct Inf<int> { static constexpr int inf() { return 0x3f3f3f3f; } };\ntemplate <> struct Inf<long long> { static constexpr long long inf() { return 0x3f3f3f3f3f3f3f3fLL; } };\nconstexpr int INF = Inf<int>::inf(); constexpr ll BINF = Inf<ll>::inf();\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n// }}}\n\nint solve() {\n\tint n, m; cin >> n >> m;\n\tvpii sv(n); cin >> sv;\n\tsort(sv.begin(), sv.end(), [] (pii l, pii r) { return tie(l.second, l.first) < tie(r.second, r.first); });\n\tvi c(m); cin >> c;\n\tsort(c.begin(), c.end());\n\tvi lomo(n);\n\tfor (int i = 0; i < n; i++)\n\t\tlomo[i] = distance(c.begin(), lower_bound(c.begin(), c.end(), sv[i].first));\n\tint z = m - 1, ans = 0;\n\tfor (int i = n - 1; i >= 0; i--) if (lomo[i] <= z) ans++, z--;\n\tcout << ans << endl;\n\treturn 0;\n}\n\n// Template Main {{{\nint main() {\n\tios::sync_with_stdio(0);\n\t// precompute();\n\t// int t; cin >> t; for (int i=1;i<=t;i++)\n\tsolve();\n\t// cout << \"Case #\" << i << \": \", solve();\n\treturn 0;\n}\n\ntemplate <class T> istream &operator>>(istream &is, vector<T> &v) {\n\tfor (auto it=v.begin();it!=v.end();++it) is >> *it;\n\treturn is;\n}\n\ntemplate <class T> ostream &operator<<(ostream &os, const vector<T> &v) {\n\tfor (auto it=v.begin();it!=v.end();) os << *it, os << \" \\n\"[++it==v.end()];\n\treturn os;\n}\n\ntemplate <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) {\n\treturn is >> p.first >> p.second;\n}\n\ntemplate <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) {\n\treturn os << p.first << ' ' << p.second;\n}\n// }}}\n\n// vim: fdm=marker\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define POWER9 1000000000\n#define MOD POWER9+7\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483647\n#define INT_MAX 2147483647\n#define LL_MIN (LL)-9223372036854775807\n#define LL_MAX (LL)9223372036854775807\n#define PI 3.14159265359\n\nint N,M;\nvector<pair<int,int> > pic;\nvector<int> gaku;\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << setprecision(9);\n\n\tcin >> N >> M;\n\tfor(int i=0; i<N; i++){\n\t\tint s,v;\n\t\tcin >> s >> v;\n\t\tpic.push_back(MP(v,s));\n\t}\n\tsort(pic.begin(),pic.end());\n\treverse(pic.begin(),pic.end());\n\tfor(int i=0; i<M; i++){\n\t\tint c;\n\t\tcin >> c;\n\t\tgaku.push_back(c);\n\t}\n\tsort(gaku.begin(),gaku.end());\n\n\tint ans = 0;\n\tfor(int i=0; i<N; i++){\n\t\tif(gaku.size() == 0) break;\n\t\tif(pic[i].second <= gaku.back()){\n\t\t\tans++;\n\t\t\tgaku.erase(gaku.end()-1);\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i,n) for(UL i=0; i<(n); i++)\n\nUL N,M;\nstruct Pic{ UL S,V; };\nbool prioriCmp(const Pic& l, const Pic& r){\n if(l.V != r.V) return l.V > r.V;\n return l.S > r.S;\n}\nUL C[100000];\nPic A[100000];\n\nint main(){\n scanf(\"%u%u\",&N,&M);\n rep(i,N) scanf(\"%u%u\",&A[i].S,&A[i].V);\n rep(i,M) scanf(\"%u\",&C[i]);\n sort(C,C+M); reverse(C,C+M);\n sort(A,A+N,prioriCmp);\n\n UL ans=0;\n rep(i,N){\n  if(ans==M) break;\n  if(C[ans] >= A[i].S) ans++;\n }\n\n printf(\"%u\\n\",ans);\n\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nint main(){\n    int n,m;\n    scanf(\" %d %d\", &n, &m);\n\n    vector<pi> p(n);\n    rep(i,n){\n        int s,v;\n        scanf(\" %d %d\", &s, &v);\n        p[i] = {v,s};\n    }\n    sort(all(p), greater<pi>());\n\n    vector<int> c(m);\n    rep(i,m) scanf(\" %d\", &c[i]);\n    sort(all(c), greater<int>());\n\n    int pidx = 0, cidx = 0;\n    int ans = 0;\n    while(pidx<n && cidx<m){\n        if(p[pidx].se <= c[cidx]){\n            ++pidx;\n            ++cidx;\n            ++ans;\n        }\n        else ++pidx;\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\n#define inf 1e9\n\n\nint main(){\n\tll n,m;\n\tcin>>n>>m;\n\tpriority_queue<mp> q;\n\tpriority_queue<ll> c;\n\tfor(ll i=0;i<n;i++){\n\t\tll s,v;\n\t\tcin>>s>>v;\n\t\tq.push(mp(v,s));\n\t}\n\tfor(ll i=0;i<m;i++){\n\t\tll cc;\n\t\tcin>>cc;\n\t\tc.push(cc);\n\t}\n\tll res = 0;\n\tll maxv = 1e10;\n\twhile(!c.empty() && !q.empty() ){\n\t\tll cc = c.top();\n\t\tmp now = q.top();\n\t\tq.pop();\n\t\tif(now.second > cc || now.first >  maxv){\n\t\t\tcontinue;\n\t\t}\n\t\tmaxv = now.first;\n\t\tc.pop();\n\t\tres++;\n\t}\n\tcout<<res<<endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\nM=額縁の数\nC[]=額縁の大きさ\nN=絵の枚数\nS[]=絵の大きさ\nV[]=絵の価値\n*/\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(void){\n\tint N,M,S,V;\n\tcin>>N>>M;\n\tint C[M];\n\tpair<int,int> paints[N]; //first V,second S\n\tfor(int i=0;i<N;i++){\n\t\tcin>>S>>V;\n\t\tpaints[i]=make_pair(V,S);\n\t}\n\tfor(int i=0;i<M;i++){\n\t\tcin>>C[i];\n\t}\n\tsort(paints,paints+N);\n\tsort(C,C+M);\n\tint ans=0;\n\tfor(int i=N-1;i>=0&&ans<M;i--){\n\t\tif(C[M-ans-1]>=paints[i].second){\n\t\t\tans++;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n\tint N, M;\n\tcin >> N >> M;\n\tvector<pair<int, int> > P(N);\n\tfor(int i = 0; i < N; i++) cin >> P[i].second >> P[i].first;\n\tvector<int> C(M);\n\tfor(int i = 0; i < M; i++) cin >> C[i];\n\tsort(P.begin(), P.end(), greater<pair<int, int> >());\n\tsort(C.begin(), C.end(), greater<int>());\n\tint res = 0;\n\tint index = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tif(P[i].second <= C[index]){\n\t\t\tres++;\n\t\t\tindex++;\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <algorithm>\n#include <vector>\n#include <iostream>\n#include <utility>\nusing namespace std;\nusing ll = long long;\n\nint main(){\n  int N, M;\n  cin >> N >> M;\n  vector<pair<ll,ll>> V;\n  for(int i = 0; i < N; ++i){\n    int s, v;\n    cin >> s >> v;\n    V.emplace_back(v,s);\n  }\n  sort(V.begin(),V.end());\n  vector<ll> C(M);\n  for(int i = 0; i < M; ++i) cin >> C[i];\n  sort(C.rbegin(),C.rend());\n  int j = N-1;\n  int ans = 0;\n  for(int i = 0; i < M; ++i){\n    while(j >= 0 and V[j].second > C[i]) --j;\n    if(j < 0 or V[j].second > C[i]) break;\n    ++ans;\n    --j;\n    if(j < 0) break;\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<utility>\n#include<vector>\n#include<queue>\n#include<functional>\n#include<map>\n#include<set>\n#include<cstring>\n#include<string>\n#include<stack>\n#include<malloc.h>\n#include<math.h>\nusing namespace std;\n//#define int long long\ntypedef pair<int, int> pii;\ntypedef pair<int, char> pic;\ntypedef priority_queue<pii, vector<pii>, greater<pii> > RPQ;\n#define mk make_pair\n#define INF (1 << 30)\n#define INFL (1ll << 60ll)\n#define mod 1000000007\n\nint N, M;\npii vs[100100];\nint c[100100];\n\nsigned main(){\n    cin >> N >> M;\n    for(int i = 0; i < N; i++){\n        int a, b;\n        cin >> a >> b;\n        vs[i] = mk(b, a);\n    }\n    for(int i = 0; i < M; i++){\n        int a;\n        cin >> a;\n        c[i] = a;\n    }\n    sort(vs, vs + N, greater<pii>() );\n    sort(c, c + M, greater<int>() );\n    int ans = 0;\n    int k = 0;\n    for(int i = 0; i < M; i++){\n        while(k < N){\n            if(vs[k].second <= c[i])break;\n            k++;\n        }\n        if(k >= N)break;\n        if(vs[k].second <= c[i]){\n            ans++;\n            k++;\n        }\n    }\n    cout << ans << endl;\n    \n\n\n    return 0;\n}\n\n/*\n\n\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define err(args...) {}\n#ifdef DEBUG\n#include \"_debug.cpp\"\n#endif\nusing namespace std;\nusing ll = long long;\ntemplate <typename T> T bsearch(T L, T R, const function<bool(T)>& can, bool left_feasible = true) {\n    T& feasible = left_feasible ? L : R;\n    T& infeasible = left_feasible ? R : L;\n    while(R - L > 1) {\n        T M = (L + R) / 2;\n        (can(M) ? feasible : infeasible) = M;\n    }\n    return feasible;\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m;\n    cin >> n >> m;\n    vector<int> s(n), v(n);\n    for(int i = 0; i < n; i++) {\n        cin >> s[i] >> v[i];\n    }\n    vector<int> by_size(n), by_value(n);\n    iota(by_size.begin(), by_size.end(), 0);\n    sort(by_size.begin(), by_size.end(), [&](int i, int j) {\n        return s[i] < s[j] or (s[i] == s[j] and v[i] < v[j]);\n    });\n    iota(by_value.begin(), by_value.end(), 0);\n    sort(by_value.begin(), by_value.end(), [&](int i, int j) {\n        return v[i] < v[j] or (v[i] == v[j] and s[i] < s[j]);\n    });\n    vector<int> c(m);\n    for(int i = 0; i < m; i++) {\n        cin >> c[i];\n    }\n    sort(c.begin(), c.end());\n    reverse(c.begin(), c.end());\n    cout << bsearch<int>(0, min(n, m) + 1, [&](int k) {\n        vector<bool> dead(n);\n        int sptr = n - 1, vptr = n - 1;\n        for(int i = 0; i < k; i++) {\n            while(sptr >= 0) {\n                if(s[by_size[sptr]] > c[i]) {\n                    dead[by_size[sptr]] = true;\n                }\n                if(dead[by_size[sptr]]) {\n                    sptr--;\n                } else {\n                    break;\n                }\n            }\n            if(sptr < 0) {\n                return false;\n            } else {\n                while(dead[by_value[vptr]]) {\n                    vptr--;\n                }\n                dead[by_value[vptr--]] = true;\n            }\n        }\n        return true;\n    }) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\n#include<random>\n#include<functional>\n#include<utility>\n\ntypedef long long ll;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define pb push_back\n#define P pair<int, int>\n#define PLI pair<ll, int>\n#define PLL pair<ll, ll>\n\nusing namespace std;\n\n\nint N, M;\nint main() {\n\tcin >> N >> M;\n\tvector<PLL> pic(N);\n\tvector<ll> gk(M);\n\n\trep(i, N) {\n\t\tint s, v;\n\t\tcin >> s >> v;\n\t\tpic[i] = PLL(v, s);\n\t}\n\trep(i, M) {\n\t\tcin >> gk[i];\n\t}\n\n\tsort(pic.begin(), pic.end());\n\tsort(gk.begin(), gk.end());\n\n\tint ans = 0;\n\n\tint n = N - 1, m = M - 1;\n\twhile (n >= 0 && m >= 0)\n\t{\n\t\tint v = pic[n].first, s = pic[n].second;\n\t\tif (s <= gk[m]) {\n\t\t\tans++;\n\t\t\t--m;\n\t\t}\n\t\t--n;\n\t}\n\n\tcout << ans << endl;\n\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <tuple>\n\ntemplate <class T>\nusing MaxHeap = std::priority_queue<T>;\n\nvoid solve() {\n    int n, m;\n    std::cin >> n >> m;\n\n    MaxHeap<std::pair<int, int>> ps;\n    while (n--) {\n        int s, v;\n        std::cin >> s >> v;\n        ps.emplace(v, s);\n    }\n\n    std::vector<int> cs(m);\n    for (auto& c : cs) std::cin >> c;\n    std::sort(cs.rbegin(), cs.rend());\n\n    int ans = 0;\n    for (auto c : cs) {\n        while (!ps.empty()) {\n            int v, s;\n            std::tie(v, s) = ps.top();\n            ps.pop();\n            if (s <= c) {\n                ++ans;\n                break;\n            }\n        }\n    }\n\n    std::cout << ans << \"\\n\";\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//const int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\n\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tpriority_queue<pair<int, int>>PQ;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> L >> R;\n\t\tPQ.push({ R,L });\n\t}\n\tvector<int>v(M);\n\tfor (auto &i : v)cin >> i;\n\tsort(v.begin(), v.end());\n\tlong long int bef = MOD * MOD;\n\twhile (1) {\n\t\twhile (!PQ.empty() && PQ.top().second > v.back()) {\n\t\t\tPQ.pop();\n\t\t}\n\t\tif (PQ.empty())break;\n\t\tbef = PQ.top().first;\n\t\tPQ.pop();\n\t\tv.pop_back();\n\t}\n\tcout << M - v.size() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nlong long N; pair<long long, long long> D[1 << 18];\nlong long M, C[1 << 18];\n\nint main() {\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; i++) cin >> D[i].second >> D[i].first;\n\tfor (int i = 0; i < M; i++) cin >> C[i];\n\tsort(D, D + N);\n\tsort(C, C + M);\n\n\tint ret = M - 1;\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\tif (C[ret] >= D[i].second) ret--;\n\t\tif (ret < 0) break;\n\t}\n\tcout << (M - 1) - ret << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> v(n, vector<int>(2));\n    for (int i = 0; i < n; i++)cin >> v[i][1] >> v[i][0];\n    vector<int> c(m);\n    for (int i = 0; i < m; i++)cin >> c[i];\n\n    sort(v.begin(), v.end());\n    reverse(v.begin(), v.end());\n    sort(c.begin(), c.end());\n    reverse(c.begin(), c.end());\n\n    int ret = 0;\n    for (int i = 0; i < n; i++) {\n        if (v[i][1] <= c[ret])ret++;\n    }\n\n    cout << ret << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    using P = pair<int, int>;\n    vector<P> v(n);\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d %d\", &v[i].second, &v[i].first);\n    }\n    vector<int> u(m);\n    for (auto &&j : u) scanf(\"%d\", &j);\n    sort(v.begin(),v.end(), greater<>());\n    sort(u.begin(),u.end(), greater<>());\n    int a = 0, b = 0;\n    while(a < u.size() && b < v.size()){\n        while(b < v.size() && v[b].second > u[a]) b++;\n        if(b == v.size()) break;\n        a++; b++;\n    }\n    cout << a << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100005\n\nstruct Info{\n\tInfo(int arg_size,int arg_value){\n\t\tsize = arg_size;\n\t\tvalue = arg_value;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\n\t\tif(value != arg.value){\n\t\t\treturn value < arg.value; //価値の降順(PQ)\n\t\t}else{\n\t\t\treturn size < arg.size; //大きさの降順\n\t\t}\n\t}\n\tint size,value;\n};\n\nint N,M;\nvector<int> V;\n\n\nint main(){\n\n\tscanf(\"%d %d\",&N,&M);\n\n\tpriority_queue<Info> Q;\n\tint size,value;\n\n\tfor(int loop = 0; loop < N; loop++){\n\n\t\tscanf(\"%d %d\",&size,&value);\n\t\tQ.push(Info(size,value));\n\t}\n\n\tint tmp;\n\n\tfor(int loop = 0; loop < M; loop++){\n\n\t\tscanf(\"%d\",&tmp);\n\t\tV.push_back(tmp);\n\t}\n\n\tsort(V.rbegin(),V.rend());\n\n\tint ans = 0;\n\n\tfor(int i = 0; Q.empty() == false && i < V.size(); ){\n\n\t\tif(Q.top().size <= V[i]){\n\t\t\tans++;\n\t\t\ti++;\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[10000100];\n                int inv[10000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n\nstruct Segmax{\n\t//       1\n\t//   2        3\n\t// 4   5   6    7\n\t\n\t\n\tprivate:\n\tpublic:\n\t\n\t// (1<<15)=32768\n\t// 1<<16 = 65536\n\t// 1<<17 = 131072\n\t// 1<<18 = 262144\n\t\n\tint cor=(1<<17);\n\t\n\tvector<pa> vec;\n\t\n\tvoid shoki1(){\n\t\t\n\t\tvec.resize(2*cor+3, mp(0,0));\n\t\tfor(int i=cor;i<2*cor;i++)vec[i].second=i-cor;\n\t}\n\t\tvoid shoki2(){\n\t\t\tfor(int i=cor-1;i>0;i--) {\n\t\t\t\tif(vec[2*i].first>=vec[2*i+1].first) vec[i]=vec[2*i];\n\t\t\t\telse vec[i]=vec[2*i+1];\n\t\t\t}\n\t\t}\n\t\t\n\tvoid updadd(int x,int w){\n\t\t//x 項目に w加算\n\t\tx+=cor;\n\t\tvec[x].first+=w;\n\t\twhile(1){\n\t\t\tx/=2;\n\t\t\tif(x==0) break;\n\t\t\tif(vec[2*x].first>=vec[2*x+1].first) vec[x]=vec[2*x];\n\t\t\telse vec[x]=vec[2*x+1];\n\t\t}\n\t\t\n\t}\n\t\n\tvoid updchan(int x,int w){\n\t\t//x項目をwに変更\n\t\t\n\t\tx+=cor;\n\t\tvec[x].first=w;\n\t\t\n\t\twhile(1){\n\t\t\tx/=2;\n\t\t\tif(x==0) break;\n\t\t\tif(vec[2*x].first>=vec[2*x+1].first) vec[x]=vec[2*x];\n\t\t\telse vec[x]=vec[2*x+1];\n\t\t}\n\t\t\n\t}\n\t// [a,b)\n\t// k-th node\n\t// k no kukanha [l,r)\n\tpa segmax(int a,int b,int k=1,int l=0,int r=-10){\n\t\tif(r<0)r=cor;\n\t\t\n\t//\tcout<<a<<\" \"<<b<<\" \"<<k<<\" \"<<l<<\" \"<<r<<endl;\n\t\t\n\t\tif(a<=l && r<=b){\n\t\t\treturn vec[k];\n\t\t}\n\t\tif(r<=a || b<=l){\n\t\t\treturn mp(-(1ll<<31),-1);\n\t\t}\n\t\t\n\t\tpa v1=segmax(a,b,k*2,l,(l+r)/2),v2=segmax(a,b,k*2+1,(l+r)/2,r);\n\t\t\n\t\tif(v1.first>=v2.first)return v1;\n\t\telse return v2;\n\t}\n\t\n\t// leftmost ブロックkは値がb以上のときに，このブロックに属する値がb以上のもののうち最も左のものを返す\n\tpa leftmost(int b, int k,int l,int r){\n\t\tif(r-l==1) return vec[k]; \n\t\tif(vec[2*k].first>=b) return leftmost(b,2*k,l,(l+r)/2);\n\t\telse return leftmost(b,2*k+1,(l+r)/2,r);\n\t\t\n\t}\n\t\n\n\t\n};\nbool hikaku(pa x,pa y){\n\tif(x.second!=y.second)return x.second<y.second;\n\treturn x.first<y.first;\n}\nsigned main(){\n\t\n\t\n   cin.tie(0);\n\tios::sync_with_stdio(false);\nset<int> ss,sv;\n\tmap<int,int> ms,mv;\n\tvector<pa> ve;\n\tvector<int> c;\n\tint n,m;\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++){\n\t\tint y,yy;\n\t\tcin>>y>>yy;\n\t\tss.insert(y);\n\t\tsv.insert(yy);\n\t\tve.pb(mp(y,yy));\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint y;\n\t\tcin>>y;\n\t\tss.insert(y);\n\t\tc.pb(y);\n\t}\n\t\n\t\n\tsort(c.begin(),c.end());\n\t\n\tsort(ve.begin(),ve.end(),hikaku);\n\t\n\tint ans=0;\n\twhile(ve.size()>0 && c.size()>0){\n\t\tpa x=ve.back();\n\t\tint y=c.back();\n\t\tif(x.first>y){\n\t\t\tve.pop_back();\n\t\t\tcontinue;\n\t\t}\n\t\telse{\n\t\t\tans++;\n\t\t//\tcout<<x.first<<\" \"<<y<<endl;\n\t\t\tve.pop_back();\n\t\t\tc.pop_back();\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n\t\n\n \n }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int N, M;\n    cin >> N >> M;\n    vector<pair<int, int>> sv;\n    for(int i = 0;i < N;i++){\n        int S, V;\n        cin >> S >> V;\n        sv.emplace_back(V, S);\n    }\n    sort(sv.begin(), sv.end());\n    vector<int> C(M);\n    for(int i = 0;i < M;i++){\n        cin >> C[i];\n    }\n    sort(C.begin(), C.end());\n    int lb = 0, ub = min(N, M) + 1;\n    while(ub - lb > 1){\n        int m = (lb + ub) / 2;\n        int it = M - m;\n        for(int i = 0;i < N && it < M;i++){\n            it += sv[i].second <= C[it];\n        }\n        (it < M ? ub : lb) = m;\n    }\n    cout << lb << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0659 Exhibition\n// 2019.3.29 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n\n//// 入力の高速化\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\nint in()    // 整数の入力（負数非対応）\n{\n\tint n = 0, c = gc();\n\tdo n = 10 * n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\ntypedef struct { int s, v; } T;\nT t[100005]; int N;\nint c[100005]; int M;\n\n// C言語内蔵クイックソート関数用比較関数\nint cmpInt(const void *a, const void *b) { return *(int *)b - *(int *)a; }\nint cmpT(const void *a, const void *b) {\n\tint t = ((T *)b)->v - ((T *)a)->v; if (t) return t;\n\treturn ((T *)b)->s - ((T *)a)->s;\n}\n\nint main()\n{\n\tint i, j, ans;\n\n\t// 入力受付\n\tN = in(), M = in();\n\tfor (i = 0; i < N; i++) t[i].s = in(), t[i].v = in();\n\tfor (i = 0; i < M; i++) c[i] = in();\n\n\t// 降順にソートしておく\n\tqsort(t, N, sizeof(T), cmpT);\n\tqsort(c, M, sizeof(int), cmpInt);\n\tt[N].s = 0;  // 番兵\n\n\tans = 0, i = 0;\n\tfor (j = 0; i < N && j < M; j++) {\n\t\twhile (t[i].s > c[j]) i++;\n\t\tif (i == N) break;\n\t\tans++, i++;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args:Array<String>?): Unit {\n    val (n, m) = readLine()!!.trim().split(' ').map(String::toInt)\n    val pictures = Array(n){\n        val (s, v) = readLine()!!.trim().split(' ').map(String::toInt)\n        Picture(s, v)\n    }.sortedArrayDescending()\n    val frames = IntArray(m){ readLine()!!.trim().toInt() }.sortedArrayDescending()\n    var i = 0\n    var count = 0\n    for (frame in frames) {\n        while(i < n && pictures[i].size > frame){\n            ++i\n        }\n        if (i in pictures.indices) {\n            ++count\n            ++i\n        }\n    }\n    println(count)\n}\ndata class Picture(val size: Int, val value: Int): Comparable<Picture> {\n    override fun compareTo(other: Picture): Int {\n        return if (value == other.value) size.compareTo(other.size) else value.compareTo(other.value)\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System;\n\npublic class P\n{\n    public int s { get; set; }\n    public int v { get; set; }\n}\n\npublic class hello\n{\n    public static void Main()\n    {\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var n = int.Parse(line[0]);\n        var m = int.Parse(line[1]);\n        var ps = new P[n];\n        for (int i = 0; i < n; i++)\n        {\n            line = Console.ReadLine().Trim().Split(' ');\n            ps[i] = new P { s = int.Parse(line[0]), v = int.Parse(line[1]) };\n        }\n        var c = new int[m];\n        for (int i = 0; i < m; i++) c[i] = int.Parse(Console.ReadLine().Trim());\n        getAns(n, ps, c);\n    }\n    static void getAns(int n, P[] ps, int[] c)\n    {\n        Array.Sort(c);\n        Array.Reverse(c);\n        var ans = 0;\n        var p = 0;\n        var ps2 = ps.OrderByDescending(x => x.v).ThenByDescending(x => x.s).ToArray();\n        foreach (var x in c)\n            while (p < n) if (ps2[p++].s <= x) { ans++; break; }\n        Console.WriteLine(ans);\n    }\n}\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python3\n\nimport array\nfrom fractions import Fraction\nimport functools\nimport itertools\nimport math\nimport os\nimport sys\n\n\ndef main():\n    N, M = read_ints()\n    P = [(s, v) for s, v in [read_ints() for _ in range(N)]]\n    C = [read_int() for _ in range(M)]\n    print(solve(N, M, P, C))\n\n\ndef solve(N, M, P, C):\n    P.sort(key=lambda p: (-p[1], -p[0]))\n    C.sort(reverse=True)\n    ci = 0\n    for pi in range(N):\n        if ci == M:\n            break\n        s = P[pi][0]\n        if C[ci] >= s:\n            ci += 1\n    return ci\n\n\n###############################################################################\n# AUXILIARY FUNCTIONS\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef read_int():\n    return int(inp())\n\n\ndef read_ints():\n    return [int(e) for e in inp().split()]\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  }
]