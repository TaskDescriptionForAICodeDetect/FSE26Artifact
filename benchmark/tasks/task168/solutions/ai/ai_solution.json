[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int size;\n    int value;\n} Painting;\n\ntypedef struct {\n    int size;\n} Frame;\n\nint comparePaintings(const void *a, const void *b) {\n    Painting *pa = (Painting *)a;\n    Painting *pb = (Painting *)b;\n    if (pa->value != pb->value) {\n        return pa->value - pb->value;\n    } else {\n        return pa->size - pb->size;\n    }\n}\n\nint compareFrames(const void *a, const void *b) {\n    Frame *fa = (Frame *)a;\n    Frame *fb = (Frame *)b;\n    return fa->size - fb->size;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    Painting *paintings = (Painting *)malloc(N * sizeof(Painting));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &paintings[i].size, &paintings[i].value);\n    }\n\n    Frame *frames = (Frame *)malloc(M * sizeof(Frame));\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d\", &frames[i].size);\n    }\n\n    qsort(paintings, N, sizeof(Painting), comparePaintings);\n    qsort(frames, M, sizeof(Frame), compareFrames);\n\n    int result = 0;\n    int frame_ptr = 0;\n\n    for (int i = 0; i < N && frame_ptr < M; i++) {\n        if (paintings[i].size <= frames[frame_ptr].size) {\n            result++;\n            frame_ptr++;\n        }\n    }\n\n    printf(\"%d\\n\", result);\n\n    free(paintings);\n    free(frames);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:53:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ArtExhibition {\n    public static int maxPaintings(int N, int M, int[] S, int[] V, int[] C) {\n        // Sort paintings by value in descending order\n        Integer[] paintingIndices = new Integer[N];\n        for (int i = 0; i < N; i++) {\n            paintingIndices[i] = i;\n        }\n        Arrays.sort(paintingIndices, (a, b) -> Integer.compare(V[b], V[a]));\n\n        // Sort frames by size in ascending order\n        Integer[] frameIndices = new Integer[M];\n        for (int j = 0; j < M; j++) {\n            frameIndices[j] = j;\n        }\n        Arrays.sort(frameIndices, (a, b) -> Integer.compare(C[a], C[b]));\n\n        int[] dp = new int[M];\n        for (int paintingIndex : paintingIndices) {\n            int currentSize = S[paintingIndex];\n            int currentValue = V[paintingIndex];\n            int maxDisplayed = 0;\n\n            for (int frameIndex : frameIndices) {\n                if (currentSize <= C[frameIndex]) {\n                    int prevMax = 0;\n                    for (int k = 0; k < frameIndex; k++) {\n                        if (C[frameIndices[k]] <= C[frameIndex]) {\n                            prevMax = Math.max(prevMax, dp[k]);\n                        }\n                    }\n                    dp[frameIndex] = Math.max(dp[frameIndex], prevMax + 1);\n                    maxDisplayed = Math.max(maxDisplayed, dp[frameIndex]);\n                }\n            }\n        }\n\n        return Arrays.stream(dp).max().orElse(0);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int N = scanner.nextInt(); // Number of paintings\n        int M = scanner.nextInt(); // Number of frames\n        \n        int[] S = new int[N]; // Painting sizes\n        int[] V = new int[N]; // Painting values\n        \n        for (int i = 0; i < N; i++) {\n            S[i] = scanner.nextInt();\n            V[i] = scanner.nextInt();\n        }\n        \n        int[] C = new int[M]; // Frame sizes\n        for (int j = 0; j < M; j++) {\n            C[j] = scanner.nextInt();\n        }\n        \n        int result = maxPaintings(N, M, S, V, C);\n        System.out.println(result);\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 18:53:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    vector<pair<int, int>> paintings(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> paintings[i].first >> paintings[i].second;\n    }\n    \n    vector<int> frames(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> frames[i];\n    }\n    \n    sort(frames.begin(), frames.end());\n    sort(paintings.begin(), paintings.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        return a.second < b.second || (a.second == b.second && a.first < b.first);\n    });\n    \n    vector<int> dp;\n    for (const auto& p : paintings) {\n        int s = p.first;\n        int v = p.second;\n        auto it = lower_bound(frames.begin(), frames.end(), s);\n        if (it != frames.end()) {\n            auto dp_it = upper_bound(dp.begin(), dp.end(), *it);\n            if (dp_it == dp.end()) {\n                dp.push_back(*it);\n            } else {\n                *dp_it = *it;\n            }\n        }\n    }\n    \n    cout << dp.size() << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:53:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 1000\n#define MAX_M 1000\n\nint main() {\n    int N, M;\n    int S[MAX_N+1], V[MAX_N+1];\n    int C[MAX_M+1];\n    int dp[MAX_N+1][MAX_M+1];\n    \n    scanf(\"%d %d\", &N, &M);\n    \n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d %d\", &S[i], &V[i]);\n    }\n    \n    for (int j = 1; j <= M; j++) {\n        scanf(\"%d\", &C[j]);\n    }\n    \n    memset(dp, 0, sizeof(dp));\n    \n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= M; j++) {\n            dp[i][j] = dp[i][j-1];\n            \n            if (S[i] <= C[j]) {\n                for (int k = 0; k < j; k++) {\n                    if (S[i] <= C[j] && (k == 0 || \n                        (S[dp[i-1][k]] <= C[j] && V[dp[i-1][k]] <= V[i]))) {\n                        dp[i][j] = (dp[i-1][k] == 0) ? i : dp[i-1][k];\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    \n    int max_paintings = 0;\n    for (int j = 1; j <= M; j++) {\n        int count = 0;\n        for (int i = 1; i <= N; i++) {\n            if (dp[i][j] != 0) count++;\n        }\n        max_paintings = (count > max_paintings) ? count : max_paintings;\n    }\n    \n    printf(\"%d\\n\", max_paintings);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:56:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint maxPaintingsDisplay(int N, int M, vector<int>& sizes, vector<int>& values, vector<int>& frames) {\n    vector<vector<int>> dp(N + 1, vector<int>(M + 1, 0));\n    \n    sort(sizes.begin(), sizes.end());\n    sort(values.begin(), values.end());\n    sort(frames.begin(), frames.end());\n    \n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= M; j++) {\n            dp[i][j] = dp[i][j-1];\n            \n            if (sizes[i-1] <= frames[j-1]) {\n                int maxPrev = 0;\n                for (int k = 1; k < j; k++) {\n                    if (frames[k-1] >= frames[j-1] && values[i-1] >= values[dp[i-1][k] - 1]) {\n                        maxPrev = max(maxPrev, dp[i-1][k]);\n                    }\n                }\n                \n                dp[i][j] = max(dp[i][j], maxPrev + 1);\n            }\n        }\n    }\n    \n    int maxPaintings = 0;\n    for (int j = 1; j <= M; j++) {\n        maxPaintings = max(maxPaintings, dp[N][j]);\n    }\n    \n    return maxPaintings;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    vector<int> sizes(N), values(N), frames(M);\n    \n    for (int i = 0; i < N; i++) {\n        cin >> sizes[i] >> values[i];\n    }\n    \n    for (int j = 0; j < M; j++) {\n        cin >> frames[j];\n    }\n    \n    int result = maxPaintingsDisplay(N, M, sizes, values, frames);\n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:56:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ArtExhibition {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int[] S = new int[N];\n        int[] V = new int[N];\n        for (int i = 0; i < N; i++) {\n            S[i] = scanner.nextInt();\n            V[i] = scanner.nextInt();\n        }\n        int[] C = new int[M];\n        for (int i = 0; i < M; i++) {\n            C[i] = scanner.nextInt();\n        }\n        \n        Arrays.sort(C);\n        List<Painting> paintings = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            paintings.add(new Painting(S[i], V[i]));\n        }\n        Collections.sort(paintings, (a, b) -> {\n            if (a.value != b.value) {\n                return Integer.compare(a.value, b.value);\n            } else {\n                return Integer.compare(a.size, b.size);\n            }\n        });\n        \n        int result = 0;\n        boolean[] usedFrames = new boolean[M];\n        \n        for (Painting p : paintings) {\n            int idx = findFrame(C, p.size, usedFrames);\n            if (idx != -1) {\n                usedFrames[idx] = true;\n                result++;\n            }\n        }\n        \n        System.out.println(result);\n    }\n    \n    private static int findFrame(int[] C, int size, boolean[] usedFrames) {\n        int left = 0;\n        int right = C.length - 1;\n        int result = -1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (C[mid] >= size) {\n                result = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        if (result != -1) {\n            for (int i = result; i < C.length; i++) {\n                if (!usedFrames[i]) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n    \n    static class Painting {\n        int size;\n        int value;\n        \n        Painting(int size, int value) {\n            this.size = size;\n            this.value = value;\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:56:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_paintings(N, M, S, V, C):\n    paintings = sorted(zip(S, V), key=lambda x: (x[0], x[1]))\n    frames = sorted(C)\n    \n    dp = [[0] * (M + 1) for _ in range(N + 1)]\n    \n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if paintings[i - 1][0] <= frames[j - 1]:\n                dp[i][j] = max(dp[i - 1][j - 1] + 1, dp[i - 1][j], dp[i][j - 1])\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    result = 0\n    max_value = 0\n    \n    for i in range(N + 1):\n        for j in range(M + 1):\n            if dp[i][j] > result:\n                max_value = max(max_value, sum(V[idx - 1] for idx in range(1, i + 1)))\n                result = dp[i][j]\n    \n    return result\n\n# Example usage:\nN = 5\nM = 4\nS = [3, 1, 4, 5, 2]\nV = [9, 7, 8, 6, 5]\nC = [5, 5, 5, 4]\n\nprint(max_paintings(N, M, S, V, C))  # Output: Maximum number of paintings",
    "timestamp": "2025-08-13 01:25:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class ArtExhibition {\n\n    static class Painting {\n        int size, value;\n\n        Painting(int size, int value) {\n            this.size = size;\n            this.value = value;\n        }\n    }\n\n    static class Frame {\n        int size;\n\n        Frame(int size) {\n            this.size = size;\n        }\n    }\n\n    public static int maxPaintingsDisplayed(Painting[] paintings, Frame[] frames) {\n        int n = paintings.length;\n        int m = frames.length;\n        \n        Arrays.sort(paintings, Comparator.comparingInt((Painting p) -> p.size)\n                                          .thenComparingInt(p -> p.value));\n        Arrays.sort(frames, Comparator.comparingInt(f -> f.size));\n\n        int[][] dp = new int[m + 1][n + 1];\n\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                dp[i][j] = dp[i][j - 1];\n                if (frames[i - 1].size >= paintings[j - 1].size) {\n                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + 1);\n                }\n                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);\n            }\n        }\n\n        return dp[m][n];\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        Painting[] paintings = { new Painting(2, 3), new Painting(3, 4), new Painting(1, 2) };\n        Frame[] frames = { new Frame(2), new Frame(3), new Frame(4) };\n        System.out.println(maxPaintingsDisplayed(paintings, frames));\n    }\n}",
    "timestamp": "2025-08-13 01:25:28"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int size;\n    int value;\n} Painting;\n\ntypedef struct {\n    int size;\n    int index;\n} Frame;\n\nint cmpPainting(const void *a, const void *b) {\n    Painting *p1 = (Painting *)a;\n    Painting *p2 = (Painting *)b;\n    if (p1->value == p2->value) {\n        return p1->size - p2->size;\n    }\n    return p1->value - p2->value;\n}\n\nint cmpFrame(const void *a, const void *b) {\n    Frame *f1 = (Frame *)a;\n    Frame *f2 = (Frame *)b;\n    return f1->size - f2->size;\n}\n\nint lowerBound(Frame *frames, int size, int l, int r) {\n    while (l < r) {\n        int m = l + (r - l) / 2;\n        if (frames[m].size < size)\n            l = m + 1;\n        else\n            r = m;\n    }\n    return l;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    Painting paintings[N];\n    Frame frames[M];\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &paintings[i].size, &paintings[i].value);\n    }\n\n    for (int j = 0; j < M; j++) {\n        scanf(\"%d\", &frames[j].size);\n        frames[j].index = j;\n    }\n\n    qsort(paintings, N, sizeof(Painting), cmpPainting);\n    qsort(frames, M, sizeof(Frame), cmpFrame);\n    \n    int dp[M];\n    for (int i = 0; i < M; i++) dp[i] = 0;\n\n    for (int i = 0; i < N; i++) {\n        int pSize = paintings[i].size;\n        int pValue = paintings[i].value;\n        int pos = lowerBound(frames, pSize, 0, M);\n\n        for (int j = M - 1; j >= pos; j--) {\n            dp[j] = (j ? dp[j - 1] : 0) + 1 > dp[j] ? (j ? dp[j - 1] : 0) + 1 : dp[j];\n        }\n    }\n\n    int maxPaintings = 0;\n    for (int i = 0; i < M; i++) {\n        if (dp[i] > maxPaintings) {\n            maxPaintings = dp[i];\n        }\n    }\n\n    printf(\"%d\\n\", maxPaintings);\n    return 0;\n}",
    "timestamp": "2025-08-13 01:25:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_paintings(N, M, S, V, C):\n    # Sort paintings by value in descending order\n    paintings = sorted(zip(S, V), key=lambda x: -x[1])\n    \n    # Sort frames by size in ascending order\n    frames = sorted(enumerate(C), key=lambda x: x[1])\n    \n    # DP table to track maximum paintings\n    dp = [[0] * M for _ in range(N)]\n    \n    # Initial filling of first row of DP\n    for j in range(M):\n        if paintings[0][0] <= frames[j][1]:\n            dp[0][j] = 1\n    \n    # Fill DP table\n    for i in range(1, N):\n        for j in range(M):\n            # If current painting fits in current frame\n            if paintings[i][0] <= frames[j][1]:\n                # Try to find a valid left frame\n                for k in range(j+1):\n                    # Check frame size and value conditions\n                    if frames[k][1] <= frames[j][1] and dp[i-1][k] > 0:\n                        dp[i][j] = max(dp[i][j], dp[i-1][k] + 1)\n    \n    # Return maximum number of paintings\n    return max(dp[N-1])\n\n# Example usage\nN, M = map(int, input().split())\nS = list(map(int, input().split()))\nV = list(map(int, input().split()))\nC = list(map(int, input().split()))\n\nresult = max_paintings(N, M, S, V, C)\nprint(result)",
    "timestamp": "2025-08-13 01:25:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    N, M = map(int, data[idx:idx+2])\n    idx +=2\n    \n    S = list(map(int, data[idx:idx+N]))\n    idx +=N\n    V = list(map(int, data[idx:idx+N]))\n    idx +=N\n    C = list(map(int, data[idx:idx+M]))\n    idx +=M\n    \n    # Pair frames with their indices and sort by size\n    frames = sorted([(C[j], j) for j in range(M)], key=lambda x: x[0])\n    # Sort paintings by size, then by value\n    paintings = sorted([(S[i], V[i]) for i in range(N)], key=lambda x: (x[0], x[1]))\n    \n    # Now, we can use a greedy approach similar to LIS but with frames\n    res = 0\n    last_frame = -1\n    last_value = -1\n    \n    # We'll process frames in order, and for each frame, find the best painting that fits\n    # Using two pointers\n    i = 0  # painting pointer\n    j = 0  # frame pointer\n    while i < N and j < M:\n        s, v = paintings[i]\n        c, frame_j = frames[j]\n        if s <= c:\n            if v >= last_value:\n                res +=1\n                last_value = v\n                last_frame = c\n                j +=1\n            i +=1\n        else:\n            j +=1\n    print(res)\n\nsolve()",
    "timestamp": "2025-08-13 01:26:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstruct Painting {\n    int size;\n    int value;\n    int index;\n};\n\nstruct Frame {\n    int size;\n    int index;\n};\n\nbool compareFrames(const Frame &a, const Frame &b) {\n    return a.size < b.size;\n}\n\nbool comparePaintings(const Painting &a, const Painting &b) {\n    if (a.value != b.value) return a.value < b.value;\n    return a.size < b.size;\n}\n\nint main() {\n    int N, M;\n    std::cin >> N >> M;\n\n    std::vector<Painting> paintings(N);\n    for (int i = 0; i < N; ++i) {\n        std::cin >> paintings[i].size >> paintings[i].value;\n        paintings[i].index = i;\n    }\n\n    std::vector<Frame> frames(M);\n    for (int j = 0; j < M; ++j) {\n        std::cin >> frames[j].size;\n        frames[j].index = j;\n    }\n\n    std::sort(paintings.begin(), paintings.end(), comparePaintings);\n    std::sort(frames.begin(), frames.end(), compareFrames);\n\n    std::vector<int> dp(N, 0);\n    std::vector<int> prev(N, -1);\n\n    int maxLength = 0, endIndex = -1;\n\n    for (int i = 0; i < N; ++i) {\n        dp[i] = 1;\n        for (int j = 0; j < i; ++j) {\n            if (paintings[i].value >= paintings[j].value &&\n                paintings[i].size <= frames[j].size) {\n                if (dp[j] + 1 > dp[i]) {\n                    dp[i] = dp[j] + 1;\n                    prev[i] = j;\n                }\n            }\n        }\n        if (dp[i] > maxLength) {\n            maxLength = dp[i];\n            endIndex = i;\n        }\n    }\n\n    std::cout << maxLength << std::endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:00:07"
  }
]