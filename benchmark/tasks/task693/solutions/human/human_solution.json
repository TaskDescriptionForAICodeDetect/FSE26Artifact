[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint read(){\n\tint a = 0; char c = getchar(); while(!isdigit(c)) c = getchar();\n\twhile(isdigit(c)){a = a * 10 + c - 48; c = getchar();} return a;\n}\n\nconst int _ = 2e5 + 7 , MOD = 998244353 , iv2 = (MOD + 1) / 2;\nstruct Edge{int end , upEd;}Ed[_ << 1];\nint dp[_][3][3] , N , cntEd , head[_];\nvoid addEd(int a , int b){Ed[++cntEd] = (Edge){b , head[a]}; head[a] = cntEd;}\n\nint mx , id , pre[_];\nvoid dfs1(int x , int p , int l){\n\tpre[x] = p; if(l > mx){mx = l; id = x;}\n\tfor(int i = head[x] ; i ; i = Ed[i].upEd)\n\t\tif(Ed[i].end != p) dfs1(Ed[i].end , x , l + 1);\n}\n\nint mxdep[_];\nvoid dfs2(int x , int p){\n\tfor(int i = head[x] ; i ; i = Ed[i].upEd)\n\t\tif(Ed[i].end != p){dfs2(Ed[i].end , x); mxdep[x] = max(mxdep[x] , mxdep[Ed[i].end] + 1);}\n}\n\nvoid DP(int x , int p){\n\tdp[x][0][0] = 1; bool flg = 0;\n\tfor(int i = head[x] ; i ; i = Ed[i].upEd)\n\t\tif(Ed[i].end != p){\n\t\t\tflg = 1; DP(Ed[i].end , x); static int tmp[3][3]; memset(tmp , 0 , sizeof(tmp));\n\t\t\tfor(int j = 0 ; j < 3 ; ++j)\n\t\t\t\tfor(int k = 0 ; k < 3 ; ++k)\n\t\t\t\t\tfor(int p = 0 ; p < 3 ; ++p)\n\t\t\t\t\t\tfor(int q = 0 ; q < 3 ; ++q){\n\t\t\t\t\t\t\tint coef = 3;\n\t\t\t\t\t\t\tif(mxdep[Ed[i].end] + 1 == mxdep[x]){\n\t\t\t\t\t\t\t\ttmp[min(j + p , 2)][k] = (tmp[min(j + p , 2)][k] + 1ll * dp[x][j][k] * dp[Ed[i].end][p][q]) % MOD;\n\t\t\t\t\t\t\t\ttmp[j][min(k + q , 2)] = (tmp[j][min(k + q , 2)] + 1ll * dp[x][j][k] * dp[Ed[i].end][p][q]) % MOD;\n\t\t\t\t\t\t\t\tcoef -= 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttmp[j][k] = (tmp[j][k] + 1ll * coef * dp[x][j][k] * dp[Ed[i].end][p][q]) % MOD;\n\t\t\t\t\t\t}\n\t\t\tmemcpy(dp[x] , tmp , sizeof(tmp));\n\t\t}\n\tif(!flg){dp[x][0][0] = 0; dp[x][1][1] = 1;}\n}\n\nint main(){\n\tN = read(); for(int i = 1 ; i < N ; ++i){int x = read() , y = read(); addEd(x , y); addEd(y , x);}\n\tdfs1(1 , 0 , 0); mx = 0; int t = id; dfs1(t , 0 , 0);\n\tfor(int i = 0 ; i < mx / 2 ; ++i) id = pre[id];\n\tif(mx & 1){\n\t\tdfs2(id , pre[id]); DP(id , pre[id]); dfs2(pre[id] , id); DP(pre[id] , id); int sum = 0;\n\t\tfor(int i = 0 ; i < 2 ; ++i) for(int j = 0 ; j < 2 ; ++j) sum = (sum + 1ll * dp[id][i][j] * dp[pre[id]][1 - i][1 - j]) % MOD;\n\t\tprintf(\"%lld\\n\" , 1ll * sum * iv2 % MOD);\n\t}else{dfs2(id , 0); DP(id , 0); printf(\"%lld\\n\" , 1ll * iv2 * dp[id][1][1] % MOD);}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for(int i=(a),_ed=(b);i<=_ed;++i)\n#define DREP(i,a,b) for(int i=(a),_ed=(b);i>=_ed;--i)\n#define mp(x,y) make_pair((x),(y))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int,int> pii;\ninline int read(){\n    register int x=0,f=1;register char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=0;ch=getchar();}\n    while(isdigit(ch)){x=x*10+(ch^'0');ch=getchar();}\n    return f?x:-x;\n}\n\nconst int N=2e5+5,mod=998244353;\nint n,c[2],mxd[N],f[N][3][3],g[3][3];\nvector<int> E[N];\ninline void inc(int& x,int y){x=x+y<mod?x+y:x+y-mod;}\n\nnamespace getcore{\n\tint d[N],fa[N],stk[N],tp,tmp;\n\tvoid dfs(int u,int pa,int dis,int& rt){\n\t\td[u]=dis,fa[u]=pa;if(d[u]>d[rt])rt=u;\n\t\tfor(int v:E[u]){\n\t\t\tif(v==pa)continue;\n\t\t\tdfs(v,u,dis+1,rt);\n\t\t}\n\t}\n\tvoid Main(){\n\t\tdfs(1,0,0,tmp);\n\t\tdfs(tmp,0,0,tmp);\n\t\twhile(tmp)stk[++tp]=tmp,tmp=fa[tmp];\n\t\tc[0]=stk[(tp+1)>>1];\n\t\tif(~tp&1)c[1]=stk[((tp+1)>>1)+1];//想清楚啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊\n\t}\n}\n\nint dfs(int u,int pa,int dep){\n\tmxd[u]=dep;\n\tfor(int v:E[u]){\n\t\tif(v==pa||v==c[0]||v==c[1])continue;\n\t\tmxd[u]=max(mxd[u],dfs(v,u,dep+1));\n\t}\n\tif(mxd[u]==dep)f[u][1][1]=1;\n\telse f[u][0][0]=1;\n\tfor(int v:E[u]){\n\t\tif(v==pa||v==c[0]||v==c[1])continue;\n\t\tREP(i,0,2)REP(j,0,2)g[i][j]=0;\n\t\tREP(a,0,2)REP(b,0,2)REP(p,0,2)REP(q,0,2){\n\t\t\tint flg=mxd[u]==mxd[v];\n\t\t\tint s=a,t=b,val=1ll*f[u][a][b]*f[v][p][q]%mod;\n\t\t\tinc(g[s][t],val);\n\t\t\ts=flg?min(2,a+p):a,t=b;\n\t\t\tinc(g[s][t],val);\n\t\t\ts=a,t=flg?min(2,b+q):b;\n\t\t\tinc(g[s][t],val);\n\t\t}\n\t\tREP(i,0,2)REP(j,0,2)f[u][i][j]=g[i][j];\n\t}\n\treturn mxd[u];\n}\n\nint main(){\n\t// freopen(\"in.in\",\"r\",stdin);\n\t// freopen(\"out.out\",\"w\",stdout);\n\tn=read();\n\tREP(i,1,n-1){\n\t\tint u=read(),v=read();\n\t\tE[u].pb(v),E[v].pb(u);\n\t}\n\tgetcore::Main();\n\tint sum=0;\n\tdfs(c[0],0,0);\n\tif(!c[1])\n\t\tsum=f[c[0]][1][1];\n\telse{\n\t\tdfs(c[1],0,0);\n\t\tREP(i,0,2)REP(j,0,2)\n\t\t\tinc(sum,1ll*f[c[0]][1][i]*f[c[1]][j][1]%mod);\n\t\tREP(i,0,2)REP(j,0,2)\n\t\t\tinc(sum,1ll*f[c[0]][i][1]*f[c[1]][1][j]%mod);\n\t}\n\tsum=1ll*sum*(mod+1)/2%mod;\n\tprintf(\"%d\\n\",sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[202020];\nconst ll mo=998244353;\n\npair<int,int> farthest(int cur,int pre,int d,vector<int>& D) {\n\tD[cur]=d;\n\tpair<int,int> r={d,cur};\n\tFORR(e,E[cur]) if(e!=pre) r=max(r, farthest(e,cur,d+1,D));\n\treturn r;\n}\n\npair<int,vector<int>> diameter() { // diameter,center\n\tvector<int> D[2];\n\tD[0].resize(N);\n\tD[1].resize(N);\n\tauto v1=farthest(0,0,0,D[0]);\n\tauto v2=farthest(v1.second,v1.second,0,D[0]);\n\tfarthest(v2.second,v2.second,0,D[1]);\n\tpair<int,vector<int>> R;\n\tR.first = v2.first;\n\t//重心を取る場合\n\tfor(int i=N-1;i>=0;i--) if(D[0][i]+D[1][i]==R.first && abs(D[0][i]-D[1][i])<=1) R.second.push_back(i);\n\n\treturn R;\n}\n\nvector<ll> dfs1(int cur,int pre,int lef,int no=0) {\n\tif(E[cur].size()==1) {\n\t\tif(lef==0) return {2,1,0};\n\t\telse return {3,0,0};\n\t}\n\telse {\n\t\tvector<ll> X={1,0,0};\n\t\tFORR(e,E[cur]) if(e!=pre) {\n\t\t\tvector<ll> Y=dfs1(e,cur,lef-1);\n\t\t\tvector<ll> Z={0,0,0};\n\t\t\tint x,y;\n\t\t\tFOR(x,3) FOR(y,3) Z[min(x+y,2)]+=X[x]*Y[y]%mo;\n\t\t\tX[0]=Z[0]%mo;\n\t\t\tX[1]=Z[1]%mo;\n\t\t\tX[2]=Z[2]%mo;\n\t\t}\n\t\tvector<ll> Y={0,0,0};\n\t\tif(no) {\n\t\t\tY=X;\n\t\t}\n\t\telse {\n\t\t\tY[0]=(X[0]*3+X[1]*2+X[2]*2)%mo;\n\t\t\tY[1]=X[1];\n\t\t\tY[2]=X[2];\n\t\t}\n\t\treturn Y;\n\t}\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tauto R=diameter();\n\tif(R.second.size()==1) {\n\t\tvector<ll> X={1,0,0,0};\n\t\tFORR(e,E[R.second[0]]) {\n\t\t\tauto Y=dfs1(e,R.second[0],R.first/2-1);\n\t\t\tvector<ll> Z={0,0,0,0};\n\t\t\tFOR(x,4) FOR(y,3) Z[min(x+(y==2?3:y),3)]+=X[x]*Y[y]%mo;\n\t\t\tFOR(x,4) X[x]=Z[x]%mo;\n\t\t}\n\t\tcout<<X[2]<<endl;\n\t}\n\telse {\n\t\tvector<ll> X=dfs1(R.second[0],R.second[1],R.first/2,1);\n\t\tvector<ll> Y=dfs1(R.second[1],R.second[0],R.first/2,1);\n\t\t\n\t\tcout<<X[1]*Y[1]%mo<<endl;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nstruct edge{int to, cost, id;};\n\nclass Graph\n{\npublic:\n    int N;\n    vector<vector<edge>> G;\n    bools f;\n    mmat dp;\n\n    Graph(int N): N(N){\n        G = vector<vector<edge>>(N, vector<edge>(0));\n        f = bools(N, false);\n        dp = mmat(N, mvec(3, 0));\n    }\n\n    void add_Directed_edge(int from, int to, int cost = 1, int id = 0){\n        G[from].push_back(edge({to, cost, id}));\n    }\n\n    void add_Undirected_edge(int v1, int v2, int cost = 1, int id = 0){\n        add_Directed_edge(v1, v2, cost, id);\n        add_Directed_edge(v2, v1, cost, id);\n    }\n\n    //calculate diameter of a Tree\n    void dfs_for_calcdist(int v, int p, int c, vec &dist){\n        if(p != -1) dist[v] = dist[p] + c;\n        for(auto e: G[v]) if(e.to != p) dfs_for_calcdist(e.to, v, e.cost, dist);\n    } \n\n    int diameter(int &v1, int &v2, int s = 0){\n        vec dist(N, 0);\n        dfs_for_calcdist(s, -1, -1, dist);\n        v1 = distance(dist.begin(), max_element(dist.begin(), dist.end()));\n        fill(dist.begin(), dist.end(), 0);\n        dfs_for_calcdist(v1, -1, -1, dist);\n        auto amax = max_element(dist.begin(), dist.end());\n        v2 = distance(dist.begin(), amax);\n        return *amax;\n    }\n\n    void dfs(int v, int p){\n\n        if(f[v]) dp[v][1] = 1;\n        else dp[v][0] = 1;\n\n        if(p != -1){\n            for(auto e: G[v]) if(e.to != p){\n                dfs(e.to, v);\n                mvec tmp(3, 0);\n                REP(j, 3){\n                    tmp[j] += dp[v][j] * (dp[e.to][0] * 3 + dp[e.to][1] * 2);\n                    tmp[min(j + 1, 2LL)] += dp[v][j] * dp[e.to][1];\n                }\n                dp[v] = tmp;\n            }\n        }else{\n            dp[v] = mvec(4, 0);\n            dp[v][0] = 1;\n            for(auto e: G[v]) if(e.to != p){\n                dfs(e.to, v);\n                mvec tmp(4, 0);\n                REP(j, 4){\n                    tmp[j] += dp[v][j] * (dp[e.to][0] * 3 - dp[e.to][1]);\n                    if((j & 1) == 0) tmp[j | 1] += dp[v][j] * dp[e.to][1];\n                    if((j & 2) == 0) tmp[j | 2] += dp[v][j] * dp[e.to][1];\n                }\n                dp[v] = tmp;\n            }\n        }\n    }\n\n};\n\n\nsigned main(){\n\n    int N; cin >> N;\n    Graph G(N);\n    REP(i, N - 1){\n        int a, b; cin >> a >> b;\n        G.add_Undirected_edge(a - 1, b - 1);\n    }\n\n    int v1, v2;\n    int R = G.diameter(v1, v2);\n    vec d1(N, 0), d2(N, 0);\n    G.dfs_for_calcdist(v1, -1, -1, d1);\n    G.dfs_for_calcdist(v2, -1, -1, d2);\n\n    vec center;\n    REP(i, N) if(d1[i] + d2[i] == R && llabs(d1[i] - d2[i]) <= 1) center.pb(i);\n    \n    fill(all(d1), 0);\n    fill(all(d2), 0);\n    mint ans;\n    if(SZ(center) == 1){\n        G.dfs_for_calcdist(center[0], -1, -1, d1);\n        REP(i, N) if(d1[i] == R / 2) G.f[i] = true;\n\n        G.dfs(center[0], -1);\n        ans = G.dp[center[0]][3] / 2;\n        assert(false);\n\n    }else{\n        G.dfs_for_calcdist(center[0], -1, -1, d1);\n        G.dfs_for_calcdist(center[1], -1, -1, d2);\n        REP(i, N) if(min(d1[i], d2[i]) == R / 2) G.f[i] = true;\n\n        G.dfs(center[0], center[1]);\n        G.dfs(center[1], center[0]);\n        ans = G.dp[center[0]][1] * G.dp[center[1]][1];\n    }\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(std::istream &in, std::ostream &out);\n\nint main() {\n#ifdef LOCAL\n  freopen(\"../IO/f.in\", \"r\", stdin);\n//  freopen(\"../IO/f.out\", \"w\", stdout);\n#else\n  std::ios_base::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  std::cout.tie(nullptr);\n#endif\n  solve(std::cin, std::cout);\n  return 0;\n}\n\nint md = 998244353;\nconstexpr int N = (int)2e5 + 499;\nvector<int> g[N];\nint par[N], dp[N][3][3];\n// dp[V][A][B] - number of ways to choose labels in subtree of V such that |label(v) - label(u)| <= 1 for adjacent vertices\n// and there are exactly A candidates for label D/2 and B candidates for label -D/2\n// since we are interested in labeling with exactly one vertex of both types, it's enough to count number of labelings with more than one candidate instead of an exact number.\n// since root has value 0, the problem is reduced to assigning edge weights.\nvoid dfs1(int v, int p, int d, int &cand, int &mx) {\n  par[v] = p;\n  if (d > mx)\n    mx = d, cand = v;\n  for (int u : g[v])\n    if (u != p)\n      dfs1(u, v, d + 1, cand, mx);\n}\n\nvoid treedp(int v, int p, int left) {\n  if (left == 0) {\n    // depending on the parent-edge value this vertex-candidate may result in states (1, 0), (0, 0), and(0, 1)\n    // so it's ok to say that this vertex is a candidate for both -D/2 and D/2\n    dp[v][1][1] = 1;\n  } else {\n    dp[v][0][0] = 1;\n  }\n  for (int u : g[v]) {\n    if (u == p) continue;\n    treedp(u, v, left - 1);\n    int ndp[3][3] = {};\n    for (int a1 : {0, 1, 2}) {\n      for (int b1 : {0, 1, 2}) {\n        for (int a2 : {0, 1, 2}) {\n          for (int b2 : {0, 1, 2}) {\n            // +1\n            ndp[min(a1 + a2, 2)][b1] = (ndp[min(a1 + a2, 2)][b1] + (int64_t) dp[v][a1][b1] * dp[u][a2][b2] % md) % md;\n            // 0\n            ndp[a1][b1] = (ndp[a1][b1] + (int64_t) dp[v][a1][b1] * dp[u][a2][b2] % md) % md;\n            // -1\n            ndp[a1][min(b1 + b2, 2)] = (ndp[a1][min(b1 + b2, 2)] + (int64_t) dp[v][a1][b1] * dp[u][a2][b2] % md) % md;\n          }\n        }\n      }\n    }\n    for (int a1 : {0, 1, 2}) {\n      for (int a2 : {0, 1, 2}) {\n        dp[v][a1][a2] = ndp[a1][a2];\n      }\n    }\n  }\n}\n\nvoid solve(std::istream &in, std::ostream &out) {\n  int n;\n  in >> n;\n  for (int i = 0, u, v; i < n - 1; ++i) {\n    in >> u >> v;\n    --u;\n    --v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  int u, v, mx = 0;\n  dfs1(0, -1, 0, u, mx);\n  mx = 0;\n  dfs1(u, -1, 0, v, mx);\n  for (int i = 0; i < mx / 2; ++i) {\n    v = par[v];\n    u = par[v];\n  }\n  if (mx % 2 == 1) {\n    treedp(v, u, mx / 2);\n    treedp(u, v, mx / 2);\n    // in fact, any labeling that has at least one -(D - 1)/2 path is ok too\n    // because none of them can form a diameter with (D - 1)/2 path as the resulting path will have length D-1 without an edge u-v\n    // division by 2 in not needed since it's only (D-1)/2 path that will be paired with the other half\n    // if we multiply signs by -1 the other part will be paired, and thus another diameter will be formed\n    int x = ((int64_t) dp[v][1][0] + dp[v][1][1] + dp[v][1][2]) % md;\n    int y = ((int64_t) dp[u][1][0] + dp[u][1][1] + dp[u][1][2]) % md;\n    out << (int64_t) x * y % md << '\\n';\n  } else {\n    treedp(v, -1, mx / 2);\n    // for a fixed diameter we can multiply labels by -1 and still have a valid labeling with the same diameter\n    // thus dividing by 2 is needed\n    out << (int64_t) dp[v][1][1] * (md + 1) / 2 % md << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i,a,b) for (int i=int(a);i<=int(b);i++)\n#define R(i,a,b) for (int i=int(a);i<int(b);i++)\n#define D(i,a,b) for (int i=int(a);i>=int(b);i--)\n#define go(i,x) for (int i=head[x];i;i=Next[i])\n#define pb push_back\n#define si size()\n#define fi first\n#define se second\n#define pa pair < ll,ll >\n#define ll long long\n#define mp make_pair\n#define be begin()\n#define en end()\n#define put putchar('\\n')\n#define gc getchar\n#define pc putchar\n#define N 6000055\n#define mo 998244353\n#define inf 1000000007\n#define ret return puts(\"-1\"),0\nusing namespace std;\ninline ll read(){\n\tll su=0,f=1;char c=gc();\n\tfor (;c<'0'||c>'9';c=gc()) if (c=='-') f=-1;\n\tfor (;c>='0'&&c<='9';c=gc()) su=su*10+c-'0';\n\treturn su*f;\n}\ninline void wr(ll x){\n\tif (x<0) pc('-'),wr(-x);\n\telse{if (x>=10) wr(x/10);pc(x%10+'0');}\n}\ninline void wri(ll x){wr(x);pc(' ');}\ninline void wrn(ll x){wr(x);put;}\ninline void wrn(ll x,ll y){wri(x);wrn(y);}\ninline void wrn(ll x,ll y,ll z){wri(x);wrn(y,z);}\nint ans,n,m,f[N][2],fa[N],dis[N],lo,rt,mx;\ninline void ad(int &x,int k){x+=k;x-=(x>=mo)?mo:0;}\nint Next[N*2],head[N],to[N*2],nedge,g[N][4];\n#define V to[i]\nvoid add(int a,int b){Next[++nedge]=head[a];head[a]=nedge;to[nedge]=b;}\nvoid add_ne(int a,int b){add(a,b);add(b,a);}\nvoid dfs(int x){\n\tmx=(dis[x]>dis[mx])?x:mx;\n\tgo(i,x){\n\t\tif (V==fa[x]) continue;\n\t\tfa[V]=x;dis[V]=dis[x]+1;dfs(V);\n\t}\n}\nint ksm(ll x,int k){\n\tint su=1;\n\tfor (;k;k>>=1,x=x*x%mo) if (k&1) su=su*x%mo;\n\treturn su;\n}\nvoid solve(int x){\n\tint pd=0;\n\tf[x][0]=1;\n\tg[x][0]=1;\n\tgo(i,x){\n\t\tif (V==fa[x]) continue;\n\t\tsolve(V);pd++;\n\t\tg[x][3]=1ll*g[x][3]*g[V][0]%mo;\n\t\tad(g[x][3],1ll*g[x][1]*g[V][2]%mo);\n\t\tad(g[x][3],1ll*g[x][2]*g[V][1]%mo);\n\t\tg[x][1]=1ll*g[x][1]*g[V][0]%mo;\n\t\tg[x][2]=1ll*g[x][2]*g[V][0]%mo;\n\t\tad(g[x][1],1ll*g[x][0]*g[V][1]%mo);\n\t\tad(g[x][2],1ll*g[x][0]*g[V][2]%mo);\n\t\tg[x][0]=1ll*g[x][0]*g[V][0]%mo;\n\t\t\n\t\tf[x][1]=1ll*f[x][1]*f[V][0]%mo;\n\t\tad(f[x][1],1ll*f[x][0]*f[V][1]%mo);\n\t\tf[x][0]=1ll*f[x][0]*f[V][0]%mo;\n\t}\n\tif (pd){\n\t\tf[x][0]=1ll*f[x][0]*3%mo;\n\t\tad(f[x][0],f[x][1]*2%mo);\n\t\tg[x][0]=1ll*g[x][0]*3%mo;\n\t\tad(g[x][0],((g[x][1]+g[x][2])%mo*2%mo+g[x][3])%mo);\n\t\tad(g[x][1],g[x][3]);ad(g[x][2],g[x][3]);\n\t}\n\telse{\n\t\tif (dis[x]==lo/2) f[x][1]=1,f[x][0]=2,g[x][1]=g[x][0]=g[x][2]=1;\n\t\telse f[x][0]=3,g[x][0]=3;\n\t}\n}\nsigned main(){\n\tn=read();\n\tR(i,1,n) add_ne(read(),read());\n\tdfs(1);\n\trt=mx;mx=0;dis[rt]=0;fa[rt]=0;\n\tdfs(rt);\n\tlo=dis[mx];\n\tF(i,1,lo/2) mx=fa[mx];\n\tif (lo&1){\n\t\tint x=mx,y=fa[mx];\n\t\tfa[y]=x;dis[x]=dis[y]=0;dfs(x);dfs(y);\n\t\t//solve(x);solve(y);\n\t\twrn(ksm(3,n-lo-1));\n\t}\n\telse{\n\t\tint x=mx,nu=0;\n\t\tfa[x]=0;dis[x]=0;dfs(x);\n\t\tF(i,1,n) if (dis[i]==lo/2) nu++;\n\t\t//ans=(1ll*nu*(nu-1)/2)%mo*ksm(3,n-lo-1)%mo;\n\t\tsolve(x);\n\t\tf[x][0]=1;f[x][1]=0;\n\t\tgo(i,x){\n\t\t\tans=1ll*ans*g[V][0]%mo;\n\t\t\tad(ans,1ll*f[x][1]*f[V][1]%mo);\n\t\t\tf[x][1]=1ll*f[x][1]*g[V][0]%mo;\n\t\t\tad(f[x][1],1ll*f[x][0]*f[V][1]%mo);\n\t\t\tf[x][0]=1ll*f[x][0]*g[V][0]%mo;\t\t\t\n\t\t}\n\t\twrn(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[202020];\nconst ll mo=998244353;\nll dp[202020][3][3];\n\npair<int,int> farthest(int cur,int pre,int d,vector<int>& D) {\n\tD[cur]=d;\n\tpair<int,int> r={d,cur};\n\tFORR(e,E[cur]) if(e!=pre) r=max(r, farthest(e,cur,d+1,D));\n\treturn r;\n}\n\npair<int,vector<int>> diameter() { // diameter,center\n\tvector<int> D[2];\n\tD[0].resize(N);\n\tD[1].resize(N);\n\tauto v1=farthest(0,0,0,D[0]);\n\tauto v2=farthest(v1.second,v1.second,0,D[0]);\n\tfarthest(v2.second,v2.second,0,D[1]);\n\tpair<int,vector<int>> R;\n\tR.first = v2.first;\n\t//重心を取る場合\n\tfor(int i=N-1;i>=0;i--) if(D[0][i]+D[1][i]==R.first && abs(D[0][i]-D[1][i])<=1) R.second.push_back(i);\n\n\treturn R;\n}\n\nvoid dfs(int cur,int pre,int lef) {\n\tif(lef==0) {\n\t\tdp[cur][1][1]=1;\n\t}\n\telse {\n\t\tdp[cur][0][0]=1;\n\t}\n\t\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\tdfs(e,cur,lef-1);\n\t\tll to[3][3]={};\n\t\tint a1,a2,b1,b2;\n\t\tFOR(a1,3) FOR(a2,3) FOR(b1,3) FOR(b2,3) {\n\t\t\t// +1\n\t\t\tto[min(a1+b1,2)][a2]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t\t// 0\n\t\t\tto[a1][a2]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t\t// -1\n\t\t\tto[a1][min(a2+b2,2)]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t}\n\t\t\n\t\tFOR(a1,3) FOR(a2,3) dp[cur][a1][a2]=to[a1][a2]%mo;\n\t}\n\t\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tauto R=diameter();\n\tif(R.second.size()==1) {\n\t\tx=R.second[0];\n\t\tdfs(x,-1,R.first/2);\n\t\tcout<<dp[x][1][1]*((mo+1)/2)%mo<<endl;\n\t}\n\telse {\n\t\tx=R.second[0];\n\t\ty=R.second[1];\n\t\tdfs(x,y,R.first/2);\n\t\tdfs(y,x,R.first/2);\n\t\tdp[x][0][1]+=dp[x][1][1];\n\t\tdp[x][1][0]+=dp[x][1][1];\n\t\tdp[y][0][1]+=dp[y][1][1];\n\t\tdp[y][1][0]+=dp[y][1][1];\n\t\tll ret=(dp[x][0][1]%mo*dp[y][1][0])%mo;\n\t\tcout<<ret<<endl;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\nconst ll mod = 998244353;\nll dp[200100][3][3];\nvector<ll> paths[200100];\nll N;\nvector<ll> C;\nll dist[2][200010];\nll depthmax[2];\nvoid dfs(int idx, int now, int from) {\n    for(auto to : paths[now]) {\n        if(to == from) continue;\n        dist[idx][to] = dist[idx][now] + 1;\n        dfs(idx, to, now);\n    }\n}\n\nvoid merge(int p, int c) {\n    vector<vector<ll>> tmp(3, vector<ll>(3, 0));\n    for(int pi = 0; pi < 3; pi++) {\n        for(int pj = 0; pj < 3; pj++) {\n            for(int ci = 0; ci < 3; ci++) {\n                for(int cj = 0; cj < 3; cj++) {\n                    for(int len = -1; len <= 1; len++) {\n                        int newi = 2;\n                        if(len != 1) newi = pi;\n                        else if(pi + ci <= 1) newi = pi + ci;\n                        int newj = 2;\n                        if(len != -1) newj = pj;\n                        else if(pj + cj <= 1) newj = pj + cj;\n                        tmp[newi][newj] += dp[p][pi][pj] * dp[c][ci][cj];\n                        tmp[newi][newj] %= mod;\n                    }\n                }\n            }\n        }\n    }\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 3; j++) {\n            dp[p][i][j] = tmp[i][j];\n        }\n    }\n}\n\nvoid f(int idx, int now, int from) {\n    bool IsLeaf = true;\n    for(auto to : paths[now]) {\n        if(to == from) continue;\n        IsLeaf = false;\n        f(idx, to, now);\n    }\n    if(IsLeaf) {\n        //cerr << \"ifleaf: \" << idx << \" \" << now << \" \" << depthmax[idx] << \" \" << dist[idx][now] << endl;\n        if(dist[idx][now] == depthmax[idx]) {\n            dp[now][1][1] = 1;\n        } else {\n            dp[now][0][0] = 1;\n        }\n        return;\n    }\n    dp[now][0][0] = 1;\n    for(auto to : paths[now]) {\n        if(to == from) continue;\n        merge(now, to);\n    }\n    return;\n}\n\nll beki(ll a, ll b) {\n    if(b == 0) return 1;\n    ll ret = beki(a, b / 2);\n    ret = ret * ret % mod;\n    if(b & 1) ret = ret * a % mod;\n    return ret;\n}\n\nint main() {\n    cin >> N;\n    for(int i = 0; i < N - 1; i++) {\n        ll a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        paths[a].push_back(b);\n        paths[b].push_back(a);\n    }\n    dfs(0, 0, -1);\n    ll v1 = 0;\n    for(int i = 0; i < N; i++) {\n        if(dist[0][v1] < dist[0][i]) v1 = i;\n    }\n    dfs(1, v1, -1);\n    ll v2 = 0;\n    for(int i = 0; i < N; i++) {\n        if(dist[1][v2] < dist[1][i]) v2 = i;\n    }\n    dist[0][v2] = 0;\n    dfs(0, v2, -1);\n    C.push_back(0);\n    //cerr << v1 << \" \" << v2 << endl;\n    for(int i = 1; i < N; i++) {\n        //cerr << i << \" \" << dist[0][i] << \" \" << dist[1][i] << endl;\n        if(dist[0][i] + dist[1][i] != dist[0][v1]) continue;\n        if(max(dist[0][C[0]], dist[1][C[0]]) == max(dist[0][i], dist[1][i])) {\n            C.push_back(i);\n        }\n        if(max(dist[0][C[0]], dist[1][C[0]]) > max(dist[0][i], dist[1][i])) {\n            C.clear();\n            C.push_back(i);\n        }\n    }\n    assert(C.size() == 1 or C.size() == 2);\n    /*\n    cerr << \"--------C--------\" << endl;\n    for(auto tmp : C) {\n        cerr << tmp << \" \";\n    }\n    cerr << endl;\n    */\n    for(int i = 0; i < N; i++) {\n        dist[0][i] = dist[1][i] = 0;\n    }\n    for(int i = 0; i < C.size(); i++) {\n        dfs(i, C[i], C[(i+1) % C.size()]);\n        for(int j = 0; j < N; j++) {\n            chmax(depthmax[i], dist[i][j]);\n        }\n        //cerr << i << \" \" << C[i] << \" \" << depthmax[i] << endl;\n        f(i, C[i], C[(i+1)%C.size()]);\n        for(int j = 0; j < 3; j++) {\n            for(int k = 0; k < 3; k++) {\n                //cerr << C[i] << \" \" << j << \" \" << k << \" \" << dp[C[i]][j][k] << endl;\n            }\n        }\n    }\n    if(C.size() == 1) {\n        cout << dp[C[0]][1][1] * beki(2, mod - 2) % mod << endl;\n        return 0;\n    } else {\n        ll ans = 0;\n        for(int i0 = 0; i0 < 3; i0++) {\n            for(int j0 = 0; j0 < 3; j0++) {\n                for(int i1 = 0; i1 < 3; i1++) {\n                    for(int j1 = 0; j1 < 3; j1++) {\n                        ll ok = 0;\n                        if(i0 == 1 and j1 == 1) ok++;\n                        if(j0 == 1 and i1 == 1) ok++;\n                        ans += ok * dp[C[0]][i0][j0] * dp[C[1]][i1][j1] % mod;\n                        ans %= mod;\n                    }\n                }\n            }\n        }\n        ans *= beki(2, mod - 2);\n        ans %= mod;\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define sz(a) int(a.size())\nconst int N=2e5+10;\nconst int mod=998244353;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nint n,f[N][3][3],mx,p,fa[N],st[N],md[N],tp;\nvi E[N];\n\nvoid dfs(int u,int ff,int dis) {\n\tfa[u]=ff;\n\tif(dis>mx) mx=dis,p=u;\n\tfor(auto v:E[u]) if(v!=ff) dfs(v,u,dis+1);\n}\n\nvoid dp(int u,int ff) {\n\tmd[u]=0;\n\tfor(auto v:E[u]) if(v!=ff) dp(v,u),md[u]=max(md[u],md[v]);\n\tif(md[u]==0) f[u][1][1]=1;\n\telse f[u][0][0]=1;\n\tfor(auto v:E[u])\n\t\tif(v!=ff) {\n\t\t\tstatic int g[3][3];memset(g,0,sizeof(g));\n\t\t\tfor(int i=0;i<3;i++)\n\t\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\t\t\tfor(int l=0;l<3;l++) {\n\t\t\t\t\t\t\tint &t=g[min(i+(md[u]==md[v]?k:0),2)][min(j+(md[u]==md[v]?l:0),2)];\n\t\t\t\t\t\t\tt=(t+1ll*f[u][i][j]*f[v][k][l])%mod;\n\t\t\t\t\t\t}\n\t\t\tfor(int i=0;i<3;i++)\n\t\t\t\tfor(int j=0;j<3;j++) f[u][i][j]=g[i][j];\n\t\t}\n\tif(ff) {\n\t\tstatic int g[3][3];memset(g,0,sizeof(g));\n\t\tfor(int i=0;i<3;i++)\n\t\t\tfor(int j=0;j<3;j++) {\n\t\t\t\tg[0][0]=(g[0][0]+f[u][i][j])%mod;\n\t\t\t\tg[i][0]=(g[i][0]+f[u][i][j])%mod;\n\t\t\t\tg[0][j]=(g[0][j]+f[u][i][j])%mod;\n\t\t\t}\n\t\tfor(int i=0;i<3;i++)\n\t\t\tfor(int j=0;j<3;j++) f[u][i][j]=g[i][j];\n\t\t++md[u];\n\t}\n}\n\nint main() {\n\tcin>>n;\n\tfor(int i=1,u,v;i<n;i++) u=gi(),v=gi(),E[u].pb(v),E[v].pb(u);\n\tdfs(1,0,0);mx=0;dfs(p,0,0);\n\tfor(int i=p;i;i=fa[i]) st[++tp]=i;\n\tif(tp&1) {\n\t\tint x=st[(tp+1)/2];\n\t\t//cerr<<x<<'\\n';\n\t\tdp(x,0);cout<<1ll*f[x][1][1]*((mod+1)>>1)%mod;\n\t}\n\telse {\n\t\tint x=st[tp/2],y=st[tp/2+1];\n\t\tdp(x,y);dp(y,x);cout<<1ll*f[x][0][1]*f[y][1][0]%mod;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*&@@@@@@@@&&&&&&&&&&&@@@@@@@@&%$$!'''..                                   .!&&&&&&&$$$$$$$$$$$%%%%%%%%%%%%%%%%%%%%%%%|\n@@@@@@@@@@@@@@@@&&&&&@@@@&&&&&%%|:`.                                          `|$$$$$$$%%%%%%%%%%||||||||||||||||||||||\n@@@@@@@@@@@@@@@@@@&@@@&&$&&$!;:.                                                .;%%%%%%%%||||||||||!!!!|||||||||||||||\n@@@@@@@@@@@@@@@@@@@&&&$%$&$%;.                                                    .:|||||||||!!!!!!!!!!!!!!!|||||||||||\n@@@@@@@@@@@@@@&&&&&$$$$$$|'                                                          '||||||!!!!!!!!!!!!!!!!!!|||||||||\n@@@@@@@@&&&&&&&&&&&$%|%!`        ....                                                 .'||||!!!!!!!!!!!!!!!!!!|||||||||\n&&&&&&&&&&&&&$$$$$$$%!'         ...                                                     .;|||!!!!!!!!!!!!!!!!!!!|||||||\n&&&&&&$$$$$$$$$$$$%|:.         ...                                                      ..'!|||||||||||||||||||||||||||\n$$$$$$$$$$$$%%%%%|;`          ....            ......                                     ..`;||||||||||||||||||||||||||\n%%%%%%%%%%%%%%%|!:..         ..`..    ..........   .                               ....     `;|||||||||||||||||||||||||\n%%||%||%|%%%%||!:`.          .``..        ..........                          .        ....  `;||||||||||||||||||||||||\n||||||||||||%|!;'.          ..``...      .....  ........                      ......    ..... .:|||||||||||||||||||||||\n|||||||||||||!;:`        ....```..    ..............                          .  ...............:||||||||||||||||||||||\n||||||||||%||!:'.      .   ..`'`.......................  .    .....              ......... ......:|%|||||||||||||||||||\n|||||||||%||!;'.          ..````..........................               ....       ..............:|%%%||||||||||||||||\n||||||||%||!;:`. ..      ...`'''``...............................                       ........  `;%||||||||||||||||||\n||||||%%%||!;:..... .......``''''```..........................................  `:;;;'.   ........ `;%|||||||||||||||||\n|||||||||%|!:`.............`''''''''`````````````.................................````...  ........ `;|||||||||||||||||\n||||||||||!:`............``'::::::::'''``'''``````````.............    ........`....```...   ........'!||||||||||||||||\n||||||||||;`............``':;;;;!;;;::::'''::'''``....................     ...`'````````....   .......:||||||||||||||||\n|||||||||;`....     ...``':;;!!!!!!!!;;;:::::::::''`````.....................':::'``````'``..   ..  ...:|||||||||||||||\n|||||||!'..         ..``':;;!!!!!!!!!!!;;;;;;;:::::'''```````````....```````'::::''''''''''``..   .  ...:||||||||||||||\n|||||!:'`.          .`'':;;!!!!!!||!!!!!!!!!;;;;;;::::::'''''''''''''''`''''''':::'''''''::`....       ..:|||||||||||||\n|||!;;'..          .`''::;;!!!!!|||||||!!!!!!!!!!!!;;;;;;;;;;;;;;;;;;;;;;;:::;:::::'''';;;:'.   .    .   .:||||||||||||\n||;!;:'`            `'::;;;!!!!!||||||||!!!!!!!!!!!!!!!!!!!!!!!!!||||||!;;;::::;;;::'':;:::'.             .:||||||||||!\n|!!!:'`.            .'::;;;!!!!!!|||||||||!!!!!!!!|!!!!!!!!!!!|||||%%%%||!;;;::::::::::::;:`..             .:|||||||||!\n!!!;''`.            .'::;;;!!!!!!!!||||!!!!||||!!!!!!;;;!!!!!!||||%%%|||||!!;;:;;;;:'':::'.                  :||||||||!\n!|!:''`.             `'::;;;!!!!!!!!!!!!!!!!!!!;::'':;;!!!!!!!|||||||||||||!!;;;;;;;:::''`.                   '!||||||!\n!!!:''`.             .`':;;;!!!!!!!!!!!!!!;:''''':;;;;;;;;!!!!||||||||||||!!!;;;;;;;:::''`..                   `;|!!!|!\n!!!:'`.               .'::;;;;!!!!!!!!;:''``':;;;;;;;;;;;;;!!|||||||||||||!!!!!;;;;;;:::''`..                   .:|||!!\n||!:'`..               `'::;;;;;;!;;;;:''':;;;;;;;;;::'`';!!||||||||||||||!!!!!!!!!;;;:::'`..                     '!|||\n|!!:'`..                `:::::;;;;;;;;;;::;;;::::::''``';!!|||||||||||||||!!!!!!!!!!;;;;::'`.                      `;||\n||!;'.                   ....``'::;;;!!;;;;;::'''`...`:;!!!|||||||||||||||!!!!!!!!!!!;;;;::'`..                 .   .'!\n%||;'..  ..               .`''::::::;!!!!!!;;;::''`::;;!!!||||||||||||||||||||||||!!!!!;;;;::'`.                      '\n|%|!:`.                     `'':::'::;!||||!!!!!!;;;;!!!!!||||||||||||||||||||||||||!!!!!;;;;;:'`.                    .\n||%|;`                        `````..`;|||||||||||!!!!!!!!|||||||||||||||||||||%||||||!!!!!!!!;::'`..                 .\n%|%%|'.  ..                    .....`':!||||||||||||!!||||||||||!!!|||||||%%%%%%%||||||!!|||||!!;:''`.                .\n|||%|;.                         .`''::;;|||||||||||!!!!|||||!!!!!!!|||||||%%%%%%|%%%||||||||||||!!;;:'`..             .\n|||%|!'.  ..                     `':::;;!|%|||||||!!!!!!!!!!!!!!!!!||||||%%%%%%%%%%%%|||||%%%|||||!!!;;:'`.           .\n||||||;`   ..                     `::;;;!|||||||||||!!!!!!!!!!!!!!!!!||||%%%%%%%$$%%%|||||%%%%%||||||||!!;:'`.        .\n||||||!:`  ...                     .::;;;!|||||||||||!!!!!!!!!!!!!!!!!||||||%%%%$$%%%||||%%%%%%%%||||%%%||!;;:'.      .\n|||||||;`     ..                    .':;;!|||||||||!!!;!!!!!!!!!!!!!!!!||||||%%%%%%%%||||%%%%%%%%%%%%%%%%%%%||!;:''`. .\n!!!!!!||;`.    ..              .      `:;;;!!!!!!;::;;!!!!!!!!!!!!!!!!!!|||||||||%%%||||%%%%%%%%||||%%%%%%%%%%%||!;;;::\n!!!!!!!!!:.  .......                    `::;;;;;;:;;;!!!||!!!;;;;:;;;!!!!!|||!!!|||||||%%%%%%%|||!||||%%%$$$%%%|||!!!!!\n!!!!!!!!!!:.  .......          .          `:::;;;;;;!!!!!!;;;:::;;;;;;!!!!!!!!!!!||||||%%%%%%%%|||!!!||||||||||||||!!!!\n;;;;;;!!!!!:`..........       ...           .`:::::;;;;;:'``':;!!!!!!!!!!|!!!!!!!||||||||%%%%%%%%%|||!!!!!!!!!!!!!!!!!!\n;;;;;;;!!!!!:`..........        .              .`::::''''':;;!!!!!!!!!|||||!!!!!!!!!!!||||||%%%$$$$%%|||!!!!!!!!!!!!!!!\n;;;;;!!!!!!!!;`............. ..                   .`::::;;;;;;;;;;!!!||%%||!!!!!!!;;;!!!!||||%%$$&&&$$%%%|||||||||||||!\n!!!!!!!!!!!!!!!:`............        ..               .':::::::;;!!|||%%%||!!!!;;;;;;;;;!!!!||%%$&&&&&$$$$$%%%%||||||||\n!!!!!!!!!!|!!!!!:`...............     .      ....        `::;;;!!||||||%||!!!:''::::;;;;;!!!!!|%$&&&&&&&$$$$%%%||||||||\n!!!!!!|||||||||!;`............         ...........         .';;!!!!!!!!!!!!;::::::::;;;;;!!!!!!|%$&&&&&&&$$$$%%%|||||||\n||||||||||||||||;`........... ...      .......`...           .';;;;;;;!!:``'':::;;;;;;!!!!|||||||$&@@@&&&&$$$$%%%%|||||\n||||||||||||||||:``.............       .............            .`':'`.....`':::;;;!!!!||%%%%%%||$@@@@@@&&&$$$%%%%%%%%|\n|||||||||||||%|!:'`.............      . ............                   ....`':::;;!|%$$$$$$$$$%%|%&@##@@@&&$$$$$$$$%%$%\n||||||||||%%%%|;;;`......  ....      ... ....     ...        ..       .....`':::;;!%$&&&&&&&&&&$%$&@@@@@@&&$$$$$$$$$$$$\n||||||%%%%%%%%%!;:'`.....   ...             ..     .......    ..   .....```''::;;!|%$&&@@@@@@@&&$$&&@@@@@&$$%%%%%%%$$$$\n%%%%%%%%%%%%%%%!!;'`...........               ...... ..........   ..``````'':;!%%$$$&&@@@###@@@@&&&&&&&$$%%%|||||%$$$&$\n%%%%%%%%%%%%%%%|!;'.....`''`..      .          ...............    .``````':!%%||||%$&@@######@@@&&&$$%%%||||||||%$&&&&&\n%%%%%%%%%%%%%%%|!:`.......`...     ...````''``````````````.......``''':;|%%|!!!!!!|%$@########@@@&$%%||||||||%%%$&&&@@@\n|%%%%%%%%%%%%%%%|;'`.`'`. .....`''''''::::::::::::::::;;:::'::::::;;;;!%%||!!!!!!!||$&########@&$%%|||||||%%$$$&@@@@@#@\nCoded by Shinmurn Shar, a 21-yr-old beautiful girl.\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define loop(i,n) for(int i=0;i<(n);i++)\n#define pool(i,n) for(int i=(n)-1;i>=0;i--)\n#define cont(i,n) for(int i=1;i<=(n);i++)\n#define tnoc(i,n) for(int i=(n);i>=1;i--)\n#define circ(i,a,b) for(int i=(a);i<=(b);i++)\n#define cric(i,a,b) for(int i=(b);i>=(a);i--)\n#define sub(i,a) for(int i=a;i;i=((i-1)&(a)))\n#define subs(i,a) for(int i=a;i>=0;i=(!i?-1:((i-1)&(a))))\n#define range(i,a,b,c) for(int i=(a);((c)>0?i<=(b):i>=(b));i+=(c))\n#define foreach(it,v) for(__typeof((v).begin()) it=(v).begin(),_e_D_=(v).end();it!=_e_D_;it++)\n#define parse(i,s) for(int i=0;s[i];i++)\n#define ln '\\n'\n#define all(a) a.begin(),a.end()\n#define OVER(s) return puts(s),0;\n#define FILL0(a) memset(a,0,sizeof(a))\n#define FILL1(a) memset(a,-1,sizeof(a))\n#define FILLBIG(a) memset(a,0x3f,sizeof(a))\n#define COPY(frm,to) memcpy(to,frm,sizeof(frm))\n#define Mask(a) (1ll<<(a))\n#define Maskx(a,x) ((a)<<(x))\n#define Full(a) ((1ll<<(a))-1)\n#define Bit(a,x) (((a)>>(x))&1)\n#define SZ(a) ((int)((a).size()))\n#define filei(a) freopen(a,\"r\",stdin);\n#define fileo(a) freopen(a,\"w\",stdout);\n#define fileio(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\n#define Floyd(a,n) cont(k,n)cont(i,n)cont(j,n)chmin(a[i][j],a[i][k]+a[k][j])\n#define Floyd0(a,n) loop(k,n)loop(i,n)loop(j,n)chmin(a[i][j],a[i][k]+a[k][j])\n#define Floydlr(a,l,r) circ(k,l,r)circ(i,l,r)circ(j,l,r)chmin(a[i][j],a[i][k]+a[k][j])\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define y0 y0O0OO00OO0OO0OO0OOO00OO0OO0O0O000OO0\n#define y1 y1II11II11III11I1III11II111IIII1II1I1\n#define ws WSrAkIoi2333wSraKIoIWSraKiOi\n#define left left_jTjTJtJtIoiiOiioIAuaU66666jtIOIau\n#define hash whYusEthiSnamE_caNyoUusEothERnaMesliKeHSH\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define mak make_pair\n#define emb emplace_back\n#define emf emplace_front\n#define emp emplace\n#define popcnt __builtin_popcount\n#define Popcnt __builtin_popcountll\ntemplate<typename _T>\nusing pair2=pair<_T,_T>;\ntemplate<typename _T>\nusing pair3=pair<pair<_T,_T>,_T>;\ntemplate<typename _T>\nusing pair4=pair<pair<_T,_T>,pair<_T,_T> >;\n#define mak3(a,b,c) make_pair(make_pair(a,b),c)\n#define mak4(a,b,c,d) make_pair(make_pair(a,b),make_pair(c,d))\ntemplate<typename _T>\nusing priq=priority_queue<_T>;\ntemplate<typename _T>\nusing qrip=priority_queue<_T,vector<_T>,greater<_T> >;\n#define ST first\n#define ND second\n#define FST first.first\n#define SND first.second\n#define RD second\n#define SRD second.first\n#define FTH second.second\n#ifndef JTAKIOI\n#define cerr if(0)cout\n#define tctest(clas,meth,...)\n#else\n#define tctest(clas,meth,...) int main(){fio<<(new clas)->meth(__VA_ARGS__)<<ln;}\n#endif\ntypedef long long ll;\ntypedef long double lf;\ntypedef istringstream iss;\ntypedef stringstream sst;\nconst lf pi=acosl(-1);\nconst int Inf=0x3f3f3f3f;\nconst ll INF=0x3f3f3f3f3f3f3f3fll;\nconst int dx[]={1,0,-1,0,1,1,-1,-1},dy[]={0,1,0,-1,1,-1,1,-1};\nunsigned Rand(){return rand()*32768+rand();}\nint rand(int a,int b){return Rand()%(b-a+1)+a;}\ntemplate<typename _T>\ninline _T chmin(_T &a,_T b){return a>b?(a=b):a;}\ntemplate<typename _T>\ninline _T chmax(_T &a,_T b){return a<b?(a=b):a;}\ntemplate<typename _T,int len>\nstruct BIT{\n\t_T dt[len];\n\tinline void add(int a,_T x){while(a<len){dt[a]+=x;a+=a&-a;}}\n\tinline void add(int l,int r,_T x){add(l,x);add(r+1,-x);}\n\tinline _T get(int a){_T ans=0;while(a){ans+=dt[a];a-=a&-a;}return ans;}\n\tinline _T get(int l,int r){return get(r)-get(l-1);}\n};\ntemplate<typename _T,int len>\nstruct segbit{\n\t_T dt[2][len];\n\tinline void add(int a,_T x){int b=a;while(a<len){dt[0][a]+=x;dt[1][a]+=x*b;a+=a&-a;}}\n\tinline void add(int l,int r,_T x){add(l,x);add(r+1,-x);}\n\tinline _T sum(int a){_T ans=0;int b=a;while(a){ans+=(b+1)*dt[0][a]-dt[1][a];a-=a&-a;}return ans;}\n\tinline _T sum(int l,int r){return sum(r)-sum(l-1);}\n};\nstruct fastIO{\n\tinline fastIO operator>>(int& num){\n\t\tnum=0;char c=getchar();while(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;if(c=='-'){foo=1;c=getchar();}\n\t\twhile(c>='0'&&c<='9'){num=(num<<3)+(num<<1)+c-'0';c=getchar();}\n\t\tif(foo)num=-num;return *this;\n\t}\n\tinline fastIO operator>>(ll& num){\n\t\tnum=0;char c=getchar();while(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;if(c=='-'){foo=1;c=getchar();}\n\t\twhile(c>='0'&&c<='9'){num=(num<<3)+(num<<1)+c-'0';c=getchar();}\n\t\tif(foo)num=-num;return *this;\n\t}\n\tinline fastIO operator>>(float& num){scanf(\"%f\",&num);return *this;}\n\tinline fastIO operator>>(double& num){scanf(\"%lf\",&num);return *this;}\n\tinline fastIO operator>>(long double& num){scanf(\"%Lf\",&num);return *this;}\n\tinline fastIO operator>>(char& num){num=getchar();while(num==' '||num=='\\n')num=getchar();return *this;}\n\tinline fastIO operator>>(char* num){\n\t\tint cnt=0;char c=getchar();while(c==' '||c=='\\n')c=getchar();\n\t\twhile(c!=' '&&c!='\\n'){num[cnt++]=c;c=getchar();}num[cnt]=0;return *this;\n\t}\n\tinline fastIO operator>>(string& num){cin>>num;return *this;}\n\tinline void printInt(const int& num){if(num<10){putchar(num+'0');return;}printInt(num/10);putchar((num%10)+'0');}\n\tinline void printll(const ll& num){if(num<10){putchar(num+'0');return;}printll(num/10);putchar((num%10)+'0');}\n\tinline fastIO operator<<(const int& num){if(num<0)putchar('-'),printInt(-num);else printInt(num);return *this;}\n\tinline fastIO operator<<(const ll& num){if(num<0)putchar('-'),printll(-num);else printll(num);return *this;}\n\tinline fastIO operator<<(const float& num){printf(\"%.10f\",num);return *this;}\n\tinline fastIO operator<<(const double& num){printf(\"%.16lf\",num);return *this;}\n\tinline fastIO operator<<(const long double& num){printf(\"%.20Lf\",num);return *this;}\n\tinline fastIO operator<<(const char& num){putchar(num);return *this;}\n\tinline fastIO operator<<(const char* num){for(int i=0;num[i];i++)putchar(num[i]);return *this;}\n\tinline fastIO operator<<(const string& num){cout<<num;return *this;}\n\ttemplate<typename _T> inline fastIO operator<<(const vector<_T> &vec){printf(\"{ \");foreach(i,vec)operator<<(*i)<<' ';printf(\"}\");return *this;}\n}fio;\nconst lf eps=1e-10;\nstruct point{\n\tlf x,y;\n\tlf ang;\n\tpoint(){}\n\tpoint(lf x,lf y):x(x),y(y){ang=atan2l(y,x);}\n\tinline point operator=(const point &pt){x=pt.x;y=pt.y;return *this;}\n\tinline point operator-()const{return point(-x,-y);}\n\tinline point operator+(const point &pt)const{return point(x+pt.x,y+pt.y);}\n\tinline point operator-(const point &pt)const{return point(x-pt.x,y-pt.y);}\n\tinline point operator*(const lf &a)const{return point(x*a,y*a);}\n\tinline point operator/(const lf &a)const{return point(x/a,y/a);}\n\tinline point operator^(const lf &ang)const{return point(x*cosl(ang)-y*sinl(ang),x*sinl(ang)+y*cosl(ang));}\n\tinline point operator+=(const point &pt){return *this=point(x+pt.x,y+pt.y);}\n\tinline point operator-=(const point &pt){return *this=point(x-pt.x,y-pt.y);}\n\tinline point operator*=(const lf &a){return *this=point(x*a,y*a);}\n\tinline point operator/=(const lf &a){return *this=point(x/a,y/a);}\n\tinline point operator^=(const lf &ang){return *this=point(x*cosl(ang)-y*sinl(ang),x*sinl(ang)+y*cosl(ang));}\n\tinline lf operator*(const point &pt)const{return x*pt.x+y*pt.y;}//dot\n\tinline lf operator%(const point &pt)const{return x*pt.y-y*pt.x;}//det\n\tinline lf length()const{return x*x+y*y;}\n\tinline lf size()const{return sqrtl(x*x+y*y);}\n\tinline lf operator^(const point &pt)const{return acosl(*this*pt)/length()/pt.length();}\n\tinline lf getangle(){return ang=atan2l(y,x);}\n\tinline lf angle()const{return atan2l(y,x);}\n\tinline bool operator<(const point &p)const{return ang<p.ang;}\n};\ninline bool xsmaller(const point &x,const point &y){return fabs(x.x-y.x)<1e-10?x.y<y.y:x.x<y.x;}\ninline bool ysmaller(const point &x,const point &y){return fabs(x.y-y.y)<1e-10?x.x<y.x:x.y<y.y;}\nstruct line{\n\tpoint a,b;\n\tline(){}\n\tline(point a,point b):a(a),b(b){}\n};\npoint intersect(line x,line y){\n\tpoint p1=x.a,v1=x.b-x.a;\n\tpoint p2=y.a,v2=y.b-y.a;\n\treturn p1+v1*(((p2-p1)%v2)/(v1%v2));\n}\nconst int jt=998244353;\ninline int &Add(int &a,int b){\n\ta+=b;\n\tif(a>jt){a-=jt;}\n\tif(a<0){a+=jt;}\n\treturn a;\n}\ninline int &Sub(int &a,int b){\n\ta-=b;\n\tif(a>jt){a-=jt;}\n\tif(a<0){a+=jt;}\n\treturn a;\n}\ninline int &Mul(int &a,int b){\n\ta=1ll*a*b%jt;\n\tif(a<0){a+=jt;}\n\treturn a;\n}\ninline int Jar(int a){\n\treturn a;\n}\ntemplate<typename ... tps>\ninline int Jar(int a,tps ... args){\n\ta+=Jar(args ...);\n\tif(a>jt){a-=jt;}\n\tif(a<0){a+=jt;}\n\treturn a;\n}\ninline int Jan(int a,int b){\n\ta-=b;\n\tif(a>jt){a-=jt;}\n\tif(a<0){a+=jt;}\n\treturn a;\n}\ninline int Churn(int a){\n\treturn a;\n}\ntemplate<typename ... tps>\ninline int Churn(int a,tps ... args){\n\ta=1ll*a*Churn(args ...)%jt;\n\tif(a<0){a+=jt;}\n\treturn a;\n}\ninline int ksmii(int a,int b=jt-2){\n\tif(b<0){return ksmii(ksmii(a),-b);}\n\tif(!b){return 1;}\n\tint x=ksmii(a,b>>1);x=1ll*x*x%jt;\n\tif(b&1)x=1ll*x*a%jt;return x;\n}\ntemplate<int len>\nstruct bitmod{\n\tint dt[len];\n\tinline void add(int a,int x){while(a<len){dt[a]=(dt[a]+x)%jt;a+=a&-a;}}\n\tinline void add(int l,int r,int x){add(l,x%jt);add(r+1,jt-x%jt);}\n\tinline int get(int a){int ans=0;while(a){ans=(ans+dt[a])%jt;a-=a&-a;}return ans;}\n\tinline int get(int l,int r){return (get(r)-get(l-1)+jt)%jt;}\n};\ntemplate<int len>\nstruct DSU{\n\tint fa[len],sz[len];\n\tDSU(){loop(i,len)fa[i]=i,sz[i]=1;}\n\tvoid init(){loop(i,len)fa[i]=i,sz[i]=1;}\n\tint root(int x){return fa[x]==x?x:(fa[x]=root(fa[x]));}\n\tbool conn(int a,int b){a=root(a);b=root(b);if(a==b)return 0;fa[a]=b;sz[b]+=sz[a];return 1;}\n};\ntemplate<typename _T>\ninline _T qp(_T a,int b){\n\tif(!b){return 1;}\n\t_T x=qp(a,b>>1);x=x*x;\n\tif(b&1){x=x*a;}return x;\n}\ntemplate<int R,int C=R>\nstruct matrix{\n\tint mat[R][C];\n\tint* operator[](int x){\n\t\treturn mat[x];\n\t}\n\tmatrix(){loop(i,R)loop(j,C)mat[i][j]=0;}\n\tmatrix(int x){loop(i,R)loop(j,C)mat[i][j]=(i==j?x:0);}\n\tmatrix<R,C> operator+(const matrix<R,C> m){\n\t\tmatrix<R,C> ans;\n\t\tloop(i,R)loop(j,C)ans.mat[i][j]=(mat[i][j]+m.mat[i][j])%jt;\n\t\treturn ans;\n\t}\n\ttemplate<int D>\n\tmatrix<R,D> operator*(const matrix<C,D> m){\n\t\tmatrix<R,D> ans;\n\t\tloop(i,R)loop(j,C)loop(k,D)ans.mat[i][k]=(ans.mat[i][k]+((ll)mat[i][j])*m.mat[j][k])%jt;\n\t\treturn ans;\n\t}\n\tmatrix<R,C> operator+=(const matrix<R,C> m){\n\t\tmatrix<R,C> ans;\n\t\tloop(i,R)loop(j,C)ans.mat[i][j]=(mat[i][j]+m.mat[i][j])%jt;\n\t\treturn ans;\n\t}\n\tmatrix<R,C> operator-=(const matrix<R,C> m){\n\t\tmatrix<R,C> ans;\n\t\tloop(i,R)loop(j,C)ans.mat[i][j]=(mat[i][j]-m.mat[i][j]+jt)%jt;\n\t\treturn ans;\n\t}\n\tvoid debug(){\n\t\tloop(i,R){loop(j,C)cerr<<mat[i][j]<<' ';cerr<<endl;}cerr<<endl;\n\t}\n};\n\nint n;\nvector<int> nei[200005];\nint mx,nd;\nint fa[200005];\nint dp[200005][3][3];\nint tmp[3][3];\n\nvoid predfs(int now,int lst,int dep){\n\tif(dep>mx){\n\t\tmx=dep;\n\t\tnd=now;\n\t}\n\tfa[now]=lst;\n\tforeach(i,nei[now]){\n\t\tif(*i==lst){\n\t\t\tcontinue;\n\t\t}\n\t\tpredfs(*i,now,dep+1);\n\t}\n}\n\nvoid dfs(int now,int lst,int dep){\n\tif(dep==(mx>>1)){\n\t\tdp[now][1][1]=1;\n\t}else{\n\t\tdp[now][0][0]=1;\n\t}\n\tforeach(i,nei[now]){\n\t\tif(*i==lst){\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(*i,now,dep+1);\n\t\tloop(iu,3){\n\t\t\tloop(ju,3){\n\t\t\t\tloop(iv,3){\n\t\t\t\t\tloop(jv,3){\n\t\t\t\t\t\tloop(fx,3){\n\t\t\t\t\t\t\tint in=min(2,iu+iv*(fx==1)),jn=min(2,ju+jv*(fx==2));\n\t\t\t\t\t\t\tAdd(tmp[in][jn],Churn(dp[now][iu][ju],dp[*i][iv][jv]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCOPY(tmp,dp[now]);\n\t\tFILL0(tmp);\n\t}\n}\n\nint main(){\n\tfio>>n;\n\tcont(i,n-1){\n\t\tint x,y;\n\t\tfio>>x>>y;\n\t\tnei[x].pub(y);\n\t\tnei[y].pub(x);\n\t}\n\tpredfs(1,0,0);\n\tmx=0;\n\tpredfs(nd,0,0);\n\tcont(i,mx>>1){\n\t\tnd=fa[nd];\n\t}\n\tif(mx&1){\n\t\tint nd1=nd,nd2=fa[nd];\n\t\tdfs(nd1,nd2,0);\n\t\tdfs(nd2,nd1,0);\n\t\tfio<<Churn(Jar(dp[nd1][1][0],dp[nd1][1][1],dp[nd1][1][2]),Jar(dp[nd2][1][0],dp[nd2][1][1],dp[nd2][1][2]))<<ln;\n\t}else{\n\t\tdfs(nd,0,0);\n\t\tfio<<Churn(dp[nd][1][1],ksmii(2))<<ln;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define R register\n#define mp make_pair\n#define ll long long\n#define pii pair<int, int>\nusing namespace std;\nconst int N = 210000, mod = 998244353;\n\nint n, dis[N], a, b, p[N];\nll f[N][2];\nvector<int> to[N];\n\ntemplate <class T>\ninline void read(T &x) {\n\tx = 0;\n\tchar ch = getchar(), w = 0;\n\twhile (!isdigit(ch)) w = (ch == '-'), ch = getchar();\n\twhile (isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();\n\tx = w ? -x : x;\n\treturn;\n}\n\ninline void addEdg(int x, int y) {\n\tto[x].push_back(y), to[y].push_back(x);\n\treturn;\n}\n\nvoid dfs1(int now, int fa) {\n\tdis[now] = dis[fa] + 1;\n\tfor (auto &v : to[now]) {\n\t\tif (v == fa) continue;\n\t\tdfs1(v, now);\n\t}\n\treturn;\n}\n\nint dfs2(int now, int fa, int maxD) {\n\tif (dis[now] == maxD) return p[now] = 1;\n\tint ret = 0;\n\tfor (auto &v : to[now]) {\n\t\tif (v == fa) continue;\n\t\tret |= dfs2(v, now, maxD);\n\t}\n\tif (ret) {\n\t\tif (dis[now] == (maxD + 1) >> 1)\n\t\t\ta = now;\n\t\telse if (dis[now] == (maxD >> 1) + 1)\n\t\t\tb = now;\n\t}\n\treturn ret;\n}\n\nvoid dfs3(int now, int fa) {\n\tf[now][0] = 1, f[now][1] = p[now];\n\tfor (auto &v : to[now]) {\n\t\tif (v == fa) continue;\n\t\tdfs3(v, now);\n\t\tf[now][1] = (f[now][1] * f[v][0] + f[now][0] * f[v][1]) % mod;\n\t\tf[now][0] = (f[now][0] * f[v][0]) % mod;\n\t}\n\tf[now][0] = (f[now][0] * 3 - f[now][1] + mod) % mod;\n\treturn;\n}\n\nint main() {\n\tint x, y;\n\tread(n);\n\tfor (R int i = 1; i < n; ++i)\n\t\tread(x), read(y), addEdg(x, y);\n\tdfs1(1, 0);\n\tint rt = 1, maxD = 1;\n\tfor (R int i = 2; i <= n; ++i)\n\t\tif (dis[i] > maxD) maxD = dis[i], rt = i;\n\tdfs1(rt, 0), maxD = 1;\n\tfor (R int i = 1; i <= n; ++i)\n\t\tmaxD = max(maxD, dis[i]);\n\tdfs2(rt, 0, maxD), p[rt] = 1;\n\tif (b) {\n\t\tdfs3(b, a), dfs3(a, b);\n\t\tprintf(\"%lld\\n\", f[a][1] * f[b][1] % mod);\n\t}\n\telse {\n\t\tf[a][0] = 1;\n\t\tll ans = 0;\n\t\tfor (auto &v : to[a]) {\n\t\t\tdfs3(v, a);\n\t\t\tans = (ans * f[v][0] + f[a][1] * f[v][1]) % mod;\n\t\t\tf[a][1] = (f[a][1] * f[v][0] + f[a][0] * f[v][1]) % mod;\n\t\t\tf[a][0] = (f[a][0] * f[v][0]) % mod;\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200100\nusing namespace std;\nvector<int> g[N];\nint to_leaf[N],p3sz[N],nume[N][3];\nconst int Q=998244353;\nint find_c(int u,int p){\n\tint mx[2]={u,u},ans=0,tans;\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint v=g[u][i];\n\t\tif(v==p) continue;\n\t\ttans=find_c(v,u);\n\t\tif(tans>ans){\n\t\t\tans=tans;\n\t\t}\n\t\tif(to_leaf[v]>to_leaf[mx[0]]){\n\t\t\tmx[1]=mx[0];\n\t\t\tmx[0]=v;\n\t\t}\n\t\telse if(to_leaf[v]>to_leaf[mx[1]]){\n\t\t\tmx[1]=v;\n\t\t}\n\t}\n\tif(to_leaf[mx[0]]+to_leaf[mx[1]]>ans){\n\t\tans=to_leaf[mx[0]]+to_leaf[mx[1]];\n\t}\n\tto_leaf[u]=to_leaf[mx[0]]+1;\n\treturn ans;\n}\nvoid build(int u,int p){\n\tto_leaf[u]=0;\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint v=g[u][i];\n\t\tif(v==p) continue;\n\t\tbuild(v,u);\n\t\tto_leaf[u]=max(to_leaf[u],to_leaf[v]+1);\n\t}\n}\nvoid solve(int u,int p){\n\tp3sz[u]=1;\n\tif(!to_leaf[u]){\n\t\tnume[u][1]=1;\n\t\treturn;\n\t}\n\tnume[u][0]=1;\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint v=g[u][i];\n\t\tif(v==p) continue;\n\t\tsolve(v,u);\n\t\tif(to_leaf[v]+1==to_leaf[u]){\n\t\t\tfor(int j=2;j>=0;j--){\n\t\t\t\tnume[u][j]=(2LL*p3sz[v]+nume[v][0])*nume[u][j]%Q;\n\t\t\t\tif(j){\n\t\t\t\t\tnume[u][j]+=1LL*nume[v][1]*nume[u][j-1]%Q;\n\t\t\t\t\tnume[u][j]%=Q;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tnume[u][j]=3LL*p3sz[v]*nume[u][j]%Q;\n\t\t\t}\n\t\t}\n\t\tp3sz[u]=3LL*p3sz[v]*p3sz[u]%Q;\n\t}\n}\nint main(){\n\tint n,x,y;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tint l,p=0,c=1;\n\tl=find_c(1,0);\n\tbool flag=true;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<g[c].size();i++){\n\t\t\tif(g[c][i]!=p && to_leaf[g[c][i]]>(l+1)/2){\n\t\t\t\tp=c;\n\t\t\t\tc=g[c][i];\n\t\t\t\tflag=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"diameter=%d\\n\",l);\n\tif(l&1){\n\t\tint d=-1;\n\t\tfor(int i=0;i<g[c].size();i++){\n\t\t\tif(to_leaf[g[c][i]]==(l+1)/2){\n\t\t\t\td=g[c][i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//printf(\"center: %d %d\\n\",c,d);\n\t\tassert(d>0);\n\t\tbuild(c,d);\n\t\tsolve(c,d);\n\t\tbuild(d,c);\n\t\tsolve(d,c);\n\t\tprintf(\"%d\\n\",1LL*nume[c][1]*nume[d][1]%Q);\n\t}\n\telse{\n\t\t//printf(\"center: %d\\n\",c);\n\t\tbuild(c,0);\n\t\tsolve(c,0);\n\t\tprintf(\"%d\\n\",nume[c][2]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i,a,b) for (int i=int(a);i<=int(b);i++)\n#define R(i,a,b) for (int i=int(a);i<int(b);i++)\n#define D(i,a,b) for (int i=int(a);i>=int(b);i--)\n#define go(i,x) for (int i=head[x];i;i=Next[i])\n#define pb push_back\n#define si size()\n#define fi first\n#define se second\n#define pa pair < ll,ll >\n#define ll long long\n#define mp make_pair\n#define be begin()\n#define en end()\n#define put putchar('\\n')\n#define gc getchar\n#define pc putchar\n#define N 6000055\n#define mo 998244353\n#define inf 1000000007\n#define ret return puts(\"-1\"),0\nusing namespace std;\ninline ll read(){\n\tll su=0,f=1;char c=gc();\n\tfor (;c<'0'||c>'9';c=gc()) if (c=='-') f=-1;\n\tfor (;c>='0'&&c<='9';c=gc()) su=su*10+c-'0';\n\treturn su*f;\n}\ninline void wr(ll x){\n\tif (x<0) pc('-'),wr(-x);\n\telse{if (x>=10) wr(x/10);pc(x%10+'0');}\n}\ninline void wri(ll x){wr(x);pc(' ');}\ninline void wrn(ll x){wr(x);put;}\ninline void wrn(ll x,ll y){wri(x);wrn(y);}\ninline void wrn(ll x,ll y,ll z){wri(x);wrn(y,z);}\nint ans,n,m,f[N][2],fa[N],dis[N],lo,rt,mx;\ninline void ad(int &x,int k){x+=k;x-=(x>=mo)?mo:0;}\nint Next[N*2],head[N],to[N*2],nedge;\n#define V to[i]\nvoid add(int a,int b){Next[++nedge]=head[a];head[a]=nedge;to[nedge]=b;}\nvoid add_ne(int a,int b){add(a,b);add(b,a);}\nvoid dfs(int x){\n\tmx=(dis[x]>dis[mx])?x:mx;\n\tgo(i,x){\n\t\tif (V==fa[x]) continue;\n\t\tfa[V]=x;dis[V]=dis[x]+1;dfs(V);\n\t}\n}\nint ksm(ll x,int k){\n\tint su=1;\n\tfor (;k;k>>=1,x=x*x%mo) if (k&1) su=su*x%mo;\n\treturn su;\n}\nvoid solve(int x){\n\tint pd=0;\n\tf[x][0]=1;\n\tgo(i,x){\n\t\tif (V==fa[x]) continue;\n\t\tsolve(V);pd++;\n\t\tf[x][1]=1ll*f[x][1]*f[V][0]%mo;\n\t\tad(f[x][1],1ll*f[x][0]*f[V][1]%mo);\n\t\tf[x][0]=1ll*f[x][0]*f[V][0]%mo;\n\t}\n\tif (pd){\n\t\tf[x][0]=1ll*f[x][0]*3%mo;\n\t\tad(f[x][0],f[x][1]*2%mo);\n\t}\n\telse{\n\t\tif (dis[x]==lo/2) f[x][1]=1,f[x][0]=2;\n\t\telse f[x][0]=3;\n\t}\n}\nsigned main(){\n\tn=read();\n\tR(i,1,n) add_ne(read(),read());\n\tdfs(1);\n\trt=mx;mx=0;dis[rt]=0;fa[rt]=0;\n\tdfs(rt);\n\tlo=dis[mx];\n\tF(i,1,lo/2) mx=fa[mx];\n\tif (lo&1){\n\t\tint x=mx,y=fa[mx];\n\t\tfa[y]=x;dis[x]=dis[y]=0;dfs(x);dfs(y);\n\t\t//solve(x);solve(y);\n\t\twrn(ksm(3,n-lo-1));\n\t}\n\telse{\n\t\tint x=mx,nu=0;\n\t\tfa[x]=0;dis[x]=0;dfs(x);\n\t\tF(i,1,n) if (dis[i]==lo/2) nu++;\n\t\t//ans=(1ll*nu*(nu-1)/2)%mo*ksm(3,n-lo-1)%mo;\n\t\tsolve(x);\n\t\tf[x][0]=1;f[x][1]=0;\n\t\tgo(i,x){\n\t\t\tans=1ll*ans*f[x][0]%mo;\n\t\t\tad(ans,1ll*f[x][1]*f[V][1]%mo);\n\t\t\tf[x][1]=1ll*f[x][1]*f[V][0]%mo;\n\t\t\tad(f[x][1],1ll*f[x][0]*f[V][1]%mo);\n\t\t\tf[x][0]=1ll*f[x][0]*f[V][0]%mo;\t\t\t\n\t\t}\n\t\twrn(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=200005;\nconst int mod=998244353;\nvoid ad(int &x,int y){x+=y;if(x>=mod)x-=mod;}\nvector<int> nxt[MAXN];\nvoid ins(int x,int y){nxt[x].emplace_back(y);}\nint dis[MAXN],sta[MAXN],tp,n;\nvoid dfs(int x,int fa){for(auto y:nxt[x])if(y^fa)dis[y]=dis[x]+1,dfs(y,x);}\nbool getpath(int x,int fa,int ed)\n{\n\tif(x==ed){sta[++tp]=x;return true;}\n\tfor(auto y:nxt[x])if((y^fa)&&getpath(y,x,ed)){sta[++tp]=x;return true;}\n\treturn false;\n}\nint f[MAXN][4];//存在几条不同子树与父亲差值没变且为mx的 \nint trans[4];bool tag[MAXN];\nvoid dp(int x,int fa)\n{\n\tif(tag[x])f[x][1]=1;else f[x][0]=1;\n\tfor(auto y:nxt[x])if(y^fa)dp(y,x);\n\tfor(auto y:nxt[x])if(y^fa)\n\t{\n\t\tmemset(trans,0,sizeof(trans));\n\t\tfor(int i=0;i<4;i++)for(int j=0;j<4;j++)if(f[x][i]&&f[y][j])\n\t\t{\n\t\t\tif(j<=1)ad(trans[min(3,i+j)],1LL*f[x][i]*f[y][j]%mod);//+1\n\t\t\tad(trans[i],2LL*f[x][i]*f[y][j]%mod);\n\t\t}\n\t\tfor(int i=0;i<4;i++)f[x][i]=trans[i];\n\t}\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\tins(x,y);ins(y,x);\n\t}dfs(1,0);int p=0,q=0;for(int i=1;i<=n;i++)if(dis[i]>dis[p])p=i;\n\tdis[p]=0;dfs(p,0);for(int i=1;i<=n;i++)if(dis[i]>dis[q])q=i;\n\tgetpath(p,0,q);\n\tif(tp&1)\n\t{\n\t\tint u=sta[tp/2+1];dis[u]=0;dfs(u,0);\n\t\tfor(int i=1;i<=n;i++)if(dis[i]==tp/2)tag[i]=1;\n\t\tdp(u,0);pr2(f[u][2]);\n\t}\n\telse\n\t{\n\t\tint u=sta[tp/2],v=sta[tp/2+1];dis[u]=dis[v]=0;dfs(u,v);dfs(v,u);\n\t\tfor(int i=1;i<=n;i++)if(dis[i]==(tp-1)/2)tag[i]=1;\n\t\tdp(u,v);dp(v,u);pr2(1LL*f[u][1]*f[v][1]%mod);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define ll long long\n#define lb(x) ((x)&(-x))\n#define pii pair<int,int>\n#define vi vector<int>\n#define pb push_back\n#define fi first\n#define se second\n#define de(x) cout<<x<<\" x\"<<endl\n#define LCAFA rep(i,1,20)rep(j,1,n+1)fa[j][i]=fa[fa[j][i-1]][i-1]\n#define all(x) x.begin(),x.end()\n#define ls(x) x<<1\n#define rs(x) x<<1|1\nusing namespace std;\nconst int N=2e5+9;\nconst ll mod=998244353;\nint d[N],cnt,vis[N],stk[N];\nvi g[N];\nll dp[N][3],temp[3];\nll add(ll x,ll y){\n\treturn ((x+y)%mod+mod)%mod;\n}\nll mul(ll x,ll y){\n\treturn ((x*y)%mod+mod)%mod;\n}\nvoid dfs(int u,int f){\n\tfor(auto v:g[u]){\n\t\tif(v==f)continue;\n\t\td[v]=d[u]+1;\n\t\tdfs(v,u); \n\t}\n}\nvoid dfs2(int u,int f){\n\tfor(auto v:g[u]){\n\t\tif(v==f)continue;\n\t\tdfs2(v,u);\n\t\tif(vis[v])vis[u]=1;\n\t}\n\tif(vis[u])stk[++cnt]=u;\n}\nvoid sol(int u,int f){\n\tif(g[u].size()==1){\n\t\tif(vis[u])dp[u][0]=2,dp[u][1]=1;\n\t\telse dp[u][0]=3;\n\t\treturn;\n\t}\n\tdp[u][0]=1;\n\tfor(auto v:g[u]){\n\t\tif(v==f)continue;\n\t\tsol(v,u);\n\t\trep(i,0,3)temp[i]=0;\n\t\trep(i,0,3)rep(j,0,3)temp[min(2,i+j)]=add(temp[min(2,i+j)],mul(dp[u][i],dp[v][j]));\n\t\trep(i,0,3)dp[u][i]=temp[i];\n\t//\tcout<<v<<' '<<u<<\" uv\\n\\n\";\n\t//\tcout<<dp[u][0]<<' '<<dp[u][1]<<' '<<dp[u][2]<<\"checkdp\\n\";\n\t}\n\tdp[u][0]=add(dp[u][0],mul(2,dp[u][0]+dp[u][1]+dp[u][2])); \n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\trep(i,1,n){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tg[u].pb(v),g[v].pb(u);\n\t}\n\tdfs(1,0);\n\tint p=1;\n\trep(i,1,n+1)if(d[i]>d[p])p=i;\n\td[p]=0;\n\tdfs(p,0);\n\tint e=1;\n\trep(i,1,n+1)if(d[i]>d[e])e=i;\n\tvis[e]=1;\n\tdfs2(p,0);\n\tmemset(vis,0,sizeof vis);\n\tif(cnt&1){\n\t//\tcout<<\"comein\\n\";\n\t\tint u=stk[cnt/2+1];d[u]=0;dfs(u,0);\n\t\trep(i,1,n+1)if(d[i]==cnt/2)vis[i]=1;\n\t\tll ans[3]={1,0,0};\n\t\tfor(auto v:g[u]){\n\t\t//\tcout<<v<<\"  v\\n\"\n;\t\t\tsol(v,u);\n\t\t\tans[2]=add(mul(ans[2],dp[v][0]),mul(ans[1],dp[v][1]));\n\t\t\tans[1]=add(mul(ans[1],dp[v][0]),mul(ans[0],dp[v][1]));\n\t\t\tans[0]=mul(ans[0],dp[v][0]);\n\t\t//\tcout<<dp[v][0]<<' '<<dp[v][1]<<' '<<dp[v][2]<<\"dp\\n\";\n\t\t//\tcout<<ans[0]<<' '<<ans[1]<<' '<<ans[2]<<\"check\\n\";\n\t\t}\n\t\tprintf(\"%lld\",ans[2]);\n\t}\n\telse{\n\t\tint u=stk[cnt>>1],v=stk[cnt/2+1];\n\t\td[u]=0;d[v]=0;\n\t\tdfs(u,v);dfs(v,u);\n\t\trep(i,1,n+1)if(d[i]==cnt/2-1)vis[i]=1;\n\t\tsol(u,v);sol(v,u);\n\t\tll ans=mul(dp[u][1],dp[v][1]);\n\t\tprintf(\"%lld\",ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define mod 998244353\n#define N 500001\nusing namespace std;\nint total1=0;\nlong long dia=0,smid,middle;\nint next[N],head[N],edge[N],maxdep1[N],maxdep2[N],maxwhere1[N],maxwhere2[N];\nlong long size[N],f[N][3],g[N];\nint n;\nlong long ksmi(long long x,long long y)\n{\n\tlong long total=1,ab=x,p=y;\n\twhile (p)\n\t{\n\t\tif (p%2==1) total=total*ab%mod;\n\t\tab=ab*ab%mod;\n\t\tp/=2;\n\t}\n\treturn total;\n}\nlong long max(long long x,long long y)\n{\n\tif (x<y) return y;\n\treturn x;\n}\nvoid insert(int x,int y)\n{\n\ttotal1++;\n\tnext[total1]=head[x];\n\thead[x]=total1;\n\tedge[total1]=y;\n}\nvoid dfs1(int k,int fa)\n{\n\tmaxdep1[k]=1;\n\tsize[k]=1;\n\tfor (int i=head[k];i;i=next[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (y==fa) continue;\n\t\tdfs1(y,k);\n\t\tsize[k]=size[k]+size[y];\n\t\tmaxdep1[k]=max(maxdep1[k],maxdep1[y]+1);\n\t\tif (maxdep1[k]==maxdep1[y]+1) maxwhere1[k]=y;\n\t}\n\tmaxdep2[k]=0;\n\tfor (int i=head[k];i;i=next[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (y==fa||y==maxwhere1[k]) continue;\n\t//\tdfs(y,k);\n\t\tmaxdep2[k]=max(maxdep2[k],maxdep1[y]+1);\n\t\tif (maxdep2[k]==maxdep1[y]+1) maxwhere2[k]=y;\n\t}\n\tdia=max(dia,maxdep1[k]);\n\tif (dia==maxdep1[k]) smid=k;\n}void dfs(int k,int fa)\n{\n\tsize[k]=1;\n\tfor (int i=head[k];i;i=next[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (y==fa) continue;\n\t\tdfs(y,k);\n\t\tsize[k]+=size[y];\n\t}\n\tf[k][0]=1;\n\tbool bo1=true;\n\tfor (int i=head[k];i;i=next[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (y==fa) continue;\n\t\tbo1=false;\n\t\tlong long daijia=ksmi(3,size[y]);\n\t\tif (maxdep1[y]+1==maxdep1[k]) daijia=(f[y][0]*3+f[y][1]*4)%mod;\n\t\tf[k][0]=(f[k][0]*(daijia)%mod)%mod;\n\t}\n\tif (bo1) f[k][0]=0;\n\tf[k][1]=0;\n\tbool bo=true;\n\tfor (int i=head[k];i;i=next[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (y==fa) continue;\n\t\tif (maxdep1[y]+1<maxdep1[k]) continue;\n\t\tbo=false;\n\t\tlong long daijia=f[y][0]*3%mod+f[y][1]*4%mod;\n\t\tdaijia%=mod;\n\t\tlong long nowf=f[k][0]*ksmi(daijia,mod-2)%mod;\n\t\tnowf=nowf*f[y][1]%mod;\n\t\tf[k][1]=(f[k][1]+nowf)%mod;\n\t}\n\tif (bo) f[k][1]=1;\n\tif (maxdep1[k]==2)\n\t{\n\t\tf[k][1]=f[k][0]=1;\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tinsert(x,y);insert(y,x);\n\t}\n\tlong long ans=0;\n\tdia=0;\n\tmiddle=0;smid=0;\n\tdfs1(1,0);\n\twhile (maxdep1[smid]!=1)\n\t\tsmid=maxwhere1[smid];\n\tdfs1(smid,0);\n\tif (dia%2==0)\n\t{\n\t\tlong long ans=ksmi(3,n-dia);\n\t\tprintf(\"%lld\\n\",ans);\n\t\treturn 0;\n\t}\n\tint k=dia/2;\n\tmiddle=smid;\n\twhile (k)\n\t{\n\t\tmiddle=maxwhere1[middle];\n\t\tk--;\n\t}\n\tdfs1(middle,0);\n\tdfs(middle,0);\n\tlong long sp=1;\n\tfor (int i=head[middle];i;i=next[i]) \n\t\tif (maxdep1[edge[i]]+1==maxdep1[middle]) g[edge[i]]=(f[edge[i]][0]*3+f[edge[i]][1]*4)%mod;\n\t\telse\tg[edge[i]]=ksmi(3,size[edge[i]]);\n\tfor (int i=head[middle];i;i=next[i]) sp=sp*g[edge[i]]%mod;\n\tlong long s0=1,s1=0,s2=0;\n\tfor (int i=head[middle];i;i=next[i])\n\t{\n\t\tint y=edge[i];\n\t\tlong long news0=s0*g[edge[i]]%mod,news1=s1*g[edge[i]]%mod,news2=s2*g[edge[i]]%mod;\n\t\tif (maxdep1[y]+1==maxdep1[middle])\n\t\t{\n\t\t\tnews1=news1+s0*f[edge[i]][1]%mod;\n\t\t\tnews1%=mod;\n\t\t\tnews2=news2+s1*f[edge[i]][1]%mod;\n\t\t\tnews2%=mod;\n\t\t}\n\t\ts0=news0,s1=news1,s2=news2;\n\t}\n\tprintf(\"%lld\\n\",s2%mod);\n} "
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n\n\n\n\n#include <algorithm>\n\n#include <array>\n\n#include <bitset>\n\n#include <cassert>\n\n#include <complex>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <iostream>\n\n#include <map>\n\n#include <numeric>\n\n#include <queue>\n\n#include <set>\n\n#include <string>\n\n#include <unordered_map>\n\n#include <unordered_set>\n\n#include <vector>\n\nusing namespace std;\n\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\nstruct Scanner {\n    FILE* fp = nullptr;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += fread(line + ed, 1, (1 << 15) - ed, fp);\n        line[ed] = '\\0';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) reread();\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == '-') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] - '0');\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(V<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    Scanner(FILE* _fp) : fp(_fp) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(' ');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single('\\n');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val; // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char('0' + (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const V<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(' ');\n            write_single(val[i]);\n        }\n    }\n};\n\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    static constexpr uint get_mod() { return MD; }\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(uint(_v % MD + MD)); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(uint(ull(v) * r.v % MD)); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\n// using Mint = ModInt<998244353>;\n// template<> const Mint Mint::G = Mint(3);\n\nusing Mint = ModInt<998244353>;\n\nScanner sc = Scanner(stdin);\nPrinter pr = Printer(stdout);\n\nVV<int> g;\n\nint mdp, mv;\nvoid dfs(int p, int b, int ndp = 0) {\n    if (mdp <= ndp) {\n        mdp = ndp;\n        mv = p;\n    }\n    for (int d: g[p]) {\n        if (d == b) continue;\n        dfs(d, p, ndp + 1);\n    }\n}\n\nV<int> path;\nbool dfs_path(int p, int b, int t) {\n    if (p == t) {\n        path.push_back(p);\n        return true;\n    }\n    for (int d: g[p]) {\n        if (d == b) continue;\n        if (dfs_path(d, p, t)) {\n            path.push_back(p);\n            return true;\n        }\n    }\n    return false;\n}\n\nint U;\n\nusing P = pair<Mint, Mint>;\n\nP solve(int p, int b, int ndp = 0) {\n    if (g[p].size() == 1) {\n        // leaf\n        if (ndp == U) {\n            // rad\n                                          ;\n            return {Mint(2), Mint(1)};\n        } else {\n//            dbg(p, b, P{Mint(3), Mint(0)});\n            return {Mint(3), Mint(0)};\n        }\n    }\n    P dp = {Mint(1), Mint(0)};\n    for (auto d: g[p]) {\n        if (d == b) continue;\n        auto ch = solve(d, p, ndp + 1);\n        Mint sm = (dp.first + dp.second) * (ch.first + ch.second);\n        dp = P(sm - dp.first * ch.second + dp.second * ch.first,\n               dp.first * ch.second + dp.second * ch.first);\n    }\n    dp = { dp.first * Mint(3) + dp.second * Mint(2), dp.second };\n//    dbg(p, b, dp);\n    return dp;\n}\n\nint main() {\n    int n;\n    sc.read(n);\n    g = VV<int>(n);\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        sc.read(a, b); a--; b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    dfs(0, -1);\n    int u = mv;\n    dfs(mv, -1);\n    int v = mv;\n                  ;\n    dfs_path(u, -1, v);\n             ;\n\n    int L = int(path.size());\n    if (L % 2) {\n        U = (L / 2) - 1;\n        int mid = path[L / 2];\n                       ;\n        V<Mint> dp(4);\n        dp[0] = Mint(1);\n        for (int d: g[mid]) {\n            V<Mint> ndp(4);\n            auto x = solve(d, mid);\n            Mint x0 = x.first - x.second, x1 = x.second;\n            ndp[3] = dp[3] * x0 + dp[2] * x1 + dp[1] * x1;\n            ndp[2] = dp[2] * x0 + dp[0] * x1;\n            ndp[1] = dp[1] * x0 + dp[0] * x1;\n            ndp[0] = dp[0] * x0;\n            dp = ndp;\n        }\n               ;\n        pr.writeln((dp[3] / Mint(2)).v);\n    } else {\n        int mid0 = path[L / 2 - 1], mid1 = path[L / 2];\n                              ;\n        U = (L / 2 - 1);\n        auto x = solve(mid0, mid1);\n        auto y = solve(mid1, mid0);\n        pr.writeln((x.second * y.second).v);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC target(\"avx,avx2,sse,sse2,ssse3,sse4.1,sse4.2,tune=native,popcnt\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define pb push_back\nusing namespace std;\nconst int maxn = 303030;\nusing vi = vector<int>;\nusing ll = long long;\nint mat[64][64];\nvector<vi> a;\nint n, m;\nll check() {\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < m; j++) {\n\t\t\tmat[i+1][j+1] = a[i][j]^ mat[i][j+1] ^ mat[i+1][j] ^ mat[i][j];\n\t\t}\n\t}\n\tll ans = 0;\n\tfor(int i = 0; i <= n; i++)\n\t\tfor(int j = 0; j < i; j++)\n\t\t\tfor(int a = 0; a <= m; a++)\n\t\t\t\tfor(int b = 0; b < a; b++) {\n\t\t\t\t\tans += mat[i][a]^mat[i][b]^mat[j][b]^mat[j][a];\n\t\t\t\t}\n\treturn ans;\n}\nvoid print() {\n\tfor(auto i : a) {\n\t\tfor(auto j : i) cout << j;\n\t\tcout << '\\n';\n\t}\n\texit(0);\n}\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n >> m;\n\tn = (1<<n)-1, m = (1<<m)-1;\n\ta = vector<vi>(n, vi(m, 1));\n\tif(n == 1 || m == 1) print();\n\tll ans = check(), u = -1, b = -1;\n\tfor(int i = 0; i <= n-1-i; i++) {\n\t\tfor(int j = 0; j < m-1-j; j++) {\n\t\t\ta[i][m/2] = a[n-1-i][m/2] = 0;\n\t\t\ta[n/2][j] = a[n/2][m-1-j] = 0;\n\t\t\t\n\t\t\tll t = check();\n\t\t\tif(ans < t) ans = t, u = i, b = j;\n\t\t\t\n\t\t\ta[i][m/2] = a[n-1-i][m/2] = 1;\n\t\t\ta[n/2][j] = a[n/2][m-1-j] = 1;\n\t\t}\n\t}\n\tif(u != -1) {\t\n\t\ta[u][m/2] = a[n-1-u][m/2] = 0;\n\t\ta[n/2][b] = a[n/2][m-1-b] = 0;\n\t}\n\tprint();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define MOD 998244353\ntemplate<typename ty1,typename ty2>\ninline int add(ty1 x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x += y; return x < MOD ? x : x - MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline void addto(ty1 &x, ty2 y) {\n\t\t  if(y>=MOD)y%=MOD;\n\t\t  if(x>=MOD)x%=MOD;\n\t      x += y; if (x >= MOD) x -= MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int sub(ty1 x, ty2 y) {\n\t\tif(y>=MOD)y%=MOD;\n\t\t if(x>=MOD)x%=MOD;\n        x -= y; return x < 0 ? x + MOD : x;\n}\ntemplate<typename ty1,typename ty2>\ninline void subto(ty1 &x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x -= y; if (x < 0) x += MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int mul(ty1 x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        return 1ll * x * y % MOD;\n}\ntemplate<typename ty1,typename ty2>\nvoid multo(ty1 &x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        x=1ll * x * y % MOD;\n}\n  \nlong long int gcd(long long int a, long long int b){\n\tif (a > b){\n\t\tswap(a, b);\n\t}\n\twhile (a){\n\t\tswap(a, b);\n\t\ta %= b;\n\t}\n\treturn b;\n}\nlong long int lcm(long long int a, long long int b){\n\treturn a / gcd(a, b)*b;\n}\nlong long int ppow(long long int i, long long int j){\n\t\tlong long int res = 1LL;\n\t\twhile (j){\n\t\t\tif ((j & 1LL)){\n\t\t\t\tres *= i;\n\t\t\t\tif (res >= MOD){\n\t\t\t\t\tres %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj >>= 1;\n\t\t\ti *= i;\n\t\t\tif (i >= MOD){\n\t\t\t\ti %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\nclass Combination{\n\t\npublic:\n\tvector<long long int> k;\n\tvector<long long int> r;\n\tvoid resize(int N){\n\t\tk.resize(N + 2);\n\t\tr.resize(N + 2);\n\t\tk[0] = 1;\n\t\tfor (int i = 1; i < N+2; i++){\n\t\t\tk[i] = k[i - 1];\n\t\t\tk[i] *= i;\n\t\t\tif (k[i] >= MOD)k[i] %= MOD;\n\t\t}\n\t\tlong long int al = k[k.size() - 1];\n\t\tlong long int iv = ppow(k[k.size() - 1],MOD-2);\n\t\tr[k.size() - 1] = iv;\n\t\tfor (int i = (int)(r.size()) - 2; i >= 0; i--){\n\t\t\tr[i] = r[i + 1] * (i + 1);\n\t\t\tif (r[i] >= MOD){\n\t\t\t\tr[i] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int C(int a, int b){\n\t\tif (a < b)return 0;\n\t\tlong long int up = k[a];\n\t\tlong long int dw = r[b] * r[a - b];\n\t\tdw %= MOD;\n\t\tup *= dw;\n\t\tup %= MOD;\n\t\treturn up;\n\t}\n\tlong long int H(int a, int b){\n\t\treturn C(a + b - 1, b);\n\t}\n\tlong long int catalan_number(int n){\n\t\treturn (C(2 * n, n) + MOD - C(2 * n, n - 1)) % MOD;\n\t}\n};\nCombination C;\n\n#define MAX 200002\nint n;\n\n\nstruct treediameter{\n\t//直径は色々いい性質がある\n\t//中心から(２頂点の場合それをくっつける）同じ距離のびた２つの頂点間が直径\n\t//直径は最大長であることにも注意\n\tconst vector<vector<int> >&g;\n\tint r1,r2;\n\tvector<int> d1,d2;  //両端からのdist\n\tint dia;\n\tvoid dfs(int v,int p,int cur,vector<int> &d){\n\t\td[v]=cur;\n\t\tfor(auto e:g[v])if(e!=p)\n\t\t\tdfs(e,v,cur+1,d);\n\t}\n\ttreediameter(const vector<vector<int> > &gg):g(gg),d1(g.size()),d2(g.size()){\n\t\tdfs(0,-1,0,d1);\n\t\tr1=max_element(d1.begin(),d1.end())-d1.begin();\n\t\tdfs(r1,-1,0,d1);\n\t\tr2=max_element(d1.begin(),d1.end())-d1.begin();\n\t\tdfs(r2,-1,0,d2);\n\t\tdia=d1[r2];\n\t}\n\tvector<int> find_centre(){  //直径の中心をさがす 1頂点 or 2頂点　直径は必ずこれらすべてを通る\n\t\tvector<int> ret;\n\t\tfor(int i=0;i<d1.size();i++){\n\t\t\tif(d1[i]+d2[i]==dia&&abs(d1[i]-d2[i])<=1){\n\t\t\t\tret.push_back(i);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n//treediameter(v)\n\nvector<vector<int> > v;\n\nbool flag[MAX];\n\n//0:none without substraction\n//1:positive without substraction\n// 2: none with substraction\nint dp[MAX][3];\nbool us[MAX][3];\nint target;\ninline int dfs(int b,int ty,int pr=-1,int d=0){\n\tif(us[b][ty]){\n\t\treturn dp[b][ty];\n\t}\n\tus[b][ty]=true;\n\tint ava=0;\n\tvector<int> can;\n\tfor(int go:v[b]){\n\t\tif(go==pr||flag[go])continue;\n\t\tava++;\n\t\tcan.push_back(go);\n\t}\n\tif(ava==0){\n\t\t//leaf\n\t\tif(ty==1){\n\t\t\tif(d==target){\n\t\t\t\tdp[b][ty]=1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tdp[b][ty]=0;\n\t\t\treturn 0;\n\t\t}\n\t\tif(ty==0){\n\t\t\tif(d==target){\n\t\t\t\tdp[b][ty]=0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdp[b][ty]=1;\n\t\t\treturn 1;\n\t\t}\n\t\tif(ty==2){\n\t\t\tdp[b][ty]=1;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif(ty==1){\n\t\tfor(int go:can){\n\t\t\tauto ret=dfs(go,1,b,d+1);\n\t\t\tfor(int goo:can){\n\t\t\t\tif(go!=goo){\n\t\t\t\t\tmulto(ret,add(dfs(goo,0,b,d+1),mul(2,dfs(goo,2,b,d+1))));\n\t\t\t\t}\n\t\t\t}\n\t\t\taddto(dp[b][ty],ret);\n\t\t}\n\t}\n\tif(ty==2){\n\t\tdp[b][ty]=1;\n\t\tfor(int goo:can){\n\t\t\tmulto(dp[b][ty],mul(3,dfs(goo,2,b,d+1)));\n\t\t}\n\t}\n\tif(ty==0){\n\t\tdp[b][ty]=1;\n\t\tfor(int goo:can){\n\t\t\tmulto(dp[b][ty],add(dfs(goo,0,b,d+1),mul(2,dfs(goo,2,b,d+1))));\n\t\t}\n\t}\n\treturn dp[b][ty];\n}\n\nint main(){\n\tcin>>n;\n\tv.resize(n);\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tauto dia=treediameter(v);\n\tauto centre=dia.find_centre();\n\tfor(auto el:centre){\n\t\tflag[el]=true;\n\t}\n\tif(centre.size()==1){\n\t\tint pos=centre[0];\n\t\ttarget=dia.dia/2;\n\t\ttarget--;\n\t\tlong long int ans=0;\n\t\tfor(int el1:v[pos]){\n\t\t\tfor(int el2:v[pos]){\n\t\t\t\tif(el1!=el2){\n\t\t\t\t\tauto ret=mul(dfs(el1,1,pos,0),dfs(el2,1,pos,0));\n\t\t\t\t\tfor(int el3:v[pos]){\n\t\t\t\t\t\tif(el1!=el3&&el2!=el3){\n\t\t\t\t\t\t\tmulto(ret,add(dfs(el3,0,pos,0),mul(2,dfs(el3,2,pos,0))));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\taddto(ans,ret);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmulto(ans,ppow(2,MOD-2));\n\t\tans%=MOD;\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\telse{\n\t\ttarget=dia.dia/2;\n\t\tlong long int ans=0;\n\t\taddto(ans,mul(dfs(centre[0],1),dfs(centre[1],1)));\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#define ll long long\n#define mod 998244353\n#define maxn 200010\ninline ll read()\n{\n\tll x=0; char c=getchar(),f=1;\n\tfor(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n\tfor(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\ninline void write(ll x)\n{\n\tstatic int buf[20],len; len=0;\n\tif(x<0)x=-x,putchar('-');\n\tfor(;x;x/=10)buf[len++]=x%10;\n\tif(!len)putchar('0');\n\telse while(len)putchar(buf[--len]+'0');\n}\ninline void writeln(ll x){write(x); putchar('\\n');}\ninline void writesp(ll x){write(x); putchar(' ');}\nconst int inv2=(mod+1)/2;\nstd::vector<int>nxt[maxn];\nint dist1[maxn],dist2[maxn],dep[maxn];\nll f[maxn][3][3],tmp[3][3];\nint n,S,T,L;\nint max(int a,int b){return a>b?a:b;}\nint min(int a,int b){return a<b?a:b;}\nvoid dfs(int now,int fa,int* dep)\n{\n\tfor(int x:nxt[now])\n\t\tif(x!=fa){\n\t\t\tdep[x]=dep[now]+1;\n\t\t\tdfs(x,now,dep);\n\t\t}\n}\nvoid dp(int now,int fa)\n{\n\tdep[now]=0;\n\tfor(int x:nxt[now])\n\t\tif(x!=fa){\n\t\t\tdp(x,now);\n\t\t\tdep[now]=max(dep[now],dep[x]);\n\t\t}\n\tif(dep[now])f[now][0][0]=1;\n\telse f[now][1][1]=1;\n\tfor(int x:nxt[now])\n\t\tif(x!=fa){\n\t\t\tmemset(tmp,0,sizeof(tmp));\n\t\t\tint flag=(dep[x]==dep[now]);\n\t\t\tfor(int i=0;i<3;i++)\n\t\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\t\t\tfor(int l=0;l<3;l++)\n\t\t\t\t\t\t\tif(!flag)tmp[i][j]=(tmp[i][j]+3*f[now][i][j]*f[x][k][l])%mod;\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\ttmp[i][j]=(tmp[i][j]+f[now][i][j]*f[x][k][l])%mod;\n\t\t\t\t\t\t\t\ttmp[min(i+k,2)][j]=(tmp[min(i+k,2)][j]+f[now][i][j]*f[x][k][l])%mod;\n\t\t\t\t\t\t\t\ttmp[i][min(j+l,2)]=(tmp[i][min(j+l,2)]+f[now][i][j]*f[x][k][l])%mod;\n\t\t\t\t\t\t\t}\n\t\t\tmemcpy(f[now],tmp,sizeof(tmp));\n\t\t}\n\t++dep[now];\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;i++){\n\t\tint x=read(),y=read();\n\t\tnxt[x].push_back(y); nxt[y].push_back(x);\n\t}\n\tdist1[1]=0;\n\tdfs(1,-1,dist1);\n\tS=1;\n\tfor(int i=2;i<=n;i++)\n\t\tif(dist1[i]>dist1[S])S=i;\n\tdist1[S]=0;\n\tdfs(S,-1,dist1);\n\tT=1;\n\tfor(int i=2;i<=n;i++)\n\t\tif(dist1[i]>dist1[T])T=i;\n\tdist2[T]=0;\n\tdfs(T,-1,dist2);\n\tL=dist1[T];\n\tif(L&1){\n\t\tint C1=0,C2=0;\n\t\tfor(int u=1;u<=n;u++)\n\t\t\tfor(int v:nxt[u])\n\t\t\t\tif(dist1[u]==L/2&&dist2[v]==L/2){\n\t\t\t\t\tC1=u; C2=v;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\tdp(C1,C2); dp(C2,C1);\n\t\tll sum1=(f[C1][1][0]+f[C1][1][1]+f[C1][1][2])%mod,sum2=(f[C2][0][1]+f[C2][1][1]+f[C2][2][1])%mod;\n\t\twriteln(sum1*sum2%mod);\n\t}\n\telse{\n\t\tint C=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(dist1[i]==L/2&&dist2[i]==L/2){\n\t\t\t\tC=i; break;\n\t\t\t}\n\t\tdp(C,-1);\n\t\twriteln(f[C][1][1]*inv2%mod);\n\t}\n\t// for(int i=1;i<=n;i++){\n\t// \tfor(int j=0;j<3;j++)\n\t// \t\tfor(int k=0;k<3;k++)\n\t// \t\t\twritesp(f[i][j][k]);\n\t// \tputchar('\\n');\n\t// }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=2e5+5,mod=998244353;\nint n,m,dis[N],fa[N],a[N],si[N],rt1,rt2,head[N],nex[N<<1],to[N<<1],tot;\nvoid add(int u,int v){to[++tot]=v;nex[tot]=head[u];head[u]=tot;}\nvoid dfs(int u,int p)\n{\n    dis[u]=dis[p]+1;\n    if(dis[u]>dis[rt1]) rt1=u;\n    fa[u]=p;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p)continue;\n        dfs(v,u);\n    }\n}\nll dp[N][3][3],p[3][3];\nvoid dfs(int u,int fa,int d)\n{\n    d==m/2?dp[u][1][1]=1:dp[u][0][0]=1;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==fa)continue;\n        dfs(v,u,d+1);\n        memset(p,0,sizeof(p));\n        for(int i=0;i<3;i++)\n            for(int j=0;j<3;j++)\n            for(int k=0;k<3;k++)\n                for(int h=0;h<3;h++)\n        {\n            p[i][j]=(p[i][j]+dp[u][i][j]*dp[v][k][h])%mod;\n            p[min(i+k,2)][j]=(p[min(i+k,2)][j]+dp[u][i][j]*dp[v][k][h])%mod;\n            p[i][min(j+h,2)]=(p[i][min(j+h,2)]+dp[u][i][j]*dp[v][k][h])%mod;\n        }\n        for(int i=0;i<3;i++)\n            for(int j=0;j<3;j++)\n            dp[u][i][j]=p[i][j];\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        int u,v;scanf(\"%d%d\",&u,&v);add(u,v);add(v,u);\n    }\n    dfs(1,0);\n    rt2=rt1;\n    dfs(rt1,0);\n    while(fa[rt1]) a[++m]=rt1,rt1=fa[rt1];\n    a[++m]=rt1;\n    rt1=rt2=0;\n    if(m%2==0) rt1=a[m/2],rt2=a[m/2+1];\n    else rt1=a[m/2+1];\n    m--;\n    if(rt1&&rt2)\n    {\n        dfs(rt1,rt2,0);dfs(rt2,rt1,0);\n        printf(\"%lld\\n\",(dp[rt1][1][0]*dp[rt2][0][1]+dp[rt2][1][0]*dp[rt1][0][1])%mod*(mod-mod/2)%mod);\n    }\n    else\n    {\n        dfs(rt1,0,0);\n        printf(\"%lld\\n\",dp[rt1][1][1]*(mod-mod/2)%mod);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#define ll long long\n#define mod 998244353\n#define maxn 200010\ninline ll read()\n{\n\tll x=0; char c=getchar(),f=1;\n\tfor(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n\tfor(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\ninline void write(ll x)\n{\n\tstatic int buf[20],len; len=0;\n\tif(x<0)x=-x,putchar('-');\n\tfor(;x;x/=10)buf[len++]=x%10;\n\tif(!len)putchar('0');\n\telse while(len)putchar(buf[--len]+'0');\n}\ninline void writeln(ll x){write(x); putchar('\\n');}\ninline void writesp(ll x){write(x); putchar(' ');}\nconst int inv2=(mod+1)/2;\nstd::vector<int>nxt[maxn];\nint dist1[maxn],dist2[maxn],dep[maxn];\nll f[maxn][3][3],tmp[3][3];\nint n,S,T,L;\nint max(int a,int b){return a>b?a:b;}\nint min(int a,int b){return a<b?a:b;}\nll power(ll a,ll b)\n{\n\tll ans=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)ans=ans*a%mod;\n\treturn ans;\n}\nvoid dfs(int now,int fa,int* dep)\n{\n\tfor(int x:nxt[now])\n\t\tif(x!=fa){\n\t\t\tdep[x]=dep[now]+1;\n\t\t\tdfs(x,now,dep);\n\t\t}\n}\nvoid dp(int now,int fa)\n{\n\tdep[now]=0;\n\tfor(int x:nxt[now])\n\t\tif(x!=fa){\n\t\t\tdp(x,now);\n\t\t\tdep[now]=std::max(dep[now],dep[x]);\n\t\t}\n\tif(dep[now])f[now][0][0]=1;\n\telse f[now][1][1]=1;\n\tfor(int x:nxt[now])\n\t\tif(x!=fa){\n\t\t\tmemset(tmp,0,sizeof(tmp));\n\t\t\tint flag=(dep[x]==dep[now]);\n\t\t\tfor(int i=0;i<3;i++)\n\t\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\t\t\tfor(int l=0;l<3;l++)\n\t\t\t\t\t\t\tif(!flag)tmp[i][j]=(tmp[i][j]+f[now][i][j]*3*f[x][k][l])%mod;\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\ttmp[i][j]=(tmp[i][j]+f[now][i][j]*f[x][k][l])%mod;\n\t\t\t\t\t\t\t\ttmp[min(i+k,2)][j]=(tmp[min(i+k,2)][j]+f[now][i][j]*f[x][k][l])%mod;\n\t\t\t\t\t\t\t\ttmp[i][min(j+l,2)]=(tmp[i][min(j+l,2)]+f[now][i][j]*f[x][k][l])%mod;\n\t\t\t\t\t\t\t}\n\t\t\tmemcpy(f[now],tmp,sizeof(tmp));\n\t\t}\n\t++dep[now];\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;i++){\n\t\tint x=read(),y=read();\n\t\tnxt[x].push_back(y); nxt[y].push_back(x);\n\t}\n\tdist1[1]=0;\n\tdfs(1,-1,dist1);\n\tS=1;\n\tfor(int i=2;i<=n;i++)\n\t\tif(dist1[i]>dist1[S])S=i;\n\tdist1[S]=0;\n\tdfs(S,-1,dist1);\n\tT=1;\n\tfor(int i=2;i<=n;i++)\n\t\tif(dist1[i]>dist1[T])T=i;\n\tdist2[T]=0;\n\tdfs(T,-1,dist2);\n\tL=dist1[T];\n\tif(L&1){\n\t\tfor(int u=1;u<=n;u++)\n\t\t\tfor(int v:nxt[u])\n\t\t\t\tif(dist1[u]==L/2&&dist2[v]==L/2){\n\t\t\t\t\tdp(u,v); dp(v,u);\n\t\t\t\t\twriteln(f[u][1][0]*f[v][0][1]%mod);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t}\n\telse{\n\t\tint C=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(dist1[i]==L/2&&dist2[i]==L/2){\n\t\t\t\tC=i; break;\n\t\t\t}\n\t\tdp(C,-1);\n\t\twriteln(f[C][1][1]*inv2%mod);\n\t}\n\t// for(int i=1;i<=n;i++){\n\t// \tfor(int j=0;j<3;j++)\n\t// \t\tfor(int k=0;k<3;k++)\n\t// \t\t\twritesp(f[i][j][k]);\n\t// \tputchar('\\n');\n\t// }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 114514*2\n#define mod 998244353\n#define int long long \nvoid add(int&x,int y){\n\tx=(x+y)%mod;\n}\nint dp[nn][4][4],n,diam,c1,c2;\nvector<int> v[nn];int chk[nn];\nint dep[nn],pa[nn];\nvoid dfs(int x,int p,int slg=0){\n\tif(!p or slg) dep[x]=0;else dep[x]=dep[p]+1;pa[x]=p;\n\tfor(int i=0;i<v[x].size();i++) if(v[x][i]!=p) dfs(v[x][i],x);\n}\nint walk(int x,int d){\n\tif(d==0) return x;\n\treturn walk(pa[x],d-1);\n}\nint mst(){\n\tint ret=0;for(int i=1;i<=n;i++) ret=max(ret,dep[i]);for(int i=1;i<=n;i++) if(dep[i]==ret) return i;\n}\nint f[2][4];int tmp[4][4];\n\nvoid copy(int x){\n\tfor(int i=0;i<4;i++) for(int j=0;j<4;j++) tmp[i][j]=dp[x][i][j],dp[x][i][j]=0;\n}\n\nvoid efs(int x,int p){\n\tdp[x][3*(dep[x]==diam/2)][0]=1;int leaf=1;\n\tfor(int i=0;i<v[x].size();i++) if(v[x][i]!=p){\n\t\tefs(v[x][i],x);\n\t\tleaf=0;\n\t\tcopy(x);\n\t\tfor(int j=0;j<16;j++) for(int k=0;k<16;k++) add(dp[x][(j%4)|(k%4)][(j/4)|(k/4)|((j%4)&(k%4))],tmp[k%4][k/4]*dp[v[x][i]][j%4][j/4]);\n\t}\n\t\n\tif(dep[x]!=diam/2 and leaf and 0) dp[x][0][0]=3;\n\telse if(x!=c1 and x!=c2){\n\t\tcopy(x);\n\t\tfor(int k=0;k<16;k++) for(int j=0;j<=2;j++) add(dp[x][(k%4)&j][(k/4)&j],tmp[k%4][k/4]);\n\t}\n}\n\n\nsigned main(){\n\tscanf(\"%d\",&n);\n\tif(n<=2) return puts(\"1\")*0;\n\t\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tv[x].push_back(y);v[y].push_back(x);\n\t}\n\t\n\tdfs(1,0);int x=mst();\n\tdfs(x,0);int y=mst();\n\tdiam=dep[y];\n\tif(diam%2==0){\n\t\tc1=walk(y,diam/2);\n\t\tint now=0;f[now][0]=1;dfs(c1,0);efs(c1,0);\n/*\t\tfor(int i=0;i<v[c1].size();i++) {\n\t\t\tefs(v[c1][i],c1);\n\t\t\tnow^=1;memset(f[now],0,sizeof f[now]);\n\t\t\tfor(int j=0;j<4;j++) for(int k=0;k<4;k++) add(f[now][j|k],dp[v[c1][i]][j][0]*f[now^1][k]);\n\t\t}\n\t\tcout<<f[now][3];*/\n\t\tcout<<dp[c1][3][0]*(mod+1)/2%mod;\n\t}\n\telse{\n\t\tc1=walk(y,diam/2);\n\t\tdfs(y,0);\n\t\tc2=walk(x,diam/2);\n\t\t\n\t\tdfs(c1,c2,1);dfs(c2,c1,1);\n\t\tefs(c1,c2);\n\t\tefs(c2,c1);\n\t\t\n\t\tcout<<dp[c1][1][0]*dp[c2][2][0]%mod;\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nstruct edge{int to, cost, id;};\n\nclass Graph\n{\npublic:\n    int N;\n    vector<vector<edge>> G;\n    bools f;\n    mmat dp;\n\n    Graph(int N): N(N){\n        G = vector<vector<edge>>(N, vector<edge>(0));\n        f = bools(N, false);\n        dp = mmat(N, mvec(3, 0));\n    }\n\n    void add_Directed_edge(int from, int to, int cost = 1, int id = 0){\n        G[from].push_back(edge({to, cost, id}));\n    }\n\n    void add_Undirected_edge(int v1, int v2, int cost = 1, int id = 0){\n        add_Directed_edge(v1, v2, cost, id);\n        add_Directed_edge(v2, v1, cost, id);\n    }\n\n    //calculate diameter of a Tree\n    void dfs_for_calcdist(int v, int p, int c, vec &dist){\n        if(p != -1) dist[v] = dist[p] + c;\n        for(auto e: G[v]) if(e.to != p) dfs_for_calcdist(e.to, v, e.cost, dist);\n    } \n\n    int diameter(int &v1, int &v2, int s = 0){\n        vec dist(N, 0);\n        dfs_for_calcdist(s, -1, -1, dist);\n        v1 = distance(dist.begin(), max_element(dist.begin(), dist.end()));\n        fill(dist.begin(), dist.end(), 0);\n        dfs_for_calcdist(v1, -1, -1, dist);\n        auto amax = max_element(dist.begin(), dist.end());\n        v2 = distance(dist.begin(), amax);\n        return *amax;\n    }\n\n    void dfs(int v, int p){\n\n        if(f[v]) dp[v][1] = 1;\n        else dp[v][0] = 1;\n\n        if(p != -1){\n            for(auto e: G[v]) if(e.to != p){\n                dfs(e.to, v);\n                mvec tmp(3, 0);\n                tmp[0] = dp[v][0] * (dp[e.to][0] * 3 + dp[e.to][1] * 2 + dp[e.to][2] * 2);\n                tmp[1] = dp[v][0] * dp[e.to][1] + dp[v][1] * (dp[e.to][0] * 3 + dp[e.to][1] * 2 + dp[e.to][2] * 2);\n                tmp[2] = dp[v][1] * dp[e.to][1] + dp[v][2] * (dp[e.to][0] + dp[e.to][1] + dp[e.to][2]) * 3 + (dp[v][0] + dp[v][1]) * dp[e.to][2];\n                dp[v] = tmp;\n            }\n        }else{\n            dp[v] = mvec(4, 0);\n            dp[v][0] = 1;\n            for(auto e: G[v]) if(e.to != p){\n                dfs(e.to, v);\n                mvec tmp(4, 0);\n                REP(j, 4){\n                    tmp[j] += dp[v][j] * (dp[e.to][0] * 3 + dp[e.to][1] + dp[e.to][2]);\n                    if((j & 1) == 0) tmp[j | 1] += dp[v][j] * dp[e.to][1];\n                    if((j & 2) == 0) tmp[j | 2] += dp[v][j] * dp[e.to][1];\n                }\n                dp[v] = tmp;\n            }\n        }\n    }\n\n};\n\n\nsigned main(){\n\n    int N; cin >> N;\n    Graph G(N);\n    REP(i, N - 1){\n        int a, b; cin >> a >> b;\n        G.add_Undirected_edge(a - 1, b - 1);\n    }\n\n    int v1, v2;\n    int R = G.diameter(v1, v2);\n    vec d1(N, 0), d2(N, 0);\n    G.dfs_for_calcdist(v1, -1, -1, d1);\n    G.dfs_for_calcdist(v2, -1, -1, d2);\n\n    vec center;\n    REP(i, N) if(d1[i] + d2[i] == R && llabs(d1[i] - d2[i]) <= 1) center.pb(i);\n    \n    fill(all(d1), 0);\n    fill(all(d2), 0);\n    mint ans;\n    if(SZ(center) == 1){\n        G.dfs_for_calcdist(center[0], -1, -1, d1);\n        REP(i, N) if(d1[i] == R / 2) G.f[i] = true;\n\n        G.dfs(center[0], -1);\n        ans = G.dp[center[0]][3] / 2;\n    }else{\n        G.dfs_for_calcdist(center[0], -1, -1, d1);\n        G.dfs_for_calcdist(center[1], -1, -1, d2);\n        REP(i, N) if(min(d1[i], d2[i]) == R / 2) G.f[i] = true;\n\n        G.dfs(center[0], center[1]);\n        G.dfs(center[1], center[0]);\n        ans = G.dp[center[0]][1] * G.dp[center[1]][1];\n    }\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n\n\n\n\n#include <algorithm>\n\n#include <array>\n\n#include <bitset>\n\n#include <cassert>\n\n#include <complex>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <iostream>\n\n#include <map>\n\n#include <numeric>\n\n#include <queue>\n\n#include <set>\n\n#include <string>\n\n#include <unordered_map>\n\n#include <unordered_set>\n\n#include <vector>\n\nusing namespace std;\n\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\nstruct Scanner {\n    FILE* fp = nullptr;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += fread(line + ed, 1, (1 << 15) - ed, fp);\n        line[ed] = '\\0';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) reread();\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == '-') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] - '0');\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(V<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    Scanner(FILE* _fp) : fp(_fp) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(' ');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single('\\n');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val; // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char('0' + (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const V<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(' ');\n            write_single(val[i]);\n        }\n    }\n};\n\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    static constexpr uint get_mod() { return MD; }\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(uint(_v % MD + MD)); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(uint(ull(v) * r.v % MD)); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\n// using Mint = ModInt<998244353>;\n// template<> const Mint Mint::G = Mint(3);\n\nusing Mint = ModInt<998244353>;\n\nScanner sc = Scanner(stdin);\nPrinter pr = Printer(stdout);\n\nVV<int> g;\n\nint mdp, mv;\nvoid dfs(int p, int b, int ndp = 0) {\n    if (mdp <= ndp) {\n        mdp = ndp;\n        mv = p;\n    }\n    for (int d: g[p]) {\n        if (d == b) continue;\n        dfs(d, p, ndp + 1);\n    }\n}\n\nV<int> path;\nbool dfs_path(int p, int b, int t) {\n    if (p == t) {\n        path.push_back(p);\n        return true;\n    }\n    for (int d: g[p]) {\n        if (d == b) continue;\n        if (dfs_path(d, p, t)) {\n            path.push_back(p);\n            return true;\n        }\n    }\n    return false;\n}\n\nint U;\n\nusing P = pair<Mint, Mint>;\n\nP solve(int p, int b, int ndp = 0) {\n    if (g[p].size() == 1) {\n        // leaf\n        if (ndp == U) {\n            // rad\n                                          ;\n            return {Mint(2), Mint(1)};\n        } else {\n//            dbg(p, b, P{Mint(3), Mint(0)});\n            return {Mint(3), Mint(0)};\n        }\n    }\n    P dp = {Mint(1), Mint(0)};\n    for (auto d: g[p]) {\n        if (d == b) continue;\n        auto ch = solve(d, p, ndp + 1);\n        Mint sm = (dp.first + dp.second) * (ch.first + ch.second);\n        dp = P(sm - dp.first * ch.second + dp.second * ch.first,\n               dp.first * ch.second + dp.second * ch.first);\n    }\n    dp = { dp.first * Mint(3) + dp.second * Mint(2), dp.second };\n//    dbg(p, b, dp);\n    return dp;\n}\n\nint main() {\n    int n;\n    sc.read(n);\n    g = VV<int>(n);\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        sc.read(a, b); a--; b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    dfs(0, -1);\n    int u = mv;\n    dfs(mv, -1);\n    int v = mv;\n                  ;\n    dfs_path(u, -1, v);\n             ;\n\n    int L = int(path.size());\n    if (L % 2) {\n        U = (L / 2) - 1;\n        int mid = path[L / 2];\n                       ;\n        V<Mint> dp(4);\n        dp[0] = Mint(1);\n        for (int d: g[mid]) {\n            V<Mint> ndp(4);\n            auto x = solve(d, mid);\n            Mint x0 = x.first - x.second, x1 = x.second;\n            ndp[3] = dp[3] * x0 + dp[2] * x1 + dp[1] * x1;\n            ndp[2] = dp[2] * x0 + dp[0] * x1;\n            ndp[1] = dp[1] * x0 + dp[0] * x1;\n            ndp[0] = dp[0] * x0;\n            dp = ndp;\n        }\n               ;\n        pr.writeln((dp[3] / Mint(2)).v);\n    } else {\n        int mid0 = path[L / 2 - 1], mid1 = path[L / 2];\n        assert(false);\n        U = (L / 2 - 1);\n        auto x = solve(mid0, mid1);\n        auto y = solve(mid1, mid0);\n        pr.writeln((x.second * y.second).v);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for(int i=(a),_ed=(b);i<=_ed;++i)\n#define DREP(i,a,b) for(int i=(a),_ed=(b);i>=_ed;--i)\n#define mp(x,y) make_pair((x),(y))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int,int> pii;\ninline int read(){\n    register int x=0,f=1;register char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=0;ch=getchar();}\n    while(isdigit(ch)){x=x*10+(ch^'0');ch=getchar();}\n    return f?x:-x;\n}\n\nconst int N=2e5+5,mod=998244353;\nint n,c[2],mxd[N],f[N][3][3],g[3][3];\nvector<int> E[N];\ninline void inc(int& x,int y){x=x+y<mod?x+y:x+y-mod;}\n\nnamespace getcore{\n\tint d[N],fa[N];\n\tvoid dfs(int u,int pa,int dis,int& rt){\n\t\td[u]=dis,fa[u]=pa;if(d[u]>d[rt])rt=u;\n\t\tfor(int v:E[u]){\n\t\t\tif(v==pa)continue;\n\t\t\tdfs(v,u,dis+1,rt);\n\t\t}\n\t}\n\tvoid Main(){\n\t\tstatic int stk[N],tp,tmp;\n\t\tdfs(1,0,0,tmp);\n\t\tdfs(tmp,0,0,tmp);\n\t\twhile(tmp)stk[++tp]=tmp,tmp=fa[tmp];\n\t\tc[0]=stk[(tp+1)>>1];\n\t\tif(~tp&1)c[1]=stk[(tp-1)>>1];\n\t}\n}\n\nint dfs(int u,int pa,int dep){\n\tmxd[u]=dep;\n\tfor(int v:E[u]){\n\t\tif(v==pa||v==c[0]||v==c[1])continue;\n\t\tmxd[u]=max(mxd[u],dfs(v,u,dep+1));\n\t}\n\tif(mxd[u]==dep)f[u][1][1]=1;\n\telse f[u][0][0]=1;\n\tfor(int v:E[u]){\n\t\tif(v==pa||v==c[0]||v==c[1])continue;\n\t\tREP(i,0,2)REP(j,0,2)g[i][j]=0;\n\t\tREP(a,0,2)REP(b,0,2)REP(p,0,2)REP(q,0,2){\n\t\t\tint flg=mxd[u]==mxd[v];\n\t\t\tint s=a,t=b,val=1ll*f[u][a][b]*f[v][p][q]%mod;\n\t\t\tinc(g[s][t],val);\n\t\t\ts=flg?min(2,a+p):a,t=b;\n\t\t\tinc(g[s][t],val);\n\t\t\ts=a,t=flg?min(2,b+q):b;\n\t\t\tinc(g[s][t],val);\n\t\t}\n\t\tREP(i,0,2)REP(j,0,2)f[u][i][j]=g[i][j];\n\t}\n\treturn mxd[u];\n}\n\nint main(){\n\t//freopen(\"in.in\",\"r\",stdin);\n\tn=read();\n\tREP(i,1,n-1){\n\t\tint u=read(),v=read();\n\t\tE[u].pb(v),E[v].pb(u);\n\t}\n\tgetcore::Main();\n\tint sum=0;\n\tdfs(c[0],0,0);\n\tif(!c[1])\n\t\tsum=f[c[0]][1][1];\n\telse{\n\t\tdfs(c[1],0,0);\n\t\tREP(i,0,2)REP(j,0,2)\n\t\t\tinc(sum,1ll*f[c[0]][1][i]*f[c[1]][j][1]%mod);\n\t\tREP(i,0,2)REP(j,0,2)\n\t\t\tinc(sum,1ll*f[c[0]][i][1]*f[c[1]][1][j]%mod);\n\t}\n\tsum=1ll*sum*(mod+1)/2%mod;\n\tprintf(\"%d\\n\",sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n\n\n\n\n#include <algorithm>\n\n#include <array>\n\n#include <bitset>\n\n#include <cassert>\n\n#include <complex>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <iostream>\n\n#include <map>\n\n#include <numeric>\n\n#include <queue>\n\n#include <set>\n\n#include <string>\n\n#include <unordered_map>\n\n#include <unordered_set>\n\n#include <vector>\n\nusing namespace std;\n\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\nstruct Scanner {\n    FILE* fp = nullptr;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += fread(line + ed, 1, (1 << 15) - ed, fp);\n        line[ed] = '\\0';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) reread();\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == '-') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] - '0');\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(V<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    Scanner(FILE* _fp) : fp(_fp) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(' ');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single('\\n');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val; // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char('0' + (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const V<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(' ');\n            write_single(val[i]);\n        }\n    }\n};\n\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    static constexpr uint get_mod() { return MD; }\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(uint(_v % MD + MD)); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(uint(ull(v) * r.v % MD)); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\n// using Mint = ModInt<998244353>;\n// template<> const Mint Mint::G = Mint(3);\n\nusing Mint = ModInt<998244353>;\n\nScanner sc = Scanner(stdin);\nPrinter pr = Printer(stdout);\n\nVV<int> g;\n\nint mdp, mv;\nvoid dfs(int p, int b, int ndp = 0) {\n    if (mdp <= ndp) {\n        mdp = ndp;\n        mv = p;\n    }\n    for (int d: g[p]) {\n        if (d == b) continue;\n        dfs(d, p, ndp + 1);\n    }\n}\n\nV<int> path;\nbool dfs_path(int p, int b, int t) {\n    if (p == t) {\n        path.push_back(p);\n        return true;\n    }\n    for (int d: g[p]) {\n        if (d == b) continue;\n        if (dfs_path(d, p, t)) {\n            path.push_back(p);\n            return true;\n        }\n    }\n    return false;\n}\n\nint U;\n\nusing P = array<Mint, 3>;\n\nP solve(int p, int b, int ndp = 0) {\n    if (g[p].size() == 1) {\n        // leaf\n        if (ndp == U) {\n            // rad\n            return {Mint(2), Mint(1), Mint(0)};\n        } else {\n//            dbg(p, b, P{Mint(3), Mint(0)});\n            return {Mint(3), Mint(0), Mint(0)};\n        }\n    }\n    P dp = {Mint(1), Mint(0), Mint(0)};\n    for (auto d: g[p]) {\n        if (d == b) continue;\n        auto ch = solve(d, p, ndp + 1);\n        P ndp = {Mint(0), Mint(0), Mint(0)};\n        for (int a = 0; a < 3; a++) {\n            for (int b = 0; b < 3; b++) {\n                ndp[min(2, a + b)] += dp[a] * ch[b];\n            }\n        }\n        dp = ndp;\n    }\n    dp[0] = dp[0] * Mint(3) + (dp[1] + dp[2]) * Mint(2);\n    return dp;\n}\n\nint main() {\n    int n;\n    sc.read(n);\n    g = VV<int>(n);\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        sc.read(a, b); a--; b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    dfs(0, -1);\n    int u = mv;\n    dfs(mv, -1);\n    int v = mv;\n    dfs_path(u, -1, v);\n\n    int L = int(path.size());\n    if (L % 2) {\n        U = (L / 2) - 1;\n        int mid = path[L / 2];\n                       ;\n        V<Mint> dp(4);\n        dp[0] = Mint(1);\n        for (int d: g[mid]) {\n            V<Mint> ndp(4);\n            auto x = solve(d, mid);\n            Mint x0 = x[0], x1 = x[1];\n            ndp[3] = dp[3] * x0 + dp[2] * x1 + dp[1] * x1;\n            ndp[2] = dp[2] * x0 + dp[0] * x1;\n            ndp[1] = dp[1] * x0 + dp[0] * x1;\n            ndp[0] = dp[0] * x0;\n            dp = ndp;\n        }\n               ;\n        pr.writeln((dp[3] / Mint(2)).v);\n    } else {\n        int mid0 = path[L / 2 - 1], mid1 = path[L / 2];\n        U = (L / 2 - 1);\n        auto x = solve(mid0, mid1);\n        auto y = solve(mid1, mid0);\n        pr.writeln((x[1] * y[1]).v);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// I think of what the world could be, A vision of the one I see, A million dreams is all it's gonna take\n\n#include<bits/stdc++.h>\n\n#define F first\n#define S second\n#define PB push_back\n#define sz(s) int((s).size())\n#define bit(n,k) (((n)>>(k))&1)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn = 2e5 + 10, mod = 1e9 + 7, inf = 998244353;\n\n\nint h[maxn], par[maxn];\nvector<int> v[maxn];\n\npii far(int u, int pr = -1){\n    par[u] = pr;\n    h[u] = pr == -1 ? 0 : (h[pr] + 1);\n    pii ans = {0, u};\n    for(int y : v[u]){\n\tif(y != pr){\n\t    pii p = far(y, u);\n\t    p.F++;\n\t    ans = max(ans, p);\n\t}\t    \n    }\n    return ans;\n}\n\nint total[maxn], dp1[maxn], dp2[maxn], dp3[maxn], under[maxn];\n\nvoid dfs(int u, int par = -1){\n    total[u] = 1, dp2[u] = 1;\n    if(sz(v[u]) == (par != -1))\n\tdp2[u] = 0, dp1[u] = 1;\n    for(int y : v[u]){\n\tif(y != par){\n\t    dfs(y, u);\n\t    under[u] = max(under[u], under[y] + 1);\n\t    total[u] = 3ll * total[u] * total[y] % mod;\n\t}\n    }\n    for(int y : v[u]){\n\tif(y != par){\n\t    int no = 0, yes = 0;\n\t    if(under[u] == under[y] + 1){\n\t\tno = (2ll * total[y] + 1ll * dp2[y]) % mod;\n\t\tyes = dp1[y];\n\t    }\n\t    else{\n\t\tno = 3ll * total[y] % mod;\n\t\tyes = 0;\n\t    }\n\t    dp3[u] = (1ll * dp3[u] * no + 1ll * dp1[u] * yes) % mod;\n\t    dp1[u] = (1ll * dp1[u] * no + 1ll * dp2[u] * yes) % mod;\n\t    dp2[u] = (1ll * dp2[u] * no) % mod;\n\t}\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie();\n\n    int n;\n    cin >> n;\n    for(int i = 0; i < n-1; i++){\n\tint a, b;\n\tcin >> a >> b;\n\tv[a].PB(b);\n\tv[b].PB(a);\n    }\n    int A = far(1).S;\n    pii p = far(A);\n    int diam = p.F, B = p.S;\n\n    int ans = 0;\n\n    if(diam & 1){\n\tfor(int i = 0; i < (diam/2); i++)\n\t    B = par[B];\n\tA = par[B];\n\tdfs(A, B);\n\tdfs(B, A);\n\tans = 1ll * dp1[A] * dp1[B] % mod;\n    }\n    else{\n\tfor(int i = 0; i < (diam/2); i++)\n\t    B = par[B];\n\tdfs(B);\n\tans = dp3[B];\n    }\n    return cout << ans << endl, 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define N 120000\n\nconst LL mod=998244353;\nLL n,f[N][2][2],g[2][2],d[N],m,mx,rt,fa[N];\nvector<LL> e[N];\n\nvoid dfs(LL u,LL dist){\n\tif (dist>mx){mx=dist; rt=u;}\n\tfor (LL v:e[u])\n\t\tif (v!=fa[u]){\n\t\t\tfa[v]=u;\n\t\t\tdfs(v,dist+1);\n\t\t}\n}\n\nLL inv(LL x){return x==1?1:(mod-mod/x)*inv(mod%x)%mod;}\n\nvoid upd(LL &x,LL y){x=(x+y)%mod;}\n\nvoid dp(LL u,LL dist){\n\tif (dist==m/2) f[u][1][1]=1;\n\telse f[u][0][0]=1;\n\tfor (LL v:e[u])\n\t\tif (v!=fa[u]){\n\t\t\tfa[v]=u;\n\t\t\tdp(v,dist+1);\n\t\t\tmemset(g,0,sizeof g);\n\t\t\tfor (LL i1:{0,1}) for (LL i2:{0,1}) for (LL j1:{0,1}) for (LL j2:{0,1})\n\t\t\t\tfor (LL k=0;k<=2;++k){\n\t\t\t\t\tLL t1=j1&&k==1,t2=j2&&k==2;\n\t\t\t\t\tif ((i1&&t1)||(i2&&t2)) continue;\n\t\t\t\t\tupd(g[i1|t1][i2|t2],f[u][i1][i2]*f[v][j1][j2]);\n\t\t\t\t}\n\t\t\tmemcpy(f[u],g,sizeof f[u]);\n\t\t}\n}\n\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor (LL i=1;i<n;++i){\n\t\tLL x,y; scanf(\"%lld%lld\",&x,&y);\n\t\te[x].push_back(y);\n\t\te[y].push_back(x);\n\t}\n\tdfs(1,1);\n\tmemset(fa,0,sizeof fa); mx=0;\n\tdfs(rt,1);\n\tfor (LL i=rt;i;i=fa[i]) d[++m]=i;\n\tmemset(fa,0,sizeof fa);\n\tif (m&1){\n\t\tLL p=d[m/2+1];\n\t\tdp(p,0);\n\t\tprintf(\"%lld\\n\",f[p][1][1]*inv(2)%mod);\n\t}\n\telse{\n\t\tLL p1=d[m/2],p2=d[m/2+1];\n\t\tfa[p1]=p2; fa[p2]=p1;\n\t\tdp(p1,1); dp(p2,1);\n\t\tprintf(\"%lld\\n\",f[p1][1][0]*f[p2][1][0]%mod);\n\t}\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=200000+5,mod=998244353;\nint ksm(int b,int n){\n\tint res=1;\n\twhile(n){\n\t\tif(n&1) res=res*b%mod;\n\t\tb=b*b%mod; n>>=1;\n\t}\n\treturn res;\n}\nint add(int x,int y){\n\treturn (x+y)%mod;\n}\nint mul(int x,int y){\n\treturn x*y%mod;\n}\nvector<int> e[N];\nint n,dis[N],pre[N];\nint dp[N][3][3];\nint bfs(int st){\n\tqueue<int> q;\n\tint res=0;\n\tfor(int i=1;i<=n;++i)\n\t\tdis[i]=0;\n\tdis[st]=1; pre[st]=0; q.push(st);\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\tif(dis[u]>dis[res]) res=u;\n\t\t//cout<<st<<\" \"<<u<<\" \"<<dis[u]<<\" \"<<res<<endl;\n\t\tfor(int i=0;i<e[u].size();++i)\n\t\t\tif(dis[e[u][i]]==0) q.push(e[u][i]),dis[e[u][i]]=dis[u]+1,pre[e[u][i]]=u;\n\t}\n\treturn res;\n}\nint L,tmp[3][3];\nvoid dfs(int u,int fath,int dep){\n\t//cout<<u<<\" \"<<fath<<\" \"<<dep<<endl;\n\tif(dep==L/2) dp[u][1][1]=1;\n\telse dp[u][0][0]=1;\n\tfor(int i=0;i<e[u].size();++i){\n\t\tint v=e[u][i];\n\t\tif(v==fath) continue;\n\t\tdfs(v,u,dep+1);\n\t\tfor(int x=0;x<=2;++x)\n\t\t\tfor(int y=0;y<=2;++y)\n\t\t\t\ttmp[x][y]=0;\n\t\tfor(int x=0;x<=2;++x)\n\t\t\tfor(int y=0;y<=2;++y)\n\t\t\t\tfor(int a=0;a<=2;++a)\n\t\t\t\t\tfor(int b=0;b<=2;++b)\n\t\t\t\t\t\tfor(int type=0;type<=2;++type){\n\t\t\t\t\t\t\tint p=min(x+(type==1)*a,2ll),q=min(y+(type==2)*b,2ll);\n\t\t\t\t\t\t\ttmp[p][q]=add(tmp[p][q],mul(dp[u][x][y],dp[v][a][b]));\n\t\t\t\t\t\t}\n\t\tfor(int x=0;x<=2;++x)\n\t\t\tfor(int y=0;y<=2;++y)\n\t\t\t\tdp[u][x][y]=tmp[x][y];\n\t}\n\t//for(int x=0;x<=2;++x)\n\t//\tfor(int y=0;y<=2;++y)\n\t\t//\tcout<<u<<\" \"<<x<<\" \"<<y<<\" \"<<dp[u][x][y]<<endl;\n}\nint c[N],tot;\nvoid solve(){\n\tint from=bfs(1),to=bfs(from);\n//\tcout<<from<<\" \"<<to<<endl;\n\ttot=0;while(to) c[++tot]=to,to=pre[to];\n//\tcout<<tot<<endl; \n\tL=tot;\n\tif(tot&1){\n\t\tfrom=c[(tot+1)/2];\n\t\tdfs(from,0,0);\n\t\t//cout<<dp[from][1][1]<<endl;\n\t\tcout<<mul(dp[from][1][1],ksm(2,mod-2));\n\t\treturn;\n\t}\n\telse{\n\t\tfrom=c[tot/2],to=c[(tot+2)/2];\n\t\t//cout<<from<<\" \"<<to<<endl;\n\t\tdfs(from,to,0);\n\t\tint x=0,y=0;\n\t\tfor(int i=0;i<=2;++i)\n\t\t\tx=add(x,dp[from][i][1]);\n\t\tdfs(to,from,0);\n\t\tfor(int i=0;i<=2;++i)\n\t\t\ty=add(y,dp[to][1][i]);\n\t//cout<<x<<\" \"<<y<<endl;\n\t\tcout<<mul(x,y);\n\t\treturn;\n\t}\n}\nsigned main(){\n\tint ans=0,u,v;\n\tcin>>n;\n\tfor(int i=1;i<n;++i){\n\t\tcin>>u>>v;\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e5 + 5, mod = 998244353;\n\nvector<int> g[N];\nint par[N], lv[N];\nlong long dp[N][3], tmp[3];\n\nvoid add(long long & var, long long val) {\n  var += val;\n  if (var >= mod)\n    var -= mod;\n}\n\nvoid dfs(int v, int p) {\n  par[v] = p;\n  for (int u : g[v]) {\n    if (u == p) continue;\n    lv[u] = lv[v] + 1;\n    dfs(u, v);\n  }\n}\n\nvoid solve(int v, int p, int depth) {\n  memset(dp[v], 0, sizeof dp[v]);\n  dp[v][(depth == 0)] = 1;\n  --depth;\n  for (int u : g[v]) {\n    if (u == p) continue;\n    solve(u, v, depth);\n    memset(tmp, 0, sizeof tmp);\n    for (int i = 0; i < 3; ++i) {\n      for (int j = 0; j < 3; ++j) {\n        add(tmp[min(i+j, 2)], dp[v][i] * dp[u][j] % mod);\n        add(tmp[i], 2LL * dp[v][i] * dp[u][j] % mod);\n      }\n    }\n    for (int i = 0; i < 3; ++i)\n      dp[v][i] = tmp[i];\n  }\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i < n; ++i) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    --u, --v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  lv[0] = 0;\n  dfs(0, 0);\n  int root = 0;\n  for (int i = 0; i < n; ++i) {\n    if (lv[i] > lv[root])\n      root = i;\n  }\n  lv[root] = 0;\n  dfs(root, -1);\n  int leaf = 0;\n  for (int i = 0; i < n; ++i) {\n    if (lv[i] > lv[leaf])\n      leaf = i;\n  }\n  int diam = lv[leaf];\n  long long ans = 0;\n  if (diam & 1) {\n    int a = leaf;\n    for (int i = 0; i < diam/2; ++i) {\n      a = par[a];\n    }\n    int b = par[a];\n    solve(a, b, diam/2);\n    solve(b, a, diam/2);\n    ans = 1LL * dp[a][1] * dp[b][1] % mod;\n  }\n  else {\n    int c = leaf;\n    for (int i = 0; i < diam/2; ++i) {\n      c = par[c];\n    }\n    long long best[3];\n    memset(best, 0, sizeof best);\n    best[0] = 1;\n    for (int u : g[c]) {\n      solve(u, c, diam/2-1);\n      memset(tmp, 0, sizeof tmp);\n      dp[u][0] = (dp[u][0] - dp[u][1] - dp[u][2]) % mod;\n      dp[u][0] = (3LL * dp[u][0] + dp[u][1] + dp[u][2]) % mod;\n      tmp[0] = (best[0] * dp[u][0]) % mod;\n      tmp[1] = (best[0] * dp[u][1] + best[1] * dp[u][0]) % mod;\n      tmp[2] = (best[1] * dp[u][1] + best[2] * dp[u][0]) % mod;\n      for (int i = 0; i < 3; ++i)\n        best[i] = tmp[i];\n    }\n    ans = best[2];\n  }\n  ans %= mod;\n  if (ans < 0)\n    ans += mod;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define R register\n#define mp make_pair\n#define ll long long\n#define pii pair<int, int>\nusing namespace std;\nconst int N = 210000, mod = 998244353;\n\nint n, dis[N], a, b, p[N];\nll f[N][2];\nvector<int> to[N];\n\ntemplate <class T>\ninline void read(T &x) {\n\tx = 0;\n\tchar ch = getchar(), w = 0;\n\twhile (!isdigit(ch)) w = (ch == '-'), ch = getchar();\n\twhile (isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();\n\tx = w ? -x : x;\n\treturn;\n}\n\ninline void addEdg(int x, int y) {\n\tto[x].push_back(y), to[y].push_back(x);\n\treturn;\n}\n\nvoid dfs1(int now, int fa) {\n\tdis[now] = dis[fa] + 1;\n\tfor (auto &v : to[now]) {\n\t\tif (v == fa) continue;\n\t\tdfs1(v, now);\n\t}\n\treturn;\n}\n\nint dfs2(int now, int fa, int maxD) {\n\tif (dis[now] == maxD) return p[now] = 1;\n\tint ret = 0;\n\tfor (auto &v : to[now]) {\n\t\tif (v == fa) continue;\n\t\tret |= dfs2(v, now, maxD);\n\t}\n\tif (ret) {\n\t\tif (dis[now] == (maxD + 1) >> 1)\n\t\t\ta = now;\n\t\telse if (dis[now] == (maxD >> 1) + 1)\n\t\t\tb = now;\n\t}\n\treturn ret;\n}\n\nvoid dfs3(int now, int fa) {\n\tf[now][0] = 1, f[now][1] = p[now];\n\tfor (auto &v : to[now]) {\n\t\tif (v == fa) continue;\n\t\tdfs3(v, now);\n\t\tf[now][1] = (f[now][1] * f[v][0] + f[now][0] * f[v][1]) % mod;\n\t\tf[now][0] = (f[now][0] * f[v][0]) % mod;\n\t}\n\tf[now][0] = (f[now][0] * 3 - f[now][1] + mod) % mod;\n\treturn;\n}\n\nint main() {\n\tint x, y;\n\tread(n);\n\tfor (R int i = 1; i < n; ++i)\n\t\tread(x), read(y), addEdg(x, y);\n\tdfs1(1, 0);\n\tint rt = 1, maxD = 1;\n\tfor (R int i = 2; i <= n; ++i)\n\t\tif (dis[i] > maxD) maxD = dis[i], rt = i;\n\tdfs1(rt, 0), maxD = 1;\n\tfor (R int i = 1; i <= n; ++i)\n\t\tmaxD = max(maxD, dis[i]);\n\tdfs2(rt, 0, maxD), p[rt] = 1;\n\tif (b) {\n\t\t//dfs3(b, a), dfs3(a, b);\n\t\t//printf(\"%lld\\n\", f[a][1] * f[b][1] % mod);\n\t}\n\telse {\n\t\tf[a][0] = 1;\n\t\tll ans = 0;\n\t\tfor (auto &v : to[a]) {\n\t\t\tdfs3(v, a);\n\t\t\tans = (ans * f[v][0] + f[a][1] * f[v][1]) % mod;\n\t\t\tf[a][1] = (f[a][1] * f[v][0] + f[a][0] * f[v][1]) % mod;\n\t\t\tf[a][0] = (f[a][0] * f[v][0]) % mod;\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define mod 998244353\n#define N 500001\nusing namespace std;\nint total1=0;\nlong long dia=0;\nint next[N],head[N],edge[N],maxdep1[N],maxdep2[N],maxwhere1[N],maxwhere2[N];\nlong long size[N],f[N][2];\nint n;\nlong long ksmi(long long x,long long y)\n{\n\tlong long total=1,ab=x,p=y;\n\twhile (p)\n\t{\n\t\tif (p%2==1) total=total*ab%mod;\n\t\tab=ab*ab%mod;\n\t\tp/=2;\n\t}\n\treturn total;\n}\nlong long max(long long x,long long y)\n{\n\tif (x<y) return y;\n\treturn x;\n}\nvoid insert(int x,int y)\n{\n\ttotal1++;\n\tnext[total1]=head[x];\n\thead[x]=total1;\n\tedge[total1]=y;\n}\nvoid dfs(int k,int fa)\n{\n\tmaxdep1[k]=1;\n\tsize[k]=1;\n\tfor (int i=head[k];i;i=next[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (y==fa) continue;\n\t\tdfs(y,k);\n\t\tsize[k]=size[k]+size[y];\n\t\tmaxdep1[k]=max(maxdep1[k],maxdep1[y]+1);\n\t\tif (maxdep1[k]==maxdep1[y]+1) maxwhere1[k]=y;\n\t}\n\tmaxdep2[k]=0;\n\tfor (int i=head[k];i;i=next[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (y==fa||y==maxwhere1[k]) continue;\n\t//\tdfs(y,k);\n\t\tmaxdep2[k]=max(maxdep2[k],maxdep1[y]+1);\n\t\tif (maxdep2[k]==maxdep1[y]+1) maxwhere2[k]=y;\n\t}\n\tif (k==3)\n\t{\n\t\tk++;k--;\n\t}\n\tdia=max(dia,maxdep1[k]+maxdep2[k]-1);\n\tdia=max(dia,maxdep1[k]);\n\tf[k][0]=1;\n\tbool bo1=true;\n\tfor (int i=head[k];i;i=next[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (y==fa) continue;\n\t\tbo1=false;\n\t\tlong long daijia=ksmi(3,size[y]);\n\t\tif (maxdep1[y]+1==maxdep1[k]) daijia=(f[y][0]*3+f[y][1]*2)%mod;\n\t\tf[k][0]=(f[k][0]*(daijia)%mod)%mod;\n\t}\n\tif (bo1) f[k][0]=0;\n\tf[k][1]=0;\n\tbool bo=true;\n\tfor (int i=head[k];i;i=next[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (y==fa) continue;\n\t\tif (maxdep1[y]+1<maxdep1[k]) continue;\n\t\tbo=false;\n\t\tlong long daijia=f[y][0]*3%mod+f[y][1]*2%mod;\n\t\tdaijia%=mod;\n\t\tlong long nowf=f[k][0]*ksmi(daijia,mod-2)%mod;\n\t\tnowf=nowf*f[y][1]%mod;\n\t\tf[k][1]=(f[k][1]+nowf)%mod;\n\t}\n\tif (bo) f[k][1]=1;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tinsert(x,y);insert(y,x);\n\t}\n\tlong long ans=0;\n\tdia=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (i==1)\n\t\t{\n\t\t\tn++;n--;\n\t\t}\n\t\tdfs(i,0);\n\t\tif (maxdep1[i]==dia)\n\t\t\tans=(ans+f[i][1])%mod;\n\t}\n\tprintf(\"%lld\\n\",ans*ksmi(2,mod-2)%mod);\n} "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define N_ 201000\nusing namespace std;\nint n, D1[N_], D2[N_], MD, C[N_], DD[N_];\nlong long po[N_], D[N_][3], Mod = 998244353;\nvector<int>E[N_];\nvoid DFS(int a, int pp, int *d) {\n\tfor (auto &x : E[a]) {\n\t\tif (x == pp)continue;\n\t\td[x] = d[a] + 1;\n\t\tDFS(x, a, d);\n\t}\n}\nvoid Add_Edge(int a, int b) {\n\tE[a].push_back(b);\n\tE[b].push_back(a);\n}\nvoid Del_Edge(int a, int b) {\n\tint sz = E[a].size();\n\tfor (int i = 0; i < sz; i++) {\n\t\tif (E[a][i] == b) {\n\t\t\tswap(E[a][i], E[a][sz - 1]);\n\t\t\tE[a].pop_back();\n\t\t\treturn;\n\t\t}\n\t}\n}\nvoid Go(int a, int pp) {\n\tvector<int>T;\n\tfor (auto &x : E[a]) {\n\t\tif (x == pp)continue;\n\t\tGo(x, a);\n\t\tT.push_back(x);\n\t}\n\tif (T.empty()) {\n\t\tif (DD[a] == MD) {\n\t\t\tD[a][0] = 2, D[a][1] = 1;\n\t\t}\n\t\telse {\n\t\t\tD[a][0] = 3;\n\t\t}\n\t\treturn;\n\t}\n\tD[a][0] = 1, D[a][1] = 0, D[a][2] = 0;\n\tfor (auto &x : T) {\n\t\tlong long d0 = D[a][0] * D[x][0];\n\t\tlong long d1 = D[a][0] * D[x][1] + D[a][1] * D[x][0];\n\t\tlong long d2 = D[a][0] * D[x][2] + D[a][1] * (D[x][1] + D[x][2]) + D[a][2] * (D[x][0] + D[x][1] + D[x][2]);\n\t\tD[a][0] = d0 % Mod, D[a][1] = d1 % Mod, D[a][2] = d2 % Mod;\n\t}\n\tD[a][0] = (D[a][0] * 3 + D[a][1] * 2 + D[a][2] * 2) % Mod;\n}\nint main() {\n\tint i, mid;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i < n; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tE[a].push_back(b);\n\t\tE[b].push_back(a);\n\t}\n\tD1[1] = 0;\n\tDFS(1, 0, D1);\n\tint Mx = -1, a = -1, b = -1;\n\tfor (i = 1; i <= n; i++) {\n\t\tif (Mx < D1[i])Mx = D1[i], a = i;\n\t}\n\tD1[a] = 0;\n\tDFS(a, 0, D1);\n\tMx = -1;\n\tfor (i = 1; i <= n; i++) {\n\t\tif (Mx < D1[i])Mx = D1[i], b = i;\n\t}\n\tD2[b] = 0;\n\tDFS(b, 0, D2);\n\tif (Mx % 2 == 1) {\n\t\tint t1, t2;\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tif (D1[i] + D2[i] == Mx) {\n\t\t\t\tif (D1[i] == Mx / 2) {\n\t\t\t\t\tt1 = i;\n\t\t\t\t}\n\t\t\t\tif (D2[i] == Mx / 2) {\n\t\t\t\t\tt2 = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tDel_Edge(t1, t2); Del_Edge(t2, t1);\n\t\tn++;\n\t\tAdd_Edge(t1, n); Add_Edge(t2, n);\n\t\tD1[a] = 0, D2[b] = 0;\n\t\tDFS(a, 0, D1);\n\t\tDFS(b, 0, D2);\n\t\tMx = D1[b];\n\t}\n\tMD = 1e9;\n\tfor (i = 1; i <= n; i++) {\n\t\tif (max(D1[i], D2[i]) < MD) {\n\t\t\tMD = max(D1[i], D2[i]);\n\t\t\tmid = i;\n\t\t}\n\t}\n\tDFS(mid, 0, DD);\n\tpo[0] = 1;\n\tfor (i = 1; i <= n; i++)po[i] = po[i - 1] * 3 % Mod;\n\tlong long dd[3] = { 1,0,0 };\n\tfor (auto &x : E[mid]) {\n\t\tGo(x, mid);\n\t\tlong long g = (D[x][0] - D[x][1] + Mod) % Mod;\n\t\tlong long dd0 = dd[0] * g;\n\t\tlong long dd1 = dd[0] * D[x][1] + dd[1]* g;\n\t\tlong long dd2 = dd[1] * D[x][1] + dd[2] * g;\n\t\tdd[0] = dd0%Mod, dd[1] = dd1 % Mod, dd[2] = dd2 % Mod;\n\t}\n\tprintf(\"%lld\\n\", dd[2]);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define N 300000\n\nconst LL mod=998244353;\nLL n,f[N][3][3],g[3][3],d[N],m,mx,rt,fa[N];\nvector<LL> e[N];\n\nvoid dfs(LL u,LL dist){\n\tif (dist>mx){mx=dist; rt=u;}\n\tfor (LL v:e[u])\n\t\tif (v!=fa[u]){\n\t\t\tfa[v]=u;\n\t\t\tdfs(v,dist+1);\n\t\t}\n}\n\nLL inv(LL x){return x==1?1:(mod-mod/x)*inv(mod%x)%mod;}\n\nvoid upd(LL &x,LL y){x=(x+y)%mod;}\n\nvoid dp(LL u,LL dist){\n\tif (dist==m/2) f[u][1][1]=1;\n\telse f[u][0][0]=1;\n\tfor (LL v:e[u])\n\t\tif (v!=fa[u]){\n\t\t\tfa[v]=u;\n\t\t\tdp(v,dist+1);\n\t\t\tmemset(g,0,sizeof g);\n\t\t\tfor (LL i1:{0,1,2}) for (LL i2:{0,1,2}) for (LL j1:{0,1,2}) for (LL j2:{0,1,2})\n\t\t\t\tfor (LL k:{0,1,2}){\n\t\t\t\t\tLL t1=j1*(k==1),t2=j2*(k==2);\n\t\t\t\t\tt1=min(2LL,i1+t1); t2=min(2LL,i2+t2);\n\t\t\t\t\tupd(g[t1][t2],f[u][i1][i2]*f[v][j1][j2]);\n\t\t\t\t}\n\t\t\tmemcpy(f[u],g,sizeof f[u]);\n\t\t}\n}\n\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor (LL i=1;i<n;++i){\n\t\tLL x,y; scanf(\"%lld%lld\",&x,&y);\n\t\te[x].push_back(y);\n\t\te[y].push_back(x);\n\t}\n\tdfs(1,1);\n\tmemset(fa,0,sizeof fa); mx=0;\n\tdfs(rt,1);\n\tfor (LL i=rt;i;i=fa[i]) d[++m]=i;\n\tmemset(fa,0,sizeof fa);\n\tif (m&1){\n\t\tLL p=d[m/2+1];\n\t\tdp(p,0);\n\t\tprintf(\"%lld\\n\",f[p][1][1]*inv(2)%mod);\n\t}\n\telse{\n\t\tLL p1=d[m/2],p2=d[m/2+1];\n\t\tfa[p1]=p2; fa[p2]=p1;\n\t\tdp(p1,1); dp(p2,1);\n\t\tprintf(\"%lld\\n\",f[p1][1][0]*f[p2][1][0]%mod);\n\t}\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200100\nusing namespace std;\nvector<int> g[N];\nlong long to_leaf[N],p3sz[N],nume[N][3];\nconst int Q=998244353;\nint find_c(int u,int p){\n\tint mx[2]={u,u},ans=0,tans;\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint v=g[u][i];\n\t\tif(v==p) continue;\n\t\ttans=find_c(v,u);\n\t\tif(tans>ans){\n\t\t\tans=tans;\n\t\t}\n\t\tif(to_leaf[v]>to_leaf[mx[0]]){\n\t\t\tmx[1]=mx[0];\n\t\t\tmx[0]=v;\n\t\t}\n\t\telse if(to_leaf[v]>to_leaf[mx[1]]){\n\t\t\tmx[1]=v;\n\t\t}\n\t}\n\tif(to_leaf[mx[0]]+to_leaf[mx[1]]>ans){\n\t\tans=to_leaf[mx[0]]+to_leaf[mx[1]];\n\t}\n\tto_leaf[u]=to_leaf[mx[0]]+1;\n\treturn ans;\n}\nvoid build(int u,int p){\n\tto_leaf[u]=0;\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint v=g[u][i];\n\t\tif(v==p) continue;\n\t\tbuild(v,u);\n\t\tto_leaf[u]=max(to_leaf[u],to_leaf[v]+1);\n\t}\n}\nvoid solve(int u,int p){\n\tp3sz[u]=1;\n\tif(!to_leaf[u]){\n\t\tnume[u][1]=1;\n\t\treturn;\n\t}\n\tnume[u][0]=1;\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint v=g[u][i];\n\t\tif(v==p) continue;\n\t\tsolve(v,u);\n\t\tif(to_leaf[v]+1==to_leaf[u]){\n\t\t\tfor(int j=2;j>=0;j--){\n\t\t\t\tnume[u][j]=(2LL*p3sz[v]+nume[v][0])*nume[u][j]%Q;\n\t\t\t\tif(j){\n\t\t\t\t\tnume[u][j]+=1LL*nume[v][1]*nume[u][j-1]%Q;\n\t\t\t\t\tnume[u][j]%=Q;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tnume[u][j]=3LL*p3sz[v]*nume[u][j]%Q;\n\t\t\t}\n\t\t}\n\t\tp3sz[u]=3LL*p3sz[v]*p3sz[u]%Q;\n\t}\n}\nint main(){\n\tint n,x,y;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tint l,p=0,c=1;\n\tl=find_c(1,0);\n\tbool flag=true;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<g[c].size();i++){\n\t\t\tif(g[c][i]!=p && to_leaf[g[c][i]]>(l+1)/2){\n\t\t\t\tp=c;\n\t\t\t\tc=g[c][i];\n\t\t\t\tflag=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"diameter=%d\\n\",l);\n\tif(l&1){\n\t\tint d=-1;\n\t\tfor(int i=0;i<g[c].size();i++){\n\t\t\tif(to_leaf[g[c][i]]==(l+1)/2){\n\t\t\t\td=g[c][i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//printf(\"center: %d %d\\n\",c,d);\n\t\tassert(d>0);\n\t\tbuild(c,d);\n\t\tsolve(c,d);\n\t\tbuild(d,c);\n\t\tsolve(d,c);\n\t\tprintf(\"%d\\n\",1LL*nume[c][1]*nume[d][1]%Q);\n\t}\n\telse{\n\t\t//printf(\"center: %d\\n\",c);\n\t\tbuild(c,0);\n\t\tsolve(c,0);\n\t\tprintf(\"%d\\n\",nume[c][2]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for(int i=(a),_ed=(b);i<=_ed;++i)\n#define DREP(i,a,b) for(int i=(a),_ed=(b);i>=_ed;--i)\n#define mp(x,y) make_pair((x),(y))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int,int> pii;\ninline int read(){\n    register int x=0,f=1;register char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=0;ch=getchar();}\n    while(isdigit(ch)){x=x*10+(ch^'0');ch=getchar();}\n    return f?x:-x;\n}\n\nconst int N=2e5+5,mod=998244353;\nint n,c[2],mxd[N],f[N][3][3],g[3][3];\nvector<int> E[N];\ninline void inc(int& x,int y){x=x+y<mod?x+y:x+y-mod;}\n\nnamespace getcore{\n\tint d[N],fa[N],stk[N],tp,tmp;\n\tvoid dfs(int u,int pa,int dis,int& rt){\n\t\td[u]=dis,fa[u]=pa;if(d[u]>d[rt])rt=u;\n\t\tfor(int v:E[u]){\n\t\t\tif(v==pa)continue;\n\t\t\tdfs(v,u,dis+1,rt);\n\t\t}\n\t}\n\tvoid Main(){\n\t\tdfs(1,0,0,tmp);\n\t\tdfs(tmp,0,0,tmp);\n\t\twhile(tmp)stk[++tp]=tmp,tmp=fa[tmp];\n\t\tc[0]=stk[(tp+1)>>1];\n\t\tif(~tp&1)c[1]=stk[((tp+1)>>1)+1];//想清楚啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊\n\t}\n}\n\nint dfs(int u,int pa,int dep){\n\tmxd[u]=dep;\n\tfor(int v:E[u]){\n\t\tif(v==pa||v==c[0]||v==c[1])continue;\n\t\tmxd[u]=max(mxd[u],dfs(v,u,dep+1));\n\t}\n\tif(mxd[u]==dep)f[u][1][1]=1;\n\telse f[u][0][0]=1;\n\tfor(int v:E[u]){\n\t\tif(v==pa||v==c[0]||v==c[1])continue;\n\t\tREP(i,0,2)REP(j,0,2)g[i][j]=0;\n\t\tREP(a,0,2)REP(b,0,2)REP(p,0,2)REP(q,0,2){\n\t\t\tint flg=mxd[u]==mxd[v];\n\t\t\tint s=a,t=b,val=1ll*f[u][a][b]*f[v][p][q]%mod;\n\t\t\tinc(g[s][t],val);\n\t\t\ts=flg?min(2,a+p):a,t=b;\n\t\t\tinc(g[s][t],val);\n\t\t\ts=a,t=flg?min(2,b+q):b;\n\t\t\tinc(g[s][t],val);\n\t\t}\n\t\tREP(i,0,2)REP(j,0,2)f[u][i][j]=g[i][j];\n\t}\n\treturn mxd[u];\n}\n\nint main(){\n\tfreopen(\"in.in\",\"r\",stdin);\n\tfreopen(\"out.out\",\"w\",stdout);\n\tn=read();\n\tREP(i,1,n-1){\n\t\tint u=read(),v=read();\n\t\tE[u].pb(v),E[v].pb(u);\n\t}\n\tgetcore::Main();\n\tint sum=0;\n\tdfs(c[0],0,0);\n\tif(!c[1])\n\t\tsum=f[c[0]][1][1];\n\telse{\n\t\tdfs(c[1],0,0);\n\t\tREP(i,0,2)REP(j,0,2)\n\t\t\tinc(sum,1ll*f[c[0]][1][i]*f[c[1]][j][1]%mod);\n\t\tREP(i,0,2)REP(j,0,2)\n\t\t\tinc(sum,1ll*f[c[0]][i][1]*f[c[1]][1][j]%mod);\n\t}\n\tsum=1ll*sum*(mod+1)/2%mod;\n\tprintf(\"%d\\n\",sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i,a,b) for (int i=a;i<=b;i++)\n#define R(i,a,b) for (int i=a;i<b;i++)\n#define D(i,a,b) for (int i=a;i>=b;i--)\n#define go(i,x) for (int i=head[x];i;i=Next[i])\n#define pb push_back\n#define si size()\n#define fi first\n#define se second\n#define pa pair < ll,ll >\n#define ll long long\n#define mp make_pair\n#define be begin()\n#define en end()\n#define put putchar('\\n')\n#define gc getchar\n#define pc putchar\n#define N 6000055\n#define mo 998244353\n#define inf 1000000007\n#define int ll\n#define ret return puts(\"-1\"),0\nusing namespace std;\ninline ll read(){\n\tll su=0,f=1;char c=gc();\n\tfor (;c<'0'||c>'9';c=gc()) if (c=='-') f=-1;\n\tfor (;c>='0'&&c<='9';c=gc()) su=su*10+c-'0';\n\treturn su*f;\n}\ninline void wr(ll x){\n\tif (x<0) pc('-'),wr(-x);\n\telse{if (x>=10) wr(x/10);pc(x%10+'0');}\n}\ninline void wri(ll x){wr(x);pc(' ');}\ninline void wrn(ll x){wr(x);put;}\ninline void wrn(ll x,ll y){wri(x);wrn(y);}\ninline void wrn(ll x,ll y,ll z){wri(x);wrn(y,z);}\nint ans,n,m,f[N][3],fa[N],dis[N],lo,rt,mx;\ninline void ad(int &x,int k){x+=k;x-=(x>=mo)?mo:0;}\nint Next[N*2],head[N],to[N*2],nedge,g[N][4];\n#define V to[i]\nvoid add(int a,int b){Next[++nedge]=head[a];head[a]=nedge;to[nedge]=b;}\nvoid add_ne(int a,int b){add(a,b);add(b,a);}\nvoid dfs(int x){\n\tmx=(dis[x]>dis[mx])?x:mx;\n\tgo(i,x){\n\t\tif (V==fa[x]) continue;\n\t\tfa[V]=x;dis[V]=dis[x]+1;dfs(V);\n\t}\n}\nint ksm(ll x,int k){\n\tint su=1;\n\tfor (;k;k>>=1,x=x*x%mo) if (k&1) su=su*x%mo;\n\treturn su;\n}\nvoid solve(int x){\n\tint pd=0;\n\tf[x][0]=1;\n\tg[x][0]=1;\n\tgo(i,x){\n\t\tif (V==fa[x]) continue;\n\t\tsolve(V);pd++;\n\t\tg[x][3]=1ll*g[x][3]*(((g[V][0]+g[V][1])%mo+g[V][2])%mo)%mo;\n\t\tad(g[x][3],1ll*g[x][1]*g[V][2]%mo);\n\t\tad(g[x][3],1ll*g[x][2]*g[V][1]%mo);\n\t\tg[x][1]=1ll*g[x][1]*((g[V][0]+g[V][1])%mo)%mo;\n\t\tg[x][2]=1ll*g[x][2]*((g[V][0]+g[V][2])%mo)%mo;\n\t\tad(g[x][1],1ll*g[x][0]*g[V][1]%mo);\n\t\tad(g[x][2],1ll*g[x][0]*g[V][2]%mo);\n\t\tg[x][0]=1ll*g[x][0]*g[V][0]%mo;\n\t\t\n\t\tf[x][2]=1ll*f[x][2]*((f[V][0]+f[V][1]+f[V][2])%mo)%mo;\n\t\tad(f[x][2],1ll*f[x][1]*(f[V][1]+f[V][2])%mo);\n\t\tad(f[x][2],1ll*f[x][0]*f[V][2]%mo);\n\t\tf[x][1]=1ll*f[x][1]*f[V][0]%mo;\n\t\tad(f[x][1],1ll*f[x][0]*f[V][1]%mo);\n\t\tf[x][0]=1ll*f[x][0]*f[V][0]%mo;\n\t}\n\tif (pd){\n\t\tf[x][0]=1ll*f[x][0]*3%mo;\n\t\tad(f[x][0],f[x][1]*2%mo);\n\t\tad(f[x][0],f[x][2]*2%mo);\n\t\tg[x][0]=1ll*g[x][0]*3%mo;\n\t\tad(g[x][0],((g[x][1]+g[x][2])%mo*2%mo+g[x][3])%mo);\n\t\tad(g[x][1],g[x][3]);ad(g[x][2],g[x][3]);\n\t}\n\telse{\n\t\tif (dis[x]==lo/2) f[x][1]=1,f[x][0]=2,g[x][1]=g[x][0]=g[x][2]=1;\n\t\telse f[x][0]=3,g[x][0]=3;\n\t}\n}\nsigned main(){\n\tn=read();\n\tR(i,1,n) add_ne(read(),read());\n\tdfs(1);\n\trt=mx;mx=0;dis[rt]=0;fa[rt]=0;\n\tdfs(rt);\n\tlo=dis[mx];\n\tF(i,1,lo/2) mx=fa[mx];\n\tif (lo&1){\n\t\tint x=mx,y=fa[mx];\n\t\tfa[y]=x;dis[x]=dis[y]=0;dfs(x);dfs(y);\n\t\tsolve(x);solve(y);\n\t\t//wrn(f[1][0],f[1][1]);\n\t\twrn(1ll*f[x][1]*f[y][1]%mo);\n\t\t//wrn(f[x][1],f[y][1]);\n\t\t//wrn(ksm(3,n-lo-1));\n\t}\n\telse{\n\t\tint x=mx,nu=0;\n\t\tfa[x]=0;dis[x]=0;dfs(x);\n\t\tF(i,1,n) if (dis[i]==lo/2) nu++;\n\t\t//ans=(1ll*nu*(nu-1)/2)%mo*ksm(3,n-lo-1)%mo;\n\t\tsolve(x);\n\t\tf[x][0]=1;f[x][1]=0;\n\t\tgo(i,x){\n\t\t\t//wrn(V);\n\t\t\t//wrn(g[V][0],g[V][1],g[V][2]);\n\t\t\tans=1ll*ans*g[V][0]%mo;\n\t\t\tad(ans,1ll*f[x][1]*f[V][1]%mo);\n\t\t\tf[x][1]=1ll*f[x][1]*g[V][0]%mo;\n\t\t\tad(f[x][1],1ll*f[x][0]*f[V][1]%mo);\n\t\t\tf[x][0]=1ll*f[x][0]*g[V][0]%mo;\t\t\t\n\t\t}\n\t\twrn(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define MOD 998244353\ntemplate<typename ty1,typename ty2>\ninline int add(ty1 x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x += y; return x < MOD ? x : x - MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline void addto(ty1 &x, ty2 y) {\n\t\t  if(y>=MOD)y%=MOD;\n\t\t  if(x>=MOD)x%=MOD;\n\t      x += y; if (x >= MOD) x -= MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int sub(ty1 x, ty2 y) {\n\t\tif(y>=MOD)y%=MOD;\n\t\t if(x>=MOD)x%=MOD;\n        x -= y; return x < 0 ? x + MOD : x;\n}\ntemplate<typename ty1,typename ty2>\ninline void subto(ty1 &x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x -= y; if (x < 0) x += MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int mul(ty1 x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        return 1ll * x * y % MOD;\n}\ntemplate<typename ty1,typename ty2>\nvoid multo(ty1 &x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        x=1ll * x * y % MOD;\n}\n  \nlong long int gcd(long long int a, long long int b){\n\tif (a > b){\n\t\tswap(a, b);\n\t}\n\twhile (a){\n\t\tswap(a, b);\n\t\ta %= b;\n\t}\n\treturn b;\n}\nlong long int lcm(long long int a, long long int b){\n\treturn a / gcd(a, b)*b;\n}\nlong long int ppow(long long int i, long long int j){\n\t\tlong long int res = 1LL;\n\t\twhile (j){\n\t\t\tif ((j & 1LL)){\n\t\t\t\tres *= i;\n\t\t\t\tif (res >= MOD){\n\t\t\t\t\tres %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj >>= 1;\n\t\t\ti *= i;\n\t\t\tif (i >= MOD){\n\t\t\t\ti %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\nclass Combination{\n\t\npublic:\n\tvector<long long int> k;\n\tvector<long long int> r;\n\tvoid resize(int N){\n\t\tk.resize(N + 2);\n\t\tr.resize(N + 2);\n\t\tk[0] = 1;\n\t\tfor (int i = 1; i < N+2; i++){\n\t\t\tk[i] = k[i - 1];\n\t\t\tk[i] *= i;\n\t\t\tif (k[i] >= MOD)k[i] %= MOD;\n\t\t}\n\t\tlong long int al = k[k.size() - 1];\n\t\tlong long int iv = ppow(k[k.size() - 1],MOD-2);\n\t\tr[k.size() - 1] = iv;\n\t\tfor (int i = (int)(r.size()) - 2; i >= 0; i--){\n\t\t\tr[i] = r[i + 1] * (i + 1);\n\t\t\tif (r[i] >= MOD){\n\t\t\t\tr[i] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int C(int a, int b){\n\t\tif (a < b)return 0;\n\t\tlong long int up = k[a];\n\t\tlong long int dw = r[b] * r[a - b];\n\t\tdw %= MOD;\n\t\tup *= dw;\n\t\tup %= MOD;\n\t\treturn up;\n\t}\n\tlong long int H(int a, int b){\n\t\treturn C(a + b - 1, b);\n\t}\n\tlong long int catalan_number(int n){\n\t\treturn (C(2 * n, n) + MOD - C(2 * n, n - 1)) % MOD;\n\t}\n};\nCombination C;\n\n#define MAX 200002\nint n;\n\n\nstruct treediameter{\n\t//直径は色々いい性質がある\n\t//中心から(２頂点の場合それをくっつける）同じ距離のびた２つの頂点間が直径\n\t//直径は最大長であることにも注意\n\tconst vector<vector<int> >&g;\n\tint r1,r2;\n\tvector<int> d1,d2;  //両端からのdist\n\tint dia;\n\tvoid dfs(int v,int p,int cur,vector<int> &d){\n\t\td[v]=cur;\n\t\tfor(auto e:g[v])if(e!=p)\n\t\t\tdfs(e,v,cur+1,d);\n\t}\n\ttreediameter(const vector<vector<int> > &gg):g(gg),d1(g.size()),d2(g.size()){\n\t\tdfs(0,-1,0,d1);\n\t\tr1=max_element(d1.begin(),d1.end())-d1.begin();\n\t\tdfs(r1,-1,0,d1);\n\t\tr2=max_element(d1.begin(),d1.end())-d1.begin();\n\t\tdfs(r2,-1,0,d2);\n\t\tdia=d1[r2];\n\t}\n\tvector<int> find_centre(){  //直径の中心をさがす 1頂点 or 2頂点　直径は必ずこれらすべてを通る\n\t\tvector<int> ret;\n\t\tfor(int i=0;i<d1.size();i++){\n\t\t\tif(d1[i]+d2[i]==dia&&abs(d1[i]-d2[i])<=1){\n\t\t\t\tret.push_back(i);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n//treediameter(v)\n\nvector<vector<int> > v;\n\nbool flag[MAX];\n\n//0:none with only one type of operation\n//1:positive without substraction\n// 2: none with mix\nint dp[MAX][3];\nbool us[MAX][3];\nint target;\ninline int dfs(int b,int ty,int pr=-1,int d=0){\n\tif(us[b][ty]){\n\t\treturn dp[b][ty];\n\t}\n\tus[b][ty]=true;\n\tint ava=0;\n\tvector<int> can;\n\tfor(int go:v[b]){\n\t\tif(go==pr||flag[go])continue;\n\t\tava++;\n\t\tcan.push_back(go);\n\t}\n\tassert(d<=target);\n\tif(ava==0){\n\t\t//leaf\n\t\tif(ty==1){\n\t\t\tif(d==target){\n\t\t\t\tdp[b][ty]=1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tdp[b][ty]=0;\n\t\t\treturn 0;\n\t\t}\n\t\tif(ty==0){\n\t\t\tif(d==target){\n\t\t\t\tdp[b][ty]=0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdp[b][ty]=1;\n\t\t\treturn 1;\n\t\t}\n\t\tif(ty==2){\n\t\t\tdp[b][ty]=1;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif(ty==1){\n\t\tif(d){\n\t\t\tfor(int go:can){\n\t\t\t\tauto ret=dfs(go,1,b,d+1);\n\t\t\t\tfor(int goo:can){\n\t\t\t\t\tif(go!=goo){\n\t\t\t\t\t\tmulto(ret,add(dfs(goo,0,b,d+1),mul(2,dfs(goo,2,b,d+1))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddto(dp[b][ty],ret);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int go:can){\n\t\t\t\tauto ret=dfs(go,1,b,d+1);\n\t\t\t\tfor(int goo:can){\n\t\t\t\t\tif(go!=goo){\n\t\t\t\t\t\tmulto(ret,add(mul(2,dfs(goo,0,b,d+1)),mul(1,dfs(goo,2,b,d+1))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddto(dp[b][ty],ret);\n\t\t\t}\n\t\t}\n\t}\n\tif(ty==2){\n\t\tdp[b][ty]=1;\n\t\tfor(int goo:can){\n\t\t\tmulto(dp[b][ty],mul(3,dfs(goo,2,b,d+1)));\n\t\t}\n\t}\n\tif(ty==0){\n\t\tdp[b][ty]=1;\n\t\tfor(int goo:can){\n\t\t\tmulto(dp[b][ty],add(dfs(goo,0,b,d+1),mul(2,dfs(goo,2,b,d+1))));\n\t\t}\n\t}\n\treturn dp[b][ty];\n}\n\nint main(){\n\tcin>>n;\n\tv.resize(n);\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tauto dia=treediameter(v);\n\tauto centre=dia.find_centre();\n\tfor(auto el:centre){\n\t\tflag[el]=true;\n\t}\n\tif(centre.size()==1){\n\t\treturn 1;\n\t\tint pos=centre[0];\n\t\ttarget=dia.dia/2;\n\t\ttarget--;\n\t\tlong long int ans=0;\n\t\tfor(int el1:v[pos]){\n\t\t\tfor(int el2:v[pos]){\n\t\t\t\tif(el1!=el2){\n\t\t\t\t\tauto ret=mul(dfs(el1,1,pos,0),dfs(el2,1,pos,0));\n\t\t\t\t\ttarget++;\n\t\t\t\t\tfor(int el3:v[pos]){\n\t\t\t\t\t\tif(el1!=el3&&el2!=el3){\n\t\t\t\t\t\t\tmulto(ret,add(mul(2,dfs(el3,0,pos,1)),mul(1,dfs(el3,2,pos,1))));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttarget--;\n\t\t\t\t\taddto(ans,ret);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmulto(ans,ppow(2,MOD-2));\n\t\tans%=MOD;\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\telse{\n\t\ttarget=dia.dia/2;\n\t\tlong long int ans=0;\n\t\taddto(ans,mul(dfs(centre[0],1),dfs(centre[1],1)));\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<ll,ll>\n#define poly vector<ll>\n#define mem(a) memset((a),0,sizeof(a))\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\n#define SZ(x) ((int)(x.size()))\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\nll rnd(){\n\tull ans=0;\n\tFor(i,0,4)ans=ans<<15^rand();\n\treturn ans%((ull)1<<63);\n}\nconst int N=200005,mod=998244353;\nint n,rt,dep[N],mx[N],fa[N];\nll dp[N][3],jb[3];\nvector<int> v[N];\ninline void add(ll &a,ll b){\n\ta=(a+b)%mod;\n}\nvoid dfs(int p){\n\tdep[p]=dep[fa[p]]+1;\n\tif(dep[p]>dep[rt])rt=p;\n\tfor(auto i:v[p])if(i!=fa[p]){\n\t\tfa[i]=p; dfs(i);\n\t}\n}\nvoid solve(int rt,int fa){\n\tdp[rt][v[rt].size()==1]=1;\n\tfor(auto i:v[rt])if(i!=fa){\n\t\tsolve(i,rt); mx[rt]=max(mx[rt],mx[i]+1);\n\t}\n\tfor(auto i:v[rt])if(i!=fa){\n\t\tif(mx[i]+1!=mx[rt]){\n\t\t\tdp[i][0]+=dp[i][1]; dp[i][1]=0;\n\t\t}\n\t\tmem(jb);\n\t\tRep(j,1,0){\n\t\t\tRep(k,1,0)if(j+k<=1)add(jb[j+k],dp[rt][j]*dp[i][k]);\n\t\t}\n\t\tswap(jb,dp[rt]);\n\t}\n\tdp[rt][0]=(dp[rt][0]*3+dp[rt][1]*2)%mod;\n}\nint main(){\n\t#ifdef Brollan\n\t\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tn=read(); \n\tFor(i,1,n-1){\n\t\tint s=read(),t=read();\n\t\tv[s].pb(t); v[t].pb(s);\n\t}\n\t\n\tdfs(1);\n\tint t=rt; rt=0; fa[t]=0;\n\tdfs(t);\n\tint len=dep[rt];//cerr<<t<<\" \"<<rt<<\" \"<<dep[rt]<<endl;\n\tFor(j,1,len/2)rt=fa[rt];\n\tif(len%2==0){\n\t\tint A=rt,B=fa[rt];\n\t\tsolve(A,B);\n\t\tsolve(B,A);\n\t\tcout<<dp[A][1]*dp[B][1]%mod<<endl;\n\t}else{\n\t\tdp[rt][0]=1;\n\t\tfor(auto i:v[rt]){\n\t\t\tsolve(i,rt); \n\t\t\tif(mx[i]+1<len/2){dp[i][0]+=dp[i][1]; dp[i][1]=0;}\n\t\t\telse dp[i][0]+=mod-dp[i][1];\n\t\t\t//cout<<dp[i][1]<<\" \"<<dp[i][0]<<\" \"<<dp[rt][1]<<endl;\n\t\t\tmem(jb);\n\t\t\tRep(j,2,0)Rep(k,1,0){\n\t\t\t\tif(j+k<=2)add(jb[j+k],dp[rt][j]*dp[i][k]);\n\t\t\t}\n\t\t\tswap(jb,dp[rt]);\n\t\t}\n\t\tcout<<dp[rt][2]<<endl;\n\t}\n}\n/*\nt t+1 (a+1)t+a+b+1\nc(at+b)+d\na(ct+d)+b\nact+bc+d\nact+ad+b\nb/(a-1)<d/(c-1)\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ninline int read()\n{\n    int s=0,f=1; char ch=getchar();\n    while(!isdigit(ch) && ch!='-')ch=getchar();\n    if(ch=='-')ch=getchar(),f=-1;\n    while(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n    return ~f?s:-s;\n}\n\nconst int maxn=1e6+20;\nconst ll mod=998244353;\n\nvector<int>ed[maxn];\nint n;\n\ninline void init()\n{\n    n=read();\n    REP(i,1,n-1)\n    {\n\tint u=read(),v=read();\n\ted[u].push_back(v);\n\ted[v].push_back(u);\n    }\n}\n\nint cir[maxn],len;\n\ninline int bfs(int S)\n{\n    static int dis[maxn],pre[maxn];\n    memset(dis,-1,sizeof(dis));\n    queue<int>q;\n    q.push(S); dis[S]=0; pre[S]=0;\n    while(!q.empty())\n    {\n\tint u=q.front(); q.pop();\n\tfor(int v:ed[u])\n\t    if(dis[v]==-1)\n\t\tq.push(v),dis[v]=dis[u]+1,pre[v]=u;\n    }\n    int T=0,tmx=0;\n    REP(i,1,n)if(dis[i]>tmx)tmx=dis[i],T=i;\n    int x=T;\n    len=0;\n    while(x)cir[++len]=x,x=pre[x];\n    reverse(cir+1,cir+len+1);\n    return T;\n}\n\nint rt;\n\ninline void find_Len()\n{\n    int S=bfs(1);\n    int T=bfs(S);\n    if(len%2==1)rt=cir[len+1>>1];\n    else {\n\tint x=cir[len>>1],y=cir[len+2>>1];\n\ted[x].erase(find(ed[x].begin(),ed[x].end(),y));\n\ted[y].erase(find(ed[y].begin(),ed[y].end(),x));\n\t++n;\n\ted[x].push_back(n); ed[y].push_back(n);\n\ted[n]={x,y};\n\trt=n;\n    }\n}\n\nint ans;\n\nint deep[maxn];\nll dp[maxn][3][3];\n\nvoid dfs(int u,int fa)\n{\n    int son=0;\n    for(int v:ed[u])\n    {\n\tif(v==fa)continue;\n\tdeep[v]=deep[u]+1;\n\tdfs(v,u);\n\tson++;\n    }\n    if(!son)dp[u][deep[u]==len/2][deep[u]==len/2]=1;\n    else {\n\tdp[u][0][0]=1;\n\tfor(int v:ed[u])\n\t{\n\t    if(v==fa)continue;\n\t    ll g[3][3]={0};\n\t    REP(a,0,2)REP(b,0,2)REP(c,0,2)REP(d,0,2)REP(edge,-1,1)\n\t\t(g[min(a+c*(edge==1),2)][min(b+d*(edge==-1),2)]+=dp[u][a][b]*dp[v][c][d])%=mod;\n\t    REP(a,0,2)REP(b,0,2)dp[u][a][b]=g[a][b];\n\t}\n    }\n}\n\ninline void doing()\n{\n    find_Len();\n    dfs(rt,0);\n    printf(\"%lld\\n\",dp[rt][1][1]/2);\n}\n\nint main()\n{\n    init();\n    doing();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<ll,ll>\n#define poly vector<ll>\n#define mem(a) memset((a),0,sizeof(a))\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\n#define SZ(x) ((int)(x.size()))\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\nll rnd(){\n\tull ans=0;\n\tFor(i,0,4)ans=ans<<15^rand();\n\treturn ans%((ull)1<<63);\n}\nconst int N=200005,mod=998244353;\nint n,rt,dep[N],mx[N],fa[N];\nll dp[N][3],jb[3];\nvector<int> v[N];\ninline void add(ll &a,ll b){\n\ta=(a+b)%mod;\n}\nvoid dfs(int p){\n\tdep[p]=dep[fa[p]]+1;\n\tif(dep[p]>dep[rt])rt=p;\n\tfor(auto i:v[p])if(i!=fa[p]){\n\t\tfa[i]=p; dfs(i);\n\t}\n}\nvoid solve(int rt,int fa){\n\tdp[rt][v[rt].size()==1]=1;\n\tfor(auto i:v[rt])if(i!=fa){\n\t\tsolve(i,rt); mx[rt]=max(mx[rt],mx[i]+1);\n\t}\n\tfor(auto i:v[rt])if(i!=fa){//分别表示 几个满的 \n\t\tif(mx[i]+1!=mx[rt]){\n\t\t\tdp[i][0]+=dp[i][1]+dp[i][2]; dp[i][1]=dp[i][2]=0;\n\t\t}\n\t\tmem(jb);\n\t\tRep(j,2,0){\n\t\t\tRep(k,2,0)add(jb[min(2,j+k)],dp[rt][j]*dp[i][k]);\n\t\t}\n\t\tswap(jb,dp[rt]);\n\t}\n\tdp[rt][0]=(dp[rt][0]*3+dp[rt][1]*2+dp[rt][2]*2)%mod;\n}\nint main(){\n\t#ifdef Brollan\n\t\tfreopen(\"std.in\",\"r\",stdin);\n\t#endif\n\tn=read(); \n\tFor(i,1,n-1){\n\t\tint s=read(),t=read();\n\t\tv[s].pb(t); v[t].pb(s);\n\t}\n\t\n\tdfs(1);\n\tint t=rt; rt=0; fa[t]=0;\n\tdfs(t);\n\tint len=dep[rt];//cerr<<t<<\" \"<<rt<<\" \"<<dep[rt]<<endl;\n\tFor(j,1,len/2)rt=fa[rt];\n\tif(len%2==0){\n\t\tint A=rt,B=fa[rt];\n\t\tsolve(A,B);\n\t\tsolve(B,A);\n\t\tcout<<dp[A][1]*dp[B][1]%mod<<endl;\n\t}else{\n\t\tdp[rt][0]=1;\n\t\tfor(auto i:v[rt]){\n\t\t\tsolve(i,rt); \n\t\t\tif(mx[i]+1<len/2){dp[i][0]+=dp[i][1]+dp[i][2]; dp[i][1]=dp[i][2]=0;}\n\t\t\telse dp[i][0]+=mod-dp[i][1]+mod-dp[i][2];\n\t\t\t//cout<<dp[i][1]<<\" \"<<dp[i][0]%mod<<\" \"<<dp[rt][1]<<endl;\n\t\t\tmem(jb);\n\t\t\tRep(j,2,0)Rep(k,1,0){\n\t\t\t\tif(j+k<=2)add(jb[j+k],dp[rt][j]*dp[i][k]);\n\t\t\t}\n\t\t\tswap(jb,dp[rt]);\n\t\t}\n\t\tcout<<dp[rt][2]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int N=200005;\nconst int MOD=998244353;\nint n;\nvector<int>G[N];\nint s,t;\nint Max,p;\nint dep[N];\nint fa[N];\nvoid dfs(int u,int father)\n{\n\tfa[u]=father;\n\tdep[u]=dep[father]+1;\n\tif(dep[u]>Max) Max=dep[u],p=u;\n\tfor(int v:G[u])\n\t{\n\t\tif(v==father) continue;\n\t\tdfs(v,u);\n\t}\n\treturn;\n}\nvector<int>pos;\nint len;\nlong long f[N][3][3];\nlong long g[3][3];\nvoid DP(int u,int father,int d)\n{\n\tif(d==len/2) f[u][1][1]=1;\n\telse f[u][0][0]=1;\n\tfor(int v:G[u])\n\t{\n\t\tif(v==father) continue;\n\t\tDP(v,u,d+1);\n\t\tfor(int i=0;i<=2;i++)\n\t\t\tfor(int j=0;j<=2;j++)\n\t\t\t\tfor(int x=0;x<=2;x++)\n\t\t\t\t\tfor(int y=0;y<=2;y++)\n\t\t\t\t\t\tfor(int k=-1;k<=1;k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint p=min(2,i+x*(k==-1)),q=min(2,j+y*(k==1));\n\t\t\t\t\t\t\tg[p][q]=(g[p][q]+f[u][i][j]*f[v][x][y]%MOD)%MOD;\n\t\t\t\t\t\t}\n\t\tfor(int i=0;i<3;i++)\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\tf[u][i][j]=g[i][j],g[i][j]=0;\n\t}\n\treturn;\n}\nlong long ksm(long long a,long long b)\n{\n\tlong long res=1;\n\twhile(b)\n\t{\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD,b>>=1;\n\t}\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\tdfs(1,0);\n\ts=p;\n\tMax=0;\n\tdfs(s,0);\n\tt=p;\n\tfor(int u=t;u!=s;u=fa[u])\n\t\tpos.push_back(u);\n\tpos.push_back(s);\n\tlen=pos.size()-1;\n\tif(len%2==0)\n\t{\n\t\tint x=pos[len/2];\n\t\tDP(x,0,0);\n\t\tprintf(\"%lld\",f[x][1][1]*ksm(2,MOD-2)%MOD);\n\t}\n\telse\n\t{\n\t\tint x=pos[(len-1)/2],y=pos[(len+1)/2];\n\t\tDP(x,y,0);\n\t\tDP(y,x,0);\n\t\tlong long fx=(f[x][1][0]+f[x][1][1]+f[x][1][2])%MOD,fy=(f[y][0][1]+f[y][1][1]+f[y][2][1])%MOD;\n\t\tprintf(\"%lld\",fx*fy%MOD);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for (int i = (a); i <= int(b); i++)\n#define per(i, a, b) for (int i = (a); i >= int(b); i--)\n#define fi first\n#define se second\nusing namespace std;\n\nconst int maxn = 2e5, mod = 998244353;\nint n, f[maxn + 3], mx[maxn + 3], se[maxn + 3], g[maxn + 3];\nint far[maxn + 3], h[maxn + 3][2];\nvector<int> G[maxn + 3];\n\nvoid dfs(int u, int p = 0) {\n\trep(i, 0, G[u].size() - 1) {\n\t\tint v = G[u][i];\n\t\tif (v == p) continue;\n\t\tdfs(v, u);\n\t\tf[u] = max(f[u], f[v] + 1);\n\t\tif (!mx[u] || f[v] >= f[mx[u]]) {\n\t\t\tse[u] = mx[u], mx[u] = v;\n\t\t} else if (!se[u] || f[v] >= f[se[u]]) {\n\t\t\tse[u] = v;\n\t\t}\n\t}\n}\n\nvoid down(int u, int p = 0) {\n\trep(i, 0, G[u].size() - 1) {\n\t\tint v = G[u][i];\n\t\tif (v == p) continue;\n\t\tif (v == mx[u]) {\n\t\t\tg[v] = max(g[u], f[se[u]] + 1) + 1;\n\t\t} else {\n\t\t\tg[v] = max(g[u], f[mx[u]] + 1) + 1;\n\t\t}\n\t\tdown(v, u);\n\t}\n\tg[u] = max(f[u], g[u]);\n}\n\nvoid work(int u, int p = 0) {\n\trep(i, 0, G[u].size() - 1) {\n\t\tint v = G[u][i];\n\t\tif (v == p) continue;\n\t\twork(v, u);\n\t\tfar[u] = max(far[u], far[v] + 1);\n\t}\n\tif (!far[u]) {\n\t\th[u][0] = h[u][1] = 1; return;\n\t}\n\tint A = 1, B = 0, C = 3;\n\trep(i, 0, G[u].size() - 1) {\n\t\tint v = G[u][i];\n\t\tif (v == p) continue;\n\t\tint D = 0, E = 0;\n\t\tif (far[v] + 1 != far[u]) {\n\t\t\tD = h[v][0] + h[v][1] * 2ll % mod; \n\t\t} else {\n\t\t\tD = h[v][0] + h[v][1], E = h[v][1];\n\t\t}\n\t\tC = 1ll * C * (h[v][0] + h[v][1] * 2ll) % mod;\n\t\tB = (1ll * B * D + 1ll * A * E) % mod;\n\t\tA = 1ll * A * D % mod;\n\t}\n\th[u][1] = B, h[u][0] = (C - B * 2) % mod;\n\th[u][0] < 0 ? h[u][0] += mod : 0;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tif (n == 1) { puts(\"1\"), exit(0); }\n\trep(i, 1, n - 1) {\n\t\tint u, v; scanf(\"%d %d\", &u, &v);\n\t\tG[u].push_back(v), G[v].push_back(u);\n\t}\n\tf[0] = -1;\n\tdfs(1);\n\tdown(1);\n\tint mn = n;\n\trep(i, 1, n) mn = min(mn, g[i]);\n\tint a = 0, b = 0, c = 0;\n\trep(i, 1, n) if (g[i] == mn) {\n\t\tif (++c == 1) a = i;\n\t\telse if (c == 2) b = i;\n\t\telse exit(1);\n\t}\n\tif (c == 1) {\n\t\tint A = 1, B = 0, C = 0;\n\t\trep(i, 0, G[a].size() - 1) {\n\t\t\tint v = G[a][i];\n\t\t\twork(v, a);\n\t\t\tint D = 0, E = 0;\n\t\t\tif (far[v] + 1 != g[a]) {\n\t\t\t\tD = h[v][0] + h[v][1] * 2ll % mod;\n\t\t\t} else {\n\t\t\t\tD = h[v][0], E = h[v][1];\n\t\t\t}\n\t\t\tC = (1ll * C * D + 1ll * B * E) % mod;\n\t\t\tB = (1ll * B * D + 1ll * A * E) % mod;\n\t\t\tA = 1ll * A * D % mod;\n\t\t}\n\t\tprintf(\"%d\\n\", C);\n\t} else {\n\t\twork(a, b);\n\t\twork(b, a);\n\t\tprintf(\"%d\\n\", int(1ll * h[a][1] * h[b][1] % mod));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat mod = 998244353;\nvector<cat> pw3(200010);\n\nvoid DFS_dp(int R, int par, int dep, int D, auto & G, auto & sz, vector<cat> * dp) {\n\tif(dep == D) {\n\t\tdp[0][R] = 2, dp[1][R] = 1;\n\t\treturn;\n\t}\n\tdp[0][R] = 1;\n\tfor(auto s : G[R]) if(s != par) {\n\t\tDFS_dp(s, R, dep+1, D, G, sz, dp);\n\t\tsz[R] += sz[s];\n\t\tdp[1][R] = (dp[1][R] * dp[0][s] + dp[0][R] * dp[1][s]) % mod;\n\t\tdp[0][R] = dp[0][R] * dp[0][s] % mod;\n\t}\n\tdp[0][R] = (dp[0][R] + pw3[sz[R]-1] * 2) % mod;\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N;\n\tcin >> N;\n\tpw3[0] = 1;\n\tfor(int i = 1; i <= N; i++) pw3[i] = pw3[i-1] * 3 % mod;\n\tvector< vector<int> > G(N);\n\tfor(int i = 0; i < N-1; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tG[--u].push_back(--v);\n\t\tG[v].push_back(u);\n\t}\n\tvector<int> dist[2];\n\tdist[0] = vector<int>(N, N);\n\tdist[0][0] = 0;\n\tqueue<int> q;\n\tq.push(0);\n\twhile(!q.empty()) {\n\t\tfor(auto v : G[q.front()]) if(dist[0][v] == N) {\n\t\t\tdist[0][v] = dist[0][q.front()]+1;\n\t\t\tq.push(v);\n\t\t}\n\t\tq.pop();\n\t}\n\tint max_dv = 0;\n\tfor(int i = 0; i < N; i++)\n\t\tif(dist[0][max_dv] < dist[0][i]) max_dv = i;\n\tdist[1] = vector<int>(N, N);\n\tdist[1][max_dv] = 0;\n\tq.push(max_dv);\n\tvector<int> par(N);\n\twhile(!q.empty()) {\n\t\tfor(auto v : G[q.front()]) if(dist[1][v] == N) {\n\t\t\tdist[1][v] = dist[1][q.front()]+1;\n\t\t\tpar[v] = q.front();\n\t\t\tq.push(v);\n\t\t}\n\t\tq.pop();\n\t}\n\tint other_end = 0;\n\tfor(int i = 0; i < N; i++)\n\t\tif(dist[1][other_end] < dist[1][i]) other_end = i;\n\tint D = dist[1][other_end];\n\tint R = other_end;\n\tfor(int i = 0; i < D/2; i++) R = par[R];\n\tif(D%2) {\n\t\tG.push_back({R, par[R]});\n\t\tG[R].erase(find(begin(G[R]), end(G[R]), par[R]));\n\t\tG[par[R]].erase(find(begin(G[par[R]]), end(G[par[R]]), R));\n\t\tG[R].push_back(N);\n\t\tG[par[R]].push_back(N);\n\t\tR = N;\n\t\tN++, D++;\n\t}\n\tD /= 2;\n\tvector<cat> dp[2] = {vector<cat>(N, 0), vector<cat>(N, 0)};\n\tvector<int> sz(N, 1);\n\tDFS_dp(R, R, 0, D, G, sz, dp);\n\tcat ans[3] = {1, 0, 0};\n\tfor(auto s : G[R]) {\n\t\tdp[0][s] -= (pw3[sz[s]]-dp[0][s]);\n\t\tif(dp[0][s] < 0) dp[0][s] += mod;\n\t\tif(dp[0][s] >= mod) dp[0][s] -= mod;\n\t\tif(dp[0][s] < 0) dp[0][s] += mod;\n\t\tif(dp[0][s] >= mod) dp[0][s] -= mod;\n\t\tans[2] = (ans[1] * dp[1][s] + ans[2] * dp[0][s]) % mod;\n\t\tans[1] = (ans[0] * dp[1][s] + ans[1] * dp[0][s]) % mod;\n\t\tans[0] = (ans[0] * dp[0][s]) % mod;\n\t}\n\tcout << ans[2] << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint read(){\n\tint a = 0; char c = getchar(); while(!isdigit(c)) c = getchar();\n\twhile(isdigit(c)){a = a * 10 + c - 48; c = getchar();} return a;\n}\n\nconst int _ = 2e5 + 7 , MOD = 998244353 , iv2 = (MOD + 1) / 2;\nstruct Edge{int end , upEd;}Ed[_ << 1];\nint dp[_][3][3] , N , cntEd , head[_];\nvoid addEd(int a , int b){Ed[++cntEd] = (Edge){b , head[a]}; head[a] = cntEd;}\n\nint mx , id , pre[_];\nvoid dfs1(int x , int p , int l){\n\tpre[x] = p;\n\tif(l > mx){mx = l; id = x;}\n\tfor(int i = head[x] ; i ; i = Ed[i].upEd)\n\t\tif(Ed[i].end != p) dfs1(Ed[i].end , x , l + 1);\n}\n\nint mxdep[_];\nvoid dfs2(int x , int p){\n\tfor(int i = head[x] ; i ; i = Ed[i].upEd)\n\t\tif(Ed[i].end != p){dfs2(Ed[i].end , x); mxdep[x] = max(mxdep[x] , mxdep[Ed[i].end] + 1);}\n}\n\nvoid DP(int x , int p){\n\tdp[x][0][0] = 1; bool flg = 0;\n\tfor(int i = head[x] ; i ; i = Ed[i].upEd)\n\t\tif(Ed[i].end != p){\n\t\t\tflg = 1; DP(Ed[i].end , x); static int tmp[3][3]; memset(tmp , 0 , sizeof(tmp));\n\t\t\tfor(int j = 0 ; j < 3 ; ++j)\n\t\t\t\tfor(int k = 0 ; k < 3 ; ++k)\n\t\t\t\t\tfor(int p = 0 ; p < 3 ; ++p)\n\t\t\t\t\t\tfor(int q = 0 ; q < 3 ; ++q){\n\t\t\t\t\t\t\tint coef = 3;\n\t\t\t\t\t\t\tif(mxdep[Ed[i].end] + 1 == mxdep[x]){\n\t\t\t\t\t\t\t\ttmp[min(j + p , 2)][k] = (tmp[min(j + p , 2)][k] + 1ll * dp[x][j][k] * dp[Ed[i].end][p][q]) % MOD;\n\t\t\t\t\t\t\t\ttmp[j][min(k + q , 2)] = (tmp[j][min(k + q , 2)] + 1ll * dp[x][j][k] * dp[Ed[i].end][p][q]) % MOD;\n\t\t\t\t\t\t\t\tcoef -= 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttmp[j][k] = (tmp[j][k] + 1ll * coef * dp[x][j][k] * dp[Ed[i].end][p][q]) % MOD;\n\t\t\t\t\t\t}\n\t\t\tmemcpy(dp[x] , tmp , sizeof(tmp));\n\t\t}\n\tif(!flg){dp[x][0][0] = 0; dp[x][1][1] = 1;}\n}\n\nint main(){\n\tN = read(); for(int i = 1 ; i < N ; ++i){int x = read() , y = read(); addEd(x , y); addEd(y , x);}\n\tdfs1(1 , 0 , 0); mx = 0; int t = id; dfs1(t , 0 , 0);\n\tfor(int i = 0 ; i < mx / 2 ; ++i) id = pre[id];\n\tif(mx & 1){\n\t\tdfs2(id , pre[id]); DP(id , pre[id]); dfs2(pre[id] , id); DP(pre[id] , id);\n\t\tprintf(\"%lld\\n\" , (1ll * dp[id][1][0] * dp[pre[id]][0][1] + 1ll * dp[id][0][1] * dp[pre[id]][1][0]) % MOD * iv2 % MOD);\n\t}else{dfs2(id , 0); DP(id , 0); printf(\"%lld\\n\" , 1ll * iv2 * dp[id][1][1] % MOD);}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ for(auto it : P) { s << \"<\" << it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ for(auto it : P) { s << \"<\" << it.first << \"->\" << it.second << \"> \"; } return s << endl; }\n\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nconst int MOD = 998244353;\nusing mint = Fp<MOD>;\n\nusing Graph = vector<vector<int>>;\nstruct Diameter {\n    vector<int> prev;\n    pair<int,int> DiameterDFS(const Graph &G, int v, int p) {\n        pair<int,int> res(v, 0);\n        for (int i = 0; i < (int)G[v].size(); ++i) {\n            if (G[v][i] == p) continue;\n            pair<int,int> tmp = DiameterDFS(G, G[v][i], v);\n            tmp.second++;\n            if (tmp.second > res.second) res = tmp, prev[G[v][i]] = v;\n        }\n        return res;\n    }\n\n    vector<int> solve(const vector<vector<int> > &G) {\n        prev.assign((int)G.size(), -1);\n        pair<int,int> leaf = DiameterDFS(G, 0, -1);\n        prev.assign((int)G.size(), -1);\n        pair<int,int> t = DiameterDFS(G, leaf.first, -1);\n        vector<int> res;\n        int cur = t.first;\n        while (cur != -1) res.push_back(cur), cur = prev[cur];\n        return res;\n    }\n};\n\nint N;\nGraph G;\n\nvector<int> md;\nvector<mint> ok, ng;\nvoid rec(int v, int p) {\n    vector<int> chs;\n    for (auto ch : G[v]) {\n        if (ch == p) continue;\n        chs.push_back(ch);\n        rec(ch, v);\n        chmax(md[v], md[ch]+1);\n    }\n    if (chs.empty()) {\n        ok[v] = 1; ng[v] = 2;\n        return;\n    }\n    \n    mint all = 3, notall = 1, ngall = 1;\n    for (auto ch : chs) {\n        all *= ok[ch] + ng[ch];\n        if (md[ch] != md[v]-1) notall *= ok[ch] + ng[ch];\n        else ngall *= ng[ch];\n    }\n    ok[v] = 0;\n    for (auto ch : chs) {\n        if (md[ch] != md[v]-1) continue;\n        mint tmp = ngall * ok[ch] / ng[ch];\n        ok[v] += tmp;\n    }\n    ok[v] *= notall;\n    ng[v] = all - ok[v];\n\n    cout << v+1 << \": \" << ok[v] << \", \" << ng[v] << endl;\n}\n\nmint solve() {\n    Diameter diam;\n    auto di = diam.solve(G);\n    int max_depth = (int)di.size()/2 - 1;\n\n    md.assign(N, 0); ok.assign(N, 0); ng.assign(N, 0);\n    vector<int> v_di, v_ndi;\n    if (di.size() % 2 == 1) {\n        int center = di[di.size() / 2];\n        for (auto v : G[center]) {\n            rec(v, center);\n            if (md[v] == max_depth) v_di.push_back(v);\n            else v_ndi.push_back(v);\n        }\n    }\n    else {\n        int u = di[(int)di.size()/2-1], v = di[(int)di.size()/2];\n        rec(u, v), rec(v, u);\n        v_di.push_back(u), v_di.push_back(v);\n    }\n    \n    mint notres = 1;\n    for (auto v : v_ndi) notres *= ok[v] + ng[v];\n    mint ngall = 1;\n    for (auto v : v_di) ngall *= (ng[v] - ok[v]);\n    mint okfact1 = 0, okfact2 = 0;\n    for (auto v : v_di) {\n        mint fac = ok[v] / (ng[v] - ok[v]);\n        okfact1 += fac;\n        okfact2 += fac * fac;\n    }\n    mint fact = (okfact1 * okfact1 - okfact2) / 2;\n    mint deepres = ngall * fact;\n\n    /*\n    COUT(v_ndi);\n    COUT(v_di);\n    COUT(notres);\n    COUT(ngall);\n    COUT(okfact1);\n    COUT(okfact2);\n    COUT(fact);\n    COUT(deepres);\n    */\n    \n    return notres * deepres;\n}\n\nint main() {\n    while (cin >> N) {\n        G.assign(N, vector<int>());\n        for (int i = 0; i < N-1; ++i) {\n            int a, b; cin >> a >> b; --a, --b;\n            G[a].push_back(b);\n            G[b].push_back(a);\n        }\n        cout << solve() << endl;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define R register\n#define mp make_pair\n#define ll long long\n#define pii pair<int, int>\nusing namespace std;\nconst int N = 210000, mod = 998244353;\n\nint n, dis[N], a, b, p[N];\nll f[N], g[N], pw[N];\nvector<int> to[N];\n\ntemplate <class T>\ninline void read(T &x) {\n\tx = 0;\n\tchar ch = getchar(), w = 0;\n\twhile (!isdigit(ch)) w = (ch == '-'), ch = getchar();\n\twhile (isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();\n\tx = w ? -x : x;\n\treturn;\n}\n\ninline void addEdg(int x, int y) {\n\tto[x].push_back(y), to[y].push_back(x);\n\treturn;\n}\n\nvoid dfs1(int now, int fa) {\n\tdis[now] = dis[fa] + 1;\n\tfor (auto &v : to[now]) {\n\t\tif (v == fa) continue;\n\t\tdfs1(v, now);\n\t}\n\treturn;\n}\n\nint dfs2(int now, int fa, int maxD) {\n\tif (dis[now] == maxD) return p[now] = 1;\n\tint ret = 0;\n\tfor (auto &v : to[now]) {\n\t\tif (v == fa) continue;\n\t\tret |= dfs2(v, now, maxD);\n\t}\n\tif (ret) {\n\t\tif (dis[now] == (maxD + 1) >> 1)\n\t\t\ta = now;\n\t\telse if (dis[now] == (maxD >> 1) + 1)\n\t\t\tb = now;\n\t}\n\treturn ret;\n}\n\nvoid dfs3(int now, int fa) {\n\tpw[now] = 1;\n\tf[now] = !p[now], g[now] = p[now];\n\tfor (auto &v : to[now]) {\n\t\tif (v == fa) continue;\n\t\tdfs3(v, now);\n\t\tg[now] = ((2 * pw[v] + f[v]) * g[now] + f[now] * g[v]) % mod;\n\t\tf[now] = (2 * pw[v] + f[v]) * f[now] % mod;\n\t\tpw[now] = pw[now] * pw[v] * 3 % mod;\n\t}\n//\tcout << \"qwq \" << now << ' ' << pw[now] << ' ' << f[now] << ' ' << g[now] << endl;\n\treturn;\n}\n\nint main() {\n\tint x, y;\n\tread(n);\n\tfor (R int i = 1; i < n; ++i)\n\t\tread(x), read(y), addEdg(x, y);\n\tdfs1(1, 0);\n\tint rt = 1, maxD = 1;\n\tfor (R int i = 2; i <= n; ++i)\n\t\tif (dis[i] > maxD) maxD = dis[i], rt = i;\n\tdfs1(rt, 0), maxD = 1;\n\tfor (R int i = 1; i <= n; ++i)\n\t\tmaxD = max(maxD, dis[i]);\n\tdfs2(rt, 0, maxD), p[rt] = 1;\n\tif (b) {\n\t\tdfs3(b, a), dfs3(a, b);\n\t\tprintf(\"%lld\\n\", g[a] * g[b] % mod);\n\t}\n\telse {\n\t\tll ans = 0;\n\t\tf[a] = 1;\n\t\tfor (auto &v : to[a]) {\n\t\t\tdfs3(v, a);\n\t\t\tans = (ans * (pw[v] + 2 * f[v]) + g[a] * g[v]) % mod;\n\t\t\tg[a] = (g[a] * (pw[v] + 2 * f[v]) + f[a] * g[v]) % mod;\n\t\t\tf[a] = f[a] * (pw[v] + 2 * f[v]) % mod;\n\t\t\t//cout << \"qwq \" << v << ' ' << f[v] << ' ' << g[v] << endl;\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ for(auto it : P) { s << \"<\" << it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ for(auto it : P) { s << \"<\" << it.first << \"->\" << it.second << \"> \"; } return s << endl; }\n\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nconst int MOD = 998244353;\nusing mint = Fp<MOD>;\n\nusing Graph = vector<vector<int>>;\nstruct Diameter {\n    vector<int> prev;\n    pair<int,int> DiameterDFS(const Graph &G, int v, int p) {\n        pair<int,int> res(v, 0);\n        for (int i = 0; i < (int)G[v].size(); ++i) {\n            if (G[v][i] == p) continue;\n            pair<int,int> tmp = DiameterDFS(G, G[v][i], v);\n            tmp.second++;\n            if (tmp.second > res.second) res = tmp, prev[G[v][i]] = v;\n        }\n        return res;\n    }\n\n    vector<int> solve(const vector<vector<int> > &G) {\n        prev.assign((int)G.size(), -1);\n        pair<int,int> leaf = DiameterDFS(G, 0, -1);\n        prev.assign((int)G.size(), -1);\n        pair<int,int> t = DiameterDFS(G, leaf.first, -1);\n        vector<int> res;\n        int cur = t.first;\n        while (cur != -1) res.push_back(cur), cur = prev[cur];\n        return res;\n    }\n};\n\nint N;\nGraph G;\n\nvector<int> md;\nvector<mint> ok, ng;\nvoid rec(int v, int p) {\n    vector<int> chs;\n    for (auto ch : G[v]) {\n        if (ch == p) continue;\n        chs.push_back(ch);\n        rec(ch, v);\n        chmax(md[v], md[ch]+1);\n    }\n    if (chs.empty()) {\n        ok[v] = 1; ng[v] = 2;\n        return;\n    }\n    \n    mint all = 3, notall = 1, ngall = 1;\n    for (auto ch : chs) {\n        all *= ok[ch] + ng[ch];\n        if (md[ch] != md[v]-1) notall *= ok[ch] + ng[ch];\n        else ngall *= ng[ch];\n    }\n    ok[v] = 0;\n    for (auto ch : chs) {\n        if (md[ch] != md[v]-1) continue;\n        mint tmp = ngall * ok[ch] / ng[ch];\n        ok[v] += tmp;\n    }\n    ok[v] *= notall;\n    ng[v] = all - ok[v];\n\n    //cout << v+1 << \": \" << ok[v] << \", \" << ng[v] << endl;\n}\n\nmint solve() {\n    Diameter diam;\n    auto di = diam.solve(G);\n    int max_depth = (int)di.size()/2 - 1;\n\n    md.assign(N, 0); ok.assign(N, 0); ng.assign(N, 0);\n    vector<int> v_di, v_ndi;\n    if (di.size() % 2 == 1) {\n        int center = di[di.size() / 2];\n        for (auto v : G[center]) {\n            rec(v, center);\n            if (md[v] == max_depth) v_di.push_back(v);\n            else v_ndi.push_back(v);\n        }\n    }\n    else {\n        int u = di[(int)di.size()/2-1], v = di[(int)di.size()/2];\n        rec(u, v), rec(v, u);\n        v_di.push_back(u), v_di.push_back(v);\n    }\n    \n    mint notres = 1;\n    for (auto v : v_ndi) notres *= ok[v] + ng[v];\n    mint ngall = 1;\n    for (auto v : v_di) ngall *= (ng[v] - ok[v]);\n    mint okfact1 = 0, okfact2 = 0;\n    for (auto v : v_di) {\n        mint fac = ok[v] / (ng[v] - ok[v]);\n        okfact1 += fac;\n        okfact2 += fac * fac;\n    }\n    mint fact = (okfact1 * okfact1 - okfact2) / 2;\n    mint deepres = ngall * fact;\n\n    /*\n    COUT(v_ndi);\n    COUT(v_di);\n    COUT(notres);\n    COUT(ngall);\n    COUT(okfact1);\n    COUT(okfact2);\n    COUT(fact);\n    COUT(deepres);\n    */\n    \n    return notres * deepres;\n}\n\nint main() {\n    while (cin >> N) {\n        G.assign(N, vector<int>());\n        for (int i = 0; i < N-1; ++i) {\n            int a, b; cin >> a >> b; --a, --b;\n            G[a].push_back(b);\n            G[b].push_back(a);\n        }\n        cout << solve() << endl;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i,a,b) for (int i=a;i<=b;i++)\n#define R(i,a,b) for (int i=a;i<b;i++)\n#define D(i,a,b) for (int i=a;i>=b;i--)\n#define go(i,x) for (int i=head[x];i;i=Next[i])\n#define pb push_back\n#define si size()\n#define fi first\n#define se second\n#define pa pair < ll,ll >\n#define ll long long\n#define mp make_pair\n#define be begin()\n#define en end()\n#define put putchar('\\n')\n#define gc getchar\n#define pc putchar\n#define N 6000055\n#define mo 998244353\n#define inf 1000000007\n//#define int ll\n#define ret return puts(\"-1\"),0\nusing namespace std;\ninline ll read(){\n\tll su=0,f=1;char c=gc();\n\tfor (;c<'0'||c>'9';c=gc()) if (c=='-') f=-1;\n\tfor (;c>='0'&&c<='9';c=gc()) su=su*10+c-'0';\n\treturn su*f;\n}\ninline void wr(ll x){\n\tif (x<0) pc('-'),wr(-x);\n\telse{if (x>=10) wr(x/10);pc(x%10+'0');}\n}\ninline void wri(ll x){wr(x);pc(' ');}\ninline void wrn(ll x){wr(x);put;}\ninline void wrn(ll x,ll y){wri(x);wrn(y);}\ninline void wrn(ll x,ll y,ll z){wri(x);wrn(y,z);}\nint ans,n,m,f[N][2],fa[N],dis[N],lo,rt,mx;\ninline void ad(int &x,int k){x+=k;x-=(x>=mo)?mo:0;}\nint Next[N*2],head[N],to[N*2],nedge,g[N][4];\n#define V to[i]\nvoid add(int a,int b){Next[++nedge]=head[a];head[a]=nedge;to[nedge]=b;}\nvoid add_ne(int a,int b){add(a,b);add(b,a);}\nvoid dfs(int x){\n\tmx=(dis[x]>dis[mx])?x:mx;\n\tgo(i,x){\n\t\tif (V==fa[x]) continue;\n\t\tfa[V]=x;dis[V]=dis[x]+1;dfs(V);\n\t}\n}\nint ksm(ll x,int k){\n\tint su=1;\n\tfor (;k;k>>=1,x=x*x%mo) if (k&1) su=su*x%mo;\n\treturn su;\n}\nvoid solve(int x){\n\tint pd=0;\n\tf[x][0]=1;\n\tg[x][0]=1;\n\tgo(i,x){\n\t\tif (V==fa[x]) continue;\n\t\tsolve(V);pd++;\n\t\tg[x][3]=1ll*g[x][3]*g[V][0]%mo;\n\t\tad(g[x][3],1ll*g[x][1]*g[V][2]%mo);\n\t\tad(g[x][3],1ll*g[x][2]*g[V][1]%mo);\n\t\tg[x][1]=1ll*g[x][1]*g[V][0]%mo;\n\t\tg[x][2]=1ll*g[x][2]*g[V][0]%mo;\n\t\tad(g[x][1],1ll*g[x][0]*g[V][1]%mo);\n\t\tad(g[x][2],1ll*g[x][0]*g[V][2]%mo);\n\t\tg[x][0]=1ll*g[x][0]*g[V][0]%mo;\n\t\t\n\t\tf[x][1]=1ll*f[x][1]*f[V][0]%mo;\n\t\tad(f[x][1],1ll*f[x][0]*f[V][1]%mo);\n\t\tf[x][0]=1ll*f[x][0]*f[V][0]%mo;\n\t}\n\tif (pd){\n\t\tf[x][0]=1ll*f[x][0]*3%mo;\n\t\tad(f[x][0],f[x][1]*2%mo);\n\t\tg[x][0]=1ll*g[x][0]*3%mo;\n\t\tad(g[x][0],((g[x][1]+g[x][2])%mo*2%mo+g[x][3])%mo);\n\t\tad(g[x][1],g[x][3]);ad(g[x][2],g[x][3]);\n\t}\n\telse{\n\t\tif (dis[x]==lo/2) f[x][1]=1,f[x][0]=2,g[x][1]=g[x][0]=g[x][2]=1;\n\t\telse f[x][0]=3,g[x][0]=3;\n\t}\n}\nsigned main(){\n\tn=read();\n\tR(i,1,n) add_ne(read(),read());\n\tdfs(1);\n\trt=mx;mx=0;dis[rt]=0;fa[rt]=0;\n\tdfs(rt);\n\tlo=dis[mx];\n\tF(i,1,lo/2) mx=fa[mx];\n\tif (lo&1){\n\t\tint x=mx,y=fa[mx];\n\t\tfa[y]=x;dis[x]=dis[y]=0;dfs(x);dfs(y);\n\t\tsolve(x);solve(y);\n\t\twrn(1ll*f[x][1]*f[y][1]%mo);\n\t\t//wrn(ksm(3,n-lo-1));\n\t}\n\telse{\n\t\tint x=mx,nu=0;\n\t\tfa[x]=0;dis[x]=0;dfs(x);\n\t\tF(i,1,n) if (dis[i]==lo/2) nu++;\n\t\t//ans=(1ll*nu*(nu-1)/2)%mo*ksm(3,n-lo-1)%mo;\n\t\tsolve(x);\n\t\tf[x][0]=1;f[x][1]=0;\n\t\tgo(i,x){\n\t\t\tans=1ll*ans*g[V][0]%mo;\n\t\t\tad(ans,1ll*f[x][1]*f[V][1]%mo);\n\t\t\tf[x][1]=1ll*f[x][1]*g[V][0]%mo;\n\t\t\tad(f[x][1],1ll*f[x][0]*f[V][1]%mo);\n\t\t\tf[x][0]=1ll*f[x][0]*g[V][0]%mo;\t\t\t\n\t\t}\n\t\twrn(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=998244353;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=401000;\nll dp[N][5][5],tmp[5][5],tmp2[5][5];\nint pt[N],md,mv,n,u,v,lef[N];\nPII cen;\nVI e[N];\n\nvoid dfs(int u,int f,int dep) {\n\tpt[dep]=u;\n\tif (dep>md) {\n\t\tmd=dep; mv=u; cen=mp(pt[dep/2],pt[(dep+1)/2]);\n\t}\n\tfor (auto v:e[u]) {\n\t\tif (v==f) continue;\n\t\tdfs(v,u,dep+1);\n\t}\n}\nvoid gao(int u,int f,int d) {\n\tif (d==md/2) {\n\t\t//printf(\"gg %d %d\\n\",u,md);\n\t\tlef[u]=1;\n\t\treturn;\n\t}\n\tdp[u][0][0]=1;\n\tfor (auto v:e[u]) {\n\t\tif (v==f) continue;\n\t\tgao(v,u,d+1);\n\t\trep(L,0,3) rep(R,0,3) tmp[L][R]=tmp2[L][R]=0;\n\t\tif (lef[v]) {\n\t\t\ttmp[1][0]=1;\n\t\t\ttmp[0][1]=1;\n\t\t\ttmp[0][0]=1;\n\t\t} else {\n\t\t\trep(L,0,3) rep(R,0,3) {\n\t\t\t\ttmp[L][0]=(tmp[L][0]+dp[v][L][R])%mod;\n\t\t\t\ttmp[0][R]=(tmp[0][R]+dp[v][L][R])%mod;\n\t\t\t\ttmp[0][0]=(tmp[0][0]+dp[v][L][R])%mod;\n\t\t\t}\n\t\t}\n\t\trep(L,0,3) rep(R,0,3) rep(fL,0,3) rep(fR,0,3)\n\t\t\ttmp2[min(L+fL,2)][min(R+fR,2)]=(tmp2[min(L+fL,2)][min(R+fR,2)]+dp[u][L][R]*tmp[fL][fR])%mod;\n\t\trep(L,0,3) rep(R,0,3) dp[u][L][R]=tmp2[L][R];\n\t}\n\t//rep(i,0,4) printf(\"gg %d %d %lld\\n\",u,i,dp[u][i]);\n}\n\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,1,n) {\n\t\tscanf(\"%d%d\",&u,&v);\n\t\te[u].pb(v);\n\t\te[v].pb(u);\n\t}\n\tmd=-1;\n\tdfs(1,0,0);\n\tmd=-1;\n\tdfs(mv,0,0);\n\tif (cen.fi==cen.se) {\n\t\tgao(cen.fi,0,0);\n\t\tprintf(\"%lld\\n\",dp[cen.fi][1][1]*powmod(2,mod-2)%mod);\n\t} else {\n\t\t//puts(\"dup center\");\n\t\tgao(cen.fi,cen.se,0);\n\t\tgao(cen.se,cen.fi,0);\n\t\trep(L,0,3) rep(R,0,3) tmp[L][R]=tmp2[L][R]=0;\n\t\trep(L,0,3) rep(R,0,3) {\n\t\t\ttmp[L][0]=(tmp[L][0]+dp[cen.fi][L][R])%mod;\n\t\t\ttmp2[0][R]=(tmp2[0][R]+dp[cen.se][L][R])%mod;\n\t\t}\n\t\tprintf(\"%lld\\n\",tmp[1][0]*tmp2[0][1]%mod);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define MOD 998244353\ntemplate<typename ty1,typename ty2>\ninline int add(ty1 x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x += y; return x < MOD ? x : x - MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline void addto(ty1 &x, ty2 y) {\n\t\t  if(y>=MOD)y%=MOD;\n\t\t  if(x>=MOD)x%=MOD;\n\t      x += y; if (x >= MOD) x -= MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int sub(ty1 x, ty2 y) {\n\t\tif(y>=MOD)y%=MOD;\n\t\t if(x>=MOD)x%=MOD;\n        x -= y; return x < 0 ? x + MOD : x;\n}\ntemplate<typename ty1,typename ty2>\ninline void subto(ty1 &x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x -= y; if (x < 0) x += MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int mul(ty1 x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        return 1ll * x * y % MOD;\n}\ntemplate<typename ty1,typename ty2>\nvoid multo(ty1 &x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        x=1ll * x * y % MOD;\n}\n  \nlong long int gcd(long long int a, long long int b){\n\tif (a > b){\n\t\tswap(a, b);\n\t}\n\twhile (a){\n\t\tswap(a, b);\n\t\ta %= b;\n\t}\n\treturn b;\n}\nlong long int lcm(long long int a, long long int b){\n\treturn a / gcd(a, b)*b;\n}\nlong long int ppow(long long int i, long long int j){\n\t\tlong long int res = 1LL;\n\t\twhile (j){\n\t\t\tif ((j & 1LL)){\n\t\t\t\tres *= i;\n\t\t\t\tif (res >= MOD){\n\t\t\t\t\tres %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj >>= 1;\n\t\t\ti *= i;\n\t\t\tif (i >= MOD){\n\t\t\t\ti %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\nclass Combination{\n\t\npublic:\n\tvector<long long int> k;\n\tvector<long long int> r;\n\tvoid resize(int N){\n\t\tk.resize(N + 2);\n\t\tr.resize(N + 2);\n\t\tk[0] = 1;\n\t\tfor (int i = 1; i < N+2; i++){\n\t\t\tk[i] = k[i - 1];\n\t\t\tk[i] *= i;\n\t\t\tif (k[i] >= MOD)k[i] %= MOD;\n\t\t}\n\t\tlong long int al = k[k.size() - 1];\n\t\tlong long int iv = ppow(k[k.size() - 1],MOD-2);\n\t\tr[k.size() - 1] = iv;\n\t\tfor (int i = (int)(r.size()) - 2; i >= 0; i--){\n\t\t\tr[i] = r[i + 1] * (i + 1);\n\t\t\tif (r[i] >= MOD){\n\t\t\t\tr[i] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int C(int a, int b){\n\t\tif (a < b)return 0;\n\t\tlong long int up = k[a];\n\t\tlong long int dw = r[b] * r[a - b];\n\t\tdw %= MOD;\n\t\tup *= dw;\n\t\tup %= MOD;\n\t\treturn up;\n\t}\n\tlong long int H(int a, int b){\n\t\treturn C(a + b - 1, b);\n\t}\n\tlong long int catalan_number(int n){\n\t\treturn (C(2 * n, n) + MOD - C(2 * n, n - 1)) % MOD;\n\t}\n};\nCombination C;\n\n#define MAX 200002\nint n;\n\n\nstruct treediameter{\n\t//直径は色々いい性質がある\n\t//中心から(２頂点の場合それをくっつける）同じ距離のびた２つの頂点間が直径\n\t//直径は最大長であることにも注意\n\tconst vector<vector<int> >&g;\n\tint r1,r2;\n\tvector<int> d1,d2;  //両端からのdist\n\tint dia;\n\tvoid dfs(int v,int p,int cur,vector<int> &d){\n\t\td[v]=cur;\n\t\tfor(auto e:g[v])if(e!=p)\n\t\t\tdfs(e,v,cur+1,d);\n\t}\n\ttreediameter(const vector<vector<int> > &gg):g(gg),d1(g.size()),d2(g.size()){\n\t\tdfs(0,-1,0,d1);\n\t\tr1=max_element(d1.begin(),d1.end())-d1.begin();\n\t\tdfs(r1,-1,0,d1);\n\t\tr2=max_element(d1.begin(),d1.end())-d1.begin();\n\t\tdfs(r2,-1,0,d2);\n\t\tdia=d1[r2];\n\t}\n\tvector<int> find_centre(){  //直径の中心をさがす 1頂点 or 2頂点　直径は必ずこれらすべてを通る\n\t\tvector<int> ret;\n\t\tfor(int i=0;i<d1.size();i++){\n\t\t\tif(d1[i]+d2[i]==dia&&abs(d1[i]-d2[i])<=1){\n\t\t\t\tret.push_back(i);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n//treediameter(v)\n\nvector<vector<int> > v;\n\nbool flag[MAX];\n\n//0:none with only one type of operation\n//1:positive without substraction\n// 2: none with mix\nint dp[MAX][3];\nbool us[MAX][3];\nint target;\ninline int dfs(int b,int ty,int pr=-1,int d=0){\n\tif(us[b][ty]){\n\t\treturn dp[b][ty];\n\t}\n\tus[b][ty]=true;\n\tint ava=0;\n\tvector<int> can;\n\tfor(int go:v[b]){\n\t\tif(go==pr||flag[go])continue;\n\t\tava++;\n\t\tcan.push_back(go);\n\t}\n\tif(ava==0){\n\t\t//leaf\n\t\tif(ty==1){\n\t\t\tif(d==target){\n\t\t\t\tdp[b][ty]=1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tdp[b][ty]=0;\n\t\t\treturn 0;\n\t\t}\n\t\tif(ty==0){\n\t\t\tif(d==target){\n\t\t\t\tdp[b][ty]=0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdp[b][ty]=1;\n\t\t\treturn 1;\n\t\t}\n\t\tif(ty==2){\n\t\t\tdp[b][ty]=1;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif(ty==1){\n\t\tif(d){\n\t\t\tfor(int go:can){\n\t\t\t\tauto ret=dfs(go,1,b,d+1);\n\t\t\t\tfor(int goo:can){\n\t\t\t\t\tif(go!=goo){\n\t\t\t\t\t\tmulto(ret,add(dfs(goo,0,b,d+1),mul(2,dfs(goo,2,b,d+1))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddto(dp[b][ty],ret);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int go:can){\n\t\t\t\tauto ret=dfs(go,1,b,d+1);\n\t\t\t\tfor(int goo:can){\n\t\t\t\t\tif(go!=goo){\n\t\t\t\t\t\tmulto(ret,add(mul(2,dfs(goo,0,b,d+1)),mul(1,dfs(goo,2,b,d+1))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddto(dp[b][ty],ret);\n\t\t\t}\n\t\t}\n\t}\n\tif(ty==2){\n\t\tdp[b][ty]=1;\n\t\tfor(int goo:can){\n\t\t\tmulto(dp[b][ty],mul(3,dfs(goo,2,b,d+1)));\n\t\t}\n\t}\n\tif(ty==0){\n\t\tdp[b][ty]=1;\n\t\tfor(int goo:can){\n\t\t\tmulto(dp[b][ty],add(dfs(goo,0,b,d+1),mul(2,dfs(goo,2,b,d+1))));\n\t\t}\n\t}\n\treturn dp[b][ty];\n}\n\nint main(){\n\tcin>>n;\n\tv.resize(n);\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tauto dia=treediameter(v);\n\tauto centre=dia.find_centre();\n\tfor(auto el:centre){\n\t\tflag[el]=true;\n\t}\n\tif(centre.size()==1){\n\t\tint pos=centre[0];\n\t\ttarget=dia.dia/2;\n\t\ttarget--;\n\t\tlong long int ans=0;\n\t\tfor(int el1:v[pos]){\n\t\t\tfor(int el2:v[pos]){\n\t\t\t\tif(el1!=el2){\n\t\t\t\t\tauto ret=mul(dfs(el1,1,pos,0),dfs(el2,1,pos,0));\n\t\t\t\t\ttarget++;\n\t\t\t\t\tfor(int el3:v[pos]){\n\t\t\t\t\t\tif(el1!=el3&&el2!=el3){\n\t\t\t\t\t\t\tmulto(ret,add(mul(2,dfs(el3,0,pos,1)),mul(1,dfs(el3,2,pos,1))));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttarget--;\n\t\t\t\t\taddto(ans,ret);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmulto(ans,ppow(2,MOD-2));\n\t\tans%=MOD;\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\telse{\n\t\ttarget=dia.dia/2;\n\t\tlong long int ans=0;\n\t\taddto(ans,mul(dfs(centre[0],1),dfs(centre[1],1)));\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=2e5+5,mod=998244353;\nint n,m,dis[N],fa[N],a[N],si[N],rt1,rt2,head[N],nex[N<<1],to[N<<1],tot;\nvoid add(int u,int v){to[++tot]=v;nex[tot]=head[u];head[u]=tot;}\nvoid dfs(int u,int p)\n{\n    dis[u]=dis[p]+1;\n    if(dis[u]>dis[rt1]) rt1=u;\n    fa[u]=p;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p)continue;\n        dfs(v,u);\n    }\n}\nll dp[N][3][3],p[3][3];\nvoid dfs(int u,int fa,int d)\n{\n    d==m/2?dp[u][1][1]=1:dp[u][0][0]=1;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==fa)continue;\n        dfs(v,u,d+1);\n        memset(p,0,sizeof(p));\n        for(int i=0;i<3;i++)\n            for(int j=0;j<3;j++)\n            for(int k=0;k<3;k++)\n                for(int h=0;h<3;h++)\n        {\n            p[i][j]=(p[i][j]+dp[u][i][j]*dp[v][k][h])%mod;\n            p[min(i+k,2)][j]=(p[min(i+k,2)][j]+dp[u][i][j]*dp[v][k][h])%mod;\n            p[i][min(j+h,2)]=(p[i][min(j+h,2)]+dp[u][i][j]*dp[v][k][h])%mod;\n        }\n        for(int i=0;i<3;i++)\n            for(int j=0;j<3;j++)\n            dp[u][i][j]=p[i][j];\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        int u,v;scanf(\"%d%d\",&u,&v);add(u,v);add(v,u);\n    }\n    dfs(1,0);\n    rt2=rt1;\n    dfs(rt1,0);\n    while(fa[rt1]) a[++m]=rt1,rt1=fa[rt1];\n    a[++m]=rt1;\n    rt1=rt2=0;\n    if(m%2==0) rt1=a[m/2],rt2=a[m/2+1];\n    else rt1=a[m/2+1];\n    m--;\n    if(rt1&&rt2)\n    {\n        dfs(rt1,rt2,0);dfs(rt2,rt1,0);\n        ll ans=((dp[rt1][1][0]+dp[rt1][1][1]+dp[rt1][1][2])*dp[rt2][1][0]+dp[rt1][1][0]*(dp[rt2][1][0]+dp[rt2][1][1]+dp[rt2][1][2]))%mod;\n        printf(\"%lld\\n\",ans*(mod-mod/2)%mod);\n    }\n    else\n    {\n        dfs(rt1,0,0);\n        printf(\"%lld\\n\",dp[rt1][1][1]*(mod-mod/2)%mod);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=2e5+5,mod=998244353;\nint n,m,dis[N],fa[N],a[N],si[N],rt1,rt2,head[N],nex[N<<1],to[N<<1],tot;\nvoid add(int u,int v){to[++tot]=v;nex[tot]=head[u];head[u]=tot;}\nvoid dfs(int u,int p)\n{\n    dis[u]=dis[p]+1;\n    if(dis[u]>dis[rt1]) rt1=u;\n    fa[u]=p;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p)continue;\n        dfs(v,u);\n    }\n}\nll dp[N][3][3],p[3][3];\nvoid dfs(int u,int fa,int d)\n{\n    d==m/2?dp[u][1][1]=1:dp[u][0][0]=1;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==fa)continue;\n        dfs(v,u,d+1);\n        memset(p,0,sizeof(p));\n        for(int i=0;i<3;i++)\n            for(int j=0;j<3;j++)\n            for(int k=0;k<3;k++)\n                for(int h=0;h<3;h++)\n        {\n            p[i][j]=(p[i][j]+dp[u][i][j]*dp[v][k][h])%mod;\n            p[min(i+k,2)][j]=(p[min(i+k,2)][j]+dp[u][i][j]*dp[v][k][h])%mod;\n            p[i][min(j+h,2)]=(p[i][min(j+h,2)]+dp[u][i][j]*dp[v][k][h])%mod;\n        }\n        for(int i=0;i<3;i++)\n            for(int j=0;j<3;j++)\n            dp[u][i][j]=p[i][j];\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        int u,v;scanf(\"%d%d\",&u,&v);add(u,v);add(v,u);\n    }\n    dfs(1,0);\n    rt2=rt1;\n    dfs(rt1,0);\n    while(fa[rt1]) a[++m]=rt1,rt1=fa[rt1];\n    a[++m]=rt1;\n    rt1=rt2=0;\n    if(m%2==0) rt1=a[m/2],rt2=a[m/2+1];\n    else rt1=a[m/2+1];\n    m--;\n    if(rt1&&rt2)\n    {\n        dfs(rt1,rt2,0);dfs(rt2,rt1,0);\n        printf(\"%lld\\n\",(dp[rt1][1][0]*dp[rt2][0][1])%mod);\n    }\n    else\n    {\n        dfs(rt1,0,0);\n        printf(\"%lld\\n\",dp[rt1][1][1]*(mod-mod/2)%mod);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[202020];\nconst ll mo=998244353;\n\npair<int,int> farthest(int cur,int pre,int d,vector<int>& D) {\n\tD[cur]=d;\n\tpair<int,int> r={d,cur};\n\tFORR(e,E[cur]) if(e!=pre) r=max(r, farthest(e,cur,d+1,D));\n\treturn r;\n}\n\npair<int,vector<int>> diameter() { // diameter,center\n\tvector<int> D[2];\n\tD[0].resize(N);\n\tD[1].resize(N);\n\tauto v1=farthest(0,0,0,D[0]);\n\tauto v2=farthest(v1.second,v1.second,0,D[0]);\n\tfarthest(v2.second,v2.second,0,D[1]);\n\tpair<int,vector<int>> R;\n\tR.first = v2.first;\n\t//重心を取る場合\n\tfor(int i=N-1;i>=0;i--) if(D[0][i]+D[1][i]==R.first && abs(D[0][i]-D[1][i])<=1) R.second.push_back(i);\n\n\treturn R;\n}\n\nvector<ll> dfs1(int cur,int pre,int lef,int no=0) {\n\tif(E[cur].size()==1) {\n\t\tif(lef==0) return {2,1,0};\n\t\telse return {3,0,0};\n\t}\n\telse {\n\t\tvector<ll> X={1,0,0};\n\t\tFORR(e,E[cur]) if(e!=pre) {\n\t\t\tvector<ll> Y=dfs1(e,cur,lef-1);\n\t\t\tvector<ll> Z={0,0,0};\n\t\t\tint x,y;\n\t\t\tFOR(x,3) FOR(y,3) Z[min(x+y,2)]+=X[x]*Y[y];\n\t\t\tX[0]=Z[0]%mo;\n\t\t\tX[1]=Z[1]%mo;\n\t\t\tX[2]=Z[2]%mo;\n\t\t}\n\t\tvector<ll> Y={0,0,0};\n\t\tif(no) {\n\t\t\tY=X;\n\t\t}\n\t\telse {\n\t\t\tY[0]=(X[0]*3+X[1]*2+X[2]*2)%mo;\n\t\t\tY[1]=X[1];\n\t\t\tY[2]=X[2];\n\t\t}\n\t\treturn Y;\n\t}\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tauto R=diameter();\n\tif(R.second.size()==1) {\n\t\tvector<ll> X={1,0,0,0};\n\t\tFORR(e,E[R.second[0]]) {\n\t\t\tauto Y=dfs1(e,R.second[0],R.first/2-1);\n\t\t\tvector<ll> Z={0,0,0,0};\n\t\t\tFOR(x,4) FOR(y,3) Z[min(x+(y==2?3:y),3)]+=X[x]*Y[y]%mo;\n\t\t\tFOR(x,4) X[x]=Z[x]%mo;\n\t\t}\n\t\tcout<<X[2]<<endl;\n\t}\n\telse {\n\t\tvector<ll> X=dfs1(R.second[0],R.second[1],R.first/2,1);\n\t\tvector<ll> Y=dfs1(R.second[1],R.second[0],R.first/2,1);\n\t\t\n\t\tcout<<X[1]*Y[1]%mo<<endl;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define MOD 998244353\ntemplate<typename ty1,typename ty2>\ninline int add(ty1 x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x += y; return x < MOD ? x : x - MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline void addto(ty1 &x, ty2 y) {\n\t\t  if(y>=MOD)y%=MOD;\n\t\t  if(x>=MOD)x%=MOD;\n\t      x += y; if (x >= MOD) x -= MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int sub(ty1 x, ty2 y) {\n\t\tif(y>=MOD)y%=MOD;\n\t\t if(x>=MOD)x%=MOD;\n        x -= y; return x < 0 ? x + MOD : x;\n}\ntemplate<typename ty1,typename ty2>\ninline void subto(ty1 &x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x -= y; if (x < 0) x += MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int mul(ty1 x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        return 1ll * x * y % MOD;\n}\ntemplate<typename ty1,typename ty2>\nvoid multo(ty1 &x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        x=1ll * x * y % MOD;\n}\n  \nlong long int gcd(long long int a, long long int b){\n\tif (a > b){\n\t\tswap(a, b);\n\t}\n\twhile (a){\n\t\tswap(a, b);\n\t\ta %= b;\n\t}\n\treturn b;\n}\nlong long int lcm(long long int a, long long int b){\n\treturn a / gcd(a, b)*b;\n}\nlong long int ppow(long long int i, long long int j){\n\t\tlong long int res = 1LL;\n\t\twhile (j){\n\t\t\tif ((j & 1LL)){\n\t\t\t\tres *= i;\n\t\t\t\tif (res >= MOD){\n\t\t\t\t\tres %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj >>= 1;\n\t\t\ti *= i;\n\t\t\tif (i >= MOD){\n\t\t\t\ti %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\nclass Combination{\n\t\npublic:\n\tvector<long long int> k;\n\tvector<long long int> r;\n\tvoid resize(int N){\n\t\tk.resize(N + 2);\n\t\tr.resize(N + 2);\n\t\tk[0] = 1;\n\t\tfor (int i = 1; i < N+2; i++){\n\t\t\tk[i] = k[i - 1];\n\t\t\tk[i] *= i;\n\t\t\tif (k[i] >= MOD)k[i] %= MOD;\n\t\t}\n\t\tlong long int al = k[k.size() - 1];\n\t\tlong long int iv = ppow(k[k.size() - 1],MOD-2);\n\t\tr[k.size() - 1] = iv;\n\t\tfor (int i = (int)(r.size()) - 2; i >= 0; i--){\n\t\t\tr[i] = r[i + 1] * (i + 1);\n\t\t\tif (r[i] >= MOD){\n\t\t\t\tr[i] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int C(int a, int b){\n\t\tif (a < b)return 0;\n\t\tlong long int up = k[a];\n\t\tlong long int dw = r[b] * r[a - b];\n\t\tdw %= MOD;\n\t\tup *= dw;\n\t\tup %= MOD;\n\t\treturn up;\n\t}\n\tlong long int H(int a, int b){\n\t\treturn C(a + b - 1, b);\n\t}\n\tlong long int catalan_number(int n){\n\t\treturn (C(2 * n, n) + MOD - C(2 * n, n - 1)) % MOD;\n\t}\n};\nCombination C;\n \n#define MAX 200002\nint n;\n \n \nstruct treediameter{\n\t//直径は色々いい性質がある\n\t//中心から(２頂点の場合それをくっつける）同じ距離のびた２つの頂点間が直径\n\t//直径は最大長であることにも注意\n\tconst vector<vector<int> >&g;\n\tint r1,r2;\n\tvector<int> d1,d2;  //両端からのdist\n\tint dia;\n\tvoid dfs(int v,int p,int cur,vector<int> &d){\n\t\td[v]=cur;\n\t\tfor(auto e:g[v])if(e!=p)\n\t\t\tdfs(e,v,cur+1,d);\n\t}\n\ttreediameter(const vector<vector<int> > &gg):g(gg),d1(g.size()),d2(g.size()){\n\t\tdfs(0,-1,0,d1);\n\t\tr1=max_element(d1.begin(),d1.end())-d1.begin();\n\t\tdfs(r1,-1,0,d1);\n\t\tr2=max_element(d1.begin(),d1.end())-d1.begin();\n\t\tdfs(r2,-1,0,d2);\n\t\tdia=d1[r2];\n\t}\n\tvector<int> find_centre(){  //直径の中心をさがす 1頂点 or 2頂点　直径は必ずこれらすべてを通る\n\t\tvector<int> ret;\n\t\tfor(int i=0;i<d1.size();i++){\n\t\t\tif(d1[i]+d2[i]==dia&&abs(d1[i]-d2[i])<=1){\n\t\t\t\tret.push_back(i);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n//treediameter(v)\n \nvector<vector<int> > v;\n \nbool flag[MAX];\n \n//0:none with only one type of operation\n//1:positive without substraction\n// 2: none with mix\nint dp[MAX][3];\nbool us[MAX][3];\nint target;\ninline int dfs(int b,int ty,int pr=-1,int d=0){\n\tif(us[b][ty]){\n\t\treturn dp[b][ty];\n\t}\n\tus[b][ty]=true;\n\tint ava=0;\n\tvector<int> can;\n\tfor(int go:v[b]){\n\t\tif(go==pr||flag[go])continue;\n\t\tava++;\n\t\tcan.push_back(go);\n\t}\n\tassert(d<=target);\n\tif(ava==0){\n\t\t//leaf\n\t\tif(ty==1){\n\t\t\tif(d==target){\n\t\t\t\tdp[b][ty]=1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tdp[b][ty]=0;\n\t\t\treturn 0;\n\t\t}\n\t\tif(ty==0){\n\t\t\tif(d==target){\n\t\t\t\tdp[b][ty]=0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdp[b][ty]=1;\n\t\t\treturn 1;\n\t\t}\n\t\tif(ty==2){\n\t\t\tdp[b][ty]=1;\n\t\t\treturn 1;\n\t\t}\n\t\texit(1);\n\t}\n\tif(ty==1){\n\t\tif(true){\n\t\t\tfor(int go:can){\n\t\t\t\tauto ret=dfs(go,1,b,d+1);\n\t\t\t\tfor(int goo:can){\n\t\t\t\t\tif(go!=goo){\n\t\t\t\t\t\tmulto(ret,add(dfs(goo,0,b,d+1),mul(2,dfs(goo,2,b,d+1))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddto(dp[b][ty],ret);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int go:can){\n\t\t\t\tauto ret=dfs(go,1,b,d+1);\n\t\t\t\tfor(int goo:can){\n\t\t\t\t\tif(go!=goo){\n\t\t\t\t\t\tmulto(ret,add(mul(2,dfs(goo,0,b,d+1)),mul(1,dfs(goo,2,b,d+1))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddto(dp[b][ty],ret);\n\t\t\t}\n\t\t}\n\t}\n\tif(ty==2){\n\t\tdp[b][ty]=1;\n\t\tfor(int goo:can){\n\t\t\tmulto(dp[b][ty],mul(3,dfs(goo,2,b,d+1)));\n\t\t}\n\t}\n\tif(ty==0){\n\t\tdp[b][ty]=1;\n\t\tfor(int goo:can){\n\t\t\tmulto(dp[b][ty],add(dfs(goo,0,b,d+1),mul(2,dfs(goo,2,b,d+1))));\n\t\t}\n\t}\n\treturn dp[b][ty];\n}\n \nint main(){\n\tcin>>n;\n\tv.resize(n);\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tauto dia=treediameter(v);\n\tauto centre=dia.find_centre();\n\tfor(auto el:centre){\n\t\tflag[el]=true;\n\t}\n\tif(centre.size()==1){\n\t\tint pos=centre[0];\n\t\ttarget=dia.dia/2;\n\t\tlong long int ans=0;\n\t\tvector<int> ml;\n\t\tint overall=1;\n\t\tfor(int el3:v[pos]){\n\t\t\tml.push_back(add(mul(2,dfs(el3,0,pos,1)),mul(1,dfs(el3,2,pos,1))));\n\t\t\tmulto(overall,ml.back());\n\t\t}\n\t\tint i=0;\n\t\tfor(int el1:v[pos]){\n\t\t\tint j=0;\n\t\t\tfor(int el2:v[pos]){\n\t\t\t\tif(el1!=el2){\n\t\t\t\t\tauto ret=mul(dfs(el1,1,pos,1),dfs(el2,1,pos,1));\n\t\t\t\t\tmulto(ret,overall);\n\t\t\t\t\tmulto(ret,ppow(ml[i],MOD-2));\n\t\t\t\t\tmulto(ret,ppow(ml[j],MOD-2));\n\t\t\t\t\taddto(ans,ret);\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tmulto(ans,ppow(2,MOD-2));\n\t\tans%=MOD;\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\telse{\n\t\tcerr<<centre[0]<<\" \"<<centre[1]<<endl;\n\t\tcerr<<dia.dia<<endl;\n\t\ttarget=dia.dia/2;\n\t\tlong long int ans=0;\n\t\tcerr<<target<<\" \"<<dfs(centre[0],1)<<\" \"<<dfs(centre[1],1)<<endl;\n\t\taddto(ans,mul(dfs(centre[0],1),dfs(centre[1],1)));\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define sz(a) int(a.size())\nconst int N=2e5+10;\nconst int mod=998244353;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nint n,f[N][3][3],mx,p,fa[N],st[N],md[N],tp;\nvi E[N];\n\nvoid dfs(int u,int ff,int dis) {\n\tfa[u]=ff;\n\tif(dis>mx) mx=dis,p=u;\n\tfor(auto v:E[u]) if(v!=ff) dfs(v,u,dis+1);\n}\n\nvoid dp(int u,int ff) {\n\tmd[u]=0;\n\tfor(auto v:E[u]) if(v!=ff) dp(v,u),md[u]=max(md[u],md[v]);\n\tif(md[u]==0) f[u][1][1]=1;\n\telse f[u][0][0]=1;\n\tfor(auto v:E[u])\n\t\tif(v!=ff) {\n\t\t\tstatic int g[3][3];memset(g,0,sizeof(g));\n\t\t\tfor(int i=0;i<3;i++)\n\t\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\t\t\tfor(int l=0;l<3;l++) {\n\t\t\t\t\t\t\tint &t=g[min(i+(md[u]==md[v]?k:0),2)][min(j+(md[u]==md[v]?l:0),2)];\n\t\t\t\t\t\t\tt=(t+1ll*f[u][i][j]*f[v][k][l])%mod;\n\t\t\t\t\t\t}\n\t\t\tfor(int i=0;i<3;i++)\n\t\t\t\tfor(int j=0;j<3;j++) f[u][i][j]=g[i][j];\n\t\t}\n\tif(ff) {\n\t\tstatic int g[3][3];memset(g,0,sizeof(g));\n\t\tfor(int i=0;i<3;i++)\n\t\t\tfor(int j=0;j<3;j++) {\n\t\t\t\tg[0][0]=(g[0][0]+f[u][i][j])%mod;\n\t\t\t\tg[i][0]=(g[i][0]+f[u][i][j])%mod;\n\t\t\t\tg[0][j]=(g[0][j]+f[u][i][j])%mod;\n\t\t\t}\n\t\tfor(int i=0;i<3;i++)\n\t\t\tfor(int j=0;j<3;j++) f[u][i][j]=g[i][j];\n\t\t++md[u];\n\t}\n}\n\nint main() {\n\tcin>>n;\n\tfor(int i=1,u,v;i<n;i++) u=gi(),v=gi(),E[u].pb(v),E[v].pb(u);\n\tdfs(1,0,0);mx=0;dfs(p,0,0);\n\tfor(int i=p;i;i=fa[i]) st[++tp]=i;\n\tif(tp&1) {\n\t\tint x=st[(tp+1)/2];\n\t\t//cerr<<x<<'\\n';\n\t\tdp(x,0);cout<<1ll*f[x][1][1]*((mod+1)>>1)%mod;\n\t}\n\telse {\n\t\tint x=st[tp/2],y=st[tp/2+1];\n\t\tdp(x,y);dp(y,x);cout<<1ll*f[x][0][1]*f[y][1][0]%mod;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define I inline\n#define fi first\n#define se second\n#define R register\n#define LL long long\n#define mp make_pair\n#define reg register int\n#define pii pair<int,int>\n#define fo(i, a, b) for(reg i = a; i <= b; i++)\n#define fd(i, a, b) for(reg i = a; i >= b; i--)\n#define bp __builtin_popcount\n#define cr const reg&\nusing namespace std;\nconst int N = 2e5 + 1, mod = 998244353, inv2 = mod + 1 >> 1;\n\nI int _max(cr x, cr y) {return x > y ? x : y;}\nI int _min(cr x, cr y) {return x < y ? x : y;}\nI int read() {\n\treg x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n\treturn x * f;\n}\nI void ptt(LL x) {if(x >= 10) ptt(x / 10); putchar(x % 10 + '0');}\nI void put(LL x) {x < 0 ? putchar('-'), ptt(-x) : ptt(x);}\nI void pr1(LL x) {put(x), putchar(' ');}\nI void pr2(LL x) {put(x), puts(\"\");}\n\nstruct edge {\n\tint x, y, next;\n} e[N * 2]; int len, last[N];\nint tp, mx, rt, sta[N], fa[N];\nint f[N][3][3], tmp[3][3];\n//x-y,y-x\n\nI void ins(cr x, cr y) {e[++len] = edge{x, y, last[x]}, last[x] = len;}\n\nvoid dfs(cr x, cr dep) {\n\tif(dep > mx) mx = dep, rt = x;\n\tfor(reg k = last[x]; k; k = e[k].next) if(e[k].y ^ fa[x]) fa[e[k].y] = x, dfs(e[k].y, dep + 1);\n}\n\nvoid treedp(cr x, cr fa, cr dep) {\n\tdep == tp / 2 ? f[x][1][1] = 1 : f[x][0][0] = 1;\n\tfor(reg k = last[x]; k; k = e[k].next) if(e[k].y ^ fa){\n\t\treg y = e[k].y;\n\t\ttreedp(y, x, dep + 1);\n\t\tfo(i, 0, 2) fo(j, 0, 2) fo(k, 0, 2) fo(l, 0, 2) fo(g, -1, 1) {\n\t\t\treg z = _min(2, i + k * (g == 1)), p = _min(2, j + l * (g == -1));\n\t\t\ttmp[z][p] = (tmp[z][p] + (LL)f[x][i][j] * f[y][k][l]) % mod;\n\t\t} fo(i, 0, 2) fo(j, 0, 2) f[x][i][j] = tmp[i][j], tmp[i][j] = 0;\n\t}\n}\n\nint main() {\n\treg n = read();\n\tfo(i, 1, n - 1) {\n\t\treg x = read(), y = read();\n\t\tins(x, y), ins(y, x);\n\t} dfs(1, 1), mx = fa[rt] = 0, dfs(rt, 1);\n\tfor(; rt; rt = fa[rt]) sta[++tp] = rt;\n\tif(tp & 1) rt = sta[tp / 2 + 1], treedp(rt, 0, 0), pr2((LL)inv2 * f[rt][1][1] % mod);\n\telse {\n\t\treg x = sta[tp / 2], y = sta[tp / 2 + 1];\n\t\ttreedp(x, y, 1), treedp(y, x, 1);\n\t\treg c1 = (f[x][1][0] + f[x][1][1] + f[x][1][2]) % mod, c2 = (f[y][1][0] + f[y][1][1] + f[y][1][2]) % mod;\n\t\tpr2((LL)c1 * c2 % mod);\n\t} return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for(int i=(a),_ed=(b);i<=_ed;++i)\n#define DREP(i,a,b) for(int i=(a),_ed=(b);i>=_ed;--i)\n#define mp(x,y) make_pair((x),(y))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int,int> pii;\ninline int read(){\n    register int x=0,f=1;register char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=0;ch=getchar();}\n    while(isdigit(ch)){x=x*10+(ch^'0');ch=getchar();}\n    return f?x:-x;\n}\n\nconst int N=2e5+5,mod=998244353;\nint n,c[2],mxd[N],f[N][3][3],g[3][3];\nvector<int> E[N];\ninline void inc(int& x,int y){x=x+y<mod?x+y:x+y-mod;}\n\nnamespace getcore{\n\tint d[N],fa[N],stk[N],tp,tmp;\n\tvoid dfs(int u,int pa,int dis,int& rt){\n\t\td[u]=dis,fa[u]=pa;if(d[u]>d[rt])rt=u;\n\t\tfor(int v:E[u]){\n\t\t\tif(v==pa)continue;\n\t\t\tdfs(v,u,dis+1,rt);\n\t\t}\n\t}\n\tvoid Main(){\n\t\tdfs(1,0,0,tmp);\n\t\tdfs(tmp,0,0,tmp);\n\t\twhile(tmp)stk[++tp]=tmp,tmp=fa[tmp];\n\t\tc[0]=stk[(tp+1)>>1];\n\t\tif(~tp&1)c[1]=stk[((tp+1)>>1)+1];//想清楚啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊\n\t}\n}\n\nint dfs(int u,int pa,int dep){\n\tmxd[u]=dep;\n\tfor(int v:E[u]){\n\t\tif(v==pa||v==c[0]||v==c[1])continue;\n\t\tmxd[u]=max(mxd[u],dfs(v,u,dep+1));\n\t}\n\tif(mxd[u]==dep)f[u][1][1]=1;\n\telse f[u][0][0]=1;\n\tfor(int v:E[u]){\n\t\tif(v==pa||v==c[0]||v==c[1])continue;\n\t\tREP(i,0,2)REP(j,0,2)g[i][j]=0;\n\t\tREP(a,0,2)REP(b,0,2)REP(p,0,2)REP(q,0,2){\n\t\t\tint flg=mxd[u]==mxd[v];\n\t\t\tint s=a,t=b,val=1ll*f[u][a][b]*f[v][p][q]%mod;\n\t\t\tinc(g[s][t],val);\n\t\t\ts=flg?min(2,a+p):a,t=b;\n\t\t\tinc(g[s][t],val);\n\t\t\ts=a,t=flg?min(2,b+q):b;\n\t\t\tinc(g[s][t],val);\n\t\t}\n\t\tREP(i,0,2)REP(j,0,2)f[u][i][j]=g[i][j];\n\t}\n\treturn mxd[u];\n}\n\nint main(){\n\t// freopen(\"in.in\",\"r\",stdin);\n\t// freopen(\"out.out\",\"w\",stdout);\n\tn=read();\n\tREP(i,1,n-1){\n\t\tint u=read(),v=read();\n\t\tE[u].pb(v),E[v].pb(u);\n\t}\n\tgetcore::Main();\n\tint sum=0;\n\tdfs(c[0],0,0);\n\tif(!c[1])\n\t\tsum=f[c[0]][1][1];\n\telse{\n\t\tdfs(c[1],0,0);\n\t\tREP(i,0,2)REP(j,0,2)\n\t\t\tinc(sum,1ll*f[c[0]][1][i]*f[c[1]][j][1]%mod);\n\t\tREP(i,0,2)REP(j,0,2)\n\t\t\tinc(sum,1ll*f[c[0]][i][1]*f[c[1]][1][j]%mod);\n\t}\n\tsum=1ll*sum*(mod+1)/2%mod;\n\tprintf(\"%d\\n\",sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;++A)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD 998244353ll\nll moddiv(ll a,ll b){\n    a %= MOD;\n    b %= MOD;\n    for(ll m=MOD-2;m>0;m/=2){\n        if(m&1){\n            a=a*b%MOD;\n        }\n        b=b*b%MOD;\n    }\n    return a;\n}\n\n\nll N,Len;\nvector<ll> abv[202020];\nvector<ll> abl[202020];\nll mk[202020],p3[202020];\nll dp[202020][4];\nll i, j, k;\nll ans;\n\nvoid dfs(ll a,ll p,ll d)\n{\n    if(abv[a].size()==1){\n        dp[a][2] = 3;\n        if(d==0){\n            dp[a][0] = 2;\n            dp[a][1] = 1;\n        }else{\n            dp[a][0] = 3;\n        }\n        return;\n    }\n    ll i;\n    ll c = 1, e = 0;\n    dp[a][2] = 1;\n    fornum(i,0,abv[a].size()){\n        ll b = abv[a][i];\n        if(b==p){\n            continue;\n        }\n        dfs(b, a, d - 1);\n        c = c * dp[b][0] % MOD;\n        dp[a][2] *= dp[b][2];\n        dp[a][2] %= MOD;\n    }\n    dp[a][0] = (dp[a][2] * 2 + c) % MOD;\n    fornum(i,0,abv[a].size()){\n        ll b = abv[a][i];\n        if(b==p){\n            continue;\n        }\n        dp[a][1] += moddiv(c * dp[b][1], dp[b][0]);\n        dp[a][1] %= MOD;\n    }\n    dp[a][2] *= 3;\n    dp[a][2] %= MOD;\n}\n\nll lencalc(ll a,ll p,ll d){\n    //printf(\"%lld,%lld,%lld\\n\", p, a, d);\n    ll i = 0,  ret = 0;\n    pll c = {0, 0};\n    fornum(i,0,abv[a].size()){\n        ll b = abv[a][i];\n        if(b==p)\n            continue;\n        if(c.first<=abl[a][i]){\n            c.second = c.first;\n            c.first = abl[a][i];\n        }else if(c.second<=abl[a][i]){\n            c.second = abl[a][i];\n        }\n    }\n    fornum(i,0,abv[a].size()){\n        ll b = abv[a][i];\n        if(b==p){\n            abl[a][i] = d;\n            continue;\n        }\n        ll r = 0;\n        if(c.first==abl[a][i]){\n            r = lencalc(b, a, max(d, c.second) + 1);\n        }else{\n            r = lencalc(b, a, max(d, c.first) + 1);\n        }\n        abl[a][i] = r;\n        ret = max(ret, r);\n    }\n    return ret + 1;\n}\n\n\nint main(){\n    scanf(\"%lld\", &N);\n    fornum(i,1,N){\n        ll a, b;\n        scanf(\"%lld%lld\", &a, &b);\n        abv[a].push_back(b);\n        abl[a].push_back(0);\n        abv[b].push_back(a);\n        abl[b].push_back(0);\n    }\n    lencalc(1, 0, 0);\n    lencalc(1, 0, 0);\n    fornum(i,1,N+1){\n        if(abv[i].size()==1){\n            Len = max(Len, abl[i][0]);\n        }\n    }\n\n    if(Len%2){\n        pll a = {0, 0};\n        fornum(i,1,N+1){\n            fornum(j,0,abv[i].size()){\n                if((Len+1)/2==abl[i][j]){\n                    break;\n                }\n            }\n            if(j<abv[i].size()){\n                a.first = i;\n                a.second = abv[i][j];\n            }\n        }\n        //printf(\"b%lld,%lld\\n\", a.first, a.second);\n        dfs(a.first, a.second, Len / 2);\n        dfs(a.second, a.first, Len / 2);\n        ans = dp[a.first][1] * dp[a.second][1] % MOD;\n    }else{\n        fornum(i,1,N+1){\n            if(abv[i].size()==1)\n                continue;\n            sort(abl[i].begin(), abl[i].end(),greater<ll>());\n            if(abl[i][0]==abl[i][1])\n                break;\n        }\n        ll a = i;\n        //printf(\"a%lld\\n\", a);\n        dfs(a, 0, Len / 2);\n        ll c = 1;\n        fornum(i,0,abv[a].size()){\n            ll b = abv[a][i];\n            //printf(\"cc%lld,%lld,%lld\\n\", b, dp[b][0], dp[b][1]);\n            c = c * (dp[b][0] * 2 - dp[b][2] + MOD) % MOD;\n        }\n        ll d = 0;\n        fornum(i,0,abv[a].size()){\n            ll b = abv[a][i];\n            ans += moddiv(d * dp[b][1], dp[b][0] * 2 - dp[b][2] + MOD);\n            ans %= MOD;\n            d += moddiv(c * dp[b][1], dp[b][0] * 2 - dp[b][2] + MOD);\n            d %= MOD;\n        }\n    }\n    \n    printf(\"%lld\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define MOD 998244353\ntemplate<typename ty1,typename ty2>\ninline int add(ty1 x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x += y; return x < MOD ? x : x - MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline void addto(ty1 &x, ty2 y) {\n\t\t  if(y>=MOD)y%=MOD;\n\t\t  if(x>=MOD)x%=MOD;\n\t      x += y; if (x >= MOD) x -= MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int sub(ty1 x, ty2 y) {\n\t\tif(y>=MOD)y%=MOD;\n\t\t if(x>=MOD)x%=MOD;\n        x -= y; return x < 0 ? x + MOD : x;\n}\ntemplate<typename ty1,typename ty2>\ninline void subto(ty1 &x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x -= y; if (x < 0) x += MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int mul(ty1 x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        return 1ll * x * y % MOD;\n}\ntemplate<typename ty1,typename ty2>\nvoid multo(ty1 &x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        x=1ll * x * y % MOD;\n}\n  \nlong long int gcd(long long int a, long long int b){\n\tif (a > b){\n\t\tswap(a, b);\n\t}\n\twhile (a){\n\t\tswap(a, b);\n\t\ta %= b;\n\t}\n\treturn b;\n}\nlong long int lcm(long long int a, long long int b){\n\treturn a / gcd(a, b)*b;\n}\nlong long int ppow(long long int i, long long int j){\n\t\tlong long int res = 1LL;\n\t\twhile (j){\n\t\t\tif ((j & 1LL)){\n\t\t\t\tres *= i;\n\t\t\t\tif (res >= MOD){\n\t\t\t\t\tres %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj >>= 1;\n\t\t\ti *= i;\n\t\t\tif (i >= MOD){\n\t\t\t\ti %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\nclass Combination{\n\t\npublic:\n\tvector<long long int> k;\n\tvector<long long int> r;\n\tvoid resize(int N){\n\t\tk.resize(N + 2);\n\t\tr.resize(N + 2);\n\t\tk[0] = 1;\n\t\tfor (int i = 1; i < N+2; i++){\n\t\t\tk[i] = k[i - 1];\n\t\t\tk[i] *= i;\n\t\t\tif (k[i] >= MOD)k[i] %= MOD;\n\t\t}\n\t\tlong long int al = k[k.size() - 1];\n\t\tlong long int iv = ppow(k[k.size() - 1],MOD-2);\n\t\tr[k.size() - 1] = iv;\n\t\tfor (int i = (int)(r.size()) - 2; i >= 0; i--){\n\t\t\tr[i] = r[i + 1] * (i + 1);\n\t\t\tif (r[i] >= MOD){\n\t\t\t\tr[i] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int C(int a, int b){\n\t\tif (a < b)return 0;\n\t\tlong long int up = k[a];\n\t\tlong long int dw = r[b] * r[a - b];\n\t\tdw %= MOD;\n\t\tup *= dw;\n\t\tup %= MOD;\n\t\treturn up;\n\t}\n\tlong long int H(int a, int b){\n\t\treturn C(a + b - 1, b);\n\t}\n\tlong long int catalan_number(int n){\n\t\treturn (C(2 * n, n) + MOD - C(2 * n, n - 1)) % MOD;\n\t}\n};\nCombination C;\n\n#define MAX 200002\nint n;\n\n\nstruct treediameter{\n\t//直径は色々いい性質がある\n\t//中心から(２頂点の場合それをくっつける）同じ距離のびた２つの頂点間が直径\n\t//直径は最大長であることにも注意\n\tconst vector<vector<int> >&g;\n\tint r1,r2;\n\tvector<int> d1,d2;  //両端からのdist\n\tint dia;\n\tvoid dfs(int v,int p,int cur,vector<int> &d){\n\t\td[v]=cur;\n\t\tfor(auto e:g[v])if(e!=p)\n\t\t\tdfs(e,v,cur+1,d);\n\t}\n\ttreediameter(const vector<vector<int> > &gg):g(gg),d1(g.size()),d2(g.size()){\n\t\tdfs(0,-1,0,d1);\n\t\tr1=max_element(d1.begin(),d1.end())-d1.begin();\n\t\tdfs(r1,-1,0,d1);\n\t\tr2=max_element(d1.begin(),d1.end())-d1.begin();\n\t\tdfs(r2,-1,0,d2);\n\t\tdia=d1[r2];\n\t}\n\tvector<int> find_centre(){  //直径の中心をさがす 1頂点 or 2頂点　直径は必ずこれらすべてを通る\n\t\tvector<int> ret;\n\t\tfor(int i=0;i<d1.size();i++){\n\t\t\tif(d1[i]+d2[i]==dia&&abs(d1[i]-d2[i])<=1){\n\t\t\t\tret.push_back(i);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n//treediameter(v)\n\nvector<vector<int> > v;\n\nbool flag[MAX];\n\n//0:none with only one type of operation\n//1:positive without substraction\n// 2: none with mix\nint dp[MAX][3];\nbool us[MAX][3];\nint target;\ninline int dfs(int b,int ty,int pr=-1,int d=0){\n\tif(us[b][ty]){\n\t\treturn dp[b][ty];\n\t}\n\tus[b][ty]=true;\n\tint ava=0;\n\tvector<int> can;\n\tfor(int go:v[b]){\n\t\tif(go==pr||flag[go])continue;\n\t\tava++;\n\t\tcan.push_back(go);\n\t}\n\tif(ava==0){\n\t\t//leaf\n\t\tif(ty==1){\n\t\t\tif(d==target){\n\t\t\t\tdp[b][ty]=1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tdp[b][ty]=0;\n\t\t\treturn 0;\n\t\t}\n\t\tif(ty==0){\n\t\t\tif(d==target){\n\t\t\t\tdp[b][ty]=0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdp[b][ty]=1;\n\t\t\treturn 1;\n\t\t}\n\t\tif(ty==2){\n\t\t\tdp[b][ty]=1;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif(ty==1){\n\t\tif(d){\n\t\t\tfor(int go:can){\n\t\t\t\tauto ret=dfs(go,1,b,d+1);\n\t\t\t\tfor(int goo:can){\n\t\t\t\t\tif(go!=goo){\n\t\t\t\t\t\tmulto(ret,add(dfs(goo,0,b,d+1),mul(2,dfs(goo,2,b,d+1))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddto(dp[b][ty],ret);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int go:can){\n\t\t\t\tauto ret=dfs(go,1,b,d+1);\n\t\t\t\tfor(int goo:can){\n\t\t\t\t\tif(go!=goo){\n\t\t\t\t\t\tmulto(ret,add(mul(2,dfs(goo,0,b,d+1)),mul(1,dfs(goo,2,b,d+1))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddto(dp[b][ty],ret);\n\t\t\t}\n\t\t}\n\t}\n\tif(ty==2){\n\t\tdp[b][ty]=1;\n\t\tfor(int goo:can){\n\t\t\tmulto(dp[b][ty],mul(3,dfs(goo,2,b,d+1)));\n\t\t}\n\t}\n\tif(ty==0){\n\t\tdp[b][ty]=1;\n\t\tfor(int goo:can){\n\t\t\tmulto(dp[b][ty],add(dfs(goo,0,b,d+1),mul(2,dfs(goo,2,b,d+1))));\n\t\t}\n\t}\n\treturn dp[b][ty];\n}\n\nint main(){\n\tcin>>n;\n\tv.resize(n);\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tauto dia=treediameter(v);\n\tauto centre=dia.find_centre();\n\tfor(auto el:centre){\n\t\tflag[el]=true;\n\t}\n\tif(centre.size()==1){\n\t\treturn 1;\n\t\tint pos=centre[0];\n\t\ttarget=dia.dia/2;\n\t\ttarget--;\n\t\tlong long int ans=0;\n\t\tfor(int el1:v[pos]){\n\t\t\tfor(int el2:v[pos]){\n\t\t\t\tif(el1!=el2){\n\t\t\t\t\tauto ret=mul(dfs(el1,1,pos,0),dfs(el2,1,pos,0));\n\t\t\t\t\ttarget++;\n\t\t\t\t\tfor(int el3:v[pos]){\n\t\t\t\t\t\tif(el1!=el3&&el2!=el3){\n\t\t\t\t\t\t\tmulto(ret,add(mul(2,dfs(el3,0,pos,1)),mul(1,dfs(el3,2,pos,1))));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttarget--;\n\t\t\t\t\taddto(ans,ret);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmulto(ans,ppow(2,MOD-2));\n\t\tans%=MOD;\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\telse{\n\t\ttarget=dia.dia/2;\n\t\tlong long int ans=0;\n\t\taddto(ans,mul(dfs(centre[0],1),dfs(centre[1],1)));\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nstruct edge{int to, cost, id;};\n\nclass Graph\n{\npublic:\n    int N;\n    vector<vector<edge>> G;\n    bools f;\n    mmat dp;\n\n    Graph(int N): N(N){\n        G = vector<vector<edge>>(N, vector<edge>(0));\n        f = bools(N, false);\n        dp = mmat(N, mvec(3, 0));\n    }\n\n    void add_Directed_edge(int from, int to, int cost = 1, int id = 0){\n        G[from].push_back(edge({to, cost, id}));\n    }\n\n    void add_Undirected_edge(int v1, int v2, int cost = 1, int id = 0){\n        add_Directed_edge(v1, v2, cost, id);\n        add_Directed_edge(v2, v1, cost, id);\n    }\n\n    //calculate diameter of a Tree\n    void dfs_for_calcdist(int v, int p, int c, vec &dist){\n        if(p != -1) dist[v] = dist[p] + c;\n        for(auto e: G[v]) if(e.to != p) dfs_for_calcdist(e.to, v, e.cost, dist);\n    } \n\n    int diameter(int &v1, int &v2, int s = 0){\n        vec dist(N, 0);\n        dfs_for_calcdist(s, -1, -1, dist);\n        v1 = distance(dist.begin(), max_element(dist.begin(), dist.end()));\n        fill(dist.begin(), dist.end(), 0);\n        dfs_for_calcdist(v1, -1, -1, dist);\n        auto amax = max_element(dist.begin(), dist.end());\n        v2 = distance(dist.begin(), amax);\n        return *amax;\n    }\n\n    void dfs(int v, int p){\n\n        if(f[v]) dp[v][1] = 1;\n        else dp[v][0] = 1;\n\n        if(p != -1){\n            for(auto e: G[v]) if(e.to != p){\n                dfs(e.to, v);\n                mvec tmp(3, 0);\n                tmp[0] = dp[v][0] * (dp[e.to][0] * 3 + dp[e.to][1] * 2 + dp[e.to][2] * 2);\n                tmp[1] = dp[v][0] * dp[e.to][1] + dp[v][1] * (dp[e.to][0] * 3 + dp[e.to][1] * 2 + dp[e.to][2] * 2);\n                tmp[2] = dp[v][1] * dp[e.to][1] + dp[v][2] * (dp[e.to][0] + dp[e.to][1] + dp[e.to][2]) * 3;\n                dp[v] = tmp;\n            }\n        }else{\n            dp[v] = mvec(4, 0);\n            dp[v][0] = 1;\n            for(auto e: G[v]) if(e.to != p){\n                dfs(e.to, v);\n                mvec tmp(4, 0);\n                REP(j, 4){\n                    tmp[j] += dp[v][j] * (dp[e.to][0] * 3 + dp[e.to][1] + dp[e.to][2]);\n                    if((j & 1) == 0) tmp[j | 1] += dp[v][j] * dp[e.to][1];\n                    if((j & 2) == 0) tmp[j | 2] += dp[v][j] * dp[e.to][1];\n                }\n                dp[v] = tmp;\n            }\n        }\n    }\n\n};\n\n\nsigned main(){\n\n    int N; cin >> N;\n    Graph G(N);\n    REP(i, N - 1){\n        int a, b; cin >> a >> b;\n        G.add_Undirected_edge(a - 1, b - 1);\n    }\n\n    int v1, v2;\n    int R = G.diameter(v1, v2);\n    vec d1(N, 0), d2(N, 0);\n    G.dfs_for_calcdist(v1, -1, -1, d1);\n    G.dfs_for_calcdist(v2, -1, -1, d2);\n\n    vec center;\n    REP(i, N) if(d1[i] + d2[i] == R && llabs(d1[i] - d2[i]) <= 1) center.pb(i);\n    \n    fill(all(d1), 0);\n    fill(all(d2), 0);\n    mint ans;\n    if(SZ(center) == 1){\n        G.dfs_for_calcdist(center[0], -1, -1, d1);\n        REP(i, N) if(d1[i] == R / 2) G.f[i] = true;\n\n        G.dfs(center[0], -1);\n        ans = G.dp[center[0]][3] / 2;\n        assert(false);\n    }else{\n        G.dfs_for_calcdist(center[0], -1, -1, d1);\n        G.dfs_for_calcdist(center[1], -1, -1, d2);\n        REP(i, N) if(min(d1[i], d2[i]) == R / 2) G.f[i] = true;\n\n        G.dfs(center[0], center[1]);\n        G.dfs(center[1], center[0]);\n        ans = G.dp[center[0]][1] * G.dp[center[1]][1];\n    }\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\ndouble startTime;\ndouble getCurrentTime() {\n\treturn ((double)clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst ll MOD = (ll)998244353;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\n\nconst int N = 200200;\nint n;\nvector<int> g[N];\nll ANS;\nint dist[N];\nint q[N];\nint par[N];\nint topQ;\nint D;\nll dp[N][3];\n\nvoid BFS(int v) {\n\tfor (int i = 0; i < n; i++)\n\t\tdist[i] = N;\n\tdist[v] = 0;\n\ttopQ = 0;\n\tq[topQ++] = v;\n\tfor (int i = 0; i < topQ; i++) {\n\t\tv = q[i];\n\t\tfor (int u : g[v]) {\n\t\t\tif (dist[u] <= dist[v] + 1) continue;\n\t\t\tdist[u] = dist[v] + 1;\n\t\t\tpar[u] = v;\n\t\t\tq[topQ++] = u;\n\t\t}\n\t}\n}\n\nvoid dfs(int v, int p) {\n\tdp[v][0] = dp[v][1] = dp[v][2] = 0;\n\tif ((int)g[v].size() == 1) {\n\t\tdp[v][(int)(dist[v] == D)] = 1;\n\t\t//dp[v][0] = add(dp[v][0], 2);\n\t\treturn;\n\t}\n\tdp[v][0] = 1;\n\tll inner[3];\n\tfor (int u : g[v]) {\n\t\tif (u == p) continue;\n\t\tinner[0] = inner[1] = inner[2] = 0;\n\t\tdfs(u, v);\n\t\tll w[2];\n\t\tw[0] = w[1] = 0;\n\t\tw[0] = add(mult(3, dp[u][0]), mult(2, add(dp[u][2], dp[u][1])));\n\t\tw[1] = dp[u][1];\n\t\tfor (int x = 0; x < 3; x++)\n\t\t\tfor (int y = 0; y < 2; y++) {\n\t\t\t\tif (x + y < 3)\n\t\t\t\t\tinner[x + y] = add(inner[x + y], mult(dp[v][x], w[y]));\n\t\t\t}\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tdp[v][i] = inner[i];\n\t}\n}\n\nvoid solveVertex(int v) {\n\teprintf(\"solveVertex %d\\n\", v);\n\tD /= 2;\n\tBFS(v);\n\tll inner[2][3];\n\tfor (int i = 0; i < 2; i++)\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tinner[i][j] = 0;\n\tinner[0][0] = 1;\n\tfor (int u : g[v]) {\n\t\tdfs(u, v);\n\t\tll w[2];\n\t\tw[0] = w[1] = 0;\n\t\tw[0] = add(mult(3, dp[u][0]), add(dp[u][2], dp[u][1]));\n\t\tw[1] = dp[u][1];\n\t\teprintf(\"%lld %lld\\n\", w[0], w[1]);\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tinner[1][i] = 0;\n\t\tfor (int x = 0; x < 3; x++)\n\t\t\tfor (int y = 0; y < 2; y++)\n\t\t\t\tif (x + y < 3)\n\t\t\t\t\tinner[1][x + y] = add(inner[1][x + y], mult(inner[0][x], w[y]));\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tinner[0][i] = inner[1][i];\n\t}\n\tll ans = inner[0][2];\n\tprintf(\"%lld\\n\", ans);\n}\nvoid solveEdge(int v, int u) {\n\teprintf(\"solveEdge %d %d\\n\", v, u);\n\tD /= 2;\n\tll ans = 1;\n\tfor (int k = 0; k < 2; k++) {\n\t\tBFS(v);\n\t\tdfs(v, u);\n\t\tans = mult(ans, dp[v][1]);\n\t\tswap(v, u);\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tstartTime = (double)clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\n\tBFS(0);\n\tint V = q[n - 1];\n\tBFS(V);\n\tint U = q[n - 1];\n\tD = dist[U];\n\n\tif (D & 1) {\n\t\tint v = U;\n\t\tfor (int i = 0; i < D / 2; i++)\n\t\t\tv = par[v];\n\t\tsolveEdge(v, par[v]);\n\t} else {\n\t\tint v = U;\n\t\tfor (int i = 0; i < D / 2; i++)\n\t\t\tv = par[v];\n\t\tsolveVertex(v);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define MOD 998244353\ntemplate<typename ty1,typename ty2>\ninline int add(ty1 x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x += y; return x < MOD ? x : x - MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline void addto(ty1 &x, ty2 y) {\n\t\t  if(y>=MOD)y%=MOD;\n\t\t  if(x>=MOD)x%=MOD;\n\t      x += y; if (x >= MOD) x -= MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int sub(ty1 x, ty2 y) {\n\t\tif(y>=MOD)y%=MOD;\n\t\t if(x>=MOD)x%=MOD;\n        x -= y; return x < 0 ? x + MOD : x;\n}\ntemplate<typename ty1,typename ty2>\ninline void subto(ty1 &x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x -= y; if (x < 0) x += MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int mul(ty1 x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        return 1ll * x * y % MOD;\n}\ntemplate<typename ty1,typename ty2>\nvoid multo(ty1 &x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        x=1ll * x * y % MOD;\n}\n  \nlong long int gcd(long long int a, long long int b){\n\tif (a > b){\n\t\tswap(a, b);\n\t}\n\twhile (a){\n\t\tswap(a, b);\n\t\ta %= b;\n\t}\n\treturn b;\n}\nlong long int lcm(long long int a, long long int b){\n\treturn a / gcd(a, b)*b;\n}\nlong long int ppow(long long int i, long long int j){\n\t\tlong long int res = 1LL;\n\t\twhile (j){\n\t\t\tif ((j & 1LL)){\n\t\t\t\tres *= i;\n\t\t\t\tif (res >= MOD){\n\t\t\t\t\tres %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj >>= 1;\n\t\t\ti *= i;\n\t\t\tif (i >= MOD){\n\t\t\t\ti %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\nclass Combination{\n\t\npublic:\n\tvector<long long int> k;\n\tvector<long long int> r;\n\tvoid resize(int N){\n\t\tk.resize(N + 2);\n\t\tr.resize(N + 2);\n\t\tk[0] = 1;\n\t\tfor (int i = 1; i < N+2; i++){\n\t\t\tk[i] = k[i - 1];\n\t\t\tk[i] *= i;\n\t\t\tif (k[i] >= MOD)k[i] %= MOD;\n\t\t}\n\t\tlong long int al = k[k.size() - 1];\n\t\tlong long int iv = ppow(k[k.size() - 1],MOD-2);\n\t\tr[k.size() - 1] = iv;\n\t\tfor (int i = (int)(r.size()) - 2; i >= 0; i--){\n\t\t\tr[i] = r[i + 1] * (i + 1);\n\t\t\tif (r[i] >= MOD){\n\t\t\t\tr[i] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int C(int a, int b){\n\t\tif (a < b)return 0;\n\t\tlong long int up = k[a];\n\t\tlong long int dw = r[b] * r[a - b];\n\t\tdw %= MOD;\n\t\tup *= dw;\n\t\tup %= MOD;\n\t\treturn up;\n\t}\n\tlong long int H(int a, int b){\n\t\treturn C(a + b - 1, b);\n\t}\n\tlong long int catalan_number(int n){\n\t\treturn (C(2 * n, n) + MOD - C(2 * n, n - 1)) % MOD;\n\t}\n};\nCombination C;\n\n#define MAX 200002\nint n;\n\n\nstruct treediameter{\n\t//直径は色々いい性質がある\n\t//中心から(２頂点の場合それをくっつける）同じ距離のびた２つの頂点間が直径\n\t//直径は最大長であることにも注意\n\tconst vector<vector<int> >&g;\n\tint r1,r2;\n\tvector<int> d1,d2;  //両端からのdist\n\tint dia;\n\tvoid dfs(int v,int p,int cur,vector<int> &d){\n\t\td[v]=cur;\n\t\tfor(auto e:g[v])if(e!=p)\n\t\t\tdfs(e,v,cur+1,d);\n\t}\n\ttreediameter(const vector<vector<int> > &gg):g(gg),d1(g.size()),d2(g.size()){\n\t\tdfs(0,-1,0,d1);\n\t\tr1=max_element(d1.begin(),d1.end())-d1.begin();\n\t\tdfs(r1,-1,0,d1);\n\t\tr2=max_element(d1.begin(),d1.end())-d1.begin();\n\t\tdfs(r2,-1,0,d2);\n\t\tdia=d1[r2];\n\t}\n\tvector<int> find_centre(){  //直径の中心をさがす 1頂点 or 2頂点　直径は必ずこれらすべてを通る\n\t\tvector<int> ret;\n\t\tfor(int i=0;i<d1.size();i++){\n\t\t\tif(d1[i]+d2[i]==dia&&abs(d1[i]-d2[i])<=1){\n\t\t\t\tret.push_back(i);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n//treediameter(v)\n\nvector<vector<int> > v;\n\nbool flag[MAX];\n\n//0:none with only one type of operation\n//1:positive without substraction\n// 2: none with mix\nint dp[MAX][3];\nbool us[MAX][3];\nint target;\ninline int dfs(int b,int ty,int pr=-1,int d=0){\n\tif(us[b][ty]){\n\t\treturn dp[b][ty];\n\t}\n\tus[b][ty]=true;\n\tint ava=0;\n\tvector<int> can;\n\tfor(int go:v[b]){\n\t\tif(go==pr||flag[go])continue;\n\t\tava++;\n\t\tcan.push_back(go);\n\t}\n\tassert(d<=target);\n\tif(ava==0){\n\t\t//leaf\n\t\tif(ty==1){\n\t\t\tif(d==target){\n\t\t\t\tdp[b][ty]=1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tdp[b][ty]=0;\n\t\t\treturn 0;\n\t\t}\n\t\tif(ty==0){\n\t\t\tif(d==target){\n\t\t\t\tdp[b][ty]=0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdp[b][ty]=1;\n\t\t\treturn 1;\n\t\t}\n\t\tif(ty==2){\n\t\t\tdp[b][ty]=1;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif(ty==1){\n\t\tif(d){\n\t\t\tfor(int go:can){\n\t\t\t\tauto ret=dfs(go,1,b,d+1);\n\t\t\t\tfor(int goo:can){\n\t\t\t\t\tif(go!=goo){\n\t\t\t\t\t\tmulto(ret,add(dfs(goo,0,b,d+1),mul(2,dfs(goo,2,b,d+1))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddto(dp[b][ty],ret);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int go:can){\n\t\t\t\tauto ret=dfs(go,1,b,d+1);\n\t\t\t\tfor(int goo:can){\n\t\t\t\t\tif(go!=goo){\n\t\t\t\t\t\tmulto(ret,add(mul(2,dfs(goo,0,b,d+1)),mul(1,dfs(goo,2,b,d+1))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddto(dp[b][ty],ret);\n\t\t\t}\n\t\t}\n\t}\n\tif(ty==2){\n\t\tdp[b][ty]=1;\n\t\tfor(int goo:can){\n\t\t\tmulto(dp[b][ty],mul(3,dfs(goo,2,b,d+1)));\n\t\t}\n\t}\n\tif(ty==0){\n\t\tdp[b][ty]=1;\n\t\tfor(int goo:can){\n\t\t\tmulto(dp[b][ty],add(dfs(goo,0,b,d+1),mul(2,dfs(goo,2,b,d+1))));\n\t\t}\n\t}\n\treturn dp[b][ty];\n}\n\nint main(){\n\tcin>>n;\n\tv.resize(n);\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tauto dia=treediameter(v);\n\tauto centre=dia.find_centre();\n\tfor(auto el:centre){\n\t\tflag[el]=true;\n\t}\n\tif(centre.size()==1){\n\t\tint pos=centre[0];\n\t\ttarget=dia.dia/2;\n\t\tlong long int ans=0;\n\t\tfor(int el1:v[pos]){\n\t\t\tfor(int el2:v[pos]){\n\t\t\t\tif(el1!=el2){\n\t\t\t\t\tauto ret=mul(dfs(el1,1,pos,1),dfs(el2,1,pos,1));\n\t\t\t\t\tfor(int el3:v[pos]){\n\t\t\t\t\t\tif(el1!=el3&&el2!=el3){\n\t\t\t\t\t\t\tmulto(ret,add(mul(2,dfs(el3,0,pos,1)),mul(1,dfs(el3,2,pos,1))));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\taddto(ans,ret);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmulto(ans,ppow(2,MOD-2));\n\t\tans%=MOD;\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\telse{\n\t\tcerr<<centre[0]<<\" \"<<centre[1]<<endl;\n\t\ttarget=dia.dia/2;\n\t\tlong long int ans=0;\n\t\tcerr<<target<<\" \"<<dfs(centre[0],1)<<\" \"<<dfs(centre[1],1)<<endl;\n\t\taddto(ans,mul(dfs(centre[0],1),dfs(centre[1],1)));\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ for(auto it : P) { s << \"<\" << it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ for(auto it : P) { s << \"<\" << it.first << \"->\" << it.second << \"> \"; } return s << endl; }\n\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nconst int MOD = 998244353;\nusing mint = Fp<MOD>;\n\nusing Graph = vector<vector<int>>;\nstruct Diameter {\n    vector<int> prev;\n    pair<int,int> DiameterDFS(const Graph &G, int v, int p) {\n        pair<int,int> res(v, 0);\n        for (int i = 0; i < (int)G[v].size(); ++i) {\n            if (G[v][i] == p) continue;\n            pair<int,int> tmp = DiameterDFS(G, G[v][i], v);\n            tmp.second++;\n            if (tmp.second > res.second) res = tmp, prev[G[v][i]] = v;\n        }\n        return res;\n    }\n\n    vector<int> solve(const vector<vector<int> > &G) {\n        prev.assign((int)G.size(), -1);\n        pair<int,int> leaf = DiameterDFS(G, 0, -1);\n        prev.assign((int)G.size(), -1);\n        pair<int,int> t = DiameterDFS(G, leaf.first, -1);\n        vector<int> res;\n        int cur = t.first;\n        while (cur != -1) res.push_back(cur), cur = prev[cur];\n        return res;\n    }\n};\n\nint N;\nGraph G;\n\nvector<int> md;\nvector<mint> ok, ng;\nvoid rec(int v, int p) {\n    vector<int> chs;\n    for (auto ch : G[v]) {\n        if (ch == p) continue;\n        chs.push_back(ch);\n        rec(ch, v);\n        chmax(md[v], md[ch]+1);\n    }\n    if (chs.empty()) {\n        ok[v] = 1; ng[v] = 2;\n        return;\n    }\n    \n    mint all = 3, notall = 1, ngall = 1;\n    for (auto ch : chs) {\n        all *= ok[ch] + ng[ch];\n        if (md[ch] != md[v]-1) notall *= ok[ch] + ng[ch];\n        else ngall *= ng[ch];\n    }\n    ok[v] = 0;\n    for (auto ch : chs) {\n        if (md[ch] != md[v]-1) continue;\n        mint tmp = ngall * ok[ch] / ng[ch];\n        ok[v] += tmp;\n    }\n    ok[v] *= notall;\n    ng[v] = all - ok[v];\n\n    //cout << v+1 << \": \" << ok[v] << \", \" << ng[v] << endl;\n}\n\nmint solve() {\n    Diameter diam;\n    auto di = diam.solve(G);\n    int max_depth = (int)di.size()/2 - 1;\n\n    md.assign(N, 0); ok.assign(N, 0); ng.assign(N, 0);\n    vector<int> v_di, v_ndi;\n    if (di.size() % 2 == 1) {\n        int center = di[di.size() / 2];\n        for (auto v : G[center]) {\n            rec(v, center);\n            if (md[v] == max_depth) v_di.push_back(v);\n            else v_ndi.push_back(v);\n        }\n    }\n    else {\n        int u = di[(int)di.size()/2-1], v = di[(int)di.size()/2];\n        rec(u, v), rec(v, u);\n        v_di.push_back(u), v_di.push_back(v);\n    }\n    \n    mint notres = 1;\n    for (auto v : v_ndi) notres *= ok[v] + ng[v];\n    mint ngall = 1;\n    for (auto v : v_di) ngall *= ng[v];\n    mint okfact1 = 0, okfact2 = 0;\n    for (auto v : v_di) {\n        okfact1 += ok[v] / ng[v];\n        okfact2 += (ok[v] / ng[v]) * (ok[v] / ng[v]);\n    }\n    mint fact = (okfact1 * okfact1 - okfact2) / 2;\n    mint deepres = ngall * fact;\n\n    /*\n    COUT(notres);\n    COUT(ngall);\n    COUT(okfact1);\n    COUT(okfact2);\n    COUT(fact);\n    COUT(deepres);\n    */\n    return notres * deepres;\n}\n\nint main() {\n    while (cin >> N) {\n        G.assign(N, vector<int>());\n        for (int i = 0; i < N-1; ++i) {\n            int a, b; cin >> a >> b; --a, --b;\n            G[a].push_back(b);\n            G[b].push_back(a);\n        }\n        cout << solve() << endl;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nstruct edge{int to, cost, id;};\n\nclass Graph\n{\npublic:\n    int N;\n    vector<vector<edge>> G;\n    bools f;\n    mmat dp;\n\n    Graph(int N): N(N){\n        G = vector<vector<edge>>(N, vector<edge>(0));\n        f = bools(N, false);\n        dp = mmat(N, mvec(3, 0));\n    }\n\n    void add_Directed_edge(int from, int to, int cost = 1, int id = 0){\n        G[from].push_back(edge({to, cost, id}));\n    }\n\n    void add_Undirected_edge(int v1, int v2, int cost = 1, int id = 0){\n        add_Directed_edge(v1, v2, cost, id);\n        add_Directed_edge(v2, v1, cost, id);\n    }\n\n    //calculate diameter of a Tree\n    void dfs_for_calcdist(int v, int p, int c, vec &dist){\n        if(p != -1) dist[v] = dist[p] + c;\n        for(auto e: G[v]) if(e.to != p) dfs_for_calcdist(e.to, v, e.cost, dist);\n    } \n\n    int diameter(int &v1, int &v2, int s = 0){\n        vec dist(N, 0);\n        dfs_for_calcdist(s, -1, -1, dist);\n        v1 = distance(dist.begin(), max_element(dist.begin(), dist.end()));\n        fill(dist.begin(), dist.end(), 0);\n        dfs_for_calcdist(v1, -1, -1, dist);\n        auto amax = max_element(dist.begin(), dist.end());\n        v2 = distance(dist.begin(), amax);\n        return *amax;\n    }\n\n    void dfs(int v, int p){\n\n        if(f[v]) dp[v][1] = 1;\n        else dp[v][0] = 1;\n\n        if(p != -1){\n            for(auto e: G[v]) if(e.to != p){\n                dfs(e.to, v);\n                mvec tmp(3, 0);\n                REP(j, 3){\n                    tmp[j] += dp[v][j] * (dp[e.to][0] * 3 + dp[e.to][1] * 2);\n                    tmp[min(j + 1, 2LL)] += dp[v][j] * dp[e.to][1];\n                }\n                dp[v] = tmp;\n            }\n        }else{\n            dp[v] = mvec(4, 0);\n            dp[v][0] = 1;\n            for(auto e: G[v]) if(e.to != p){\n                dfs(e.to, v);\n                mvec tmp(4, 0);\n                REP(j, 4){\n                    tmp[j] += dp[v][j] * (dp[e.to][0] * 3 - dp[e.to][1]);\n                    if((j & 1) == 0) tmp[j | 1] += dp[v][j] * dp[e.to][1];\n                    if((j & 2) == 0) tmp[j | 2] += dp[v][j] * dp[e.to][1];\n                }\n                dp[v] = tmp;\n            }\n        }\n    }\n\n};\n\n\nsigned main(){\n\n    int N; cin >> N;\n    Graph G(N);\n    REP(i, N - 1){\n        int a, b; cin >> a >> b;\n        G.add_Undirected_edge(a - 1, b - 1);\n    }\n\n    int v1, v2;\n    int R = G.diameter(v1, v2);\n    vec d1(N, 0), d2(N, 0);\n    G.dfs_for_calcdist(v1, -1, -1, d1);\n    G.dfs_for_calcdist(v2, -1, -1, d2);\n\n    vec center;\n    REP(i, N) if(d1[i] + d2[i] == R && llabs(d1[i] - d2[i]) <= 1) center.pb(i);\n    \n    fill(all(d1), 0);\n    fill(all(d2), 0);\n    mint ans;\n    if(SZ(center) == 1){\n        G.dfs_for_calcdist(center[0], -1, -1, d1);\n        REP(i, N) if(d1[i] == R / 2) G.f[i] = true;\n\n        G.dfs(center[0], -1);\n        ans = G.dp[center[0]][3] / 2;\n\n    }else{\n        G.dfs_for_calcdist(center[0], -1, -1, d1);\n        G.dfs_for_calcdist(center[1], -1, -1, d2);\n        REP(i, N) if(min(d1[i], d2[i]) == R / 2) G.f[i] = true;\n\n        G.dfs(center[0], center[1]);\n        G.dfs(center[1], center[0]);\n        ans = G.dp[center[0]][1] * G.dp[center[1]][1];\n    }\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[202020];\nconst ll mo=998244353;\nll dp[202020][3][3];\n\npair<int,int> farthest(int cur,int pre,int d,vector<int>& D) {\n\tD[cur]=d;\n\tpair<int,int> r={d,cur};\n\tFORR(e,E[cur]) if(e!=pre) r=max(r, farthest(e,cur,d+1,D));\n\treturn r;\n}\n\npair<int,vector<int>> diameter() { // diameter,center\n\tvector<int> D[2];\n\tD[0].resize(N);\n\tD[1].resize(N);\n\tauto v1=farthest(0,0,0,D[0]);\n\tauto v2=farthest(v1.second,v1.second,0,D[0]);\n\tfarthest(v2.second,v2.second,0,D[1]);\n\tpair<int,vector<int>> R;\n\tR.first = v2.first;\n\t//重心を取る場合\n\tfor(int i=N-1;i>=0;i--) if(D[0][i]+D[1][i]==R.first && abs(D[0][i]-D[1][i])<=1) R.second.push_back(i);\n\n\treturn R;\n}\n\nvoid dfs(int cur,int pre,int lef) {\n\tif(lef==0) {\n\t\tdp[cur][1][1]=1;\n\t}\n\telse {\n\t\tdp[cur][0][0]=1;\n\t}\n\t\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\tdfs(e,cur,lef-1);\n\t\tll to[3][3]={};\n\t\tint a1,a2,b1,b2;\n\t\tFOR(a1,3) FOR(a2,3) FOR(b1,3) FOR(b2,3) {\n\t\t\t// +1\n\t\t\tto[min(a1+b1,2)][a2]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t\t// 0\n\t\t\tto[a1][a2]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t\t// -1\n\t\t\tto[a1][min(a2+b2,2)]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t}\n\t\t\n\t\tFOR(a1,3) FOR(a2,3) dp[cur][a1][a2]=to[a1][a2]%mo;\n\t}\n\t\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tauto R=diameter();\n\tif(R.second.size()==1) {\n\t\tx=R.second[0];\n\t\tdfs(x,-1,R.first/2);\n\t\tcout<<dp[x][1][1]*((mo+1)/2)%mo<<endl;\n\t}\n\telse {\n\t\tx=R.second[0];\n\t\ty=R.second[1];\n\t\tdfs(x,y,R.first/2);\n\t\tdfs(y,x,R.first/2);\n\t\tll ret=(dp[x][0][1]+dp[x][1][1])*dp[y][1][0]%mo;\n\t\tret+=(dp[y][0][1]+dp[y][1][1])*dp[x][1][0]%mo;\n\t\tret+=(dp[x][1][1]*dp[y][1][1])*4%mo;\n\t\tcout<<ret%mo*((mo+1)/2)%mo<<endl;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 2e5 + 5, mod = 998244353;\n\ninline int gi()\n{\n\tchar c = getchar();\n\twhile (c < '0' || c > '9') c = getchar();\n\tint sum = 0;\n\twhile ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();\n\treturn sum;\n}\n\ninline void inc(int &a, int b) {a += b; if (a >= mod) a -= mod;}\n\nint n, rt, len, fa[maxn], ch[maxn];\n\nstruct edge\n{\n\tint to, next;\n} e[maxn * 2];\nint h[maxn], tot;\nint md[maxn], f[maxn][3][3], g[3][3];\n\ninline void add(int u, int v)\n{\n\te[++tot] = (edge) {v, h[u]}; h[u] = tot;\n\te[++tot] = (edge) {u, h[v]}; h[v] = tot;\n}\n\nvoid dfs1(int u, int d)\n{\n\tif (d > len) rt = u, len = d;\n\tmd[u] = d;\n\tfor (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n\t\tif (v != fa[u]) fa[v] = u, dfs1(v, d + 1), md[u] = max(md[u], md[v]);\n}\n\nvoid dfs2(int u, int d)\n{\n\t(md[u] == d ? f[u][1][1] : f[u][0][0]) = 1;\n\tfor (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n\t\tif (v != fa[u]) {\n\t\t\tfa[v] = u; dfs2(v, d + 1);\n\t\t\tmemset(g, 0, sizeof(g));\n\t\t\tfor (int a = 0; a <= 2; ++a)\n\t\t\t\tfor (int b = 0; b <= 2; ++b)\n\t\t\t\t\tif (f[u][a][b])\n\t\t\t\t\t\tfor (int c = 0; c <= 2; ++c)\n\t\t\t\t\t\t\tfor (int d = 0; d <= 2; ++d)\n\t\t\t\t\t\t\t\tif (f[v][c][d])\n\t\t\t\t\t\t\t\t\tfor (int t = -1; t <= 1; ++t)\n\t\t\t\t\t\t\t\t\t\tinc(g[min(2, a + (md[v] == md[u] && t == 1) * c)][min(2, b + (md[v] == md[u] && t == -1) * d)], (ll)f[u][a][b] * f[v][c][d] % mod);\n\t\t\tmemcpy(f[u], g, sizeof(f[u]));\n\t\t}\n}\n\nint main()\n{\n\tn = gi();\n\tfor (int i = 1; i < n; ++i) add(gi(), gi());\n\n\tdfs1(1, 0);\n\tfa[rt] = 0; len = 0; dfs1(rt, 0);\n\tfor (int i = 0, x = rt; x; x = fa[x]) ch[i++] = x;\n\n\tif (~len & 1) {\n\t\tint x = ch[len >> 1];\n\t\tfa[x] = 0, dfs1(x, 0);\n\t\tdfs2(x, 0);\n\t\tprintf(\"%lld\\n\", (ll)f[x][1][1] * (mod + 1) / 2 % mod);\n\t}\n\telse {\n\t\tint x = ch[len >> 1], y = ch[len + 1 >> 1];\n\t\tfa[x] = y; fa[y] = x;\n\t\tdfs1(x, 0); dfs2(x, 0);\n\t\tdfs1(y, 0); dfs2(y, 0);\n\t\tprintf(\"%lld\\n\", ((ll)f[x][1][0] + f[x][1][1] + f[x][1][2]) * ((ll)f[y][1][0] + f[y][1][1] + f[y][1][2]) % mod);\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\ndouble startTime;\ndouble getCurrentTime() {\n\treturn ((double)clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst ll MOD = (ll)998244353;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\n\nconst int N = 200200;\nint n;\nvector<int> g[N];\nll ANS;\nint dist[N];\nint q[N];\nint par[N];\nint topQ;\nint D;\nll dp[N][3];\n\nvoid BFS(int v) {\n\tfor (int i = 0; i < n; i++)\n\t\tdist[i] = N;\n\tdist[v] = 0;\n\ttopQ = 0;\n\tq[topQ++] = v;\n\tfor (int i = 0; i < topQ; i++) {\n\t\tv = q[i];\n\t\tfor (int u : g[v]) {\n\t\t\tif (dist[u] <= dist[v] + 1) continue;\n\t\t\tdist[u] = dist[v] + 1;\n\t\t\tpar[u] = v;\n\t\t\tq[topQ++] = u;\n\t\t}\n\t}\n}\n\nvoid dfs(int v, int p) {\n\tdp[v][0] = dp[v][1] = dp[v][2] = 0;\n\tif ((int)g[v].size() == 1) {\n\t\tdp[v][(int)(dist[v] == D)] = 1;\n\t\t//dp[v][0] = add(dp[v][0], 2);\n\t\treturn;\n\t}\n\tdp[v][0] = 1;\n\tll inner[3];\n\tfor (int u : g[v]) {\n\t\tif (u == p) continue;\n\t\tinner[0] = inner[1] = inner[2] = 0;\n\t\tdfs(u, v);\n\t\tll w[2];\n\t\tw[0] = w[1] = 0;\n\t\tw[0] = add(mult(3, dp[u][0]), mult(2, add(dp[u][2], dp[u][1])));\n\t\tw[1] = dp[u][1];\n\t\tfor (int x = 0; x < 3; x++)\n\t\t\tfor (int y = 0; y < 2; y++) {\n\t\t\t\t\tinner[min(2, x + y)] = add(inner[min(2, x + y)], mult(dp[v][x], w[y]));\n\t\t\t}\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tdp[v][i] = inner[i];\n\t}\n}\n\nvoid solveVertex(int v) {\n\teprintf(\"solveVertex %d\\n\", v);\n\tD /= 2;\n\tBFS(v);\n\tll inner[2][3];\n\tfor (int i = 0; i < 2; i++)\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tinner[i][j] = 0;\n\tinner[0][0] = 1;\n\tfor (int u : g[v]) {\n\t\tdfs(u, v);\n\t\tll w[2];\n\t\tw[0] = w[1] = 0;\n\t\tw[0] = add(mult(3, dp[u][0]), add(mult(2, dp[u][2]), dp[u][1]));\n\t\tw[1] = dp[u][1];\n\t\teprintf(\"%lld %lld\\n\", w[0], w[1]);\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tinner[1][i] = 0;\n\t\tfor (int x = 0; x < 3; x++)\n\t\t\tfor (int y = 0; y < 2; y++)\n\t\t\t\tif (x + y < 3)\n\t\t\t\t\tinner[1][x + y] = add(inner[1][x + y], mult(inner[0][x], w[y]));\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tinner[0][i] = inner[1][i];\n\t}\n\tll ans = inner[0][2];\n\tprintf(\"%lld\\n\", ans);\n}\nvoid solveEdge(int v, int u) {\n\teprintf(\"solveEdge %d %d\\n\", v, u);\n\tD /= 2;\n\tll ans = 1;\n\tfor (int k = 0; k < 2; k++) {\n\t\tBFS(v);\n\t\tdfs(v, u);\n\t\tans = mult(ans, dp[v][1]);\n\t\tswap(v, u);\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tstartTime = (double)clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\n\tBFS(0);\n\tint V = q[n - 1];\n\tBFS(V);\n\tint U = q[n - 1];\n\tD = dist[U];\n\n\tif (D & 1) {\n\t\tint v = U;\n\t\tfor (int i = 0; i < D / 2; i++)\n\t\t\tv = par[v];\n\t\tsolveEdge(v, par[v]);\n\t} else {\n\t\tint v = U;\n\t\tfor (int i = 0; i < D / 2; i++)\n\t\t\tv = par[v];\n\t\tsolveVertex(v);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include <complex>\nusing namespace std;\n//long long p = 998244353;\nlong long p = 1000000007;\n#define int long long\n#define ll long long\n#define vel vector<ll>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\nvel kai;\nvel inv_kai;\nint rui(int a, int n, int mod) {\n\tif (n == 0) { return 1 % mod; }\n\tint x = rui(a, n / 2, mod);\n\tx *= x; x %= mod;\n\tif (n % 2 == 1) { x *= a; x %= mod; }\n\treturn x;\n}\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(ll x, ll y) {\n\tx = abs(x); y = abs(y);\n\treturn x * y / gcd(x, y);\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvoid make_kai(int max_kai) {\n\tkai = vel(max_kai, 1);\n\tinv_kai = kai;\n\trep(i, max_kai - 1) {\n\t\tkai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n\t\tinv_kai[i + 1] = modinv(kai[i + 1], p);\n\t}\n}\nint com(int n, int r) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\tint ans = (kai[n] * inv_kai[r]) % p;\n\treturn (ans * inv_kai[n - r]) % p;\n}\nvel uni(vel x) {\n\tif (x.size() == 0) { return x; }\n\tsor(x);\n\tint n = x.size();\n\tvel ans(1, x[0]);\n\tfor (int j = 1; j < n; j++) {\n\t\tif (x[j - 1] != x[j]) { ans.push_back(x[j]); }\n\t}\n\tx = ans;\n\treturn x;\n}\nvoid pr(vel& v) {\n\tint n = v.size();\n\tif (n != 0) {\n\t\tcout << v[0];\n\t\trep(i, n - 1) {\n\t\t\tcout << \" \" << v[i + 1];\n\t\t}\n\t\tcout << endl;\n\t}\n}\nvel dijk(V<V<pin>>& way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nvel mul(vel& a, vel& b) {\n\tint n = a.size();\n\tint m = b.size();\n\tvel ans(n + m - 1, 0);\n\trep(i, n) {\n\t\trep(j, m) {\n\t\t\tans[i + j] += a[i] * b[j];\n\t\t\tans[i + j] %= p;\n\t\t}\n\t}\n\treturn ans;\n}\nvel rui_p(vel& a, int n) {\n\tif (n == 0) { return { 1 }; }\n\tvel qans = rui_p(a, n / 2);\n\tqans = mul(qans, qans);\n\tif (n % 2 == 1) {\n\t\tqans = mul(qans, a);\n\t}\n\treturn qans;\n}\nbool is_prime(int n) {\n\tif (n == 0 || n == 1) { return false; }\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) { return false; }\n\t}\n\treturn true;\n}\n#define bs bitset<50>\nvoid per(int& ans) {\n\tans %= p;\n\tif (ans < 0) { ans += p; }\n}\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define mat V<V<pin>>\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nvvel disj_max(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = max(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\treturn min(dv[i][l], dv[i][r - (1 << i)]);\n}\nint find_max(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\treturn max(dv[i][l], dv[i][r - (1 << i)]);\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nvvel dbl(vel& v) {\n\tvvel ans(20, vel(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j] = ans[i][ans[i][j]];\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, vvel& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\ts = pa[i][s];\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\ts = pa[i][s];\n\t\t\tt = pa[i][t];\n\t\t}\n\t}\n\tif (s != t) {\n\t\ts = pa[0][s];\n\t}\n\treturn s;\n}\nint sz = 1024 * 1024;\nvel bit(2 * sz, 0);\nvel bit2(2 * sz, 0);\nvoid add(int a, int w) {\n\ta += sz; bit[a] += w; bit2[a] = bit[a]; a /= 2;\n\twhile (a != 0) {\n\t\tbit[a] += w;\n\t\tbit2[a] = max(bit2[2 * a], bit[2 * a] + max(bit2[2 * a + 1], (int)0));\n\t\ta /= 2;\n\t}\n}\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\nint modpow(int a, int n) {\n\tif (n == 0) { return 1; }\n\tint m = n / 2;\n\tint x = modpow(a,n / 2);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\nsigned main() {\n\tint n; cin >> n;\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tint val = 0; int v = 0;\n\trep(i, n) {\n\t\tif (val < dist[i]) { v = i; val = dist[i]; }\n\t}\n\tdist = dijk(way, v, n + 1);\n\tint d1 = 0;\n\trep(i, n) { mmax(d1, dist[i]); }\n\tint m = 0;\n\trep(i, n) {\n\t\tif (dist[i] == d1) { m++; }\n\t}\n\tp = 998244353;\n\tif (m == 1) {\n\t\tcout << modpow(3, n - d1 - 1) << endl;\n\t}\n\telse {\n\t\tmake_kai(5000000);\n\t\tint k = d1 / 2;\n\t\tm++;\n\t\tint x = modinv(modpow(3, k), p);\n\t\tint ans = 0;\n\t\tfor (int i = 2; i <= m; i++) {\n\t\t\tif (i % 2 == 0) { ans += modpow(x, i) * com(m, i); }\n\t\t\telse{ans-= modpow(x, i) * com(m, i);}\n\t\t\tans %= p;\n\t\t}\n\t\tint qans = 0;\n\t\tfor (int i = 3; i <= m; i++) {\n\t\t\tif (i % 2 == 0) { qans -= modpow(x, i) * com(m, i); }\n\t\t\telse { qans += modpow(x, i) * com(m, i); }\n\t\t\tqans %= p;\n\t\t}\n\t\tqans *= m; qans %= p;\n\t\tans -= qans;\n\t\tans *= modinv(3, p); ans %= p;\n\t\tans *= modpow(3, n); ans %= p;\n\t\tans += p; ans %= p;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "う　し　た　ぷ　に　き　あ　く　ん　笑"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nconst char lf = '\\n';\n\nnamespace ae86\n{\n\tconst int bufl = 1 << 15;\n\n\tchar buf[bufl],*s=buf,*t=buf;\n\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\n\tinline int ty()\n\t{\n\t\tint a=0;int b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 200007 , mo = 998244353;\n\ntemplate<typename T1,typename T2> inline T1 ad(T1 &a,T2 b){return a=a+b>=mo?a+b-mo:a+b;}\ntemplate<typename T1,typename T2> inline T1 dl(T1 &a,T2 b){return a=a>=b?a-b:a-b+mo;}\ntemplate<typename T1,typename T2> inline T1 add(T1 a,T2 b){return a+b>=mo?a+b-mo:a+b;}\ntemplate<typename T1,typename T2> inline T1 del(T1 a,T2 b){return a>=b?a-b:a-b+mo;}\n\nlint powa(lint a,lint t)\n{\n\tlint b=1;a=(a+mo)%mo;\n\twhile(t){if(t&1)b=b*a%mo;a=a*a%mo,t>>=1;}\n\treturn b;\n}\n\ninline lint inva(lint a)\n{\n\treturn powa(a,mo-2);\n}\n\nvector<int> e[_];\n\nint n,fa[_]={0},rt=0,mxdep=0;\n\nvoid dfs(int x,int ff,int dep)\n{\n\tfa[x]=ff;\n\tif(dep>mxdep)mxdep=dep,rt=x;\n\tfor(auto b:e[x])if(b!=ff)dfs(b,x,dep+1);\n}\n\nint ps[_]={0},lps=0;\nlint f[_][3][3]={0};\n\nvoid dfs2(int x,int ff,int dep)\n{\n\tfa[x]=ff;\n\tmemset(f[x],0,sizeof(f[x]));\n\tif(dep==lps/2)f[x][1][1]=1;\n\telse f[x][0][0]=1;\n\n\tfor(auto b:e[x])\n\t{\n\t\tif(b==ff)continue;\n\t\tdfs2(b,x,dep+1);\n\t\tlint sf[3][3];memset(sf,0,sizeof(sf));\n\t\tfor(int i=0;i<3;i++)\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\tfor(int p=0;p<3;p++)\n\t\t\t\t\tfor(int q=0;q<3;q++)\n\t\t\t\t\t\tfor(int r=-1;r<=1;r++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint pp=r==1?p:0,qq=r==-1?q:0;\n\t\t\t\t\t\t\tpp=min(2,pp+i),qq=min(2,qq+j);\n\t\t\t\t\t\t\tad(sf[pp][qq],f[x][i][j]*f[b][p][q]%mo);\n\t\t\t\t\t\t}\n\t\tmemcpy(f[x],sf,sizeof(sf));\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(0),cout.tie(nullptr);\n\n\tn=ty();\n\tfor(int i=1,a,b;i<n;i++)a=ty(),b=ty(),e[a].emplace_back(b),e[b].emplace_back(a);\n\n\tdfs(1,0,1),mxdep=0,dfs(rt,0,1);\n\tfor(int i=rt;i;i=fa[i])ps[++lps]=i;\n\n\tif(lps&1)\n\t{\n\t\tint mid=ps[lps/2+1];\n\t\tdfs2(mid,0,0);\n\t\tcout<<f[mid][1][1]*inva(2)%mo<<lf;\n\t\treturn 0;\n\t}\n\t\n\tint ll=ps[lps/2],rr=ps[lps/2+1];\n\tdfs2(ll,rr,1),dfs2(rr,ll,1);\n\tcout<<add(add(f[ll][1][0],f[ll][1][1]),f[ll][1][2])\n\t\t*add(add(f[rr][0][1],f[rr][1][1]),f[rr][2][1])%mo<<lf;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\ndouble startTime;\ndouble getCurrentTime() {\n\treturn ((double)clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst ll MOD = (ll)998244353;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\n\nconst int N = 200200;\nint n;\nvector<int> g[N];\nll ANS;\nint dist[N];\nint q[N];\nint par[N];\nint topQ;\nint D;\nll dp[N][3];\n\nvoid BFS(int v) {\n\tfor (int i = 0; i < n; i++)\n\t\tdist[i] = N;\n\tdist[v] = 0;\n\ttopQ = 0;\n\tq[topQ++] = v;\n\tfor (int i = 0; i < topQ; i++) {\n\t\tv = q[i];\n\t\tfor (int u : g[v]) {\n\t\t\tif (dist[u] <= dist[v] + 1) continue;\n\t\t\tdist[u] = dist[v] + 1;\n\t\t\tpar[u] = v;\n\t\t\tq[topQ++] = u;\n\t\t}\n\t}\n}\n\nvoid dfs(int v, int p) {\n\tdp[v][0] = dp[v][1] = dp[v][2] = 0;\n\tif ((int)g[v].size() == 1) {\n\t\tdp[v][(int)(dist[v] == D)] = 1;\n\t\t//dp[v][0] = add(dp[v][0], 2);\n\t\treturn;\n\t}\n\tdp[v][0] = 1;\n\tll inner[3];\n\tfor (int u : g[v]) {\n\t\tif (u == p) continue;\n\t\tinner[0] = inner[1] = inner[2] = 0;\n\t\tdfs(u, v);\n\t\tll w[2];\n\t\tw[0] = w[1] = 0;\n\t\tw[0] = add(mult(3, dp[u][0]), mult(2, add(dp[u][2], dp[u][1])));\n\t\tw[1] = dp[u][1];\n\t\tfor (int x = 0; x < 3; x++)\n\t\t\tfor (int y = 0; y < 2; y++) {\n\t\t\t\t\tinner[min(2, x + y)] = add(inner[min(2, x + y)], mult(dp[v][x], w[y]));\n\t\t\t}\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tdp[v][i] = inner[i];\n\t}\n}\n\nvoid solveVertex(int v) {\n\teprintf(\"solveVertex %d\\n\", v);\n\tD /= 2;\n\tBFS(v);\n\tll inner[2][3];\n\tfor (int i = 0; i < 2; i++)\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tinner[i][j] = 0;\n\tinner[0][0] = 1;\n\tfor (int u : g[v]) {\n\t\tdfs(u, v);\n\t\tll w[2];\n\t\tw[0] = w[1] = 0;\n\t\tw[0] = add(mult(3, dp[u][0]), add(dp[u][2], dp[u][1]));\n\t\tw[1] = dp[u][1];\n\t\teprintf(\"%lld %lld\\n\", w[0], w[1]);\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tinner[1][i] = 0;\n\t\tfor (int x = 0; x < 3; x++)\n\t\t\tfor (int y = 0; y < 2; y++)\n\t\t\t\tif (x + y < 3)\n\t\t\t\t\tinner[1][x + y] = add(inner[1][x + y], mult(inner[0][x], w[y]));\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tinner[0][i] = inner[1][i];\n\t}\n\tll ans = inner[0][2];\n\tprintf(\"%lld\\n\", ans);\n}\nvoid solveEdge(int v, int u) {\n\teprintf(\"solveEdge %d %d\\n\", v, u);\n\tD /= 2;\n\tll ans = 1;\n\tfor (int k = 0; k < 2; k++) {\n\t\tBFS(v);\n\t\tdfs(v, u);\n\t\tans = mult(ans, dp[v][1]);\n\t\tswap(v, u);\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tstartTime = (double)clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\n\tBFS(0);\n\tint V = q[n - 1];\n\tBFS(V);\n\tint U = q[n - 1];\n\tD = dist[U];\n\n\tif (D & 1) {\n\t\tint v = U;\n\t\tfor (int i = 0; i < D / 2; i++)\n\t\t\tv = par[v];\n\t\tsolveEdge(v, par[v]);\n\t} else {\n\t\tint v = U;\n\t\tfor (int i = 0; i < D / 2; i++)\n\t\t\tv = par[v];\n\t\tsolveVertex(v);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n#define resz resize\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define sort_by(x, y) sort(all(x), [&](const auto& a, const auto& b) { return y; })\n\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpll = vector<pll>;\nusing vvpll = vector<vpll>;\nusing vpdd = vector<pdd>;\nusing vvpdd = vector<vpdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\ntemplate<typename T> using max_heap = priority_queue<T>;\ntemplate<typename T> using min_heap = priority_queue<T, vector<T>, greater<T>>;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const deque<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T, bool pretty = true> void prContain(const T& x) {\n        if (pretty) pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?pretty?\", \":\" \":\"\",a), fst = 0;\n        if (pretty) pr(\"}\");\n    }\n    template<class T> void pc(const T& x) { prContain<T, false>(x); pr(\"\\n\"); }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const deque<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __numeric {\n    template<typename T>\n    typename enable_if<is_integral<T>::value, T>::type floor(T n, T d) {\n        assert(d != 0);\n        if (d < 0) tie(n, d) = mp(-n, -d);\n        return n / d - ((n < 0) && (n % d));\n    }\n    template<typename T>\n    typename enable_if<is_integral<T>::value, T>::type ceil(T n, T d) {\n        assert(d != 0);\n        if (d < 0) tie(n, d) = mp(-n, -d);\n        return n / d + ((n > 0) && (n % d));\n    }\n};\nusing namespace __numeric;\n\nnamespace __algorithm {\n    template<typename T> void dedup(vector<T>& v) {\n        sort(all(v)); v.erase(unique(all(v)), v.end());\n    }\n    template<typename T> typename vector<T>::iterator find(vector<T>& v, const T& x) {\n        auto it = lower_bound(all(v), x); return it != v.end() && *it == x ? it : v.end();\n    }\n    template<typename T> size_t index(vector<T>& v, const T& x) {\n        auto it = find(v, x); assert(it != v.end() && *it == x); return it - v.begin();\n    }\n    template<typename C, typename T, typename OP> vector<T> prefixes(const C& v, T id, OP op) {\n        vector<T> r(sz(v)+1, id); F0R (i, sz(v)) r[i+1] = op(r[i], v[i]); return r;\n    }\n    template<typename C, typename T, typename OP> vector<T> suffixes(const C& v, T id, OP op) {\n        vector<T> r(sz(v)+1, id); F0Rd (i, sz(v)) r[i] = op(v[i], r[i+1]); return r;\n    }\n}\nusing namespace __algorithm;\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-parameter\"\nstruct monostate {\n    friend istream& operator>>(istream& is, const monostate& ms) { return is; }\n    friend ostream& operator<<(ostream& os, const monostate& ms) { return os; }\n    friend monostate operator+(const monostate& a, const monostate& b) { return a; }\n} ms;\n#pragma GCC diagnostic pop\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        cout << fixed << setprecision(15);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\n// tree {{{\nstruct edge {\n    int uv; //int id;\n    edge (int _uv = 0, __attribute__((unused))monostate _ = ms) : uv(_uv) {}\n    int operator()(int u) const { assert(uv); return uv ^ u; }\n    monostate& wt() const { return ms; }\n    struct path { int len;\n        path operator+(const path& p) const { return {len+p.len}; }\n    }; explicit operator path() { return {1}; }\n};\ntemplate<typename W> struct wedge : edge {\n    mutable W w;\n    wedge (int _uv = 0, W _w = {}) : edge(_uv), w(_w) {}\n    W& wt() const { return w; }\n    struct path { int len; W wt;\n        path operator+(const path& p) { return {len+p.len, wt+p.wt}; }\n    }; explicit operator path() { return {1, w}; }\n};\n\nenum INPUT_FORMAT { EDGE_LIST, PARENT_LIST };\ntemplate<typename E> struct tree {\n    int V, root;\n    vector<vector<E>> nbrs, children;\n\n    vi par, depth, subt_sz;\n    vi preorder, reverse_preorder;\n\n    tree() : V(0), root(-1) {}\n    tree(int _V, int _root) : V(_V), root(_root), nbrs(V) {}\n\n    const E& up_edge(int u) const {\n        assert(u != root);\n        return nbrs[u].front();\n    }\n\n    void add_edge(int u, int v, E e = {}) {\n        assert(0 <= u && u < V && 0 <= v && v < V);\n        e.uv = u ^ v;\n        nbrs[u].pb(e);\n        nbrs[v].pb(e);\n    }\n\n    template<INPUT_FORMAT FMT = EDGE_LIST, bool FIRST_INDEX = 1>\n    friend void re(tree& t) {\n        assert(t.V > 0);\n        for (int i = 0; i < t.V - 1; i++) {\n            int u, v;\n            re(u), u -= FIRST_INDEX;\n            if (FMT == PARENT_LIST) v = i+1;\n            else re(v), v -= FIRST_INDEX;\n            E e{}; re(e.wt()); // e.id = i\n            t.add_edge(u, v, e);\n        }\n        t.init();\n    }\n\n    void init() {\n        children.resz(V), par.resz(V), depth.resz(V), subt_sz.resz(V);\n        par[root] = -1, depth[root] = 0;\n\n        traverse(root);\n        for (int u = 0; u < V; u++) {\n            sort_by(nbrs[u], subt_sz[a(u)] > subt_sz[b(u)]);\n            children[u].clear();\n            copy(nbrs[u].begin() + (u != root), nbrs[u].end(), back_inserter(children[u]));\n        }\n\n        preorder.clear(), preorder.reserve(V), build_preorder(root);\n        reverse_preorder = preorder, reverse(all(reverse_preorder));\n    }\n    void reroot(int _root) { root = _root; init(); }\n\n    void traverse(int u) {\n        subt_sz[u] = 1;\n        for (E e : nbrs[u]) {\n            int v = e(u);\n            if (v == par[u]) continue;\n            par[v] = u;\n            depth[v] = depth[u] + 1;\n            traverse(v);\n            subt_sz[u] += subt_sz[v];\n        }\n    }\n\n    void build_preorder(int u) {\n        preorder.pb(u);\n        for (E e : children[u]) build_preorder(e(u));\n    }\n\n    friend void pr(const tree& t) {\n        pr(\"{V=\", t.V, \" root=\", t.root, \" |\");\n        for (int u = 0; u < t.V; u++) {\n            pr(\" \", u, \"--{\");\n            for (E e : t.children[u])\n                pr(\"(ch=\", e(u), \" wt=\", e.wt(), \")\");\n            pr(\"}\");\n        }\n        pr(\"}\");\n    }\n};\n// }}}\n\n// modnum {{{\nusing v_t = int;\nusing vv_t = ll;\ntemplate<v_t MOD> struct modnum {\n    v_t v;\n    modnum() : v(0) {}\n    modnum(vv_t _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator v_t() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { vv_t w; i >> w; n = modnum(w); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return x % m;\n#endif\n        // x must be less than 2^32 * m so that x / m fits in a 32-bit integer.\n        unsigned x_high = x >> 32, x_low = (unsigned) x, quot, rem;\n        asm(\"divl %4\\n\"\n                : \"=a\" (quot), \"=d\" (rem)\n                : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = fast_mod(vv_t(v) * o.v); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(vv_t e) const {\n        if (e < 0) return 1 / this->pow(-e);\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        v_t g = MOD, x = 0, y = 1;\n        for (v_t r = v; r != 0; ) {\n            v_t q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static constexpr v_t totient() {\n        v_t tot = MOD, tmp = MOD;\n        for (v_t p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static v_t primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        v_t tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (v_t p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (v_t r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (v_t p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static v_t discrete_log(modnum v) {\n        static const v_t M = ceil(sqrt(MOD));\n        static unordered_map<v_t, v_t> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (v_t i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (v_t i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum unity_root(int deg) {\n        assert(totient() % deg == 0);\n        return generator().pow(totient() / deg);\n    }\n\n    static modnum unity_root(int deg, int pow) {\n        static vector<modnum> table{ 0, 1 };\n        while (sz(table) <= deg) {\n            modnum w = unity_root(sz(table));\n            for (int i = sz(table)/2, s = sz(table); i < s; i++) {\n                table.push_back(table[i]);\n                table.push_back(table[i] * w);\n            }\n        }\n        return table[deg + (pow < 0 ? deg + pow : pow)];\n    }\n\n    static modnum factorial(int n) {\n        static vector<modnum> fact = {1};\n        assert(n >= 0);\n        if (sz(fact) <= n) {\n            int had = sz(fact);\n            fact.resize(n + 1);\n            for (int i = had; i <= n; i++) fact[i] = fact[i-1] * i;\n        }\n        return fact[n];\n    }\n    static modnum inverse_factorial(int n) {\n        static vector<modnum> finv = {1};\n        assert(n >= 0);\n        if (sz(finv) <= n) {\n            int had = sz(finv);\n            finv.resz(n + 1), finv[n] = factorial(n).inv();\n            for (int i = n - 1; i >= had; i--) finv[i] = finv[i+1] * (i+1);\n        }\n        return finv[n];\n    }\n\n    static modnum small_inv(int n) {\n        assert(n > 0); return factorial(n - 1) * inverse_factorial(n);\n    }\n\n    static modnum ncr(int n, int r) {\n        if (r < 0 || n < r) return 0;\n        return factorial(n) * inverse_factorial(r) * inverse_factorial(n - r);\n    }\n};\n// }}}\nusing mn = modnum<int(998244353)>;\nusing vmn = vector<mn>;\nusing vvmn = vector<vmn>;\n\nint main() {\n    setIO();\n\n    int N; re(N); tree<edge> tr(N, 0); re(tr);\n\n    // expects adjacency list \"adj\", return distances and bfs tree\n    auto bfs = [&](int src) {\n        vi dist(N, -1), pred(N, -1);\n        dist[src] = 0;\n        for (queue<int> bfs({src}); !bfs.empty(); bfs.pop()) {\n            int loc = bfs.front();\n            trav (e, tr.nbrs[loc]) {\n                int nbr = e(loc);\n                if (dist[nbr] == -1) {\n                    dist[nbr] = dist[loc] + 1;\n                    pred[nbr] = loc;\n                    bfs.push(nbr);\n                }\n            }\n        }\n        return mp(dist, pred);\n    };\n\n    int x;\n    {\n        auto dist = bfs(0).f;\n        x = max_element(all(dist)) - dist.begin();\n    }\n    int y, diam, c0, c1;\n    {\n        vi dist, pred;\n        tie(dist, pred) = bfs(x);\n        y = max_element(all(dist)) - dist.begin();\n        diam = dist[y];\n\n        c0 = y;\n        F0R (i, diam / 2)\n            c0 = pred[c0];\n        if (diam&1)\n            c1 = pred[c0];\n        else\n            c1 = -1;\n    }\n\n    tr.reroot(c0);\n\n    vb extreme(N);\n    {\n        if (c1 != -1) {\n            vb c1_side(N);\n            c1_side[c1] = 1;\n            trav (u, tr.preorder)\n                if (tr.depth[u] > tr.depth[c1])\n                    c1_side[u] = c1_side[tr.par[u]];\n            F0R (i, N)\n                extreme[i] = tr.depth[i] == (diam + c1_side[i]) / 2;\n        } else {\n            F0R (i, N) extreme[i] = tr.depth[i] == (diam / 2);\n        }\n    }\n\n    vector<array<mn, 9>> dp(N);\n    trav (u, tr.reverse_preorder) {\n        if (tr.children[u].empty()) {\n            if (extreme[u]) dp[u][3 * 1 + 1] = 1;\n            else dp[u][0] = 1;\n        } else {\n            dp[u][0] = 1;\n            trav (e, tr.children[u]) {\n                if (e(u) == c1) continue;\n                array<mn, 9> DP; DP.fill(0);\n                F0R (pos, 3) F0R (neg, 3) {\n                    F0R (POS, 3) F0R (NEG, 3) {\n                        mn ways = dp[u][3 * pos + neg] * dp[e(u)][3 * POS + NEG];\n                        for (int dir = -1; dir <= 1; dir++) {\n                            int rpos = min(2, pos + ((dir > 0) ? POS : 0));\n                            int rneg = min(2, neg + ((dir < 0) ? NEG : 0));\n                            DP[3 * rpos + rneg] += ways;\n                        }\n                    }\n                }\n                dp[u] = DP;\n            }\n        }\n    }\n\n    if (diam&1) {\n        mn s0 = 0, s1 = 0;\n        F0R (i, 3) {\n            s0 += dp[c0][3 * 1 + i];\n            s1 += dp[c1][3 * i + 1];\n        }\n        ps(s0 * s1);\n    } else {\n        ps(dp[c0][3 * 1 + 1] / 2);\n    }\n\n    // did you check N=1? did you mix up N,M?\n    // check your \"infinity\" and \"null\" values against the bounds\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=2e5+5,mod=998244353;\nint n,m,dis[N],fa[N],a[N],si[N],rt1,rt2,head[N],nex[N<<1],to[N<<1],tot;\nvoid add(int u,int v){to[++tot]=v;nex[tot]=head[u];head[u]=tot;}\nvoid dfs(int u,int p)\n{\n    dis[u]=dis[p]+1;\n    if(dis[u]>dis[rt1]) rt1=u;\n    fa[u]=p;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p)continue;\n        dfs(v,u);\n    }\n}\nll dp[N][3][3],p[3][3];\nvoid dfs(int u,int fa,int d)\n{\n    d==m/2?dp[u][1][1]=1:dp[u][0][0]=1;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==fa)continue;\n        dfs(v,u,d+1);\n        memset(p,0,sizeof(p));\n        for(int i=0;i<3;i++)\n            for(int j=0;j<3;j++)\n            for(int k=0;k<3;k++)\n                for(int h=0;h<3;h++)\n        {\n            p[i][j]=(p[i][j]+dp[u][i][j]*dp[v][k][h])%mod;\n            p[min(i+k,2)][j]=(p[min(i+k,2)][j]+dp[u][i][j]*dp[v][k][h])%mod;\n            p[i][min(j+h,2)]=(p[i][min(j+h,2)]+dp[u][i][j]*dp[v][k][h])%mod;\n        }\n        for(int i=0;i<3;i++)\n            for(int j=0;j<3;j++)\n            dp[u][i][j]=p[i][j];\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        int u,v;scanf(\"%d%d\",&u,&v);add(u,v);add(v,u);\n    }\n    dfs(1,0);\n    rt2=rt1;\n    dfs(rt1,0);\n    while(fa[rt1]) a[++m]=rt1,rt1=fa[rt1];\n    a[++m]=rt1;\n    rt1=rt2=0;\n    if(m%2==0) rt1=a[m/2],rt2=a[m/2+1];\n    else rt1=a[m/2+1];\n    m--;\n    if(rt1&&rt2)\n    {\n        dfs(rt1,rt2,0);dfs(rt2,rt1,0);\n        printf(\"%lld\\n\",(dp[rt1][1][0]*dp[rt2][0][1]))%mod;\n    }\n    else\n    {\n        dfs(rt1,0,0);\n        printf(\"%lld\\n\",dp[rt1][1][1]*(mod-mod/2)%mod);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;++A)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD 998244353ll\nll moddiv(ll a,ll b){\n    a %= MOD;\n    b %= MOD;\n    for(ll m=MOD-2;m>0;m/=2){\n        if(m&1){\n            a=a*b%MOD;\n        }\n        b=b*b%MOD;\n    }\n    return a;\n}\n\n\nll N,Len;\nvector<ll> abv[202020];\nvector<ll> abl[202020];\nll mk[202020],p3[202020];\nll dp[202020][4];\nll i, j, k;\nll ans;\n\nvoid dfs(ll a,ll p,ll d)\n{\n    if(abv[a].size()==1){\n        dp[a][2] = 3;\n        if(d==0){\n            dp[a][0] = 2;\n            dp[a][1] = 1;\n        }else{\n            dp[a][0] = 3;\n        }\n        return;\n    }\n    ll i;\n    ll c = 1,e=0;\n    dp[a][2] = 1;\n    fornum(i,0,abv[a].size()){\n        ll b = abv[a][i];\n        if(b==p){\n            continue;\n        }\n        dfs(b, a, d - 1);\n        c = c * dp[b][0] % MOD;\n        dp[a][2] *= dp[b][2];\n        dp[a][2] %= MOD;\n    }\n    dp[a][0] = (dp[a][2] * 2 + c) % MOD;\n    fornum(i,0,abv[a].size()){\n        ll b = abv[a][i];\n        if(b==p){\n            continue;\n        }\n        dp[a][1] += moddiv(c * dp[b][1], dp[b][0]);\n        dp[a][1] %= MOD;\n    }\n    dp[a][2] *= 3;\n    dp[a][2] %= MOD;\n}\n\nll lencalc(ll a,ll p,ll d){\n    //printf(\"%lld,%lld,%lld\\n\", p, a, d);\n    ll i = 0,  ret = 0;\n    pll c = {0, 0};\n    fornum(i,0,abv[a].size()){\n        ll b = abv[a][i];\n        if(b==p)\n            continue;\n        if(c.first<=abl[a][i]){\n            c.second = c.first;\n            c.first = abl[a][i];\n        }else if(c.second<=abl[a][i]){\n            c.second = abl[a][i];\n        }\n    }\n    fornum(i,0,abv[a].size()){\n        ll b = abv[a][i];\n        if(b==p){\n            abl[a][i] = d;\n            continue;\n        }\n        ll r = 0;\n        if(c.first==abl[a][i]){\n            r = lencalc(b, a, max(d, c.second) + 1);\n        }else{\n            r = lencalc(b, a, max(d, c.first) + 1);\n        }\n        abl[a][i] = r;\n        ret = max(ret, r);\n    }\n    return ret + 1;\n}\n\n\nint main(){\n    scanf(\"%lld\", &N);\n    fornum(i,1,N){\n        ll a, b;\n        scanf(\"%lld%lld\", &a, &b);\n        abv[a].push_back(b);\n        abl[a].push_back(0);\n        abv[b].push_back(a);\n        abl[b].push_back(0);\n    }\n    lencalc(1, 0, 0);\n    lencalc(1, 0, 0);\n    fornum(i,1,N+1){\n        if(abv[i].size()==1){\n            Len = max(Len, abl[i][0]);\n        }\n    }\n\n    if(Len%2){\n        pll a = {0, 0};\n        fornum(i,1,N+1){\n            fornum(j,0,abv[i].size()){\n                if((Len+1)/2==abl[i][j]){\n                    break;\n                }\n            }\n            if(j<abv[i].size()){\n                a.first = i;\n                a.second = abv[i][j];\n            }\n        }\n        //printf(\"b%lld,%lld\\n\", a.first, a.second);\n        dfs(a.first, a.second, Len / 2);\n        dfs(a.second, a.first, Len / 2);\n        ans = dp[a.first][1] * dp[a.second][1] % MOD;\n    }else{\n        fornum(i,1,N+1){\n            if(abv[i].size()==1)\n                continue;\n            sort(abl[i].begin(), abl[i].end(),greater<ll>());\n            if(abl[i][0]==abl[i][1])\n                break;\n        }\n        ll a = i;\n        //printf(\"a%lld\\n\", a);\n        dfs(a, 0, Len / 2);\n        ll c = 1;\n        fornum(i,0,abv[a].size()){\n            ll b = abv[a][i];\n            //printf(\"cc%lld,%lld,%lld\\n\", b, dp[b][0], dp[b][1]);\n            c = c * (dp[b][0] - dp[b][1] + MOD) % MOD;\n        }\n        ll d = 0;\n        fornum(i,0,abv[a].size()){\n            ll b = abv[a][i];\n            ans += moddiv(d * dp[b][1], dp[b][0] - dp[b][1] + MOD) % MOD;\n            ans %= MOD;\n            d += moddiv(c * dp[b][1], dp[b][0] - dp[b][1] + MOD);\n            d %= MOD;\n        }\n    }\n    \n    printf(\"%lld\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200100\nusing namespace std;\nvector<int> g[N];\nlong long to_leaf[N],p3sz[N],nume[N][3];\nint par[N];\nconst int Q=998244353;\nint find_c(int u,int p,int &c){\n\tpar[u]=p;\n\tint mx[2]={u,u},ans=0,tans,tc;\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint v=g[u][i];\n\t\tif(v==p) continue;\n\t\ttans=find_c(v,u,tc);\n\t\tif(tans>ans){\n\t\t\tans=tans;\n\t\t\tc=tc;\n\t\t}\n\t\tif(to_leaf[v]>to_leaf[mx[0]]){\n\t\t\tmx[1]=mx[0];\n\t\t\tmx[0]=v;\n\t\t}\n\t\telse if(to_leaf[v]>to_leaf[mx[1]]){\n\t\t\tmx[1]=v;\n\t\t}\n\t}\n\tif(to_leaf[mx[0]]+to_leaf[mx[1]]>ans){\n\t\tans=to_leaf[mx[0]]+to_leaf[mx[1]];\n\t\tc=u;\n\t}\n\tto_leaf[u]=to_leaf[mx[0]]+1;\n\treturn ans;\n}\nvoid build(int u,int p){\n\tto_leaf[u]=0;\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint v=g[u][i];\n\t\tif(v==p) continue;\n\t\tbuild(v,u);\n\t\tto_leaf[u]=max(to_leaf[u],to_leaf[v]+1);\n\t}\n}\nvoid solve(int u,int p){\n\tp3sz[u]=1;\n\tif(!to_leaf[u]){\n\t\tnume[u][1]=1;\n\t\treturn;\n\t}\n\tnume[u][0]=1;\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint v=g[u][i];\n\t\tif(v==p) continue;\n\t\tsolve(v,u);\n\t\tif(to_leaf[v]+1==to_leaf[u]){\n\t\t\tfor(int j=2;j>=0;j--){\n\t\t\t\tnume[u][j]=(2*p3sz[v]+nume[v][0])*nume[u][j]%Q;\n\t\t\t\tif(j){\n\t\t\t\t\tnume[u][j]+=nume[v][1]*nume[u][j-1]%Q;\n\t\t\t\t\tnume[u][j]%=Q;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tnume[u][j]=3*p3sz[v]*nume[u][j]%Q;\n\t\t\t}\n\t\t}\n\t\tp3sz[u]=3*p3sz[v]*p3sz[u]%Q;\n\t}\n}\nint main(){\n\tint n,x,y;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tint l,p,c;\n\tl=find_c(1,0,c);\n\tp=par[c];\n\tbool flag=true;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<g[c].size();i++){\n\t\t\tif(g[c][i]!=p && to_leaf[g[c][i]]>(l+1)/2){\n\t\t\t\tp=c;\n\t\t\t\tc=g[c][i];\n\t\t\t\tflag=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"diameter=%d\\n\",l);\n\tif(l&1){\n\t\tint d=-1;\n\t\tfor(int i=0;i<g[c].size();i++){\n\t\t\tif(to_leaf[g[c][i]]==(l+1)/2){\n\t\t\t\td=g[c][i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//printf(\"center: %d %d\\n\",c,d);\n\t\tassert(d>0);\n\t\tbuild(c,d);\n\t\tsolve(c,d);\n\t\tbuild(d,c);\n\t\tsolve(d,c);\n\t\tprintf(\"%lld\\n\",1LL*nume[c][1]*nume[d][1]%Q);\n\t}\n\telse{\n\t\t//printf(\"center: %d\\n\",c);\n\t\tbuild(c,0);\n\t\tsolve(c,0);\n\t\tprintf(\"%lld\\n\",nume[c][2]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[202020];\nconst ll mo=998244353;\nll dp[202020][3][3];\n\npair<int,int> farthest(int cur,int pre,int d,vector<int>& D) {\n\tD[cur]=d;\n\tpair<int,int> r={d,cur};\n\tFORR(e,E[cur]) if(e!=pre) r=max(r, farthest(e,cur,d+1,D));\n\treturn r;\n}\n\npair<int,vector<int>> diameter() { // diameter,center\n\tvector<int> D[2];\n\tD[0].resize(N);\n\tD[1].resize(N);\n\tauto v1=farthest(0,0,0,D[0]);\n\tauto v2=farthest(v1.second,v1.second,0,D[0]);\n\tfarthest(v2.second,v2.second,0,D[1]);\n\tpair<int,vector<int>> R;\n\tR.first = v2.first;\n\t//重心を取る場合\n\tfor(int i=N-1;i>=0;i--) if(D[0][i]+D[1][i]==R.first && abs(D[0][i]-D[1][i])<=1) R.second.push_back(i);\n\n\treturn R;\n}\n\nvoid dfs(int cur,int pre,int lef) {\n\tif(lef==0) {\n\t\tdp[cur][1][1]=1;\n\t}\n\telse {\n\t\tdp[cur][0][0]=1;\n\t}\n\t\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\tdfs(e,cur,lef-1);\n\t\tll to[3][3]={};\n\t\tint a1,a2,b1,b2;\n\t\tFOR(a1,3) FOR(a2,3) FOR(b1,3) FOR(b2,3) {\n\t\t\t// +1\n\t\t\tto[min(a1+b1,2)][a2]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t\t// 0\n\t\t\tto[a1][a2]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t\t// -1\n\t\t\tto[a1][min(a2+b2,2)]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t}\n\t\t\n\t\tFOR(a1,3) FOR(a2,3) dp[cur][a1][a2]=to[a1][a2]%mo;\n\t}\n\t\n}\n\nvoid dfs2(int cur,int pre,int lef) {\n\tif(lef==0) {\n\t\tdp[cur][0][1]=1;\n\t}\n\telse {\n\t\tdp[cur][0][0]=1;\n\t}\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\tdfs2(e,cur,lef-1);\n\t\tll to[3]={};\n\t\tint a,b;\n\t\tFOR(a,3) FOR(b,3) {\n\t\t\t// +1\n\t\t\tto[min(a+b,2)]+=dp[cur][0][a]*dp[e][0][b]%mo;\n\t\t\t// 0,-1\n\t\t\tto[a]+=2*dp[cur][0][a]*dp[e][0][b]%mo;\n\t\t}\n\t\t\n\t\tFOR(a,3) dp[cur][0][a]=to[a]%mo;\n\t}\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tauto R=diameter();\n\tif(R.second.size()==1) {\n\t\tx=R.second[0];\n\t\tdfs(x,-1,R.first/2);\n\t\tcout<<dp[x][1][1]*((mo+1)/2)%mo<<endl;\n\t}\n\telse {\n\t\tx=R.second[0];\n\t\ty=R.second[1];\n\t\tdfs2(x,y,R.first/2);\n\t\tdfs2(y,x,R.first/2);\n\t\tll ret=(dp[x][0][1]%mo*dp[y][0][1])%mo;\n\t\tcout<<ret<<endl;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll mod = 998244353;\nvector<int>pat[202020];\nint dep[202020];\nbool flag[202020];\nint diam = 0;\nbool iscent[202020];\nvector<int>ko[202020];\nvoid dfs(int node, int d)\n{\n\tflag[node] = true;\n\tdep[node] = d;\n\tdiam = max(diam, d);\n\tfor (int i = 0; i < pat[node].size(); i++)if (!flag[pat[node][i]])dfs(pat[node][i], d + 1);\n}\nvoid dfs2(int node, int d)\n{\n\tflag[node] = true;\n\tdep[node] = d;\n\tfor (int i = 0; i < pat[node].size(); i++)\n\t{\n\t\tif (!flag[pat[node][i]] && !iscent[pat[node][i]])\n\t\t{\n\t\t\tdfs2(pat[node][i], d + 1);\n\t\t\tko[node].push_back(pat[node][i]);\n\t\t}\n\t}\n}\ntypedef pair<ll, ll>pii;\nint siz[202020];\nint p3[202020];\npii calc(int node)\n{\n\tif (ko[node].empty())\n\t{\n\t\tsiz[node] = 1;\n\t\tif (dep[node] == diam / 2)return make_pair(1, 2);\n\t\telse return make_pair(0, 3);\n\t}\n\tvector<pii>v;\n\tsiz[node] = 1;\n\tfor (int i = 0; i < ko[node].size(); i++)v.push_back(calc(ko[node][i])), siz[node] += siz[ko[node][i]];\n\tvector<ll>r1, r2;\n\tr1.resize(v.size() + 1), r1[0] = 1;\n\tr2.resize(v.size() + 1), r2[v.size()] = 1;\n\tfor (int i = 0; i < v.size(); i++)r1[i + 1] = r1[i] * v[i].second%mod;\n\tfor (int i = v.size() - 1; i >= 0; i--)r2[i] = r2[i + 1] * v[i].second%mod;\n\tll t1 = 0, t2 = 1;\n\tfor (int i = 0; i < v.size(); i++)\n\t{\n\t\tt1 = (t1 + r1[i] * r2[i + 1] % mod*v[i].first) % mod;\n\t\tt2 = t2*v[i].second%mod;\n\t}\n\tt2 = (t2 + p3[siz[node] - 1] * 2) % mod;\n\t//printf(\"%d %d   %lld %lld\\n\", node + 1, siz[node], t1, t2);\n\treturn make_pair(t1, t2);\n}\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < num - 1; i++)\n\t{\n\t\tint za, zb;\n\t\tscanf(\"%d%d\", &za, &zb);\n\t\tza--, zb--;\n\t\tpat[za].push_back(zb);\n\t\tpat[zb].push_back(za);\n\t}\n\tdfs(0, 0);\n\tint r = 0;\n\tfor (int i = 0; i < num; i++)if (dep[i] == diam)r = i;\n\tfill(flag, flag + num, false);\n\tdfs(r, 0);\n\tint now;\n\tfor (int i = 0; i < num; i++)if (dep[i] == diam)now = i;\n\tvector<int>path;\n\tfor (int i = 0; i < diam; i++)\n\t{\n\t\tpath.push_back(now);\n\t\tfor (int j = 0; j < pat[now].size(); j++)\n\t\t{\n\t\t\tif (dep[pat[now][j]] == dep[now] - 1)\n\t\t\t{\n\t\t\t\tnow = pat[now][j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpath.push_back(now);\n\tp3[0] = 1;\n\tfor (int i = 0; i < num + 10; i++)p3[i + 1] = p3[i] * 3 % mod;\n\t//for (int i = 0; i < path.size(); i++)printf(\"%d \", path[i] + 1); printf(\"\\n\");\n\n\n\tif (diam % 2 == 0)\n\t{\n\t\tint c = path[diam / 2];\n\t\tfill(flag, flag + num, false);\n\t\tiscent[c] = true;\n\t\tdfs2(c, 0);\n\t\tll d0 = 1, d1 = 0, d2 = 0, d3 = 0;\n\t\tfor (int i = 0; i < ko[c].size(); i++)\n\t\t{\n\t\t\tpii z = calc(ko[c][i]);\n\t\t\tll x = z.second + z.second - p3[siz[ko[c][i]]];\n\t\t\tll e0 = d0*(z.second - z.first);\n\t\t\tll e1 = d0*z.first + d1*x;\n\t\t\tll e2 = d0*z.first + d2*x;\n\t\t\tll e3 = d1*z.first + d2*z.first + d3*x;\n\t\t\td0 = (e0%mod + mod) % mod;\n\t\t\td1 = (e1%mod + mod) % mod;\n\t\t\td2 = (e2%mod + mod) % mod;\n\t\t\td3 = (e3%mod + mod) % mod;\n\t\t}\n\t\tprintf(\"%lld\\n\", d3*(mod + 1) / 2 % mod);\n\t}\n\telse\n\t{\n\t\tint c1 = path[diam / 2], c2 = path[(diam + 1) / 2];\n\t\tfill(flag, flag + num, false);\n\t\tiscent[c1] = iscent[c2] = true;\n\t\tdfs2(c1, 0), dfs2(c2, 0);\n\n\t\tpii a = calc(path[diam / 2]), b = calc(path[(diam + 1) / 2]);\n\t\tprintf(\"%lld\\n\", a.first*b.first%mod);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint read(){\n\tint a = 0; char c = getchar(); while(!isdigit(c)) c = getchar();\n\twhile(isdigit(c)){a = a * 10 + c - 48; c = getchar();} return a;\n}\n\nconst int _ = 2e5 + 7 , MOD = 998244353 , iv2 = (MOD + 1) / 2;\nstruct Edge{int end , upEd;}Ed[_ << 1];\nint dp[_][3][3] , N , cntEd , head[_];\nvoid addEd(int a , int b){Ed[++cntEd] = (Edge){b , head[a]}; head[a] = cntEd;}\n\nint mx , id , pre[_];\nvoid dfs1(int x , int p , int l){\n\tpre[x] = p; if(l > mx){mx = l; id = x;}\n\tfor(int i = head[x] ; i ; i = Ed[i].upEd)\n\t\tif(Ed[i].end != p) dfs1(Ed[i].end , x , l + 1);\n}\n\nint mxdep[_];\nvoid dfs2(int x , int p){\n\tfor(int i = head[x] ; i ; i = Ed[i].upEd)\n\t\tif(Ed[i].end != p){dfs2(Ed[i].end , x); mxdep[x] = max(mxdep[x] , mxdep[Ed[i].end] + 1);}\n}\n\nvoid DP(int x , int p){\n\tdp[x][0][0] = 1; bool flg = 0;\n\tfor(int i = head[x] ; i ; i = Ed[i].upEd)\n\t\tif(Ed[i].end != p){\n\t\t\tflg = 1; DP(Ed[i].end , x); static int tmp[3][3]; memset(tmp , 0 , sizeof(tmp));\n\t\t\tfor(int j = 0 ; j < 3 ; ++j)\n\t\t\t\tfor(int k = 0 ; k < 3 ; ++k)\n\t\t\t\t\tfor(int p = 0 ; p < 3 ; ++p)\n\t\t\t\t\t\tfor(int q = 0 ; q < 3 ; ++q){\n\t\t\t\t\t\t\tint coef = 3;\n\t\t\t\t\t\t\tif(mxdep[Ed[i].end] + 1 == mxdep[x]){\n\t\t\t\t\t\t\t\ttmp[min(j + p , 2)][k] = (tmp[min(j + p , 2)][k] + 1ll * dp[x][j][k] * dp[Ed[i].end][p][q]) % MOD;\n\t\t\t\t\t\t\t\ttmp[j][min(k + q , 2)] = (tmp[j][min(k + q , 2)] + 1ll * dp[x][j][k] * dp[Ed[i].end][p][q]) % MOD;\n\t\t\t\t\t\t\t\tcoef -= 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttmp[j][k] = (tmp[j][k] + 1ll * coef * dp[x][j][k] * dp[Ed[i].end][p][q]) % MOD;\n\t\t\t\t\t\t}\n\t\t\tmemcpy(dp[x] , tmp , sizeof(tmp));\n\t\t}\n\tif(!flg){dp[x][0][0] = 0; dp[x][1][1] = 1;}\n}\n\nint main(){\n\tN = read(); for(int i = 1 ; i < N ; ++i){int x = read() , y = read(); addEd(x , y); addEd(y , x);}\n\tdfs1(1 , 0 , 0); mx = 0; int t = id; dfs1(t , 0 , 0);\n\tfor(int i = 0 ; i < mx / 2 ; ++i) id = pre[id];\n\tif(mx & 1){\n\t\tdfs2(id , pre[id]); DP(id , pre[id]); dfs2(pre[id] , id); DP(pre[id] , id); int sum = 0;\n\t\tfor(int i = 0 ; i < 3 ; ++i)\n\t\t\tfor(int j = 0 ; j < 3 ; ++j)\n\t\t\t\tfor(int k = 0 ; k < 3 ; ++k)\n\t\t\t\t\tfor(int l = 0 ; l < 3 ; ++l){\n\t\t\t\t\t\tif(i == 1 && l == 1) sum = (sum + 1ll * dp[id][i][j] * dp[pre[id]][k][l]) % MOD;\n\t\t\t\t\t\tif(j == 1 && k == 1) sum = (sum + 1ll * dp[id][i][j] * dp[pre[id]][k][l]) % MOD;\n\t\t\t\t\t}\n\t\tprintf(\"%lld\\n\" , 1ll * sum * iv2 % MOD);\n\t}else{dfs2(id , 0); DP(id , 0); printf(\"%lld\\n\" , 1ll * iv2 * dp[id][1][1] % MOD);}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll mod = 998244353;\nvector<int>pat[202020];\nint dep[202020];\nbool flag[202020];\nint diam = 0;\nbool iscent[202020];\nvector<int>ko[202020];\nvoid dfs(int node, int d)\n{\n\tflag[node] = true;\n\tdep[node] = d;\n\tdiam = max(diam, d);\n\tfor (int i = 0; i < pat[node].size(); i++)if (!flag[pat[node][i]])dfs(pat[node][i], d + 1);\n}\nvoid dfs2(int node, int d)\n{\n\tflag[node] = true;\n\tdep[node] = d;\n\tfor (int i = 0; i < pat[node].size(); i++)\n\t{\n\t\tif (!flag[pat[node][i]] && !iscent[pat[node][i]])\n\t\t{\n\t\t\tdfs2(pat[node][i], d + 1);\n\t\t\tko[node].push_back(pat[node][i]);\n\t\t}\n\t}\n}\ntypedef pair<ll, ll>pii;\nint siz[202020];\nint p3[202020];\npii calc(int node)\n{\n\tif (ko[node].empty())\n\t{\n\t\tsiz[node] = 1;\n\t\tif (dep[node] == diam / 2)return make_pair(1, 2);\n\t\telse return make_pair(0, 3);\n\t}\n\tvector<pii>v;\n\tsiz[node] = 1;\n\tfor (int i = 0; i < ko[node].size(); i++)v.push_back(calc(ko[node][i])), siz[node] += siz[ko[node][i]];\n\tvector<ll>r1, r2;\n\tr1.resize(v.size() + 1), r1[0] = 1;\n\tr2.resize(v.size() + 1), r2[v.size()] = 1;\n\tfor (int i = 0; i < v.size(); i++)r1[i + 1] = r1[i] * v[i].second%mod;\n\tfor (int i = v.size() - 1; i >= 0; i--)r2[i] = r2[i + 1] * v[i].second%mod;\n\tll t1 = 0, t2 = 1;\n\tfor (int i = 0; i < v.size(); i++)\n\t{\n\t\tt1 = (t1 + r1[i] * r2[i + 1] % mod*v[i].first) % mod;\n\t\tt2 = t2*v[i].second%mod;\n\t}\n\tt2 = (t2 + p3[siz[node] - 1] * 2) % mod;\n\t//printf(\"%d %lld %lld\\n\", node + 1, t1, t2);\n\treturn make_pair(t1, t2);\n}\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < num - 1; i++)\n\t{\n\t\tint za, zb;\n\t\tscanf(\"%d%d\", &za, &zb);\n\t\tza--, zb--;\n\t\tpat[za].push_back(zb);\n\t\tpat[zb].push_back(za);\n\t}\n\tdfs(0, 0);\n\tint r = 0;\n\tfor (int i = 0; i < num; i++)if (dep[i] == diam)r = i;\n\tfill(flag, flag + num, false);\n\tdfs(r, 0);\n\tint now;\n\tfor (int i = 0; i < num; i++)if (dep[i] == diam)now = i;\n\tvector<int>path;\n\tfor (int i = 0; i < diam; i++)\n\t{\n\t\tpath.push_back(now);\n\t\tfor (int j = 0; j < pat[now].size(); j++)\n\t\t{\n\t\t\tif (dep[pat[now][j]] == dep[now] - 1)\n\t\t\t{\n\t\t\t\tnow = pat[now][j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpath.push_back(now);\n\tp3[0] = 1;\n\tfor (int i = 0; i < num + 10; i++)p3[i + 1] = p3[i] * 3 % mod;\n\t//for (int i = 0; i < path.size(); i++)printf(\"%d \", path[i] + 1); printf(\"\\n\");\n\n\n\tif (diam % 2 == 0)\n\t{\n\t\tint c = path[diam / 2];\n\t\tfill(flag, flag + num, false);\n\t\tiscent[c] = true;\n\t\tdfs2(c, 0);\n\t\tll d0 = 1, d1 = 0, d2 = 0, d3 = 0;\n\t\tfor (int i = 0; i < ko[c].size(); i++)\n\t\t{\n\t\t\tpii z = calc(ko[c][i]);\n\t\t\tll e0 = d0*(z.second - z.first);\n\t\t\tll e1 = d0*z.first + d1*(z.second - z.first);\n\t\t\tll e2 = d0*z.first + d2*(z.second - z.first);\n\t\t\tll e3 = d1*z.first + d2*z.first + d3*(z.second - z.first);\n\t\t\td0 = (e0%mod + mod) % mod;\n\t\t\td1 = (e1%mod + mod) % mod;\n\t\t\td2 = (e2%mod + mod) % mod;\n\t\t\td3 = (e3%mod + mod) % mod;\n\t\t}\n\t\tprintf(\"%lld\\n\", d3*(mod + 1) / 2 % mod);\n\t}\n\telse\n\t{\n\t\tint c1 = path[diam / 2], c2 = path[(diam + 1) / 2];\n\t\tfill(flag, flag + num, false);\n\t\tiscent[c1] = iscent[c2] = true;\n\t\tdfs2(c1, 0), dfs2(c2, 0);\n\n\t\tpii a = calc(path[diam / 2]), b = calc(path[(diam + 1) / 2]);\n\t\tprintf(\"%lld\\n\", a.first*b.first%mod);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define R register\n#define mp make_pair\n#define ll long long\n#define pii pair<int, int>\nusing namespace std;\nconst int N = 210000, mod = 998244353;\n\nint n, dis[N], a, b;\nll f[N], g[N], pw[N];\nvector<int> to[N];\n\ntemplate <class T>\ninline void read(T &x) {\n\tx = 0;\n\tchar ch = getchar(), w = 0;\n\twhile (!isdigit(ch)) w = (ch == '-'), ch = getchar();\n\twhile (isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();\n\tx = w ? -x : x;\n\treturn;\n}\n\ninline void addEdg(int x, int y) {\n\tto[x].push_back(y), to[y].push_back(x);\n\treturn;\n}\n\nvoid dfs1(int now, int fa) {\n\tdis[now] = dis[fa] + 1;\n\tfor (auto &v : to[now]) {\n\t\tif (v == fa) continue;\n\t\tdfs1(v, now);\n\t}\n\treturn;\n}\n\nint dfs2(int now, int fa, int maxD) {\n\tif (dis[now] == maxD) return 1;\n\tint ret = 0;\n\tfor (auto &v : to[now]) {\n\t\tif (v == fa) continue;\n\t\tret |= dfs2(v, now, maxD);\n\t}\n\tif (ret) {\n\t\tif (dis[now] == (maxD + 1) >> 1)\n\t\t\ta = now;\n\t\telse if (dis[now] == (maxD >> 1) + 1)\n\t\t\tb = now;\n\t}\n\treturn ret;\n}\n\nvoid dfs3(int now, int fa, int maxD) {\n\tpw[now] = 1, dis[now] = dis[fa] + 1;\n\tif (dis[now] == (maxD + 1) >> 1) g[now] = 1;\n\tf[now] = 1 - g[now];\n\tfor (auto &v : to[now]) {\n\t\tif (v == fa) continue;\n\t\tdfs3(v, now, maxD);\n\t\tg[now] = ((2 * pw[v] + f[v]) * g[now] + f[now] * g[v]) % mod;\n\t\tf[now] = (2 * pw[v] + f[v]) * f[now] % mod;\n\t\tpw[now] = pw[now] * pw[v] * 3 % mod;\n\t}\n//\tcout << \"qwq \" << now << ' ' << pw[now] << ' ' << f[now] << ' ' << g[now] << endl;\n\treturn;\n}\n\nint main() {\n\tint x, y;\n\tread(n);\n\tfor (R int i = 1; i < n; ++i)\n\t\tread(x), read(y), addEdg(x, y);\n\tdfs1(1, 0);\n\tint rt = 1, maxD = 1;\n\tfor (R int i = 2; i <= n; ++i)\n\t\tif (dis[i] > maxD) maxD = dis[i], rt = i;\n\tdfs1(rt, 0), maxD = 1;\n\tfor (R int i = 1; i <= n; ++i)\n\t\tmaxD = max(maxD, dis[i]);\n\tdfs2(rt, 0, maxD);\n\tif (b) {\n\t\tdis[a] = 0, dfs3(b, a, maxD);\n\t\tdis[b] = 0, dfs3(a, b, maxD);\n\t\tprintf(\"%lld\\n\", g[a] * g[b] % mod);\n\t}\n\telse {\n\t\tll ans = 0;\n\t\tf[a] = 1, dis[a] = 1;\n\t\tfor (auto &v : to[a]) {\n\t\t\tdfs3(v, a, maxD);\n\t\t\tans = (ans * (pw[v] + 2 * f[v]) + g[a] * g[v]) % mod;\n\t\t\tg[a] = (g[a] * (pw[v] + 2 * f[v]) + f[a] * g[v]) % mod;\n\t\t\tf[a] = f[a] * (pw[v] + 2 * f[v]) % mod;\n\t\t\t//cout << \"qwq \" << v << ' ' << f[v] << ' ' << g[v] << endl;\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst int M=998244353;\nconst int inv2=(M+1)/2;\nconst int maxn=3e5+3;\nvector <int> h[maxn];\nint dis[maxn],n,pre[maxn],p,q,d[maxn],m;\nll dp[maxn][2];\nvoid dfs(int u,int fa){\n    pre[u]=fa; dis[u]=dis[fa]+1;\n    for (auto v:h[u]){\n        if (v==fa) continue;\n        dfs(v,u);\n    }\n}\nvoid dfs2(int u,int fa){\n    d[u]=d[fa]+1;\n    if (d[u]==m){\n        dp[u][0]=2;\n        dp[u][1]=1;\n        return;\n    }\n    ll r1=1,r2=0;\n    for (auto v:h[u]){\n        if (v==fa) continue;\n        dfs2(v,u);\n        ll nr1=r1*dp[v][0]%M;\n        ll nr2=(r1*dp[v][1]+r2*dp[v][0])%M;\n        r1=nr1; r2=nr2;\n    }\n    dp[u][0]=r1*3%M;\n    dp[u][1]=r2;\n}\nint main(){\n    scanf(\"%d\",&n); dis[0]=-1;\n    for (int i=1;i<n;i++){\n        int u,v; scanf(\"%d%d\",&u,&v);\n        h[u].pb(v); h[v].pb(u);\n    }\n    //puts(\"B\");\n    dfs(1,0);\n    int s=1;\n    for (int i=2;i<=n;i++) if (dis[i]>dis[s]) s=i;\n    dfs(s,0);\n    int t=s;\n    for (int i=1;i<=n;i++) if (dis[i]>dis[t]) t=i;\n    m=dis[t]/2; p=t;\n    for (int i=0;i<m;i++) p=pre[p];\n    if (dis[t]&1){\n        q=pre[p];\n        d[q]=-1; dfs2(p,q);\n        d[p]=-1; dfs2(q,p);\n        printf(\"%lld\\n\",dp[p][1]*dp[q][1]%M);\n    } else {\n        ll ans0=1,ans1=0,ans2=0;\n        for (auto u:h[p]){\n            d[u]=0; dfs2(u,p);\n            ll nans0,nans1,nans2;\n            nans0=ans0*(dp[u][0]+M-dp[u][1])%M;\n            nans1=(ans0*dp[u][1]+ans1*(dp[u][0]+M-dp[u][1]))%M;\n            nans2=(ans1*dp[u][1]+ans2*(dp[u][0]+M-dp[u][1]))%M;\n            ans0=nans0; ans1=nans1; ans2=nans2;\n        }\n        printf(\"%lld\\n\",ans2);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nFor even diameter D, label tree vertices with -D/2..D/2 so adjacent vertices have label diff <= 1,\nand there are exactly one vertex labelled D/2 and one -D/2.\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n//#define cerr if (false) cerr\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntemplate <typename A, typename B>\nostream& operator<<(ostream& os, const pair<A, B>& x) {\n\treturn os << \"(\" << x.first << \",\" << x.second << \")\";\n}\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 998244353;\nstruct Mint {\n\tint val;\n\tMint() { val = 0; }\n\tMint(const ll& x) {\n\t\tval = (-MOD <= x && x < MOD) ? x : x % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\ttemplate <typename U>\n\texplicit operator U() const { return (U)val; }\n\tfriend bool operator==(const Mint& a, const Mint& b) { return a.val == b.val; }\n\tfriend bool operator!=(const Mint& a, const Mint& b) { return !(a == b); }\n\tfriend bool operator<(const Mint& a, const Mint& b) { return a.val < b.val; }\n\tMint& operator+=(const Mint& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tMint& operator-=(const Mint& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tMint& operator*=(const Mint& m) { val = (ll)val * m.val % MOD; return *this; }\n\tfriend Mint modex(Mint a, ll p) {\n\t\tassert(p >= 0);\n\t\tMint ans = 1;\n\t\tfor (; p; p >>= 1, a *= a) if (p & 1) ans *= a;\n\t\treturn ans;\n\t}\n\tMint& operator/=(const Mint& m) { return *this *= modex(m, MOD - 2); }\n\tMint& operator++() { return *this += 1; }\n\tMint& operator--() { return *this -= 1; }\n\tMint operator++(int) { Mint result(*this); *this += 1; return result; }\n\tMint operator--(int) { Mint result(*this); *this -= 1; return result; }\n\tMint operator-() const { return Mint(-val); }\n\tfriend Mint operator+(Mint a, const Mint& b) { return a += b; }\n\tfriend Mint operator-(Mint a, const Mint& b) { return a -= b; }\n\tfriend Mint operator*(Mint a, const Mint& b) { return a *= b; }\n\tfriend Mint operator/(Mint a, const Mint& b) { return a /= b; }\n\tfriend ostream& operator<<(ostream& os, const Mint& x) { return os << x.val; }\n};\nconst int MAXN = 200005;\nvector<int> E[MAXN];\nMint F[MAXN][3][3];\nint lim;\nvoid go(int x, int p = -1, int h = 0) {\n\tif (h == lim) return;\n\tvector<vector<Mint>> dp(3, vector<Mint>(3));\n\tdp[0][0] = 1;\n\tfor (int y : E[x]) {\n\t\tif (y == p) continue;\n\t\tgo(y, x, h + 1);\n\t\tvector<vector<Mint>> ndp(3, vector<Mint>(3));\n\t\tfor (int a = 0; a < 3; ++a)\n\t\t\tfor (int b = 0; b < 3; ++b) {\n\t\t\t\tfor (int aa = 0; aa < 3; ++aa)\n\t\t\t\t\tfor (int bb = 0; bb < 3; ++bb) {\n\t\t\t\t\t\tndp[min(a + aa, 2)][b] += dp[a][b] * F[y][aa][bb];\n\t\t\t\t\t\tndp[a][min(b + bb, 2)] += dp[a][b] * F[y][aa][bb];\n\t\t\t\t\t\tndp[a][b] += dp[a][b] * F[y][aa][bb];\n\t\t\t\t\t}\n\t\t\t\tif (h + 1 == lim) {\n\t\t\t\t\tndp[min(a + 1, 2)][b] += dp[a][b];\n\t\t\t\t\tndp[a][min(b + 1, 2)] += dp[a][b];\n\t\t\t\t\tndp[a][b] += dp[a][b];\n\t\t\t\t}\n\t\t\t}\n\t\tswap(dp, ndp);\n\t}\n\tfor (int a = 0; a < 3; ++a)\n\t\tfor (int b = 0; b < 3; ++b)\n\t\t\tF[x][a][b] = dp[a][b];\n}\nint pv[MAXN];\nint mxh, mxv;\nvoid dfs(int x, int p = -1, int h = 0) {\n\tif (h > mxh) {\n\t\tmxh = h;\n\t\tmxv = x;\n\t}\n\tfor (int y : E[x]) {\n\t\tif (y == p) continue;\n\t\tpv[y] = x;\n\t\tdfs(y, x, h + 1);\n\t}\n}\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tE[a].push_back(b);\n\t\tE[b].push_back(a);\n\t}\n\tmxh = -1;\n\tdfs(1);\n\tmxh = -1;\n\tint diam1 = mxv;\n\tdfs(mxv);\n\tint diam2 = mxv;\n\tvector<int> path;\n\tfor (int i = diam2;; i = pv[i]) {\n\t\tpath.push_back(i);\n\t\tif (i == diam1) break;\n\t}\n\tif (mxh % 2 == 0) {\n\t\tlim = mxh / 2;\n\t\tint cen = path[lim];\n\t\tgo(cen);\n\t\tassert(F[cen][0][1] == F[cen][1][0]);\n\t\tassert(F[cen][0][2] == F[cen][2][0]);\n\t\tMint ans = F[cen][1][1] / 2;\n\t\tprintf(\"%d\\n\", ans.val);\n\t} else {\n\t\tlim = mxh / 2;\n\t\tint cen1 = path[lim], cen2 = path[lim + 1];\n\t\tgo(cen1, cen2);\n\t\tMint ans = F[cen1][1][0] + F[cen1][1][1] + F[cen1][1][2];\n\t\tmemset(F, 0, sizeof(F));\n\t\tgo(cen2, cen1);\n\t\tans *= F[cen2][0][1] + F[cen2][1][1] + F[cen2][2][1];\n\t\tprintf(\"%d\\n\", ans.val);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nconst int N=300007,P=998244353,i2=P-P/2;\nint m,root,len,fa[N],dia[N],f[N][3][3],g[3][3];std::vector<int>e[N];\nvoid inc(int&a,int b){a+=b-P,a+=a>>31&P;}\nint mul(int a,int b){return 1ll*a*b%P;}\nint read(){int x=0,c=getchar();while(isspace(c))c=getchar();while(isdigit(c))(x*=10)+=c&15,c=getchar();return x;}\nvoid dfs(int u,int dep)\n{\n    if(dep>len) len=dep,root=u;\n    for(int v:e[u]) if(v^fa[u]) fa[v]=u,dfs(v,dep+1);\n}\nvoid dp(int u,int fa,int d)\n{\n    (d==m/2? f[u][1][1]:f[u][0][0])=1;\n    for(int v:e[u])\n    {\n\tif(v==fa) continue;\n\tdp(v,u,d+1),memset(g,0,36);\n\tfor(int x=0;x<3;++x) for(int y=0;y<3;++y) for(int p=0;p<3;++p) for(int q=0;q<3;++q) for(int k=0,r,t;k<3;++k) r=std::min(2,x+p*(k==1)),t=std::min(2,y+q*(k==2)),inc(g[r][t],mul(f[u][x][y],f[v][p][q]));\n\tmemcpy(f[u],g,36);\n    }\n}\nint main()\n{\n    int n=read(),p,q;\n    for(int i=1,u,v;i<n;++i) u=read(),v=read(),e[u].push_back(v),e[v].push_back(u);\n    dfs(1,1),memset(fa+1,0,n<<2),len=0,dfs(root,1);\n    for(int i=root;i;i=fa[i]) dia[++m]=i;\n    if(m&1) p=dia[m/2+1],dp(p,0,0),printf(\"%d\",mul(i2,f[p][1][1]));\n    else p=dia[m/2],q=dia[m/2+1],dp(p,q,1),dp(q,p,1),printf(\"%d\",mul((1ll*f[p][1][0]+f[p][1][1]+f[p][1][2])%P,(1ll*f[q][1][0]+f[q][1][1]+f[q][1][2])%P));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for (int i = (a); i <= int(b); i++)\n#define per(i, a, b) for (int i = (a); i >= int(b); i--)\n#define fi first\n#define se second\nusing namespace std;\n\nconst int maxn = 2e5, mod = 998244353;\nint n, f[maxn + 3], mx[maxn + 3], se[maxn + 3], g[maxn + 3];\nint far[maxn + 3], h[maxn + 3][2];\nvector<int> G[maxn + 3];\n\nvoid dfs(int u, int p = 0) {\n\trep(i, 0, G[u].size() - 1) {\n\t\tint v = G[u][i];\n\t\tif (v == p) continue;\n\t\tdfs(v, u);\n\t\tf[u] = max(f[u], f[v] + 1);\n\t\tif (!mx[u] || f[v] >= f[mx[u]]) {\n\t\t\tse[u] = mx[u], mx[u] = v;\n\t\t} else if (!se[u] || f[v] >= f[se[u]]) {\n\t\t\tse[u] = v;\n\t\t}\n\t}\n}\n\nvoid down(int u, int p = 0) {\n\trep(i, 0, G[u].size() - 1) {\n\t\tint v = G[u][i];\n\t\tif (v == p) continue;\n\t\tif (v == mx[u]) {\n\t\t\tg[v] = max(g[u], f[se[u]] + 1) + 1;\n\t\t} else {\n\t\t\tg[v] = max(g[u], f[mx[u]] + 1) + 1;\n\t\t}\n\t\tdown(v, u);\n\t}\n\tg[u] = max(f[u], g[u]);\n}\n\nvoid work(int u, int p = 0) {\n\trep(i, 0, G[u].size() - 1) {\n\t\tint v = G[u][i];\n\t\tif (v == p) continue;\n\t\twork(v, u);\n\t\tfar[u] = max(far[u], far[v] + 1);\n\t}\n\tif (!far[u]) {\n\t\th[u][0] = h[u][1] = 1; return;\n\t}\n\tint A = 1, B = 0, C = 3;\n\trep(i, 0, G[u].size() - 1) {\n\t\tint v = G[u][i];\n\t\tif (v == p) continue;\n\t\tint D = 0, E = 0;\n\t\tif (far[v] + 1 != far[u]) {\n\t\t\tD = h[v][0] + h[v][1] * 2ll % mod; \n\t\t} else {\n\t\t\tD = h[v][0] + h[v][1], E = h[v][1];\n\t\t}\n\t\tC = 1ll * C * (h[v][0] + h[v][1] * 2ll) % mod;\n\t\tB = (1ll * B * D + 1ll * A * E) % mod;\n\t\tA = 1ll * A * D % mod;\n\t}\n\th[u][1] = B, h[u][0] = (C - B * 2) % mod;\n\th[u][0] < 0 ? h[u][0] += mod : 0;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tif (n == 1) { puts(\"1\"), exit(0); }\n\trep(i, 1, n - 1) {\n\t\tint u, v; scanf(\"%d %d\", &u, &v);\n\t\tG[u].push_back(v), G[v].push_back(u);\n\t}\n\tf[0] = -1;\n\tdfs(1);\n\tdown(1);\n\tint mn = n;\n\trep(i, 1, n) mn = min(mn, g[i]);\n\tint a = 0, b = 0, c = 0;\n\trep(i, 1, n) if (g[i] == mn) {\n\t\tif (++c == 1) a = i;\n\t\telse if (c == 2) b = i;\n\t\telse exit(1);\n\t}\n\tif (c == 1) {\n\t\tint A = 1, B = 0, C = 0;\n\t\trep(i, 0, G[a].size() - 1) {\n\t\t\tint v = G[a][i];\n\t\t\twork(v, a);\n\t\t\tint D = 0, E = 0;\n\t\t\tif (far[v] + 1 != g[a]) {\n\t\t\t\tD = h[v][0] + h[v][1] * 2ll % mod;\n\t\t\t} else {\n\t\t\t\tD = h[v][0] + h[v][1], E = h[v][1];\n\t\t\t}\n\t\t\tC = (1ll * C * D + 1ll * B * E) % mod;\n\t\t\tB = (1ll * B * D + 1ll * A * E) % mod;\n\t\t\tA = 1ll * A * D % mod;\n\t\t}\n\t\tprintf(\"%d\\n\", C);\n\t} else {\n\t\twork(a, b);\n\t\twork(b, a);\n\t\tprintf(\"%d\\n\", int(1ll * h[a][1] * h[b][1] % mod));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <bits/stdc++.h>\n#include <random>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define sz(x) ((int)(x).size())\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef double db;\nmt19937 mrand(random_device{}());\nconst ll mod = 998244353;\nint rnd(int x) { return mrand() % x; }\nll powmod(ll a, ll b) { ll res = 1; a %= mod; assert(b >= 0); for (; b; b >>= 1) { if (b & 1)res = res * a%mod; a = a * a%mod; }return res; }\nll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\n// head\n\n#define LL long long\n\nconst int MAXN = 200005;\nvoid ad(int &x, int y) { x += y; if (x >= mod)x -= mod; }\nvector<int> nxt[MAXN];\nvoid ins(int x, int y) { nxt[x].emplace_back(y); }\nint dis[MAXN], sta[MAXN], tp, n;\nvoid dfs(int x, int fa) { for (auto y : nxt[x])if (y^fa)dis[y] = dis[x] + 1, dfs(y, x); }\nbool getpath(int x, int fa, int ed)\n{\n\tif (x == ed) { sta[++tp] = x; return true; }\n\tfor (auto y : nxt[x])if ((y^fa) && getpath(y, x, ed)) { sta[++tp] = x; return true; }\n\treturn false;\n}\nint f[MAXN][3]; //f[x][0]以x为根的子树不包含直径的可能数; \n\t\t\t\t//f[x][1]以x为根的子树包含恰好一条直径的可能数\n\t\t\t\t//f[x][2]以x为根的子树包含2个及以上直径的可能数\nint trans[3]; \nbool tag[MAXN];\n\nvoid dp(int x, int fa)\n{\n\t//leaf\n\tif (sz(nxt[x]) == 1) {\n\t\tif (tag[x]) f[x][1] = 1, f[x][0] = 2;\n\t\telse f[x][0] = 3;\n\t\treturn;\n\t}\n\tf[x][0] = 1;\n\tfor (auto y : nxt[x])if (y^fa)dp(y, x);\n\tfor (auto y : nxt[x])\n\t\tif (y^fa) {\n\t\t\tmemset(trans, 0, sizeof(trans));\n\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t\t\tif (f[x][i] && f[y][j])\n\t\t\t\t\t\tad(trans[min(2, i + j)], 1LL * f[x][i] * f[y][j] % mod);//+1\n\t\t\tfor (int i = 0; i < 3; i++)\tf[x][i] = trans[i];\n\t\t}\n\tf[x][0] = (3LL * f[x][0] + 2LL * (f[x][1] + f[x][2])) % mod;\n}\n\nint ans[3];\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//\tfreopen(\"a.in\",\"r\",stdin);\n\t//\tfreopen(\"a.out\",\"w\",stdout);\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tins(x, y); ins(y, x);\n\t}\n\tdfs(1, 0); \n\tint p = 0, q = 0; \n\tfor (int i = 1; i <= n; i++)if (dis[i] > dis[p])p = i;\n\tdis[p] = 0; \n\tdfs(p, 0); \n\tfor (int i = 1; i <= n; i++)if (dis[i] > dis[q])q = i;\n\tgetpath(p, 0, q);\n\tif (tp & 1) {\n\t\tint u = sta[tp / 2 + 1]; dis[u] = 0; dfs(u, 0);\n\t\tfor (int i = 1; i <= n; i++)if (dis[i] == tp / 2)tag[i] = 1;\n\t\tans[0] = 1;\n\t\tfor (auto y : nxt[u]) {\n\t\t\tdp(y, u); \n\t\t\t//int x0 = (f[y][0] - (f[y][1] + f[y][2]) % mod + mod) % mod, x1 = f[y][1];\n\t\t\tint x0 = f[y][0], x1 = f[y][1];\n\t\t\tans[2] = (1LL * ans[2] * x0 + 1LL * ans[1] * x1) % mod;\n\t\t\tans[1] = (1LL * ans[1] * x0 + 1LL * ans[0] * x1) % mod;\n\t\t\tans[0] = 1LL * ans[0] * x0 % mod;\n\t\t}\n\t\tcout << ans[2] << endl;\n\t\t//cout << \"-----\" << endl;\n\t}\n\telse {\n\t\tint u = sta[tp / 2], v = sta[tp / 2 + 1]; dis[u] = dis[v] = 0; dfs(u, v); dfs(v, u);\n\t\tfor (int i = 1; i <= n; i++)if (dis[i] == (tp - 1) / 2)tag[i] = 1;\n\t\tdp(u, v); dp(v, u); \n\t\tcout << (1LL * f[u][1] * f[v][1] % mod) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 114514*2\n#define mod 998244353\n#define int long long \nvoid add(int&x,int y){\n\tx=(x+y)%mod;\n}\nint dp[nn][4][4],n,diam,c1,c2;\nvector<int> v[nn];int chk[nn];\nint dep[nn],pa[nn];\nvoid dfs(int x,int p,int slg=0){\n\tif(!p or slg) dep[x]=0;else dep[x]=dep[p]+1;pa[x]=p;\n\tfor(int i=0;i<v[x].size();i++) if(v[x][i]!=p) dfs(v[x][i],x);\n}\nint walk(int x,int d){\n\tif(d==0) return x;\n\treturn walk(pa[x],d-1);\n}\nint mst(){\n\tint ret=0;for(int i=1;i<=n;i++) ret=max(ret,dep[i]);for(int i=1;i<=n;i++) if(dep[i]==ret) return i;\n}\nint f[2][4];int tmp[4][4];\n\nvoid copy(int x){\n\tfor(int i=0;i<4;i++) for(int j=0;j<4;j++) tmp[i][j]=dp[x][i][j],dp[x][i][j]=0;\n}\n\nvoid efs(int x,int p){\n\tdp[x][3*(dep[x]==diam/2)][0]=1;int leaf=1;\n\tfor(int i=0;i<v[x].size();i++) if(v[x][i]!=p){\n\t\tefs(v[x][i],x);\n\t\tleaf=0;\n\t\tcopy(x);\n\t\tfor(int j=0;j<16;j++) for(int k=0;k<16;k++) add(dp[x][(j%4)|(k%4)][(j/4)|(k/4)|((j%4)&(k%4))],tmp[k%4][k/4]*dp[v[x][i]][j%4][j/4]);\n\t}\n\t\n\tif(dep[x]!=diam/2 and leaf and 0) dp[x][0][0]=3;\n\telse if(x!=c1 and x!=c2){\n\t\tcopy(x);\n\t\tfor(int k=0;k<16;k++) for(int j=0;j<=2;j++) add(dp[x][(k%4)&j][(k/4)&j],tmp[k%4][k/4]);\n\t}\n}\n\n\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tif(n<=2) return puts(\"1\")*0;\n\t\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;scanf(\"%lld%lld\",&x,&y);\n\t\tv[x].push_back(y);v[y].push_back(x);\n\t}\n\t\n\tdfs(1,0);int x=mst();\n\tdfs(x,0);int y=mst();\n\tdiam=dep[y];\n\tif(diam%2==0){\n\t\tc1=walk(y,diam/2);\n\t\tint now=0;f[now][0]=1;dfs(c1,0);efs(c1,0);\n/*\t\tfor(int i=0;i<v[c1].size();i++) {\n\t\t\tefs(v[c1][i],c1);\n\t\t\tnow^=1;memset(f[now],0,sizeof f[now]);\n\t\t\tfor(int j=0;j<4;j++) for(int k=0;k<4;k++) add(f[now][j|k],dp[v[c1][i]][j][0]*f[now^1][k]);\n\t\t}\n\t\tcout<<f[now][3];*/\n\t\tcout<<dp[c1][3][0]*(mod+1)/2%mod;\n\t}\n\telse{\n\t\tc1=walk(y,diam/2);\n\t\tdfs(y,0);\n\t\tc2=walk(x,diam/2);\n\t\t\n\t\tdfs(c1,c2,1);dfs(c2,c1,1);\n\t\tefs(c1,c2);\n\t\tefs(c2,c1);\n\t\t\n\t\tcout<<dp[c1][1][0]*dp[c2][2][0]%mod;\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define endl \"\\n\";\n\nconst i64 MOD = 998244353;\n\nint main()\n{\n  i64 N;\n  cin >> N;\n  vector<i64> a(N - 1), b(N - 1);\n  for (i64 i = 0; i < N - 1; i++)\n    cin >> a[i] >> b[i];\n  srand(N * time(NULL));\n  cout << rand() % MOD << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll mod = 998244353;\nvector<int>pat[202020];\nint dep[202020];\nbool flag[202020];\nint diam = 0;\nbool iscent[202020];\nvector<int>ko[202020];\nvoid dfs(int node, int d)\n{\n\tflag[node] = true;\n\tdep[node] = d;\n\tdiam = max(diam, d);\n\tfor (int i = 0; i < pat[node].size(); i++)if (!flag[pat[node][i]])dfs(pat[node][i], d + 1);\n}\nvoid dfs2(int node, int d)\n{\n\tflag[node] = true;\n\tdep[node] = d;\n\tfor (int i = 0; i < pat[node].size(); i++)\n\t{\n\t\tif (!flag[pat[node][i]] && !iscent[pat[node][i]])\n\t\t{\n\t\t\tdfs2(pat[node][i], d + 1);\n\t\t\tko[node].push_back(pat[node][i]);\n\t\t}\n\t}\n}\ntypedef pair<ll, ll>pii;\nint siz[202020];\nint p3[202020];\npii calc(int node)\n{\n\tif (ko[node].empty())\n\t{\n\t\tsiz[node] = 1;\n\t\tif (dep[node] == diam / 2)return make_pair(1, 2);\n\t\telse return make_pair(0, 3);\n\t}\n\tvector<pii>v;\n\tsiz[node] = 1;\n\tfor (int i = 0; i < ko[node].size(); i++)v.push_back(calc(ko[node][i])), siz[node] += siz[ko[node][i]];\n\tvector<ll>r1, r2;\n\tr1.resize(v.size() + 1), r1[0] = 1;\n\tr2.resize(v.size() + 1), r2[v.size()] = 1;\n\tfor (int i = 0; i < v.size(); i++)r1[i + 1] = r1[i] * v[i].second%mod;\n\tfor (int i = v.size() - 1; i >= 0; i--)r2[i] = r2[i + 1] * v[i].second%mod;\n\tll t1 = 0, t2 = 1;\n\tfor (int i = 0; i < v.size(); i++)\n\t{\n\t\tt1 = (t1 + r1[i] * r2[i + 1] % mod*v[i].first) % mod;\n\t\tt2 = t2*v[i].second%mod;\n\t}\n\tt2 = (t2 + p3[siz[node] - 1] * 2) % mod;\n\t//printf(\"%d %d   %lld %lld\\n\", node + 1, siz[node], t1, t2);\n\treturn make_pair(t1, t2);\n}\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < num - 1; i++)\n\t{\n\t\tint za, zb;\n\t\tscanf(\"%d%d\", &za, &zb);\n\t\tza--, zb--;\n\t\tpat[za].push_back(zb);\n\t\tpat[zb].push_back(za);\n\t}\n\tdfs(0, 0);\n\tint r = 0;\n\tfor (int i = 0; i < num; i++)if (dep[i] == diam)r = i;\n\tfill(flag, flag + num, false);\n\tdfs(r, 0);\n\tint now;\n\tfor (int i = 0; i < num; i++)if (dep[i] == diam)now = i;\n\tvector<int>path;\n\tfor (int i = 0; i < diam; i++)\n\t{\n\t\tpath.push_back(now);\n\t\tfor (int j = 0; j < pat[now].size(); j++)\n\t\t{\n\t\t\tif (dep[pat[now][j]] == dep[now] - 1)\n\t\t\t{\n\t\t\t\tnow = pat[now][j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpath.push_back(now);\n\tp3[0] = 1;\n\tfor (int i = 0; i < num + 10; i++)p3[i + 1] = p3[i] * 3 % mod;\n\t//for (int i = 0; i < path.size(); i++)printf(\"%d \", path[i] + 1); printf(\"\\n\");\n\n\n\tif (diam % 2 == 0)\n\t{\n\t\tint c = path[diam / 2];\n\t\tfill(flag, flag + num, false);\n\t\tiscent[c] = true;\n\t\tdfs2(c, 0);\n\t\tll d0 = 1, d1 = 0, d2 = 0, d3 = 0;\n\t\tfor (int i = 0; i < ko[c].size(); i++)\n\t\t{\n\t\t\tpii z = calc(ko[c][i]);\n\t\t\tll x = z.second + z.second - p3[siz[ko[c][i]]];\n\t\t\tll e0 = d0*(z.second - z.first);\n\t\t\tll e1 = d0*z.first + d1*x;\n\t\t\tll e2 = d0*z.first + d2*x;\n\t\t\tll e3 = d1*z.first + d2*z.first + d3*x;\n\t\t\td0 = (e0%mod + mod) % mod;\n\t\t\td1 = (e1%mod + mod) % mod;\n\t\t\td2 = (e2%mod + mod) % mod;\n\t\t\td3 = (e3%mod + mod) % mod;\n\t\t}\n\t\tprintf(\"%lld\\n\", d3*(mod + 1) / 2 % mod);\n\t}\n\telse\n\t{\n\t\tabort();\n\t\tint c1 = path[diam / 2], c2 = path[(diam + 1) / 2];\n\t\tfill(flag, flag + num, false);\n\t\tiscent[c1] = iscent[c2] = true;\n\t\tdfs2(c1, 0), dfs2(c2, 0);\n\n\t\tpii a = calc(path[diam / 2]), b = calc(path[(diam + 1) / 2]);\n\t\tprintf(\"%lld\\n\", a.first*b.first%mod);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<ll,ll>\n#define poly vector<ll>\n#define mem(a) memset((a),0,sizeof(a))\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\n#define SZ(x) ((int)(x.size()))\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\nll rnd(){\n\tull ans=0;\n\tFor(i,0,4)ans=ans<<15^rand();\n\treturn ans%((ull)1<<63);\n}\nconst int N=200005,mod=998244353;\nint n,rt,dep[N],mx[N],fa[N];\nll dp[N][3],jb[3];\nvector<int> v[N];\ninline void add(ll &a,ll b){\n\ta=(a+b)%mod;\n}\nvoid dfs(int p){\n\tdep[p]=dep[fa[p]]+1;\n\tif(dep[p]>dep[rt])rt=p;\n\tfor(auto i:v[p])if(i!=fa[p]){\n\t\tfa[i]=p; dfs(i);\n\t}\n}\nvoid solve(int rt,int fa){\n\tdp[rt][v[rt].size()==1]=1;\n\tfor(auto i:v[rt])if(i!=fa){\n\t\tsolve(i,rt); mx[rt]=max(mx[rt],mx[i]+1);\n\t}\n\tfor(auto i:v[rt])if(i!=fa){//分别表示 几个满的 \n\t\tif(mx[i]+1!=mx[rt]){\n\t\t\tdp[i][0]+=dp[i][1]+dp[i][2]; dp[i][1]=dp[i][2]=0;\n\t\t}\n\t\tmem(jb);\n\t\tRep(j,2,0){\n\t\t\tRep(k,2,0)add(jb[min(2,j+k)],dp[rt][j]*dp[i][k]);\n\t\t}\n\t\tswap(jb,dp[rt]);\n\t}\n\tdp[rt][0]=(dp[rt][0]*3+dp[rt][1]*2+dp[rt][2]*2)%mod;\n}\nint main(){\n\t#ifdef Brollan\n\t\tfreopen(\"std.in\",\"r\",stdin);\n\t#endif\n\tn=read(); \n\tFor(i,1,n-1){\n\t\tint s=read(),t=read();\n\t\tv[s].pb(t); v[t].pb(s);\n\t}\n\t\n\tdfs(1);\n\tint t=rt; rt=0; fa[t]=0;\n\tdfs(t);\n\tint len=dep[rt];//cerr<<t<<\" \"<<rt<<\" \"<<dep[rt]<<endl;\n\tFor(j,1,(len-1)/2)rt=fa[rt];\n\tif(len%2==0){\n\t\tint A=rt,B=fa[rt];\n\t\t//cout<<A<<\" \"<<B<<endl;\n\t\tsolve(A,B);\n\t\tsolve(B,A);\n\t\tcout<<dp[A][1]*dp[B][1]%mod<<endl;\n\t}else{\n\t\tdp[rt][0]=1;\n\t\tfor(auto i:v[rt]){\n\t\t\tsolve(i,rt); \n\t\t\tif(mx[i]+1<len/2){dp[i][0]+=dp[i][1]+dp[i][2]; dp[i][1]=dp[i][2]=0;}\n\t\t\telse dp[i][0]+=mod-dp[i][1]+mod-dp[i][2];\n\t\t\t//cout<<dp[i][1]<<\" \"<<dp[i][0]%mod<<\" \"<<dp[rt][1]<<endl;\n\t\t\tmem(jb);\n\t\t\tRep(j,2,0)Rep(k,1,0){\n\t\t\t\tif(j+k<=2)add(jb[j+k],dp[rt][j]*dp[i][k]);\n\t\t\t}\n\t\t\tswap(jb,dp[rt]);\n\t\t}\n\t\tcout<<dp[rt][2]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[202020];\nconst ll mo=998244353;\nll dp[202020][3][3];\n\npair<int,int> farthest(int cur,int pre,int d,vector<int>& D) {\n\tD[cur]=d;\n\tpair<int,int> r={d,cur};\n\tFORR(e,E[cur]) if(e!=pre) r=max(r, farthest(e,cur,d+1,D));\n\treturn r;\n}\n\npair<int,vector<int>> diameter() { // diameter,center\n\tvector<int> D[2];\n\tD[0].resize(N);\n\tD[1].resize(N);\n\tauto v1=farthest(0,0,0,D[0]);\n\tauto v2=farthest(v1.second,v1.second,0,D[0]);\n\tfarthest(v2.second,v2.second,0,D[1]);\n\tpair<int,vector<int>> R;\n\tR.first = v2.first;\n\t//重心を取る場合\n\tfor(int i=N-1;i>=0;i--) if(D[0][i]+D[1][i]==R.first && abs(D[0][i]-D[1][i])<=1) R.second.push_back(i);\n\n\treturn R;\n}\n\nvoid dfs(int cur,int pre,int lef) {\n\tif(lef==0) {\n\t\tdp[cur][1][1]=1;\n\t}\n\telse {\n\t\tdp[cur][0][0]=1;\n\t}\n\t\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\tdfs(e,cur,lef-1);\n\t\tll to[3][3]={};\n\t\tint a1,a2,b1,b2;\n\t\tFOR(a1,3) FOR(a2,3) FOR(b1,3) FOR(b2,3) {\n\t\t\t// +1\n\t\t\tto[min(a1+b1,2)][a2]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t\t// 0\n\t\t\tto[a1][a2]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t\t// -1\n\t\t\tto[a1][min(a2+b2,2)]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t}\n\t\t\n\t\tFOR(a1,3) FOR(a2,3) dp[cur][a1][a2]=to[a1][a2]%mo;\n\t}\n\t\n\t\n\t\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tauto R=diameter();\n\tif(R.second.size()==1) {\n\t\tx=R.second[0];\n\t\tdfs(x,-1,R.first/2);\n\t\tcout<<dp[x][1][1]*((mo+1)/2)%mo<<endl;\n\t}\n\telse {\n\t\tx=R.second[0];\n\t\ty=R.second[1];\n\t\tdfs(x,y,R.first/2);\n\t\tdfs(y,x,R.first/2);\n\t\tFOR(i,3) FOR(j,3) assert(dp[x][i][j]==dp[x][j][i]);\n\t\tFOR(i,3) FOR(j,3) assert(dp[y][i][j]==dp[y][j][i]);\n\t\t\n\t\tcout<<dp[x][0][1]*dp[y][1][0]%mo<<endl;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat mod = 998244353;\nvector<cat> pw3(200010);\n\nint DFS_dp(int R, int par, int dep, int D, auto & G, vector<cat> * dp) {\n\tif(dep == D) {\n\t\tdp[0][R] = 2, dp[1][R] = 1;\n\t\treturn 1;\n\t}\n\tdp[0][R] = 1;\n\tint sz = 1;\n\tfor(auto s : G[R]) if(s != par) {\n\t\tsz += DFS_dp(s, R, dep+1, D, G, dp);\n\t\tdp[1][R] = (dp[1][R] * dp[0][s] + dp[0][R] * dp[1][s]) % mod;\n\t\tdp[0][R] = dp[0][R] * dp[0][s] % mod;\n\t}\n\tdp[0][R] = (dp[0][R] + pw3[sz-1] * 2) % mod;\n\treturn sz;\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N;\n\tcin >> N;\n\tpw3[0] = 1;\n\tfor(int i = 1; i <= N; i++) pw3[i] = pw3[i-1] * 3 % mod;\n\tvector< vector<int> > G(N);\n\tfor(int i = 0; i < N-1; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tG[--u].push_back(--v);\n\t\tG[v].push_back(u);\n\t}\n\tvector<int> dist[2];\n\tdist[0] = vector<int>(N, N);\n\tdist[0][0] = 0;\n\tqueue<int> q;\n\tq.push(0);\n\twhile(!q.empty()) {\n\t\tfor(auto v : G[q.front()]) if(dist[0][v] == N) {\n\t\t\tdist[0][v] = dist[0][q.front()]+1;\n\t\t\tq.push(v);\n\t\t}\n\t\tq.pop();\n\t}\n\tint max_dv = 0;\n\tfor(int i = 0; i < N; i++)\n\t\tif(dist[0][max_dv] < dist[0][i]) max_dv = i;\n\tdist[1] = vector<int>(N, N);\n\tdist[1][max_dv] = 0;\n\tq.push(max_dv);\n\tvector<int> par(N);\n\twhile(!q.empty()) {\n\t\tfor(auto v : G[q.front()]) if(dist[1][v] == N) {\n\t\t\tdist[1][v] = dist[1][q.front()]+1;\n\t\t\tpar[v] = q.front();\n\t\t\tq.push(v);\n\t\t}\n\t\tq.pop();\n\t}\n\tint other_end = 0;\n\tfor(int i = 0; i < N; i++)\n\t\tif(dist[1][other_end] < dist[1][i]) other_end = i;\n\tint D = dist[1][other_end];\n\tint R = other_end;\n\tfor(int i = 0; i < D/2; i++) R = par[R];\n\tif(D%2) {\n\t\tG.push_back({R, par[R]});\n\t\tG[R].erase(find(begin(G[R]), end(G[R]), par[R]));\n\t\tG[par[R]].erase(find(begin(G[par[R]]), end(G[par[R]]), R));\n\t\tG[R].push_back(N);\n\t\tG[par[R]].push_back(N);\n\t\tR = N;\n\t\tN++, D++;\n\t}\n\tD /= 2;\n\tvector<cat> dp[2] = {vector<cat>(N, 0), vector<cat>(N, 0)};\n\tDFS_dp(R, R, 0, D, G, dp);\n\tcat ans[3] = {1, 0, 0};\n\tfor(auto s : G[R]) {\n\t\tans[2] = (ans[1] * dp[1][s] + ans[2] * dp[0][s]) % mod;\n\t\tans[1] = (ans[0] * dp[1][s] + ans[1] * dp[0][s]) % mod;\n\t\tans[0] = (ans[0] * dp[0][s]) % mod;\n\t}\n\tcout << ans[2] << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\n#define N 200020\nconst int mod=998244353;\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,dep[N],root,f[N],L,dp[N][3][3];\nvector<int> G[N],D;\nvoid init(int u,int fa){\n\tdep[u]=dep[fa]+1;\n\tf[u]=fa;\n\tif(dep[u]>L){\n\t\tL=dep[u],root=u;\n\t}\n\tfor(auto v:G[u]){\n\t\tif(v==fa)continue;\n\t\tinit(v,u);\n\t}\n}\nvoid dfs(int u,int fa,int dep){\n\tif(dep==(D.size()-1)/2){\n\t\tdp[u][1][1]=1;\n\t}\n\telse{\n\t\tdp[u][0][0]=1;\n\t}\n\tfor(auto v:G[u]){\n\t\tif(v==fa)continue;\n\t\tdfs(v,u,dep+1);\n\t\tstatic int g[3][3];\n\t\tmemset(g,0,sizeof(g));\n\t\tfor(int i=0;i<3;++i){\n\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\tfor(int x=0;x<3;++x){\n\t\t\t\t\tfor(int y=0;y<3;++y){\n\t\t\t\t\t\tfor(int k=0;k<3;++k){\n\t\t\t\t\t\t\tint a=min(2,i+x*(k==1));\n\t\t\t\t\t\t\tint b=min(2,j+y*(k==2));\n\t\t\t\t\t\t\tg[a][b]=(g[a][b]+1LL*dp[u][i][j]*dp[v][x][y])%mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemcpy(dp[u],g,sizeof(dp[u]));\n\t}\n}\nint main(){\n\tn=read();\n\tfor(int i=1;i<n;++i){\n\t\tint u=read(),v=read();\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tinit(1,0);\n\tL=0;\n\tinit(root,0);\n\tfor(int u=root;u;u=f[u]){\n\t\tD.push_back(u);\n\t}\n\tif(D.size()&1){\n\t\tint x=D[D.size()>>1];\n\t\tdfs(x,0,0);\n\t\tprintf(\"%lld\\n\",1LL*dp[x][1][1]*((mod+1)/2)%mod);\n\t}\n\telse{\n\t\tint x=D[(D.size()>>1)-1],y=D[D.size()>>1];\n\t\tdfs(x,y,0),dfs(y,x,0);\n\t\tprintf(\"%lld\\n\",(1LL*dp[x][1][0]+dp[x][1][1]+dp[x][1][2])*(1LL*dp[y][0][1]+dp[y][1][1]+dp[y][2][1])%mod);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[202020];\nconst ll mo=998244353;\n\npair<int,int> farthest(int cur,int pre,int d,vector<int>& D) {\n\tD[cur]=d;\n\tpair<int,int> r={d,cur};\n\tFORR(e,E[cur]) if(e!=pre) r=max(r, farthest(e,cur,d+1,D));\n\treturn r;\n}\n\npair<int,vector<int>> diameter() { // diameter,center\n\tvector<int> D[2];\n\tD[0].resize(N);\n\tD[1].resize(N);\n\tauto v1=farthest(0,0,0,D[0]);\n\tauto v2=farthest(v1.second,v1.second,0,D[0]);\n\tfarthest(v2.second,v2.second,0,D[1]);\n\tpair<int,vector<int>> R;\n\tR.first = v2.first;\n\t//重心を取る場合\n\tfor(int i=N-1;i>=0;i--) if(D[0][i]+D[1][i]==R.first && abs(D[0][i]-D[1][i])<=1) R.second.push_back(i);\n\n\treturn R;\n}\n\nvector<ll> dfs1(int cur,int pre,int lef,int no=0) {\n\tif(E[cur].size()==1) {\n\t\tif(lef==0) return {2,1,0};\n\t\telse return {3,0,0};\n\t}\n\telse {\n\t\tvector<ll> X={1,0,0};\n\t\tFORR(e,E[cur]) if(e!=pre) {\n\t\t\tvector<ll> Y=dfs1(e,cur,lef-1);\n\t\t\tvector<ll> Z={0,0,0};\n\t\t\tZ[0]=X[0]*Y[0];\n\t\t\tZ[1]=X[1]*Y[0]+X[0]*Y[1];\n\t\t\tZ[2]=X[0]*Y[2]+X[1]*Y[2]+X[2]*Y[2]+X[2]*Y[1]+X[2]*Y[0]+X[1]*Y[1];\n\t\t\tX[0]=Z[0]%mo;\n\t\t\tX[1]=Z[1]%mo;\n\t\t\tX[2]=Z[2]%mo;\n\t\t}\n\t\tvector<ll> Y={0,0,0};\n\t\tif(no) {\n\t\t\tY=X;\n\t\t}\n\t\telse {\n\t\t\tY[0]=(X[0]*3+X[1]*2+X[2]*2)%mo;\n\t\t\tY[1]=X[1];\n\t\t\tY[2]=X[2];\n\t\t}\n\t\treturn Y;\n\t}\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tauto R=diameter();\n\tif(R.second.size()==1) {\n\t\tvector<ll> X={1,0,0,0};\n\t\tFORR(e,E[R.second[0]]) {\n\t\t\tauto Y=dfs1(e,R.second[0],R.first/2-1);\n\t\t\tvector<ll> Z={0,0,0,0};\n\t\t\tFOR(x,4) FOR(y,3) Z[min(x+y,3)]+=X[x]*Y[y]%mo;\n\t\t\tFOR(x,4) X[x]=Z[x]%mo;\n\t\t}\n\t\tcout<<X[2]<<endl;\n\t}\n\telse {\n\t\tvector<ll> X=dfs1(R.second[0],R.second[1],R.first/2,1);\n\t\tvector<ll> Y=dfs1(R.second[1],R.second[0],R.first/2,1);\n\t\tcout<<X[1]*Y[1]%mo<<endl;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<ll,ll>\n#define poly vector<ll>\n#define mem(a) memset((a),0,sizeof(a))\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\n#define SZ(x) ((int)(x.size()))\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\nll rnd(){\n\tull ans=0;\n\tFor(i,0,4)ans=ans<<15^rand();\n\treturn ans%((ull)1<<63);\n}\nconst int N=200005,mod=998244353;\nint n,rt,dep[N],mx[N],fa[N];\nll dp[N][3],jb[3];\nvector<int> v[N];\ninline void add(ll &a,ll b){\n\ta=(a+b)%mod;\n}\nvoid dfs(int p){\n\tdep[p]=dep[fa[p]]+1;\n\tif(dep[p]>dep[rt])rt=p;\n\tfor(auto i:v[p])if(i!=fa[p]){\n\t\tfa[i]=p; dfs(i);\n\t}\n}\nvoid solve(int rt,int fa){\n\tdp[rt][v[rt].size()==1]=1;\n\tfor(auto i:v[rt])if(i!=fa){\n\t\tsolve(i,rt); mx[rt]=max(mx[rt],mx[i]+1);\n\t}\n\tfor(auto i:v[rt])if(i!=fa){//分别表示 几个满的 \n\t\tif(mx[i]+1!=mx[rt]){\n\t\t\tdp[i][0]+=dp[i][1]+dp[i][2]; dp[i][1]=dp[i][2]=0;\n\t\t}\n\t\tmem(jb);\n\t\tRep(j,2,0){\n\t\t\tRep(k,2,0)add(jb[min(2,j+k)],dp[rt][j]*dp[i][k]);\n\t\t}\n\t\tswap(jb,dp[rt]);\n\t}\n\tdp[rt][0]=(dp[rt][0]*3+dp[rt][1]*2+dp[rt][2]*2)%mod;\n}\nint main(){\n\t#ifdef Brollan\n\t\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tn=read(); \n\tFor(i,1,n-1){\n\t\tint s=read(),t=read();\n\t\tv[s].pb(t); v[t].pb(s);\n\t}\n\t\n\tdfs(1);\n\tint t=rt; rt=0; fa[t]=0;\n\tdfs(t);\n\tint len=dep[rt];//cerr<<t<<\" \"<<rt<<\" \"<<dep[rt]<<endl;\n\tFor(j,1,len/2)rt=fa[rt];\n\tif(len%2==0){\n\t\tint A=rt,B=fa[rt];\n\t\tsolve(A,B);\n\t\tsolve(B,A);\n\t\tcout<<dp[A][1]*dp[B][1]%mod<<endl;\n\t}else{\n\t\tdp[rt][0]=1;\n\t\tfor(auto i:v[rt]){\n\t\t\tsolve(i,rt); \n\t\t\tif(mx[i]+1<len/2){dp[i][0]+=dp[i][1]+dp[i][2]; dp[i][1]=dp[i][2]=0;}\n\t\t\telse dp[i][0]+=mod-dp[i][1];\n\t\t\t//cout<<dp[i][1]<<\" \"<<dp[i][0]<<\" \"<<dp[rt][1]<<endl;\n\t\t\tmem(jb);\n\t\t\tRep(j,2,0)Rep(k,1,0){\n\t\t\t\tif(j+k<=2)add(jb[j+k],dp[rt][j]*dp[i][k]);\n\t\t\t}\n\t\t\tswap(jb,dp[rt]);\n\t\t}\n\t\tcout<<dp[rt][2]<<endl;\n\t}\n}\n/*\nt t+1 (a+1)t+a+b+1\nc(at+b)+d\na(ct+d)+b\nact+bc+d\nact+ad+b\nb/(a-1)<d/(c-1)\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i,a,b) for (int i=int(a);i<=int(b);i++)\n#define R(i,a,b) for (int i=int(a);i<int(b);i++)\n#define D(i,a,b) for (int i=int(a);i>=int(b);i--)\n#define go(i,x) for (int i=head[x];i;i=Next[i])\n#define pb push_back\n#define si size()\n#define fi first\n#define se second\n#define pa pair < ll,ll >\n#define ll long long\n#define mp make_pair\n#define be begin()\n#define en end()\n#define put putchar('\\n')\n#define gc getchar\n#define pc putchar\n#define N 6000055\n#define mo 998244353\n#define inf 1000000007\n#define ret return puts(\"-1\"),0\nusing namespace std;\ninline ll read(){\n\tll su=0,f=1;char c=gc();\n\tfor (;c<'0'||c>'9';c=gc()) if (c=='-') f=-1;\n\tfor (;c>='0'&&c<='9';c=gc()) su=su*10+c-'0';\n\treturn su*f;\n}\ninline void wr(ll x){\n\tif (x<0) pc('-'),wr(-x);\n\telse{if (x>=10) wr(x/10);pc(x%10+'0');}\n}\ninline void wri(ll x){wr(x);pc(' ');}\ninline void wrn(ll x){wr(x);put;}\ninline void wrn(ll x,ll y){wri(x);wrn(y);}\ninline void wrn(ll x,ll y,ll z){wri(x);wrn(y,z);}\nint ans,n,m,f[N][2],fa[N],dis[N],lo,rt,mx;\ninline void ad(int &x,int k){x+=k;x-=(x>=mo)?mo:0;}\nint Next[N*2],head[N],to[N*2],nedge;\n#define V to[i]\nvoid add(int a,int b){Next[++nedge]=head[a];head[a]=nedge;to[nedge]=b;}\nvoid add_ne(int a,int b){add(a,b);add(b,a);}\nvoid dfs(int x){\n\tmx=(dis[x]>dis[mx])?x:mx;\n\tgo(i,x){\n\t\tif (V==fa[x]) continue;\n\t\tfa[V]=x;dis[V]=dis[x]+1;dfs(V);\n\t}\n}\nint ksm(ll x,int k){\n\tint su=1;\n\tfor (;k;k>>=1,x=x*x%mo) if (k&1) su=su*x%mo;\n\treturn su;\n}\nvoid solve(int x){\n\tint pd=0;\n\tf[x][0]=1;\n\tgo(i,x){\n\t\tif (V==fa[x]) continue;\n\t\tsolve(V);pd++;\n\t\tf[x][1]=1ll*f[x][1]*f[V][0]%mo;\n\t\tad(f[x][1],1ll*f[x][0]*f[V][1]%mo);\n\t\tf[x][0]=1ll*f[x][0]*f[V][0]%mo;\n\t}\n\tif (pd){\n\t\tf[x][0]=1ll*f[x][0]*3%mo;\n\t\tad(f[x][0],f[x][1]*2%mo);\n\t}\n\telse{\n\t\tif (dis[x]==lo/2) f[x][1]=1,f[x][0]=2;\n\t\telse f[x][0]=3;\n\t}\n}\nsigned main(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\tn=read();\n\tR(i,1,n) add_ne(read(),read());\n\tdfs(1);\n\trt=mx;mx=0;dis[rt]=0;fa[rt]=0;\n\tdfs(rt);\n\tlo=dis[mx];\n\tF(i,1,lo/2) mx=fa[mx];\n\tif (lo&1){\n\t\tint x=mx,y=fa[mx];\n\t\tfa[y]=x;dis[x]=dis[y]=0;dfs(x);dfs(y);\n\t\t//solve(x);solve(y);\n\t\twrn(ksm(3,n-lo-1));\n\t}\n\telse{\n\t\tint x=mx,nu=0;\n\t\tfa[x]=0;dis[x]=0;dfs(x);\n\t\tF(i,1,n) if (dis[i]==lo/2) nu++;\n\t\t//ans=(1ll*nu*(nu-1)/2)%mo*ksm(3,n-lo-1)%mo;\n\t\tsolve(x);\n\t\tf[x][0]=1;f[x][1]=0;\n\t\tgo(i,x){\n\t\t\tans=1ll*ans*f[x][0]%mo;\n\t\t\tad(ans,1ll*f[x][1]*f[V][1]%mo);\n\t\t\tf[x][1]=1ll*f[x][1]*f[V][0]%mo;\n\t\t\tad(f[x][1],1ll*f[x][0]*f[V][1]%mo);\n\t\t\tf[x][0]=1ll*f[x][0]*f[V][0]%mo;\t\t\t\n\t\t}\n\t\twrn(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 114514*2\n#define mod 998244353\n#define int long long \nvoid add(int&x,int y){\n\tx=(x+y)%mod;\n}\nint dp[nn][4][4],n,diam,c1,c2;\nvector<int> v[nn];int chk[nn];\nint dep[nn],pa[nn];\nvoid dfs(int x,int p,int slg=0){\n\tif(!p or slg) dep[x]=0;else dep[x]=dep[p]+1;pa[x]=p;\n\tfor(int i=0;i<v[x].size();i++) if(v[x][i]!=p) dfs(v[x][i],x);\n}\nint walk(int x,int d){\n\tif(d==0) return x;\n\treturn walk(pa[x],d-1);\n}\nint mst(){\n\tint ret=0;for(int i=1;i<=n;i++) ret=max(ret,dep[i]);for(int i=1;i<=n;i++) if(dep[i]==ret) return i;\n}\nint tmp[4][4];\n\nvoid copy(int x){\n\tfor(int i=0;i<4;i++) for(int j=0;j<4;j++) tmp[i][j]=dp[x][i][j],dp[x][i][j]=0;\n}\n\nvoid efs(int x,int p){\n\tdp[x][3*(dep[x]==diam/2)][0]=1;int leaf=1;\n\tfor(int i=0;i<v[x].size();i++) if(v[x][i]!=p){\n\t\tefs(v[x][i],x);\n\t\tleaf=0;\n\t\tcopy(x);\n\t\tfor(int j=0;j<16;j++) for(int k=0;k<16;k++) add(dp[x][(j%4)|(k%4)][(j/4)|(k/4)|((j%4)&(k%4))],tmp[k%4][k/4]*dp[v[x][i]][j%4][j/4]);\n\t}\n\t\n\tif(x!=c1 and x!=c2){\n\t\tcopy(x);\n\t\tfor(int k=0;k<16;k++) for(int j=0;j<=2;j++) add(dp[x][(k%4)&j][(k/4)&j],tmp[k%4][k/4]);\n\t}\n}\n\n\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tif(n<=2) return puts(\"1\")*0;\n\t\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;scanf(\"%lld%lld\",&x,&y);\n\t\tv[x].push_back(y);v[y].push_back(x);\n\t}\n\t\n\tdfs(1,0);int x=mst();\n\tdfs(x,0);int y=mst();\n\tdiam=dep[y];\n\tif(diam%2==0){\n\t\tc1=walk(y,diam/2);\n\t\tdfs(c1,0);efs(c1,0);\n\t\tcout<<-dp[c1][3][0]*(mod+1)/2%mod;\n\t}\n\telse{\n\t\tc1=walk(y,diam/2);\n\t\tdfs(y,0);\n\t\tc2=walk(x,diam/2);\n\t\t\n\t\tdfs(c1,c2,1);dfs(c2,c1,1);\n\t\tassert(dep[mst()]==diam/2);\n\t\tefs(c1,c2);\n\t\tefs(c2,c1);\n\t\t\n\t\tcout<<dp[c1][1][0]*dp[c2][2][0]%mod;\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define MOD 998244353\ntemplate<typename ty1,typename ty2>\ninline int add(ty1 x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x += y; return x < MOD ? x : x - MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline void addto(ty1 &x, ty2 y) {\n\t\t  if(y>=MOD)y%=MOD;\n\t\t  if(x>=MOD)x%=MOD;\n\t      x += y; if (x >= MOD) x -= MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int sub(ty1 x, ty2 y) {\n\t\tif(y>=MOD)y%=MOD;\n\t\t if(x>=MOD)x%=MOD;\n        x -= y; return x < 0 ? x + MOD : x;\n}\ntemplate<typename ty1,typename ty2>\ninline void subto(ty1 &x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x -= y; if (x < 0) x += MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int mul(ty1 x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        return 1ll * x * y % MOD;\n}\ntemplate<typename ty1,typename ty2>\nvoid multo(ty1 &x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        x=1ll * x * y % MOD;\n}\n  \nlong long int gcd(long long int a, long long int b){\n\tif (a > b){\n\t\tswap(a, b);\n\t}\n\twhile (a){\n\t\tswap(a, b);\n\t\ta %= b;\n\t}\n\treturn b;\n}\nlong long int lcm(long long int a, long long int b){\n\treturn a / gcd(a, b)*b;\n}\nlong long int ppow(long long int i, long long int j){\n\t\tlong long int res = 1LL;\n\t\twhile (j){\n\t\t\tif ((j & 1LL)){\n\t\t\t\tres *= i;\n\t\t\t\tif (res >= MOD){\n\t\t\t\t\tres %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj >>= 1;\n\t\t\ti *= i;\n\t\t\tif (i >= MOD){\n\t\t\t\ti %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\nclass Combination{\n\t\npublic:\n\tvector<long long int> k;\n\tvector<long long int> r;\n\tvoid resize(int N){\n\t\tk.resize(N + 2);\n\t\tr.resize(N + 2);\n\t\tk[0] = 1;\n\t\tfor (int i = 1; i < N+2; i++){\n\t\t\tk[i] = k[i - 1];\n\t\t\tk[i] *= i;\n\t\t\tif (k[i] >= MOD)k[i] %= MOD;\n\t\t}\n\t\tlong long int al = k[k.size() - 1];\n\t\tlong long int iv = ppow(k[k.size() - 1],MOD-2);\n\t\tr[k.size() - 1] = iv;\n\t\tfor (int i = (int)(r.size()) - 2; i >= 0; i--){\n\t\t\tr[i] = r[i + 1] * (i + 1);\n\t\t\tif (r[i] >= MOD){\n\t\t\t\tr[i] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int C(int a, int b){\n\t\tif (a < b)return 0;\n\t\tlong long int up = k[a];\n\t\tlong long int dw = r[b] * r[a - b];\n\t\tdw %= MOD;\n\t\tup *= dw;\n\t\tup %= MOD;\n\t\treturn up;\n\t}\n\tlong long int H(int a, int b){\n\t\treturn C(a + b - 1, b);\n\t}\n\tlong long int catalan_number(int n){\n\t\treturn (C(2 * n, n) + MOD - C(2 * n, n - 1)) % MOD;\n\t}\n};\nCombination C;\n \n#define MAX 200002\nint n;\n \n \nstruct treediameter{\n\t//直径は色々いい性質がある\n\t//中心から(２頂点の場合それをくっつける）同じ距離のびた２つの頂点間が直径\n\t//直径は最大長であることにも注意\n\tconst vector<vector<int> >&g;\n\tint r1,r2;\n\tvector<int> d1,d2;  //両端からのdist\n\tint dia;\n\tvoid dfs(int v,int p,int cur,vector<int> &d){\n\t\td[v]=cur;\n\t\tfor(auto e:g[v])if(e!=p)\n\t\t\tdfs(e,v,cur+1,d);\n\t}\n\ttreediameter(const vector<vector<int> > &gg):g(gg),d1(g.size()),d2(g.size()){\n\t\tdfs(0,-1,0,d1);\n\t\tr1=max_element(d1.begin(),d1.end())-d1.begin();\n\t\tdfs(r1,-1,0,d1);\n\t\tr2=max_element(d1.begin(),d1.end())-d1.begin();\n\t\tdfs(r2,-1,0,d2);\n\t\tdia=d1[r2];\n\t}\n\tvector<int> find_centre(){  //直径の中心をさがす 1頂点 or 2頂点　直径は必ずこれらすべてを通る\n\t\tvector<int> ret;\n\t\tfor(int i=0;i<d1.size();i++){\n\t\t\tif(d1[i]+d2[i]==dia&&abs(d1[i]-d2[i])<=1){\n\t\t\t\tret.push_back(i);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n//treediameter(v)\n \nvector<vector<int> > v;\n \nbool flag[MAX];\n \n//0:none with only one type of operation\n//1:positive without substraction\n// 2: none with mix\nint dp[MAX][3];\nbool us[MAX][3];\nint target;\ninline int dfs(int b,int ty,int pr=-1,int d=0){\n\tif(us[b][ty]){\n\t\treturn dp[b][ty];\n\t}\n\tus[b][ty]=true;\n\tint ava=0;\n\tvector<int> can;\n\tfor(int go:v[b]){\n\t\tif(go==pr||flag[go])continue;\n\t\tava++;\n\t\tcan.push_back(go);\n\t}\n\tassert(d<=target);\n\tif(ava==0){\n\t\t//leaf\n\t\tif(ty==1){\n\t\t\tif(d==target){\n\t\t\t\tdp[b][ty]=1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tdp[b][ty]=0;\n\t\t\treturn 0;\n\t\t}\n\t\tif(ty==0){\n\t\t\tif(d==target){\n\t\t\t\tdp[b][ty]=0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdp[b][ty]=1;\n\t\t\treturn 1;\n\t\t}\n\t\tif(ty==2){\n\t\t\tdp[b][ty]=1;\n\t\t\treturn 1;\n\t\t}\n\t\texit(1);\n\t}\n\tif(ty==1){\n\t\tif(true){\n\t\t\tfor(int go:can){\n\t\t\t\tauto ret=dfs(go,1,b,d+1);\n\t\t\t\tfor(int goo:can){\n\t\t\t\t\tif(go!=goo){\n\t\t\t\t\t\tmulto(ret,add(dfs(goo,0,b,d+1),mul(2,dfs(goo,2,b,d+1))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddto(dp[b][ty],ret);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int go:can){\n\t\t\t\tauto ret=dfs(go,1,b,d+1);\n\t\t\t\tfor(int goo:can){\n\t\t\t\t\tif(go!=goo){\n\t\t\t\t\t\tmulto(ret,add(mul(2,dfs(goo,0,b,d+1)),mul(1,dfs(goo,2,b,d+1))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddto(dp[b][ty],ret);\n\t\t\t}\n\t\t}\n\t}\n\tif(ty==2){\n\t\tdp[b][ty]=1;\n\t\tfor(int goo:can){\n\t\t\tmulto(dp[b][ty],mul(3,dfs(goo,2,b,d+1)));\n\t\t}\n\t}\n\tif(ty==0){\n\t\tdp[b][ty]=1;\n\t\tfor(int goo:can){\n\t\t\tmulto(dp[b][ty],add(dfs(goo,0,b,d+1),mul(2,dfs(goo,2,b,d+1))));\n\t\t}\n\t}\n\treturn dp[b][ty];\n}\n \nint main(){\n\tcin>>n;\n\tv.resize(n);\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tauto dia=treediameter(v);\n\tauto centre=dia.find_centre();\n\tfor(auto el:centre){\n\t\tflag[el]=true;\n\t}\n\tif(centre.size()==1){\n\t\tint pos=centre[0];\n\t\ttarget=dia.dia/2;\n\t\tlong long int ans=0;\n\t\tvector<int> ml;\n\t\tint overall=1;\n\t\tfor(int el3:v[pos]){\n\t\t\tml.push_back(add(mul(2,dfs(el3,0,pos,1)),mul(1,dfs(el3,2,pos,1))));\n\t\t\tmulto(overall,ml.back());\n\t\t}\n\t\tint tmp=0;\n\t\tfor(int i=0;i<v[pos].size();i++){\n\t\t\tauto ret1=mul(dfs(v[pos][i],1,pos,1),ppow(ml[i],MOD-2));\n\t\t\taddto(ans,mul(tmp,ret1));\n\t\t\taddto(tmp,ret1);\n\t\t}\n\t\tmulto(ans,overall);\n\t\tans%=MOD;\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\telse{\n\t\tcerr<<centre[0]<<\" \"<<centre[1]<<endl;\n\t\tcerr<<dia.dia<<endl;\n\t\ttarget=dia.dia/2;\n\t\tlong long int ans=0;\n\t\tcerr<<target<<\" \"<<dfs(centre[0],1)<<\" \"<<dfs(centre[1],1)<<endl;\n\t\taddto(ans,mul(dfs(centre[0],1),dfs(centre[1],1)));\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 2e5 + 5, mod = 998244353;\n\ninline int gi()\n{\n\tchar c = getchar();\n\twhile (c < '0' || c > '9') c = getchar();\n\tint sum = 0;\n\twhile ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();\n\treturn sum;\n}\n\ninline void inc(int &a, int b) {a += b; if (a >= mod) a -= mod;}\n\nint n, rt, len, fa[maxn], ch[maxn];\n\nstruct edge\n{\n\tint to, next;\n} e[maxn * 2];\nint h[maxn], tot;\nint md[maxn], f[maxn][3][3], g[3][3];\n\ninline void add(int u, int v)\n{\n\te[++tot] = (edge) {v, h[u]}; h[u] = tot;\n\te[++tot] = (edge) {u, h[v]}; h[v] = tot;\n}\n\nvoid dfs1(int u, int d)\n{\n\tif (d > len) rt = u, len = d;\n\tmd[u] = d;\n\tfor (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n\t\tif (v != fa[u]) fa[v] = u, dfs1(v, d + 1), md[u] = max(md[u], md[v]);\n}\n\nvoid dfs2(int u, int d)\n{\n\t(md[u] == d ? f[u][1][1] : f[u][0][0]) = 1;\n\tfor (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n\t\tif (v != fa[u]) {\n\t\t\tfa[v] = u; dfs2(v, d + 1);\n\t\t\tmemset(g, 0, sizeof(g));\n\t\t\tfor (int a = 0; a < 2; ++a)\n\t\t\t\tfor (int b = 0; b < 2; ++b)\n\t\t\t\t\tfor (int c = 0; c < 2; ++c)\n\t\t\t\t\t\tfor (int d = 0; d <= 2; ++d)\n\t\t\t\t\t\t\tfor (int t = -1; t <= 1; ++t)\n\t\t\t\t\t\t\t\tinc(g[min(2, a + (md[v] == md[u] && t == 1) * c)][min(2, b + (md[v] == md[u] && t == -1) * d)], (ll)f[u][a][b] * f[v][c][d] % mod);\n\t\t\tmemcpy(f[u], g, sizeof(f[u]));\n\t\t}\n}\n\nint main()\n{\n\tn = gi();\n\tfor (int i = 1; i < n; ++i) add(gi(), gi());\n\n\tdfs1(1, 0);\n\tfa[rt] = 0; len = 0; dfs1(rt, 0);\n\tfor (int i = 0, x = rt; x; x = fa[x]) ch[i++] = x;\n\n\tif (~len & 1) {\n\t\tint x = ch[len >> 1];\n\t\tfa[x] = 0, dfs1(x, 0);\n\t\tdfs2(x, 0);\n\t\tprintf(\"%lld\\n\", (ll)f[x][1][1] * (mod + 1) / 2 % mod);\n\t}\n\telse {\n\t\tint x = ch[len >> 1], y = ch[len + 1 >> 1];\n\t\tfa[x] = y; fa[y] = x;\n\t\tdfs1(x, 0); dfs2(x, 0);\n\t\tdfs1(y, 0); dfs2(y, 0);\n\t\tprintf(\"%lld\\n\", ((ll)f[x][1][0] + f[x][1][1] + f[x][1][2]) * ((ll)f[y][1][0] + f[y][1][1] + f[y][1][2]) % mod);\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 200005, P = 998244353, I2 = (P + 1) >> 1;\n\nint n;\nstd::vector<int> E[N];\nint Fa[N];\n\nstd::pair<int, int> dfs(int u, int fa = 0) {\n\tFa[u] = fa;\n\tstd::pair<int, int> ans(0, u);\n\tfor (int v : E[u]) {\n\t\tif (v != fa) {\n\t\t\tstd::pair<int, int> tmp = dfs(v, u);\n\t\t\t++tmp.first;\n\t\t\tans = std::max(ans, tmp);\n\t\t}\n\t}\n\treturn ans;\n}\n\nint diam;\n\nint f[N][3][3], g[3][3];\n\nvoid DP(int u, int d, int fa = 0) {\n\tif (d == diam / 2) {\n\t\tf[u][1][1] = 1;\n\t} else {\n\t\tf[u][0][0] = 1;\n\t}\n\tfor (int v : E[u]) {\n\t\tif (v != fa) {\n\t\t\tDP(v, d + 1, u);\n\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\t\tfor (int x = 0; x < 3; ++x) {\n\t\t\t\t\t\tfor (int y = 0; y < 3; ++y) {\n\t\t\t\t\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\t\t\t\t\tint p = std::min(2, i + x * (k == 1)), q = std::min(2, j + y * (k == 2));\n\t\t\t\t\t\t\t\tg[p][q] = (g[p][q] + 1ll * f[u][i][j] * f[v][x][y]) % P;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\t\tf[u][i][j] = g[i][j];\n\t\t\t\t\tg[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tread(n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u, v;\n\t\tread(u), read(v);\n\t\tE[u].push_back(v), E[v].push_back(u);\n\t}\n\tint S = dfs(1).second, T = dfs(S).second;\n\tstd::vector<int> p;\n\tfor (int u = T; u; u = Fa[u]) {\n\t\tp.push_back(u);\n\t}\n\tdiam = (int)p.size() - 1;\n\tif (diam % 2 == 0) {\n\t\tint x = p[diam >> 1];\n\t\tDP(x, 0);\n\t\tprint(1ll * f[x][1][1] * I2 % P);\n\t} else {\n\t\tint x = p[(diam - 1) >> 1], y = p[(diam + 1) >> 1];\n\t\tDP(x, 0, y), DP(y, 0, x);\n\t\tint fx = (1ll * f[x][1][0] + f[x][1][1] + f[x][1][2]) % P;\n\t\tint fy = (1ll * f[y][0][1] + f[y][1][1] + f[y][2][1]) % P;\n\t\tprint(1ll * fx * fy % P);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define N_ 201000\nusing namespace std;\nint n, D1[N_], D2[N_], MD, C[N_], DD[N_];\nlong long po[N_], D[N_][2], Mod = 998244353;\nvector<int>E[N_];\nvoid DFS(int a, int pp, int *d) {\n\tfor (auto &x : E[a]) {\n\t\tif (x == pp)continue;\n\t\td[x] = d[a] + 1;\n\t\tDFS(x, a, d);\n\t}\n}\nvoid Add_Edge(int a, int b) {\n\tE[a].push_back(b);\n\tE[b].push_back(a);\n}\nvoid Del_Edge(int a, int b) {\n\tint sz = E[a].size();\n\tfor (int i = 0; i < sz; i++) {\n\t\tif (E[a][i] == b) {\n\t\t\tswap(E[a][i], E[a][sz - 1]);\n\t\t\tE[a].pop_back();\n\t\t\treturn;\n\t\t}\n\t}\n}\nvoid Go(int a, int pp) {\n\tvector<int>T;\n\tfor (auto &x : E[a]) {\n\t\tif (x == pp)continue;\n\t\tGo(x, a);\n\t\tT.push_back(x);\n\t}\n\tif (T.empty()) {\n\t\tif (DD[a] == MD) {\n\t\t\tD[a][0] = 2, D[a][1] = 1;\n\t\t}\n\t\telse {\n\t\t\tD[a][0] = 3;\n\t\t}\n\t\treturn;\n\t}\n\tD[a][0] = 1, D[a][1] = 0;\n\tfor (auto &x : T) {\n\t\tlong long d0 = D[a][0] * D[x][0];\n\t\tlong long d1 = D[a][0] * D[x][1] + D[a][1] * D[x][0];\n\t\tD[a][0] = d0 % Mod, D[a][1] = d1 % Mod;\n\t}\n\tD[a][0] = (D[a][0] * 3 + D[a][1] * 2) % Mod;\n}\nint main() {\n\tint i, mid;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i < n; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tE[a].push_back(b);\n\t\tE[b].push_back(a);\n\t}\n\tD1[1] = 0;\n\tDFS(1, 0, D1);\n\tint Mx = -1, a = -1, b = -1;\n\tfor (i = 1; i <= n; i++) {\n\t\tif (Mx < D1[i])Mx = D1[i], a = i;\n\t}\n\tD1[a] = 0;\n\tDFS(a, 0, D1);\n\tMx = -1;\n\tfor (i = 1; i <= n; i++) {\n\t\tif (Mx < D1[i])Mx = D1[i], b = i;\n\t}\n\tD2[b] = 0;\n\tDFS(b, 0, D2);\n\tif (Mx % 2 == 1) {\n\t\tint t1, t2;\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tif (D1[i] + D2[i] == Mx) {\n\t\t\t\tif (D1[i] == Mx / 2) {\n\t\t\t\t\tt1 = i;\n\t\t\t\t}\n\t\t\t\tif (D2[i] == Mx / 2) {\n\t\t\t\t\tt2 = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tDel_Edge(t1, t2); Del_Edge(t2, t1);\n\t\tn++;\n\t\tAdd_Edge(t1, n); Add_Edge(t2, n);\n\t\tD1[a] = 0, D2[b] = 0;\n\t\tDFS(a, 0, D1);\n\t\tDFS(b, 0, D2);\n\t\tMx = D1[b];\n\t}\n\tMD = 1e9;\n\tfor (i = 1; i <= n; i++) {\n\t\tif (max(D1[i], D2[i]) < MD) {\n\t\t\tMD = max(D1[i], D2[i]);\n\t\t\tmid = i;\n\t\t}\n\t}\n\tDFS(mid, 0, DD);\n\tpo[0] = 1;\n\tfor (i = 1; i <= n; i++)po[i] = po[i - 1] * 3 % Mod;\n\tlong long dd[3] = { 1,0,0 };\n\tfor (auto &x : E[mid]) {\n\t\tGo(x, mid);\n\t\tlong long g = (D[x][0] - D[x][1] + Mod) % Mod;\n\t\tlong long dd0 = dd[0] * g;\n\t\tlong long dd1 = dd[0] * D[x][1] + dd[1]* g;\n\t\tlong long dd2 = dd[1] * D[x][1] + dd[2] * g;\n\t\tdd[0] = dd0%Mod, dd[1] = dd1 % Mod, dd[2] = dd2 % Mod;\n\t}\n\tprintf(\"%lld\\n\", dd[2]);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define I inline\n#define fi first\n#define se second\n#define R register\n#define LL long long\n#define mp make_pair\n#define reg register int\n#define pii pair<int,int>\n#define fo(i, a, b) for(reg i = a; i <= b; i++)\n#define fd(i, a, b) for(reg i = a; i >= b; i--)\n#define bp __builtin_popcount\n#define cr const reg&\nusing namespace std;\nconst int N = 2e5 + 1, mod = 998244353, inv2 = mod + 1 >> 1;\n\nI int _max(cr x, cr y) {return x > y ? x : y;}\nI int _min(cr x, cr y) {return x < y ? x : y;}\nI int read() {\n\treg x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n\treturn x * f;\n}\nI void ptt(LL x) {if(x >= 10) ptt(x / 10); putchar(x % 10 + '0');}\nI void put(LL x) {x < 0 ? putchar('-'), ptt(-x) : ptt(x);}\nI void pr1(LL x) {put(x), putchar(' ');}\nI void pr2(LL x) {put(x), puts(\"\");}\n\nstruct edge {\n\tint x, y, next;\n} e[N * 2]; int len, last[N];\nint tp, mx, rt, sta[N], fa[N];\nint f[N][3][3], tmp[3][3];\n//x-y,y-x\n\nI void ins(cr x, cr y) {e[++len] = edge{x, y, last[x]}, last[x] = len;}\n\nvoid dfs(cr x, cr dep) {\n\tif(dep > mx) mx = dep, rt = x;\n\tfor(reg k = last[x]; k; k = e[k].next) if(e[k].y ^ fa[x]) fa[e[k].y] = x, dfs(e[k].y, dep + 1);\n}\n\nvoid treedp(cr x, cr fa, cr dep) {\n\tdep == tp / 2 ? f[x][1][1] = 1 : f[x][0][0] = 1;\n\tfor(reg k = last[x]; k; k = e[k].next) if(e[k].y ^ fa){\n\t\treg y = e[k].y;\n\t\ttreedp(y, x, dep + 1);\n\t\tfo(i, 0, 2) fo(j, 0, 2) fo(k, 0, 2) fo(l, 0, 2) fo(g, -1, 1) {\n\t\t\treg z = _min(2, i + k * (g == 1)), p = _min(2, j + l * (g == -1));\n\t\t\ttmp[z][p] = (tmp[z][p] + (LL)f[x][i][j] * f[y][k][l]) % mod;\n\t\t} fo(i, 0, 2) fo(j, 0, 2) f[x][i][j] = tmp[i][j], tmp[i][j] = 0;\n\t}\n}\n\nint main() {\n\treg n = read();\n\tfo(i, 1, n - 1) {\n\t\treg x = read(), y = read();\n\t\tins(x, y), ins(y, x);\n\t} dfs(1, 1), mx = fa[rt] = 0, dfs(rt, 1);\n\tfor(; rt; rt = fa[rt]) sta[++tp] = rt;\n\tif(tp & 1) rt = sta[tp / 2 + 1], treedp(rt, 0, 0), pr2((LL)inv2 * f[rt][1][1] % mod);\n\telse {\n\t\treg x = sta[tp / 2], y = sta[tp / 2 + 1];\n\t\ttreedp(x, y, 1), treedp(y, x, 1);\n\t\treg c1 = ((LL)f[x][1][0] + f[x][1][1] + f[x][1][2]) % mod, c2 = ((LL)f[y][1][0] + f[y][1][1] + f[y][1][2]) % mod;\n\t\tpr2((LL)c1 * c2 % mod);\n\t} return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200100\nusing namespace std;\nvector<int> g[N];\nint to_leaf[N];\nlong long p3sz[N],nume[N][3];\nconst int Q=998244353;\nint find_c(int u,int p){\n\tint mx[2]={u,u},ans=0;\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint v=g[u][i];\n\t\tif(v==p) continue;\n\t\tans=max(ans,find_c(v,u));\n\t\tif(to_leaf[v]>to_leaf[mx[0]]){\n\t\t\tmx[1]=mx[0];\n\t\t\tmx[0]=v;\n\t\t}\n\t\telse if(to_leaf[v]>to_leaf[mx[1]]){\n\t\t\tmx[1]=v;\n\t\t}\n\t}\n\tans=max(ans,to_leaf[mx[0]]+to_leaf[mx[1]]);\n\tto_leaf[u]=to_leaf[mx[0]]+1;\n\treturn ans;\n}\nvoid build(int u,int p){\n\tto_leaf[u]=0;\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint v=g[u][i];\n\t\tif(v==p) continue;\n\t\tbuild(v,u);\n\t\tto_leaf[u]=max(to_leaf[u],to_leaf[v]+1);\n\t}\n}\nvoid solve(int u,int p){\n\tp3sz[u]=1;\n\tif(!to_leaf[u]){\n\t\tnume[u][1]=1;\n\t\treturn;\n\t}\n\tnume[u][0]=1;\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint v=g[u][i];\n\t\tif(v==p) continue;\n\t\tsolve(v,u);\n\t\tif(to_leaf[v]+1==to_leaf[u]){\n\t\t\tfor(int j=2;j>=0;j--){\n\t\t\t\tif(p) nume[u][j]*=nume[v][0]+2*p3sz[v];\n\t\t\t\telse nume[u][j]*=2*nume[v][0]+p3sz[v];\n\t\t\t\tif(j) nume[u][j]+=nume[u][j-1]*nume[v][1];\n\t\t\t\tnume[u][j]%=Q;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tnume[u][j]=3*p3sz[v]*nume[u][j]%Q;\n\t\t\t}\n\t\t}\n\t\tp3sz[u]=3*p3sz[v]*p3sz[u]%Q;\n\t}\n}\nint main(){\n\tint n,x,y;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tint l,p=0,c=1;\n\tl=find_c(1,0);\n\tbool flag=true;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<g[c].size();i++){\n\t\t\tif(g[c][i]!=p && to_leaf[g[c][i]]>(l+1)/2){\n\t\t\t\tp=c;\n\t\t\t\tc=g[c][i];\n\t\t\t\tflag=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"diameter=%d\\n\",l);\n\tif(l&1){\n\t\tint d=-1;\n\t\tfor(int i=0;i<g[c].size();i++){\n\t\t\tif(to_leaf[g[c][i]]==(l+1)/2){\n\t\t\t\td=g[c][i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//printf(\"center: %d %d\\n\",c,d);\n\t\tassert(d>0);\n\t\tbuild(c,d);\n\t\tsolve(c,d);\n\t\tbuild(d,c);\n\t\tsolve(d,c);\n\t\tprintf(\"%lld\\n\",1LL*nume[c][1]*nume[d][1]%Q);\n\t}\n\telse{\n\t\t//printf(\"center: %d\\n\",c);\n\t\tbuild(c,0);\n\t\tsolve(c,0);\n\t\tprintf(\"%lld\\n\",nume[c][2]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// I think of what the world could be, A vision of the one I see, A million dreams is all it's gonna take\n\n#include<bits/stdc++.h>\n\n#define F first\n#define S second\n#define PB push_back\n#define sz(s) int((s).size())\n#define bit(n,k) (((n)>>(k))&1)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn = 2e5 + 10, mod = 1e9 + 7, inf = 998244353;\n\n\nint h[maxn], par[maxn];\nvector<int> v[maxn];\n\npii far(int u, int pr = -1){\n    par[u] = pr;\n    h[u] = pr == -1 ? 0 : (h[pr] + 1);\n    pii ans = {0, u};\n    for(int y : v[u]){\n\tif(y != pr){\n\t    pii p = far(y, u);\n\t    p.F++;\n\t    ans = max(ans, p);\n\t}\t    \n    }\n    return ans;\n}\n\nint total[maxn], dp1[maxn], dp2[maxn], dp3[maxn], under[maxn];\n\nvoid dfs(int u, int par = -1){\n    total[u] = 1, dp2[u] = 1;\n    if(sz(v[u]) == (par != -1))\n\tdp2[u] = 0, dp1[u] = 1;\n    for(int y : v[u]){\n\tif(y != par){\n\t    dfs(y, u);\n\t    under[u] = max(under[u], under[y] + 1);\n\t    total[u] = 3ll * total[u] * total[y] % mod;\n\t}\n    }\n    for(int y : v[u]){\n\tif(y != par){\n\t    int no = 0, yes = 0;\n\t    if(under[u] == under[y] + 1){\n\t\tno = (2ll * total[y] + 1ll * dp2[y]) % mod;\n\t\tyes = dp1[y];\n\t    }\n\t    else{\n\t\tno = 3ll * total[y] % mod;\n\t\tyes = 0;\n\t    }\n\t    dp3[u] = (1ll * dp3[u] * no + 1ll * dp1[u] * yes) % mod;\n\t    dp1[u] = (1ll * dp1[u] * no + 1ll * dp2[u] * yes) % mod;\n\t    dp2[u] = (1ll * dp2[u] * no) % mod;\n\t}\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie();\n\n    int n;\n    cin >> n;\n    for(int i = 0; i < n-1; i++){\n\tint a, b;\n\tcin >> a >> b;\n\tv[a].PB(b);\n\tv[b].PB(a);\n    }\n    int A = far(1).S;\n    auto [diam, B] = far(A);\n\n    int ans = 0;\n\n    if(diam & 1){\n\tfor(int i = 0; i < (diam/2); i++)\n\t    B = par[B];\n\tA = par[B];\n\tdfs(A, B);\n\tdfs(B, A);\n\tans = 1ll * dp1[A] * dp1[B] % mod;\n    }\n    else{\n\tfor(int i = 0; i < (diam/2); i++)\n\t    B = par[B];\n\tdfs(B);\n\tans = dp3[B];\n    }\n    return cout << ans << endl, 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 2e5 + 5, mod = 998244353;\n\ninline int gi()\n{\n\tchar c = getchar();\n\twhile (c < '0' || c > '9') c = getchar();\n\tint sum = 0;\n\twhile ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();\n\treturn sum;\n}\n\ninline void inc(int &a, int b) {a += b; if (a >= mod) a -= mod;}\n\nint n, rt, len, fa[maxn], ch[maxn];\n\nstruct edge\n{\n\tint to, next;\n} e[maxn * 2];\nint h[maxn], tot;\nint md[maxn], f[maxn][3][3], g[3][3];\n\ninline void add(int u, int v)\n{\n\te[++tot] = (edge) {v, h[u]}; h[u] = tot;\n\te[++tot] = (edge) {u, h[v]}; h[v] = tot;\n}\n\nvoid dfs1(int u, int d)\n{\n\tif (d > len) rt = u, len = d;\n\tmd[u] = d;\n\tfor (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n\t\tif (v != fa[u]) fa[v] = u, dfs1(v, d + 1), md[u] = max(md[u], md[v]);\n}\n\nvoid dfs2(int u, int d)\n{\n\t(md[u] == d ? f[u][1][1] : f[u][0][0]) = 1;\n\tfor (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n\t\tif (v != fa[u]) {\n\t\t\tfa[v] = u; dfs2(v, d + 1);\n\t\t\tmemset(g, 0, sizeof(g));\n\t\t\tfor (int a = 0; a <= 2; ++a)\n\t\t\t\tfor (int b = 0; b <= 2; ++b)\n\t\t\t\t\tif (f[u][a][b])\n\t\t\t\t\t\tfor (int c = 0; c <= 2; ++c)\n\t\t\t\t\t\t\tfor (int d = 0; d <= 2; ++d)\n\t\t\t\t\t\t\t\tif (f[v][c][d])\n\t\t\t\t\t\t\t\t\tfor (int t = -1; t <= 1; ++t)\n\t\t\t\t\t\t\t\t\t\tinc(g[min(2, a + (md[v] == md[u] && t == 1) * c)][min(2, b + (md[v] == md[u] && t == -1) * d)], (ll)f[u][a][b] * f[v][c][d] % mod);\n\t\t\tmemcpy(f[u], g, sizeof(f[u]));\n\t\t}\n}\n\nint main()\n{\n\tn = gi();\n\tfor (int i = 1; i < n; ++i) add(gi(), gi());\n\n\tdfs1(1, 0);\n\tfa[rt] = 0; len = 0; dfs1(rt, 0);\n\tfor (int i = 0, x = rt; x; x = fa[x]) ch[i++] = x;\n\n\tif (~len & 1) {\n\t\tint x = ch[len >> 1];\n\t\tfa[x] = 0, dfs1(x, 0);\n\t\tdfs2(x, 0);\n\t\tprintf(\"%lld\\n\", (ll)f[x][1][1] * (mod + 1) / 2 % mod);\n\t}\n\telse {\n\t\tint x = ch[len >> 1], y = ch[len + 1 >> 1];\n\t\tfa[x] = y; fa[y] = x;\n\t\tdfs1(x, 0); dfs2(x, 0);\n\t\tdfs1(y, 0); dfs2(y, 0);\n\t\tprintf(\"%lld\\n\", ((ll)f[x][1][0] + f[x][1][1] + f[x][1][2]) * ((ll)f[y][1][0] + f[y][1][1] + f[y][1][2]) % mod);\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*&@@@@@@@@&&&&&&&&&&&@@@@@@@@&%$$!'''..                                   .!&&&&&&&$$$$$$$$$$$%%%%%%%%%%%%%%%%%%%%%%%|\n@@@@@@@@@@@@@@@@&&&&&@@@@&&&&&%%|:`.                                          `|$$$$$$$%%%%%%%%%%||||||||||||||||||||||\n@@@@@@@@@@@@@@@@@@&@@@&&$&&$!;:.                                                .;%%%%%%%%||||||||||!!!!|||||||||||||||\n@@@@@@@@@@@@@@@@@@@&&&$%$&$%;.                                                    .:|||||||||!!!!!!!!!!!!!!!|||||||||||\n@@@@@@@@@@@@@@&&&&&$$$$$$|'                                                          '||||||!!!!!!!!!!!!!!!!!!|||||||||\n@@@@@@@@&&&&&&&&&&&$%|%!`        ....                                                 .'||||!!!!!!!!!!!!!!!!!!|||||||||\n&&&&&&&&&&&&&$$$$$$$%!'         ...                                                     .;|||!!!!!!!!!!!!!!!!!!!|||||||\n&&&&&&$$$$$$$$$$$$%|:.         ...                                                      ..'!|||||||||||||||||||||||||||\n$$$$$$$$$$$$%%%%%|;`          ....            ......                                     ..`;||||||||||||||||||||||||||\n%%%%%%%%%%%%%%%|!:..         ..`..    ..........   .                               ....     `;|||||||||||||||||||||||||\n%%||%||%|%%%%||!:`.          .``..        ..........                          .        ....  `;||||||||||||||||||||||||\n||||||||||||%|!;'.          ..``...      .....  ........                      ......    ..... .:|||||||||||||||||||||||\n|||||||||||||!;:`        ....```..    ..............                          .  ...............:||||||||||||||||||||||\n||||||||||%||!:'.      .   ..`'`.......................  .    .....              ......... ......:|%|||||||||||||||||||\n|||||||||%||!;'.          ..````..........................               ....       ..............:|%%%||||||||||||||||\n||||||||%||!;:`. ..      ...`'''``...............................                       ........  `;%||||||||||||||||||\n||||||%%%||!;:..... .......``''''```..........................................  `:;;;'.   ........ `;%|||||||||||||||||\n|||||||||%|!:`.............`''''''''`````````````.................................````...  ........ `;|||||||||||||||||\n||||||||||!:`............``'::::::::'''``'''``````````.............    ........`....```...   ........'!||||||||||||||||\n||||||||||;`............``':;;;;!;;;::::'''::'''``....................     ...`'````````....   .......:||||||||||||||||\n|||||||||;`....     ...``':;;!!!!!!!!;;;:::::::::''`````.....................':::'``````'``..   ..  ...:|||||||||||||||\n|||||||!'..         ..``':;;!!!!!!!!!!!;;;;;;;:::::'''```````````....```````'::::''''''''''``..   .  ...:||||||||||||||\n|||||!:'`.          .`'':;;!!!!!!||!!!!!!!!!;;;;;;::::::'''''''''''''''`''''''':::'''''''::`....       ..:|||||||||||||\n|||!;;'..          .`''::;;!!!!!|||||||!!!!!!!!!!!!;;;;;;;;;;;;;;;;;;;;;;;:::;:::::'''';;;:'.   .    .   .:||||||||||||\n||;!;:'`            `'::;;;!!!!!||||||||!!!!!!!!!!!!!!!!!!!!!!!!!||||||!;;;::::;;;::'':;:::'.             .:||||||||||!\n|!!!:'`.            .'::;;;!!!!!!|||||||||!!!!!!!!|!!!!!!!!!!!|||||%%%%||!;;;::::::::::::;:`..             .:|||||||||!\n!!!;''`.            .'::;;;!!!!!!!!||||!!!!||||!!!!!!;;;!!!!!!||||%%%|||||!!;;:;;;;:'':::'.                  :||||||||!\n!|!:''`.             `'::;;;!!!!!!!!!!!!!!!!!!!;::'':;;!!!!!!!|||||||||||||!!;;;;;;;:::''`.                   '!||||||!\n!!!:''`.             .`':;;;!!!!!!!!!!!!!!;:''''':;;;;;;;;!!!!||||||||||||!!!;;;;;;;:::''`..                   `;|!!!|!\n!!!:'`.               .'::;;;;!!!!!!!!;:''``':;;;;;;;;;;;;;!!|||||||||||||!!!!!;;;;;;:::''`..                   .:|||!!\n||!:'`..               `'::;;;;;;!;;;;:''':;;;;;;;;;::'`';!!||||||||||||||!!!!!!!!!;;;:::'`..                     '!|||\n|!!:'`..                `:::::;;;;;;;;;;::;;;::::::''``';!!|||||||||||||||!!!!!!!!!!;;;;::'`.                      `;||\n||!;'.                   ....``'::;;;!!;;;;;::'''`...`:;!!!|||||||||||||||!!!!!!!!!!!;;;;::'`..                 .   .'!\n%||;'..  ..               .`''::::::;!!!!!!;;;::''`::;;!!!||||||||||||||||||||||||!!!!!;;;;::'`.                      '\n|%|!:`.                     `'':::'::;!||||!!!!!!;;;;!!!!!||||||||||||||||||||||||||!!!!!;;;;;:'`.                    .\n||%|;`                        `````..`;|||||||||||!!!!!!!!|||||||||||||||||||||%||||||!!!!!!!!;::'`..                 .\n%|%%|'.  ..                    .....`':!||||||||||||!!||||||||||!!!|||||||%%%%%%%||||||!!|||||!!;:''`.                .\n|||%|;.                         .`''::;;|||||||||||!!!!|||||!!!!!!!|||||||%%%%%%|%%%||||||||||||!!;;:'`..             .\n|||%|!'.  ..                     `':::;;!|%|||||||!!!!!!!!!!!!!!!!!||||||%%%%%%%%%%%%|||||%%%|||||!!!;;:'`.           .\n||||||;`   ..                     `::;;;!|||||||||||!!!!!!!!!!!!!!!!!||||%%%%%%%$$%%%|||||%%%%%||||||||!!;:'`.        .\n||||||!:`  ...                     .::;;;!|||||||||||!!!!!!!!!!!!!!!!!||||||%%%%$$%%%||||%%%%%%%%||||%%%||!;;:'.      .\n|||||||;`     ..                    .':;;!|||||||||!!!;!!!!!!!!!!!!!!!!||||||%%%%%%%%||||%%%%%%%%%%%%%%%%%%%||!;:''`. .\n!!!!!!||;`.    ..              .      `:;;;!!!!!!;::;;!!!!!!!!!!!!!!!!!!|||||||||%%%||||%%%%%%%%||||%%%%%%%%%%%||!;;;::\n!!!!!!!!!:.  .......                    `::;;;;;;:;;;!!!||!!!;;;;:;;;!!!!!|||!!!|||||||%%%%%%%|||!||||%%%$$$%%%|||!!!!!\n!!!!!!!!!!:.  .......          .          `:::;;;;;;!!!!!!;;;:::;;;;;;!!!!!!!!!!!||||||%%%%%%%%|||!!!||||||||||||||!!!!\n;;;;;;!!!!!:`..........       ...           .`:::::;;;;;:'``':;!!!!!!!!!!|!!!!!!!||||||||%%%%%%%%%|||!!!!!!!!!!!!!!!!!!\n;;;;;;;!!!!!:`..........        .              .`::::''''':;;!!!!!!!!!|||||!!!!!!!!!!!||||||%%%$$$$%%|||!!!!!!!!!!!!!!!\n;;;;;!!!!!!!!;`............. ..                   .`::::;;;;;;;;;;!!!||%%||!!!!!!!;;;!!!!||||%%$$&&&$$%%%|||||||||||||!\n!!!!!!!!!!!!!!!:`............        ..               .':::::::;;!!|||%%%||!!!!;;;;;;;;;!!!!||%%$&&&&&$$$$$%%%%||||||||\n!!!!!!!!!!|!!!!!:`...............     .      ....        `::;;;!!||||||%||!!!:''::::;;;;;!!!!!|%$&&&&&&&$$$$%%%||||||||\n!!!!!!|||||||||!;`............         ...........         .';;!!!!!!!!!!!!;::::::::;;;;;!!!!!!|%$&&&&&&&$$$$%%%|||||||\n||||||||||||||||;`........... ...      .......`...           .';;;;;;;!!:``'':::;;;;;;!!!!|||||||$&@@@&&&&$$$$%%%%|||||\n||||||||||||||||:``.............       .............            .`':'`.....`':::;;;!!!!||%%%%%%||$@@@@@@&&&$$$%%%%%%%%|\n|||||||||||||%|!:'`.............      . ............                   ....`':::;;!|%$$$$$$$$$%%|%&@##@@@&&$$$$$$$$%%$%\n||||||||||%%%%|;;;`......  ....      ... ....     ...        ..       .....`':::;;!%$&&&&&&&&&&$%$&@@@@@@&&$$$$$$$$$$$$\n||||||%%%%%%%%%!;:'`.....   ...             ..     .......    ..   .....```''::;;!|%$&&@@@@@@@&&$$&&@@@@@&$$%%%%%%%$$$$\n%%%%%%%%%%%%%%%!!;'`...........               ...... ..........   ..``````'':;!%%$$$&&@@@###@@@@&&&&&&&$$%%%|||||%$$$&$\n%%%%%%%%%%%%%%%|!;'.....`''`..      .          ...............    .``````':!%%||||%$&@@######@@@&&&$$%%%||||||||%$&&&&&\n%%%%%%%%%%%%%%%|!:`.......`...     ...````''``````````````.......``''':;|%%|!!!!!!|%$@########@@@&$%%||||||||%%%$&&&@@@\n|%%%%%%%%%%%%%%%|;'`.`'`. .....`''''''::::::::::::::::;;:::'::::::;;;;!%%||!!!!!!!||$&########@&$%%|||||||%%$$$&@@@@@#@\nCoded by Shinmurn Shar, a 21-yr-old beautiful girl.\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define loop(i,n) for(int i=0;i<(n);i++)\n#define pool(i,n) for(int i=(n)-1;i>=0;i--)\n#define cont(i,n) for(int i=1;i<=(n);i++)\n#define tnoc(i,n) for(int i=(n);i>=1;i--)\n#define circ(i,a,b) for(int i=(a);i<=(b);i++)\n#define cric(i,a,b) for(int i=(b);i>=(a);i--)\n#define sub(i,a) for(int i=a;i;i=((i-1)&(a)))\n#define subs(i,a) for(int i=a;i>=0;i=(!i?-1:((i-1)&(a))))\n#define range(i,a,b,c) for(int i=(a);((c)>0?i<=(b):i>=(b));i+=(c))\n#define foreach(it,v) for(__typeof((v).begin()) it=(v).begin(),_e_D_=(v).end();it!=_e_D_;it++)\n#define parse(i,s) for(int i=0;s[i];i++)\n#define ln '\\n'\n#define all(a) a.begin(),a.end()\n#define OVER(s) return puts(s),0;\n#define FILL0(a) memset(a,0,sizeof(a))\n#define FILL1(a) memset(a,-1,sizeof(a))\n#define FILLBIG(a) memset(a,0x3f,sizeof(a))\n#define COPY(frm,to) memcpy(to,frm,sizeof(frm))\n#define Mask(a) (1ll<<(a))\n#define Maskx(a,x) ((a)<<(x))\n#define Full(a) ((1ll<<(a))-1)\n#define Bit(a,x) (((a)>>(x))&1)\n#define SZ(a) ((int)((a).size()))\n#define filei(a) freopen(a,\"r\",stdin);\n#define fileo(a) freopen(a,\"w\",stdout);\n#define fileio(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\n#define Floyd(a,n) cont(k,n)cont(i,n)cont(j,n)chmin(a[i][j],a[i][k]+a[k][j])\n#define Floyd0(a,n) loop(k,n)loop(i,n)loop(j,n)chmin(a[i][j],a[i][k]+a[k][j])\n#define Floydlr(a,l,r) circ(k,l,r)circ(i,l,r)circ(j,l,r)chmin(a[i][j],a[i][k]+a[k][j])\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define y0 y0O0OO00OO0OO0OO0OOO00OO0OO0O0O000OO0\n#define y1 y1II11II11III11I1III11II111IIII1II1I1\n#define ws WSrAkIoi2333wSraKIoIWSraKiOi\n#define left left_jTjTJtJtIoiiOiioIAuaU66666jtIOIau\n#define hash whYusEthiSnamE_caNyoUusEothERnaMesliKeHSH\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define mak make_pair\n#define emb emplace_back\n#define emf emplace_front\n#define emp emplace\n#define popcnt __builtin_popcount\n#define Popcnt __builtin_popcountll\ntemplate<typename _T>\nusing pair2=pair<_T,_T>;\ntemplate<typename _T>\nusing pair3=pair<pair<_T,_T>,_T>;\ntemplate<typename _T>\nusing pair4=pair<pair<_T,_T>,pair<_T,_T> >;\n#define mak3(a,b,c) make_pair(make_pair(a,b),c)\n#define mak4(a,b,c,d) make_pair(make_pair(a,b),make_pair(c,d))\ntemplate<typename _T>\nusing priq=priority_queue<_T>;\ntemplate<typename _T>\nusing qrip=priority_queue<_T,vector<_T>,greater<_T> >;\n#define ST first\n#define ND second\n#define FST first.first\n#define SND first.second\n#define RD second\n#define SRD second.first\n#define FTH second.second\n#ifndef JTAKIOI\n#define cerr if(0)cout\n#define tctest(clas,meth,...)\n#else\n#define tctest(clas,meth,...) int main(){fio<<(new clas)->meth(__VA_ARGS__)<<ln;}\n#endif\ntypedef long long ll;\ntypedef long double lf;\ntypedef istringstream iss;\ntypedef stringstream sst;\nconst lf pi=acosl(-1);\nconst int Inf=0x3f3f3f3f;\nconst ll INF=0x3f3f3f3f3f3f3f3fll;\nconst int dx[]={1,0,-1,0,1,1,-1,-1},dy[]={0,1,0,-1,1,-1,1,-1};\nunsigned Rand(){return rand()*32768+rand();}\nint rand(int a,int b){return Rand()%(b-a+1)+a;}\ntemplate<typename _T>\ninline _T chmin(_T &a,_T b){return a>b?(a=b):a;}\ntemplate<typename _T>\ninline _T chmax(_T &a,_T b){return a<b?(a=b):a;}\ntemplate<typename _T,int len>\nstruct BIT{\n\t_T dt[len];\n\tinline void add(int a,_T x){while(a<len){dt[a]+=x;a+=a&-a;}}\n\tinline void add(int l,int r,_T x){add(l,x);add(r+1,-x);}\n\tinline _T get(int a){_T ans=0;while(a){ans+=dt[a];a-=a&-a;}return ans;}\n\tinline _T get(int l,int r){return get(r)-get(l-1);}\n};\ntemplate<typename _T,int len>\nstruct segbit{\n\t_T dt[2][len];\n\tinline void add(int a,_T x){int b=a;while(a<len){dt[0][a]+=x;dt[1][a]+=x*b;a+=a&-a;}}\n\tinline void add(int l,int r,_T x){add(l,x);add(r+1,-x);}\n\tinline _T sum(int a){_T ans=0;int b=a;while(a){ans+=(b+1)*dt[0][a]-dt[1][a];a-=a&-a;}return ans;}\n\tinline _T sum(int l,int r){return sum(r)-sum(l-1);}\n};\nstruct fastIO{\n\tinline fastIO operator>>(int& num){\n\t\tnum=0;char c=getchar();while(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;if(c=='-'){foo=1;c=getchar();}\n\t\twhile(c>='0'&&c<='9'){num=(num<<3)+(num<<1)+c-'0';c=getchar();}\n\t\tif(foo)num=-num;return *this;\n\t}\n\tinline fastIO operator>>(ll& num){\n\t\tnum=0;char c=getchar();while(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;if(c=='-'){foo=1;c=getchar();}\n\t\twhile(c>='0'&&c<='9'){num=(num<<3)+(num<<1)+c-'0';c=getchar();}\n\t\tif(foo)num=-num;return *this;\n\t}\n\tinline fastIO operator>>(float& num){scanf(\"%f\",&num);return *this;}\n\tinline fastIO operator>>(double& num){scanf(\"%lf\",&num);return *this;}\n\tinline fastIO operator>>(long double& num){scanf(\"%Lf\",&num);return *this;}\n\tinline fastIO operator>>(char& num){num=getchar();while(num==' '||num=='\\n')num=getchar();return *this;}\n\tinline fastIO operator>>(char* num){\n\t\tint cnt=0;char c=getchar();while(c==' '||c=='\\n')c=getchar();\n\t\twhile(c!=' '&&c!='\\n'){num[cnt++]=c;c=getchar();}num[cnt]=0;return *this;\n\t}\n\tinline fastIO operator>>(string& num){cin>>num;return *this;}\n\tinline void printInt(const int& num){if(num<10){putchar(num+'0');return;}printInt(num/10);putchar((num%10)+'0');}\n\tinline void printll(const ll& num){if(num<10){putchar(num+'0');return;}printll(num/10);putchar((num%10)+'0');}\n\tinline fastIO operator<<(const int& num){if(num<0)putchar('-'),printInt(-num);else printInt(num);return *this;}\n\tinline fastIO operator<<(const ll& num){if(num<0)putchar('-'),printll(-num);else printll(num);return *this;}\n\tinline fastIO operator<<(const float& num){printf(\"%.10f\",num);return *this;}\n\tinline fastIO operator<<(const double& num){printf(\"%.16lf\",num);return *this;}\n\tinline fastIO operator<<(const long double& num){printf(\"%.20Lf\",num);return *this;}\n\tinline fastIO operator<<(const char& num){putchar(num);return *this;}\n\tinline fastIO operator<<(const char* num){for(int i=0;num[i];i++)putchar(num[i]);return *this;}\n\tinline fastIO operator<<(const string& num){cout<<num;return *this;}\n\ttemplate<typename _T> inline fastIO operator<<(const vector<_T> &vec){printf(\"{ \");foreach(i,vec)operator<<(*i)<<' ';printf(\"}\");return *this;}\n}fio;\nconst lf eps=1e-10;\nstruct point{\n\tlf x,y;\n\tlf ang;\n\tpoint(){}\n\tpoint(lf x,lf y):x(x),y(y){ang=atan2l(y,x);}\n\tinline point operator=(const point &pt){x=pt.x;y=pt.y;return *this;}\n\tinline point operator-()const{return point(-x,-y);}\n\tinline point operator+(const point &pt)const{return point(x+pt.x,y+pt.y);}\n\tinline point operator-(const point &pt)const{return point(x-pt.x,y-pt.y);}\n\tinline point operator*(const lf &a)const{return point(x*a,y*a);}\n\tinline point operator/(const lf &a)const{return point(x/a,y/a);}\n\tinline point operator^(const lf &ang)const{return point(x*cosl(ang)-y*sinl(ang),x*sinl(ang)+y*cosl(ang));}\n\tinline point operator+=(const point &pt){return *this=point(x+pt.x,y+pt.y);}\n\tinline point operator-=(const point &pt){return *this=point(x-pt.x,y-pt.y);}\n\tinline point operator*=(const lf &a){return *this=point(x*a,y*a);}\n\tinline point operator/=(const lf &a){return *this=point(x/a,y/a);}\n\tinline point operator^=(const lf &ang){return *this=point(x*cosl(ang)-y*sinl(ang),x*sinl(ang)+y*cosl(ang));}\n\tinline lf operator*(const point &pt)const{return x*pt.x+y*pt.y;}//dot\n\tinline lf operator%(const point &pt)const{return x*pt.y-y*pt.x;}//det\n\tinline lf length()const{return x*x+y*y;}\n\tinline lf size()const{return sqrtl(x*x+y*y);}\n\tinline lf operator^(const point &pt)const{return acosl(*this*pt)/length()/pt.length();}\n\tinline lf getangle(){return ang=atan2l(y,x);}\n\tinline lf angle()const{return atan2l(y,x);}\n\tinline bool operator<(const point &p)const{return ang<p.ang;}\n};\ninline bool xsmaller(const point &x,const point &y){return fabs(x.x-y.x)<1e-10?x.y<y.y:x.x<y.x;}\ninline bool ysmaller(const point &x,const point &y){return fabs(x.y-y.y)<1e-10?x.x<y.x:x.y<y.y;}\nstruct line{\n\tpoint a,b;\n\tline(){}\n\tline(point a,point b):a(a),b(b){}\n};\npoint intersect(line x,line y){\n\tpoint p1=x.a,v1=x.b-x.a;\n\tpoint p2=y.a,v2=y.b-y.a;\n\treturn p1+v1*(((p2-p1)%v2)/(v1%v2));\n}\nconst int jt=998244353;\ninline int &Add(int &a,int b){\n\ta+=b;\n\tif(a>jt){a-=jt;}\n\tif(a<0){a+=jt;}\n\treturn a;\n}\ninline int &Sub(int &a,int b){\n\ta-=b;\n\tif(a>jt){a-=jt;}\n\tif(a<0){a+=jt;}\n\treturn a;\n}\ninline int &Mul(int &a,int b){\n\ta=1ll*a*b%jt;\n\tif(a<0){a+=jt;}\n\treturn a;\n}\ninline int Jar(int a){\n\treturn a;\n}\ntemplate<typename ... tps>\ninline int Jar(int a,tps ... args){\n\ta+=Jar(args ...);\n\tif(a>jt){a-=jt;}\n\tif(a<0){a+=jt;}\n\treturn a;\n}\ninline int Jan(int a,int b){\n\ta-=b;\n\tif(a>jt){a-=jt;}\n\tif(a<0){a+=jt;}\n\treturn a;\n}\ninline int Churn(int a){\n\treturn a;\n}\ntemplate<typename ... tps>\ninline int Churn(int a,tps ... args){\n\ta=1ll*a*Churn(args ...)%jt;\n\tif(a<0){a+=jt;}\n\treturn a;\n}\ninline int ksmii(int a,int b=jt-2){\n\tif(b<0){return ksmii(ksmii(a),-b);}\n\tif(!b){return 1;}\n\tint x=ksmii(a,b>>1);x=1ll*x*x%jt;\n\tif(b&1)x=1ll*x*a%jt;return x;\n}\ntemplate<int len>\nstruct bitmod{\n\tint dt[len];\n\tinline void add(int a,int x){while(a<len){dt[a]=(dt[a]+x)%jt;a+=a&-a;}}\n\tinline void add(int l,int r,int x){add(l,x%jt);add(r+1,jt-x%jt);}\n\tinline int get(int a){int ans=0;while(a){ans=(ans+dt[a])%jt;a-=a&-a;}return ans;}\n\tinline int get(int l,int r){return (get(r)-get(l-1)+jt)%jt;}\n};\ntemplate<int len>\nstruct DSU{\n\tint fa[len],sz[len];\n\tDSU(){loop(i,len)fa[i]=i,sz[i]=1;}\n\tvoid init(){loop(i,len)fa[i]=i,sz[i]=1;}\n\tint root(int x){return fa[x]==x?x:(fa[x]=root(fa[x]));}\n\tbool conn(int a,int b){a=root(a);b=root(b);if(a==b)return 0;fa[a]=b;sz[b]+=sz[a];return 1;}\n};\ntemplate<typename _T>\ninline _T qp(_T a,int b){\n\tif(!b){return 1;}\n\t_T x=qp(a,b>>1);x=x*x;\n\tif(b&1){x=x*a;}return x;\n}\ntemplate<int R,int C=R>\nstruct matrix{\n\tint mat[R][C];\n\tint* operator[](int x){\n\t\treturn mat[x];\n\t}\n\tmatrix(){loop(i,R)loop(j,C)mat[i][j]=0;}\n\tmatrix(int x){loop(i,R)loop(j,C)mat[i][j]=(i==j?x:0);}\n\tmatrix<R,C> operator+(const matrix<R,C> m){\n\t\tmatrix<R,C> ans;\n\t\tloop(i,R)loop(j,C)ans.mat[i][j]=(mat[i][j]+m.mat[i][j])%jt;\n\t\treturn ans;\n\t}\n\ttemplate<int D>\n\tmatrix<R,D> operator*(const matrix<C,D> m){\n\t\tmatrix<R,D> ans;\n\t\tloop(i,R)loop(j,C)loop(k,D)ans.mat[i][k]=(ans.mat[i][k]+((ll)mat[i][j])*m.mat[j][k])%jt;\n\t\treturn ans;\n\t}\n\tmatrix<R,C> operator+=(const matrix<R,C> m){\n\t\tmatrix<R,C> ans;\n\t\tloop(i,R)loop(j,C)ans.mat[i][j]=(mat[i][j]+m.mat[i][j])%jt;\n\t\treturn ans;\n\t}\n\tmatrix<R,C> operator-=(const matrix<R,C> m){\n\t\tmatrix<R,C> ans;\n\t\tloop(i,R)loop(j,C)ans.mat[i][j]=(mat[i][j]-m.mat[i][j]+jt)%jt;\n\t\treturn ans;\n\t}\n\tvoid debug(){\n\t\tloop(i,R){loop(j,C)cerr<<mat[i][j]<<' ';cerr<<endl;}cerr<<endl;\n\t}\n};\n\nint n;\nvector<int> nei[200005];\nint mx,nd;\nint fa[200005];\nint dp[200005][3][3];\nint tmp[3][3];\n\nvoid predfs(int now,int lst,int dep){\n\tif(dep>mx){\n\t\tmx=dep;\n\t\tnd=now;\n\t}\n\tfa[now]=lst;\n\tforeach(i,nei[now]){\n\t\tif(*i==lst){\n\t\t\tcontinue;\n\t\t}\n\t\tpredfs(*i,now,dep+1);\n\t}\n}\n\nvoid dfs(int now,int lst,int dep){\n\tif(dep==(mx>>1)){\n\t\tdp[now][1][1]=1;\n\t}else{\n\t\tdp[now][0][0]=1;\n\t}\n\tforeach(i,nei[now]){\n\t\tif(*i==lst){\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(*i,now,dep+1);\n\t\tloop(iu,3){\n\t\t\tloop(ju,3){\n\t\t\t\tloop(iv,3){\n\t\t\t\t\tloop(jv,3){\n\t\t\t\t\t\tloop(fx,3){\n\t\t\t\t\t\t\tint in=min(2,iu+iv*(fx==1)),jn=min(2,ju+jv*(fx==2));\n\t\t\t\t\t\t\tAdd(tmp[in][jn],Churn(dp[now][iu][ju],dp[*i][iv][jv]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCOPY(tmp,dp[now]);\n\t\tFILL0(tmp);\n\t}\n}\n\nint main(){\n\tfio>>n;\n\tcont(i,n-1){\n\t\tint x,y;\n\t\tfio>>x>>y;\n\t\tnei[x].pub(y);\n\t\tnei[y].pub(x);\n\t}\n\tpredfs(1,0,0);\n\tmx=0;\n\tpredfs(nd,0,0);\n\tcont(i,mx>>1){\n\t\tnd=fa[nd];\n\t}\n\tif(mx&1){\n\t\tint nd1=nd,nd2=fa[nd];\n\t\tdfs(nd1,nd2,0);\n\t\tdfs(nd2,nd1,0);\n\t\tfio<<Churn(Jar(dp[nd1][1][0],dp[nd1][1][1],dp[nd1][1][2]),Jar(dp[nd2][1][0],dp[nd2][1][1],dp[nd2][1][2]))<<ln;\n\t}else{\n\t\tdfs(nd,0,0);\n\t\tfio<<Churn(dp[nd][1][1],ksmii(2))<<ln;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 114514*4\n#define mod 998244353\n#define int long long \nvoid add(int&x,int y){\n\tx=(x+y)%mod;\n}\nint dp[nn][4][4],n,diam,c1,c2;\nvector<int> v[nn];int chk[nn];\nint dep[nn],pa[nn];\nvoid dfs(int x,int p,int slg=0){\n\tif(!p or slg) dep[x]=0;else dep[x]=dep[p]+1;pa[x]=p;\n\tfor(int i=0;i<v[x].size();i++) if(v[x][i]!=p) dfs(v[x][i],x);\n}\nint walk(int x,int d){\n\tif(d==0) return x;\n\treturn walk(pa[x],d-1);\n}\nint mst(){\n\tint ret=0;for(int i=1;i<=n;i++) ret=max(ret,dep[i]);for(int i=1;i<=n;i++) if(dep[i]==ret) return i;\n}\nint tmp[4][4];\n\nvoid copy(int x){\n\tfor(int i=0;i<4;i++) for(int j=0;j<4;j++) tmp[i][j]=dp[x][i][j],dp[x][i][j]=0;\n}\n\nvoid efs(int x,int p){\n\tdp[x][3*(dep[x]==diam/2)][0]=1;\n\tfor(int i=0;i<v[x].size();i++) if(v[x][i]!=p){\n\t\tefs(v[x][i],x);\n\t\tcopy(x);\n\t\tfor(int j=0;j<16;j++) for(int k=0;k<16;k++) add(dp[x][(j%4)|(k%4)][(j/4)|(k/4)|((j%4)&(k%4))],tmp[k%4][k/4]*dp[v[x][i]][j%4][j/4]);\n\t}\n\t\n\tif(x!=c1 and x!=c2){\n\t\tcopy(x);\n\t\tfor(int k=0;k<16;k++) for(int j=0;j<=2;j++) add(dp[x][(k%4)&j][(k/4)&j],tmp[k%4][k/4]);\n\t}\n}\n\n\nsigned main(){\n\tscanf(\"%lld\",&n);\n\t\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;scanf(\"%lld%lld\",&x,&y);\n\t\tv[x].push_back(y);v[y].push_back(x);\n\t}\n\tif(n<=2) return puts(\"1\")*0;\n\t\n\tdfs(1,0);int x=mst();\n\tdfs(x,0);int y=mst();\n\tdiam=dep[y];\n\tif(diam%2==0){\n\t\tc1=walk(y,diam/2);\n\t\tdfs(c1,0);efs(c1,0);\n\t\tcout<<dp[c1][3][0]*(mod+1)/2%mod;\n\t}\n\telse{\n\t\tc1=walk(y,diam/2);\n\t\tdfs(y,0);\n\t\tc2=walk(x,diam/2);\n\t\t\n\t\tdfs(c1,c2,1);dfs(c2,c1,1);\n\t\tassert(dep[mst()]==diam/2);\n\t\tefs(c1,c2);\n\t\tefs(c2,c1);\n\t\t\n\t\tcout<<(dp[c1][1][0]*dp[c2][2][0]+dp[c1][3][2]*dp[c2][1][0]%mod+dp[c1][3][1]*dp[c2][2][0]+dp[c1][3][0]*(dp[c2][1][0]+dp[c2][2][0])%mod )%mod;\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint read(){\n\tint a = 0; char c = getchar(); while(!isdigit(c)) c = getchar();\n\twhile(isdigit(c)){a = a * 10 + c - 48; c = getchar();} return a;\n}\n\nconst int _ = 2e5 + 7 , MOD = 998244353 , iv2 = (MOD + 1) / 2;\nstruct Edge{int end , upEd;}Ed[_ << 1];\nint dp[_][3][3] , N , cntEd , head[_];\nvoid addEd(int a , int b){Ed[++cntEd] = (Edge){b , head[a]}; head[a] = cntEd;}\n\nint mx , id , pre[_];\nvoid dfs1(int x , int p , int l){\n\tpre[x] = p; if(l > mx){mx = l; id = x;}\n\tfor(int i = head[x] ; i ; i = Ed[i].upEd)\n\t\tif(Ed[i].end != p) dfs1(Ed[i].end , x , l + 1);\n}\n\nint mxdep[_];\nvoid dfs2(int x , int p){\n\tfor(int i = head[x] ; i ; i = Ed[i].upEd)\n\t\tif(Ed[i].end != p){dfs2(Ed[i].end , x); mxdep[x] = max(mxdep[x] , mxdep[Ed[i].end] + 1);}\n}\n\nvoid DP(int x , int p){\n\tdp[x][0][0] = 1; bool flg = 0;\n\tfor(int i = head[x] ; i ; i = Ed[i].upEd)\n\t\tif(Ed[i].end != p){\n\t\t\tflg = 1; DP(Ed[i].end , x); static int tmp[3][3]; memset(tmp , 0 , sizeof(tmp));\n\t\t\tfor(int j = 0 ; j < 3 ; ++j)\n\t\t\t\tfor(int k = 0 ; k < 3 ; ++k)\n\t\t\t\t\tfor(int p = 0 ; p < 3 ; ++p)\n\t\t\t\t\t\tfor(int q = 0 ; q < 3 ; ++q){\n\t\t\t\t\t\t\tint coef = 3;\n\t\t\t\t\t\t\tif(mxdep[Ed[i].end] + 1 == mxdep[x]){\n\t\t\t\t\t\t\t\ttmp[min(j + p , 2)][k] = (tmp[min(j + p , 2)][k] + 1ll * dp[x][j][k] * dp[Ed[i].end][p][q]) % MOD;\n\t\t\t\t\t\t\t\ttmp[j][min(k + q , 2)] = (tmp[j][min(k + q , 2)] + 1ll * dp[x][j][k] * dp[Ed[i].end][p][q]) % MOD;\n\t\t\t\t\t\t\t\tcoef -= 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttmp[j][k] = (tmp[j][k] + 1ll * coef * dp[x][j][k] * dp[Ed[i].end][p][q]) % MOD;\n\t\t\t\t\t\t}\n\t\t\tmemcpy(dp[x] , tmp , sizeof(tmp));\n\t\t}\n\tif(!flg){dp[x][0][0] = 0; dp[x][1][1] = 1;}\n}\n\nint main(){\n\tN = read(); for(int i = 1 ; i < N ; ++i){int x = read() , y = read(); addEd(x , y); addEd(y , x);}\n\tdfs1(1 , 0 , 0); mx = 0; int t = id; dfs1(t , 0 , 0);\n\tfor(int i = 0 ; i < mx / 2 ; ++i) id = pre[id];\n\tif(mx & 1){\n\t\tdfs2(id , pre[id]); DP(id , pre[id]); dfs2(pre[id] , id); DP(pre[id] , id); int sum = 0;\n\t\tfor(int i = 0 ; i < 3 ; ++i)\n\t\t\tfor(int j = 0 ; j < 3 ; ++j)\n\t\t\t\tfor(int k = 0 ; k < 3 ; ++k)\n\t\t\t\t\tfor(int l = 0 ; l < 3 ; ++l){\n\t\t\t\t\t\tif(i == 1 && l == 1) sum = (sum + 1ll * dp[id][i][j] * dp[pre[id]][k][l]) % MOD;\n\t\t\t\t\t\tif(j == 1 && k == 1) sum = (sum + 1ll * dp[id][i][j] * dp[pre[id]][k][l]) % MOD;\n\t\t\t\t\t}\n\t\tprintf(\"%lld\\n\" , 1ll * sum * iv2 % MOD);\n\t}else{dfs2(id , 0); DP(id , 0); printf(\"%lld\\n\" , 1ll * iv2 * dp[id][1][1] % MOD);}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define mod 998244353\n#define N 500001\nusing namespace std;\nint total1=0;\nlong long dia=0,smid,middle;\nint next[N],head[N],edge[N],maxdep1[N],maxdep2[N],maxwhere1[N],maxwhere2[N];\nlong long size[N],f[N][2],g[N];\nint n;\nlong long ksmi(long long x,long long y)\n{\n\tlong long total=1,ab=x,p=y;\n\twhile (p)\n\t{\n\t\tif (p%2==1) total=total*ab%mod;\n\t\tab=ab*ab%mod;\n\t\tp/=2;\n\t}\n\treturn total;\n}\nlong long max(long long x,long long y)\n{\n\tif (x<y) return y;\n\treturn x;\n}\nvoid insert(int x,int y)\n{\n\ttotal1++;\n\tnext[total1]=head[x];\n\thead[x]=total1;\n\tedge[total1]=y;\n}\nvoid dfs1(int k,int fa)\n{\n\tmaxdep1[k]=1;\n\tsize[k]=1;\n\tfor (int i=head[k];i;i=next[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (y==fa) continue;\n\t\tdfs1(y,k);\n\t\tsize[k]=size[k]+size[y];\n\t\tmaxdep1[k]=max(maxdep1[k],maxdep1[y]+1);\n\t\tif (maxdep1[k]==maxdep1[y]+1) maxwhere1[k]=y;\n\t}\n\tmaxdep2[k]=0;\n\tfor (int i=head[k];i;i=next[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (y==fa||y==maxwhere1[k]) continue;\n\t//\tdfs(y,k);\n\t\tmaxdep2[k]=max(maxdep2[k],maxdep1[y]+1);\n\t\tif (maxdep2[k]==maxdep1[y]+1) maxwhere2[k]=y;\n\t}\n\tdia=max(dia,maxdep1[k]);\n\tif (dia==maxdep1[k]) smid=k;\n}\nvoid dfs(int k,int fa)\n{\n\tsize[k]=1;\n\tfor (int i=head[k];i;i=next[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (y==fa) continue;\n\t\tdfs(y,k);\n\t\tsize[k]+=size[y];\n\t}\n\tf[k][0]=1;\n\tbool bo1=true;\n\tfor (int i=head[k];i;i=next[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (y==fa) continue;\n\t\tbo1=false;\n\t\tlong long daijia=ksmi(3,size[y]);\n\t\tif (maxdep1[y]+1==maxdep1[k]) daijia=(f[y][0]*3+f[y][1]*2)%mod;\n\t\tf[k][0]=(f[k][0]*(daijia)%mod)%mod;\n\t}\n\tif (bo1) f[k][0]=0;\n\tf[k][1]=0;\n\tbool bo=true;\n\tfor (int i=head[k];i;i=next[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (y==fa) continue;\n\t\tif (maxdep1[y]+1<maxdep1[k]) continue;\n\t\tbo=false;\n\t\tlong long daijia=f[y][0]*3%mod+f[y][1]*2%mod;\n\t\tdaijia%=mod;\n\t\tlong long nowf=f[k][0]*ksmi(daijia,mod-2)%mod;\n\t\tnowf=nowf*f[y][1]%mod;\n\t\tf[k][1]=(f[k][1]+nowf)%mod;\n\t}\n\tif (bo) f[k][1]=1;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tinsert(x,y);insert(y,x);\n\t}\n\tlong long ans=0;\n\tdia=0;\n\tmiddle=0;smid=0;\n\tdfs1(1,0);\n\twhile (maxdep1[smid]!=1)\n\t\tsmid=maxwhere1[smid];\n\tdfs1(smid,0);\n\tif (dia%2==0)\n\t{\n\t\tlong long ans=ksmi(3,n-dia);\n\t\tprintf(\"%lld\\n\",ans);\n\t\treturn 0;\n\t}\n\tint k=dia/2;\n\tmiddle=smid;\n\twhile (k)\n\t{\n\t\tmiddle=maxwhere1[middle];\n\t\tk--;\n\t}\n\tdfs1(middle,0);\n\tdfs(middle,0);\n\tlong long sp=1;\n\tfor (int i=head[middle];i;i=next[i]) \n\t\tif (maxdep1[edge[i]]+1==maxdep1[middle]) g[edge[i]]=(ksmi(3,size[edge[i]])-2*f[edge[i]][1]%mod+mod)%mod;\n\t\telse\tg[edge[i]]=ksmi(3,size[edge[i]]);\n\tfor (int i=head[middle];i;i=next[i]) sp=sp*g[edge[i]]%mod;\n\tfor (int i=head[middle];i;i=next[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (maxdep1[y]+1!=maxdep1[middle]) continue;\n\t\tfor (int j=head[middle];j;j=next[j])\n\t\t{\n\t\t\tint p=edge[j];\n\t\t\tif (p==y) continue;\n\t\t\tif (maxdep1[y]+maxdep1[p]+1<dia) continue;\n\t\t\tlong long daijia=sp*ksmi(g[y],mod-2)%mod*ksmi(g[p],mod-2)%mod;\n\t\t\tans=(ans+daijia*f[y][1]%mod*f[p][1]%mod)%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans*ksmi(2,mod-2)%mod);\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e5 + 5, mod = 998244353;\n\nvector<int> g[N];\nint par[N], lv[N];\nlong long dp[N][3], tmp[3];\n\nvoid add(long long & var, long long val) {\n  var += val;\n  if (var >= mod)\n    var -= mod;\n}\n\nvoid dfs(int v, int p) {\n  par[v] = p;\n  for (int u : g[v]) {\n    if (u == p) continue;\n    lv[u] = lv[v] + 1;\n    dfs(u, v);\n  }\n}\n\nvoid solve(int v, int p, int depth) {\n  memset(dp[v], 0, sizeof dp[v]);\n  dp[v][(depth == 0)] = 1;\n  --depth;\n  for (int u : g[v]) {\n    if (u == p) continue;\n    solve(u, v, depth);\n    memset(tmp, 0, sizeof tmp);\n    for (int i = 0; i < 3; ++i) {\n      for (int j = 0; j < 3; ++j) {\n        add(tmp[min(i+j, 2)], dp[v][i] * dp[u][j] % mod);\n        add(tmp[i], 2LL * dp[v][i] * dp[u][j] % mod);\n      }\n    }\n    for (int i = 0; i < 3; ++i)\n      dp[v][i] = tmp[i];\n  }\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i < n; ++i) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    --u, --v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  lv[0] = 0;\n  dfs(0, 0);\n  int root = 0;\n  for (int i = 0; i < n; ++i) {\n    if (lv[i] > lv[root])\n      root = i;\n  }\n  lv[root] = 0;\n  dfs(root, -1);\n  int leaf = 0;\n  for (int i = 0; i < n; ++i) {\n    if (lv[i] > lv[leaf])\n      leaf = i;\n  }\n  int diam = lv[leaf];\n  long long ans = 0;\n  if (diam & 1) {\n    int a = leaf;\n    for (int i = 0; i < diam/2; ++i) {\n      a = par[a];\n    }\n    int b = par[a];\n    solve(a, b, diam/2);\n    solve(b, a, diam/2);\n    ans = 1LL * dp[a][1] * dp[b][1] % mod;\n  }\n  else {\n    int c = leaf;\n    for (int i = 0; i < diam/2; ++i) {\n      c = par[c];\n    }\n    long long best[3];\n    memset(best, 0, sizeof best);\n    best[0] = 1;\n    for (int u : g[c]) {\n      solve(u, c, diam/2-1);\n      memset(tmp, 0, sizeof tmp);\n      dp[u][0] = (dp[u][0] - dp[u][1] - dp[u][2]) % mod;\n      dp[u][0] = (3LL * dp[u][0] + 2LL * dp[u][1] + 2LL * dp[u][2]) % mod;\n      tmp[0] = (best[0] * dp[u][0]) % mod;\n      tmp[1] = (best[0] * dp[u][1] + best[1] * dp[u][0]) % mod;\n      tmp[2] = (best[1] * dp[u][1] + best[2] * dp[u][0]) % mod;\n      for (int i = 0; i < 3; ++i)\n        best[i] = tmp[i];\n    }\n    ans = best[2];\n  }\n  ans %= mod;\n  if (ans < 0)\n    ans += mod;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=2e5+5,mod=998244353;\nint n,m,dis[N],fa[N],a[N],si[N],rt1,rt2,head[N],nex[N<<1],to[N<<1],tot;\nvoid add(int u,int v){to[++tot]=v;nex[tot]=head[u];head[u]=tot;}\nvoid dfs(int u,int p)\n{\n    dis[u]=dis[p]+1;\n    if(dis[u]>dis[rt1]) rt1=u;\n    fa[u]=p;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p)continue;\n        dfs(v,u);\n    }\n}\nll dp[N][3][3],p[3][3];\nvoid dfs(int u,int fa,int d)\n{\n    d==m/2?dp[u][1][1]=1:dp[u][0][0]=1;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==fa)continue;\n        dfs(v,u,d+1);\n        memset(p,0,sizeof(p));\n        for(int i=0;i<3;i++)\n            for(int j=0;j<3;j++)\n            for(int k=0;k<3;k++)\n                for(int h=0;h<3;h++)\n        {\n            p[i][j]=(p[i][j]+dp[u][i][j]*dp[v][k][h])%mod;\n            p[min(i+k,2)][j]=(p[min(i+k,2)][j]+dp[u][i][j]*dp[v][k][h])%mod;\n            p[i][min(j+h,2)]=(p[i][min(j+h,2)]+dp[u][i][j]*dp[v][k][h])%mod;\n        }\n        for(int i=0;i<3;i++)\n            for(int j=0;j<3;j++)\n            dp[u][i][j]=p[i][j];\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        int u,v;scanf(\"%d%d\",&u,&v);add(u,v);add(v,u);\n    }\n    dfs(1,0);\n    rt2=rt1;\n    dfs(rt1,0);\n    while(fa[rt1]) a[++m]=rt1,rt1=fa[rt1];\n    a[++m]=rt1;\n    rt1=rt2=0;\n    if(m%2==0) rt1=a[m/2],rt2=a[m/2+1];\n    else rt1=a[m/2+1];\n    m--;\n    if(rt1&&rt2)\n    {\n        dfs(rt1,rt2,0);dfs(rt2,rt1,0);\n        printf(\"%lld\\n\",(dp[rt1][1][0]+dp[rt1][1][1]+dp[rt1][1][2])*(dp[rt2][1][0]+dp[rt2][1][1]+dp[rt2][1][2])%mod);\n    }\n    else\n    {\n        dfs(rt1,0,0);\n        printf(\"%lld\\n\",dp[rt1][1][1]*(mod-mod/2)%mod);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e5 + 5, mod = 998244353;\n\nvector<int> g[N];\nint par[N], lv[N];\nlong long dp[N][3], tmp[3];\n\nvoid add(long long & var, long long val) {\n  var += val;\n  if (var >= mod)\n    var -= mod;\n}\n\nvoid dfs(int v, int p) {\n  par[v] = p;\n  for (int u : g[v]) {\n    if (u == p) continue;\n    lv[u] = lv[v] + 1;\n    dfs(u, v);\n  }\n}\n\nvoid solve(int v, int p, int depth) {\n  memset(dp[v], 0, sizeof dp[v]);\n  dp[v][(depth == 0)] = 1;\n  --depth;\n  for (int u : g[v]) {\n    if (u == p) continue;\n    solve(u, v, depth);\n    memset(tmp, 0, sizeof tmp);\n    for (int i = 0; i < 3; ++i) {\n      for (int j = 0; j < 3; ++j) {\n        add(tmp[min(i+j, 2)], dp[v][i] * dp[u][j] % mod);\n        add(tmp[i], 2LL * dp[v][i] * dp[u][j] % mod);\n      }\n    }\n    for (int i = 0; i < 3; ++i)\n      dp[v][i] = tmp[i];\n  }\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i < n; ++i) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    --u, --v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  lv[0] = 0;\n  dfs(0, 0);\n  int root = 0;\n  for (int i = 0; i < n; ++i) {\n    if (lv[i] > lv[root])\n      root = i;\n  }\n  lv[root] = 0;\n  dfs(root, -1);\n  int leaf = 0;\n  for (int i = 0; i < n; ++i) {\n    if (lv[i] > lv[leaf])\n      leaf = i;\n  }\n  int diam = lv[leaf];\n  long long ans = 0;\n  if (diam & 1) {\n    int a = leaf;\n    for (int i = 0; i < diam/2; ++i) {\n      a = par[a];\n    }\n    int b = par[a];\n    solve(a, b, diam/2);\n    solve(b, a, diam/2);\n    ans = 1LL * dp[a][1] * dp[b][1] % mod;\n  }\n  else {\n    int c = leaf;\n    for (int i = 0; i < diam/2; ++i) {\n      c = par[c];\n    }\n    long long best[3];\n    memset(best, 0, sizeof best);\n    best[0] = 1;\n    for (int u : g[c]) {\n      solve(u, c, diam/2-1);\n      memset(tmp, 0, sizeof tmp);\n      if (diam/2 > 1)\n        dp[u][0] = (dp[u][0] - dp[u][1] - dp[u][2]) % mod;\n      dp[u][0] = (3LL * dp[u][0] + dp[u][1] + dp[u][2]) % mod;\n      tmp[0] = (best[0] * dp[u][0]) % mod;\n      tmp[1] = (best[0] * dp[u][1] + best[1] * dp[u][0]) % mod;\n      tmp[2] = (best[1] * dp[u][1] + best[2] * dp[u][0]) % mod;\n      for (int i = 0; i < 3; ++i)\n        best[i] = tmp[i];\n    }\n    ans = best[2];\n  }\n  ans %= mod;\n  if (ans < 0)\n    ans += mod;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 2e5 + 5, mod = 998244353;\n\ninline int gi()\n{\n\tchar c = getchar();\n\twhile (c < '0' || c > '9') c = getchar();\n\tint sum = 0;\n\twhile ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();\n\treturn sum;\n}\n\ninline void inc(int &a, int b) {a += b; if (a >= mod) a -= mod;}\n\nint n, rt, len, fa[maxn], ch[maxn];\n\nstruct edge\n{\n\tint to, next;\n} e[maxn * 2];\nint h[maxn], tot;\nint md[maxn], f[maxn][3][3], g[3][3];\n\ninline void add(int u, int v)\n{\n\te[++tot] = (edge) {v, h[u]}; h[u] = tot;\n\te[++tot] = (edge) {u, h[v]}; h[v] = tot;\n}\n\nvoid dfs1(int u, int d)\n{\n\tif (d > len) rt = u, len = d;\n\tmd[u] = d;\n\tfor (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n\t\tif (v != fa[u]) fa[v] = u, dfs1(v, d + 1), md[u] = max(md[u], md[v]);\n}\n\nvoid dfs2(int u, int d)\n{\n\t(md[u] == d ? f[u][1][1] : f[u][0][0]) = 1;\n\tfor (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n\t\tif (v != fa[u]) {\n\t\t\tfa[v] = u; dfs2(v, d + 1);\n\t\t\tmemset(g, 0, sizeof(g));\n\t\t\tfor (int a = 0; a <= 2; ++a)\n\t\t\t\tfor (int b = 0; b <= 2; ++b)\n\t\t\t\t\tif (f[u][a][b])\n\t\t\t\t\t\tfor (int c = 0; c <= 2; ++c)\n\t\t\t\t\t\t\tfor (int d = 0; d <= 2; ++d)\n\t\t\t\t\t\t\t\tif (f[v][c][d])\n\t\t\t\t\t\t\t\t\tfor (int t = -1; t <= 1; ++t)\n\t\t\t\t\t\t\t\t\t\tinc(g[min(2, a + (md[v] == md[u] && t == 1) * c)][min(2, b + (md[v] == md[u] && t == -1) * d)], (ll)f[u][a][b] * f[v][c][d] % mod);\n\t\t\tmemcpy(f[u], g, sizeof(f[u]));\n\t\t}\n}\n\nint main()\n{\n\tn = gi();\n\tfor (int i = 1; i < n; ++i) add(gi(), gi());\n\n\tdfs1(1, 0);\n\tfa[rt] = 0; len = 0; dfs1(rt, 0);\n\tfor (int i = 0, x = rt; x; x = fa[x]) ch[i++] = x;\n\n\tif (~len & 1) {\n\t\tint x = ch[len >> 1];\n\t\tfa[x] = 0, dfs1(x, 0);\n\t\tdfs2(x, 0);\n\t\tprintf(\"%lld\\n\", (ll)f[x][1][1] * (mod + 1) / 2 % mod);\n\t}\n\telse {\n\t\tint x = ch[len >> 1], y = ch[len + 1 >> 1];\n\t\tfa[x] = y; fa[y] = x;\n\t\tdfs1(x, 0); dfs2(x, 0);\n\t\tdfs1(y, 0); dfs2(y, 0);\n\t\tprintf(\"%lld\\n\", ((ll)f[x][1][0] + f[x][1][1] + f[x][1][2]) * ((ll)f[y][1][0] + f[y][1][1] + f[y][1][2]) % mod);\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#define ll long long\n#define mod 998244353\n#define maxn 200010\ninline ll read()\n{\n\tll x=0; char c=getchar(),f=1;\n\tfor(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n\tfor(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\ninline void write(ll x)\n{\n\tstatic int buf[20],len; len=0;\n\tif(x<0)x=-x,putchar('-');\n\tfor(;x;x/=10)buf[len++]=x%10;\n\tif(!len)putchar('0');\n\telse while(len)putchar(buf[--len]+'0');\n}\ninline void writeln(ll x){write(x); putchar('\\n');}\ninline void writesp(ll x){write(x); putchar(' ');}\nconst int inv2=(mod+1)/2;\nstruct edge{\n\tint to,nxt;\n}e[2*maxn];\nint fir[maxn],dist1[maxn],dist2[maxn],dep[maxn],size[maxn];\nll f[maxn],g[maxn];\nint n,tot;\nll power(ll a,ll b)\n{\n\tll ans=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)ans=ans*a%mod;\n\treturn ans;\n}\nvoid add_edge(int x,int y){e[tot].to=y; e[tot].nxt=fir[x]; fir[x]=tot++;}\nvoid dfs(int now,int fa,int* dep)\n{\n\tfor(int i=fir[now];~i;i=e[i].nxt)\n\t\tif(e[i].to!=fa){\n\t\t\tdep[e[i].to]=dep[now]+1;\n\t\t\tdfs(e[i].to,now,dep);\n\t\t}\n}\nvoid dp(int now,int fa)\n{\n\tdep[now]=0; size[now]=1;\n\tint cnt=0;\n\tfor(int i=fir[now];~i;i=e[i].nxt)\n\t\tif(e[i].to!=fa){\n\t\t\t++cnt;\n\t\t\tdp(e[i].to,now);\n\t\t\tdep[now]=std::max(dep[now],dep[e[i].to]+1);\n\t\t\tsize[now]+=size[e[i].to];\n\t\t}\n\tif(!cnt){\n\t\tf[now]=1; g[now]=2;\n\t\treturn;\n\t}\n\tll t=1;\n\tfor(int i=fir[now];~i;i=e[i].nxt)\n\t\tif(e[i].to!=fa){\n\t\t\tif(dep[now]==dep[e[i].to]+1)t=t*g[e[i].to]%mod;\n\t\t\telse t=t*(f[e[i].to]+g[e[i].to])%mod;\n\t\t}\n\tf[now]=0;\n\tfor(int i=fir[now];~i;i=e[i].nxt)\n\t\tif(e[i].to!=fa){\n\t\t\tif(dep[now]==dep[e[i].to]+1)f[now]=(f[now]+t*power(g[e[i].to],mod-2)%mod*f[e[i].to])%mod;\n\t\t}\n\tg[now]=(power(3,size[now])-f[now]+mod)%mod;\n}\nint main()\n{\n\tn=read();\n\tmemset(fir,255,sizeof(fir)); tot=0;\n\tfor(int i=1;i<n;i++){\n\t\tint x=read(),y=read();\n\t\tadd_edge(x,y); add_edge(y,x);\n\t}\n\tdist1[1]=0;\n\tdfs(1,-1,dist1);\n\tint S=1;\n\tfor(int i=2;i<=n;i++)\n\t\tif(dist1[i]>dist1[S])S=i;\n\tdist1[S]=0;\n\tdfs(S,-1,dist1);\n\tint T=1;\n\tfor(int i=2;i<=n;i++)\n\t\tif(dist1[i]>dist1[T])T=i;\n\tdist2[T]=0;\n\tdfs(T,-1,dist2);\n\tint L=dist1[T];\n\tif(L&1){\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=fir[i];~j;j=e[j].nxt)\n\t\t\t\tif(dist1[i]==L/2&&dist2[e[j].to]==L/2){\n\t\t\t\t\tdp(i,e[j].to); dp(e[j].to,i);\n\t\t\t\t\twriteln(f[i]*f[e[j].to]%mod);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t}\n\telse{\n\t\tint C=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(dist1[i]==L/2&&dist2[i]==L/2){\n\t\t\t\tC=i; break;\n\t\t\t}\n\t\t// writeln(C);\n\t\tdp(C,-1);\n\t\tll t=1,sum1=0,sum2=0;\n\t\tfor(int i=fir[C];~i;i=e[i].nxt)\n\t\t\tif(dep[e[i].to]+1==L/2){\n\t\t\t\tt=t*(g[e[i].to]-f[e[i].to]+mod)%mod;\n\t\t\t\tll cur=power(g[e[i].to]-f[e[i].to]+mod,mod-2)*f[e[i].to]%mod;\n\t\t\t\tsum1=(sum1+cur)%mod;\n\t\t\t\tsum2=(sum2+cur*cur)%mod;\n\t\t\t}\n\t\t\telse t=t*(f[e[i].to]+g[e[i].to])%mod;\n\t\t// printf(\"%lld %lld %lld\\n\",t,sum1,sum2);\n\t\twriteln(t*((sum1*sum1-sum2+mod)%mod*inv2%mod)%mod);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=200005;\nconst int mod=998244353;\nvoid ad(int &x,int y){x+=y;if(x>=mod)x-=mod;}\nvector<int> nxt[MAXN];\nvoid ins(int x,int y){nxt[x].emplace_back(y);}\nint dis[MAXN],sta[MAXN],tp,n;\nvoid dfs(int x,int fa){for(auto y:nxt[x])if(y^fa)dis[y]=dis[x]+1,dfs(y,x);}\nbool getpath(int x,int fa,int ed)\n{\n\tif(x==ed){sta[++tp]=x;return true;}\n\tfor(auto y:nxt[x])if((y^fa)&&getpath(y,x,ed)){sta[++tp]=x;return true;}\n\treturn false;\n}\nint f[MAXN][3];//存在几条不同子树与父亲差值没变且为mx的 \nint trans[3];bool tag[MAXN];\nvoid dp(int x,int fa)\n{\n\tif(SZ(nxt[x])==1)\n\t{\n\t\tif(tag[x])f[x][1]=1,f[x][0]=2;\n\t\telse f[x][0]=3;return ;\n\t}f[x][0]=1;\n\tfor(auto y:nxt[x])if(y^fa)dp(y,x);\n\tfor(auto y:nxt[x])if(y^fa)\n\t{\n\t\tmemset(trans,0,sizeof(trans));\n\t\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)if(f[x][i]&&f[y][j])\n\t\t\tad(trans[min(2,i+j)],1LL*f[x][i]*f[y][j]%mod);//+1\n\t\tfor(int i=0;i<3;i++)f[x][i]=trans[i];\n\t}f[x][0]=(3LL*f[x][0]+2LL*(f[x][1]+f[x][2]))%mod;\n}\nint ans[3];\nint main()\n{\n//\tfreopen(\"a.in\",\"r\",stdin);\n//\tfreopen(\"a.out\",\"w\",stdout);\n\tn=read();\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\tins(x,y);ins(y,x);\n\t}dfs(1,0);int p=0,q=0;for(int i=1;i<=n;i++)if(dis[i]>dis[p])p=i;\n\tdis[p]=0;dfs(p,0);for(int i=1;i<=n;i++)if(dis[i]>dis[q])q=i;\n\tgetpath(p,0,q);\n\tif(tp&1)\n\t{\n\t\tint u=sta[tp/2+1];dis[u]=0;dfs(u,0);\n\t\tfor(int i=1;i<=n;i++)if(dis[i]==tp/2)tag[i]=1;\n\t\tans[0]=1;\n\t\tfor(auto y:nxt[u])\n\t\t{\n\t\t\tdp(y,u);int x0=(f[y][0]-(f[y][1]+f[y][2])%mod+mod)%mod,x1=f[y][1];\n\t\t\tans[2]=(1LL*ans[2]*x0+1LL*ans[1]*x1)%mod;\n\t\t\tans[1]=(1LL*ans[1]*x0+1LL*ans[0]*x1)%mod;\n\t\t\tans[0]=1LL*ans[0]*x0%mod;\n\t\t}pr2(ans[2]);\n\t}\n\telse\n\t{\n\t\tint u=sta[tp/2],v=sta[tp/2+1];dis[u]=dis[v]=0;dfs(u,v);dfs(v,u);\n\t\tfor(int i=1;i<=n;i++)if(dis[i]==(tp-1)/2)tag[i]=1;\n\t\tdp(u,v);dp(v,u);pr2(1LL*f[u][1]*f[v][1]%mod);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e5 + 5, mod = 998244353;\n\nvector<int> g[N];\nint par[N], lv[N];\nlong long dp[N][3], tmp[3];\n\nvoid add(long long & var, long long val) {\n  var += val;\n  if (var >= mod)\n    var -= mod;\n}\n\nvoid dfs(int v, int p) {\n  par[v] = p;\n  for (int u : g[v]) {\n    if (u == p) continue;\n    lv[u] = lv[v] + 1;\n    dfs(u, v);\n  }\n}\n\nvoid solve(int v, int p, int depth) {\n  memset(dp[v], 0, sizeof dp[v]);\n  dp[v][(depth == 0)] = 1;\n  --depth;\n  for (int u : g[v]) {\n    if (u == p) continue;\n    solve(u, v, depth);\n    memset(tmp, 0, sizeof tmp);\n    for (int i = 0; i < 3; ++i) {\n      for (int j = 0; j < 3; ++j) {\n        add(tmp[min(i+j, 2)], dp[v][i] * dp[u][j] % mod);\n        add(tmp[i], 2LL * dp[v][i] * dp[u][j] % mod);\n      }\n    }\n    for (int i = 0; i < 3; ++i)\n      dp[v][i] = tmp[i];\n  }\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i < n; ++i) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    --u, --v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  lv[0] = 0;\n  dfs(0, 0);\n  int root = 0;\n  for (int i = 0; i < n; ++i) {\n    if (lv[i] > lv[root])\n      root = i;\n  }\n  lv[root] = 0;\n  dfs(root, -1);\n  int leaf = 0;\n  for (int i = 0; i < n; ++i) {\n    if (lv[i] > lv[leaf])\n      leaf = i;\n  }\n  int diam = lv[leaf];\n  long long ans = 0;\n  if (diam & 1) {\n    int a = leaf;\n    for (int i = 0; i < diam/2; ++i) {\n      a = par[a];\n    }\n    int b = par[a];\n    solve(a, b, diam/2);\n    solve(b, a, diam/2);\n    ans = 1LL * dp[a][1] * dp[b][1] % mod;\n  }\n  else {\n    int c = leaf;\n    for (int i = 0; i < diam/2; ++i) {\n      c = par[c];\n    }\n    long long best[3];\n    memset(best, 0, sizeof best);\n    best[0] = 1;\n    for (int u : g[c]) {\n      solve(u, c, diam/2-1);\n      memset(tmp, 0, sizeof tmp);\n      if (diam == 2)\n        dp[u][0] = dp[u][1];\n      else {\n        dp[u][0] = (dp[u][0] - dp[u][1] - dp[u][2]) % mod;\n        dp[u][0] = (3LL * dp[u][0] + 3LL * dp[u][1] + 3LL * dp[u][2]) % mod;\n      }\n      tmp[0] = (best[0] * dp[u][0]) % mod;\n      tmp[1] = (best[0] * dp[u][1] + best[1] * dp[u][0]) % mod;\n      tmp[2] = (best[1] * dp[u][1] + best[2] * dp[u][0]) % mod;\n      for (int i = 0; i < 3; ++i)\n        best[i] = tmp[i];\n    }\n    ans = best[2];\n  }\n  ans %= mod;\n  if (ans < 0)\n    ans += mod;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[202020];\nconst ll mo=998244353;\nll dp[202020][3][3];\n\npair<int,int> farthest(int cur,int pre,int d,vector<int>& D) {\n\tD[cur]=d;\n\tpair<int,int> r={d,cur};\n\tFORR(e,E[cur]) if(e!=pre) r=max(r, farthest(e,cur,d+1,D));\n\treturn r;\n}\n\npair<int,vector<int>> diameter() { // diameter,center\n\tvector<int> D[2];\n\tD[0].resize(N);\n\tD[1].resize(N);\n\tauto v1=farthest(0,0,0,D[0]);\n\tauto v2=farthest(v1.second,v1.second,0,D[0]);\n\tfarthest(v2.second,v2.second,0,D[1]);\n\tpair<int,vector<int>> R;\n\tR.first = v2.first;\n\t//重心を取る場合\n\tfor(int i=N-1;i>=0;i--) if(D[0][i]+D[1][i]==R.first && abs(D[0][i]-D[1][i])<=1) R.second.push_back(i);\n\n\treturn R;\n}\n\nvoid dfs(int cur,int pre,int lef) {\n\tif(lef==0) {\n\t\tdp[cur][1][1]=1;\n\t}\n\telse {\n\t\tdp[cur][0][0]=1;\n\t}\n\t\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\tdfs(e,cur,lef-1);\n\t\tll to[3][3]={};\n\t\tint a1,a2,b1,b2;\n\t\tFOR(a1,3) FOR(a2,3) FOR(b1,3) FOR(b2,3) {\n\t\t\t// +1\n\t\t\tto[min(a1+b1,2)][a2]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t\t// 0\n\t\t\tto[a1][a2]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t\t// -1\n\t\t\tto[a1][min(a2+b2,2)]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t}\n\t\t\n\t\tFOR(a1,3) FOR(a2,3) dp[cur][a1][a2]=to[a1][a2]%mo;\n\t}\n\t\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tauto R=diameter();\n\tif(R.second.size()==1) {\n\t\tx=R.second[0];\n\t\tdfs(x,-1,R.first/2);\n\t\tcout<<dp[x][1][1]*((mo+1)/2)%mo<<endl;\n\t}\n\telse {\n\t\tx=R.second[0];\n\t\ty=R.second[1];\n\t\tdfs(x,y,R.first/2);\n\t\tdfs(y,x,R.first/2);\n\t\tll ret=(dp[x][0][1]+dp[x][1][1])*dp[y][1][0]%mo;\n\t\tret+=(dp[y][0][1]+dp[y][1][1])*dp[x][1][0]%mo;\n\t\tret+=(dp[x][1][1]+dp[y][1][1])*2%mo;\n\t\tcout<<ret%mo*((mo+1)/2)%mo<<endl;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\ndouble startTime;\ndouble getCurrentTime() {\n\treturn ((double)clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst ll MOD = (ll)998244353;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\n\nconst int N = 200200;\nint n;\nvector<int> g[N];\nll ANS;\nint dist[N];\nint q[N];\nint par[N];\nint topQ;\nint D;\nll dp[N][3];\n\nvoid BFS(int v) {\n\tfor (int i = 0; i < n; i++)\n\t\tdist[i] = N;\n\tdist[v] = 0;\n\ttopQ = 0;\n\tq[topQ++] = v;\n\tfor (int i = 0; i < topQ; i++) {\n\t\tv = q[i];\n\t\tfor (int u : g[v]) {\n\t\t\tif (dist[u] <= dist[v] + 1) continue;\n\t\t\tdist[u] = dist[v] + 1;\n\t\t\tpar[u] = v;\n\t\t\tq[topQ++] = u;\n\t\t}\n\t}\n}\n\nvoid dfs(int v, int p) {\n\tdp[v][0] = dp[v][1] = dp[v][2] = 0;\n\tif ((int)g[v].size() == 1) {\n\t\tdp[v][(int)(dist[v] == D)] = 1;\n\t\t//dp[v][0] = add(dp[v][0], 2);\n\t\treturn;\n\t}\n\tdp[v][0] = 1;\n\tll inner[3];\n\tfor (int u : g[v]) {\n\t\tif (u == p) continue;\n\t\tinner[0] = inner[1] = inner[2] = 0;\n\t\tdfs(u, v);\n\t\tll w[2];\n\t\tw[0] = w[1] = 0;\n\t\tw[0] = add(mult(3, dp[u][0]), mult(2, add(dp[u][2], dp[u][1])));\n\t\tw[1] = dp[u][1];\n\t\tfor (int x = 0; x < 3; x++)\n\t\t\tfor (int y = 0; y < 2; y++) {\n\t\t\t\tif (x + y < 3)\n\t\t\t\t\tinner[x + y] = add(inner[x + y], mult(dp[v][x], w[y]));\n\t\t\t}\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tdp[v][i] = inner[i];\n\t}\n}\n\nvoid solveVertex(int v) {\n\teprintf(\"solveVertex %d\\n\", v);\n\tD /= 2;\n\tBFS(v);\n\tll inner[2][3];\n\tfor (int i = 0; i < 2; i++)\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tinner[i][j] = 0;\n\tinner[0][0] = 1;\n\tfor (int u : g[v]) {\n\t\tdfs(u, v);\n\t\tll w[2];\n\t\tw[0] = w[1] = 0;\n\t\tw[0] = add(mult(3, dp[u][0]), add(mult(2, dp[u][2]), dp[u][1]));\n\t\tw[1] = dp[u][1];\n\t\teprintf(\"%lld %lld\\n\", w[0], w[1]);\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tinner[1][i] = 0;\n\t\tfor (int x = 0; x < 3; x++)\n\t\t\tfor (int y = 0; y < 2; y++)\n\t\t\t\tif (x + y < 3)\n\t\t\t\t\tinner[1][x + y] = add(inner[1][x + y], mult(inner[0][x], w[y]));\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tinner[0][i] = inner[1][i];\n\t}\n\tll ans = inner[0][2];\n\tprintf(\"%lld\\n\", ans);\n}\nvoid solveEdge(int v, int u) {\n\teprintf(\"solveEdge %d %d\\n\", v, u);\n\tD /= 2;\n\tll ans = 1;\n\tfor (int k = 0; k < 2; k++) {\n\t\tBFS(v);\n\t\tdfs(v, u);\n\t\tans = mult(ans, dp[v][1]);\n\t\tswap(v, u);\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tstartTime = (double)clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\n\tBFS(0);\n\tint V = q[n - 1];\n\tBFS(V);\n\tint U = q[n - 1];\n\tD = dist[U];\n\n\tif (D & 1) {\n\t\tint v = U;\n\t\tfor (int i = 0; i < D / 2; i++)\n\t\t\tv = par[v];\n\t\tsolveEdge(v, par[v]);\n\t} else {\n\t\tint v = U;\n\t\tfor (int i = 0; i < D / 2; i++)\n\t\t\tv = par[v];\n\t\tsolveVertex(v);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ninline int read()\n{\n    int s=0,f=1; char ch=getchar();\n    while(!isdigit(ch) && ch!='-')ch=getchar();\n    if(ch=='-')ch=getchar(),f=-1;\n    while(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n    return ~f?s:-s;\n}\n\nconst int maxn=1e6+20;\n\nvector<int>ed[maxn];\nint n;\n\ninline void init()\n{\n    n=read();\n    REP(i,1,n-1)\n    {\n\tint u=read(),v=read();\n\ted[u].push_back(v);\n\ted[v].push_back(u);\n    }\n}\n\nint cir[maxn],len;\n\ninline int bfs(int S)\n{\n    static int dis[maxn],pre[maxn];\n    memset(dis,-1,sizeof(dis));\n    queue<int>q;\n    q.push(S); dis[S]=0; pre[S]=0;\n    while(!q.empty())\n    {\n\tint u=q.front(); q.pop();\n\tfor(int v:ed[u])\n\t    if(dis[v]==-1)\n\t\tq.push(v),dis[v]=dis[u]+1,pre[v]=u;\n    }\n    int T=0,tmx=0;\n    REP(i,1,n)if(dis[i]>tmx)tmx=dis[i],T=i;\n    int x=T;\n    len=0;\n    while(x)cir[++len]=x,x=pre[x];\n    reverse(cir+1,cir+len+1);\n    return T;\n}\n\nint rt;\n\ninline void find_Len()\n{\n    int S=bfs(1);\n    int T=bfs(S);\n    if(len%2==1)rt=cir[len+1>>1];\n    else {\n\tint x=cir[len>>1],y=cir[len+2>>1];\n\ted[x].erase(find(ed[x].begin(),ed[x].end(),y));\n\ted[y].erase(find(ed[y].begin(),ed[y].end(),x));\n\t++n;\n\ted[x].push_back(n); ed[y].push_back(n);\n\ted[n]={x,y};\n\trt=n;\n    }\n}\n\nint ans;\n\nint deep[maxn];\nll dp[maxn][3][3];\n\nvoid dfs(int u,int fa)\n{\n    int son=0;\n    for(int v:ed[u])\n    {\n\tif(v==fa)continue;\n\tdeep[v]=deep[u]+1;\n\tdfs(v,u);\n\tson++;\n    }\n    if(!son)dp[u][deep[u]==len/2][deep[u]==len/2]=1;\n    else {\n\tdp[u][0][0]=1;\n\tfor(int v:ed[u])\n\t{\n\t    if(v==fa)continue;\n\t    ll g[3][3]={0};\n\t    REP(a,0,2)REP(b,0,2)REP(c,0,2)REP(d,0,2)REP(edge,-1,1)\n\t\tg[min(a+c*(edge==1),2)][min(b+d*(edge==-1),2)]+=dp[u][a][b]*dp[v][c][d];\n\t    REP(a,0,2)REP(b,0,2)dp[u][a][b]=g[a][b];\n\t}\n    }\n}\n\ninline void doing()\n{\n    find_Len();\n    dfs(rt,0);\n    printf(\"%lld\\n\",dp[rt][1][1]/2);\n}\n\nint main()\n{\n    init();\n    doing();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for(int i=(a),_ed=(b);i<=_ed;++i)\n#define DREP(i,a,b) for(int i=(a),_ed=(b);i>=_ed;--i)\n#define mp(x,y) make_pair((x),(y))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int,int> pii;\ninline int read(){\n    register int x=0,f=1;register char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=0;ch=getchar();}\n    while(isdigit(ch)){x=x*10+(ch^'0');ch=getchar();}\n    return f?x:-x;\n}\n\nconst int N=2e5+5,mod=998244353;\nint n,c[2],mxd[N],f[N][3][3],g[3][3];\nvector<int> E[N];\ninline void inc(int& x,int y){x=x+y<mod?x+y:x+y-mod;}\n\nnamespace getcore{\n\tint d[N],fa[N],stk[N],tp,tmp;\n\tvoid dfs(int u,int pa,int dis,int& rt){\n\t\td[u]=dis,fa[u]=pa;if(d[u]>d[rt])rt=u;\n\t\tfor(int v:E[u]){\n\t\t\tif(v==pa)continue;\n\t\t\tdfs(v,u,dis+1,rt);\n\t\t}\n\t}\n\tvoid Main(){\n\t\tdfs(1,0,0,tmp);\n\t\tdfs(tmp,0,0,tmp);\n\t\twhile(tmp)stk[++tp]=tmp,tmp=fa[tmp];\n\t\tc[0]=stk[(tp+1)>>1];\n\t\tif(~tp&1)c[1]=stk[((tp+1)>>1)+1];//想清楚啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊\n\t}\n}\n\nint dfs(int u,int pa,int dep){\n\tmxd[u]=dep;\n\tfor(int v:E[u]){\n\t\tif(v==pa||v==c[0]||v==c[1])continue;\n\t\tmxd[u]=max(mxd[u],dfs(v,u,dep+1));\n\t}\n\tif(mxd[u]==dep)f[u][1][1]=1;\n\telse f[u][0][0]=1;\n\tfor(int v:E[u]){\n\t\tif(v==pa||v==c[0]||v==c[1])continue;\n\t\tREP(i,0,2)REP(j,0,2)g[i][j]=0;\n\t\tREP(a,0,2)REP(b,0,2)REP(p,0,2)REP(q,0,2){\n\t\t\tint flg=mxd[u]==mxd[v];\n\t\t\tint s=a,t=b,val=1ll*f[u][a][b]*f[v][p][q]%mod;\n\t\t\tinc(g[s][t],val);\n\t\t\ts=flg?min(2,a+p):a,t=b;\n\t\t\tinc(g[s][t],val);\n\t\t\ts=a,t=flg?min(2,b+q):b;\n\t\t\tinc(g[s][t],val);\n\t\t}\n\t\tREP(i,0,2)REP(j,0,2)f[u][i][j]=g[i][j];\n\t}\n\treturn mxd[u];\n}\n\nint main(){\n\tfreopen(\"in.in\",\"r\",stdin);\n\tfreopen(\"out.out\",\"w\",stdout);\n\tn=read();\n\tREP(i,1,n-1){\n\t\tint u=read(),v=read();\n\t\tE[u].pb(v),E[v].pb(u);\n\t}\n\tgetcore::Main();\n\tint sum=0;\n\tdfs(c[0],0,0);\n\tif(!c[1])\n\t\tsum=f[c[0]][1][1];\n\telse{\n\t\tdfs(c[1],0,0);\n\t\tREP(i,0,2)REP(j,0,2)\n\t\t\tinc(sum,1ll*f[c[0]][1][i]*f[c[1]][j][1]%mod);\n\t\tREP(i,0,2)REP(j,0,2)\n\t\t\tinc(sum,1ll*f[c[0]][i][1]*f[c[1]][1][j]%mod);\n\t}\n\tsum=1ll*sum*(mod+1)/2%mod;\n\tprintf(\"%d\\n\",sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for(int i=(a),_ed=(b);i<=_ed;++i)\n#define DREP(i,a,b) for(int i=(a),_ed=(b);i>=_ed;--i)\n#define mp(x,y) make_pair((x),(y))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int,int> pii;\ninline int read(){\n    register int x=0,f=1;register char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=0;ch=getchar();}\n    while(isdigit(ch)){x=x*10+(ch^'0');ch=getchar();}\n    return f?x:-x;\n}\n\nconst int N=2e5+5,mod=998244353;\nint n,c[2],mxd[N],f[N][3][3],g[3][3];\nvector<int> E[N];\ninline void inc(int& x,int y){x=x+y<mod?x+y:x+y-mod;}\n\nnamespace getcore{\n\tint d[N],fa[N];\n\tvoid dfs(int u,int pa,int dis,int& rt){\n\t\td[u]=dis,fa[u]=pa;if(d[u]>d[rt])rt=u;\n\t\tfor(int v:E[u]){\n\t\t\tif(v==pa)continue;\n\t\t\tdfs(v,u,dis+1,rt);\n\t\t}\n\t}\n\tvoid Main(){\n\t\tstatic int stk[N],tp,tmp;\n\t\tdfs(1,0,0,tmp);\n\t\td[tmp]=0;\n\t\tdfs(tmp,0,0,tmp);\n\t\twhile(tmp)stk[++tp]=tmp,tmp=fa[tmp];\n\t\tc[0]=stk[(tp+1)>>1];\n\t\tif(~tp&1)c[1]=stk[(tp-1)>>1];\n\t}\n}\n\nint dfs(int u,int pa,int dep){\n\tmxd[u]=dep;\n\tfor(int v:E[u]){\n\t\tif(v==pa||v==c[0]||v==c[1])continue;\n\t\tmxd[u]=max(mxd[u],dfs(v,u,dep+1));\n\t}\n\tif(mxd[u]==dep)f[u][1][1]=1;\n\telse f[u][0][0]=1;\n\tfor(int v:E[u]){\n\t\tif(v==pa||v==c[0]||v==c[1])continue;\n\t\tREP(i,0,2)REP(j,0,2)g[i][j]=0;\n\t\tREP(a,0,2)REP(b,0,2)REP(p,0,2)REP(q,0,2){\n\t\t\tint flg=mxd[u]==mxd[v];\n\t\t\tint s=a,t=b,val=1ll*f[u][a][b]*f[v][p][q]%mod;\n\t\t\tinc(g[s][t],val);\n\t\t\ts=flg?min(2,a+p):a,t=b;\n\t\t\tinc(g[s][t],val);\n\t\t\ts=a,t=flg?min(2,b+q):b;\n\t\t\tinc(g[s][t],val);\n\t\t}\n\t\tREP(i,0,2)REP(j,0,2)f[u][i][j]=g[i][j];\n\t}\n\treturn mxd[u];\n}\n\nint main(){\n\t//freopen(\"in.in\",\"r\",stdin);\n\tn=read();\n\tREP(i,1,n-1){\n\t\tint u=read(),v=read();\n\t\tE[u].pb(v),E[v].pb(u);\n\t}\n\tgetcore::Main();\n\tint sum=0;\n\tdfs(c[0],0,0);\n\tif(!c[1])\n\t\tsum=f[c[0]][1][1];\n\telse{\n\t\tdfs(c[1],0,0);\n\t\tREP(i,0,2)REP(j,0,2)\n\t\t\tinc(sum,1ll*f[c[0]][1][i]*f[c[1]][j][1]%mod);\n\t\tREP(i,0,2)REP(j,0,2)\n\t\t\tinc(sum,1ll*f[c[0]][i][1]*f[c[1]][1][j]%mod);\n\t}\n\tsum=1ll*sum*(mod+1)/2%mod;\n\tprintf(\"%d\\n\",sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ninline int read()\n{\n    int s=0,f=1; char ch=getchar();\n    while(!isdigit(ch) && ch!='-')ch=getchar();\n    if(ch=='-')ch=getchar(),f=-1;\n    while(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n    return ~f?s:-s;\n}\n\nconst int maxn=1e6+20;\nconst ll mod=998244353;\n\nvector<int>ed[maxn];\nint n;\n\ninline void init()\n{\n    n=read();\n    REP(i,1,n-1)\n    {\n\tint u=read(),v=read();\n\ted[u].push_back(v);\n\ted[v].push_back(u);\n    }\n}\n\nint cir[maxn],len;\n\ninline int bfs(int S)\n{\n    static int dis[maxn],pre[maxn];\n    memset(dis,-1,sizeof(dis));\n    queue<int>q;\n    q.push(S); dis[S]=0; pre[S]=0;\n    while(!q.empty())\n    {\n\tint u=q.front(); q.pop();\n\tfor(int v:ed[u])\n\t    if(dis[v]==-1)\n\t\tq.push(v),dis[v]=dis[u]+1,pre[v]=u;\n    }\n    int T=0,tmx=0;\n    REP(i,1,n)if(dis[i]>tmx)tmx=dis[i],T=i;\n    int x=T;\n    len=0;\n    while(x)cir[++len]=x,x=pre[x];\n    reverse(cir+1,cir+len+1);\n    return T;\n}\n\nint rt;\n\ninline void find_Len()\n{\n    int S=bfs(1);\n    int T=bfs(S);\n    if(len%2==1)rt=cir[len+1>>1];\n    else {\n\tint x=cir[len>>1],y=cir[len+2>>1];\n\ted[x].erase(find(ed[x].begin(),ed[x].end(),y));\n\ted[y].erase(find(ed[y].begin(),ed[y].end(),x));\n\t++n;\n\ted[x].push_back(n); ed[y].push_back(n);\n\ted[n]={x,y};\n\trt=n;\n    }\n}\n\nint ans;\n\nint deep[maxn];\nll dp[maxn][3][3];\n\nvoid dfs(int u,int fa)\n{\n    int son=0;\n    for(int v:ed[u])\n    {\n\tif(v==fa)continue;\n\tdeep[v]=deep[u]+1;\n\tdfs(v,u);\n\tson++;\n    }\n    if(!son)dp[u][deep[u]==len/2][deep[u]==len/2]=1;\n    else {\n\tdp[u][0][0]=1;\n\tfor(int v:ed[u])\n\t{\n\t    if(v==fa)continue;\n\t    ll g[3][3]={0};\n\t    REP(a,0,2)REP(b,0,2)REP(c,0,2)REP(d,0,2)REP(edge,-1,1)\n\t\t(g[min(a+c*(edge==1),2)][min(b+d*(edge==-1),2)]+=dp[u][a][b]*dp[v][c][d])%=mod;\n\t    REP(a,0,2)REP(b,0,2)dp[u][a][b]=g[a][b];\n\t}\n    }\n}\n\ninline void doing()\n{\n    find_Len();\n    dfs(rt,0);\n    printf(\"%lld\\n\",(ll)dp[rt][1][1]*(mod+1>>1)%mod);\n}\n\nint main()\n{\n    init();\n    doing();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#define ll long long\n#define mod 998244353\n#define maxn 200010\ninline ll read()\n{\n\tll x=0; char c=getchar(),f=1;\n\tfor(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n\tfor(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\ninline void write(ll x)\n{\n\tstatic int buf[20],len; len=0;\n\tif(x<0)x=-x,putchar('-');\n\tfor(;x;x/=10)buf[len++]=x%10;\n\tif(!len)putchar('0');\n\telse while(len)putchar(buf[--len]+'0');\n}\ninline void writeln(ll x){write(x); putchar('\\n');}\ninline void writesp(ll x){write(x); putchar(' ');}\nstruct edge{\n\tint to,nxt;\n}e[2*maxn];\nint fir[maxn],dist1[maxn],dist2[maxn],dep[maxn],size[maxn];\nll f[maxn],g[maxn];\nint n,tot;\nll power(ll a,ll b)\n{\n\tll ans=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)ans=ans*a%mod;\n\treturn ans;\n}\nvoid add_edge(int x,int y){e[tot].to=y; e[tot].nxt=fir[x]; fir[x]=tot++;}\nvoid dfs(int now,int fa,int* dep)\n{\n\tfor(int i=fir[now];~i;i=e[i].nxt)\n\t\tif(e[i].to!=fa){\n\t\t\tdep[e[i].to]=dep[now]+1;\n\t\t\tdfs(e[i].to,now,dep);\n\t\t}\n}\nvoid dp(int now,int fa)\n{\n\tdep[now]=0; size[now]=1;\n\tint cnt=0;\n\tfor(int i=fir[now];~i;i=e[i].nxt)\n\t\tif(e[i].to!=fa){\n\t\t\t++cnt;\n\t\t\tdp(e[i].to,now);\n\t\t\tdep[now]=std::max(dep[now],dep[e[i].to]+1);\n\t\t\tsize[now]+=size[e[i].to];\n\t\t}\n\tif(!cnt){\n\t\tf[now]=g[now]=1;\n\t\treturn;\n\t}\n\tll t=1;\n\tfor(int i=fir[now];~i;i=e[i].nxt)\n\t\tif(e[i].to!=fa){\n\t\t\tif(dep[now]==dep[e[i].to]+1)t=t*g[e[i].to]%mod;\n\t\t\telse t=t*(2*f[e[i].to]+g[e[i].to])%mod;\n\t\t}\n\tf[now]=0;\n\tfor(int i=fir[now];~i;i=e[i].nxt)\n\t\tif(e[i].to!=fa){\n\t\t\tif(dep[now]==dep[e[i].to]+1)f[now]=(f[now]+t*power(g[e[i].to],mod-2)%mod*f[e[i].to])%mod;\n\t\t}\n\tg[now]=(power(3,size[now])-2*f[now]+2*mod)%mod;\n}\nint main()\n{\n\tn=read();\n\tmemset(fir,255,sizeof(fir)); tot=0;\n\tfor(int i=1;i<n;i++){\n\t\tint x=read(),y=read();\n\t\tadd_edge(x,y); add_edge(y,x);\n\t}\n\tdist1[1]=0;\n\tdfs(1,-1,dist1);\n\tint S=1;\n\tfor(int i=2;i<=n;i++)\n\t\tif(dist1[i]>dist1[S])S=i;\n\tdist1[S]=0;\n\tdfs(S,-1,dist1);\n\tint T=1;\n\tfor(int i=2;i<=n;i++)\n\t\tif(dist1[i]>dist1[T])T=i;\n\tdist2[T]=0;\n\tdfs(T,-1,dist2);\n\tint L=dist1[T];\n\tif(L&1){\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=fir[i];~j;j=e[j].nxt)\n\t\t\t\tif(dist1[i]==L/2&&dist2[e[j].to]==L/2){\n\t\t\t\t\tdp(i,e[j].to); dp(e[j].to,i);\n\t\t\t\t\twriteln(f[i]*f[e[j].to]%mod);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t}\n\telse{\n\t\tint C=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(dist1[i]==L/2&&dist2[i]==L/2){\n\t\t\t\tC=i; break;\n\t\t\t}\n\t\t// writeln(C);\n\t\tdp(C,-1);\n\t\tll t=1,sum1=0,sum2=0;\n\t\tfor(int i=fir[C];~i;i=e[i].nxt)\n\t\t\tif(dep[e[i].to]+1==L/2){\n\t\t\t\tt=t*g[e[i].to]%mod;\n\t\t\t\tll cur=power(g[e[i].to],mod-2)*f[e[i].to]%mod;\n\t\t\t\tsum1=(sum1+cur)%mod;\n\t\t\t\tsum2=(sum2+cur*cur)%mod;\n\t\t\t}\n\t\t\telse t=t*(2*f[e[i].to]+g[e[i].to])%mod;\n\t\t// printf(\"%lld %lld %lld\\n\",t,sum1,sum2);\n\t\twriteln(t*((sum1*sum1-sum2+mod)%mod*((mod+1)/2)%mod)%mod);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i,a,b) for (int i=a;i<=b;i++)\n#define R(i,a,b) for (int i=a;i<b;i++)\n#define D(i,a,b) for (int i=a;i>=b;i--)\n#define go(i,x) for (int i=head[x];i;i=Next[i])\n#define pb push_back\n#define si size()\n#define fi first\n#define se second\n#define pa pair < ll,ll >\n#define ll long long\n#define mp make_pair\n#define be begin()\n#define en end()\n#define put putchar('\\n')\n#define gc getchar\n#define pc putchar\n#define N 6000055\n#define mo 998244353\n#define inf 1000000007\n#define int ll\n#define ret return puts(\"-1\"),0\nusing namespace std;\ninline ll read(){\n\tll su=0,f=1;char c=gc();\n\tfor (;c<'0'||c>'9';c=gc()) if (c=='-') f=-1;\n\tfor (;c>='0'&&c<='9';c=gc()) su=su*10+c-'0';\n\treturn su*f;\n}\ninline void wr(ll x){\n\tif (x<0) pc('-'),wr(-x);\n\telse{if (x>=10) wr(x/10);pc(x%10+'0');}\n}\ninline void wri(ll x){wr(x);pc(' ');}\ninline void wrn(ll x){wr(x);put;}\ninline void wrn(ll x,ll y){wri(x);wrn(y);}\ninline void wrn(ll x,ll y,ll z){wri(x);wrn(y,z);}\nint ans,n,m,f[N][2],fa[N],dis[N],lo,rt,mx;\ninline void ad(int &x,int k){x+=k;x-=(x>=mo)?mo:0;}\nint Next[N*2],head[N],to[N*2],nedge,g[N][4];\n#define V to[i]\nvoid add(int a,int b){Next[++nedge]=head[a];head[a]=nedge;to[nedge]=b;}\nvoid add_ne(int a,int b){add(a,b);add(b,a);}\nvoid dfs(int x){\n\tmx=(dis[x]>dis[mx])?x:mx;\n\tgo(i,x){\n\t\tif (V==fa[x]) continue;\n\t\tfa[V]=x;dis[V]=dis[x]+1;dfs(V);\n\t}\n}\nint ksm(ll x,int k){\n\tint su=1;\n\tfor (;k;k>>=1,x=x*x%mo) if (k&1) su=su*x%mo;\n\treturn su;\n}\nvoid solve(int x){\n\tint pd=0;\n\tf[x][0]=1;\n\tg[x][0]=1;\n\tgo(i,x){\n\t\tif (V==fa[x]) continue;\n\t\tsolve(V);pd++;\n\t\tg[x][3]=1ll*g[x][3]*g[V][0]%mo;\n\t\tad(g[x][3],1ll*g[x][1]*g[V][2]%mo);\n\t\tad(g[x][3],1ll*g[x][2]*g[V][1]%mo);\n\t\tg[x][1]=1ll*g[x][1]*g[V][0]%mo;\n\t\tg[x][2]=1ll*g[x][2]*g[V][0]%mo;\n\t\tad(g[x][1],1ll*g[x][0]*g[V][1]%mo);\n\t\tad(g[x][2],1ll*g[x][0]*g[V][2]%mo);\n\t\tg[x][0]=1ll*g[x][0]*g[V][0]%mo;\n\t\t\n\t\tf[x][1]=1ll*f[x][1]*f[V][0]%mo;\n\t\tad(f[x][1],1ll*f[x][0]*f[V][1]%mo);\n\t\tf[x][0]=1ll*f[x][0]*f[V][0]%mo;\n\t}\n\tif (pd){\n\t\tf[x][0]=1ll*f[x][0]*3%mo;\n\t\tad(f[x][0],f[x][1]*2%mo);\n\t\tg[x][0]=1ll*g[x][0]*3%mo;\n\t\tad(g[x][0],((g[x][1]+g[x][2])%mo*2%mo+g[x][3])%mo);\n\t\tad(g[x][1],g[x][3]);ad(g[x][2],g[x][3]);\n\t}\n\telse{\n\t\tif (dis[x]==lo/2) f[x][1]=1,f[x][0]=2,g[x][1]=g[x][0]=g[x][2]=1;\n\t\telse f[x][0]=3,g[x][0]=3;\n\t}\n}\nsigned main(){\n\tn=read();\n\tR(i,1,n) add_ne(read(),read());\n\tdfs(1);\n\trt=mx;mx=0;dis[rt]=0;fa[rt]=0;\n\tdfs(rt);\n\tlo=dis[mx];\n\tF(i,1,lo/2) mx=fa[mx];\n\tif (lo&1){\n\t\tint x=mx,y=fa[mx];\n\t\tfa[y]=x;dis[x]=dis[y]=0;dfs(x);dfs(y);\n\t\tsolve(x);solve(y);\n\t\twrn(1ll*f[x][1]*f[y][1]%mo);\n\t\t//wrn(ksm(3,n-lo-1));\n\t}\n\telse{\n\t\tint x=mx,nu=0;\n\t\tfa[x]=0;dis[x]=0;dfs(x);\n\t\tF(i,1,n) if (dis[i]==lo/2) nu++;\n\t\t//ans=(1ll*nu*(nu-1)/2)%mo*ksm(3,n-lo-1)%mo;\n\t\tsolve(x);\n\t\tf[x][0]=1;f[x][1]=0;\n\t\tgo(i,x){\n\t\t\tans=1ll*ans*g[V][0]%mo;\n\t\t\tad(ans,1ll*f[x][1]*f[V][1]%mo);\n\t\t\tf[x][1]=1ll*f[x][1]*g[V][0]%mo;\n\t\t\tad(f[x][1],1ll*f[x][0]*f[V][1]%mo);\n\t\t\tf[x][0]=1ll*f[x][0]*g[V][0]%mo;\t\t\t\n\t\t}\n\t\twrn(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst int M=998244353;\nconst int inv2=(M+1)/2;\nconst int maxn=3e5+3;\nvector <int> h[maxn];\nint dis[maxn],n,pre[maxn],p,q,d[maxn],m;\nll dp[maxn][2];\nvoid dfs(int u,int fa){\n    pre[u]=fa; dis[u]=dis[fa]+1;\n    for (auto v:h[u]){\n        if (v==fa) continue;\n        dfs(v,u);\n    }\n}\nvoid dfs2(int u,int fa){\n    d[u]=d[fa]+1;\n    if (d[u]==m){\n        dp[u][0]=2;\n        dp[u][1]=1;\n        return;\n    }\n    ll r1=1,r2=0;\n    for (auto v:h[u]){\n        if (v==fa) continue;\n        dfs2(v,u);\n        ll nr1=r1*dp[v][0]%M;\n        ll nr2=(r1*dp[v][1]+r2*dp[v][0])%M;\n        r1=nr1; r2=nr2;\n    }\n    dp[u][0]=r1*3%M;\n    dp[u][1]=r2;\n}\nint main(){\n    scanf(\"%d\",&n); dis[0]=-1;\n    for (int i=1;i<n;i++){\n        int u,v; scanf(\"%d%d\",&u,&v);\n        h[u].pb(v); h[v].pb(u);\n    }\n    //puts(\"B\");\n    dfs(1,0);\n    int s=1;\n    for (int i=2;i<=n;i++) if (dis[i]>dis[s]) s=i;\n    dfs(s,0);\n    int t=s;\n    for (int i=1;i<=n;i++) if (dis[i]>dis[t]) t=i;\n    m=dis[t]/2; p=t;\n    for (int i=0;i<m;i++) p=pre[p];\n    if (dis[t]&1){\n        q=pre[p];\n        d[q]=-1; dfs2(p,q);\n        d[p]=-1; dfs2(q,p);\n        printf(\"%lld\\n\",dp[p][1]*dp[q][1]%M);\n    } else {\n        ll ans0=1,ans1=0,ans2=0;\n        for (auto u:h[p]){\n            d[u]=0; dfs2(u,p);\n            ll nans0,nans1,nans2;\n            nans0=ans0*dp[u][0]%M;\n            nans1=(ans0*dp[u][1]+ans1*dp[u][0])%M;\n            nans2=(ans1*dp[u][1]+ans2*dp[u][0])%M;\n            ans0=nans0; ans1=nans1; ans2=nans2;\n        }\n        printf(\"%lld\\n\",ans2);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <bits/stdc++.h>\n#include <random>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define sz(x) ((int)(x).size())\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef double db;\nmt19937 mrand(random_device{}());\nconst ll mod = 998244353;\nint rnd(int x) { return mrand() % x; }\nll powmod(ll a, ll b) { ll res = 1; a %= mod; assert(b >= 0); for (; b; b >>= 1) { if (b & 1)res = res * a%mod; a = a * a%mod; }return res; }\nll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\n// head\n\n#define LL long long\n\nconst int MAXN = 200005;\nvoid ad(int &x, int y) { x += y; if (x >= mod)x -= mod; }\nvector<int> nxt[MAXN];\nvoid ins(int x, int y) { nxt[x].emplace_back(y); }\nint dis[MAXN], sta[MAXN], tp, n;\nvoid dfs(int x, int fa) { for (auto y : nxt[x])if (y^fa)dis[y] = dis[x] + 1, dfs(y, x); }\nbool getpath(int x, int fa, int ed)\n{\n\tif (x == ed) { sta[++tp] = x; return true; }\n\tfor (auto y : nxt[x])if ((y^fa) && getpath(y, x, ed)) { sta[++tp] = x; return true; }\n\treturn false;\n}\nint f[MAXN][3]; //f[x][0]以x为根的子树不包含直径的可能数; \n\t\t\t\t//f[x][1]以x为根的子树包含恰好一条直径的可能数\n\t\t\t\t//f[x][2]以x为根的子树包含2个及以上直径的可能数\nint trans[3]; \nbool tag[MAXN];\n\nvoid dp(int x, int fa)\n{\n\t//leaf\n\tif (sz(nxt[x]) == 1) {\n\t\tif (tag[x]) f[x][1] = 1, f[x][0] = 2;\n\t\telse f[x][0] = 3;\n\t\treturn;\n\t}\n\tf[x][0] = 1;\n\tfor (auto y : nxt[x])if (y^fa)dp(y, x);\n\tfor (auto y : nxt[x])\n\t\tif (y^fa) {\n\t\t\tmemset(trans, 0, sizeof(trans));\n\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t\t\tif (f[x][i] && f[y][j])\n\t\t\t\t\t\tad(trans[min(2, i + j)], 1LL * f[x][i] * f[y][j] % mod);//+1\n\t\t\tfor (int i = 0; i < 3; i++)\tf[x][i] = trans[i];\n\t\t}\n\tf[x][0] = (3LL * f[x][0] + 2LL * (f[x][1] + f[x][2])) % mod;\n}\n\nint ans[3];\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//\tfreopen(\"a.in\",\"r\",stdin);\n\t//\tfreopen(\"a.out\",\"w\",stdout);\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tins(x, y); ins(y, x);\n\t}\n\tdfs(1, 0); \n\tint p = 0, q = 0; \n\tfor (int i = 1; i <= n; i++)if (dis[i] > dis[p])p = i;\n\tdis[p] = 0; \n\tdfs(p, 0); \n\tfor (int i = 1; i <= n; i++)if (dis[i] > dis[q])q = i;\n\tgetpath(p, 0, q);\n\tif (tp & 1) {\n\t\tint u = sta[tp / 2 + 1]; dis[u] = 0; dfs(u, 0);\n\t\tfor (int i = 1; i <= n; i++)if (dis[i] == tp / 2)tag[i] = 1;\n\t\tans[0] = 1;\n\t\tfor (auto y : nxt[u]) {\n\t\t\tdp(y, u); \n\t\t\tint x0 = (f[y][0] - 2*(f[y][1] + f[y][2]) % mod + mod) % mod, x1 = f[y][1];\n\t\t\t//int x0 = f[y][0], x1 = f[y][1];\n\t\t\tans[2] = (1LL * ans[2] * x0 + 1LL * ans[1] * x1) % mod;\n\t\t\tans[1] = (1LL * ans[1] * x0 + 1LL * ans[0] * x1) % mod;\n\t\t\tans[0] = 1LL * ans[0] * x0 % mod;\n\t\t}\n\t\tcout << ans[2] << endl;\n\t}\n\telse {\n\t\tint u = sta[tp / 2], v = sta[tp / 2 + 1]; dis[u] = dis[v] = 0; dfs(u, v); dfs(v, u);\n\t\tfor (int i = 1; i <= n; i++)if (dis[i] == (tp - 1) / 2)tag[i] = 1;\n\t\tdp(u, v); dp(v, u); \n\t\tcout << (1LL * f[u][1] * f[v][1] % mod) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst int M=998244353;\nconst int inv2=(M+1)/2;\nconst int inv3=(M+1)/3;\nconst int maxn=3e5+3;\nvector <int> h[maxn];\nint dis[maxn],n,pre[maxn],p,q,d[maxn],m;\nll dp[maxn][4];\nvoid dfs(int u,int fa){\n    pre[u]=fa; dis[u]=dis[fa]+1;\n    for (auto v:h[u]){\n        if (v==fa) continue;\n        dfs(v,u);\n    }\n}\nvoid dfs2(int u,int fa){\n    d[u]=d[fa]+1;\n    if (d[u]==m){\n        dp[u][0]=2; // none\n        dp[u][1]=1; // exactly one\n        dp[u][2]=3; // all\n        dp[u][3]=1; // at least one\n        return;\n    }\n    ll r1=1,r2=0,r3=1,r4=0;\n    for (auto v:h[u]){\n        if (v==fa) continue;\n        dfs2(v,u);\n        ll nr1=r1*dp[v][0]%M;\n        ll nr2=(r1*dp[v][1]+r2*dp[v][0])%M;\n        ll nr3=r3*dp[v][2]%M;\n        ll nr4=((r3*dp[v][3]+r4*dp[v][2]-r4*dp[v][3])%M+M)%M;\n        r1=nr1; r2=nr2; r3=nr3; r4=nr4;\n    }\n    dp[u][0]=(r1*3+r4*2)%M;\n    dp[u][1]=r2;\n    dp[u][2]=r3*3%M;\n    dp[u][3]=r4;\n}\nint main(){\n    scanf(\"%d\",&n); dis[0]=-1;\n    for (int i=1;i<n;i++){\n        int u,v; scanf(\"%d%d\",&u,&v);\n        h[u].pb(v); h[v].pb(u);\n    }\n    //puts(\"B\");\n    dfs(1,0);\n    int s=1;\n    for (int i=2;i<=n;i++) if (dis[i]>dis[s]) s=i;\n    dfs(s,0);\n    int t=s;\n    for (int i=1;i<=n;i++) if (dis[i]>dis[t]) t=i;\n    m=dis[t]/2; p=t;\n    for (int i=0;i<m;i++) p=pre[p];\n    if (dis[t]&1){\n        q=pre[p];\n        d[q]=-1; dfs2(p,q);\n        d[p]=-1; dfs2(q,p);\n        printf(\"%lld\\n\",dp[p][1]*dp[q][1]%M);\n    } else {\n        ll ans0=1,ans1=0,ans2=0;\n        for (auto u:h[p]){\n            d[u]=0; dfs2(u,p);\n            ll nans0,nans1,nans2,has,none;\n            has=dp[u][1]; none=(dp[u][2]+2*(M-dp[u][3]))%M;\n            //cout<<has<<' '<<none<<endl;\n            //cout<<dp[u][2]<<' '<<dp[u][3]<<endl;\n            nans0=ans0*none%M;\n            nans1=(ans0*has+ans1*none)%M;\n            nans2=(ans1*has+ans2*none)%M;\n            ans0=nans0; ans1=nans1; ans2=nans2;\n        }\n        printf(\"%lld\\n\",ans2);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#define ll long long\n#define mod 998244353\n#define maxn 200010\ninline ll read()\n{\n\tll x=0; char c=getchar(),f=1;\n\tfor(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n\tfor(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\ninline void write(ll x)\n{\n\tstatic int buf[20],len; len=0;\n\tif(x<0)x=-x,putchar('-');\n\tfor(;x;x/=10)buf[len++]=x%10;\n\tif(!len)putchar('0');\n\telse while(len)putchar(buf[--len]+'0');\n}\ninline void writeln(ll x){write(x); putchar('\\n');}\ninline void writesp(ll x){write(x); putchar(' ');}\nstruct edge{\n\tint to,nxt;\n}e[2*maxn];\nint fir[maxn],dist1[maxn],dist2[maxn],dep[maxn],size[maxn];\nll f[maxn],g[maxn];\nint n,tot;\nll power(ll a,ll b)\n{\n\tll ans=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)ans=ans*a%mod;\n\treturn ans;\n}\nvoid add_edge(int x,int y){e[tot].to=y; e[tot].nxt=fir[x]; fir[x]=tot++;}\nvoid dfs(int now,int fa,int* dep)\n{\n\tfor(int i=fir[now];~i;i=e[i].nxt)\n\t\tif(e[i].to!=fa){\n\t\t\tdep[e[i].to]=dep[now]+1;\n\t\t\tdfs(e[i].to,now,dep);\n\t\t}\n}\nvoid dp(int now,int fa)\n{\n\tdep[now]=0; size[now]=1;\n\tint cnt=0;\n\tfor(int i=fir[now];~i;i=e[i].nxt)\n\t\tif(e[i].to!=fa){\n\t\t\t++cnt;\n\t\t\tdp(e[i].to,now);\n\t\t\tdep[now]=std::max(dep[now],dep[e[i].to]+1);\n\t\t\tsize[now]+=size[e[i].to];\n\t\t}\n\tif(!cnt){\n\t\tf[now]=1; g[now]=2;\n\t\treturn;\n\t}\n\tll t=1;\n\tfor(int i=fir[now];~i;i=e[i].nxt)\n\t\tif(e[i].to!=fa){\n\t\t\tif(dep[now]==dep[e[i].to]+1)t=t*g[e[i].to]%mod;\n\t\t\telse t=t*(f[e[i].to]+g[e[i].to])%mod;\n\t\t}\n\tf[now]=0;\n\tfor(int i=fir[now];~i;i=e[i].nxt)\n\t\tif(e[i].to!=fa){\n\t\t\tif(dep[now]==dep[e[i].to]+1)f[now]=(f[now]+t*power(g[e[i].to],mod-2)%mod*f[e[i].to]);\n\t\t}\n\tg[now]=(power(3,size[now])-f[now]+mod)%mod;\n}\nint main()\n{\n\tn=read();\n\tmemset(fir,255,sizeof(fir)); tot=0;\n\tfor(int i=1;i<n;i++){\n\t\tint x=read(),y=read();\n\t\tadd_edge(x,y); add_edge(y,x);\n\t}\n\tdist1[1]=0;\n\tdfs(1,-1,dist1);\n\tint S=1;\n\tfor(int i=2;i<=n;i++)\n\t\tif(dist1[i]>dist1[S])S=i;\n\tdist1[S]=0;\n\tdfs(S,-1,dist1);\n\tint T=1;\n\tfor(int i=2;i<=n;i++)\n\t\tif(dist1[i]>dist1[T])T=i;\n\tdist2[T]=0;\n\tdfs(T,-1,dist2);\n\tint L=dist1[T];\n\tif(L&1){\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=fir[i];~j;j=e[j].nxt)\n\t\t\t\tif(dist1[i]==L/2&&dist2[e[j].to]==L/2){\n\t\t\t\t\tdp(i,e[j].to); dp(e[j].to,i);\n\t\t\t\t\twriteln(f[i]*f[e[j].to]%mod);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t}\n\telse{\n\t\tint C=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(dist1[i]==L/2&&dist2[i]==L/2){\n\t\t\t\tC=i; break;\n\t\t\t}\n\t\t// writeln(C);\n\t\tdp(C,-1);\n\t\tll t=1,sum1=0,sum2=0;\n\t\tfor(int i=fir[C];~i;i=e[i].nxt)\n\t\t\tif(dep[e[i].to]+1==L/2){\n\t\t\t\tt=t*g[e[i].to]%mod;\n\t\t\t\tll cur=power(g[e[i].to],mod-2)*f[e[i].to]%mod;\n\t\t\t\tsum1=(sum1+cur)%mod;\n\t\t\t\tsum2=(sum2+cur*cur)%mod;\n\t\t\t}\n\t\t\telse t=t*(f[e[i].to]+g[e[i].to])%mod;\n\t\twriteln(t*((sum1*sum1-sum2+mod)%mod*((mod+1)/2)%mod)%mod);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.rbegin(),a.rend()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ntypedef vector<T> vt;\ninline int getInt() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\nconst int MX = 200005;\n\n// Mod int\nconst int mod = 998244353;\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  // mint(ll x):x(x){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint operator~() const { return mint(1) / *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=a.pow(mod-2).x)%=mod; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  mint pow(ll t) const {\n    if(!t) return 1;\n    mint res = pow(t/2);\n    res *= res;\n    return (t&1)?res*x:res;\n  }\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nmint ex(mint x, ll t) { return x.pow(t);}\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\ntypedef vector<mint> vm;\nstruct comb {\n  vm f, g;\n  comb(){}\n  comb(int mx):f(mx+1),g(mx+1) {\n    f[0] = 1;\n    rrep(i,mx) f[i] = f[i-1]*i;\n    g[mx] = f[mx].pow(mod-2);\n    for(int i=mx;i>0;i--) g[i-1] = g[i]*i;\n  }\n  mint operator()(int a, int b) {\n    if (a < b) return 0;\n    return f[a]*g[b]*g[a-b];\n  }\n};\n//\n\n\nvi to[MX];\n\nvi vs;\nP rfs(int v, int p=-1) {\n  P res(0,v);\n  for (int u : to[v]) {\n    if (u == p) continue;\n    maxs(res, rfs(u,v));\n  }\n  res.fi++;\n  return res;\n}\nbool pfs(int v, int tv, int p=-1) {\n  if (v == tv) {\n    vs.pb(v);\n    return true;\n  }\n  for (int u : to[v]) {\n    if (u == p) continue;\n    if (pfs(u, tv, v)) {\n      vs.pb(v);\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid nxt(vm& d) {\n  d[0] *= 3;\n  d[0] += d[1]*2;\n  d[0] += d[2]*2;\n}\n\nvm dfs(int v, int l, int p=-1) {\n  vm dp(3);\n  dp[!l] = 1;\n  for (int u : to[v]) {\n    if (u == p) continue;\n    vm d = dfs(u,l-1,v);\n    nxt(d);\n    vm p(3);\n    swap(dp,p);\n    rep(i,3)rep(j,3) {\n      int ni = min(2, i+j);\n      dp[ni] += d[i]*p[j];\n    }\n  }\n  return dp;\n}\n\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  rep(i,n-1) {\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    --a; --b;\n    to[a].pb(b);\n    to[b].pb(a);\n  }\n  int sv = rfs(0).se;\n  int tv = rfs(sv).se;\n  pfs(sv,tv);\n  int l = sz(vs);\n  mint ans;\n  if (l%2) {\n    int c = vs[l/2];\n    vm dp(3,1);\n    for (int u : to[c]) {\n      vm d = dfs(u, l/2-1, c);\n      nxt(d);\n      dp[0] *= d[0]+d[1];\n      dp[1] *= d[0];\n      dp[2] *= d[0]-d[1];\n    }\n    ans = dp[0]-dp[1]*2+dp[2];\n    ans /= 2;\n  } else {\n    vm dp(4, 1);\n    int s = vs[l/2-1], t = vs[l/2];\n    rep(_,2) {\n      vm d = dfs(s,l/2-1,t);\n      d[1] += d[0];\n      swap(s,t);\n      rep(i,4) {\n        int ni = i>>_&1;\n        dp[i] *= d[ni];\n      }\n    }\n    ans = dp[3]-dp[1]-dp[2]+dp[0];\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#define ll long long\n#define mod 998244353\n#define maxn 200010\ninline ll read()\n{\n\tll x=0; char c=getchar(),f=1;\n\tfor(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n\tfor(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\ninline void write(ll x)\n{\n\tstatic int buf[20],len; len=0;\n\tif(x<0)x=-x,putchar('-');\n\tfor(;x;x/=10)buf[len++]=x%10;\n\tif(!len)putchar('0');\n\telse while(len)putchar(buf[--len]+'0');\n}\ninline void writeln(ll x){write(x); putchar('\\n');}\ninline void writesp(ll x){write(x); putchar(' ');}\nstruct edge{\n\tint to,nxt;\n}e[2*maxn];\nint fir[maxn],dist1[maxn],dist2[maxn],dep[maxn],size[maxn];\nll f[maxn],g[maxn];\nint n,tot;\nll power(ll a,ll b)\n{\n\tll ans=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)ans=ans*a%mod;\n\treturn ans;\n}\nvoid add_edge(int x,int y){e[tot].to=y; e[tot].nxt=fir[x]; fir[x]=tot++;}\nvoid dfs(int now,int fa,int* dep)\n{\n\tfor(int i=fir[now];~i;i=e[i].nxt)\n\t\tif(e[i].to!=fa){\n\t\t\tdep[e[i].to]=dep[now]+1;\n\t\t\tdfs(e[i].to,now,dep);\n\t\t}\n}\nvoid dp(int now,int fa)\n{\n\tdep[now]=0; size[now]=1;\n\tint cnt=0;\n\tfor(int i=fir[now];~i;i=e[i].nxt)\n\t\tif(e[i].to!=fa){\n\t\t\t++cnt;\n\t\t\tdp(e[i].to,now);\n\t\t\tdep[now]=std::max(dep[now],dep[e[i].to]+1);\n\t\t\tsize[now]+=size[e[i].to];\n\t\t}\n\tif(!cnt){\n\t\tf[now]=1; g[now]=2;\n\t\treturn;\n\t}\n\tll t=1;\n\tfor(int i=fir[now];~i;i=e[i].nxt)\n\t\tif(e[i].to!=fa){\n\t\t\tif(dep[now]==dep[e[i].to]+1)t=t*g[e[i].to]%mod;\n\t\t\telse t=t*(f[e[i].to]+g[e[i].to])%mod;\n\t\t}\n\tf[now]=0;\n\tfor(int i=fir[now];~i;i=e[i].nxt)\n\t\tif(e[i].to!=fa){\n\t\t\tif(dep[now]==dep[e[i].to]+1)f[now]=(f[now]+t*power(g[e[i].to],mod-2)%mod*f[e[i].to])%mod;\n\t\t}\n\tg[now]=(power(3,size[now])-f[now]+mod)%mod;\n}\nint main()\n{\n\tn=read();\n\tmemset(fir,255,sizeof(fir)); tot=0;\n\tfor(int i=1;i<n;i++){\n\t\tint x=read(),y=read();\n\t\tadd_edge(x,y); add_edge(y,x);\n\t}\n\tdist1[1]=0;\n\tdfs(1,-1,dist1);\n\tint S=1;\n\tfor(int i=2;i<=n;i++)\n\t\tif(dist1[i]>dist1[S])S=i;\n\tdist1[S]=0;\n\tdfs(S,-1,dist1);\n\tint T=1;\n\tfor(int i=2;i<=n;i++)\n\t\tif(dist1[i]>dist1[T])T=i;\n\tdist2[T]=0;\n\tdfs(T,-1,dist2);\n\tint L=dist1[T];\n\tif(L&1){\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=fir[i];~j;j=e[j].nxt)\n\t\t\t\tif(dist1[i]==L/2&&dist2[e[j].to]==L/2){\n\t\t\t\t\tdp(i,e[j].to); dp(e[j].to,i);\n\t\t\t\t\twriteln(f[i]*f[e[j].to]%mod);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t}\n\telse{\n\t\tint C=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(dist1[i]==L/2&&dist2[i]==L/2){\n\t\t\t\tC=i; break;\n\t\t\t}\n\t\t// writeln(C);\n\t\tdp(C,-1);\n\t\tll t=1,sum1=0,sum2=0;\n\t\tfor(int i=fir[C];~i;i=e[i].nxt)\n\t\t\tif(dep[e[i].to]+1==L/2){\n\t\t\t\tt=t*g[e[i].to]%mod;\n\t\t\t\tll cur=power(g[e[i].to],mod-2)*f[e[i].to]%mod;\n\t\t\t\tsum1=(sum1+cur)%mod;\n\t\t\t\tsum2=(sum2+cur*cur)%mod;\n\t\t\t}\n\t\t\telse t=t*(f[e[i].to]+g[e[i].to])%mod;\n\t\twriteln(t*((sum1*sum1-sum2+mod)%mod*((mod+1)/2)%mod)%mod);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e5 + 5, mod = 998244353;\n\nvector<int> g[N];\nint par[N], lv[N];\nlong long dp[N][3], tmp[3];\n\nvoid add(long long & var, long long val) {\n  var += val;\n  if (var >= mod)\n    var -= mod;\n}\n\nvoid dfs(int v, int p) {\n  par[v] = p;\n  for (int u : g[v]) {\n    if (u == p) continue;\n    lv[u] = lv[v] + 1;\n    dfs(u, v);\n  }\n}\n\nvoid solve(int v, int p, int depth) {\n  memset(dp[v], 0, sizeof dp[v]);\n  dp[v][(depth == 0)] = 1;\n  --depth;\n  for (int u : g[v]) {\n    if (u == p) continue;\n    solve(u, v, depth);\n    memset(tmp, 0, sizeof tmp);\n    for (int i = 0; i < 3; ++i) {\n      for (int j = 0; j < 3; ++j) {\n        add(tmp[min(i+j, 2)], dp[v][i] * dp[u][j] % mod);\n        add(tmp[i], 2LL * dp[v][i] * dp[u][j] % mod);\n      }\n    }\n    for (int i = 0; i < 3; ++i)\n      dp[v][i] = tmp[i];\n  }\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i < n; ++i) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    --u, --v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  lv[0] = 0;\n  dfs(0, 0);\n  int root = 0;\n  for (int i = 0; i < n; ++i) {\n    if (lv[i] > lv[root])\n      root = i;\n  }\n  lv[root] = 0;\n  dfs(root, -1);\n  int leaf = 0;\n  for (int i = 0; i < n; ++i) {\n    if (lv[i] > lv[leaf])\n      leaf = i;\n  }\n  int diam = lv[leaf];\n  long long ans = 0;\n  if (diam & 1) {\n    int a = leaf;\n    for (int i = 0; i < diam/2; ++i) {\n      a = par[a];\n    }\n    int b = par[a];\n    solve(a, b, diam/2);\n    solve(b, a, diam/2);\n    ans = 1LL * dp[a][1] * dp[b][1] % mod;\n  }\n  else {\n    assert(false);\n    int c = leaf;\n    for (int i = 0; i < diam/2; ++i) {\n      c = par[c];\n    }\n    long long best[3];\n    memset(best, 0, sizeof best);\n    best[0] = 1;\n    for (int u : g[c]) {\n      solve(u, c, diam/2-1);\n      memset(tmp, 0, sizeof tmp);\n      dp[u][0] = (dp[u][0] - dp[u][1] - dp[u][2]) % mod;\n      dp[u][0] = (3LL * dp[u][0] + dp[u][1] + dp[u][2]) % mod;\n      cerr << u << \" \" << dp[u][0] << \" \" << dp[u][1] << endl;\n      tmp[0] = (best[0] * dp[u][0]) % mod;\n      tmp[1] = (best[0] * dp[u][1] + best[1] * dp[u][0]) % mod;\n      tmp[2] = (best[1] * dp[u][1] + best[2] * dp[u][0]) % mod;\n      for (int i = 0; i < 3; ++i)\n        best[i] = tmp[i];\n    }\n    ans = best[2];\n  }\n  ans %= mod;\n  if (ans < 0)\n    ans += mod;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[202020];\nconst ll mo=998244353;\nll dp[202020][3][3];\n\npair<int,int> farthest(int cur,int pre,int d,vector<int>& D) {\n\tD[cur]=d;\n\tpair<int,int> r={d,cur};\n\tFORR(e,E[cur]) if(e!=pre) r=max(r, farthest(e,cur,d+1,D));\n\treturn r;\n}\n\npair<int,vector<int>> diameter() { // diameter,center\n\tvector<int> D[2];\n\tD[0].resize(N);\n\tD[1].resize(N);\n\tauto v1=farthest(0,0,0,D[0]);\n\tauto v2=farthest(v1.second,v1.second,0,D[0]);\n\tfarthest(v2.second,v2.second,0,D[1]);\n\tpair<int,vector<int>> R;\n\tR.first = v2.first;\n\t//重心を取る場合\n\tfor(int i=N-1;i>=0;i--) if(D[0][i]+D[1][i]==R.first && abs(D[0][i]-D[1][i])<=1) R.second.push_back(i);\n\n\treturn R;\n}\n\nvoid dfs(int cur,int pre,int lef) {\n\tif(lef==0) {\n\t\tdp[cur][1][1]=1;\n\t}\n\telse {\n\t\tdp[cur][0][0]=1;\n\t}\n\t\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\tdfs(e,cur,lef-1);\n\t\tll to[3][3]={};\n\t\tint a1,a2,b1,b2;\n\t\tFOR(a1,3) FOR(a2,3) FOR(b1,3) FOR(b2,3) {\n\t\t\t// +1\n\t\t\tto[min(a1+b1,2)][a2]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t\t// 0\n\t\t\tto[a1][a2]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t\t// -1\n\t\t\tto[a1][min(a2+b2,2)]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t}\n\t\t\n\t\tFOR(a1,3) FOR(a2,3) dp[cur][a1][a2]=to[a1][a2]%mo;\n\t}\n\t\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tauto R=diameter();\n\tif(R.second.size()==1) {\n\t\tx=R.second[0];\n\t\tdfs(x,-1,R.first/2);\n\t\tcout<<dp[x][1][1]*((mo+1)/2)%mo<<endl;\n\t}\n\telse {\n\t\tx=R.second[0];\n\t\ty=R.second[1];\n\t\tdfs(x,y,R.first/2);\n\t\tdfs(y,x,R.first/2);\n\t\tll X=(dp[x][0][1]+dp[x][1][1]+dp[x][2][1])%mo;\n\t\tll Y=(dp[y][0][1]+dp[y][1][1]+dp[y][2][1])%mo;\n\t\tcout<<X*Y%mo<<endl;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=998244353;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=401000;\nll dp[N][5][5],tmp[5][5],tmp2[5][5];\nint pt[N],md,mv,n,u,v,lef[N];\nPII cen;\nVI e[N];\n\nvoid dfs(int u,int f,int dep) {\n\tpt[dep]=u;\n\tif (dep>md) {\n\t\tmd=dep; mv=u; cen=mp(pt[dep/2],pt[(dep+1)/2]);\n\t}\n\tfor (auto v:e[u]) {\n\t\tif (v==f) continue;\n\t\tdfs(v,u,dep+1);\n\t}\n}\nvoid gao(int u,int f,int d) {\n\tif (d==md/2) {\n\t\t//printf(\"gg %d %d\\n\",u,md);\n\t\tlef[u]=1;\n\t\treturn;\n\t}\n\tdp[u][0][0]=1;\n\tfor (auto v:e[u]) {\n\t\tif (v==f) continue;\n\t\tgao(v,u,d+1);\n\t\trep(L,0,3) rep(R,0,3) tmp[L][R]=tmp2[L][R]=0;\n\t\tif (lef[v]) {\n\t\t\ttmp[1][0]=1;\n\t\t\ttmp[0][1]=1;\n\t\t\ttmp[0][0]=1;\n\t\t} else {\n\t\t\trep(L,0,3) rep(R,0,3) {\n\t\t\t\ttmp[L][0]=(tmp[L][0]+dp[v][L][R])%mod;\n\t\t\t\ttmp[0][R]=(tmp[0][R]+dp[v][L][R])%mod;\n\t\t\t\ttmp[0][0]=(tmp[0][0]+dp[v][L][R])%mod;\n\t\t\t}\n\t\t}\n\t\trep(L,0,3) rep(R,0,3) rep(fL,0,3) rep(fR,0,3)\n\t\t\ttmp2[min(L+fL,2)][min(R+fR,2)]=(tmp2[min(L+fL,2)][min(R+fR,2)]+dp[u][L][R]*tmp[fL][fR])%mod;\n\t\trep(L,0,3) rep(R,0,3) dp[u][L][R]=tmp2[L][R];\n\t}\n\t//rep(i,0,4) printf(\"gg %d %d %lld\\n\",u,i,dp[u][i]);\n}\n\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,1,n) {\n\t\tscanf(\"%d%d\",&u,&v);\n\t\te[u].pb(v);\n\t\te[v].pb(u);\n\t}\n\tmd=-1;\n\tdfs(1,0,0);\n\tmd=-1;\n\tdfs(mv,0,0);\n\tif (cen.fi==cen.se) {\n\t\tgao(cen.fi,0,0);\n\t\tprintf(\"%lld\\n\",dp[cen.fi][1][1]*powmod(2,mod-2)%mod);\n\t} else {\n\t\t//puts(\"dup center\");\n\t\tgao(cen.fi,cen.se,0);\n\t\tgao(cen.se,cen.fi,0);\n\t\trep(L,0,3) rep(R,0,3) tmp[L][R]=tmp2[L][R]=0;\n\t\trep(L,0,3) rep(R,0,3) {\n\t\t\ttmp[L][0]=(tmp[L][0]+dp[cen.fi][L][R])%mod;\n\t\t\ttmp2[0][R]=(tmp2[0][R]+dp[cen.se][L][R])%mod;\n\t\t}\n\t\tprintf(\"%lld\\n\",dp[cen.fi][1][0]*dp[cen.se][0][1]%mod);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[202020];\nconst ll mo=998244353;\nll dp[202020][3][3];\n\npair<int,int> farthest(int cur,int pre,int d,vector<int>& D) {\n\tD[cur]=d;\n\tpair<int,int> r={d,cur};\n\tFORR(e,E[cur]) if(e!=pre) r=max(r, farthest(e,cur,d+1,D));\n\treturn r;\n}\n\npair<int,vector<int>> diameter() { // diameter,center\n\tvector<int> D[2];\n\tD[0].resize(N);\n\tD[1].resize(N);\n\tauto v1=farthest(0,0,0,D[0]);\n\tauto v2=farthest(v1.second,v1.second,0,D[0]);\n\tfarthest(v2.second,v2.second,0,D[1]);\n\tpair<int,vector<int>> R;\n\tR.first = v2.first;\n\t//重心を取る場合\n\tfor(int i=N-1;i>=0;i--) if(D[0][i]+D[1][i]==R.first && abs(D[0][i]-D[1][i])<=1) R.second.push_back(i);\n\n\treturn R;\n}\n\nvoid dfs(int cur,int pre,int lef) {\n\tif(lef==0) {\n\t\tdp[cur][1][1]=1;\n\t}\n\telse {\n\t\tdp[cur][0][0]=1;\n\t}\n\t\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\tdfs(e,cur,lef-1);\n\t\tll to[3][3]={};\n\t\tint a1,a2,b1,b2;\n\t\tFOR(a1,3) FOR(a2,3) FOR(b1,3) FOR(b2,3) {\n\t\t\t// +1\n\t\t\tto[min(a1+b1,2)][a2]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t\t// 0\n\t\t\tto[a1][a2]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t\t// -1\n\t\t\tto[a1][min(a2+b2,2)]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t}\n\t\t\n\t\tFOR(a1,3) FOR(a2,3) dp[cur][a1][a2]=to[a1][a2]%mo;\n\t}\n\t\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tauto R=diameter();\n\tif(R.second.size()==1) {\n\t\tx=R.second[0];\n\t\tdfs(x,-1,R.first/2);\n\t\tcout<<dp[x][1][1]*((mo+1)/2)%mo<<endl;\n\t}\n\telse {\n\t\tx=R.second[0];\n\t\ty=R.second[1];\n\t\tdfs(x,y,R.first/2);\n\t\tdfs(y,x,R.first/2);\n\t\tll ret=(dp[x][0][1]+dp[x][1][1])*dp[y][1][0]%mo;\n\t\tret+=(dp[y][0][1]+dp[y][1][1])*dp[x][1][0]%mo;\n\t\tret+=(dp[x][1][1]+dp[y][1][1])*2%mo;\n\t\tcout<<ret%mo<<endl;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll mod = 998244353;\nvector<int>pat[202020];\nint dep[202020];\nbool flag[202020];\nint diam = 0;\nbool iscent[202020];\nvector<int>ko[202020];\nvoid dfs(int node, int d)\n{\n\tflag[node] = true;\n\tdep[node] = d;\n\tdiam = max(diam, d);\n\tfor (int i = 0; i < pat[node].size(); i++)if (!flag[pat[node][i]])dfs(pat[node][i], d + 1);\n}\nvoid dfs2(int node, int d)\n{\n\tflag[node] = true;\n\tdep[node] = d;\n\tfor (int i = 0; i < pat[node].size(); i++)\n\t{\n\t\tif (!flag[pat[node][i]] && !iscent[pat[node][i]])\n\t\t{\n\t\t\tdfs2(pat[node][i], d + 1);\n\t\t\tko[node].push_back(pat[node][i]);\n\t\t}\n\t}\n}\ntypedef pair<ll, ll>pii;\npii calc(int node)\n{\n\tif (ko[node].empty())\n\t{\n\t\tif (dep[node] == diam / 2)return make_pair(1, 2);\n\t\telse return make_pair(0, 3);\n\t}\n\tvector<pii>v;\n\tfor (int i = 0; i < ko[node].size(); i++)v.push_back(calc(ko[node][i]));\n\tvector<ll>r1, r2;\n\tr1.resize(v.size() + 1), r1[0] = 1;\n\tr2.resize(v.size() + 1), r2[v.size()] = 1;\n\tfor (int i = 0; i < v.size(); i++)r1[i + 1] = r1[i] * v[i].second%mod;\n\tfor (int i = v.size() - 1; i >= 0; i--)r2[i] = r2[i + 1] * v[i].second%mod;\n\tll t1 = 0, t2 = 1;\n\tfor (int i = 0; i < v.size(); i++)\n\t{\n\t\tt1 = (t1 + r1[i] * r2[i + 1] % mod*v[i].first) % mod;\n\t\tt2 = t2*v[i].second%mod;\n\t}\n\tt2 = (t2 + t1 + t2 + t1 + t2) % mod;\n\t//printf(\"%d %lld %lld\\n\", node + 1, t1, t2);\n\treturn make_pair(t1, t2);\n}\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < num - 1; i++)\n\t{\n\t\tint za, zb;\n\t\tscanf(\"%d%d\", &za, &zb);\n\t\tza--, zb--;\n\t\tpat[za].push_back(zb);\n\t\tpat[zb].push_back(za);\n\t}\n\tdfs(0, 0);\n\tint r = 0;\n\tfor (int i = 0; i < num; i++)if (dep[i] == diam)r = i;\n\tfill(flag, flag + num, false);\n\tdfs(r, 0);\n\tint now;\n\tfor (int i = 0; i < num; i++)if (dep[i] == diam)now = i;\n\tvector<int>path;\n\tfor (int i = 0; i < diam; i++)\n\t{\n\t\tpath.push_back(now);\n\t\tfor (int j = 0; j < pat[now].size(); j++)\n\t\t{\n\t\t\tif (dep[pat[now][j]] == dep[now] - 1)\n\t\t\t{\n\t\t\t\tnow = pat[now][j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpath.push_back(now);\n\n\t//for (int i = 0; i < path.size(); i++)printf(\"%d \", path[i] + 1); printf(\"\\n\");\n\n\n\tif (diam % 2 == 0)\n\t{\n\t\tint c = path[diam / 2];\n\t\tfill(flag, flag + num, false);\n\t\tiscent[c] = true;\n\t\tdfs2(c, 0);\n\t\tll d0 = 1, d1 = 0, d2 = 0, d3 = 0;\n\t\tfor (int i = 0; i < ko[c].size(); i++)\n\t\t{\n\t\t\tpii z = calc(ko[c][i]);\n\t\t\tll e0 = d0*(z.second - z.first);\n\t\t\tll e1 = d0*z.first + d1*(z.second - z.first);\n\t\t\tll e2 = d0*z.first + d2*(z.second - z.first);\n\t\t\tll e3 = d1*z.first + d2*z.first + d3*(z.second - z.first);\n\t\t\td0 = (e0%mod + mod) % mod;\n\t\t\td1 = (e1%mod + mod) % mod;\n\t\t\td2 = (e2%mod + mod) % mod;\n\t\t\td3 = (e3%mod + mod) % mod;\n\t\t}\n\t\tprintf(\"%lld\\n\", d3*(mod + 1) / 2 % mod);\n\t}\n\telse\n\t{\n\t\tint c1 = path[diam / 2], c2 = path[(diam + 1) / 2];\n\t\tfill(flag, flag + num, false);\n\t\tiscent[c1] = iscent[c2] = true;\n\t\tdfs2(c1, 0), dfs2(c2, 0);\n\n\t\tpii a = calc(path[diam / 2]), b = calc(path[(diam + 1) / 2]);\n\t\tprintf(\"%lld\\n\", a.first*b.first%mod);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll mod = 998244353;\nvector<int>pat[202020];\nint dep[202020];\nbool flag[202020];\nint diam = 0;\nbool iscent[202020];\nvector<int>ko[202020];\nvoid dfs(int node, int d)\n{\n\tflag[node] = true;\n\tdep[node] = d;\n\tdiam = max(diam, d);\n\tfor (int i = 0; i < pat[node].size(); i++)if (!flag[pat[node][i]])dfs(pat[node][i], d + 1);\n}\nvoid dfs2(int node, int d)\n{\n\tflag[node] = true;\n\tdep[node] = d;\n\tfor (int i = 0; i < pat[node].size(); i++)\n\t{\n\t\tif (!flag[pat[node][i]] && !iscent[pat[node][i]])\n\t\t{\n\t\t\tdfs2(pat[node][i], d + 1);\n\t\t\tko[node].push_back(pat[node][i]);\n\t\t}\n\t}\n}\ntypedef pair<ll, ll>pii;\nint siz[202020];\nint p3[202020];\npii calc(int node)\n{\n\tif (ko[node].empty())\n\t{\n\t\tsiz[node] = 1;\n\t\tif (dep[node] == diam / 2)return make_pair(1, 2);\n\t\telse return make_pair(0, 3);\n\t}\n\tvector<pii>v;\n\tsiz[node] = 1;\n\tfor (int i = 0; i < ko[node].size(); i++)v.push_back(calc(ko[node][i])), siz[node] += siz[ko[node][i]];\n\tvector<ll>r1, r2;\n\tr1.resize(v.size() + 1), r1[0] = 1;\n\tr2.resize(v.size() + 1), r2[v.size()] = 1;\n\tfor (int i = 0; i < v.size(); i++)r1[i + 1] = r1[i] * v[i].second%mod;\n\tfor (int i = v.size() - 1; i >= 0; i--)r2[i] = r2[i + 1] * v[i].second%mod;\n\tll t1 = 0, t2 = 1;\n\tfor (int i = 0; i < v.size(); i++)\n\t{\n\t\tt1 = (t1 + r1[i] * r2[i + 1] % mod*v[i].first) % mod;\n\t\tt2 = t2*v[i].second%mod;\n\t}\n\tt2 = (t2 + p3[siz[node] - 1] * 2) % mod;\n\tprintf(\"%d %d   %lld %lld\\n\", node + 1, siz[node], t1, t2);\n\treturn make_pair(t1, t2);\n}\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < num - 1; i++)\n\t{\n\t\tint za, zb;\n\t\tscanf(\"%d%d\", &za, &zb);\n\t\tza--, zb--;\n\t\tpat[za].push_back(zb);\n\t\tpat[zb].push_back(za);\n\t}\n\tdfs(0, 0);\n\tint r = 0;\n\tfor (int i = 0; i < num; i++)if (dep[i] == diam)r = i;\n\tfill(flag, flag + num, false);\n\tdfs(r, 0);\n\tint now;\n\tfor (int i = 0; i < num; i++)if (dep[i] == diam)now = i;\n\tvector<int>path;\n\tfor (int i = 0; i < diam; i++)\n\t{\n\t\tpath.push_back(now);\n\t\tfor (int j = 0; j < pat[now].size(); j++)\n\t\t{\n\t\t\tif (dep[pat[now][j]] == dep[now] - 1)\n\t\t\t{\n\t\t\t\tnow = pat[now][j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpath.push_back(now);\n\tp3[0] = 1;\n\tfor (int i = 0; i < num + 10; i++)p3[i + 1] = p3[i] * 3 % mod;\n\t//for (int i = 0; i < path.size(); i++)printf(\"%d \", path[i] + 1); printf(\"\\n\");\n\n\n\tif (diam % 2 == 0)\n\t{\n\t\tint c = path[diam / 2];\n\t\tfill(flag, flag + num, false);\n\t\tiscent[c] = true;\n\t\tdfs2(c, 0);\n\t\tll d0 = 1, d1 = 0, d2 = 0, d3 = 0;\n\t\tfor (int i = 0; i < ko[c].size(); i++)\n\t\t{\n\t\t\tpii z = calc(ko[c][i]);\n\t\t\tll x = z.second + z.second - p3[siz[ko[c][i]]];\n\t\t\tll e0 = d0*(z.second - z.first);\n\t\t\tll e1 = d0*z.first + d1*x;\n\t\t\tll e2 = d0*z.first + d2*x;\n\t\t\tll e3 = d1*z.first + d2*z.first + d3*x;\n\t\t\td0 = (e0%mod + mod) % mod;\n\t\t\td1 = (e1%mod + mod) % mod;\n\t\t\td2 = (e2%mod + mod) % mod;\n\t\t\td3 = (e3%mod + mod) % mod;\n\t\t}\n\t\tprintf(\"%lld\\n\", d3*(mod + 1) / 2 % mod);\n\t}\n\telse\n\t{\n\t\tabort();\n\t\tint c1 = path[diam / 2], c2 = path[(diam + 1) / 2];\n\t\tfill(flag, flag + num, false);\n\t\tiscent[c1] = iscent[c2] = true;\n\t\tdfs2(c1, 0), dfs2(c2, 0);\n\n\t\tpii a = calc(path[diam / 2]), b = calc(path[(diam + 1) / 2]);\n\t\tprintf(\"%lld\\n\", a.first*b.first%mod);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define N 300000\n\nconst LL mod=998244353;\nLL n,f[N][3][3],g[3][3],d[N],m,mx,rt,fa[N];\nvector<LL> e[N];\n\nvoid dfs(LL u,LL dist){\n\tif (dist>mx){mx=dist; rt=u;}\n\tfor (LL v:e[u])\n\t\tif (v!=fa[u]){\n\t\t\tfa[v]=u;\n\t\t\tdfs(v,dist+1);\n\t\t}\n}\n\nLL inv(LL x){return x==1?1:(mod-mod/x)*inv(mod%x)%mod;}\n\nvoid upd(LL &x,LL y){x=(x+y)%mod;}\n\nvoid dp(LL u,LL dist){\n\tif (dist==m/2) f[u][1][1]=1;\n\telse f[u][0][0]=1;\n\tfor (LL v:e[u])\n\t\tif (v!=fa[u]){\n\t\t\tfa[v]=u;\n\t\t\tdp(v,dist+1);\n\t\t\tmemset(g,0,sizeof g);\n\t\t\tfor (LL i1:{0,1,2}) for (LL i2:{0,1,2}) for (LL j1:{0,1,2}) for (LL j2:{0,1,2})\n\t\t\t\tfor (LL k:{0,1,2}){\n\t\t\t\t\tLL t1=j1*(k==1),t2=j2*(k==2);\n\t\t\t\t\tt1=min(2LL,i1+t1); t2=min(2LL,i2+t2);\n\t\t\t\t\tupd(g[t1][t2],f[u][i1][i2]*f[v][j1][j2]);\n\t\t\t\t}\n\t\t\tmemcpy(f[u],g,sizeof f[u]);\n\t\t}\n}\n\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor (LL i=1;i<n;++i){\n\t\tLL x,y; scanf(\"%lld%lld\",&x,&y);\n\t\te[x].push_back(y);\n\t\te[y].push_back(x);\n\t}\n\tdfs(1,1);\n\tmemset(fa,0,sizeof fa); mx=0;\n\tdfs(rt,1);\n\tfor (LL i=rt;i;i=fa[i]) d[++m]=i;\n\tmemset(fa,0,sizeof fa);\n\tif (m&1){\n\t\tLL p=d[m/2+1];\n\t\tdp(p,0);\n\t\tprintf(\"%lld\\n\",f[p][1][1]*inv(2)%mod);\n\t}\n\telse{\n\t\tLL p1=d[m/2],p2=d[m/2+1];\n\t\tfa[p1]=p2; fa[p2]=p1;\n\t\tdp(p1,1); dp(p2,1);\n\t\tprintf(\"%lld\\n\",(f[p1][1][0]+f[p1][1][1]+f[p1][1][2])*(f[p2][1][0]+f[p2][1][1]+f[p2][1][2])%mod);\n\t}\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i,a,b) for (int i=a;i<=b;i++)\n#define R(i,a,b) for (int i=a;i<b;i++)\n#define D(i,a,b) for (int i=a;i>=b;i--)\n#define go(i,x) for (int i=head[x];i;i=Next[i])\n#define pb push_back\n#define si size()\n#define fi first\n#define se second\n#define pa pair < ll,ll >\n#define ll long long\n#define mp make_pair\n#define be begin()\n#define en end()\n#define put putchar('\\n')\n#define gc getchar\n#define pc putchar\n#define N 6000055\n#define mo 998244353\n#define inf 1000000007\n#define int ll\n#define ret return puts(\"-1\"),0\nusing namespace std;\ninline ll read(){\n\tll su=0,f=1;char c=gc();\n\tfor (;c<'0'||c>'9';c=gc()) if (c=='-') f=-1;\n\tfor (;c>='0'&&c<='9';c=gc()) su=su*10+c-'0';\n\treturn su*f;\n}\ninline void wr(ll x){\n\tif (x<0) pc('-'),wr(-x);\n\telse{if (x>=10) wr(x/10);pc(x%10+'0');}\n}\ninline void wri(ll x){wr(x);pc(' ');}\ninline void wrn(ll x){wr(x);put;}\ninline void wrn(ll x,ll y){wri(x);wrn(y);}\ninline void wrn(ll x,ll y,ll z){wri(x);wrn(y,z);}\nint ans,n,m,f[N][2],fa[N],dis[N],lo,rt,mx;\ninline void ad(int &x,int k){x+=k;x-=(x>=mo)?mo:0;}\nint Next[N*2],head[N],to[N*2],nedge,g[N][4];\n#define V to[i]\nvoid add(int a,int b){Next[++nedge]=head[a];head[a]=nedge;to[nedge]=b;}\nvoid add_ne(int a,int b){add(a,b);add(b,a);}\nvoid dfs(int x){\n\tmx=(dis[x]>dis[mx])?x:mx;\n\tgo(i,x){\n\t\tif (V==fa[x]) continue;\n\t\tfa[V]=x;dis[V]=dis[x]+1;dfs(V);\n\t}\n}\nint ksm(ll x,int k){\n\tint su=1;\n\tfor (;k;k>>=1,x=x*x%mo) if (k&1) su=su*x%mo;\n\treturn su;\n}\nvoid solve(int x){\n\tint pd=0;\n\tf[x][0]=1;\n\tg[x][0]=1;\n\tgo(i,x){\n\t\tif (V==fa[x]) continue;\n\t\tsolve(V);pd++;\n\t\tg[x][3]=1ll*g[x][3]*g[V][0]%mo;\n\t\tad(g[x][3],1ll*g[x][1]*g[V][2]%mo);\n\t\tad(g[x][3],1ll*g[x][2]*g[V][1]%mo);\n\t\tg[x][1]=1ll*g[x][1]*g[V][0]%mo;\n\t\tg[x][2]=1ll*g[x][2]*g[V][0]%mo;\n\t\tad(g[x][1],1ll*g[x][0]*g[V][1]%mo);\n\t\tad(g[x][2],1ll*g[x][0]*g[V][2]%mo);\n\t\tg[x][0]=1ll*g[x][0]*g[V][0]%mo;\n\t\t\n\t\tf[x][1]=1ll*f[x][1]*f[V][0]%mo;\n\t\tad(f[x][1],1ll*f[x][0]*f[V][1]%mo);\n\t\tf[x][0]=1ll*f[x][0]*f[V][0]%mo;\n\t}\n\tif (pd){\n\t\tf[x][0]=1ll*f[x][0]*3%mo;\n\t\tad(f[x][0],f[x][1]*2%mo);\n\t\tg[x][0]=1ll*g[x][0]*3%mo;\n\t\tad(g[x][0],((g[x][1]+g[x][2])%mo*2%mo+g[x][3])%mo);\n\t\tad(g[x][1],g[x][3]);ad(g[x][2],g[x][3]);\n\t}\n\telse{\n\t\tif (dis[x]==lo/2) f[x][1]=1,f[x][0]=2,g[x][1]=g[x][0]=g[x][2]=1;\n\t\telse f[x][0]=3,g[x][0]=3;\n\t}\n}\nsigned main(){\n\tn=read();\n\tR(i,1,n) add_ne(read(),read());\n\tdfs(1);\n\trt=mx;mx=0;dis[rt]=0;fa[rt]=0;\n\tdfs(rt);\n\tlo=dis[mx];\n\tF(i,1,lo/2) mx=fa[mx];\n\tif (lo&1){\n\t\tint x=mx,y=fa[mx];\n\t\tfa[y]=x;dis[x]=dis[y]=0;dfs(x);dfs(y);\n\t\t//solve(x);solve(y);\n\t\twrn(ksm(3,n-lo-1));\n\t}\n\telse{\n\t\tint x=mx,nu=0;\n\t\tfa[x]=0;dis[x]=0;dfs(x);\n\t\tF(i,1,n) if (dis[i]==lo/2) nu++;\n\t\t//ans=(1ll*nu*(nu-1)/2)%mo*ksm(3,n-lo-1)%mo;\n\t\tsolve(x);\n\t\tf[x][0]=1;f[x][1]=0;\n\t\tgo(i,x){\n\t\t\tans=1ll*ans*g[V][0]%mo;\n\t\t\tad(ans,1ll*f[x][1]*f[V][1]%mo);\n\t\t\tf[x][1]=1ll*f[x][1]*g[V][0]%mo;\n\t\t\tad(f[x][1],1ll*f[x][0]*f[V][1]%mo);\n\t\t\tf[x][0]=1ll*f[x][0]*g[V][0]%mo;\t\t\t\n\t\t}\n\t\twrn(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\nusing namespace std;\nconst int mo=998244353;\nconst int N=200005;\nint n;\nvector<int> e[N];\nint q[N],dS[N],dT[N];\nint mx[N],f[N][9],tmp[9];\nint bfs(int S,int *d){\n\tFor(i,1,n) d[i]=-1;\n\tint h=0,t=1;\n\tq[1]=S; d[S]=0;\n\twhile (h!=t){\n\t\tint x=q[++h];\n\t\tfor (auto i:e[x])\n\t\t\tif (d[i]==-1){\n\t\t\t\td[i]=d[x]+1;\n\t\t\t\tq[++t]=i;\n\t\t\t}\n\t}\n\treturn q[t];\n}\nvoid DP(int x,int fa){\n\tmx[x]=0;\n\tfor (auto i:e[x]) if (i!=fa)\n\t\tDP(i,x),mx[x]=max(mx[x],mx[i]);\n\tf[x][mx[x]==0?4:0]=1;\n\tfor (auto i:e[x]) if (i!=fa){\n\t\tmemset(tmp,0,sizeof(tmp));\n\t\tFor(j,0,8) For(k,0,8){\n\t\t\tint ek=(mx[i]==mx[x]?k:0);\n\t\t\tint nv=min(j%3+ek%3,2)+3*min(j/3+ek/3,2);\n\t\t\ttmp[nv]=(tmp[nv]+1ll*f[x][j]*f[i][k])%mo;\n\t\t} \n\t\tmemcpy(f[x],tmp,sizeof(f[x]));\n\t}\n\t//cout<<mx[x]<<endl;\n\tif (fa){\n\t\tmemset(tmp,0,sizeof(tmp));\n\t\tFor(j,0,8){\n\t\t\tint v1=0,v2=j%3,v3=j/3*3;\n\t\t\ttmp[v1]=(tmp[v1]+f[x][j])%mo;\n\t\t\ttmp[v2]=(tmp[v2]+f[x][j])%mo;\n\t\t\ttmp[v3]=(tmp[v3]+f[x][j])%mo;\n\t\t}\n\t\tmemcpy(f[x],tmp,sizeof(tmp));\n\t\t++mx[x];\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n-1){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\te[x].PB(y); e[y].PB(x);\n\t}\n\tint S=bfs(1,dS);\n\tint T=bfs(S,dS);\n\tbfs(T,dT);\n\tFor(i,1,n)\n\t\tif (dS[i]==dS[T]/2||dT[i]==dT[S]/2)\n\t\t\tif (dS[i]+dT[i]==dT[S])\n\t\t\t\tq[++*q]=i;\n\tif (*q==1){\n\t\tDP(q[1],0);\n\t\tprintf(\"%lld\\n\",1ll*f[q[1]][4]*(mo+1)/2%mo);\n\t}\n\telse{\n\t\tDP(q[2],q[1]);\n\t\tDP(q[1],q[2]);\n\t\tprintf(\"%lld\\n\",1ll*f[q[1]][1]*f[q[2]][3]%mo);\n\t}\n}\n/*\n    5\n    |\n4-3-2-1-6\n\nf[i][0/1][0/1]的方案数\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint read(){\n\tint a = 0; char c = getchar(); while(!isdigit(c)) c = getchar();\n\twhile(isdigit(c)){a = a * 10 + c - 48; c = getchar();} return a;\n}\n\nconst int _ = 2e5 + 7 , MOD = 998244353 , iv2 = (MOD + 1) / 2;\nstruct Edge{int end , upEd;}Ed[_ << 1];\nint dp[_][3][3] , N , cntEd , head[_];\nvoid addEd(int a , int b){Ed[++cntEd] = (Edge){b , head[a]}; head[a] = cntEd;}\n\nint mx , id , pre[_];\nvoid dfs1(int x , int p , int l){\n\tpre[x] = p; if(l > mx){mx = l; id = x;}\n\tfor(int i = head[x] ; i ; i = Ed[i].upEd)\n\t\tif(Ed[i].end != p) dfs1(Ed[i].end , x , l + 1);\n}\n\nint mxdep[_];\nvoid dfs2(int x , int p){\n\tfor(int i = head[x] ; i ; i = Ed[i].upEd)\n\t\tif(Ed[i].end != p){dfs2(Ed[i].end , x); mxdep[x] = max(mxdep[x] , mxdep[Ed[i].end] + 1);}\n}\n\nvoid DP(int x , int p){\n\tdp[x][0][0] = 1; bool flg = 0;\n\tfor(int i = head[x] ; i ; i = Ed[i].upEd)\n\t\tif(Ed[i].end != p){\n\t\t\tflg = 1; DP(Ed[i].end , x); static int tmp[3][3]; memset(tmp , 0 , sizeof(tmp));\n\t\t\tfor(int j = 0 ; j < 3 ; ++j)\n\t\t\t\tfor(int k = 0 ; k < 3 ; ++k)\n\t\t\t\t\tfor(int p = 0 ; p < 3 ; ++p)\n\t\t\t\t\t\tfor(int q = 0 ; q < 3 ; ++q){\n\t\t\t\t\t\t\tint coef = 3;\n\t\t\t\t\t\t\tif(mxdep[Ed[i].end] + 1 == mxdep[x]){\n\t\t\t\t\t\t\t\ttmp[min(j + p , 2)][k] = (tmp[min(j + p , 2)][k] + 1ll * dp[x][j][k] * dp[Ed[i].end][p][q]) % MOD;\n\t\t\t\t\t\t\t\ttmp[j][min(k + q , 2)] = (tmp[j][min(k + q , 2)] + 1ll * dp[x][j][k] * dp[Ed[i].end][p][q]) % MOD;\n\t\t\t\t\t\t\t\tcoef -= 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttmp[j][k] = (tmp[j][k] + 1ll * coef * dp[x][j][k] * dp[Ed[i].end][p][q]) % MOD;\n\t\t\t\t\t\t}\n\t\t\tmemcpy(dp[x] , tmp , sizeof(tmp));\n\t\t}\n\tif(!flg){dp[x][0][0] = 0; dp[x][1][1] = 1;}\n}\n\nint main(){\n\tN = read(); for(int i = 1 ; i < N ; ++i){int x = read() , y = read(); addEd(x , y); addEd(y , x);}\n\tdfs1(1 , 0 , 0); mx = 0; int t = id; dfs1(t , 0 , 0);\n\tfor(int i = 0 ; i < mx / 2 ; ++i) id = pre[id];\n\tif(mx & 1){\n\t\tdfs2(id , pre[id]); DP(id , pre[id]); dfs2(pre[id] , id); DP(pre[id] , id); int sum = 0;\n\t\tfor(int i = 0 ; i < 3 ; ++i)\n\t\t\tfor(int j = 0 ; j < 3 ; ++j)\n\t\t\t\tfor(int k = 0 ; k < 3 ; ++k)\n\t\t\t\t\tfor(int l = 0 ; l < 3 ; ++l){\n\t\t\t\t\t\tif(i == 1 && l == 1) sum = (sum + 1ll * dp[id][i][j] * dp[pre[id]][k][l]) % MOD;\n\t\t\t\t\t\tif(j == 1 && k == 1) sum = (sum + 1ll * dp[id][i][j] * dp[pre[id]][k][l]) % MOD;\n\t\t\t\t\t}\n\t\tprintf(\"%lld\\n\" , 1ll * sum * iv2 % MOD);\n\t}else{dfs2(id , 0); DP(id , 0); printf(\"%lld\\n\" , 1ll * iv2 * dp[id][1][1] % MOD);}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst int M=998244353;\nconst int inv2=(M+1)/2;\nconst int inv3=(M+1)/3;\nconst int maxn=3e5+3;\nvector <int> h[maxn];\nint dis[maxn],n,pre[maxn],p,q,d[maxn],m;\nll dp[maxn][4];\nvoid dfs(int u,int fa){\n    pre[u]=fa; dis[u]=dis[fa]+1;\n    for (auto v:h[u]){\n        if (v==fa) continue;\n        dfs(v,u);\n    }\n}\nvoid dfs2(int u,int fa){\n    d[u]=d[fa]+1;\n    if (d[u]==m){\n        dp[u][0]=2; // none\n        dp[u][1]=1; // exactly one\n        dp[u][2]=3; // all\n        dp[u][3]=1; // at least one\n        return;\n    }\n    ll r1=1,r2=0,r3=1,r4=0;\n    for (auto v:h[u]){\n        if (v==fa) continue;\n        dfs2(v,u);\n        ll nr1=r1*dp[v][0]%M;\n        ll nr2=(r1*dp[v][1]+r2*dp[v][0])%M;\n        ll nr3=r3*dp[v][2]%M;\n        ll nr4=((r3*dp[v][3]+r4*dp[v][2]-r4*dp[v][3])%M+M)%M;\n        r1=nr1; r2=nr2; r3=nr3; r4=nr4;\n    }\n    dp[u][0]=(r1*3+r4*2)%M;\n    dp[u][1]=r2;\n    dp[u][2]=r3*3%M;\n    dp[u][3]=r4;\n    \n}\nint main(){\n    scanf(\"%d\",&n); dis[0]=-1;\n    for (int i=1;i<n;i++){\n        int u,v; scanf(\"%d%d\",&u,&v);\n        h[u].pb(v); h[v].pb(u);\n    }\n    //puts(\"B\");\n    dfs(1,0);\n    int s=1;\n    for (int i=2;i<=n;i++) if (dis[i]>dis[s]) s=i;\n    dfs(s,0);\n    int t=s;\n    for (int i=1;i<=n;i++) if (dis[i]>dis[t]) t=i;\n    m=dis[t]/2; p=t;\n    for (int i=0;i<m;i++) p=pre[p];\n    if (dis[t]&1){\n        q=pre[p];\n        d[q]=-1; dfs2(p,q);\n        d[p]=-1; dfs2(q,p);\n        printf(\"%lld\\n\",dp[p][1]*dp[q][1]%M);\n    } else {\n        ll ans0=1,ans1=0,ans2=0;\n        for (auto u:h[p]){\n            d[u]=0; dfs2(u,p);\n            ll nans0,nans1,nans2,has,none;\n            has=dp[u][1]; none=(dp[u][2]+2*(M-dp[u][3]))%M;\n            //cout<<has<<' '<<none<<endl;\n            //cout<<dp[u][2]<<' '<<dp[u][3]<<endl;\n            nans0=ans0*none%M;\n            nans1=(ans0*has+ans1*none)%M;\n            nans2=(ans1*has+ans2*none)%M;\n            ans0=nans0; ans1=nans1; ans2=nans2;\n        }\n        printf(\"%lld\\n\",ans2);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n\n\n\n\n#include <algorithm>\n\n#include <array>\n\n#include <bitset>\n\n#include <cassert>\n\n#include <complex>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <iostream>\n\n#include <map>\n\n#include <numeric>\n\n#include <queue>\n\n#include <set>\n\n#include <string>\n\n#include <unordered_map>\n\n#include <unordered_set>\n\n#include <vector>\n\nusing namespace std;\n\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\nstruct Scanner {\n    FILE* fp = nullptr;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += fread(line + ed, 1, (1 << 15) - ed, fp);\n        line[ed] = '\\0';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) reread();\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == '-') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] - '0');\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(V<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    Scanner(FILE* _fp) : fp(_fp) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(' ');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single('\\n');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val; // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char('0' + (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const V<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(' ');\n            write_single(val[i]);\n        }\n    }\n};\n\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    static constexpr uint get_mod() { return MD; }\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(uint(_v % MD + MD)); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(uint(ull(v) * r.v % MD)); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\n// using Mint = ModInt<998244353>;\n// template<> const Mint Mint::G = Mint(3);\n\nusing Mint = ModInt<998244353>;\n\nScanner sc = Scanner(stdin);\nPrinter pr = Printer(stdout);\n\nVV<int> g;\n\nint mdp, mv;\nvoid dfs(int p, int b, int ndp = 0) {\n    if (mdp <= ndp) {\n        mdp = ndp;\n        mv = p;\n    }\n    for (int d: g[p]) {\n        if (d == b) continue;\n        dfs(d, p, ndp + 1);\n    }\n}\n\nV<int> path;\nbool dfs_path(int p, int b, int t) {\n    if (p == t) {\n        path.push_back(p);\n        return true;\n    }\n    for (int d: g[p]) {\n        if (d == b) continue;\n        if (dfs_path(d, p, t)) {\n            path.push_back(p);\n            return true;\n        }\n    }\n    return false;\n}\n\nint U;\n\nusing P = array<Mint, 3>;\n\nP solve(int p, int b, int ndps = 0) {\n    if (g[p].size() == 1) {\n        // leaf\n        if (ndps == U) {\n            // rad\n            return {Mint(2), Mint(1), Mint(0)};\n        } else {\n//            dbg(p, b, P{Mint(3), Mint(0)});\n            return {Mint(3), Mint(0), Mint(0)};\n        }\n    }\n    P dp = {Mint(1), Mint(0), Mint(0)};\n    for (auto d: g[p]) {\n        if (d == b) continue;\n        auto ch = solve(d, p, ndps + 1);\n        P ndp = {Mint(0), Mint(0), Mint(0)};\n        for (int a = 0; a < 3; a++) {\n            for (int b = 0; b < 3; b++) {\n                ndp[min(2, a + b)] += dp[a] * ch[b];\n            }\n        }\n        dp = ndp;\n    }\n    dp[0] = dp[0] * Mint(3) + (dp[1] + dp[2]) * Mint(2);\n    return dp;\n}\n\nint main() {\n    int n;\n    sc.read(n);\n    g = VV<int>(n);\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        sc.read(a, b); a--; b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    dfs(0, -1);\n    int u = mv;\n    dfs(mv, -1);\n    int v = mv;\n    dfs_path(u, -1, v);\n\n    int L = int(path.size());\n    if (L % 2) {\n        U = (L / 2) - 1;\n        int mid = path[L / 2];\n                       ;\n        V<Mint> dp(4);\n        dp[0] = Mint(1);\n        for (int d: g[mid]) {\n            V<Mint> ndp(4);\n            auto x = solve(d, mid);\n            Mint x0 = x[0], x1 = x[1];\n            ndp[3] = dp[3] * x0 + dp[2] * x1 + dp[1] * x1;\n            ndp[2] = dp[2] * x0 + dp[0] * x1;\n            ndp[1] = dp[1] * x0 + dp[0] * x1;\n            ndp[0] = dp[0] * x0;\n            dp = ndp;\n        }\n               ;\n        pr.writeln((dp[3] / Mint(2)).v);\n    } else {\n        int mid0 = path[L / 2 - 1], mid1 = path[L / 2];\n        assert(false);\n        U = (L / 2 - 1);\n        auto x = solve(mid0, mid1);\n        auto y = solve(mid1, mid0);\n        pr.writeln((x[1] * y[1]).v);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll mod = 998244353;\nvector<int>pat[202020];\nint dep[202020];\nbool flag[202020];\nint diam = 0;\nbool iscent[202020];\nvector<int>ko[202020];\nvoid dfs(int node, int d)\n{\n\tflag[node] = true;\n\tdep[node] = d;\n\tdiam = max(diam, d);\n\tfor (int i = 0; i < pat[node].size(); i++)if (!flag[pat[node][i]])dfs(pat[node][i], d + 1);\n}\nvoid dfs2(int node, int d)\n{\n\tflag[node] = true;\n\tdep[node] = d;\n\tfor (int i = 0; i < pat[node].size(); i++)\n\t{\n\t\tif (!flag[pat[node][i]] && !iscent[pat[node][i]])\n\t\t{\n\t\t\tdfs2(pat[node][i], d + 1);\n\t\t\tko[node].push_back(pat[node][i]);\n\t\t}\n\t}\n}\ntypedef pair<ll, ll>pii;\npii calc(int node)\n{\n\tif (ko[node].empty())\n\t{\n\t\tif (dep[node] == diam / 2)return make_pair(1, 2);\n\t\telse return make_pair(0, 3);\n\t}\n\tvector<pii>v;\n\tfor (int i = 0; i < ko[node].size(); i++)v.push_back(calc(ko[node][i]));\n\tvector<ll>r1, r2;\n\tr1.resize(v.size() + 1), r1[0] = 1;\n\tr2.resize(v.size() + 1), r2[v.size()] = 1;\n\tfor (int i = 0; i < v.size(); i++)r1[i + 1] = r1[i] * v[i].second%mod;\n\tfor (int i = v.size() - 1; i >= 0; i--)r2[i] = r2[i + 1] * v[i].second%mod;\n\tll t1 = 0, t2 = 1;\n\tfor (int i = 0; i < v.size(); i++)\n\t{\n\t\tt1 = (t1 + r1[i] * r2[i + 1] % mod*v[i].first) % mod;\n\t\tt2 = t2*v[i].second%mod;\n\t}\n\tt2 = (t2 + t1 + t2 + t1 + t2) % mod;\n\t//printf(\"%d %lld %lld\\n\", node + 1, t1, t2);\n\treturn make_pair(t1, t2);\n}\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < num - 1; i++)\n\t{\n\t\tint za, zb;\n\t\tscanf(\"%d%d\", &za, &zb);\n\t\tza--, zb--;\n\t\tpat[za].push_back(zb);\n\t\tpat[zb].push_back(za);\n\t}\n\tdfs(0, 0);\n\tint r = 0;\n\tfor (int i = 0; i < num; i++)if (dep[i] == diam)r = i;\n\tfill(flag, flag + num, false);\n\tdfs(r, 0);\n\tint now;\n\tfor (int i = 0; i < num; i++)if (dep[i] == diam)now = i;\n\tvector<int>path;\n\tfor (int i = 0; i < diam; i++)\n\t{\n\t\tpath.push_back(now);\n\t\tfor (int j = 0; j < pat[now].size(); j++)\n\t\t{\n\t\t\tif (dep[pat[now][j]] == dep[now] - 1)\n\t\t\t{\n\t\t\t\tnow = pat[now][j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j == pat[now].size() - 1)abort();\n\t\t}\n\t}\n\tpath.push_back(now);\n\n\t//for (int i = 0; i < path.size(); i++)printf(\"%d \", path[i] + 1); printf(\"\\n\");\n\n\n\tif (diam % 2 == 0)\n\t{\n\t\tint c = path[diam / 2];\n\t\tfill(flag, flag + num, false);\n\t\tiscent[c] = true;\n\t\tdfs2(c, 0);\n\t\tll d0 = 1, d1 = 0, d2 = 0, d3 = 0;\n\t\tfor (int i = 0; i < ko[c].size(); i++)\n\t\t{\n\t\t\tpii z = calc(ko[c][i]);\n\t\t\tll e0 = d0*(z.second - z.first);\n\t\t\tll e1 = d0*z.first + d1*(z.second - z.first);\n\t\t\tll e2 = d0*z.first + d2*(z.second - z.first);\n\t\t\tll e3 = d1*z.first + d2*z.first + d3*(z.second - z.first);\n\t\t\td0 = (e0%mod + mod) % mod;\n\t\t\td1 = (e1%mod + mod) % mod;\n\t\t\td2 = (e2%mod + mod) % mod;\n\t\t\td3 = (e3%mod + mod) % mod;\n\t\t}\n\t\tprintf(\"%lld\\n\", d3*(mod + 1) / 2 % mod);\n\t}\n\telse\n\t{\n\t\tint c1 = path[diam / 2], c2 = path[(diam + 1) / 2];\n\t\tfill(flag, flag + num, false);\n\t\tiscent[c1] = iscent[c2] = true;\n\t\tdfs2(c1, 0), dfs2(c2, 0);\n\n\t\tpii a = calc(path[diam / 2]), b = calc(path[(diam + 1) / 2]);\n\t\tprintf(\"%lld\\n\", a.first*b.first%mod);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=200000+5,mod=998244353;\nint ksm(int b,int n){\n\tint res=1;\n\twhile(n){\n\t\tif(n&1) res=res*b%mod;\n\t\tb=b*b%mod; n>>=1;\n\t}\n\treturn res;\n}\nint add(int x,int y){\n\treturn (x+y)%mod;\n}\nint mul(int x,int y){\n\treturn x*y%mod;\n}\nvector<int> e[N];\nint n,dis[N],pre[N];\nint dp[N][3][3];\nint bfs(int st){\n\tqueue<int> q;\n\tint res=0;\n\tfor(int i=1;i<=n;++i)\n\t\tdis[i]=0;\n\tdis[st]=1; pre[st]=0; q.push(st);\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\tif(dis[u]>dis[res]) res=u;\n\t\t//cout<<st<<\" \"<<u<<\" \"<<dis[u]<<\" \"<<res<<endl;\n\t\tfor(int i=0;i<e[u].size();++i)\n\t\t\tif(dis[e[u][i]]==0) q.push(e[u][i]),dis[e[u][i]]=dis[u]+1,pre[e[u][i]]=u;\n\t}\n\treturn res;\n}\nint L,tmp[3][3];\nvoid dfs(int u,int fath,int dep){\n\t//cout<<u<<\" \"<<fath<<\" \"<<dep<<endl;\n\tif(dep==L/2) dp[u][1][1]=1;\n\telse dp[u][0][0]=1;\n\tfor(int i=0;i<e[u].size();++i){\n\t\tint v=e[u][i];\n\t\tif(v==fath) continue;\n\t\tdfs(v,u,dep+1);\n\t\tfor(int x=0;x<=2;++x)\n\t\t\tfor(int y=0;y<=2;++y)\n\t\t\t\ttmp[x][y]=0;\n\t\tfor(int x=0;x<=2;++x)\n\t\t\tfor(int y=0;y<=2;++y)\n\t\t\t\tfor(int a=0;a<=2;++a)\n\t\t\t\t\tfor(int b=0;b<=2;++b)\n\t\t\t\t\t\tfor(int type=0;type<=2;++type){\n\t\t\t\t\t\t\tint p=min(x+(type==1)*a,2ll),q=min(y+(type==2)*b,2ll);\n\t\t\t\t\t\t\ttmp[p][q]=add(tmp[p][q],mul(dp[u][x][y],dp[v][a][b]));\n\t\t\t\t\t\t}\n\t\tfor(int x=0;x<=2;++x)\n\t\t\tfor(int y=0;y<=2;++y)\n\t\t\t\tdp[u][x][y]=tmp[x][y];\n\t}\n\t//for(int x=0;x<=2;++x)\n\t//\tfor(int y=0;y<=2;++y)\n\t\t//\tcout<<u<<\" \"<<x<<\" \"<<y<<\" \"<<dp[u][x][y]<<endl;\n}\nint c[N],tot;\nvoid solve(){\n\tint from=bfs(1),to=bfs(from);\n\ttot=0;while(to) c[++tot]=to,to=pre[to];\n\tL=tot;\n\tif(tot&1){\n\t\tfrom=c[(tot+1)/2];\n\t\tdfs(from,0,0);\n\t\tcout<<mul(dp[from][1][1],ksm(2,mod-2));\n\t\treturn;\n\t}\n\telse{\n\t\tfrom=c[tot/2],to=c[(tot+2)/2];\n\t//\tcout<<from<<\" \"<<to<<\" \"<<tot<<endl;\n\t\tdfs(from,to,1);\n\t\tint x=0,y=0;\n\t\tfor(int i=0;i<=2;++i)\n\t\t\tx=add(x,dp[from][i][1]);\n\t\tdfs(to,from,1);\n\t\tfor(int i=0;i<=2;++i)\n\t\t\ty=add(y,dp[to][1][i]);\n\t\tcout<<mul(x,y);\n\t\treturn;\n\t}\n}\nsigned main(){\n\tint ans=0,u,v;\n\tcin>>n;\n\tfor(int i=1;i<n;++i){\n\t\tcin>>u>>v;\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n#define resz resize\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define sort_by(x, y) sort(all(x), [&](const auto& a, const auto& b) { return y; })\n\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpll = vector<pll>;\nusing vvpll = vector<vpll>;\nusing vpdd = vector<pdd>;\nusing vvpdd = vector<vpdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\ntemplate<typename T> using max_heap = priority_queue<T>;\ntemplate<typename T> using min_heap = priority_queue<T, vector<T>, greater<T>>;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const deque<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T, bool pretty = true> void prContain(const T& x) {\n        if (pretty) pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?pretty?\", \":\" \":\"\",a), fst = 0;\n        if (pretty) pr(\"}\");\n    }\n    template<class T> void pc(const T& x) { prContain<T, false>(x); pr(\"\\n\"); }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const deque<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __numeric {\n    template<typename T>\n    typename enable_if<is_integral<T>::value, T>::type floor(T n, T d) {\n        assert(d != 0);\n        if (d < 0) tie(n, d) = mp(-n, -d);\n        return n / d - ((n < 0) && (n % d));\n    }\n    template<typename T>\n    typename enable_if<is_integral<T>::value, T>::type ceil(T n, T d) {\n        assert(d != 0);\n        if (d < 0) tie(n, d) = mp(-n, -d);\n        return n / d + ((n > 0) && (n % d));\n    }\n};\nusing namespace __numeric;\n\nnamespace __algorithm {\n    template<typename T> void dedup(vector<T>& v) {\n        sort(all(v)); v.erase(unique(all(v)), v.end());\n    }\n    template<typename T> typename vector<T>::iterator find(vector<T>& v, const T& x) {\n        auto it = lower_bound(all(v), x); return it != v.end() && *it == x ? it : v.end();\n    }\n    template<typename T> size_t index(vector<T>& v, const T& x) {\n        auto it = find(v, x); assert(it != v.end() && *it == x); return it - v.begin();\n    }\n    template<typename C, typename T, typename OP> vector<T> prefixes(const C& v, T id, OP op) {\n        vector<T> r(sz(v)+1, id); F0R (i, sz(v)) r[i+1] = op(r[i], v[i]); return r;\n    }\n    template<typename C, typename T, typename OP> vector<T> suffixes(const C& v, T id, OP op) {\n        vector<T> r(sz(v)+1, id); F0Rd (i, sz(v)) r[i] = op(v[i], r[i+1]); return r;\n    }\n}\nusing namespace __algorithm;\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-parameter\"\nstruct monostate {\n    friend istream& operator>>(istream& is, const monostate& ms) { return is; }\n    friend ostream& operator<<(ostream& os, const monostate& ms) { return os; }\n    friend monostate operator+(const monostate& a, const monostate& b) { return a; }\n} ms;\n#pragma GCC diagnostic pop\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        cout << fixed << setprecision(15);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\n// tree {{{\nstruct edge {\n    int uv; //int id;\n    edge (int _uv = 0, __attribute__((unused))monostate _ = ms) : uv(_uv) {}\n    int operator()(int u) const { assert(uv); return uv ^ u; }\n    monostate& wt() const { return ms; }\n    struct path { int len;\n        path operator+(const path& p) const { return {len+p.len}; }\n    }; explicit operator path() { return {1}; }\n};\ntemplate<typename W> struct wedge : edge {\n    mutable W w;\n    wedge (int _uv = 0, W _w = {}) : edge(_uv), w(_w) {}\n    W& wt() const { return w; }\n    struct path { int len; W wt;\n        path operator+(const path& p) { return {len+p.len, wt+p.wt}; }\n    }; explicit operator path() { return {1, w}; }\n};\n\nenum INPUT_FORMAT { EDGE_LIST, PARENT_LIST };\ntemplate<typename E> struct tree {\n    int V, root;\n    vector<vector<E>> nbrs, children;\n\n    vi par, depth, subt_sz;\n    vi preorder, reverse_preorder;\n\n    tree() : V(0), root(-1) {}\n    tree(int _V, int _root) : V(_V), root(_root), nbrs(V) {}\n\n    const E& up_edge(int u) const {\n        assert(u != root);\n        return nbrs[u].front();\n    }\n\n    void add_edge(int u, int v, E e = {}) {\n        assert(0 <= u && u < V && 0 <= v && v < V);\n        e.uv = u ^ v;\n        nbrs[u].pb(e);\n        nbrs[v].pb(e);\n    }\n\n    template<INPUT_FORMAT FMT = EDGE_LIST, bool FIRST_INDEX = 1>\n    friend void re(tree& t) {\n        assert(t.V > 0);\n        for (int i = 0; i < t.V - 1; i++) {\n            int u, v;\n            re(u), u -= FIRST_INDEX;\n            if (FMT == PARENT_LIST) v = i+1;\n            else re(v), v -= FIRST_INDEX;\n            E e{}; re(e.wt()); // e.id = i\n            t.add_edge(u, v, e);\n        }\n        t.init();\n    }\n\n    void init() {\n        children.resz(V), par.resz(V), depth.resz(V), subt_sz.resz(V);\n        par[root] = -1, depth[root] = 0;\n\n        traverse(root);\n        for (int u = 0; u < V; u++) {\n            sort_by(nbrs[u], subt_sz[a(u)] > subt_sz[b(u)]);\n            children[u].clear();\n            copy(nbrs[u].begin() + (u != root), nbrs[u].end(), back_inserter(children[u]));\n        }\n\n        preorder.clear(), preorder.reserve(V), build_preorder(root);\n        reverse_preorder = preorder, reverse(all(reverse_preorder));\n    }\n    void reroot(int _root) { root = _root; init(); }\n\n    void traverse(int u) {\n        subt_sz[u] = 1;\n        for (E e : nbrs[u]) {\n            int v = e(u);\n            if (v == par[u]) continue;\n            par[v] = u;\n            depth[v] = depth[u] + 1;\n            traverse(v);\n            subt_sz[u] += subt_sz[v];\n        }\n    }\n\n    void build_preorder(int u) {\n        preorder.pb(u);\n        for (E e : children[u]) build_preorder(e(u));\n    }\n\n    friend void pr(const tree& t) {\n        pr(\"{V=\", t.V, \" root=\", t.root, \" |\");\n        for (int u = 0; u < t.V; u++) {\n            pr(\" \", u, \"--{\");\n            for (E e : t.children[u])\n                pr(\"(ch=\", e(u), \" wt=\", e.wt(), \")\");\n            pr(\"}\");\n        }\n        pr(\"}\");\n    }\n};\n// }}}\n\n// modnum {{{\nusing v_t = int;\nusing vv_t = ll;\ntemplate<v_t MOD> struct modnum {\n    v_t v;\n    modnum() : v(0) {}\n    modnum(vv_t _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator v_t() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { vv_t w; i >> w; n = modnum(w); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return x % m;\n#endif\n        // x must be less than 2^32 * m so that x / m fits in a 32-bit integer.\n        unsigned x_high = x >> 32, x_low = (unsigned) x, quot, rem;\n        asm(\"divl %4\\n\"\n                : \"=a\" (quot), \"=d\" (rem)\n                : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = fast_mod(vv_t(v) * o.v); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(vv_t e) const {\n        if (e < 0) return 1 / this->pow(-e);\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        v_t g = MOD, x = 0, y = 1;\n        for (v_t r = v; r != 0; ) {\n            v_t q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static constexpr v_t totient() {\n        v_t tot = MOD, tmp = MOD;\n        for (v_t p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static v_t primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        v_t tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (v_t p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (v_t r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (v_t p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static v_t discrete_log(modnum v) {\n        static const v_t M = ceil(sqrt(MOD));\n        static unordered_map<v_t, v_t> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (v_t i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (v_t i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum unity_root(int deg) {\n        assert(totient() % deg == 0);\n        return generator().pow(totient() / deg);\n    }\n\n    static modnum unity_root(int deg, int pow) {\n        static vector<modnum> table{ 0, 1 };\n        while (sz(table) <= deg) {\n            modnum w = unity_root(sz(table));\n            for (int i = sz(table)/2, s = sz(table); i < s; i++) {\n                table.push_back(table[i]);\n                table.push_back(table[i] * w);\n            }\n        }\n        return table[deg + (pow < 0 ? deg + pow : pow)];\n    }\n\n    static modnum factorial(int n) {\n        static vector<modnum> fact = {1};\n        assert(n >= 0);\n        if (sz(fact) <= n) {\n            int had = sz(fact);\n            fact.resize(n + 1);\n            for (int i = had; i <= n; i++) fact[i] = fact[i-1] * i;\n        }\n        return fact[n];\n    }\n    static modnum inverse_factorial(int n) {\n        static vector<modnum> finv = {1};\n        assert(n >= 0);\n        if (sz(finv) <= n) {\n            int had = sz(finv);\n            finv.resz(n + 1), finv[n] = factorial(n).inv();\n            for (int i = n - 1; i >= had; i--) finv[i] = finv[i+1] * (i+1);\n        }\n        return finv[n];\n    }\n\n    static modnum small_inv(int n) {\n        assert(n > 0); return factorial(n - 1) * inverse_factorial(n);\n    }\n\n    static modnum ncr(int n, int r) {\n        if (r < 0 || n < r) return 0;\n        return factorial(n) * inverse_factorial(r) * inverse_factorial(n - r);\n    }\n};\n// }}}\nusing mn = modnum<int(998244353)>;\nusing vmn = vector<mn>;\nusing vvmn = vector<vmn>;\n\nint main() {\n    setIO();\n\n    int N; re(N); tree<edge> tr(N, 0); re(tr);\n\n    // expects adjacency list \"adj\", return distances and bfs tree\n    auto bfs = [&](int src) {\n        vi dist(N, -1), pred(N, -1);\n        dist[src] = 0;\n        for (queue<int> bfs({src}); !bfs.empty(); bfs.pop()) {\n            int loc = bfs.front();\n            trav (e, tr.nbrs[loc]) {\n                int nbr = e(loc);\n                if (dist[nbr] == -1) {\n                    dist[nbr] = dist[loc] + 1;\n                    pred[nbr] = loc;\n                    bfs.push(nbr);\n                }\n            }\n        }\n        return mp(dist, pred);\n    };\n\n    int x;\n    {\n        auto dist = bfs(0).f;\n        x = max_element(all(dist)) - dist.begin();\n    }\n    int y, diam, c0, c1;\n    {\n        vi dist, pred;\n        tie(dist, pred) = bfs(x);\n        y = max_element(all(dist)) - dist.begin();\n        diam = dist[y];\n\n        c0 = y;\n        F0R (i, diam / 2)\n            c0 = pred[c0];\n        if (diam&1)\n            c1 = pred[c0];\n        else\n            c1 = -1;\n    }\n\n    tr.reroot(c0);\n\n    vb extreme(N);\n    {\n        if (c1 != -1) {\n            vb c1_side(N);\n            c1_side[c1] = 1;\n            trav (u, tr.preorder)\n                if (tr.depth[u] > tr.depth[c1])\n                    c1_side[u] = c1_side[tr.par[u]];\n            F0R (i, N)\n                extreme[i] = tr.depth[i] == (diam + c1_side[i]) / 2;\n        } else {\n            F0R (i, N) extreme[i] = tr.depth[i] == (diam / 2);\n        }\n    }\n\n    vector<array<mn, 9>> dp(N);\n    trav (u, tr.reverse_preorder) {\n        if (tr.children[u].empty()) {\n            if (extreme[u]) dp[u][3 * 1 + 1] = 1;\n            else dp[u][0] = 1;\n        } else {\n            dp[u][0] = 1;\n            trav (e, tr.children[u]) {\n                if (e(u) == c1) continue;\n                array<mn, 9> DP; DP.fill(0);\n                F0R (pos, 3) F0R (neg, 3) {\n                    F0R (POS, 3) F0R (NEG, 3) {\n                        mn ways = dp[u][3 * pos + neg] * dp[e(u)][3 * POS + NEG];\n                        for (int dir = -1; dir <= 1; dir++) {\n                            int rpos = min(2, pos + (dir > 0 ? POS : 0));\n                            int rneg = min(2, neg + (dir < 0 ? NEG : 0));\n                            DP[3 * rpos + rneg] += ways;\n                        }\n                    }\n                }\n                dp[u] = DP;\n            }\n        }\n    }\n\n    if (diam&1) {\n        ps(dp[c0][3 * 1] * dp[c1][1]);\n    } else {\n        ps(dp[c0][3 * 1 + 1] / 2);\n    }\n\n    // did you check N=1? did you mix up N,M?\n    // check your \"infinity\" and \"null\" values against the bounds\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200100\nusing namespace std;\nvector<int> g[N];\nint to_leaf[N];\nlong long p3sz[N],nume[N][3];\nconst int Q=998244353;\nint find_c(int u,int p){\n\tint mx[2]={u,u},ans=0;\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint v=g[u][i];\n\t\tif(v==p) continue;\n\t\tans=max(ans,find_c(v,u));\n\t\tif(to_leaf[v]>to_leaf[mx[0]]){\n\t\t\tmx[1]=mx[0];\n\t\t\tmx[0]=v;\n\t\t}\n\t\telse if(to_leaf[v]>to_leaf[mx[1]]){\n\t\t\tmx[1]=v;\n\t\t}\n\t}\n\tans=max(ans,to_leaf[mx[0]]+to_leaf[mx[1]]);\n\tto_leaf[u]=to_leaf[mx[0]]+1;\n\treturn ans;\n}\nvoid build(int u,int p){\n\tto_leaf[u]=0;\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint v=g[u][i];\n\t\tif(v==p) continue;\n\t\tbuild(v,u);\n\t\tto_leaf[u]=max(to_leaf[u],to_leaf[v]+1);\n\t}\n}\nvoid solve(int u,int p){\n\tp3sz[u]=1;\n\tif(!to_leaf[u]){\n\t\tnume[u][1]=1;\n\t\treturn;\n\t}\n\tnume[u][0]=1;\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint v=g[u][i];\n\t\tif(v==p) continue;\n\t\tsolve(v,u);\n\t\tif(to_leaf[v]+1==to_leaf[u]){\n\t\t\tfor(int j=2;j>=0;j--){\n\t\t\t\tif(j<2) nume[u][j]*=2*p3sz[v]+nume[v][0];\n\t\t\t\telse nume[u][j]*=p3sz[v]+2*nume[v][0];\n\t\t\t\tnume[u][j]%=Q;\n\t\t\t\tif(j){\n\t\t\t\t\tnume[u][j]+=nume[v][1]*nume[u][j-1]%Q;\n\t\t\t\t\tnume[u][j]%=Q;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tnume[u][j]=3*p3sz[v]*nume[u][j]%Q;\n\t\t\t}\n\t\t}\n\t\tp3sz[u]=3*p3sz[v]*p3sz[u]%Q;\n\t}\n}\nint main(){\n\tint n,x,y;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tint l,p=0,c=1;\n\tl=find_c(1,0);\n\tbool flag=true;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<g[c].size();i++){\n\t\t\tif(g[c][i]!=p && to_leaf[g[c][i]]>(l+1)/2){\n\t\t\t\tp=c;\n\t\t\t\tc=g[c][i];\n\t\t\t\tflag=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"diameter=%d\\n\",l);\n\tif(l&1){\n\t\tint d=-1;\n\t\tfor(int i=0;i<g[c].size();i++){\n\t\t\tif(to_leaf[g[c][i]]==(l+1)/2){\n\t\t\t\td=g[c][i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//printf(\"center: %d %d\\n\",c,d);\n\t\tassert(d>0);\n\t\tbuild(c,d);\n\t\tsolve(c,d);\n\t\tbuild(d,c);\n\t\tsolve(d,c);\n\t\tprintf(\"%lld\\n\",1LL*nume[c][1]*nume[d][1]%Q);\n\t}\n\telse{\n\t\t//printf(\"center: %d\\n\",c);\n\t\tbuild(c,0);\n\t\tsolve(c,0);\n\t\tprintf(\"%lld\\n\",nume[c][2]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  static constexpr T mod = MOD;\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n\n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n\n  Mint inv(){return pow(MOD-2);}\n\n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n\n  Mint operator+(Mint a) const{return Mint(v)+=a;}\n  Mint operator-(Mint a) const{return Mint(v)-=a;}\n  Mint operator*(Mint a) const{return Mint(v)*=a;}\n  Mint operator/(Mint a) const{return Mint(v)/=a;}\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  static Mint comb(long long n,int k){\n    Mint num(1),dom(1);\n    for(int i=0;i<k;i++){\n      num*=Mint(n-i);\n      dom*=Mint(i+1);\n    }\n    return num/dom;\n  }\n};\ntemplate<typename T,T MOD> constexpr T Mint<T, MOD>::mod;\ntemplate<typename T,T MOD>\nostream& operator<<(ostream &os,Mint<T, MOD> m){os<<m.v;return os;}\n\n\ntemplate<typename F>\nstruct FixPoint : F{\n  FixPoint(F&& f):F(forward<F>(f)){}\n  template<typename... Args>\n  decltype(auto) operator()(Args&&... args) const{\n    return F::operator()(*this,forward<Args>(args)...);\n  }\n};\ntemplate<typename F>\ninline decltype(auto) MFP(F&& f){\n  return FixPoint<F>{forward<F>(f)};\n}\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n//INSERT ABOVE HERE\nsigned main(){\n  using M = Mint<int, 998244353>;\n  auto solve2=\n    [&](vector< vector<int> > G){\n      int n=G.size();\n      vector<int> dep(n),par(n);\n      auto dfs1=\n        MFP([&](auto dfs,int v,int p,int d)->void{\n              dep[v]=d;\n              par[v]=p;\n              for(int u:G[v])\n                if(u!=p) dfs(u,v,d+1);\n            });\n      dfs1(0,-1,0);\n      int s=max_element(dep.begin(),dep.end())-dep.begin();\n      dfs1(s,-1,0);\n      int t=max_element(dep.begin(),dep.end())-dep.begin();\n      int len=dep[t];\n\n      vector<int> vs;\n      vs.emplace_back(t);\n      while(t!=s){\n        t=par[t];\n        vs.emplace_back(t);\n      }\n\n      int cen=vs[vs.size()/2];\n      if(len&1){\n        int x=vs[len/2],y=vs[len/2+1];\n        for(int &z:G[x])\n          if(z==y) swap(z,G[x].back());\n        for(int &z:G[y])\n          if(z==x) swap(z,G[y].back());\n        G[x].back()=n;\n        G[y].back()=n;\n        G.emplace_back();\n        G[n].emplace_back(x);\n        G[n].emplace_back(y);\n        cen=n++;\n        len++;\n      }\n\n      vector<M> dp[3][3];\n      for(int i=0;i<3;i++)\n        for(int j=0;j<3;j++)\n          dp[i][j].assign(n,0);\n\n      MFP([&](auto dfs,int v,int p,int d)->void{\n            dp[d*2==len][d*2==len][v]=1;\n            for(int u:G[v]){\n              if(u==p) continue;\n              dfs(u,v,d+1);\n              M nx[3][3]={};\n              for(int i=0;i<3;i++){\n                for(int j=0;j<3;j++){\n                  for(int x=0;x<3;x++){\n                    for(int y=0;y<3;y++){\n                      for(int z=0;z<3;z++){\n                        int ni=min(i+x*(z==0),2);\n                        int nj=min(j+y*(z==1),2);\n                        nx[ni][nj]+=dp[i][j][v]*dp[x][y][u];\n                      }\n                    }\n                  }\n                }\n              }\n\n              for(int i=0;i<3;i++)\n                for(int j=0;j<3;j++)\n                  dp[i][j][v]=nx[i][j];\n            }\n          })(cen,-1,0);\n\n      return dp[1][1][cen]/2;\n    };\n\n  int n;\n  cin>>n;\n  vector< vector<int> > G(n);\n  for(int i=1;i<n;i++){\n    int x,y;\n    cin>>x>>y;\n    x--;y--;\n    G[x].emplace_back(y);\n    G[y].emplace_back(x);\n  }\n\n  cout<<solve2(G)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[202020];\nconst ll mo=998244353;\nll dp[202020][3][3];\n\npair<int,int> farthest(int cur,int pre,int d,vector<int>& D) {\n\tD[cur]=d;\n\tpair<int,int> r={d,cur};\n\tFORR(e,E[cur]) if(e!=pre) r=max(r, farthest(e,cur,d+1,D));\n\treturn r;\n}\n\npair<int,vector<int>> diameter() { // diameter,center\n\tvector<int> D[2];\n\tD[0].resize(N);\n\tD[1].resize(N);\n\tauto v1=farthest(0,0,0,D[0]);\n\tauto v2=farthest(v1.second,v1.second,0,D[0]);\n\tfarthest(v2.second,v2.second,0,D[1]);\n\tpair<int,vector<int>> R;\n\tR.first = v2.first;\n\t//重心を取る場合\n\tfor(int i=N-1;i>=0;i--) if(D[0][i]+D[1][i]==R.first && abs(D[0][i]-D[1][i])<=1) R.second.push_back(i);\n\n\treturn R;\n}\n\nvoid dfs(int cur,int pre,int lef) {\n\tif(lef==0) {\n\t\tdp[cur][1][1]=1;\n\t}\n\telse {\n\t\tdp[cur][0][0]=1;\n\t}\n\t\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\tdfs(e,cur,lef-1);\n\t\tll to[3][3]={};\n\t\tint a1,a2,b1,b2;\n\t\tFOR(a1,3) FOR(a2,3) FOR(b1,3) FOR(b2,3) {\n\t\t\t// +1\n\t\t\tto[min(a1+b1,2)][a2]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t\t// 0\n\t\t\tto[a1][a2]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t\t// -1\n\t\t\tto[a1][min(a2+b2,2)]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t}\n\t\t\n\t\tFOR(a1,3) FOR(a2,3) dp[cur][a1][a2]=to[a1][a2]%mo;\n\t}\n\t\n\t\n\t\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tauto R=diameter();\n\tif(R.second.size()==1) {\n\t\tx=R.second[0];\n\t\tdfs(x,-1,R.first/2);\n\t\tcout<<dp[x][1][1]*((mo+1)/2)%mo<<endl;\n\t}\n\telse {\n\t\tx=R.second[0];\n\t\ty=R.second[1];\n\t\tdfs(x,y,R.first/2);\n\t\tdfs(y,x,R.first/2);\n\t\tassert(0);\n\t\tcout<<dp[x][0][1]*dp[y][1][0]%mo<<endl;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<ll,ll>\n#define poly vector<ll>\n#define mem(a) memset((a),0,sizeof(a))\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\n#define SZ(x) ((int)(x.size()))\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\nll rnd(){\n\tull ans=0;\n\tFor(i,0,4)ans=ans<<15^rand();\n\treturn ans%((ull)1<<63);\n}\nconst int N=200005,mod=998244353;\nint n,rt,dep[N],mx[N],fa[N];\nll dp[N][3],jb[3];\nvector<int> v[N];\ninline void add(ll &a,ll b){\n\ta=(a+b)%mod;\n}\nvoid dfs(int p){\n\tdep[p]=dep[fa[p]]+1;\n\tif(dep[p]>dep[rt])rt=p;\n\tfor(auto i:v[p])if(i!=fa[p]){\n\t\tfa[i]=p; dfs(i);\n\t}\n}\nvoid solve(int rt,int fa){\n\tdp[rt][v[rt].size()==1]=1;\n\tfor(auto i:v[rt])if(i!=fa){\n\t\tsolve(i,rt); mx[rt]=max(mx[rt],mx[i]+1);\n\t}\n\tfor(auto i:v[rt])if(i!=fa){\n\t\tif(mx[i]+1!=mx[rt]){\n\t\t\tdp[i][0]+=dp[i][1]; dp[i][1]=0;\n\t\t}\n\t\tmem(jb);\n\t\tRep(j,1,0){\n\t\t\tRep(k,1,0)if(j+k<=1)add(jb[j+k],dp[rt][j]*dp[i][k]);\n\t\t}\n\t\tswap(jb,dp[rt]);\n\t}\n\tdp[rt][0]=(dp[rt][0]*3+dp[rt][1]*2)%mod;\n}\nint main(){\n\t#ifdef Brollan\n\t\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tn=read(); \n\tFor(i,1,n-1){\n\t\tint s=read(),t=read();\n\t\tv[s].pb(t); v[t].pb(s);\n\t}\n\t\n\tdfs(1);\n\tint t=rt; rt=0; fa[t]=0;\n\tdfs(t);\n\tint len=dep[rt];//cerr<<t<<\" \"<<rt<<\" \"<<dep[rt]<<endl;\n\tFor(j,1,len/2)rt=fa[rt];\n\tif(len%2==0){\n\t\tint A=rt,B=fa[rt];\n\t\tsolve(A,B);\n\t\tsolve(B,A);\n\t\tcout<<dp[A][1]*dp[B][1]%mod<<endl;\n\t}else{\n\t\tdp[rt][0]=1;\n\t\tfor(auto i:v[rt]){\n\t\t\tsolve(i,rt); if(mx[i]+1<len/2){dp[i][0]+=dp[i][1]; dp[i][1]=0;}\n\t\t\t//cout<<mx[i]+1<<\" \"<<len/2<<\" \"<<dp[i][1]<<\" \"<<dp[i][0]<<\" \"<<dp[rt][1]<<endl;\n\t\t\tmem(jb);\n\t\t\tRep(j,2,0)Rep(k,1,0){\n\t\t\t\tif(j+k<=2)add(jb[j+k],dp[rt][j]*dp[i][k]);\n\t\t\t}\n\t\t\tswap(jb,dp[rt]);\n\t\t}\n\t\tcout<<dp[rt][2]<<endl;\n\t}\n}\n/*\nt t+1 (a+1)t+a+b+1\nc(at+b)+d\na(ct+d)+b\nact+bc+d\nact+ad+b\nb/(a-1)<d/(c-1)\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 2e5 + 5, mod = 998244353;\n\ninline int gi()\n{\n\tchar c = getchar();\n\twhile (c < '0' || c > '9') c = getchar();\n\tint sum = 0;\n\twhile ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();\n\treturn sum;\n}\n\ninline void inc(int &a, int b) {a += b; if (a >= mod) a -= mod;}\n\nint n, rt, len, fa[maxn], ch[maxn];\n\nstruct edge\n{\n\tint to, next;\n} e[maxn * 2];\nint h[maxn], tot;\nint md[maxn], f[maxn][3][3], g[3][3];\n\ninline void add(int u, int v)\n{\n\te[++tot] = (edge) {v, h[u]}; h[u] = tot;\n\te[++tot] = (edge) {u, h[v]}; h[v] = tot;\n}\n\nvoid dfs1(int u, int d)\n{\n\tif (d > len) rt = u, len = d;\n\tmd[u] = d;\n\tfor (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n\t\tif (v != fa[u]) fa[v] = u, dfs1(v, d + 1), md[u] = max(md[u], md[v]);\n}\n\nvoid dfs2(int u, int d)\n{\n\t(md[u] == d ? f[u][1][1] : f[u][0][0]) = 1;\n\tfor (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n\t\tif (v != fa[u]) {\n\t\t\tfa[v] = u; dfs2(v, d + 1);\n\t\t\tmemset(g, 0, sizeof(g));\n\t\t\tfor (int a = 0; a < 2; ++a)\n\t\t\t\tfor (int b = 0; b < 2; ++b)\n\t\t\t\t\tfor (int c = 0; c < 2; ++c)\n\t\t\t\t\t\tfor (int d = 0; d <= 2; ++d)\n\t\t\t\t\t\t\tfor (int t = -1; t <= 1; ++t)\n\t\t\t\t\t\t\t\tinc(g[min(2, a + (md[v] == md[u] && t == 1) * c)][min(2, b + (md[v] == md[u] && t == -1) * d)], (ll)f[u][a][b] * f[v][c][d] % mod);\n\t\t\tmemcpy(f[u], g, sizeof(f[u]));\n\t\t}\n}\n\nint main()\n{\n\tn = gi();\n\tfor (int i = 1; i < n; ++i) add(gi(), gi());\n\n\tdfs1(1, 0);\n\tfa[rt] = 0; len = 0; dfs1(rt, 0);\n\tfor (int i = 0, x = rt; x; x = fa[x]) ch[i++] = x;\n\n\tif (~len & 1) {\n\t\tint x = ch[len >> 1];\n\t\tfa[x] = 0, dfs1(x, 0);\n\t\tdfs2(x, 0);\n\t\tprintf(\"%lld\\n\", (ll)f[x][1][1] * (mod + 1) / 2 % mod);\n\t}\n\telse {\n\t\tint x = ch[len >> 1], y = ch[len + 1 >> 1];\n\t\tfa[x] = y; fa[y] = x;\n\t\tdfs1(x, 0); dfs2(x, 0);\n\t\tdfs1(y, 0); dfs2(y, 0);\n\t\tprintf(\"%lld\\n\", ((ll)f[x][1][0] + f[x][1][1] + f[x][1][2]) * ((ll)f[y][1][0] + f[y][1][1] + f[y][1][2]) % mod);\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\n\nint n;\nvector<int> G[1 << 18];\n\nint mostfar(int x) {\n\tqueue<int> q;\n\tvector<bool> used(n, false);\n\tused[x] = true; q.push(x);\n\tint res = x;\n\twhile (!q.empty()) {\n\t\tint id = q.front(); q.pop();\n\t\tres = id;\n\t\trep(j, G[id].size()) {\n\t\t\tint to = G[id][j];\n\t\t\tif (used[to])continue;\n\t\t\tused[to] = true;\n\t\t\tq.push(to);\n\t\t}\n\t}\n\treturn res;\n}\n\nvector<int> make_road(int l, int r) {\n\tvector<int> res;\n\tfunction<bool(int, int)> dfs = [&](int id, int fr)->bool {\n\t\tif (id == r) {\n\t\t\tres.push_back(id); return true;\n\t\t}\n\t\trep(j, G[id].size()) {\n\t\t\tint to = G[id][j]; if (to == fr)continue;\n\t\t\tif (dfs(to, id)) {\n\t\t\t\tres.push_back(id); return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\tdfs(l, -1);\n\treturn res;\n}\n\nbool onroad[1 << 18];\nbool marked[1 << 18];\nvoid mark(int id, int fr, int k, int dep) {\n\tif (dep == k)marked[id] = true;\n\trep(j, G[id].size()) {\n\t\tint to = G[id][j];\n\t\tif (to == fr)continue;\n\t\tmark(to, id, k, dep + 1);\n\t}\n}\nusing dpval = vector<ll>;\n\ndpval merge(dpval &a, dpval &b) {\n\tdpval res = { 0,0,0 };\n\trep(i, 3) {\n\t\trep(j, 3) {\n\t\t\tif (i == 2 && j == 2) {\n\t\t\t\t(res[2] += a[2] * b[2]) %= mod;\n\t\t\t}\n\t\t\telse if (i*j == 2) {\n\t\t\t\t(res[1] += a[i] * b[j]) %= mod;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t(res[0] += a[i] * b[j]) %= mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nvoid update(dpval &a) {\n\tdpval nex = { 0,0,0 };\n\tnex[0] = a[0];\n\tnex[1] = a[1];\n\tnex[2] = a[0] * 2 + a[1] * 2 + a[2] * 3; nex[2] %= mod;\n\tswap(a, nex);\n}\ndpval dfs(int id, int fr) {\n\tdpval res = { 0,0,1 };\n\tif (marked[id])res = { 0,1,0 };\n\trep(j, G[id].size()) {\n\t\tint to = G[id][j];\n\t\tif (to == fr)continue;\n\t\tdpval nex = dfs(to, id);\n\t\tres = merge(res, nex);\n\t}\n\tupdate(res);\n\treturn res;\n}\nvoid solve() {\n\tcin >> n;\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tif (n == 2) {\n\t\tcout << 1 << endl; return;\n\t}\n\tint r = 0;\n\tint l = mostfar(r);\n\tr = mostfar(l);\n\tvector<int> v = make_road(l, r);\n\tint len = v.size();\n\trep(i, len)onroad[v[i]] = true;\n\trep(i, len) {\n\t\tint r = v[i];\n\t\trep(j, G[r].size()) {\n\t\t\tint to = G[r][j];\n\t\t\tif (!onroad[to]) {\n\t\t\t\tint m = min(i, len - 1 - i);\n\t\t\t\tmark(to, r, m, 1);\n\t\t\t}\n\t\t}\n\t}\n\tmarked[v[0]] = marked[v[len - 1]] = true;\n\tif (len % 2) {\n\t\tint m = v[len / 2];\n\t\tvector<LP> pv;\n\t\trep(j, G[m].size()) {\n\t\t\tint to = G[m][j];\n\t\t\tdpval nex = dfs(to, m);\n\t\t\tnex[2] -= (nex[0] + nex[1]);\n\t\t\twhile (nex[2] < 0)nex[2] += mod;\n\t\t\tLP cur = { nex[1],nex[2] };\n\t\t\tpv.push_back(cur);\n\t\t}\n\t\tll ans = 0;\n\t\tvector<int> zeros;\n\t\trep(i, pv.size()) {\n\t\t\tswap(pv[i].first, pv[i].second);\n\t\t\t//cout << pv[i].first << \" \" << pv[i].second << endl;\n\t\t\tif (pv[i].first == 0)zeros.push_back(i);\n\t\t}\n\t\t/*if (zeros.size() >= 3)ans = 0;\n\t\telse if (zeros.size() == 2) {\n\t\t\tans = 1;\n\t\t\trep(i, pv.size()) {\n\t\t\t\tif (pv[i].first == 0)ans = ans * pv[i].second%mod;\n\t\t\t\telse ans = ans * pv[i].first%mod;\n\t\t\t}\n\t\t}\n\t\telse if (zeros.size() == 1) {\n\t\t\tll al = 1;\n\t\t\trep(i, pv.size()) {\n\t\t\t\tif (pv[i].first > 0)al = al * pv[i].first%mod;\n\t\t\t\telse al = al * pv[i].second%mod;\n\t\t\t}\n\t\t\trep(i, pv.size()) {\n\t\t\t\tif (pv[i].first > 0) {\n\t\t\t\t\tll csum = al * pv[i].second%mod*mod_pow(pv[i].first, mod - 2) % mod;\n\t\t\t\t\tans += csum;\n\t\t\t\t\tif (ans >= mod)ans -= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\t//else {\n\t\t\tvector<ll> rpv(pv.size() + 1);\n\t\t\trep(i, pv.size()) {\n\t\t\t\tll c = pv[i].second*mod_pow(pv[i].first, mod - 2) % mod;\n\t\t\t\t(rpv[i + 1] += rpv[i] + c) %= mod;\n\t\t\t}\n\t\t\tll al = 1;\n\t\t\trep(i, pv.size())al = al * pv[i].first%mod;\n\t\t\trep(i, pv.size()) {\n\t\t\t\tll pre = al * pv[i].second%mod*mod_pow(pv[i].first, mod - 2) % mod;\n\t\t\t\tll z = rpv[pv.size()] - rpv[i + 1]; if (z < 0)z += mod;\n\t\t\t\tpre = pre * z%mod;\n\t\t\t\tans += pre; if (ans >= mod)ans -= mod;\n\t\t\t}\n\t\t//}\n\t\tcout << ans << endl;\n\t}\n\telse {\n\t\tint m1 = v[len / 2 - 1], m2 = v[len / 2];\n\t\tdpval v1 = { 0,0,1 }, v2 = { 0,0,1 };\n\t\trep(j, G[m1].size()) {\n\t\t\tint to = G[m1][j];\n\t\t\tif (to == m2)continue;\n\t\t\tdpval nex = dfs(to, m1);\n\t\t\tv1 = merge(v1, nex);\n\t\t}\n\t\trep(j, G[m2].size()) {\n\t\t\tint to = G[m2][j];\n\t\t\tif (to == m1)continue;\n\t\t\tdpval nex = dfs(to, m2);\n\t\t\tv2 = merge(v2, nex);\n\t\t}\n\t\tll ans = v1[1] * v2[1] % mod;\n\t\tcout << ans << endl;\n\t}\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(17);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[202020];\nconst ll mo=998244353;\nll dp[202020][3][3];\n\npair<int,int> farthest(int cur,int pre,int d,vector<int>& D) {\n\tD[cur]=d;\n\tpair<int,int> r={d,cur};\n\tFORR(e,E[cur]) if(e!=pre) r=max(r, farthest(e,cur,d+1,D));\n\treturn r;\n}\n\npair<int,vector<int>> diameter() { // diameter,center\n\tvector<int> D[2];\n\tD[0].resize(N);\n\tD[1].resize(N);\n\tauto v1=farthest(0,0,0,D[0]);\n\tauto v2=farthest(v1.second,v1.second,0,D[0]);\n\tfarthest(v2.second,v2.second,0,D[1]);\n\tpair<int,vector<int>> R;\n\tR.first = v2.first;\n\t//重心を取る場合\n\tfor(int i=N-1;i>=0;i--) if(D[0][i]+D[1][i]==R.first && abs(D[0][i]-D[1][i])<=1) R.second.push_back(i);\n\n\treturn R;\n}\n\nvoid dfs(int cur,int pre,int lef) {\n\tif(lef==0) {\n\t\tdp[cur][1][1]=1;\n\t}\n\telse {\n\t\tdp[cur][0][0]=1;\n\t}\n\t\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\tdfs(e,cur,lef-1);\n\t\tll to[3][3]={};\n\t\tint a1,a2,b1,b2;\n\t\tFOR(a1,3) FOR(a2,3) FOR(b1,3) FOR(b2,3) {\n\t\t\t// +1\n\t\t\tto[min(a1+b1,2)][a2]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t\t// 0\n\t\t\tto[a1][a2]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t\t// -1\n\t\t\tto[a1][min(a2+b2,2)]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t}\n\t\t\n\t\tFOR(a1,3) FOR(a2,3) dp[cur][a1][a2]=to[a1][a2]%mo;\n\t}\n\t\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tauto R=diameter();\n\tif(R.second.size()==1) {\n\t\tx=R.second[0];\n\t\tdfs(x,-1,R.first/2);\n\t\tcout<<dp[x][1][1]*((mo+1)/2)%mo<<endl;\n\t}\n\telse {\n\t\tx=R.second[0];\n\t\ty=R.second[1];\n\t\tdfs(x,y,R.first/2);\n\t\tdfs(y,x,R.first/2);\n\t\tassert(dp[x][1][1]==0);\n\t\tassert(dp[y][1][1]==0);\n\t\tcout<<dp[x][0][1]*dp[y][1][0]%mo<<endl;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 200005\n#define MOD 998244353\nusing namespace std;\ntypedef pair <int,int> P;\ntypedef long long int ll;\n\nvector <int> vec[SIZE];\nint par[SIZE];\nint dep[SIZE];\nll dp[SIZE][2][2];\nll cur[2][2];\nP farthest(int v,int p=-1,int d=0)\n{\n\tpar[v]=p;\n\tP ret=P(d,v);\n\tfor(int i=0;i<vec[v].size();i++)\n\t{\n\t\tint to=vec[v][i];\n\t\tif(to!=p) ret=max(ret,farthest(to,v,d+1));\n\t}\n\treturn ret;\n}\nvoid add(int a,int b)\n{\n\tvec[a].push_back(b);\n\tvec[b].push_back(a);\n}\nvoid dfs(int v,int p)\n{\n\tdep[v]=0;\n\tdp[v][1][1]=1;\n\tfor(int i=0;i<vec[v].size();i++)\n\t{\n\t\tint to=vec[v][i];\n\t\tif(to!=p)\n\t\t{\n\t\t\tdfs(to,v);\n\t\t\tint d=dep[to]+1;\n\t\t\tif(dep[v]<d)\n\t\t\t{\n\t\t\t\tll all=0;\n\t\t\t\tfor(int x=0;x<2;x++)\n\t\t\t\t{\n\t\t\t\t\tfor(int y=0;y<2;y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tall+=dp[v][x][y];\n\t\t\t\t\t\tdp[v][x][y]=0;\n\t\t\t\t\t\tif(all>=MOD) all-=MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[v][0][0]=all;\n\t\t\t\tdep[v]=d;\n\t\t\t}\n\t\t\tif(d<dep[v])\n\t\t\t{\n\t\t\t\tll w=(dp[to][0][0]+dp[to][1][0]+dp[to][0][1]+dp[to][1][1])*3LL%MOD;\n\t\t\t\tfor(int x=0;x<2;x++)\n\t\t\t\t{\n\t\t\t\t\tfor(int y=0;y<2;y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[v][x][y]=dp[v][x][y]*w%MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmemset(cur,0,sizeof(cur));\n\t\t\t\tfor(int x=0;x<2;x++)\n\t\t\t\t{\n\t\t\t\t\tfor(int y=0;y<2;y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tll w=dp[to][x][y];\n\t\t\t\t\t\tfor(int a=0;a<2;a++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int b=0;b<2;b++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcur[a][b]+=dp[v][a][b]*w%MOD;\n\t\t\t\t\t\t\t\tcur[a][1&y]+=dp[v][a][b]*w%MOD;\n\t\t\t\t\t\t\t\tcur[1&x][b]+=dp[v][a][b]*w%MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int x=0;x<2;x++)\n\t\t\t\t{\n\t\t\t\t\tfor(int y=0;y<2;y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[v][x][y]=cur[x][y]%MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d %d\",&a,&b);a--,b--;\n\t\tadd(a,b);\n\t}\n\tP p=farthest(0);\n\tP q=farthest(p.second);\n\tvector <int> vx;\n\tint now=q.second;\n\twhile(now!=-1)\n\t{\n\t\t//printf(\"* %d\\n\",now);\n\t\tvx.push_back(now);\n\t\tnow=par[now];\n\t}\n\tint rt=vx[vx.size()/2];\n\tif(vx.size()%2==0)\n\t{\n\t\tn++;\n\t\tint l=vx[vx.size()/2-1],r=vx[vx.size()/2];\n\t\tvector <int> nv;\n\t\tfor(int i=0;i<vec[l].size();i++) if(vec[l][i]!=r) nv.push_back(vec[l][i]);\n\t\tvec[l]=nv;\n\t\tnv.clear();\n\t\tfor(int i=0;i<vec[r].size();i++) if(vec[r][i]!=l) nv.push_back(vec[r][i]);\n\t\tvec[r]=nv;\n\t\tnv.clear();\n\t\tadd(n-1,l);\n\t\tadd(n-1,r);\n\t\trt=n-1;\n\t}\n\tdfs(rt,-1);\n\tll ret=dp[rt][1][1];\n\tif(ret%2==1) ret+=MOD;\n\tret/=2;\n\tprintf(\"%lld\\n\",ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define R register\n#define mp make_pair\n#define ll long long\n#define pii pair<int, int>\nusing namespace std;\nconst int N = 210000, mod = 998244353;\n\nint n, dis[N], a, b, p[N];\nll f[N][2];\nvector<int> to[N];\n\ntemplate <class T>\ninline void read(T &x) {\n\tx = 0;\n\tchar ch = getchar(), w = 0;\n\twhile (!isdigit(ch)) w = (ch == '-'), ch = getchar();\n\twhile (isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();\n\tx = w ? -x : x;\n\treturn;\n}\n\ninline void addEdg(int x, int y) {\n\tto[x].push_back(y), to[y].push_back(x);\n\treturn;\n}\n\nvoid dfs1(int now, int fa) {\n\tdis[now] = dis[fa] + 1;\n\tfor (auto &v : to[now]) {\n\t\tif (v == fa) continue;\n\t\tdfs1(v, now);\n\t}\n\treturn;\n}\n\nint dfs2(int now, int fa, int maxD) {\n\tif (dis[now] == maxD) return p[now] = 1;\n\tint ret = 0;\n\tfor (auto &v : to[now]) {\n\t\tif (v == fa) continue;\n\t\tret |= dfs2(v, now, maxD);\n\t}\n\tif (ret) {\n\t\tif (dis[now] == (maxD + 1) >> 1)\n\t\t\ta = now;\n\t\telse if (dis[now] == (maxD >> 1) + 1)\n\t\t\tb = now;\n\t}\n\treturn ret;\n}\n\nvoid dfs3(int now, int fa) {\n\tdis[now] = dis[fa] + 1;\n\tf[now][0] = 1, f[now][1] = p[now];\n\tfor (auto &v : to[now]) {\n\t\tif (v == fa) continue;\n\t\tdfs3(v, now);\n\t\tf[now][1] = (f[now][1] * f[v][0] + f[now][0] * f[v][1]) % mod;\n\t\tf[now][0] = (f[now][0] * f[v][0]) % mod;\n\t}\n\tf[now][0] = f[now][0] * 3 % mod;\n\treturn;\n}\n\nint main() {\n\tint x, y;\n\tread(n);\n\tfor (R int i = 1; i < n; ++i)\n\t\tread(x), read(y), addEdg(x, y);\n\tdfs1(1, 0);\n\tint rt = 1, maxD = 1;\n\tfor (R int i = 2; i <= n; ++i)\n\t\tif (dis[i] > maxD) maxD = dis[i], rt = i;\n\tdfs1(rt, 0), maxD = 1;\n\tfor (R int i = 1; i <= n; ++i)\n\t\tmaxD = max(maxD, dis[i]);\n\tdfs2(rt, 0, maxD), p[rt] = 1;\n\t//for (R int i = 1; i <= n; ++i) cout << \"QwQ \" << i << ' ' << p[i] << endl;\n\tif (b) {\n\t\tdis[a] = 0, dfs3(b, a);\n\t\tdis[b] = 0, dfs3(a, b);\n\t\tprintf(\"%lld\\n\", f[a][1] * f[b][1] % mod);\n\t}\n\telse {\n\t\tf[a][0] = 1, dis[a] = 1;\n\t\tll ans = 0;\n\t\tfor (auto &v : to[a]) {\n\t\t\tdfs3(v, a);\n\t\t\tf[v][0] = (f[v][0] - 2 * f[v][1] + 2 * mod) % mod;\n//\t\t\tcout << \"qwq \" << v << ' ' << f[v][0] << ' ' << f[v][1] << endl;\n\t\t\tans = (ans * f[v][0] + f[a][1] * f[v][1]) % mod;\n\t\t\tf[a][1] = (f[a][1] * f[v][0] + f[a][0] * f[v][1]) % mod;\n\t\t\tf[a][0] = (f[a][0] * f[v][0]) % mod;\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define N 300000\n\nconst LL mod=998244353;\nLL n,f[N][2][2],g[2][2],d[N],m,mx,rt,fa[N];\nvector<LL> e[N];\n\nvoid dfs(LL u,LL dist){\n\tif (dist>mx){mx=dist; rt=u;}\n\tfor (LL v:e[u])\n\t\tif (v!=fa[u]){\n\t\t\tfa[v]=u;\n\t\t\tdfs(v,dist+1);\n\t\t}\n}\n\nLL inv(LL x){return x==1?1:(mod-mod/x)*inv(mod%x)%mod;}\n\nvoid upd(LL &x,LL y){x=(x+y)%mod;}\n\nvoid dp(LL u,LL dist){\n\tif (dist==m/2) f[u][1][1]=1;\n\telse f[u][0][0]=1;\n\tfor (LL v:e[u])\n\t\tif (v!=fa[u]){\n\t\t\tfa[v]=u;\n\t\t\tdp(v,dist+1);\n\t\t\tmemset(g,0,sizeof g);\n\t\t\tfor (LL i1:{0,1}) for (LL i2:{0,1}) for (LL j1:{0,1}) for (LL j2:{0,1})\n\t\t\t\tfor (LL k=0;k<=2;++k){\n\t\t\t\t\tLL t1=j1&&k==1,t2=j2&&k==2;\n\t\t\t\t\tif ((i1&&t1)||(i2&&t2)) continue;\n\t\t\t\t\tupd(g[i1|t1][i2|t2],f[u][i1][i2]*f[v][j1][j2]);\n\t\t\t\t}\n\t\t\tmemcpy(f[u],g,sizeof f[u]);\n\t\t}\n}\n\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor (LL i=1;i<n;++i){\n\t\tLL x,y; scanf(\"%lld%lld\",&x,&y);\n\t\te[x].push_back(y);\n\t\te[y].push_back(x);\n\t}\n\tdfs(1,1);\n\tmemset(fa,0,sizeof fa); mx=0;\n\tdfs(rt,1);\n\tfor (LL i=rt;i;i=fa[i]) d[++m]=i;\n\tmemset(fa,0,sizeof fa);\n\tif (m&1){\n\t\tLL p=d[m/2+1];\n\t\tdp(p,0);\n\t\tprintf(\"%lld\\n\",f[p][1][1]*inv(2)%mod);\n\t}\n\telse{\n\t\tLL p1=d[m/2],p2=d[m/2+1];\n\t\tfa[p1]=p2; fa[p2]=p1;\n\t\tdp(p1,1); dp(p2,1);\n\t\tprintf(\"%lld\\n\",f[p1][1][0]*f[p2][1][0]%mod);\n\t}\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\ndouble startTime;\ndouble getCurrentTime() {\n\treturn ((double)clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst ll MOD = (ll)998244353;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\n\nconst int N = 200200;\nint n;\nvector<int> g[N];\nll ANS;\nint dist[N];\nint q[N];\nint par[N];\nint topQ;\nint D;\nll dp[N][3];\n\nvoid BFS(int v) {\n\tfor (int i = 0; i < n; i++)\n\t\tdist[i] = N;\n\tdist[v] = 0;\n\ttopQ = 0;\n\tq[topQ++] = v;\n\tfor (int i = 0; i < topQ; i++) {\n\t\tv = q[i];\n\t\tfor (int u : g[v]) {\n\t\t\tif (dist[u] <= dist[v] + 1) continue;\n\t\t\tdist[u] = dist[v] + 1;\n\t\t\tpar[u] = v;\n\t\t\tq[topQ++] = u;\n\t\t}\n\t}\n}\n\nvoid dfs(int v, int p) {\n\tdp[v][0] = dp[v][1] = dp[v][2] = 0;\n\tif ((int)g[v].size() == 1) {\n\t\tdp[v][(int)(dist[v] == D)] = 1;\n\t\t//dp[v][0] = add(dp[v][0], 2);\n\t\treturn;\n\t}\n\tdp[v][0] = 1;\n\tll inner[3];\n\tfor (int u : g[v]) {\n\t\tif (u == p) continue;\n\t\tinner[0] = inner[1] = inner[2] = 0;\n\t\tdfs(u, v);\n\t\tll w[2];\n\t\tw[0] = w[1] = 0;\n\t\tw[0] = add(mult(3, dp[u][0]), mult(2, add(dp[u][2], dp[u][1])));\n\t\tw[1] = dp[u][1];\n\t\tfor (int x = 0; x < 3; x++)\n\t\t\tfor (int y = 0; y < 2; y++) {\n\t\t\t\tif (x + y < 3)\n\t\t\t\t\tinner[x + y] = add(inner[x + y], mult(dp[v][x], w[y]));\n\t\t\t}\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tdp[v][i] = inner[i];\n\t}\n}\n\nvoid solveVertex(int v) {\n\teprintf(\"solveVertex %d\\n\", v);\n\tD /= 2;\n\tBFS(v);\n\tll inner[2][3];\n\tfor (int i = 0; i < 2; i++)\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tinner[i][j] = 0;\n\tinner[0][0] = 1;\n\tfor (int u : g[v]) {\n\t\tdfs(u, v);\n\t\tll w[2];\n\t\tw[0] = w[1] = 0;\n\t\tw[0] = add(mult(3, dp[u][0]), add(mult(2, dp[u][2]), dp[u][1]));\n\t\tw[1] = dp[u][1];\n\t\teprintf(\"%lld %lld\\n\", w[0], w[1]);\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tinner[1][i] = 0;\n\t\tfor (int x = 0; x < 3; x++)\n\t\t\tfor (int y = 0; y < 2; y++)\n\t\t\t\tif (x + y < 3)\n\t\t\t\t\tinner[1][x + y] = add(inner[1][x + y], mult(inner[0][x], w[y]));\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tinner[0][i] = inner[1][i];\n\t}\n\tll ans = inner[0][2];\n\tprintf(\"%lld\\n\", ans);\n}\nvoid solveEdge(int v, int u) {\n\teprintf(\"solveEdge %d %d\\n\", v, u);\n\tD /= 2;\n\tll ans = 1;\n\tfor (int k = 0; k < 2; k++) {\n\t\tBFS(v);\n\t\tdfs(v, u);\n\t\tans = mult(ans, dp[v][1]);\n\t\tswap(v, u);\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tstartTime = (double)clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\n\tBFS(0);\n\tint V = q[n - 1];\n\tBFS(V);\n\tint U = q[n - 1];\n\tD = dist[U];\n\n\tif (D & 1) {\n\t\tint v = U;\n\t\tfor (int i = 0; i < D / 2; i++)\n\t\t\tv = par[v];\n\t\tsolveEdge(v, par[v]);\n\t} else {\n\t\tint v = U;\n\t\tfor (int i = 0; i < D / 2; i++)\n\t\t\tv = par[v];\n\t\tsolveVertex(v);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+5,mo=998244353,inv=499122177;\nstruct Edge{\n\tint next,to;\n}edge[N*2];\nint fi[N],se,rt,mx,fa[N],f[N][3][3],tmp[3][3];\n//f[i][j][k]±íÊ¾i×ÓÊ÷ÖÐÓÐ´ïµ½d==-m/2ºÍm/2Éî¶ÈµÄ½Úµã¸öÊý(2´ú±í¶à¸ö\n//it's easy to prove f[i][j][k]=f[i][k][j]\ninline void add_edge(int u,int v){edge[++se].next=fi[u],fi[u]=se,edge[se].to=v;}\ninline void add(int u,int v){add_edge(u,v),add_edge(v,u);}\nvoid dfs(int x,int d){\n\tif(d>mx)mx=d,rt=x;\n\tfor(int i=fi[x];i;i=edge[i].next){\n\t\tint v=edge[i].to;if(v==fa[x])continue;\n\t\tfa[v]=x,dfs(v,d+1);\n\t}\n}\nvoid dp(int x,int d,int fa){\n\tif(d==mx/2)f[x][1][1]=1;\n\telse f[x][0][0]=1;\n\tfor(int i=fi[x];i;i=edge[i].next){\n\t\tint v=edge[i].to;if(v==fa)continue;\n\t\tdp(v,d+1,x);\n\t\tmemset(tmp,0,sizeof(tmp));\n\t\tfor(int t1:{0,1,2})for(int t2:{0,1,2})for(int s1:{0,1,2})for(int s2:{0,1,2}){\n\t\t\tfor(int k:{0,1,2}){//0 indicate d[u]==d[v],1 indicate d[v]==d[u]-1,2 indicate d[v]==d[u]+1\n\t\t\t\tint w1=min(2,t1+s1*(k==1)),w2=min(2,t2+s2*(k==2));\n\t\t\t\t(tmp[w1][w2]+=1ll*f[x][t1][t2]*f[v][s1][s2]%mo)%=mo;\n\t\t\t}\n\t\t}\n\t\tmemcpy(f[x],tmp,sizeof(tmp));\n\t}\n}\nint main(){\n\tint n,u,v;scanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)scanf(\"%d%d\",&u,&v),add(u,v);\n\tdfs(1,0);\n\tmx=fa[rt]=0,dfs(rt,0);\n\tfor(int i=0;i<mx/2;i++)rt=fa[rt];\n\tif(mx&1){\n\t\tu=rt,v=fa[rt];\n\t\tdp(u,0,v),dp(v,0,u);\n\t\tprintf(\"%d\\n\",(1ll*f[u][1][0]+f[u][1][1]+f[u][1][2])*(1ll*f[v][1][0]+f[v][1][1]+f[v][1][2])%mo);\n\t}\n\telse{\n\t\tdp(rt,0,0);\n\t\tprintf(\"%d\\n\",1ll*f[rt][1][1]*inv%mo);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200100\nusing namespace std;\nvector<int> g[N];\nlong long to_leaf[N],p3sz[N],nume[N][3];\nconst int Q=998244353;\nint find_c(int u,int p){\n\tint mx[2]={u,u},ans=0,tans;\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint v=g[u][i];\n\t\tif(v==p) continue;\n\t\ttans=find_c(v,u);\n\t\tif(tans>ans){\n\t\t\tans=tans;\n\t\t}\n\t\tif(to_leaf[v]>to_leaf[mx[0]]){\n\t\t\tmx[1]=mx[0];\n\t\t\tmx[0]=v;\n\t\t}\n\t\telse if(to_leaf[v]>to_leaf[mx[1]]){\n\t\t\tmx[1]=v;\n\t\t}\n\t}\n\tif(to_leaf[mx[0]]+to_leaf[mx[1]]>ans){\n\t\tans=to_leaf[mx[0]]+to_leaf[mx[1]];\n\t}\n\tto_leaf[u]=to_leaf[mx[0]]+1;\n\treturn ans;\n}\nvoid build(int u,int p){\n\tto_leaf[u]=0;\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint v=g[u][i];\n\t\tif(v==p) continue;\n\t\tbuild(v,u);\n\t\tto_leaf[u]=max(to_leaf[u],to_leaf[v]+1);\n\t}\n}\nvoid solve(int u,int p){\n\tp3sz[u]=1;\n\tif(!to_leaf[u]){\n\t\tnume[u][1]=1;\n\t\treturn;\n\t}\n\tnume[u][0]=1;\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint v=g[u][i];\n\t\tif(v==p) continue;\n\t\tsolve(v,u);\n\t\tif(to_leaf[v]+1==to_leaf[u]){\n\t\t\tfor(int j=2;j>=0;j--){\n\t\t\t\tnume[u][j]=(2LL*p3sz[v]+nume[v][0])*nume[u][j]%Q;\n\t\t\t\tif(j){\n\t\t\t\t\tnume[u][j]+=1LL*nume[v][1]*nume[u][j-1]%Q;\n\t\t\t\t\tnume[u][j]%=Q;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tnume[u][j]=3LL*p3sz[v]*nume[u][j]%Q;\n\t\t\t}\n\t\t}\n\t\tp3sz[u]=3LL*p3sz[v]*p3sz[u]%Q;\n\t}\n}\nint main(){\n\tint n,x,y;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tint l,p=0,c=1;\n\tl=find_c(1,0);\n\tbool flag=true;\n\twhile(flag){\n\t\tflag=false;\n\t\tfor(int i=0;i<g[c].size();i++){\n\t\t\tif(g[c][i]!=p && to_leaf[g[c][i]]>(l+1)/2){\n\t\t\t\tp=c;\n\t\t\t\tc=g[c][i];\n\t\t\t\tflag=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"diameter=%d\\n\",l);\n\tif(l&1){\n\t\tint d=-1;\n\t\tfor(int i=0;i<g[c].size();i++){\n\t\t\tif(to_leaf[g[c][i]]==(l+1)/2){\n\t\t\t\td=g[c][i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//printf(\"center: %d %d\\n\",c,d);\n\t\tassert(d>0);\n\t\tbuild(c,d);\n\t\tsolve(c,d);\n\t\tbuild(d,c);\n\t\tsolve(d,c);\n\t\tprintf(\"%lld\\n\",1LL*nume[c][1]*nume[d][1]%Q);\n\t}\n\telse{\n\t\t//printf(\"center: %d\\n\",c);\n\t\tbuild(c,0);\n\t\tsolve(c,0);\n\t\tprintf(\"%lld\\n\",nume[c][2]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define N_ 201000\nusing namespace std;\nint n, D1[N_], D2[N_], MD, C[N_], DD[N_];\nlong long po[N_], D[N_][3], Mod = 998244353;\nvector<int>E[N_];\nvoid DFS(int a, int pp, int *d) {\n\tfor (auto &x : E[a]) {\n\t\tif (x == pp)continue;\n\t\td[x] = d[a] + 1;\n\t\tDFS(x, a, d);\n\t}\n}\nvoid Add_Edge(int a, int b) {\n\tE[a].push_back(b);\n\tE[b].push_back(a);\n}\nvoid Del_Edge(int a, int b) {\n\tint sz = E[a].size();\n\tfor (int i = 0; i < sz; i++) {\n\t\tif (E[a][i] == b) {\n\t\t\tswap(E[a][i], E[a][sz - 1]);\n\t\t\tE[a].pop_back();\n\t\t\treturn;\n\t\t}\n\t}\n}\nvoid Go(int a, int pp) {\n\tvector<int>T;\n\tfor (auto &x : E[a]) {\n\t\tif (x == pp)continue;\n\t\tGo(x, a);\n\t\tT.push_back(x);\n\t}\n\tif (T.empty()) {\n\t\tif (DD[a] == MD) {\n\t\t\tD[a][0] = 2, D[a][1] = 1;\n\t\t}\n\t\telse {\n\t\t\tD[a][0] = 3;\n\t\t}\n\t\treturn;\n\t}\n\tD[a][0] = 1, D[a][1] = 0, D[a][2] = 0;\n\tfor (auto &x : T) {\n\t\tlong long d0 = D[a][0] * D[x][0];\n\t\tlong long d1 = D[a][0] * D[x][1] + D[a][1] * D[x][0];\n\t\tlong long d2 = D[a][0] * D[x][2] + D[a][1] * (D[x][1] + D[x][2]) + D[a][2] * (D[x][0] + D[x][1] + D[x][2]);\n\t\tD[a][0] = d0 % Mod, D[a][1] = d1 % Mod, D[a][2] = d2 % Mod;\n\t}\n\tD[a][0] = (D[a][0] * 3 + D[a][1] * 2 + D[a][2] * 2) % Mod;\n}\nint main() {\n\tint i, mid;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i < n; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tE[a].push_back(b);\n\t\tE[b].push_back(a);\n\t}\n\tD1[1] = 0;\n\tDFS(1, 0, D1);\n\tint Mx = -1, a = -1, b = -1;\n\tfor (i = 1; i <= n; i++) {\n\t\tif (Mx < D1[i])Mx = D1[i], a = i;\n\t}\n\tD1[a] = 0;\n\tDFS(a, 0, D1);\n\tMx = -1;\n\tfor (i = 1; i <= n; i++) {\n\t\tif (Mx < D1[i])Mx = D1[i], b = i;\n\t}\n\tD2[b] = 0;\n\tDFS(b, 0, D2);\n\tif (Mx % 2 == 1) {\n\t\tint t1, t2;\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tif (D1[i] + D2[i] == Mx) {\n\t\t\t\tif (D1[i] == Mx / 2) {\n\t\t\t\t\tt1 = i;\n\t\t\t\t}\n\t\t\t\tif (D2[i] == Mx / 2) {\n\t\t\t\t\tt2 = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tDel_Edge(t1, t2); Del_Edge(t2, t1);\n\t\tn++;\n\t\tAdd_Edge(t1, n); Add_Edge(t2, n);\n\t\tD1[a] = 0, D2[b] = 0;\n\t\tDFS(a, 0, D1);\n\t\tDFS(b, 0, D2);\n\t\tMx = D1[b];\n\t}\n\tMD = 1e9;\n\tfor (i = 1; i <= n; i++) {\n\t\tif (max(D1[i], D2[i]) < MD) {\n\t\t\tMD = max(D1[i], D2[i]);\n\t\t\tmid = i;\n\t\t}\n\t}\n\tDFS(mid, 0, DD);\n\tpo[0] = 1;\n\tfor (i = 1; i <= n; i++)po[i] = po[i - 1] * 3 % Mod;\n\tlong long dd[3] = { 1,0,0 };\n\tfor (auto &x : E[mid]) {\n\t\tGo(x, mid);\n\t\tlong long g = (D[x][0] - D[x][1] - D[x][2] + Mod + Mod) % Mod;\n\t\tlong long dd0 = dd[0] * g;\n\t\tlong long dd1 = dd[0] * D[x][1] + dd[1]* g;\n\t\tlong long dd2 = dd[1] * D[x][1] + dd[2] * g;\n\t\tdd[0] = dd0%Mod, dd[1] = dd1 % Mod, dd[2] = dd2 % Mod;\n\t}\n\tprintf(\"%lld\\n\", dd[2]);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define N_ 201000\nusing namespace std;\nint n, D1[N_], D2[N_], MD, C[N_], DD[N_];\nlong long po[N_], D[N_][2], Mod = 998244353;\nvector<int>E[N_];\nvoid DFS(int a, int pp, int *d) {\n\tfor (auto &x : E[a]) {\n\t\tif (x == pp)continue;\n\t\td[x] = d[a] + 1;\n\t\tDFS(x, a, d);\n\t}\n}\nvoid Add_Edge(int a, int b) {\n\tE[a].push_back(b);\n\tE[b].push_back(a);\n}\nvoid Del_Edge(int a, int b) {\n\tint sz = E[a].size();\n\tfor (int i = 0; i < sz; i++) {\n\t\tif (E[a][i] == b) {\n\t\t\tswap(E[a][i], E[a][sz - 1]);\n\t\t\tE[a].pop_back();\n\t\t\treturn;\n\t\t}\n\t}\n}\nvoid Go(int a, int pp) {\n\tvector<int>T;\n\tfor (auto &x : E[a]) {\n\t\tif (x == pp)continue;\n\t\tGo(x, a);\n\t\tT.push_back(x);\n\t}\n\tif (T.empty()) {\n\t\tif (DD[a] == MD) {\n\t\t\tD[a][0] = 2, D[a][1] = 1;\n\t\t}\n\t\telse {\n\t\t\tD[a][0] = 3;\n\t\t}\n\t\treturn;\n\t}\n\tD[a][0] = 1, D[a][1] = 0;\n\tfor (auto &x : T) {\n\t\tlong long d0 = D[a][0] * D[x][0];\n\t\tlong long d1 = D[a][0] * D[x][1] + D[a][1] * D[x][0];\n\t\tD[a][0] = d0 % Mod, D[a][1] = d1 % Mod;\n\t}\n\tD[a][0] = (D[a][0] * 3 + D[a][1] * 2) % Mod;\n}\nint main() {\n\tint i, mid;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i < n; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tE[a].push_back(b);\n\t\tE[b].push_back(a);\n\t}\n\tD1[1] = 0;\n\tDFS(1, 0, D1);\n\tint Mx = -1, a = -1, b = -1;\n\tfor (i = 1; i <= n; i++) {\n\t\tif (Mx < D1[i])Mx = D1[i], a = i;\n\t}\n\tD1[a] = 0;\n\tDFS(a, 0, D1);\n\tMx = -1;\n\tfor (i = 1; i <= n; i++) {\n\t\tif (Mx < D1[i])Mx = D1[i], b = i;\n\t}\n\tD2[b] = 0;\n\tDFS(b, 0, D2);\n\tif (Mx % 2 == 1) {\n\t\tint t1, t2;\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tif (D1[i] + D2[i] == Mx) {\n\t\t\t\tif (D1[i] == Mx / 2) {\n\t\t\t\t\tt1 = i;\n\t\t\t\t}\n\t\t\t\tif (D2[i] == Mx / 2) {\n\t\t\t\t\tt2 = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tDel_Edge(t1, t2); Del_Edge(t2, t1);\n\t\tn++;\n\t\tAdd_Edge(t1, n); Add_Edge(t2, n);\n\t\tD1[a] = 0, D2[b] = 0;\n\t\tDFS(a, 0, D1);\n\t\tDFS(b, 0, D2);\n\t\tMx = D1[b];\n\t}\n\tMD = 1e9;\n\tfor (i = 1; i <= n; i++) {\n\t\tif (max(D1[i], D2[i]) < MD) {\n\t\t\tMD = max(D1[i], D2[i]);\n\t\t\tmid = i;\n\t\t}\n\t}\n\tDFS(mid, 0, DD);\n\tpo[0] = 1;\n\tfor (i = 1; i <= n; i++)po[i] = po[i - 1] * 3 % Mod;\n\tlong long dd[3] = { 1,0,0 };\n\tfor (auto &x : E[mid]) {\n\t\tGo(x, mid);\n\t\tlong long dd0 = dd[0] * D[x][0];\n\t\tlong long dd1 = dd[0] * D[x][1] + dd[1]*D[x][0];\n\t\tlong long dd2 = dd[1] * D[x][1] + dd[2] * D[x][0];\n\t\tdd[0] = dd0%Mod, dd[1] = dd1 % Mod, dd[2] = dd2 % Mod;\n\t}\n\tprintf(\"%lld\\n\", dd[2]);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 2e5 + 5, mod = 998244353;\n\ninline int gi()\n{\n\tchar c = getchar();\n\twhile (c < '0' || c > '9') c = getchar();\n\tint sum = 0;\n\twhile ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();\n\treturn sum;\n}\n\ninline void inc(int &a, int b) {a += b; if (a >= mod) a -= mod;}\n\nint n, rt, len, fa[maxn], ch[maxn];\n\nstruct edge\n{\n\tint to, next;\n} e[maxn * 2];\nint h[maxn], tot;\nint md[maxn], f[maxn][3][3], g[3][3];\n\ninline void add(int u, int v)\n{\n\te[++tot] = (edge) {v, h[u]}; h[u] = tot;\n\te[++tot] = (edge) {u, h[v]}; h[v] = tot;\n}\n\nvoid dfs1(int u, int d)\n{\n\tif (d > len) rt = u, len = d;\n\tmd[u] = d;\n\tfor (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n\t\tif (v != fa[u]) fa[v] = u, dfs1(v, d + 1), md[u] = max(md[u], md[v]);\n}\n\nvoid dfs2(int u, int d)\n{\n\t(md[u] == d ? f[u][1][1] : f[u][0][0]) = 1;\n\tfor (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n\t\tif (v != fa[u]) {\n\t\t\tfa[v] = u; dfs2(v, d + 1);\n\t\t\tmemset(g, 0, sizeof(g));\n\t\t\tfor (int a = 0; a < 2; ++a)\n\t\t\t\tfor (int b = 0; b < 2; ++b)\n\t\t\t\t\tfor (int c = 0; c < 2; ++c)\n\t\t\t\t\t\tfor (int d = 0; d < 2; ++d)\n\t\t\t\t\t\t\tfor (int t = -1; t <= 1; ++t)\n\t\t\t\t\t\t\t\tinc(g[min(2, a + (md[v] == md[u] && t == 1) * c)][min(2, b + (md[v] == md[u] && t == -1) * d)], (ll)f[u][a][b] * f[v][c][d] % mod);\n\t\t\tmemcpy(f[u], g, sizeof(f[u]));\n\t\t}\n}\n\nint main()\n{\n\tn = gi();\n\tfor (int i = 1; i < n; ++i) add(gi(), gi());\n\n\tdfs1(1, 0);\n\tfa[rt] = 0; len = 0; dfs1(rt, 0);\n\tfor (int i = 0, x = rt; x; x = fa[x]) ch[i++] = x;\n\n\tif (~len & 1) {\n\t\tint x = ch[len >> 1];\n\t\tfa[x] = 0, dfs1(x, 0);\n\t\tdfs2(x, 0);\n\t\tprintf(\"%lld\\n\", (ll)f[x][1][1] * (mod + 1) / 2 % mod);\n\t}\n\telse {\n\t\tint x = ch[len >> 1], y = ch[len + 1 >> 1];\n\t\tfa[x] = y; fa[y] = x;\n\t\tdfs1(x, 0); dfs2(x, 0);\n\t\tdfs1(y, 0); dfs2(y, 0);\n\t\tprintf(\"%lld\\n\", ((ll)f[x][1][0] + f[x][1][1] + f[x][1][2]) * ((ll)f[y][1][0] + f[y][1][1] + f[y][1][2]) % mod);\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\n//AGC33 C\ntemplate<class E>\nstruct treediameter{\n\tconst vvc<E>&g;\n\tint r1,r2;\n\tvi d1,d2;\n\tint dia;\n\tvoid dfs(int v,int p,int cur,vi&d){\n\t\td[v]=cur;\n\t\tfor(auto e:g[v])if(e!=p)\n\t\t\tdfs(e,v,cur+1,d);\n\t}\n\ttreediameter(const vvc<E>&gg):g(gg),d1(g.size()),d2(g.size()){\n\t\tdfs(0,-1,0,d1);\n\t\tr1=max_element(all(d1))-d1.bg;\n\t\tdfs(r1,-1,0,d1);\n\t\tr2=max_element(all(d1))-d1.bg;\n\t\tdfs(r2,-1,0,d2);\n\t\tdia=d1[r2];\n\t}\n};\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nstruct modinfo{uint mod,root;};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(int n)const{\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(int x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(int x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(int x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(int x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\nextern constexpr modinfo base{998244353,3};\n//extern constexpr modinfo base{1000000007,0};\nusing mint=modular<base>;\n\nconst int vmax=(1<<21)+10;\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\nstruct res{\n\tint mx;\n\tmint tot,w[2];\n\tvoid show(){\n\t\tdmp(mx);\n\t\tdmp(tot);\n\t\tdmp(w[0]);\n\t\tdmp(w[1]);\n\t}\n};\n\nres advance(res x){\n\tres y;\n\ty.mx=x.mx+1;\n\ty.tot=x.tot*3;\n\ty.w[0]=x.w[0];\n\ty.w[1]=x.w[1];\n\treturn y;\n}\n\nvvc<int> t;\n\nres dfs(int v,int p){\n\tres z;\n\tz.mx=0;\n\tz.tot=1;\n\tz.w[0]=1;\n\tz.w[1]=0;\n\t\n\tfor(auto c:t[v])if(c!=p){\n\t\tauto x=dfs(c,v);\n\t\tx=advance(x);\n\t\t\n\t\tif(z.mx<x.mx){\n\t\t\tz.w[0]=0;\n\t\t\tz.w[1]=0;\n\t\t\tz.mx=x.mx;\n\t\t}\n\t\tif(z.mx>x.mx){\n\t\t\tx.w[0]=0;\n\t\t\tx.w[1]=0;\n\t\t}\n\t\t\n\t\tmint tmp=z.tot-z.w[0]-z.w[1];\n\t\tz.w[1]=z.w[1]*x.tot+z.w[0]*(x.w[0]+x.w[1])+tmp*x.w[1];\n\t\tz.w[0]=z.w[0]*(x.tot-x.w[0]-x.w[1])+tmp*x.w[0];\n\t\tz.tot*=x.tot;\n\t}\n\t\n\treturn z;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n;cin>>n;\n\tt.resize(n);\n\trep(i,n-1){\n\t\tint a,b;cin>>a>>b;\n\t\ta--;b--;\n\t\tt[a].pb(b);\n\t\tt[b].pb(a);\n\t}\n\t\n\tauto dia=treediameter<int>(t);\n\t\n\tvi rs;\n\trep(i,n)if(dia.d1[i]+dia.d2[i]==dia.dia&&abs(dia.d1[i]-dia.d2[i])<=1)\n\t\trs.pb(i);\n\t\n\tif(si(rs)==2){\n\t\tdmp(rs);\n\t\tauto x=dfs(rs[0],rs[1]);\n\t\tauto y=dfs(rs[1],rs[0]);\n\t\tx.show();\n\t\ty.show();\n\t\tmint ans=x.w[0]*y.w[0];\n\t\tcout<<ans<<endl;\n\t}else{\n\t\tassert(si(rs)==1);\n\t\tint r=rs[0];\n\t\tint h=dia.dia/2;\n\t\t\n\t\tmint dp[2][2]{};\n\t\tdp[0][0]=1;\n\t\t\n\t\tfor(auto c:t[r]){\n\t\t\tauto x=dfs(c,r);\n\t\t\tx=advance(x);\n\t\t\tif(x.mx==h){\n\t\t\t\tper(i,2)per(j,2){\n\t\t\t\t\tif(i==0){\n\t\t\t\t\t\tdp[i+1][j]+=dp[i][j]*x.w[0];\n\t\t\t\t\t}\n\t\t\t\t\tif(j==0){\n\t\t\t\t\t\tdp[i][j+1]+=dp[i][j]*x.w[0];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j]*=(x.tot-(x.w[0]+x.w[1])*2);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tper(i,2)per(j,2)\n\t\t\t\t\tdp[i][j]*=x.tot;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<dp[1][1]/2<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair \n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nint pct(int x) { return __builtin_popcount(x); } \nint bit(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nint cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 \n\nnamespace input {\n\ttemplate<class T> void re(complex<T>& x);\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p);\n\ttemplate<class T> void re(vector<T>& a);\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a);\n\n\ttemplate<class T> void re(T& x) { cin >> x; }\n\tvoid re(double& x) { string t; re(t); x = stod(t); }\n\tvoid re(ld& x) { string t; re(t); x = stold(t); }\n\ttemplate<class T, class... Ts> void re(T& t, Ts&... ts) { \n\t\tre(t); re(ts...); \n\t}\n\n\ttemplate<class T> void re(complex<T>& x) { T a,b; re(a,b); x = {a,b}; }\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n\ttemplate<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n\tvoid pr(int x) { cout << x; }\n\tvoid pr(long x) { cout << x; }\n\tvoid pr(ll x) { cout << x; }\n\tvoid pr(unsigned x) { cout << x; }\n\tvoid pr(unsigned long x) { cout << x; }\n\tvoid pr(unsigned long long x) { cout << x; }\n\tvoid pr(float x) { cout << x; }\n\tvoid pr(double x) { cout << x; }\n\tvoid pr(ld x) { cout << x; }\n\tvoid pr(char x) { cout << x; }\n\tvoid pr(const char* x) { cout << x; }\n\tvoid pr(const string& x) { cout << x; }\n\tvoid pr(bool x) { pr(x ? \"true\" : \"false\"); }\n\ttemplate<class T> void pr(const complex<T>& x) { cout << x; }\n\t\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x);\n\ttemplate<class T> void pr(const T& x);\n\t\n\ttemplate<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n\t\tpr(t); pr(ts...); \n\t}\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x) { \n\t\tpr(\"{\",x.f,\", \",x.s,\"}\"); \n\t}\n\ttemplate<class T> void pr(const T& x) { \n\t\tpr(\"{\"); // const iterator needed for vector<bool>\n\t\tbool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; \n\t\tpr(\"}\");\n\t}\n\t\n\tvoid ps() { pr(\"\\n\"); } // print w/ spaces\n\ttemplate<class T, class... Ts> void ps(const T& t, const Ts&... ts) { \n\t\tpr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); \n\t}\n\t\n\tvoid pc() { pr(\"]\\n\"); } // debug w/ commas\n\ttemplate<class T, class... Ts> void pc(const T& t, const Ts&... ts) { \n\t\tpr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); \n\t}\n\t#define dbg(x...) pr(\"[\",#x,\"] = [\"), pc(x);\n}\n\nusing namespace output;\n\nnamespace io {\n\tvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(string s = \"\") {\n\t\tios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n\t\t// cin.exceptions(cin.failbit); \n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n\t}\n}\n\nusing namespace io;\n\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\n/**\n * Description: modular arithmetic operations \n * Source: \n\t* KACTL\n\t* https://codeforces.com/blog/entry/63903\n\t* https://codeforces.com/contest/1261/submission/65632855 (tourist)\n\t* https://codeforces.com/contest/1264/submission/66344993 (ksun)\n * Verification: \n\t* https://open.kattis.com/problems/modulararithmetic\n */\n\nstruct mi {\n\ttypedef decay<decltype(MOD)>::type T; \n \t/// don't silently convert to T\n\tT v; explicit operator T() const { return v; }\n\tmi() { v = 0; }\n\tmi(ll _v) { \n\t\tv = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n\t\tif (v < 0) v += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.v < b.v; }\n\tfriend void re(mi& a) { ll x; re(x); a = mi(x); }\n\tfriend void pr(const mi& a) { pr(a.v); }\n\tfriend ostream& operator<<(ostream& os, const mi& a) { \n\t\treturn os << a.v; }\n   \n\tmi& operator+=(const mi& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { \n\t\tv = (ll)v*m.v%MOD; return *this; }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmi operator-() const { return mi(-v); }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n};\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvector<vmi> comb;\nvoid genComb(int SZ) {\n\tcomb.assign(SZ,vmi(SZ)); comb[0][0] = 1;\n\tFOR(i,1,SZ) F0R(j,i+1) \n\t\tcomb[i][j] = comb[i-1][j]+(j?comb[i-1][j-1]:0);\n}\n\n/**\n * Description: Calculates longest path in tree\n * Source: own\n * Verification: \n   * http://www.spoj.com/problems/PT07Z/\n   * https://codeforces.com/contest/1182/problem/D\n */\n\ntemplate<int SZ> struct TreeDiameter {\n\tint N; \n\tvi adj[SZ];\n\tvoid ae(int a, int b) { adj[a].pb(b), adj[b].pb(a); }\n\tint par[SZ], dist[SZ];\n\tvoid dfs(int x) {\n\t\ttrav(y,adj[x]) if (y != par[x]) {\n\t\t\tpar[y] = x; dist[y] = dist[x]+1;\n\t\t\tdfs(y);\n\t\t}\n\t}\n\tvoid genDist(int x) { par[x] = -1; dist[x] = 0; dfs(x); }\n\tint diaLen;\n\tvi center, dia = {1,1}; \n\tvoid init(int _N) {\n\t\tN = _N; // find one endpoint of a diameter\n\t\tgenDist(1); FOR(i,1,N+1) if (dist[i]>dist[dia[0]]) dia[0] = i; \n\t\tgenDist(dia[0]); FOR(i,1,N+1) if (dist[i]>dist[dia[1]]) dia[1] = i;\n\t\tdiaLen = dist[dia[1]];\n\t\tint cen = dia[1]; F0R(i,diaLen/2) cen = par[cen];\n\t\tif (diaLen&1) center = {cen,par[cen]};\n\t\telse center = {cen};\n\t}\n};\nTreeDiameter<MX> T;\n\nmi dp[MX][3];\n// not possible -> 0, yes possible -> 0, yes possible -> 1\nint N, dist[MX];\n\nvoid genDist(int a, int b) {\n\ttrav(t,T.adj[a]) if (t != b) {\n\t\tdist[t] = dist[a]+1;\n\t\tgenDist(t,a);\n\t}\n}\n\nvoid solve(int a, int b) {\n\tdp[a][0] = 1;\n\tmi zero = 1, one = 0;\n\tif (dist[a] == T.diaLen/2) zero = 0, one = 1;\n\ttrav(t,T.adj[a]) if (t != b) {\n\t\tsolve(t,a);\n\t\tdp[a][0] *= 3*dp[t][0];\n\t\tmi t0 = 2*dp[t][0]+dp[t][1], t1 = dp[t][2];\n\t\ttie(zero,one) = mp(zero*t0,zero*t1+one*t0);\n\t}\n\tdp[a][1] = zero; dp[a][2] = one;\n}\n\nmi cur[3];\n\nvoid ad(mi no, mi yes) {\n\tR0F(i,3) {\n\t\tif (i < 2) cur[i+1] += cur[i]*yes;\n\t\tcur[i] *= no;\n\t}\n\t// ps(\"AD\",no,yes);\n}\n\nint main() {\n\tsetIO(); re(N);\n\tF0R(i,N-1) {\n\t\tint a,b; re(a,b);\n\t\tT.ae(a,b);\n\t}\n\tT.init(N);\n\t// ps(T.center,T.diaLen);\n\tif (sz(T.center) == 1) {\n\t\tint x = T.center[0];\n\t\tgenDist(x,0);\n\t\tcur[0] = 1;\n\t\ttrav(t,T.adj[x]) {\n\t\t\tsolve(t,x);\n\t\t\tad(dp[t][0]+2*dp[t][1],dp[t][2]);\n\t\t}\n\t\tps(cur[2]);\n\t} else {\n\t\tint x = T.center[0], y = T.center[1];\n\t\tgenDist(x,y); genDist(y,x);\n\t\tsolve(x,y); solve(y,x);\n\t\tps(dp[x][2]*dp[y][2]);\n\t}\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;++A)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD 998244353ll\n\nll N,gr;\nvector<ll> abv[202020];\nll mk[202020];\nll i, j, k;\nll ans;\n\npll grcalc(ll a,ll p){\n    ll i = 0;\n    pll ret = {0, 0};\n    fornum(i,0,abv[a].size()){\n        ll b = abv[a][i];\n        if(b==p)\n            continue;\n        pll p = grcalc(b, a);\n        if(ret.first<p.first){\n            ret.first = p.first;\n        }\n        if(ret.first<p.second+ret.second){\n            ret.first = p.second+ret.second;\n        }\n        if(ret.second<p.second){\n            ret.second = p.second;\n        }\n    }\n    ++ret.second;\n    return ret;\n}\n\nll dfs2(ll a,ll p,ll c,ll d,ll dd){\n    c = c * 3 % MOD;\n    if(abv[a].size()==1){\n        if(d==dd){\n            c += MOD - 1;\n        }\n        if(d==gr-dd){\n            c += MOD - 1;\n        }\n        return c % MOD;\n    }\n    ll ret = 1, i;\n    fornum(i,0,abv[a].size()){\n        ll b = abv[a][i];\n        if(b==p)\n            continue;\n        ret *= dfs2(b, a, c, d + 1, dd);\n        ret %= MOD;\n    }\n    return ret;\n}\nll dfs1(ll a,ll p,ll d){\n    mk[d] = a;\n    ll i, j;\n    ll ret = 0;\n    if(d==gr){\n        if(mk[0]>mk[d])\n            return 0;\n        i = 0;\n        ret = 1;\n        fornum(i,0,gr){\n            fornum(j,0,abv[mk[i]].size()){\n                ll b = abv[mk[i]][j];\n                if(mk[i+1]==b)\n                    continue;\n                if(i>0&&mk[i-1]==b)\n                    continue;\n                ret *= dfs2(b, mk[i], 1, 1, i);\n                ret %= MOD;\n            }\n        }\n        return ret;\n    }\n    fornum(i,0,abv[a].size()){\n        ll b = abv[a][i];\n        if(b==p)\n            continue;\n        ret += dfs1(b, a, d + 1);\n        ret %= MOD;\n    }\n    return ret;\n}\nint main(){\n    scanf(\"%lld\", &N);\n    fornum(i,1,N){\n        ll a, b;\n        scanf(\"%lld%lld\", &a, &b);\n        abv[a].push_back(b);\n        abv[b].push_back(a);\n    }\n    gr = grcalc(1, 0).first;\n    ans = 0;\n    printf(\"%lld \", gr);\n    fornum(i,0,N){\n        if(abv[i+1].size()==1){\n            printf(\"%lld %lld\\n\", i + 1, ans);\n            ans += dfs1(i + 1, 0, 0);\n            ans %= MOD;\n        }\n    }\n    printf(\"%lld\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n\n\n\n\n#include <algorithm>\n\n#include <array>\n\n#include <bitset>\n\n#include <cassert>\n\n#include <complex>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <iostream>\n\n#include <map>\n\n#include <numeric>\n\n#include <queue>\n\n#include <set>\n\n#include <string>\n\n#include <unordered_map>\n\n#include <unordered_set>\n\n#include <vector>\n\nusing namespace std;\n\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\nstruct Scanner {\n    FILE* fp = nullptr;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += fread(line + ed, 1, (1 << 15) - ed, fp);\n        line[ed] = '\\0';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) reread();\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == '-') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] - '0');\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(V<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    Scanner(FILE* _fp) : fp(_fp) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(' ');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single('\\n');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val; // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char('0' + (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const V<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(' ');\n            write_single(val[i]);\n        }\n    }\n};\n\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    static constexpr uint get_mod() { return MD; }\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(uint(_v % MD + MD)); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(uint(ull(v) * r.v % MD)); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\n// using Mint = ModInt<998244353>;\n// template<> const Mint Mint::G = Mint(3);\n\nusing Mint = ModInt<998244353>;\n\nScanner sc = Scanner(stdin);\nPrinter pr = Printer(stdout);\n\nVV<int> g;\n\nint mdp, mv;\nvoid dfs(int p, int b, int ndp = 0) {\n    if (mdp <= ndp) {\n        mdp = ndp;\n        mv = p;\n    }\n    for (int d: g[p]) {\n        if (d == b) continue;\n        dfs(d, p, ndp + 1);\n    }\n}\n\nV<int> path;\nbool dfs_path(int p, int b, int t) {\n    if (p == t) {\n        path.push_back(p);\n        return true;\n    }\n    for (int d: g[p]) {\n        if (d == b) continue;\n        if (dfs_path(d, p, t)) {\n            path.push_back(p);\n            return true;\n        }\n    }\n    return false;\n}\n\nint U;\n\nusing P = array<Mint, 3>;\n\nP solve(int p, int b, int ndps = 0) {\n    if (g[p].size() == 1) {\n        // leaf\n        if (ndps == U) {\n            // rad\n            return {Mint(2), Mint(1), Mint(0)};\n        } else {\n//            dbg(p, b, P{Mint(3), Mint(0)});\n            return {Mint(3), Mint(0), Mint(0)};\n        }\n    }\n    P dp = {Mint(1), Mint(0), Mint(0)};\n    for (auto d: g[p]) {\n        if (d == b) continue;\n        auto ch = solve(d, p, ndps + 1);\n        P ndp = {Mint(0), Mint(0), Mint(0)};\n        for (int a = 0; a < 3; a++) {\n            for (int b = 0; b < 3; b++) {\n                ndp[min(2, a + b)] += dp[a] * ch[b];\n            }\n        }\n        dp = ndp;\n    }\n    dp[0] = dp[0] * Mint(3) + (dp[1] + dp[2]) * Mint(2);\n    return dp;\n}\n\nint main() {\n    int n;\n    sc.read(n);\n    g = VV<int>(n);\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        sc.read(a, b); a--; b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    dfs(0, -1);\n    int u = mv;\n    dfs(mv, -1);\n    int v = mv;\n    dfs_path(u, -1, v);\n\n    int L = int(path.size());\n    if (L % 2) {\n        U = (L / 2) - 1;\n        int mid = path[L / 2];\n                       ;\n        V<Mint> dp(4);\n        dp[0] = Mint(1);\n        for (int d: g[mid]) {\n            V<Mint> ndp(4);\n            auto x = solve(d, mid);\n            Mint x0 = x[0] - (x[1] + x[2]), x1 = x[1];\n            ndp[3] = dp[3] * x0 + dp[2] * x1 + dp[1] * x1;\n            ndp[2] = dp[2] * x0 + dp[0] * x1;\n            ndp[1] = dp[1] * x0 + dp[0] * x1;\n            ndp[0] = dp[0] * x0;\n            dp = ndp;\n        }\n               ;\n        pr.writeln((dp[3] / Mint(2)).v);\n    } else {\n        int mid0 = path[L / 2 - 1], mid1 = path[L / 2];\n        U = (L / 2 - 1);\n        auto x = solve(mid0, mid1);\n        auto y = solve(mid1, mid0);\n        pr.writeln((x[1] * y[1]).v);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ninline int read()\n{\n    int s=0,f=1; char ch=getchar();\n    while(!isdigit(ch) && ch!='-')ch=getchar();\n    if(ch=='-')ch=getchar(),f=-1;\n    while(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n    return ~f?s:-s;\n}\n\nconst int maxn=1e6+20;\n\nvector<int>ed[maxn];\nint n;\n\ninline void init()\n{\n    n=read();\n    REP(i,1,n-1)\n    {\n\tint u=read(),v=read();\n\ted[u].push_back(v);\n\ted[v].push_back(u);\n    }\n}\n\nint cir[maxn],len;\n\ninline int bfs(int S)\n{\n    static int dis[maxn],pre[maxn];\n    memset(dis,-1,sizeof(dis));\n    queue<int>q;\n    q.push(S); dis[S]=0; pre[S]=0;\n    while(!q.empty())\n    {\n\tint u=q.front(); q.pop();\n\tfor(int v:ed[u])\n\t    if(dis[v]==-1)\n\t\tq.push(v),dis[v]=dis[u]+1,pre[v]=u;\n    }\n    int T=0,tmx=0;\n    REP(i,1,n)if(dis[i]>tmx)tmx=dis[i],T=i;\n    int x=T;\n    len=0;\n    while(x)cir[++len]=x,x=pre[x];\n    reverse(cir+1,cir+len+1);\n    return T;\n}\n\nint rt;\n\ninline void find_Len()\n{\n    int S=bfs(1);\n    int T=bfs(S);\n    if(len%2==1)rt=cir[len+1>>1];\n    else {\n\tint x=cir[len>>1],y=cir[len+2>>1];\n\ted[x].erase(find(ed[x].begin(),ed[x].end(),y));\n\ted[y].erase(find(ed[y].begin(),ed[y].end(),x));\n\t++n;\n\ted[x].push_back(n); ed[y].push_back(n);\n\ted[n]={x,y};\n\trt=n;\n    }\n}\n\nint ans;\n\nint deep[maxn];\nll dp[maxn][3][3];\n\nvoid dfs(int u,int fa)\n{\n    int son=0;\n    for(int v:ed[u])\n    {\n\tif(v==fa)continue;\n\tdeep[v]=deep[u]+1;\n\tdfs(v,u);\n\tson++;\n    }\n    if(!son)dp[u][deep[u]==len/2][deep[u]==len/2]=1;\n    else {\n\tdp[u][0][0]=1;\n\tfor(int v:ed[u])\n\t{\n\t    if(v==fa)continue;\n\t    ll g[3][3]={0};\n\t    REP(a,0,2)REP(b,0,2)REP(c,0,2)REP(d,0,2)REP(edge,-1,1)\n\t\tg[min(a+c*(edge==1),2)][min(b+d*(edge==-1),2)]+=dp[u][a][b]*dp[v][c][d];\n\t    REP(a,0,2)REP(b,0,2)dp[u][a][b]=g[a][b];\n\t}\n    }\n}\n\ninline void doing()\n{\n    find_Len();\n    dfs(rt,0);\n    printf(\"%lld\\n\",dp[rt][1][1]/2);\n}\n\nint main()\n{\n    init();\n    doing();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// I think of what the world could be, A vision of the one I see, A million dreams is all it's gonna take\n\n#include<bits/stdc++.h>\n\n#define F first\n#define S second\n#define PB push_back\n#define sz(s) int((s).size())\n#define bit(n,k) (((n)>>(k))&1)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn = 2e5 + 10, mod = 1e9 + 7, inf = 998244353;\n\n\nint h[maxn], par[maxn];\nvector<int> v[maxn];\n\npii far(int u, int pr = -1){\n    par[u] = pr;\n    h[u] = pr == -1 ? 0 : (h[pr] + 1);\n    pii ans = {0, u};\n    for(int y : v[u]){\n\tif(y != pr){\n\t    pii p = far(y, u);\n\t    p.F++;\n\t    ans = max(ans, p);\n\t}\t    \n    }\n    return ans;\n}\n\nint total[maxn], dp1[maxn], dp2[maxn], under[maxn];\n\nvoid dfs(int u, int par = -1){\n    total[u] = 1, dp2[u] = 1;\n    if(sz(v[u]) == (par != -1))\n\tdp2[u] = 0, dp1[u] = 1;\n    for(int y : v[u]){\n\tif(y != par){\n\t    dfs(y, u);\n\t    under[u] = max(under[u], under[y] + 1);\n\t    total[u] = 3ll * total[u] * total[y] % mod;\n\t}\n    }\n    for(int y : v[u]){\n\tif(y != par){\n\t    int no = 0, yes = 0;\n\t    if(under[u] == under[y] + 1){\n\t\tno = (2ll * total[y] + 1ll * dp2[y]) % mod;\n\t\tyes = dp1[y];\n\t    }\n\t    else{\n\t\tno = 3ll * total[y] % mod;\n\t\tyes = 0;\n\t    }\n\t    dp1[u] = (1ll * dp1[u] * no + 1ll * dp2[u] * yes) % mod;\n\t    dp2[u] = (1ll * dp2[u] * no) % mod;\n\t}\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie();\n\n    int n;\n    cin >> n;\n    for(int i = 0; i < n-1; i++){\n\tint a, b;\n\tcin >> a >> b;\n\tv[a].PB(b);\n\tv[b].PB(a);\n    }\n    int A = far(1).S;\n    pii p = far(A);\n    int diam = p.F, B = p.S;\n\n    int ans = 0;\n\n    if(diam & 1){\n\tfor(int i = 0; i < (diam/2); i++)\n\t    B = par[B];\n\tA = par[B];\n\tdfs(A, B);\n\tdfs(B, A);\n\tans = 1ll * dp1[A] * dp1[B] % mod;\n    }\n    else{\n\tfor(int i = 0; i < (diam/2); i++)\n\t    B = par[B];\n\tdfs(B);\n\tint zer = 1, one = 0, two = 0; \n\tfor(int y : v[B]){\n\t    int yes = 0, no = 0;\n\t    if(under[B] == under[y] + 1){\n\t\tno = (1ll * total[y] + 2ll * dp2[y]) % mod;\n\t\tyes = dp1[y];\n\t    }\n\t    else{\n\t\tno = 3ll * total[y] % mod;\n\t    }\n\t    two = (1ll * two * no + 1ll * one * yes) % mod;\n\t    one = (1ll * one * no + 1ll * zer * yes) % mod;\n\t    zer = (1ll * zer * no) % mod;\n\t}\n\tans = two;\n    }\n    return cout << ans << endl, 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst int M=998244353;\nconst int inv2=(M+1)/2;\nconst int maxn=3e5+3;\nvector <int> h[maxn];\nint dis[maxn],n,pre[maxn],p,q,d[maxn],m;\nll dp[maxn][2];\nvoid dfs(int u,int fa){\n    pre[u]=fa; dis[u]=dis[fa]+1;\n    for (auto v:h[u]){\n        if (v==fa) continue;\n        dfs(v,u);\n    }\n}\nvoid dfs2(int u,int fa){\n    d[u]=d[fa]+1;\n    if (d[u]==m){\n        dp[u][0]=2;\n        dp[u][1]=1;\n        return;\n    }\n    ll r1=1,r2=0;\n    for (auto v:h[u]){\n        if (v==fa) continue;\n        dfs2(v,u);\n        ll nr1=r1*dp[v][0]%M;\n        ll nr2=(r1*dp[v][1]+r2*dp[v][0])%M;\n        r1=nr1; r2=nr2;\n    }\n    dp[u][0]=(r1*3+r2*2)%M;\n    dp[u][1]=r2;\n}\nint main(){\n    scanf(\"%d\",&n); dis[0]=-1;\n    for (int i=1;i<n;i++){\n        int u,v; scanf(\"%d%d\",&u,&v);\n        h[u].pb(v); h[v].pb(u);\n    }\n    //puts(\"B\");\n    dfs(1,0);\n    int s=1;\n    for (int i=2;i<=n;i++) if (dis[i]>dis[s]) s=i;\n    dfs(s,0);\n    int t=s;\n    for (int i=1;i<=n;i++) if (dis[i]>dis[t]) t=i;\n    m=dis[t]/2; p=t;\n    for (int i=0;i<m;i++) p=pre[p];\n    if (dis[t]&1){\n        q=pre[p];\n        d[q]=-1; dfs2(p,q);\n        d[p]=-1; dfs2(q,p);\n        printf(\"%lld\\n\",dp[p][1]*dp[q][1]%M);\n    } else {\n        ll ans0=1,ans1=0,ans2=0;\n        for (auto u:h[p]){\n            d[u]=0; dfs2(u,p);\n            ll nans0,nans1,nans2;\n            //cout<<dp[u][0]<<' '<<dp[u][1]<<endl;\n            nans0=ans0*(dp[u][0]+M-dp[u][1])%M;\n            nans1=(ans0*dp[u][1]+ans1*(dp[u][0]+M-dp[u][1]))%M;\n            nans2=(ans1*dp[u][1]+ans2*(dp[u][0]+M-dp[u][1]))%M;\n            ans0=nans0; ans1=nans1; ans2=nans2;\n        }\n        printf(\"%lld\\n\",ans2);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nconst char lf = '\\n';\n\nnamespace ae86\n{\n\tconst int bufl = 1 << 15;\n\n\tchar buf[bufl],*s=buf,*t=buf;\n\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\n\tinline int ty()\n\t{\n\t\tint a=0;int b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 200007 , mo = 998244353;\n\ntemplate<typename T1,typename T2> inline T1 ad(T1 &a,T2 b){return a=a+b>=mo?a+b-mo:a+b;}\ntemplate<typename T1,typename T2> inline T1 dl(T1 &a,T2 b){return a=a>=b?a-b:a-b+mo;}\ntemplate<typename T1,typename T2> inline T1 add(T1 a,T2 b){return a+b>=mo?a+b-mo:a+b;}\ntemplate<typename T1,typename T2> inline T1 del(T1 a,T2 b){return a>=b?a-b:a-b+mo;}\n\nlint powa(lint a,lint t)\n{\n\tlint b=1;a=(a+mo)%mo;\n\twhile(t){if(t&1)b=b*a%mo;a=a*a%mo,t>>=1;}\n\treturn b;\n}\n\ninline lint inva(lint a)\n{\n\treturn powa(a,mo-2);\n}\n\nvector<int> e[_];\n\nint n,fa[_]={0},rt=0,mxdep=0;\n\nvoid dfs(int x,int ff,int dep)\n{\n\tfa[x]=ff;\n\tif(dep>mxdep)mxdep=dep,rt=x;\n\tfor(auto b:e[x])if(b!=ff)dfs(b,x,dep+1);\n}\n\nint ps[_]={0},lps=0;\nlint f[_][3][3]={0};\n\nvoid dfs2(int x,int ff,int dep)\n{\n\tfa[x]=ff;\n\tmemset(f[x],0,sizeof(f[x]));\n\tif(dep==lps/2)f[x][1][1]=1;\n\telse f[x][0][0]=1;\n\n\tfor(auto b:e[x])\n\t{\n\t\tif(b==ff)continue;\n\t\tdfs2(b,x,dep+1);\n\t\tlint sf[3][3];memset(sf,0,sizeof(sf));\n\t\tfor(int i=0;i<3;i++)\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\tfor(int p=0;p<3;p++)\n\t\t\t\t\tfor(int q=0;q<3;q++)\n\t\t\t\t\t\tfor(int r=-1;r<=1;r++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint pp=r==1?p:0,qq=r==-1?q:0;\n\t\t\t\t\t\t\tpp=min(2,pp+i),qq=min(2,qq+j);\n\t\t\t\t\t\t\tad(sf[pp][qq],f[x][i][j]*f[b][p][q]%mo);\n\t\t\t\t\t\t}\n\t\tmemcpy(f[x],sf,sizeof(sf));\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(0),cout.tie(nullptr);\n\n\tn=ty();\n\tfor(int i=1,a,b;i<n;i++)a=ty(),b=ty(),e[a].emplace_back(b),e[b].emplace_back(a);\n\n\tdfs(1,0,1),mxdep=0,dfs(rt,0,1);\n\tfor(int i=rt;i;i=fa[i])ps[++lps]=i;\n\n\tif(lps&1)\n\t{\n\t\tint mid=ps[lps/2+1];\n\t\tdfs2(mid,0,0);\n\t\tcout<<f[mid][1][1]*inva(2)%mo<<lf;\n\t\treturn 0;\n\t}\n\t\n\tint ll=ps[lps/2],rr=ps[lps/2+1];\n\tdfs2(ll,rr,1),dfs2(rr,ll,1);\n\tlint ans=0;\n\tad(ans,f[ll][1][1]*f[rr][0][0]%mo);\n\tad(ans,f[ll][1][0]*f[rr][0][1]%mo);\n\tad(ans,f[ll][0][1]*f[rr][1][0]%mo);\n\tad(ans,f[ll][0][0]*f[rr][1][1]%mo);\n\tcout<<ans*inva(2)%mo<<lf;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[202020];\nconst ll mo=998244353;\n\npair<int,int> farthest(int cur,int pre,int d,vector<int>& D) {\n\tD[cur]=d;\n\tpair<int,int> r={d,cur};\n\tFORR(e,E[cur]) if(e!=pre) r=max(r, farthest(e,cur,d+1,D));\n\treturn r;\n}\n\npair<int,vector<int>> diameter() { // diameter,center\n\tvector<int> D[2];\n\tD[0].resize(N);\n\tD[1].resize(N);\n\tauto v1=farthest(0,0,0,D[0]);\n\tauto v2=farthest(v1.second,v1.second,0,D[0]);\n\tfarthest(v2.second,v2.second,0,D[1]);\n\tpair<int,vector<int>> R;\n\tR.first = v2.first;\n\t//重心を取る場合\n\tfor(int i=N-1;i>=0;i--) if(D[0][i]+D[1][i]==R.first && abs(D[0][i]-D[1][i])<=1) R.second.push_back(i);\n\n\treturn R;\n}\n\nvector<ll> dfs1(int cur,int pre,int lef,int no=0) {\n\tif(E[cur].size()==1) {\n\t\tif(lef==0) return {2,1,0};\n\t\telse return {3,0,0};\n\t}\n\telse {\n\t\tvector<ll> X={1,0,0};\n\t\tFORR(e,E[cur]) if(e!=pre) {\n\t\t\tvector<ll> Y=dfs1(e,cur,lef-1);\n\t\t\tvector<ll> Z={0,0,0};\n\t\t\tint x,y;\n\t\t\tFOR(x,3) FOR(y,3) Z[min(x+y,2)]+=X[x]*Y[y];\n\t\t\tX[0]=Z[0]%mo;\n\t\t\tX[1]=Z[1]%mo;\n\t\t\tX[2]=Z[2]%mo;\n\t\t}\n\t\tvector<ll> Y={0,0,0};\n\t\tif(no) {\n\t\t\tY=X;\n\t\t}\n\t\telse {\n\t\t\tY[0]=(X[0]*3+X[1]*2+X[2]*2)%mo;\n\t\t\tY[1]=X[1];\n\t\t\tY[2]=X[2];\n\t\t}\n\t\treturn Y;\n\t}\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tauto R=diameter();\n\tif(R.second.size()==1) {\n\t\tvector<ll> X={1,0,0,0};\n\t\tFORR(e,E[R.second[0]]) {\n\t\t\tauto Y=dfs1(e,R.second[0],R.first/2-1);\n\t\t\tvector<ll> Z={0,0,0,0};\n\t\t\tFOR(x,4) FOR(y,3) Z[min(x+y,3)]+=X[x]*Y[y]%mo;\n\t\t\tFOR(x,4) X[x]=Z[x]%mo;\n\t\t}\n\t\tassert(0);\n\t\tcout<<X[2]<<endl;\n\t}\n\telse {\n\t\tvector<ll> X=dfs1(R.second[0],R.second[1],R.first/2,1);\n\t\tvector<ll> Y=dfs1(R.second[1],R.second[0],R.first/2,1);\n\t\t\n\t\tcout<<X[1]*Y[1]%mo<<endl;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define R register\n#define mp make_pair\n#define ll long long\n#define pii pair<int, int>\nusing namespace std;\nconst int N = 210000, mod = 998244353;\n\nint n, dis[N], a, b, p[N];\nll f[N][2];\nvector<int> to[N];\n\ntemplate <class T>\ninline void read(T &x) {\n\tx = 0;\n\tchar ch = getchar(), w = 0;\n\twhile (!isdigit(ch)) w = (ch == '-'), ch = getchar();\n\twhile (isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();\n\tx = w ? -x : x;\n\treturn;\n}\n\ninline void addEdg(int x, int y) {\n\tto[x].push_back(y), to[y].push_back(x);\n\treturn;\n}\n\nvoid dfs1(int now, int fa) {\n\tdis[now] = dis[fa] + 1;\n\tfor (auto &v : to[now]) {\n\t\tif (v == fa) continue;\n\t\tdfs1(v, now);\n\t}\n\treturn;\n}\n\nint dfs2(int now, int fa, int maxD) {\n\tif (dis[now] == maxD) return p[now] = 1;\n\tint ret = 0;\n\tfor (auto &v : to[now]) {\n\t\tif (v == fa) continue;\n\t\tret |= dfs2(v, now, maxD);\n\t}\n\tif (ret) {\n\t\tif (dis[now] == (maxD + 1) >> 1)\n\t\t\ta = now;\n\t\telse if (dis[now] == (maxD >> 1) + 1)\n\t\t\tb = now;\n\t}\n\treturn ret;\n}\n\nvoid dfs3(int now, int fa) {\n\tf[now][0] = 1, f[now][1] = p[now];\n\tfor (auto &v : to[now]) {\n\t\tif (v == fa) continue;\n\t\tdfs3(v, now);\n\t\tf[now][1] = (f[now][1] * f[v][0] + f[now][0] * f[v][1]) % mod;\n\t\tf[now][0] = (f[now][0] * f[v][0]) % mod;\n\t}\n\tf[now][0] = (f[now][0] * min(3, dis[now] - 1) - f[now][1] + mod) % mod;\n\treturn;\n}\n\nint main() {\n\tint x, y;\n\tread(n);\n\tfor (R int i = 1; i < n; ++i)\n\t\tread(x), read(y), addEdg(x, y);\n\tdfs1(1, 0);\n\tint rt = 1, maxD = 1;\n\tfor (R int i = 2; i <= n; ++i)\n\t\tif (dis[i] > maxD) maxD = dis[i], rt = i;\n\tdfs1(rt, 0), maxD = 1;\n\tfor (R int i = 1; i <= n; ++i)\n\t\tmaxD = max(maxD, dis[i]);\n\tdfs2(rt, 0, maxD), p[rt] = 1;\n\t//for (R int i = 1; i <= n; ++i) cout << \"QwQ \" << i << ' ' << p[i] << endl;\n\tif (b) {\n\t\tdfs3(b, a), dfs3(a, b);\n\t\tprintf(\"%lld\\n\", f[a][1] * f[b][1] % mod);\n\t}\n\telse {\n\t\tf[a][0] = 1;\n\t\tll ans = 0;\n\t\tfor (auto &v : to[a]) {\n\t\t\tdfs3(v, a);\n\t\t\tans = (ans * f[v][0] + f[a][1] * f[v][1]) % mod;\n\t\t\tf[a][1] = (f[a][1] * f[v][0] + f[a][0] * f[v][1]) % mod;\n\t\t\tf[a][0] = (f[a][0] * f[v][0]) % mod;\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define MOD 998244353\ntemplate<typename ty1,typename ty2>\ninline int add(ty1 x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x += y; return x < MOD ? x : x - MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline void addto(ty1 &x, ty2 y) {\n\t\t  if(y>=MOD)y%=MOD;\n\t\t  if(x>=MOD)x%=MOD;\n\t      x += y; if (x >= MOD) x -= MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int sub(ty1 x, ty2 y) {\n\t\tif(y>=MOD)y%=MOD;\n\t\t if(x>=MOD)x%=MOD;\n        x -= y; return x < 0 ? x + MOD : x;\n}\ntemplate<typename ty1,typename ty2>\ninline void subto(ty1 &x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x -= y; if (x < 0) x += MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int mul(ty1 x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        return 1ll * x * y % MOD;\n}\ntemplate<typename ty1,typename ty2>\nvoid multo(ty1 &x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        x=1ll * x * y % MOD;\n}\n  \nlong long int gcd(long long int a, long long int b){\n\tif (a > b){\n\t\tswap(a, b);\n\t}\n\twhile (a){\n\t\tswap(a, b);\n\t\ta %= b;\n\t}\n\treturn b;\n}\nlong long int lcm(long long int a, long long int b){\n\treturn a / gcd(a, b)*b;\n}\nlong long int ppow(long long int i, long long int j){\n\t\tlong long int res = 1LL;\n\t\twhile (j){\n\t\t\tif ((j & 1LL)){\n\t\t\t\tres *= i;\n\t\t\t\tif (res >= MOD){\n\t\t\t\t\tres %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj >>= 1;\n\t\t\ti *= i;\n\t\t\tif (i >= MOD){\n\t\t\t\ti %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\nclass Combination{\n\t\npublic:\n\tvector<long long int> k;\n\tvector<long long int> r;\n\tvoid resize(int N){\n\t\tk.resize(N + 2);\n\t\tr.resize(N + 2);\n\t\tk[0] = 1;\n\t\tfor (int i = 1; i < N+2; i++){\n\t\t\tk[i] = k[i - 1];\n\t\t\tk[i] *= i;\n\t\t\tif (k[i] >= MOD)k[i] %= MOD;\n\t\t}\n\t\tlong long int al = k[k.size() - 1];\n\t\tlong long int iv = ppow(k[k.size() - 1],MOD-2);\n\t\tr[k.size() - 1] = iv;\n\t\tfor (int i = (int)(r.size()) - 2; i >= 0; i--){\n\t\t\tr[i] = r[i + 1] * (i + 1);\n\t\t\tif (r[i] >= MOD){\n\t\t\t\tr[i] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int C(int a, int b){\n\t\tif (a < b)return 0;\n\t\tlong long int up = k[a];\n\t\tlong long int dw = r[b] * r[a - b];\n\t\tdw %= MOD;\n\t\tup *= dw;\n\t\tup %= MOD;\n\t\treturn up;\n\t}\n\tlong long int H(int a, int b){\n\t\treturn C(a + b - 1, b);\n\t}\n\tlong long int catalan_number(int n){\n\t\treturn (C(2 * n, n) + MOD - C(2 * n, n - 1)) % MOD;\n\t}\n};\nCombination C;\n\n#define MAX 200002\nint n;\n\n\nstruct treediameter{\n\t//直径は色々いい性質がある\n\t//中心から(２頂点の場合それをくっつける）同じ距離のびた２つの頂点間が直径\n\t//直径は最大長であることにも注意\n\tconst vector<vector<int> >&g;\n\tint r1,r2;\n\tvector<int> d1,d2;  //両端からのdist\n\tint dia;\n\tvoid dfs(int v,int p,int cur,vector<int> &d){\n\t\td[v]=cur;\n\t\tfor(auto e:g[v])if(e!=p)\n\t\t\tdfs(e,v,cur+1,d);\n\t}\n\ttreediameter(const vector<vector<int> > &gg):g(gg),d1(g.size()),d2(g.size()){\n\t\tdfs(0,-1,0,d1);\n\t\tr1=max_element(d1.begin(),d1.end())-d1.begin();\n\t\tdfs(r1,-1,0,d1);\n\t\tr2=max_element(d1.begin(),d1.end())-d1.begin();\n\t\tdfs(r2,-1,0,d2);\n\t\tdia=d1[r2];\n\t}\n\tvector<int> find_centre(){  //直径の中心をさがす 1頂点 or 2頂点　直径は必ずこれらすべてを通る\n\t\tvector<int> ret;\n\t\tfor(int i=0;i<d1.size();i++){\n\t\t\tif(d1[i]+d2[i]==dia&&abs(d1[i]-d2[i])<=1){\n\t\t\t\tret.push_back(i);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n//treediameter(v)\n\nvector<vector<int> > v;\n\nbool flag[MAX];\n\n//0:none with only one type of operation\n//1:positive without substraction\n// 2: none with mix\nint dp[MAX][3];\nbool us[MAX][3];\nint target;\ninline int dfs(int b,int ty,int pr=-1,int d=0){\n\tif(us[b][ty]){\n\t\treturn dp[b][ty];\n\t}\n\tus[b][ty]=true;\n\tint ava=0;\n\tvector<int> can;\n\tfor(int go:v[b]){\n\t\tif(go==pr||flag[go])continue;\n\t\tava++;\n\t\tcan.push_back(go);\n\t}\n\tassert(d<=target);\n\tif(ava==0){\n\t\t//leaf\n\t\tif(ty==1){\n\t\t\tif(d==target){\n\t\t\t\tdp[b][ty]=1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tdp[b][ty]=0;\n\t\t\treturn 0;\n\t\t}\n\t\tif(ty==0){\n\t\t\tif(d==target){\n\t\t\t\tdp[b][ty]=0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdp[b][ty]=1;\n\t\t\treturn 1;\n\t\t}\n\t\tif(ty==2){\n\t\t\tdp[b][ty]=1;\n\t\t\treturn 1;\n\t\t}\n\t\texit(1);\n\t}\n\tif(ty==1){\n\t\tif(true){\n\t\t\tfor(int go:can){\n\t\t\t\tauto ret=dfs(go,1,b,d+1);\n\t\t\t\tfor(int goo:can){\n\t\t\t\t\tif(go!=goo){\n\t\t\t\t\t\tmulto(ret,add(dfs(goo,0,b,d+1),mul(2,dfs(goo,2,b,d+1))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddto(dp[b][ty],ret);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int go:can){\n\t\t\t\tauto ret=dfs(go,1,b,d+1);\n\t\t\t\tfor(int goo:can){\n\t\t\t\t\tif(go!=goo){\n\t\t\t\t\t\tmulto(ret,add(mul(2,dfs(goo,0,b,d+1)),mul(1,dfs(goo,2,b,d+1))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddto(dp[b][ty],ret);\n\t\t\t}\n\t\t}\n\t}\n\tif(ty==2){\n\t\tdp[b][ty]=1;\n\t\tfor(int goo:can){\n\t\t\tmulto(dp[b][ty],mul(3,dfs(goo,2,b,d+1)));\n\t\t}\n\t}\n\tif(ty==0){\n\t\tdp[b][ty]=1;\n\t\tfor(int goo:can){\n\t\t\tmulto(dp[b][ty],add(dfs(goo,0,b,d+1),mul(2,dfs(goo,2,b,d+1))));\n\t\t}\n\t}\n\treturn dp[b][ty];\n}\n\nint main(){\n\tcin>>n;\n\tv.resize(n);\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tauto dia=treediameter(v);\n\tauto centre=dia.find_centre();\n\tfor(auto el:centre){\n\t\tflag[el]=true;\n\t}\n\tif(centre.size()==1){\n\t\tint pos=centre[0];\n\t\ttarget=dia.dia/2;\n\t\tlong long int ans=0;\n\t\tfor(int el1:v[pos]){\n\t\t\tfor(int el2:v[pos]){\n\t\t\t\tif(el1!=el2){\n\t\t\t\t\tauto ret=mul(dfs(el1,1,pos,1),dfs(el2,1,pos,1));\n\t\t\t\t\tfor(int el3:v[pos]){\n\t\t\t\t\t\tif(el1!=el3&&el2!=el3){\n\t\t\t\t\t\t\tmulto(ret,add(mul(2,dfs(el3,0,pos,1)),mul(1,dfs(el3,2,pos,1))));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\taddto(ans,ret);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmulto(ans,ppow(2,MOD-2));\n\t\tans%=MOD;\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\telse{\n\t\tcerr<<centre[0]<<\" \"<<centre[1]<<endl;\n\t\tcerr<<dia.dia<<endl;\n\t\ttarget=dia.dia/2;\n\t\tlong long int ans=0;\n\t\tcerr<<target<<\" \"<<dfs(centre[0],1)<<\" \"<<dfs(centre[1],1)<<endl;\n\t\taddto(ans,mul(dfs(centre[0],1),dfs(centre[1],1)));\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[202020];\nconst ll mo=998244353;\nll dp[202020][3][3];\n\npair<int,int> farthest(int cur,int pre,int d,vector<int>& D) {\n\tD[cur]=d;\n\tpair<int,int> r={d,cur};\n\tFORR(e,E[cur]) if(e!=pre) r=max(r, farthest(e,cur,d+1,D));\n\treturn r;\n}\n\npair<int,vector<int>> diameter() { // diameter,center\n\tvector<int> D[2];\n\tD[0].resize(N);\n\tD[1].resize(N);\n\tauto v1=farthest(0,0,0,D[0]);\n\tauto v2=farthest(v1.second,v1.second,0,D[0]);\n\tfarthest(v2.second,v2.second,0,D[1]);\n\tpair<int,vector<int>> R;\n\tR.first = v2.first;\n\t//重心を取る場合\n\tfor(int i=N-1;i>=0;i--) if(D[0][i]+D[1][i]==R.first && abs(D[0][i]-D[1][i])<=1) R.second.push_back(i);\n\n\treturn R;\n}\n\nvoid dfs(int cur,int pre,int lef) {\n\tif(lef==0) {\n\t\tdp[cur][1][1]=1;\n\t}\n\telse {\n\t\tdp[cur][0][0]=1;\n\t}\n\t\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\tdfs(e,cur,lef-1);\n\t\tll to[3][3]={};\n\t\tint a1,a2,b1,b2;\n\t\tFOR(a1,3) FOR(a2,3) FOR(b1,3) FOR(b2,3) {\n\t\t\t// +1\n\t\t\tto[min(a1+b1,2)][a2]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t\t// 0\n\t\t\tto[a1][a2]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t\t// -1\n\t\t\tto[a1][min(a2+b2,2)]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t}\n\t\t\n\t\tFOR(a1,3) FOR(a2,3) dp[cur][a1][a2]=to[a1][a2]%mo;\n\t}\n\t\n\t\n\t\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tauto R=diameter();\n\tif(R.second.size()==1) {\n\t\tx=R.second[0];\n\t\tdfs(x,-1,R.first/2);\n\t\tassert(0);\n\t\tcout<<dp[x][1][1]*((mo+1)/2)%mo<<endl;\n\t}\n\telse {\n\t\tx=R.second[0];\n\t\ty=R.second[1];\n\t\tdfs(x,y,R.first/2);\n\t\tdfs(y,x,R.first/2);\n\t\t\n\t\tcout<<dp[x][0][1]*dp[y][1][0]%mo<<endl;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (q < m) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\ntemplate <int mod>\nstruct ModInt\n{\n    using lint = long long;\n    static int get_mod() { return mod; }\n    static int get_primitive_root() {\n        static int primitive_root = 0;\n        if (!primitive_root) {\n            primitive_root = [&](){\n                std::set<int> fac;\n                int v = mod - 1;\n                for (lint i = 2; i * i <= v; i++) while (v % i == 0) fac.insert(i), v /= i;\n                if (v > 1) fac.insert(v);\n                for (int g = 1; g < mod; g++) {\n                    bool ok = true;\n                    for (auto i : fac) if (ModInt(g).power((mod - 1) / i) == 1) { ok = false; break; }\n                    if (ok) return g;\n                }\n                return -1;\n            }();\n        }\n        return primitive_root;\n    }\n    int val;\n    constexpr ModInt() : val(0) {}\n    constexpr ModInt &_setval(lint v) { val = (v >= mod ? v - mod : v); return *this; }\n    constexpr ModInt(lint v) { _setval(v % mod + mod); }\n    explicit operator bool() const { return val != 0; }\n    constexpr ModInt operator+(const ModInt &x) const { return ModInt()._setval((lint)val + x.val); }\n    constexpr ModInt operator-(const ModInt &x) const { return ModInt()._setval((lint)val - x.val + mod); }\n    constexpr ModInt operator*(const ModInt &x) const { return ModInt()._setval((lint)val * x.val % mod); }\n    constexpr ModInt operator/(const ModInt &x) const { return ModInt()._setval((lint)val * x.inv() % mod); }\n    constexpr ModInt operator-() const { return ModInt()._setval(mod - val); }\n    constexpr ModInt &operator+=(const ModInt &x) { return *this = *this + x; }\n    constexpr ModInt &operator-=(const ModInt &x) { return *this = *this - x; }\n    constexpr ModInt &operator*=(const ModInt &x) { return *this = *this * x; }\n    constexpr ModInt &operator/=(const ModInt &x) { return *this = *this / x; }\n    friend constexpr ModInt operator+(lint a, const ModInt &x) { return ModInt()._setval(a % mod + x.val); }\n    friend constexpr ModInt operator-(lint a, const ModInt &x) { return ModInt()._setval(a % mod - x.val + mod); }\n    friend constexpr ModInt operator*(lint a, const ModInt &x) { return ModInt()._setval(a % mod * x.val % mod); }\n    friend constexpr ModInt operator/(lint a, const ModInt &x) { return ModInt()._setval(a % mod * x.inv() % mod); }\n    constexpr bool operator==(const ModInt &x) const { return val == x.val; }\n    constexpr bool operator!=(const ModInt &x) const { return val != x.val; }\n    bool operator<(const ModInt &x) const { return val < x.val; }  // To use std::map<ModInt, T>\n    friend std::istream &operator>>(std::istream &is, ModInt &x) { lint t; is >> t; x = ModInt(t); return is; }\n    friend std::ostream &operator<<(std::ostream &os, const ModInt &x) { os << x.val;  return os; }\n    constexpr lint power(lint n) const {\n        lint ans = 1, tmp = this->val;\n        while (n) {\n            if (n & 1) ans = ans * tmp % mod;\n            tmp = tmp * tmp % mod;\n            n /= 2;\n        }\n        return ans;\n    }\n    constexpr lint inv() const { return this->power(mod - 2); }\n    constexpr ModInt operator^(lint n) const { return ModInt(this->power(n)); }\n    constexpr ModInt &operator^=(lint n) { return *this = *this ^ n; }\n};\nusing mint = ModInt<998244353>;\n\nvector<vector<int>> to;\n\nvector<int> D, par;\nint L;\nvoid dfs1(int now, int prv, int d)\n{\n    par[now] = prv;\n    D[now] = d;\n    for (auto nxt : to[now]) if (nxt != prv) {\n        dfs1(nxt, now, d + 1);\n    }\n}\n\nvector<mint> dp0, dp1, dp2;\n\nvoid dfs_dp(int now, int prv) {\n    dp0[now] = 1;\n    dp1[now] = 0;\n    dp2[now] = 0;\n    bool f = false;\n    for (auto nxt : to[now]) if (nxt != prv) {\n        f = true;\n        dfs_dp(nxt, now);\n        dp2[now] = dp2[now] * (dp2[nxt] + dp1[nxt] + dp0[nxt]) + dp1[now] * (dp1[nxt] + dp2[nxt]) + dp0[now] * dp2[nxt];\n        dp1[now] = dp1[now] * dp0[nxt] + dp0[now] * dp1[nxt];\n        dp0[now] = dp0[now] * dp0[nxt];\n    }\n    dp0[now] = dp0[now] * 3 + dp1[now] * 2 + dp2[now] * 2;\n    if (!f) {\n        if (D[now] == L / 2) {\n            dp0[now] = 2;\n            dp1[now] = 1;\n        }\n        else dp0[now] = 3;\n    }\n}\n\nvector<vector<vector<mint>>> dpv;  // (N, 3, 2)\nvoid dfs_even(int now, int prv) {\n    bool f = false;\n    dpv[now][0][0] = 1;\n    for (auto nxt : to[now]) if (nxt != prv) {\n        f = true;\n        dfs_even(nxt, now);\n        vector<vector<mint>> dpnxt(3, vector<mint>(2));\n        REP(np, 3) REP(nm, 2) REP(nnp, 3) REP(nnm, 2) {\n            dpnxt[min(np + nnp, 2)][min(nm + nnm, 1)] += dpv[now][np][nm] * dpv[nxt][nnp][nnm];\n        }\n        dpv[now] = dpnxt;\n    }\n    if (f) {\n        mint pl2 = 0, pl1 = 0, zero = 0, mi1 = 0;\n        REP(np, 3) REP(nm, 2) {\n            // +1\n            if (np == 2) pl2 += dpv[now][np][nm];\n            if (np == 1) pl1 += dpv[now][np][nm];\n            if (np == 0) zero += dpv[now][np][nm];\n            // +-0\n            zero += dpv[now][np][nm];\n            // -1\n            if (nm == 1) mi1 += dpv[now][np][nm];\n            if (nm == 0) zero += dpv[now][np][nm];\n            dpv[now][np][nm] = 0;\n        }\n        dpv[now][2][0] = pl2;\n        dpv[now][1][0] = pl1;\n        dpv[now][0][0] = zero;\n        dpv[now][0][1] = mi1;\n    }\n    else {\n        if (D[now] == L / 2) dpv[now][1][0] = dpv[now][0][1] = dpv[now][0][0] = 1;\n        else dpv[now][0][0] = 3;\n    }\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n    to.resize(N);\n    REP(_, N - 1) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        to[a].push_back(b);\n        to[b].push_back(a);\n    }\n    D.assign(N, 0);\n    par.assign(N, -1);\n    dfs1(0, -1, 0);\n\n    int S = max_element(ALL(D)) - D.begin();\n    dfs1(S, -1, 0);\n    int T = max_element(ALL(D)) - D.begin();\n    L = D[T];\n    int R = T;\n    REP(_, L / 2) R = par[R];\n\n    if (L % 2 == 0) {\n        ndarray(dpv, N, 3, 2);\n        dfs1(R, -1, 0);\n        for (auto A : to[R]) dfs_even(A, R);\n        vector<mint> P(3);\n        P[0] = 1;\n        for (auto A : to[R]) {\n            IREP(d, 3) {\n                if (d + 1 < 3) P[d + 1] += P[d] * dpv[A][1][0];\n                P[d] *= dpv[A][0][0];\n            }\n        }\n        cout << P[2] << endl;\n    }\n    else {\n        dp0.resize(N);\n        dp1.resize(N);\n        dp2.resize(N);\n        int U = par[R];\n        mint ret = 1;\n        REP(_, 2) {\n            dfs1(R, -1, 0);\n            mint P0 = 1, P1 = 0;\n            for (auto A : to[R]) if (A != U) {\n                dfs_dp(A, R);\n                P1 = P1 * dp0[A] + P0 * dp1[A];\n                P0 *= dp0[A];\n            }\n            ret *= P1;\n            swap(R, U);\n        }\n        cout << ret << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\ntemplate<int MOD>\nstruct ModInt {\n   using Mint = ModInt;\n   int val;\n   ModInt(ll __val = 0) { fix(__val % MOD + MOD); }\n   Mint& fix(int __val) { val = __val; if (val >= MOD) val -= MOD; return *this; }\n   explicit operator int() { return val; }\n   Mint operator + (const Mint &mt) const { return Mint().fix(val + mt.val); }\n   Mint operator - (const Mint &mt) const { return Mint().fix(val - mt.val + MOD); }\n   Mint operator * (const Mint &mt) const { return Mint().fix(ll(val) * mt.val % MOD + MOD); }\n   Mint& operator += (const Mint &mt) { return *this = *this + mt; }\n   Mint& operator -= (const Mint &mt) { return *this = *this - mt; }\n   Mint& operator *= (const Mint &mt) { return *this = *this * mt; }\n   Mint pow(int y) const {\n      Mint x = *this;\n      Mint ans(1);\n      for (; y > 0; y >>= 1, x *= x) {\n         if (y & 1) ans *= x;\n      }\n      return ans;\n   }\n   Mint operator -() const { return Mint().fix(MOD - val); }\n   Mint inv() const { return pow(MOD - 2); }\n   Mint operator / (const Mint &mt) const { return *this * mt.inv(); }\n   Mint& operator /= (const Mint &mt) const { return *this / mt; }\n   friend ostream& operator<<(ostream& os, const Mint& mt) { return os << mt.val; }\n};\n\nusing Mint = ModInt<998244353>;\n\nusing State = array<array<Mint, 3>, 3>;\n\nint main() {\n   ios_base::sync_with_stdio(false); cin.tie(nullptr);\n   int N;\n   cin >> N;\n   vector<vector<int>> adj(N);\n   for (int i = 0; i < N - 1; ++i) {\n      int v, u;\n      cin >> v >> u;\n      adj[--v].emplace_back(--u);\n      adj[u].emplace_back(v);\n   }\n   vector<int> diam;\n   {\n      vector<int> par(N, -1);\n      pair<int, int> best = {0, -1};\n      function<void(int, int, int)> dfs = [&](int v, int p, int dist) {\n         par[v] = p;\n         best = max(best, make_pair(dist, v));\n         for (auto u : adj[v]) if (u != p) {\n            dfs(u, v, dist + 1);\n         }\n      };\n      dfs(0, -1, 0);\n      int v = best.second;\n      best = {0, -1};\n      dfs(v, -1, 0);\n      int u = best.second;\n      while (u != v) {\n         diam.emplace_back(u);\n         u = par[u];\n      }\n      diam.emplace_back(v);\n   }\n   int limit = 0;\n   function<State(int, int, int)> dfs = [&](int v, int p, int dist) {\n      if (adj[v].size() == 1) {\n         State cur{};\n         if (dist == limit) cur[1][1] = 1;\n         else cur[0][0] = 1;\n         return cur;\n      }\n      State cur{};\n      cur[0][0] = 1;\n      for (int u : adj[v]) if (u != p) {\n         auto nxt = dfs(u, v, dist + 1);\n         State ncur{};\n         for (int cp = 0; cp < 3; ++cp) {\n            for (int cn = 0; cn < 3; ++cn) {\n               for (int np = 0; np < 3; ++np) {\n                  for (int nn = 0; nn < 3; ++nn) {\n                     ncur[min(cp + np, 2)][cn] += cur[cp][cn] * nxt[np][nn];\n                     ncur[cp][cn] += cur[cp][cn] * nxt[np][nn];\n                     ncur[cp][min(cn + nn, 2)] += cur[cp][cn] * nxt[np][nn];\n                  }\n               }\n            }\n         }\n         cur = ncur;\n      }\n      return cur;\n   };\n   if (diam.size() & 1) {\n      limit = diam.size() / 2;\n      int v = diam[diam.size() / 2];\n      auto cur = dfs(v, -1, 0);\n      cout << cur[1][1] / 2 << \"\\n\";\n   } else {\n      limit = (diam.size() / 2) - 1;\n      int v0 = diam[(diam.size() / 2) - 1];\n      int v1 = diam[diam.size() / 2];\n      auto cur0 = dfs(v0, v1, 0);\n      auto cur1 = dfs(v1, v0, 0);\n      cout << (cur0[1][0] + cur0[1][1] + cur0[1][2]) * (cur1[0][1] + cur1[1][1] + cur1[1][2]) << \"\\n\";\n   }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for (int i = (a); i <= int(b); i++)\n#define per(i, a, b) for (int i = (a); i >= int(b); i--)\n#define fi first\n#define se second\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 2e5, mod = 998244353;\nint n, f[maxn + 3], mx[maxn + 3], se[maxn + 3], g[maxn + 3];\nint far[maxn + 3], h[maxn + 3][3][3], t[3][3];\nvector<int> G[maxn + 3];\n\nvoid dfs(int u, int p = 0) {\n\trep(i, 0, G[u].size() - 1) {\n\t\tint v = G[u][i];\n\t\tif (v == p) continue;\n\t\tdfs(v, u);\n\t\tf[u] = max(f[u], f[v] + 1);\n\t\tif (!mx[u] || f[v] >= f[mx[u]]) {\n\t\t\tse[u] = mx[u], mx[u] = v;\n\t\t} else if (!se[u] || f[v] >= f[se[u]]) {\n\t\t\tse[u] = v;\n\t\t}\n\t}\n}\n\nvoid down(int u, int p = 0) {\n\trep(i, 0, G[u].size() - 1) {\n\t\tint v = G[u][i];\n\t\tif (v == p) continue;\n\t\tif (v == mx[u]) {\n\t\t\tg[v] = max(g[u], f[se[u]] + 1) + 1;\n\t\t} else {\n\t\t\tg[v] = max(g[u], f[mx[u]] + 1) + 1;\n\t\t}\n\t\tdown(v, u);\n\t}\n\tg[u] = max(f[u], g[u]);\n}\n\nvoid work(int u, int p = 0) {\n\trep(i, 0, G[u].size() - 1) {\n\t\tint v = G[u][i];\n\t\tif (v == p) continue;\n\t\twork(v, u);\n\t\tfar[u] = max(far[u], far[v] + 1);\n\t}\n\tif (!far[u]) { h[u][1][1] = 1; return; }\n\th[u][0][0] = 1;\n\trep(i, 0, G[u].size() - 1) {\n\t\tint v = G[u][i];\n\t\tif (v == p) continue;\n\t\tmemset(t, 0, sizeof(t));\n\t\trep(a, 0, 2) rep(b, 0, 2) if (h[u][a][b]) {\n\t\t\trep(c, 0, 2) rep(d, 0, 2) if (h[v][c][d]) {\n\t\t\t\tint x = 1ll * h[u][a][b] * h[v][c][d] % mod;\n\t\t\t\trep(e, -1, 1) {\n\t\t\t\t\tint t1 = min(2, (far[v] + e == far[u]) ? a + c : a);\n\t\t\t\t\tint t2 = min(2, (far[v] - e == far[u]) ? b + d : b);\n\t\t\t\t\tt[t1][t2] += x, t[t1][t2] >= mod ? t[t1][t2] -= mod : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemcpy(h[u], t, sizeof(h[u]));\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\trep(i, 1, n - 1) {\n\t\tint u, v; scanf(\"%d %d\", &u, &v);\n\t\tG[u].push_back(v), G[v].push_back(u);\n\t}\n\tf[0] = -1;\n\tdfs(1);\n\tdown(1);\n\tint mn = n;\n\trep(i, 1, n) mn = min(mn, g[i]);\n\tint a = 0, b = 0, c = 0;\n\trep(i, 1, n) if (g[i] == mn) {\n\t\tif (++c == 1) a = i;\n\t\telse if (c == 2) b = i;\n\t\telse exit(1);\n\t}\n\tif (c == 1) {\n\t\twork(a);\n\t\tprintf(\"%d\\n\", int(1ll * (mod + 1) / 2 * h[a][1][1] % mod));\n\t} else {\n\t\twork(a, b), work(b, a);\n\t\tprintf(\"%d\\n\", int(((ll)h[a][1][0] + h[a][1][1] + h[a][1][2]) * ((ll)h[b][1][0] + h[b][1][1] + h[b][1][2]) % mod));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i,a,b) for (int i=int(a);i<=int(b);i++)\n#define R(i,a,b) for (int i=int(a);i<int(b);i++)\n#define D(i,a,b) for (int i=int(a);i>=int(b);i--)\n#define go(i,x) for (int i=head[x];i;i=Next[i])\n#define pb push_back\n#define si size()\n#define fi first\n#define se second\n#define pa pair < ll,ll >\n#define ll long long\n#define mp make_pair\n#define be begin()\n#define en end()\n#define put putchar('\\n')\n#define gc getchar\n#define pc putchar\n#define N 6000055\n#define mo 998244353\n#define inf 1000000007\n#define ret return puts(\"-1\"),0\nusing namespace std;\ninline ll read(){\n\tll su=0,f=1;char c=gc();\n\tfor (;c<'0'||c>'9';c=gc()) if (c=='-') f=-1;\n\tfor (;c>='0'&&c<='9';c=gc()) su=su*10+c-'0';\n\treturn su*f;\n}\ninline void wr(ll x){\n\tif (x<0) pc('-'),wr(-x);\n\telse{if (x>=10) wr(x/10);pc(x%10+'0');}\n}\ninline void wri(ll x){wr(x);pc(' ');}\ninline void wrn(ll x){wr(x);put;}\ninline void wrn(ll x,ll y){wri(x);wrn(y);}\ninline void wrn(ll x,ll y,ll z){wri(x);wrn(y,z);}\nint ans,n,m,f[N][2],fa[N],dis[N],lo,rt,mx;\ninline void ad(int &x,int k){x+=k;x-=(x>=mo)?mo:0;}\nint Next[N*2],head[N],to[N*2],nedge;\n#define V to[i]\nvoid add(int a,int b){Next[++nedge]=head[a];head[a]=nedge;to[nedge]=b;}\nvoid add_ne(int a,int b){add(a,b);add(b,a);}\nvoid dfs(int x){\n\tmx=(dis[x]>dis[mx])?x:mx;\n\tgo(i,x){\n\t\tif (V==fa[x]) continue;\n\t\tfa[V]=x;dis[V]=dis[x]+1;dfs(V);\n\t}\n}\nvoid solve(int x){\n\tint pd=0;\n\tf[x][0]=1;\n\tgo(i,x){\n\t\tif (V==fa[x]) continue;\n\t\tsolve(V);pd++;\n\t\tf[x][1]=1ll*f[x][1]*f[V][0]%mo;\n\t\tad(f[x][1],1ll*f[x][0]*f[V][1]%mo);\n\t\tf[x][0]=1ll*f[x][0]*f[V][0]%mo;\n\t}\n\tif (pd){\n\t\tf[x][0]=1ll*f[x][0]*3%mo;\n\t\tad(f[x][0],f[x][1]*2%mo);\n\t}\n\telse{\n\t\tif (dis[x]==lo/2) f[x][1]=1,f[x][0]=2;\n\t\telse f[x][0]=3;\n\t}\n}\nsigned main(){\n\tn=read();\n\tR(i,1,n) add_ne(read(),read());\n\tdfs(1);\n\trt=mx;mx=0;dis[rt]=0;fa[rt]=0;\n\tdfs(rt);\n\tlo=dis[mx];\n\tF(i,1,lo/2) mx=fa[mx];\n\tif (lo&1){\n\t\tint x=mx,y=fa[mx];\n\t\tfa[y]=x;dis[x]=dis[y]=0;dfs(x);dfs(y);solve(x);solve(y);\n\t\twrn(1ll*f[x][1]*f[y][1]%mo);\n\t}\n\telse{\n\t\tint x=mx;\n\t\tfa[x]=0;dis[x]=0;dfs(x);\n\t\tsolve(x);\n\t\tf[x][0]=1;f[x][1]=0;\n\t\tgo(i,x){\n\t\t\tans=1ll*ans*f[x][0]%mo;\n\t\t\tad(ans,1ll*f[x][1]*f[V][1]%mo);\n\t\t\tf[x][1]=1ll*f[x][1]*f[V][0]%mo;\n\t\t\tad(f[x][1],1ll*f[x][0]*f[V][1]%mo);\n\t\t\tf[x][0]=1ll*f[x][0]*f[V][0]%mo;\t\t\t\n\t\t}\n\t\twrn(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[202020];\nconst ll mo=998244353;\nll dp[202020][3][3];\n\npair<int,int> farthest(int cur,int pre,int d,vector<int>& D) {\n\tD[cur]=d;\n\tpair<int,int> r={d,cur};\n\tFORR(e,E[cur]) if(e!=pre) r=max(r, farthest(e,cur,d+1,D));\n\treturn r;\n}\n\npair<int,vector<int>> diameter() { // diameter,center\n\tvector<int> D[2];\n\tD[0].resize(N);\n\tD[1].resize(N);\n\tauto v1=farthest(0,0,0,D[0]);\n\tauto v2=farthest(v1.second,v1.second,0,D[0]);\n\tfarthest(v2.second,v2.second,0,D[1]);\n\tpair<int,vector<int>> R;\n\tR.first = v2.first;\n\t//重心を取る場合\n\tfor(int i=N-1;i>=0;i--) if(D[0][i]+D[1][i]==R.first && abs(D[0][i]-D[1][i])<=1) R.second.push_back(i);\n\n\treturn R;\n}\n\nvoid dfs(int cur,int pre,int lef) {\n\tif(lef==0) {\n\t\tdp[cur][1][1]=1;\n\t}\n\telse {\n\t\tdp[cur][0][0]=1;\n\t}\n\t\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\tdfs(e,cur,lef-1);\n\t\tll to[3][3]={};\n\t\tint a1,a2,b1,b2;\n\t\tFOR(a1,3) FOR(a2,3) FOR(b1,3) FOR(b2,3) {\n\t\t\t// +1\n\t\t\tto[min(a1+b1,2)][a2]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t\t// 0\n\t\t\tto[a1][a2]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t\t// -1\n\t\t\tto[a1][min(a2+b2,2)]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t}\n\t\t\n\t\tFOR(a1,3) FOR(a2,3) dp[cur][a1][a2]=to[a1][a2]%mo;\n\t}\n\t\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tauto R=diameter();\n\tif(R.second.size()==1) {\n\t\tx=R.second[0];\n\t\tdfs(x,-1,R.first/2);\n\t\tcout<<dp[x][1][1]*((mo+1)/2)%mo<<endl;\n\t}\n\telse {\n\t\tx=R.second[0];\n\t\ty=R.second[1];\n\t\tdfs(x,y,R.first/2);\n\t\tdfs(y,x,R.first/2);\n\t\tdp[x][0][1]+=dp[x][1][1];\n\t\tdp[x][1][0]+=dp[x][1][1];\n\t\tdp[y][0][1]+=dp[y][1][1];\n\t\tdp[y][1][0]+=dp[y][1][1];\n\t\tll ret=(dp[x][0][1]*dp[y][1][0])%mo;\n\t\tcout<<ret<<endl;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 114514*2\n#define mod 998244353\n#define int long long \nvoid add(int&x,int y){\n\tx=(x+y)%mod;\n}\nint dp[nn][4][4],n,diam,c1,c2;\nvector<int> v[nn];int chk[nn];\nint dep[nn],pa[nn];\nvoid dfs(int x,int p,int slg=0){\n\tif(!p or slg) dep[x]=0;else dep[x]=dep[p]+1;pa[x]=p;\n\tfor(int i=0;i<v[x].size();i++) if(v[x][i]!=p) dfs(v[x][i],x);\n}\nint walk(int x,int d){\n\tif(d==0) return x;\n\treturn walk(pa[x],d-1);\n}\nint mst(){\n\tint ret=0;for(int i=1;i<=n;i++) ret=max(ret,dep[i]);for(int i=1;i<=n;i++) if(dep[i]==ret) return i;\n}\nint f[2][4];int tmp[4][4];\n\nvoid copy(int x){\n\tfor(int i=0;i<4;i++) for(int j=0;j<4;j++) tmp[i][j]=dp[x][i][j],dp[x][i][j]=0;\n}\n\nvoid efs(int x,int p){\n\tdp[x][3*(dep[x]==diam/2)][0]=1;int leaf=1;\n\tfor(int i=0;i<v[x].size();i++) if(v[x][i]!=p){\n\t\tefs(v[x][i],x);\n\t\tleaf=0;\n\t\tcopy(x);\n\t\tfor(int j=0;j<16;j++) for(int k=0;k<16;k++) add(dp[x][(j%4)|(k%4)][(j/4)|(k/4)|((j%4)&(k%4))],tmp[k%4][k/4]*dp[v[x][i]][j%4][j/4]);\n\t}\n\t\n\tif(dep[x]!=diam/2 and leaf and 0) dp[x][0][0]=3;\n\telse if(x!=c1 and x!=c2){\n\t\tcopy(x);\n\t\tfor(int k=0;k<16;k++) for(int j=0;j<=2;j++) add(dp[x][(k%4)&j][(k/4)&j],tmp[k%4][k/4]);\n\t}\n}\n\n\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tif(n<=2) return puts(\"1\")*0;\n\t\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;scanf(\"%lld%lld\",&x,&y);\n\t\tv[x].push_back(y);v[y].push_back(x);\n\t}\n\t\n\tdfs(1,0);int x=mst();\n\tdfs(x,0);int y=mst();\n\tdiam=dep[y];\n\tif(diam%2==0){\n\t\tc1=walk(y,diam/2);\n\t\tint now=0;f[now][0]=1;dfs(c1,0);efs(c1,0);\n/*\t\tfor(int i=0;i<v[c1].size();i++) {\n\t\t\tefs(v[c1][i],c1);\n\t\t\tnow^=1;memset(f[now],0,sizeof f[now]);\n\t\t\tfor(int j=0;j<4;j++) for(int k=0;k<4;k++) add(f[now][j|k],dp[v[c1][i]][j][0]*f[now^1][k]);\n\t\t}\n\t\tcout<<f[now][3];*/\n\t\tcout<<dp[c1][3][0]*(mod+1)/2%mod;\n\t}\n\telse{\n\t\tc1=walk(y,diam/2);\n\t\tdfs(y,0);\n\t\tc2=walk(x,diam/2);\n\t\t\n\t\tdfs(c1,c2,1);dfs(c2,c1,1);\n\t\tefs(c1,c2);\n\t\tefs(c2,c1);\n\t\t\n\t\tcout<<-dp[c1][1][0]*dp[c2][2][0]%mod;\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\n\nint n;\nvector<int> G[1 << 18];\n\nint mostfar(int x) {\n\tqueue<int> q;\n\tvector<bool> used(n, false);\n\tused[x] = true; q.push(x);\n\tint res = x;\n\twhile (!q.empty()) {\n\t\tint id = q.front(); q.pop();\n\t\tres = id;\n\t\trep(j, G[id].size()) {\n\t\t\tint to = G[id][j];\n\t\t\tif (used[to])continue;\n\t\t\tused[to] = true;\n\t\t\tq.push(to);\n\t\t}\n\t}\n\treturn res;\n}\n\nvector<int> make_road(int l, int r) {\n\tvector<int> res;\n\tfunction<bool(int, int)> dfs = [&](int id, int fr)->bool {\n\t\tif (id == r) {\n\t\t\tres.push_back(id); return true;\n\t\t}\n\t\trep(j, G[id].size()) {\n\t\t\tint to = G[id][j]; if (to == fr)continue;\n\t\t\tif (dfs(to, id)) {\n\t\t\t\tres.push_back(id); return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\tdfs(l, -1);\n\treturn res;\n}\n\nbool onroad[1 << 18];\nbool marked[1 << 18];\nvoid mark(int id, int fr, int k, int dep) {\n\tif (dep == k)marked[id] = true;\n\trep(j, G[id].size()) {\n\t\tint to = G[id][j];\n\t\tif (to == fr)continue;\n\t\tmark(to, id, k, dep + 1);\n\t}\n}\nusing dpval = vector<ll>;\n\ndpval merge(dpval &a, dpval &b) {\n\tdpval res = { 0,0,0 };\n\trep(i, 3) {\n\t\trep(j, 3) {\n\t\t\tif (i == 2 && j == 2) {\n\t\t\t\t(res[2] += a[2] * b[2]) %= mod;\n\t\t\t}\n\t\t\telse if (i*j == 2) {\n\t\t\t\t(res[1] += a[i] * b[j]) %= mod;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t(res[0] += a[i] * b[j]) %= mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nvoid update(dpval &a) {\n\tdpval nex = { 0,0,0 };\n\tnex[0] = a[0];\n\tnex[1] = a[1];\n\tnex[2] = a[0] * 2 + a[1] * 2 + a[2] * 3; nex[2] %= mod;\n\tswap(a, nex);\n}\ndpval dfs(int id, int fr) {\n\tdpval res = { 0,0,1 };\n\tif (marked[id])res = { 0,1,0 };\n\trep(j, G[id].size()) {\n\t\tint to = G[id][j];\n\t\tif (to == fr)continue;\n\t\tdpval nex = dfs(to, id);\n\t\tres = merge(res, nex);\n\t}\n\tupdate(res);\n\treturn res;\n}\nvoid solve() {\n\tcin >> n;\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tif (n == 2) {\n\t\tcout << 1 << endl; return;\n\t}\n\tint r = 0;\n\tint l = mostfar(r);\n\tr = mostfar(l);\n\tvector<int> v = make_road(l, r);\n\tint len = v.size();\n\trep(i, len)onroad[v[i]] = true;\n\trep(i, len) {\n\t\tint r = v[i];\n\t\trep(j, G[r].size()) {\n\t\t\tint to = G[r][j];\n\t\t\tif (!onroad[to]) {\n\t\t\t\tint m = min(i, len - 1 - i);\n\t\t\t\tmark(to, r, m, 1);\n\t\t\t}\n\t\t}\n\t}\n\tmarked[v[0]] = marked[v[len - 1]] = true;\n\tif (len % 2) {\n\t\tint m = v[len / 2];\n\t\tvector<LP> pv;\n\t\trep(j, G[m].size()) {\n\t\t\tint to = G[m][j];\n\t\t\tdpval nex = dfs(to, m);\n\t\t\tnex[2] -= (nex[0] + nex[1]);\n\t\t\twhile (nex[2] < 0)nex[2] += mod;\n\t\t\tLP cur = { nex[1],nex[2] };\n\t\t\tpv.push_back(cur);\n\t\t}\n\t\tll ans = 0;\n\t\tvector<int> zeros;\n\t\trep(i, pv.size()) {\n\t\t\tswap(pv[i].first, pv[i].second);\n\t\t\t//cout << pv[i].first << \" \" << pv[i].second << endl;\n\t\t\tif (pv[i].first == 0)zeros.push_back(i);\n\t\t}\n\t\t/*if (zeros.size() >= 3)ans = 0;\n\t\telse if (zeros.size() == 2) {\n\t\t\tans = 1;\n\t\t\trep(i, pv.size()) {\n\t\t\t\tif (pv[i].first == 0)ans = ans * pv[i].second%mod;\n\t\t\t\telse ans = ans * pv[i].first%mod;\n\t\t\t}\n\t\t}\n\t\telse if (zeros.size() == 1) {\n\t\t\tll al = 1;\n\t\t\trep(i, pv.size()) {\n\t\t\t\tif (pv[i].first > 0)al = al * pv[i].first%mod;\n\t\t\t\telse al = al * pv[i].second%mod;\n\t\t\t}\n\t\t\trep(i, pv.size()) {\n\t\t\t\tif (pv[i].first > 0) {\n\t\t\t\t\tll csum = al * pv[i].second%mod*mod_pow(pv[i].first, mod - 2) % mod;\n\t\t\t\t\tans += csum;\n\t\t\t\t\tif (ans >= mod)ans -= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\t//else {\n\t\t\tvector<ll> rpv(pv.size() + 1);\n\t\t\trep(i, pv.size()) {\n\t\t\t\tll c = pv[i].second*mod_pow(pv[i].first, mod - 2) % mod;\n\t\t\t\t(rpv[i + 1] += rpv[i] + c) %= mod;\n\t\t\t}\n\t\t\tll al = 1;\n\t\t\trep(i, pv.size())al = al * pv[i].first%mod;\n\t\t\trep(i, pv.size()) {\n\t\t\t\tll pre = al * pv[i].second%mod*mod_pow(pv[i].first, mod - 2) % mod;\n\t\t\t\tll z = rpv[pv.size()] - rpv[i + 1]; if (z < 0)z += mod;\n\t\t\t\tpre = pre * z%mod;\n\t\t\t\tans += pre; if (ans >= mod)ans -= mod;\n\t\t\t}\n\t\t//}\n\t\tcout << ans << endl;\n\t}\n\telse {\n\t\tint m1 = v[len / 2 - 1], m2 = v[len / 2];\n\t\tdpval v1 = { 0,0,1 }, v2 = { 0,0,1 };\n\t\trep(j, G[m1].size()) {\n\t\t\tint to = G[m1][j];\n\t\t\tif (to == m2)continue;\n\t\t\tdpval nex = dfs(to, m1);\n\t\t\tv1 = merge(v1, nex);\n\t\t}\n\t\trep(j, G[m2].size()) {\n\t\t\tint to = G[m2][j];\n\t\t\tif (to == m1)continue;\n\t\t\tdpval nex = dfs(to, m2);\n\t\t\tv2 = merge(v2, nex);\n\t\t}\n\t\tll ans = v1[1] * v2[1] % mod;\n\t\tcout << ans << endl;\n\t}\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(17);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// I think of what the world could be, A vision of the one I see, A million dreams is all it's gonna take\n\n#include<bits/stdc++.h>\n\n#define F first\n#define S second\n#define PB push_back\n#define sz(s) int((s).size())\n#define bit(n,k) (((n)>>(k))&1)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn = 2e5 + 10, mod = 998244353;\n\nint h[maxn], par[maxn];\nvector<int> v[maxn];\n\npii far(int u, int pr = -1){\n    par[u] = pr;\n    h[u] = pr == -1 ? 0 : (h[pr] + 1);\n    pii ans = {0, u};\n    for(int y : v[u]){\n\tif(y != pr){\n\t    pii p = far(y, u);\n\t    p.F++;\n\t    ans = max(ans, p);\n\t}\t    \n    }\n    return ans;\n}\n\nint total[maxn], dp1[maxn], dp2[maxn], under[maxn];\n\nvoid dfs(int u, int par = -1){\n    total[u] = 1, dp2[u] = 1;\n    if(sz(v[u]) == (par != -1))\n\tdp2[u] = 0, dp1[u] = 1;\n    for(int y : v[u]){\n\tif(y != par){\n\t    dfs(y, u);\n\t    under[u] = max(under[u], under[y] + 1);\n\t    total[u] = 3ll * total[u] * total[y] % mod;\n\t}\n    }\n    for(int y : v[u]){\n\tif(y != par){\n\t    int no = 0, yes = 0;\n\t    if(under[u] == under[y] + 1){\n\t\tno = (2ll * total[y] + 1ll * dp2[y]) % mod;\n\t\tyes = dp1[y];\n\t    }\n\t    else{\n\t\tno = 3ll * total[y] % mod;\n\t\tyes = 0;\n\t    }\n\t    dp1[u] = (1ll * dp1[u] * no + 1ll * dp2[u] * yes) % mod;\n\t    dp2[u] = (1ll * dp2[u] * no) % mod;\n\t}\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie();\n\n    int n;\n    cin >> n;\n    for(int i = 0; i < n-1; i++){\n\tint a, b;\n\tcin >> a >> b;\n\tv[a].PB(b);\n\tv[b].PB(a);\n    }\n    int A = far(1).S;\n    pii p = far(A);\n    int diam = p.F, B = p.S;\n\n    int ans = 0;\n\n    if(diam & 1){\n\tfor(int i = 0; i < (diam/2); i++)\n\t    B = par[B];\n\tA = par[B];\n\tdfs(A, B);\n\tdfs(B, A);\n\tans = 1ll * dp1[A] * dp1[B] % mod;\n    }\n    else{\n\tfor(int i = 0; i < (diam/2); i++)\n\t    B = par[B];\n\tdfs(B);\n\tint zer = 1, one = 0, two = 0; \n\tfor(int y : v[B]){\n\t    int yes = 0, no = 0;\n\t    if(under[B] == under[y] + 1){\n\t\tno = (1ll * total[y] + 2ll * dp2[y]) % mod;\n\t\tyes = dp1[y];\n\t    }\n\t    else{\n\t\tno = 3ll * total[y] % mod;\n\t    }\n\t    two = (1ll * two * no + 1ll * one * yes) % mod;\n\t    one = (1ll * one * no + 1ll * zer * yes) % mod;\n\t    zer = (1ll * zer * no) % mod;\n\t}\n\tans = two;\n    }\n    return cout << ans << endl, 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define MOD 998244353\ntemplate<typename ty1,typename ty2>\ninline int add(ty1 x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x += y; return x < MOD ? x : x - MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline void addto(ty1 &x, ty2 y) {\n\t\t  if(y>=MOD)y%=MOD;\n\t\t  if(x>=MOD)x%=MOD;\n\t      x += y; if (x >= MOD) x -= MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int sub(ty1 x, ty2 y) {\n\t\tif(y>=MOD)y%=MOD;\n\t\t if(x>=MOD)x%=MOD;\n        x -= y; return x < 0 ? x + MOD : x;\n}\ntemplate<typename ty1,typename ty2>\ninline void subto(ty1 &x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x -= y; if (x < 0) x += MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int mul(ty1 x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        return 1ll * x * y % MOD;\n}\ntemplate<typename ty1,typename ty2>\nvoid multo(ty1 &x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        x=1ll * x * y % MOD;\n}\n  \nlong long int gcd(long long int a, long long int b){\n\tif (a > b){\n\t\tswap(a, b);\n\t}\n\twhile (a){\n\t\tswap(a, b);\n\t\ta %= b;\n\t}\n\treturn b;\n}\nlong long int lcm(long long int a, long long int b){\n\treturn a / gcd(a, b)*b;\n}\nlong long int ppow(long long int i, long long int j){\n\t\tlong long int res = 1LL;\n\t\twhile (j){\n\t\t\tif ((j & 1LL)){\n\t\t\t\tres *= i;\n\t\t\t\tif (res >= MOD){\n\t\t\t\t\tres %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj >>= 1;\n\t\t\ti *= i;\n\t\t\tif (i >= MOD){\n\t\t\t\ti %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\nclass Combination{\n\t\npublic:\n\tvector<long long int> k;\n\tvector<long long int> r;\n\tvoid resize(int N){\n\t\tk.resize(N + 2);\n\t\tr.resize(N + 2);\n\t\tk[0] = 1;\n\t\tfor (int i = 1; i < N+2; i++){\n\t\t\tk[i] = k[i - 1];\n\t\t\tk[i] *= i;\n\t\t\tif (k[i] >= MOD)k[i] %= MOD;\n\t\t}\n\t\tlong long int al = k[k.size() - 1];\n\t\tlong long int iv = ppow(k[k.size() - 1],MOD-2);\n\t\tr[k.size() - 1] = iv;\n\t\tfor (int i = (int)(r.size()) - 2; i >= 0; i--){\n\t\t\tr[i] = r[i + 1] * (i + 1);\n\t\t\tif (r[i] >= MOD){\n\t\t\t\tr[i] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int C(int a, int b){\n\t\tif (a < b)return 0;\n\t\tlong long int up = k[a];\n\t\tlong long int dw = r[b] * r[a - b];\n\t\tdw %= MOD;\n\t\tup *= dw;\n\t\tup %= MOD;\n\t\treturn up;\n\t}\n\tlong long int H(int a, int b){\n\t\treturn C(a + b - 1, b);\n\t}\n\tlong long int catalan_number(int n){\n\t\treturn (C(2 * n, n) + MOD - C(2 * n, n - 1)) % MOD;\n\t}\n};\nCombination C;\n\n#define MAX 200002\nint n;\n\n\nstruct treediameter{\n\t//直径は色々いい性質がある\n\t//中心から(２頂点の場合それをくっつける）同じ距離のびた２つの頂点間が直径\n\t//直径は最大長であることにも注意\n\tconst vector<vector<int> >&g;\n\tint r1,r2;\n\tvector<int> d1,d2;  //両端からのdist\n\tint dia;\n\tvoid dfs(int v,int p,int cur,vector<int> &d){\n\t\td[v]=cur;\n\t\tfor(auto e:g[v])if(e!=p)\n\t\t\tdfs(e,v,cur+1,d);\n\t}\n\ttreediameter(const vector<vector<int> > &gg):g(gg),d1(g.size()),d2(g.size()){\n\t\tdfs(0,-1,0,d1);\n\t\tr1=max_element(d1.begin(),d1.end())-d1.begin();\n\t\tdfs(r1,-1,0,d1);\n\t\tr2=max_element(d1.begin(),d1.end())-d1.begin();\n\t\tdfs(r2,-1,0,d2);\n\t\tdia=d1[r2];\n\t}\n\tvector<int> find_centre(){  //直径の中心をさがす 1頂点 or 2頂点　直径は必ずこれらすべてを通る\n\t\tvector<int> ret;\n\t\tfor(int i=0;i<d1.size();i++){\n\t\t\tif(d1[i]+d2[i]==dia&&abs(d1[i]-d2[i])<=1){\n\t\t\t\tret.push_back(i);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n//treediameter(v)\n\nvector<vector<int> > v;\n\nbool flag[MAX];\n\n//0:none without substraction\n//1:positive without substraction\n// 2: none with substraction\nint dp[MAX][3];\nbool us[MAX][3];\nint target;\ninline int dfs(int b,int ty,int pr=-1,int d=0){\n\tif(us[b][ty]){\n\t\treturn dp[b][ty];\n\t}\n\tus[b][ty]=true;\n\tint ava=0;\n\tvector<int> can;\n\tfor(int go:v[b]){\n\t\tif(go==pr||flag[go])continue;\n\t\tava++;\n\t\tcan.push_back(go);\n\t}\n\tif(ava==0){\n\t\t//leaf\n\t\tif(ty==1){\n\t\t\tif(d==target){\n\t\t\t\tdp[b][ty]=1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tdp[b][ty]=0;\n\t\t\treturn 0;\n\t\t}\n\t\tif(ty==0){\n\t\t\tif(d==target){\n\t\t\t\tdp[b][ty]=0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdp[b][ty]=1;\n\t\t\treturn 1;\n\t\t}\n\t\tif(ty==2){\n\t\t\tdp[b][ty]=1;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif(ty==1){\n\t\tfor(int go:can){\n\t\t\tauto ret=dfs(go,1,b,d+1);\n\t\t\tfor(int goo:can){\n\t\t\t\tif(go!=goo){\n\t\t\t\t\tmulto(ret,add(dfs(goo,0,b,d+1),mul(2,dfs(goo,2,b,d+1))));\n\t\t\t\t}\n\t\t\t}\n\t\t\taddto(dp[b][ty],ret);\n\t\t}\n\t}\n\tif(ty==2){\n\t\tdp[b][ty]=1;\n\t\tfor(int goo:can){\n\t\t\tmulto(dp[b][ty],mul(3,dfs(goo,2,b,d+1)));\n\t\t}\n\t}\n\tif(ty==0){\n\t\tdp[b][ty]=1;\n\t\tfor(int goo:can){\n\t\t\tmulto(dp[b][ty],add(dfs(goo,0,b,d+1),mul(2,dfs(goo,2,b,d+1))));\n\t\t}\n\t}\n\treturn dp[b][ty];\n}\n\nint main(){\n\tcin>>n;\n\tv.resize(n);\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tauto dia=treediameter(v);\n\tauto centre=dia.find_centre();\n\tfor(auto el:centre){\n\t\tflag[el]=true;\n\t}\n\tif(centre.size()==1){\n\t\tint pos=centre[0];\n\t\ttarget=dia.dia/2;\n\t\ttarget--;\n\t\tlong long int ans=0;\n\t\tfor(int el1:v[pos]){\n\t\t\tfor(int el2:v[pos]){\n\t\t\t\tif(el1!=el2){\n\t\t\t\t\tauto ret=mul(dfs(el1,1,pos,0),dfs(el2,1,pos,0));\n\t\t\t\t\tfor(int el3:v[pos]){\n\t\t\t\t\t\tif(el1!=el3&&el2!=el3){\n\t\t\t\t\t\t\tmulto(ret,add(dfs(el3,0,pos,0),mul(2,dfs(el3,2,pos,0))));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\taddto(ans,ret);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmulto(ans,ppow(2,MOD-2));\n\t\tans%=MOD;\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\telse{\n\t\ttarget=dia.dia/2;\n\t\tlong long int ans=0;\n\t\taddto(ans,mul(dfs(centre[0],1),dfs(centre[1],1)));\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n#define resz resize\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define sort_by(x, y) sort(all(x), [&](const auto& a, const auto& b) { return y; })\n\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpll = vector<pll>;\nusing vvpll = vector<vpll>;\nusing vpdd = vector<pdd>;\nusing vvpdd = vector<vpdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\ntemplate<typename T> using max_heap = priority_queue<T>;\ntemplate<typename T> using min_heap = priority_queue<T, vector<T>, greater<T>>;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const deque<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T, bool pretty = true> void prContain(const T& x) {\n        if (pretty) pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?pretty?\", \":\" \":\"\",a), fst = 0;\n        if (pretty) pr(\"}\");\n    }\n    template<class T> void pc(const T& x) { prContain<T, false>(x); pr(\"\\n\"); }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const deque<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __numeric {\n    template<typename T>\n    typename enable_if<is_integral<T>::value, T>::type floor(T n, T d) {\n        assert(d != 0);\n        if (d < 0) tie(n, d) = mp(-n, -d);\n        return n / d - ((n < 0) && (n % d));\n    }\n    template<typename T>\n    typename enable_if<is_integral<T>::value, T>::type ceil(T n, T d) {\n        assert(d != 0);\n        if (d < 0) tie(n, d) = mp(-n, -d);\n        return n / d + ((n > 0) && (n % d));\n    }\n};\nusing namespace __numeric;\n\nnamespace __algorithm {\n    template<typename T> void dedup(vector<T>& v) {\n        sort(all(v)); v.erase(unique(all(v)), v.end());\n    }\n    template<typename T> typename vector<T>::iterator find(vector<T>& v, const T& x) {\n        auto it = lower_bound(all(v), x); return it != v.end() && *it == x ? it : v.end();\n    }\n    template<typename T> size_t index(vector<T>& v, const T& x) {\n        auto it = find(v, x); assert(it != v.end() && *it == x); return it - v.begin();\n    }\n    template<typename C, typename T, typename OP> vector<T> prefixes(const C& v, T id, OP op) {\n        vector<T> r(sz(v)+1, id); F0R (i, sz(v)) r[i+1] = op(r[i], v[i]); return r;\n    }\n    template<typename C, typename T, typename OP> vector<T> suffixes(const C& v, T id, OP op) {\n        vector<T> r(sz(v)+1, id); F0Rd (i, sz(v)) r[i] = op(v[i], r[i+1]); return r;\n    }\n}\nusing namespace __algorithm;\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-parameter\"\nstruct monostate {\n    friend istream& operator>>(istream& is, const monostate& ms) { return is; }\n    friend ostream& operator<<(ostream& os, const monostate& ms) { return os; }\n    friend monostate operator+(const monostate& a, const monostate& b) { return a; }\n} ms;\n#pragma GCC diagnostic pop\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        cout << fixed << setprecision(15);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\n// tree {{{\nstruct edge {\n    int uv; //int id;\n    edge (int _uv = 0, __attribute__((unused))monostate _ = ms) : uv(_uv) {}\n    int operator()(int u) const { assert(uv); return uv ^ u; }\n    monostate& wt() const { return ms; }\n    struct path { int len;\n        path operator+(const path& p) const { return {len+p.len}; }\n    }; explicit operator path() { return {1}; }\n};\ntemplate<typename W> struct wedge : edge {\n    mutable W w;\n    wedge (int _uv = 0, W _w = {}) : edge(_uv), w(_w) {}\n    W& wt() const { return w; }\n    struct path { int len; W wt;\n        path operator+(const path& p) { return {len+p.len, wt+p.wt}; }\n    }; explicit operator path() { return {1, w}; }\n};\n\nenum INPUT_FORMAT { EDGE_LIST, PARENT_LIST };\ntemplate<typename E> struct tree {\n    int V, root;\n    vector<vector<E>> nbrs, children;\n\n    vi par, depth, subt_sz;\n    vi preorder, reverse_preorder;\n\n    tree() : V(0), root(-1) {}\n    tree(int _V, int _root) : V(_V), root(_root), nbrs(V) {}\n\n    const E& up_edge(int u) const {\n        assert(u != root);\n        return nbrs[u].front();\n    }\n\n    void add_edge(int u, int v, E e = {}) {\n        assert(0 <= u && u < V && 0 <= v && v < V);\n        e.uv = u ^ v;\n        nbrs[u].pb(e);\n        nbrs[v].pb(e);\n    }\n\n    template<INPUT_FORMAT FMT = EDGE_LIST, bool FIRST_INDEX = 1>\n    friend void re(tree& t) {\n        assert(t.V > 0);\n        for (int i = 0; i < t.V - 1; i++) {\n            int u, v;\n            re(u), u -= FIRST_INDEX;\n            if (FMT == PARENT_LIST) v = i+1;\n            else re(v), v -= FIRST_INDEX;\n            E e{}; re(e.wt()); // e.id = i\n            t.add_edge(u, v, e);\n        }\n        t.init();\n    }\n\n    void init() {\n        children.resz(V), par.resz(V), depth.resz(V), subt_sz.resz(V);\n        par[root] = -1, depth[root] = 0;\n\n        traverse(root);\n        for (int u = 0; u < V; u++) {\n            sort_by(nbrs[u], subt_sz[a(u)] > subt_sz[b(u)]);\n            children[u].clear();\n            copy(nbrs[u].begin() + (u != root), nbrs[u].end(), back_inserter(children[u]));\n        }\n\n        preorder.clear(), preorder.reserve(V), build_preorder(root);\n        reverse_preorder = preorder, reverse(all(reverse_preorder));\n    }\n    void reroot(int _root) { root = _root; init(); }\n\n    void traverse(int u) {\n        subt_sz[u] = 1;\n        for (E e : nbrs[u]) {\n            int v = e(u);\n            if (v == par[u]) continue;\n            par[v] = u;\n            depth[v] = depth[u] + 1;\n            traverse(v);\n            subt_sz[u] += subt_sz[v];\n        }\n    }\n\n    void build_preorder(int u) {\n        preorder.pb(u);\n        for (E e : children[u]) build_preorder(e(u));\n    }\n\n    friend void pr(const tree& t) {\n        pr(\"{V=\", t.V, \" root=\", t.root, \" |\");\n        for (int u = 0; u < t.V; u++) {\n            pr(\" \", u, \"--{\");\n            for (E e : t.children[u])\n                pr(\"(ch=\", e(u), \" wt=\", e.wt(), \")\");\n            pr(\"}\");\n        }\n        pr(\"}\");\n    }\n};\n// }}}\n\n// modnum {{{\nusing v_t = int;\nusing vv_t = ll;\ntemplate<v_t MOD> struct modnum {\n    v_t v;\n    modnum() : v(0) {}\n    modnum(vv_t _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator v_t() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { vv_t w; i >> w; n = modnum(w); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return x % m;\n#endif\n        // x must be less than 2^32 * m so that x / m fits in a 32-bit integer.\n        unsigned x_high = x >> 32, x_low = (unsigned) x, quot, rem;\n        asm(\"divl %4\\n\"\n                : \"=a\" (quot), \"=d\" (rem)\n                : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = fast_mod(vv_t(v) * o.v); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(vv_t e) const {\n        if (e < 0) return 1 / this->pow(-e);\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        v_t g = MOD, x = 0, y = 1;\n        for (v_t r = v; r != 0; ) {\n            v_t q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static constexpr v_t totient() {\n        v_t tot = MOD, tmp = MOD;\n        for (v_t p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static v_t primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        v_t tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (v_t p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (v_t r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (v_t p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static v_t discrete_log(modnum v) {\n        static const v_t M = ceil(sqrt(MOD));\n        static unordered_map<v_t, v_t> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (v_t i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (v_t i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum unity_root(int deg) {\n        assert(totient() % deg == 0);\n        return generator().pow(totient() / deg);\n    }\n\n    static modnum unity_root(int deg, int pow) {\n        static vector<modnum> table{ 0, 1 };\n        while (sz(table) <= deg) {\n            modnum w = unity_root(sz(table));\n            for (int i = sz(table)/2, s = sz(table); i < s; i++) {\n                table.push_back(table[i]);\n                table.push_back(table[i] * w);\n            }\n        }\n        return table[deg + (pow < 0 ? deg + pow : pow)];\n    }\n\n    static modnum factorial(int n) {\n        static vector<modnum> fact = {1};\n        assert(n >= 0);\n        if (sz(fact) <= n) {\n            int had = sz(fact);\n            fact.resize(n + 1);\n            for (int i = had; i <= n; i++) fact[i] = fact[i-1] * i;\n        }\n        return fact[n];\n    }\n    static modnum inverse_factorial(int n) {\n        static vector<modnum> finv = {1};\n        assert(n >= 0);\n        if (sz(finv) <= n) {\n            int had = sz(finv);\n            finv.resz(n + 1), finv[n] = factorial(n).inv();\n            for (int i = n - 1; i >= had; i--) finv[i] = finv[i+1] * (i+1);\n        }\n        return finv[n];\n    }\n\n    static modnum small_inv(int n) {\n        assert(n > 0); return factorial(n - 1) * inverse_factorial(n);\n    }\n\n    static modnum ncr(int n, int r) {\n        if (r < 0 || n < r) return 0;\n        return factorial(n) * inverse_factorial(r) * inverse_factorial(n - r);\n    }\n};\n// }}}\nusing mn = modnum<int(998244353)>;\nusing vmn = vector<mn>;\nusing vvmn = vector<vmn>;\n\nint main() {\n    setIO();\n\n    int N; re(N); tree<edge> tr(N, 0); re(tr);\n\n    // expects adjacency list \"adj\", return distances and bfs tree\n    auto bfs = [&](int src) {\n        vi dist(N, -1), pred(N, -1);\n        dist[src] = 0;\n        for (queue<int> bfs({src}); !bfs.empty(); bfs.pop()) {\n            int loc = bfs.front();\n            trav (e, tr.nbrs[loc]) if (int nbr = e(loc); dist[nbr] == -1) {\n                dist[nbr] = dist[loc] + 1;\n                pred[nbr] = loc;\n                bfs.push(nbr);\n            }\n        }\n        return mp(dist, pred);\n    };\n\n    int x;\n    {\n        auto [dist, _] = bfs(0);\n        x = max_element(all(dist)) - dist.begin();\n    }\n    int y, diam, c0, c1;\n    {\n        auto [dist, pred] = bfs(x);\n        y = max_element(all(dist)) - dist.begin();\n        diam = dist[y];\n\n        c0 = y;\n        F0R (i, diam / 2)\n            c0 = pred[c0];\n        if (diam&1)\n            c1 = pred[c0];\n        else\n            c1 = -1;\n    }\n\n    tr.reroot(c0);\n\n    vb extreme(N);\n    {\n        if (c1 != -1) {\n            vb c1_side(N);\n            c1_side[c1] = 1;\n            trav (u, tr.preorder)\n                if (tr.depth[u] > tr.depth[c1])\n                    c1_side[u] = c1_side[tr.par[u]];\n            F0R (i, N)\n                extreme[i] = tr.depth[i] == (diam + c1_side[i]) / 2;\n        } else {\n            F0R (i, N) extreme[i] = tr.depth[i] == (diam / 2);\n        }\n    }\n\n    vector<array<mn, 9>> dp(N);\n    trav (u, tr.reverse_preorder) {\n        if (tr.children[u].empty()) {\n            if (extreme[u]) dp[u][3 * 1 + 1] = 1;\n            else dp[u][0] = 1;\n        } else {\n            dp[u][0] = 1;\n            trav (e, tr.children[u]) {\n                if (e(u) == c1) continue;\n                array<mn, 9> DP; DP.fill(0);\n                F0R (pos, 3) F0R (neg, 3) {\n                    F0R (POS, 3) F0R (NEG, 3) {\n                        mn ways = dp[u][3 * pos + neg] * dp[e(u)][3 * POS + NEG];\n                        for (int dir = -1; dir <= 1; dir++) {\n                            int rpos = min(2, pos + (dir > 0 ? POS : 0));\n                            int rneg = min(2, neg + (dir < 0 ? NEG : 0));\n                            DP[3 * rpos + rneg] += ways;\n                        }\n                    }\n                }\n                dp[u] = DP;\n            }\n        }\n    }\n\n    if (diam&1) {\n        ps(dp[c0][3 * 1] * dp[c1][1]);\n    } else {\n        ps(dp[c0][3 * 1 + 1] / 2);\n    }\n\n    // did you check N=1? did you mix up N,M?\n    // check your \"infinity\" and \"null\" values against the bounds\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 2e5+10, mod = 998244353, inv2 = (mod+1)>>1;\nint n;\nvector<int>e[N];\n\nint mx,pos,s,cnt,p[N],fa[N];\ninline void dfs(int u,int fa,int dep){\n\tif (dep>=mx) mx=dep,pos=u;\n\t::fa[u]=fa;\n\tfor (auto v:e[u]) if (v!=fa) dfs(v,u,dep+1);\n}\ninline void Find(){\n\tdfs(1,0,0),s=pos,dfs(s,0,0);\n\tfor (int u=pos;u!=s;u=fa[u]) p[++cnt]=u;\n\tp[++cnt]=s;\n}\n\nint dp[N][3][3],f[3][3];\ninline void Dfs(int u,int fa,int dep){\n\tif (dep==mx/2) dp[u][1][1]=1;\n\t\telse dp[u][0][0]=1;\n\tfor (auto v:e[u]) if (v!=fa){\n\t\tDfs(v,u,dep+1),fil(f,0);\n\t\tFOR(i,0,3) FOR(j,0,3) if (dp[u][i][j])\n\t\t\tFOR(_i,0,3) FOR(_j,0,3) if (dp[v][_i][_j])\n\t\t\t\tFOR(k,0,3){\n\t\t\t\t\tint x=min(2,i+(_i)*(k==1)),y=min(2,j+(_j)*(k==2));\n\t\t\t\t\tf[x][y]=(f[x][y]+1ll*dp[u][i][j]*dp[v][_i][_j])%mod;\n\t\t\t\t}\n\t\tFOR(i,0,3) FOR(j,0,3) dp[u][i][j]=f[i][j];\n\t}\n}\n\nint main(){\n\tn=read();\n\tFOR(i,1,n){\n\t\tint x=read(),y=read();\n\t\te[x].pb(y),e[y].pb(x);\n\t}\n\tFind();\n\tif (mx%2==0){\n\t\tDfs(p[cnt+1>>1],0,0);\n\t\tprintf(\"%d\\n\",1ll*dp[p[cnt+1>>1]][1][1]*inv2%mod);\n\t} else {\n\t\tint x=p[cnt/2],y=p[cnt/2+1];\n\t\tDfs(x,y,0),Dfs(y,x,0);\n\t\tint ans=(1ll*dp[x][1][0]+dp[x][1][1]+dp[x][1][2])%mod*(1ll*dp[y][1][0]+dp[y][1][1]+dp[y][1][2])%mod;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define ll long long\n#define lb(x) ((x)&(-x))\n#define pii pair<int,int>\n#define vi vector<int>\n#define pb push_back\n#define fi first\n#define se second\n#define de(x) cout<<x<<\" x\"<<endl\n#define LCAFA rep(i,1,20)rep(j,1,n+1)fa[j][i]=fa[fa[j][i-1]][i-1]\n#define all(x) x.begin(),x.end()\n#define ls(x) x<<1\n#define rs(x) x<<1|1\nusing namespace std;\nconst int N=2e5+9;\nconst ll mod=998244353;\nint d[N],cnt,vis[N],stk[N];\nvi g[N];\nll dp[N][3],temp[3];\nll add(ll x,ll y){\n\treturn ((x+y)%mod+mod)%mod;\n}\nll mul(ll x,ll y){\n\treturn ((x*y)%mod+mod)%mod;\n}\nvoid dfs(int u,int f){\n\tfor(auto v:g[u]){\n\t\tif(v==f)continue;\n\t\td[v]=d[u]+1;\n\t\tdfs(v,u); \n\t}\n}\nvoid dfs2(int u,int f){\n\tfor(auto v:g[u]){\n\t\tif(v==f)continue;\n\t\tdfs2(v,u);\n\t\tif(vis[v])vis[u]=1;\n\t}\n\tif(vis[u])stk[++cnt]=u;\n}\nvoid sol(int u,int f){\n\tif(g[u].size()==1){\n\t\tif(vis[u])dp[u][0]=2,dp[u][1]=1;\n\t\telse dp[u][0]=3;\n\t\treturn;\n\t}\n\tdp[u][0]=1;\n\tfor(auto v:g[u]){\n\t\tif(v==f)continue;\n\t\tsol(v,u);\n\t\trep(i,0,3)temp[i]=0;\n\t\trep(i,0,3)rep(j,0,3)temp[min(2,i+j)]=add(temp[min(2,i+j)],mul(dp[u][i],dp[v][j]));\n\t\trep(i,0,3)dp[u][i]=temp[i];\n\t//\tcout<<v<<' '<<u<<\" uv\\n\\n\";\n\t//\tcout<<dp[u][0]<<' '<<dp[u][1]<<' '<<dp[u][2]<<\"checkdp\\n\";\n\t}\n\tdp[u][0]=add(dp[u][0],mul(2,dp[u][0]+dp[u][1]+dp[u][2])); \n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\trep(i,1,n){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tg[u].pb(v),g[v].pb(u);\n\t}\n\tdfs(1,0);\n\tint p=1;\n\trep(i,1,n+1)if(d[i]>d[p])p=i;\n\td[p]=0;\n\tdfs(p,0);\n\tint e=1;\n\trep(i,1,n+1)if(d[i]>d[e])e=i;\n\tvis[e]=1;\n\tdfs2(p,0);\n\tmemset(vis,0,sizeof vis);\n\tif(cnt&1){\n\t//\tcout<<\"comein\\n\";\n\t\tint u=stk[cnt/2+1];d[u]=0;dfs(u,0);\n\t\trep(i,1,n+1)if(d[i]==cnt/2)vis[i]=1;\n\t\tll ans[3]={1,0,0};\n\t\tfor(auto v:g[u]){\n\t\t//\tcout<<v<<\"  v\\n\";\n\t\t\tsol(v,u);\n\t\t\tdp[v][0]-=dp[v][1]+dp[v][2];\n\t\t\tans[2]=add(mul(ans[2],dp[v][0]),mul(ans[1],dp[v][1]));\n\t\t\tans[1]=add(mul(ans[1],dp[v][0]),mul(ans[0],dp[v][1]));\n\t\t\tans[0]=mul(ans[0],dp[v][0]);\n\t\t//\tcout<<dp[v][0]<<' '<<dp[v][1]<<' '<<dp[v][2]<<\"dp\\n\";\n\t\t//\tcout<<ans[0]<<' '<<ans[1]<<' '<<ans[2]<<\"check\\n\";\n\t\t}\n\t\tprintf(\"%lld\",ans[2]);\n\t}\n\telse{\n\t\tint u=stk[cnt>>1],v=stk[cnt/2+1];\n\t\td[u]=0;d[v]=0;\n\t\tdfs(u,v);dfs(v,u);\n\t\trep(i,1,n+1)if(d[i]==cnt/2-1)vis[i]=1;\n\t\tsol(u,v);sol(v,u);\n\t\tll ans=mul(dp[u][1],dp[v][1]);\n\t\tprintf(\"%lld\",ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (q < m) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\ntemplate <int mod>\nstruct ModInt\n{\n    using lint = long long;\n    static int get_mod() { return mod; }\n    static int get_primitive_root() {\n        static int primitive_root = 0;\n        if (!primitive_root) {\n            primitive_root = [&](){\n                std::set<int> fac;\n                int v = mod - 1;\n                for (lint i = 2; i * i <= v; i++) while (v % i == 0) fac.insert(i), v /= i;\n                if (v > 1) fac.insert(v);\n                for (int g = 1; g < mod; g++) {\n                    bool ok = true;\n                    for (auto i : fac) if (ModInt(g).power((mod - 1) / i) == 1) { ok = false; break; }\n                    if (ok) return g;\n                }\n                return -1;\n            }();\n        }\n        return primitive_root;\n    }\n    int val;\n    constexpr ModInt() : val(0) {}\n    constexpr ModInt &_setval(lint v) { val = (v >= mod ? v - mod : v); return *this; }\n    constexpr ModInt(lint v) { _setval(v % mod + mod); }\n    explicit operator bool() const { return val != 0; }\n    constexpr ModInt operator+(const ModInt &x) const { return ModInt()._setval((lint)val + x.val); }\n    constexpr ModInt operator-(const ModInt &x) const { return ModInt()._setval((lint)val - x.val + mod); }\n    constexpr ModInt operator*(const ModInt &x) const { return ModInt()._setval((lint)val * x.val % mod); }\n    constexpr ModInt operator/(const ModInt &x) const { return ModInt()._setval((lint)val * x.inv() % mod); }\n    constexpr ModInt operator-() const { return ModInt()._setval(mod - val); }\n    constexpr ModInt &operator+=(const ModInt &x) { return *this = *this + x; }\n    constexpr ModInt &operator-=(const ModInt &x) { return *this = *this - x; }\n    constexpr ModInt &operator*=(const ModInt &x) { return *this = *this * x; }\n    constexpr ModInt &operator/=(const ModInt &x) { return *this = *this / x; }\n    friend constexpr ModInt operator+(lint a, const ModInt &x) { return ModInt()._setval(a % mod + x.val); }\n    friend constexpr ModInt operator-(lint a, const ModInt &x) { return ModInt()._setval(a % mod - x.val + mod); }\n    friend constexpr ModInt operator*(lint a, const ModInt &x) { return ModInt()._setval(a % mod * x.val % mod); }\n    friend constexpr ModInt operator/(lint a, const ModInt &x) { return ModInt()._setval(a % mod * x.inv() % mod); }\n    constexpr bool operator==(const ModInt &x) const { return val == x.val; }\n    constexpr bool operator!=(const ModInt &x) const { return val != x.val; }\n    bool operator<(const ModInt &x) const { return val < x.val; }  // To use std::map<ModInt, T>\n    friend std::istream &operator>>(std::istream &is, ModInt &x) { lint t; is >> t; x = ModInt(t); return is; }\n    friend std::ostream &operator<<(std::ostream &os, const ModInt &x) { os << x.val;  return os; }\n    constexpr lint power(lint n) const {\n        lint ans = 1, tmp = this->val;\n        while (n) {\n            if (n & 1) ans = ans * tmp % mod;\n            tmp = tmp * tmp % mod;\n            n /= 2;\n        }\n        return ans;\n    }\n    constexpr lint inv() const { return this->power(mod - 2); }\n    constexpr ModInt operator^(lint n) const { return ModInt(this->power(n)); }\n    constexpr ModInt &operator^=(lint n) { return *this = *this ^ n; }\n};\nusing mint = ModInt<998244353>;\n\nvector<vector<int>> to;\n\nvector<int> D, par;\nint L;\nvoid dfs1(int now, int prv, int d)\n{\n    par[now] = prv;\n    D[now] = d;\n    for (auto nxt : to[now]) if (nxt != prv) {\n        dfs1(nxt, now, d + 1);\n    }\n}\n\nvector<mint> dpall, dp1, dpbad;\n\nint dfs_count(int now, int prv) {\n    int ret = 1;\n    for (auto nxt : to[now]) if (nxt != prv) ret += dfs_count(nxt, now);\n    return ret;\n}\n\nvoid dfs_dp(int now, int prv) {\n    dpall[now] = 1;\n    dp1[now] = 0;\n    dpbad[now] = 0;\n    bool f = false;\n    for (auto nxt : to[now]) if (nxt != prv) {\n        f = true;\n        dfs_dp(nxt, now);\n        dpbad[now] = dpbad[now] * (dpbad[nxt] + dp1[nxt] + dpall[nxt]) + dp1[now] * (dp1[nxt] + dpbad[nxt]) + dpall[now] * dpbad[nxt];\n        dp1[now] = dp1[now] * dpall[nxt] + dpall[now] * dp1[nxt];\n        dpall[now] = dpall[now] * dpall[nxt];\n    }\n    dpall[now] = dpall[now] * 3 + dp1[now] * 2 + dpbad[now] * 2;\n    if (!f) {\n        if (D[now] == L / 2) {\n            dpall[now] = 2;\n            dp1[now] = 1;\n        }\n        else dpall[now] = 3;\n    }\n}\n\nvector<vector<vector<mint>>> dpv;  // (N, 3, 2)\nvoid dfs_even(int now, int prv) {\n    bool f = false;\n    dpv[now][0][0] = 1;\n    for (auto nxt : to[now]) if (nxt != prv) {\n        f = true;\n        dfs_even(nxt, now);\n        vector<vector<mint>> dpnxt(3, vector<mint>(2));\n        REP(np, 3) REP(nm, 2) REP(nnp, 3) REP(nnm, 2) {\n            dpnxt[min(np + nnp, 2)][min(nm + nnm, 1)] += dpv[now][np][nm] * dpv[nxt][nnp][nnm];\n        }\n        dpv[now] = dpnxt;\n    }\n    if (f) {\n        mint pl2 = 0, pl1 = 0, zero = 0, mi1 = 0;\n        REP(np, 3) REP(nm, 2) {\n            if (np == 2) pl2 += dpv[now][np][nm];\n            if (np == 1) pl1 += dpv[now][np][nm];\n            if (np == 0) zero += dpv[now][np][nm];\n            zero += dpv[now][np][nm];\n            if (nm == 1) mi1 += dpv[now][np][nm];\n            if (nm == 0) zero += dpv[now][np][nm];\n            dpv[now][np][nm] = 0;\n        }\n        dpv[now][2][0] = pl2;\n        dpv[now][1][0] = pl1;\n        dpv[now][0][0] = zero;\n        dpv[now][0][1] = mi1;\n    }\n    else {\n        if (D[now] == L / 2) dpv[now][1][0] = dpv[now][0][1] = dpv[now][0][0] = 1;\n        else dpv[now][0][0] = 3;\n    }\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n    to.resize(N);\n    REP(_, N - 1) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        to[a].push_back(b);\n        to[b].push_back(a);\n    }\n    D.assign(N, 0);\n    par.assign(N, -1);\n    dfs1(0, -1, 0);\n\n    int S = max_element(ALL(D)) - D.begin();\n    dfs1(S, -1, 0);\n    int T = max_element(ALL(D)) - D.begin();\n    L = D[T];\n    int R = T;\n    REP(_, L / 2) R = par[R];\n\n    if (L % 2 == 0) {\n        ndarray(dpv, N, 3, 2);\n        dfs1(R, -1, 0);\n        for (auto A : to[R]) {\n            dpv[A][0][0] = mint(3).power(dfs_count(A, R));\n            dfs_even(A, R);\n        }\n        vector<mint> P(3);\n        P[0] = 1;\n        for (auto A : to[R]) {\n            IREP(d, 2) {\n                P[d + 1] += P[d] * dpv[A][1][0];\n                P[d] *= dpv[A][0][0];\n            }\n        }\n        cout << P[2] << endl;\n    }\n    else {\n        dpall.resize(N);\n        dp1.resize(N);\n        dpbad.resize(N);\n        int U = par[R];\n        mint ret = 1;\n        REP(_, 2) {\n            dfs1(R, -1, 0);\n            for (auto A : to[R]) if (A != U) {\n                dfs_dp(A, R);\n            }\n            mint P0 = 1, P1 = 0;\n            for (auto A : to[R]) if (A != U) {\n                P1 = P1 * dpall[A] + P0 * dp1[A];\n                P0 *= dpall[A];\n            }\n            ret *= P1;\n            swap(R, U);\n        }\n        cout << ret << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[202020];\nconst ll mo=998244353;\n\npair<int,int> farthest(int cur,int pre,int d,vector<int>& D) {\n\tD[cur]=d;\n\tpair<int,int> r={d,cur};\n\tFORR(e,E[cur]) if(e!=pre) r=max(r, farthest(e,cur,d+1,D));\n\treturn r;\n}\n\npair<int,vector<int>> diameter() { // diameter,center\n\tvector<int> D[2];\n\tD[0].resize(N);\n\tD[1].resize(N);\n\tauto v1=farthest(0,0,0,D[0]);\n\tauto v2=farthest(v1.second,v1.second,0,D[0]);\n\tfarthest(v2.second,v2.second,0,D[1]);\n\tpair<int,vector<int>> R;\n\tR.first = v2.first;\n\t//重心を取る場合\n\tfor(int i=N-1;i>=0;i--) if(D[0][i]+D[1][i]==R.first && abs(D[0][i]-D[1][i])<=1) R.second.push_back(i);\n\n\treturn R;\n}\n\nvector<ll> dfs1(int cur,int pre,int lef,int no=0) {\n\tif(E[cur].size()==1) {\n\t\tif(lef==0) return {2,1,0};\n\t\telse return {3,0,0};\n\t}\n\telse {\n\t\tvector<ll> X={1,0,0};\n\t\tFORR(e,E[cur]) if(e!=pre) {\n\t\t\tvector<ll> Y=dfs1(e,cur,lef-1);\n\t\t\tvector<ll> Z={0,0,0};\n\t\t\tint x,y;\n\t\t\tFOR(x,3) FOR(y,3) Z[min(x+y,2)]+=X[x]*Y[y]%mo;\n\t\t\tX[0]=Z[0]%mo;\n\t\t\tX[1]=Z[1]%mo;\n\t\t\tX[2]=Z[2]%mo;\n\t\t}\n\t\tvector<ll> Y={0,0,0};\n\t\tif(no) {\n\t\t\tY=X;\n\t\t}\n\t\telse {\n\t\t\tY[0]=(X[0]*3+X[1]*2+X[2]*2)%mo;\n\t\t\tY[1]=X[1];\n\t\t\tY[2]=X[2];\n\t\t}\n\t\treturn Y;\n\t}\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tauto R=diameter();\n\tif(R.second.size()==1) {\n\t\tvector<ll> X={1,0,0,0};\n\t\tFORR(e,E[R.second[0]]) {\n\t\t\tauto Y=dfs1(e,R.second[0],R.first/2-1);\n\t\t\tvector<ll> Z={0,0,0,0};\n\t\t\tFOR(x,4) FOR(y,3) Z[min(x+((y==2)?3:y),3)]+=X[x]*Y[y]%mo;\n\t\t\tFOR(x,4) X[x]=Z[x]%mo;\n\t\t}\n\t\tcout<<X[2]<<endl;\n\t}\n\telse {\n\t\tvector<ll> X=dfs1(R.second[0],R.second[1],R.first/2,1);\n\t\tvector<ll> Y=dfs1(R.second[1],R.second[0],R.first/2,1);\n\t\t\n\t\tcout<<X[1]*Y[1]%mo<<endl;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n\n\n\n\n#include <algorithm>\n\n#include <array>\n\n#include <bitset>\n\n#include <cassert>\n\n#include <complex>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <iostream>\n\n#include <map>\n\n#include <numeric>\n\n#include <queue>\n\n#include <set>\n\n#include <string>\n\n#include <unordered_map>\n\n#include <unordered_set>\n\n#include <vector>\n\nusing namespace std;\n\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\nstruct Scanner {\n    FILE* fp = nullptr;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += fread(line + ed, 1, (1 << 15) - ed, fp);\n        line[ed] = '\\0';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) reread();\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == '-') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] - '0');\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(V<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    Scanner(FILE* _fp) : fp(_fp) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(' ');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single('\\n');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val; // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char('0' + (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const V<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(' ');\n            write_single(val[i]);\n        }\n    }\n};\n\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    static constexpr uint get_mod() { return MD; }\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(uint(_v % MD + MD)); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(uint(ull(v) * r.v % MD)); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\n// using Mint = ModInt<998244353>;\n// template<> const Mint Mint::G = Mint(3);\n\nusing Mint = ModInt<998244353>;\n\nScanner sc = Scanner(stdin);\nPrinter pr = Printer(stdout);\n\nVV<int> g;\n\nint mdp, mv;\nvoid dfs(int p, int b, int ndp = 0) {\n    if (mdp <= ndp) {\n        mdp = ndp;\n        mv = p;\n    }\n    for (int d: g[p]) {\n        if (d == b) continue;\n        dfs(d, p, ndp + 1);\n    }\n}\n\nV<int> path;\nbool dfs_path(int p, int b, int t) {\n    if (p == t) {\n        path.push_back(p);\n        return true;\n    }\n    for (int d: g[p]) {\n        if (d == b) continue;\n        if (dfs_path(d, p, t)) {\n            path.push_back(p);\n            return true;\n        }\n    }\n    return false;\n}\n\nint U;\n\nusing P = array<Mint, 3>;\n\nP solve(int p, int b, int ndps = 0) {\n    if (g[p].size() == 1) {\n        // leaf\n        if (ndps == U) {\n            // rad\n            return {Mint(2), Mint(1), Mint(0)};\n        } else {\n//            dbg(p, b, P{Mint(3), Mint(0)});\n            return {Mint(3), Mint(0), Mint(0)};\n        }\n    }\n    P dp = {Mint(1), Mint(0), Mint(0)};\n    for (auto d: g[p]) {\n        if (d == b) continue;\n        auto ch = solve(d, p, ndps + 1);\n        P ndp = {Mint(0), Mint(0), Mint(0)};\n        for (int a = 0; a < 3; a++) {\n            for (int b = 0; b < 3; b++) {\n                ndp[min(2, a + b)] += dp[a] * ch[b];\n            }\n        }\n        dp = ndp;\n    }\n    dp[0] = dp[0] * Mint(3) + (dp[1] + dp[2]) * Mint(2);\n    return dp;\n}\n\nint main() {\n    int n;\n    sc.read(n);\n    g = VV<int>(n);\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        sc.read(a, b); a--; b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    dfs(0, -1);\n    int u = mv;\n    dfs(mv, -1);\n    int v = mv;\n    dfs_path(u, -1, v);\n\n    int L = int(path.size());\n    if (L % 2) {\n        U = (L / 2) - 1;\n        int mid = path[L / 2];\n                       ;\n        V<Mint> dp(4);\n        dp[0] = Mint(1);\n        for (int d: g[mid]) {\n            V<Mint> ndp(4);\n            auto x = solve(d, mid);\n            Mint x0 = x[0] - x[1], x1 = x[1];\n            ndp[3] = dp[3] * x0 + dp[2] * x1 + dp[1] * x1;\n            ndp[2] = dp[2] * x0 + dp[0] * x1;\n            ndp[1] = dp[1] * x0 + dp[0] * x1;\n            ndp[0] = dp[0] * x0;\n            dp = ndp;\n        }\n               ;\n        pr.writeln((dp[3] / Mint(2)).v);\n    } else {\n        int mid0 = path[L / 2 - 1], mid1 = path[L / 2];\n        U = (L / 2 - 1);\n        auto x = solve(mid0, mid1);\n        auto y = solve(mid1, mid0);\n        pr.writeln((x[1] * y[1]).v);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e5 + 5, mod = 998244353;\n\nvector<int> g[N];\nint par[N], lv[N];\nlong long dp[N][3], tmp[3];\n\nvoid add(long long & var, long long val) {\n  var += val;\n  if (var >= mod)\n    var -= mod;\n}\n\nvoid dfs(int v, int p) {\n  par[v] = p;\n  for (int u : g[v]) {\n    if (u == p) continue;\n    lv[u] = lv[v] + 1;\n    dfs(u, v);\n  }\n}\n\nvoid solve(int v, int p, int depth) {\n  memset(dp[v], 0, sizeof dp[v]);\n  dp[v][(depth == 0)] = 1;\n  --depth;\n  for (int u : g[v]) {\n    if (u == p) continue;\n    solve(u, v, depth);\n    memset(tmp, 0, sizeof tmp);\n    for (int i = 0; i < 3; ++i) {\n      for (int j = 0; j < 3; ++j) {\n        add(tmp[min(i+j, 2)], dp[v][i] * dp[u][j] % mod);\n        add(tmp[i], 2LL * dp[v][i] * dp[u][j] % mod);\n      }\n    }\n    for (int i = 0; i < 3; ++i)\n      dp[v][i] = tmp[i];\n  }\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i < n; ++i) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    --u, --v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  lv[0] = 0;\n  dfs(0, 0);\n  int root = 0;\n  for (int i = 0; i < n; ++i) {\n    if (lv[i] > lv[root])\n      root = i;\n  }\n  lv[root] = 0;\n  dfs(root, -1);\n  int leaf = 0;\n  for (int i = 0; i < n; ++i) {\n    if (lv[i] > lv[leaf])\n      leaf = i;\n  }\n  int diam = lv[leaf];\n  long long ans = 0;\n  if (diam & 1) {\n    int a = leaf;\n    for (int i = 0; i < diam/2; ++i) {\n      a = par[a];\n    }\n    int b = par[a];\n    solve(a, b, diam/2);\n    solve(b, a, diam/2);\n    ans = 1LL * dp[a][1] * dp[b][1] % mod;\n  }\n  else {\n    int c = leaf;\n    for (int i = 0; i < diam/2; ++i) {\n      c = par[c];\n    }\n    long long best[3];\n    memset(best, 0, sizeof best);\n    best[0] = 1;\n    for (int u : g[c]) {\n      solve(u, c, diam/2-1);\n      memset(tmp, 0, sizeof tmp);\n      if (diam == 2)\n        dp[u][0] = dp[u][1];\n      else {\n        dp[u][0] = (dp[u][0] - dp[u][1] - dp[u][2]) % mod;\n        dp[u][0] = (3LL * dp[u][0] + 4LL * dp[u][1] + 4LL * dp[u][2]) % mod;\n      }\n      tmp[0] = (best[0] * dp[u][0]) % mod;\n      tmp[1] = (best[0] * dp[u][1] + best[1] * dp[u][0]) % mod;\n      tmp[2] = (best[1] * dp[u][1] + best[2] * dp[u][0]) % mod;\n      for (int i = 0; i < 3; ++i)\n        best[i] = tmp[i];\n    }\n    ans = best[2];\n  }\n  ans %= mod;\n  if (ans < 0)\n    ans += mod;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define I inline\n#define fi first\n#define se second\n#define R register\n#define LL long long\n#define mp make_pair\n#define reg register int\n#define pii pair<int,int>\n#define fo(i, a, b) for(reg i = a; i <= b; i++)\n#define fd(i, a, b) for(reg i = a; i >= b; i--)\n#define bp __builtin_popcount\n#define cr const reg&\nusing namespace std;\nconst int N = 2e5 + 1, mod = 998244353, inv2 = mod + 1 >> 1;\n\nI int _max(cr x, cr y) {return x > y ? x : y;}\nI int _min(cr x, cr y) {return x < y ? x : y;}\nI int read() {\n\treg x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n\treturn x * f;\n}\nI void ptt(LL x) {if(x >= 10) ptt(x / 10); putchar(x % 10 + '0');}\nI void put(LL x) {x < 0 ? putchar('-'), ptt(-x) : ptt(x);}\nI void pr1(LL x) {put(x), putchar(' ');}\nI void pr2(LL x) {put(x), puts(\"\");}\n\nstruct edge {\n\tint x, y, next;\n} e[N * 2]; int len, last[N];\nint tp, mx, rt, sta[N], fa[N];\nint f[N][3][3], tmp[3][3];\n//x-y,y-x\n\nI void ins(cr x, cr y) {e[++len] = edge{x, y, last[x]}, last[x] = len;}\n\nvoid dfs(cr x, cr dep) {\n\tif(dep > mx) mx = dep, rt = x;\n\tfor(reg k = last[x]; k; k = e[k].next) if(e[k].y ^ fa[x]) fa[e[k].y] = x, dfs(e[k].y, dep + 1);\n}\n\nvoid treedp(cr x, cr fa, cr dep) {\n\tdep == tp / 2 ? f[x][1][1] = 1 : f[x][0][0] = 1;\n\tfor(reg k = last[x]; k; k = e[k].next) if(e[k].y ^ fa){\n\t\treg y = e[k].y;\n\t\ttreedp(y, x, dep + 1);\n\t\tfo(i, 0, 2) fo(j, 0, 2) fo(k, 0, 2) fo(l, 0, 2) fo(g, -1, 1) {\n\t\t\treg z = _min(2, i + k * (g == 1)), p = _min(2, j + l * (g == -1));\n\t\t\ttmp[z][p] = (tmp[z][p] + (LL)f[x][i][j] * f[y][k][l]) % mod;\n\t\t} fo(i, 0, 2) fo(j, 0, 2) f[x][i][j] = tmp[i][j], tmp[i][j] = 0;\n\t}\n}\n\nint main() {\n\treg n = read();\n\tfo(i, 1, n - 1) {\n\t\treg x = read(), y = read();\n\t\tins(x, y), ins(y, x);\n\t} dfs(1, 1), mx = fa[rt] = 0, dfs(rt, 1);\n\tfor(; rt; rt = fa[rt]) sta[++tp] = rt;\n\tif(tp & 1) rt = sta[tp / 2 + 1], treedp(rt, 0, 0), pr2(f[rt][1][1]);\n\telse {\n\t\treg x = sta[tp / 2], y = sta[tp / 2 + 1];\n\t\ttreedp(x, y, 1), treedp(y, x, 1);\n\t\treg c1 = (f[x][1][0] + f[x][1][1] + f[x][1][2]) % mod, c2 = (f[y][1][0] + f[y][1][1] + f[y][1][2]) % mod;\n\t\tpr2((LL)c1 * c2 % mod);\n\t} return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e5 + 5, mod = 998244353;\n\nvector<int> g[N];\nint par[N], lv[N];\nlong long dp[N][3], tmp[3];\n\nvoid add(long long & var, long long val) {\n  var += val;\n  if (var >= mod)\n    var -= mod;\n}\n\nvoid dfs(int v, int p) {\n  par[v] = p;\n  for (int u : g[v]) {\n    if (u == p) continue;\n    lv[u] = lv[v] + 1;\n    dfs(u, v);\n  }\n}\n\nvoid solve(int v, int p, int depth) {\n  memset(dp[v], 0, sizeof dp[v]);\n  dp[v][(depth == 0)] = 1;\n  --depth;\n  for (int u : g[v]) {\n    if (u == p) continue;\n    solve(u, v, depth);\n    memset(tmp, 0, sizeof tmp);\n    for (int i = 0; i < 3; ++i) {\n      for (int j = 0; j < 3; ++j) {\n        add(tmp[min(i+j, 2)], dp[v][i] * dp[u][j] % mod);\n        add(tmp[i], 2LL * dp[v][i] * dp[u][j] % mod);\n      }\n    }\n    for (int i = 0; i < 3; ++i)\n      dp[v][i] = tmp[i];\n  }\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i < n; ++i) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    --u, --v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  lv[0] = 0;\n  dfs(0, 0);\n  int root = 0;\n  for (int i = 0; i < n; ++i) {\n    if (lv[i] > lv[root])\n      root = i;\n  }\n  lv[root] = 0;\n  dfs(root, -1);\n  int leaf = 0;\n  for (int i = 0; i < n; ++i) {\n    if (lv[i] > lv[leaf])\n      leaf = i;\n  }\n  int diam = lv[leaf];\n  long long ans = 0;\n  if (diam & 1) {\n    int a = leaf;\n    for (int i = 0; i < diam/2; ++i) {\n      a = par[a];\n    }\n    int b = par[a];\n    solve(a, b, diam/2);\n    solve(b, a, diam/2);\n    ans = 1LL * dp[a][1] * dp[b][1] % mod;\n  }\n  else {\n    int c = leaf;\n    for (int i = 0; i < diam/2; ++i) {\n      c = par[c];\n    }\n    long long best[3];\n    memset(best, 0, sizeof best);\n    best[0] = 1;\n    for (int u : g[c]) {\n      solve(u, c, diam/2-1);\n      memset(tmp, 0, sizeof tmp);\n      dp[u][0] = (dp[u][0] - dp[u][1] - dp[u][2]) % mod;\n      dp[u][0] = (3LL * dp[u][0] + dp[u][1] + dp[u][2]) % mod;\n      tmp[0] = (best[0] * dp[u][0]) % mod;\n      tmp[1] = (best[0] * dp[u][1] + best[1] * dp[u][0]) % mod;\n      tmp[2] = (best[1] * dp[u][1] + best[2] * dp[u][0]) % mod;\n      for (int i = 0; i < 3; ++i)\n        best[i] = tmp[i];\n    }\n    ans = best[2];\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;++A)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD 998244353ll\n\nll N,gr;\nvector<ll> abv[202020];\nll mk[202020];\nll i, j, k;\nll ans;\n\npll grcalc(ll a,ll p){\n    ll i = 0;\n    pll ret = {0, 0};\n    fornum(i,0,abv[a].size()){\n        ll b = abv[a][i];\n        if(b==p)\n            continue;\n        pll p = grcalc(b, a);\n        if(ret.first<p.first){\n            ret.first = p.first;\n        }\n        if(ret.first<p.second+ret.second){\n            ret.first = p.second+ret.second;\n        }\n        if(ret.second<p.second){\n            ret.second = p.second;\n        }\n    }\n    ++ret.second;\n    return ret;\n}\n\nll dfs2(ll a,ll p,ll c,ll d,ll dd){\n    c = c * 3 % MOD;\n    if(abv[a].size()==1){\n        if(d==dd){\n            c += MOD - 1;\n        }\n        if(d==gr-dd){\n            c += MOD - 1;\n        }\n        return c % MOD;\n    }\n    ll ret = 1, i;\n    fornum(i,0,abv[a].size()){\n        ll b = abv[a][i];\n        if(b==p)\n            continue;\n        ret *= dfs2(b, a, c, d + 1, dd);\n        ret %= MOD;\n    }\n    return ret;\n}\nll dfs1(ll a,ll p,ll d){\n    mk[d] = a;\n    ll i, j;\n    ll ret = 0;\n    if(d==gr){\n        if(mk[0]>mk[d])\n            return 0;\n        i = 0;\n        ret = 1;\n        fornum(i,0,gr){\n            fornum(j,0,abv[mk[i]].size()){\n                ll b = abv[mk[i]][j];\n                if(mk[i+1]==b)\n                    continue;\n                if(i>0&&mk[i-1]==b)\n                    continue;\n                ret *= dfs2(b, mk[i], 1, 1, i);\n            }\n        }\n        return ret;\n    }\n    fornum(i,0,abv[a].size()){\n        ll b = abv[a][i];\n        if(b==p)\n            continue;\n        ret += dfs1(b, a, d + 1);\n        ret %= MOD;\n    }\n    return ret;\n}\nint main(){\n    scanf(\"%lld\", &N);\n    fornum(i,1,N){\n        ll a, b;\n        scanf(\"%lld%lld\", &a, &b);\n        abv[a].push_back(b);\n        abv[b].push_back(a);\n    }\n    gr = grcalc(1, 0).first;\n    ans = 0;\n    //printf(\"%lld\", gr);\n    fornum(i,0,N){\n        if(abv[i+1].size()==1){\n            ans += dfs1(i + 1, 0, 0);\n            ans %= MOD;\n        }\n    }\n    printf(\"%lld\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;++A)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD 998244353ll\n\nll N,gr;\nvector<ll> abv[202020];\nll mk[202020];\nll i, j, k;\nll ans;\n\npll grcalc(ll a,ll p){\n    ll i = 0;\n    pll ret = {0, 0};\n    fornum(i,0,abv[a].size()){\n        ll b = abv[a][i];\n        if(b==p)\n            continue;\n        pll p = grcalc(b, a);\n        if(ret.first<p.first){\n            ret.first = p.first;\n        }\n        if(ret.first<p.second+ret.second){\n            ret.first = p.second+ret.second;\n        }\n        if(ret.second<p.second){\n            ret.second = p.second;\n        }\n    }\n    ++ret.second;\n    return ret;\n}\n\nll dfs2(ll a,ll p,ll c,ll d,ll dd){\n    c = c * 3 % MOD;\n    if(abv[a].size()==1){\n        if(d==dd){\n            c += MOD - 1;\n        }\n        if(d==gr-dd){\n            c += MOD - 1;\n        }\n        return c % MOD;\n    }\n    ll ret = 1, i;\n    fornum(i,0,abv[a].size()){\n        ll b = abv[a][i];\n        if(b==p)\n            continue;\n        ret *= dfs2(b, a, c, d + 1, dd);\n        ret %= MOD;\n    }\n    return ret;\n}\nll dfs1(ll a,ll p,ll d){\n    mk[d] = a;\n    ll i, j;\n    ll ret = 0;\n    if(d==gr){\n        if(mk[0]>mk[d])\n            return 0;\n        i = 0;\n        ret = 1;\n        fornum(i,0,gr){\n            fornum(j,0,abv[mk[i]].size()){\n                ll b = abv[mk[i]][j];\n                if(mk[i+1]==b)\n                    continue;\n                if(i>0&&mk[i-1]==b)\n                    continue;\n                ret *= dfs2(b, mk[i], 1, 1, i);\n                ret %= MOD;\n            }\n        }\n        return ret;\n    }\n    fornum(i,0,abv[a].size()){\n        ll b = abv[a][i];\n        if(b==p)\n            continue;\n        ret += dfs1(b, a, d + 1);\n        ret %= MOD;\n    }\n    return ret;\n}\nint main(){\n    scanf(\"%lld\", &N);\n    fornum(i,1,N){\n        ll a, b;\n        scanf(\"%lld%lld\", &a, &b);\n        abv[a].push_back(b);\n        abv[b].push_back(a);\n    }\n    gr = grcalc(1, 0).first;\n    ans = 0;\n    //printf(\"%lld \", gr);\n    fornum(i,0,N){\n        if(abv[i+1].size()==1){\n            //printf(\"%lld %lld\\n\", i + 1, ans);\n            ans += dfs1(i + 1, 0, 0);\n            ans %= MOD;\n        }\n    }\n    printf(\"%lld\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nstruct edge{int to, cost, id;};\n\nclass Graph\n{\npublic:\n    int N;\n    vector<vector<edge>> G;\n    bools f;\n    mmat dp;\n\n    Graph(int N): N(N){\n        G = vector<vector<edge>>(N, vector<edge>(0));\n        f = bools(N, false);\n        dp = mmat(N, mvec(3, 0));\n    }\n\n    void add_Directed_edge(int from, int to, int cost = 1, int id = 0){\n        G[from].push_back(edge({to, cost, id}));\n    }\n\n    void add_Undirected_edge(int v1, int v2, int cost = 1, int id = 0){\n        add_Directed_edge(v1, v2, cost, id);\n        add_Directed_edge(v2, v1, cost, id);\n    }\n\n    //calculate diameter of a Tree\n    void dfs_for_calcdist(int v, int p, int c, vec &dist){\n        if(p != -1) dist[v] = dist[p] + c;\n        for(auto e: G[v]) if(e.to != p) dfs_for_calcdist(e.to, v, e.cost, dist);\n    } \n\n    int diameter(int &v1, int &v2, int s = 0){\n        vec dist(N, 0);\n        dfs_for_calcdist(s, -1, -1, dist);\n        v1 = distance(dist.begin(), max_element(dist.begin(), dist.end()));\n        fill(dist.begin(), dist.end(), 0);\n        dfs_for_calcdist(v1, -1, -1, dist);\n        auto amax = max_element(dist.begin(), dist.end());\n        v2 = distance(dist.begin(), amax);\n        return *amax;\n    }\n\n    void dfs(int v, int p){\n\n        if(f[v]) dp[v][1] = 1;\n        else dp[v][0] = 1;\n\n        if(p != -1){\n            for(auto e: G[v]) if(e.to != p){\n                dfs(e.to, v);\n                mvec tmp(3, 0);\n                tmp[0] = dp[v][0] * (dp[e.to][0] * 3 + dp[e.to][1] * 2 + dp[e.to][2] * 2);\n                tmp[1] = dp[v][0] * dp[e.to][1] + dp[v][1] * (dp[e.to][0] * 3 + dp[e.to][1] * 2 + dp[e.to][2] * 2);\n                tmp[2] = dp[v][1] * dp[e.to][1] + dp[v][2] * (dp[e.to][0] + dp[e.to][1] + dp[e.to][2]) * 3;\n                dp[v] = tmp;\n            }\n        }else{\n            dp[v] = mvec(4, 0);\n            dp[v][0] = 1;\n            for(auto e: G[v]) if(e.to != p){\n                dfs(e.to, v);\n                mvec tmp(4, 0);\n                REP(j, 4){\n                    tmp[j] += dp[v][j] * (dp[e.to][0] * 3 + dp[e.to][1] + dp[e.to][2]);\n                    if((j & 1) == 0) tmp[j | 1] += dp[v][j] * dp[e.to][1];\n                    if((j & 2) == 0) tmp[j | 2] += dp[v][j] * dp[e.to][1];\n                }\n                dp[v] = tmp;\n            }\n        }\n    }\n\n};\n\n\nsigned main(){\n\n    int N; cin >> N;\n    Graph G(N);\n    REP(i, N - 1){\n        int a, b; cin >> a >> b;\n        G.add_Undirected_edge(a - 1, b - 1);\n    }\n\n    int v1, v2;\n    int R = G.diameter(v1, v2);\n    vec d1(N, 0), d2(N, 0);\n    G.dfs_for_calcdist(v1, -1, -1, d1);\n    G.dfs_for_calcdist(v2, -1, -1, d2);\n\n    vec center;\n    REP(i, N) if(d1[i] + d2[i] == R && llabs(d1[i] - d2[i]) <= 1) center.pb(i);\n    \n    fill(all(d1), 0);\n    fill(all(d2), 0);\n    mint ans;\n    if(SZ(center) == 1){\n        G.dfs_for_calcdist(center[0], -1, -1, d1);\n        REP(i, N) if(d1[i] == R / 2) G.f[i] = true;\n\n        G.dfs(center[0], -1);\n        ans = G.dp[center[0]][3] / 2;\n\n    }else{\n        G.dfs_for_calcdist(center[0], -1, -1, d1);\n        G.dfs_for_calcdist(center[1], -1, -1, d2);\n        REP(i, N) if(min(d1[i], d2[i]) == R / 2) G.f[i] = true;\n\n        G.dfs(center[0], center[1]);\n        G.dfs(center[1], center[0]);\n        ans = G.dp[center[0]][1] * G.dp[center[1]][1];\n    }\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define MOD 998244353\ntemplate<typename ty1,typename ty2>\ninline int add(ty1 x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x += y; return x < MOD ? x : x - MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline void addto(ty1 &x, ty2 y) {\n\t\t  if(y>=MOD)y%=MOD;\n\t\t  if(x>=MOD)x%=MOD;\n\t      x += y; if (x >= MOD) x -= MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int sub(ty1 x, ty2 y) {\n\t\tif(y>=MOD)y%=MOD;\n\t\t if(x>=MOD)x%=MOD;\n        x -= y; return x < 0 ? x + MOD : x;\n}\ntemplate<typename ty1,typename ty2>\ninline void subto(ty1 &x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x -= y; if (x < 0) x += MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int mul(ty1 x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        return 1ll * x * y % MOD;\n}\ntemplate<typename ty1,typename ty2>\nvoid multo(ty1 &x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        x=1ll * x * y % MOD;\n}\n  \nlong long int gcd(long long int a, long long int b){\n\tif (a > b){\n\t\tswap(a, b);\n\t}\n\twhile (a){\n\t\tswap(a, b);\n\t\ta %= b;\n\t}\n\treturn b;\n}\nlong long int lcm(long long int a, long long int b){\n\treturn a / gcd(a, b)*b;\n}\nlong long int ppow(long long int i, long long int j){\n\t\tlong long int res = 1LL;\n\t\twhile (j){\n\t\t\tif ((j & 1LL)){\n\t\t\t\tres *= i;\n\t\t\t\tif (res >= MOD){\n\t\t\t\t\tres %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj >>= 1;\n\t\t\ti *= i;\n\t\t\tif (i >= MOD){\n\t\t\t\ti %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\nclass Combination{\n\t\npublic:\n\tvector<long long int> k;\n\tvector<long long int> r;\n\tvoid resize(int N){\n\t\tk.resize(N + 2);\n\t\tr.resize(N + 2);\n\t\tk[0] = 1;\n\t\tfor (int i = 1; i < N+2; i++){\n\t\t\tk[i] = k[i - 1];\n\t\t\tk[i] *= i;\n\t\t\tif (k[i] >= MOD)k[i] %= MOD;\n\t\t}\n\t\tlong long int al = k[k.size() - 1];\n\t\tlong long int iv = ppow(k[k.size() - 1],MOD-2);\n\t\tr[k.size() - 1] = iv;\n\t\tfor (int i = (int)(r.size()) - 2; i >= 0; i--){\n\t\t\tr[i] = r[i + 1] * (i + 1);\n\t\t\tif (r[i] >= MOD){\n\t\t\t\tr[i] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int C(int a, int b){\n\t\tif (a < b)return 0;\n\t\tlong long int up = k[a];\n\t\tlong long int dw = r[b] * r[a - b];\n\t\tdw %= MOD;\n\t\tup *= dw;\n\t\tup %= MOD;\n\t\treturn up;\n\t}\n\tlong long int H(int a, int b){\n\t\treturn C(a + b - 1, b);\n\t}\n\tlong long int catalan_number(int n){\n\t\treturn (C(2 * n, n) + MOD - C(2 * n, n - 1)) % MOD;\n\t}\n};\nCombination C;\n\n#define MAX 200002\nint n;\n\n\nstruct treediameter{\n\t//直径は色々いい性質がある\n\t//中心から(２頂点の場合それをくっつける）同じ距離のびた２つの頂点間が直径\n\t//直径は最大長であることにも注意\n\tconst vector<vector<int> >&g;\n\tint r1,r2;\n\tvector<int> d1,d2;  //両端からのdist\n\tint dia;\n\tvoid dfs(int v,int p,int cur,vector<int> &d){\n\t\td[v]=cur;\n\t\tfor(auto e:g[v])if(e!=p)\n\t\t\tdfs(e,v,cur+1,d);\n\t}\n\ttreediameter(const vector<vector<int> > &gg):g(gg),d1(g.size()),d2(g.size()){\n\t\tdfs(0,-1,0,d1);\n\t\tr1=max_element(d1.begin(),d1.end())-d1.begin();\n\t\tdfs(r1,-1,0,d1);\n\t\tr2=max_element(d1.begin(),d1.end())-d1.begin();\n\t\tdfs(r2,-1,0,d2);\n\t\tdia=d1[r2];\n\t}\n\tvector<int> find_centre(){  //直径の中心をさがす 1頂点 or 2頂点　直径は必ずこれらすべてを通る\n\t\tvector<int> ret;\n\t\tfor(int i=0;i<d1.size();i++){\n\t\t\tif(d1[i]+d2[i]==dia&&abs(d1[i]-d2[i])<=1){\n\t\t\t\tret.push_back(i);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n//treediameter(v)\n\nvector<vector<int> > v;\n\nbool flag[MAX];\n\n//0:none with only one type of operation\n//1:positive without substraction\n// 2: none with mix\nint dp[MAX][3];\nbool us[MAX][3];\nint target;\ninline int dfs(int b,int ty,int pr=-1,int d=0){\n\tif(us[b][ty]){\n\t\treturn dp[b][ty];\n\t}\n\tus[b][ty]=true;\n\tint ava=0;\n\tvector<int> can;\n\tfor(int go:v[b]){\n\t\tif(go==pr||flag[go])continue;\n\t\tava++;\n\t\tcan.push_back(go);\n\t}\n\tassert(d<=target);\n\tif(ava==0){\n\t\t//leaf\n\t\tif(ty==1){\n\t\t\tif(d==target){\n\t\t\t\tdp[b][ty]=1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tdp[b][ty]=0;\n\t\t\treturn 0;\n\t\t}\n\t\tif(ty==0){\n\t\t\tif(d==target){\n\t\t\t\tdp[b][ty]=0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdp[b][ty]=1;\n\t\t\treturn 1;\n\t\t}\n\t\tif(ty==2){\n\t\t\tdp[b][ty]=1;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif(ty==1){\n\t\tif(d){\n\t\t\tfor(int go:can){\n\t\t\t\tauto ret=dfs(go,1,b,d+1);\n\t\t\t\tfor(int goo:can){\n\t\t\t\t\tif(go!=goo){\n\t\t\t\t\t\tmulto(ret,add(dfs(goo,0,b,d+1),mul(2,dfs(goo,2,b,d+1))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddto(dp[b][ty],ret);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int go:can){\n\t\t\t\tauto ret=dfs(go,1,b,d+1);\n\t\t\t\tfor(int goo:can){\n\t\t\t\t\tif(go!=goo){\n\t\t\t\t\t\tmulto(ret,add(mul(2,dfs(goo,0,b,d+1)),mul(1,dfs(goo,2,b,d+1))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddto(dp[b][ty],ret);\n\t\t\t}\n\t\t}\n\t}\n\tif(ty==2){\n\t\tdp[b][ty]=1;\n\t\tfor(int goo:can){\n\t\t\tmulto(dp[b][ty],mul(3,dfs(goo,2,b,d+1)));\n\t\t}\n\t}\n\tif(ty==0){\n\t\tdp[b][ty]=1;\n\t\tfor(int goo:can){\n\t\t\tmulto(dp[b][ty],add(dfs(goo,0,b,d+1),mul(2,dfs(goo,2,b,d+1))));\n\t\t}\n\t}\n\treturn dp[b][ty];\n}\n\nint main(){\n\tcin>>n;\n\tv.resize(n);\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tauto dia=treediameter(v);\n\tauto centre=dia.find_centre();\n\tfor(auto el:centre){\n\t\tflag[el]=true;\n\t}\n\tif(centre.size()==1){\n\t\tint pos=centre[0];\n\t\ttarget=dia.dia/2;\n\t\ttarget--;\n\t\tlong long int ans=0;\n\t\tfor(int el1:v[pos]){\n\t\t\tfor(int el2:v[pos]){\n\t\t\t\tif(el1!=el2){\n\t\t\t\t\tauto ret=mul(dfs(el1,1,pos,0),dfs(el2,1,pos,0));\n\t\t\t\t\ttarget++;\n\t\t\t\t\tfor(int el3:v[pos]){\n\t\t\t\t\t\tif(el1!=el3&&el2!=el3){\n\t\t\t\t\t\t\tmulto(ret,add(mul(2,dfs(el3,0,pos,1)),mul(1,dfs(el3,2,pos,1))));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttarget--;\n\t\t\t\t\taddto(ans,ret);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmulto(ans,ppow(2,MOD-2));\n\t\tans%=MOD;\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\telse{\n\t\ttarget=dia.dia/2;\n\t\tlong long int ans=0;\n\t\taddto(ans,mul(dfs(centre[0],1),dfs(centre[1],1)));\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nstruct edge{int to, cost, id;};\n\nclass Graph\n{\npublic:\n    int N;\n    vector<vector<edge>> G;\n    bools f;\n    mmat dp;\n\n    Graph(int N): N(N){\n        G = vector<vector<edge>>(N, vector<edge>(0));\n        f = bools(N, false);\n        dp = mmat(N, mvec(2, 0));\n    }\n\n    void add_Directed_edge(int from, int to, int cost = 1, int id = 0){\n        G[from].push_back(edge({to, cost, id}));\n    }\n\n    void add_Undirected_edge(int v1, int v2, int cost = 1, int id = 0){\n        add_Directed_edge(v1, v2, cost, id);\n        add_Directed_edge(v2, v1, cost, id);\n    }\n\n    //calculate diameter of a Tree\n    void dfs_for_calcdist(int v, int p, int c, vec &dist){\n        if(p != -1) dist[v] = dist[p] + c;\n        for(auto e: G[v]) if(e.to != p) dfs_for_calcdist(e.to, v, e.cost, dist);\n    } \n\n    int diameter(int &v1, int &v2, int s = 0){\n        vec dist(N, 0);\n        dfs_for_calcdist(s, -1, -1, dist);\n        v1 = distance(dist.begin(), max_element(dist.begin(), dist.end()));\n        fill(dist.begin(), dist.end(), 0);\n        dfs_for_calcdist(v1, -1, -1, dist);\n        auto amax = max_element(dist.begin(), dist.end());\n        v2 = distance(dist.begin(), amax);\n        return *amax;\n    }\n\n    void dfs(int v, int p){\n\n        if(f[v]) dp[v][1] = 1;\n        else dp[v][0] = 1;\n\n        if(p != -1){\n            for(auto e: G[v]) if(e.to != p){\n                dfs(e.to, v);\n                mvec tmp(2, 0);\n                tmp[0] = dp[v][0] * (dp[e.to][0] * 3 + dp[e.to][1] * 2);\n                tmp[1] = dp[v][0] * dp[e.to][1] + dp[v][1] * (dp[e.to][0] + dp[e.to][1]) * 3;\n\n                dp[v][0] = tmp[0];\n                dp[v][1] = tmp[1];\n            }\n        }else{\n            dp[v] = mvec(3, 0);\n            dp[v][0] = 1;\n            for(auto e: G[v]) if(e.to != p){\n                dfs(e.to, v);\n                mvec tmp(3, 0);\n                REP(j, 3){\n                    tmp[j] += dp[v][j] * (dp[e.to][0] * 3 + dp[e.to][1] * 2);\n                    tmp[min(j + 1, 2LL)] += dp[v][j] * dp[e.to][1];\n                }\n                dp[v][0] = tmp[0];\n                dp[v][1] = tmp[1];\n                dp[v][2] = tmp[2];\n            }\n        }\n    }\n\n};\n\n\nsigned main(){\n\n    int N; cin >> N;\n    Graph G(N);\n    REP(i, N - 1){\n        int a, b; cin >> a >> b;\n        G.add_Undirected_edge(a - 1, b - 1);\n    }\n\n    int v1, v2;\n    int R = G.diameter(v1, v2);\n    vec d1(N, 0), d2(N, 0);\n    G.dfs_for_calcdist(v1, -1, -1, d1);\n    G.dfs_for_calcdist(v2, -1, -1, d2);\n\n    vec center;\n    REP(i, N) if(d1[i] + d2[i] == R && llabs(d1[i] - d2[i]) <= 1) center.pb(i);\n    \n    fill(all(d1), 0);\n    fill(all(d2), 0);\n    mint ans;\n    if(SZ(center) == 1){\n        G.dfs_for_calcdist(center[0], -1, -1, d1);\n        REP(i, N) if(d1[i] == R / 2) G.f[i] = true;\n\n        G.dfs(center[0], -1);\n        ans = G.dp[center[0]][2];\n\n    }else{\n        G.dfs_for_calcdist(center[0], -1, -1, d1);\n        G.dfs_for_calcdist(center[1], -1, -1, d2);\n        REP(i, N) if(min(d1[i], d2[i]) == R / 2) G.f[i] = true;\n\n        G.dfs(center[0], center[1]);\n        G.dfs(center[1], center[0]);\n        ans = G.dp[center[0]][1] * G.dp[center[1]][1];\n    }\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=2e5+5,mod=998244353;\nint n,m,dis[N],fa[N],a[N],si[N],rt1,rt2,head[N],nex[N<<1],to[N<<1],tot;\nvoid add(int u,int v){to[++tot]=v;nex[tot]=head[u];head[u]=tot;}\nvoid dfs(int u,int p)\n{\n    dis[u]=dis[p]+1;\n    if(dis[u]>dis[rt1]) rt1=u;\n    fa[u]=p;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p)continue;\n        dfs(v,u);\n    }\n}\nll dp[N][3][3],p[3][3];\nvoid dfs(int u,int fa,int d)\n{\n    d==m/2?dp[u][1][1]=1:dp[u][0][0]=1;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==fa)continue;\n        dfs(v,u,d+1);\n        memset(p,0,sizeof(p));\n        for(int i=0;i<3;i++)\n            for(int j=0;j<3;j++)\n            for(int k=0;k<3;k++)\n                for(int h=0;h<3;h++)\n        {\n            p[i][j]=(p[i][j]+dp[u][i][j]*dp[v][k][h])%mod;\n            p[min(i+k,2)][j]=(p[min(i+k,2)][j]+dp[u][i][j]*dp[v][k][h])%mod;\n            p[i][min(j+h,2)]=(p[i][min(j+h,2)]+dp[u][i][j]*dp[v][k][h])%mod;\n        }\n        for(int i=0;i<3;i++)\n            for(int j=0;j<3;j++)\n            dp[u][i][j]=p[i][j];\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        int u,v;scanf(\"%d%d\",&u,&v);add(u,v);add(v,u);\n    }\n    dfs(1,0);\n    rt2=rt1;\n    dfs(rt1,0);\n    while(fa[rt1]) a[++m]=rt1,rt1=fa[rt1];\n    a[++m]=rt1;\n    rt1=rt2=0;\n    if(m%2==0) rt1=a[m/2],rt2=a[m/2+1];\n    else rt1=a[m/2+1];\n    m--;\n    if(rt1&&rt2)\n    {\n        dfs(rt1,rt2,0);dfs(rt2,rt1,0);\n        printf(\"%lld\\n\",(dp[rt1][1][0]+dp[rt1][1][1]+dp[rt1][1][2])*(dp[rt2][1][0]+dp[rt2][1][1]+dp[rt2][1][2])%mod);\n    }\n    else\n    {\n        dfs(rt1,0,0);\n        printf(\"%lld\\n\",dp[rt1][1][1]*(mod-mod/2)%mod);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[202020];\nconst ll mo=998244353;\n\npair<int,int> farthest(int cur,int pre,int d,vector<int>& D) {\n\tD[cur]=d;\n\tpair<int,int> r={d,cur};\n\tFORR(e,E[cur]) if(e!=pre) r=max(r, farthest(e,cur,d+1,D));\n\treturn r;\n}\n\npair<int,vector<int>> diameter() { // diameter,center\n\tvector<int> D[2];\n\tD[0].resize(N);\n\tD[1].resize(N);\n\tauto v1=farthest(0,0,0,D[0]);\n\tauto v2=farthest(v1.second,v1.second,0,D[0]);\n\tfarthest(v2.second,v2.second,0,D[1]);\n\tpair<int,vector<int>> R;\n\tR.first = v2.first;\n\t//重心を取る場合\n\tfor(int i=N-1;i>=0;i--) if(D[0][i]+D[1][i]==R.first && abs(D[0][i]-D[1][i])<=1) R.second.push_back(i);\n\n\treturn R;\n}\n\nvector<ll> dfs1(int cur,int pre,int lef,int no=0) {\n\tif(E[cur].size()==1) {\n\t\tif(lef==0) return {2,1,0};\n\t\telse return {3,0,0};\n\t}\n\telse {\n\t\tvector<ll> X={1,0,0};\n\t\tFORR(e,E[cur]) if(e!=pre) {\n\t\t\tvector<ll> Y=dfs1(e,cur,lef-1);\n\t\t\tvector<ll> Z={0,0,0};\n\t\t\tint x,y;\n\t\t\tFOR(x,3) FOR(y,3) Z[min(x+y,2)]+=X[x]*Y[y];\n\t\t\tX[0]=Z[0]%mo;\n\t\t\tX[1]=Z[1]%mo;\n\t\t\tX[2]=Z[2]%mo;\n\t\t}\n\t\tvector<ll> Y={0,0,0};\n\t\tif(no) {\n\t\t\tY=X;\n\t\t}\n\t\telse {\n\t\t\tY[0]=(X[0]*3+X[1]*2+X[2]*2)%mo;\n\t\t\tY[1]=X[1];\n\t\t\tY[2]=X[2];\n\t\t}\n\t\treturn Y;\n\t}\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tauto R=diameter();\n\tif(R.second.size()==1) {\n\t\tvector<ll> X={1,0,0,0};\n\t\tFORR(e,E[R.second[0]]) {\n\t\t\tauto Y=dfs1(e,R.second[0],R.first/2-1);\n\t\t\tvector<ll> Z={0,0,0,0};\n\t\t\tFOR(x,4) FOR(y,3) Z[min(x+y,3)]+=X[x]*Y[y]%mo;\n\t\t\tFOR(x,4) X[x]=Z[x]%mo;\n\t\t}\n\t\tcout<<X[2]<<endl;\n\t}\n\telse {\n\t\tvector<ll> X=dfs1(R.second[0],R.second[1],R.first/2,1);\n\t\tvector<ll> Y=dfs1(R.second[1],R.second[0],R.first/2,1);\n\t\tassert(0);\n\t\tcout<<X[1]*Y[1]%mo<<endl;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma gcc optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define PER(i, n) for (int i = (n-1); i >= 0; --i)\n#define ALL(V) (V).begin(),(V).end()\n#define SORT(V) sort(ALL(V)) //小さい方からソート\n#define REV(V) reverse(ALL(V)) //リバース\n#define RSORT(V) SORT(V);REV(V) //大きい方からソート\n#define NEXP(V) next_permutation(ALL(V)) //順列\n#define pb(n) push_back(n)\n#define popb(n) pop_back(n)\n#define endl '\\n'\n#define Endl '\\n'\n#define DUMP(x)  cout << #x << \" = \" << (x) << endl\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\"  ) << endl\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\"  ) << endl\n#define yes(n) cout << ((n) ? \"yes\" : \"no\"  ) << endl\n#define Yay(n) cout << ((n) ? \"Yay!\": \":(\") << endl\n#define VSUM(V) accumulate(ALL(V), 0)\n#define MID(a,b,c) (a) < (b) && (b) < (c)\n#define MIDe(a,b,c) (a) <= (b) && (b) <= (c)\n#define IN(n) cin >> n\n#define IN2(a,b) cin >> a >> b\n#define IN3(a,b,c) cin >> a >> b >> c \n#define IN4(a,b,c,d) cin >> a >> b >> c >> d\n#define VIN(V) for(int i = 0; i < (V).size(); i++) {cin >> (V).at(i);}\n#define OUT(n) cout << n << endl\n#define VOUT(V) REP(i, (V).size()) {cout << (V)[i] << endl;}\n#define VOUT2(V) REP(i, (V).size()) {cout << (V)[i] << \" \";} cout<<endl;\n\n#define int long long\n#define P pair<ll,ll>\n#define Vi vector<ll>\n#define VVi vector<vector<ll>>\n#define Vd vector<double>\n#define Vb vector<bool>\n#define Vs vector<string>\n#define Vc vector<char>\n#define M map<ll,ll>\n#define S set<ll>\n#define PQ priority_queue<ll>\n#define PQG priority_queue<ll,V,greater<ll>\n\nusing ll = long long;\nusing Graph = vector<vector<int>>;\n\nconst int MOD = 1000000007;\nconst int INF = 1061109567;\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nstruct UnionFind {\n  vector<int> par;\n\n  UnionFind(int n) : par(n) {\n    for(int i = 0; i < n; ++i) par[i] = i;\n  }\n\n  int root(int x) {\n    if(par[x] == x) return x;\n    return par[x] = root(par[x]);\n  }\n\n  void unite(int x, int y) {\n    int rx = root(x);\n    int ry = root(y);\n    if(rx == ry) return;\n    par[rx] = ry;\n  }\n\n  bool same(int x, int y) {\n    int rx = root(x);\n    int ry = root(y);\n    return rx == ry;\n  }\n};\n\nint gcd(int a, int b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nint lcm(int a, int b) {\n  return a * b / gcd(a, b);\n}\n\n// 文字を全て大文字にします\nstring toStrUp(string str) {\n  char diff = 'A'-'a';\n  REP(i,str.size()) str[i] += diff;\n  return str;\n}\n\n// 文字をstring型で一文字取得します\nstring get1ch(string str, int key) {\n  return str.substr(key,1);\n}\n\n// 素因数分解 (O(sqrt(n)))\nmap<int,int> prime_factor(int n) {\n  map<int,int> ret;\n  for(int i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n\n// 素数判定 (O(sqrt(n)))\nbool is_prime(int x) {\n  for(int i = 2; i * i <= x; i++) {\n    if(x % i == 0) return false;\n  }\n  return true;\n}\n\n// 進数変換 (O(log n))\ntemplate<typename T>\nvector<T> convert_base(T x, T b) {\n  vector< T > ret;\n  T t = 1, k = abs(b);\n  while(x) {\n    ret.emplace_back((x * t) % k);\n    if(ret.back() < 0) ret.back() += k;\n    x -= ret.back() * t;\n    x /= k;\n    t *= b / k;\n  }\n  if(ret.empty()) ret.emplace_back(0);\n  reverse(begin(ret), end(ret));\n  return ret;\n}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n  if(a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate<class T> inline bool chmax(T& a, T b) {\n  if(a < b){\n    a = b;\n    return true;\n  }\n  return false;\n}\n\nstruct RandomNumberGenerator {\n  mt19937 mt;\n\n  RandomNumberGenerator() : mt(chrono::steady_clock::now().time_since_epoch().count()) {}\n\n  int operator()(int a, int b) { // [a, b)\n    uniform_int_distribution< int > dist(a, b - 1);\n    return dist(mt);\n  }\n\n  int operator()(int b) { // [0, b)\n    return (*this)(0, b);\n  }\n};\n\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(15);\n\n  // デフォルト変数定義\n  int n=0,m=0,a=0,b=0,c=0,d=0,x=0,y=0,z=0;\n  string s=\"\",t=\"\";\n  //\n\n  // ここから\n  IN(n);\n  Vi A(n-1);\n  Vi B(n-1);\n  REP(i,n-1){\n    IN2(A[i],B[i]);\n  }\n  OUT(rand()%998244352+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=998244353,iv=(mod+1)/2;\nint n,x,y,dist[222222],pre[222222],rt,cnt,dp[222222][4][4],len,f[4][4],G[4][4];\nvector<int> g[222222];\nint bfs(int s)\n{\n\tqueue<int> q;\n\tq.push(s);\n\tmemset(dist,-1,sizeof(dist));\n\tdist[s]=0;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();q.pop();\n\t\tfor (int i=0;i<g[x].size();i++)\n\t\t{\n\t\t\tint to=g[x][i];\n\t\t\tif (!~dist[to])\n\t\t\t{\n\t\t\t\tdist[to]=dist[x]+1;\n\t\t\t\tpre[to]=x;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\tint mxi=1;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tif (dist[i]>dist[mxi]) mxi=i;\n\t}\n\treturn mxi;\n}\nvoid add(int &x,int y)\n{\n\tx+=y;\n\tif (x>=mod) x-=mod;\n}\nvoid dfs(int i,int fa,int dep)\n{\n\tif (dep==len)\n\t{\n\t\tdp[i][0][0]=dp[i][1][0]=dp[i][0][1]=1;\n\t\treturn;\n\t}\n\tfor (int j=0;j<g[i].size();j++)\n\t{\n\t\tint to=g[i][j];\n\t\tif (to==fa) continue;\n\t\tdfs(to,i,dep+1);\n\t}\n\tmemset(f,0,sizeof(f));\n\tf[0][0]=1;\n\tfor (int j=0;j<g[i].size();j++)\n\t{\n\t\tint to=g[i][j];\n\t\tif (to==fa) continue;\n\t\tmemset(G,0,sizeof(G));\n\t\tfor (int k=0;k<3;k++)\n\t\t{\n\t\t\tfor (int h=0;h<3;h++)\n\t\t\t{\n\t\t\t\tfor (int s=0;s<3;s++)\n\t\t\t\t{\n\t\t\t\t\tfor (int t=0;t<3;t++)\n\t\t\t\t\t{\n\t\t\t\t\t\tadd(G[min(k+s,2)][min(h+t,2)],1ll*f[k][h]*dp[to][s][t]%mod);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemcpy(f,G,sizeof(G));\n\t}\n\tfor (int j=0;j<3;j++)\n\t{\n\t\tfor (int k=0;k<3;k++)\n\t\t{\n\t\t\tif (i!=rt)\n\t\t\t{\n\t\t\t\tadd(dp[i][0][0],f[j][k]);\n\t\t\t\tadd(dp[i][0][k],f[j][k]);\n\t\t\t\tadd(dp[i][j][0],f[j][k]);\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tadd(dp[i][j][k],f[j][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tx=bfs(1);\n\ty=bfs(x);\n\tif (dist[y]&1)\n\t{\n\t\tfor (int i=y;i!=x;i=pre[i])\n\t\t{\n\t\t\tcnt++;\n\t\t\tif (cnt==(dist[y]+1)/2)\n\t\t\t{\n\t\t\t\t++n;\n\t\t\t\trt=n;\n\t\t\t\tg[rt].push_back(i);\n\t\t\t\tg[rt].push_back(pre[i]);\n\t\t\t\tg[i].push_back(rt);\n\t\t\t\tg[pre[i]].push_back(rt);\n\t\t\t\tfor (int j=0;j<g[i].size();j++)\n\t\t\t\t{\n\t\t\t\t\tif (g[i][j]==pre[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tg[i].erase(g[i].begin()+j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j=0;j<g[pre[i]].size();j++)\n\t\t\t\t{\n\t\t\t\t\tif (g[pre[i]][j]==i)\n\t\t\t\t\t{\n\t\t\t\t\t\tg[pre[i]].erase(g[pre[i]].begin()+j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlen=(dist[y]+1)/2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (int i=y;i!=x;i=pre[i])\n\t\t{\n\t\t\tcnt++;\n\t\t\tif (cnt==dist[y]/2+1)\n\t\t\t{\n\t\t\t\trt=i;\n\t\t\t\tlen=dist[y]/2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tdfs(rt,0,0);\n\tprintf(\"%d\\n\",1ll*dp[rt][1][1]*iv%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[202020];\nconst ll mo=998244353;\nint D;\nll dp[202020][3][3];\n\npair<int,int> farthest(int cur,int pre,int d,vector<int>& D) {\n\tD[cur]=d;\n\tpair<int,int> r={d,cur};\n\tFORR(e,E[cur]) if(e!=pre) r=max(r, farthest(e,cur,d+1,D));\n\treturn r;\n}\n\npair<int,vector<int>> diameter() { // diameter,center\n\tvector<int> D[2];\n\tD[0].resize(N);\n\tD[1].resize(N);\n\tauto v1=farthest(0,0,0,D[0]);\n\tauto v2=farthest(v1.second,v1.second,0,D[0]);\n\tfarthest(v2.second,v2.second,0,D[1]);\n\tpair<int,vector<int>> R;\n\tR.first = v2.first;\n\t//重心を取る場合\n\tfor(int i=N-1;i>=0;i--) if(D[0][i]+D[1][i]==R.first && abs(D[0][i]-D[1][i])<=1) R.second.push_back(i);\n\n\treturn R;\n}\n\nvoid dfs(int cur,int pre,int lef) {\n\tif(lef==0) {\n\t\tdp[cur][1][1]=1;\n\t}\n\telse {\n\t\tdp[cur][0][0]=1;\n\t}\n\t\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\tdfs(e,cur,lef-1);\n\t\tll to[3][3]={};\n\t\tint a1,a2,b1,b2;\n\t\tFOR(a1,3) FOR(a2,3) FOR(b1,3) FOR(b2,3) {\n\t\t\t// +1\n\t\t\tto[min(a1+b1,2)][a2]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t\t// 0\n\t\t\tto[a1][a2]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t\t// -1\n\t\t\tto[a1][min(a2+b2,2)]+=dp[cur][a1][a2]*dp[e][b1][b2]%mo;\n\t\t}\n\t\t\n\t\tFOR(a1,3) FOR(a2,3) dp[cur][a1][a2]=to[a1][a2]%mo;\n\t}\n\t\n\t\n\t\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tauto R=diameter();\n\tD=R.first;\n\tif(R.second.size()==1) {\n\t\tx=R.second[0];\n\t\tdfs(x,-1,R.first/2);\n\t\t\n\t\tcout<<dp[x][1][1]*((mo+1)/2)%mo<<endl;\n\t}\n\telse {\n\t\tx=R.second[0];\n\t\ty=R.second[1];\n\t\tdfs(x,y,R.first/2);\n\t\tdfs(y,x,R.first/2);\n\t\t\n\t\tcout<<dp[x][0][1]*dp[y][1][0]%mo<<endl;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nstruct edge{int to, cost, id;};\n\nclass Graph\n{\npublic:\n    int N;\n    vector<vector<edge>> G;\n    bools f;\n    mmat dp;\n\n    Graph(int N): N(N){\n        G = vector<vector<edge>>(N, vector<edge>(0));\n        f = bools(N, false);\n        dp = mmat(N, mvec(2, 0));\n    }\n\n    void add_Directed_edge(int from, int to, int cost = 1, int id = 0){\n        G[from].push_back(edge({to, cost, id}));\n    }\n\n    void add_Undirected_edge(int v1, int v2, int cost = 1, int id = 0){\n        add_Directed_edge(v1, v2, cost, id);\n        add_Directed_edge(v2, v1, cost, id);\n    }\n\n    //calculate diameter of a Tree\n    void dfs_for_calcdist(int v, int p, int c, vec &dist){\n        if(p != -1) dist[v] = dist[p] + c;\n        for(auto e: G[v]) if(e.to != p) dfs_for_calcdist(e.to, v, e.cost, dist);\n    } \n\n    int diameter(int &v1, int &v2, int s = 0){\n        vec dist(N, 0);\n        dfs_for_calcdist(s, -1, -1, dist);\n        v1 = distance(dist.begin(), max_element(dist.begin(), dist.end()));\n        fill(dist.begin(), dist.end(), 0);\n        dfs_for_calcdist(v1, -1, -1, dist);\n        auto amax = max_element(dist.begin(), dist.end());\n        v2 = distance(dist.begin(), amax);\n        return *amax;\n    }\n\n    void dfs(int v, int p){\n\n        if(f[v]) dp[v][1] = 1;\n        else dp[v][0] = 1;\n\n        if(p != -1){\n            for(auto e: G[v]) if(e.to != p){\n                dfs(e.to, v);\n                mvec tmp(2, 0);\n                tmp[0] = dp[v][0] * (dp[e.to][0] * 3 + dp[e.to][1] * 2);\n                tmp[1] = dp[v][0] * dp[e.to][1] + dp[v][1] * (dp[e.to][0] + dp[e.to][1]) * 3;\n\n                dp[v][0] = tmp[0];\n                dp[v][1] = tmp[1];\n            }\n        }else{\n            dp[v] = mvec(3, 0);\n            dp[v][0] = 1;\n            for(auto e: G[v]) if(e.to != p){\n                dfs(e.to, v);\n                mvec tmp(3, 0);\n                REP(j, 3){\n                    tmp[j] += dp[v][j] * (dp[e.to][0] * 3 + dp[e.to][1] * 2);\n                    tmp[min(j + 1, 2LL)] += dp[v][j] * dp[e.to][1];\n                }\n                dp[v][0] = tmp[0];\n                dp[v][1] = tmp[1];\n                dp[v][2] = tmp[2];\n            }\n        }\n    }\n\n};\n\n\nsigned main(){\n\n    int N; cin >> N;\n    Graph G(N);\n    REP(i, N - 1){\n        int a, b; cin >> a >> b;\n        G.add_Undirected_edge(a - 1, b - 1);\n    }\n\n    int v1, v2;\n    int R = G.diameter(v1, v2);\n    vec d1(N, 0), d2(N, 0);\n    G.dfs_for_calcdist(v1, -1, -1, d1);\n    G.dfs_for_calcdist(v2, -1, -1, d2);\n\n    vec center;\n    REP(i, N) if(d1[i] + d2[i] == R && llabs(d1[i] - d2[i]) <= 1) center.pb(i);\n    \n    fill(all(d1), 0);\n    fill(all(d2), 0);\n    mint ans;\n    if(SZ(center) == 1){\n        G.dfs_for_calcdist(center[0], -1, -1, d1);\n        REP(i, N) if(d1[i] == R / 2) G.f[i] = true;\n\n        G.dfs(center[0], -1);\n        ans = G.dp[center[0]][2];\n        assert(false);\n\n    }else{\n        G.dfs_for_calcdist(center[0], -1, -1, d1);\n        G.dfs_for_calcdist(center[1], -1, -1, d2);\n        REP(i, N) if(min(d1[i], d2[i]) == R / 2) G.f[i] = true;\n\n        G.dfs(center[0], center[1]);\n        G.dfs(center[1], center[0]);\n        ans = G.dp[center[0]][1] * G.dp[center[1]][1];\n    }\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (q < m) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\ntemplate <int mod>\nstruct ModInt\n{\n    using lint = long long;\n    static int get_mod() { return mod; }\n    static int get_primitive_root() {\n        static int primitive_root = 0;\n        if (!primitive_root) {\n            primitive_root = [&](){\n                std::set<int> fac;\n                int v = mod - 1;\n                for (lint i = 2; i * i <= v; i++) while (v % i == 0) fac.insert(i), v /= i;\n                if (v > 1) fac.insert(v);\n                for (int g = 1; g < mod; g++) {\n                    bool ok = true;\n                    for (auto i : fac) if (ModInt(g).power((mod - 1) / i) == 1) { ok = false; break; }\n                    if (ok) return g;\n                }\n                return -1;\n            }();\n        }\n        return primitive_root;\n    }\n    int val;\n    constexpr ModInt() : val(0) {}\n    constexpr ModInt &_setval(lint v) { val = (v >= mod ? v - mod : v); return *this; }\n    constexpr ModInt(lint v) { _setval(v % mod + mod); }\n    explicit operator bool() const { return val != 0; }\n    constexpr ModInt operator+(const ModInt &x) const { return ModInt()._setval((lint)val + x.val); }\n    constexpr ModInt operator-(const ModInt &x) const { return ModInt()._setval((lint)val - x.val + mod); }\n    constexpr ModInt operator*(const ModInt &x) const { return ModInt()._setval((lint)val * x.val % mod); }\n    constexpr ModInt operator/(const ModInt &x) const { return ModInt()._setval((lint)val * x.inv() % mod); }\n    constexpr ModInt operator-() const { return ModInt()._setval(mod - val); }\n    constexpr ModInt &operator+=(const ModInt &x) { return *this = *this + x; }\n    constexpr ModInt &operator-=(const ModInt &x) { return *this = *this - x; }\n    constexpr ModInt &operator*=(const ModInt &x) { return *this = *this * x; }\n    constexpr ModInt &operator/=(const ModInt &x) { return *this = *this / x; }\n    friend constexpr ModInt operator+(lint a, const ModInt &x) { return ModInt()._setval(a % mod + x.val); }\n    friend constexpr ModInt operator-(lint a, const ModInt &x) { return ModInt()._setval(a % mod - x.val + mod); }\n    friend constexpr ModInt operator*(lint a, const ModInt &x) { return ModInt()._setval(a % mod * x.val % mod); }\n    friend constexpr ModInt operator/(lint a, const ModInt &x) { return ModInt()._setval(a % mod * x.inv() % mod); }\n    constexpr bool operator==(const ModInt &x) const { return val == x.val; }\n    constexpr bool operator!=(const ModInt &x) const { return val != x.val; }\n    bool operator<(const ModInt &x) const { return val < x.val; }  // To use std::map<ModInt, T>\n    friend std::istream &operator>>(std::istream &is, ModInt &x) { lint t; is >> t; x = ModInt(t); return is; }\n    friend std::ostream &operator<<(std::ostream &os, const ModInt &x) { os << x.val;  return os; }\n    constexpr lint power(lint n) const {\n        lint ans = 1, tmp = this->val;\n        while (n) {\n            if (n & 1) ans = ans * tmp % mod;\n            tmp = tmp * tmp % mod;\n            n /= 2;\n        }\n        return ans;\n    }\n    constexpr lint inv() const { return this->power(mod - 2); }\n    constexpr ModInt operator^(lint n) const { return ModInt(this->power(n)); }\n    constexpr ModInt &operator^=(lint n) { return *this = *this ^ n; }\n\n    inline ModInt fac() const {\n        static std::vector<ModInt> facs;\n        int l0 = facs.size();\n        if (l0 > this->val) return facs[this->val];\n\n        facs.resize(this->val + 1);\n        for (int i = l0; i <= this->val; i++) facs[i] = (i == 0 ? ModInt(1) : facs[i - 1] * ModInt(i));\n        return facs[this->val];\n    }\n};\nusing mint = ModInt<998244353>;\n\nvector<vector<int>> to;\n\nvector<int> D, par;\nint L;\nvoid dfs1(int now, int prv, int d)\n{\n    par[now] = prv;\n    D[now] = d;\n    for (auto nxt : to[now]) if (nxt != prv) {\n        dfs1(nxt, now, d + 1);\n    }\n}\n\nvector<mint> dpall, dp1, dpbad;\n\nint dfs_furthest(int now, int prv) {\n    int ret = D[now];\n    for (auto nxt : to[now]) if (nxt != prv) {\n        mmax(ret, dfs_furthest(nxt, now));\n    }\n    return ret;\n}\n\nint dfs_count(int now, int prv) {\n    int ret = 1;\n    for (auto nxt : to[now]) if (nxt != prv) ret += dfs_count(nxt, now);\n    return ret;\n}\n\nvoid dfs_dp(int now, int prv) {\n    dpall[now] = 1;\n    dp1[now] = 0;\n    dpbad[now] = 0;\n    bool f = false;\n    for (auto nxt : to[now]) if (nxt != prv) {\n        f = true;\n        dfs_dp(nxt, now);\n        dpbad[now] = dpbad[now] * (dpbad[nxt] + dp1[nxt] + dpall[nxt]) + dp1[now] * dp1[nxt];\n        dp1[now] = dp1[now] * dpall[nxt] + dpall[now] * dp1[nxt];\n        dpall[now] = dpall[now] * dpall[nxt];\n    }\n    dpall[now] = dpall[now] * 3 + dp1[now] * 2 + dpbad[now] * 2;\n    if (!f) {\n        if (D[now] == L / 2) {\n            dpall[now] = 2;\n            dp1[now] = 1;\n        }\n        else dpall[now] = 3;\n    }\n}\n\nvector<vector<vector<mint>>> dpv;  // (N, 3, 2)\nvoid dfs_even(int now, int prv) {\n    bool f = false;\n    dpv[now][0][0] = 1;\n    for (auto nxt : to[now]) if (nxt != prv) {\n        f = true;\n        dfs_even(nxt, now);\n        vector<vector<mint>> dpnxt(3, vector<mint>(2));\n        REP(np, 3) REP(nm, 2) REP(nnp, 3) REP(nnm, 2) {\n            dpnxt[min(np + nnp, 2)][min(nm + nnm, 1)] += dpv[now][np][nm] * dpv[nxt][nnp][nnm];\n        }\n        dpv[now] = dpnxt;\n    }\n    if (f) {\n        mint pl2 = 0, pl1 = 0, zero = 0, mi1 = 0;\n        REP(np, 3) REP(nm, 2) {\n            if (np == 2) pl2 += dpv[now][np][nm];\n            if (np == 1) pl1 += dpv[now][np][nm];\n            if (np == 0) zero += dpv[now][np][nm];\n            zero += dpv[now][np][nm];\n            if (nm == 1) mi1 += dpv[now][np][nm];\n            if (nm == 0) zero += dpv[now][np][nm];\n            dpv[now][np][nm] = 0;\n        }\n        dpv[now][2][0] = pl2;\n        dpv[now][1][0] = pl1;\n        dpv[now][0][0] = zero;\n        dpv[now][0][1] = mi1;\n    }\n    else {\n        if (D[now] == L / 2) dpv[now][1][0] = dpv[now][0][1] = dpv[now][0][0] = 1;\n        else dpv[now][0][0] = 3;\n    }\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n    to.resize(N);\n    REP(_, N - 1) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        to[a].push_back(b);\n        to[b].push_back(a);\n    }\n    D.assign(N, 0);\n    par.assign(N, -1);\n    dfs1(0, -1, 0);\n\n    int S = max_element(ALL(D)) - D.begin();\n    dfs1(S, -1, 0);\n    int T = max_element(ALL(D)) - D.begin();\n    L = D[T];\n    // dbg(L);\n    dpall.resize(N);\n    dp1.resize(N);\n    dpbad.resize(N);\n    ndarray(dpv, N, 3, 2);\n    int R = T;\n    REP(_, L / 2) R = par[R];\n    // dbg(R);\n\n    if (L % 2 == 0) {\n        dfs1(R, -1, 0);\n        for (auto A : to[R]) {\n            int l = dfs_furthest(A, R);\n            if (l < L / 2) {\n                dpv[A][0][0] = mint(3).power(dfs_count(A, R));\n            }\n            else {\n                dfs_even(A, R);\n            }\n        }\n        vector<mint> P(3);\n        P[0] = 1;\n        for (auto A : to[R]) {\n            IREP(d, 2) {\n                P[d + 1] += P[d] * dpv[A][1][0];\n                P[d] *= dpv[A][0][0];\n            }\n        }\n        // REP(i, dpv.size()) {\n        //     dbg(i + 1);\n        //     dbg(dpv[i]);\n        // }\n        cout << P[2] << endl;\n        return 0;\n    }\n    else {\n        int U = par[R];\n        mint ret = 1;\n        // dbg(R);\n        // dbg(U);\n        REP(_, 2) {\n            dfs1(R, -1, 0);\n            for (auto A : to[R]) if (A != U) {\n                int l = dfs_furthest(A, R);\n                if (l < L / 2) {\n                    dpall[A] = mint(3).power(dfs_count(A, R));\n                    dp1[A] = 0;\n                }\n                else {\n                    dfs_dp(A, R);\n                }\n            }\n            mint P0 = 1, P1 = 0;\n            for (auto A : to[R]) if (A != U) {\n                P1 = P1 * dpall[A] + P0 * dp1[A];\n                P0 *= dpall[A];\n            }\n            ret *= P1;\n            swap(R, U);\n        }\n        // dbg(dp1);\n        // dbg(dpall);\n        cout << ret << endl;\n        return 0;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=200000+5,mod=998244353;\nint ksm(int b,int n){\n\tint res=1;\n\twhile(n){\n\t\tif(n&1) res=res*b%mod;\n\t\tb=b*b%mod; n>>=1;\n\t}\n\treturn res;\n}\nint add(int x,int y){\n\treturn (x+y)%mod;\n}\nint mul(int x,int y){\n\treturn x*y%mod;\n}\nvector<int> e[N];\nint n,dis[N],pre[N];\nint dp[N][3][3];\nint bfs(int st){\n\tqueue<int> q;\n\tint res=0;\n\tfor(int i=1;i<=n;++i)\n\t\tdis[i]=0;\n\tdis[st]=1; pre[st]=0; q.push(st);\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\tif(dis[u]>dis[res]) res=u;\n\t\t//cout<<st<<\" \"<<u<<\" \"<<dis[u]<<\" \"<<res<<endl;\n\t\tfor(int i=0;i<e[u].size();++i)\n\t\t\tif(dis[e[u][i]]==0) q.push(e[u][i]),dis[e[u][i]]=dis[u]+1,pre[e[u][i]]=u;\n\t}\n\treturn res;\n}\nint L,tmp[3][3];\nvoid dfs(int u,int fath,int dep){\n\t//cout<<u<<\" \"<<fath<<\" \"<<dep<<endl;\n\tif(dep==L/2) dp[u][1][1]=1;\n\telse dp[u][0][0]=1;\n\tfor(int i=0;i<e[u].size();++i){\n\t\tint v=e[u][i];\n\t\tif(v==fath) continue;\n\t\tdfs(v,u,dep+1);\n\t\tfor(int x=0;x<=2;++x)\n\t\t\tfor(int y=0;y<=2;++y)\n\t\t\t\ttmp[x][y]=0;\n\t\tfor(int x=0;x<=2;++x)\n\t\t\tfor(int y=0;y<=2;++y)\n\t\t\t\tfor(int a=0;a<=2;++a)\n\t\t\t\t\tfor(int b=0;b<=2;++b)\n\t\t\t\t\t\tfor(int type=0;type<=2;++type){\n\t\t\t\t\t\t\tint p=min(x+(type==1)*a,2ll),q=min(y+(type==2)*b,2ll);\n\t\t\t\t\t\t\ttmp[p][q]=add(tmp[p][q],mul(dp[u][x][y],dp[v][a][b]));\n\t\t\t\t\t\t}\n\t\tfor(int x=0;x<=2;++x)\n\t\t\tfor(int y=0;y<=2;++y)\n\t\t\t\tdp[u][x][y]=tmp[x][y];\n\t}\n\t//for(int x=0;x<=2;++x)\n\t//\tfor(int y=0;y<=2;++y)\n\t\t//\tcout<<u<<\" \"<<x<<\" \"<<y<<\" \"<<dp[u][x][y]<<endl;\n}\nint c[N],tot;\nvoid solve(){\n\tint from=bfs(1),to=bfs(from);\n//\tcout<<from<<\" \"<<to<<endl;\n\ttot=0;while(to) c[++tot]=to,to=pre[to];\n\tcout<<tot<<endl; \n\tL=tot;\n\tif(tot&1){\n\t\tfrom=c[(tot+1)/2];\n\t\tdfs(from,0,0);\n\t\t//cout<<dp[from][1][1]<<endl;\n\t\tcout<<mul(dp[from][1][1],ksm(2,mod-2));\n\t\treturn;\n\t}\n\telse{\n\t\tfrom=c[tot/2],to=c[(tot+2)/2];\n\t\t//cout<<from<<\" \"<<to<<endl;\n\t\tdfs(from,to,0);\n\t\tint x=0,y=0;\n\t\tfor(int i=0;i<=2;++i)\n\t\t\tx=add(x,dp[from][i][1]);\n\t\tdfs(to,from,0);\n\t\tfor(int i=0;i<=2;++i)\n\t\t\ty=add(y,dp[to][1][i]);\n\t//cout<<x<<\" \"<<y<<endl;\n\t\tcout<<mul(x,y);\n\t\treturn;\n\t}\n}\nsigned main(){\n\tint ans=0,u,v;\n\tcin>>n;\n\tfor(int i=1;i<n;++i){\n\t\tcin>>u>>v;\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\ndouble startTime;\ndouble getCurrentTime() {\n\treturn ((double)clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst ll MOD = (ll)998244353;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\n\nconst int N = 200200;\nll pw3[N];\nint n;\nvector<int> g[N];\nll ANS;\nint dist[N];\nbool fromV[N], fromU[N];\nint q[N];\nint par[N];\nint topQ;\nint D;\nll dp[N][2];\n\nvoid BFS(int v) {\n\tfor (int i = 0; i < n; i++)\n\t\tdist[i] = N;\n\tdist[v] = 0;\n\ttopQ = 0;\n\tq[topQ++] = v;\n\tfor (int i = 0; i < topQ; i++) {\n\t\tv = q[i];\n\t\tfor (int u : g[v]) {\n\t\t\tif (dist[u] <= dist[v] + 1) continue;\n\t\t\tdist[u] = dist[v] + 1;\n\t\t\tpar[u] = v;\n\t\t\tq[topQ++] = u;\n\t\t}\n\t}\n}\n\nvoid dfs(int v, int p) {\n\tdp[v][0] = dp[v][1] = 0;\n\tif ((int)g[v].size() == 1) {\n\t\tdp[v][(int)(dist[v] == D)] = 1;\n\t\t//dp[v][0] = add(dp[v][0], 2);\n\t\treturn;\n\t}\n\tdp[v][0] = 1;\n\tll inner[2];\n\tfor (int u : g[v]) {\n\t\tif (u == p) continue;\n\t\tinner[0] = inner[1] = 0;\n\t\tdfs(u, v);\n\t\tll w[2];\n\t\tw[0] = w[1] = 0;\n\t\tw[0] = add(mult(3, dp[u][0]), mult(2, dp[u][1]));\n\t\tw[1] = dp[u][1];\n\t\tfor (int x = 0; x < 2; x++)\n\t\t\tfor (int y = 0; y < 2; y++) {\n\t\t\t\tif (x + y < 2)\n\t\t\t\t\tinner[x + y] = add(inner[x + y], mult(dp[v][x], w[y]));\n\t\t\t}\n\t\tfor (int i = 0; i < 2; i++)\n\t\t\tdp[v][i] = inner[i];\n\t}\n}\n\nvoid solveVertex(int v) {\n\teprintf(\"solveVertex %d\\n\", v);\n\tD /= 2;\n\tBFS(v);\n\tll inner[2][3];\n\tfor (int i = 0; i < 2; i++)\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tinner[i][j] = 0;\n\tinner[0][0] = 1;\n\tfor (int u : g[v]) {\n\t\tdfs(u, v);\n\t\tll w[2];\n\t\tw[0] = w[1] = 0;\n\t\tw[0] = add(mult(3, dp[u][0]), dp[u][1]);\n\t\tw[1] = dp[u][1];\n\t\teprintf(\"%lld %lld\\n\", w[0], w[1]);\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tinner[1][i] = 0;\n\t\tfor (int x = 0; x < 3; x++)\n\t\t\tfor (int y = 0; y < 2; y++)\n\t\t\t\tif (x + y < 3)\n\t\t\t\t\tinner[1][x + y] = add(inner[1][x + y], mult(inner[0][x], w[y]));\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tinner[0][i] = inner[1][i];\n\t}\n\tll ans = inner[0][2];\n\tprintf(\"%lld\\n\", ans);\n}\nvoid solveEdge(int v, int u) {\n\teprintf(\"solveEdge %d %d\\n\", v, u);\n\tD /= 2;\n\tll ans = 1;\n\tfor (int k = 0; k < 2; k++) {\n\t\tBFS(v);\n\t\tdfs(v, u);\n\t\tans = mult(ans, dp[v][1]);\n\t\tswap(v, u);\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tstartTime = (double)clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tpw3[0] = 1;\n\tfor (int i = 1; i < N; i++)\n\t\tpw3[i] = mult(pw3[i - 1], 3);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\n\tBFS(0);\n\tint V = q[n - 1];\n\tBFS(V);\n\tint U = q[n - 1];\n\tD = dist[U];\n\n\tif (D & 1) {\n\t\tint v = U;\n\t\tfor (int i = 0; i < D / 2; i++)\n\t\t\tv = par[v];\n\t\tsolveEdge(v, par[v]);\n\t} else {\n\t\tint v = U;\n\t\tfor (int i = 0; i < D / 2; i++)\n\t\t\tv = par[v];\n\t\tsolveVertex(v);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=200005;\nconst int mod=998244353;\nint n,diam,s,t,ans;\nvector<int>edge[maxn];\nint dep[maxn],par[maxn],dp[maxn][3][3],ndp[3][3];\nbool leaf[maxn];\nvoid Add(int &a,int b){\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\n\nvoid predfs(int x,int p,int d){\n\tpar[x]=p;\n\tdep[x]=d;\n\tfor(int i=0;i<int(edge[x].size());i++)\n\t\tif(edge[x][i]!=p)predfs(edge[x][i],x,d+1);\n}\nvoid dfs(int x,int p,int d){\n\tif(d==diam/2)leaf[x]=true;\n\tdp[x][0][0]=1;\n\tfor(int i=0;i<int(edge[x].size());i++){\n\t\tint y=edge[x][i];\n\t\tif(y==p)continue;\n\t\tdfs(y,x,d+1);\n\t\tfor(int a=0;a<3;a++)for(int b=0;b<3;b++)ndp[a][b]=0;\n\t\tfor(int a=0;a<3;a++)for(int b=0;b<3;b++)if(dp[x][a][b])\n\t\t\tfor(int c=0;c<3;c++)for(int d=0;d<3;d++)if(dp[y][c][d]){\n\t\t\t\tint cur=1LL*dp[x][a][b]*dp[y][c][d]%mod;\n\t\t\t\tif(leaf[y]){\n\t\t\t\t\tAdd(ndp[min(2,a+1)][b],cur);\n\t\t\t\t\tAdd(ndp[a][b],cur);\n\t\t\t\t\tAdd(ndp[a][min(2,b+1)],cur);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tAdd(ndp[min(2,a+c)][b],cur);\n\t\t\t\t\tAdd(ndp[a][b],cur);\n\t\t\t\t\tAdd(ndp[a][min(2,b+d)],cur);\n\t\t\t\t}\n\t\t\t}\n\t\tfor(int a=0;a<3;a++)for(int b=0;b<3;b++)dp[x][a][b]=ndp[a][b];\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n-1;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tedge[u].push_back(v);\n\t\tedge[v].push_back(u);\n\t}\n\tpredfs(1,0,0);\n\tfor(int i=1;i<=n;i++)if(!s||dep[i]>dep[s])s=i;\n\tpredfs(s,0,0);\n\tfor(int i=1;i<=n;i++)if(!t||dep[i]>dep[t])t=i;\n\tdiam=dep[t];\n\tint u=t;\n\tfor(int i=1;i<=diam/2;i++)u=par[u];\n\tif(diam%2==0){\n\t\tdfs(u,0,0);\n\t\tans=dp[u][1][1];\n\t}\n\telse{\n\t\tint v=par[u];\n\t\tdfs(u,v,0);\n\t\tdfs(v,u,0);\n\t\tint ansu=(1LL*dp[u][0][1]+dp[u][1][1]+dp[u][2][1])%mod;\n\t\tint ansv=(1LL*dp[v][1][0]+dp[v][1][1]+dp[v][1][2])%mod;\n\t\tans=2LL*ansu%mod*ansv%mod;\n\t}\n\tprintf(\"%d\\n\",1LL*ans*(mod+1)/2%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<ctime>\n#include<set>\n#include<queue>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);++(i))\n#define fd1(i,n) for ((i)=(n);(i)>=1;--(i))\n#define fz0g(i,n) for ((i)=0;(i)<=(n);++(i))\n#define fd0g(i,n) for ((i)=(n);(i)>=0;--(i))\n#define fz0k(i,n) for ((i)=0;(i)<(n);++(i))\n#define fd0k(i,n) for ((i)=(long long)((n)-1);(i)>=0;--(i))\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);++(i))\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);--(i))\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\nusing namespace std;\nconst int mod=998244353;\nint n,m,i,j,a[300005],dep[300005],pre[300005],dp[300005][3][3],f[3][3],mx,mxd,rt;\nvector<int> bi[300005],seq;\nvoid dfs1(int x,int fa)\n{\n\tif(dep[x]>mx){\n\t\tmx=dep[x];\n\t\tmxd=x;\n\t}\n\tff(bi[x],it){\n\t\tif(*it==fa) continue;\n\t\tdep[*it]=dep[x]+1;\n\t\tpre[*it]=x;\n\t\tdfs1(*it,x);\n\t}\n}\nvoid dfs2(int x,int fa)\n{\n\tif(dep[x]==seq.size()/2) dp[x][1][1]=1; else dp[x][0][0]=1;\n\tff(bi[x],it){\n\t\tif(*it==fa) continue;\n\t\tdep[*it]=dep[x]+1;\n\t\tdfs2(*it,x);\n\t\tmemset(f,0,sizeof(f));\n\t\tint a,b,c,d,i;\n\t\tfz0k(a,3)fz0k(b,3){\n\t\t\tfz0k(c,3)fz0k(d,3){\n\t\t\t\tfz0k(i,3){\n\t\t\t\t\tint na=min(2,a+c*(i==1));\n\t\t\t\t\tint nb=min(2,b+d*(i==2));\n\t\t\t\t\tf[na][nb]=(f[na][nb]+1ll*dp[x][a][b]*dp[*it][c][d])%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemcpy(dp[x],f,sizeof(f));\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfz1(i,n-1){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tbi[x].push_back(y);\n\t\tbi[y].push_back(x);\n\t}\n\tmx=mxd=-1;\n\tdfs1(1,0);\n\tdep[mxd]=0;\n\tmx=-1;\n\tdfs1(rt=mxd,0);\n\tint x=mxd;\n\twhile(x!=rt){\n\t\tseq.push_back(x);\n\t\tx=pre[x];\n\t}\n\tseq.push_back(x);\n/*\tff(seq,it){\n\t\tcerr<<*it<<' ';\n\t}cerr<<endl;*/\n\tif(seq.size()&1){\n\t\tint x=seq[seq.size()/2];\n\t\tdep[x]=0;\n\t\tdfs2(x,0);\n\t\tprintf(\"%lld\\n\",1ll*dp[x][1][1]*(mod+1)/2%mod);\n\t}\n\telse{\n\t\tint x=seq[seq.size()/2-1],y=seq[seq.size()/2];\n\t\tdep[x]=dep[y]=1;\n\t\tdfs2(x,y);dfs2(y,x);\n\t\tprintf(\"%lld\\n\",(0ll+dp[x][1][0]+dp[x][1][1]+dp[x][1][2])*(0ll+dp[y][1][0]+dp[y][1][1]+dp[y][1][2])%mod);\n\t} \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;++A)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD 998244353ll\n\nstruct llm{\n    ll value=0;\n    llm(const ll& val=0){this->value = (MOD + val % MOD) % MOD;}\n    llm(const int& val){this->value = (MOD + val % MOD) % MOD;}\n    llm(const llm& a) { llm(a.value); }\n    llm inv(){ll a = 1;ll b = this->value;for(ll m=MOD-2;m>0;m/=2){if(m&1){a=a*b%MOD;}b=b*b%MOD;}return llm(a);}\n    llm &operator+=(const llm &a) {this->value = (this->value + a.value) % MOD;return *this;}\n    llm &operator-=(const llm &a) {this->value = (this->value - a.value + MOD) % MOD;return *this;}\n    llm &operator*=(const llm &a) {this->value = (this->value * a.value) % MOD; return *this; }\n    explicit operator ll() const{return (ll)value;}\n    explicit operator int() const{return (int)value;}\n};\nllm operator+(const llm &a, const llm &b) { return llm(a.value + b.value); }\nllm operator-(const llm &a, const llm &b) { return llm(a.value - b.value); }\nllm operator*(const llm &a, const llm &b) { return llm(a.value * b.value); }\n#define pllm pair<llm,llm>\n\nll N, Len;\nvector<ll> abv[202020];\nvector<ll> abl[202020];\nllm dp[202020][4];\nll i, j, k;\nllm ans;\n\nvoid dfs(ll a,ll p,ll d)\n{\n    if(abv[a].size()==1){\n        dp[a][2] = 3;\n        if(d==0){\n            dp[a][0] = 2;\n            dp[a][1] = 1;\n        }else{\n            dp[a][0] = 3;\n        }\n        return;\n    }\n    ll i;\n    llm c = 1;\n    dp[a][2] = 1;\n    fornum(i,0,abv[a].size()){\n        ll b = abv[a][i];\n        if(b==p){\n            continue;\n        }\n        dfs(b, a, d - 1);\n        c *= dp[b][0];\n        dp[a][2] *= dp[b][2];\n    }\n    dp[a][0] = dp[a][2] * 2 + c;\n    fornum(i,0,abv[a].size()){\n        ll b = abv[a][i];\n        if(b==p){\n            continue;\n        }\n        dp[a][1] += c * dp[b][1] * dp[b][0].inv();\n    }\n    dp[a][2] *= 3;\n}\n\nll lencalc(ll a,ll p,ll d){\n    ll i = 0,  ret = 0;\n    pll c = {0, 0};\n    fornum(i,0,abv[a].size()){\n        ll b = abv[a][i];\n        if(b==p)\n            continue;\n        if(c.first<=abl[a][i]){\n            c.second = c.first;\n            c.first = abl[a][i];\n        }else if(c.second<=abl[a][i]){\n            c.second = abl[a][i];\n        }\n    }\n    fornum(i,0,abv[a].size()){\n        ll b = abv[a][i];\n        if(b==p){\n            abl[a][i] = d;\n            continue;\n        }\n        ll r = 0;\n        if(c.first==abl[a][i]){\n            r = lencalc(b, a, max(d, c.second) + 1);\n        }else{\n            r = lencalc(b, a, max(d, c.first) + 1);\n        }\n        abl[a][i] = r;\n        ret = max(ret, r);\n    }\n    return ret + 1;\n}\n\n\nint main(){\n    scanf(\"%lld\", &N);\n    fornum(i,1,N){\n        ll a, b;\n        scanf(\"%lld%lld\", &a, &b);\n        abv[a].push_back(b);\n        abl[a].push_back(0);\n        abv[b].push_back(a);\n        abl[b].push_back(0);\n    }\n    lencalc(1, 0, 0);\n    lencalc(1, 0, 0);\n    fornum(i,1,N+1){\n        if(abv[i].size()==1){\n            Len = max(Len, abl[i][0]);\n        }\n    }\n\n    if(Len%2){\n        pll a = {0, 0};\n        fornum(i,1,N+1){\n            fornum(j,0,abv[i].size()){\n                if((Len+1)/2==abl[i][j]){\n                    break;\n                }\n            }\n            if(j<abv[i].size()){\n                a.first = i;\n                a.second = abv[i][j];\n            }\n        }\n        dfs(a.first, a.second, Len / 2);\n        dfs(a.second, a.first, Len / 2);\n        ans = dp[a.first][1] * dp[a.second][1];\n    }else{\n        fornum(i,1,N+1){\n            if(abv[i].size()==1)\n                continue;\n            sort(abl[i].begin(), abl[i].end(),greater<ll>());\n            if(abl[i][0]==abl[i][1])\n                break;\n        }\n        ll a = i;\n        dfs(a, 0, Len / 2);\n\n        llm c = 1;\n        fornum(i,0,abv[a].size()){\n            ll b = abv[a][i];\n            c *= dp[b][0] * 2 - dp[b][2];\n        }\n        llm d = 0;\n        fornum(i,0,abv[a].size()){\n            ll b = abv[a][i];\n            ans += d * dp[b][1] * (dp[b][0] * 2 - dp[b][2]).inv();\n            d += c * dp[b][1] * (dp[b][0] * 2 - dp[b][2]).inv();\n        }\n    }\n    \n    printf(\"%lld\", (ll)ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for(int i=(a),_ed=(b);i<=_ed;++i)\n#define DREP(i,a,b) for(int i=(a),_ed=(b);i>=_ed;--i)\n#define mp(x,y) make_pair((x),(y))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int,int> pii;\ninline int read(){\n    register int x=0,f=1;register char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=0;ch=getchar();}\n    while(isdigit(ch)){x=x*10+(ch^'0');ch=getchar();}\n    return f?x:-x;\n}\n\nconst int N=2e5+5,mod=998244353;\nint n,c[2],mxd[N],f[N][3][3],g[3][3];\nvector<int> E[N];\ninline void inc(int& x,int y){x=x+y<mod?x+y:x+y-mod;}\n\nnamespace getcore{\n\tint d[N],fa[N],stk[N],tp,tmp;\n\tvoid dfs(int u,int pa,int dis,int& rt){\n\t\td[u]=dis,fa[u]=pa;if(d[u]>d[rt])rt=u;\n\t\tfor(int v:E[u]){\n\t\t\tif(v==pa)continue;\n\t\t\tdfs(v,u,dis+1,rt);\n\t\t}\n\t}\n\tvoid Main(){\n\t\tdfs(1,0,0,tmp);\n\t\tdfs(tmp,0,0,tmp);\n\t\twhile(tmp)stk[++tp]=tmp,tmp=fa[tmp];\n\t\tc[0]=stk[(tp+1)>>1];\n\t\tif(~tp&1)c[1]=stk[((tp+1)>>1)+1];//想清楚啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊\n\t}\n}\n\nint dfs(int u,int pa,int dep){\n\tmxd[u]=dep;\n\tfor(int v:E[u]){\n\t\tif(v==pa||v==c[0]||v==c[1])continue;\n\t\tmxd[u]=max(mxd[u],dfs(v,u,dep+1));\n\t}\n\tif(mxd[u]==dep)f[u][1][1]=1;\n\telse f[u][0][0]=1;\n\tfor(int v:E[u]){\n\t\tif(v==pa||v==c[0]||v==c[1])continue;\n\t\tREP(i,0,2)REP(j,0,2)g[i][j]=0;\n\t\tREP(a,0,2)REP(b,0,2)REP(p,0,2)REP(q,0,2){\n\t\t\tint flg=mxd[u]==mxd[v];\n\t\t\tint s=a,t=b,val=1ll*f[u][a][b]*f[v][p][q]%mod;\n\t\t\tinc(g[s][t],val);\n\t\t\ts=flg?min(2,a+p):a,t=b;\n\t\t\tinc(g[s][t],val);\n\t\t\ts=a,t=flg?min(2,b+q):b;\n\t\t\tinc(g[s][t],val);\n\t\t}\n\t\tREP(i,0,2)REP(j,0,2)f[u][i][j]=g[i][j];\n\t}\n\treturn mxd[u];\n}\n\nint main(){\n\tfreopen(\"in.in\",\"r\",stdin);\n\tfreopen(\"out.out\",\"w\",stdout);\n\tn=read();\n\tREP(i,1,n-1){\n\t\tint u=read(),v=read();\n\t\tE[u].pb(v),E[v].pb(u);\n\t}\n\tgetcore::Main();\n\tint sum=0;\n\tdfs(c[0],0,0);\n\tif(!c[1])\n\t\tsum=f[c[0]][1][1];\n\telse{\n\t\tdfs(c[1],0,0);\n\t\tREP(i,0,2)REP(j,0,2)\n\t\t\tinc(sum,1ll*f[c[0]][1][i]*f[c[1]][j][1]%mod);\n\t\tREP(i,0,2)REP(j,0,2)\n\t\t\tinc(sum,1ll*f[c[0]][i][1]*f[c[1]][1][j]%mod);\n\t}\n\tsum=1ll*sum*(mod+1)/2%mod;\n\tprintf(\"%d\\n\",sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst int M=998244353;\nconst int inv2=(M+1)/2;\nconst int inv3=(M+1)/3;\nconst int maxn=3e5+3;\nvector <int> h[maxn];\nint dis[maxn],n,pre[maxn],p,q,d[maxn],m;\nll dp[maxn][4];\nvoid dfs(int u,int fa){\n    pre[u]=fa; dis[u]=dis[fa]+1;\n    for (auto v:h[u]){\n        if (v==fa) continue;\n        dfs(v,u);\n    }\n}\nvoid dfs2(int u,int fa){\n    d[u]=d[fa]+1;\n    if (d[u]==m){\n        dp[u][0]=2; // none\n        dp[u][1]=1; // exactly one\n        dp[u][2]=3; // all\n        dp[u][3]=1; // at least one\n        return;\n    }\n    ll r1=1,r2=0,r3=1,r4=0;\n    for (auto v:h[u]){\n        if (v==fa) continue;\n        dfs2(v,u);\n        ll nr1=r1*dp[v][0]%M;\n        ll nr2=(r1*dp[v][1]+r2*dp[v][0])%M;\n        ll nr3=r3*dp[v][2]%M;\n        ll nr4=((r3*dp[v][3]+r4*dp[v][2]-r4*dp[v][3])%M+M)%M;\n        r1=nr1; r2=nr2; r3=nr3; r4=nr4;\n    }\n    dp[u][0]=(r1*3+r4*2)%M;\n    dp[u][1]=r2;\n    dp[u][2]=r3*3%M;\n    dp[u][3]=r4;\n}\nint main(){\n    scanf(\"%d\",&n); dis[0]=-1;\n    for (int i=1;i<n;i++){\n        int u,v; scanf(\"%d%d\",&u,&v);\n        h[u].pb(v); h[v].pb(u);\n    }\n    //puts(\"B\");\n    dfs(1,0);\n    int s=1;\n    for (int i=2;i<=n;i++) if (dis[i]>dis[s]) s=i;\n    dfs(s,0);\n    int t=s;\n    for (int i=1;i<=n;i++) if (dis[i]>dis[t]) t=i;\n    m=dis[t]/2; p=t;\n    for (int i=0;i<m;i++) p=pre[p];\n    if (dis[t]&1){\n        q=pre[p];\n        d[q]=-1; dfs2(p,q);\n        d[p]=-1; dfs2(q,p);\n        printf(\"%lld\\n\",dp[p][1]*dp[q][1]%M);\n    } else {\n        ll ans0=1,ans1=0,ans2=0;\n        for (auto u:h[p]){\n            d[u]=0; dfs2(u,p);\n            ll nans0,nans1,nans2,has,none;\n            has=dp[u][1]; none=(dp[u][2]+2*(M-dp[u][3]))%M;\n            cout<<has<<' '<<none<<endl;\n            //cout<<dp[u][2]<<' '<<dp[u][3]<<endl;\n            nans0=ans0*none%M;\n            nans1=(ans0*has+ans1*none)%M;\n            nans2=(ans1*has+ans2*none)%M;\n            ans0=nans0; ans1=nans1; ans2=nans2;\n        }\n        printf(\"%lld\\n\",ans2);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;++A)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD 998244353ll\n\nll N,gr;\nvector<ll> abv[202020];\nll mk[202020],p3[202020];\nll i, j, k;\nll ans;\n\npll grcalc(ll a,ll p){\n    ll i = 0;\n    pll ret = {0, 0};\n    fornum(i,0,abv[a].size()){\n        ll b = abv[a][i];\n        if(b==p)\n            continue;\n        pll p = grcalc(b, a);\n        if(ret.first<p.first){\n            ret.first = p.first;\n        }\n        if(ret.first<p.second+ret.second){\n            ret.first = p.second+ret.second;\n        }\n        if(ret.second<p.second){\n            ret.second = p.second;\n        }\n    }\n    ++ret.second;\n    return ret;\n}\n\nvoid dfs2(ll a,ll p,ll d,ll dd,ll& ra,ll& rb){\n    ra = 1;\n    rb = 1;\n    ll i, j;\n    if(abv[a].size()==1){\n        if(d==dd||d==gr-dd){\n            rb = 0;\n        }\n        //printf(\"%lld:%lld,%lld\\n\", a, ra, rb);\n        return;\n    }\n    \n    fornum(i,0,abv[a].size()){\n        ll b = abv[a][i];\n        if(b==p)\n            continue;\n        ll rra,rrb;\n        dfs2(b, a, d + 1, dd, rra, rrb);\n        ra *= rra * 3;\n        ra %= MOD;\n        rb *= rrb + rra * 2;\n        rb %= MOD;\n    }\n    //printf(\"%lld:%lld,%lld\\n\", a, ra, rb);\n    return;\n}\nll dfs1(ll a,ll p,ll d){\n    mk[d] = a;\n    ll i, j;\n    ll ret = 0;\n    if(d==gr){\n        if(mk[0]>mk[d])\n            return 0;\n        i = 0;\n        ret = 1;\n        fornum(i,1,gr){\n            fornum(j,0,abv[mk[i]].size()){\n                ll b = abv[mk[i]][j];\n                if(mk[i+1]==b)\n                    continue;\n                if(mk[i-1]==b)\n                    continue;\n                //printf(\"%lld,%lld,%lld:\\n\", mk[0], mk[d], mk[i]);\n                ll ra, rb;\n                dfs2(b, mk[i], 1, i, ra, rb);\n                if(gr==i*2){\n                    ret *= ra + rb * 2;\n                }else{\n                    ret *= ra * 2 + rb;\n                }\n                ret %= MOD;\n            }\n        }\n        return ret;\n    }\n    fornum(i,0,abv[a].size()){\n        ll b = abv[a][i];\n        if(b==p)\n            continue;\n        ret += dfs1(b, a, d + 1);\n        ret %= MOD;\n    }\n    return ret;\n}\nint main(){\n    scanf(\"%lld\", &N);\n    fornum(i,1,N){\n        ll a, b;\n        scanf(\"%lld%lld\", &a, &b);\n        abv[a].push_back(b);\n        abv[b].push_back(a);\n    }\n    gr = grcalc(1, 0).first;\n    ans = 0;\n    p3[0] = 1;\n    fornum(i,0,N){\n        p3[i + 1] = p3[i] * 3 % MOD;\n    }\n    //printf(\"%lld \", gr);\n    fornum(i,0,N){\n        if(abv[i+1].size()==1){\n            //printf(\"%lld %lld\\n\", i + 1, ans);\n            ans += dfs1(i + 1, 0, 0);\n            ans %= MOD;\n        }\n    }\n    printf(\"%lld\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i,a,b) for (int i=int(a);i<=int(b);i++)\n#define R(i,a,b) for (int i=int(a);i<int(b);i++)\n#define D(i,a,b) for (int i=int(a);i>=int(b);i--)\n#define go(i,x) for (int i=head[x];i;i=Next[i])\n#define pb push_back\n#define si size()\n#define fi first\n#define se second\n#define pa pair < ll,ll >\n#define ll long long\n#define mp make_pair\n#define be begin()\n#define en end()\n#define put putchar('\\n')\n#define gc getchar\n#define pc putchar\n#define N 6000055\n#define mo 998244353\n#define inf 1000000007\n#define ret return puts(\"-1\"),0\nusing namespace std;\ninline ll read(){\n\tll su=0,f=1;char c=gc();\n\tfor (;c<'0'||c>'9';c=gc()) if (c=='-') f=-1;\n\tfor (;c>='0'&&c<='9';c=gc()) su=su*10+c-'0';\n\treturn su*f;\n}\ninline void wr(ll x){\n\tif (x<0) pc('-'),wr(-x);\n\telse{if (x>=10) wr(x/10);pc(x%10+'0');}\n}\ninline void wri(ll x){wr(x);pc(' ');}\ninline void wrn(ll x){wr(x);put;}\ninline void wrn(ll x,ll y){wri(x);wrn(y);}\ninline void wrn(ll x,ll y,ll z){wri(x);wrn(y,z);}\nint ans,n,m,f[N][2],fa[N],dis[N],lo,rt,mx;\ninline void ad(int &x,int k){x+=k;x-=(x>=mo)?mo:0;}\nint Next[N*2],head[N],to[N*2],nedge,g[N][4];\n#define V to[i]\nvoid add(int a,int b){Next[++nedge]=head[a];head[a]=nedge;to[nedge]=b;}\nvoid add_ne(int a,int b){add(a,b);add(b,a);}\nvoid dfs(int x){\n\tmx=(dis[x]>dis[mx])?x:mx;\n\tgo(i,x){\n\t\tif (V==fa[x]) continue;\n\t\tfa[V]=x;dis[V]=dis[x]+1;dfs(V);\n\t}\n}\nint ksm(ll x,int k){\n\tint su=1;\n\tfor (;k;k>>=1,x=x*x%mo) if (k&1) su=su*x%mo;\n\treturn su;\n}\nvoid solve(int x){\n\tint pd=0;\n\tf[x][0]=1;\n\tg[x][0]=1;\n\tgo(i,x){\n\t\tif (V==fa[x]) continue;\n\t\tsolve(V);pd++;\n\t\tg[x][3]=1ll*g[x][3]*g[V][0]%mo;\n\t\tad(g[x][3],1ll*g[x][1]*g[V][2]%mo);\n\t\tad(g[x][3],1ll*g[x][2]*g[V][1]%mo);\n\t\tg[x][1]=1ll*g[x][1]*g[V][0]%mo;\n\t\tg[x][2]=1ll*g[x][2]*g[V][0]%mo;\n\t\tad(g[x][1],1ll*g[x][0]*g[V][1]%mo);\n\t\tad(g[x][2],1ll*g[x][0]*g[V][2]%mo);\n\t\tg[x][0]=1ll*g[x][0]*g[V][0]%mo;\n\t\t\n\t\tf[x][1]=1ll*f[x][1]*f[V][0]%mo;\n\t\tad(f[x][1],1ll*f[x][0]*f[V][1]%mo);\n\t\tf[x][0]=1ll*f[x][0]*f[V][0]%mo;\n\t}\n\tif (pd){\n\t\tf[x][0]=1ll*f[x][0]*3%mo;\n\t\tad(f[x][0],f[x][1]*2%mo);\n\t\tg[x][0]=1ll*g[x][0]*3%mo;\n\t\tad(g[x][0],((g[x][1]+g[x][2])%mo*2%mo+g[x][3])%mo);\n\t\tad(g[x][1],g[x][3]);ad(g[x][2],g[x][3]);\n\t}\n\telse{\n\t\tif (dis[x]==lo/2) f[x][1]=1,f[x][0]=2,g[x][1]=g[x][0]=g[x][2]=1;\n\t\telse f[x][0]=3,g[x][0]=3;\n\t}\n}\nsigned main(){\n\tn=read();\n\tR(i,1,n) add_ne(read(),read());\n\tdfs(1);\n\trt=mx;mx=0;dis[rt]=0;fa[rt]=0;\n\tdfs(rt);\n\tlo=dis[mx];\n\tF(i,1,lo/2) mx=fa[mx];\n\tif (lo&1){\n\t\tint x=mx,y=fa[mx];\n\t\tfa[y]=x;dis[x]=dis[y]=0;dfs(x);dfs(y);\n\t\t//solve(x);solve(y);\n\t\twrn(ksm(3,n-lo-1));\n\t}\n\telse{\n\t\tint x=mx,nu=0;\n\t\tfa[x]=0;dis[x]=0;dfs(x);\n\t\tF(i,1,n) if (dis[i]==lo/2) nu++;\n\t\t//ans=(1ll*nu*(nu-1)/2)%mo*ksm(3,n-lo-1)%mo;\n\t\tsolve(x);\n\t\tf[x][0]=1;f[x][1]=0;\n\t\tgo(i,x){\n\t\t\tans=1ll*ans*g[x][0]%mo;\n\t\t\tad(ans,1ll*f[x][1]*f[V][1]%mo);\n\t\t\tf[x][1]=1ll*f[x][1]*g[V][0]%mo;\n\t\t\tad(f[x][1],1ll*f[x][0]*f[V][1]%mo);\n\t\t\tf[x][0]=1ll*f[x][0]*g[V][0]%mo;\t\t\t\n\t\t}\n\t\twrn(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=200000+5,mod=998244353;\nint ksm(int b,int n){\n\tint res=1;\n\twhile(n){\n\t\tif(n&1) res=res*b%mod;\n\t\tb=b*b%mod; n>>=1;\n\t}\n\treturn res;\n}\nint add(int x,int y){\n\treturn (x+y)%mod;\n}\nint mul(int x,int y){\n\treturn x*y%mod;\n}\nvector<int> e[N];\nint n,dis[N],pre[N];\nint dp[N][3][3];\nint bfs(int st){\n\tqueue<int> q;\n\tint res=0;\n\tfor(int i=1;i<=n;++i)\n\t\tdis[i]=0;\n\tdis[st]=1; pre[st]=0; q.push(st);\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\tif(dis[u]>dis[res]) res=u;\n\t\t//cout<<st<<\" \"<<u<<\" \"<<dis[u]<<\" \"<<res<<endl;\n\t\tfor(int i=0;i<e[u].size();++i)\n\t\t\tif(dis[e[u][i]]==0) q.push(e[u][i]),dis[e[u][i]]=dis[u]+1,pre[e[u][i]]=u;\n\t}\n\treturn res;\n}\nint L,tmp[3][3];\nvoid dfs(int u,int fath,int dep){\n\t//cout<<u<<\" \"<<fath<<\" \"<<dep<<endl;\n\tif(dep==L/2) cout<<u<<endl,dp[u][1][1]=1;\n\telse dp[u][0][0]=1;\n\tfor(int i=0;i<e[u].size();++i){\n\t\tint v=e[u][i];\n\t\tif(v==fath) continue;\n\t\tdfs(v,u,dep+1);\n\t\tfor(int x=0;x<=2;++x)\n\t\t\tfor(int y=0;y<=2;++y)\n\t\t\t\ttmp[x][y]=0;\n\t\tfor(int x=0;x<=2;++x)\n\t\t\tfor(int y=0;y<=2;++y)\n\t\t\t\tfor(int a=0;a<=2;++a)\n\t\t\t\t\tfor(int b=0;b<=2;++b)\n\t\t\t\t\t\tfor(int type=0;type<=2;++type){\n\t\t\t\t\t\t\tint p=min(x+(type==1)*a,2ll),q=min(y+(type==2)*b,2ll);\n\t\t\t\t\t\t\ttmp[p][q]=add(tmp[p][q],mul(dp[u][x][y],dp[v][a][b]));\n\t\t\t\t\t\t}\n\t\tfor(int x=0;x<=2;++x)\n\t\t\tfor(int y=0;y<=2;++y)\n\t\t\t\tdp[u][x][y]=tmp[x][y];\n\t}\n\t//for(int x=0;x<=2;++x)\n\t//\tfor(int y=0;y<=2;++y)\n\t\t//\tcout<<u<<\" \"<<x<<\" \"<<y<<\" \"<<dp[u][x][y]<<endl;\n}\nint c[N],tot;\nvoid solve(){\n\tint from=bfs(1),to=bfs(from);\n\ttot=0;while(to) c[++tot]=to,to=pre[to];\n\tL=tot;\n\tif(tot&1){\n\t\tfrom=c[(tot+1)/2];\n\t\tdfs(from,0,0);\n\t\tcout<<mul(dp[from][1][1],ksm(2,mod-2));\n\t\treturn;\n\t}\n\telse{\n\t\tfrom=c[tot/2],to=c[(tot+2)/2];\n\t//\tcout<<from<<\" \"<<to<<\" \"<<tot<<endl;\n\t\tdfs(from,to,1);\n\t\tint x=0,y=0;\n\t\tfor(int i=0;i<=2;++i)\n\t\t\tx=add(x,dp[from][i][1]);\n\t\tdfs(to,from,1);\n\t\tfor(int i=0;i<=2;++i)\n\t\t\ty=add(y,dp[to][1][i]);\n\t\tcout<<mul(x,y);\n\t\treturn;\n\t}\n}\nsigned main(){\n\tint ans=0,u,v;\n\tcin>>n;\n\tfor(int i=1;i<n;++i){\n\t\tcin>>u>>v;\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<n;i++)\n#define pb push_back\ntypedef long long ll;\ntypedef long double la;\nusing namespace std;\n \nint main(){\n    string s;\n    int j=0,k;\n    cin >> s;\n    fr(i,s.size()){\n        if(s[i] == 'h'){\n            if(i != 0){\n                if(s[--i] != 'i'){\n                    j = 0;\n                }\n            }\n            k = i + 2;\n            if(s[++i] == 'i'){\n                if(s.size() != 3){\n                if(s[k] != 'i'){\n                    j = 1;\n                }\n                }  \n            }\n        }\n    }\n    if(j==0){\n        cout << \"No\" << endl;\n    }else{\n        cout << \"Yes\" << endl;\n    }\n    //cout << j << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nconst char lf = '\\n';\n\nnamespace ae86\n{\n\tconst int bufl = 1 << 15;\n\n\tchar buf[bufl],*s=buf,*t=buf;\n\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\n\tinline int ty()\n\t{\n\t\tint a=0;int b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 200007 , mo = 998244353;\n\ntemplate<typename T1,typename T2> inline T1 ad(T1 &a,T2 b){return a=a+b>=mo?a+b-mo:a+b;}\ntemplate<typename T1,typename T2> inline T1 dl(T1 &a,T2 b){return a=a>=b?a-b:a-b+mo;}\ntemplate<typename T1,typename T2> inline T1 add(T1 a,T2 b){return a+b>=mo?a+b-mo:a+b;}\ntemplate<typename T1,typename T2> inline T1 del(T1 a,T2 b){return a>=b?a-b:a-b+mo;}\n\nlint powa(lint a,lint t)\n{\n\tlint b=1;a=(a+mo)%mo;\n\twhile(t){if(t&1)b=b*a%mo;a=a*a%mo,t>>=1;}\n\treturn b;\n}\n\ninline lint inva(lint a)\n{\n\treturn powa(a,mo-2);\n}\n\nvector<int> e[_];\n\nint n,fa[_]={0},rt=0,mxdep=0;\n\nvoid dfs(int x,int ff,int dep)\n{\n\tfa[x]=ff;\n\tif(dep>mxdep)mxdep=dep,rt=x;\n\tfor(auto b:e[x])if(b!=ff)dfs(b,x,dep+1);\n}\n\nint ps[_]={0},lps=0;\nlint f[_][3][3]={0};\n\nvoid dfs2(int x,int ff,int dep)\n{\n\tfa[x]=ff;\n\tmemset(f[x],0,sizeof(f[x]));\n\tif(dep==lps/2)f[x][1][1]=1;\n\telse f[x][0][0]=1;\n\n\tfor(auto b:e[x])\n\t{\n\t\tif(b==ff)continue;\n\t\tdfs2(b,x,dep+1);\n\t\tlint sf[3][3];memset(sf,0,sizeof(sf));\n\t\tfor(int i=0;i<3;i++)\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\tfor(int p=0;p<3;p++)\n\t\t\t\t\tfor(int q=0;q<3;q++)\n\t\t\t\t\t\tfor(int r=-1;r<=1;r++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint pp=r==1?p:0,qq=r==-1?q:0;\n\t\t\t\t\t\t\tpp=min(2,pp+i),qq=min(2,qq+j);\n\t\t\t\t\t\t\tad(sf[pp][qq],f[x][i][j]*f[b][p][q]%mo);\n\t\t\t\t\t\t}\n\t\tmemcpy(f[x],sf,sizeof(sf));\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(0),cout.tie(nullptr);\n\n\tn=ty();\n\tfor(int i=1,a,b;i<n;i++)a=ty(),b=ty(),e[a].emplace_back(b),e[b].emplace_back(a);\n\n\tdfs(1,0,1),mxdep=0,dfs(rt,0,1);\n\tfor(int i=rt;i;i=fa[i])ps[++lps]=i;\n\n\tif(lps&1)\n\t{\n\t\tint mid=ps[lps/2+1];\n\t\tdfs2(mid,0,0);\n\t\tcout<<f[mid][1][1]*inva(2)%mo<<lf;\n\t\treturn 0;\n\t}\n\t\n\tint ll=ps[lps/2],rr=ps[lps/2+1];\n\tdfs2(ll,rr,1),dfs2(rr,ll,1);\n\tcout<<add(add(f[ll][1][0],f[ll][1][1]),f[ll][1][2])\n\t\t*add(add(f[rr][0][1],f[rr][1][1]),f[rr][2][1])%mo<<lf;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[202020];\nconst ll mo=998244353;\n\npair<int,int> farthest(int cur,int pre,int d,vector<int>& D) {\n\tD[cur]=d;\n\tpair<int,int> r={d,cur};\n\tFORR(e,E[cur]) if(e!=pre) r=max(r, farthest(e,cur,d+1,D));\n\treturn r;\n}\n\npair<int,vector<int>> diameter() { // diameter,center\n\tvector<int> D[2];\n\tD[0].resize(N);\n\tD[1].resize(N);\n\tauto v1=farthest(0,0,0,D[0]);\n\tauto v2=farthest(v1.second,v1.second,0,D[0]);\n\tfarthest(v2.second,v2.second,0,D[1]);\n\tpair<int,vector<int>> R;\n\tR.first = v2.first;\n\t//重心を取る場合\n\tfor(int i=N-1;i>=0;i--) if(D[0][i]+D[1][i]==R.first && abs(D[0][i]-D[1][i])<=1) R.second.push_back(i);\n\n\treturn R;\n}\n\nvector<ll> dfs1(int cur,int pre,int lef,int no=0) {\n\tif(E[cur].size()==1) {\n\t\tif(lef==0) return {2,1,0};\n\t\telse return {3,0,0};\n\t}\n\telse {\n\t\tvector<ll> X={1,0,0};\n\t\tFORR(e,E[cur]) if(e!=pre) {\n\t\t\tvector<ll> Y=dfs1(e,cur,lef-1);\n\t\t\tvector<ll> Z={0,0,0};\n\t\t\tint x,y;\n\t\t\tFOR(x,3) FOR(y,3) Z[min(x+y,2)]+=X[x]*Y[y]%mo;\n\t\t\tX[0]=Z[0]%mo;\n\t\t\tX[1]=Z[1]%mo;\n\t\t\tX[2]=Z[2]%mo;\n\t\t}\n\t\tvector<ll> Y={0,0,0};\n\t\tif(no) {\n\t\t\tY=X;\n\t\t}\n\t\telse {\n\t\t\tY[0]=(X[0]*3+X[1]*2+X[2]*2)%mo;\n\t\t\tY[1]=X[1];\n\t\t\tY[2]=X[2];\n\t\t}\n\t\treturn Y;\n\t}\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tauto R=diameter();\n\tif(R.second.size()==1) {\n\t\tassert(R.first>2);\n\t\tvector<ll> X={1,0,0,0};\n\t\tFORR(e,E[R.second[0]]) {\n\t\t\tauto Y=dfs1(e,R.second[0],R.first/2-1);\n\t\t\tvector<ll> Z={0,0,0,0};\n\t\t\tFOR(x,4) FOR(y,3) Z[min(x+((y==2)?3:y),3)]+=X[x]*Y[y]%mo;\n\t\t\tFOR(x,4) X[x]=Z[x]%mo;\n\t\t}\n\t\tcout<<X[2]<<endl;\n\t}\n\telse {\n\t\tvector<ll> X=dfs1(R.second[0],R.second[1],R.first/2,1);\n\t\tvector<ll> Y=dfs1(R.second[1],R.second[0],R.first/2,1);\n\t\t\n\t\tcout<<X[1]*Y[1]%mo<<endl;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst int M=998244353;\nconst int inv2=(M+1)/2;\nconst int inv3=(M+1)/3;\nconst int maxn=3e5+3;\nvector <int> h[maxn];\nint dis[maxn],n,pre[maxn],p,q,d[maxn],m;\nll dp[maxn][4];\nvoid dfs(int u,int fa){\n    pre[u]=fa; dis[u]=dis[fa]+1;\n    for (auto v:h[u]){\n        if (v==fa) continue;\n        dfs(v,u);\n    }\n}\nvoid dfs2(int u,int fa){\n    d[u]=d[fa]+1;\n    if (d[u]==m){\n        dp[u][0]=2; // none\n        dp[u][1]=1; // exactly one\n        dp[u][2]=3; // all\n        dp[u][3]=1; // at least one\n        return;\n    }\n    ll r1=1,r2=0,r3=1,r4=0;\n    for (auto v:h[u]){\n        if (v==fa) continue;\n        dfs2(v,u);\n        ll nr1=r1*dp[v][0]%M;\n        ll nr2=(r1*dp[v][1]+r2*dp[v][0])%M;\n        ll nr3=r3*dp[v][2]%M;\n        ll nr4=((r3*dp[v][3]+r4*dp[v][2]-r4*dp[v][3])%M+M)%M;\n        r1=nr1; r2=nr2; r3=nr3; r4=nr4;\n    }\n    dp[u][0]=(r1*3+r4*2)%M;\n    dp[u][1]=r2;\n    dp[u][2]=r3*3%M;\n    dp[u][3]=r4;\n}\nint main(){\n    scanf(\"%d\",&n); dis[0]=-1;\n    for (int i=1;i<n;i++){\n        int u,v; scanf(\"%d%d\",&u,&v);\n        h[u].pb(v); h[v].pb(u);\n    }\n    //puts(\"B\");\n    dfs(1,0);\n    int s=1;\n    for (int i=2;i<=n;i++) if (dis[i]>dis[s]) s=i;\n    dfs(s,0);\n    int t=s;\n    for (int i=1;i<=n;i++) if (dis[i]>dis[t]) t=i;\n    m=dis[t]/2; p=t;\n    for (int i=0;i<m;i++) p=pre[p];\n    if (dis[t]&1){\n        q=pre[p];\n        d[q]=-1; dfs2(p,q);\n        d[p]=-1; dfs2(q,p);\n        printf(\"%lld\\n\",dp[p][1]*dp[q][1]%M);\n    } else {\n        ll ans0=1,ans1=0,ans2=0;\n        for (auto u:h[p]){\n            d[u]=0; dfs2(u,p);\n            ll nans0,nans1,nans2,has,none;\n            has=dp[u][1]; none=(dp[u][2]+2*(M-dp[u][3]))%M;\n            //cout<<has<<' '<<none<<endl;\n            //cout<<dp[u][2]<<' '<<dp[u][3]<<endl;\n            nans0=ans0*none%M;\n            nans1=(ans0*has+ans1*none)%M;\n            nans2=(ans1*has+ans2*none)%M;\n            ans0=nans0; ans1=nans1; ans2=nans2;\n        }\n        printf(\"%lld\\n\",ans2);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 2e5 + 5, mod = 998244353;\n\ninline int gi()\n{\n\tchar c = getchar();\n\twhile (c < '0' || c > '9') c = getchar();\n\tint sum = 0;\n\twhile ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();\n\treturn sum;\n}\n\ninline void inc(int &a, int b) {a += b; if (a >= mod) a -= mod;}\n\nint n, rt, len, fa[maxn], ch[maxn];\n\nstruct edge\n{\n\tint to, next;\n} e[maxn * 2];\nint h[maxn], tot;\nint md[maxn], f[maxn][3][3], g[3][3];\n\ninline void add(int u, int v)\n{\n\te[++tot] = (edge) {v, h[u]}; h[u] = tot;\n\te[++tot] = (edge) {u, h[v]}; h[v] = tot;\n}\n\nvoid dfs1(int u, int d)\n{\n\tif (d > len) rt = u, len = d;\n\tmd[u] = d;\n\tfor (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n\t\tif (v != fa[u]) fa[v] = u, dfs1(v, d + 1), md[u] = max(md[u], md[v]);\n}\n\nvoid dfs2(int u, int d)\n{\n\t(md[u] == d ? f[u][1][1] : f[u][0][0]) = 1;\n\tfor (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n\t\tif (v != fa[u]) {\n\t\t\tfa[v] = u; dfs2(v, d + 1);\n\t\t\tmemset(g, 0, sizeof(g));\n\t\t\tfor (int a = 0; a < 2; ++a)\n\t\t\t\tfor (int b = 0; b < 2; ++b)\n\t\t\t\t\tfor (int c = 0; c < 2; ++c)\n\t\t\t\t\t\tfor (int d = 0; d <= 2; ++d)\n\t\t\t\t\t\t\tfor (int t = -1; t <= 1; ++t)\n\t\t\t\t\t\t\t\tinc(g[min(2, a + (md[v] == md[u] && t == 1) * c)][min(2, b + (md[v] == md[u] && t == -1) * d)], (ll)f[u][a][b] * f[v][c][d] % mod);\n\t\t\tmemcpy(f[u], g, sizeof(f[u]));\n\t\t}\n}\n\nint main()\n{\n\tn = gi();\n\tfor (int i = 1; i < n; ++i) add(gi(), gi());\n\n\tdfs1(1, 0);\n\tfa[rt] = 0; len = 0; dfs1(rt, 0);\n\tfor (int i = 0, x = rt; x; x = fa[x]) ch[i++] = x;\n\n\tif (~len & 1) {\n\t\tint x = ch[len >> 1];\n\t\tfa[x] = 0, dfs1(x, 0);\n\t\tdfs2(x, 0);\n\t\tprintf(\"%lld\\n\", (ll)f[x][1][1] * (mod + 1) / 2 % mod);\n\t}\n\telse {\n\t\tint x = ch[len >> 1], y = ch[len + 1 >> 1];\n\t\tfa[x] = y; fa[y] = x;\n\t\tdfs1(x, 0); dfs2(x, 0);\n\t\tdfs1(y, 0); dfs2(y, 0);\n\t\tprintf(\"%lld\\n\", ((ll)f[x][1][0] + f[x][1][1] + f[x][1][2]) * ((ll)f[y][1][0] + f[y][1][1] + f[y][1][2]) % mod);\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=200005;\nconst int mod=998244353;\nint n,diam,s,t,ans;\nvector<int>edge[maxn];\nint dep[maxn],par[maxn],dp[maxn][3][3],ndp[3][3];\nbool leaf[maxn];\nvoid Add(int &a,int b){\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\n\nvoid predfs(int x,int p,int d){\n\tpar[x]=p;\n\tdep[x]=d;\n\tfor(int i=0;i<int(edge[x].size());i++)\n\t\tif(edge[x][i]!=p)predfs(edge[x][i],x,d+1);\n}\nvoid dfs(int x,int p,int d){\n\tif(d==diam/2)leaf[x]=true;\n\tdp[x][0][0]=1;\n\tfor(int i=0;i<int(edge[x].size());i++){\n\t\tint y=edge[x][i];\n\t\tif(y==p)continue;\n\t\tdfs(y,x,d+1);\n\t\tfor(int a=0;a<3;a++)for(int b=0;b<3;b++)ndp[a][b]=0;\n\t\tfor(int a=0;a<3;a++)for(int b=0;b<3;b++)if(dp[x][a][b])\n\t\t\tfor(int c=0;c<3;c++)for(int d=0;d<3;d++)if(dp[y][c][d]){\n\t\t\t\tint cur=1LL*dp[x][a][b]*dp[y][c][d]%mod;\n\t\t\t\tif(leaf[y]){\n\t\t\t\t\tAdd(ndp[min(2,a+1)][b],cur);\n\t\t\t\t\tAdd(ndp[a][b],cur);\n\t\t\t\t\tAdd(ndp[a][min(2,b+1)],cur);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tAdd(ndp[min(2,a+c)][b],cur);\n\t\t\t\t\tAdd(ndp[a][b],cur);\n\t\t\t\t\tAdd(ndp[a][min(2,b+d)],cur);\n\t\t\t\t}\n\t\t\t}\n\t\tfor(int a=0;a<3;a++)for(int b=0;b<3;b++)dp[x][a][b]=ndp[a][b];\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n-1;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tedge[u].push_back(v);\n\t\tedge[v].push_back(u);\n\t}\n\tpredfs(1,0,0);\n\tfor(int i=1;i<=n;i++)if(!s||dep[i]>dep[s])s=i;\n\tpredfs(s,0,0);\n\tfor(int i=1;i<=n;i++)if(!t||dep[i]>dep[t])t=i;\n\tdiam=dep[t];\n\tint u=t;\n\tfor(int i=1;i<=diam/2;i++)u=par[u];\n\tif(diam%2==0){\n\t\tdfs(u,0,0);\n\t\tans=dp[u][1][1];\n\t}\n\telse{\n\t\tint v=par[u];\n\t\tdfs(u,v,0);\n\t\tdfs(v,u,0);\n\t\tans=1LL*dp[u][0][1]*dp[v][1][0]%mod;\n\t\tAdd(ans,1LL*dp[u][1][0]*dp[v][0][1]%mod);\n\t}\n\tprintf(\"%d\\n\",1LL*ans*(mod+1)/2%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=200000,mod=998244353,inv2=499122177;\n\nint add(int a,int b,int p=mod){return a+b>=p?a+b-p:a+b;}\nint sub(int a,int b,int p=mod){return a-b<0?a-b+p:a-b;}\nint mul(int a,int b,int p=mod){return (LL)a*b%p;}\nvoid sadd(int &a,int b,int p=mod){a=add(a,b,p);}\nvoid ssub(int &a,int b,int p=mod){a=sub(a,b,p);}\nvoid smul(int &a,int b,int p=mod){a=mul(a,b,p);}\n\nint n;\nstruct side{\n  int y,next;\n}e[N*2+9];\nint lin[N+9],cs;\n\nvoid Ins(int x,int y){e[++cs].y=y;e[cs].next=lin[x];lin[x]=cs;}\nvoid Ins2(int x,int y){Ins(x,y);Ins(y,x);}\n\nvoid into(){\n  scanf(\"%d\",&n);\n  for (int i=1;i<n;++i){\n\tint x,y;\n\tscanf(\"%d%d\",&x,&y);\n\tIns2(x,y);\n  }\n}\n\nint dis[N+9],pre[N+9];\nqueue<int>q;\n\nint Bfs_dis(int st){\n  int res=st;\n  for (int i=1;i<=n;++i) dis[i]=0;\n  dis[st]=1;pre[st]=0;q.push(st);\n  for (;!q.empty();){\n\tint t=q.front();q.pop();\n\tif (dis[t]>dis[res]) res=t;\n\tfor (int i=lin[t];i;i=e[i].next)\n\t  if (!dis[e[i].y]){\n\t\tdis[e[i].y]=dis[t]+1;\n\t\tpre[e[i].y]=t;\n\t\tq.push(e[i].y);\n\t  }\n  }\n  return res;\n}\n\nint dia,d[N+9],cd;\n\nvoid Get_dia(){\n  int k=Bfs_dis(Bfs_dis(1));\n  dia=dis[k]-1;\n  for (;k;k=pre[k]) d[++cd]=k;\n}\n\nint dp[N+9][3][3],tmp[3][3];\n\nvoid Dfs_dp(int k,int fa,int dep){\n  dep==dia>>1?dp[k][1][1]=1:dp[k][0][0]=1;\n  for (int i=lin[k];i;i=e[i].next){\n\tint y=e[i].y;\n\tif (y==fa) continue;\n\tDfs_dp(e[i].y,k,dep+1);\n\tfor (int i=0;i<3;++i)\n\t  for (int j=0;j<3;++j)\n\t\tfor (int u=0;u<3;++u)\n\t\t  for (int v=0;v<3;++v)\n\t\t\tfor (int t=0;t<3;++t){\n\t\t\t  int p=min(2,i+u*(t==1)),q=min(2,j+v*(t==2));\n\t\t\t  sadd(tmp[p][q],mul(dp[k][i][j],dp[y][u][v]));\n\t\t\t}\n\tfor (int i=0;i<3;++i)\n\t  for (int j=0;j<3;++j) dp[k][i][j]=tmp[i][j],tmp[i][j]=0;\n  }\n}\n\nint ans;\n\nvoid Get_dp(){\n  if (cd&1){\n\tint k=d[cd+1>>1];\n\tDfs_dp(k,0,0);\n\tans=mul(dp[k][1][1],inv2);\n  }else{\n\tint x=d[cd>>1],y=d[cd+2>>1];\n\tDfs_dp(x,y,0);Dfs_dp(y,x,0);\n\tans=mul(add(dp[x][1][0],add(dp[x][1][1],dp[x][1][2])),add(dp[y][0][1],add(dp[y][1][1],dp[y][2][1])));\n  }\n}\n\nvoid work(){\n  Get_dia();\n  Get_dp();\n}\n\nvoid outo(){\n  printf(\"%d\\n\",ans);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for(int i=(a),_ed=(b);i<=_ed;++i)\n#define DREP(i,a,b) for(int i=(a),_ed=(b);i>=_ed;--i)\n#define mp(x,y) make_pair((x),(y))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int,int> pii;\ninline int read(){\n    register int x=0,f=1;register char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=0;ch=getchar();}\n    while(isdigit(ch)){x=x*10+(ch^'0');ch=getchar();}\n    return f?x:-x;\n}\n\nconst int N=2e5+5,mod=998244353;\nint n,c[2],mxd[N],f[N][3][3],g[3][3];\nvector<int> E[N];\ninline void inc(int& x,int y){x=x+y<mod?x+y:x+y-mod;}\n\nnamespace getcore{\n\tint d[N],fa[N];\n\tvoid dfs(int u,int pa,int dis,int& rt){\n\t\td[u]=dis,fa[u]=pa;if(d[u]>d[rt])rt=u;\n\t\tfor(int v:E[u]){\n\t\t\tif(v==pa)continue;\n\t\t\tdfs(v,u,dis+1,rt);\n\t\t}\n\t}\n\tvoid Main(){\n\t\tstatic int stk[N],tp,tmp;\n\t\tdfs(1,0,0,tmp);\n\t\tdfs(tmp,0,0,tmp);\n\t\twhile(tmp)stk[++tp]=tmp,tmp=fa[tmp];\n\t\tc[0]=stk[(tp+1)>>1];\n\t\tif(~tp&1)c[1]=stk[(tp-1)>>1];\n\t}\n}\n\nint dfs(int u,int pa,int dep){\n\tmxd[u]=dep;\n\tfor(int v:E[u]){\n\t\tif(v==pa||v==c[0]||v==c[1])continue;\n\t\tmxd[u]=max(mxd[u],dfs(v,u,dep+1));\n\t}\n\tif(mxd[u]==dep)f[u][1][1]=1;\n\telse f[u][0][0]=1;\n\tfor(int v:E[u]){\n\t\tif(v==pa||v==c[0]||v==c[1])continue;\n\t\tREP(i,0,2)REP(j,0,2)g[i][j]=0;\n\t\tREP(a,0,2)REP(b,0,2)REP(p,0,2)REP(q,0,2){\n\t\t\tint flg=mxd[u]==mxd[v];\n\t\t\tint s=a,t=b,val=1ll*f[u][a][b]*f[v][p][q]%mod;\n\t\t\tinc(g[s][t],val);\n\t\t\ts=flg?min(2,a+p):a,t=b;\n\t\t\tinc(g[s][t],val);\n\t\t\ts=a,t=flg?min(2,b+q):b;\n\t\t\tinc(g[s][t],val);\n\t\t}\n\t\tREP(i,0,2)REP(j,0,2)f[u][i][j]=g[i][j];\n\t}\n\treturn mxd[u];\n}\n\nint main(){\n\t//freopen(\"in.in\",\"r\",stdin);\n\tn=read();\n\tREP(i,1,n-1){\n\t\tint u=read(),v=read();\n\t\tE[u].pb(v),E[v].pb(u);\n\t}\n\tgetcore::Main();\n\tint sum=0;\n\tdfs(c[0],0,0);\n\tif(!c[1])\n\t\tsum=f[c[0]][1][1];\n\telse{\n\t\tdfs(c[1],0,0);\n\t\tREP(i,0,2)REP(j,0,2)\n\t\t\tinc(sum,1ll*f[c[0]][1][i]*f[c[1]][j][1]%mod);\n\t\tREP(i,0,2)REP(j,0,2)\n\t\t\tinc(sum,1ll*f[c[0]][i][1]*f[c[1]][1][j]%mod);\n\t}\n\tsum=1ll*sum*(mod+1)/2%mod;\n\tprintf(\"%d\\n\",sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for (int i = (a); i <= int(b); i++)\n#define per(i, a, b) for (int i = (a); i >= int(b); i--)\n#define fi first\n#define se second\n#define int long long\nusing namespace std;\n\nconst int maxn = 2e5, mod = 998244353;\nint n, f[maxn + 3], mx[maxn + 3], se[maxn + 3], g[maxn + 3];\nint far[maxn + 3], h[maxn + 3][2];\nvector<int> G[maxn + 3];\n\nvoid dfs(int u, int p = 0) {\n\trep(i, 0, G[u].size() - 1) {\n\t\tint v = G[u][i];\n\t\tif (v == p) continue;\n\t\tdfs(v, u);\n\t\tf[u] = max(f[u], f[v] + 1);\n\t\tif (!mx[u] || f[v] >= f[mx[u]]) {\n\t\t\tse[u] = mx[u], mx[u] = v;\n\t\t} else if (!se[u] || f[v] >= f[se[u]]) {\n\t\t\tse[u] = v;\n\t\t}\n\t}\n}\n\nvoid down(int u, int p = 0) {\n\trep(i, 0, G[u].size() - 1) {\n\t\tint v = G[u][i];\n\t\tif (v == p) continue;\n\t\tif (v == mx[u]) {\n\t\t\tg[v] = max(g[u], f[se[u]] + 1) + 1;\n\t\t} else {\n\t\t\tg[v] = max(g[u], f[mx[u]] + 1) + 1;\n\t\t}\n\t\tdown(v, u);\n\t}\n\tg[u] = max(f[u], g[u]);\n}\n\nvoid work(int u, int p = 0) {\n\trep(i, 0, G[u].size() - 1) {\n\t\tint v = G[u][i];\n\t\tif (v == p) continue;\n\t\twork(v, u);\n\t\tfar[u] = max(far[u], far[v] + 1);\n\t}\n\tif (!far[u]) {\n\t\th[u][0] = h[u][1] = 1; return;\n\t}\n\tint A = 1, B = 0, C = 3;\n\trep(i, 0, G[u].size() - 1) {\n\t\tint v = G[u][i];\n\t\tif (v == p) continue;\n\t\tint D = 0, E = 0;\n\t\tif (far[v] + 1 != far[u]) {\n\t\t\tD = h[v][0] + h[v][1] * 2ll % mod; \n\t\t} else {\n\t\t\tD = h[v][0] + h[v][1], E = h[v][1];\n\t\t}\n\t\tC = 1ll * C * (h[v][0] + h[v][1] * 2ll) % mod;\n\t\tB = (1ll * B * D + 1ll * A * E) % mod;\n\t\tA = 1ll * A * D % mod;\n\t}\n\th[u][1] = B, h[u][0] = (C - B * 2) % mod;\n\th[u][0] < 0 ? h[u][0] += mod : 0;\n}\n\nsigned main() {\n\tscanf(\"%d\", &n);\n\tif (n == 1) { puts(\"1\"), exit(0); }\n\trep(i, 1, n - 1) {\n\t\tint u, v; scanf(\"%d %d\", &u, &v);\n\t\tG[u].push_back(v), G[v].push_back(u);\n\t}\n\tf[0] = -1;\n\tdfs(1);\n\tdown(1);\n\tint mn = n;\n\trep(i, 1, n) mn = min(mn, g[i]);\n\tint a = 0, b = 0, c = 0;\n\trep(i, 1, n) if (g[i] == mn) {\n\t\tif (++c == 1) a = i;\n\t\telse if (c == 2) b = i;\n\t\telse exit(1);\n\t}\n\tif (c == 1) {\n\t\tint A = 1, B = 0, C = 0;\n\t\trep(i, 0, G[a].size() - 1) {\n\t\t\tint v = G[a][i];\n\t\t\twork(v, a);\n\t\t\tint D = 0, E = 0;\n\t\t\tif (far[v] + 1 != g[a]) {\n\t\t\t\tD = h[v][0] + h[v][1] * 2ll % mod;\n\t\t\t} else {\n\t\t\t\tD = h[v][0], E = h[v][1];\n\t\t\t}\n\t\t\tC = (1ll * C * D + 1ll * B * E) % mod;\n\t\t\tB = (1ll * B * D + 1ll * A * E) % mod;\n\t\t\tA = 1ll * A * D % mod;\n\t\t}\n\t\tprintf(\"%d\\n\", C);\n\t} else {\n\t\twork(a, b);\n\t\twork(b, a);\n\t\tprintf(\"%d\\n\", int(1ll * h[a][1] * h[b][1] % mod));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define mem(x,v) memset(x,v,sizeof(x))\n#define Rep(i,a,b) for(int i=(a);i<=int(b);++i)\n#define rep(i,a,b) for(int i=(a);i<int(b);++i)\n#define Dep(i,a,b) for(int i=(a);i>=int(b);--i)\n#define gc getchar\n#define pc putchar\n#define fi first\n#define se second\ninline ll read(){\n    ll x=0,f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\ninline void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\ninline void writeln(ll x){write(x);pc('\\n');}\ninline void wri(ll x){write(x);pc(' ');}\nint n,m,a[1<<11][1<<11],w[12][1<<11],f[1<<11];\n#define lowbit(x) ((x)&-(x))\nint main(){\n\tn = read(),m = read();\n\tint h = max(n,m);\n\trep(i,0,h){\n\t\trep(j,1,1<<h){\n\t\t\tw[h-1-i][j] = lowbit(j)==(1<<i);\n\t\t}\n\t}\n\trep(i,1,1<<h) f[i] = i;\n\tswap(f[1],f[(1<<h)-1]);\n\trep(i,1,1<<h){\n\t\trep(j,1,1<<h){\n\t\t\trep(k,0,h) if(f[i]>>k&1){\n\t\t\t\ta[i][j] |= w[k][j];\n\t\t\t}\n\t\t}\n\t}\n\tif(n<m){\n\t\trep(i,1,1<<n){\n\t\t\trep(j,1,1<<m){\n\t\t\t\tpc(a[i][j]+'0');\n\t\t\t}puts(\"\");\n\t\t}\n\t} else{\n\t\trep(i,1,1<<n){\n\t\t\trep(j,1,1<<m){\n\t\t\t\tpc(a[j][i]+'0');\n\t\t\t}puts(\"\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n\n\n\n\n#include <algorithm>\n\n#include <array>\n\n#include <bitset>\n\n#include <cassert>\n\n#include <complex>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <iostream>\n\n#include <map>\n\n#include <numeric>\n\n#include <queue>\n\n#include <set>\n\n#include <string>\n\n#include <unordered_map>\n\n#include <unordered_set>\n\n#include <vector>\n\nusing namespace std;\n\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    static constexpr uint get_mod() { return MD; }\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(uint(_v % MD + MD)); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(uint(ull(v) * r.v % MD)); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\n// using Mint = ModInt<998244353>;\n// template<> const Mint Mint::G = Mint(3);\n\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\nusing Mint = ModInt<998244353>;\n\nVV<int> g;\n\nint mdp, mv;\nvoid dfs(int p, int b, int ndp = 0) {\n    if (mdp <= ndp) {\n        mdp = ndp;\n        mv = p;\n    }\n    for (int d: g[p]) {\n        if (d == b) continue;\n        dfs(d, p, ndp + 1);\n    }\n}\n\nV<int> path;\nbool dfs_path(int p, int b, int t) {\n    if (p == t) {\n        path.push_back(p);\n        return true;\n    }\n    for (int d: g[p]) {\n        if (d == b) continue;\n        if (dfs_path(d, p, t)) {\n            path.push_back(p);\n            return true;\n        }\n    }\n    return false;\n}\n\nint U;\n\nusing P = array<Mint, 3>;\n\nP solve(int p, int b, int ndps = 0) {\n    if (g[p].size() == 1) {\n        // leaf\n        if (ndps == U) {\n            // rad\n            return {Mint(2), Mint(1), Mint(0)};\n        } else {\n//            dbg(p, b, P{Mint(3), Mint(0)});\n            return {Mint(3), Mint(0), Mint(0)};\n        }\n    }\n    P dp = {Mint(1), Mint(0), Mint(0)};\n    for (auto d: g[p]) {\n        if (d == b) continue;\n        auto ch = solve(d, p, ndps + 1);\n        P ndp = {Mint(0), Mint(0), Mint(0)};\n        for (int a = 0; a < 3; a++) {\n            for (int b = 0; b < 3; b++) {\n                ndp[min(2, a + b)] += dp[a] * ch[b];\n            }\n        }\n        dp = ndp;\n    }\n    dp[0] = dp[0] * Mint(3) + (dp[1] + dp[2]) * Mint(2);\n    return dp;\n}\n\nint main() {\n    int n;\n    n=read();\n    g = VV<int>(n);\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        a=read();b=read(); a--; b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    dfs(0, -1);\n    int u = mv;\n    dfs(mv, -1);\n    int v = mv;\n    dfs_path(u, -1, v);\n\n    int L = int(path.size());\n    if (L % 2) {\n        U = (L / 2) - 1;\n        int mid = path[L / 2];\n                       ;\n        V<Mint> dp(4);\n        dp[0] = Mint(1);\n        for (int d: g[mid]) {\n            V<Mint> ndp(4);\n            auto x = solve(d, mid);\n            Mint x0 = x[0] - (x[1] + x[2]), x1 = x[1];\n//            ndp[3] = dp[3] * x0 + dp[2] * x1 + dp[1] * x1;\n            ndp[2] = dp[2] * x0 + dp[1] * x1;\n            ndp[1] = dp[1] * x0 + dp[0] * x1;\n            ndp[0] = dp[0] * x0;\n            dp = ndp;\n        }\n               ;\n//        pr.writeln((dp[3] / Mint(2)).v);\n//\t\tprintf(\"%\");\n//\t\tpr2((dp[3]/Mint(2)).v);\n\t\tpr2(dp[2].v);\n    } else {\n        int mid0 = path[L / 2 - 1], mid1 = path[L / 2];\n        U = (L / 2 - 1);\n        auto x = solve(mid0, mid1);\n        auto y = solve(mid1, mid0);\n    \tpr2((x[1] * y[1]).v);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for(int i=(a),_ed=(b);i<=_ed;++i)\n#define DREP(i,a,b) for(int i=(a),_ed=(b);i>=_ed;--i)\n#define mp(x,y) make_pair((x),(y))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int,int> pii;\ninline int read(){\n    register int x=0,f=1;register char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=0;ch=getchar();}\n    while(isdigit(ch)){x=x*10+(ch^'0');ch=getchar();}\n    return f?x:-x;\n}\n\nconst int N=2e5+5,mod=998244353;\nint n,c[2],mxd[N],f[N][3][3],g[3][3];\nvector<int> E[N];\ninline void inc(int& x,int y){x=x+y<mod?x+y:x+y-mod;}\n\nnamespace getcore{\n\tint d[N],fa[N];\n\tvoid dfs(int u,int pa,int dis,int& rt){\n\t\td[u]=dis,fa[u]=pa;if(d[u]>d[rt])rt=u;\n\t\tfor(int v:E[u]){\n\t\t\tif(v==pa)continue;\n\t\t\tdfs(v,u,dis+1,rt);\n\t\t}\n\t}\n\tvoid Main(){\n\t\tstatic int stk[N],tp,tmp;\n\t\tdfs(1,0,0,tmp);\n\t\tdfs(tmp,0,0,tmp);\n\t\twhile(tmp)stk[++tp]=tmp,tmp=fa[tmp];\n\t\tc[0]=stk[(tp+1)>>1];\n\t\tif(~tp&1)c[1]=stk[(tp-1)>>1];\n\t}\n}\n\nint dfs(int u,int pa,int dep){\n\tmxd[u]=dep;\n\tfor(int v:E[u]){\n\t\tif(v==pa||v==c[0]||v==c[1])continue;\n\t\tmxd[u]=max(mxd[u],dfs(v,u,dep+1));\n\t}\n\tif(mxd[u]==dep)f[u][1][1]=1;\n\telse f[u][0][0]=1;\n\tfor(int v:E[u]){\n\t\tif(v==pa||v==c[0]||v==c[1])continue;\n\t\tREP(i,0,2)REP(j,0,2)g[i][j]=0;\n\t\tREP(a,0,2)REP(b,0,2)REP(p,0,2)REP(q,0,2){\n\t\t\tint flg=mxd[u]==mxd[v];\n\t\t\tint s=a,t=b,val=1ll*f[u][a][b]*f[v][p][q]%mod;\n\t\t\tinc(g[s][t],val);\n\t\t\ts=flg?min(2,a+p):a,t=b;\n\t\t\tinc(g[s][t],val);\n\t\t\ts=a,t=flg?min(2,b+q):b;\n\t\t\tinc(g[s][t],val);\n\t\t}\n\t\tREP(i,0,2)REP(j,0,2)f[u][i][j]=g[i][j];\n\t}\n\treturn mxd[u];\n}\n\nint main(){\n\t//freopen(\"in.in\",\"r\",stdin);\n\tn=read();\n\tREP(i,1,n-1){\n\t\tint u=read(),v=read();\n\t\tE[u].pb(v),E[v].pb(u);\n\t}\n\tgetcore::Main();\n\tint sum=0;\n\tdfs(c[0],0,0);\n\tif(!c[1])\n\t\tsum=f[c[0]][1][1];\n\telse{\n\t\tdfs(c[1],0,0);\n\t\tREP(i,0,2)REP(j,0,2)\n\t\t\tinc(sum,1ll*f[c[0]][1][i]*f[c[1]][j][1]%mod);\n\t\tprintf(\"%d\\n\",sum);return 0;\n\t}\n\tsum=1ll*sum*(mod+1)/2%mod;\n\tprintf(\"%d\\n\",sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst int M=998244353;\nconst int inv2=(M+1)/2;\nconst int inv3=(M+1)/3;\nconst int maxn=3e5+3;\nvector <int> h[maxn];\nint dis[maxn],n,pre[maxn],p,q,d[maxn],m;\nll dp[maxn][4];\nvoid dfs(int u,int fa){\n    pre[u]=fa; dis[u]=dis[fa]+1;\n    for (auto v:h[u]){\n        if (v==fa) continue;\n        dfs(v,u);\n    }\n}\nvoid dfs2(int u,int fa){\n    d[u]=d[fa]+1;\n    if (d[u]==m){\n        dp[u][0]=2; // none\n        dp[u][1]=1; // exactly one\n        dp[u][2]=3; // all\n        dp[u][3]=1; // at least one\n        return;\n    }\n    ll r1=1,r2=0,r3=1,r4=0;\n    for (auto v:h[u]){\n        if (v==fa) continue;\n        dfs2(v,u);\n        ll nr1=r1*dp[v][0]%M;\n        ll nr2=(r1*dp[v][1]+r2*dp[v][0])%M;\n        ll nr3=r3*dp[v][2]%M;\n        ll nr4=((r3*dp[v][3]+r4*dp[v][2]-r4*dp[v][3])%M+M)%M;\n        r1=nr1; r2=nr2; r3=nr3; r4=nr4;\n    }\n    dp[u][0]=(r1*3+r2*2)%M;\n    dp[u][1]=r2;\n    dp[u][2]=r3*3%M;\n    dp[u][3]=r4;\n}\nint main(){\n    scanf(\"%d\",&n); dis[0]=-1;\n    for (int i=1;i<n;i++){\n        int u,v; scanf(\"%d%d\",&u,&v);\n        h[u].pb(v); h[v].pb(u);\n    }\n    //puts(\"B\");\n    dfs(1,0);\n    int s=1;\n    for (int i=2;i<=n;i++) if (dis[i]>dis[s]) s=i;\n    dfs(s,0);\n    int t=s;\n    for (int i=1;i<=n;i++) if (dis[i]>dis[t]) t=i;\n    m=dis[t]/2; p=t;\n    for (int i=0;i<m;i++) p=pre[p];\n    if (dis[t]&1){\n        q=pre[p];\n        d[q]=-1; dfs2(p,q);\n        d[p]=-1; dfs2(q,p);\n        printf(\"%lld\\n\",dp[p][1]*dp[q][1]%M);\n    } else {\n        ll ans0=1,ans1=0,ans2=0;\n        for (auto u:h[p]){\n            d[u]=0; dfs2(u,p);\n            ll nans0,nans1,nans2,has,none;\n            has=dp[u][1]; none=(dp[u][2]+2*(M-dp[u][3]))%M;\n            //cout<<dp[u][2]<<' '<<dp[u][3]<<endl;\n            nans0=ans0*none%M;\n            nans1=(ans0*has+ans1*none)%M;\n            nans2=(ans1*has+ans2*none)%M;\n            ans0=nans0; ans1=nans1; ans2=nans2;\n        }\n        printf(\"%lld\\n\",ans2);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[202020];\nconst ll mo=998244353;\nint D;\npair<int,int> farthest(int cur,int pre,int d,vector<int>& D) {\n\tD[cur]=d;\n\tpair<int,int> r={d,cur};\n\tFORR(e,E[cur]) if(e!=pre) r=max(r, farthest(e,cur,d+1,D));\n\treturn r;\n}\n\npair<int,vector<int>> diameter() { // diameter,center\n\tvector<int> D[2];\n\tD[0].resize(N);\n\tD[1].resize(N);\n\tauto v1=farthest(0,0,0,D[0]);\n\tauto v2=farthest(v1.second,v1.second,0,D[0]);\n\tfarthest(v2.second,v2.second,0,D[1]);\n\tpair<int,vector<int>> R;\n\tR.first = v2.first;\n\t//重心を取る場合\n\tfor(int i=N-1;i>=0;i--) if(D[0][i]+D[1][i]==R.first && abs(D[0][i]-D[1][i])<=1) R.second.push_back(i);\n\n\treturn R;\n}\n\nvector<ll> dfs1(int cur,int pre,int lef,int no=0) {\n\tif(E[cur].size()==1) {\n\t\tif(lef==0) {\n\t\t\tif(D==2) return {1,1,0};\n\t\t\telse return {2,1,0};\n\t\t}\n\t\telse return {3,0,0};\n\t}\n\telse {\n\t\tvector<ll> X={1,0,0};\n\t\tFORR(e,E[cur]) if(e!=pre) {\n\t\t\tvector<ll> Y=dfs1(e,cur,lef-1);\n\t\t\tvector<ll> Z={0,0,0};\n\t\t\tint x,y;\n\t\t\tFOR(x,3) FOR(y,3) Z[min(x+y,2)]+=X[x]*Y[y]%mo;\n\t\t\tX[0]=Z[0]%mo;\n\t\t\tX[1]=Z[1]%mo;\n\t\t\tX[2]=Z[2]%mo;\n\t\t}\n\t\tvector<ll> Y={0,0,0};\n\t\tif(no) {\n\t\t\tY=X;\n\t\t}\n\t\telse {\n\t\t\tY[0]=(X[0]*3+X[1]*2+X[2]*2)%mo;\n\t\t\tY[1]=X[1];\n\t\t\tY[2]=X[2];\n\t\t}\n\t\treturn Y;\n\t}\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tauto R=diameter();\n\tD=R.first;\n\tif(R.second.size()==1) {\n\t\tvector<ll> X={1,0,0,0};\n\t\tFORR(e,E[R.second[0]]) {\n\t\t\tauto Y=dfs1(e,R.second[0],R.first/2-1);\n\t\t\tvector<ll> Z={0,0,0,0};\n\t\t\tFOR(x,4) FOR(y,3) Z[min(x+((y==2)?3:y),3)]+=X[x]*Y[y]%mo;\n\t\t\tFOR(x,4) X[x]=Z[x]%mo;\n\t\t\t//FOR(x,4) cout<<X[x]<<\" \";\n\t\t\t//cout<<endl;\n\t\t}\n\t\tcout<<X[2]<<endl;\n\t}\n\telse {\n\t\tvector<ll> X=dfs1(R.second[0],R.second[1],R.first/2,1);\n\t\tvector<ll> Y=dfs1(R.second[1],R.second[0],R.first/2,1);\n\t\t\n\t\tcout<<X[1]*Y[1]%mo<<endl;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nconst int N=300007,P=998244353,i2=P-P/2;\nint m,root,len,fa[N],dia[N],f[N][3][3],g[3][3];std::vector<int>e[N];\nvoid inc(int&a,int b){a+=b-P,a+=a>>31&P;}\nint mul(int a,int b){return 1ll*a*b%P;}\nint read(){int x=0,c=getchar();while(isspace(c))c=getchar();while(isdigit(c))(x*=10)+=c&15,c=getchar();return x;}\nvoid dfs(int u,int dep)\n{\n    if(dep>len) len=dep,root=u;\n    for(int v:e[u]) if(v^fa[u]) fa[v]=u,dfs(v,dep+1);\n}\nvoid dp(int u,int fa,int d)\n{\n    (d==m/2? f[u][1][1]:f[u][0][0])=1;\n    for(int v:e[u])\n    {\n\tif(v==fa) continue;\n\tdp(v,u,d+1),memset(g,0,36);\n\tfor(int x=0;x<3;++x) for(int y=0;y<3;++y) for(int p=0;p<3;++p) for(int q=0;q<3;++q) for(int k=0,r,t;k<3;++k) r=std::min(2,x+p*(k==1)),t=std::min(2,y+q*(k==2)),inc(g[r][t],mul(f[u][x][y],f[v][p][q]));\n\tmemcpy(f[u],g,36);\n    }\n}\nint main()\n{\n    int n=read(),p,q;\n    for(int i=1,u,v;i<n;++i) u=read(),v=read(),e[u].push_back(v),e[v].push_back(u);\n    dfs(1,1),memset(fa+1,0,n<<2),len=0,dfs(root,1);\n    for(int i=root;i;i=fa[i]) dia[++m]=i;\n    if(m&1) p=dia[m/2+1],dp(p,0,0),printf(\"%d\",mul(i2,f[p][1][1]));\n    else p=dia[m/2],q=dia[m/2+1],dp(p,q,1),dp(q,p,1),printf(\"%d\",mul((1ll*f[p][1][0]+f[p][1][1]+f[p][1][2])%P,(1ll*f[q][1][0]+f[q][1][1]+f[q][1][2])%P));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for(int i=(a),_ed=(b);i<=_ed;++i)\n#define DREP(i,a,b) for(int i=(a),_ed=(b);i>=_ed;--i)\n#define mp(x,y) make_pair((x),(y))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int,int> pii;\ninline int read(){\n    register int x=0,f=1;register char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=0;ch=getchar();}\n    while(isdigit(ch)){x=x*10+(ch^'0');ch=getchar();}\n    return f?x:-x;\n}\n\nconst int N=2e5+5,mod=998244353;\nint n,c[2],mxd[N],f[N][3][3],g[3][3];\nvector<int> E[N];\ninline void inc(int& x,int y){x=x+y<mod?x+y:x+y-mod;}\n\nnamespace getcore{\n\tint d[N],fa[N];\n\tvoid dfs(int u,int pa,int dis,int& rt){\n\t\td[u]=dis,fa[u]=pa;if(d[u]>d[rt])rt=u;\n\t\tfor(int v:E[u]){\n\t\t\tif(v==pa)continue;\n\t\t\tdfs(v,u,dis+1,rt);\n\t\t}\n\t}\n\tvoid Main(){\n\t\tstatic int stk[N],tp,tmp;\n\t\tdfs(1,0,0,tmp);\n\t\tdfs(tmp,0,0,tmp);\n\t\twhile(tmp)stk[++tp]=tmp,tmp=fa[tmp];\n\t\tc[0]=stk[(tp+1)>>1];\n\t\tif(~tp&1)c[1]=stk[(tp-1)>>1];\n\t}\n}\n\nint dfs(int u,int pa,int dep){\n\tmxd[u]=dep;\n\tfor(int v:E[u]){\n\t\tif(v==pa||v==c[0]||v==c[1])continue;\n\t\tmxd[u]=max(mxd[u],dfs(v,u,dep+1));\n\t}\n\tif(mxd[u]==dep)f[u][1][1]=1;\n\telse f[u][0][0]=1;\n\tfor(int v:E[u]){\n\t\tif(v==pa||v==c[0]||v==c[1])continue;\n\t\tREP(i,0,2)REP(j,0,2)g[i][j]=0;\n\t\tREP(a,0,2)REP(b,0,2)REP(p,0,2)REP(q,0,2){\n\t\t\tint flg=mxd[u]==mxd[v];\n\t\t\tint s=a,t=b,val=1ll*f[u][a][b]*f[v][p][q]%mod;\n\t\t\tinc(g[s][t],val);\n\t\t\ts=flg?min(2,a+p):a,t=b;\n\t\t\tinc(g[s][t],val);\n\t\t\ts=a,t=flg?min(2,b+q):b;\n\t\t\tinc(g[s][t],val);\n\t\t}\n\t\tREP(i,0,2)REP(j,0,2)f[u][i][j]=g[i][j];\n\t}\n\treturn mxd[u];\n}\n\nint main(){\n\t//freopen(\"in.in\",\"r\",stdin);\n\tn=read();\n\tREP(i,1,n-1){\n\t\tint u=read(),v=read();\n\t\tE[u].pb(v),E[v].pb(u);\n\t}\n\tgetcore::Main();\n\tint sum=0;\n\tdfs(c[0],0,0);\n\tif(!c[1])\n\t\tsum=f[c[0]][1][1];\n\telse{\n\t\tdfs(c[1],0,0);\n\t\tREP(i,0,2)REP(j,0,2)\n\t\t\tinc(sum,1ll*f[c[0]][1][i]*f[c[1]][j][1]%mod);\n\t\tREP(i,0,2)REP(j,0,2)\n\t\t\tinc(sum,1ll*f[c[0]][i][1]*f[c[1]][1][j]%mod);\n\t}\n\tsum=1ll*sum*(mod+1)/2%mod;\n\tprintf(\"%d\\n\",sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll mod = 998244353;\nvector<int>pat[202020];\nint dep[202020];\nbool flag[202020];\nint diam = 0;\nbool iscent[202020];\nvector<int>ko[202020];\nvoid dfs(int node, int d)\n{\n\tflag[node] = true;\n\tdep[node] = d;\n\tdiam = max(diam, d);\n\tfor (int i = 0; i < pat[node].size(); i++)if (!flag[pat[node][i]])dfs(pat[node][i], d + 1);\n}\nvoid dfs2(int node, int d)\n{\n\tflag[node] = true;\n\tdep[node] = d;\n\tfor (int i = 0; i < pat[node].size(); i++)\n\t{\n\t\tif (!flag[pat[node][i]] && !iscent[pat[node][i]])\n\t\t{\n\t\t\tdfs2(pat[node][i], d + 1);\n\t\t\tko[node].push_back(pat[node][i]);\n\t\t}\n\t}\n}\ntypedef pair<ll, ll>pii;\npii calc(int node)\n{\n\tif (ko[node].empty())\n\t{\n\t\tif (dep[node] == diam / 2)return make_pair(1, 2);\n\t\telse return make_pair(0, 3);\n\t}\n\tvector<pii>v;\n\tfor (int i = 0; i < ko[node].size(); i++)v.push_back(calc(ko[node][i]));\n\tvector<ll>r1, r2;\n\tr1.resize(v.size() + 1), r1[0] = 1;\n\tr2.resize(v.size() + 1), r2[v.size()] = 1;\n\tfor (int i = 0; i < v.size(); i++)r1[i + 1] = r1[i] * v[i].second%mod;\n\tfor (int i = v.size() - 1; i >= 0; i--)r2[i] = r2[i + 1] * v[i].second%mod;\n\tll t1 = 0, t2 = 1;\n\tfor (int i = 0; i < v.size(); i++)\n\t{\n\t\tt1 = (t1 + r1[i] * r2[i + 1] % mod*v[i].first) % mod;\n\t\tt2 = t2*v[i].second%mod;\n\t}\n\tt2 = (t2 + t1 + t2 + t1 + t2) % mod;\n\t//printf(\"%d %lld %lld\\n\", node + 1, t1, t2);\n\treturn make_pair(t1, t2);\n}\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < num - 1; i++)\n\t{\n\t\tint za, zb;\n\t\tscanf(\"%d%d\", &za, &zb);\n\t\tza--, zb--;\n\t\tpat[za].push_back(zb);\n\t\tpat[zb].push_back(za);\n\t}\n\tdfs(0, 0);\n\tint r = 0;\n\tfor (int i = 0; i < num; i++)if (dep[i] == diam)r = i;\n\tfill(flag, flag + num, false);\n\tdfs(r, 0);\n\tint now;\n\tfor (int i = 0; i < num; i++)if (dep[i] == diam)now = i;\n\tvector<int>path;\n\tfor (int i = 0; i < diam; i++)\n\t{\n\t\tpath.push_back(now);\n\t\tfor (int j = 0; j < pat[now].size(); j++)\n\t\t{\n\t\t\tif (dep[pat[now][j]] == dep[now] - 1)\n\t\t\t{\n\t\t\t\tnow = pat[now][j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpath.push_back(now);\n\n\t//for (int i = 0; i < path.size(); i++)printf(\"%d \", path[i] + 1); printf(\"\\n\");\n\n\n\tif (diam % 2 == 0)\n\t{\n\t\tabort();\n\t\tint c = path[diam / 2];\n\t\tfill(flag, flag + num, false);\n\t\tiscent[c] = true;\n\t\tdfs2(c, 0);\n\t\tll d0 = 1, d1 = 0, d2 = 0, d3 = 0;\n\t\tfor (int i = 0; i < ko[c].size(); i++)\n\t\t{\n\t\t\tpii z = calc(ko[c][i]);\n\t\t\tll e0 = d0*(z.second - z.first);\n\t\t\tll e1 = d0*z.first + d1*(z.second - z.first);\n\t\t\tll e2 = d0*z.first + d2*(z.second - z.first);\n\t\t\tll e3 = d1*z.first + d2*z.first + d3*(z.second - z.first);\n\t\t\td0 = (e0%mod + mod) % mod;\n\t\t\td1 = (e1%mod + mod) % mod;\n\t\t\td2 = (e2%mod + mod) % mod;\n\t\t\td3 = (e3%mod + mod) % mod;\n\t\t}\n\t\tprintf(\"%lld\\n\", d3*(mod + 1) / 2 % mod);\n\t}\n\telse\n\t{\n\t\tint c1 = path[diam / 2], c2 = path[(diam + 1) / 2];\n\t\tfill(flag, flag + num, false);\n\t\tiscent[c1] = iscent[c2] = true;\n\t\tdfs2(c1, 0), dfs2(c2, 0);\n\n\t\tpii a = calc(path[diam / 2]), b = calc(path[(diam + 1) / 2]);\n\t\tprintf(\"%lld\\n\", a.first*b.first%mod);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "int main(void){\n  puts(\"1\");\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map;\n\n// TLEするけど一応\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint[] from = new int[n - 1];\n\t\tint[] to = new int[n - 1];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tfrom[i] = ni() - 1;\n\t\t\tto[i] = ni() - 1;\n\t\t}\n\t\t\n\t\tint[][] g = packU(n, from, to);\n\t\tint[] cents = center(g);\n\t\tint[][] pars = parents3(g, cents[0]);\n\t\tint[] par = pars[0], ord = pars[1], dep = pars[2];\n\t\t\n\t\tint root = cents[0];\n//\t\ttr(cents);\n\t\tlong[][] dp = new long[n][];\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tint cur = ord[i];\n\t\t\t\n\t\t\tlong[] ldp = {0L, 1L};\n\t\t\tfor(int e : g[cur]){\n\t\t\t\tif(par[cur] == e)continue;\n\t\t\t\tif(cents.length == 2 && i == 0 && e == cents[1])continue;\n\t\t\t\tlong[] t = new long[dp[e].length+1];\n\t\t\t\tfor(int j = 1;j < dp[e].length+1;j++){\n\t\t\t\t\tlong s = 0;\n\t\t\t\t\tfor(int k = j-1;k <= j+1;k++){\n\t\t\t\t\t\ts += dp[e][Math.min(k, dp[e].length-1)];\n\t\t\t\t\t}\n\t\t\t\t\tt[j] = s % mod;\n\t\t\t\t}\n\t\t\t\tldp = merge(ldp, t);\n\t\t\t}\n\t\t\tdp[cur] = ldp;\n\t\t}\n\t\t\n\t\tint[][] spar = logstepParents(par);\n\t\t\n\t\tif(cents.length == 1){\n\t\t\tint[] ds = dist(g, cents[0]);\n\t\t\tint R = 0;\n\t\t\tfor(int x : ds)R = Math.max(R, x);\n\t\t\t\n\t\t\tlong[] down = new long[n];\n\t\t\tdown[root] = 1;//get(dp[root], R);\n\t\t\tfor(int i = 1;i < n;i++){\n\t\t\t\tint cur = ord[i];\n\t\t\t\tint h = R-dep[cur];\n//\t\t\t\ttr(cur, h, get(dp[cur], h) + get(dp[cur], h+1) + get(dp[cur], h+2));\n\t\t\t\tdown[cur] = down[par[cur]] * \n\t\t\t\t\t\t(h == 0 ? 1 : get(dp[cur], h)) % mod *\n\t\t\t\t\t\tinvl(get(dp[cur], h) + get(dp[cur], h+1) + get(dp[cur], h+2), mod) % mod;\n\t\t\t}\n\t\t\t\n\t\t\tMap<Integer, Long> ho = new HashMap<>();\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tif(ds[i] == R){\n\t\t\t\t\tint id = ancestor(i, R-1, spar);\n\t\t\t\t\tif(!ho.containsKey(id)){\n\t\t\t\t\t\tho.put(id, down[i]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tho.put(id, (ho.get(id) + down[i]) % mod);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong all = 0;\n\t\t\tfor(long v : ho.values())all += v;\n\t\t\tall %= mod;\n\t\t\tall = all * all % mod;\n\t\t\tfor(long v : ho.values()){\n\t\t\t\tall -= v * v;\n\t\t\t\tall %= mod;\n\t\t\t}\n\t\t\tall = all * invl(2, mod) % mod;\n\t\t\tif(all < 0)all += mod;\n\t\t\tout.println(all * get(dp[root], R) % mod);\n\t\t}else{\n\t\t\tint[] ds0 = dist(g, cents[0]);\n\t\t\tint[] ds1 = dist(g, cents[1]);\n\t\t\tint R = 0;\n\t\t\tfor(int x : ds0)R = Math.max(R, x);\n\t\t\tR--;\n\t\t\t\n\t\t\tlong[] down0 = new long[n];\n\t\t\tdown0[root] = get(dp[root], R);\n\t\t\tfor(int i = 1;i < n;i++){\n\t\t\t\tint cur = ord[i];\n\t\t\t\tint h = R-dep[cur];\n//\t\t\t\ttr(cur, h, get(dp[cur], h) + get(dp[cur], h+1) + get(dp[cur], h+2));\n\t\t\t\tdown0[cur] = down0[par[cur]] * \n\t\t\t\t\t\t(h == 0 ? 1 : get(dp[cur], h)) % mod *\n\t\t\t\t\t\tinvl(get(dp[cur], h) + get(dp[cur], h+1) + get(dp[cur], h+2), mod) % mod;\n\t\t\t}\n\t\t\t\n\t\t\tpars = parents3(g, cents[1]);\n\t\t\tpar = pars[0]; ord = pars[1]; dep = pars[2];\n\t\t\t\n\t\t\tint root1 = cents[1];\n\t\t\tlong[] down1 = new long[n];\n\t\t\tdown1[root1] = get(dp[root1], R);\n\t\t\tfor(int i = 1;i < n;i++){\n\t\t\t\tint cur = ord[i];\n\t\t\t\tint h = R-dep[cur];\n//\t\t\t\ttr(cur, h, get(dp[cur], h) + get(dp[cur], h+1) + get(dp[cur], h+2));\n\t\t\t\tdown1[cur] = down1[par[cur]] * \n\t\t\t\t\t\t(h == 0 ? 1 : get(dp[cur], h)) % mod *\n\t\t\t\t\t\tinvl(get(dp[cur], h) + get(dp[cur], h+1) + get(dp[cur], h+2), mod) % mod;\n\t\t\t}\n\t\t\t\n\t\t\tlong s0 = 0;\n\t\t\tlong s1 = 0;\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tif(ds0[i] == R && ds1[i] == R + 1){\n\t\t\t\t\ts0 += down0[i];\n\t\t\t\t}\n\t\t\t\tif(ds1[i] == R && ds0[i] == R + 1){\n\t\t\t\t\ts1 += down1[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ts0 %= mod;\n\t\t\ts1 %= mod;\n\t\t\tout.println(s0 * s1 % mod);\n\t\t}\n\t}\n\t\n\tstatic long get(long[] a, int h)\n\t{\n\t\tif(h >= a.length)return a[a.length-1];\n\t\tif(h <= 0)return 0;\n\t\treturn a[h];\n\t}\n\t\n\tstatic long[] merge(long[] a, long[] b)\n\t{\n\t\tif(a.length < b.length){\n\t\t\tlong[] d = a; a = b; b = d;\n\t\t}\n\t\t\n\t\tfor(int i = 1;i < a.length;i++){\n\t\t\ta[i] = a[i] * b[Math.min(i, b.length-1)] % mod;\n\t\t}\n\t\treturn a;\n\t}\n\t\n\tpublic static int lca2(int a, int b, int[][] spar, int[] depth) {\n\t\tif (depth[a] < depth[b]) {\n\t\t\tb = ancestor(b, depth[b] - depth[a], spar);\n\t\t} else if (depth[a] > depth[b]) {\n\t\t\ta = ancestor(a, depth[a] - depth[b], spar);\n\t\t}\n\n\t\tif (a == b)\n\t\t\treturn a;\n\t\tint sa = a, sb = b;\n\t\tfor (int low = 0, high = depth[a], t = Integer.highestOneBit(high), k = Integer\n\t\t\t\t.numberOfTrailingZeros(t); t > 0; t >>>= 1, k--) {\n\t\t\tif ((low ^ high) >= t) {\n\t\t\t\tif (spar[k][sa] != spar[k][sb]) {\n\t\t\t\t\tlow |= t;\n\t\t\t\t\tsa = spar[k][sa];\n\t\t\t\t\tsb = spar[k][sb];\n\t\t\t\t} else {\n\t\t\t\t\thigh = low | t - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn spar[0][sa];\n\t}\n\n\tprotected static int ancestor(int a, int m, int[][] spar) {\n\t\tfor (int i = 0; m > 0 && a != -1; m >>>= 1, i++) {\n\t\t\tif ((m & 1) == 1)\n\t\t\t\ta = spar[i][a];\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static int[][] logstepParents(int[] par) {\n\t\tint n = par.length;\n\t\tint m = Integer.numberOfTrailingZeros(Integer.highestOneBit(n - 1)) + 1;\n\t\tint[][] pars = new int[m][n];\n\t\tpars[0] = par;\n\t\tfor (int j = 1; j < m; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tpars[j][i] = pars[j - 1][i] == -1 ? -1 : pars[j - 1][pars[j - 1][i]];\n\t\t\t}\n\t\t}\n\t\treturn pars;\n\t}\n\n\t\n\tpublic static int[] center(int[][] g)\n\t{\n\t\tint n = g.length;\n\t\tint start = 0;\n\t\tint[] d1 = dist(g, start);\n\t\tint maxd1 = -1;\n\t\tint argmaxd1 = -1;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(d1[i] > maxd1){\n\t\t\t\tmaxd1 = d1[i];\n\t\t\t\targmaxd1 = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] d2 = dist(g, argmaxd1);\n\t\tint maxd2 = -1;\n\t\tint argmaxd2 = -1;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(d2[i] > maxd2){\n\t\t\t\tmaxd2 = d2[i];\n\t\t\t\targmaxd2 = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(maxd2 % 2 == 0){\n\t\t\tint h = maxd2/2;\n\t\t\tint j = argmaxd2;\n\t\t\touter:\n\t\t\tfor(int i = maxd2;i > h;i--){\n\t\t\t\tfor(int e : g[j]){\n\t\t\t\t\tif(d2[e] == i-1){\n\t\t\t\t\t\tj = e;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow new RuntimeException();\n\t\t\t}\n\t\t\treturn new int[]{j};\n\t\t}else{\n\t\t\tint h = maxd2/2;\n\t\t\tint j = argmaxd2;\n\t\t\tint[] cs = new int[2];\n\t\t\tint p = 0;\n\t\t\touter:\n\t\t\tfor(int i = maxd2;i >= h;i--){\n\t\t\t\tif(i <= h+1)cs[p++] = j;\n\t\t\t\tif(i > h){\n\t\t\t\t\tfor(int e : g[j]){\n\t\t\t\t\t\tif(d2[e] == i-1){\n\t\t\t\t\t\t\tj = e;\n\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthrow new RuntimeException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cs;\n\t\t}\n\t}\n\n\t// distance array from start\n\tpublic static int[] dist(int[][] g, int start)\n\t{\n\t\tint n = g.length;\n\t\tint[] d = new int[n];\n\t\tArrays.fill(d, n+3);\n\t\tint[] q = new int[n];\n\t\tint p = 0;\n\t\tq[p++] = start;\n\t\td[start] = 0;\n\t\tfor(int r = 0;r < p;r++){\n\t\t\tint cur = q[r];\n\t\t\tfor(int e : g[cur]){\n\t\t\t\tif(d[e] > d[cur] + 1){\n\t\t\t\t\td[e] = d[cur] + 1;\n\t\t\t\t\tq[p++] = e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\t\n\t\n\t\n\t\n\t\n\tpublic static int mod = 998244353;\n\tpublic static int G = 3;\n\t\n\tstatic long[][] pas;\n\t\n\tstatic {\n\t\tlong[] a = {1, 1, 1};\n\t\tpas = new long[17][];\n\t\tpas[0] = a;\n\t\tfor(int i = 1;i < 17;i++){\n\t\t\tpas[i] = mul(pas[i-1], pas[i-1]);\n\t\t}\n\t}\n\t\n\tstatic long[] pow(int e)\n\t{\n\t\tlong[] q = {1};\n\t\twhile(e > 0){\n\t\t\tint v = Integer.numberOfTrailingZeros(e);\n\t\t\te &= e-1;;\n\t\t\tq = mul(q, pas[v]);\n\t\t}\n\t\treturn q;\n\t}\n\t\n\tpublic static long[] mul(long[] a, long[] b)\n\t{\n\t\tif(a.length + b.length < 100){\n\t\t\treturn mulnaive(a, b);\n\t\t}else{\n\t\t\treturn Arrays.copyOf(convoluteSimply(a, b, mod, G), a.length+b.length-1);\n\t\t}\n\t}\n\t\n\tpublic static long[] mul(long[] a, long[] b, int lim)\n\t{\n\t\treturn Arrays.copyOf(convoluteSimply(a, b, mod, G), lim);\n\t}\n\t\n\tpublic static long[] mulnaive(long[] a, long[] b)\n\t{\n\t\tlong[] c = new long[a.length+b.length-1];\n\t\tlong big = 8L*mod*mod;\n\t\tfor(int i = 0;i < a.length;i++){\n\t\t\tfor(int j = 0;j < b.length;j++){\n\t\t\t\tc[i+j] += a[i]*b[j];\n\t\t\t\tif(c[i+j] >= big)c[i+j] -= big;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < c.length;i++)c[i] %= mod;\n\t\treturn c;\n\t}\n\t\n\tpublic static long[] mulnaive(long[] a, long[] b, int lim)\n\t{\n\t\tlong[] c = new long[lim];\n\t\tlong big = 8L*mod*mod;\n\t\tfor(int i = 0;i < a.length;i++){\n\t\t\tfor(int j = 0;j < b.length && i+j < lim;j++){\n\t\t\t\tc[i+j] += a[i]*b[j];\n\t\t\t\tif(c[i+j] >= big)c[i+j] -= big;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < c.length;i++)c[i] %= mod;\n\t\treturn c;\n\t}\n\t\n\tpublic static long[] mul_(long[] a, long k)\n\t{\n\t\tfor(int i = 0;i < a.length;i++)a[i] = a[i] * k % mod;\n\t\treturn a;\n\t}\n\t\n\tpublic static long[] mul(long[] a, long k)\n\t{\n\t\ta = Arrays.copyOf(a, a.length);\n\t\tfor(int i = 0;i < a.length;i++)a[i] = a[i] * k % mod;\n\t\treturn a;\n\t}\n\n\n\tpublic static final int[] NTTPrimes = {1053818881, 1051721729, 1045430273, 1012924417, 1007681537, 1004535809, 998244353, 985661441, 976224257, 975175681};\n\tpublic static final int[] NTTPrimitiveRoots = {7, 6, 3, 5, 3, 3, 3, 3, 3, 17};\n//\tpublic static final int[] NTTPrimes = {1012924417, 1004535809, 998244353, 985661441, 975175681, 962592769, 950009857, 943718401, 935329793, 924844033};\n//\tpublic static final int[] NTTPrimitiveRoots = {5, 3, 3, 3, 17, 7, 7, 7, 3, 5};\n\t\n\tpublic static long[] convoluteSimply(long[] a, long[] b, int P, int g)\n\t{\n\t\tint m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);\n\t\tlong[] fa = nttmb(a, m, false, P, g);\n\t\tlong[] fb = a == b ? fa : nttmb(b, m, false, P, g);\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tfa[i] = fa[i]*fb[i]%P;\n\t\t}\n\t\treturn nttmb(fa, m, true, P, g);\n\t}\n\t\n\tpublic static long[] convolute(long[] a, long[] b)\n\t{\n\t\tint USE = 2;\n\t\tint m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);\n\t\tlong[][] fs = new long[USE][];\n\t\tfor(int k = 0;k < USE;k++){\n\t\t\tint P = NTTPrimes[k], g = NTTPrimitiveRoots[k];\n\t\t\tlong[] fa = nttmb(a, m, false, P, g);\n\t\t\tlong[] fb = a == b ? fa : nttmb(b, m, false, P, g);\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tfa[i] = fa[i]*fb[i]%P;\n\t\t\t}\n\t\t\tfs[k] = nttmb(fa, m, true, P, g);\n\t\t}\n\t\t\n\t\tint[] mods = Arrays.copyOf(NTTPrimes, USE);\n\t\tlong[] gammas = garnerPrepare(mods);\n\t\tint[] buf = new int[USE];\n\t\tfor(int i = 0;i < fs[0].length;i++){\n\t\t\tfor(int j = 0;j < USE;j++)buf[j] = (int)fs[j][i];\n\t\t\tlong[] res = garnerBatch(buf, mods, gammas);\n\t\t\tlong ret = 0;\n\t\t\tfor(int j = res.length-1;j >= 0;j--)ret = ret * mods[j] + res[j];\n\t\t\tfs[0][i] = ret;\n\t\t}\n\t\treturn fs[0];\n\t}\n\t\n\tpublic static long[] convolute(long[] a, long[] b, int USE, int mod)\n\t{\n\t\tint m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);\n\t\tlong[][] fs = new long[USE][];\n\t\tfor(int k = 0;k < USE;k++){\n\t\t\tint P = NTTPrimes[k], g = NTTPrimitiveRoots[k];\n\t\t\tlong[] fa = nttmb(a, m, false, P, g);\n\t\t\tlong[] fb = a == b ? fa : nttmb(b, m, false, P, g);\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tfa[i] = fa[i]*fb[i]%P;\n\t\t\t}\n\t\t\tfs[k] = nttmb(fa, m, true, P, g);\n\t\t}\n\t\t\n\t\tint[] mods = Arrays.copyOf(NTTPrimes, USE);\n\t\tlong[] gammas = garnerPrepare(mods);\n\t\tint[] buf = new int[USE];\n\t\tfor(int i = 0;i < fs[0].length;i++){\n\t\t\tfor(int j = 0;j < USE;j++)buf[j] = (int)fs[j][i];\n\t\t\tlong[] res = garnerBatch(buf, mods, gammas);\n\t\t\tlong ret = 0;\n\t\t\tfor(int j = res.length-1;j >= 0;j--)ret = (ret * mods[j] + res[j]) % mod;\n\t\t\tfs[0][i] = ret;\n\t\t}\n\t\treturn fs[0];\n\t}\n\t\n\t// static int[] wws = new int[270000]; // outer faster\n\t\n\t// Modifed Montgomery + Barrett\n\tprivate static long[] nttmb(long[] src, int n, boolean inverse, int P, int g)\n\t{\n\t\tlong[] dst = Arrays.copyOf(src, n);\n\t\t\n\t\tint h = Integer.numberOfTrailingZeros(n);\n\t\tlong K = Integer.highestOneBit(P)<<1;\n\t\tint H = Long.numberOfTrailingZeros(K)*2;\n\t\tlong M = K*K/P;\n\t\t\n\t\tint[] wws = new int[1<<h-1];\n\t\tlong dw = inverse ? pow(g, P-1-(P-1)/n, P) : pow(g, (P-1)/n, P);\n\t\tlong w = (1L<<32)%P;\n\t\tfor(int k = 0;k < 1<<h-1;k++){\n\t\t\twws[k] = (int)w;\n\t\t\tw = modh(w*dw, M, H, P);\n\t\t}\n\t\tlong J = invl(P, 1L<<32);\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < 1<<i;j++){\n\t\t\t\tfor(int k = 0, s = j<<h-i, t = s|1<<h-i-1;k < 1<<h-i-1;k++,s++,t++){\n\t\t\t\t\tlong u = (dst[s] - dst[t] + 2*P)*wws[k];\n\t\t\t\t\tdst[s] += dst[t];\n\t\t\t\t\tif(dst[s] >= 2*P)dst[s] -= 2*P;\n//\t\t\t\t\tlong Q = (u&(1L<<32)-1)*J&(1L<<32)-1;\n\t\t\t\t\tlong Q = (u<<32)*J>>>32;\n\t\t\t\t\tdst[t] = (u>>>32)-(Q*P>>>32)+P;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i < h-1){\n\t\t\t\tfor(int k = 0;k < 1<<h-i-2;k++)wws[k] = wws[k*2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(dst[i] >= P)dst[i] -= P;\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint rev = Integer.reverse(i)>>>-h;\n\t\t\tif(i < rev){\n\t\t\t\tlong d = dst[i]; dst[i] = dst[rev]; dst[rev] = d;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(inverse){\n\t\t\tlong in = invl(n, P);\n\t\t\tfor(int i = 0;i < n;i++)dst[i] = modh(dst[i]*in, M, H, P);\n\t\t}\n\t\t\n\t\treturn dst;\n\t}\n\t\n\t// Modified Shoup + Barrett\n\tprivate static long[] nttsb(long[] src, int n, boolean inverse, int P, int g)\n\t{\n\t\tlong[] dst = Arrays.copyOf(src, n);\n\t\t\n\t\tint h = Integer.numberOfTrailingZeros(n);\n\t\tlong K = Integer.highestOneBit(P)<<1;\n\t\tint H = Long.numberOfTrailingZeros(K)*2;\n\t\tlong M = K*K/P;\n\t\t\n\t\tlong dw = inverse ? pow(g, P-1-(P-1)/n, P) : pow(g, (P-1)/n, P);\n\t\tlong[] wws = new long[1<<h-1];\n\t\tlong[] ws = new long[1<<h-1];\n\t\tlong w = 1;\n\t\tfor(int k = 0;k < 1<<h-1;k++){\n\t\t\twws[k] = (w<<32)/P;\n\t\t\tws[k] = w;\n\t\t\tw = modh(w*dw, M, H, P);\n\t\t}\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < 1<<i;j++){\n\t\t\t\tfor(int k = 0, s = j<<h-i, t = s|1<<h-i-1;k < 1<<h-i-1;k++,s++,t++){\n\t\t\t\t\tlong ndsts = dst[s] + dst[t];\n\t\t\t\t\tif(ndsts >= 2*P)ndsts -= 2*P;\n\t\t\t\t\tlong T = dst[s] - dst[t] + 2*P;\n\t\t\t\t\tlong Q = wws[k]*T>>>32;\n\t\t\t\t\tdst[s] = ndsts;\n\t\t\t\t\tdst[t] = ws[k]*T-Q*P&(1L<<32)-1;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tdw = dw * dw % P;\n\t\t\tif(i < h-1){\n\t\t\t\tfor(int k = 0;k < 1<<h-i-2;k++){\n\t\t\t\t\twws[k] = wws[k*2];\n\t\t\t\t\tws[k] = ws[k*2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(dst[i] >= P)dst[i] -= P;\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint rev = Integer.reverse(i)>>>-h;\n\t\t\tif(i < rev){\n\t\t\t\tlong d = dst[i]; dst[i] = dst[rev]; dst[rev] = d;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(inverse){\n\t\t\tlong in = invl(n, P);\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tdst[i] = modh(dst[i] * in, M, H, P);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn dst;\n\t}\n\t\n\tstatic final long mask = (1L<<31)-1;\n\t\n\tpublic static long modh(long a, long M, int h, int mod)\n\t{\n\t\tlong r = a-((M*(a&mask)>>>31)+M*(a>>>31)>>>h-31)*mod;\n\t\treturn r < mod ? r : r-mod;\n\t}\n\t\n\tprivate static long[] garnerPrepare(int[] m)\n\t{\n\t\tint n = m.length;\n\t\tassert n == m.length;\n\t\tif(n == 0)return new long[0];\n\t\tlong[] gamma = new long[n];\n\t\tfor(int k = 1;k < n;k++){\n\t\t\tlong prod = 1;\n\t\t\tfor(int i = 0;i < k;i++){\n\t\t\t\tprod = prod * m[i] % m[k];\n\t\t\t}\n\t\t\tgamma[k] = invl(prod, m[k]);\n\t\t}\n\t\treturn gamma;\n\t}\n\t\n\tprivate static long[] garnerBatch(int[] u, int[] m, long[] gamma)\n\t{\n\t\tint n = u.length;\n\t\tassert n == m.length;\n\t\tlong[] v = new long[n];\n\t\tv[0] = u[0];\n\t\tfor(int k = 1;k < n;k++){\n\t\t\tlong temp = v[k-1];\n\t\t\tfor(int j = k-2;j >= 0;j--){\n\t\t\t\ttemp = (temp * m[j] + v[j]) % m[k];\n\t\t\t}\n\t\t\tv[k] = (u[k] - temp) * gamma[k] % m[k];\n\t\t\tif(v[k] < 0)v[k] += m[k];\n\t\t}\n\t\treturn v;\n\t}\n\t\n\tprivate static long pow(long a, long n, long mod) {\n\t\t//\t\ta %= mod;\n\t\tlong ret = 1;\n\t\tint x = 63 - Long.numberOfLeadingZeros(n);\n\t\tfor (; x >= 0; x--) {\n\t\t\tret = ret * ret % mod;\n\t\t\tif (n << 63 - x < 0)\n\t\t\t\tret = ret * a % mod;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tprivate static long invl(long a, long mod) {\n\t\ta %= mod;\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\n\t\n\t\n\tpublic static int[][] parents3(int[][] g, int root) {\n\t\tint n = g.length;\n\t\tint[] par = new int[n];\n\t\tArrays.fill(par, -1);\n\n\t\tint[] depth = new int[n];\n\t\tdepth[0] = 0;\n\n\t\tint[] q = new int[n];\n\t\tq[0] = root;\n\t\tfor (int p = 0, r = 1; p < r; p++) {\n\t\t\tint cur = q[p];\n\t\t\tfor (int nex : g[cur]) {\n\t\t\t\tif (par[cur] != nex) {\n\t\t\t\t\tq[r++] = nex;\n\t\t\t\t\tpar[nex] = cur;\n\t\t\t\t\tdepth[nex] = depth[cur] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new int[][] { par, q, depth };\n\t}\n\n\tstatic int[][] packU(int n, int[] from, int[] to) {\n\t\tint[][] g = new int[n][];\n\t\tint[] p = new int[n];\n\t\tfor (int f : from)\n\t\t\tp[f]++;\n\t\tfor (int t : to)\n\t\t\tp[t]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new int[p[i]];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\tg[from[i]][--p[from[i]]] = to[i];\n\t\t\tg[to[i]][--p[to[i]]] = from[i];\n\t\t}\n\t\treturn g;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "C#",
    "code": "#region いつもの\nusing AtCoderProject;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing static AtCoderProject.Global;\nusing BigInteger = System.Numerics.BigInteger;\nusing BitOperations = System.Numerics.BitOperations;\nusing IEnumerable = System.Collections.IEnumerable;\nusing IEnumerator = System.Collections.IEnumerator;\nusing StringBuilder = System.Text.StringBuilder;\nusing Unsafe = System.Runtime.CompilerServices.Unsafe;\n\nnamespace AtCoderProject { using System.IO; using System.Text; using System.Diagnostics; using System.Runtime.CompilerServices; using System.Linq.Expressions; public static class Global { public static T[] NewArray<T>(int len0, T value) => new T[len0].Fill(value); public static T[] NewArray<T>(int len0, Func<T> factory) { var arr = new T[len0]; for (int i = 0; i < arr.Length; i++) arr[i] = factory(); return arr; } public static T[][] NewArray<T>(int len0, int len1, T value) where T : struct { var arr = new T[len0][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, value); return arr; } public static T[][] NewArray<T>(int len0, int len1, Func<T> factory) { var arr = new T[len0][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, factory); return arr; } public static T[][][] NewArray<T>(int len0, int len1, int len2, T value) where T : struct { var arr = new T[len0][][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, len2, value); return arr; } public static T[][][] NewArray<T>(int len0, int len1, int len2, Func<T> factory) { var arr = new T[len0][][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, len2, factory); return arr; } public static T[][][][] NewArray<T>(int len0, int len1, int len2, int len3, T value) where T : struct { var arr = new T[len0][][][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, len2, len3, value); return arr; } public static T[][][][] NewArray<T>(int len0, int len1, int len2, int len3, Func<T> factory) { var arr = new T[len0][][][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, len2, len3, factory); return arr; } public static int Pow(int x, int y) { int res = 1; for (; y > 0; y >>= 1) { if ((y & 1) == 1) res *= x; x *= x; } return res; } public static BigInteger ParseBigInteger(ReadOnlySpan<char> s) { /* 自前実装の方が速い */ BigInteger res; if (s.Length % 9 == 0) res = 0; else { res = new BigInteger(int.Parse(s.Slice(0, s.Length % 9))); s = s.Slice(s.Length % 9); } while (s.Length > 0) { var sp = s.Slice(0, 9); res *= 1000_000_000; res += int.Parse(sp); s = s.Slice(9); } return res; } public static int PopCount(int x) => BitOperations.PopCount((uint)x); public static int PopCount(long x) => BitOperations.PopCount((ulong)x); public static int PopCount(ulong x) => BitOperations.PopCount(x); public static int MSB(int x) => BitOperations.Log2((uint)x); public static int MSB(uint x) => BitOperations.Log2(x); public static int MSB(long x) => BitOperations.Log2((ulong)x); public static int MSB(ulong x) => BitOperations.Log2(x); public static int LSB(int x) => BitOperations.TrailingZeroCount((uint)x); public static int LSB(uint x) => BitOperations.TrailingZeroCount(x); public static int LSB(long x) => BitOperations.TrailingZeroCount((ulong)x); public static int LSB(ulong x) => BitOperations.TrailingZeroCount(x); } public static class Ext { public static bool UpdateMax(this ref int r, int val) { if (r < val) { r = val; return true; } return false; } public static bool UpdateMax(this ref long r, long val) { if (r < val) { r = val; return true; } return false; } public static bool UpdateMin(this ref int r, int val) { if (r > val) { r = val; return true; } return false; } public static bool UpdateMin(this ref long r, long val) { if (r > val) { r = val; return true; } return false; } public static long ToLong(this int i) => i; public static T[] Fill<T>(this T[] arr, T value) { Array.Fill(arr, value); return arr; } public static T[] Sort<T>(this T[] arr) { Array.Sort(arr); return arr; } public static string[] Sort(this string[] arr) => Sort(arr, StringComparer.OrdinalIgnoreCase); public static T[] Sort<T, U>(this T[] arr, Expression<Func<T, U>> selector) where U : IComparable<U> => Sort(arr, new ExpComparer<T, U>(selector)); public static T[] Sort<T>(this T[] arr, Comparison<T> comparison) { Array.Sort(arr, comparison); return arr; } public static T[] Sort<T>(this T[] arr, IComparer<T> comparer) { Array.Sort(arr, comparer); return arr; } public static T[] Reverse<T>(this T[] arr) { Array.Reverse(arr); return arr; } public static (int index, T max) MaxBy<T>(this T[] arr) where T : IComparable<T> { T max = arr[0]; int maxIndex = 0; for (int i = 0; i < arr.Length; i++) { if (max.CompareTo(arr[i]) < 0) { max = arr[i]; maxIndex = i; } } return (maxIndex, max); } public static (TSource item, TMax max) MaxBy<TSource, TMax>(this IEnumerable<TSource> source, Func<TSource, TMax> maxBySelector) where TMax : IComparable<TMax> { TMax max; TSource maxByItem; var e = source.GetEnumerator(); e.MoveNext(); maxByItem = e.Current; max = maxBySelector(maxByItem); while (e.MoveNext()) { var item = e.Current; var next = maxBySelector(item); if (max.CompareTo(next) < 0) { max = next; maxByItem = item; } } return (maxByItem, max); } public static (int index, T min) MinBy<T>(this T[] arr) where T : IComparable<T> { T min = arr[0]; int minIndex = 0; for (int i = 0; i < arr.Length; i++) { if (min.CompareTo(arr[i]) > 0) { min = arr[i]; minIndex = i; } } return (minIndex, min); } public static (TSource item, TMin min) MinBy<TSource, TMin>(this IEnumerable<TSource> source, Func<TSource, TMin> minBySelector) where TMin : IComparable<TMin> { TMin min; TSource minByItem; var e = source.GetEnumerator(); e.MoveNext(); minByItem = e.Current; min = minBySelector(minByItem); while (e.MoveNext()) { var item = e.Current; var next = minBySelector(item); if (min.CompareTo(next) > 0) { min = next; minByItem = item; } } return (minByItem, min); } public static IComparer<T> Reverse<T>(this IComparer<T> comparer) => Comparer<T>.Create((x, y) => comparer.Compare(y, x)); public static Dictionary<TKey, int> GroupCount<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector) => source.GroupBy(keySelector).ToDictionary(g => g.Key, g => g.Count()); public static Dictionary<TKey, int> GroupCount<TKey>(this IEnumerable<TKey> source) => source.GroupCount(i => i); public static ref T Get<T>(this T[] arr, int index) { if (index < 0) return ref arr[arr.Length + index]; return ref arr[index]; } public static TValue Get<TKey, TValue>(this IDictionary<TKey, TValue> dic, TKey key) { dic.TryGetValue(key, out var v); return v; } public static TValue GetOrInit<TKey, TValue>(this IDictionary<TKey, TValue> dic, TKey key, TValue value) { if (dic.TryGetValue(key, out var v)) return v; return dic[key] = value; } } public class ExpComparer<T, K> : IComparer<T> where K : IComparable<K> { private class ParameterReplaceVisitor : ExpressionVisitor { private readonly ParameterExpression from; private readonly ParameterExpression to; public ParameterReplaceVisitor(ParameterExpression from, ParameterExpression to) { this.from = from; this.to = to; } protected override Expression VisitParameter(ParameterExpression node) => node == from ? to : base.VisitParameter(node); } private readonly Func<T, T, int> func; public ExpComparer(Expression<Func<T, K>> expression) { var paramA = expression.Parameters[0]; var paramB = Expression.Parameter(typeof(T)); var f2 = (Expression<Func<T, K>>)new ParameterReplaceVisitor(expression.Parameters[0], paramB).Visit(expression); var compExp = Expression.Lambda<Func<T, T, int>>(Expression.Call(expression.Body, typeof(K).GetMethod(nameof(IComparable<K>.CompareTo), new[] { typeof(K) }), f2.Body), paramA, paramB); this.func = compExp.Compile(); } public int Compare(T x, T y) => func(x, y); public override bool Equals(object obj) => obj != null && GetType() == obj.GetType(); public override int GetHashCode() => GetType().GetHashCode(); } public class ReverseComparer<T> : IComparer<T> where T : IComparable<T> { private static ReverseComparer<T> defaultComparer; public static IComparer<T> Default => defaultComparer ??= new ReverseComparer<T>(); public int Compare(T y, T x) => x.CompareTo(y); public override bool Equals(object obj) => obj != null && GetType() == obj.GetType(); public override int GetHashCode() => GetType().GetHashCode(); } public class ΔDebugView<T> { private IEnumerable<T> collection; public ΔDebugView(IEnumerable<T> collection) { this.collection = collection ?? throw new ArgumentNullException(nameof(collection)); }[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)] public T[] Items => collection.ToArray(); }[DebuggerStepThrough] public class ConsoleReader { const int BufSize = 1 << 12; private readonly byte[] buffer = new byte[BufSize]; private readonly Stream input; private readonly Encoding encoding; private int pos = 0; private int len = 0; public ConsoleReader(Stream input, Encoding encoding) { this.input = input; this.encoding = encoding; } public ConsoleReader(Stream input) : this(input, Console.InputEncoding) { } private void MoveNext() { if (++pos >= len) { len = input.Read(buffer, 0, buffer.Length); if (len == 0) { buffer[0] = 10; } pos = 0; } } public int Int { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { int res = 0; bool neg = false; while (buffer[pos] < 48) { neg = buffer[pos] == 45; MoveNext(); } do { res = checked(res * 10 + (buffer[pos] ^ 48)); MoveNext(); } while (48 <= buffer[pos]); return neg ? -res : res; } } public int Int0 => this.Int - 1; public long Long { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { long res = 0; bool neg = false; while (buffer[pos] < 48) { neg = buffer[pos] == 45; MoveNext(); } do { res = res * 10 + (buffer[pos] ^ 48); MoveNext(); } while (48 <= buffer[pos]); return neg ? -res : res; } } public long Long0 => this.Long - 1; public string String { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { var sb = new List<byte>(); while (buffer[pos] <= 32) MoveNext(); do { sb.Add(buffer[pos]); MoveNext(); } while (32 < buffer[pos]); return this.encoding.GetString(sb.ToArray()); } } public string Ascii { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { var sb = new StringBuilder(); while (buffer[pos] <= 32) MoveNext(); do { sb.Append((char)buffer[pos]); MoveNext(); } while (32 < buffer[pos]); return sb.ToString(); } } public string Line { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { var sb = new List<byte>(); while (buffer[pos] <= 32) MoveNext(); do { sb.Add(buffer[pos]); MoveNext(); } while (buffer[pos] != 10 && buffer[pos] != 13); return this.encoding.GetString(sb.ToArray()); } } public char Char { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { while (buffer[pos] <= 32) MoveNext(); char res = (char)buffer[pos]; MoveNext(); return res; } } public double Double => double.Parse(this.Ascii);[DebuggerStepThrough] public struct RepeatReader { ConsoleReader cr; int count; public RepeatReader(ConsoleReader cr, int count) { this.cr = cr; this.count = count; } public T[] Select<T>(Func<ConsoleReader, T> factory) { var arr = new T[count]; for (var i = 0; i < count; i++) arr[i] = factory(cr); return arr; } public T[] Select<T>(Func<ConsoleReader, int, T> factory) { var arr = new T[count]; for (var i = 0; i < count; i++) arr[i] = factory(cr, i); return arr; } public string[] Line { get { var arr = new string[count]; for (var i = 0; i < count; i++) arr[i] = cr.Line; return arr; } } public string[] String { get { var arr = new string[count]; for (var i = 0; i < count; i++) arr[i] = cr.String; return arr; } } public string[] Ascii { get { var arr = new string[count]; for (var i = 0; i < count; i++) arr[i] = cr.Ascii; return arr; } } public int[] Int { get { var arr = new int[count]; for (var i = 0; i < count; i++) arr[i] = cr.Int; return arr; } } public int[] Int0 { get { var arr = new int[count]; for (var i = 0; i < count; i++) arr[i] = cr.Int0; return arr; } } public long[] Long { get { var arr = new long[count]; for (var i = 0; i < count; i++) arr[i] = cr.Long; return arr; } } public long[] Long0 { get { var arr = new long[count]; for (var i = 0; i < count; i++) arr[i] = cr.Long0; return arr; } } public double[] Double { get { var arr = new double[count]; for (var i = 0; i < count; i++) arr[i] = cr.Double; return arr; } } public static implicit operator int[](RepeatReader rr) => rr.Int; public static implicit operator long[](RepeatReader rr) => rr.Long; public static implicit operator double[](RepeatReader rr) => rr.Double; public static implicit operator string[](RepeatReader rr) => rr.Ascii; } public RepeatReader Repeat(int count) => new RepeatReader(this, count);[DebuggerStepThrough] public struct SplitReader { ConsoleReader cr; public SplitReader(ConsoleReader cr) { this.cr = cr; } public string[] String { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<string>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.String); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public string[] Ascii { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<string>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Ascii); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public int[] Int { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<int>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Int); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public int[] Int0 { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<int>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Int0); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public long[] Long { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<long>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Long); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public long[] Long0 { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<long>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Long0); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public double[] Double { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<double>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Double); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public static implicit operator int[](SplitReader sr) => sr.Int; public static implicit operator long[](SplitReader sr) => sr.Long; public static implicit operator double[](SplitReader sr) => sr.Double; public static implicit operator string[](SplitReader sr) => sr.Ascii; } public SplitReader Split => new SplitReader(this); public static implicit operator int(ConsoleReader cr) => cr.Int; public static implicit operator long(ConsoleReader cr) => cr.Long; public static implicit operator double(ConsoleReader cr) => cr.Double; public static implicit operator string(ConsoleReader cr) => cr.Ascii; public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2) => (o1, o2) = (this, this); public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2, out ConsoleReader o3) => (o1, o2, o3) = (this, this, this); public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2, out ConsoleReader o3, out ConsoleReader o4) => (o1, o2, o3, o4) = (this, this, this, this); public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2, out ConsoleReader o3, out ConsoleReader o4, out ConsoleReader o5) => (o1, o2, o3, o4, o5) = (this, this, this, this, this); public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2, out ConsoleReader o3, out ConsoleReader o4, out ConsoleReader o5, out ConsoleReader o6) => (o1, o2, o3, o4, o5, o6) = (this, this, this, this, this, this); public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2, out ConsoleReader o3, out ConsoleReader o4, out ConsoleReader o5, out ConsoleReader o6, out ConsoleReader o7) => (o1, o2, o3, o4, o5, o6, o7) = (this, this, this, this, this, this, this); public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2, out ConsoleReader o3, out ConsoleReader o4, out ConsoleReader o5, out ConsoleReader o6, out ConsoleReader o7, out ConsoleReader o8) => (o1, o2, o3, o4, o5, o6, o7, o8) = (this, this, this, this, this, this, this, this); }[DebuggerStepThrough] public class ConsoleWriter {[DebuggerBrowsable(DebuggerBrowsableState.Never)] public readonly StreamWriter sw; public ConsoleWriter(Stream output) : this(output, Console.OutputEncoding) { } public ConsoleWriter(Stream output, Encoding encoding) { sw = new StreamWriter(output, encoding); } public void Flush() => sw.Flush(); public ConsoleWriter WriteLine(ReadOnlySpan<char> obj) { sw.WriteLine(obj); return this; } public ConsoleWriter WriteLine<T>(T obj) { sw.WriteLine(obj.ToString()); return this; } public ConsoleWriter WriteLineJoin<T>(ReadOnlySpan<T> col) => WriteMany(' ', col); public ConsoleWriter WriteLineJoin<T>(IEnumerable<T> col) => WriteMany(' ', col); public ConsoleWriter WriteLines<T>(ReadOnlySpan<T> col) => WriteMany('\\n', col); public ConsoleWriter WriteLines<T>(IEnumerable<T> col) => WriteMany('\\n', col); public ConsoleWriter WriteLineGrid<T>(IEnumerable<IEnumerable<T>> cols) { var en = cols.GetEnumerator(); while (en.MoveNext()) WriteLineJoin(en.Current); return this; } private ConsoleWriter WriteMany<T>(char sep, ReadOnlySpan<T> col) { var en = col.GetEnumerator(); if (!en.MoveNext()) return this; sw.Write(en.Current.ToString()); while (en.MoveNext()) { sw.Write(sep); sw.Write(en.Current.ToString()); } sw.WriteLine(); return this; } private ConsoleWriter WriteMany<T>(char sep, IEnumerable<T> col) { var en = col.GetEnumerator(); if (!en.MoveNext()) return this; sw.Write(en.Current.ToString()); while (en.MoveNext()) { sw.Write(sep); sw.Write(en.Current.ToString()); } sw.WriteLine(); return this; } } }\npublic partial class Program {[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)] public ConsoleReader cr;[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)] public ConsoleWriter cw; public Program(ConsoleReader reader, ConsoleWriter writer) { this.cr = reader; this.cw = writer; System.Globalization.CultureInfo.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture; } static void Main() => new Program(new ConsoleReader(Console.OpenStandardInput()), new ConsoleWriter(Console.OpenStandardOutput())).Run(); public void Run() { var res = Calc(); if (res is double) cw.WriteLine(Result((double)res)); else if (res is bool) cw.WriteLine(Result((bool)res)); else if (res != null) cw.WriteLine(res.ToString()); cw.Flush(); } }\npublic partial class Program\n{\n    public static string Result(double d) => d.ToString(\"0.####################\", System.Globalization.CultureInfo.InvariantCulture);\n    #endregion\n    public static string Result(bool b) => b ? \"Yes\" : \"No\";\n    private object Calc()\n    {\n        N = cr;\n        var gb = new GraphBuilder(N, cr, N - 1, false);\n        var tmpTree = gb.ToTree(gb.ToTree(0).MaxBy(t => t.depth).item.index);\n        TreeNode cur;\n        (cur, L) = tmpTree.MaxBy(t => t.depth);\n        for (int i = L / 2; i > 0; i--) cur = tmpTree[cur.root];\n        tree = gb.ToTree(root = cur.index);\n\n        dp = NewArray(N, 3, 3, default(Mod));\n        if (L % 2 == 1)\n        {\n            other = cur.root;\n            tree[root].children = tree[root].children.Where(i => i != other).ToArray();\n            Dfs(root, L / 2);\n            Dfs(other, L / 2);\n            return dp[root][1].Sum() * dp[other][1].Sum();\n        }\n        else\n        {\n            Dfs(root, L / 2);\n            return dp[root][1][1] / 2;\n        }\n    }\n    void Dfs(int v, int len)\n    {\n        if (len == 0) dp[v][1][1] = 1;\n        else dp[v][0][0] = 1;\n\n        foreach (var child in tree[v].children)\n        {\n            Dfs(child, len - 1);\n            var nx = NewArray(3, 3, default(Mod));\n            for (int a1 = 0; a1 < 3; a1++)\n                for (int a2 = 0; a2 < 3; a2++)\n                {\n                    for (int b1 = 0; b1 < 3; b1++)\n                        for (int b2 = 0; b2 < 3; b2++)\n                        {\n                            nx[Math.Min(a1 + b1, 2)][a2] += dp[v][a1][a2] * dp[child][b1][b2];\n                            nx[a1][a2] += dp[v][a1][a2] * dp[child][b1][b2];\n                            nx[a1][Math.Min(a2 + b2, 2)] += dp[v][a1][a2] * dp[child][b1][b2];\n                        }\n\n                }\n            for (int a1 = 0; a1 < 3; a1++)\n                for (int a2 = 0; a2 < 3; a2++)\n                    dp[v][a1][a2] = nx[a1][a2];\n        }\n    }\n\n    Mod[][][] dp;\n    int N;\n    int L;\n    int root;\n    int other;\n    TreeNode[] tree;\n}\n\nreadonly struct Mod : IEquatable<Mod> { public const long mod = 998244353; public static readonly Mod invalid = new Mod(-1, false); public readonly long val; private Mod(long val, bool isValid) : this(val) { if (!isValid) this.val = val; } public Mod(long val) { this.val = val % mod; if (this.val < 0) this.val += mod; } public override bool Equals(object obj) => (obj is Mod) && this == ((Mod)obj); public bool Equals(Mod obj) => this.val == obj.val; public override int GetHashCode() => val.GetHashCode(); public override string ToString() => val.ToString(); public static implicit operator Mod(long x) => new Mod(x); public static implicit operator Mod(ConsoleReader cr) => new Mod(cr.Long); public static Mod operator -(Mod x) => new Mod(-x.val); public static Mod operator +(Mod x, Mod y) => new Mod(x.val + y.val); public static Mod operator -(Mod x, Mod y) => new Mod(x.val - y.val); public static Mod operator *(Mod x, Mod y) => new Mod(x.val * y.val); public static Mod operator /(Mod x, Mod y) => x * y.Inverse(); public static bool operator ==(Mod x, Mod y) => x.val == y.val; public static bool operator !=(Mod x, Mod y) => x.val != y.val; public Mod Inverse() { long a = val, b = mod, u = 1, v = 0; while (b > 0) { long t = a / b; var b2 = a - t * b; a = b; b = b2; var v2 = u - t * v; u = v; v = v2; } u %= mod; if (u < 0) u += mod; return u; } public static Mod Pow(Mod x, int y) { Mod res = 1; for (; y > 0; y >>= 1) { if ((y & 1) == 1) res *= x; x *= x; } return res; } public static Factor CreateFactor(int max) => new Factor(max); public class Factor { private readonly Mod[] fac, finv; public Factor(int max) { ++max; var inv = new Mod[max]; fac = new Mod[max]; finv = new Mod[max]; fac[0] = fac[1] = 1; finv[0] = finv[1] = 1; inv[1] = 1; for (var i = 2; i < max; i++) { fac[i] = fac[i - 1] * i; inv[i] = mod - inv[mod % i].val * (mod / i) % mod; finv[i] = finv[i - 1] * inv[i]; } } /** <summary>組み合わせ関数(二項係数)</summary> */ public Mod Combine(int n, int k) { if (n < k) return 0; if (n < 0 || k < 0) return 0; return fac[n] * finv[k] * finv[n - k]; } public Mod Factorial(int n) => fac[n]; public Mod FactorialInvers(int n) => finv[n]; } }\nstatic class ModExt { public static Mod Sum(this IEnumerable<Mod> source) { Mod sum = 0; foreach (var v in source) sum += v; return sum; } }\nclass GraphBuilder { private List<int>[] roots; private List<int>[] children; public GraphBuilder(int count, bool isOriented) { this.roots = new List<int>[count]; this.children = new List<int>[count]; for (var i = 0; i < count; i++) { if (isOriented) { this.roots[i] = new List<int>(); this.children[i] = new List<int>(); } else { this.roots[i] = this.children[i] = new List<int>(); } } } public GraphBuilder(int count, ConsoleReader cr, int edgeCount, bool isOriented) : this(count, isOriented) { for (var i = 0; i < edgeCount; i++) this.Add(cr.Int0, cr.Int0); } public void Add(int from, int to) { children[from].Add(to); roots[to].Add(from); } public TreeNode[] ToTree(int root) { if (this.roots[0] != this.children[0]) throw new Exception(\"木には無向グラフをしたほうが良い\"); var res = new TreeNode[this.children.Length]; res[root] = new TreeNode(root, -1, 0, this.children[root].ToArray()); var queue = new Queue<int>(); foreach (var child in res[root].children) { res[child] = new TreeNode(child, root, 1, Array.Empty<int>()); queue.Enqueue(child); } while (queue.Count > 0) { var from = queue.Dequeue(); if (res[from].root == -1) res[from].children = this.children[from].ToArray(); else { var children = new List<int>(this.children[from].Count); foreach (var c in this.children[from]) if (c != res[from].root) children.Add(c); res[from].children = children.ToArray(); } foreach (var child in res[from].children) { res[child] = new TreeNode(child, from, res[from].depth + 1, Array.Empty<int>()); queue.Enqueue(child); } } return res; } public Node[] ToArray() => Enumerable.Zip(roots, children, (root, child) => (root, child)).Select((t, i) => new Node(i, t.root.ToArray(), t.child.ToArray())).ToArray(); public GraphBuilder Clone() { var count = this.roots.Length; var isOriented = this.roots[0] != this.children[0]; var cl = new GraphBuilder(count, isOriented); for (int i = 0; i < count; i++) { if (isOriented) { cl.children[i] = this.children[i].ToList(); cl.roots[i] = this.roots[i].ToList(); } else cl.children[i] = cl.roots[i] = this.roots[i].ToList(); } return cl; } }\nclass TreeNode { public TreeNode(int i, int root, int depth, int[] children) { this.index = i; this.root = root; this.children = children; this.depth = depth; } public readonly int index; public readonly int root; public readonly int depth; public int[] children; public override string ToString() => $\"children: {string.Join(\",\", children)}\"; public override bool Equals(object obj) { if (obj is TreeNode) return this.Equals((TreeNode)obj); else return false; } public bool Equals(TreeNode other) => this.index == other.index; public override int GetHashCode() => this.index; }\nclass Node { public Node(int i, int[] roots, int[] children) { this.index = i; this.roots = roots; this.children = children; } public readonly int index; public readonly int[] roots; public readonly int[] children; public override string ToString() => $\"children: {string.Join(\",\", children)}\"; public override bool Equals(object obj) { if (obj is Node) return this.Equals((Node)obj); else return false; } public bool Equals(Node other) => this.index == other.index; public override int GetHashCode() => this.index; }\nclass LowestCommonAncestor { private TreeNode[] tree; /** <summary> *  kprv[u][k] 頂点uの2^k個上の祖先頂点v, 0<=k<logN *  </summary> */ private int[][] kprv; private int logN; public LowestCommonAncestor(TreeNode[] tree) { if (tree.Length == 0) throw new ArgumentException(nameof(tree)); this.tree = tree; this.logN = MSB(tree.Length) + 1; this.kprv = NewArray(tree.Length, logN, 0); for (int v = 0; v < tree.Length; v++) { this.kprv[v][0] = tree[v].root; } for (int k = 0; k < logN - 1; k++) { for (int v = 0; v < tree.Length; v++) { if (this.kprv[v][k] < 0) this.kprv[v][k + 1] = -1; else this.kprv[v][k + 1] = this.kprv[this.kprv[v][k]][k]; } } } public int Lca(int u, int v) { if (Depth(u) > Depth(v)) { (u, v) = (v, u); } for (int k = 0; k <= logN; k++) { if ((((Depth(v) - Depth(u)) >> k) & 1) == 1) { v = kprv[v][k]; } } if (u == v) return u; for (int k = logN - 1; k >= 0; k--) { if (kprv[u][k] != kprv[v][k] && kprv[u][k] != -1 && kprv[v][k] != -1) { u = kprv[u][k]; v = kprv[v][k]; } } return kprv[u][0]; } int Depth(int index) => tree[index].depth; }\n"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n#}}}\n\nconst MOD = 998244353\nvar N:int\nvar a:seq[int]\nvar b:seq[int]\n\n#{{{ input part\nproc main()\nblock:\n  N = nextInt()\n  a = newSeqWith(N-1, 0)\n  b = newSeqWith(N-1, 0)\n  for i in 0..<N-1:\n    a[i] = nextInt() - 1\n    b[i] = nextInt() - 1\n#}}}\n\n#{{{ ModInt[Mod]\nproc getDefault(T:typedesc): T = (var temp:T;temp)\nproc getDefault[T](x:T): T = (var temp:T;temp)\n\ntype ModInt[Mod: static[int]] = object\n  v:int\nproc initModInt[T](a:T, Mod: static[int]):ModInt[Mod] =\n  when T is ModInt[Mod]:\n    return a\n  else:\n    var a = a\n    a = a mod Mod\n    if a < 0: a += Mod\n    result.v = a\nproc initModInt[T](a:T):ModInt[Mod] = initModInt(a, MOD)\nproc init[T](self:ModInt[Mod], a:T):ModInt[Mod] = initModInt(a, Mod)\nproc Identity(self:ModInt[Mod]):ModInt[Mod] = return initModInt(1, Mod)\n\nproc `==`[T](a:ModInt[Mod], b:T):bool = a.v == a.init(b).v\nproc `!=`[T](a:ModInt[Mod], b:T):bool = a.v != a.init(b).v\nproc `-`(self:ModInt[Mod]):ModInt[Mod] =\n  if self.v == 0: return self\n  else: return ModInt[Mod](v:MOD - self.v)\nproc `$`(a:ModInt[Mod]):string = return $(a.v)\n\nproc `+=`[T](self:var ModInt[Mod]; a:T):void =\n  self.v += initModInt(a, Mod).v\n  if self.v >= MOD: self.v -= MOD\nproc `-=`[T](self:var ModInt[Mod],a:T):void =\n  self.v -= initModInt(a, Mod).v\n  if self.v < 0: self.v += MOD\nproc `*=`[T](self:var ModInt[Mod],a:T):void =\n  self.v *= initModInt(a, Mod).v\n  self.v = self.v mod MOD\nproc `^=`(self:var ModInt[Mod], n:int) =\n  var (x,n,a) = (self,n,self.Identity)\n  while n > 0:\n    if (n and 1) > 0: a *= x\n    x *= x\n    n = (n shr 1)\n  swap(self, a)\nproc inverse(x:int):ModInt[Mod] =\n  var (a, b) = (x, MOD)\n  var (u, v) = (1, 0)\n  while b > 0:\n    let t = a div b\n    a -= t * b;swap(a,b)\n    u -= t * v;swap(u,v)\n  return initModInt(u, Mod)\nproc `/=`[T](a:var ModInt[Mod],b:T):void = a *= initModInt(b, Mod).v.inverse()\nproc `+`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result += b\nproc `-`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result -= b\nproc `*`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result *= b\nproc `/`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a; result /= b\nproc `^`(a:ModInt[Mod],b:int):ModInt[Mod] = result = a; result ^= b\n#}}}\n\ntype Mint = ModInt[Mod]\nproc initMint[T](a:T):ModInt[Mod] = initModInt(a, Mod)\n\n#{{{ Graph\nimport sequtils\n\ntype\n  Edge[T] = object\n    src,dst:int\n    weight:T\n    rev:int\n  Edges[T] = seq[Edge[T]]\n  Graph[T] = seq[seq[Edge[T]]]\n\nproc initEdge[T](src,dst:int,weight:T,rev:int = -1):Edge[T] =\n  var e:Edge[T]\n  e.src = src\n  e.dst = dst\n  e.weight = weight\n  e.rev = rev\n  return e\n\nproc initGraph[T](n:int):Graph[T] =\n  return newSeqWith(n,newSeq[Edge[T]]())\n\nproc addBiEdge[T](g:var Graph[T],e:Edge[T]):void =\n  var e_rev = e\n  swap(e_rev.src, e_rev.dst)\n  let (r, s) = (g[e.src].len, g[e.dst].len)\n  g[e.src].add(e)\n  g[e.dst].add(e_rev)\n  g[e.src][^1].rev = s\n  g[e.dst][^1].rev = r\nproc addBiEdge[T](g:var Graph[T],src,dst:int,weight:T=1):void =\n  g.addBiEdge(initEdge(src, dst, weight))\n\nproc initUndirectedGraph[T](n:int, a,b,c:seq[T]):Graph[T] =\n  var result = initGraph[T](n)\n  for i in 0..<a.len: result.addBiEdge(a[i], b[i], c[i])\nproc initUndirectedGraph[T](n:int, a,b:seq[T]):Graph[T] =\n  result = initGraph[T](n)\n  for i in 0..<a.len: result.addBiEdge(a[i], b[i], T(1))\nproc initGraph[T](n:int, a,b,c:seq[T]):Graph[T] =\n  var result = initGraph[T](n)\n  for i in 0..<a.len: result.addEdge(a[i], b[i], c[i])\nproc initGraph[T](n:int, a,b:seq[T]):Graph[T] =\n  result = initGraph[T](n)\n  for i in 0..<a.len: result.addEdge(a[i], b[i], T(1))\n\n\nproc addEdge[T](g:var Graph[T],e:Edge[T]):void =\n  g[e.src].add(e)\nproc addEdge[T](g:var Graph[T],src,dst:int,weight:T=1):void =\n  g.addEdge(initEdge(src, dst, weight, -1))\n\nproc `<`[T](l,r:Edge[T]):bool = l.weight < r.weight\n#}}}\n\nvar p1:int\n\nproc treeDiameter[T](g:Graph[T]):int =\n  proc dfs(idx, par:int):(T,int) =\n    result[1] = idx\n    for e in g[idx]:\n      if e.dst == par: continue\n      var cost = dfs(e.dst, idx)\n      cost[0] += e.weight\n      result = max(result, cost)\n  let\n    p = dfs(0, -1)\n    q = dfs(p[1], -1)\n  p1 = p[1]\n  return q[0]\n\n# depth first search {{{\nvar v = newSeq[int]()\nproc dfs0[T](g:Graph[T], u:int, p:int, h:int):bool =\n  if h == 0: return true\n  for e in g[u]:\n    if e.dst == p: continue\n    v.add(e.dst)\n    if g.dfs0(e.dst, u, h - 1): return true\n    discard v.pop()\n  return false\n#}}}\n\nvar max_depth = newSeq[int](N)\nvar size = newSeq[int](N)\n\nproc dfs1[T](g:Graph[T], u:int, p = -1, depth = 0):void =\n  max_depth[u] = depth\n  size[u] = 1\n  for e in g[u]:\n    if e.dst == p: continue\n    g.dfs1(e.dst, u, depth + 1)\n    max_depth[u] .max= max_depth[e.dst]\n    size[u] += size[e.dst]\n\nvar target_depth:int\n\nproc dfs2[T](g:Graph[T], u:int, p = -1, depth = 0):(Mint,Mint) =\n  if g[u].len == 1:\n    if depth == target_depth:\n      return (initMint(0), initMint(1))\n    else:\n      return (initMint(1), initMint(0))\n  result = (initMint(1), initMint(0))\n  for e in g[u]:\n    if e.dst == p: continue\n    let a = g.dfs2(e.dst, u, depth + 1)\n    if max_depth[e.dst] == target_depth:\n      var result2:(Mint,Mint)\n      # make e critical\n      result2[0] += result[0] * a[0]\n#      result2[1] += result[1] * t + result[0] * (t - a[0])\n      result2[1] += result[0] * a[1] + result[1] * a[0]\n      # make e non critical\n      let d = initMint(2) * initMint(3)^(size[e.dst] - 1)\n      result2[0] += result[0] * d\n      result2[1] += result[1] * d\n      swap(result, result2)\n    else:\n      # always non critical\n      let d = initMint(3)^size[e.dst]\n      result[0] *= d\n      result[1] *= d\n\nproc main() =\n  g := initUndirectedGraph[int](N, a, b)\n  let d = g.treeDiameter\n  v.add(p1)\n  assert g.dfs0(p1, -1, d)\n  target_depth = d div 2\n  if d mod 2 == 0:\n    let c = v[d div 2]\n    g.dfs1(c)\n    dp := newSeq[Mint](3)\n    dp[0] = initMint(1)\n    for e in g[c]:\n      let v0 = g.dfs2(e.dst, c, 1)\n      if max_depth[e.dst] < target_depth:\n        for b in 0..<dp.len: dp[b] *= initMint(3) * v0[0]\n      else:\n        dp2 := newSeq[Mint](3)\n        for b in 0..<dp.len:\n          # make e critical\n          if b < 2:\n            dp2[b + 1] += dp[b] * v0[1]\n            dp2[b] += dp[b] * v0[0]\n          # non critical\n          dp2[b] += dp[b] * initMint(2) * initMint(3)^(size[e.dst] - 1)\n        swap(dp, dp2)\n    echo dp[2]\n  else:\n    let\n      c0 = v[d div 2]\n      c1 = v[d div 2 + 1]\n    g.dfs1(c0, c1)\n    g.dfs1(c1, c0)\n    let\n      v0 = g.dfs2(c0, c1)\n      v1 = g.dfs2(c1, c0)\n    echo v0[1] * v1[1]\n  return\n\nmain()\n"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n#}}}\n\nconst MOD = 998244353\nvar N:int\nvar a:seq[int]\nvar b:seq[int]\n\n#{{{ input part\nproc main()\nblock:\n  N = nextInt()\n  a = newSeqWith(N-1, 0)\n  b = newSeqWith(N-1, 0)\n  for i in 0..<N-1:\n    a[i] = nextInt() - 1\n    b[i] = nextInt() - 1\n#}}}\n\n#{{{ ModInt[Mod]\nproc getDefault(T:typedesc): T = (var temp:T;temp)\nproc getDefault[T](x:T): T = (var temp:T;temp)\n\ntype ModInt[Mod: static[int]] = object\n  v:int\nproc initModInt[T](a:T, Mod: static[int]):ModInt[Mod] =\n  when T is ModInt[Mod]:\n    return a\n  else:\n    var a = a\n    a = a mod Mod\n    if a < 0: a += Mod\n    result.v = a\nproc initModInt[T](a:T):ModInt[Mod] = initModInt(a, MOD)\nproc init[T](self:ModInt[Mod], a:T):ModInt[Mod] = initModInt(a, Mod)\nproc Identity(self:ModInt[Mod]):ModInt[Mod] = return initModInt(1, Mod)\n\nproc `==`[T](a:ModInt[Mod], b:T):bool = a.v == a.init(b).v\nproc `!=`[T](a:ModInt[Mod], b:T):bool = a.v != a.init(b).v\nproc `-`(self:ModInt[Mod]):ModInt[Mod] =\n  if self.v == 0: return self\n  else: return ModInt[Mod](v:MOD - self.v)\nproc `$`(a:ModInt[Mod]):string = return $(a.v)\n\nproc `+=`[T](self:var ModInt[Mod]; a:T):void =\n  self.v += initModInt(a, Mod).v\n  if self.v >= MOD: self.v -= MOD\nproc `-=`[T](self:var ModInt[Mod],a:T):void =\n  self.v -= initModInt(a, Mod).v\n  if self.v < 0: self.v += MOD\nproc `*=`[T](self:var ModInt[Mod],a:T):void =\n  self.v *= initModInt(a, Mod).v\n  self.v = self.v mod MOD\nproc `^=`(self:var ModInt[Mod], n:int) =\n  var (x,n,a) = (self,n,self.Identity)\n  while n > 0:\n    if (n and 1) > 0: a *= x\n    x *= x\n    n = (n shr 1)\n  swap(self, a)\nproc inverse(x:int):ModInt[Mod] =\n  var (a, b) = (x, MOD)\n  var (u, v) = (1, 0)\n  while b > 0:\n    let t = a div b\n    a -= t * b;swap(a,b)\n    u -= t * v;swap(u,v)\n  return initModInt(u, Mod)\nproc `/=`[T](a:var ModInt[Mod],b:T):void = a *= initModInt(b, Mod).v.inverse()\nproc `+`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result += b\nproc `-`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result -= b\nproc `*`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result *= b\nproc `/`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a; result /= b\nproc `^`(a:ModInt[Mod],b:int):ModInt[Mod] = result = a; result ^= b\n#}}}\n\ntype Mint = ModInt[Mod]\nproc initMint[T](a:T):ModInt[Mod] = initModInt(a, Mod)\n\n#{{{ Graph\nimport sequtils\n\ntype\n  Edge[T] = object\n    src,dst:int\n    weight:T\n    rev:int\n  Edges[T] = seq[Edge[T]]\n  Graph[T] = seq[seq[Edge[T]]]\n\nproc initEdge[T](src,dst:int,weight:T,rev:int = -1):Edge[T] =\n  var e:Edge[T]\n  e.src = src\n  e.dst = dst\n  e.weight = weight\n  e.rev = rev\n  return e\n\nproc initGraph[T](n:int):Graph[T] =\n  return newSeqWith(n,newSeq[Edge[T]]())\n\nproc addBiEdge[T](g:var Graph[T],e:Edge[T]):void =\n  var e_rev = e\n  swap(e_rev.src, e_rev.dst)\n  let (r, s) = (g[e.src].len, g[e.dst].len)\n  g[e.src].add(e)\n  g[e.dst].add(e_rev)\n  g[e.src][^1].rev = s\n  g[e.dst][^1].rev = r\nproc addBiEdge[T](g:var Graph[T],src,dst:int,weight:T=1):void =\n  g.addBiEdge(initEdge(src, dst, weight))\n\nproc initUndirectedGraph[T](n:int, a,b,c:seq[T]):Graph[T] =\n  var result = initGraph[T](n)\n  for i in 0..<a.len: result.addBiEdge(a[i], b[i], c[i])\nproc initUndirectedGraph[T](n:int, a,b:seq[T]):Graph[T] =\n  result = initGraph[T](n)\n  for i in 0..<a.len: result.addBiEdge(a[i], b[i], T(1))\nproc initGraph[T](n:int, a,b,c:seq[T]):Graph[T] =\n  var result = initGraph[T](n)\n  for i in 0..<a.len: result.addEdge(a[i], b[i], c[i])\nproc initGraph[T](n:int, a,b:seq[T]):Graph[T] =\n  result = initGraph[T](n)\n  for i in 0..<a.len: result.addEdge(a[i], b[i], T(1))\n\n\nproc addEdge[T](g:var Graph[T],e:Edge[T]):void =\n  g[e.src].add(e)\nproc addEdge[T](g:var Graph[T],src,dst:int,weight:T=1):void =\n  g.addEdge(initEdge(src, dst, weight, -1))\n\nproc `<`[T](l,r:Edge[T]):bool = l.weight < r.weight\n#}}}\n\nvar p1:int\n\nproc treeDiameter[T](g:Graph[T]):int =\n  proc dfs(idx, par:int):(T,int) =\n    result[1] = idx\n    for e in g[idx]:\n      if e.dst == par: continue\n      var cost = dfs(e.dst, idx)\n      cost[0] += e.weight\n      result = max(result, cost)\n  let\n    p = dfs(0, -1)\n    q = dfs(p[1], -1)\n  p1 = p[1]\n  return q[0]\n\n# depth first search {{{\nvar v = newSeq[int]()\nproc dfs0[T](g:Graph[T], u:int, p:int, h:int):bool =\n  if h == 0: return true\n  for e in g[u]:\n    if e.dst == p: continue\n    v.add(e.dst)\n    if g.dfs0(e.dst, u, h - 1): return true\n    discard v.pop()\n  return false\n#}}}\n\nvar max_depth = newSeq[int](N)\nvar size = newSeq[int](N)\n\nproc dfs1[T](g:Graph[T], u:int, p = -1, depth = 0):void =\n  max_depth[u] = depth\n  size[u] = 1\n  for e in g[u]:\n    if e.dst == p: continue\n    g.dfs1(e.dst, u, depth + 1)\n    max_depth[u] .max= max_depth[e.dst]\n    size[u] += size[e.dst]\n\nvar target_depth:int\n\nproc dfs2[T](g:Graph[T], u:int, p = -1, depth = 0):(Mint,Mint) =\n  if g[u].len == 1:\n    if depth == target_depth:\n      return (initMint(0), initMint(1))\n    else:\n      return (initMint(1), initMint(0))\n  result = (initMint(1), initMint(0))\n  for e in g[u]:\n    if e.dst == p: continue\n    let a = g.dfs2(e.dst, u, depth + 1)\n    if max_depth[e.dst] == target_depth:\n      var result2:(Mint,Mint)\n      # make e critical\n      result2[0] += result[0] * a[0]\n#      result2[1] += result[1] * t + result[0] * (t - a[0])\n      result2[1] += result[0] * a[1] + result[1] * a[0]\n      # make e non critical\n      let d = initMint(2) * initMint(3)^(size[e.dst] - 1)\n      result2[0] += result[0] * d\n      result2[1] += result[1] * d\n      swap(result, result2)\n    else:\n      # always non critical\n      let d = initMint(3)^size[e.dst]\n      result[0] *= d\n      result[1] *= d\n\nproc main() =\n  g := initUndirectedGraph[int](N, a, b)\n  let d = g.treeDiameter\n  v.add(p1)\n  discard g.dfs0(p1, -1, d)\n  target_depth = d div 2\n  if d mod 2 == 0:\n    let c = v[d div 2]\n    g.dfs1(c)\n    dp := newSeq[Mint](3)\n    dp[0] = initMint(1)\n    for e in g[c]:\n      let v0 = g.dfs2(e.dst, c, 1)\n      if max_depth[e.dst] < target_depth:\n        for b in 0..<dp.len: dp[b] *= initMint(3) * v0[0]\n      else:\n        dp2 := newSeq[Mint](3)\n        for b in 0..<dp.len:\n          # make e critical\n          if b < 2:\n            dp2[b + 1] += dp[b] * v0[1]\n          dp2[b] += dp[b] * v0[0]\n          # make e non critical\n          dp2[b] += dp[b] * initMint(2) * initMint(3)^(size[e.dst] - 1)\n        swap(dp, dp2)\n    echo dp[2]\n  else:\n    assert(false)\n    let\n      c0 = v[d div 2]\n      c1 = v[d div 2 + 1]\n    g.dfs1(c0, c1)\n    g.dfs1(c1, c0)\n    let\n      v0 = g.dfs2(c0, c1)\n      v1 = g.dfs2(c1, c0)\n    echo v0[1] * v1[1]\n  return\n\nmain()"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n#}}}\n\n#{{{ bitutils\nproc bits[B:SomeInteger](v:varargs[int]): B =\n  result = 0\n  for x in v: result = (result or (B(1) shl B(x)))\nproc `[]`[B:SomeInteger](b:B,n:int):int = (b shr n) mod 2\nproc `[]`[B:SomeInteger](b:B,s:Slice[int]):int = (b shr s.a) mod (1 shl (s.b - s.a + 1))\nproc test[B:SomeInteger](b:B,n:int):bool = (if b[n] == 1:true else: false)\nproc set[B:SomeInteger](b:var B,n:int) = b = (b or (B(1) shl B(n)))\nproc unset[B:SomeInteger](b:var B,n:int) = b = (b and (not (B(1) shl B(n))))\nproc `[]=`[B:SomeInteger](b:var B,n:int,t:int) =\n  if t == 0: b.unset(n)\n  elif t == 1: b.set(n)\n  else: assert(false)\nproc writeBits[B:SomeInteger](b:B,n:int) =\n  var n = n * 8\n  for i in countdown(n-1,0):stdout.write(b[i])\n  echo \"\"\nproc setBits[B:SomeInteger](n:int):B = return (B(1) shl B(n)) - B(1)\nproc builtin_ctz(n:int):int =\n  for i in 0..<(8 * sizeof(n)):\n    if n[i] == 1: return i\n  assert(false)\nproc builtin_popcount(n:int):int =\n  result = 0\n  for i in 0..<(8 * sizeof(n)):\n    if n[i] == 1: result += 1\n#}}}\n\nconst MOD = 998244353\nvar N:int\nvar a:seq[int]\nvar b:seq[int]\n\n#{{{ input part\nproc main()\nblock:\n  N = nextInt()\n  a = newSeqWith(N-1, 0)\n  b = newSeqWith(N-1, 0)\n  for i in 0..<N-1:\n    a[i] = nextInt() - 1\n    b[i] = nextInt() - 1\n#}}}\n\n#{{{ ModInt[Mod]\nproc getDefault(T:typedesc): T = (var temp:T;temp)\nproc getDefault[T](x:T): T = (var temp:T;temp)\n\ntype ModInt[Mod: static[int]] = object\n  v:int\nproc initModInt[T](a:T, Mod: static[int]):ModInt[Mod] =\n  when T is ModInt[Mod]:\n    return a\n  else:\n    var a = a\n    a = a mod Mod\n    if a < 0: a += Mod\n    result.v = a\nproc initModInt[T](a:T):ModInt[Mod] = initModInt(a, MOD)\nproc init[T](self:ModInt[Mod], a:T):ModInt[Mod] = initModInt(a, Mod)\nproc Identity(self:ModInt[Mod]):ModInt[Mod] = return initModInt(1, Mod)\n\nproc `==`[T](a:ModInt[Mod], b:T):bool = a.v == a.init(b).v\nproc `!=`[T](a:ModInt[Mod], b:T):bool = a.v != a.init(b).v\nproc `-`(self:ModInt[Mod]):ModInt[Mod] =\n  if self.v == 0: return self\n  else: return ModInt[Mod](v:MOD - self.v)\nproc `$`(a:ModInt[Mod]):string = return $(a.v)\n\nproc `+=`[T](self:var ModInt[Mod]; a:T):void =\n  self.v += initModInt(a, Mod).v\n  if self.v >= MOD: self.v -= MOD\nproc `-=`[T](self:var ModInt[Mod],a:T):void =\n  self.v -= initModInt(a, Mod).v\n  if self.v < 0: self.v += MOD\nproc `*=`[T](self:var ModInt[Mod],a:T):void =\n  self.v *= initModInt(a, Mod).v\n  self.v = self.v mod MOD\nproc `^=`(self:var ModInt[Mod], n:int) =\n  var (x,n,a) = (self,n,self.Identity)\n  while n > 0:\n    if (n and 1) > 0: a *= x\n    x *= x\n    n = (n shr 1)\n  swap(self, a)\nproc inverse(x:int):ModInt[Mod] =\n  var (a, b) = (x, MOD)\n  var (u, v) = (1, 0)\n  while b > 0:\n    let t = a div b\n    a -= t * b;swap(a,b)\n    u -= t * v;swap(u,v)\n  return initModInt(u, Mod)\nproc `/=`[T](a:var ModInt[Mod],b:T):void = a *= initModInt(b, Mod).v.inverse()\nproc `+`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result += b\nproc `-`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result -= b\nproc `*`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result *= b\nproc `/`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a; result /= b\nproc `^`(a:ModInt[Mod],b:int):ModInt[Mod] = result = a; result ^= b\n#}}}\n\ntype Mint = ModInt[Mod]\nproc initMint[T](a:T):ModInt[Mod] = initModInt(a, Mod)\n\n#{{{ Graph\nimport sequtils\n\ntype\n  Edge[T] = object\n    src,dst:int\n    weight:T\n    rev:int\n  Edges[T] = seq[Edge[T]]\n  Graph[T] = seq[seq[Edge[T]]]\n\nproc initEdge[T](src,dst:int,weight:T,rev:int = -1):Edge[T] =\n  var e:Edge[T]\n  e.src = src\n  e.dst = dst\n  e.weight = weight\n  e.rev = rev\n  return e\n\nproc initGraph[T](n:int):Graph[T] =\n  return newSeqWith(n,newSeq[Edge[T]]())\n\nproc addBiEdge[T](g:var Graph[T],e:Edge[T]):void =\n  var e_rev = e\n  swap(e_rev.src, e_rev.dst)\n  let (r, s) = (g[e.src].len, g[e.dst].len)\n  g[e.src].add(e)\n  g[e.dst].add(e_rev)\n  g[e.src][^1].rev = s\n  g[e.dst][^1].rev = r\nproc addBiEdge[T](g:var Graph[T],src,dst:int,weight:T=1):void =\n  g.addBiEdge(initEdge(src, dst, weight))\n\nproc initUndirectedGraph[T](n:int, a,b,c:seq[T]):Graph[T] =\n  var result = initGraph[T](n)\n  for i in 0..<a.len: result.addBiEdge(a[i], b[i], c[i])\nproc initUndirectedGraph[T](n:int, a,b:seq[T]):Graph[T] =\n  result = initGraph[T](n)\n  for i in 0..<a.len: result.addBiEdge(a[i], b[i], T(1))\nproc initGraph[T](n:int, a,b,c:seq[T]):Graph[T] =\n  var result = initGraph[T](n)\n  for i in 0..<a.len: result.addEdge(a[i], b[i], c[i])\nproc initGraph[T](n:int, a,b:seq[T]):Graph[T] =\n  result = initGraph[T](n)\n  for i in 0..<a.len: result.addEdge(a[i], b[i], T(1))\n\n\nproc addEdge[T](g:var Graph[T],e:Edge[T]):void =\n  g[e.src].add(e)\nproc addEdge[T](g:var Graph[T],src,dst:int,weight:T=1):void =\n  g.addEdge(initEdge(src, dst, weight, -1))\n\nproc `<`[T](l,r:Edge[T]):bool = l.weight < r.weight\n#}}}\n\nvar p1:int\n\nproc treeDiameter[T](g:Graph[T]):int =\n  proc dfs(idx, par:int):(T,int) =\n    result[1] = idx\n    for e in g[idx]:\n      if e.dst == par: continue\n      var cost = dfs(e.dst, idx)\n      cost[0] += e.weight\n      result = max(result, cost)\n  let\n    p = dfs(0, -1)\n    q = dfs(p[1], -1)\n  p1 = p[1]\n  return q[0]\n\n# depth first search {{{\nvar v = newSeq[int]()\nproc dfs0[T](g:Graph[T], u:int, p:int, h:int):bool =\n  if h == 0: return true\n  for e in g[u]:\n    if e.dst == p: continue\n    v.add(e.dst)\n    if g.dfs0(e.dst, u, h - 1): return true\n    discard v.pop()\n  return false\n#}}}\n\nvar max_depth = newSeq[int](N)\nvar size = newSeq[int](N)\n\nproc dfs1[T](g:Graph[T], u:int, p = -1, depth = 0):void =\n  max_depth[u] = depth\n  size[u] = 1\n  for e in g[u]:\n    if e.dst == p: continue\n    g.dfs1(e.dst, u, depth + 1)\n    max_depth[u] .max= max_depth[e.dst]\n    size[u] += size[e.dst]\n\nvar target_depth:int\n\nproc dfs2[T](g:Graph[T], u:int, p = -1, depth = 0):(Mint,Mint) =\n  if g[u].len == 1:\n#    echo \"leaf: \", u, \" \", depth\n    if depth == target_depth:\n      return (initMint(0), initMint(1))\n    else:\n      return (initMint(1), initMint(0))\n  result = (initMint(1), initMint(0))\n  for e in g[u]:\n    if e.dst == p: continue\n    let a = g.dfs2(e.dst, u, depth + 1)\n    if max_depth[e.dst] == target_depth:\n      var result2:(Mint,Mint)\n      # make e critical\n#      let t = initMint(3)^(size[e.dst] - 1)\n      result2[0] += result[0] * a[0]\n#      result2[1] += result[1] * t + result[0] * (t - a[0])\n      result2[1] += result[0] * a[1]\n      # make e non critical\n      let d = initMint(2) * initMint(3)^(size[e.dst] - 1)\n      result2[0] += result[0] * d\n      result2[1] += result[1] * d\n      swap(result, result2)\n    else:\n      # always non critical\n      let d = initMint(3)^size[e.dst]\n      result[0] *= d\n      result[1] *= d\n#  echo u, \" \", p, \" \", result\n\nproc main() =\n  g := initUndirectedGraph[int](N, a, b)\n  let d = g.treeDiameter\n  v.add(p1)\n  assert g.dfs0(p1, -1, d)\n  target_depth = d div 2\n  if d mod 2 == 0:\n    let c = v[d div 2]\n#    echo \"center: \", c + 1\n    g.dfs1(c)\n    dp := newSeq[Mint](3)\n    dp[0] = initMint(1)\n    for e in g[c]:\n      let v0 = g.dfs2(e.dst, c, 1)\n#      echo max_depth[e.dst], \" \", target_depth\n      if max_depth[e.dst] < target_depth:\n        for b in 0..<dp.len: dp[b] *= initMint(3) * v0[0]\n      else:\n        dp2 := newSeq[Mint](3)\n        for b in 0..<dp.len:\n          # critical\n          if b < 2:\n            dp2[b + 1] += dp[b] * v0[1]\n          # non critical\n          dp2[b] += dp[b] * v0[0] * 3\n        swap(dp, dp2)\n    echo dp[2]\n  else:\n    let\n      c0 = v[d div 2]\n      c1 = v[d div 2 + 1]\n#    echo c0, \" \", c1\n    g.dfs1(c0, c1)\n    g.dfs1(c1, c0)\n    let\n      v0 = g.dfs2(c0, c1)\n      v1 = g.dfs2(c1, c0)\n    echo v0[1] * v1[1]\n  return\n\nmain()\n"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n#}}}\n\nconst MOD = 998244353\nvar N:int\nvar a:seq[int]\nvar b:seq[int]\n\n#{{{ input part\nproc main()\nblock:\n  N = nextInt()\n  a = newSeqWith(N-1, 0)\n  b = newSeqWith(N-1, 0)\n  for i in 0..<N-1:\n    a[i] = nextInt() - 1\n    b[i] = nextInt() - 1\n#}}}\n\n#{{{ ModInt[Mod]\nproc getDefault(T:typedesc): T = (var temp:T;temp)\nproc getDefault[T](x:T): T = (var temp:T;temp)\n\ntype ModInt[Mod: static[int]] = object\n  v:int\nproc initModInt[T](a:T, Mod: static[int]):ModInt[Mod] =\n  when T is ModInt[Mod]:\n    return a\n  else:\n    var a = a\n    a = a mod Mod\n    if a < 0: a += Mod\n    result.v = a\nproc initModInt[T](a:T):ModInt[Mod] = initModInt(a, MOD)\nproc init[T](self:ModInt[Mod], a:T):ModInt[Mod] = initModInt(a, Mod)\nproc Identity(self:ModInt[Mod]):ModInt[Mod] = return initModInt(1, Mod)\n\nproc `==`[T](a:ModInt[Mod], b:T):bool = a.v == a.init(b).v\nproc `!=`[T](a:ModInt[Mod], b:T):bool = a.v != a.init(b).v\nproc `-`(self:ModInt[Mod]):ModInt[Mod] =\n  if self.v == 0: return self\n  else: return ModInt[Mod](v:MOD - self.v)\nproc `$`(a:ModInt[Mod]):string = return $(a.v)\n\nproc `+=`[T](self:var ModInt[Mod]; a:T):void =\n  self.v += initModInt(a, Mod).v\n  if self.v >= MOD: self.v -= MOD\nproc `-=`[T](self:var ModInt[Mod],a:T):void =\n  self.v -= initModInt(a, Mod).v\n  if self.v < 0: self.v += MOD\nproc `*=`[T](self:var ModInt[Mod],a:T):void =\n  self.v *= initModInt(a, Mod).v\n  self.v = self.v mod MOD\nproc `^=`(self:var ModInt[Mod], n:int) =\n  var (x,n,a) = (self,n,self.Identity)\n  while n > 0:\n    if (n and 1) > 0: a *= x\n    x *= x\n    n = (n shr 1)\n  swap(self, a)\nproc inverse(x:int):ModInt[Mod] =\n  var (a, b) = (x, MOD)\n  var (u, v) = (1, 0)\n  while b > 0:\n    let t = a div b\n    a -= t * b;swap(a,b)\n    u -= t * v;swap(u,v)\n  return initModInt(u, Mod)\nproc `/=`[T](a:var ModInt[Mod],b:T):void = a *= initModInt(b, Mod).v.inverse()\nproc `+`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result += b\nproc `-`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result -= b\nproc `*`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result *= b\nproc `/`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a; result /= b\nproc `^`(a:ModInt[Mod],b:int):ModInt[Mod] = result = a; result ^= b\n#}}}\n\ntype Mint = ModInt[Mod]\nproc initMint[T](a:T):ModInt[Mod] = initModInt(a, Mod)\n\n#{{{ Graph\nimport sequtils\n\ntype\n  Edge[T] = object\n    src,dst:int\n    weight:T\n    rev:int\n  Edges[T] = seq[Edge[T]]\n  Graph[T] = seq[seq[Edge[T]]]\n\nproc initEdge[T](src,dst:int,weight:T,rev:int = -1):Edge[T] =\n  var e:Edge[T]\n  e.src = src\n  e.dst = dst\n  e.weight = weight\n  e.rev = rev\n  return e\n\nproc initGraph[T](n:int):Graph[T] =\n  return newSeqWith(n,newSeq[Edge[T]]())\n\nproc addBiEdge[T](g:var Graph[T],e:Edge[T]):void =\n  var e_rev = e\n  swap(e_rev.src, e_rev.dst)\n  let (r, s) = (g[e.src].len, g[e.dst].len)\n  g[e.src].add(e)\n  g[e.dst].add(e_rev)\n  g[e.src][^1].rev = s\n  g[e.dst][^1].rev = r\nproc addBiEdge[T](g:var Graph[T],src,dst:int,weight:T=1):void =\n  g.addBiEdge(initEdge(src, dst, weight))\n\nproc initUndirectedGraph[T](n:int, a,b,c:seq[T]):Graph[T] =\n  var result = initGraph[T](n)\n  for i in 0..<a.len: result.addBiEdge(a[i], b[i], c[i])\nproc initUndirectedGraph[T](n:int, a,b:seq[T]):Graph[T] =\n  result = initGraph[T](n)\n  for i in 0..<a.len: result.addBiEdge(a[i], b[i], T(1))\nproc initGraph[T](n:int, a,b,c:seq[T]):Graph[T] =\n  var result = initGraph[T](n)\n  for i in 0..<a.len: result.addEdge(a[i], b[i], c[i])\nproc initGraph[T](n:int, a,b:seq[T]):Graph[T] =\n  result = initGraph[T](n)\n  for i in 0..<a.len: result.addEdge(a[i], b[i], T(1))\n\n\nproc addEdge[T](g:var Graph[T],e:Edge[T]):void =\n  g[e.src].add(e)\nproc addEdge[T](g:var Graph[T],src,dst:int,weight:T=1):void =\n  g.addEdge(initEdge(src, dst, weight, -1))\n\nproc `<`[T](l,r:Edge[T]):bool = l.weight < r.weight\n#}}}\n\nvar p1:int\n\nproc treeDiameter[T](g:Graph[T]):int =\n  proc dfs(idx, par:int):(T,int) =\n    result[1] = idx\n    for e in g[idx]:\n      if e.dst == par: continue\n      var cost = dfs(e.dst, idx)\n      cost[0] += e.weight\n      result = max(result, cost)\n  let\n    p = dfs(0, -1)\n    q = dfs(p[1], -1)\n  p1 = p[1]\n  return q[0]\n\n# depth first search {{{\nvar v = newSeq[int]()\nproc dfs0[T](g:Graph[T], u:int, p:int, h:int):bool =\n  if h == 0: return true\n  for e in g[u]:\n    if e.dst == p: continue\n    v.add(e.dst)\n    if g.dfs0(e.dst, u, h - 1): return true\n    discard v.pop()\n  return false\n#}}}\n\nvar max_depth = newSeq[int](N)\nvar size = newSeq[int](N)\n\nproc dfs1[T](g:Graph[T], u:int, p = -1, depth = 0):void =\n  max_depth[u] = depth\n  size[u] = 1\n  for e in g[u]:\n    if e.dst == p: continue\n    g.dfs1(e.dst, u, depth + 1)\n    max_depth[u] .max= max_depth[e.dst]\n    size[u] += size[e.dst]\n\nvar target_depth:int\n\nproc dfs2[T](g:Graph[T], u:int, p = -1, depth = 0):(Mint,Mint) =\n  if g[u].len == 1:\n    if depth == target_depth:\n      return (initMint(0), initMint(1))\n    else:\n      return (initMint(1), initMint(0))\n  result = (initMint(1), initMint(0))\n  for e in g[u]:\n    if e.dst == p: continue\n    let a = g.dfs2(e.dst, u, depth + 1)\n    if max_depth[e.dst] == target_depth:\n      var result2:(Mint,Mint)\n      # make e critical\n      result2[0] += result[0] * a[0]\n#      result2[1] += result[1] * t + result[0] * (t - a[0])\n      result2[1] += result[0] * a[1] + result[1] * a[0]\n      # make e non critical\n      let d = initMint(2) * initMint(3)^(size[e.dst] - 1)\n      result2[0] += result[0] * d\n      result2[1] += result[1] * d\n      swap(result, result2)\n    else:\n      # always non critical\n      let d = initMint(3)^size[e.dst]\n      result[0] *= d\n      result[1] *= d\n\nproc main() =\n  g := initUndirectedGraph[int](N, a, b)\n  let d = g.treeDiameter\n  v.add(p1)\n  assert g.dfs0(p1, -1, d)\n  target_depth = d div 2\n  if d mod 2 == 0:\n    let c = v[d div 2]\n    g.dfs1(c)\n    dp := newSeq[Mint](3)\n    dp[0] = initMint(1)\n    for e in g[c]:\n      let v0 = g.dfs2(e.dst, c, 1)\n      if max_depth[e.dst] < target_depth:\n        for b in 0..<dp.len: dp[b] *= initMint(3) * v0[0]\n      else:\n        dp2 := newSeq[Mint](3)\n        for b in 0..<dp.len:\n          # critical\n          if b < 2:\n            dp2[b + 1] += dp[b] * v0[1]\n          # non critical\n          dp2[b] += dp[b] * v0[0] * 3\n        swap(dp, dp2)\n    echo dp[2]\n  else:\n    let\n      c0 = v[d div 2]\n      c1 = v[d div 2 + 1]\n    g.dfs1(c0, c1)\n    g.dfs1(c1, c0)\n    let\n      v0 = g.dfs2(c0, c1)\n      v1 = g.dfs2(c1, c0)\n    echo v0[1] * v1[1]\n  return\n\nmain()\n"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n#}}}\n\nconst MOD = 998244353\nvar N:int\nvar a:seq[int]\nvar b:seq[int]\n\n#{{{ input part\nproc main()\nblock:\n  N = nextInt()\n  a = newSeqWith(N-1, 0)\n  b = newSeqWith(N-1, 0)\n  for i in 0..<N-1:\n    a[i] = nextInt() - 1\n    b[i] = nextInt() - 1\n#}}}\n\n#{{{ ModInt[Mod]\nproc getDefault(T:typedesc): T = (var temp:T;temp)\nproc getDefault[T](x:T): T = (var temp:T;temp)\n\ntype ModInt[Mod: static[int]] = object\n  v:int\nproc initModInt[T](a:T, Mod: static[int]):ModInt[Mod] =\n  when T is ModInt[Mod]:\n    return a\n  else:\n    var a = a\n    a = a mod Mod\n    if a < 0: a += Mod\n    result.v = a\nproc initModInt[T](a:T):ModInt[Mod] = initModInt(a, MOD)\nproc init[T](self:ModInt[Mod], a:T):ModInt[Mod] = initModInt(a, Mod)\nproc Identity(self:ModInt[Mod]):ModInt[Mod] = return initModInt(1, Mod)\n\nproc `==`[T](a:ModInt[Mod], b:T):bool = a.v == a.init(b).v\nproc `!=`[T](a:ModInt[Mod], b:T):bool = a.v != a.init(b).v\nproc `-`(self:ModInt[Mod]):ModInt[Mod] =\n  if self.v == 0: return self\n  else: return ModInt[Mod](v:MOD - self.v)\nproc `$`(a:ModInt[Mod]):string = return $(a.v)\n\nproc `+=`[T](self:var ModInt[Mod]; a:T):void =\n  self.v += initModInt(a, Mod).v\n  if self.v >= MOD: self.v -= MOD\nproc `-=`[T](self:var ModInt[Mod],a:T):void =\n  self.v -= initModInt(a, Mod).v\n  if self.v < 0: self.v += MOD\nproc `*=`[T](self:var ModInt[Mod],a:T):void =\n  self.v *= initModInt(a, Mod).v\n  self.v = self.v mod MOD\nproc `^=`(self:var ModInt[Mod], n:int) =\n  var (x,n,a) = (self,n,self.Identity)\n  while n > 0:\n    if (n and 1) > 0: a *= x\n    x *= x\n    n = (n shr 1)\n  swap(self, a)\nproc inverse(x:int):ModInt[Mod] =\n  var (a, b) = (x, MOD)\n  var (u, v) = (1, 0)\n  while b > 0:\n    let t = a div b\n    a -= t * b;swap(a,b)\n    u -= t * v;swap(u,v)\n  return initModInt(u, Mod)\nproc `/=`[T](a:var ModInt[Mod],b:T):void = a *= initModInt(b, Mod).v.inverse()\nproc `+`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result += b\nproc `-`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result -= b\nproc `*`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result *= b\nproc `/`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a; result /= b\nproc `^`(a:ModInt[Mod],b:int):ModInt[Mod] = result = a; result ^= b\n#}}}\n\ntype Mint = ModInt[Mod]\nproc initMint[T](a:T):ModInt[Mod] = initModInt(a, Mod)\n\n#{{{ Graph\nimport sequtils\n\ntype\n  Edge[T] = object\n    src,dst:int\n    weight:T\n    rev:int\n  Edges[T] = seq[Edge[T]]\n  Graph[T] = seq[seq[Edge[T]]]\n\nproc initEdge[T](src,dst:int,weight:T,rev:int = -1):Edge[T] =\n  var e:Edge[T]\n  e.src = src\n  e.dst = dst\n  e.weight = weight\n  e.rev = rev\n  return e\n\nproc initGraph[T](n:int):Graph[T] =\n  return newSeqWith(n,newSeq[Edge[T]]())\n\nproc addBiEdge[T](g:var Graph[T],e:Edge[T]):void =\n  var e_rev = e\n  swap(e_rev.src, e_rev.dst)\n  let (r, s) = (g[e.src].len, g[e.dst].len)\n  g[e.src].add(e)\n  g[e.dst].add(e_rev)\n  g[e.src][^1].rev = s\n  g[e.dst][^1].rev = r\nproc addBiEdge[T](g:var Graph[T],src,dst:int,weight:T=1):void =\n  g.addBiEdge(initEdge(src, dst, weight))\n\nproc initUndirectedGraph[T](n:int, a,b,c:seq[T]):Graph[T] =\n  var result = initGraph[T](n)\n  for i in 0..<a.len: result.addBiEdge(a[i], b[i], c[i])\nproc initUndirectedGraph[T](n:int, a,b:seq[T]):Graph[T] =\n  result = initGraph[T](n)\n  for i in 0..<a.len: result.addBiEdge(a[i], b[i], T(1))\nproc initGraph[T](n:int, a,b,c:seq[T]):Graph[T] =\n  var result = initGraph[T](n)\n  for i in 0..<a.len: result.addEdge(a[i], b[i], c[i])\nproc initGraph[T](n:int, a,b:seq[T]):Graph[T] =\n  result = initGraph[T](n)\n  for i in 0..<a.len: result.addEdge(a[i], b[i], T(1))\n\n\nproc addEdge[T](g:var Graph[T],e:Edge[T]):void =\n  g[e.src].add(e)\nproc addEdge[T](g:var Graph[T],src,dst:int,weight:T=1):void =\n  g.addEdge(initEdge(src, dst, weight, -1))\n\nproc `<`[T](l,r:Edge[T]):bool = l.weight < r.weight\n#}}}\n\nvar p1:int\n\nproc treeDiameter[T](g:Graph[T]):int =\n  proc dfs(idx, par:int):(T,int) =\n    result[1] = idx\n    for e in g[idx]:\n      if e.dst == par: continue\n      var cost = dfs(e.dst, idx)\n      cost[0] += e.weight\n      result = max(result, cost)\n  let\n    p = dfs(0, -1)\n    q = dfs(p[1], -1)\n  p1 = p[1]\n  return q[0]\n\n# depth first search {{{\nvar v = newSeq[int]()\nproc dfs0[T](g:Graph[T], u:int, p:int, h:int):bool =\n  if h == 0: return true\n  for e in g[u]:\n    if e.dst == p: continue\n    v.add(e.dst)\n    if g.dfs0(e.dst, u, h - 1): return true\n    discard v.pop()\n  return false\n#}}}\n\nvar max_depth = newSeq[int](N)\nvar size = newSeq[int](N)\n\nproc dfs1[T](g:Graph[T], u:int, p = -1, depth = 0):void =\n  max_depth[u] = depth\n  size[u] = 1\n  for e in g[u]:\n    if e.dst == p: continue\n    g.dfs1(e.dst, u, depth + 1)\n    max_depth[u] .max= max_depth[e.dst]\n    size[u] += size[e.dst]\n\nvar target_depth:int\n\nproc dfs2[T](g:Graph[T], u:int, p = -1, depth = 0):(Mint,Mint) =\n  if depth == target_depth: return (initMint(0), initMint(1))\n  result = (initMint(1), initMint(0))\n  for e in g[u]:\n    if e.dst == p: continue\n    let a = g.dfs2(e.dst, u, depth + 1)\n    if max_depth[e.dst] == target_depth:\n      var result2:(Mint,Mint)\n      # make e critical\n      result2[0] += result[0] * a[0]\n#      result2[1] += result[1] * t + result[0] * (t - a[0])\n      result2[1] += result[0] * a[1] + result[1] * a[0]\n      # make e non critical\n      let d = initMint(2) * initMint(3)^(size[e.dst] - 1)\n      result2[0] += result[0] * d\n      result2[1] += result[1] * d\n      swap(result, result2)\n    else:\n      # always non critical\n      let d = initMint(3)^size[e.dst]\n      result[0] *= d\n      result[1] *= d\n\nproc main() =\n  g := initUndirectedGraph[int](N, a, b)\n  let d = g.treeDiameter\n  v.add(p1)\n  discard g.dfs0(p1, -1, d)\n  target_depth = d div 2\n  if d mod 2 == 0:\n    let c = v[d div 2]\n    g.dfs1(c)\n    dp := newSeq[Mint](3)\n    dp[0] = initMint(1)\n    for e in g[c]:\n      let v0 = g.dfs2(e.dst, c, 1)\n      if max_depth[e.dst] < target_depth:\n        for b in 0..<dp.len: dp[b] *= initMint(3) * v0[0]\n      else:\n        dp2 := newSeq[Mint](3)\n        for b in 0..<dp.len:\n          # make e critical\n          if b < 2:\n            dp2[b + 1] += dp[b] * v0[1]\n          dp2[b] += dp[b] * v0[0]\n          # make e non critical\n          dp2[b] += dp[b] * initMint(2) * initMint(3)^(size[e.dst] - 1)\n        swap(dp, dp2)\n    echo dp[2]\n  else:\n    let\n      c0 = v[d div 2]\n      c1 = v[d div 2 + 1]\n    g.dfs1(c0, c1)\n    g.dfs1(c1, c0)\n    let\n      v0 = g.dfs2(c0, c1)\n      v1 = g.dfs2(c1, c0)\n    echo v0[1] * v1[1]\n  return\n\nmain()\n"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n#}}}\n\nconst MOD = 998244353\nvar N:int\nvar a:seq[int]\nvar b:seq[int]\n\n#{{{ input part\nproc main()\nblock:\n  N = nextInt()\n  a = newSeqWith(N-1, 0)\n  b = newSeqWith(N-1, 0)\n  for i in 0..<N-1:\n    a[i] = nextInt() - 1\n    b[i] = nextInt() - 1\n#}}}\n\n#{{{ ModInt[Mod]\nproc getDefault(T:typedesc): T = (var temp:T;temp)\nproc getDefault[T](x:T): T = (var temp:T;temp)\n\ntype ModInt[Mod: static[int]] = object\n  v:int\nproc initModInt[T](a:T, Mod: static[int]):ModInt[Mod] =\n  when T is ModInt[Mod]:\n    return a\n  else:\n    var a = a\n    a = a mod Mod\n    if a < 0: a += Mod\n    result.v = a\nproc initModInt[T](a:T):ModInt[Mod] = initModInt(a, MOD)\nproc init[T](self:ModInt[Mod], a:T):ModInt[Mod] = initModInt(a, Mod)\nproc Identity(self:ModInt[Mod]):ModInt[Mod] = return initModInt(1, Mod)\n\nproc `==`[T](a:ModInt[Mod], b:T):bool = a.v == a.init(b).v\nproc `!=`[T](a:ModInt[Mod], b:T):bool = a.v != a.init(b).v\nproc `-`(self:ModInt[Mod]):ModInt[Mod] =\n  if self.v == 0: return self\n  else: return ModInt[Mod](v:MOD - self.v)\nproc `$`(a:ModInt[Mod]):string = return $(a.v)\n\nproc `+=`[T](self:var ModInt[Mod]; a:T):void =\n  self.v += initModInt(a, Mod).v\n  if self.v >= MOD: self.v -= MOD\nproc `-=`[T](self:var ModInt[Mod],a:T):void =\n  self.v -= initModInt(a, Mod).v\n  if self.v < 0: self.v += MOD\nproc `*=`[T](self:var ModInt[Mod],a:T):void =\n  self.v *= initModInt(a, Mod).v\n  self.v = self.v mod MOD\nproc `^=`(self:var ModInt[Mod], n:int) =\n  var (x,n,a) = (self,n,self.Identity)\n  while n > 0:\n    if (n and 1) > 0: a *= x\n    x *= x\n    n = (n shr 1)\n  swap(self, a)\nproc inverse(x:int):ModInt[Mod] =\n  var (a, b) = (x, MOD)\n  var (u, v) = (1, 0)\n  while b > 0:\n    let t = a div b\n    a -= t * b;swap(a,b)\n    u -= t * v;swap(u,v)\n  return initModInt(u, Mod)\nproc `/=`[T](a:var ModInt[Mod],b:T):void = a *= initModInt(b, Mod).v.inverse()\nproc `+`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result += b\nproc `-`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result -= b\nproc `*`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result *= b\nproc `/`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a; result /= b\nproc `^`(a:ModInt[Mod],b:int):ModInt[Mod] = result = a; result ^= b\n#}}}\n\ntype Mint = ModInt[Mod]\nproc initMint[T](a:T):ModInt[Mod] = initModInt(a, Mod)\n\n#{{{ Graph\nimport sequtils\n\ntype\n  Edge[T] = object\n    src,dst:int\n    weight:T\n    rev:int\n  Edges[T] = seq[Edge[T]]\n  Graph[T] = seq[seq[Edge[T]]]\n\nproc initEdge[T](src,dst:int,weight:T,rev:int = -1):Edge[T] =\n  var e:Edge[T]\n  e.src = src\n  e.dst = dst\n  e.weight = weight\n  e.rev = rev\n  return e\n\nproc initGraph[T](n:int):Graph[T] =\n  return newSeqWith(n,newSeq[Edge[T]]())\n\nproc addBiEdge[T](g:var Graph[T],e:Edge[T]):void =\n  var e_rev = e\n  swap(e_rev.src, e_rev.dst)\n  let (r, s) = (g[e.src].len, g[e.dst].len)\n  g[e.src].add(e)\n  g[e.dst].add(e_rev)\n  g[e.src][^1].rev = s\n  g[e.dst][^1].rev = r\nproc addBiEdge[T](g:var Graph[T],src,dst:int,weight:T=1):void =\n  g.addBiEdge(initEdge(src, dst, weight))\n\nproc initUndirectedGraph[T](n:int, a,b,c:seq[T]):Graph[T] =\n  var result = initGraph[T](n)\n  for i in 0..<a.len: result.addBiEdge(a[i], b[i], c[i])\nproc initUndirectedGraph[T](n:int, a,b:seq[T]):Graph[T] =\n  result = initGraph[T](n)\n  for i in 0..<a.len: result.addBiEdge(a[i], b[i], T(1))\nproc initGraph[T](n:int, a,b,c:seq[T]):Graph[T] =\n  var result = initGraph[T](n)\n  for i in 0..<a.len: result.addEdge(a[i], b[i], c[i])\nproc initGraph[T](n:int, a,b:seq[T]):Graph[T] =\n  result = initGraph[T](n)\n  for i in 0..<a.len: result.addEdge(a[i], b[i], T(1))\n\n\nproc addEdge[T](g:var Graph[T],e:Edge[T]):void =\n  g[e.src].add(e)\nproc addEdge[T](g:var Graph[T],src,dst:int,weight:T=1):void =\n  g.addEdge(initEdge(src, dst, weight, -1))\n\nproc `<`[T](l,r:Edge[T]):bool = l.weight < r.weight\n#}}}\n\nvar p1:int\n\nproc treeDiameter[T](g:Graph[T]):int =\n  proc dfs(idx, par:int):(T,int) =\n    result[1] = idx\n    for e in g[idx]:\n      if e.dst == par: continue\n      var cost = dfs(e.dst, idx)\n      cost[0] += e.weight\n      result = max(result, cost)\n  let\n    p = dfs(0, -1)\n    q = dfs(p[1], -1)\n  p1 = p[1]\n  return q[0]\n\n# depth first search {{{\nvar v = newSeq[int]()\nproc dfs0[T](g:Graph[T], u:int, p:int, h:int):bool =\n  if h == 0: return true\n  for e in g[u]:\n    if e.dst == p: continue\n    v.add(e.dst)\n    if g.dfs0(e.dst, u, h - 1): return true\n    discard v.pop()\n  return false\n#}}}\n\nvar max_depth = newSeq[int](N)\nvar size = newSeq[int](N)\n\nproc dfs1[T](g:Graph[T], u:int, p = -1, depth = 0):void =\n  max_depth[u] = depth\n  size[u] = 1\n  for e in g[u]:\n    if e.dst == p: continue\n    g.dfs1(e.dst, u, depth + 1)\n    max_depth[u] .max= max_depth[e.dst]\n    size[u] += size[e.dst]\n\nvar target_depth:int\n\nproc dfs2[T](g:Graph[T], u:int, p = -1, depth = 0):(Mint,Mint) =\n  if g[u].len == 1:\n    if depth == target_depth:\n      return (initMint(0), initMint(1))\n    else:\n      return (initMint(1), initMint(0))\n  result = (initMint(1), initMint(0))\n  for e in g[u]:\n    if e.dst == p: continue\n    let a = g.dfs2(e.dst, u, depth + 1)\n    if max_depth[e.dst] == target_depth:\n      var result2:(Mint,Mint)\n      # make e critical\n      result2[0] += result[0] * a[0]\n#      result2[1] += result[1] * t + result[0] * (t - a[0])\n      result2[1] += result[0] * a[1] + result[1] * a[0]\n      # make e non critical\n      let d = initMint(2) * initMint(3)^(size[e.dst] - 1)\n      result2[0] += result[0] * d\n      result2[1] += result[1] * d\n      swap(result, result2)\n    else:\n      # always non critical\n      let d = initMint(3)^size[e.dst]\n      result[0] *= d\n      result[1] *= d\n\nproc main() =\n  g := initUndirectedGraph[int](N, a, b)\n  let d = g.treeDiameter\n  v.add(p1)\n  discard g.dfs0(p1, -1, d)\n  target_depth = d div 2\n  if d mod 2 == 0:\n    let c = v[d div 2]\n    g.dfs1(c)\n    dp := newSeq[Mint](3)\n    dp[0] = initMint(1)\n    for e in g[c]:\n      let v0 = g.dfs2(e.dst, c, 1)\n      if max_depth[e.dst] < target_depth:\n        for b in 0..<dp.len: dp[b] *= initMint(3) * v0[0]\n      else:\n        dp2 := newSeq[Mint](3)\n        for b in 0..<dp.len:\n          # make e critical\n          if b < 2:\n            dp2[b + 1] += dp[b] * v0[1]\n            dp2[b] += dp[b] * v0[0]\n          # non critical\n          dp2[b] += dp[b] * initMint(2) * initMint(3)^(size[e.dst] - 1)\n        swap(dp, dp2)\n    echo dp[2]\n  else:\n    let\n      c0 = v[d div 2]\n      c1 = v[d div 2 + 1]\n    g.dfs1(c0, c1)\n    g.dfs1(c1, c0)\n    let\n      v0 = g.dfs2(c0, c1)\n      v1 = g.dfs2(c1, c0)\n    echo v0[1] * v1[1]\n  return\n\nmain()"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n#}}}\n\nconst MOD = 998244353\nvar N:int\nvar a:seq[int]\nvar b:seq[int]\n\n#{{{ input part\nproc main()\nblock:\n  N = nextInt()\n  a = newSeqWith(N-1, 0)\n  b = newSeqWith(N-1, 0)\n  for i in 0..<N-1:\n    a[i] = nextInt() - 1\n    b[i] = nextInt() - 1\n#}}}\n\n#{{{ ModInt[Mod]\nproc getDefault(T:typedesc): T = (var temp:T;temp)\nproc getDefault[T](x:T): T = (var temp:T;temp)\n\ntype ModInt[Mod: static[int]] = object\n  v:int\nproc initModInt[T](a:T, Mod: static[int]):ModInt[Mod] =\n  when T is ModInt[Mod]:\n    return a\n  else:\n    var a = a\n    a = a mod Mod\n    if a < 0: a += Mod\n    result.v = a\nproc initModInt[T](a:T):ModInt[Mod] = initModInt(a, MOD)\nproc init[T](self:ModInt[Mod], a:T):ModInt[Mod] = initModInt(a, Mod)\nproc Identity(self:ModInt[Mod]):ModInt[Mod] = return initModInt(1, Mod)\n\nproc `==`[T](a:ModInt[Mod], b:T):bool = a.v == a.init(b).v\nproc `!=`[T](a:ModInt[Mod], b:T):bool = a.v != a.init(b).v\nproc `-`(self:ModInt[Mod]):ModInt[Mod] =\n  if self.v == 0: return self\n  else: return ModInt[Mod](v:MOD - self.v)\nproc `$`(a:ModInt[Mod]):string = return $(a.v)\n\nproc `+=`[T](self:var ModInt[Mod]; a:T):void =\n  self.v += initModInt(a, Mod).v\n  if self.v >= MOD: self.v -= MOD\nproc `-=`[T](self:var ModInt[Mod],a:T):void =\n  self.v -= initModInt(a, Mod).v\n  if self.v < 0: self.v += MOD\nproc `*=`[T](self:var ModInt[Mod],a:T):void =\n  self.v *= initModInt(a, Mod).v\n  self.v = self.v mod MOD\nproc `^=`(self:var ModInt[Mod], n:int) =\n  var (x,n,a) = (self,n,self.Identity)\n  while n > 0:\n    if (n and 1) > 0: a *= x\n    x *= x\n    n = (n shr 1)\n  swap(self, a)\nproc inverse(x:int):ModInt[Mod] =\n  var (a, b) = (x, MOD)\n  var (u, v) = (1, 0)\n  while b > 0:\n    let t = a div b\n    a -= t * b;swap(a,b)\n    u -= t * v;swap(u,v)\n  return initModInt(u, Mod)\nproc `/=`[T](a:var ModInt[Mod],b:T):void = a *= initModInt(b, Mod).v.inverse()\nproc `+`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result += b\nproc `-`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result -= b\nproc `*`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result *= b\nproc `/`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a; result /= b\nproc `^`(a:ModInt[Mod],b:int):ModInt[Mod] = result = a; result ^= b\n#}}}\n\ntype Mint = ModInt[Mod]\nproc initMint[T](a:T):ModInt[Mod] = initModInt(a, Mod)\n\n#{{{ Graph\nimport sequtils\n\ntype\n  Edge[T] = object\n    src,dst:int\n    weight:T\n    rev:int\n  Edges[T] = seq[Edge[T]]\n  Graph[T] = seq[seq[Edge[T]]]\n\nproc initEdge[T](src,dst:int,weight:T,rev:int = -1):Edge[T] =\n  var e:Edge[T]\n  e.src = src\n  e.dst = dst\n  e.weight = weight\n  e.rev = rev\n  return e\n\nproc initGraph[T](n:int):Graph[T] =\n  return newSeqWith(n,newSeq[Edge[T]]())\n\nproc addBiEdge[T](g:var Graph[T],e:Edge[T]):void =\n  var e_rev = e\n  swap(e_rev.src, e_rev.dst)\n  let (r, s) = (g[e.src].len, g[e.dst].len)\n  g[e.src].add(e)\n  g[e.dst].add(e_rev)\n  g[e.src][^1].rev = s\n  g[e.dst][^1].rev = r\nproc addBiEdge[T](g:var Graph[T],src,dst:int,weight:T=1):void =\n  g.addBiEdge(initEdge(src, dst, weight))\n\nproc initUndirectedGraph[T](n:int, a,b,c:seq[T]):Graph[T] =\n  var result = initGraph[T](n)\n  for i in 0..<a.len: result.addBiEdge(a[i], b[i], c[i])\nproc initUndirectedGraph[T](n:int, a,b:seq[T]):Graph[T] =\n  result = initGraph[T](n)\n  for i in 0..<a.len: result.addBiEdge(a[i], b[i], T(1))\nproc initGraph[T](n:int, a,b,c:seq[T]):Graph[T] =\n  var result = initGraph[T](n)\n  for i in 0..<a.len: result.addEdge(a[i], b[i], c[i])\nproc initGraph[T](n:int, a,b:seq[T]):Graph[T] =\n  result = initGraph[T](n)\n  for i in 0..<a.len: result.addEdge(a[i], b[i], T(1))\n\n\nproc addEdge[T](g:var Graph[T],e:Edge[T]):void =\n  g[e.src].add(e)\nproc addEdge[T](g:var Graph[T],src,dst:int,weight:T=1):void =\n  g.addEdge(initEdge(src, dst, weight, -1))\n\nproc `<`[T](l,r:Edge[T]):bool = l.weight < r.weight\n#}}}\n\nvar p1:int\n\nproc treeDiameter[T](g:Graph[T]):int =\n  proc dfs(idx, par:int):(T,int) =\n    result[1] = idx\n    for e in g[idx]:\n      if e.dst == par: continue\n      var cost = dfs(e.dst, idx)\n      cost[0] += e.weight\n      result = max(result, cost)\n  let\n    p = dfs(0, -1)\n    q = dfs(p[1], -1)\n  p1 = p[1]\n  return q[0]\n\n# depth first search {{{\nvar v = newSeq[int]()\nproc dfs0[T](g:Graph[T], u:int, p:int, h:int):bool =\n  if h == 0: return true\n  for e in g[u]:\n    if e.dst == p: continue\n    v.add(e.dst)\n    if g.dfs0(e.dst, u, h - 1): return true\n    discard v.pop()\n  return false\n#}}}\n\nvar max_depth = newSeq[int](N)\nvar size = newSeq[int](N)\n\nproc dfs1[T](g:Graph[T], u:int, p = -1, depth = 0):void =\n  max_depth[u] = depth\n  size[u] = 1\n  for e in g[u]:\n    if e.dst == p: continue\n    g.dfs1(e.dst, u, depth + 1)\n    max_depth[u] .max= max_depth[e.dst]\n    size[u] += size[e.dst]\n\nvar target_depth:int\n\nproc dfs2[T](g:Graph[T], u:int, p = -1, depth = 0):(Mint,Mint) =\n  if g[u].len == 1:\n    if depth == target_depth:\n      return (initMint(0), initMint(1))\n    else:\n      return (initMint(1), initMint(0))\n  result = (initMint(1), initMint(0))\n  for e in g[u]:\n    if e.dst == p: continue\n    let a = g.dfs2(e.dst, u, depth + 1)\n    if max_depth[e.dst] == target_depth:\n      var result2:(Mint,Mint)\n      # make e critical\n      result2[0] += result[0] * a[0]\n#      result2[1] += result[1] * t + result[0] * (t - a[0])\n      result2[1] += result[0] * a[1] + result[1] * a[0]\n      # make e non critical\n      let d = initMint(2) * initMint(3)^(size[e.dst] - 1)\n      result2[0] += result[0] * d\n      result2[1] += result[1] * d\n      swap(result, result2)\n    else:\n      # always non critical\n      let d = initMint(3)^size[e.dst]\n      result[0] *= d\n      result[1] *= d\n\nproc main() =\n  g := initUndirectedGraph[int](N, a, b)\n  let d = g.treeDiameter\n  v.add(p1)\n  assert g.dfs0(p1, -1, d)\n  target_depth = d div 2\n  if d mod 2 == 0:\n    let c = v[d div 2]\n    g.dfs1(c)\n    dp := newSeq[Mint](3)\n    dp[0] = initMint(1)\n    for e in g[c]:\n      let v0 = g.dfs2(e.dst, c, 1)\n      if max_depth[e.dst] < target_depth:\n        for b in 0..<dp.len: dp[b] *= initMint(3) * v0[0]\n      else:\n        dp2 := newSeq[Mint](3)\n        for b in 0..<dp.len:\n          # critical\n          if b < 2:\n            dp2[b + 1] += dp[b] * v0[1]\n          # non critical\n          dp2[b] += dp[b] * (v0[0] * 3 + v0[1] * 2)\n        swap(dp, dp2)\n    echo dp[2]\n  else:\n    let\n      c0 = v[d div 2]\n      c1 = v[d div 2 + 1]\n    g.dfs1(c0, c1)\n    g.dfs1(c1, c0)\n    let\n      v0 = g.dfs2(c0, c1)\n      v1 = g.dfs2(c1, c0)\n    echo v0[1] * v1[1]\n  return\n\nmain()\n"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n#}}}\n\nconst MOD = 998244353\nvar N:int\nvar a:seq[int]\nvar b:seq[int]\n\n#{{{ input part\nproc main()\nblock:\n  N = nextInt()\n  a = newSeqWith(N-1, 0)\n  b = newSeqWith(N-1, 0)\n  for i in 0..<N-1:\n    a[i] = nextInt() - 1\n    b[i] = nextInt() - 1\n#}}}\n\n#{{{ ModInt[Mod]\nproc getDefault(T:typedesc): T = (var temp:T;temp)\nproc getDefault[T](x:T): T = (var temp:T;temp)\n\ntype ModInt[Mod: static[int]] = object\n  v:int\nproc initModInt[T](a:T, Mod: static[int]):ModInt[Mod] =\n  when T is ModInt[Mod]:\n    return a\n  else:\n    var a = a\n    a = a mod Mod\n    if a < 0: a += Mod\n    result.v = a\nproc initModInt[T](a:T):ModInt[Mod] = initModInt(a, MOD)\nproc init[T](self:ModInt[Mod], a:T):ModInt[Mod] = initModInt(a, Mod)\nproc Identity(self:ModInt[Mod]):ModInt[Mod] = return initModInt(1, Mod)\n\nproc `==`[T](a:ModInt[Mod], b:T):bool = a.v == a.init(b).v\nproc `!=`[T](a:ModInt[Mod], b:T):bool = a.v != a.init(b).v\nproc `-`(self:ModInt[Mod]):ModInt[Mod] =\n  if self.v == 0: return self\n  else: return ModInt[Mod](v:MOD - self.v)\nproc `$`(a:ModInt[Mod]):string = return $(a.v)\n\nproc `+=`[T](self:var ModInt[Mod]; a:T):void =\n  self.v += initModInt(a, Mod).v\n  if self.v >= MOD: self.v -= MOD\nproc `-=`[T](self:var ModInt[Mod],a:T):void =\n  self.v -= initModInt(a, Mod).v\n  if self.v < 0: self.v += MOD\nproc `*=`[T](self:var ModInt[Mod],a:T):void =\n  self.v *= initModInt(a, Mod).v\n  self.v = self.v mod MOD\nproc `^=`(self:var ModInt[Mod], n:int) =\n  var (x,n,a) = (self,n,self.Identity)\n  while n > 0:\n    if (n and 1) > 0: a *= x\n    x *= x\n    n = (n shr 1)\n  swap(self, a)\nproc inverse(x:int):ModInt[Mod] =\n  var (a, b) = (x, MOD)\n  var (u, v) = (1, 0)\n  while b > 0:\n    let t = a div b\n    a -= t * b;swap(a,b)\n    u -= t * v;swap(u,v)\n  return initModInt(u, Mod)\nproc `/=`[T](a:var ModInt[Mod],b:T):void = a *= initModInt(b, Mod).v.inverse()\nproc `+`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result += b\nproc `-`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result -= b\nproc `*`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result *= b\nproc `/`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a; result /= b\nproc `^`(a:ModInt[Mod],b:int):ModInt[Mod] = result = a; result ^= b\n#}}}\n\ntype Mint = ModInt[Mod]\nproc initMint[T](a:T):ModInt[Mod] = initModInt(a, Mod)\n\n#{{{ Graph\nimport sequtils\n\ntype\n  Edge[T] = object\n    src,dst:int\n    weight:T\n    rev:int\n  Edges[T] = seq[Edge[T]]\n  Graph[T] = seq[seq[Edge[T]]]\n\nproc initEdge[T](src,dst:int,weight:T,rev:int = -1):Edge[T] =\n  var e:Edge[T]\n  e.src = src\n  e.dst = dst\n  e.weight = weight\n  e.rev = rev\n  return e\n\nproc initGraph[T](n:int):Graph[T] =\n  return newSeqWith(n,newSeq[Edge[T]]())\n\nproc addBiEdge[T](g:var Graph[T],e:Edge[T]):void =\n  var e_rev = e\n  swap(e_rev.src, e_rev.dst)\n  let (r, s) = (g[e.src].len, g[e.dst].len)\n  g[e.src].add(e)\n  g[e.dst].add(e_rev)\n  g[e.src][^1].rev = s\n  g[e.dst][^1].rev = r\nproc addBiEdge[T](g:var Graph[T],src,dst:int,weight:T=1):void =\n  g.addBiEdge(initEdge(src, dst, weight))\n\nproc initUndirectedGraph[T](n:int, a,b,c:seq[T]):Graph[T] =\n  var result = initGraph[T](n)\n  for i in 0..<a.len: result.addBiEdge(a[i], b[i], c[i])\nproc initUndirectedGraph[T](n:int, a,b:seq[T]):Graph[T] =\n  result = initGraph[T](n)\n  for i in 0..<a.len: result.addBiEdge(a[i], b[i], T(1))\nproc initGraph[T](n:int, a,b,c:seq[T]):Graph[T] =\n  var result = initGraph[T](n)\n  for i in 0..<a.len: result.addEdge(a[i], b[i], c[i])\nproc initGraph[T](n:int, a,b:seq[T]):Graph[T] =\n  result = initGraph[T](n)\n  for i in 0..<a.len: result.addEdge(a[i], b[i], T(1))\n\n\nproc addEdge[T](g:var Graph[T],e:Edge[T]):void =\n  g[e.src].add(e)\nproc addEdge[T](g:var Graph[T],src,dst:int,weight:T=1):void =\n  g.addEdge(initEdge(src, dst, weight, -1))\n\nproc `<`[T](l,r:Edge[T]):bool = l.weight < r.weight\n#}}}\n\nvar p1:int\n\nproc treeDiameter[T](g:Graph[T]):int =\n  proc dfs(idx, par:int):(T,int) =\n    result[1] = idx\n    for e in g[idx]:\n      if e.dst == par: continue\n      var cost = dfs(e.dst, idx)\n      cost[0] += e.weight\n      result = max(result, cost)\n  let\n    p = dfs(0, -1)\n    q = dfs(p[1], -1)\n  p1 = p[1]\n  return q[0]\n\n# depth first search {{{\nvar v = newSeq[int]()\nproc dfs0[T](g:Graph[T], u:int, p:int, h:int):bool =\n  if h == 0: return true\n  for e in g[u]:\n    if e.dst == p: continue\n    v.add(e.dst)\n    if g.dfs0(e.dst, u, h - 1): return true\n    discard v.pop()\n  return false\n#}}}\n\nvar max_depth = newSeq[int](N)\nvar size = newSeq[int](N)\n\nproc dfs1[T](g:Graph[T], u:int, p = -1, depth = 0):void =\n  max_depth[u] = depth\n  size[u] = 1\n  for e in g[u]:\n    if e.dst == p: continue\n    g.dfs1(e.dst, u, depth + 1)\n    max_depth[u] .max= max_depth[e.dst]\n    size[u] += size[e.dst]\n\nvar target_depth:int\n\nproc dfs2[T](g:Graph[T], u:int, p = -1, depth = 0):(Mint,Mint) =\n  if g[u].len == 1:\n    if depth == target_depth:\n      return (initMint(0), initMint(1))\n    else:\n      return (initMint(1), initMint(0))\n  result = (initMint(1), initMint(0))\n  for e in g[u]:\n    if e.dst == p: continue\n    let a = g.dfs2(e.dst, u, depth + 1)\n    if max_depth[e.dst] == target_depth:\n      var result2:(Mint,Mint)\n      # make e critical\n      result2[0] += result[0] * a[0]\n#      result2[1] += result[1] * t + result[0] * (t - a[0])\n      result2[1] += result[0] * a[1] + result[1] * a[0]\n      # make e non critical\n      let d = initMint(2) * initMint(3)^(size[e.dst] - 1)\n      result2[0] += result[0] * d\n      result2[1] += result[1] * d\n      swap(result, result2)\n    else:\n      # always non critical\n      let d = initMint(3)^size[e.dst]\n      result[0] *= d\n      result[1] *= d\n\nproc main() =\n  g := initUndirectedGraph[int](N, a, b)\n  let d = g.treeDiameter\n  v.add(p1)\n  discard g.dfs0(p1, -1, d)\n  target_depth = d div 2\n  if d mod 2 == 0:\n    let c = v[d div 2]\n    g.dfs1(c)\n    dp := newSeq[Mint](3)\n    dp[0] = initMint(1)\n    for e in g[c]:\n      let v0 = g.dfs2(e.dst, c, 1)\n      if max_depth[e.dst] < target_depth:\n        for b in 0..<dp.len: dp[b] *= initMint(3) * v0[0]\n      else:\n        dp2 := newSeq[Mint](3)\n        for b in 0..<dp.len:\n          # make e critical\n          if b < 2:\n            dp2[b + 1] += dp[b] * v0[1]\n          dp2[b] += dp[b] * v0[0]\n          # make e non critical\n          dp2[b] += dp[b] * initMint(2) * initMint(3)^(size[e.dst] - 1)\n        swap(dp, dp2)\n    echo dp[2]\n  else:\n    doassert(false)\n    let\n      c0 = v[d div 2]\n      c1 = v[d div 2 + 1]\n    g.dfs1(c0, c1)\n    g.dfs1(c1, c0)\n    let\n      v0 = g.dfs2(c0, c1)\n      v1 = g.dfs2(c1, c0)\n    echo v0[1] * v1[1]\n  return\n\nmain()"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n#}}}\n\nconst MOD = 998244353\nvar N:int\nvar a:seq[int]\nvar b:seq[int]\n\n#{{{ input part\nproc main()\nblock:\n  N = nextInt()\n  a = newSeqWith(N-1, 0)\n  b = newSeqWith(N-1, 0)\n  for i in 0..<N-1:\n    a[i] = nextInt() - 1\n    b[i] = nextInt() - 1\n#}}}\n\n#{{{ ModInt[Mod]\nproc getDefault(T:typedesc): T = (var temp:T;temp)\nproc getDefault[T](x:T): T = (var temp:T;temp)\n\ntype ModInt[Mod: static[int]] = object\n  v:int\nproc initModInt[T](a:T, Mod: static[int]):ModInt[Mod] =\n  when T is ModInt[Mod]:\n    return a\n  else:\n    var a = a\n    a = a mod Mod\n    if a < 0: a += Mod\n    result.v = a\nproc initModInt[T](a:T):ModInt[Mod] = initModInt(a, MOD)\nproc init[T](self:ModInt[Mod], a:T):ModInt[Mod] = initModInt(a, Mod)\nproc Identity(self:ModInt[Mod]):ModInt[Mod] = return initModInt(1, Mod)\n\nproc `==`[T](a:ModInt[Mod], b:T):bool = a.v == a.init(b).v\nproc `!=`[T](a:ModInt[Mod], b:T):bool = a.v != a.init(b).v\nproc `-`(self:ModInt[Mod]):ModInt[Mod] =\n  if self.v == 0: return self\n  else: return ModInt[Mod](v:MOD - self.v)\nproc `$`(a:ModInt[Mod]):string = return $(a.v)\n\nproc `+=`[T](self:var ModInt[Mod]; a:T):void =\n  self.v += initModInt(a, Mod).v\n  if self.v >= MOD: self.v -= MOD\nproc `-=`[T](self:var ModInt[Mod],a:T):void =\n  self.v -= initModInt(a, Mod).v\n  if self.v < 0: self.v += MOD\nproc `*=`[T](self:var ModInt[Mod],a:T):void =\n  self.v *= initModInt(a, Mod).v\n  self.v = self.v mod MOD\nproc `^=`(self:var ModInt[Mod], n:int) =\n  var (x,n,a) = (self,n,self.Identity)\n  while n > 0:\n    if (n and 1) > 0: a *= x\n    x *= x\n    n = (n shr 1)\n  swap(self, a)\nproc inverse(x:int):ModInt[Mod] =\n  var (a, b) = (x, MOD)\n  var (u, v) = (1, 0)\n  while b > 0:\n    let t = a div b\n    a -= t * b;swap(a,b)\n    u -= t * v;swap(u,v)\n  return initModInt(u, Mod)\nproc `/=`[T](a:var ModInt[Mod],b:T):void = a *= initModInt(b, Mod).v.inverse()\nproc `+`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result += b\nproc `-`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result -= b\nproc `*`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result *= b\nproc `/`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a; result /= b\nproc `^`(a:ModInt[Mod],b:int):ModInt[Mod] = result = a; result ^= b\n#}}}\n\ntype Mint = ModInt[Mod]\nproc initMint[T](a:T):ModInt[Mod] = initModInt(a, Mod)\n\n#{{{ Graph\nimport sequtils\n\ntype\n  Edge[T] = object\n    src,dst:int\n    weight:T\n    rev:int\n  Edges[T] = seq[Edge[T]]\n  Graph[T] = seq[seq[Edge[T]]]\n\nproc initEdge[T](src,dst:int,weight:T,rev:int = -1):Edge[T] =\n  var e:Edge[T]\n  e.src = src\n  e.dst = dst\n  e.weight = weight\n  e.rev = rev\n  return e\n\nproc initGraph[T](n:int):Graph[T] =\n  return newSeqWith(n,newSeq[Edge[T]]())\n\nproc addBiEdge[T](g:var Graph[T],e:Edge[T]):void =\n  var e_rev = e\n  swap(e_rev.src, e_rev.dst)\n  let (r, s) = (g[e.src].len, g[e.dst].len)\n  g[e.src].add(e)\n  g[e.dst].add(e_rev)\n  g[e.src][^1].rev = s\n  g[e.dst][^1].rev = r\nproc addBiEdge[T](g:var Graph[T],src,dst:int,weight:T=1):void =\n  g.addBiEdge(initEdge(src, dst, weight))\n\nproc initUndirectedGraph[T](n:int, a,b,c:seq[T]):Graph[T] =\n  var result = initGraph[T](n)\n  for i in 0..<a.len: result.addBiEdge(a[i], b[i], c[i])\nproc initUndirectedGraph[T](n:int, a,b:seq[T]):Graph[T] =\n  result = initGraph[T](n)\n  for i in 0..<a.len: result.addBiEdge(a[i], b[i], T(1))\nproc initGraph[T](n:int, a,b,c:seq[T]):Graph[T] =\n  var result = initGraph[T](n)\n  for i in 0..<a.len: result.addEdge(a[i], b[i], c[i])\nproc initGraph[T](n:int, a,b:seq[T]):Graph[T] =\n  result = initGraph[T](n)\n  for i in 0..<a.len: result.addEdge(a[i], b[i], T(1))\n\n\nproc addEdge[T](g:var Graph[T],e:Edge[T]):void =\n  g[e.src].add(e)\nproc addEdge[T](g:var Graph[T],src,dst:int,weight:T=1):void =\n  g.addEdge(initEdge(src, dst, weight, -1))\n\nproc `<`[T](l,r:Edge[T]):bool = l.weight < r.weight\n#}}}\n\nvar p1:int\n\nproc treeDiameter[T](g:Graph[T]):int =\n  proc dfs(idx, par:int):(T,int) =\n    result[1] = idx\n    for e in g[idx]:\n      if e.dst == par: continue\n      var cost = dfs(e.dst, idx)\n      cost[0] += e.weight\n      result = max(result, cost)\n  let\n    p = dfs(0, -1)\n    q = dfs(p[1], -1)\n  p1 = p[1]\n  return q[0]\n\n# depth first search {{{\nvar v = newSeq[int]()\nproc dfs0[T](g:Graph[T], u:int, p:int, h:int):bool =\n  if h == 0: return true\n  for e in g[u]:\n    if e.dst == p: continue\n    v.add(e.dst)\n    if g.dfs0(e.dst, u, h - 1): return true\n    discard v.pop()\n  return false\n#}}}\n\nvar max_depth = newSeq[int](N)\nvar size = newSeq[int](N)\n\nproc dfs1[T](g:Graph[T], u:int, p = -1, depth = 0):void =\n  max_depth[u] = depth\n  size[u] = 1\n  for e in g[u]:\n    if e.dst == p: continue\n    g.dfs1(e.dst, u, depth + 1)\n    max_depth[u] .max= max_depth[e.dst]\n    size[u] += size[e.dst]\n\nvar target_depth:int\n\nproc dfs2[T](g:Graph[T], u:int, p = -1, depth = 0):(Mint,Mint) =\n  if g[u].len == 1:\n    if depth == target_depth:\n      return (initMint(0), initMint(1))\n    else:\n      return (initMint(1), initMint(0))\n  result = (initMint(1), initMint(0))\n  for e in g[u]:\n    if e.dst == p: continue\n    let a = g.dfs2(e.dst, u, depth + 1)\n    if max_depth[e.dst] == target_depth:\n      var result2:(Mint,Mint)\n      # make e critical\n      result2[0] += result[0] * a[0]\n#      result2[1] += result[1] * t + result[0] * (t - a[0])\n      result2[1] += result[0] * a[1] + result[1] * a[0]\n      # make e non critical\n      let d = initMint(2) * initMint(3)^(size[e.dst] - 1)\n      result2[0] += result[0] * d\n      result2[1] += result[1] * d\n      swap(result, result2)\n    else:\n      # always non critical\n      let d = initMint(3)^size[e.dst]\n      result[0] *= d\n      result[1] *= d\n\nproc main() =\n  g := initUndirectedGraph[int](N, a, b)\n  let d = g.treeDiameter\n  v.add(p1)\n  doAssert g.dfs0(p1, -1, d)\n  target_depth = d div 2\n  if d mod 2 == 0:\n    let c = v[d div 2]\n    g.dfs1(c)\n    dp := newSeq[Mint](3)\n    dp[0] = initMint(1)\n    for e in g[c]:\n      let v0 = g.dfs2(e.dst, c, 1)\n      if max_depth[e.dst] < target_depth:\n        for b in 0..<dp.len: dp[b] *= initMint(3) * v0[0]\n      else:\n        dp2 := newSeq[Mint](3)\n        for b in 0..<dp.len:\n          # make e critical\n          if b < 2:\n            dp2[b + 1] += dp[b] * v0[1]\n            dp2[b] += dp[b] * v0[0]\n          # non critical\n          dp2[b] += dp[b] * initMint(2) * initMint(3)^(size[e.dst] - 1)\n        swap(dp, dp2)\n    echo dp[2]\n  else:\n    let\n      c0 = v[d div 2]\n      c1 = v[d div 2 + 1]\n    g.dfs1(c0, c1)\n    g.dfs1(c1, c0)\n    let\n      v0 = g.dfs2(c0, c1)\n      v1 = g.dfs2(c1, c0)\n    echo v0[1] * v1[1]\n  return\n\nmain()\n"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n#}}}\n\nconst MOD = 998244353\nvar N:int\nvar a:seq[int]\nvar b:seq[int]\n\n#{{{ input part\nproc main()\nblock:\n  N = nextInt()\n  a = newSeqWith(N-1, 0)\n  b = newSeqWith(N-1, 0)\n  for i in 0..<N-1:\n    a[i] = nextInt() - 1\n    b[i] = nextInt() - 1\n#}}}\n\n#{{{ ModInt[Mod]\nproc getDefault(T:typedesc): T = (var temp:T;temp)\nproc getDefault[T](x:T): T = (var temp:T;temp)\n\ntype ModInt[Mod: static[int]] = object\n  v:int\nproc initModInt[T](a:T, Mod: static[int]):ModInt[Mod] =\n  when T is ModInt[Mod]:\n    return a\n  else:\n    var a = a\n    a = a mod Mod\n    if a < 0: a += Mod\n    result.v = a\nproc initModInt[T](a:T):ModInt[Mod] = initModInt(a, MOD)\nproc init[T](self:ModInt[Mod], a:T):ModInt[Mod] = initModInt(a, Mod)\nproc Identity(self:ModInt[Mod]):ModInt[Mod] = return initModInt(1, Mod)\n\nproc `==`[T](a:ModInt[Mod], b:T):bool = a.v == a.init(b).v\nproc `!=`[T](a:ModInt[Mod], b:T):bool = a.v != a.init(b).v\nproc `-`(self:ModInt[Mod]):ModInt[Mod] =\n  if self.v == 0: return self\n  else: return ModInt[Mod](v:MOD - self.v)\nproc `$`(a:ModInt[Mod]):string = return $(a.v)\n\nproc `+=`[T](self:var ModInt[Mod]; a:T):void =\n  self.v += initModInt(a, Mod).v\n  if self.v >= MOD: self.v -= MOD\nproc `-=`[T](self:var ModInt[Mod],a:T):void =\n  self.v -= initModInt(a, Mod).v\n  if self.v < 0: self.v += MOD\nproc `*=`[T](self:var ModInt[Mod],a:T):void =\n  self.v *= initModInt(a, Mod).v\n  self.v = self.v mod MOD\nproc `^=`(self:var ModInt[Mod], n:int) =\n  var (x,n,a) = (self,n,self.Identity)\n  while n > 0:\n    if (n and 1) > 0: a *= x\n    x *= x\n    n = (n shr 1)\n  swap(self, a)\nproc inverse(x:int):ModInt[Mod] =\n  var (a, b) = (x, MOD)\n  var (u, v) = (1, 0)\n  while b > 0:\n    let t = a div b\n    a -= t * b;swap(a,b)\n    u -= t * v;swap(u,v)\n  return initModInt(u, Mod)\nproc `/=`[T](a:var ModInt[Mod],b:T):void = a *= initModInt(b, Mod).v.inverse()\nproc `+`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result += b\nproc `-`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result -= b\nproc `*`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result *= b\nproc `/`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a; result /= b\nproc `^`(a:ModInt[Mod],b:int):ModInt[Mod] = result = a; result ^= b\n#}}}\n\ntype Mint = ModInt[Mod]\nproc initMint[T](a:T):ModInt[Mod] = initModInt(a, Mod)\n\n#{{{ Graph\nimport sequtils\n\ntype\n  Edge[T] = object\n    src,dst:int\n    weight:T\n    rev:int\n  Edges[T] = seq[Edge[T]]\n  Graph[T] = seq[seq[Edge[T]]]\n\nproc initEdge[T](src,dst:int,weight:T,rev:int = -1):Edge[T] =\n  var e:Edge[T]\n  e.src = src\n  e.dst = dst\n  e.weight = weight\n  e.rev = rev\n  return e\n\nproc initGraph[T](n:int):Graph[T] =\n  return newSeqWith(n,newSeq[Edge[T]]())\n\nproc addBiEdge[T](g:var Graph[T],e:Edge[T]):void =\n  var e_rev = e\n  swap(e_rev.src, e_rev.dst)\n  let (r, s) = (g[e.src].len, g[e.dst].len)\n  g[e.src].add(e)\n  g[e.dst].add(e_rev)\n  g[e.src][^1].rev = s\n  g[e.dst][^1].rev = r\nproc addBiEdge[T](g:var Graph[T],src,dst:int,weight:T=1):void =\n  g.addBiEdge(initEdge(src, dst, weight))\n\nproc initUndirectedGraph[T](n:int, a,b,c:seq[T]):Graph[T] =\n  var result = initGraph[T](n)\n  for i in 0..<a.len: result.addBiEdge(a[i], b[i], c[i])\nproc initUndirectedGraph[T](n:int, a,b:seq[T]):Graph[T] =\n  result = initGraph[T](n)\n  for i in 0..<a.len: result.addBiEdge(a[i], b[i], T(1))\nproc initGraph[T](n:int, a,b,c:seq[T]):Graph[T] =\n  var result = initGraph[T](n)\n  for i in 0..<a.len: result.addEdge(a[i], b[i], c[i])\nproc initGraph[T](n:int, a,b:seq[T]):Graph[T] =\n  result = initGraph[T](n)\n  for i in 0..<a.len: result.addEdge(a[i], b[i], T(1))\n\n\nproc addEdge[T](g:var Graph[T],e:Edge[T]):void =\n  g[e.src].add(e)\nproc addEdge[T](g:var Graph[T],src,dst:int,weight:T=1):void =\n  g.addEdge(initEdge(src, dst, weight, -1))\n\nproc `<`[T](l,r:Edge[T]):bool = l.weight < r.weight\n#}}}\n\nvar p1:int\n\nproc treeDiameter[T](g:Graph[T]):int =\n  proc dfs(idx, par:int):(T,int) =\n    result[1] = idx\n    for e in g[idx]:\n      if e.dst == par: continue\n      var cost = dfs(e.dst, idx)\n      cost[0] += e.weight\n      result = max(result, cost)\n  let\n    p = dfs(0, -1)\n    q = dfs(p[1], -1)\n  p1 = p[1]\n  return q[0]\n\n# depth first search {{{\nvar v = newSeq[int]()\nproc dfs0[T](g:Graph[T], u:int, p:int, h:int):bool =\n  if h == 0: return true\n  for e in g[u]:\n    if e.dst == p: continue\n    v.add(e.dst)\n    if g.dfs0(e.dst, u, h - 1): return true\n    discard v.pop()\n  return false\n#}}}\n\nvar max_depth = newSeq[int](N)\nvar size = newSeq[int](N)\n\nproc dfs1[T](g:Graph[T], u:int, p = -1, depth = 0):void =\n  max_depth[u] = depth\n  size[u] = 1\n  for e in g[u]:\n    if e.dst == p: continue\n    g.dfs1(e.dst, u, depth + 1)\n    max_depth[u] .max= max_depth[e.dst]\n    size[u] += size[e.dst]\n\nvar target_depth:int\n\nproc dfs2[T](g:Graph[T], u:int, p = -1, depth = 0):(Mint,Mint) =\n  if g[u].len == 1:\n    if depth == target_depth:\n      return (initMint(0), initMint(1))\n    else:\n      return (initMint(1), initMint(0))\n  result = (initMint(1), initMint(0))\n  for e in g[u]:\n    if e.dst == p: continue\n    let a = g.dfs2(e.dst, u, depth + 1)\n    if max_depth[e.dst] == target_depth:\n      var result2:(Mint,Mint)\n      # make e critical\n      result2[0] += result[0] * a[0]\n#      result2[1] += result[1] * t + result[0] * (t - a[0])\n      result2[1] += result[0] * a[1] + result[1] * a[0]\n      # make e non critical\n      let d = initMint(2) * initMint(3)^(size[e.dst] - 1)\n      result2[0] += result[0] * d\n      result2[1] += result[1] * d\n      swap(result, result2)\n    else:\n      # always non critical\n      let d = initMint(3)^size[e.dst]\n      result[0] *= d\n      result[1] *= d\n\nproc main() =\n  g := initUndirectedGraph[int](N, a, b)\n  let d = g.treeDiameter\n  v.add(p1)\n  discard g.dfs0(p1, -1, d)\n  target_depth = d div 2\n  if d mod 2 == 0:\n    let c = v[d div 2]\n    g.dfs1(c)\n    dp := newSeq[Mint](3)\n    dp[0] = initMint(1)\n    for e in g[c]:\n      let v0 = g.dfs2(e.dst, c, 1)\n      if max_depth[e.dst] < target_depth:\n        for b in 0..<dp.len: dp[b] *= initMint(3) * v0[0]\n      else:\n        dp2 := newSeq[Mint](3)\n        for b in 0..<dp.len:\n          # make e critical\n          if b < 2:\n            dp2[b + 1] += dp[b] * v0[1]\n          dp2[b] += dp[b] * v0[0]\n          # non critical\n          dp2[b] += dp[b] * initMint(2) * initMint(3)^(size[e.dst] - 1)\n        swap(dp, dp2)\n    echo dp[2]\n  else:\n    let\n      c0 = v[d div 2]\n      c1 = v[d div 2 + 1]\n    g.dfs1(c0, c1)\n    g.dfs1(c1, c0)\n    let\n      v0 = g.dfs2(c0, c1)\n      v1 = g.dfs2(c1, c0)\n    echo v0[1] * v1[1]\n  return\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "BASE = 9973\nMOD1 = 10 ** 9 + 7\nMOD2 = 998244353\n\n\nclass RollingHash:\n    # 文字列Sのローリングハッシュを構築\n    # 計算量: O(N)\n    def __init__(self, S, MOD):\n        self.MOD = MOD\n        # acc[i]はS[0:i]のハッシュ値となる\n        self.acc = [0]\n        a = 0\n        # 累積和を計算するイメージ\n        for i, c in enumerate(S):\n            h = ord(c) - ord(\"a\") + 1\n            offset = pow(BASE, i, MOD)\n            a = (a + (h * offset)) % MOD\n            self.acc.append(a)\n\n    # S[i:j]のハッシュ値を返す\n    # 計算量: O(1)\n    def hash(self, i, j):\n        # 累積和を用いて部分区間の和を計算するイメージ\n        # 注意: 基数によるオフセットをキャンセルする必要がある\n        offset = pow(BASE, i, self.MOD)\n        # 素数MODを法とする剰余類における除算は逆元を乗算することで計算できる\n        # 素数MODを法とする剰余類におけるxの逆元はx^(MOD - 2)に等しい\n        offset_inv = pow(offset, self.MOD - 2, self.MOD)\n        return ((self.acc[j] - self.acc[i]) * offset_inv) % self.MOD\n\n\nN = int(input())\nS = input()\n\n# Sのローリングハッシュを計算しておく\nrolling1 = RollingHash(S, MOD1)\nrolling2 = RollingHash(S, MOD2)\n\n# 長さmのダジャレがSに含まれるならば、長さm-1のダジャレも含まれる\n# つまり、長さmのダジャレがSに含まれるならば真となる述語をP(m)とすると、以下を満たす整数cが存在する:\n#   - 0以上c以下の整数mについてP(m)は真\n#   - cより大きい整数mについてP(m)は偽\n# ※ Pは単調関数ということ\n# このcを二分探索で発見すれば高速化できる！\n\n# P(ok)は真\nok = 0\n# P(ng)は偽\nng = N\nwhile ng - ok > 1:\n    # 区間[ok, ng)の中央値をmとする\n    m = (ok + ng) // 2\n\n    # 長さmのダジャレが存在するか判定する\n    # 長さmのformerのハッシュ値のキャッシュ\n    former_cache1 = set()\n    former_cache2 = set()\n    p = False\n    # latterに着目してループを回す\n    for i in range(m, N):\n        # ダジャレ長を決め打ちしているのでjを直接計算できる\n        j = i + m\n        # S[i:j]がSをはみ出したらループ終了\n        if j > N:\n            break\n        # formerのハッシュ値をキャッシュする\n        former_cache1.add(rolling1.hash(i - m, i))\n        former_cache2.add(rolling2.hash(i - m, i))\n        # キャッシャに同一のハッシュ値が存在する場合（ハッシュ値が衝突した場合）、ダジャレになっていると判定できる\n        # ハッシュ値の計算、キャッシュ存在判定は共にO(1)で処理できる！\n        if (\n            rolling1.hash(i, j) in former_cache1\n            and rolling2.hash(i, j) in former_cache2\n        ):\n            p = True\n    # 区間[ok, ng) を更新\n    if p:\n        ok = m\n    else:\n        ng = m\n# whileループを抜けると区間[ok, ng)は[c, c + 1) になっている\nans = ok\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nmod=998244353\n\nN=int(input())\nE=[[] for i in range(N+1)]\n\nfor i in range(N-1):\n    x,y=map(int,input().split())\n    E[x].append(y)\n    E[y].append(x)\n\nQ=[1]\nD=[-1]*(N+1)\nD[1]=0\nwhile Q:\n    x=Q.pop()\n    for to in E[x]:\n        if D[to]==-1:\n            D[to]=D[x]+1\n            Q.append(to)\n            \nf=D.index(max(D))\nQ=[f]\nD=[-1]*(N+1)\nD[f]=0\nwhile Q:\n    x=Q.pop()\n    for to in E[x]:\n        if D[to]==-1:\n            D[to]=D[x]+1\n            Q.append(to)\n\nMAX=max(D)\nl=D.index(MAX)\nQ=[l]\nD2=[-1]*(N+1)\nD2[l]=0\nwhile Q:\n    x=Q.pop()\n    for to in E[x]:\n        if D2[to]==-1:\n            D2[to]=D2[x]+1\n            Q.append(to)\n\nif MAX%2==0:\n    for i in range(N+1):\n        if D[i]==MAX//2 and D2[i]==MAX//2:\n            c=i\n            break\n        \n    TOP_SORT=[]\n    \n    Q=[c]\n    D=[-1]*(N+1)\n    P=[-1]*(N+1)\n    D[c]=0\n    while Q:\n        x=Q.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if D[to]==-1:\n                D[to]=D[x]+1\n                Q.append(to)\n                P[to]=x\n\n    DP=[[[0,0,0] for i in range(3)] for i in range(N+1)]\n    # DP[x][p][m]で, plusのものが0個, 1個, 2個以上, minusのものが0個, 1個, 2個以上\n\n    for x in TOP_SORT[::-1]:\n        if D[x]==MAX//2:\n            DP[x][1][1]=1\n\n        elif len(E[x])==1:\n            DP[x][0][0]=1\n            \n        else:\n            for to in E[x]:\n                if to==P[x]:\n                    continue\n\n                X=[[0,0,0] for i in range(3)]\n                for i in range(3):\n                    for j in range(3):\n                        X[0][0]+=DP[to][i][j]\n                        X[i][0]+=DP[to][i][j]\n                        X[0][j]+=DP[to][i][j]\n                \n                if DP[x]==[[0,0,0] for i in range(3)]:\n                    DP[x]=X\n                    \n                else:\n                    Y=[[0,0,0] for i in range(3)]\n\n                    for i in range(3):\n                        for j in range(3):\n                            for k in range(3):\n                                for l in range(3):\n                                    Y[min(2,i+k)][min(2,j+l)]=(Y[min(2,i+k)][min(2,j+l)]+X[i][j]*DP[x][k][l])%mod\n\n                    DP[x]=Y\n\n    #print(DP)\n    print(DP[c][1][1]*pow(2,mod-2,mod)%mod)\n    \nelse:\n    for i in range(N+1):\n        if D[i]==MAX//2 and D2[i]==MAX//2+1:\n            c1=i\n        elif D[i]==MAX//2+1 and D2[i]==MAX//2:\n            c2=i\n        \n    TOP_SORT=[]\n    \n    Q=[c1,c2]\n    D=[-1]*(N+1)\n    P=[-1]*(N+1)\n    D[c1]=0\n    D[c2]=0\n    \n    while Q:\n        x=Q.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if D[to]==-1:\n                D[to]=D[x]+1\n                Q.append(to)\n                P[to]=x\n\n    DP=[[[0,0,0] for i in range(3)] for i in range(N+1)]\n    # DP[x][p][m]で, plusのものが0個, 1個, 2個以上, minusのものが0個, 1個, 2個以上\n\n    for x in TOP_SORT[::-1]:\n        if D[x]==MAX//2:\n            DP[x][1][1]=1\n\n        elif len(E[x])==1:\n            DP[x][0][0]=1\n            \n        else:\n            for to in E[x]:\n                if to==P[x]:\n                    continue\n\n                X=[[0,0,0] for i in range(3)]\n                for i in range(3):\n                    for j in range(3):\n                        X[0][0]+=DP[to][i][j]\n                        X[i][0]+=DP[to][i][j]\n                        X[0][j]+=DP[to][i][j]\n                \n                if DP[x]==[[0,0,0] for i in range(3)]:\n                    DP[x]=X\n                    \n                else:\n                    Y=[[0,0,0] for i in range(3)]\n\n                    for i in range(3):\n                        for j in range(3):\n                            for k in range(3):\n                                for l in range(3):\n                                    Y[min(2,i+k)][min(2,j+l)]=(Y[min(2,i+k)][min(2,j+l)]+X[i][j]*DP[x][k][l])%mod\n\n                    DP[x]=Y\n\n    #print(DP)\n    print(DP[c2][1][1]*pow(2,mod-2,mod)%mod)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nmod=998244353\n\nN=int(input())\nE=[[] for i in range(N+1)]\n\nfor i in range(N-1):\n    x,y=map(int,input().split())\n    E[x].append(y)\n    E[y].append(x)\n\nQ=[1]\nD=[-1]*(N+1)\nD[1]=0\nwhile Q:\n    x=Q.pop()\n    for to in E[x]:\n        if D[to]==-1:\n            D[to]=D[x]+1\n            Q.append(to)\n            \nf=D.index(max(D))\nQ=[f]\nD=[-1]*(N+1)\nD[f]=0\nwhile Q:\n    x=Q.pop()\n    for to in E[x]:\n        if D[to]==-1:\n            D[to]=D[x]+1\n            Q.append(to)\n\nMAX=max(D)\nl=D.index(MAX)\nQ=[l]\nD2=[-1]*(N+1)\nD2[l]=0\nwhile Q:\n    x=Q.pop()\n    for to in E[x]:\n        if D2[to]==-1:\n            D2[to]=D2[x]+1\n            Q.append(to)\n\nif MAX%2==0:\n    for i in range(N+1):\n        if D[i]==MAX//2 and D2[i]==MAX//2:\n            c=i\n            break\n        \n    TOP_SORT=[]\n    \n    Q=[c]\n    D=[-1]*(N+1)\n    P=[-1]*(N+1)\n    D[c]=0\n    while Q:\n        x=Q.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if D[to]==-1:\n                D[to]=D[x]+1\n                Q.append(to)\n                P[to]=x\n\n    DP=[[0,0,0] for i in range(N+1)]\n    # 中心からの距離が条件を満たすものが、0個, 1個, 2個以上\n\n    for x in TOP_SORT[::-1]:\n        if D[x]==MAX//2:\n            DP[x]=[0,1,0]\n\n        elif len(E[x])==1:\n            DP[x]=[1,0,0]\n\n        elif x==c:\n            True\n            \n        else:\n            for to in E[x]:\n                if to==P[x]:\n                    continue\n                xt,yt,zt=DP[to]\n                x1,y1,z1=xt*3+yt*2+zt*2,yt,zt\n                \n                if DP[x]==[0,0,0]:\n                    DP[x]=[x1,y1,z1]\n                else:\n                    x0,y0,z0=DP[x]\n                    DP[x]=[x0*x1%mod,(x1*y0+x0*y1)%mod,(y0*y1+z0*(x1+y1+z1)+z1*(x0+y0))%mod]\n\n    ANS=[0,0,0] # 0個, 1個, 2個ちょうど\n    for to in E[c]:\n        xt,yt,zt=DP[to]\n        x1,y1,z1=xt*3+yt*2+zt*2,yt,zt\n        \n        if ANS==[0,0,0]:\n            ANS=[x1,y1,z1]\n\n        else:\n            x0,y0,z0=ANS\n            ANS=[x0*x1%mod,(x1*y0+x0*y1)%mod,(y1*y0+y0*y1)%mod]\n\n    print(ANS[2]*pow(2,mod-2,mod)%mod)\nelse:\n    A[10000]"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nmod=998244353\n\nN=int(input())\nE=[[] for i in range(N+1)]\n\nfor i in range(N-1):\n    x,y=map(int,input().split())\n    E[x].append(y)\n    E[y].append(x)\n\nQ=[1]\nD=[-1]*(N+1)\nD[1]=0\nwhile Q:\n    x=Q.pop()\n    for to in E[x]:\n        if D[to]==-1:\n            D[to]=D[x]+1\n            Q.append(to)\n            \nf=D.index(max(D))\nQ=[f]\nD=[-1]*(N+1)\nD[f]=0\nwhile Q:\n    x=Q.pop()\n    for to in E[x]:\n        if D[to]==-1:\n            D[to]=D[x]+1\n            Q.append(to)\n\nMAX=max(D)\nl=D.index(MAX)\nQ=[l]\nD2=[-1]*(N+1)\nD2[l]=0\nwhile Q:\n    x=Q.pop()\n    for to in E[x]:\n        if D2[to]==-1:\n            D2[to]=D2[x]+1\n            Q.append(to)\n\nif MAX%2==0:\n    for i in range(N+1):\n        if D[i]==MAX//2 and D2[i]==MAX//2:\n            c=i\n            break\n        \n    TOP_SORT=[]\n    \n    Q=[c]\n    D=[-1]*(N+1)\n    P=[-1]*(N+1)\n    D[c]=0\n    while Q:\n        x=Q.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if D[to]==-1:\n                D[to]=D[x]+1\n                Q.append(to)\n                P[to]=x\n\n    DP=[[[0,0,0] for i in range(3)] for i in range(N+1)]\n    # DP[x][p][m]で, plusのものが0個, 1個, 2個以上, minusのものが0個, 1個, 2個以上\n\n    for x in TOP_SORT[::-1]:\n        if D[x]==MAX//2:\n            DP[x][1][1]=1\n\n        elif len(E[x])==1:\n            DP[x][0][0]=1\n            \n        else:\n            for to in E[x]:\n                if to==P[x]:\n                    continue\n\n                X=[[0,0,0] for i in range(3)]\n                for i in range(3):\n                    for j in range(3):\n                        X[0][0]+=DP[to][i][j]\n                        X[i][0]+=DP[to][i][j]\n                        X[0][j]+=DP[to][i][j]\n                \n                if DP[x]==[[0,0,0] for i in range(3)]:\n                    DP[x]=X\n                    \n                else:\n                    Y=[[0,0,0] for i in range(3)]\n\n                    for i in range(3):\n                        for j in range(3):\n                            for k in range(3):\n                                for l in range(3):\n                                    Y[min(2,i+k)][min(2,j+l)]=(Y[min(2,i+k)][min(2,j+l)]+X[i][j]*DP[x][k][l])%mod\n\n                    DP[x]=Y\n\n    #print(DP)\n    print(DP[c][1][1]*pow(2,mod-2,mod)%mod)\n    \nelse:\n    A[10000]\n            \n            \n                    \n                \n                \n            \n\n        \n\n            \n            \n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nmod=998244353\n\nN=int(input())\nE=[[] for i in range(N+1)]\n\nfor i in range(N-1):\n    x,y=map(int,input().split())\n    E[x].append(y)\n    E[y].append(x)\n\nQ=[1]\nD=[-1]*(N+1)\nD[1]=0\nwhile Q:\n    x=Q.pop()\n    for to in E[x]:\n        if D[to]==-1:\n            D[to]=D[x]+1\n            Q.append(to)\n            \nf=D.index(max(D))\nQ=[f]\nD=[-1]*(N+1)\nD[f]=0\nwhile Q:\n    x=Q.pop()\n    for to in E[x]:\n        if D[to]==-1:\n            D[to]=D[x]+1\n            Q.append(to)\n\nMAX=max(D)\nl=D.index(MAX)\nQ=[l]\nD2=[-1]*(N+1)\nD2[l]=0\nwhile Q:\n    x=Q.pop()\n    for to in E[x]:\n        if D2[to]==-1:\n            D2[to]=D2[x]+1\n            Q.append(to)\n\nif MAX%2==0:\n    for i in range(N+1):\n        if D[i]==MAX//2 and D2[i]==MAX//2:\n            c=i\n            break\n        \n    TOP_SORT=[]\n    \n    Q=[c]\n    D=[-1]*(N+1)\n    P=[-1]*(N+1)\n    D[c]=0\n    while Q:\n        x=Q.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if D[to]==-1:\n                D[to]=D[x]+1\n                Q.append(to)\n                P[to]=x\n\n    DP=[[[0,0,0] for i in range(3)] for i in range(N+1)]\n    # DP[x][p][m]で, plusのものが0個, 1個, 2個以上, minusのものが0個, 1個, 2個以上\n\n    for x in TOP_SORT[::-1]:\n        if D[x]==MAX//2:\n            DP[x][1][1]=1\n\n        elif len(E[x])==1:\n            DP[x][0][0]=1\n            \n        else:\n            for to in E[x]:\n                if to==P[x]:\n                    continue\n\n                X=[[0,0,0] for i in range(3)]\n                for i in range(3):\n                    for j in range(3):\n                        X[0][0]+=DP[to][i][j]\n                        X[i][0]+=DP[to][i][j]\n                        X[0][j]+=DP[to][i][j]\n                \n                if DP[x]==[[0,0,0] for i in range(3)]:\n                    DP[x]=X\n                    \n                else:\n                    Y=[[0,0,0] for i in range(3)]\n\n                    for i in range(3):\n                        for j in range(3):\n                            for k in range(3):\n                                for l in range(3):\n                                    Y[min(2,i+k)][min(2,j+l)]=(Y[min(2,i+k)][min(2,j+l)]+X[i][j]*DP[x][k][l])%mod\n\n                    DP[x]=Y\n\n    #print(DP)\n    print(DP[c][1][1]*pow(2,mod-2,mod)%mod)\n    \nelse:\n    for i in range(N+1):\n        if D[i]==MAX//2 and D2[i]==MAX//2+1:\n            c1=i\n        elif D[i]==MAX//2+1 and D2[i]==MAX//2:\n            c2=i\n        \n    TOP_SORT=[]\n    \n    Q=[c1,c2]\n    D=[-1]*(N+1)\n    P=[-1]*(N+1)\n    D[c1]=0\n    D[c2]=0\n    P[c1]=c2\n    P[c2]=c1\n    \n    while Q:\n        x=Q.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if D[to]==-1:\n                D[to]=D[x]+1\n                Q.append(to)\n                P[to]=x\n\n    DP=[[[0,0,0] for i in range(3)] for i in range(N+1)]\n    # DP[x][p][m]で, plusのものが0個, 1個, 2個以上, minusのものが0個, 1個, 2個以上\n\n    for x in TOP_SORT[::-1]:\n        if D[x]==MAX//2:\n            DP[x][1][1]=1\n\n        elif len(E[x])==1:\n            DP[x][0][0]=1\n            \n        else:\n            for to in E[x]:\n                if to==P[x]:\n                    continue\n\n                X=[[0,0,0] for i in range(3)]\n                for i in range(3):\n                    for j in range(3):\n                        X[0][0]+=DP[to][i][j]\n                        X[i][0]+=DP[to][i][j]\n                        X[0][j]+=DP[to][i][j]\n                \n                if DP[x]==[[0,0,0] for i in range(3)]:\n                    DP[x]=X\n                    \n                else:\n                    Y=[[0,0,0] for i in range(3)]\n\n                    for i in range(3):\n                        for j in range(3):\n                            for k in range(3):\n                                for l in range(3):\n                                    Y[min(2,i+k)][min(2,j+l)]=(Y[min(2,i+k)][min(2,j+l)]+X[i][j]*DP[x][k][l])%mod\n\n                    DP[x]=Y\n\n    #print(DP[c1])\n    #print(DP[c2])\n    print(sum(DP[c1][1])*sum(DP[c2][1])%mod)"
  }
]