[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MOD 998244353\n#define MAX_N 2005\n\nint n, original_diameter;\nint graph[MAX_N][MAX_N];\nint dist[MAX_N][MAX_N];\n\nvoid floyd_warshall() {\n    for (int k = 1; k <= n; k++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (dist[i][k] + dist[k][j] < dist[i][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }\n    }\n}\n\nint calculate_diameter() {\n    int max_dist = 0;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            max_dist = (dist[i][j] > max_dist) ? dist[i][j] : max_dist;\n        }\n    }\n    return max_dist;\n}\n\nbool can_reduce_diameter(int u, int v) {\n    for (int x = 1; x <= n; x++) {\n        for (int y = 1; y <= n; y++) {\n            int current_dist = dist[x][y];\n            int new_dist = (dist[x][u] + 1 + dist[v][y] < current_dist) ||\n                           (dist[x][v] + 1 + dist[u][y] < current_dist);\n            \n            if (new_dist) return true;\n        }\n    }\n    return false;\n}\n\nvoid solve() {\n    scanf(\"%d\", &n);\n    \n    memset(graph, 0, sizeof(graph));\n    memset(dist, 0x3f, sizeof(dist));\n    \n    for (int i = 1; i <= n; i++) {\n        dist[i][i] = 0;\n    }\n    \n    for (int i = 1; i < n; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        graph[a][b] = graph[b][a] = 1;\n        dist[a][b] = dist[b][a] = 1;\n    }\n    \n    floyd_warshall();\n    original_diameter = calculate_diameter();\n    \n    long long result = 0;\n    \n    for (int u = 1; u <= n; u++) {\n        for (int v = u + 1; v <= n; v++) {\n            if (graph[u][v]) continue;\n            \n            dist[u][v] = dist[v][u] = 1;\n            floyd_warshall();\n            \n            int new_diameter = calculate_diameter();\n            \n            if (new_diameter == original_diameter && !can_reduce_diameter(u, v)) {\n                result++;\n            }\n            \n            dist[u][v] = dist[v][u] = 0x3f3f3f3f;\n            floyd_warshall();\n        }\n    }\n    \n    printf(\"%lld\\n\", result % MOD);\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:35:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 998244353\n#define MAXN 2005\n\nint N;\nint a[MAXN], b[MAXN];\nint dist[MAXN][MAXN];\nint adj[MAXN][MAXN];\nint diameter;\nint cnt[MAXN];\n\nvoid bfs(int start) {\n    int queue[MAXN], front = 0, rear = 0;\n    int visited[MAXN];\n    memset(visited, -1, sizeof(visited));\n    visited[start] = 0;\n    queue[rear++] = start;\n    while (front < rear) {\n        int u = queue[front++];\n        for (int v = 1; v <= N; v++) {\n            if (adj[u][v] && visited[v] == -1) {\n                visited[v] = visited[u] + 1;\n                queue[rear++] = v;\n            }\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        dist[start][i] = visited[i];\n    }\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            adj[i][j] = 0;\n        }\n    }\n    for (int i = 0; i < N-1; i++) {\n        scanf(\"%d %d\", &a[i], &b[i]);\n        adj[a[i]][b[i]] = 1;\n        adj[b[i]][a[i]] = 1;\n    }\n\n    for (int i = 1; i <= N; i++) {\n        bfs(i);\n    }\n\n    diameter = 0;\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            if (dist[i][j] > diameter) {\n                diameter = dist[i][j];\n            }\n        }\n    }\n\n    for (int i = 1; i <= N; i++) {\n        for (int j = i+1; j <= N; j++) {\n            if (dist[i][j] == diameter) {\n                cnt[i]++;\n                cnt[j]++;\n            }\n        }\n    }\n\n    int res = 1;\n    for (int i = 1; i <= N; i++) {\n        if (cnt[i] > 0) {\n            res = (res * 2) % MOD;\n        }\n    }\n\n    printf(\"%d\\n\", res);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:35:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint N;\nvector<vector<int>> G;\nvector<int> dist;\n\nvoid bfs(int s) {\n    dist.assign(N + 1, -1);\n    queue<int> q;\n    dist[s] = 0;\n    q.push(s);\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : G[u]) {\n            if (dist[v] == -1) {\n                dist[v] = dist[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n}\n\nint main() {\n    cin >> N;\n    G.resize(N + 1);\n    for (int i = 0; i < N - 1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    bfs(1);\n    int u = max_element(dist.begin() + 1, dist.end()) - dist.begin();\n    bfs(u);\n    int v = max_element(dist.begin() + 1, dist.end()) - dist.begin();\n    int D = dist[v];\n\n    vector<int> diam;\n    bfs(u);\n    vector<int> dist_u = dist;\n    bfs(v);\n    vector<int> dist_v = dist;\n    for (int i = 1; i <= N; ++i) {\n        if (dist_u[i] + dist_v[i] == D) {\n            diam.push_back(i);\n        }\n    }\n\n    int center1 = diam[diam.size() / 2];\n    int center2 = -1;\n    if (diam.size() % 2 == 0) {\n        center2 = diam[diam.size() / 2 - 1];\n    }\n\n    vector<int> cnt(N + 1);\n    function<void(int, int, int)> dfs = [&](int u, int p, int d) {\n        if (d == D / 2) {\n            cnt[u]++;\n            return;\n        }\n        for (int v : G[u]) {\n            if (v != p) {\n                dfs(v, u, d + 1);\n            }\n        }\n    };\n\n    if (center2 == -1) {\n        dfs(center1, -1, 0);\n    } else {\n        dfs(center1, center2, 0);\n        dfs(center2, center1, 0);\n    }\n\n    long long ans = 1;\n    long long sum = 0;\n    for (int i = 1; i <= N; ++i) {\n        if (cnt[i] > 0) {\n            ans = ans * cnt[i] % MOD;\n            sum = (sum + cnt[i]) % MOD;\n        }\n    }\n\n    if (center2 != -1) {\n        ans = (ans * 2) % MOD;\n    } else {\n        ans = (ans - sum + MOD) % MOD;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:36:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final int MOD = 998244353;\n    static int N;\n    static List<Integer>[] tree;\n    static int[] dist;\n    static int[][] distance;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        N = Integer.parseInt(br.readLine());\n        tree = new ArrayList[N + 1];\n        for (int i = 1; i <= N; i++) {\n            tree[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < N - 1; i++) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(st.nextToken());\n            int b = Integer.parseInt(st.nextToken());\n            tree[a].add(b);\n            tree[b].add(a);\n        }\n\n        distance = new int[N + 1][N + 1];\n        for (int i = 1; i <= N; i++) {\n            bfs(i, distance[i]);\n        }\n\n        int diamG = 0;\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= N; j++) {\n                diamG = Math.max(diamG, distance[i][j]);\n            }\n        }\n\n        int[] cnt = new int[diamG + 1];\n        for (int i = 1; i <= N; i++) {\n            for (int j = i + 1; j <= N; j++) {\n                cnt[distance[i][j]]++;\n            }\n        }\n\n        long res = 1;\n        for (int d = 1; d < diamG; d++) {\n            res = res * pow(2, cnt[d]) % MOD;\n        }\n        System.out.println(res);\n    }\n\n    static void bfs(int start, int[] dist) {\n        Arrays.fill(dist, -1);\n        Queue<Integer> q = new LinkedList<>();\n        dist[start] = 0;\n        q.add(start);\n        while (!q.isEmpty()) {\n            int u = q.poll();\n            for (int v : tree[u]) {\n                if (dist[v] == -1) {\n                    dist[v] = dist[u] + 1;\n                    q.add(v);\n                }\n            }\n        }\n    }\n\n    static long pow(long a, long b) {\n        long res = 1;\n        while (b > 0) {\n            if ((b & 1) == 1) {\n                res = res * a % MOD;\n            }\n            a = a * a % MOD;\n            b >>= 1;\n        }\n        return res;\n    }\n}",
    "timestamp": "2025-08-05 22:37:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    static final int MOD = 998244353;\n    static int N;\n    static List<List<Integer>> graph;\n    static int originalDiameter;\n\n    public static int countGraphs() {\n        // Calculate original diameter\n        originalDiameter = calculateDiameter(graph);\n        \n        // Find all possible candidate edges\n        List<int[]> candidateEdges = findCandidateEdges();\n        \n        // Recursive backtracking to count valid graphs\n        return backtrack(candidateEdges, new HashSet<>(), 0);\n    }\n\n    static int backtrack(List<int[]> candidates, Set<int[]> addedEdges, int index) {\n        // Base case: processed all candidates\n        if (index == candidates.size()) {\n            // Create graph with added edges\n            List<List<Integer>> newGraph = copyGraph(graph);\n            for (int[] edge : addedEdges) {\n                addEdge(newGraph, edge[0], edge[1]);\n            }\n            \n            // Check diameter condition\n            if (calculateDiameter(newGraph) == originalDiameter) {\n                return 1;\n            }\n            return 0;\n        }\n        \n        // Don't add current edge\n        int result = backtrack(candidates, addedEdges, index + 1);\n        \n        // Try adding current edge\n        int[] currentEdge = candidates.get(index);\n        addedEdges.add(currentEdge);\n        result = (result + backtrack(candidates, addedEdges, index + 1)) % MOD;\n        addedEdges.remove(currentEdge);\n        \n        return result;\n    }\n\n    static List<int[]> findCandidateEdges() {\n        List<int[]> candidates = new ArrayList<>();\n        for (int u = 0; u < N; u++) {\n            for (int v = u + 1; v < N; v++) {\n                if (!isConnected(graph, u, v)) {\n                    candidates.add(new int[]{u, v});\n                }\n            }\n        }\n        return candidates;\n    }\n\n    static int calculateDiameter(List<List<Integer>> g) {\n        int maxDiameter = 0;\n        for (int start = 0; start < N; start++) {\n            int[] distances = bfs(g, start);\n            int maxDistance = 0;\n            for (int dist : distances) {\n                maxDistance = Math.max(maxDistance, dist);\n            }\n            maxDiameter = Math.max(maxDiameter, maxDistance);\n        }\n        return maxDiameter;\n    }\n\n    static int[] bfs(List<List<Integer>> g, int start) {\n        int[] distances = new int[N];\n        Arrays.fill(distances, Integer.MAX_VALUE);\n        distances[start] = 0;\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(start);\n        \n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            for (int neighbor : g.get(current)) {\n                if (distances[neighbor] == Integer.MAX_VALUE) {\n                    distances[neighbor] = distances[current] + 1;\n                    queue.offer(neighbor);\n                }\n            }\n        }\n        \n        return distances;\n    }\n\n    static boolean isConnected(List<List<Integer>> g, int u, int v) {\n        return g.get(u).contains(v);\n    }\n\n    static void addEdge(List<List<Integer>> g, int u, int v) {\n        g.get(u).add(v);\n        g.get(v).add(u);\n    }\n\n    static List<List<Integer>> copyGraph(List<List<Integer>> original) {\n        List<List<Integer>> copy = new ArrayList<>();\n        for (List<Integer> list : original) {\n            copy.add(new ArrayList<>(list));\n        }\n        return copy;\n    }\n\n    public static void main(String[] args) {\n        // Input parsing and graph construction would go here\n        // This is just a template method\n        N = /* number of vertices */;\n        graph = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        // Add initial edges\n        // graph.get(a).add(b);\n        \n        System.out.println(countGraphs());\n    }\n}",
    "timestamp": "2025-08-05 22:37:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\nconst int MAXN = 200005;\n\nvector<int> adj[MAXN];\nint N, M;\n\nint diameter(vector<int> graph[], int n) {\n    auto bfs = [&](int start) {\n        vector<int> dist(n + 1, -1);\n        queue<int> q;\n        q.push(start);\n        dist[start] = 0;\n        int maxDist = 0, maxNode = start;\n\n        while (!q.empty()) {\n            int curr = q.front();\n            q.pop();\n\n            for (int next : graph[curr]) {\n                if (dist[next] == -1) {\n                    dist[next] = dist[curr] + 1;\n                    q.push(next);\n                    if (dist[next] > maxDist) {\n                        maxDist = dist[next];\n                        maxNode = next;\n                    }\n                }\n            }\n        }\n        return make_pair(maxNode, maxDist);\n    };\n\n    auto [end1, _] = bfs(1);\n    auto [end2, dia] = bfs(end1);\n    return dia;\n}\n\nbool is_critical_edge(vector<int> graph[], int n) {\n    int origDia = diameter(graph, n);\n    \n    int result = 0;\n    for (int u = 1; u <= n; u++) {\n        for (int v = u + 1; v <= n; v++) {\n            bool connected = false;\n            for (int neighbor : graph[u]) {\n                if (neighbor == v) {\n                    connected = true;\n                    break;\n                }\n            }\n            \n            if (!connected) {\n                graph[u].push_back(v);\n                graph[v].push_back(u);\n                \n                int newDia = diameter(graph, n);\n                if (newDia >= origDia) {\n                    result++;\n                }\n                \n                graph[u].pop_back();\n                graph[v].pop_back();\n            }\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> N >> M;\n    \n    for (int i = 0; i < M; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    \n    int ways = is_critical_edge(adj, N);\n    cout << ways % MOD << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:37:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nsys.setrecursionlimit(10**6)\n\nMOD = 998244353\n\ndef dfs(u, adj, visited):\n    visited[u] = True\n    max_dist = 0\n    farthest_node = u\n    \n    for v in adj[u]:\n        if not visited[v]:\n            dist, node = dfs(v, adj, visited)\n            if dist + 1 > max_dist:\n                max_dist = dist + 1\n                farthest_node = node\n    \n    return max_dist, farthest_node\n\ndef tree_diameter(adj, n):\n    visited = [False] * n\n    _, farthest_node = dfs(0, adj, visited)\n    \n    visited = [False] * n\n    diameter, _ = dfs(farthest_node, adj, visited)\n    \n    return diameter\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    \n    edges = []\n    for _ in range(N - 1):\n        a = int(data[idx]) - 1\n        b = int(data[idx+1]) - 1\n        edges.append((a, b))\n        idx += 2\n    \n    adj = [[] for _ in range(N)]\n    for a, b in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n\n    diameter_g = tree_diameter(adj, N)\n    \n    # Finding the count of H with the same diameter as G\n    # Since we can't add any edges to these graphs without reducing the diameter \n    # due to the problem constraints, the count is straightforward.\n    result = pow(2, (N * (N - 1) // 2 - (N - 1)), MOD)\n\n    print(result)\n\nsolve()",
    "timestamp": "2025-08-13 11:34:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final int MOD = 998244353;\n\n    static int add(int a, int b) {\n        return (a + b) % MOD;\n    }\n\n    // Helper function to calculate power with mod.\n    static int powMod(int x, int y) {\n        int res = 1;\n        while (y > 0) {\n            if ((y & 1) != 0) res = (int)(1L * res * x % MOD);\n            x = (int)(1L * x * x % MOD);\n            y >>= 1;\n        }\n        return res;\n    }\n\n    // Helper function to calculate factorial with mod\n    static int factorialMod(int n) {\n        int result = 1;\n        for (int i = 1; i <= n; i++) {\n            result = (int)(1L * result * i % MOD);\n        }\n        return result;\n    }\n\n    // Helper function to calculate combinations with mod\n    static int combMod(int n, int k) {\n        if (k > n) return 0;\n        int num = factorialMod(n);\n        int denom = powMod(factorialMod(k), MOD - 2);\n        denom = (int)(1L * denom * powMod(factorialMod(n - k), MOD - 2) % MOD);\n        return (int)(1L * num * denom % MOD);\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = Integer.parseInt(br.readLine());\n        int[] a = new int[n - 1];\n        int[] b = new int[n - 1];\n        for (int i = 0; i < n - 1; i++) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            a[i] = Integer.parseInt(st.nextToken()) - 1;\n            b[i] = Integer.parseInt(st.nextToken()) - 1;\n        }\n\n        // Maximum possible edges in graph\n        int maxEdges = n * (n - 1) / 2;\n\n        // Number of ways to delete edges\n        int totalGraphs = powMod(2, maxEdges - (n - 1));\n\n        // Number of graphs satisfying all conditions:\n        // Assuming only some ways can satisfy constraints like equal diameters and no reduction.\n        int validGraphCount = combMod(totalGraphs, n - 1);\n\n        pw.println(validGraphCount);\n        pw.close();\n    }\n}",
    "timestamp": "2025-08-13 11:35:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MOD 998244353\n\n// Function to calculate power with mod\nlong long power_mod(long long a, long long b, long long mod) {\n    long long res = 1;\n    while (b > 0) {\n        if (b % 2 == 1)\n            res = (res * a) % mod;\n        a = (a * a) % mod;\n        b /= 2;\n    }\n    return res;\n}\n\n// Function to calculate factorial with mod\nlong long factorial_mod(int n, long long mod) {\n    long long res = 1;\n    for (int i = 2; i <= n; ++i)\n        res = (res * i) % mod;\n    return res;\n}\n\n// Find union of two sets\nint find_set(int v, int parent[]) {\n    if (v == parent[v]) return v;\n    return parent[v] = find_set(parent[v], parent);\n}\n\n// Union by rank\nvoid union_sets(int a, int b, int parent[], int rank[]) {\n    a = find_set(a, parent);\n    b = find_set(b, parent);\n    if (a != b) {\n        if (rank[a] < rank[b])\n            parent[a] = b;\n        else if (rank[a] > rank[b])\n            parent[b] = a;\n        else {\n            parent[b] = a;\n            rank[a]++;\n        }\n    }\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d\", &N);\n\n    int parent[N + 1], rank[N + 1];\n    for (int i = 1; i <= N; ++i) { \n        parent[i] = i;\n        rank[i] = 0;\n    }\n\n    int edges[N - 1][2];\n    \n    for (int i = 0; i < N - 1; ++i) {\n        scanf(\"%d%d\", &edges[i][0], &edges[i][1]);\n        union_sets(edges[i][0], edges[i][1], parent, rank);\n    }\n\n    // Find the number of connected components\n    int components = 0;\n    for (int i = 1; i <= N; ++i) {\n        if (find_set(i, parent) == i)\n            components++;\n    }\n\n    // Calculate the number of ways to add edges\n    long long result = power_mod(2, N - 1, MOD);\n\n    // Handle the power of components\n    result = (result * power_mod(2, components - 1, MOD)) % MOD;\n\n    // Output the result\n    printf(\"%lld\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:35:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countValidGraphs(N, edges) {\n    const MOD = 998244353;\n\n    // Precompute powers of 2 up to N choose 2\n    const maxEdges = (N * (N - 1)) / 2;\n    const pow2 = new Array(maxEdges + 1).fill(1);\n\n    for (let i = 1; i <= maxEdges; i++) {\n        pow2[i] = (pow2[i - 1] * 2) % MOD;\n    }\n\n    // Helper function to compute the diameter of a tree\n    function treeDiameter(edges) {\n        // BFS to find the farthest node\n        function bfs(start) {\n            const dist = new Array(N + 1).fill(-1);\n            const queue = [start];\n            dist[start] = 0;\n            let farthestNode = start;\n\n            while (queue.length > 0) {\n                let current = queue.shift();\n                \n                for (let neighbor of adjacencyList[current]) {\n                    if (dist[neighbor] === -1) {\n                        dist[neighbor] = dist[current] + 1;\n                        queue.push(neighbor);\n                        if (dist[neighbor] > dist[farthestNode]) {\n                            farthestNode = neighbor;\n                        }\n                    }\n                }\n            }\n            return { farthestNode, distance: dist[farthestNode] };\n        }\n\n        // Adjacency list of the tree\n        let adjacencyList = Array.from({ length: N + 1 }, () => []);\n        \n        for (let [a, b] of edges) {\n            adjacencyList[a].push(b);\n            adjacencyList[b].push(a);\n        }\n\n        // Find the diameter\n        let result = bfs(1);\n        result = bfs(result.farthestNode);\n\n        return result.distance;\n    }\n\n    const diameterG = treeDiameter(edges);\n    let validGraphCount = 0;\n\n    // Iterate over potential sets of edges to add\n    for (let mask = 0; mask < 1 << maxEdges; mask++) {\n        let hEdges = [...edges];\n        let addEdge = 0;\n\n        for (let j = 0; j < maxEdges; j++) {\n            if (mask & (1 << j)) {\n                let u = Math.floor(j / (N - 1)) + 1;\n                let v = (j % (N - 1)) + 2;\n                if (u < v && !hEdges.some(edge => (edge[0] === u && edge[1] === v) || (edge[0] === v && edge[1] === u))) {\n                    hEdges.push([u, v]);\n                    addEdge++;\n                }\n            }\n        }\n\n        if (treeDiameter(hEdges) === diameterG && addEdge <= N - 1) {\n            validGraphCount = (validGraphCount + pow2[incompleteEdges(addEdge, hEdges)]) % MOD;\n        }\n    }\n\n    function incompleteEdges(addedEdges, hEdges) {\n        let existingEdges = hEdges.length;\n        return maxEdges - existingEdges + addedEdges;\n    }\n\n    return validGraphCount;\n}\n\n// Example usage\nconst N = 3;\nconst edges = [[1, 2], [2, 3]];\nconsole.log(countValidGraphs(N, edges)); // Replace this line with input",
    "timestamp": "2025-08-13 11:35:33"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef find_diameter(graph):\n    def bfs(start):\n        dist = [float('inf')] * (len(graph) + 1)\n        dist[start] = 0\n        queue = deque([start])\n        max_dist = 0\n        max_node = start\n        \n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if dist[neighbor] == float('inf'):\n                    dist[neighbor] = dist[node] + 1\n                    queue.append(neighbor)\n                    if dist[neighbor] > max_dist:\n                        max_dist = dist[neighbor]\n                        max_node = neighbor\n        \n        return max_node, max_dist\n\n    # First BFS to find a farthest node from an arbitrary node\n    first_far_node, _ = bfs(1)\n    \n    # Second BFS from the farthest node\n    _, diameter = bfs(first_far_node)\n    \n    return diameter\n\ndef solve(N, edges):\n    MOD = 998244353\n    \n    # Build graph\n    graph = defaultdict(list)\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Original graph diameter\n    original_diameter = find_diameter(graph)\n    \n    # Find candidates to add edges\n    candidate_edges = []\n    for u in range(1, N+1):\n        for v in range(u+1, N+1):\n            if v not in graph[u]:\n                # Create a copy of the graph and add edge\n                temp_graph = defaultdict(list, {k: v.copy() for k, v in graph.items()})\n                temp_graph[u].append(v)\n                temp_graph[v].append(u)\n                \n                # Check if diameter reduces\n                temp_diameter = find_diameter(temp_graph)\n                if temp_diameter < original_diameter:\n                    candidate_edges.append((u, v))\n    \n    # Total possible graphs\n    result = pow(2, len(candidate_edges), MOD)\n    \n    return result\n\n# Example usage\nN, edges = map(int, input().split())\nedges_list = [tuple(map(int, input().split())) for _ in range(edges)]\nprint(solve(N, edges_list))",
    "timestamp": "2025-08-13 11:35:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, edges) {\n    const MOD = 998244353;\n    \n    function createAdjacencyList(N, edges) {\n        const graph = Array.from({ length: N + 1 }, () => []);\n        for (const [u, v] of edges) {\n            graph[u].push(v);\n            graph[v].push(u);\n        }\n        return graph;\n    }\n    \n    function findDiameter(graph) {\n        function bfs(start) {\n            const dist = new Array(graph.length).fill(-1);\n            const queue = [start];\n            dist[start] = 0;\n            let maxDist = 0;\n            let farthestNode = start;\n            \n            while (queue.length) {\n                const current = queue.shift();\n                \n                for (const neighbor of graph[current]) {\n                    if (dist[neighbor] === -1) {\n                        dist[neighbor] = dist[current] + 1;\n                        queue.push(neighbor);\n                        \n                        if (dist[neighbor] > maxDist) {\n                            maxDist = dist[neighbor];\n                            farthestNode = neighbor;\n                        }\n                    }\n                }\n            }\n            \n            return { maxDist, farthestNode, dist };\n        }\n        \n        const firstBFS = bfs(1);\n        const secondBFS = bfs(firstBFS.farthestNode);\n        \n        return secondBFS.maxDist;\n    }\n    \n    function countValidGraphs(graph, originalDiameter) {\n        const n = graph.length - 1;\n        const possibleEdges = [];\n        \n        for (let u = 1; u <= n; u++) {\n            for (let v = u + 1; v <= n; v++) {\n                if (!graph[u].includes(v)) {\n                    possibleEdges.push([u, v]);\n                }\n            }\n        }\n        \n        let validGraphs = 1;\n        \n        for (const subset of generateSubsets(possibleEdges)) {\n            const newGraph = createGraphWithEdges(graph, subset);\n            const newDiameter = findDiameter(newGraph);\n            \n            if (newDiameter === originalDiameter && checkDiameterProperty(newGraph)) {\n                validGraphs = (validGraphs * 2) % MOD;\n            }\n        }\n        \n        return validGraphs;\n    }\n    \n    function createGraphWithEdges(originalGraph, newEdges) {\n        const graph = originalGraph.map(row => [...row]);\n        \n        for (const [u, v] of newEdges) {\n            graph[u].push(v);\n            graph[v].push(u);\n        }\n        \n        return graph;\n    }\n    \n    function checkDiameterProperty(graph) {\n        for (let u = 1; u < graph.length; u++) {\n            for (let v = u + 1; v < graph.length; v++) {\n                if (!graph[u].includes(v)) {\n                    const tempGraph = createGraphWithEdges(graph, [[u, v]]);\n                    if (findDiameter(tempGraph) < findDiameter(graph)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    \n    function* generateSubsets(arr) {\n        for (let i = 0; i < (1 << arr.length); i++) {\n            const subset = [];\n            for (let j = 0; j < arr.length; j++) {\n                if (i & (1 << j)) {\n                    subset.push(arr[j]);\n                }\n            }\n            yield subset;\n        }\n    }\n    \n    const graph = createAdjacencyList(N, edges);\n    const originalDiameter = findDiameter(graph);\n    \n    return countValidGraphs(graph, originalDiameter);\n}",
    "timestamp": "2025-08-13 11:35:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\nMOD = 998244353\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    adj = [[] for _ in range(N+1)]\n    for _ in range(N-1):\n        a = int(input[ptr])\n        b = int(input[ptr+1])\n        ptr += 2\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    # Find all pairs of vertices with distance equal to diameter (BFS for each node)\n    def bfs(start):\n        dist = [-1]*(N+1)\n        q = deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    q.append(v)\n        far = max(range(1, N+1), key=lambda x: dist[x])\n        return dist, far\n    \n    _, u = bfs(1)\n    dist_u, v = bfs(u)\n    diameter = dist_u[v]\n    \n    # Find all vertices on the diameter (path from u to v)\n    parent = [0]*(N+1)\n    visited = [False]*(N+1)\n    q = deque()\n    q.append(v)\n    visited[v] = True\n    parent[v] = 0\n    while q:\n        x = q.popleft()\n        for y in adj[x]:\n            if not visited[y] and dist_u[y] == dist_u[x] - 1:\n                visited[y] = True\n                parent[y] = x\n                q.append(y)\n    \n    path = []\n    current = u\n    while current != v:\n        path.append(current)\n        current = parent[current]\n    path.append(v)\n    \n    # Check if the diameter is unique (all diameter paths pass through the same central edge or vertex)\n    # For even diameter, center is one vertex; for odd, it's two vertices (central edge)\n    if diameter % 2 == 0:\n        center_pos = diameter // 2\n        center = path[center_pos]\n        # Now, count the number of vertices at distance center_pos from center in the original tree\n        dist_center = [-1]*(N+1)\n        q = deque()\n        dist_center[center] = 0\n        q.append(center)\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if dist_center[y] == -1:\n                    dist_center[y] = dist_center[x] + 1\n                    q.append(y)\n        cnt = 0\n        for i in range(1, N+1):\n            if dist_center[i] == center_pos:\n                cnt += 1\n        # The answer is (cnt choose 2) + cnt, but need to verify\n        # Actually, the answer is (cnt)^2 - cnt*(cnt-1)/2, but not sure\n        # For the case where center is a single vertex, the answer is (s1 * s2 * ... * sk) where s_i is the size of each subtree\n        # So need to find all subtrees of the center\n        subtree_sizes = []\n        visited = [False]*(N+1)\n        visited[center] = True\n        for neighbor in adj[center]:\n            q = deque()\n            q.append(neighbor)\n            visited[neighbor] = True\n            size = 0\n            while q:\n                x = q.popleft()\n                size += 1\n                for y in adj[x]:\n                    if not visited[y] and y != center:\n                        visited[y] = True\n                        q.append(y)\n            subtree_sizes.append(size)\n        if len(subtree_sizes) < 2:\n            print(1)\n            return\n        total = sum(subtree_sizes)\n        ans = 1\n        sum_part = 0\n        for s in subtree_sizes:\n            ans = ans * (s + 1) % MOD\n            sum_part = (sum_part + s) % MOD\n        ans = (ans - 1 - sum_part) % MOD\n        print(ans)\n    else:\n        center_pos1 = diameter // 2\n        center_pos2 = diameter // 2 + 1\n        c1 = path[center_pos1]\n        c2 = path[center_pos2]\n        # Need to split the tree into two parts: c1's side and c2's side\n        # Count the number of vertices in c1's subtree not containing c2, and vice versa\n        # The answer is s1 * s2\n        # Perform BFS from c1, blocking c2\n        visited = [False]*(N+1)\n        q = deque()\n        visited[c1] = True\n        visited[c2] = True  # block\n        s1 = 0\n        for neighbor in adj[c1]:\n            if neighbor == c2:\n                continue\n            q.append(neighbor)\n            visited[neighbor] = True\n            s1 += 1\n            while q:\n                x = q.popleft()\n                for y in adj[x]:\n                    if not visited[y]:\n                        visited[y] = True\n                        q.append(y)\n                        s1 += 1\n        # Similarly for c2's side\n        visited = [False]*(N+1)\n        q = deque()\n        visited[c2] = True\n        visited[c1] = True  # block\n        s2 = 0\n        for neighbor in adj[c2]:\n            if neighbor == c1:\n                continue\n            q.append(neighbor)\n            visited[neighbor] = True\n            s2 += 1\n            while q:\n                x = q.popleft()\n                for y in adj[x]:\n                    if not visited[y]:\n                        visited[y] = True\n                        q.append(y)\n                        s2 += 1\n        ans = s1 * s2 % MOD\n        print(ans)\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 11:41:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 998244353;\n\nfunction solve() {\n    const input = require('fs').readFileSync(0, 'utf-8').trim().split('\\n');\n    const N = parseInt(input[0], 10);\n    const adj = Array.from({ length: N + 1 }, () => []);\n    for (let i = 1; i <= N - 1; i++) {\n        const [a, b] = input[i].split(' ').map(Number);\n        adj[a].push(b);\n        adj[b].push(a);\n    }\n\n    // BFS to find the diameter and the centers\n    const bfs = (start) => {\n        const dist = Array(N + 1).fill(-1);\n        const q = [start];\n        dist[start] = 0;\n        let u = start;\n        while (q.length > 0) {\n            u = q.shift();\n            for (const v of adj[u]) {\n                if (dist[v] === -1) {\n                    dist[v] = dist[u] + 1;\n                    q.push(v);\n                }\n            }\n        }\n        return { node: u, dist };\n    };\n\n    const { node: u } = bfs(1);\n    const { node: v, dist: distU } = bfs(u);\n    const { dist: distV } = bfs(v);\n    const diameter = distU[v];\n    const centers = [];\n    for (let i = 1; i <= N; i++) {\n        if (distU[i] + distV[i] === diameter && Math.abs(distU[i] - distV[i]) <= 1) {\n            centers.push(i);\n        }\n    }\n\n    // The tree has one or two centers\n    if (centers.length === 1) {\n        const center = centers[0];\n        // We need to split into subtrees and compute the product (size + 1)\n        const visited = Array(N + 1).fill(false);\n        visited[center] = true;\n        let result = 1;\n        for (const neighbor of adj[center]) {\n            const stack = [neighbor];\n            visited[neighbor] = true;\n            let size = 0;\n            while (stack.length > 0) {\n                const node = stack.pop();\n                size++;\n                for (const v of adj[node]) {\n                    if (!visited[v]) {\n                        visited[v] = true;\n                        stack.push(v);\n                    }\n                }\n            }\n            result = (result * (size + 1)) % MOD;\n        }\n        result = (result - 1 - adj[center].length + MOD) % MOD;\n        console.log(result);\n    } else {\n        const [c1, c2] = centers;\n        // Split into two parts\n        const visited1 = Array(N + 1).fill(false);\n        const visited2 = Array(N + 1).fill(false);\n        visited1[c1] = true;\n        visited2[c2] = true;\n        let size1 = 0, size2 = 0;\n        const stack1 = [c1];\n        while (stack1.length > 0) {\n            const node = stack1.pop();\n            size1++;\n            for (const v of adj[node]) {\n                if (v !== c2 && !visited1[v]) {\n                    visited1[v] = true;\n                    stack1.push(v);\n                }\n            }\n        }\n        const stack2 = [c2];\n        while (stack2.length > 0) {\n            const node = stack2.pop();\n            size2++;\n            for (const v of adj[node]) {\n                if (v !== c1 && !visited2[v]) {\n                    visited2[v] = true;\n                    stack2.push(v);\n                }\n            }\n        }\n        const result = (size1 * size2) % MOD;\n        console.log(result);\n    }\n}\n\nsolve();",
    "timestamp": "2025-08-13 11:41:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\n#define MOD 998244353\n\nstruct Graph {\n    int n;\n    vector<vector<int>> adj;\n\n    Graph(int n) : n(n), adj(n + 1) {}\n\n    void addEdge(int u, int v) {\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    int calculateDiameter() const {\n        vector<int> dist(n + 1, -1);\n        int farthest = bfs(1, dist);\n        dist = vector<int>(n + 1, -1);\n        bfs(farthest, dist);\n        int diameter = 0;\n        for (int i = 1; i <= n; ++i) {\n            diameter = max(diameter, dist[i]);\n        }\n        return diameter;\n    }\n\nprivate:\n    int bfs(int start, vector<int>& dist) const {\n        vector<int> queue = {start};\n        dist[start] = 0;\n        int front = 0;\n        int farthest = start;\n        while (front < queue.size()) {\n            int u = queue[front++];\n            for (int v : adj[u]) {\n                if (dist[v] == -1) {\n                    dist[v] = dist[u] + 1;\n                    queue.push_back(v);\n                    farthest = v;\n                }\n            }\n        }\n        return farthest;\n    }\n};\n\nlong long power(long long base, long long exp, long long mod) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) result = (result * base) % mod;\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return result;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    Graph G(N);\n    for (int i = 0; i < N - 1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        G.addEdge(a, b);\n    }\n    int diameter = G.calculateDiameter();\n    long long result = power(2, N * (N - 1) / 2 - (N - 1), MOD);\n    cout << result << '\\n';\n    return 0;\n}",
    "timestamp": "2025-08-13 12:04:29"
  }
]