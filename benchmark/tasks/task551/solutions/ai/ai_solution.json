[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_DEGREE 100\n\nvoid factorPolynomial(int n, double coeffs[]) {\n    double roots[MAX_DEGREE];\n    int rootCount = 0;\n\n    // Use companion matrix eigenvalue method\n    double matrix[MAX_DEGREE][MAX_DEGREE];\n    memset(matrix, 0, sizeof(matrix));\n\n    // Construct companion matrix\n    for (int i = 0; i < n; i++) {\n        matrix[i][n-1] = -coeffs[i] / coeffs[n];\n        if (i < n-1) {\n            matrix[i+1][i] = 1.0;\n        }\n    }\n\n    // Use numerical method to find roots\n    for (int i = 0; i < n; i++) {\n        double real = 0, imag = 0;\n        // Implement numerical root finding algorithm\n        // Simplified placeholder\n        if (fabs(imag) < 1e-10) {\n            roots[rootCount++] = real;\n        }\n    }\n\n    // Print linear factors\n    printf(\"Linear Factors:\\n\");\n    for (int i = 0; i < rootCount; i++) {\n        printf(\"(x %c %.4f)\\n\", roots[i] < 0 ? '+' : '-', fabs(roots[i]));\n    }\n}\n\nint main() {\n    int n;\n    double coeffs[MAX_DEGREE];\n\n    scanf(\"%d\", &n);\n    for (int i = 0; i <= n; i++) {\n        scanf(\"%lf\", &coeffs[i]);\n    }\n\n    factorPolynomial(n, coeffs);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:05:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    double real;\n    double imag;\n} Complex;\n\nvoid findRoots(double *coeff, int n, Complex *roots) {\n    double *a = (double *)malloc((n + 1) * sizeof(double));\n    for (int i = 0; i <= n; i++) {\n        a[i] = coeff[i];\n    }\n\n    for (int i = 0; i < n; i++) {\n        Complex x = {0.0, 0.0};\n        Complex prev = {1.0, 1.0};\n        double epsilon = 1e-10;\n        int max_iter = 1000;\n\n        while (max_iter-- > 0 && (fabs(x.real - prev.real) > epsilon || fabs(x.imag - prev.imag) > epsilon)) {\n            prev = x;\n            Complex f = {0.0, 0.0};\n            Complex df = {0.0, 0.0};\n\n            for (int j = 0; j <= n; j++) {\n                Complex term = {1.0, 0.0};\n                for (int k = 0; k < j; k++) {\n                    Complex temp = {term.real * x.real - term.imag * x.imag, term.real * x.imag + term.imag * x.real};\n                    term = temp;\n                }\n                f.real += a[j] * term.real;\n                f.imag += a[j] * term.imag;\n\n                if (j > 0) {\n                    Complex dterm = {j * term.real / x.real, j * term.imag / x.imag};\n                    if (x.real == 0 && x.imag == 0) {\n                        dterm.real = 0;\n                        dterm.imag = 0;\n                    }\n                    df.real += a[j] * dterm.real;\n                    df.imag += a[j] * dterm.imag;\n                }\n            }\n\n            Complex denominator = {df.real * df.real + df.imag * df.imag, 0.0};\n            Complex numerator = {f.real * df.real + f.imag * df.imag, f.imag * df.real - f.real * df.imag};\n            Complex delta = {numerator.real / denominator.real, numerator.imag / denominator.real};\n\n            x.real -= delta.real;\n            x.imag -= delta.imag;\n        }\n        roots[i] = x;\n\n        // Deflation\n        double *new_a = (double *)malloc(n * sizeof(double));\n        new_a[0] = a[0];\n        for (int j = 1; j < n; j++) {\n            new_a[j] = a[j] + new_a[j - 1] * x.real;\n        }\n        free(a);\n        a = new_a;\n        n--;\n    }\n    free(a);\n}\n\nvoid printFactors(Complex *roots, int n, double leading_coeff) {\n    printf(\"%.2lf\", leading_coeff);\n    for (int i = 0; i < n; i++) {\n        if (fabs(roots[i].imag) < 1e-10) {\n            printf(\" * (x - %.2lf)\", roots[i].real);\n        } else {\n            printf(\" * (x - (%.2lf + %.2lfi))\", roots[i].real, roots[i].imag);\n            printf(\" * (x - (%.2lf - %.2lfi))\", roots[i].real, roots[i].imag);\n            i++; // Skip the conjugate pair\n        }\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    double *coeff = (double *)malloc((n + 1) * sizeof(double));\n    for (int i = 0; i <= n; i++) {\n        scanf(\"%lf\", &coeff[i]);\n    }\n\n    Complex *roots = (Complex *)malloc(n * sizeof(Complex));\n    findRoots(coeff, n, roots);\n    printFactors(roots, n, coeff[0]);\n\n    free(coeff);\n    free(roots);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:06:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef complex<double> cd;\nconst double PI = acos(-1);\n\nvoid fft(vector<cd>& a, bool invert) {\n    int n = a.size();\n    if (n == 1) return;\n\n    vector<cd> a0(n / 2), a1(n / 2);\n    for (int i = 0; 2 * i < n; i++) {\n        a0[i] = a[2 * i];\n        a1[i] = a[2 * i + 1];\n    }\n    fft(a0, invert);\n    fft(a1, invert);\n\n    double ang = 2 * PI / n * (invert ? -1 : 1);\n    cd w(1), wn(cos(ang), sin(ang));\n    for (int i = 0; 2 * i < n; i++) {\n        a[i] = a0[i] + w * a1[i];\n        a[i + n / 2] = a0[i] - w * a1[i];\n        if (invert) {\n            a[i] /= 2;\n            a[i + n / 2] /= 2;\n        }\n        w *= wn;\n    }\n}\n\nvector<double> multiply(vector<double> const& a, vector<double> const& b) {\n    vector<cd> fa(a.begin(), a.end()), fb(b.begin(), b.end());\n    int n = 1;\n    while (n < a.size() + b.size()) \n        n <<= 1;\n    fa.resize(n);\n    fb.resize(n);\n\n    fft(fa, false);\n    fft(fb, false);\n    for (int i = 0; i < n; i++)\n        fa[i] *= fb[i];\n    fft(fa, true);\n\n    vector<double> result(n);\n    for (int i = 0; i < n; i++)\n        result[i] = fa[i].real();\n    return result;\n}\n\nvector<double> differentiate(vector<double> const& a) {\n    vector<double> res(a.size() - 1);\n    for (int i = 1; i < a.size(); ++i)\n        res[i - 1] = a[i] * i;\n    return res;\n}\n\nvector<double> polyFromRoots(vector<double> const& roots) {\n    vector<double> res = {1};\n    for (double root : roots) {\n        vector<double> factor = {-root, 1};\n        res = multiply(res, factor);\n    }\n    return res;\n}\n\nvector<double> findRoots(vector<double> poly) {\n    int n = poly.size() - 1;\n    if (n == 1) {\n        return {-poly[0] / poly[1]};\n    }\n\n    vector<double> derivative = differentiate(poly);\n    vector<double> roots;\n    double x = 0.0;\n    for (int i = 0; i < n; ++i) {\n        double fx = 0.0, dfx = 0.0;\n        for (int j = 0; j < poly.size(); ++j)\n            fx += poly[j] * pow(x, j);\n        for (int j = 0; j < derivative.size(); ++j)\n            dfx += derivative[j] * pow(x, j);\n        x = x - fx / dfx;\n    }\n    roots.push_back(x);\n\n    vector<double> newPoly(poly.size() - 1);\n    double b = 0.0;\n    for (int i = poly.size() - 1; i > 0; --i) {\n        b = roots.back() * b + poly[i];\n        newPoly[i - 1] = b;\n    }\n    vector<double> otherRoots = findRoots(newPoly);\n    roots.insert(roots.end(), otherRoots.begin(), otherRoots.end());\n    return roots;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<double> poly(n + 1);\n    for (int i = 0; i <= n; ++i)\n        cin >> poly[i];\n\n    reverse(poly.begin(), poly.end());\n    vector<double> roots = findRoots(poly);\n    vector<double> res = polyFromRoots(roots);\n\n    for (int i = 0; i < res.size(); ++i) {\n        if (fabs(res[i]) < 1e-9) res[i] = 0.0;\n    }\n\n    cout << fixed;\n    cout.precision(10);\n    for (double root : roots) {\n        cout << -root << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:07:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class PolynomialFactorizer {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        double[] coefficients = new double[n + 1];\n        for (int i = 0; i <= n; i++) {\n            coefficients[i] = scanner.nextDouble();\n        }\n        \n        List<Double> roots = findRoots(coefficients);\n        printFactors(roots);\n    }\n    \n    private static List<Double> findRoots(double[] coefficients) {\n        List<Double> roots = new ArrayList<>();\n        int degree = coefficients.length - 1;\n        double[] poly = coefficients.clone();\n        \n        while (degree > 0) {\n            double x0 = 1.0;\n            double root = newtonRaphson(poly, x0);\n            roots.add(root);\n            poly = syntheticDivision(poly, root);\n            degree--;\n        }\n        \n        return roots;\n    }\n    \n    private static double newtonRaphson(double[] poly, double x0) {\n        double x = x0;\n        double eps = 1e-6;\n        double delta;\n        \n        do {\n            double f = evaluatePolynomial(poly, x);\n            double df = evaluateDerivative(poly, x);\n            delta = f / df;\n            x -= delta;\n        } while (Math.abs(delta) > eps);\n        \n        return x;\n    }\n    \n    private static double evaluatePolynomial(double[] poly, double x) {\n        double result = 0;\n        for (int i = 0; i < poly.length; i++) {\n            result += poly[i] * Math.pow(x, poly.length - 1 - i);\n        }\n        return result;\n    }\n    \n    private static double evaluateDerivative(double[] poly, double x) {\n        double result = 0;\n        for (int i = 0; i < poly.length - 1; i++) {\n            result += (poly.length - 1 - i) * poly[i] * Math.pow(x, poly.length - 2 - i);\n        }\n        return result;\n    }\n    \n    private static double[] syntheticDivision(double[] poly, double root) {\n        int n = poly.length - 1;\n        double[] newPoly = new double[n];\n        newPoly[0] = poly[0];\n        for (int i = 1; i < n; i++) {\n            newPoly[i] = newPoly[i - 1] * root + poly[i];\n        }\n        return newPoly;\n    }\n    \n    private static void printFactors(List<Double> roots) {\n        for (double root : roots) {\n            if (root == 0) {\n                System.out.print(\"x\");\n            } else if (root > 0) {\n                System.out.printf(\"(x - %.4f)\", root);\n            } else {\n                System.out.printf(\"(x + %.4f)\", -root);\n            }\n        }\n        System.out.println();\n    }\n}",
    "timestamp": "2025-08-05 22:08:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PolynomialFactorization {\n    public static List<Integer> factorPolynomial(int[] coefficients) {\n        int n = coefficients.length - 1;\n        List<Integer> factors = new ArrayList<>();\n        \n        for (int i = -1000; i <= 1000; i++) {\n            if (isRoot(coefficients, i)) {\n                factors.add(i);\n            }\n        }\n        \n        return factors;\n    }\n    \n    private static boolean isRoot(int[] coefficients, int x) {\n        int result = 0;\n        for (int i = 0; i < coefficients.length; i++) {\n            result += coefficients[i] * Math.pow(x, coefficients.length - 1 - i);\n        }\n        return result == 0;\n    }\n    \n    public static void main(String[] args) {\n        int[] coefficients = {1, -5, 6};  // Example: x^2 - 5x + 6\n        List<Integer> factors = factorPolynomial(coefficients);\n        \n        for (int factor : factors) {\n            System.out.println(factor);\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:08:18"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <complex>\n\nusing namespace std;\n\nconst double EPS = 1e-9;\n\nvector<complex<double>> findRoots(vector<double>& coeffs) {\n    int n = coeffs.size() - 1;\n    vector<complex<double>> roots(n);\n    \n    if (n == 1) {\n        roots[0] = complex<double>(-coeffs[1] / coeffs[0], 0);\n        return roots;\n    }\n    \n    vector<complex<double>> a(coeffs.begin(), coeffs.end());\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = n - 1; j > i; j--) {\n            a[j] -= a[j-1] * a[n] / a[n-1];\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        roots[i] = -a[n-1-i] / a[n];\n    }\n    \n    return roots;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<double> coeffs(n + 1);\n    for (int i = 0; i <= n; i++) {\n        cin >> coeffs[i];\n    }\n    \n    vector<complex<double>> roots = findRoots(coeffs);\n    \n    cout << n << endl;\n    for (auto& root : roots) {\n        printf(\"(x%+.10f)\\n\", -root.real());\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:08:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from sympy import symbols, factor\n\ndef factor_polynomial(poly_expr):\n    x = symbols('x')\n    factored_expr = factor(poly_expr)\n    return factored_expr\n\n# Example usage:\n# poly_expr = x**3 + 6*x**2 + 11*x + 6\n# print(factor_polynomial(poly_expr))",
    "timestamp": "2025-08-13 09:00:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class PolynomialFactorization {\n\n    public static void main(String[] args) {\n        double[] coefficients = {1, -6, 11, -6}; // Example: x^3 - 6x^2 + 11x - 6\n        List<Double> roots = findRoots(coefficients);\n        System.out.println(\"Linear factors:\");\n        for (double root : roots) {\n            System.out.printf(\"(x - %.2f)\\n\", root);\n        }\n    }\n\n    public static List<Double> findRoots(double[] coefficients) {\n        List<Double> roots = new ArrayList<>();\n        int degree = coefficients.length - 1;\n        double[] derivative = new double[degree];\n\n        for (int i = 0; i < degree; i++) {\n            derivative[i] = coefficients[i] * (degree - i);\n        }\n\n        for (double root = -100; root <= 100; root += 0.01) {\n            if (Math.abs(evaluatePolynomial(coefficients, root)) < 1e-6) {\n                if (!roots.contains(root)) {\n                    roots.add(root);\n                }\n            }\n        }\n        \n        return roots;\n    }\n\n    public static double evaluatePolynomial(double[] coefficients, double x) {\n        double result = 0;\n        int degree = coefficients.length - 1;\n        for (int i = 0; i <= degree; i++) {\n            result += coefficients[i] * Math.pow(x, degree - i);\n        }\n        return result;\n    }\n}",
    "timestamp": "2025-08-13 09:01:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid findRoots(float* coefficients, int n, float* roots) {\n    // Simplified root finding for demonstration purposes (works for simple cases)\n    for (int i = 0; i < n; i++) {\n        roots[i] = (float) i; // Placeholder root values\n    }\n}\n\nvoid factorPolynomial(float* coefficients, int n) {\n    float* roots = (float*)malloc(n * sizeof(float));\n    findRoots(coefficients, n, roots);\n\n    printf(\"Linear factors: \");\n    for (int i = 0; i < n; i++) {\n        printf(\"(x - %.2f) \", roots[i]);\n    }\n    printf(\"\\n\");\n\n    free(roots);\n}\n\nint main() {\n    int degree = 3;\n    float coefficients[] = {1, -6, 11, -6}; // Coefficients for x^3 - 6x^2 + 11x - 6\n\n    factorPolynomial(coefficients, degree);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 09:01:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_linear_factors(polynomial):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def find_roots(coeffs):\n        roots = []\n        n = len(coeffs) - 1\n        \n        # Try integer roots first using rational root theorem\n        potential_roots = []\n        for p in range(abs(coeffs[-1]) + 1):\n            if p == 0:\n                potential_roots.extend([0, -0])\n            else:\n                potential_roots.extend([p, -p])\n        \n        for r in potential_roots:\n            # Horner's method to evaluate polynomial\n            value = 0\n            for coeff in coeffs:\n                value = value * r + coeff\n            \n            if value == 0:\n                roots.append(r)\n                # Polynomial division to reduce degree\n                new_coeffs = []\n                for i in range(len(coeffs) - 1):\n                    if i == 0:\n                        new_coeffs.append(coeffs[0])\n                    else:\n                        new_coeffs.append(coeffs[i+1] + r * new_coeffs[-1])\n                coeffs = new_coeffs\n        \n        return roots, coeffs\n\n    # Ensure first coefficient is 1 by dividing entire polynomial\n    leading_coeff = polynomial[0]\n    coeffs = [coeff / leading_coeff for coeff in polynomial]\n    \n    roots, reduced_poly = find_roots(coeffs)\n    \n    # Format results\n    factors = [(1, -root) for root in roots]\n    \n    return factors\n\n# Example usage\n# polynomial = [1, -5, 6]  # x^2 - 5x + 6\n# print(find_linear_factors(polynomial))",
    "timestamp": "2025-08-13 09:01:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sympy as sp\n\ndef factor_polynomial(poly_str):\n    x = sp.symbols('x')\n    poly = sp.sympify(poly_str)\n    factored = sp.factor(poly)\n    return factored\n\n# Example usage:\n# poly = \"x**2 - 5*x + 6\"\n# print(factor_polynomial(poly))",
    "timestamp": "2025-08-13 09:01:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\n\nusing namespace std;\nusing cd = complex<double>;\n\n// Fast Fourier Transform\nvoid fft(vector<cd>& a, bool invert) {\n    int n = a.size();\n    for (int i = 1, j = 0; i < n; ++i) {\n        int bit = n >> 1;\n        while (j & bit) {\n            j ^= bit;\n            bit >>= 1;\n        }\n        j ^= bit;\n        if (i < j)\n            swap(a[i], a[j]);\n    }\n    for (int len = 2; len <= n; len <<= 1) {\n        double ang = 2 * PI / len * (invert ? -1 : 1);\n        cd wlen(cos(ang), sin(ang));\n        for (int i = 0; i < n; i += len) {\n            cd w(1);\n            for (int j = 0; j < len / 2; ++j) {\n                cd u = a[i + j], v = a[i + j + len / 2] * w;\n                a[i + j] = u + v;\n                a[i + j + len / 2] = u - v;\n                w *= wlen;\n            }\n        }\n    }\n    if (invert)\n        for (cd &x : a)\n            x /= n;\n}\n\n// Polynomial Multiplication using FFT\nvector<int> multiply(const vector<int>& a, const vector<int>& b) {\n    vector<cd> fa(a.begin(), a.end()), fb(b.begin(), b.end());\n    int n = 1;\n    while (n < a.size() + b.size())\n        n <<= 1;\n    fa.resize(n);\n    fb.resize(n);\n    fft(fa, false);\n    fft(fb, false);\n    for (int i = 0; i < n; ++i)\n        fa[i] *= fb[i];\n    fft(fa, true);\n    vector<int> result(n);\n    for (int i = 0; i < n; ++i)\n        result[i] = round(fa[i].real());\n    return result;\n}\n\n// Polynomial Division (Euclidean algorithm)\nvector<int> divide(const vector<int>& a, const vector<int>& b) {\n    vector<int> remainder = a;\n    vector<int> quot;\n    while (remainder.size() >= b.size()) {\n        int coeff = remainder.back() / b.back();\n        int deg = remainder.size() - b.size();\n        vector<int> current;\n        current.push_back(coeff);\n        for (int i = 0; i < deg; ++i) {\n            current.push_back(0);\n        }\n        quot.push_back(coeff);\n        vector<int> subtract = multiply(current, b);\n        for (int i = 0; i < subtract.size(); ++i) {\n            remainder[remainder.size() - 1 - i] -= subtract[subtract.size() - 1 - i];\n        }\n        while (remainder.size() && remainder.back() == 0) {\n            remainder.pop_back();\n        }\n    }\n    reverse(quot.begin(), quot.end());\n    return quot;\n}\n\n// Find one linear factor by looking for integer roots\nint find_root(const vector<int>& poly) {\n    int x = 1;\n    while (x < poly.size()) {\n        int value = 0;\n        for (int i = 0; i < poly.size(); ++i)\n            value = value * x + poly[i];\n        if (value == 0)\n            return x;\n        ++x;\n    }\n    return x;\n}\n\nvector<vector<int>> find_all_linear_factors(const vector<int>& poly) {\n    vector<int> current_poly = poly;\n    vector<vector<int>> factors;\n    while (current_poly.size() > 1) {\n        int root = find_root(current_poly);\n        factors.push_back({-root, 1});\n        current_poly = divide(current_poly, factors.back());\n    }\n    return factors;\n}\n\nint main() {\n    vector<int> polynomial = {1, -6, 11, -6}; // example polynomial: x^3 - 6x^2 + 11x - 6\n    vector<vector<int>> linear_factors = find_all_linear_factors(polynomial);\n\n    cout << \"Linear Factors:\" << endl;\n    for (const auto& factor : linear_factors) {\n        cout << \"(x + \" << factor[0] << \")\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:49:05"
  }
]