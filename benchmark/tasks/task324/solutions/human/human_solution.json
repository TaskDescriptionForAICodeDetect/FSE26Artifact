[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int n, h, w;\n  std::cin >> n;\n  for (int roop = 0; roop < n; roop++) {\n    std::cin >> h >> w;\n    vector<string> vs(h);\n    set<char> s;\n    for (int i = 0; i < h; i++) {\n      std::cin >> vs[i];\n      for (int j = 0; j < vs[i].length(); j++) {\n        if('A' <= vs[i][j] and vs[i][j] <= 'Z')s.insert(vs[i][j]);\n      }\n    }\n    vector<char> perm;\n    for (auto i: s) perm.push_back(i);\n    if(perm.size() == 0){\n      std::cout << \"SAFE\" << std::endl;\n      continue;\n    }\n    bool f = false;\n    do{\n      // for (int i = 0; i < perm.size(); i++) {\n      //   std::cout << perm[i] << \" \";\n      // }\n      // std::cout << std::endl;\n      vector<string> tmp = vs;\n      bool flag = true;\n      for (int i = 0; i < perm.size(); i++) {\n        int lux = 1e9, luy = 1e9, rdx = 0, rdy = 0;\n        for (int j = 0; j < h; j++) {\n          for (int k = 0; k < w; k++) {\n            flag = false;\n            if(tmp[j][k] == perm[i]){\n              lux = min(lux, k);\n              luy = min(luy, j);\n              rdx = max(rdx, k);\n              rdy = max(rdy, j);\n            }\n          }\n        }\n        if(flag)continue;\n        // printf(\"luy:%d rdy:%d lux:%d rdx:%d\\n\", luy, rdy, lux, rdx);\n        for (int j = luy; j <= rdy; j++) {\n          for (int k = lux; k <= rdx; k++) {\n            if(tmp[j][k] == '.' or \n               (tmp[j][k] != perm[i] and tmp[j][k] != '$')){\n              i = j = k = 1e9;\n              continue;\n            }\n            tmp[j][k] = '$';\n          }\n        }\n        if(i == perm.size() - 1){\n          if(not f)std::cout << \"SAFE\" << std::endl;\n          f = true;\n        }\n\n      //   for (int j = 0; j < h; j++) {\n      //     std::cout << tmp[j] << std::endl;\n      //   }\n      //   std::cout << std::endl;\n      }\n    }while(next_permutation(perm.begin(), perm.end()));\n    if(not f)std::cout << \"SUSPICIOUS\" << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nstruct node {\n  vector<char> v;\n  int mx, my, Mx, My;\n  node(vector<char v>, int mx, int my, int Mx, int My):\n    v(v), mx(mx), my(mx), Mx(Mx), My(My) {}\n};\n\nmap<char, node> G;\n\nint field[50 + 2][50 + 2];\n\nint main()\n{\n  int numberOfInput;\n  scanf(\"%d \", &numberOfInput);\n  for (int caseIndex = 0; caseIndex < numberOfInput; caseIndex++) {\n    int H, W;\n    scanf(\"%d %d \", &H, &W);\n    for (int i = 0; i < H; i++) {\n      fill(field[i], &field[i][52], '.');\n    }\n    for (int i = 1; i <= H; i++) {\n      for (int j = 1; j <= W; j++) {\n\tscanf(\"%c \", &field[i][j]);\n\tif (field[i][j] != '.') {\n\t  G[ field[i][j] ] = node(vector<int>(), 0, 0, \n\t\t\t\t  0, 0, field[i][j]);\n\t}\n      }\n    }\n    \n    for (map<char, node>::iterator it = G.begin(); \n\t it != G.end(); it++) {\n      char c = it->first;\n      int mx = 50, my = 50, Mx = -1, My = -1;\n      for (int i = 1; i <= H; i++) {\n\tfor (int j = 1; j <= W; j++) {\n\t  if (field[i][j] == c) {\n\t    mx = min(mx, j);\n\t    my = min(my, i);\n\t    Mx = max(Mx, j);\n\t    My = max(My, i);\n\t  }\n\t}\n      }\n      G[c] = node(vector<int>(), mx, my, Mx, My, c);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep2(i,m,n) for(int i=m;i<=n;i++)\n\nstruct rec{\n\tint x1,x2,y1,y2;\n\trec(){x1=99,x2=-1,y1=99,y2=-1;}\n\trec(int x1,int x2,int y1,int y2):\n\tx1(x1),x2(x2),y1(y1),y2(y2) {}\n};\n\nint N,H,W,perm[7];\nchar c[51][51],kind[7];\nrec r[8];\n\nint main(){\n\tcin>>N;\n\twhile(N--){\n\t\trep(i,7)perm[i]=i;\n\t\tcin>>H>>W;\n\t\tint cur=0,ans=0;\n\t\tmap<char,rec> m;\n\t\tmap<char,rec>::iterator it;\n\t\trep(i,H)rep(j,W){\n\t\t\tcin>>c[i][j];\n\t\t\tif(c[i][j]!='.'){\n\t\t\t\trec r=m[c[i][j]];\n\t\t\t\tif(r.x1==99)kind[cur++]=c[i][j];\n\t\t\t\tr.x1=min(r.x1,j);r.x2=max(r.x2,j);\n\t\t\t\tr.y1=min(r.y1,i);r.y2=max(r.y2,i);\n\t\t\t\tm[c[i][j]]=r;\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tdo{\n\t\t\tint ok=1;\n\t\t\trep(i,cur){\n\t\t\t\trec r=m[kind[perm[i]]];\n\t\t\t\trep2(j,r.y1,r.y2){\n\t\t\t\t\trep2(k,r.x1,r.x2){\n\t\t\t\t\t\tint ok2=0;\n\t\t\t\t\t\trep(l,i+1)if(c[j][k]==kind[perm[l]]){ok2=1;break;}\n\t\t\t\t\t\tif(!ok2){ok=0;break;}\n\t\t\t\t\t}\n\t\t\t\t\tif(!ok)break;\n\t\t\t\t}\n\t\t\t\tif(!ok)break;\n\t\t\t}\n\t\t\tif(ok){ans=1;break;}\n\t\t}while(next_permutation(perm,perm+cur));\n\t\tcout<<(ans?\"SAFE\":\"SUSPICIOUS\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconstexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1 << 28;\n//constexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\n\nint main()\n{\n\t\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\t\n\n\tint kkt; cin >> kkt;\n\twhile (kkt--) {\n\t\tll H, W; cin >> H >> W;\n\t\tvector<string> vs(H); for (int i = 0; i < H; i++) cin >> vs[i];\n\t\tvector<char> v;\n\t\tmap<char, int> x_mn, x_mx, y_mn, y_mx;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (vs[i][j] != '.') {\n\t\t\t\t\tv.push_back(vs[i][j]);\n\t\t\t\t\tif (x_mn.find(vs[i][j]) == x_mn.end()) {\n\t\t\t\t\t\tx_mn[vs[i][j]] = x_mx[vs[i][j]] = i;\n\t\t\t\t\t\ty_mn[vs[i][j]] = y_mx[vs[i][j]] = j;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tchmin(x_mn[vs[i][j]], i);\n\t\t\t\t\t\tchmax(x_mx[vs[i][j]], i);\n\t\t\t\t\t\tchmin(y_mn[vs[i][j]], j);\n\t\t\t\t\t\tchmax(y_mx[vs[i][j]], j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tv.erase(unique(v.begin(), v.end()), v.end());\n\t\tbool flag = false;\n\t\tdo {\n\t\t\tvector<string> vss(H, string(W, '.'));\n\t\t\tfor (int i = 0; i < v.size(); i++) {\n\t\t\t\tfor (int j = x_mn[v[i]]; j <= x_mx[v[i]]; j++) {\n\t\t\t\t\tfor (int k = y_mn[v[i]]; k <= y_mx[v[i]]; k++) {\n\t\t\t\t\t\tvss[j][k] = v[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vs == vss) flag = true;\n\t\t\tif (flag) break;\n\t\t} while (next_permutation(v.begin(), v.end()));\n\t\tif (flag) puts(\"SAFE\");\n\t\telse puts(\"SUSPICIOUS\");\n\t}\n\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring f[50];\nint maxX[26], maxY[26], minX[26], minY[26];\nbool on[26][26];\n\nvoid check() {\n\tmemset(on, 0, sizeof on);\n\tfor(int i = 0; i < 26; i++) {\n\t\tif(maxX[i] == -1) continue;\n\t\tfor(int y = minY[i]; y <= maxY[i]; y++) {\n\t\t\tfor(int x = minX[i]; x <= maxX[i]; x++) {\n\t\t\t\tif(f[y][x] == '.') {\n\t\t\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(f[y][x] != 'A' + i) {\n\t\t\t\t\ton[i][f[y][x] - 'A'] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int k = 0; k < 26; k++) {\n\t\tfor(int i = 0; i < 26; i++) {\n\t\t\tfor(int j = 0; j < 26; j++) {\n\t\t\t\ton[i][j] |= on[i][k] & on[k][j];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 26; i++) {\n\t\tfor(int j = 0; j < 26; j++) {\n\t\t\tif(on[i][j] && on[j][i]) {\n\t\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"SAFE\" << endl;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint T, H, W;\n\tcin >> T;\n\twhile(T--) {\n\t\tcin >> H >> W;\n\t\tfor(int i = 0; i < H; i++) {\n\t\t\tcin >> f[i];\n\t\t}\n\n\t\tfor(int i = 0; i < 26; i++) {\n\t\t\tmaxX[i] = maxY[i] = -1;\n\t\t\tminX[i] = minY[i] = 100000;\n\t\t}\n\n\t\tfor(int y = 0; y < H; y++) {\n\t\t\tfor(int x = 0; x < W; x++) {\n\t\t\t\tif(f[y][x] == '.') continue;\n\t\t\t\tint c = f[y][x] - 'A';\n\t\t\t\tmaxX[c] = max(maxX[c], x);\n\t\t\t\tmaxY[c] = max(maxY[c], y);\n\t\t\t\tminX[c] = min(minX[c], x);\n\t\t\t\tminY[c] = min(minY[c], y);\n\t\t\t}\n\t\t}\n\n\t\tcheck();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <set>\n#include <iomanip>\n#include <stack>\n#include <fstream>\n#include <cstdint>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <functional>\n\nusing namespace std;\n\n\ntypedef int64_t ll;\n\n\nclass rect{\n    static const int inf = 100000;\npublic:\n    int sx, sy; // 始点 左上\n    int ex, ey; // 終点 右下\n    rect() :sx(inf), sy(inf), ex(), ey() {}\n    \n    void modify(const int& i, const int& j){\n        sx = min(i, sx);\n        sy = min(j, sy);\n        \n        ex = max(i, ex);\n        ey = max(j, ey);\n    }\n};\n\nbool is_real_over(map<char, set<char>>& overs){\n    vector<char> chs;\n    for(auto && t : overs){\n        chs.push_back(t.first);\n    }\n    if(chs.size() == 0)\n        return true;\n    while(next_permutation(chs.begin(), chs.end())){\n        bool ndo = false;\n        for (int i = 0; i < chs.size(); ++i) {\n            for(auto&& t : overs[chs[i]]){\n                int pt;\n                for (int j = 0; j < chs.size(); ++j) {\n                    if(t == chs[j]){\n                        pt = j;\n                        break;\n                    }\n                }\n                if(pt < i) {\n                    ndo = true;\n                    break;\n               }\n            }\n        }\n        if(!ndo) return true;\n    }\n    return false;\n}\n\n\nbool solve(){\n    int h, w;\n    cin >> h >> w;\n    vector<vector<char>> v;\n    map<char, rect> shapes;\n    for (int i = 0; i < h; ++i) {\n        v.push_back({});\n        for (int j = 0; j < w; ++j) {\n            char tmp;\n            cin >> tmp;\n            v[i].push_back(tmp);\n\n            if(tmp != '.')\n                shapes[tmp].modify(i, j);\n        }\n    }\n\n\n    // 矩形調査 yz\n    map<char, set<char>> overs;\n    for(auto && rec_pair: shapes){\n        auto && rec = rec_pair.second;\n        auto && rec_name = rec_pair.first;\n//        cerr << \"NAME:\" << rec_name << '\\n';\n        for (int i = rec.sx; i <= rec.ex; ++i) {\n            for (int j = rec.sy; j <= rec.ey; ++j) {\n                auto&& this_char = v[i][j];\n                if(this_char != rec_name){\n                    if(this_char == '.'){\n//                        cerr << \"SHAPE MISS\\n\";\n                        return false;\n                    }\n                    overs[rec_name].insert(this_char);\n                }\n            }\n        }\n    }\n\n    return is_real_over(overs);\n    \n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        cout << (!solve() ? \"SUSPICIOUS\" : \"SAFE\") << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint w,h,img[50][50],m[8][8],u[8],c,rectck;\nbool upper(int u,int d){\n\tif(m[u][d]>=0)return m[u][d];\n\tint t=h,b=0,l=w,r=0;\n\trep(i,h)rep(j,w)if(img[i][j]==u){\n\t\tif(t>i)t=i; if(b<i)b=i; if(l>j)l=j; if(r<j)r=j;\n\t}\n\trep(i,b-t+1)rep(j,r-l+1){\n\t\tif(img[i+t][j+l]==0){\n\t\t\trectck=0;\n\t\t}\n\t\tif(img[i+t][j+l]==d){\n\t\t\tm[u][d]=0; return 0;\n\t\t}\n\t}\n\tm[u][d]=1; return 1;\n}\nbool rec(){\n\tif(!rectck)return 0;\n\tint suc=0,finish=1;\n\trep(i,c+1)finish=finish&&u[i];\n\tif(finish)return 1;\n\trep(i,c+1)if(!suc&&!u[i]){\n\t\tint fail=0;\n\t\trep(j,c+1)if(i!=j&&u[j]&&!upper(i,j))fail=1;\n\t\tif(fail)continue;\n\t\tu[i]=1; suc=suc||rec(); u[i]=0;\n\t}\n\treturn suc;\n}\nint main(){\n\tint n; cin>>n;\n\twhile(n--){\n\t\tint alpha[26]={0},f=0; c=0;\n\t\tcin>>h>>w; rep(i,h)rep(j,w){\n\t\t\tchar t; cin>>t;\n\t\t\tif(t=='.'||alpha[t-'A'])img[i][j]=t=='.'?0:alpha[t-'A'];\n\t\t\telse img[i][j]=alpha[t-'A']=++c;\n\t\t}\n\t\trep(i,8)rep(j,8)m[i][j]=-1; rep(i,8)u[i]=0; u[0]=1;\n\t\trectck=1;\n\t\trep(i,c)if(rectck&&!f){\n\t\t\tu[i+1]=1; f=rec(); u[i+1]=0;\n\t\t}\n\t\tcout<<(rectck&&(c==0||f)?\"SAFE\":\"SUSPICIOUS\")<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\n#define For(i,a,n)\tfor(int i = a;i < n;i++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(n)\t\tmemset(n,0,sizeof n)\n#define all(n)\t\t(n).begin(),(n).end()\n\nconst int INF = 1e9;\nint dx[4] = { 0, 1, 0, -1 }, dy[4] = { 1, 0, -1, 0 };\nbool cheak(int x, int y, int mx, int my){\n\treturn x >= 0 && y >= 0 && x < mx &&  y < my;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\trep(_, n){\n\t\tint h, w;\n\t\tchar d[51][51];\n\t\tcin >> h >> w;\n\t\trep(y, h)rep(x, w){\n\t\t\tcin >> d[y][x];\n\t\t}\n\n\t\tbool f = false;\n\t\tset<char> vs[256];\n\t\tFor(ct, 'A', 'Z' + 1){\n\t\t\tint rx = -1, ry = -1;\n\t\t\tint lx = 51, ly = 51;\n\t\t\trep(y, h)rep(x, w){\n\t\t\t\tif (d[y][x] == ct){\n\t\t\t\t\tlx = min(lx, x), ly = min(ly, y);\n\t\t\t\t\trx = max(rx, x), ry = max(ry, y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tset<char> v;\n\t\t\tFor(y, ly, ry + 1)For(x, lx, rx + 1){\n\t\t\t\tif (d[y][x] == '.'){\n\t\t\t\t\tf = true; goto End;\n\t\t\t\t}\n\t\t\t\tif (d[y][x] != ct){\n\t\t\t\t\tv.insert(d[y][x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvs[ct] = v;\n\t\t}\n\t\trep(i, 256){\n\t\t\tbool cf[256]; clr(cf);\n\t\t\tcf[i] = true;\n\t\t\tif (vs[i].size()){\n\t\t\t\tqueue<char> q;\n\t\t\t\tfor(auto j : vs[i]){\n\t\t\t\t\tq.push(j);\n\t\t\t\t\tcf[j] = true;\n\t\t\t\t}\n\t\t\t\twhile (q.size()){\n\t\t\t\t\tint now = q.front(); q.pop();\n\t\t\t\t\tfor (auto j : vs[now]){\n\t\t\t\t\t\tif (cf[j]){\n\t\t\t\t\t\t\tf = true; goto End;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.push(j);\n\t\t\t\t\t\tcf[j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tEnd:;\n\n\t\tif (f)cout << \"SUSPICIOUS\" << endl;\n\t\telse  cout << \"SAFE\" << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n);i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(a);i>=(int)(b);--i)\n#define ALL(a) (a).begin(),(a).end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\n\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\n\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n  if(a < b) {a = b; return true;}\n  return false;\n}\n\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n  if(a > b) {a = b; return true;}\n  return false;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  REP(i, SZ(v)) {\n    if(i) os << \" \";\n    os << v[i];\n  }\n  return os;\n}\n\nclass Scc {\n  using Graph = std::vector<std::vector<int>>;\n  int V, K;\n  Graph G, rG;\n  std::vector<int> vs;\n  std::vector<bool> used;\n  std::vector<int> cmp;\n  void dfs(int cur) {\n    used[cur] = true;\n    for (const auto &v : G[cur]) {\n      if (!used[v]) dfs(v);\n    }\n    vs.push_back(cur);\n  }\n  void rdfs(int cur, int k) {\n    used[cur] = true;\n    cmp[cur] = k;\n    for (const auto &v : rG[cur]) {\n      if (!used[v]) rdfs(v, k);\n    }\n  }\n\npublic:\n  Scc(int _V) : V(_V), G(_V), rG(_V), used(_V, false), cmp(_V) {}\n  void add_edge(int from, int to) {\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  }\n  // SCCした後の頂点の対応関係(xor頂点数)を取得する\n  std::vector<int> scc() {\n    for (int i = 0; i < V; i++) used[i] = false;\n    vs.clear();\n    for (int v = 0; v < V; v++) {\n      if (!used[v]) dfs(v);\n    }\n    for (int i = 0; i < V; i++) used[i] = false;\n    int k = 0;\n    for (int i = (int)vs.size() - 1; i >= 0; i--) {\n      if (!used[vs[i]]) rdfs(vs[i], k++);\n    }\n    // 頂点数\n    K = k;\n    // cmp[i] := 頂点i がSCC後に属する強連結成分番号\n    return cmp;\n  }\n  // 強連結成分を潰した後のグラフを得る\n  Graph buildGraph() {\n    scc();\n    std::vector<std::set<int>> s(K);\n    Graph ret(K);\n    for (int v = 0; v < V; v++) {\n      for (const auto to : G[v]) {\n        s[cmp[v]].insert(cmp[to]);\n      }\n    }\n    for (int i = 0; i < K; i++) {\n      for (auto j : s[i]) {\n        if (i != j) ret[i].push_back(j);\n      }\n    }\n    return ret;\n  }\n};\n\nstruct Rect {\n  int rmi=INF, rma=0, cmi=INF, cma=0;\n};\n\nvoid solve() {\n  int h, w; cin >> h >> w;\n  vector<string> v;\n  REP(i, h) {\n    string tmp; cin >> tmp;\n    v.push_back(tmp);\n  }\n\n  map<char, Rect> mp;\n  map<char, int> zatu;\n  int id = 1;\n  REP(i, h) {\n    REP(j, w) {\n      if(v[i][j] == '.') continue;\n      if(zatu[v[i][j]] == 0) {\n        zatu[v[i][j]] = id;\n        id++;\n      }\n      auto &e = mp[v[i][j]];\n      chmin(e.rmi, i);\n      chmax(e.rma, i);\n      chmin(e.cmi, j);\n      chmax(e.cma, j);\n    }\n  }\n\n  bool ok = true;\n\n  vector<set<int>> g(id-1);\n  REP(i, h) {\n    if(!ok) break;\n    REP(j, w) {\n      if(v[i][j] == '.') {\n        for (auto &e: mp) {\n          auto rec = e.second;\n          if(rec.rmi <= i && i <= rec.rma &&\n             rec.cmi <= j && j <= rec.cma) {\n            ok = false;\n            break;\n          }\n        }\n      } else {\n        for(auto &e: mp) {\n          if(e.first == v[i][j]) continue;\n          auto rec = e.second;\n          if(rec.rmi <= i && i <= rec.rma &&\n             rec.cmi <= j && j <= rec.cma) {\n            g[zatu[v[i][j]]-1].insert(zatu[e.first]-1);\n          }\n        }\n      }\n    }\n  }\n/*\n  for(auto &e: mp) {\n    cout << e.first << endl;\n    cout << e.second.rmi << \" \" << e.second.rma << \" \" << e.second.cmi << \" \" << e.second.cma << endl;\n  }\n\n  REP(i, SZ(zatu)) {\n    cout << i << \":\";\n    for(auto &e: g[i]) {\n      cout << e << \" \";\n    }\n    cout << endl;\n  }\n  */\n\n  Scc scc(id-1);\n  REP(i, id-1) {\n    for(auto &e: g[i]) {\n      scc.add_edge(i, e);\n    }\n  }\n\n  vi tmp = scc.scc();\n  map<int, int> cnt;\n  REP(i, id-1) {\n    cnt[tmp[i]]++;\n  }\n  if(SZ(cnt) != id-1) ok = false;\n\n  cout << (ok ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  int t; cin >> t;\n  while(t--) {\n    solve();\n  }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<(S)<<endl\n#define F first\n#define S second\nusing namespace std;\n\nint main(){\n\tint N;\n\tcin>>N;\n\tREP(n,0,N){\n\t\tint H,W;\n\t\tcin>>H>>W;\n\t\tbool safe=true;\n\t\tmap<char,int> xmin,xmax,ymin,ymax;\n\t\tchar field[51][51];\n\t\tset<char> s;\n\t\tREP(i,0,H){\n\t\t\tREP(j,0,W){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tchar c=field[i][j];\n\t\t\t\tif(c=='.') continue;\n\t\t\t\tif(s.find(c)==s.end()){\n\t\t\t\t\ts.insert(c);\n\t\t\t\t\txmin[c]=xmax[c]=j;\n\t\t\t\t\tymin[c]=ymin[c]=i;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\txmin[c]=min(xmin[c],j);\n\t\t\t\t\txmax[c]=max(xmax[c],j);\n\t\t\t\t\tymin[c]=min(ymin[c],i);\n\t\t\t\t\tymax[c]=max(ymax[c],i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tset<char> oks;\n\t\tfor(char c:s){\n\t\t\tbool flag=true;\n\t\t\tREP(i,ymin[c],ymax[c]+1) REP(j,xmin[c],xmax[c]+1){\n\t\t\t\tif(field[i][j]!=c) flag=false;\n\t\t\t}\n\t\t\tif(flag) oks.insert(c);\n\t\t}\n\t\twhile(s.size()!=oks.size()){\n\t\t\tbool flag2=false;\n\t\t\tfor(char c:s){\n\t\t\t\tif(oks.find(c)!=oks.end()) continue;\n\t\t\t\tbool flag=true;\n\t\t\t\tREP(i,ymin[c],ymax[c]+1) REP(j,xmin[c],xmax[c]+1){\n\t\t\t\t\tif(field[i][j]!=c&&oks.find(field[i][j])==oks.end()) flag=false;\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\toks.insert(c);\n\t\t\t\t\tflag2=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag2) {\n\t\t\t\tsafe=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp(safe?\"SAFE\":\"SUSPICIOUS\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <tuple>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <array>\n#include <functional>\n#include <list>\n#include <iomanip>\n#include <set>\nconst int MOD=1000000007;\nconst int INF=1000000000;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nconst double eps=1e-9;\nconst int inf=1e9;\ntypedef pair<int,int> P;\nstruct Point\n{\n  double x,y,z;\n};\nPoint operator-(const Point& a,const Point& b)\n{\n  Point ret={a.x-b.x,a.y-b.y,a.z-b.z};\n  return ret;\n}\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x+a.y*b.y+a.z*b.z;\n}\nPoint cross(Point a,Point b)\n{\n  Point ret={a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x};\n  return ret;\n}\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y+a.z*a.z;\n}\n\nstring board[55];\nint H,W;\nint n;\nbool visited[55][55];\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\ntypedef pair<int,int> P;\n\nbool isrect(int x,int y)\n{\n  int left,right,top,bottom;\n  left=right=x;\n  top=bottom=y;\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  if(board[i][j]==board[y][x])\n\t    {\n\t      if(j<left) left=j;\n\t      if(j>right) right=j;\n\t      if(i<top) top=i;\n\t      if(i>bottom) bottom=i;\n\t    }\n\t}\n    }\n  for(int i=top;i<bottom+1;i++)\n    {\n      for(int j=left;j<right+1;j++)\n\t{\n\t  if(board[i][j]!=board[y][x] && !visited[i][j]) return false;\n\t}\n    }\n  return true;\n}\n\nvoid draw(int x,int y,char c)\n{\n  if(visited[y][x]) return;\n  visited[y][x]=true;\n  for(int i=0;i<4;i++)\n    {\n      int nx=x+dx[i];\n      int ny=y+dy[i];\n      if(nx<0 || W<=nx || ny<0 || H<=ny) continue;\n      if(board[ny][nx]!=c) continue;\n      draw(nx,ny,c);\n    }\n}\n\nbool isSafe()\n{\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  if(board[i][j]!='.' && !visited[i][j]) return false;\n\t}\n    }\n  return true;\n}\n\n\nint main(int argc,char const* argv[])\n{\n  cin >> n;\n  for(int k=0;k<n;k++)\n    {\n      cin >> H >> W;\n      memset(visited,false,sizeof(visited));\n      for(int j=0;j<H;j++)\n\t{\n\t  cin >> board[j];\n\t}\n      while(1)\n\t{\n\t  bool end=true;\n\t  bool update=false;\n\t  for(int i=0;i<H;i++)\n\t    {\n\t      for(int j=0;j<W;j++)\n\t\t{\n\t\t  if(board[i][j]=='.') continue;\n\t\t  if(visited[i][j]) continue;\n\t\t  end=false;\n\t\t  if(isrect(j,i))\n\t\t    {\n\t\t      update=true;\n\t\t      draw(j,i,board[i][j]);\n\t\t    }\n\t\t}\n\t    }\n\t  if(end || !update) break;\n\t}\n      if(isSafe())\n\t{\n\t  cout << \"SAFE\" << endl;\n\t}\n      else\n\t{\n\t  cout << \"SUSPICIOUS\" << endl;\n\t}\n    }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\nstring enumerate(int,int,int,int);\nbool consistent_order(string);\n\nchar datas[50][50];\nint data;\nchar moji;\nint min_x[256];\nint max_x[256];\nint min_y[256];\nint max_y[256];\nstring include_moji[256];\n\nint main(){\n  int h,w,tmp;\n  while(cin >> tmp){\n    for(int kaisu=0;kaisu<tmp;kaisu++){\n      cin >> h >> w;\n      \n      for(int i=0;i<256;i++){\n\tmin_x[i] = max_x[i] = min_y[i] = max_y[i] = -1;\n      }\n      \n      for(int i=0;i<h;i++){\n\tfor(int j=0;j<w;j++){\n\t  cin >> datas[i][j];\n\t  data=int(datas[i][j]);\n\t  if(min_x[data]==-1){\n\t    min_x[data] = max_x[data] = i;\n\t    min_y[data] = max_y[data] = j;\n\t  }\n\t  if(max_x[data] < i){\n\t    max_x[data] = i;\n\t  }else if(min_x[data] > i){\n\t    min_x[data]  = i;\n\t  }\n\t  if(max_y[data] < j){\n\t    max_y[data] = j;\n\t  }else if(min_y[data] > j){\n\t    min_y[data]  = j;\n\t  }\n\t}\n      }\n\n      \n      string enume = enumerate(0,0,w-1,h-1);\n      sort(enume.begin(), enume.end());\n\n      if(enume == \".\"){\n\tcout << \"SAFE\" << endl;\n      }else{\n\n\tif(enume[0]=='.'){\n\t  enume.erase(0,1);\n\n\t}\n\n\tstring all =\" \";\n\t\n\tfor(unsigned int k=0;k<enume.size();k++){\n\t  moji = enume[k];\n\t  all+=enumerate(min_y[moji],min_x[moji],max_y[moji],max_x[moji]);\n\t}\n\t\n\tif(all.find('.') != string::npos){ //àµ·û`àÉ.ª Á½çAâßé\n\t  cout << \"SUSPICIOUS\" << endl;\n\t}else{\n\t  for(unsigned int k=0;k<enume.size();k++){\n\t    moji = enume[k];\n\t    include_moji[moji] = enumerate(min_y[moji],\n\t\t\t\t\t   min_x[moji],max_y[moji],max_x[moji]);\n\t  }\n\t  if(!consistent_order(enume)){\n\t    cout << \"SUSPICIOUS\" << endl;\n\t  }\t\n\t}\n      }\n    }    \n  }\n}\n\n\nstring enumerate(int left, int top, int right, int bottom){\n  string all=\"\";\n  for(int i=top;i <= bottom; i++){\n    for(int j=left;j <= right;j++){\n      //±ÌªÌL@ªöµ¢ ±±©ç\n      if(all.find(datas[i][j])==string::npos){\n\tall += datas[i][j];\n\t//±±ÜÅ\n      }\n    }\n  }\n  return all;\t\n}\n\nbool consistent_order(string order){\n  int i;\n  int order_size = order.size();\n  do{\n    for(i=0 ; i<order_size;i++){\n      string wa = \"\";\n      \n      for(int j=i+1;j<order_size;j++){\n\twa += include_moji[order[j]];\t\n      }\n      \n      if(wa.find(order[i])!= string::npos){\n\tbreak;\n      }\n    }\n    if(i==order_size){\n      cout <<\"SAFE\" << endl;\n      return true;\n    }\n  }while(next_permutation(order.begin(),order.end()));\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 52;\n\nchar c[MAX_N][MAX_N];\nint up[31],lf[31],rg[31],dw[31];\nbool flag[31];\nint n,H,W;\nbool end_flag;\n\nvector<int> G[31];\nint color[31];\ndeque<int> L;\nbool cycle;\t//????????????\n\nvoid visit(int u)\n{\n\tif(color[u] == 0){\n\t\tcycle = true;\t//DAG??§??????\n\t\treturn;\n\t}\n\tif(color[u] == 1){\n\t\treturn;\n\t}\n\tcolor[u] = 0;\n\tfor(int i=0;i<G[u].size();i++){\n\t\tvisit(G[u][i]);\n\t}\n\tcolor[u] = 1;\n\tL.push_front(u);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n    for(int loop=0;loop<n;loop++){\n        scanf(\"%d%d\",&H,&W);\n        end_flag = false;\n        fill(up,up+30,INF);\n        fill(lf,lf+30,INF);\n        fill(rg,rg+30,-1);\n        fill(dw,dw+30,-1);\n        fill(flag,flag+30,false);\n        rep(i,30){\n            G[i].clear();\n        }\n        L.clear();\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                cin >> c[i][j];\n                if(c[i][j] != '.'){\n                    int id = (int)(c[i][j] - 'A');\n                    if(up[id] > i){\n                        up[id] = i;\n                    }\n                    if(lf[id] > j){\n                        lf[id] = j;\n                    }\n                    if(rg[id] < j){\n                        rg[id] = j;\n                    }\n                    if(dw[id] < i){\n                        dw[id] = i;\n                    }\n                    if(!flag[id]){\n                        flag[id] = true;\n                    }\n                }\n            }\n        }\n        for(int i=0;i<30;i++){\n            if(flag[i]){\n                for(int j = up[i];j <= dw[i];j++){\n                    for(int k = lf[i];k <= rg[i];k++){\n                        if(c[j][k] == '.'){\n                            cout << \"SUSPICIOUS\\n\";\n                            end_flag = true;\n                            break;\n                        }\n                        if((char)('A' + i) != c[j][k]){\n                            G[i].push_back((int)(c[j][k] - 'A'));\n                        }\n                    }\n                    if(end_flag){\n                        break;\n                    }\n                }\n            }\n            if(end_flag){\n                break;\n            }\n        }\n        if(end_flag){\n            continue;\n        }\n        rep(i,30){\n            sort(G[i].begin(),G[i].end());\n            G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n        }\n        rep(i,30){\n    \t\tcolor[i] = -1;\n    \t}\n    \trep(i,30){\n    \t\tif(color[i] == -1){\n    \t\t\tcycle = false;\n    \t\t\tvisit(i);\n    \t\t}\n    \t\tif(cycle){\n    \t\t\tbreak;\n    \t\t}\n    \t}\n        if(cycle){\n            cout << \"SUSPICIOUS\\n\";\n        }else{\n            cout << \"SAFE\\n\";\n        }\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nint h, w;\nbool ans;\n\nvoid debug(vector<string> s){\n\tcout << \"[debug]\" << endl;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tcout << s[y] << endl;\n\t}\n\tcout << endl;\n}\n\n// ツ債カツ湘」ツづ?右ツ可コツづ個催?標ツづーツ陛板つキ\npair<P,P> get_size(const vector<string>& s, char c){\n\tint max_x=0, max_y=0, min_x=1e+8, min_y=1e+8;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( s[y][x] == c ){\n\t\t\t\tmax_x = max( max_x , x );\n\t\t\t\tmax_y = max( max_y , y );\n\t\t\t\tmin_x = min( min_x , x );\n\t\t\t\tmin_y = min( min_y , y );\n\t\t\t}\n\t\t}\n\t}\n\treturn pair<P,P>( P(min_x,min_y) , P(max_x,max_y) );\n}\n\n// ツ陳キツ陛サツ形ツつゥツ陳イツづ猟づゥ\nbool is_rect(const vector<string>& s, char c){\n\tpair<P,P> pp = get_size( s , c );\n\t\n\tint min_x = pp.first.first;\n\tint min_y = pp.first.second;\n\tint max_x = pp.second.first;\n\tint max_y = pp.second.second;\n\t//cout << \"char c : \" << c << \" (\" << min_x << \",\" << min_y << \") , (\" << max_x << \",\" << max_y << \")\" << endl;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( min_x <= x && min_y <= y && x <= max_x && y <= max_y ){\n\t\t\t\tif( s[y][x] == c || s[y][x] == '*' ){\n\t\t\t\t}else{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif( s[y][x] == c ) return false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\n// ツ嘉猟閉ィツづーツ偲ヲツづィツ渉慊つュ\nvector<string> remove(vector<string> s, char c){\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( s[y][x] == c ){\n\t\t\t\ts[y][x] = '*';\n\t\t\t}\n\t\t}\n\t}\n\treturn s;\n}\n\n// memo[i] : iツ氾板姪堋づ個嘉猟閉ィツづーツ陳イツづ猟つスツつゥツづ?つ、ツつゥ, vc[i] : iツ氾板姪堋づ個嘉猟閉ィツづーツ表ツつキツ閉カツ篠?\n// s : w*hツづ個湘ウツ妥? cnt : ツ偲ヲツづィツ渉慊つ「ツつスツ嘉猟閉ィツづ個青?\nvoid solve(vector<bool> memo, vector<char> vc, vector<string> s, int cnt){\n\tif( ans ) return;\n\tif( cnt == vc.size() ){\n\t\tans = true;\n\t\treturn;\n\t}\n\t\n\tfor(int i=0 ; i < vc.size() ; i++ ){\n\t\tif( memo[i] ) continue;\n\t\t//debug( s );\n\t\tchar c = vc[i];\n\t\tif( is_rect( s , c ) ){\n\t\t\tmemo[i] = true;\n\t\t\ts = remove( s , c );\n\t\t\t//debug( s );\n\t\t\tsolve( memo , vc , s , cnt+1 );\n\t\t\tmemo[i] = false;\n\t\t}\n\t}\n}\n\nint main(){\n\tint T;\n\tcin >> T;\n\tfor(int i = 0 ; i < T ; i++ ){\n\t\tcin >> w >> h;\n\t\tvector<string> s;\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tstring s_;\n\t\t\tcin >> s_;\n\t\t\ts.push_back( s_ );\n\t\t}\n\n\t\tint f[256] = {0};\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tchar c = s[y][x];\n\t\t\t\tif( c >= 'A' && c <= 'Z' ){\n\t\t\t\t\tf[c] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<char> vc;\n\t\tfor(char c='A' ; c <= 'Z' ; c++ ){\n\t\t\tif( f[c] ){\n\t\t\t\tvc.push_back( c );\n\t\t\t}\n\t\t}\n\n\t\t//debug( s );\n\t\tif( vc.size() == 0 ){\n\t\t\tcout << \"SAFE\" << endl;\n\t\t}else{\n\t\t\tans = false;\n\t\t\tvector<bool> memo( (int)vc.size() , false );\n\t\t\t//solve( memo , vc , s , 0 );\n\t\t\tif( ans ){\n\t\t\t\tcout << \"SAFE\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\n\tint h,w;\nbool dfs(vs &m,vi &usedChars,char c){\n\tusedChars[c-'A']=1;\n\tint x1=INT_MAX,x2=INT_MIN,y1=INT_MAX,y2=INT_MIN;\n\tfor (int i = 0; i < h; i++)\n\t{\n\t\tfor (int j = 0; j < w; j++)\n\t\t{\n\t\t\tif(m[i][j]==c){\n\t\t\t\tx1=min(x1,j);\n\t\t\t\tx2=max(x2,j);\n\t\t\t\ty1=min(y1,i);\n\t\t\t\ty2=max(y2,i);\n\t\t\t}\n\t\t}\n\t}\n\tvector<pii> p;\n\tfor (int i = y1; i <= y2; i++)\n\t{\n\t\tfor (int j = x1; j <= x2; j++)\n\t\t{\n\t\t\tif(m[i][j]!=c){\n\t\t\t\tif(m[i][j]=='.'||usedChars[m[i][j]-'A']){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tp.push_back(make_pair(i,j));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < p.size(); i++)\n\t{\n\t\tpii pp=p[i];\n\t\tif(!dfs(m,usedChars,m[pp.first][pp.second])){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor (int c = 0; c < n; c++)\n\t{\n\t\tcin>>h>>w;\n\t\tvs m(h);\n\t\tfor (int i = 0; i < h; i++)\n\t\t{\n\t\t\tcin>>m[i];\n\t\t}\n\t\tvi usedChars('Z'-'A'+1);\n\t\tbool ok=true;\n\t\tfor (int i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tif(m[i][j]!='.'&&!usedChars[m[i][j]-'A']){\n\t\t\t\t\tif(!dfs(m,usedChars,m[i][j])){\n\t\t\t\t\t\tok=false;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\nend:\n\t\tcout<<(ok?\"SAFE\":\"SUSPICIOUS\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<map>\nusing namespace std;\nmap<char,int> mp;\nint x1[10];\nint x2[10];\nint y1[10];\nint y2[10];\nbool used[10];\nint t[50][50];\nint max(int a,int b){return a>b?a:b;}\nint min(int a,int b){return a<b?a:b;}\nvoid update(int n,int x,int y){\n\tx1[n]=min(x1[n],x);\n\tx2[n]=max(x2[n],x);\n\ty1[n]=min(y1[n],y);\n\ty2[n]=max(y2[n],y);\n}\nint main(){\n\tint d;\n\tint h,w;\n\tint i,j,k;\n\tscanf(\"%d\",&d);\n\tfor(int di=0;di<d;di++){\n\t\tscanf(\"%d %d\",&h,&w);\n\t\tint p=1;\n\t\tmp.clear();\n\t\tfor(i=0;i<10;i++){\n\t\t\tx1[i]=100;\n\t\t\tx2[i]=0;\n\t\t\ty1[i]=100;\n\t\t\ty2[i]=0;\n\t\t\tused[i]=false;\n\t\t}\n\t\tfor(i=0;i<h;i++){\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tchar c;\n\t\t\t\tscanf(\" %c\",&c);\n\t\t\t\tif(c=='.'){\n\t\t\t\t\tt[i][j]=-1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(mp[c]==0)mp[c]=p++;\n\t\t\t\tupdate(mp[c],i,j);\n\t\t\t\tt[i][j]=mp[c];\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tfor(i=1;i<=p;i++){\n\t\t\t\tif(used[i])continue;\n\t\t\t\tint res=0;\n\t\t\t\tfor(j=x1[i];j<=x2[i];j++){\n\t\t\t\t\tfor(k=y1[i];k<=y2[i];k++){\n\t\t\t\t\t\tif(t[j][k]==i||t[j][k]==0)res++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(res==(x2[i]-x1[i]+1)*(y2[i]-y1[i]+1)){\n\t\t\t\t\tfor(j=x1[i];j<=x2[i];j++){\n\t\t\t\t\t\tfor(k=y1[i];k<=y2[i];k++){\n\t\t\t\t\t\t\tt[j][k]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tused[i]=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i==p+1)break;\n\t\t}\n\t\tfor(i=0;i<h;i++){\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tif(!(t[i][j]==0||t[i][j]==-1))break;\n\t\t\t}\n\t\t\tif(j!=w)break;\n\t\t}\n\t\tif(i==h)printf(\"SAFE\\n\");\n\t\telse printf(\"SUSPICIOUS\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n\nconst double pi = 3.141592653589793238462643383279;\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s)\n{\n  int v;\n  istringstream sin(s);\n  sin >> v;\n  return v;\n}\ntemplate <class T>\ninline string toString(T x)\n{\n  ostringstream sout;\n  sout << x;\n  return sout.str();\n}\ninline int readInt()\n{\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a) * (a))\n#define EACH(i, c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort((c).begin(), (c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i, s, n) for (int i = s; i < (int)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define MOD 1000000007\n\n#define rep(i, a, b) for (int i = a; i < (b); ++i)\n#define trav(a, x) for (auto &a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\n\nclass UnionFind\n{\npublic:\n  vector<int> par;\n  vector<int> siz;\n\n  UnionFind(int sz_) : par(sz_), siz(sz_, 1)\n  {\n    for (ll i = 0; i < sz_; ++i)\n      par[i] = i;\n  }\n  void init(int sz_)\n  {\n    par.resize(sz_);\n    siz.assign(sz_, 1LL);\n    for (ll i = 0; i < sz_; ++i)\n      par[i] = i;\n  }\n\n  int root(int x)\n  {\n    while (par[x] != x)\n    {\n      x = par[x] = par[par[x]];\n    }\n    return x;\n  }\n\n  bool merge(int x, int y)\n  {\n    x = root(x);\n    y = root(y);\n    if (x == y)\n      return false;\n    if (siz[x] < siz[y])\n      swap(x, y);\n    siz[x] += siz[y];\n    par[y] = x;\n    return true;\n  }\n\n  bool issame(int x, int y)\n  {\n    return root(x) == root(y);\n  }\n\n  int size(int x)\n  {\n    return siz[root(x)];\n  }\n};\n\nll modPow(ll x, ll n, ll mod = MOD)\n{\n  ll res = 1;\n  while (n)\n  {\n    if (n & 1)\n      res = (res * x) % mod;\n\n    res %= mod;\n    x = x * x % mod;\n    n >>= 1;\n  }\n  return res;\n}\n\n#define SIEVE_SIZE 5000000 + 10\nbool sieve[SIEVE_SIZE];\nvoid makeSieve()\n{\n  for (int i = 0; i < SIEVE_SIZE; ++i)\n    sieve[i] = true;\n  sieve[0] = sieve[1] = false;\n  for (int i = 2; i * i < SIEVE_SIZE; ++i)\n    if (sieve[i])\n      for (int j = 2; i * j < SIEVE_SIZE; ++j)\n        sieve[i * j] = false;\n}\n\nbool isprime(ll n)\n{\n  if (n == 0 || n == 1)\n    return false;\n  for (ll i = 2; i * i <= n; ++i)\n    if (n % i == 0)\n      return false;\n  return true;\n}\n\nconst int MAX = 2000010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit()\n{\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (int i = 2; i < MAX; i++)\n  {\n    fac[i] = fac[i - 1] * i % MOD;\n    inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n    finv[i] = finv[i - 1] * inv[i] % MOD;\n  }\n}\n\n// 二項係数計算\nlong long COM(int n, int k)\n{\n  if (n < k)\n    return 0;\n  if (n < 0 || k < 0)\n    return 0;\n  return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nlong long extGCD(long long a, long long b, long long &x, long long &y)\n{\n  if (b == 0)\n  {\n    x = 1;\n    y = 0;\n    return a;\n  }\n  long long d = extGCD(b, a % b, y, x);\n  y -= a / b * x;\n  return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK)\ninline long long mod(long long a, long long m)\n{\n  return (a % m + m) % m;\n}\n\n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m)\n{\n  long long x, y;\n  extGCD(a, m, x, y);\n  return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b)\n{\n\n  if (b == 0)\n    return a;\n  return GCD(b, a % b);\n}\n\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nmat mul(mat &A, mat &B)\n{\n  mat C(A.size(), vec((int)B[0].size()));\n  for (int i = 0; i < A.size(); ++i)\n  {\n    for (int k = 0; k < B.size(); ++k)\n    {\n      for (int j = 0; j < B[0].size(); ++j)\n      {\n        C[i][j] = (C[i][j] + A[i][k] * B[k][j] % MOD) % MOD;\n      }\n    }\n  }\n  return C;\n}\nmat matPow(mat A, ll n)\n{\n  mat B(A.size(), vec((int)A.size()));\n\n  for (int i = 0; i < A.size(); ++i)\n  {\n    B[i][i] = 1;\n  }\n\n  while (n > 0)\n  {\n    if (n & 1)\n      B = mul(B, A);\n    A = mul(A, A);\n    n >>= 1;\n  }\n  return B;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(15);\n\n  int q;\n  cin >> q;\n  while (q--)\n  {\n    int H, W;\n    cin >> H >> W;\n    vector<string> s;\n    for (int i = 0; i < H; i++)\n    {\n      string t;\n      cin >> t;\n      s.push_back(t);\n    }\n\n    bool update = true;\n    bool ok = false;\n    while (update)\n    {\n      update = false;\n      bool completed = true;\n      for (int i = 0; i < H; i++)\n      {\n        for (int j = 0; j < W; j++)\n        {\n          if (s[i][j] != '.' && s[i][j] != '?')\n            completed = false;\n        }\n      }\n      if (completed)\n      {\n        ok = true;\n        break;\n      }\n\n      bool checked[26] = {false};\n      for (int i = 0; i < H; i++)\n      {\n        for (int j = 0; j < W; j++)\n        {\n          if (s[i][j] == '.' || s[i][j] == '?')\n            continue;\n\n          if (checked[s[i][j] - 'A'])\n            continue;\n\n          checked[s[i][j] - 'A'] = true;\n          char c = s[i][j];\n          int wl = INT_MAX, wr = 0, hu = INT_MAX, hd = 0;\n\n          for (int k = 0; k < H; k++)\n          {\n            for (int l = 0; l < W; l++)\n            {\n              if (s[k][l] == c)\n              {\n                wl = min(wl, l);\n                wr = max(wr, l);\n                hu = min(hu, k);\n                hd = max(hd, k);\n              }\n            }\n          }\n          //cout << c << \" \" << mxh << \" \" << mxw << endl;\n          bool f = true;\n          for (int k = hu; k <= hd; k++)\n          {\n            for (int l = wl; l <= wr; l++)\n            {\n              if (s[k][l] != c && s[k][l] != '?')\n                f = false;\n            }\n          }\n\n          if (f)\n          {\n            update = true;\n            for (int k = hu; k <= hd; k++)\n            {\n              for (int l = wl; l <= wr; l++)\n              {\n                s[k][l] = '?';\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (ok)\n    {\n      cout << \"SAFE\" << endl;\n    }\n    else\n    {\n      cout << \"SUSPICIOUS\" << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nstruct make\n{\n\tchar str;\n\tint posi,start[2];\n\tint high,wide,JUDGE;\n\tstruct make *front[8];\n\tint f_count;\n};\n\nint loop_judge(int COUNT,int count,struct make *M);\n\nint main()\n{\n\tint N,H,W,count,COUNT,judge,no_rect[7],NO_RECT,prin[500];\n\tchar img[1000][51],print[6][20]={\"SUSPICIOUS1\",\"SUSPICIOUS2\",\"SAFE1\",\"SUSPICIOUS3\",\"SAFE2\",\"SAFE3\"};\n\tstruct make M[8];\n\tstruct make *MP;\n\t\n\tscanf(\"%d\",&N);//データの個数\n\tfor(int a=0;a<N;a++)\n\t{\n\t\tcount=0;//材質の個数\n\t\tCOUNT=0;\n\t\tNO_RECT=0;\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tscanf(\"%s\",img[b]);\n\t\t\timg[b][W]='\\0';\n\t\t}\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tfor(int d=0;d<count;d++) M[d].posi=-1;\n\t\t\tfor(int c=0;c<W;c++)\n\t\t\t{\n\t\t\t\tif(img[b][c]!='.')\n\t\t\t\t{\n\t\t\t\t\t//材質判定\n\t\t\t\t\tjudge=0;\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t\tif(count>0 && img[b][c]!=M[judge].str) judge++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}while(judge<count);\n\t\t\t\t\t//新しい材質の場合\n\t\t\t\t\tif(judge==count)\n\t\t\t\t\t{\n\t\t\t\t\t\tM[count].str=img[b][c];\n\t\t\t\t\t\tM[count].start[0]=b;\n\t\t\t\t\t\tM[count].start[1]=c;\n\t\t\t\t\t\tM[count].posi=c;\n\t\t\t\t\t\tM[count].high=1;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\t//既出の材質の場合\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(M[judge].start[1]>c) M[judge].start[1]=c;\n\t\t\t\t\t\tif(M[judge].posi<0) M[judge].posi=c;\n\t\t\t\t\t\telse if(M[judge].wide<c-M[judge].posi+1) M[judge].wide=c-M[judge].posi+1;\n\t\t\t\t\t\tM[judge].high=b-M[judge].start[0]+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//判定開始\n\t\tif(count)\n\t\t{\n\t\t\t//見えている部分が長方形かどうか判定\n\t\t\tfor(int b=0;b<count;b++)\n\t\t\t{\n\t\t\t\tM[b].JUDGE=1;\n\t\t\t\tM[b].f_count=0;\n\t\t\t\tfor(int c=0;c<8;c++) M[b].front[c]=NULL;\n\t\t\t\tfor(int s1=0;s1<M[b].high;s1++)\n\t\t\t\t{\n\t\t\t\t\tfor(int s2=0;s2<M[b].wide;s2++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//確実に長方形ではない場合\n\t\t\t\t\t\tif(img[s1+M[b].start[0]][s2+M[b].start[1]]=='.')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNO_RECT=1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//長方形の可能性もある場合\n\t\t\t\t\t\tif(img[s1+M[b].start[0]][s2+M[b].start[1]]!=M[b].str)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int c=0;c<count;c++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint e=0;\n\t\t\t\t\t\t\t\tfor(int d=0;d<M[b].f_count;)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif(img[s1+M[b].start[0]][s2+M[b].start[1]]==M[b].front[d]->str) break;\n\t\t\t\t\t\t\t\t\td++;\n\t\t\t\t\t\t\t\t\te=d;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//今いる座標のもじと比べる\n\t\t\t\t\t\t\t\tif(img[s1+M[b].start[0]][s2+M[b].start[1]]==M[c].str && e==M[b].f_count)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tM[b].front[M[b].f_count]=&M[c];\n\t\t\t\t\t\t\t\t\tM[b].f_count++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(M[b].JUDGE!=0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tno_rect[COUNT]=b;\n\t\t\t\t\t\t\t\tCOUNT++;\n\t\t\t\t\t\t\t\tM[b].JUDGE=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(NO_RECT==1) break;\n\t\t\t\t}\n\t\t\t\tif(M[b].JUDGE)M[b].front[M[b].f_count]=NULL;\n\t\t\t}\n\t\t\tif(NO_RECT) prin[a]=0;\n\t\t\t//printf(\"SUSPICIOUS1\\n\");\n\t\t\telse if(COUNT)\n\t\t\t{\n\t\t\t\tif(count!=COUNT)\n\t\t\t\t{\n\t\t\t\t\tint loop=0;\n\t\t\t\t\tint LCOUNT=0;\n\t\t\t\t\t//循環していないか確認\n\t\t\t\t\tfor(int b=0;b<COUNT;b++)\n\t\t\t\t\t{\n\t\t\t\t\t\tMP=&M[no_rect[b]];\n\t\t\t\t\t\tloop+=loop_judge(COUNT,LCOUNT,MP);\n\t\t\t\t\t\tif(loop)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprintf(\"SUSPICIOUS2\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(loop==0) prin[a]=2;\n\t\t\t\t\t//printf(\"SAFE1\\n\");\n\t\t\t\t}\n\t\t\t\telse prin[a]=3;//printf(\"SUSPICIOUS3\\n\");\n\t\t\t}\n\t\t\telse prin[a]=4;//printf(\"SAFE2\\n\");\n\t\t}\n\t\telse prin[a]=5;//printf(\"SAFE3\\n\");\n\t}\n\tfor(int a=0;a<N;a++) printf(\"%s\\n\",print[prin[a]]);\n\treturn 0;\n}\nint loop_judge(int COUNT,int count,struct make *M)\n{\n\tint loop;\n\tif(M->front==NULL) return 0;\n\telse count++;\n\tif(COUNT==count) return 1;\n\telse\n\tfor(loop=0;loop<M->f_count;loop++)\n\t{\n\t\tif(loop_judge(COUNT,count,M->front[loop])==0) return 0;\n\t}\n\tif(loop==M->f_count) return 1;\n}\n//printf(\"#\\n\");\n//printf(\"#1 count=%d\\n\",count);\n//printf(\"#1 COUNT=%d\\n\",COUNT);\n//printf(\"#1 NO_RECT=%d\\n\",NO_RECT);\n//printf(\"M[%d].str=%c\\nM[%d].high=%d\\nM[%d].wide=%d\\n\\n\",b,M[b].str,b,M[b].high,b,M[b].wide);\n//printf(\"#1\\nM[%d].start[0]=%d\\nM[%d].start[1]=%d\\n\\n\",b,M[b].start[0],b,M[b].start[1]);\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\n#include <vector>\nusing namespace std;\n\ntypedef pair<char,char> P;\n\nint main(){\n\tint t;\n\tcin >> t;\n\tfor(int a = 0;a < t;a++){\n\t\tint h,w;\n\t\tmap<char,int> xmin,xmax,ymin,ymax,in;\n\t\tmap<char,bool> used;\n\t\tmap<char,vector<int> > G;\n\t\tmap<P,bool> already;\n\t\tstring field[50];\n\t\tcin >> h >> w;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tcin >> field[i];\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(field[i][j] != '.'){\n\t\t\t\t\tif(xmin.find(field[i][j]) == xmin.end()){\n\t\t\t\t\t\txmin[field[i][j]] = i;\n\t\t\t\t\t\txmax[field[i][j]] = i;\n\t\t\t\t\t\tymin[field[i][j]] = j;\n\t\t\t\t\t\tymax[field[i][j]] = j;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\txmin[field[i][j]] = min(i,xmin[field[i][j]]);\n\t\t\t\t\t\txmax[field[i][j]] = max(i,xmax[field[i][j]]);\n\t\t\t\t\t\tymin[field[i][j]] = min(j,ymin[field[i][j]]);\n\t\t\t\t\t\tymax[field[i][j]] = max(j,ymax[field[i][j]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag = true;\n\t\tfor(auto it = xmin.begin();it != xmin.end();it++) {\n\t\t\tin[it->first] = 0;\n\t\t\tused[it->first] = false;\n\t\t}\n\t\tfor(auto it = xmin.begin();it != xmin.end();it++){\n\t\t\tchar c = it->first;\n\t\t\tfor(int i = xmin[c];i <= xmax[c];i++){\n\t\t\t\tfor(int j = ymin[c];j <= ymax[c];j++){\n\t\t\t\t\tif(field[i][j] == '.') flag = false;\n\t\t\t\t\telse if(field[i][j] != c && !already[P(c,field[i][j])]){\n\t\t\t\t\t\tG[c].push_back(field[i][j]);\n\t\t\t\t\t\tin[field[i][j]]++;\n\t\t\t\t\t\talready[P(c,field[i][j])] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<char> que;\n\t\tfor(auto it = in.begin();it != in.end();it++){\n\t\t\tif(it->second == 0) que.push(it->first);\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tchar v = que.front();que.pop();\n\t\t\tused[v] = true;\n\t\t\tfor(int i = 0;i < G[v].size();i++){\n\t\t\t\tchar to = G[v][i];\n\t\t\t\tin[to]--;\n\t\t\t\tif(!in[to]){\n\t\t\t\t\tque.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(auto it = used.begin();it != used.end();it++){\n\t\t\tif(!it->second) flag = false;\n\t\t}\n\t\tif(flag) cout << \"SAFE\" << endl;\n\t\telse cout << \"SUSPICIOUS\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int MAX_S = 51;\nconst int dx[4] = {1,0,-1,0};\nconst int dy[4] = {0,1,0,-1};\nint H, W;\nchar G[MAX_S][MAX_S];\nbool vis[MAX_S][MAX_S];\n\npair<P, P> rec(int x, int y, char c) {\n  vis[y][x] = true;\n  pair<P, P> p = make_pair(P(x, y), P(x, y));\n  for(int i = 0; i < 4; ++i) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(nx < 0 || nx >= W) continue;\n    if(ny < 0 || ny >= H) continue;\n    if(vis[ny][nx]) continue;\n    if(G[ny][nx] != c) continue;\n    pair<P, P> q = rec(nx, ny, c);\n    p.first.first = min(p.first.first, q.first.first);\n    p.first.second = min(p.first.second, q.first.second);\n    p.second.first = max(p.second.first, q.second.first);\n    p.second.second = max(p.second.second, q.second.second);\n  }\n  return p;\n}\n\nbool isShikaku(int sx, int sy, int ex, int ey) {\n  char c = 0;\n  for(int i = sy; i <= ey; ++i) {\n    for(int j = sx; j <= ex; ++j) {\n      if(G[i][j] == '.') return false;\n      if(c == 0) {\n\tif(G[i][j] != '#') c = G[i][j];\n      } else if(G[i][j] != c && G[i][j] != '#') {\n\treturn false;\n      }\n    }\n  }\n  return true;\n}\n\nvoid fills(int sx, int sy, int ex, int ey) {\n  for(int i = sy; i <= ey; ++i) {\n    for(int j = sx; j <= ex; ++j) {\n      G[i][j] = '#';\n    }\n  }\n}\n\nvoid show() {\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      cout << G[i][j];\n    }\n    cout << endl;\n  }\n}\n\nvoid make(vector<pair<P, P> >&v) {\n  for(int i = 0; i < H; ++i) {\n    fill(vis[i], vis[i]+W, false);\n  }\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if(!vis[i][j] && G[i][j] != '.') {\n\tpair<P, P> p = rec(j, i, G[i][j]);\n\tv.push_back(p);\n      }\n    }\n  }\n}\n\nbool ans() {\n  vector<pair<P, P> > v;\n  make(v);\n  for(;;) {\n    bool flag = true;\n    for(vector<pair<P, P> >::iterator it = v.begin(); it != v.end();) {\n      pair<P, P> &p = *it;\n      if(isShikaku(p.first.first, p.first.second,\n\t\t   p.second.first, p.second.second)) {\n\n\tfills(p.first.first, p.first.second,\n\t      p.second.first, p.second.second);\n\tit = v.erase(it);\n\tflag = false;\n      } else {\n\t++it;\n      }\n    }\n    if(flag) return v.size() == 0;\n  }\n}\n\n\nint main() {\n  int T;\n  cin >> T;\n  while(T--) {\n    cin >> H >> W;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tcin >> G[i][j];\n      }\n    }\n    if(ans()) cout << \"SAFE\" << endl;\n    else cout << \"SUSPICIOUS\" << endl;\n    //show();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\n\tint h,w;\nbool search(vs &m,char c,vvi &order){\n\tint x1=INT_MAX,x2=INT_MIN,y1=INT_MAX,y2=INT_MIN;\n\tfor (int i = 0; i < h; i++)\n\t{\n\t\tfor (int j = 0; j < w; j++)\n\t\t{\n\t\t\tif(m[i][j]==c){\n\t\t\t\tx1=min(x1,j);\n\t\t\t\tx2=max(x2,j);\n\t\t\t\ty1=min(y1,i);\n\t\t\t\ty2=max(y2,i);\n\t\t\t}\n\t\t}\n\t}\n\tvector<pii> p;\n\tfor (int i = y1; i <= y2; i++)\n\t{\n\t\tfor (int j = x1; j <= x2; j++)\n\t\t{\n\t\t\tchar cc=m[i][j];\n\t\t\tif(cc!=c){\n\t\t\t\tif(cc=='.'){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\torder[c-'A'][cc-'A']=1;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nbool dfs(vvi &order,vi &used,int p){\n\tused[p-'A']=1;\n\tfor (int i = 'A'; i < 'Z'+1; i++)\n\t{\n\t\tif(order[p-'A'][i-'A']){\n\t\t\tif(used[i-'A']){\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\treturn dfs(order,used,i);\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor (int c = 0; c < n; c++)\n\t{\n\t\tcin>>h>>w;\n\t\tvs m(h);\n\t\tfor (int i = 0; i < h; i++)\n\t\t{\n\t\t\tcin>>m[i];\n\t\t}\n\t\tvvi order('Z'-'A'+1,vi('Z'-'A'+1));\n\t\tbool ok=true;\n\t\tvi used('Z'-'A'+1);\n\t\tfor (int i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tif(m[i][j]!='.'&&!used[m[i][j]-'A']){\n\t\t\t\t\tused[m[i][j]-'A']=1;\n\t\t\t\t\tif(!search(m,m[i][j],order)){\n\t\t\t\t\t\tok=false;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 'A'; i < 'Z'+1; i++)\n\t\t{\n\t\t\tvi used2('Z'-'A'+1);\n\t\t\tif(!used2[i-'A']&&!dfs(order,used2,i)){\n\t\t\t\tok=false;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\nend:\n\t\tcout<<(ok?\"SAFE\":\"SUSPICIOUS\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nint adj[26][26];\n\nbool cycle(void){\n  int d[26];\n  for(int i=0;i<26;i++)d[i] = 0;\n\n  for(int i=0;i<26;i++){\n    for(int j=0;j<26;j++){\n      for(int k=0;k<26;k++){\n\tif(adj[k][j] && d[j] > d[k] + adj[k][j]){\n\t  d[j] = d[k] + adj[k][j];\n\t  if(i==25)return true;\n\t}\n      }\n    }\n  }\n  return false;\n}\n\nint main(){\n  int n,h,w;\n  string pict[50];\n  int rr,rd,lu,ll;\n  bool flag;\n\n  cin >> n;\n  while(n){\n    n--;\n    cin >> h >> w;\n    for(int i=0;i<h;i++)cin >> pict[i];\n    for(int i=0;i<26;i++){\n      for(int j=0;j<26;j++)adj[i][j] = 0;\n    }\n\n    flag = true;\n    for(int i='A';i<='Z';i++){\n      rr = 0;\n      rd = 0;\n      lu = h;\n      ll = w;\n      for(int j=0;j<h;j++){\n\tfor(int k=0;k<w;k++){\n\t  if(pict[j][k] == i){\n\t    rr = max(rr,k);\n\t    rd = max(rd,j);\n\t    lu = min(lu,j);\n\t    ll = min(ll,k);\n\t  }\n\t}\n      }\n\n      for(int j=lu;j<=rd;j++){\n\tfor(int k=ll;k<=rr;k++){\n\t  if(pict[j][k] == '.'){\n\t    flag = false;\n\t    break;\n\t  }else if(pict[j][k] != i){\n\t    adj[pict[j][k] - 'A'][i - 'A'] = -1;\n\t    \n\t    if(cycle()){\n\t      flag = false;\n\t      break;\n\t    }\n\t    \n\t  }\n\t}\n\tif(!flag)break;\n      }\n      if(!flag)break;\n    }\n    /*\n    for(int i=0;i<26;i++){\n      for(int j=0;j<26;j++)cout << adj[i][j] << \" \";\n\tcout << endl;\n    }\n    */\n    if(!flag)cout << \"SUSPICOUS\" << endl;\n    else cout << \"SAFE\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\nstring f[50];\nint maxX[26], maxY[26], minX[26], minY[26];\nbool on[26][26];\nbool used[26];\n\nbool dfs(int n, int prev) {\n\tif(used[n]) {\n\t\treturn false;\n\t}\n\tused[n] = true;\n\tfor(int i = 0; i < 26; i++) {\n\t\tif(on[n][i] && i != prev && i != n) {\n\t\t\tif(!dfs(i, n)) return false;\n\t\t}\n\t}\n\tused[n] = false;\n\treturn true;\n}\n\nvoid check() {\n\tmemset(on, 0, sizeof on);\n\tmemset(used, 0, sizeof used);\n\tfor(int i = 0; i < 26; i++) {\n\t\tif(maxX[i] == -1) continue;\n\t\tfor(int y = minY[i]; y <= maxY[i]; y++) {\n\t\t\tfor(int x = minX[i]; x <= maxX[i]; x++) {\n\t\t\t\tif(f[y][x] == '.') {\n\t\t\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(f[y][x] != 'A' + i) {\n\t\t\t\t\ton[i][f[y][x] - 'A'] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 26; i++) {\n\t\tif(!dfs(i, -1)) {\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tcout << \"SAFE\" << endl;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint T, H, W;\n\tcin >> T;\n\twhile(T--) {\n\t\tcin >> H >> W;\n\t\tfor(int i = 0; i < H; i++) {\n\t\t\tcin >> f[i];\n\t\t}\n\n\t\tfor(int i = 0; i < 26; i++) {\n\t\t\tmaxX[i] = maxY[i] = -1;\n\t\t\tminX[i] = minY[i] = 100000;\n\t\t}\n\n\t\tfor(int y = 0; y < H; y++) {\n\t\t\tfor(int x = 0; x < W; x++) {\n\t\t\t\tif(f[y][x] == '.') continue;\n\t\t\t\tint c = f[y][x] - 'A';\n\t\t\t\tmaxX[c] = max(maxX[c], x);\n\t\t\t\tmaxY[c] = max(maxY[c], y);\n\t\t\t\tminX[c] = min(minX[c], x);\n\t\t\t\tminY[c] = min(minY[c], y);\n\t\t\t}\n\t\t}\n\n\t\tcheck();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nstruct make\n{\n\tchar str;\n\tint posi,start[2];\n\tint high,wide,JUDGE;//JUDGE==1で長方形,==0で長方形以外,==2で未定\n\tstruct make *front;\n};\n\n\nint main()\n{\n\tint N,H,W,count,COUNT,judge,no_rect,NO_RECT;\n\tchar img[1000][51],RECT[8];\n\tstruct make M[8];\n\tint s1,s2,num;\n\t\n\tscanf(\"%d\",&N);//データの個数\n\tfor(int a=0;a<N;a++)\n\t{\n\t\tcount=0;//材質の個数\n\t\tCOUNT=0;\n\t\tNO_RECT=0;\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tscanf(\"%s\",img[b]);\n\t\t\timg[b][W]='\\0';\n\t\t}\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tfor(int d=0;d<count;d++) M[d].posi=-1;\n\t\t\tfor(int c=0;c<W;c++)\n\t\t\t{\n\t\t\t\tif(img[b][c]!='.')\n\t\t\t\t{\n\t\t\t\t\t//材質判定\n\t\t\t\t\tjudge=0;\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t\tif(count>0 && img[b][c]!=M[judge].str) judge++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}while(judge<count);\n\t\t\t\t\t//新しい材質の場合\n\t\t\t\t\tif(judge==count)\n\t\t\t\t\t{\n\t\t\t\t\t\tM[count].str=img[b][c];\n\t\t\t\t\t\tM[count].start[0]=b;\n\t\t\t\t\t\tM[count].start[1]=c;\n\t\t\t\t\t\tM[count].posi=c;\n\t\t\t\t\t\tM[count].high=1;\n\t\t\t\t\t\tM[count].wide=1;\n\t\t\t\t\t\tM[count].JUDGE=0;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\t//既出の材質の場合\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(M[judge].start[1]>c) M[judge].start[1]=c;\n\t\t\t\t\t\tif(M[judge].posi<0) M[judge].posi=c;\n\t\t\t\t\t\telse if(M[judge].wide<c-M[judge].posi+1) M[judge].wide=c-M[judge].posi+1;\n\t\t\t\t\t\tM[judge].high=b-M[judge].start[0]+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tno_rect=count;\n\t\t//printf(\"count=%d\\n\",count);\n\t\t//判定開始\n\t\twhile(count)//文字アリ\n\t\t{\n\t\t\tCOUNT=0;\n\t\t\t//見えている部分が長方形かどうか判定\n\t\t\tfor(num=0;num<count;num++)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(M[num].JUDGE==1) continue;\n\t\t\t\tM[num].JUDGE=0;//長方形なら\n\t\t\t\t//printf(\"M[%d].str=%c\\nM[%d].high=%d\\nM[%d].wide=%d\\n\",num,M[num].str,num,M[num].high,num,M[num].wide);\n\t\t\t\t//printf(\"M[%d].start[0]=%d\\nM[%d].start[1]=%d\\n\",num,M[num].start[0],num,M[num].start[1]);\n\t\t\t\tfor(s1=0;s1<M[num].high;s1++)\n\t\t\t\t{\n\t\t\t\t\tfor(s2=0;s2<M[num].wide;s2++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//確実に長方形ではない場合\n\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]=='.')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNO_RECT=1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//長方形の可能性もある場合\n\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]!=M[num].str)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int r=0;r<count-no_rect;)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]==RECT[r]) break;\n\t\t\t\t\t\t\t\tr++;\n\t\t\t\t\t\t\t\tif(r==count-no_rect)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tM[num].JUDGE=2;\n\t\t\t\t\t\t\t\t\tCOUNT++;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(NO_RECT || M[num].JUDGE==2) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(NO_RECT || M[num].JUDGE==2) break;\n\t\t\t\t}\n\t\t\t\tif(NO_RECT) break;\n\t\t\t\t//長方形だった場合\n\t\t\t\tif(s1==M[num].high && s2==M[num].wide)\n\t\t\t\t{\n\t\t\t\t\tM[num].JUDGE=1;\n\t\t\t\t\tno_rect--;\n\t\t\t\t\tM[num].front=NULL;\n\t\t\t\t\tRECT[num]=M[num].str;\n\t\t\t\t}\n\t\t\t\t//printf(\"M[%d].JUDGE=%d\\n\\n\",num,M[num].JUDGE);\n\t\t\t}\n\t\t\tfor(int n=0;n<num;)\n\t\t\t{\n\t\t\t\tif(M[num].JUDGE!=2 && M[num].JUDGE!=1) break;\n\t\t\t\tn++;\n\t\t\t\t//どれも長方形ではなかった場合\n\t\t\t\tif(n==num) NO_RECT=1;\n\t\t\t}\n\t\t\t\n\t\t\t//printf(\"NO_RECT=%d\\n\",NO_RECT);\n\t\t\tif(NO_RECT==1) break;\n\t\t\t//printf(\"#no_rect=%d\\n\\n\\n\",no_rect);\n\t\t\t//すべて長方形\n\t\t\tif(no_rect==0) break;\n\t\t}\n\t\t//出力\n\t\tif(NO_RECT) printf(\"SUSPICIOUS1\\n\");\n\t\telse if(no_rect) printf(\"SUSPICIOUS2\\n\");\n\t\telse printf(\"SAFE1\\n\");\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <set>\n#include <iomanip>\n#include <stack>\n#include <fstream>\n#include <cstdint>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <functional>\n\nusing namespace std;\n\n\ntypedef int64_t ll;\n\n\nclass rect{\n    static const int inf = 100000;\npublic:\n    int sx, sy; // 始点 左上\n    int ex, ey; // 終点 右下\n    rect() :sx(inf), sy(inf), ex(), ey() {}\n    \n    void modify(const int& i, const int& j){\n        sx = min(i, sx);\n        sy = min(j, sy);\n        \n        ex = max(i, ex);\n        ey = max(j, ey);\n    }\n};\n\nbool is_real_over(char T, map<char, set<char>>& overs, set<char> pre){\n    for (auto && top : overs[T]) {\n        if(pre.count(top) > 0) {\n//            cerr << \"CROSS ERROrR\\n\";\n            return false;\n        }\n        pre.insert(top);\n        return is_real_over(top, overs, pre);\n    }\n    return true;\n\n}\n\n\nbool solve(){\n    int h, w;\n    cin >> h >> w;\n    vector<vector<char>> v;\n    map<char, rect> shapes;\n    for (int i = 0; i < h; ++i) {\n        v.push_back({});\n        for (int j = 0; j < w; ++j) {\n            char tmp;\n            cin >> tmp;\n            v[i].push_back(tmp);\n\n            if(tmp != '.')\n                shapes[tmp].modify(i, j);\n        }\n    }\n\n\n    // 矩形調査 yz\n    map<char, set<char>> overs;\n    for(auto && rec_pair: shapes){\n        auto && rec = rec_pair.second;\n        auto && rec_name = rec_pair.first;\n//        cerr << \"NAME:\" << rec_name << '\\n';\n        for (int i = rec.sx; i <= rec.ex; ++i) {\n            for (int j = rec.sy; j <= rec.ey; ++j) {\n                auto&& this_char = v[i][j];\n                if(this_char != rec_name){\n                    if(this_char == '.'){\n//                        cerr << \"SHAPE MISS\\n\";\n                        return false;\n                    }\n                    overs[rec_name].insert(this_char);\n                }\n            }\n        }\n    }\n//    cerr << \"OVERS::\\n\";\n//    for(auto && m : overs){\n//        cerr << m.first << ':';\n//        for(auto && t : m.second){\n//            cerr << ' ' << t;\n//        }\n//        cerr << '\\n';\n//    }\n\n    // 重なり調査\n    for(auto&& op: overs){\n        if(!is_real_over(op.first, overs, {op.first}))\n            return false;\n    }\n\n\n    return true;\n    \n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        cout << (!solve() ? \"SUSPICIOUS\" : \"SAFE\") << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nstruct make\n{\n\tchar str;\n\tint posi,start[2];\n\tint high,wide,JUDGE;//JUDGE==1で長方形,==0で長方形以外,==2で未定\n\tstruct make *front[8];\n};\n\n\nint main()\n{\n\tint N,H,W,count,COUNT,judge,no_rect,NO_RECT;\n\tchar img[1000][51];\n\tstruct make M[8];\n\tint s1,s2,num;\n\t\n\tscanf(\"%d\",&N);//データの個数\n\tfor(int a=0;a<N;a++)\n\t{\n\t\tcount=0;//材質の個数\n\t\tCOUNT=0;\n\t\tNO_RECT=0;\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tscanf(\"%s\",img[b]);\n\t\t\timg[b][W]='\\0';\n\t\t}\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tfor(int d=0;d<count;d++) M[d].posi=-1;\n\t\t\tfor(int c=0;c<W;c++)\n\t\t\t{\n\t\t\t\tif(img[b][c]!='.')\n\t\t\t\t{\n\t\t\t\t\t//材質判定\n\t\t\t\t\tjudge=0;\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t\tif(count>0 && img[b][c]!=M[judge].str) judge++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}while(judge<count);\n\t\t\t\t\t//新しい材質の場合\n\t\t\t\t\tif(judge==count)\n\t\t\t\t\t{\n\t\t\t\t\t\tM[count].str=img[b][c];\n\t\t\t\t\t\tM[count].start[0]=b;\n\t\t\t\t\t\tM[count].start[1]=c;\n\t\t\t\t\t\tM[count].posi=c;\n\t\t\t\t\t\tM[count].high=1;\n\t\t\t\t\t\tM[count].wide=1;\n\t\t\t\t\t\tM[count].JUDGE=0;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\t//既出の材質の場合\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(M[judge].start[1]>c) M[judge].start[1]=c;\n\t\t\t\t\t\tif(M[judge].posi<0) M[judge].posi=c;\n\t\t\t\t\t\telse if(M[judge].wide<c-M[judge].posi+1) M[judge].wide=c-M[judge].posi+1;\n\t\t\t\t\t\tM[judge].high=b-M[judge].start[0]+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tno_rect=count;\n\t\t//printf(\"count=%d\\n\",count);\n\t\t//判定開始\n\t\twhile(count)//文字アリ\n\t\t{\n\t\t\tCOUNT=0;\n\t\t\t//見えている部分が長方形かどうか判定\n\t\t\tfor(num=0;num<count;num++)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(M[num].JUDGE==1) continue;\n\t\t\t\tM[num].JUDGE=0;//長方形なら\n\t\t\t\t//printf(\"M[%d].str=%c\\nM[%d].high=%d\\nM[%d].wide=%d\\n\",num,M[num].str,num,M[num].high,num,M[num].wide);\n\t\t\t\t//printf(\"M[%d].start[0]=%d\\nM[%d].start[1]=%d\\n\",num,M[num].start[0],num,M[num].start[1]);\n\t\t\t\tfor(s1=0;s1<M[num].high;s1++)\n\t\t\t\t{\n\t\t\t\t\tfor(s2=0;s2<M[num].wide;s2++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//確実に長方形ではない場合\n\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]=='.')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNO_RECT=1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//長方形の可能性もある場合\n\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]!=M[num].str && img[s1+M[num].start[0]][s2+M[num].start[1]]!='#' )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tM[num].JUDGE=2;\n\t\t\t\t\t\t\tCOUNT++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(NO_RECT || M[num].JUDGE==2) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(NO_RECT || M[num].JUDGE==2) break;\n\t\t\t\t}\n\t\t\t\tif(NO_RECT) break;\n\t\t\t\t//長方形だった場合\n\t\t\t\tif(s1==M[num].high && s2==M[num].wide)\n\t\t\t\t{\n\t\t\t\t\tM[num].JUDGE=1;\n\t\t\t\t\tno_rect--;\n\t\t\t\t\tfor(int s1=0;s1<M[num].high;s1++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int s2=0;s2<M[num].wide;s2++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\timg[s1+M[num].start[0]][s2+M[num].start[1]]='#';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//printf(\"M[%d].JUDGE=%d\\n\\n\",num,M[num].JUDGE);\n\t\t\t}\n\t\t\tif(NO_RECT==1) break;\n\t\t\t//どれも長方形ではなかった場合\n\t\t\tif(no_rect==COUNT && no_rect>1) break;\n\t\t\t//printf(\"#no_rect=%d\\n\\n\\n\",no_rect);\n\t\t\t//すべて長方形\n\t\t\tif(no_rect==0) break;\n\t\t}\n\t\t//出力\n\t\tif(NO_RECT) printf(\"SUSPICIOUS\\n\");\n\t\telse if(no_rect) printf(\"SUSPICIOUS\\n\");\n\t\telse printf(\"SAFE\\n\");\n\t}\n\t\n\treturn 0;\n}\n//printf(\"#1\");\n//printf(\"M[%d].str=%c\\nM[%d].high=%d\\nM[%d].wide=%d\\n\",num,M[num].str,num,M[num].high,num,M[num].wide);\n//printf(\"M[%d].start[0]=%d\\nM[%d].start[1]=%d\\n\\n\",num,M[num].start[0],num,M[num].start[1]);\n//printf(\"M[%d].JUDGE=%d\\n\\n\",num,M[num].JUDGE);\n//printf(\"s1=%d s2=%d\\n\",s1,s2);\n//printf(\"#no_rect=%d\\n\\n\\n\",no_rect);\n//printf(\"#s1=%d\\n#s2=%d\\n\",s1,s2);\n/*\n1\n10 10\n..........\n.DDDDDD...\n.DDDDCCC..\n.DDDDCCC..\nADDDDCCC..\nAAA..CCC..\nAAABBBBC..\nAAABBBB...\n..BBBBB...\n..........\n*/\n/*\n1\n10 10\n..........\n.DDDDCCC..\n.DDDDCCC..\n.DDDDCCC..\nADDDDCCC..\nAAA..CCC..\nAAABBBBC..\nAAABBBB...\n..BBBBB...\n..........\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<cstring>\nusing namespace std;\n\nchar **data;\nchar done[20];\nint donen;\nint h,w;\n\nint r(char);\nint inc(char);\nvoid sear(char,int*,int*,int*,int*);\n\nint main(){\n\tint n;\n\tint i,j;\n\tchar s[100];\n\tchar *ps;\n\tint size;\n\tint error;\n\tfgets(s,sizeof(s),stdin);\n\tsize=atoi(s);\n\tfor(n=0;n<size;n++){\n\t\tfgets(s,sizeof(s),stdin);\n\t\tps=strtok(s,\" \");\n\t\th=atoi(ps);\n\t\tps=strtok(NULL,\" \");\n\t\tw=atoi(ps);\n\n\t\tdata=new char*[h];\n\t\tfor(i=0;i<h;i++){\n\t\t\tdata[i]=new char[w];\n\t\t\tfgets(s,sizeof(s),stdin);\n\t\t\tmemcpy(data[i],s,w);\n\t\t}\n\t\t//memset(done,0,sizeof(done));\n\t\tdonen=0;\n\t\terror=0;\n\t\tfor(i=0;i<h;i++){\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tif(data[i][j]!='.' && data[i][j]!=' '){\n\t\t\t\t\tif(r(data[i][j])==1){\n\t\t\t\t\t\terror=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(error==1) break;\n\t\t}\n\t\tif(error==0) cout<<\"SAFE\"<<endl;\n\t\telse cout<<\"SUSPICIOUS\"<<endl;\n\t\tfor(i=0;i<h;i++) delete [] data[i];\n\t\tdelete [] data;\n\t}\n\treturn 0;\n}\n\nint r(char c){\n\tint i,j;\n\tint x1,x2,y1,y2;\n\tsear(c,&x1,&y1,&x2,&y2);\n\tfor(i=y1;i<=y2;i++){\n\t\tfor(j=x1;j<=x2;j++){\n\t\t\tif(data[i][j]=='.') return 1;\n\t\t\telse if(inc(data[i][j])==1) return 1;\n\t\t}\n\t}\n\tdone[donen++]=c;\n\tfor(i=y1;i<=y2;i++){\n\t\tfor(j=x1;j<=x2;j++){\n\t\t\tif(data[i][j]!=c &&data[i][j]!=' '){\n\t\t\t\tif(r(data[i][j])==1) return 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=y1;i<=y2;i++){\n\t\tfor(j=x1;j<=x2;j++){\n\t\t\tif(data[i][j]==c) data[i][j]=' ';\n\t\t}\n\t}\n\treturn 0;\n}\n\nint inc(char c){\n\tfor(int i=0;i<donen;i++) if(done[i]==c) return 1;\n\treturn 0;\n}\n\nvoid sear(char c,int *x1,int *y1,int *x2,int *y2){\n\tint i,j;\n\t*x1=*x2=*y1=*y2=-1;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(data[i][j]==c){\n\t\t\t\t*y1=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(*y1!=-1) break;\n\t}\n\tfor(i=h-1;i>=0;i--){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(data[i][j]==c){\n\t\t\t\t*y2=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(*y2!=-1) break;\n\t}\n\tfor(i=0;i<w;i++){\n\t\tfor(j=0;j<h;j++){\n\t\t\tif(data[j][i]==c){\n\t\t\t\t*x1=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(*x1!=-1) break;\n\t}\n\tfor(i=w-1;i>=0;i--){\n\t\tfor(j=0;j<h;j++){\n\t\t\tif(data[j][i]==c){\n\t\t\t\t*x2=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(*x2!=-1) break;\n\t}\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define rep(i,N) for(ll i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nint n;\nint h, w;\nstring table[50];\n\nint main() {\n\tcin >> n;\n\trep(kk, n) {\n\t\tcin >> h >> w;\n\t\tvector<char> vi;\n\t\trep(i, h) {\n\t\t\tcin >> table[i];\n\t\t\trep(j, w) {\n\t\t\t\tif (table[i][j] != '.')vi.push_back(table[i][j]);\n\t\t\t}\n\t\t}\n\t\tsort(ALL(vi));\n\t\tvi.erase(unique(ALL(vi)), vi.end());\n\t\tbool f = 0;\n\t\tdo {\n\t\t\tmap<char, int> mci;\n\t\t\tmci['.'] = 0;\n\t\t\trep(i, vi.size()) {\n\t\t\t\tmci[vi[i]] = i + 1;\n\t\t\t}\n\t\t\tbool ng = 0;\n\t\t\trep(i, vi.size()) {\n\t\t\t\tll l = w - 1, r = 0, d = h - 1, u = 0;\n\t\t\t\trep(j, h) {\n\t\t\t\t\trep(k, w) {\n\t\t\t\t\t\tif (table[j][k] == vi[i]) {\n\t\t\t\t\t\t\t//cout << j << \" \" << k << endl;\n\t\t\t\t\t\t\tl = min(l, k);\n\t\t\t\t\t\t\tr = max(r, k);\n\t\t\t\t\t\t\td = min(d, j);\n\t\t\t\t\t\t\tu = max(u, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//cout << d << \" \" << u << \" \" << l << \" \" << r << endl;\n\t\t\t\tfor (int j = d; j <= u; j++) {\n\t\t\t\t\tfor (int k = l; k <= r; k++) {\n\t\t\t\t\t\tif (table[j][k] != vi[i]) {\n\t\t\t\t\t\t\tif (mci[table[j][k]] < mci[vi[i]])ng = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ng)break;\n\t\t\t\t\t}\n\t\t\t\t\tif (ng)break;\n\t\t\t\t}\n\t\t\t\tif (ng)break;\n\t\t\t}\n\t\t\tif (!ng)f = 1;\n\t\t} while (next_permutation(ALL(vi)));\n\t\tif (f)cout << \"SAFE\" << endl;\n\t\telse cout << \"SUSPICIOUS\" << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint h,w;\nstring s[55];\nmap<char,bool> able;\n\nbool check(char c){\n\tint mini=INF,minj=INF,maxi=-1,maxj=-1;\n\trep(i,h)rep(j,w){\n\t\tif(s[i][j]==c){\n\t\t\tminch(mini,i);\n\t\t\tminch(minj,j);\n\t\t\tmaxch(maxi,i);\n\t\t\tmaxch(maxj,j);\n\t\t}\n\t}\n\trepl(i,mini,maxi+1)repl(j,minj,maxj+1){\n\t\tif(s[i][j]=='.'||!able[s[i][j]])return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tint cases;\n\tcin>>cases;\n\twhile(cases--){\n\t\tcin>>h>>w;\n\t\trep(i,h)cin>>s[i];\n\t\tvector<char> cs;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(s[i][j]!='.'&&(cs.size()==0||!exist(cs,s[i][j])))cs.pb(s[i][j]);\n\t\t}\n\t\tif(cs.size()==0){\n\t\t\tcout<<\"SAFE\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tsort(all(cs));\n\t\tbool ok;\n\t\tdo{\n\t\t\tok=true;\n\t\t\trep(i,cs.size())able[cs[i]]=false;\n\t\t\table[cs[0]]=true;\n\t\t\trep(i,cs.size()){\n\t\t\t\tif(!check(cs[i])){\n\t\t\t\t\tok=false;break;\n\t\t\t\t}\n\t\t\t\tif(i<cs.size()-1)able[cs[i+1]]=true;\n\t\t\t}\n\t\t\tif(ok)break;\n\t\t}while(next_permutation(all(cs)));\n\t\tif(ok)cout<<\"SAFE\"<<endl;\n\t\telse cout<<\"SUSPICIOUS\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass Belongings {\npublic:\n  Belongings() : left(100),right(0),upper(100),lower(0){}\n  int left,right,upper,lower;\n};\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    for(int stage_idx = 0; stage_idx < N; stage_idx++){\n      int H,W;\n      \n      scanf(\"%d %d\",&H,&W);\n      char stage[2500];\n      char hypothesis[2500];\n      memset(stage,'.',sizeof(stage));\n\n      map<char,Belongings> layer;\n    \n      for(int y=0;y<H;y++){\n\tchar line[51];\n\tscanf(\"%s\",line);\n\tfor(int x=0;x<W;x++){\n\t  stage[y*W+x] = line[x];\n\t  //x:0->...\n\t  //y:0\n\t  //  |\n\t  //  v\n\t  //  .\n\t  //  upper\n\t  //left right\n\t  //  lower\n\t  Belongings& it = layer[stage[y*W+x]];\n\t  it.left = min(it.left,x);\n\t  it.right = max(it.right,x);\n\t  it.upper = min(it.upper,y);\n\t  it.lower = max(it.lower,y);\n\t}\n      }\n\n      bool is_safe = false;\n\n      vector<char> order;\n      for(map<char,Belongings>::iterator it = layer.begin();\n\t  it != layer.end();\n\t  it++){\n\torder.push_back(it->first);\n      }\n      sort(order.begin(),order.end());\n\n\n      do{\n\tmemset(hypothesis,'.',sizeof(hypothesis));\n\n\tfor(int i=0;i<order.size();i++){\n\t  char c = order[i];\n\t  Belongings& it = layer[c];\n\t  for(int y=it.upper; y<=it.lower; y++){\n\t    for(int x=it.left; x<=it.right; x++){\n\t      hypothesis[y*W+x] = c;\n\t    }\n\t  }\n\t}\n\n\tif(strcmp(hypothesis,stage) == 0){\n\t  is_safe = true;\n\t  break;\n\t}\n      }while(next_permutation(order.begin(),order.end()));\n      printf(\"%s\\n\",is_safe ? \"SAFE\" : \"SUSPICIOUS\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stdio.h>\n\nusing namespace std;\n\nvoid solve(){\n\n\tstring strs[] = { \"SAFE\", \"SUSPICIOUS\" };\n\n\tint h, w;\n\tcin >> h >> w;\n\n\tvector< string > screen( h );\n\tvector< bool > flg( 26, false );\n\n\tfor( int i = 0; i < h; i++ )\n\t\tcin >> screen[ i ];\n\t\n\tbool fig = true;\n\n\twhile( fig ) {\n\n\t\tfig = false;\n\n\t\tfor( int x = 0; x < w; x++ ) {\n\t\t\tfor( int y = 0; y < h; y++ ) {\n\t\t\t\tchar ch = screen[ y ][ x ];\n\n\t\t\t\tif( ch == '.' || ch == '*' ) continue;\n\t\t\t\tif( flg[ ch - 'A' ] ) continue;\n\n\t\t\t\tint stx = w, sty = h, edx = -1, edy = -1;\n\t\t\t\tfor( int tx = 0; tx < w; tx ++ ) {\n\t\t\t\t\tfor( int ty = 0; ty < h; ty ++ ) {\n\t\t\t\t\t\tif( screen[ty][tx] == ch ) {\n\t\t\t\t\t\t\tstx = min( stx, tx );\n\t\t\t\t\t\t\tsty = min( sty, ty );\n\t\t\t\t\t\t\tedx = max( edx, tx );\n\t\t\t\t\t\t\tedy = max( edy, ty );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbool fillflg = true;\n\t\t\t\tfor( int tx = stx; tx <= edx && fillflg; tx ++ ) {\n\t\t\t\t\tfor( int ty = sty; ty <= edy && fillflg; ty ++ ) {\n\t\t\t\t\t\tfillflg &= ( screen[ ty ][ tx ] == ch || screen[ ty ][ tx ] == '*' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfig |= fillflg;\n\t\t\t\tif( fillflg ) {\n\t\t\t\t\tflg[ ch - 'A' ] = true;\n\t\t\t\t\tfor( int tx = stx; tx <= edx; tx ++ ) {\n\t\t\t\t\t\tfor( int ty = sty; ty <= edy; ty ++ ) {\n\t\t\t\t\t\t\tscreen[ ty ][ tx ] = '*';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool b = false;\n\tfor( int x = 0; x < w; x++ ) {\n\t\tfor( int y = 0; y < h; y++ ) {\n\t\t\tb |= ( screen[ y ][ x ] != '.' && screen[ y ][ x ] != '*' );\n\t\t}\n\t}\n\tcout << strs[ b ] << endl;\n}\n\nint main( void ) {\n\n\tint n;\n\tcin >> n;\n\n\tfor( int i = 0; i < n; i++ )\n\t\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long double EPS = 1e-8;\n\nlong long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> H >> W;\n\t\tvector<string>s(H);\n\t\tfor (int j = 0; j < H; j++) {\n\t\t\tcin >> s[j];\n\t\t}\n\t\tvector<int>l(26, MOD);\n\t\tvector<int>r(26, -1);\n\t\tvector<int>u(26, MOD);\n\t\tvector<int>d(26, -1);\n\t\tfor (int j = 0; j < H; j++) {\n\t\t\tfor (int k = 0; k < W; k++) {\n\t\t\t\tif (s[j][k] == '.')continue;\n\t\t\t\tint index = s[j][k] - 'A';\n\t\t\t\tl[index] = min(l[index], k);\n\t\t\t\tr[index] = max(r[index], k);\n\t\t\t\tu[index] = min(u[index], j);\n\t\t\t\td[index] = max(d[index], j);\n\t\t\t}\n\t\t}\n\t\tvector<vector<int>>edge(26, vector<int>(26));\n\t\tbool flag = false;\n\t\tfor (int j = 0; j < 26; j++) {\n\t\t\tif (l[j] == MOD)continue;\n\t\t\tfor (int k = l[j]; k <= r[j]; k++) {\n\t\t\t\tfor (int m = u[j]; m <= d[j]; m++) {\n\t\t\t\t\tif (s[m][k] == '.') {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint index = s[m][k] - 'A';\n\t\t\t\t\t\tif (index != j) {\n\t\t\t\t\t\t\tedge[j][index] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < 26; j++) {\n\t\t\tvector<bool>used(26, false);\n\t\t\tused[j] = true;\n\t\t\tqueue<int>Q;\n\t\t\tQ.push(j);\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tint cn = Q.front();\n\t\t\t\tQ.pop();\n\t\t\t\tfor (int k = 0; k < 26; k++) {\n\t\t\t\t\tif (edge[cn][k]) {\n\t\t\t\t\t\tif (k == j) {\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!used[k]) {\n\t\t\t\t\t\t\tQ.push(k);\n\t\t\t\t\t\t\tused[k] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag)cout << \"SUSPICIOUS\\n\";\n\t\telse cout << \"SAFE\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 52;\n\nchar c[MAX_N][MAX_N];\nint up[31],lf[31],rg[31],dw[31];\nbool flag[31];\nint n,H,W;\nbool end_flag;\n\nvector<int> G[31];\nint color[31];\ndeque<int> L;\nbool cycle;\t//????????????\n\nvoid visit(int u)\n{\n\tif(color[u] == 0){\n\t\tcycle = true;\t//DAG??§??????\n\t\treturn;\n\t}\n\tif(color[u] == 1){\n\t\treturn;\n\t}\n\tcolor[u] = 0;\n\tfor(int i=0;i<G[u].size();i++){\n\t\tvisit(G[u][i]);\n\t}\n\tcolor[u] = 1;\n\tL.push_front(u);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n    for(int loop=0;loop<n;loop++){\n        scanf(\"%d%d\",&H,&W);\n        end_flag = false;\n        fill(up,up+30,INF);\n        fill(lf,lf+30,INF);\n        fill(rg,rg+30,-1);\n        fill(dw,dw+30,-1);\n        fill(flag,flag+30,false);\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                cin >> c[i][j];\n                if(c[i][j] != '.'){\n                    int id = (int)(c[i][j] - 'A');\n                    if(up[id] > i){\n                        up[id] = i;\n                    }\n                    if(lf[id] > j){\n                        lf[id] = j;\n                    }\n                    if(rg[id] < j){\n                        rg[id] = j;\n                    }\n                    if(dw[id] < i){\n                        dw[id] = i;\n                    }\n                    if(!flag[id]){\n                        flag[id] = true;\n                    }\n                }\n            }\n        }\n        for(int i=0;i<30;i++){\n            if(flag[i]){\n                for(int j = up[i];j <= dw[i];j++){\n                    for(int k = lf[i];k <= rg[i];k++){\n                        if(c[j][k] == '.'){\n                            cout << \"SUSPICIOUS\\n\";\n                            end_flag = true;\n                            break;\n                        }\n                        if((char)('A' + i) != c[j][k]){\n                            G[i].push_back((int)(c[j][k] - 'A'));\n                        }\n                    }\n                    if(end_flag){\n                        break;\n                    }\n                }\n            }\n            if(end_flag){\n                break;\n            }\n        }\n        if(end_flag){\n            continue;\n        }\n        rep(i,30){\n            sort(G[i].begin(),G[i].end());\n            G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n        }\n        rep(i,30){\n    \t\tcolor[i] = -1;\n    \t}\n    \trep(i,30){\n    \t\tif(color[i] == -1){\n    \t\t\tcycle = false;\n    \t\t\tvisit(i);\n    \t\t}\n    \t\tif(cycle){\n    \t\t\tbreak;\n    \t\t}\n    \t}\n        if(cycle){\n            cout << \"SUSPICIOUS\\n\";\n        }else{\n            cout << \"SAFE\\n\";\n        }\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid chmin(int &a, int b) { a = min(a, b); }\nvoid chmax(int &a, int b) { a = max(a, b); }\n\nint n;\nint h, w;\nstring s[50];\n\nvoid solve() {\n\tint minX[26];\n\tint minY[26];\n\tint maxX[26];\n\tint maxY[26];\n\tstatic int rui[26][51][51];\n\tint i, j, k;\n\t\n\tfor (i = 0; i < 26; i++) {\n\t\tminX[i] = 114;\n\t\tminY[i] = 114;\n\t\tmaxX[i] = -114;\n\t\tmaxY[i] = -114;\n\t}\n\t\n\tfor (i = 0; i < 26; i++) {\n\t\tfor (j = 0; j <= h; j++) {\n\t\t\tfor (k = 0; k <= w; k++) {\n\t\t\t\trui[i][j][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tif ('A' <= s[i][j] && s[i][j] <= 'Z') {\n\t\t\t\tchmin(minX[s[i][j] - 'A'], j);\n\t\t\t\tchmax(maxX[s[i][j] - 'A'], j);\n\t\t\t\tchmin(minY[s[i][j] - 'A'], i);\n\t\t\t\tchmax(maxY[s[i][j] - 'A'], i);\n\t\t\t\trui[s[i][j] - 'A'][i + 1][j + 1]++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < 26; i++) {\n\t\tfor (j = 0; j <= h; j++) {\n\t\t\tfor (k = 1; k <= w; k++) rui[i][j][k] += rui[i][j][k - 1];\n\t\t}\n\t\tfor (j = 0; j <= w; j++) {\n\t\t\tfor (k = 1; k <= h; k++) rui[i][k][j] += rui[i][k - 1][j];\n\t\t}\n\t}\n\t\n\tstring chars;\n\tbool used[26] = {false};\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tif (s[i][j] == '.') continue;\n\t\t\tif (!used[s[i][j] - 'A']) {\n\t\t\t\tchars += s[i][j];\n\t\t\t\tused[s[i][j] - 'A'] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int> perm;\n\tfor (i = 0; i < chars.length(); i++) { perm.push_back(i); }\n\tdo {\n\t\tint z[26] = {0};\t//??????????????????\n\t\tint j;\n\t\tfor (i = 0; i < chars.length(); i++) {\n\t\t\tz[chars[i] - 'A'] = perm[i] + 1;\n\t\t}\n\t\t\n\t\tfor (i = 0; i < chars.length(); i++) {\n\t\t\tint id = chars[i] - 'A';\n\t\t\tint area = (maxY[id] - minY[id] + 1) * (maxX[id] - minX[id] + 1);\n\t\t\tfor (j = 0; j < 26; j++) {\n\t\t\t\tif (z[j] < z[chars[i] - 'A']) continue;\n\t\t\t\tint a = rui[j][maxY[j] + 1][maxX[j] + 1];\n\t\t\t\tint b = rui[j][maxY[j] + 1][minX[j]];\n\t\t\t\tint c = rui[j][minY[j]][maxX[j] + 1];\n\t\t\t\tint d = rui[j][minY[j]][minX[j]];\n\t\t\t\tarea -= a - b - c + d;\n\t\t\t}\n\t\t\tif (area > 0) { break; }\n\t\t}\n\t\t\n\t\tif (i == chars.length()) {\n\t\t\tcout << \"SAFE\" << endl;\n\t\t\treturn;\n\t\t}\n\t} while (next_permutation(perm.begin(), perm.end()));\n\t\n\tcout << \"SUSPICIOUS\" << endl;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> h >> w;\n\t\tfor (int j = 0; j < h; j++) cin >> s[j];\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n\n#define ll long long int\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\n\nconst string ascii = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\nstruct Rect{\n    int t, b, l, r;\n};\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int T; cin >> T;\n    while(T--){\n        int H, W; cin >> H >> W;\n        vector<string> field(H);\n        for(auto &s: field)\n            cin >> s;\n        \n        vector<Rect> rects(ascii.size());\n        for(auto &r: rects){\n            r.t = -1; r.r = -1;\n            r.b = H; r.l = W;\n        }\n        \n        for(int h=0; h<H; h++){\n            for(int w=0; w<W; w++) if(field[h][w] != '.'){\n                int i = field[h][w] - 'A';\n                Rect &r = rects[i];\n                r.t = max(r.t, h);\n                r.b = min(r.b, h);\n                r.r = max(r.r, w);\n                r.l = min(r.l, w);\n            }\n        }\n        \n        for(int t=0; t<ascii.size(); t++){\n            for(char c: ascii){\n                Rect r = rects[c-'A'];\n                if(r.t == -1)\n                    continue;\n                \n                bool flag = true;\n                for(int h=r.b; h<=r.t; h++){\n                    for(int w=r.l; w<=r.r; w++){\n                        flag &= field[h][w]==c || field[h][w]=='@';\n                    }\n                }\n                if(flag)\n                    for(int h=r.b; h<=r.t; h++)\n                        for(int w=r.l; w<=r.r; w++)\n                            field[h][w] = '@';\n            }\n        }\n        bool safe = true;\n        for(auto r: field)\n            for(auto c: r)\n                safe &= c=='.' || c=='@';\n        \n        cout << (safe ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n    \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\nint h,w;\nstring G[51];\nbool checked[51][51];\nbool visited[51][51];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nvoid dfs(int x,int y,char c,int &x1,int &x2,int &y1,int &y2)\n{\n  if(visited[y][x])return;\n  visited[y][x] = true;\n  if(x < x1)x1 = x;\n  if(x > x2)x2 = x;\n  if(y < y1)y1 = y;\n  if(y > y2)y2 = y;\n  rep(i,4)\n    {\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(G[ny][nx] != c)continue;\n      dfs(nx,ny,c,x1,x2,y1,y2);\n    }\n}\n\nbool isRect(int x,int y)\n{\n  int x1,x2,y1,y2;\n  x1 = x2 = x;\n  y1 = y2 = y;\n  rep(i,h)rep(j,w)visited[i][j] = false;\n  dfs(x,y,G[y][x],x1,x2,y1,y2);\n\n  REP(i,y1,y2+1)\n    REP(j,x1,x2+1)\n    if(G[i][j] != G[y][x] && !checked[i][j])return false;\n  return true;\n\n}\n\nvoid draw(int x,int y,char c)\n{\n  if(checked[y][x])return;\n  checked[y][x] = true;\n  rep(i,4)\n    {\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(G[ny][nx] != c)continue;\n      draw(nx,ny,c);\n    }\n}\n\nbool isSafe()\n{\n  rep(i,h)\n    rep(j,w)\n    if(G[i][j] != '.' && !checked[i][j])return false;\n  return true;\n}\n\nint main()\n{\n  int T;\n  cin >> T;\n  while(T-- > 0)\n    {\n      cin >> h >> w;\n      rep(i,h)\n\tcin >> G[i];\n      rep(i,51)rep(j,51)checked[i][j] = false;\n\n      while(true)\n\t{\n\t  bool Fin = true;\n\t  bool update = false;\n       \n\t  rep(i,h)\n\t    {\t\n\t      rep(j,w)\n\t\t{\n\t\t  if(G[i][j] == '.')continue;\n\t\t  if(checked[i][j])continue;\n\t\t  Fin = false;\n\t\t  if(isRect(j,i))\n\t\t    {\n\t\t      update = true;\n\t\t      draw(j,i,G[i][j]);\n\t\t    }\n\t\t}\n\t    }\n\t  if(Fin || !update)break;\n\t}\n   \n      isSafe()?cout << \"SAFE\" << endl:cout << \"SUSPICIOUS\" << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define all(v) ALL(v)\n#define Dedupe(v) (v).erase(unique(ALL((v))),(v).end())\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n#define CININIT cin.tie(0),ios::sync_with_stdio(false)\nstruct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\nint h,w;\nchar tbl[64][64];\n\nvoid solve(){\n    rep(i,64) rep(j,64) tbl[i][j]=0;\n\n    cin>>h>>w;\n    rep(i,h) rep(j,w) cin>>tbl[i][j];\n\n    vector<vector<int>> g(32);\n\n    for(char c='A';c<='Z';c++){\n        int u=INF,d=-INF,l=INF,r=-INF;\n        rep(i,h) rep(j,w){\n            if(tbl[i][j]==c){\n                u=min(u,i);\n                d=max(d,i);\n                l=min(l,j);\n                r=max(r,j);\n            }\n        }\n        for(int i=u;i<=d;i++) for(int j=l;j<=r;j++) if(tbl[i][j]=='.'){\n            cout << \"SUSPICIOUS\" << endl;\n            return;\n        }\n        for(int i=u;i<=d;i++) for(int j=l;j<=r;j++){\n            if(i<0 or j<0) continue;\n            if('A'<=tbl[i][j] and tbl[i][j]<='Z' and tbl[i][j]!=c){\n                g[c-'A'].push_back(tbl[i][j]-'A');\n            }\n        }\n    }\n    for(int i=0;i<32;i++){\n        sort(all(g[i]));\n        Dedupe(g[i]);\n    }\n\n    /*\n    for(int i=0;i<32;i++){\n        if(g[i].size()==0) continue;\n        cout << (char)(i+'A') << \" : [\";\n        for(int j=0;j<g[i].size();j++) cout << (char)(g[i][j]+'A') << \",\";\n        cout << \"]\" << endl;\n    }\n    */\n\n    bool used[32];\n    for(char c='A';c<='Z';c++){\n//        cout << c << endl;\n        rep(i,32) used[i]=false;\n        int t=c-'A';\n        if(g[t].size()==0) continue;\n\n        queue<int> que;\n        que.push(t);\n        while(!que.empty()){\n            int p=que.front();\n            que.pop();\n//            cout << \"\\t\" << (char)(p+'A') << endl;\n\n            used[p] = true;\n\n            for(int i=0;i<g[p].size();i++){\n                int ne = g[p][i];\n                if(used[ne]){\n                    cout << \"SUSPICIOUS\" << endl;\n                    return;\n                }\n                que.push(ne);\n            }\n        }\n    }\n    cout << \"SAFE\" << endl;\n}\n\n\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nstring str[60];\nint h,w;\nint num;\nbool flag;\nbool used[55][55];\nchar moji[10];\nint vx[4]={1,0,-1,0};\nint vy[4]={0,1,0,-1};\nvoid dfs(int Bit,int depth){\n  if(Bit==((1<<num)-1)){\n    flag=true;\n    return;\n  }\n  for(int i=0;i<num;i++){\n    if(!(Bit&(1<<i))){\n      bool used2[55][55]={};\n      int lemi=100,lema=0,rimi=100,rima=0;\n      for(int j=0;j<h;j++){\n\tfor(int k=0;k<w;k++){\n\t  if(str[j][k]==moji[i]){\n\t    used2[j][k]=true;\n\t    used[j][k]=true;\n\t    lemi=min(lemi,k);\n\t    lema=max(lema,k);\n\t    rima=max(rima,j);\n\t    rimi=min(rimi,j);\n\t  }\n\t}\n      }\n      bool fll=true;\n      for(int j=rimi;j<=rima;j++){\n\tfor(int k=lemi;k<=lema;k++){\n\t  if(!used[j][k]){\n\t    fll=false;\n\t  }\n\t}\n      }\n      if(fll)\n\tdfs(Bit+(1<<i),depth+1);\n      for(int j=rimi;j<=rima;j++){\n\tfor(int k=lemi;k<=lema;k++){\n\t  if(used2[j][k]){\n\t    used[j][k]=false;\n\t  }\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int n;cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>h>>w;\n    num=0;\n    for(int i=0;i<55;i++)\n      for(int j=0;j<55;j++)\n\tused[i][j]=false;\n    flag=false;\n    bool alfa[26]={};\n    for(int i=0;i<h;i++){\n      cin>>str[i];\n      for(int j=0;j<w;j++){\n\talfa[str[i][j]-'A']=true;\n      }\n    }\n    int cnt=0;\n    for(int i=0;i<26;i++){\n      num+=alfa[i];\n      if(alfa[i]){\n\tmoji[cnt]=(char)(i+'A');\n\tcnt++;\n      }\n    }\n    dfs(0,0);\n    if(flag)\n      cout<<\"SAFE\"<<endl;\n    else \n      cout<<\"SUSPICIOUS\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\ntypedef long long ll;\n \nint h,w;\nchar mp[52][52];\nbool hid[52][52];\n \nvoid solve(){\n  scanf(\"%d%d\",&h,&w);\n  REP(i,h)scanf(\"%s\",mp[i]);\n  set<char> S;\n  REP(i,h)REP(j,w)if(mp[i][j]!='.')S.insert(mp[i][j]);\n  int n = S.size();\n  if(n==0){\n    puts(\"SAFE\");\n    return;\n  }\n  vector<int> p(n);\n  REP(i,n)p[i] = i;\n  vector<char> cc;\n  for(char c : S){\n    cc.push_back(c);\n  }\n  do{\n    REP(i,h)REP(j,w)hid[i][j] = false;\n    bool ok = true;\n    REP(x,n){\n      char c = cc[p[x]];\n      int umost = h, dmost = 0, lmost = w, rmost = 0;\n      REP(i,h)REP(j,w)if(mp[i][j]==c){\n        umost = min(umost, i);\n        dmost = max(dmost, i);\n        lmost = min(lmost, j);\n        rmost = max(rmost, j);\n      }\n      // printf(\"%d %d %d %d\\n\",umost,dmost,lmost,rmost);\n      for(int i=umost; i<=dmost; i++){\n        for(int j=lmost; j<=rmost; j++){\n          if(mp[i][j] == c){\n            hid[i][j] = true;\n          }\n          if(!hid[i][j]){\n            ok = false;\n          }\n        }\n      }\n      if(!ok)break;\n    }\n    if(ok){\n      puts(\"SAFE\");\n      return;\n    }\n    // break;\n  }while(next_permutation(p.begin(), p.end()));\n  puts(\"SUSPICIOUS\");\n  return;\n}\n \nint main(){\n  int t;\n  scanf(\"%d\",&t);\n  while(t--)solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass Belongings {\npublic:\n  Belongings() : left(100),right(0),upper(100),lower(0){}\n  int left,right,upper,lower;\n};\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    for(int stage_idx = 0; stage_idx < N; stage_idx++){\n      int H,W;\n      char stage[50*50];\n      memset(stage,'.',sizeof(stage));\n      \n      scanf(\"%d %d\",&H,&W);\n      map<char,Belongings> layer;\n    \n      for(int y=0;y<H;y++){\n\tchar line[51];\n\tscanf(\"%s\",line);\n\tfor(int x=0;x<W;x++){\n\t  stage[y*W+x] = line[x];\n\t  //x:0->...\n\t  //y:0\n\t  //  |\n\t  //  v\n\t  //  .\n\t  //  upper\n\t  //left right\n\t  //  lower\n\t  char c = stage[y*W+x];\n\t  layer[c].left = min(layer[c].left,x);\n\t  layer[c].right = max(layer[c].right,x);\n\t  layer[c].upper = min(layer[c].upper,y);\n\t  layer[c].lower = max(layer[c].lower,y);\n\t}\n      }\n\n      bool is_safe = false;\n\n      vector<char> order;\n      for(map<char,Belongings>::iterator it = layer.begin();\n\t  it != layer.end();\n\t  it++){\n\torder.push_back(it->first);\n      }\n      sort(order.begin(),order.end());\n      char hypothesis[50*50];\n\n      do{\n\tmemset(hypothesis,'.',sizeof(hypothesis));\n\n\tfor(int i=0;i<order.size();i++){\n\t  int c = order[i];\n\t  Belongings& it = layer[c];\n\t  for(int y=it.upper; y<=it.lower; y++){\n\t    for(int x=it.left; x<=it.right; x++){\n\t      hypothesis[y*W+x] = c;\n\t    }\n\t  }\n\t}\n\n\tif(strcmp(hypothesis,stage) == 0){\n\t  is_safe = true;\n\t  break;\n\t}\n      }while(next_permutation(order.begin(),order.end()));\n      printf(\"%s\\n\",is_safe ? \"SAFE\" : \"SUSPICIOUS\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nbool G[32][32];\nbool visit[32];\nbool dfs(int node){\n  if(visit[node]) return false;\n  visit[node] = true;\n\n  for(int to=0;to<32;++to){\n\tif(!G[node][to]) continue;\n\tif(!dfs(to)) return false;\n  }\n  \n  visit[node] = false;\n  return true;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int Q; cin >> Q;\n  while(Q--){\n\tint H, W; cin >> H >> W;\n\tvector<string> line(H);\n\tREP(i,H) cin >> line[i];\n\n\tvector< pair<PII,PII> > sz(32, MP(MP(128,128),MP(-1,-1)));\n\tREP(y,H) REP(x,W){\n\t  if(line[y][x] == '.') continue;\n\t  PII& tl = sz[line[y][x]-'A'].first;\n\t  PII& br = sz[line[y][x]-'A'].second;\n\t  tl.first = min(tl.first, x);\n\t  br.first = max(br.first, x);\n\t  tl.second = min(tl.second, y);\n\t  br.second = max(br.second, y);\n\t}\n\t\n\tfill((bool*)G, (bool*)G+32*32, false); \n\tbool isSafe = true;\n\tREP(i,32){\n\t  if(sz[i].second.second < 0) continue;\n\t  PII& tl = sz[i].first;\n\t  PII& br = sz[i].second;\n\t  for(int y=tl.second;y<=br.second;++y){\n\t\tfor(int x=tl.first;x<=br.first;++x){\n\t\t  if(line[y][x] == '.'){\n\t\t\tisSafe = false;\n\t\t\tbreak;\n\t\t  }\n\t\t  char over = line[y][x]-'A';\n\t\t  if(over != i) G[over][i] = true;\n\t\t}\n\t  }\n\t}\n\n\tfor(int i=0;i<32;++i){\n\t  fill(visit, visit+32, false);\n\t  if(!dfs(i)){\n\t\tisSafe = false;\n\t\tbreak;\n\t  }\n\t}\n\t\n\tcout << (isSafe? \"SAFE\": \"SUSPICIOUS\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define all(v) ALL(v)\n#define Dedupe(v) (v).erase(unique(ALL((v))),(v).end())\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n#define CININIT cin.tie(0),ios::sync_with_stdio(false)\nstruct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\nint h,w;\nchar tbl[64][64];\n\nvoid solve(){\n    rep(i,64) rep(j,64) tbl[i][j]=0;\n\n    cin>>h>>w;\n    rep(i,h) rep(j,w) cin>>tbl[i][j];\n\n    vector<vector<int>> g(32);\n\n    for(char c='A';c<='Z';c++){\n        int u=INF,d=-INF,l=INF,r=-INF;\n        rep(i,h) rep(j,w){\n            if(tbl[i][j]==c){\n                u=min(u,i);\n                d=max(d,i);\n                l=min(l,j);\n                r=max(r,j);\n            }\n        }\n        for(int i=u;i<=d;i++) for(int j=l;j<=r;j++) if(tbl[i][j]=='.'){\n            cout << \"SUSPICIOUS\" << endl;\n            return;\n        }\n        for(int i=u;i<=d;i++) for(int j=l;j<=r;j++){\n            if(i<0 or j<0) continue;\n            if('A'<=tbl[i][j] and tbl[i][j]<='Z' and tbl[i][j]!=c){\n                g[c-'A'].push_back(tbl[i][j]-'A');\n            }\n        }\n    }\n    for(int i=0;i<32;i++){\n        sort(all(g[i]));\n        Dedupe(g[i]);\n    }\n\n    /*\n    for(int i=0;i<32;i++){\n        if(g[i].size()==0) continue;\n        cout << (char)(i+'A') << \" : [\";\n        for(int j=0;j<g[i].size();j++) cout << (char)(g[i][j]+'A') << \",\";\n        cout << \"]\" << endl;\n    }\n    */\n\n    bool used[32];\n    for(char c='A';c<='Z';c++){\n        rep(i,32) used[i]=false;\n        int t=c-'A';\n        if(g[t].size()==0) continue;\n//        cout << c << endl;\n\n        queue<int> que;\n        que.push(t);\n        while(!que.empty()){\n            int p=que.front();\n            que.pop();\n//            cout << \"\\t\" << (char)(p+'A') << endl;\n\n            used[p] = true;\n\n            for(int i=0;i<g[p].size();i++){\n                int ne = g[p][i];\n                if(ne+'A'==c){\n                    cout << \"SUSPICIOUS\" << endl;\n                    return;\n                }\n                if(used[ne]){\n                    continue;\n                }\n                que.push(ne);\n            }\n        }\n    }\n    cout << \"SAFE\" << endl;\n}\n\n\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<set>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a,i<b;++i)\n#define rep(i,n) REP(i,0,n)\n\nstruct P {\n  int maxx,maxy,minx,miny;\n  P() {\n    maxx = maxy = -1;\n    minx = miny = 51;\n  }\n};\n\nint dist[26][26];\nint visited[26];\n\nbool visit(int i) {\n  if(i<0 || i>25) return false;\n  visited[i] = 2;\n  for(int j=0; j<26; ++j) {\n    if(dist[i][j] == 0) continue;\n    if(visited[j] != 0) {\n      if(visited[j] == 2) return false;\n    } else if (!visit(j)) return false;\n  }\n  visited[i] = 1;\n  return true;\n}\n\nint main() {\n  int h,w,n,k,l,start,now,i,j;\n  string s;\n  cin>>n;\n  while(n--) {\n    cin>>h>>w;\n    vector<string> in;\n    memset(dist, 0, sizeof(dist));\n    memset(visited, 0, sizeof(visited));\n    for(i=0; i<h; ++i) {\n      cin>>s;\n      in.push_back(s);\n    }\n\n    for(k=0; k<26; ++k) {\n      for(l=0; l<26; ++l) {\n\tdist[k][l] = 0;\n      }\n    }\n\n    set<char> badget;\n    map<char, P> mp;\n    queue<int> Q;\n    for(i=0; i<h; ++i) {\n      for(j=0; j<w; ++j) {\n\tif(in[i].at(j) != '.') {\n\t  badget.insert(in[i].at(j));\n\t  mp[in[i].at(j)].maxx = max(mp[in[i].at(j)].maxx, j);\n\t  mp[in[i].at(j)].maxy = max(mp[in[i].at(j)].maxy, i);\n\t  mp[in[i].at(j)].minx = min(mp[in[i].at(j)].minx, j);\n\t  mp[in[i].at(j)].miny = min(mp[in[i].at(j)].miny, i);\n\t}\n      }\n    }\n\n    if(badget.size() == 0) {\n      cout<<\"SAFE\"<<endl;\n      goto NEXT;\n    }\n\n    for(set<char>::iterator it = badget.begin(); it != badget.end(); ++it) {\n      int maxx = mp[(*it)].maxx,maxy = mp[(*it)].maxy;\n      int minx = mp[(*it)].minx,miny = mp[(*it)].miny;\n      for(i=miny; i<=maxy; ++i) {\n\tfor(j=minx; j<=maxx; ++j) {\n\t  if(in[i].at(j) == '.') {\n\t    cout<<\"SUSPICOUS\"<<endl;\n\t    goto NEXT;\n\t  }else if(in[i].at(j) != (*it)) {\n\t    dist[(*it)-'A'][in[i].at(j)-'A'] = 1;\n\t  }\n\t}\n      }\n    }\n\n    //±±Ég|WJ\\[gð­\n    //dist[i][j] Í iÌãÉjªæÁÄ¢éÆ¢¤ÖWð\\·\n    for(i=0; i<26; ++i) {\n      if(!visit(i)) {\n\tcout<<\"SUSPICOUS\"<<endl;\n\tgoto NEXT;\n      }\n    }\n    cout<<\"SAFE\"<<endl;\n\n  NEXT:\n    ;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#define rep(i,j) for(int i=0;i<j;i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define ms(i,j) memset(i,j,sizeof(i))\nusing namespace std;\nint n,h,w;\nchar m[50][51];\nint main(){\n    scanf(\"%d\",&n);\n    while(n--){\n        scanf(\"%d%d\",&h,&w);\n        bool a=true;\n            int t[26],l[26],r[26]={0},b[26]={0};\n            rep(i,26)t[i]=l[i]=55;\n            bool f[26][26];\n            ms(f,0);\n        rep(i,h){\n            scanf(\"%s\",m[i]);\n            rep(j,w)if(m[i][j]!='.'){\n                char c=m[i][j]-'A';\n                f[c][c]=true;\n                t[c]=min(t[c],i);\n                l[c]=min(l[c],j);\n                r[c]=max(r[c],j);\n                b[c]=max(b[c],i);\n            }\n        }\n        bool rf=false;\n        rep(i,26)if(f[i][i]){\n            //printf(\"%c %d %d %d %d\\n\",i+'A',t[i],l[i],r[i],b[i]);\n            reps(j,t[i],b[i])reps(k,l[i],r[i]){\n                if(m[j][k]!=i+'A'){\n                    if(m[j][k]=='.')a=false;\n                    else f[i][m[j][k]-'A']=true;\n                }\n            }\n            int cnt=0;\n            rep(j,26)cnt+=f[i][j];\n            if(cnt==1)rf=true;\n        }\n\n        puts(a&&rf?\"SAFE\":\"SUSPICIOUS\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <string>\n#include <tuple>\n#include <set>\n\nusing namespace std;\n\nint get_single_int() {\n  string line;\n  getline( cin, line );\n  return stoi( line );\n}\n\nbool is_rect( vector<string> &table, char ch ) {\n  int min_x = 10000, max_x = -1, min_y = 10000, max_y = -1;\n  for ( int i = 0; i < table.size(); i++ ) {\n\tfor ( int j = 0; j < table[ i ].length(); j++ ) {\n\t  if ( ch == table[ i ][ j ] ) {\n\t\tmin_x = min( min_x, j );\n\t\tmax_x = max( max_x, j );\n\t\tmin_y = min( min_y, i );\n\t\tmax_y = max( max_y, i );\n\t  }\n\t}\n  }\n  for ( int i = min_y; i <= max_y; i++ ) {\n\tfor ( int j = min_x; j <= max_x; j++ ) {\n\t  if ( table[ i ][ j ] != '#' and ch != table[ i ][ j ] ) {\n\t\treturn false;\n\t  }\n\t}\n  }\n  for ( int i = min_y; i <= max_y; i++ ) {\n\tfor ( int j = min_x; j <= max_x; j++ ) {\n\t  table[ i ][ j ] = '#';\n\t}\n  }\n  return true;\n}\n\nint main() {\n  int n = get_single_int();\n  for ( int t = 0; t < n; t++ ) {\n\tint h, w;\n\tcin >> h >> w;\n\tstring line;\n\tgetline( cin, line );\n\tvector<string> table( h );\n\tfor ( int j = 0; j < h; j++ ) {\n\t  getline( cin, table[ j ] );\n\t}\n\tset<char> ch_set;\n\tfor ( int i = 0; i < h; i++ ) {\n\t  for ( int j = 0; j < w; j++ ) {\n\t\tif ( table[ i ][ j ] != '.' ) {\n\t\t  ch_set.insert( table[ i ][ j ] );\n\t\t}\n\t  }\n\t}\n\tint bef_no_ch = ch_set.size() + 1;\n\twhile ( bef_no_ch > ch_set.size() ) {\n\t  bef_no_ch = ch_set.size();\n\t  set<char> remove_set;\n\t  for ( char ch : ch_set ) {\n\t\tif ( is_rect( table, ch ) ) {\n\t\t  remove_set.insert( ch );\n\t\t}\n\t  }\n\t  for ( char ch : remove_set ) {\n\t\tif ( ch_set.find( ch ) != ch_set.end() ) {\n\t\t  ch_set.erase( ch );\n\t\t}\n\t  }\n\t}\n\tif ( ch_set.size() == 0 ) {\n\t  cout << \"SAFE\" << endl;\n\t} else {\n\t  cout << \"SUSPICIOUS\" << endl;\n\t}\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct pos{\n  int x, y;\n};\nstruct rect{\n  pos lt, rb;\n};\n\nint H, W;\nchar pjt[55][55];\n\nmap<char, rect> bg;\n\nbool judge(const vector<char> &vec)\n{\n  string ex = \"\";\n  for(auto &v : vec){\n    ex += v;\n    for(int i = bg[v].lt.y; i <= bg[v].rb.y; i++){\n      for(int j = bg[v].lt.x; j <= bg[v].rb.x; j++){\n\tif(ex.find(pjt[i][j]) == string::npos) return false;\n      }\n    }\n  }\n  return true;\n}\n\nint main()\n{\n  int N; cin >> N;\n  while(N--){\n    bg.clear();\n    cin >> H >> W;\n    vector<char> mtl;\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n\tcin >> pjt[i][j];\n\tif(pjt[i][j] == '.') continue;\n\tif(bg.count(pjt[i][j]) == 0){\t  \n\t  mtl.push_back(pjt[i][j]);\n\t  bg[pjt[i][j]].lt.x = j;\n\t  bg[pjt[i][j]].lt.y = i;\n\t  bg[pjt[i][j]].rb.x = j;\n\t  bg[pjt[i][j]].rb.y = i;\n\t} else {\n\t  bg[pjt[i][j]].lt.x = min(bg[pjt[i][j]].lt.x, j);\n\t  bg[pjt[i][j]].lt.y = min(bg[pjt[i][j]].lt.y, i);\n\t  bg[pjt[i][j]].rb.x = max(bg[pjt[i][j]].rb.x, j);\n\t  bg[pjt[i][j]].rb.y = max(bg[pjt[i][j]].rb.y, i);\n\t}\n      }\n    }\n    sort(mtl.begin(), mtl.end());\n    bool flag = false;\n    do{\n      flag |= judge(mtl);\n      if(flag) break;\n    }while(next_permutation(mtl.begin(), mtl.end()));\n    if(!flag) cout << \"SUSPICIOUS\" << endl;\n    else cout << \"SAFE\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor(int loop=0;loop<n;loop++){\n\t\tint h,w;\n\t\tcin >> h >> w;\n\t\tint i,j,k;\n\t\tint c[256];\n\t\tfor(i=0;i<256;i++) c[i]=-2;\n\t\tc['.']=-1;\n\t\t\n\t\tchar in;\n\t\tint num=0;\n\t\tint m[50][50];\n\t\tint nwse[10][4];\n\t\tfor(i=0;i<10;i++){\n\t\t\tnwse[i][0]=1000;\n\t\t\tnwse[i][1]=1000;\n\t\t\tnwse[i][2]=-1;\n\t\t\tnwse[i][3]=-1;\n\t\t}\n\t\tfor(i=0;i<h;i++){\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tcin >> in;\n\t\t\t\tif(c[in]==-2){\n\t\t\t\t\tc[in] = num;\n\t\t\t\t\tnum++;\n\t\t\t\t}\n\t\t\t\tm[i][j]=c[in];\n\t\t\t\tif(c[in]!=-1){\n\t\t\t\t\tnwse[c[in]][0] = min(nwse[c[in]][0],i);\n\t\t\t\t\tnwse[c[in]][1] = min(nwse[c[in]][1],j);\n\t\t\t\t\tnwse[c[in]][2] = max(nwse[c[in]][2],i);\n\t\t\t\t\tnwse[c[in]][3] = max(nwse[c[in]][3],j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint g[10][10];\n\t\tfor(i=0;i<10;i++) for(j=0;j<10;j++) g[i][j]=0;\n\t\t\n\t\tint f=0;\n\t\tfor(k=0;k<num;k++){\n\t\t\tfor(i=nwse[k][0];i<=nwse[k][2];i++){\n\t\t\t\tfor(j=nwse[k][1];j<=nwse[k][3];j++){\n\t\t\t\t\tif(m[i][j]==-1){\n\t\t\t\t\t\tf=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(m[i][j]!=k){\n\t\t\t\t\t\tg[m[i][j]][k]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(f==1){\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint mark[10];\n\t\tfor(i=0;i<10;i++) mark[i]=0;\n\t\t\n\t\tfor(k=0;k<num;k++){\n\t\t\tfor(i=0;i<num;i++){\n\t\t\t\tif(mark[i]==0){\n\t\t\t\t\tf=0;\n\t\t\t\t\tfor(j=0;j<num;j++) if(g[j][i]==1) f=1;\n\t\t\t\t\tif(f==0){\n\t\t\t\t\t\tfor(j=0;j<num;j++) g[i][j]=0;\n\t\t\t\t\t\tmark[i]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tf=0;\n\t\tfor(i=0;i<num;i++) if(mark[i]==0) f=1;\n\t\tif(f==0) cout << \"SAFE\" << endl;\n\t\telse cout << \"SUSPICIOUS\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nbool solve(){\n\tint h,w;\n\tcin>>h>>w;\n\tstring s[50];\n\trep(i,h) cin>>s[i];\n\tvector<char> ash;\n\trep(i,h) rep(j,w) if(s[i][j]!='.') ash.pb(s[i][j]);\n\tsort(all(ash));\n\tash.erase(unique(all(ash)),ash.end());\n\tmap<char,int> mp;\n\trep(i,ash.size()) mp[ash[i]]=i;\n\tint n=ash.size();\n\tif(n==0) return true;\n\tint ord[7];\n\trep(i,n) ord[i]=i;\n\tdo{\n\t\tbool can=true;\n\t\tint inv[7];\n\t\trep(i,n) inv[ord[i]]=i;\n\t\trep(i,n){\n\t\t\tint o=ord[i];\n\t\t\tint l=100,r=-1,u=100,b=-1;\n\t\t\trep(j,h) rep(k,w){\n\t\t\t\tif(s[j][k]!='.'&&s[j][k]==ash[o]){\n\t\t\t\t\tl=min(l,k),r=max(r,k),u=min(u,j),b=max(b,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=u;j<=b;j++) for(int k=l;k<=r;k++){\n\t\t\t\tif(s[j][k]=='.'||inv[mp[s[j][k]]]>i){\n\t\t\t\t\tcan=false;\n\t\t\t\t\tgoto hoge;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thoge:\n\t\tif(can) return true;\n\t}while(next_permutation(ord,ord+n));\n\treturn false;\n}\nint main(){\n\tint t;\n\tcin>>t;\n\trep(tt,t){\n\t\tif(solve()) puts(\"SAFE\");\n\t\telse puts(\"SUSPICIOUS\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvoid print() { cout << \"\\n\"; }\ntemplate <class T> void print(const T &x) { cout << x << \"\\n\"; }\ntemplate <class T, class... Args> void print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\ntemplate <class T> void printVector(const vector<T> &v) {\n    for(const T &x : v) {\n        cout << x << \" \";\n    }\n    cout << \"\\n\";\n}\nusing ll = long long;\n\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\nconst double EPS = 1e-7;\nconst int INF = 1 << 30;\nconst ll LLINF = 1LL << 60;\nconst double PI = acos(-1);\nconstexpr int MOD = 1000000007;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\n//-------------------------------------\n\n// (x1, y1)が最小、(x2, y2)が最大\nstruct Rect {\n    int x1, y1, x2, y2;\n};\n\nint h, w;\nvector<string> g;\nvector<vector<bool>> seen;\n\nbool isRect(int y, int x) {\n    Rect rect;\n    rect.x1 = rect.x2 = x;\n    rect.y1 = rect.y2 = y;\n    for(int i = 0; i < h; i++) {\n        for(int j = 0; j < w; j++) {\n            if(g[i][j] != g[y][x]) {\n                continue;\n            }\n            chmax(rect.x2, j);\n            chmax(rect.y2, i);\n            chmin(rect.x1, j);\n            chmin(rect.y1, i);\n        }\n    }\n    for(int i = rect.y1; i <= rect.y2; i++) {\n        for(int j = rect.x1; j <= rect.x2; j++) {\n            if(g[i][j] != g[y][x] && !seen[i][j]) {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nvoid dfs(int y, int x, char c) {\n    if(seen[y][x]) {\n        return;\n    }\n    seen[y][x] = true;\n    for(int d = 0; d < 4; d++) {\n        int ny = y + dy[d];\n        int nx = x + dx[d];\n        if(0 <= nx && nx < w && 0 <= ny && ny < h && g[ny][nx] == c) {\n            dfs(ny, nx, c);\n        }\n    }\n}\n\nvoid solve() {\n    g.clear();\n    seen.clear();\n    cin >> h >> w;\n    g.resize(h);\n    seen.resize(h, vector<bool>(w, false));\n    for(int i = 0; i < h; i++) {\n        cin >> g[i];\n    }\n    while(1) {\n        bool ed = true;\n        bool update = false;\n        for(int i = 0; i < h; i++) {\n            for(int j = 0; j < w; j++) {\n                if(g[i][j] == '.') {\n                    continue;\n                }\n                ed = false;\n                if(seen[i][j]) {\n                    continue;\n                }\n                if(isRect(i, j)) {\n                    update = true;\n                    dfs(i, j, g[i][j]);\n                }\n            }\n        }\n        if(ed || !update) {\n            break;\n        }\n    }\n    for(int i = 0; i < h; i++) {\n        for(int j = 0; j < w; j++) {\n            if(g[i][j] != '.' && !seen[i][j]) {\n                print(\"SUSPICIOUS\");\n                return;\n            }\n        }\n    }\n    print(\"SAFE\");\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int t;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint adj[26][26];\n\nbool cycle(void){\n  int d[26];\n  for(int i=0;i<26;i++)d[i] = 0;\n\n  for(int i=0;i<26;i++){\n    for(int j=0;j<26;j++){\n      for(int k=0;k<26;k++){\n\tif(adj[k][j] && d[j] > d[k] + adj[k][j]){\n\t  d[j] = d[k] + adj[k][j];\n\t  if(i==25)return true;\n\t}\n      }\n    }\n  }\n  return false;\n}\n\nint main(){\n  int n,h,w;\n  string pict[50];\n  int rr,rd,lu,ll;\n  bool flag;\n\n  cin >> n;\n  while(n){\n    n--;\n    cin >> h >> w;\n    for(int i=0;i<h;i++)cin >> pict[i];\n    for(int i=0;i<26;i++){\n      for(int j=0;j<26;j++)adj[i][j] = 0;\n    }\n\n    flag = true;\n    for(int i='A';i<='Z';i++){\n      rr = 0;\n      rd = 0;\n      lu = h;\n      ll = w;\n      for(int j=0;j<h;j++){\n\tfor(int k=0;k<w;k++){\n\t  if(pict[j][k] == i){\n\t    rr = max(rr,k);\n\t    rd = max(rd,j);\n\t    lu = min(lu,j);\n\t    ll = min(ll,k);\n\t  }\n\t}\n      }\n\n      for(int j=lu;j<=rd;j++){\n\tfor(int k=ll;k<=rr;k++){\n\t  if(pict[j][k] == '.'){\n\t    flag = false;\n\t    break;\n\t  }else if(pict[j][k] != i){\n\t    adj[pict[j][k] - 'A'][i - 'A'] = -1;\n\t  }\n\t}\n\tif(!flag)break;\n      }\n      if(!flag)break;\n    }\n\n    if(flag && !cycle())cout << \"SAFE\" << endl;\n    else cout << \"SUSPICIOUS\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nstruct make\n{\n\tchar str;\n\tint posi,start[2];\n\tint high,wide,JUDGE;\n\tstruct make *front[8];\n\tint f_count;\n};\n\nint main()\n{\n\tint N,H,W,count,COUNT,judge,no_rect[7],NO_RECT;\n\tchar img[1000][51];\n\tstruct make M[8];\n\tstruct make *MP;\n\t\n\tscanf(\"%d\",&N);//データの個数\n\tfor(int a=0;a<N;a++)\n\t{\n\t\tcount=0;//材質の個数\n\t\tCOUNT=0;\n\t\tNO_RECT=0;\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tscanf(\"%s\",img[b]);\n\t\t\timg[b][W]='\\0';\n\t\t}\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tfor(int d=0;d<count;d++) M[d].posi=-1;\n\t\t\tfor(int c=0;c<W;c++)\n\t\t\t{\n\t\t\t\tif(img[b][c]!='.')\n\t\t\t\t{\n\t\t\t\t\t//材質判定\n\t\t\t\t\tjudge=0;\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t\tif(count>0 && img[b][c]!=M[judge].str) judge++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}while(judge<count);\n\t\t\t\t\t//新しい材質の場合\n\t\t\t\t\tif(judge==count)\n\t\t\t\t\t{\n\t\t\t\t\t\tM[count].str=img[b][c];\n\t\t\t\t\t\tM[count].start[0]=b;\n\t\t\t\t\t\tM[count].start[1]=c;\n\t\t\t\t\t\tM[count].posi=c;\n\t\t\t\t\t\tM[count].high=1;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\t//既出の材質の場合\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(M[judge].start[1]>c) M[judge].start[1]=c;\n\t\t\t\t\t\tif(M[judge].posi<0) M[judge].posi=c;\n\t\t\t\t\t\telse if(M[judge].wide<c-M[judge].posi+1) M[judge].wide=c-M[judge].posi+1;\n\t\t\t\t\t\tM[judge].high=b-M[judge].start[0]+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//判定開始\n\t\tif(count)\n\t\t{\n\t\t\t//見えている部分が長方形かどうか判定\n\t\t\tfor(int b=0;b<count;b++)\n\t\t\t{\n\t\t\t\tM[b].JUDGE=1;\n\t\t\t\tM[b].f_count=0;\n\t\t\t\tfor(int s1=0;s1<M[b].high;s1++)\n\t\t\t\t{\n\t\t\t\t\tfor(int s2=0;s2<M[b].wide;s2++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//確実に長方形ではない場合\n\t\t\t\t\t\tif(img[s1+M[b].start[0]][s2+M[b].start[1]]=='.')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNO_RECT=1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//長方形の可能性もある場合\n\t\t\t\t\t\tif(img[s1+M[b].start[0]][s2+M[b].start[1]]!=M[b].str)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int c=0;c<count;c++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint e=0;\n\t\t\t\t\t\t\t\tfor(int d=0;d<M[b].f_count;)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif(img[s1+M[b].start[0]][s2+M[b].start[1]]==M[b].front[d]->str) break;\n\t\t\t\t\t\t\t\t\td++;\n\t\t\t\t\t\t\t\t\te=d;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//今いる座標のもじと比べる\n\t\t\t\t\t\t\t\tif(img[s1+M[b].start[0]][s2+M[b].start[1]]==M[c].str && e==M[b].f_count)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tM[b].front[M[b].f_count]=&M[c];\n\t\t\t\t\t\t\t\t\tM[b].f_count++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(M[b].JUDGE!=0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tno_rect[COUNT]=b;\n\t\t\t\t\t\t\t\tCOUNT++;\n\t\t\t\t\t\t\t\tM[b].JUDGE=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(NO_RECT==1) break;\n\t\t\t\t}\n\t\t\t\tif(M[b].JUDGE)M[b].front[M[b].f_count]=NULL;\n\t\t\t}\n\t\t\tif(NO_RECT) printf(\"SUSPICIOUS\\n\");\n\t\t\telse if(COUNT)\n\t\t\t{\n\t\t\t\tif(count!=COUNT)\n\t\t\t\t{\n\t\t\t\t\t//循環していないか確認\n\t\t\t\t\tfor(int b=0;b<COUNT;b++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int c=0;c<M[no_rect[b]].f_count;c++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMP=M[no_rect[b]].front[c];\n\t\t\t\t\t\t\tfor(int d=0;;d++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(MP==NULL) break;\n\t\t\t\t\t\t\t\tif(d>count)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tprintf(\"SUSPICIOUS\\n\");\n\t\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMP=(MP->front[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"SAFE\\n\");\n\t\t\t\t}\n\t\t\t\telse printf(\"SUSPICIOUS\\n\");\n\t\t\t}\n\t\t\telse printf(\"SAFE\\n\");\n\t\t}\n\t\telse printf(\"SAFE\\n\");\n\t}\n\treturn 0;\n}\n//printf(\"#\\n\");\n//printf(\"#1 count=%d\\n\",count);\n//printf(\"#1 COUNT=%d\\n\",COUNT);\n//printf(\"#1 NO_RECT=%d\\n\",NO_RECT);\n//printf(\"M[%d].str=%c\\nM[%d].high=%d\\nM[%d].wide=%d\\n\\n\",b,M[b].str,b,M[b].high,b,M[b].wide);\n//printf(\"#1\\nM[%d].start[0]=%d\\nM[%d].start[1]=%d\\n\\n\",b,M[b].start[0],b,M[b].start[1]);\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid chmin(int& x, int y)\n{\n  x = min(x, y);\n}\nvoid chmax(int& x, int y)\n{\n  x = max(x, y);\n}\n\nint main()\n{\n  int Q, H, W;\n  string S[50];\n  int proc = 1;\n  int used[50][50] = {{}};\n\n  cin >> Q;\n  while(Q--) {\n    cin >> H >> W;\n\n    string chars = \"\";\n    for(int i = 0; i < H; i++) {\n      cin >> S[i];\n      chars += S[i];\n    }\n    sort(chars.begin(), chars.end());\n    chars.erase(unique(chars.begin(), chars.end()), chars.end());\n    vector< int > x1(chars.size(), W), x2(chars.size(), 0);\n    vector< int > y1(chars.size(), H), y2(chars.size(), 0);\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        int pos = chars.find(S[i][j]);\n        chmin(x1[pos], j);\n        chmax(x2[pos], j);\n        chmin(y1[pos], i);\n        chmax(y2[pos], i);\n      }\n    }\n    map< char, int > xx1, xx2, yy1, yy2;\n    for(int i = 0; i < chars.size(); i++) {\n      xx1[chars[i]] = x1[i];\n      xx2[chars[i]] = x2[i];\n      yy1[chars[i]] = y1[i];\n      yy2[chars[i]] = y2[i];\n    }\n\n    bool Judge = false;\n\n    do {\n      Judge = true;\n      for(int i = 0; i < chars.size(); i++) {\n        for(int j = xx1[chars[i]]; j <= xx2[chars[i]]; j++) {\n          for(int k = yy1[chars[i]]; k <= yy2[chars[i]]; k++) {\n            if(used[j][k] == proc) continue;\n            used[j][k] = proc;\n            if(S[k][j] != chars[i]) {\n              Judge = false;\n              goto myon;\n            }\n          }\n        }\n      }\n    myon: ;\n      ++proc;\n    } while(!Judge && next_permutation(chars.begin(), chars.end()));\n    if(Judge) cout << \"SAFE\" << endl;\n    else cout << \"SUSPICIOUS\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <string>\n#include <cmath>\n#include <map>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int inf = 100100100;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int number;\n  cin >> number;\n  rep(aaaaaaa,number){\n      int h,w;\n      bool flag =true;\n      cin >> h >> w;\n      string s[55]={};\n      map<char,bool> m;\n      rep(y,h){\n          cin >> s[y];\n      }\n      rep(y,h)rep(x,w){\n          if(s[y][x]!='.'){\n              if(m[s[y][x]]){\n                  flag = false;\n                  x=w;y=h;break;\n              }\n              int st = x;\n              char tc = s[y][x];\n              m[tc] = true;\n              while(s[y][x]==tc) x++;\n              int et = x-1;\n              int yy = y;\n              while(s[yy][st]==tc){\n                  REP(xx,st,et+1) {\n                      if(s[yy][xx]!=tc){flag=false;}\n                      s[yy][xx]='.';\n                  }\n                  yy+=1;\n              }\n          }\n      }\n      rep(y,h)rep(x,w){\n         if(s[y][x]!='.') flag = false;\n      }\n      if(flag) cout << \"SAFE\" << endl;\n      else cout << \"SUSPICIOUS\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <string>\n#include <set>\n#define REP(i,a,b) for (int i = (a); i < (int)(b); i++)\n#define rep(i,a) REP(i,0,a)\n\nusing namespace std;\n\nchar field[51][51];\nmap<char, vector<int>> corner;\nvector<char> chars;\nset<char> schars;\nint H, W;\n\nbool judge(char (*field)[51], char c) {\n    REP(y, corner[c][2], corner[c][3]+1)\n        REP(x, corner[c][0], corner[c][1]+1) {\n            if (field[y][x] != c && field[y][x] != '*')  return false;\n            field[y][x] = '*';\n        }\n    return true;\n}\n\nstring solve(vector<char> chars) {\n    do {\n        char cp[51][51];\n        rep(y, H) rep(x, W) cp[y][x] = field[y][x];\n        \n        bool flag = true;\n        for(char c: chars) \n            if (!judge(cp, c)) {\n                flag = false;\n                break;\n            }\n        if (flag) return \"SAFE\";\n    } while (next_permutation(chars.begin(), chars.end()));\n\n    return \"SUSPICIOUSE\";\n}\n\nint main(void){\n    int N;\n    cin >> N;\n    while (N--) {\n        cin >> H >> W;\n        rep(y, H) rep(x, W) cin >> field[y][x];\n        chars.clear(); schars.clear(); corner.clear();\n        \n        rep(y, H) rep(x, W) {\n            char c = field[y][x];\n            if (c == '.') continue;\n            \n            schars.insert(c);\n            if (corner.find(c) == corner.end()) {\n                vector<int> vec(4);\n                vec = {x, x, y, y};\n                corner[c] = vec;\n            }\n            else {\n                corner[c][0] = min(corner[c][0], x);\n                corner[c][1] = max(corner[c][1], x);\n                corner[c][2] = min(corner[c][2], y);\n                corner[c][3] = max(corner[c][3], y);\n            }\n        }\n        \n        for (char c: schars) chars.push_back(c);\n        sort(chars.begin(), chars.end());\n        cout << solve(chars) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass Belongings {\npublic:\n  Belongings() : left(100),right(0),upper(100),lower(0){}\n  int left,right,upper,lower;\n};\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    for(int stage_idx = 0; stage_idx < N; stage_idx++){\n      int H,W;\n      \n      scanf(\"%d %d\",&H,&W);\n      char stage[2500];\n      char hypothesis[2500];\n      memset(stage,'.',sizeof(stage));\n\n      map<char,Belongings> layer;\n\n      for(int y=0;y<H;y++){\n\tchar line[51];\n\tscanf(\"%s\",line);\n\tfor(int x=0;x<W;x++){\n\t  stage[y*W+x] = line[x];\n\t  if(line[x] == '.') continue;\n\t  //x:0->...\n\t  //y:0\n\t  //  |\n\t  //  v\n\t  //  .\n\t  //  upper\n\t  //left right\n\t  //  lower\n\t  Belongings& be = layer[stage[y*W+x]];\n\t  be.left = min(be.left,x);\n\t  be.right = max(be.right,x);\n\t  be.upper = min(be.upper,y);\n\t  be.lower = max(be.lower,y);\n\t}\n      }\n\n      bool is_safe = false;\n\n      vector<char> order;\n      for(map<char,Belongings>::iterator it = layer.begin();\n\t  it != layer.end();\n\t  it++){\n\torder.push_back(it->first);\n      }\n      sort(order.begin(),order.end());\n\n\n      do{\n\tmemset(hypothesis,'.',sizeof(hypothesis));\n\n\tfor(int i=0;i<order.size();i++){\n\t  char c = order[i];\n\t  Belongings& be = layer[c];\n\t  for(int y=be.upper; y<=be.lower; y++){\n\t    for(int x=be.left; x<=be.right; x++){\n\t      hypothesis[y*W+x] = c;\n\t    }\n\t  }\n\t}\n\n\tif(strcmp(hypothesis,stage) == 0){\n\t  is_safe = true;\n\t  break;\n\t}\n      }while(next_permutation(order.begin(),order.end()));\n      printf(\"%s\\n\",is_safe ? \"SAFE\" : \"SUSPICIOUS\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nbool u[256][256];\nint used[256],kai;\n\nbool dfs(int x){\n  if(used[x]){\n    if(used[x]==kai)return 0;\n    else {kai++;return 1;}\n  }\n  used[x]=kai;\n  bool res=1;\n  for(int i='A';i<='Z';i++)if(u[x][i])res&=dfs(i);\n  return res;\n}\n\nint main(){\n  int T;\n  cin>>T;\n  while(T--){\n    int h,w;\n    cin>>h>>w;\n    char c[50][50],d;\n    int x1[256],x2[256],y1[256],y2[256];\n    for(int i='A';i<='Z';i++){\n      x1[i]=y1[i]=1e9;\n      x2[i]=y2[i]=-1;\n    }\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tcin>>d;\n\tc[i][j]=d;\n\tx1[d]=min(x1[d],j);\n\ty1[d]=min(y1[d],i);\n\tx2[d]=max(x2[d],j);\n\ty2[d]=max(y2[d],i);\n      }\n    \n    bool ans=1;\n    memset(u,0,sizeof(u));\n    memset(used,0,sizeof(used));\n    for(int i='A';i<='Z';i++)\n      for(int y=y1[i];y<=y2[i];y++)\n\tfor(int x=x1[i];x<=x2[i];x++){\n\t  if(c[y][x]=='.')ans=0;\n\t  else if(c[y][x]!=i){\n\t    if(u[c[y][x]][i])ans=0;\n\t    else u[i][c[y][x]]=1;\n\t  }\n\t}\n    \n    kai=1;\n    for(int i='A';i<='Z';i++)if(!used[i])ans&=dfs(i),kai++;\n    \n    cout<<(ans?\"SAFE\":\"SUSPICIOUS\")<<endl;  \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <string>\n#include <set>\n#define REP(i,a,b) for (int i = (a); i < (int)(b); i++)\n#define rep(i,a) REP(i,0,a)\n\nusing namespace std;\n\nchar field[51][51];\nmap<char, vector<int>> corner;\nvector<char> chars;\nset<char> schars;\nint H, W;\n\nbool judge(char (*field)[51], char c) {\n    REP(y, corner[c][2], corner[c][3]+1)\n        REP(x, corner[c][0], corner[c][1]+1) {\n            if (field[y][x] != c && field[y][x] != '*')  return false;\n            field[y][x] = '*';\n        }\n    return true;\n}\n\nstring solve(vector<char> chars) {\n    do {\n        char cp[51][51];\n        rep(y, H) rep(x, W) cp[y][x] = field[y][x];\n        \n        bool flag = true;\n        for(char c: chars) \n            if (!judge(cp, c)) {\n                flag = false;\n                break;\n            }\n        if (flag) return \"SAFE\";\n    } while (next_permutation(chars.begin(), chars.end()));\n\n    return \"SUSPICIOUS\";\n}\n\nint main(void){\n    int N;\n    cin >> N;\n    while (N--) {\n        cin >> H >> W;\n        rep(y, H) rep(x, W) cin >> field[y][x];\n        chars.clear(); schars.clear(); corner.clear();\n        \n        rep(y, H) rep(x, W) {\n            char c = field[y][x];\n            if (c == '.') continue;\n            \n            schars.insert(c);\n            if (corner.find(c) == corner.end()) {\n                vector<int> vec(4);\n                vec = {x, x, y, y};\n                corner[c] = vec;\n            }\n            else {\n                corner[c][0] = min(corner[c][0], x);\n                corner[c][1] = max(corner[c][1], x);\n                corner[c][2] = min(corner[c][2], y);\n                corner[c][3] = max(corner[c][3], y);\n            }\n        }\n        \n        for (char c: schars) chars.push_back(c);\n        sort(chars.begin(), chars.end());\n        cout << solve(chars) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\nusing namespace std;\n#define FOR(i,a,n) for(int i=(a); i<(n); ++i)\n\nstruct Rect {\n\tint x1, x2, y1, y2;\n};\nmap<char, Rect> item;\nvector<string> img;\nint t, H, W;\n\nbool ok(Rect &r, char c) {\n\tFOR(i,r.y1,r.y2+1) FOR(j,r.x1,r.x2+1) {\n\t\tif (img[i][j] != c && img[i][j] != '#') {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid fill(Rect &r, char c) {\n\tFOR(i,r.y1,r.y2+1) FOR(j,r.x1,r.x2+1) img[i][j] = c;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> t;\n\twhile (t--) {\n\t\tcin >> H >> W;\n\t\timg.resize(H);\n\t\tFOR(i,0,H) cin >> img[i];\n\n\t\tFOR(i,0,H) FOR(j,0,W) {\n\t\t\tchar c = img[i][j];\n\t\t\tif (c != '.') {\n\t\t\t\tif ( ! item.count(c)) {\n\t\t\t\t\titem[c] = (Rect){j, j, i, i};\n\t\t\t\t} else {\n\t\t\t\t\titem[c].x1 = min(item[c].x1, j);\n\t\t\t\t\titem[c].x2 = max(item[c].x2, j);\n\t\t\t\t\titem[c].y1 = min(item[c].y1, i);\n\t\t\t\t\titem[c].y2 = max(item[c].y2, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmap<char, Rect>::iterator it = item.begin();\n\t\twhile (it != item.end()) {\n\t\t\tchar c = (*it).first;\n\t\t\tRect &r = (*it).second;\n\t\t\tif (ok(r, c)) {\n\t\t\t\tfill(r, '#');\n\t\t\t\titem.erase(c);\n\t\t\t\tit = item.begin();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t++ it;\n\t\t}\n\t\tcout << (item.empty() ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n\t\titem.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass Belongings {\npublic:\n  Belongings() : left(100),right(0),upper(100),lower(0){}\n  int left,right,upper,lower;\n};\n\nbool check(char hypothesis[50][50],char stage[50][50],int W,int H){\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      if (hypothesis[y][x] != stage[y][x]) return false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    for(int stage_idx = 0; stage_idx < N; stage_idx++){\n      int H,W;\n      char stage[50][50];\n      scanf(\"%d %d\",&H,&W);\n      map<char,Belongings> layer;\n    \n      for(int y=0;y<H;y++){\n\tchar line[51];\n\tscanf(\"%s\",line);\n\tfor(int x=0;x<W;x++){\n\t  stage[y][x] = line[x];\n\t  //x:0->...\n\t  //y:0\n\t  //  |\n\t  //  v\n\t  //  .\n\t  //  upper\n\t  //left right\n\t  //  lower\n\t  layer[stage[y][x]].left = min(layer[stage[y][x]].left,x);\n\t  layer[stage[y][x]].right = max(layer[stage[y][x]].right,x);\n\t  layer[stage[y][x]].upper = min(layer[stage[y][x]].upper,y);\n\t  layer[stage[y][x]].lower = max(layer[stage[y][x]].lower,y);\n\t}\n      }\n\n      string res = \"SUSPICIOUS\";\n    \n      vector<char> order;\n      for(map<char,Belongings>::iterator it = layer.begin();\n\t  it != layer.end();\n\t  it++){\n\torder.push_back(it->first);\n      }\n      sort(order.begin(),order.end());\n      do{\n\tchar hypothesis[50][50];\n\tmemset(hypothesis,'.',sizeof(hypothesis));\n\n\tfor(int i=0;i<order.size();i++){\n\t  int c = order[i];\n\t  for(int y=layer[c].upper; y<=layer[c].lower; y++){\n\t    for(int x=layer[c].left; x<=layer[c].right; x++){\n\t      hypothesis[y][x] = c;\n\t    }\n\t  }\n\t}\n\n\tif(check(hypothesis,stage,W,H)){\n\t  res = \"SAFE\";\n\t  break;\n\t}\n      }while(next_permutation(order.begin(),order.end()));\n      cout << res << \"\\n\";\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\", &T);\n\n\twhile (T--){\n\t\tint H, W;\n\t\tchar m[64][64];\n\n\t\tscanf(\"%d %d\", &H, &W);\n\n\t\tfor (int i = 1; i <= H; i++){\n\t\t\tscanf(\"%s\", &m[i][1]);\n\t\t}\n\n\t\tfor (int t = 0; t < 7; t++){\n\t\t\tint ct[27][64][64];\n\n\t\t\tmemset(ct, 0, sizeof(ct));\n\n\t\t\tfor (int ch = 26; ch >= 0; ch--){\n\t\t\t\tint top, left, down, right;\n\t\t\t\ttop = left = down = right = -1;\n\t\t\t\tchar alpha = (ch == 26 ? '?' : 'A' + ch);\n\n\t\t\t\tfor (int i = 1; i <= H; i++){\n\t\t\t\t\tfor (int j = 1; j <= W; j++){\n\t\t\t\t\t\tct[ch][i][j] = (alpha == m[i][j]) + ct[ch][i - 1][j] + ct[ch][i][j - 1] - ct[ch][i - 1][j - 1];\n\n\t\t\t\t\t\tif (alpha == m[i][j]){\n\t\t\t\t\t\t\tif (top   == -1 ||   top > i) top = i;\n\t\t\t\t\t\t\tif (left  == -1 ||  left > j) left = j;\n\t\t\t\t\t\t\tif (down  == -1 ||  down < i) down = i;\n\t\t\t\t\t\t\tif (right == -1 || right < j) right = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (top == -1 || ch == 26) continue;\n\t\t\t\tint cnt = ct[ch][down][right] - ct[ch][down][left - 1] - ct[ch][top - 1][right] + ct[ch][top - 1][left - 1]\n\t\t\t\t\t\t+ ct[26][down][right] - ct[26][down][left - 1] - ct[26][top - 1][right] + ct[26][top - 1][left - 1];\n\n\t\t\t\tif (cnt == (down - top + 1) * (right - left + 1)){\n\t\t\t\t\tfor (int i = top; i <= down; i++){\n\t\t\t\t\t\tfor (int j = left; j <= right; j++){\n\t\t\t\t\t\t\tm[i][j] = '?';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmemset(ct[26], 0, sizeof(ct[26]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool safe = true;\n\t\tfor (int i = 1; i <= H; i++){\n\t\t\tfor (int j = 1; j <= W; j++){\n\t\t\t\tsafe &= !isalpha(m[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%s\\n\", safe ? \"SAFE\" : \"SUSPICIOUS\");\n\t}\n\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n#include <map>\n#define rep(i,n) for(int i=0; i<n; ++i)\n\nusing namespace std;\n\nint N, n;\nint H,W;\n\nchar m[50][50];\nbool used[26];\nint U[26],D[26],L[26],R[26];\n\n\nbool check(char ch){\n  int z = ch-'A';\n  for(int i=U[z]; i<D[z]; ++i){\n    for(int j=L[z]; j<R[z]; ++j){\n      if(m[i][j] != '.' && used[z] == false) continue;\n      if(m[i][j]!=ch) return false;\n    }\n  }\n  return true;\n}\nvoid input(){\n  int x;\n  string str;\n  cin >> H >> W;\n  rep(i,H){\n    cin>>str;\n    rep(j,W){\n      m[i][j] = str[j];\n      if(m[i][j]=='.')continue;\n      x=m[i][j]-'A';\n      used[x] = true;\n      U[x]=min(U[x],i);\n      D[x]=max(D[x],i);\n      L[x]=min(L[x],j);\n      R[x]=max(R[x],j);\n    }\n  }\n}\n\nvoid init(){\n  rep(i,26){\n    U[i] = 50;\n    D[i] = 0;\n    L[i] = 50;\n    R[i] = 0;\n    used[i] = false;\n  }\n}\nint main(){\n  cin >> N;\n  while(N--){\n    init();\n    input();\n    while(1){\n      bool flag = false;\n      rep(i,26){\n        if(used[i]==false)continue;\n        if(check(i+'A')==true){\n          used[i] = false;\n          flag = true;\n          break;\n        }\n        \n      }\n      flag = false;\n      rep(i,26) flag |= used[i];\n      cout << (flag ? \"SUSPICIOUS\" : \"SAFE\") << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid chmin(int& x, int y)\n{\n  x = min(x, y);\n}\nvoid chmax(int& x, int y)\n{\n  x = max(x, y);\n}\n\nint main()\n{\n  int Q, H, W;\n  string S[50];\n\n  cin >> Q;\n  while(Q--) {\n    cin >> H >> W;\n\n    string chars = \"\";\n    for(int i = 0; i < H; i++) {\n      cin >> S[i];\n      chars += S[i];\n    }\n    sort(chars.begin(), chars.end());\n    chars.erase(unique(chars.begin(), chars.end()), chars.end());\n    vector< int > x1(chars.size(), W), x2(chars.size(), 0);\n    vector< int > y1(chars.size(), H), y2(chars.size(), 0);\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        int pos = chars.find(S[i][j]);\n        chmin(x1[pos], j);\n        chmax(x2[pos], j);\n        chmin(y1[pos], i);\n        chmax(y2[pos], i);\n      }\n    }\n    map< char, int > xx1, xx2, yy1, yy2;\n    // ???????????¨???????????????????????¨???????????????\n    for(int i = 0; i < chars.size(); i++) {\n      xx1[chars[i]] = x1[i];\n      xx2[chars[i]] = x2[i];\n      yy1[chars[i]] = y1[i];\n      yy2[chars[i]] = y2[i];\n    }\n\n    bool Judge = false;\n    bool used[50][50];\n\n    do {\n      Judge = true;\n      memset(used, false, sizeof(used));\n      for(int i = 0; i < chars.size(); i++) {\n        for(int j = xx1[chars[i]]; j <= xx2[chars[i]]; j++) {\n          for(int k = yy1[chars[i]]; k <= yy2[chars[i]]; k++) {\n            if(used[j][k]++) continue;\n            Judge &= S[k][j] == chars[i];\n          }\n        }\n      }\n    } while(!Judge && next_permutation(chars.begin(), chars.end()));\n    if(Judge) cout << \"SAFE\" << endl;\n    else cout << \"SUSPICIOUS\" << endl;\n\n  }\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tint work[8],count;\n};\n\nint H,W,word_num,loc[128];\nchar map[50][51],word_table[8];\nbool isOK;\n\n\nvoid func(){\n\n\tfor(int i = 0; i < 128; i++)loc[i] = -1;\n\tword_num = 0;\n\n\tscanf(\"%d %d\",&H,&W);\n\tfor(int i = 0; i < H; i++){\n\t\tscanf(\"%s\",map[i]);\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tif(map[i][k] != '.'){\n\t\t\t\tif(loc[map[i][k]-'0'] == -1){ //????????´?????´???\n\t\t\t\t\tloc[map[i][k]-'0'] = word_num;\n\t\t\t\t\tword_table[word_num] = map[i][k];\n\t\t\t\t\tword_num++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool FLG = true;\n\tint most_left,most_right,most_top,most_bottom;\n\tchar ch;\n\n\tfor(int i = 0; i < word_num; i++){\n\t\tch = word_table[i];\n\n\t\tmost_left = 51,most_right = -1,most_top = 51,most_bottom = -1;\n\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(map[row][col] == ch){\n\t\t\t\t\tmost_left = min(most_left,col);\n\t\t\t\t\tmost_right = max(most_right,col);\n\t\t\t\t\tmost_top = min(most_top,row);\n\t\t\t\t\tmost_bottom = max(most_bottom,row);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int row = most_top; row <= most_bottom; row++){\n\t\t\tfor(int col = most_left; col <= most_right; col++){\n\t\t\t\tif(map[row][col] == '.'){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!FLG)break;\n\t\t}\n\t}\n\n\tif(!FLG){\n\t\tprintf(\"SUSPICIOUS\\n\");\n\t\treturn;\n\t}\n\n\tisOK = false;\n\n\tqueue<Info> Q;\n\n\tInfo first;\n\tfirst.count = 0;\n\tfor(int i = 0; i < word_num; i++)first.work[i] = -1;\n\tQ.push(first);\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().count == word_num){\n\n\t\t\tFLG = true;\n\n\t\t\tfor(int i = 0; i < word_num; i++){\n\t\t\t\tch = word_table[i];\n\t\t\t\trank = Q.front().work[i];\n\n\t\t\t\tmost_left = 51,most_right = -1,most_top = 51,most_bottom = -1;\n\n\t\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\t\tif(map[row][col] == ch){\n\t\t\t\t\t\t\tmost_left = min(most_left,col);\n\t\t\t\t\t\t\tmost_right = max(most_right,col);\n\t\t\t\t\t\t\tmost_top = min(most_top,row);\n\t\t\t\t\t\t\tmost_bottom = max(most_bottom,row);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int row = most_top; row <= most_bottom; row++){\n\t\t\t\t\tfor(int col = most_left; col <= most_right; col++){\n\t\t\t\t\t\tif(map[row][col] != ch){\n\t\t\t\t\t\t\tif(rank > Q.front().work[loc[map[row][col]-'0']]){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG)break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(FLG){\n\t\t\t\tisOK = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < word_num; i++){\n\t\t\tif(Q.front().work[i] == -1){\n\t\t\t\tInfo next;\n\t\t\t\tfor(int k = 0; k < 8; k++)next.work[k] = Q.front().work[k];\n\t\t\t\tnext.work[i] = Q.front().count;\n\t\t\t\tnext.count = Q.front().count+1;\n\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\n\t\tQ.pop();\n\t}\n\n\tif(isOK){\n\t\tprintf(\"SAFE\\n\");\n\t}else{\n\t\tprintf(\"SUSPICIOUS\\n\");\n\t}\n}\n\n\nint main(){\n\n\tint num;\n\tscanf(\"%d\",&num);\n\n\tfor(int i = 0; i < num; i++)func();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\ntypedef pair<int,int> P;\n\nconst int kInf = 1 << 28;\nconst string msg[] = {\"SAFE\", \"SUSPICIOUS\"};\nchar m[60][60];\nint H, W;\n\nbool solve() {\n  string s, base;\n  rep(i,H) rep(j,W) if (m[i][j] != '.') s += m[i][j];\n  sort(s.begin(), s.end());\n  s.erase(unique(s.begin(), s.end()), s.end());\n  // printf(\"%s\\n\", s.c_str());\n\n  base = s;\n  vector<P> xs, ys;\n\n  rep(i,s.size()) {\n    int mnx = kInf, mny = kInf, mxx = -1, mxy = -1;\n    rep(j,H) rep(k,W) if (m[j][k] == s[i]) {\n      mnx = min(mnx, k); mxx = max(mxx, k);\n      mny = min(mny, j); mxy = max(mxy, j);\n    }\n    xs.push_back(P(mnx, mxx));\n    ys.push_back(P(mny, mxy));\n  }\n  \n  do {\n    bool ok = true;\n    rep(i,s.size()) {\n      for (int y = ys[i].first; y <= ys[i].second; ++y) {\n        for (int x = xs[i].first; x <= xs[i].second; ++x) {\n          if (base[i] != m[y][x]) {\n            if (s.find(base[i]) < s.find(m[y][x])) ok = false;\n          }\n        }\n      }\n    }\n    if (ok) return false;\n  } while (next_permutation(s.begin(), s.end()));\n  \n  return true;\n}\n\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) {\n    scanf(\"%d%d\", &H, &W);\n    rep(i,H) fscanf(stdin, \"%s\", m[i]);\n    printf(\"%s\\n\", msg[solve()].c_str());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int MAX_S = 51;\nconst int dx[4] = {1,0,-1,0};\nconst int dy[4] = {0,1,0,-1};\nint H, W;\nchar G[MAX_S][MAX_S];\nbool vis[MAX_S][MAX_S];\n\nvoid show() {\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      cout << G[i][j];\n    }\n    cout << endl;\n  }\n}\n\npair<P, P> rec(int x, int y, char c) {\n  vis[y][x] = true;\n  pair<P, P> p = make_pair(P(x, y), P(x, y));\n  for(int i = 0; i < 4; ++i) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(nx < 0 || nx >= W) continue;\n    if(ny < 0 || ny >= H) continue;\n    if(vis[ny][nx]) continue;\n    if(G[ny][nx] != c) continue;\n    pair<P, P> q = rec(nx, ny, c);\n    p.first.first = min(p.first.first, q.first.first);\n    p.first.second = min(p.first.second, q.first.second);\n    p.second.first = max(p.second.first, q.second.first);\n    p.second.second = max(p.second.second, q.second.second);\n  }\n  return p;\n}\n\nvoid make(map<char, pair<P, P> > &m) {\n  for(int i = 0; i < H; ++i) fill(vis[i], vis[i]+W, false);\n\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if(!vis[i][j] && G[i][j] != '.') {\n\tpair<P, P> q = rec(j, i, G[i][j]);\n\t//v.push_back(q);\n\tif(m.find(G[i][j]) == m.end()) {\n\t  m[G[i][j]] = q;\n\t} else {\n\t  pair<P, P> &p = m[G[i][j]];\n\t  p.first.first = min(p.first.first, q.first.first);\n\t  p.first.second = min(p.first.second, q.first.second);\n\t  p.second.first = max(p.second.first, q.second.first);\n\t  p.second.second = max(p.second.second, q.second.second);\n\t}\n      }\n    }\n  }\n}\n\nbool isShikaku(int sx, int sy, int ex, int ey) {\n  char c = 0;\n  for(int i = sy; i <= ey; ++i) {\n    for(int j = sx; j <= ex; ++j) {\n      if(G[i][j] == '.') return false;\n      if(c == 0) {\n\tif(G[i][j] != '#') c = G[i][j];\n      } else if(G[i][j] != c && G[i][j] != '#') {\n\treturn false;\n      }\n    }\n  }\n  return true;\n}\n\nvoid fills(int sx, int sy, int ex, int ey) {\n  for(int i = sy; i <= ey; ++i) {\n    for(int j = sx; j <= ex; ++j) {\n      G[i][j] = '#';\n    }\n  }\n}\n\nbool ans() {\n  vector<pair<P, P> > v;\n  map<char, pair<P, P > > m;\n  make(m);\n  v.clear();\n  for(map<char, pair<P, P> >::iterator it = m.begin(); it != m.end(); ++it) {\n    v.push_back(it->second);\n  }\n  for(;;) {\n    bool flag = true;\n    for(vector<pair<P, P> >::iterator it = v.begin(); it != v.end();) {\n      pair<P, P> p = *it;\n      if(isShikaku(p.first.first, p.first.second,\n\t\t   p.second.first, p.second.second)) {\n\n\tfills(p.first.first, p.first.second,\n\t      p.second.first, p.second.second);\n\n\tit = v.erase(it);\n\tflag = false;\n      } else {\n\t++it;\n      }\n    }\n    if(flag) return v.size() == 0;\n  }\n}\n\nint main() {\n  int T;\n  cin >> T;\n  while(T--) {\n    cin >> H >> W;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tcin >> G[i][j];\n      }\n    }\n    if(ans()) cout << \"SAFE\" << endl;\n    else cout << \"SUSPICIOUS\" << endl;\n    //show();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//15\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int n;\n  cin>>n;\n  while(n--){\n    int t[128],b[128]={},l[128],r[128]={};\n    fill(t,t+128,100);\n    fill(l,l+128,100);\n    int h,w;\n    cin>>h>>w;\n    char g[50][50];\n    for(int y=0;y<h;y++){\n      for(int x=0;x<w;x++){\n\tchar c;\n\tcin>>c;\n\tg[y][x]=c;\n\tt[c]=min(t[c],y);\n\tb[c]=max(b[c],y);\n\tl[c]=min(l[c],x);\n\tr[c]=max(r[c],x);\n      }\n    }\n    bool safe=true;\n    int d[128][128];\n    fill(d[0],d[128],1<<29);\n    for(char c='A';c<='Z';c++){\n      for(int y=t[c];y<=b[c];y++){\n\tfor(int x=l[c];x<=r[c];x++){\n\t  if(g[y][x]=='.'){\n\t    safe=false;\n\t  }else{\n\t    d[c][g[y][x]]=((c==g[y][x])?0:-1);\n\t  }\n\t}\n      }\n    }\n    for(char i='A';i<='Z';i++){\n      for(char j='A';j<='Z';j++){\n\tfor(char k='A';k<='Z';k++){\n\t  d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t}\n      }\n    }\n    for(char i='A';i<='Z';i++){\n      if(d[i][i]<0){\n\tsafe=false;\n      }\n    }\n    cout<<(safe?\"SAFE\":\"SUSPICIOUS\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n#define USE_MATH_DEFINES\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 30;\nconst double EPS = 1E-9;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\n\nint h, w;\nchar field[50][50];\nbool used[50][50];\nbool per[8];\nchar ma[8];\nmap<char, int> mp;\nint c;\n\nbool dfs(int n, int rest){\n\tif(n == 0) {\n\t\treturn rest == 0 ? true : false;\n\t}\n\tbool res = false;\n\tfor(int i = 1; i < c; i++){\n\t\tif(per[i]) continue;\n\t\telse{\n\t\t\tper[i] = true;\n\t\t\tint ymax = 0;\n\t\t\tint ymin = INF;\n\t\t\tint xmax = 0;\n\t\t\tint xmin = INF;\n\t\t\tbool f = true;\n\t\t\tint cnt = 0;\n\t\t\tfor(int j = 0; j < h; j++){\n\t\t\t\tfor(int k = 0; k < w; k++){\n\t\t\t\t\tif(mp[field[j][k]] == i){\n\t\t\t\t\t\tymax = max(ymax, j);\n\t\t\t\t\t\tymin = min(ymin, j);\n\t\t\t\t\t\txmax = max(xmax, k);\n\t\t\t\t\t\txmin = min(xmin, k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = ymin; j <= ymax; j++){\n\t\t\t\tfor(int k = xmin; k <= xmax; k++){\n\t\t\t\t\tif(per[mp[field[j][k]]]){\n\t\t\t\t\t\tif(mp[field[j][k]] == i) cnt++;\n\t\t\t\t\t}else f = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tres |= dfs(n-1, rest - cnt);\n\t\t\t\tper[i] = false;\n\t\t\t}else{\n\t\t\t\tper[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ppii pair<pair<int,int>,pair<int,int>>\nusing namespace std;\n \nint h,w;\nvector<string> s;\n \nvoid removeRect(char c){\n    int minx = 50;\n    int miny = 50;\n    int maxx = 0;\n    int maxy = 0;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(s[i][j]==c){\n                minx = min(minx,j);\n                maxx = max(maxx,j);\n                miny = min(miny,i);\n                maxy = max(maxy,i);\n            }\n        }\n    }\n    bool f = true;\n    for(int i=miny;i<=maxy;i++){\n    \tfor(int j=minx;j<=maxx;j++){\n    \t\tif(s[i][j] != c && s[i][j] != '?') f=false;\n    \t}\n    }\n    //cout << cnt << \" \" << maxx-minx << \" \" << maxy-miny << endl;\n    if(!f)return;\n    for(int i=miny;i<=maxy;i++){\n        for(int j=minx;j<=maxx;j++){\n            s[i][j] = '?';\n        }\n    }\n    return;\n}\n \nbool isEmpty(){\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(s[i][j] != '.' && s[i][j] != '?') return false;\n        }\n    }\n    return true;\n}\n \nvoid show(){\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            cout << s[i][j];\n        }\n        cout << endl;\n    }\n}\n \nint main(){\n    int n;\n    cin >> n;\n    for(int i=0;i<n;i++){\n        s.clear();\n        cin >> h >> w;\n        for(int i=0;i<h;i++){\n            string str;\n            cin >> str;\n            s.emplace_back(str);\n        }\n        int cnt=0;\n        while(!isEmpty() && cnt<=25){\n            char c;\n            for(c='A';c<='Z';c++){\n                //cout << c << endl;\n                removeRect(c);\n                //show();\n            }\n            cnt++;\n        }\n        if(isEmpty()){\n            cout << \"SAFE\" << endl;\n        } else {\n            cout << \"SUSPICIOUS\" << endl;\n        }\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nstring str[60];\nint h,w;\nint num;\nbool flag;\nbool used[55][55];\nchar moji[10];\nint vx[4]={1,0,-1,0};\nint vy[4]={0,1,0,-1};\nvoid dfs(int Bit,int depth){\n  if(Bit==((1<<num)-1)){\n    flag=true;\n    return;\n  }\n\n  for(int i=0;i<num;i++){\n    if(!(Bit&(1<<i))){\n      bool used2[55][55]={};\n      int lemi=100,lema=0,rimi=100,rima=0;\n      for(int j=0;j<h;j++){\n\tfor(int k=0;k<w;k++){\n\t  if(str[j][k]==moji[i]){\n\t    used2[j][k]=true;\n\t    used[j][k]=true;\n\t    lemi=min(lemi,k);\n\t    lema=max(lema,k);\n\t    rima=max(rima,j);\n\t    rimi=min(rimi,j);\n\t  }\n\t}\n      }\n      bool fll=true;\n      //cout<<moji[i]<<\" \"<<lemi<<\" \"<<lema<<\" \"<<rimi<<\" \"<<rima<<endl;\n      for(int j=rimi;j<=rima;j++){\n\tfor(int k=lemi;k<=lema;k++){\n\t  if(!used[j][k]){\n\t    fll=false;\n\t  }\n\t}\n      }\n      if(fll)\n      dfs(Bit+(1<<i),depth+1);\n      for(int j=rimi;j<=rima;j++){\n\tfor(int k=lemi;k<=lema;k++){\n\t  if(used2[j][k]){\n\t    used[j][k]=false;\n\t  }\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int n;cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>h>>w;\n    num=0;\n    for(int i=0;i<55;i++)\n      for(int j=0;j<55;j++)\n\tused[i][j]=false;\n    flag=false;\n    bool alfa[26]={};\n    for(int i=0;i<h;i++){\n      cin>>str[i];\n      for(int j=0;j<w;j++){\n\talfa[str[i][j]-'A']=true;\n      }\n    }\n    int cnt=0;\n    for(int i=0;i<26;i++){\n      num+=alfa[i];\n      if(alfa[i]){\n\tmoji[cnt]=(char)(i+'A');\n\t//cout<<moji[cnt]<<endl;\n\tcnt++;\n      }\n    }\n    dfs(0,0);\n    if(flag)\n      cout<<\"SAFE\"<<endl;\n    else cout<<\"SUSPICIOUS\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\nint mat[7][7];\nbool visited[7];\n\nbool find_cycle(int idx) {\n\tvisited[idx] = true;\n\tfor(int i = 0; i < 7; ++i)\n\t\tif(mat[idx][i] && (visited[i] || find_cycle(i)))\n\t\t\treturn true;\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\twhile(n--) {\n\t\tint h, w;\n\t\tcin >> h >> w;\n\n\t\tvector<string> field(h);\n\t\tmap<char, int> convert;\n\t\tfor(int i = 0; i < h; ++i)\n\t\t\tcin >> field[i];\n\n\t\tvector<int> mx_x(7, -1), mx_y(7, -1), mn_x(7, w), mn_y(7, h);\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tif(field[i][j] == '.')\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif(!convert.count(field[i][j]))\n\t\t\t\t\tconvert.insert(make_pair(field[i][j], convert.size()));\n\n\t\t\t\tconst int idx = convert[field[i][j]];\n\t\t\t\tchmax(mx_x[idx], j);\n\t\t\t\tchmax(mx_y[idx], i);\n\t\t\t\tchmin(mn_x[idx], j);\n\t\t\t\tchmin(mn_y[idx], i);\n\t\t\t}\n\t\t}\n\n\t\tconst int num = (int)convert.size();\n\n\t\tmemset(mat, false, sizeof(mat));\n\t\tFOR(it, convert) {\n\t\t\tconst char target = it->first;\n\t\t\tconst int idx = it->second;\n\t\t\tfor(int i = mn_y[idx]; i <= mx_y[idx]; ++i) {\n\t\t\t\tfor(int j = mn_x[idx]; j <= mx_x[idx]; ++j) {\n\t\t\t\t\tif(field[i][j] == '.')\n\t\t\t\t\t\tgoto ng;\n\n\t\t\t\t\tif(field[i][j] != target)\n\t\t\t\t\t\tmat[convert[field[i][j]]][idx] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(visited, false, sizeof(visited));\n\t\tfor(int i = 0; i < num; ++i)\n\t\t\tif(!visited[i] && find_cycle(i))\n\t\t\t\tgoto ng;\n\n\t\tcout << \"SAFE\" << endl;\n\t\tcontinue;\n\n\tng:;\n\t\tcout << \"SUSPICIOUS\" << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main() {\n\n  long long int t;\n  cin >> t;\n\n  for ( long long int tt = 0; tt < t; tt++ ) {\n\n    long long int h, w;\n    cin >> h >> w;\n\n    vector< string > m;\n\n    long long int min_x[26] = {};\n    long long int max_x[26] = {};\n    long long int min_y[26] = {};\n    long long int max_y[26] = {};\n\n    for ( long long int i = 0; i < 26; i++ ) {\n      min_x[i] = w;\n      max_x[i] = -1;\n      min_y[i] = h;\n      max_y[i] = -1;\n    }\n\n    for ( long long int i = 0; i < h; i++ ) {\n\n      string in;\n      cin >> in;\n      m.push_back( in );\n\n      for ( long long int j = 0; j < w; j++ ) {\n\n\tif ( in[j] == '.' ) continue;\n\tlong long int k = in[j] - 'A';\n\tmin_x[ k ] = min( min_x[k], j );\n\tmax_x[ k ] = max( max_x[k], j );\n\tmin_y[ k ] = min( min_y[k], i );\n\tmax_y[ k ] = max( max_y[k], i );\n\n      }\n\n    }\n\n    bool f = true;\n\n    while( f ) {\n\n      f = false;\n\n      for ( long long int i = 0; i < 26; i++ ) {\n\n\tif ( max_x[i] < 0 ) continue;\n\n\tbool ff = true;\n\n\tfor ( long long int x = min_x[i]; x <= max_x[i]; x++ ) {\n\t  for ( long long int y = min_y[i]; y <= max_y[i]; y++ ) {\n\n\t    if ( m[y][x] != '*' && m[y][x] != 'A' + i ) {\n\t      ff = false;\n\t      break;\n\t    }\n\n\t  }\n\t  if ( ff == false ) break;\n\t}\n\n\tif ( ff == true ) {\n\t  f = true;\n\t  for ( long long int x = min_x[i]; x <= max_x[i]; x++ ) {\n\t    for ( long long int y = min_y[i]; y <= max_y[i]; y++ ) {\n\t      m[y][x] = '*';\n\t    }\n\t  }\n\t  max_x[i] = -1;\n\t}\n\n      }\n\n    }\n\n    string out = \"SAFE\";\n    for ( long long int i = 0; i < 26; i++ ) {\n      if ( max_x[i] >= 0 ) {\n\tout = \"SUSPICIOUS\";\n\tbreak;\n      }\n    }\n    cout << out << endl;\n\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Rect{\n\tint t,b,l,r;\n\tRect(){}\n\tRect(int t,int b,int l,int r):t(t),b(b),l(l),r(r){}\n};\n\nbool solve()\n{\n\tint h,w; cin>>h>>w;\n\tvs grid(h);\n\trep(i,h) cin>>grid[i];\n\t\n\tvi cs(26);\n\tvector<Rect> rs(26,Rect(h,0,w,0));\n\trep(i,h) rep(j,w) if(grid[i][j]!='.'){\n\t\tint c=grid[i][j]-'A';\n\t\tcs[c]=1;\n\t\trs[c].t=min(rs[c].t,i);\n\t\trs[c].b=max(rs[c].b,i+1);\n\t\trs[c].l=min(rs[c].l,j);\n\t\trs[c].r=max(rs[c].r,j+1);\n\t}\n\t\n\tvvi dp(26,vi(26));\n\trep(c,26)\n\t\trepi(i,rs[c].t,rs[c].b) repi(j,rs[c].l,rs[c].r){\n\t\t\tif(grid[i][j]=='.')\n\t\t\t\treturn false;\n\t\t\tif(grid[i][j]!=c+'A')\n\t\t\t\tdp[c][grid[i][j]-'A']=1;\n\t\t}\n\t\n\trep(k,26) rep(i,26) rep(j,26)\n\t\tdp[i][j]|=dp[i][k]&dp[k][j];\n\t\n\trep(i,26) if(dp[i][i])\n\t\treturn false;\n\treturn true;\n}\n\nint main()\n{\n\tint tc; cin>>tc;\n\trep(i,tc)\n\t\tcout<<(solve()?\"SAFE\":\"SUSPICIOUS\")<<endl;;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<map>\n#include<set>\n\nusing namespace std;\nusing ll = long long;\n\nstruct f_e{\n  int y_min = 49, y_max = 0, z_min = 49, z_max = 0;\n};\n\nbool solve(int h, int w, vector<vector<char>>field, map<char, f_e>mp, vector<char>v){\n  for(auto i:v){\n    f_e item = mp[i];\n    for(int y = item.y_min; y <= item.y_max; y++){\n      for(int z = item.z_min; z <= item.z_max; z++){\n        if(field[y][z] == '.') return false;\n        if(field[y][z] == i) field[y][z] = '.';\n      }\n    }\n  }\n  return true;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int ti = clock();\n  // start-----------------------------------------------\n  int n; cin >> n;\n  while(n--){\n    int h, w; cin >> h >> w;\n    vector<vector<char>> field(h, vector<char>(w));\n    map<char, f_e> mp;\n    vector<char> v;\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        cin >> field[i][j];\n        if(field[i][j] == '.') continue;\n        if(mp.find(field[i][j]) == mp.end()) v.push_back(field[i][j]);\n        mp[field[i][j]].y_min = min(mp[field[i][j]].y_min, i);\n        mp[field[i][j]].y_max = max(mp[field[i][j]].y_max, i);\n        mp[field[i][j]].z_min = min(mp[field[i][j]].z_min, j);\n        mp[field[i][j]].z_max = max(mp[field[i][j]].z_max, j);\n      }\n    }\n    sort(v.begin(), v.end());\n    bool f = false;\n    do{\n      if(solve(h, w, field, mp, v)) f = true;\n    }while(next_permutation(v.begin(), v.end()));\n    if(f) cout << \"SAFE\" << endl;\n    else cout << \"SUSPICIOUS\" << endl;\n  }\n  // end-----------------------------------------------\n  // cerr << 1.0 * (clock() - ti) / CLOCKS_PER_SEC << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\ntemplate <typename T>\nvector<int> tpsort_Kahn(const vector< vector< T > > &g) {\n    const int V = g.size();\n    vector<int> indeg(V, 0);\n    stack<int> S;\n\n    rep(i,0,V) rep(j,0,g[i].size())\n        indeg[ g[i][j] ]++;\n    rep(i,0,V) if(indeg[i] == 0) S.push(i);\n\n    vector<int> ans;\n    while(S.size() > 0) {\n        int u = S.top(); S.pop();\n        ans.push_back(u);\n        rep(i,0,g[u].size()) {\n            indeg[ g[u][i] ]--;\n            if(indeg[ g[u][i] ] ==  0)\n                S.push( g[u][i] );\n        }\n    }\n    return ans;\n}\n\nint H, W;\nchar board[60][60];\nint min_x[35], max_x[35], min_y[35], max_y[35];\n\nsigned main() {\n    int DATA; cin >> DATA;\n    while(DATA--) {\n        // initialize\n        fill(min_x, min_x + 35, INF);\n        fill(min_y, min_y + 35, INF);\n\n        fill(max_x, max_x + 35, -1);\n        fill(max_y, max_y + 35, -1);\n\n        cin >> H >> W;\n        rep(i,0,H) rep(j,0,W) {\n            cin >> board[i][j];\n            if(board[i][j] == '.') continue;\n            int alph = board[i][j] - 'A';\n\n            chmin(min_x[alph], i);\n            chmin(min_y[alph], j);\n\n            chmax(max_x[alph], i+1);\n            chmax(max_y[alph], j+1);\n        }\n\n        bool ng = false;\n        vector< vector<int> > G(30);\n        rep(f,0,26) {\n            if(min_x[f] == INF) continue;\n            // printf(\"search: character %c\\n\", (char)('A' + f));\n            // printf(\"debug: min_x = %lld, max_x = %lld, min_y = %lld, max_y = %lld\\n\", min_x[f], max_x[f], min_y[f], max_y[f]);\n            rep(i,min_x[f],max_x[f]) {\n                rep(j,min_y[f],max_y[f]) {\n                    if(board[i][j] == '.') ng = true;\n                    else if(board[i][j] - 'A' != f) {\n                        int v = board[i][j] - 'A';\n                        G[f].push_back(v);\n                    }\n                }\n            }\n        }\n\n        vector<int> ans = tpsort_Kahn(G);\n        if(ans.size() != 30) ng = true;\n\n        cout << (ng ? \"SUSPICIOUS\" : \"SAFE\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;/*{{{*/\n\n#include <iostream>\n#include <map>\n#include <vector>\n\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n/*}}}*/\n\nstruct article {\n\tchar material;\n\tbool is_removed;\n\tint topmost;\n\tint bottommost;\n\tint leftmost;\n\tint rightmost;\n};\n\ntypedef map<char, article> MCA;\n\nVVC image;\nMCA articles;\n\nbool remove_all()\n{\n\tbool all_removed = true;\n\tEACH (articles, itr) {\n\t\tarticle &art = itr->second;\n\t\tif (!art.is_removed) {\n\t\t\tall_removed = false;\n\t\t\t// Remove it and recurse\n\t\t\tVVC save = image;\n\t\t\tbool rect = true;\n\t\t\tFOR (i, art.topmost, art.bottommost + 1) {\n\t\t\t\tFOR (j, art.leftmost, art.rightmost + 1) {\n\t\t\t\t\tif (image[i][j] != '*' && image[i][j] != art.material) {\n\t\t\t\t\t\trect = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\timage[i][j] = '*';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rect) {\n\t\t\t\t// Recurse\n\t\t\t\tart.is_removed = true;\n\t\t\t\tif (remove_all()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Restore and continue trying\n\t\t\tart.is_removed = false;\n\t\t\timage = save;\n\t\t}\n\t}\n\treturn all_removed;\n}\n\nint main()\n{\n\tint t; cin >> t;\n\tREP (_, t) {\n\t\tint h, w; cin >> h >> w;\n\t\timage = VVC(h, VC(w, '.'));\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tcin >> image[i][j];\n\t\t\t}\n\t\t}\n\n\t\t// Scan Image\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tif (image[i][j] != '.') {\n\t\t\t\t\tchar c = image[i][j];\n\t\t\t\t\tif (!EXIST(articles, c)) {\n\t\t\t\t\t\tarticle a = {c, false, h-1, 0, w-1, 0};\n\t\t\t\t\t\tarticles[c] = a;\n\t\t\t\t\t}\n\t\t\t\t\tarticles[c].topmost = min(articles[c].topmost, i);\n\t\t\t\t\tarticles[c].bottommost = max(articles[c].bottommost, i);\n\t\t\t\t\tarticles[c].leftmost = min(articles[c].leftmost, j);\n\t\t\t\t\tarticles[c].rightmost = max(articles[c].rightmost, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (remove_all()) {\n\t\t\tcout << \"SAFE\" << endl;\n\t\t} else {\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define mem(a) memset(a,0,sizeof(a))\n#define pd(a) printf(\"%.10f\\n\",a)\n#define pb(a) push_back(a)\n#define in(a) insert(a)\n#define pi M_PI\n#define R cin>>\n#define F first\n#define S second\n#define C class\n#define ll long long\n#define ln cout<<'\\n'\n#define _(_1,_2,_3,N,...)N\n#define pr(...) _(__VA_ARGS__,pr3,pr2,pr1)(__VA_ARGS__)\ntemplate<C T>void pr1(T a){cout<<a;ln;}\ntemplate<C T,C T2>void pr2(T a,T2 b){cout<<a<<' '<<b;ln;}\ntemplate<C T,C T2,C T3>void pr3(T a,T2 b,T3 c){cout<<a<<' '<<b<<' '<<c;ln;}\ntemplate<C T>void PR(T a,int n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nvoid Main() {\n  int T;\n  R T;\n  while(T--) {\n    int n,m;\n    cin >> n >> m;\n    string s[n];\n    rep(i,n) R s[i];\n    rep(kk,26) {\n      rep(k,26) {\n        char c='A'+k;\n        int x1=MAX,y1=MAX,x2=-1,y2=-1;\n        rep(i,n) {\n          rep(j,m) {\n            if(s[i][j]==c) {\n              x1=min(x1,i);\n              y1=min(y1,j);\n              x2=max(x2,i);\n              y2=max(y2,j);\n            }\n          }\n        }\n        if(x1==MAX) continue;\n        bool f=1;\n        REP(i,x1,x2+1) {\n          REP(j,y1,y2+1) {\n            if(s[i][j]!=c&&s[i][j]!='?') f=0;\n          }\n        }\n        if(f) {\n          REP(i,x1,x2+1) {\n            REP(j,y1,y2+1) s[i][j]='?';\n          }\n        }\n      }\n    }\n    bool ck=1;\n    rep(i,n) {\n      rep(j,m) {\n        if(isalpha(s[i][j])) ck=0;\n      }\n    }\n    if(ck) pr(\"SAFE\");\n    else pr(\"SUSPICIOUS\");\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(0);cin.tie(0);\n  Main();return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <set>\n#include <iomanip>\n#include <stack>\n#include <fstream>\n#include <cstdint>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <functional>\n\nusing namespace std;\n\n\ntypedef int64_t ll;\n\n\nclass rect{\n    static const int inf = 100000;\npublic:\n    int sx, sy; // 始点 左上\n    int ex, ey; // 終点 右下\n    rect() :sx(inf), sy(inf), ex(), ey() {}\n    \n    void modify(const int& i, const int& j){\n        sx = min(i, sx);\n        sy = min(j, sy);\n        \n        ex = max(i, ex);\n        ey = max(j, ey);\n    }\n};\n\nbool is_real_over(char T, map<char, set<char>>& overs, set<char> pre){\n    for (auto && top : overs[T]) {\n        if(pre.count(top) > 0) {\n//            cerr << \"CROSS ERROrR\\n\";\n            return false;\n        }\n        pre.insert(top);\n        if(!is_real_over(top, overs, pre))  return false;\n    }\n    return true;\n\n}\n\n\nbool solve(){\n    int h, w;\n    cin >> h >> w;\n    vector<vector<char>> v;\n    map<char, rect> shapes;\n    for (int i = 0; i < h; ++i) {\n        v.push_back({});\n        for (int j = 0; j < w; ++j) {\n            char tmp;\n            cin >> tmp;\n            v[i].push_back(tmp);\n\n            if(tmp != '.')\n                shapes[tmp].modify(i, j);\n        }\n    }\n\n\n    // 矩形調査 yz\n    map<char, set<char>> overs;\n    for(auto && rec_pair: shapes){\n        auto && rec = rec_pair.second;\n        auto && rec_name = rec_pair.first;\n//        cerr << \"NAME:\" << rec_name << '\\n';\n        for (int i = rec.sx; i <= rec.ex; ++i) {\n            for (int j = rec.sy; j <= rec.ey; ++j) {\n                auto&& this_char = v[i][j];\n                if(this_char != rec_name){\n                    if(this_char == '.'){\n//                        cerr << \"SHAPE MISS\\n\";\n                        return false;\n                    }\n                    overs[rec_name].insert(this_char);\n                }\n            }\n        }\n    }\n//    cerr << \"OVERS::\\n\";\n//    for(auto && m : overs){\n//        cerr << m.first << ':';\n//        for(auto && t : m.second){\n//            cerr << ' ' << t;\n//        }\n//        cerr << '\\n';\n//    }\n\n    // 重なり調査\n    for(auto&& op: overs){\n        if(!is_real_over(op.first, overs, {op.first}))\n            return false;\n    }\n\n\n    return true;\n    \n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        cout << (!solve() ? \"SUSPICIOUS\" : \"SAFE\") << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define Y first\n#define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nstruct Corner{\n\tCorner(char c_) : c(c_) {\n\t\ts = MP(INF, INF);\n\t\te = MP(-1, -1);\n\t}\n\n\tvoid update(PII p) {\n\t\ts.X = min(s.X, p.X);\n\t\ts.Y = min(s.Y, p.Y);\n\t\te.X = max(e.X, p.X);\n\t\te.Y = max(e.Y, p.Y);\n\t}\n\n\tPII s; // ??????\n\tPII e; // ??????\n\tchar c;\n};\n\nconst char DONE = '*';\n\nint H, W;\nVS ts;\nvector<Corner> corners;\nstring types;\n\n// ???????????¶????????????????????¶???\n// ???????????¶???????????£??????????????????\nvoid corner_fill(Corner &corner) {\n\tPII s = corner.s;\n\tPII e = corner.e;\n\tchar c = corner.c;\n\n\tfor (int y = s.Y; y <= e.Y; y++) {\n\t\tfor (int x = s.X; x <= e.X; x++) {\n\t\t\tif (ts[y][x] != c && ts[y][x] != DONE) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t// fill\n\tfor (int y = s.Y; y <= e.Y; y++) {\n\t\tfor (int x = s.X; x <= e.X; x++) {\n\t\t\tts[y][x] = DONE;\n\t\t}\n\t}\n}\n\n// ??????????????????\nbool is_ok() {\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = 0; x < W; x++) {\n\t\t\tif (ts[y][x] != DONE &&\n\t\t\t\tts[y][x] != '.') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid dump() {\n\tcout << \"---------------\" << endl;\n\tfor (auto &line : ts) {\n\t\tcout << line << endl;\n\t}\n\tcout << \"---------------\" << endl << endl;\n}\n\nint main(void) {\n\tint N;\n\tcin >> N;\n\twhile (N--) {\n\t\t// input\n\t\tcin >> H >> W;\n\t\tts = VS(H);\n\t\tcorners = vector<Corner>();\n\t\ttypes = \"\";\n\n\t\tfor (int y = 0; y < H; y++) {\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\tfor (int x = 0; x < W; x++) {\n\t\t\t\tchar t = line[x];\n\t\t\t\tts[y] += t;\n\n\t\t\t\tif (t != '.') {\n\t\t\t\t\tauto num = types.find(t);\n\t\t\t\t\tif (num == string::npos) {\n\t\t\t\t\t\ttypes += t;\n\t\t\t\t\t\tnum = types.size() - 1;\n\t\t\t\t\t\tcorners.PB(Corner(t));\n\t\t\t\t\t}\n\n\t\t\t\t\tcorners[num].update(MP(y,x));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// /input\n\n\t\tfor (int i = 0; i < 7; i++) {\n\t\t\tfor (auto corner : corners) {\n\t\t\t\tcorner_fill(corner);\n\t\t\t}\n\t\t}\n\n//\t\tdump();\n\n\t\tcout << (is_ok() ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\n\tint Q;\n\tcin >> Q;\n\twhile (Q--) {\n\t\tint H, W;\n\t\tcin >> H >> W;\n\t\tvector<string> S(H);\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tcin >> S[i];\n\t\t}\n\t\tvector<char> spec;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (S[i][j] != '.') {\n\t\t\t\t\tspec.push_back(S[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(spec.begin(), spec.end());\n\t\tspec.erase(unique(spec.begin(), spec.end()), spec.end());\n\t\tint C = spec.size();\n\t\tvector<int> lx(C, H), ly(C, W), rx(C, -1), ry(C, -1);\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (S[i][j] != '.') {\n\t\t\t\t\tint val = lower_bound(spec.begin(), spec.end(), S[i][j]) - spec.begin();\n\t\t\t\t\tS[i][j] = char(val + '0');\n\t\t\t\t\tlx[val] = min(lx[val], i);\n\t\t\t\t\tly[val] = min(ly[val], j);\n\t\t\t\t\trx[val] = max(rx[val], i);\n\t\t\t\t\try[val] = max(ry[val], j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<bool> used(C, false);\n\t\tbool able = true;\n\t\tfor (int i = 0; i < C; ++i) {\n\t\t\tint ptr = -1;\n\t\t\tfor (int j = 0; j < C; ++j) {\n\t\t\t\tif (used[j]) continue;\n\t\t\t\tbool flag = true;\n\t\t\t\tfor (int k = lx[j]; k <= rx[j]; ++k) {\n\t\t\t\t\tfor (int l = ly[j]; l <= ry[j]; ++l) {\n\t\t\t\t\t\tif (S[k][l] != '?' && S[k][l] != char(j + '0')) {\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tptr = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ptr == -1) {\n\t\t\t\table = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tused[ptr] = true;\n\t\t\tfor (int j = lx[ptr]; j <= rx[ptr]; ++j) {\n\t\t\t\tfor (int k = ly[ptr]; k <= ry[ptr]; ++k) {\n\t\t\t\t\tS[j][k] = '?';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (able ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint T;\n\t\n\tcin >> T;\n\twhile(T--){\n\t\tint W,H;\n\t\tcin >> H >> W;\n\t\tmap<char,int> x1,x2,y1,y2;\n\t\tvector<string> data(H);\n\t\tfor(int i=0;i<H;i++)\n\t\t\tcin >> data[i];\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tchar c = data[i][j];\n\t\t\t\tif(c != '.'){\n\t\t\t\t\tif(x1.find(c) == x1.end())\n\t\t\t\t\t\tx1[c] = j;\n\t\t\t\t\telse \n\t\t\t\t\t\tx1[c] = min(j,x1[c]);\n\t\t\t\t\tx2[c] = max(j,x2[c]);\n\t\t\t\t\tif(y1.find(c) == y1.end())\n\t\t\t\t\t\ty1[c] = i;\n\t\t\t\t\telse \n\t\t\t\t\t\ty1[c] = min(i,y1[c]);\n\t\t\t\t\t\t\n\t\t\t\t\ty2[c] = max(i,y2[c]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<char> v;\n\t\tfor(map<char,int>::iterator it = x1.begin();it != x1.end();++it)\n\t\t\tv.push_back(it->first);\n\t\tbool safe = false;\n\t\tsort(v.begin(),v.end());\n\t\tdo{\t\n\t\t\tmap<char,int> memo;\n\t\t\tfor(int i=0;i<v.size();i++)\n\t\t\t\tmemo[v[i]] = i;\n\t\t\tbool ok = true;\n\t\t\tfor(int k=0;k<v.size();k++){\n\t\t\t\tfor(int i=y1[v[k]];i<=y2[v[k]];i++){\n\t\t\t\t\tfor(int j=x1[v[k]];j<=x2[v[k]];j++){\n\t\t\t\t\t\tchar c = data[i][j];\n\t\t\t\t\t\tif(c == '.'){ok = false;}\n\t\t\t\t\t\tif(memo[c] < memo[v[k]]){\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tsafe |= ok;\n\t\t}while(next_permutation(v.begin(),v.end()));\n\t\tcout << (safe ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main (void) {\n  int n;\n  cin >> n;\n  while (n--) {\n    int H, W;\n    cin >> H >> W;\n    string HW[51];\n    for (int i=0; i<H; i++) {\n      cin >> HW[i];\n    }\n    bool f=true;\n    while (f) {\n      f=false;\n      vector<char> v;\n      for (int i=0; i<H; i++) {\n        for (int j=0; j<W; j++) {\n          if (HW[i][j]!='.' && HW[i][j]!='?') {\n            v.push_back(HW[i][j]);\n          }\n        }\n      }\n      int r=0, l=W, u=H, d=0; \n      for (int k=0; k<v.size(); k++) {\n        for (int i=0; i<H; i++) {\n          for (int j=0; j<W; j++) {\n            if (HW[i][j]==v[k]) {\n              r=max(r,j);\n              l=min(l,j);\n              u=min(u,i);\n              d=max(d,i);\n            }\n          }\n        }\n        bool e=true;\n        for (int i=u; i<=d; i++) {\n          for (int j=l; j<=r; j++) {\n            if (HW[i][j]!=v[k] && HW[i][j]!='?') {\n              e = false;\n            }\n          }\n        }\n        if (!e) {\n          continue;\n        }\n        f=true;\n        for (int i=u; i<=d; i++) {\n          for (int j=l; j<=r; j++) {\n            HW[i][j]='?';\n          }\n        }\n      }\n    }\n    vector<char> v;\n    for (int i=0; i<H; i++) {\n      for (int j=0; j<W; j++) {\n        if (HW[i][j]!='.' && HW[i][j]!='?') {\n          v.push_back(HW[i][j]);\n        }\n      }\n    }\n    if (v.size()==0) {\n      cout << \"SAFE\" << endl;\n    } else {\n      cout << \"SUSPICIOUS\" << endl;\n    }\n  }\n  return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <map>\n#include <algorithm>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nstruct rect { int ly, ry, lx, rx; };\n\nint T, H, W;\nchar S[55][55];\n\nint main(void) {\n  cin >> T;\n  while(T--) {\n    cin >> H >> W;\n    REP(i, 0, H) cin >> S[i];\n\n    set<char> st;\n    REP(i, 0, H) REP(j, 0, W) if(S[i][j] != '.') st.insert(S[i][j]);\n    map<char, int> ctoi;\n    for(char i : st) ctoi[i] = ctoi.size();\n\n    int a[7];\n    REP(i, 0, 7) a[i] = i;\n\n    int ans = false;\n    do {\n      map<char, rect> p;\n      REP(i, 0, H) REP(j, 0, W) if(S[i][j] != '.') p[S[i][j]] = (rect) { i, i, j, j };\n\n      REP(i, 0, H) REP(j, 0, W) {\n        if(S[i][j] != '.') {\n          p[S[i][j]].ly = min(p[S[i][j]].ly, i);\n          p[S[i][j]].ry = max(p[S[i][j]].ry, i);\n          p[S[i][j]].lx = min(p[S[i][j]].lx, j);\n          p[S[i][j]].rx = max(p[S[i][j]].rx, j);\n        }\n      }\n\n      bool f = true;\n      for(pair<char, rect> r : p) {\n        char c = r.first;\n        rect q = r.second;\n        REP(i, q.ly, q.ry + 1) REP(j, q.lx, q.rx + 1) {\n          if(S[i][j] == '.' || a[ctoi[c]] < a[ctoi[S[i][j]]]) f = false;\n        }\n      }\n      ans = ans || f;\n    } while(next_permutation(a, a + st.size()));\n\n    cout << (ans ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool ans;\n\n// 文字cの出現するx,y座標の最大値と最小値の保持に使う\nstruct range{\n\tint min_x, min_y, max_x, max_y;\n\trange(int min_x_ , int min_y_ , int max_x_ , int max_y_ ){\n\t\tmin_x = min_x_;\n\t\tmin_y = min_y_;\n\t\tmax_x = max_x_;\n\t\tmax_y = max_y_;\n\t}\n};\n\nvoid debug(const vector<string>& m){\n\tcout << \"[debug]\" << endl;\n\tfor(int y=0 ; y < m.size() ; y++ ){\n\t\tcout << m[y] << endl;\n\t}\n\tcout << endl;\n}\n\nvoid debug2(const vector<char>& vc, const vector<range>& vr){\n\tfor(int i=0 ; i < vc.size() ; i++ ){\n\t\trange r = vr[i];\n\t\tcout << vc[i] << \" \" << endl;\n\t\tcout << \"x => [\" << r.min_x << \",\" << r.max_x << \"] \";\n\t\tcout << \"y => [\" << r.min_y << \",\" << r.max_y << \"] \";\n\t\tcout << endl << endl;\n\t}\n}\n\n// 文字 c の出現する x,y 座標の最大値と最小値を求める\nrange search_range(const vector<string>& m, char c){\n\tint min_x = -1, min_y = -1, max_x = -1, max_y = -1;\n\tfor(int y = 0 ; y < m.size() ; y++ ){\n\t\tfor(int x=0 ; x < m[y].size() ; x++ ){\n\t\t\tif( m[y][x] == c ){\n\t\t\t\tmin_x = (min_x == -1)? x : min( min_x , x );\n\t\t\t\tmin_y = (min_y == -1)? y : min( min_y , y );\n\t\t\t\tmax_x = (max_x == -1)? x : max( max_x , x );\n\t\t\t\tmax_y = (max_y == -1)? y : max( max_y , y );\n\t\t\t}\n\t\t}\n\t}\n\trange r( min_x , min_y , max_x , max_y );\n\treturn r;\n}\n\n// 文字 c について長方形かどうか\nbool check(const vector<string>& m, range r, char c){\n\tint cnt = 0;\n\tfor(int y = r.min_y ; y <= r.max_y ; y++ ){\n\t\tfor(int x = r.min_x ; x <= r.max_x ; x++ ){\n\t\t\tif( m[y][x] == c || m[y][x] == '*' ){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//cout << \"search \" << c << \" cnt : \" << cnt << endl;\n\t//cout << \"(\" << r.min_x << \",\" << r.min_y << \") => (\" << r.max_x << \",\" << r.max_y << \")\" << endl; \n\t\n\tif( cnt != (r.max_x - r.min_x + 1) * (r.max_y - r.min_y + 1) ){\n\t\treturn false;\n\t}\n\t\n\tfor(int y = 0 ; y < m.size() ; y++ ){\n\t\tfor(int x = 0 ; x < m[y].size() ; x++ ){\n\t\t\tif( r.min_x <= x && r.min_y <= y && x <= r.max_x && y <= r.max_y ){\n\t\t\t}else if( m[y][x] == c ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\n// 文字 c を' *' に置き換える (荷物を取り除く) \nvoid remove(vector<string>& m, range r, char c){\n\tfor(int y = r.min_y ; y <= r.max_y ; y++ ){\n\t\tfor(int x = r.min_x ; x <= r.max_x ; x++ ){\n\t\t\tif( m[y][x] == c ){\n\t\t\t\tm[y][x] = '*';\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(int id, vector<bool> memo, vector<string> m, vector<char> vc, vector<range> vr){\n\tmemo[id] = true;\n\t\n\t// 長方形かどうか\n\tbool is_rect = check( m , vr[id] , vc[id] );\n\tif( is_rect == false ){\n\t\treturn;\n\t}\n\t\n\t// 文字 vc[id] を '*' に置き換える (荷物を取り除く) \n\tremove( m , vr[id] , vc[id] );\n\t\n\t//cout << vc[id] << \" is rectangle! \" << endl;\n\t//debug( m );\n\t\n\t// すべて調べたかどうか\n\tint cnt = 0;\n\tfor(int i=0 ; i < memo.size() ; i++ ){\n\t\tif( memo[i] )\n\t\t\tcnt++;\n\t}\n\tif( cnt == memo.size() && is_rect ){\n\t\tans = true;\n\t\treturn;\n\t}\n\t\n\tfor(int i=0 ; i < memo.size() ; i++ ){\n\t\tif( memo[i] == false ){\n\t\t\t//cout << \"next : \" << vc[i] << endl;\n\t\t\tdfs( i , memo , m , vc , vr );\n\t\t}\n\t}\n}\n\nvoid solve(const vector<string>& m){\n\tchar ch[256] = {0};\n\tvector<char> vc;\n\tvector<range> vr;\n\tans = false;\n\t\n\t// 出現する文字を調べる\n\tfor(int y=0 ; y < m.size() ; y++ ){\n\t\tfor(int x=0 ; x < m[y].size() ; x++ ){\n\t\t\tif( m[y][x] >= 'A' && m[y][x] <= 'Z' ){\n\t\t\t\tch[ m[y][x] ] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(char c = 'A' ; c <= 'Z' ; c++ ){\n\t\tif( ch[c] )\n\t\t\tvc.push_back( c );\n\t}\n\t\n\t// 文字がなかったら \"SAFE\"\n\tif( vc.size() == 0 ){\n\t\tans = true;\n\t}\n\t\n\t// 各文字 c について x,y 座標の最大値と最小値を求める\n\tfor(int i=0 ; i < vc.size() ; i++ ){\n\t\trange r = search_range( m , vc[i] );\n\t\tvr.push_back( r );\n\t}\n\t//debug2( vc , vr );\n\t\n\t// DFSで重なる順番をすべて調べる\n\tvector<bool> memo( vc.size() );\n\tfor(int k=0 ; k < vc.size() ; k++ ){\n\t\tfor(int i=0 ; i < memo.size() ; i++ ){\n\t\t\tmemo[i] = false;\n\t\t}\n\t\tdfs( k , memo , m , vc , vr );\n\t}\n\t\n}\n\nint main(){\n\tint T;\n\tcin >> T;\n\tfor(int t_ = 0 ; t_ < T ; t_++ ){\n\t\tint w, h;\n\t\tcin >> h >> w;\n\t\t\n\t\tvector<string> m(h);\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> m[y];\n\t\t}\n\t\t\n\t\tsolve( m );\n\t\t\n\t\tif( ans ){\n\t\t\tcout << \"SAFE\" << endl;\n\t\t}else{\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool rectangle(char map[51][51], int left, int right, int up, int down, char now){\n    for(int i=up; i<=down; i++){\n        for(int j=left; j<=right; j++){\n            if(map[i][j]!='*' && map[i][j]!=now)    return false;\n        }\n    }\n    return true;\n}\n\nint main(void){\n    int N;\n    cin >> N;\n    while(N--){\n        int H, W;\n        cin >> H >> W;\n        char field[51][51];\n        for(int i=0; i<H; i++){\n            string s;\n            cin >> s;\n            for(int j=0; j<W; j++){\n                field[i][j]=s[j];\n            }\n        }\n        int left[27], right[27], up[27], down[27];\n        fill(left, left+27, 51);\n        fill(right, right+27, 0);\n        fill(up, up+27, 51);\n        fill(down, down+27, 0);\n        \n        for(int i=0; i<H; i++){\n            for(int j=0; j<W; j++){\n                if('A'<=field[i][j] && field[i][j]<='Z'){\n                    int now=field[i][j]-'A';\n                    left[now]=min(left[now], j);\n                    right[now]=max(right[now], j);\n                    up[now]=min(up[now], i);\n                    down[now]=max(down[now], i);\n                }\n            }\n        }\n        bool tf=true;//長方形のものしかないといえる→trueになる\n        while(true){\n            bool rec=false;\n            for(int i=0; i<H; i++){\n                for(int j=0; j<W; j++){\n                    if('A'<=field[i][j] && field[i][j]<='Z'){\n                        int now=field[i][j]-'A';\n                        if(rectangle(field, left[now], right[now], up[now], down[now], field[i][j])){\n                            rec=true;\n                            for(int i2=up[now]; i2<=down[now]; i2++){\n                                for(int j2=left[now]; j2<=right[now]; j2++){\n                                    field[i2][j2]='*';\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if(!rec)    break;\n        }\n        for(int i=0; i<H; i++){\n            for(int j=0; j<W; j++){\n                if('A'<=field[i][j] && field[i][j]<='Z'){\n                    tf=false;\n                }\n            }\n        }\n        cout << (tf? \"SAFE\":\"SUSPICIOUS\") << \"\\n\";\n        \n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Solve {\nprivate:\n\tint H, W;\n\tstd::vector<std::string> data;\n\tbool is_founded[26]{};\n\n\tbool is_suspicious()\n\t{\n\t\tscanf(\"%d%d\", &H, &W);\n\t\tdata.resize(H);\n\t\tfor (auto& e: data) std::cin >> e;\n\t\twhile (true)\n\t\t{\n\t\t\tif (square_exist()) continue;\n\t\t\treturn alphabet_exist();\n\t\t}\n\t}\n\n\tbool alphabet_exist()\n\t{\n\t\tfor (auto& e: data)\n\t\t\tfor (auto& f: e)\n\t\t\t\tif ('A' <= f && f <= 'Z')\n\t\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tbool square_exist()\n\t{\n\t\tfor (char c{'A'}; c <= 'Z'; c++)\n\t\t\tif (is_square(c))\n\t\t\t{\n\t\t\t\tchange_available(c);\n\t\t\t\treturn true;\n\t\t\t}\n\t\treturn false;\n\t}\n\n\tbool is_square(char c)\n\t{\n\t\tint left{W}, right{-1}, top{H}, bottom{-1};\n\t\tfor (int i{}; i < H; i++)\n\t\t\tfor (int j{}; j < W; j++)\n\t\t\t\tif (data[i][j] == c)\n\t\t\t\t{\n\t\t\t\t\tleft = std::min(left, j);\n\t\t\t\t\tright = std::max(right, j);\n\t\t\t\t\ttop = std::min(top, i);\n\t\t\t\t\tbottom = std::max(bottom, i);\n\t\t\t\t}\n\t\tif (left == W) return false;\n\t\tfor (int i{top}; i <= bottom; i++)\n\t\t\tfor (int j{left}; j <= right; j++)\n\t\t\t\tif (data[i][j] != c && data[i][j] != '?')\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tvoid change_available(char c)\n\t{\n\t\tfor (auto& e: data)\n\t\t\tfor (auto& f: e)\n\t\t\t\tif (f == c)\n\t\t\t\t\tf = '?';\n\t}\npublic:\n\tbool is_last_query{};\n\tSolve()\n\t{\n\t\tif (is_suspicious()) puts(\"SUSPICIOUS\");\n\t\telse puts(\"SAFE\");\n\t}\n};\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i{}; i < n; i++)\n\t\tSolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n \nusing namespace std;\n \nvoid solve(){\n \n    string strs[] = { \"SAFE\", \"SUSPICIOUS\" };\n \n    int h, w;\n    cin >> h >> w;\n \n    vector< string > screen( h );\n    vector< int > maxx( 26, 0 );\n    vector< int > maxy( 26, 0 );\n    vector< int > minx( 26, w );\n    vector< int > miny( 26, h );\n \n    for( int i = 0; i < h; i++ )\n        cin >> screen[ i ];\n     \n    bool fig = true;\n \n    for( int x = 0; x < w; x++ )\n        for( int y = 0; y < h; y++ )\n            if( screen[y][x] != '.' ) {\n                int i = screen[y][x] - 'A';\n                maxx[i] = max( maxx[i], x );\n                minx[i] = min( minx[i], x );\n                maxy[i] = max( maxy[i], y );\n                miny[i] = min( miny[i], y );\n            }\n \n \n    while( fig ) {\n \n        fig = false;\n \n        for( int x = 0; x < w; x++ ) {\n            for( int y = 0; y < h; y++ ) {\n \n                    char ch = screen[ y ][ x ];\n                    if( ch == '.' || ch == '*' ) continue;\n                    int i = ch - 'A';\n \n                    bool fflg = true;\n                    for( int tx = minx[i]; tx <= maxx[i] && fflg; tx ++ )\n                        for( int ty = miny[i]; ty <= maxy[i] && fflg; ty ++ )\n                            fflg &= ( screen[ ty ][ tx ] == ch || screen[ ty ][ tx ] == '*' );\n                     \n                    fig |= fflg;\n                    if( !fflg ) continue;\n \n                    for( int tx = minx[i]; tx <= maxx[i]; tx ++ )\n                        for( int ty = miny[i]; ty <= maxy[i]; ty ++ ) \n                            screen[ ty ][ tx ] = '*';\n \n                }\n            }\n        }\n     \n \n    bool b = false;\n    for( int x = 0; x < w; x++ )\n        for( int y = 0; y < h; y++ )\n            b |= ( screen[ y ][ x ] != '.' && screen[ y ][ x ] != '*' );\n    cout << strs[ b ] << endl;\n \n}\n \nint main( void ) {\n    int n;\n    cin >> n;\n    for( int i = 0; i < n; i++ )\n        solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\nint mat[7][7];\nbool visited[7];\n\nbool find_cycle(int idx) {\n\tvisited[idx] = true;\n\tfor(int i = 0; i < 7; ++i)\n\t\tif(mat[idx][i] && (visited[i] || find_cycle(i)))\n\t\t\treturn true;\n\n\tvisited[idx] = false;\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\twhile(n--) {\n\t\tint h, w;\n\t\tcin >> h >> w;\n\n\t\tvector<string> field(h);\n\t\tmap<char, int> convert;\n\t\tfor(int i = 0; i < h; ++i)\n\t\t\tcin >> field[i];\n\n\t\tvector<int> mx_x(7, -1), mx_y(7, -1), mn_x(7, w), mn_y(7, h);\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tif(field[i][j] == '.')\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif(!convert.count(field[i][j]))\n\t\t\t\t\tconvert.insert(make_pair(field[i][j], convert.size()));\n\n\t\t\t\tconst int idx = convert[field[i][j]];\n\t\t\t\tchmax(mx_x[idx], j);\n\t\t\t\tchmax(mx_y[idx], i);\n\t\t\t\tchmin(mn_x[idx], j);\n\t\t\t\tchmin(mn_y[idx], i);\n\t\t\t}\n\t\t}\n\n\t\tconst int num = (int)convert.size();\n\n\t\tmemset(mat, false, sizeof(mat));\n\t\tFOR(it, convert) {\n\t\t\tconst char target = it->first;\n\t\t\tconst int idx = it->second;\n\t\t\tcout << target << \": \" << idx << endl;\n\t\t\tfor(int i = mn_y[idx]; i <= mx_y[idx]; ++i) {\n\t\t\t\tfor(int j = mn_x[idx]; j <= mx_x[idx]; ++j) {\n\t\t\t\t\tif(field[i][j] == '.')\n\t\t\t\t\t\tgoto ng;\n\n\t\t\t\t\tif(field[i][j] != target)\n\t\t\t\t\t\tmat[convert[field[i][j]]][idx] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tfor(int i = 0; i < num; ++i)\n\t\t\tfor(int j = 0; j < num; ++j)\n\t\t\t\tcout << mat[i][j] << (j + 1 == num ? \"\\n\" : \" \");\n\n\t\tmemset(visited, false, sizeof(visited));\n\t\tfor(int i = 0; i < num; ++i)\n\t\t\tif(find_cycle(i))\n\t\t\t\tgoto ng;\n\n\t\tcout << \"SAFE\" << endl;\n\t\tcontinue;\n\n\tng:;\n\t\tcout << \"SUSPICIOUS\" << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint w, h;\nint sy, sx, gy, gx;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nbool can(int y,int x) {\n\tif(0 <= y && y < h && 0 <= x && x < w) return true;\n\treturn false;\n}\n\nvector<string> s;\nchar c;\nbool used[55][55], visited[55][55];\n\nvoid dfs(int i, int j) {\n\tvisited[i][j] = true;\n\tsy = min(sy, i);\n\tsx = min(sx, j);\n\tgy = max(gy, i);\n\tgx = max(gx, j);\n\n\trep(i, 4) {\n\t\tint y = i + dy[i];\n\t\tint x = j + dx[i];\n\n\t\tif(can(y, x) && !visited[y][x] && s[y][x] == c) {\n\t\t\tdfs(y, x);\n\t\t}\n\t}\n}\n\nbool check() {\n\tREP(i, sy, gy+1){\n\t\tREP(j, sx, gx+1) {\n\t\t\tif(s[i][j] == c || used[i][j]) continue;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid f() {\n\tREP(i, sy, gy+1) {\n\t\tREP(j, sx, gx+1) {\n\t\t\tused[i][j] = true;\n\t\t}\n\t}\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\trep(q, n) {\n\t\tcin >> h >> w;\n\t\ts.resize(h);\n\t\trep(i, h) cin >> s[i];\n\n\t\tmemset(used, 0, sizeof(used));\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tif(used[i][j]) continue;\n\t\t\t\tif(s[i][j] == '.') continue;\n\n\t\t\t\tsy = i;\n\t\t\t\tsx = j;\n\t\t\t\tgy = i;\n\t\t\t\tgx = j;\n\t\t\t\tc = s[i][j];\n\t\t\t\tmemset(visited, 0, sizeof(visited));\n\t\t\t\tdfs(i, j);\n\n\t\t\t\tif(check()) {\n\t\t\t\t\tf();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tif(used[i][j]) continue;\n\t\t\t\tif(s[i][j] == '.') continue;\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\n\t\tif(flag) cout << \"SAFE\" << endl;\n\t\telse cout << \"SUSPICIOUS\" << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma gcc optimize(\"Ofast\")\nusing namespace std;\n\n#define rep(i, a, b) for (int i = a; i < (b); ++i)\n#define trav(a, x) for (auto& a : x)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nstruct Rect {\n\tint lti, ltj, rbi, rbj;\n\tchar color;\n\tconst bool operator<(const Rect& r) const {\n\t\treturn color < r.color;\n\t}\n};\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tint n; cin >> n;\n\tint h, w;\n\tfor (int tt = 0; tt < n; tt++) {\n\t\tcin >> h >> w;\n\t\tvector<string> grid(h);\n\t\trep(i, 0, h) cin >> grid[i];\n\t\tset<char> colors;\n\t\trep(i, 0, h) rep(j, 0, w) if (grid[i][j] != '.') colors.insert(grid[i][j]);\n\t\n\t\tvector<Rect> rects;\n\t\tbool isbad = false;\n\t\tfor (char color : colors) {\n\t\t\tint lti = -1, ltj = -1, rbi = -1, rbj = -1;\n\t\t\trep(i, 0, h) rep(j, 0, w) if (grid[i][j] == color) {\n\t\t\t\tif (lti == -1) lti = rbi = i, ltj = rbj = j;\n\t\t\t\telse {\n\t\t\t\t\tif (i < lti) lti = i;\n\t\t\t\t\tif (j < ltj) ltj = j;\n\t\t\t\t\tif (i > rbi) rbi = i;\n\t\t\t\t\tif (j > rbj) rbj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//printf(\"%c: (%d, %d) - (%d, %d)\\n\", color, lti, ltj, rbi, rbj);\n\t\t\t\n\t\t\tfor (int i = lti; i <= rbi; i++) for (int j = ltj; j <= rbj; j++) if (grid[i][j] == '.') {\n\t\t\t\tisbad = true;\n\t\t\t}\n\t\t\trects.push_back(Rect {lti, ltj, rbi, rbj, color});\n\t\t}\n\n\t\tif (isbad) {\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvector<string> grid2(h, string(w, '.'));\n\t\tbool isgood = false;\n\n\t\tsort(all(rects));\n\t\tdo {\n\t\t\tfor (Rect r : rects) {\n\t\t\t\tfor (int i = r.lti; i <= r.rbi; i++) for (int j = r.ltj; j <= r.rbj; j++)\n\t\t\t\t\tgrid2[i][j] = r.color;\n\t\t\t}\n\t\t\tif (grid2 == grid)\n\t\t\t\tisgood = true;\n\t\t} while (next_permutation(all(rects)));\n\n\t\tcout << (!isgood ? \"SUSPICIOUS\" : \"SAFE\") << '\\n';\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n#define inf 1e9\n\n\nstruct item{\n    int l = inf, r = 0, t = inf, b = 0;\n    void init() {\n        l = inf, r = 0, t = inf, b = 0;\n    }\n};\n\nvector<string> g(50);\nvector<item> a(26);\nvector<int> x;\nbool f;\n\nvoid perm(vector<int> p, int bit, int n) {\n    if (f) return;\n    if (n == x.size()) {\n        bool ff = true;\n        for (int i = 0; i < p.size(); i++) {\n            int ho = x[p[i]];\n            set<int> se;\n            for (int j = i; j < x.size(); j++) se.insert(x[p[j]]);\n            \n            for (int h = a[ho].t; h < a[ho].b + 1; h++) {\n                for (int w = a[ho].l; w < a[ho].r + 1; w++) {\n                    int c = g[h][w]-'A';\n                    set<int>::iterator it = se.find(c);\n                    if (it == se.end()) ff = false;\n                    if (!ff) break;\n                }\n                if (!ff) break;\n            }\n            if (!ff) break;\n        }\n        if (ff) f = true;\n        return ;\n    }\n    \n    for (int i = 0; i < x.size(); i++) {\n        if (bit & 1<<i) continue;\n        vector<int> a = p;\n        a.push_back(i);\n        perm(a, bit | 1<<i, n+1);\n    }\n}\n\n\nint main(void){\n    int n;\n    cin >> n;\n    while (n--) {\n        int h, w;\n        cin >> h >> w;\n        g.clear();\n        x.clear();\n        a.clear();\n        for (int i = 0; i < 26; i++) a[i].init();\n        f = false;\n        for (int i = 0; i < h; i++) {\n            cin >> g[i];\n            for (int j = 0; j < w; j++) if (g[i][j] != '.') {\n                char c = g[i][j];\n                int  t = c - 'A';\n                a[t].l = min(a[t].l, j);\n                a[t].r = max(a[t].r, j);\n                a[t].t = min(a[t].t, i);\n                a[t].b = max(a[t].b, i);\n                t = g[i][j]-'A';\n                x.push_back(t);\n            } \n        }\n        sort(x.begin(), x.end());\n        x.erase(unique(x.begin(), x.end()), x.end());\n        vector<int> t;\n        \n        perm(t,0,0);\n        if (f) cout << \"SAFE\" << endl;\n        else cout << \"SUSPICIOUS\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class F> int ppt(C const& v, F f) {\n    return partition_point(v.begin(), v.end(), f)-v.begin();\n}\n// <<<\n// >>> scc\n\nconstexpr int dst(int v) { return v; }\ntemplate <class E, class = decltype(E().to)>\nconstexpr int dst(E const& e) { return e.to; }\n\ntemplate <class E> struct SCC {\n    vector<vector<E> > const& g;\n    vector<int32_t> ord, low, st;\n    int32_t time = 0, pos = 0, sz = 0;\n    SCC(vector<vector<E> > const& g) : g(g), ord(g.size()), low(g.size()), st(g.size()) {\n        rep (v,g.size()) if (ord[v] == 0) dfs(v);\n        for (auto &x : ord) x += sz;\n    }\n    void dfs(int v) {\n        low[v] = ord[v] = ++time; st[pos++] = v;\n        for (auto const& e : g[v]) {\n            if (ord[dst(e)] == 0) {\n                dfs(dst(e));\n                chmin(low[v], low[dst(e)]);\n            } else if (ord[dst(e)] > 0) {\n                chmin(low[v], ord[dst(e)]);\n            }\n        }\n        if (low[v] == ord[v]) {\n            sz++; do ord[st[--pos]] = -sz; while (st[pos] != v);\n        }\n    }\n\n    // t-sorted id\n    int id(int v) const { return ord[v]; }\n    int size() const { return sz; }\n    vector<vector<int>> groups() const {\n        vector<vector<int> > grp(sz);\n        rep (v,g.size()) grp[ord[v]].push_back(v);\n        return grp;\n    }\n\n    // no multiple edges, no self-loops\n    // no edge information\n    vector<vector<int>> graph() const {\n        vector<vector<int>> ret(size());\n        rep (v,g.size()) {\n            for (auto const& e : g[v]) {\n                int x = id(v), y = id(dst(e));\n                if (x != y) ret[x].push_back(y);\n            }\n        }\n        for (auto &ls : ret) {\n            sort(ls.begin(), ls.end());\n            ls.erase(unique(ls.begin(), ls.end()), ls.end());\n        }\n        return ret;\n    }\n};\ntemplate <class E> auto get_scc(vector<vector<E> > const& g) { return SCC<E>(g); }\n\n// <<<\n\nbool solve() {\n    int h,w; cin >> h >> w;\n    vector<string> s(h); cin >> s;\n\n    vector<vector<int>> g(26);\n    rep (c,26) {\n        int L = INF, R = -1;\n        int U = INF, D = -1;\n        rep (i,h) rep (j,w) if (s[i][j] == 'A'+c) {\n            chmin(L,i);\n            chmax(R,i);\n            chmin(U,j);\n            chmax(D,j);\n        }\n        if (L < 0) continue;\n        set<int> to;\n        loop (i,L,<=R) loop (j,U,<=D) if (s[i][j] != 'A'+c) {\n            if (s[i][j] == '.') return false;\n            to.insert(s[i][j]-'A');\n        }\n        g[c] = {all(to)};\n    }\n\n    return get_scc(g).size() == 26;\n\n}\n\nint32_t main() {\n    int t; cin >> t;\n    while (t--) cout << (solve() ? \"SAFE\" : \"SUSPICIOUS\") << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nstring s[100], t[100];\nsigned main(void)\n{\n\tint n;\n\tcin >> n;\n\tREP(i, n) {\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tREP(j, h) cin >> s[j];\n\n\t\tset<char> st;\n\t\tREP(j, h) REP(k, w) if(s[j][k] != '.') st.insert(s[j][k]);\n\n\t\tvector<char> v;\n\t\tfor(char j: st) v.PB(j);\n\t\tsort(ALL(v));\n\n\t\tbool ans = true;\n\t\tdo {\n\t\t\tREP(j, h) t[j] = s[j];\n\t\t\tans = true;\n\t\t\t//cout << \"v:\"; for(char j: v) cout << j << \" \"; cout << endl;\n\t\t\tREP(j, v.size()) {\n\t\t\t\tll le = INF, r = -INF, u = INF, d = -INF;\n\t\t\t\tREP(k, h) REP(l, w) {\n\t\t\t\t\t//cout << t[k][l] << \" \";\n\t\t\t\t\tif(t[k][l] == v[j]) {\n\t\t\t\t\t\t//cout << \"a\" << endl;\n\t\t\t\t\t\tle = min(le, l);\n\t\t\t\t\t\tr = max(r, l);\n\t\t\t\t\t\tu = min(u, k);\n\t\t\t\t\t\td = max(d, k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//cout << endl;\n\t\t\t\t//cout << v[j] << \" \" << le << \" \" << r << \" \" << u << \" \" << d << endl;\n\t\t\t\tbool flag = true;\n\t\t\t\tFOR(k, u, d+1) {\n\t\t\t\t\tFOR(l, le, r+1) {\n\t\t\t\t\t\t//cout << k << \" \" << l << \" \" << endl;\n\t\t\t\t\t\tif(t[k][l] != v[j] && t[k][l] != '-') {flag = false; break;}\n\t\t\t\t\t}\n\t\t\t\t\tif(!flag) break;\n\t\t\t\t}\n\t\t\t\tif(!flag) {ans = false; break;}\n\t\t\t\tREP(k, h) REP(l, w) if(t[k][l] == v[j]) t[k][l] = '-';\n\t\t\t}\n\t\t\tif(ans) break;\n\t\t} while(next_permutation(ALL(v)));\n\n\t\tif(ans) cout << \"SAFE\" << endl;\n\t\telse cout << \"SUSPICIOUS\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nvoid solve() {\n    int h,w;\n    cin>>h>>w;\n    vector<vector<char>> d(h,vector<char>(w));\n    set<char> st;\n\n    for(int i = 0;i < h;++i) {\n        for(int j = 0;j < w;++j) {\n            cin>>d[i][j];\n            st.insert(d[i][j]);\n        }\n    }\n    st.erase('.');\n    int k=st.size();\n    if(k==0) {\n        cout<<\"SAFE\"<<endl;\n        return;\n    }\n\n    map<char,vector<int>> mp;//left,right,up,down\n    for(auto c:st) {\n        mp[c]={w,-1,h,-1};\n    }\n    for(int i = 0;i < h;++i) {\n        for(int j = 0;j < w;++j) {\n            if(d[i][j]=='.')continue;\n            mp[d[i][j]][0]=min(mp[d[i][j]][0],j);\n            mp[d[i][j]][1]=max(mp[d[i][j]][1],j);\n            mp[d[i][j]][2]=min(mp[d[i][j]][2],i);\n            mp[d[i][j]][3]=max(mp[d[i][j]][3],i);\n        }\n    }\n\n    vector<int> perm(k);\n    for(int i = 0;i < k;++i) {\n        perm[i]=i;\n    }\n\n    map<char,int> ind;\n    {\n        int t=0;\n        for(auto c:st){\n            ind[c]=t;\n            ++t;\n        }\n    }\n    //for(auto i:ind)cout<<i.first<<\" \"<<i.second<<endl;\n\n\n    do{\n        bool ok=true;\n        for(auto dt:mp) {\n            char tc=dt.first;\n            auto v=dt.second;\n            int l=v[0],r=v[1],u=v[2],dw=v[3];\n\n            for(int i = u;i <= dw;++i) {\n                for(int j = l;j <= r;++j) {\n                    if(d[i][j]==tc)continue;\n\n                    if(d[i][j]=='.') {\n                        cout<<\"SUSPICIOUS\"<<endl;\n                        //cout<<\"hoge\"<<endl;\n                        return;\n                    }\n                    if(perm[ind[d[i][j]]]<perm[ind[tc]]) {\n                        ok=false;\n                        goto nx;\n                    }\n                }\n            }\n        }\n        nx:;\n        if(ok) {\n            cout<<\"SAFE\"<<endl;\n            return;\n        }\n    }while(next_permutation(perm.begin(),perm.end()));\n\n    cout<<\"SUSPICIOUS\"<<endl;\n    return;\n}\n\nint main() {\n    int T;\n    cin>>T;\n    for(int TestSet = 0;TestSet < T;++TestSet) {\n        solve();\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\nchar **data;\nchar **datab;\nchar done[7];\nint donen;\nint h,w;\n\nint r(char);\nint inc(char);\nvoid sear(char,int*,int*,int*,int*);\n\nint main(){\n\tint n;\n\tint i,j;\n\tchar s[50];\n\tchar *ps;\n\tint size;\n\tint error;\n\tfgets(s,sizeof(s),stdin);\n\tsize=atoi(s);\n\tfor(n=0;n<size;n++){\n\t\tfgets(s,sizeof(s),stdin);\n\t\tps=strtok(s,\" \");\n\t\th=atoi(ps);\n\t\tps=strtok(NULL,\" \");\n\t\tw=atoi(ps);\n\n\t\tdata=new char*[h];\n\t\tdatab=new char*[h];\n\t\tfor(i=0;i<h;i++){\n\t\t\tdata[i]=new char[w];\n\t\t\tdatab[i]=new char[w];\n\t\t\tfgets(s,sizeof(s),stdin);\n\t\t\tmemcpy(data[i],s,w);\n\t\t\tmemcpy(datab[i],s,w);\n\t\t}\n\t\tmemset(done,0,sizeof(done));\n\t\tdonen=0;\n\t\terror=0;\n\t\tfor(i=0;i<h;i++){\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tif(data[i][j]!='.' && data[i][j]!=' '){\n\t\t\t\t\tif(r(data[i][j])==1){\n\t\t\t\t\t\terror=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}/*\n\t\t\t\t\tfor(int k=0;k<h;k++){\n\t\t\t\t\t\tfor(int l=0;l<w;l++){\n\t\t\t\t\t\t\tif(data[k][l]==' ') data[k][l]='.';\n\t\t\t\t\t\t}\n\t\t\t\t\t}*/\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(error==1) break;\n\t\t}\n\t\tif(error==0) cout<<\"SAFE\"<<endl;\n\t\telse cout<<\"SUSPICIOUS\"<<endl;\n\t\tfor(i=0;i<h;i++) delete []data[i];\n\t\tdelete []data;\n\t}\n\treturn 0;\n}\n\nint r(char c){\n\tint i,j;\n\tint x1,x2,y1,y2;\n\tsear(c,&x1,&y1,&x2,&y2);\n\tfor(i=y1;i<=y2;i++){\n\t\tfor(j=x1;j<=x2;j++){\n\t\t\t//if(data[i][j]==c) data[i][j]=' ';\n\t\t\tif(data[i][j]=='.') return 1;\n\t\t\telse if(inc(data[i][j])==1) return 1;\n\t\t}\n\t}\n\tdone[donen++]=c;\n\tfor(i=y1;i<=y2;i++){\n\t\tfor(j=x1;j<=x2;j++){\n\t\t\tif(data[i][j]!=c &&data[i][j]!=' '){\n\t\t\t\tif(r(datab[i][j])==1) return 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=y1;i<=y2;i++){\n\t\tfor(j=x1;j<=x2;j++){\n\t\t\tif(data[i][j]==c) data[i][j]=' ';\n\t\t}\n\t}\n\treturn 0;\n}\n\nint inc(char c){\n\tfor(int i=0;i<donen;i++) if(done[i]==c) return 1;\n\treturn 0;\n}\n\nvoid sear(char c,int *x1,int *y1,int *x2,int *y2){\n\tint i,j;\n\t*x1=*x2=*y1=*y2=-1;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(data[i][j]==c){\n\t\t\t\t*y1=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(*y1!=-1) break;\n\t}\n\tfor(i=h-1;i>=0;i--){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(data[i][j]==c){\n\t\t\t\t*y2=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(*y2!=-1) break;\n\t}\n\tfor(i=0;i<w;i++){\n\t\tfor(j=0;j<h;j++){\n\t\t\tif(data[j][i]==c){\n\t\t\t\t*x1=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(*x1!=-1) break;\n\t}\n\tfor(i=w-1;i>=0;i--){\n\t\tfor(j=0;j<h;j++){\n\t\t\tif(data[j][i]==c){\n\t\t\t\t*x2=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(*x2!=-1) break;\n\t}\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \nvoid chmin(int& x, int y)\n{\n  x = min(x, y);\n}\nvoid chmax(int& x, int y)\n{\n  x = max(x, y);\n}\n  \nint main()\n{\n  int Q, H, W;\n  string S[50];\n  int proc = 1;\n  int used[50][50] = {{}};\n  \n  cin >> Q;\n  while(Q--) {\n    cin >> H >> W;\n  \n    string chars = \"\";\n    for(int i = 0; i < H; i++) {\n      cin >> S[i];\n      chars += S[i];\n    }\n    sort(chars.begin(), chars.end());\n    chars.erase(unique(chars.begin(), chars.end()), chars.end());\n    vector< int > x1(chars.size(), W), x2(chars.size(), 0);\n    vector< int > y1(chars.size(), H), y2(chars.size(), 0);\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        int pos = chars.find(S[i][j]);\n        chmin(x1[pos], j);\n        chmax(x2[pos], j);\n        chmin(y1[pos], i);\n        chmax(y2[pos], i);\n      }\n    }\n    int xx1[128], xx2[128], yy1[128], yy2[128];\n    for(int i = 0; i < chars.size(); i++) {\n      xx1[chars[i]] = x1[i];\n      xx2[chars[i]] = x2[i];\n      yy1[chars[i]] = y1[i];\n      yy2[chars[i]] = y2[i];\n    }\n  \n    bool Judge = chars.size() == 1;\n    do {\n      if(chars[chars.size() - 1] != '.') continue;\n      Judge = true;\n      for(int i = 0; i < chars.size(); i++) {\n        for(int j = xx1[chars[i]]; j <= xx2[chars[i]]; j++) {\n          for(int k = yy1[chars[i]]; k <= yy2[chars[i]]; k++) {\n            if(used[j][k] == proc) continue;\n            used[j][k] = proc;\n            if(S[k][j] != chars[i]) {\n              Judge = false;\n              goto myon;\n            }\n          }\n        }\n      }\n    myon: ;\n      ++proc;\n    } while(!Judge && next_permutation(chars.begin(), chars.end()));\n    if(Judge) cout << \"SAFE\" << endl;\n    else cout << \"SUSPICIOUS\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nint main(){\n  int n; cin>>n;\n  while(n --> 0){\n    int w,h; cin>>h>>w;\n    char buff[h][w+1];\n    bool ans = true;\n    REP(i,h) cin>>buff[i];\n    for(char c = 'A'; c <= 'Z'; c++){\n      int cnt = 0;\n      int maxx = 0, maxy = 0;\n      int minx = w, miny = h;\n      REP(i,h) REP(j,w){\n        if(buff[i][j] == c){\n          cnt++;\n          maxx = max(maxx, j);\n          maxy = max(maxy, i);\n          minx = min(minx, j);\n          miny = min(miny, i);\n        }\n      }\n      if(cnt == 0) continue;\n      //printf(\"%c: (%d,%d) => (%d,%d)\\n\",c,minx,miny,maxx,maxy);\n      for(int i = miny; i<=maxy; i++){\n        for(int j = minx; j<=maxx; j++){\n          if(buff[i][j] == '.')\n            ans = false;\n        }\n      }\n      if(!ans) break;\n    }\n    puts(ans?\"SAFE\":\"SUSPICIOUS\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stdio.h>\n\nusing namespace std;\n\nvoid solve(){\n\n\tstring strs[] = { \"SAFE\", \"SUSPICIOUS\" };\n\n\tint h, w;\n\tcin >> h >> w;\n\n\tvector< string > screen( h );\n\tvector< int > maxx( 26, 0 );\n\tvector< int > maxy( 26, 0 );\n\tvector< int > minx( 26, w );\n\tvector< int > miny( 26, h );\n\n\tfor( int i = 0; i < h; i++ )\n\t\tcin >> screen[ i ];\n\t\n\tbool fig = true;\n\n\tfor( int x = 0; x < w; x++ )\n\t\tfor( int y = 0; y < h; y++ )\n\t\t\tif( screen[y][x] != '.' ) {\n\t\t\t\tint i = screen[y][x] - 'A';\n\t\t\t\tmaxx[i] = max( maxx[i], x );\n\t\t\t\tminx[i] = min( minx[i], x );\n\t\t\t\tmaxy[i] = max( maxy[i], y );\n\t\t\t\tminy[i] = min( miny[i], y );\n\t\t\t}\n\n\n\twhile( fig ) {\n\n\t\tfig = false;\n\n\t\tfor( int x = 0; x < w; x++ ) {\n\t\t\tfor( int y = 0; y < h; y++ ) {\n\n\t\t\t\t\tchar ch = screen[ y ][ x ];\n\t\t\t\t\tif( ch == '.' || ch == '*' ) continue;\n\t\t\t\t\tint i = ch - 'A';\n\n\t\t\t\t\tbool fflg = true;\n\t\t\t\t\tfor( int tx = minx[i]; tx <= maxx[i] && fflg; tx ++ )\n\t\t\t\t\t\tfor( int ty = miny[i]; ty <= maxy[i] && fflg; ty ++ )\n\t\t\t\t\t\t\tfflg &= ( screen[ ty ][ tx ] == ch || screen[ ty ][ tx ] == '*' );\n\t\t\t\t\t\n\t\t\t\t\tfig |= fflg;\n\t\t\t\t\tif( !fflg ) continue;\n\n\t\t\t\t\tfor( int tx = minx[i]; tx <= maxx[i]; tx ++ )\n\t\t\t\t\t\tfor( int ty = miny[i]; ty <= maxy[i]; ty ++ ) \n\t\t\t\t\t\t\tscreen[ ty ][ tx ] = '*';\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\n\tbool b = false;\n\tfor( int x = 0; x < w; x++ )\n\t\tfor( int y = 0; y < h; y++ )\n\t\t\tb |= ( screen[ y ][ x ] != '.' && screen[ y ][ x ] != '*' );\n\tcout << strs[ b ] << endl;\n\n}\n\nint main( void ) {\n\tint n;\n\tcin >> n;\n\tfor( int i = 0; i < n; i++ )\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//tempaa\n//#pragma GCC optimize (\"-O3\")\n#ifdef _DEBUG\n#include<cassert>\n#include \"bits_stdc++.h\"\n#else\n#include <bits/stdc++.h>\n#endif\n\n#define r_ return\n#define v_ vector\n#define t_T template<class T>\n\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} __initon;\n//衝突対策\n#define ws ___ws\n#define over4(o1, o2, o3, o4, name, ...) name\n\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define vec v_\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\nusing vi = v_<ll>;\nusing vb = v_<bool>;\nusing vs = v_<string>;\nusing vd = v_<double>;\nusing vc = v_<char>;\nusing vp = v_<P>;\n\n//#define V v_\n#define vvt0(t) v_<v_<t>>\n#define vvt1(t, a) v_<v_<t>>a\n#define vvt2(t, a, b) v_<v_<t>>a(b)\n#define vvt3(t, a, b, c) v_<v_<t>> a(b,v_<t>(c))\n#define vvt4(t, a, b, c, d) v_<v_<t>> a(b,v_<t>(c,d))\n\n#define vvi(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(ll,__VA_ARGS__)\n#define vvb(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(bool,__VA_ARGS__)\n#define vvs(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(string,__VA_ARGS__)\n#define vvd(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(double,__VA_ARGS__)\n#define vvc(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(char,__VA_ARGS__)\n#define vvp(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(P,__VA_ARGS__)\n\n\n#define v3i(a, b, c, d) v_<v_<vi>> a(b, v_<vi>(c, vi(d)))\n#define v3d(a, b, c, d) v_<v_<vd>> a(b, v_<vd>(c, vd(d)))\n#define v3m(a, b, c, d) v_<v_<vm>> a(b, v_<vm>(c, vm(d)))\n\n\n#define PQ priority_queue<ll, v_<ll>, greater<ll> >\n#define tos to_string\n\nusing mapi = map<int, int>;\nusing mapd = map<dou, int>;\nusing mapc = map<char, int>;\nusing maps = map<str, int>;\nusing seti = set<int>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<int>;\n#define bset bitset\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define umapi unordered_map<int,int>\n#define umapp unordered_map<P,int>\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, _4, name, ...) name\n# define _rep(i, n) for(int i = 0,_lim=n; i < _lim ; i++)\n#define repi(i, m, n) for(int i = m,_lim=n; i < _lim ; i++)\n#define repadd(i, m, n, ad) for(int i = m,_lim=n; i < _lim ; i+= ad)\n#define rep(...) _overloadrep(__VA_ARGS__,repadd,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m,_lim=n; i >= _lim ; i--)\n#define rerdec(i, m, n, dec) for(int i = m,_lim=n; i >= _lim ; i-=dec)\n#define rer(...) _overloadrep(__VA_ARGS__,rerdec,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\n\nt_T T MAX() { r_ numeric_limits<T>::max(); }\nt_T T MIN() { r_ numeric_limits<T>::min(); }\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nt_T T INF() { r_ MAX<T>() / 2; }\ntemplate<> signed INF() { r_ inf; }\ntemplate<> ll INF() { r_ linf; }\ntemplate<> double INF() { r_ (double) linf * linf; }\n\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define sz(a) ((int)(a).size())\n#define rs resize\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n/*@formatter:off*/\ninline void sort(string &a) { sort(all(a)); }\nt_T inline void sort(v_<T> &a) { sort(all(a)); };\nt_T inline void rsort(v_<T> &a) { sort(all(a), greater<T>()); };\ntemplate<class U> inline void sortp(v_<U> &a, v_<U> &b) {    vp c;    int n = sz(a);    assert(n == sz(b));    rep(i, n)c.eb(a[i], b[i]);    sort(c);    rep(i, n) {        a[i] = c[i].first;        b[i] = c[i].second;;    }};//F = T<T>\n//例えばr_ p.fi + p.se;\ntemplate<class U> inline void rsortp(v_<U> &a, v_<U> &b) {    vp c;    int n = sz(a);    assert(n == sz(b));    rep(i, n)c.eb(a[i], b[i]);    rsort(c);    rep(i, n) {        a[i] = c[i].first;        b[i] = c[i].second;    }};\ntemplate<typename V, typename T>\nvoid fill(V &xx, const T vall) {xx = vall;}\ntemplate<typename V, typename T>\nvoid fill(v_<V> &vecc, const T vall) {for (auto &&vx: vecc) fill(vx, vall);}\n\n//@汎用便利関数 入力\ntemplate<typename T = int> T _in() {T x;cin >> x;r_ (x);}\n#define _overloadin(_1, _2, _3, _4, name, ...) name\n#define in0() _in()\n#define in1(a) cin>>a\n#define in2(a, b) cin>>a>>b\n#define in3(a, b, c) cin>>a>>b>>c\n#define in4(a, b, c, d) cin>>a>>b>>c>>d\n#define in(...) _overloadin(__VA_ARGS__,in4,in3,in2 ,in1,in0)(__VA_ARGS__)\n\n#define _overloaddin(_1, _2, _3, _4, name, ...) name\n#define din1(a) int a;cin>>a\n#define din2(a, b) int a,b;cin>>a>>b\n#define din3(a, b, c) int a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d\n#define din(...) _overloadin(__VA_ARGS__,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define _overloaddind(_1, _2, _3, _4, name, ...) name\n#define din1d(a) int a;cin>>a;a--\n#define din2d(a, b) int a,b;cin>>a>>b;a--,b--\n#define din3d(a, b, c) int a,b,c;cin>>a>>b>>c;a--,b--,c--\n#define din4d(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d;;a--,b--,c--,d--\n#define dind(...) _overloaddind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\ntemplate<typename W, typename H> void resize(W &vec_, const H head) { vec_.resize(head); }\ntemplate<typename W, typename H, typename ... T> void resize(W &vec_, const H &head, const T ... tail) {vec_.resize(head);for (auto &v: vec_)resize(v, tail...);}\n\n\nstring sin() { r_ _in<string>(); }\nll lin() { r_ _in<ll>(); }\nt_T void na(v_<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i];}\n#define dna(a, n) vi a; na(a, n);/*nを複数使うと n==in()の時バグる事に注意*/\n#define dnad(a, n) vi a; nad(a, n);\nt_T void nad(v_<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i], a[i]--;}\ntemplate<class T, class U> void na2(v_<T> &a, v_<U> &b, ll n) {a.resize(n);b.resize(n);rep(i, n)cin >> a[i] >> b[i];}\n#define dna2(a, b, n) vi a,b; na2(a,b,n);\ntemplate<class T, class U, class W> void na3(v_<T> &a, v_<U> &b, v_<W> &c, ll n) {a.resize(n);b.resize(n);c.resize(n);rep(i, n)cin >> a[i] >> b[i] >> c[i];}\n#define nt(a, h, w) resize(a,h,w);rep(nthi,h)rep(ntwi,w) cin >> a[nthi][ntwi];\n#define ntd(a, h, w) resize(a,h,w);rep(ntdhi,h)rep(ntdwi,w) cin >> a[ntdhi][ntdwi], a[ntdhi][ntdwi]--;\n#define ntp(a, h, w) resize(a,h+2,w+2);fill(a,'#');rep(ntphi,1,h+1)rep(ntpwi,1,w+1) cin >> a[ntphi][ntpwi];\n#define dnt(S, h, w) vvi(S,h,w);nt(S,h,w);\n#define dntc(S, h, w) vvc(S,h,w);nt(S,h,w);\n#define dnts(S, h, w) vvs(S,h,w);nt(S,h,w);\n\n//デバッグ\n#define sp << \" \" <<\nt_T string out_m2(v_<T> &a, ll W = inf) {    stringstream ss;    if (W == inf)W = min(sz(a), 20ll);    if (sz(a) == 0)r_ ss.str();    rep(i, W) {        ss << a[i];        if (typeid(a[i]) == typeid(P)) { ss << endl; } else { ss << \" \"; }    }    r_ ss.str();}\nt_T string out_m2(v_<v_<T> > &a, vi H, vi W, int key = -1) {    stringstream ss;    ss << endl;    vi lens(sz(W));    fora(h, H) {        rep(wi, sz(W)) {            auto v = a[h][W[wi]];            str s;            if(is_same<decltype(v), char>::value)s+=v;            else s = tos(v);            if (abs(v) == inf || abs(v) == INF<T>())s = \"e\";            lens[wi] = max(lens[wi], sz(s) + 1);            lens[wi] = max(lens[wi], sz(tos(W[wi])) + 1);        }    }    if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";    int wi = 0;    fora(w, W) {        ss << std::right << std::setw(lens[wi]) << w;        wi++;    }    ss << \"\" << endl;    rep(i, sz(W))rep(_, lens[i]) ss << \"_\";    rep(i, 3)ss << \"_\";    ss << \"\" << endl;    fora(h, H) {        ss << std::right << std::setw(2) << h << \"|\";        int wi = 0;        fora(w, W) {            auto v = a[h][w];            str s;            if(is_same<decltype(v), char>::value)s+=v;            else s = tos(v);            if (abs(a[h][w]) == inf || abs(a[h][w]) == INF<T>())s = \"e\";            ss << std::right << std::setw(lens[wi]) << s;            wi++;        }        ss << \"\" << endl;    }    r_ ss.str();}\nt_T string out_m2(v_<v_<T> > &a, ll H = inf, ll W = inf, int key = -1) {    H = (H != inf) ? H : min({H, sz(a), 12ll});    W = min({W, sz(a[0]), 12ll});    vi hs, ws;    rep(h, H) { hs.push_back(h); }    rep(w, W) { ws.push_back(w); }    r_ out_m2(a, hs, ws, key);}\nt_T string out_m2(v_<v_<v_<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {    stringstream ss;    if (H == inf)H = 12;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << out_m2(a[i], W, U, i);    }    r_ ss.str();}\nstring out_m2(int a) {    stringstream ss;    ss << a;    r_ ss.str();}\nt_T string out_m2(T &a) {    stringstream ss;    ss << a;    r_ ss.str();}\n\n#define debugName(VariableName) # VariableName\n\n#define _deb1(x) cerr <<  debugName(x)<<\" = \"<<out_m2(x) << endl\n#define _deb2(x, y) cerr <<  debugName(x)<<\" = \"<<out_m2(x)<<\", \"<< debugName(y)<<\" = \"<<out_m2(y)<< endl\n#define _deb3(x, y, z) cerr <<  debugName(x)<<\" = \"<<out_m2(x)  << \", \" <<  debugName(y)<<\" = \"<<out_m2(y) <<\", \" debugName(z)<<\" = \"<<out_m2(z) <<endl\n#define _deb4(x, y, z, a) cerr <<  debugName(x)<<\" = \"<<out_m2(x) <<\", \" <<   debugName(y)<<\" = \"<<out_m2(y) <<\", \" <<  debugName(z)<<\" = \"<<out_m2(z) <<\", \" <<  debugName(a)<<\" = \"<<out_m2(a)<<endl\n#define _deb5(x, y, z, a, b) cerr <<  debugName(x)<<\" = \"<<out_m2(x) <<\", \" <<   debugName(y)<<\" = \"<<out_m2(y) <<\", \" <<  debugName(z)<<\" = \"<<out_m2(z) <<\", \" <<  debugName(a)<<\" = \"<<out_m2(a)<<\", \" <<  debugName(b)<<\" = \"<<out_m2(b)<<endl\n\n\n#define _overloadebug(_1, _2, _3, _4, _5, name, ...) name\n#define debug(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#ifdef _DEBUG\n#define deb(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#else\n#define deb(...) ;\n#endif\n\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n\nll gcd(ll a, ll b) { r_ b ? gcd(b, a % b) : a; }\nll gcd(vi b) {ll res = b[0];for (auto &&v :b)res = gcd(v, res);r_ res;}\nll lcm(ll a, ll b) { r_ a / gcd(a, b) * b; }\nll rev(ll a) {    ll res = 0;    while (a) {        res *= 10;        res += a % 10;        a /= 10;    }    r_ res;}\nt_T v_<T> rev(v_<T> &a) {    auto b = a;    reverse(all(b));    r_ b;}\nstr rev(str &a) {str s = a;reverse(all(s));r_ s;}\nll ceil(ll a, ll b) {if (b == 0) {cerr<<\"ceil\"<<endl;exit(1);r_ -1;} else r_ (a + b - 1) / b;}\nll sqrt(ll a) {    if (a < 0) {        cerr<<\"sqrt\"<<endl;        exit(1);    }    ll res = (ll) std::sqrt(a);    while (res * res < a)res++;    r_ res;}\ndouble log(double e, double x) { r_ log(x) / log(e); }\nll sig(ll t) { r_ (1 + t) * t / 2; }\nll sig(ll s, ll t) { r_ (s + t) * (t - s + 1) / 2; }\n\nvi divisors(int v) {    vi res;    double lim = std::sqrt(v);    rep(i, 1, lim+1){        if (v % i == 0) {            res.pb(i);            if (i != v / i)res.pb(v / i);        }    }    r_ res;}\nvb isPrime;\nvi primes;\n\nvoid setPrime() {    int len = 4010101;    isPrime.resize(4010101);    fill(isPrime, true);    isPrime[0] = isPrime[1] = false;    for (int i = 2; i <= sqrt(len) + 5; ++i) {        if (!isPrime[i])continue;        for (int j = 2; i * j < len; ++j) {            isPrime[i * j] = false;        }    }    rep(i, len)if (isPrime[i])primes.pb(i);}\n\nvi factorization(int v) {    int tv = v;    vi res;    if (isPrime.size() == 0)setPrime();    for (auto &&p :primes) {        if (v % p == 0)res.push_back(p);        while (v % p == 0) {            v /= p;        }        if (v == 1 || p * p > tv)break;    }    if (v > 1)res.pb(v);    r_ res;}\ninline bool inside(int h, int w, int H, int W) { r_ h >= 0 && w >= 0 && h < H && w < W; }\ninline bool inside(int v, int l, int r) { r_ l <= v && v < r; }\n\n\nt_T v_<T> ruiv(v_<T> &a) {    v_<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i];    r_ ret;}\n//imoは0-indexed\n//ruiは1-indexed\nt_T v_<T> imo(v_<T> &v) {    v_<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    r_ ret;}\n\n#define ins inside\nll u0(ll a) { r_ a < 0 ? 0 : a; }\nt_T v_<T> u(const v_<T> &a) {\n    v_<T> ret = a;fora(v, ret)v = u0(v);r_ ret;}\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\n\nvoid yn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n}\nvoid Yn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}\nvoid YN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\nvoid fyn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n    exit(0);\n}\nvoid fYn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    exit(0);\n}\nvoid fYN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    exit(0);\n}\nvoid Possible(bool a) {\n    if (a)cout << \"Possible\" << endl;\n    else cout << \"Impossible\" << endl;\n    exit(0);\n}\nvoid POSSIBLE(bool a) {\n    if (a)cout << \"POSSIBLE\" << endl;\n    else cout << \"IMPOSSIBLE\" << endl;\n    exit(0);\n}\ntemplate<class T, class U> set<T> &operator+=(set<T> &a, U v) {\n    a.insert(v);\n    r_ a;\n}\ntemplate<class T, class U> v_<T> &operator+=(v_<T> &a, U v) {\n    a.push_back(v);\n    r_ a;\n}\ntemplate<class T> v_<T>& operator+=(v_<T> & a,const v_<T> & b){\n    fora(v, b)a += v;\n    return a;\n}\nt_T T sum(v_<T> &v, int s = 0, int t = inf) {    T ret = 0;    rep(i, s, min(sz(v), t))ret += v[i];    r_ ret;}\nvoid mod(int &a, int m) { a = (a % m + m) % m; }\ntemplate<class F> inline int mgr(int ok, int ng, F f) {\n#define _mgrbody int mid = (ok + ng) / 2; if (f(mid))ok = mid; else ng = mid;\n    if (ok < ng)while (ng - ok > 1) { _mgrbody } else while (ok - ng > 1) { _mgrbody }\n    r_ ok;\n}\n\ntemplate<class F> inline int mgr(int ok, int ng, int second, F f) {\n#define _mgrbody2 int mid = (ok + ng) / 2; if (f(mid, second))ok = mid; else ng = mid;\n    if (ok < ng) while (ng - ok > 1) { _mgrbody2 } else while (ok - ng > 1) { _mgrbody2 }\n    r_ ok;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, v_<T> &m) {    rep(i, sz(m)){os << m[i];if(i < sz(m)-1)os<<\" \";}   r_ os;}\nostream &operator<<(ostream &os, v_<char> &m) {rep(i, sz(m)){os << m[i];}   r_ os;}\ntemplate<typename T> ostream &operator<<(ostream &os, v_<v_<T>> &m) {rep(i, sz(m)){os << m[i]; if(i < sz(m)-1)os << endl;}   r_ os;}\nconstexpr bool bget(ll m, int keta) { r_ (m >> keta) & 1; }\nint bget(ll m, int keta, int sinsuu) {m /= (ll) pow(sinsuu, keta);r_ m % sinsuu;}\nll bit(int n) { r_ (1LL << (n)); }\nll bit(int n, int sinsuu) { r_ (ll) pow(sinsuu, n); }\nint mask(int n) { r_ (1ll << n) - 1; }\n#define bcou __builtin_popcountll\ntemplate<class T, class U> inline bool chma(T &a, const U &b) {if (a < b) {a = b;r_ true;}r_ false;}\ntemplate<class U> inline bool chma(const U &b) { r_ chma(ma, b); }\ntemplate<class T, class U> inline bool chmi(T &a, const U &b) {    if (b < a) {        a = b;        r_ true;    }    r_ false;}\ntemplate<class U> inline bool chmi(const U &b) { r_ chmi(mi, b); }\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\nint max(vi &a) {    int res = a[0];    fora(v, a) {        res = max(res, v);    }    r_ res;}\nint min(vi &a) {    int res = a[0];    fora(v, a) {        res = min(res, v);    }    r_ res;}\ntemplate<typename T> class fixed_point        : T {public:    explicit constexpr fixed_point(T &&t) noexcept: T(std::forward<T>(t)) {}    template<typename... Args> constexpr decltype(auto) operator()(Args &&... args) const { r_ T::operator()(*this, std::forward<Args>(args)...); }};template<typename T> static inline constexpr decltype(auto) fix(T &&t) noexcept { r_ fixed_point<T>{std::forward<T>(t)}; }\nconstexpr ll h4[] = {1, -1, 0, 0};\nconstexpr ll w4[] = {0, 0, -1, 1};\nconstexpr ll h8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconstexpr ll w8[] = {1, 0, -1, 0, 1, -1, 1, -1};\nint mei_inc(int h, int w, int H, int W, int i) {while (++i < 4) { if (inside(h + h4[i], w + w4[i], H, W))r_ i; }r_ i;}\n#define mei(nh, nw, h, w) for (int i = mei_inc(h, w, H, W, -1), nh = i<4? h + h4[i] : 0, nw = i<4? w + w4[i] : 0; i < 4; i=mei_inc(h,w,H,W,i), nh = h+h4[i], nw = w+w4[i])\nint mei_inc8(int h, int w, int H, int W, int i) {    while (++i < 8) {        if (inside(h + h8[i], w + w8[i], H, W))r_ i;    }    r_ i;}\n#define mei8(nh, nw, h, w) for (int i = mei_inc8(h, w, H, W, -1), nh = i<8? h + h8[i] : 0, nw = i<8? w + w8[i] : 0; i < 8; i=mei_inc8(h,w,H,W,i), nh = h+h8[i], nw = w+w8[i])\nint mei_incv(int h, int w, int H, int W, int i, vp &p) {    while (++i < sz(p)) { if (inside(h + p[i].fi, w + p[i].se, H, W))r_ i; }    r_ i;}\n#define meiv(nh, nw, h, w, p) for (int i = mei_incv(h, w, H, W, -1, p), nh = i<sz(p)? h + p[i].fi : 0, nw = i<sz(p)? w + p[i].se : 0; i < sz(p); i=mei_incv(h,w,H,W,i,p), nh = h+p[i].fi, nw = w+p[i].se)\nvi compress(vi &A) {    vi B = A;    sort(B);    unique(B);    vi inds(sz(B));    rep(i, sz(A)) {        int ind = lower_bound(all(B), A[i]) - B.begin();        inds[ind] = A[i];        A[i] = ind;    }    return inds;}\nvi compress(vi &A, umapi& map){    vi i_v = compress(A);    rep(i, sz(i_v)){        map[i_v[i]] = i;    }    return i_v;}\n\nt_T void out2(T head) {    cout << head;}\ntemplate<class T, class... U> void out2(T head, U ... tail) {    cout << head << \" \";      out2(tail...);}\ntemplate<class T, class... U> void out(T head, U ... tail) {    cout << head << \" \";        out2(tail...);    cout << \"\" << endl;}\nt_T void out(T head) {    cout << head << endl; }\nvoid out() { cout << \"\" << endl; }\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n\n\n/*@formatter:on*/\nint N, M, H, W;\nvi A, B, C;\n\n//12:31\nvoid solve() {\n    din(Q);\n    while (Q--) {\n        in(H, W);\n        vvc(S);\n        nt(S, H, W);\n        vi L('Z'+1, inf);\n        vi R('Z'+1, -1);\n        vi D('Z'+1, inf);\n        vi U('Z'+1, -1);\n        vc C;\n        rep(h, H) rep(w, W) {\n            if (S[h][w] != '.')C += S[h][w];\n            chmi(L[S[h][w]], w);\n            chma(R[S[h][w]], w+1);\n            chmi(D[S[h][w]], h);\n            chma(U[S[h][w]], h+1);\n        }\n        sort(C);\n        unique(C);\n\n        do {\n            auto T = S;\n        #define S !not_use!\n            bool can = true;\n            [&](){\n            rep(ni, sz(C )) {\n                char c = C[ni];\n                rep(h, D[c], U[c]){\n                    rep(w, L[c], R[c]){\n                        if(T[h][w] != '*' &&  T[h][w] != c){\n                            can = false;\n                            return ;\n                        }else{\n                            T[h][w] = '*';\n                        }\n                    }\n                }\n            }}();\n            if(can){\n                deb(C);\n                out(\"SAFE\");\n                goto end2;\n            }\n        } while (next_permutation(all(C)));\n        out(\"SUSPICIOUS\");\n        end2:;\n    }\n\n}\n\n\nsigned main() {\n    solve();\n    r_ 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <utility>\nusing namespace std;\n\n#define INF 100\n\nint main(void){\n  int n;\n  cin >> n;\n  for(int dataset = 0; dataset < n; dataset++){\n    int h, w;\n    cin >> h >> w;\n\n    vector<string> input(h);\n    vector<vector<int> > screening(h, vector<int>(w));\n    map<char, int> material;\n    vector<pair<pair<int, int>, pair<int, int> > > range;\n    for(int i = 0; i < h; i++){ cin >> input[i]; }\n    for(int i = 0; i < h; i++)\n      for(int j = 0; j < w; j++)\n        if(input[i][j] != '.' && material.count(input[i][j]) == 0)\n          material[input[i][j]] = material.size();\n    material['.'] = material.size();\n    for(int i = 0; i < h; i++)\n      for(int j = 0; j < w; j++)\n        screening[i][j] = material[input[i][j]];\n    \n    for(int k = 0; k < (int)material.size(); k++){\n      int minh = INF, minw = INF, maxh = 0, maxw = 0;\n      for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n          if(screening[i][j] == k){\n            minh = min(minh, i);\n            maxh = max(maxh, i);\n            minw = min(minw, j);\n            maxw = max(maxw, j);\n          }\n        }\n      }\n      range.push_back(make_pair(make_pair(minh, minw), make_pair(maxh, maxw)));\n    }\n\n    \n    vector<bool> dp(1 << material.size(), false);\n    dp[0] = true;\n    for(int i = 0; i < (1 << material.size()); i++){      \n      if(dp[i]){\n        for(int j = 0; j < (int)material.size(); j++){\n          if((i & (1 << j)) == 0){\n            int next = i | (1 << j);\n            if(!dp[next]){\n              bool flag = true;\n              int minh = range[j].first.first;\n              int minw = range[j].first.second;\n              int maxh = range[j].second.first;\n              int maxw = range[j].second.second;\n              for(int k = minh; flag && k <= maxh; k++)\n                for(int m = minw; flag && m <= maxw; m++)\n                  flag = ((next & (1 << screening[k][m])) != 0);\n              dp[next] = flag;\n            }\n          }\n        }\n      }\n    }\n\n    if(dp[dp.size() - 1]){ cout << \"SAFE\" << endl; }\n    else{ cout << \"SUSPICIOUS\" << endl; }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nstruct make\n{\n\tchar str;\n\tint posi,start[2];\n\tint high,wide,JUDGE;\n\tstruct make *front[8];\n\tint f_count;\n};\n\nint main()\n{\n\tint N,H,W,count,COUNT,judge,no_rect[7],NO_RECT,prin[500];\n\tchar img[1000][51],print[6][20]={\"SUSPICIOUS1\",\"SUSPICIOUS2\",\"SAFE1\",\"SUSPICIOUS3\",\"SAFE2\",\"SAFE3\"};\n\tstruct make M[8];\n\tstruct make *MP;\n\t\n\tscanf(\"%d\",&N);//データの個数\n\tfor(int a=0;a<N;a++)\n\t{\n\t\tcount=0;//材質の個数\n\t\tCOUNT=0;\n\t\tNO_RECT=0;\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tscanf(\"%s\",img[b]);\n\t\t\timg[b][W]='\\0';\n\t\t}\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tfor(int d=0;d<count;d++) M[d].posi=-1;\n\t\t\tfor(int c=0;c<W;c++)\n\t\t\t{\n\t\t\t\tif(img[b][c]!='.')\n\t\t\t\t{\n\t\t\t\t\t//材質判定\n\t\t\t\t\tjudge=0;\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t\tif(count>0 && img[b][c]!=M[judge].str) judge++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}while(judge<count);\n\t\t\t\t\t//新しい材質の場合\n\t\t\t\t\tif(judge==count)\n\t\t\t\t\t{\n\t\t\t\t\t\tM[count].str=img[b][c];\n\t\t\t\t\t\tM[count].start[0]=b;\n\t\t\t\t\t\tM[count].start[1]=c;\n\t\t\t\t\t\tM[count].posi=c;\n\t\t\t\t\t\tM[count].high=1;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\t//既出の材質の場合\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(M[judge].start[1]>c) M[judge].start[1]=c;\n\t\t\t\t\t\tif(M[judge].posi<0) M[judge].posi=c;\n\t\t\t\t\t\telse if(M[judge].wide<c-M[judge].posi+1) M[judge].wide=c-M[judge].posi+1;\n\t\t\t\t\t\tM[judge].high=b-M[judge].start[0]+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//判定開始\n\t\tif(count)\n\t\t{\n\t\t\t//見えている部分が長方形かどうか判定\n\t\t\tfor(int b=0;b<count;b++)\n\t\t\t{\n\t\t\t\tM[b].JUDGE=1;\n\t\t\t\tM[b].f_count=0;\n\t\t\t\tfor(int c=0;c<8;c++) M[b].front[c]=NULL;\n\t\t\t\tfor(int s1=0;s1<M[b].high;s1++)\n\t\t\t\t{\n\t\t\t\t\tfor(int s2=0;s2<M[b].wide;s2++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//確実に長方形ではない場合\n\t\t\t\t\t\tif(img[s1+M[b].start[0]][s2+M[b].start[1]]=='.')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNO_RECT=1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//長方形の可能性もある場合\n\t\t\t\t\t\tif(img[s1+M[b].start[0]][s2+M[b].start[1]]!=M[b].str)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int c=0;c<count;c++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint e=0;\n\t\t\t\t\t\t\t\tfor(int d=0;d<M[b].f_count;)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif(img[s1+M[b].start[0]][s2+M[b].start[1]]==M[b].front[d]->str) break;\n\t\t\t\t\t\t\t\t\td++;\n\t\t\t\t\t\t\t\t\te=d;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//今いる座標のもじと比べる\n\t\t\t\t\t\t\t\tif(img[s1+M[b].start[0]][s2+M[b].start[1]]==M[c].str && e==M[b].f_count)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tM[b].front[M[b].f_count]=&M[c];\n\t\t\t\t\t\t\t\t\tM[b].f_count++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(M[b].JUDGE!=0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tno_rect[COUNT]=b;\n\t\t\t\t\t\t\t\tCOUNT++;\n\t\t\t\t\t\t\t\tM[b].JUDGE=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(NO_RECT==1) break;\n\t\t\t\t}\n\t\t\t\tif(M[b].JUDGE)M[b].front[M[b].f_count]=NULL;\n\t\t\t}\n\t\t\tif(NO_RECT) prin[a]=0;\n\t\t\t//printf(\"SUSPICIOUS1\\n\");\n\t\t\telse if(COUNT)\n\t\t\t{\n\t\t\t\tif(count!=COUNT)\n\t\t\t\t{\n\t\t\t\t\t//循環していないか確認\n\t\t\t\t\t\n\t\t\t\t\tfor(int b=0;b<COUNT;b++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int c=0;c<M[no_rect[b]].f_count;c++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMP=M[no_rect[b]].front[c];\n\t\t\t\t\t\t\tfor(int d=0;;d++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(MP==NULL) break;\n\t\t\t\t\t\t\t\tif(d>count)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tprin[a]=1;\n\t\t\t\t\t\t\t\t\t//printf(\"SUSPICIOUS2\\n\");\n\t\t\t\t\t\t\t\t\tb=c=count;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMP=(MP->front[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tprin[a]=2;\n\t\t\t\t\t//printf(\"SAFE1\\n\");\n\t\t\t\t}\n\t\t\t\telse prin[a]=3;//printf(\"SUSPICIOUS3\\n\");\n\t\t\t}\n\t\t\telse prin[a]=4;//printf(\"SAFE2\\n\");\n\t\t}\n\t\telse prin[a]=5;//printf(\"SAFE3\\n\");\n\t}\n\tfor(int a=0;a<N;a++) printf(\"%s\\n\",print[prin[a]]);\n\treturn 0;\n}\n//printf(\"#\\n\");\n//printf(\"#1 count=%d\\n\",count);\n//printf(\"#1 COUNT=%d\\n\",COUNT);\n//printf(\"#1 NO_RECT=%d\\n\",NO_RECT);\n//printf(\"M[%d].str=%c\\nM[%d].high=%d\\nM[%d].wide=%d\\n\\n\",b,M[b].str,b,M[b].high,b,M[b].wide);\n//printf(\"#1\\nM[%d].start[0]=%d\\nM[%d].start[1]=%d\\n\\n\",b,M[b].start[0],b,M[b].start[1]);\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nstd::vector<std::vector<char> > move(std::vector<std::vector<char> > recv,char c){\n    std::vector<std::vector<char> > vec;\n    int le=0,ri=recv[0].size()-1,up=0,dow=recv.size()-1;\n    //left\n    for(;le<recv[0].size();++le){\n        bool del=false;\n        for(int count=0;count<recv.size();++count){\n            if(recv[count][le]==c){\n                del=true;\n                break;\n            }\n        }\n        if(del){\n            le--;\n            break;\n        }\n    }\n    //right\n    for(;ri>=0;--ri){\n        bool del=false;\n        for(int count=0;count<recv.size();++count){\n            if(recv[count][ri]==c){\n                del=true;\n                break;\n            }\n        }\n        if(del){\n            ri++;\n            break;\n        }\n    }\n    //up\n    for(;up<recv.size();++up){\n        bool del=false;\n        for(int count=0;count<recv[0].size();++count){\n            if(recv[up][count]==c){\n                del=true;\n                break;\n            }\n        }\n        if(del){\n            up--;\n            break;\n        }\n    }\n    //down\n    for(;dow>0;--dow){\n        bool del=false;\n        for(int count=0;count<recv[0].size();++count){\n            if(recv[dow][count]==c){\n                del=true;\n                break;\n            }\n        }\n        if(del){\n            dow++;\n            break;\n        }\n    }\n    for(int i=up+1;i<dow;++i){\n        std::vector<char> mem;\n        for(int l=le+1;l<ri;++l){\n            mem.push_back(recv[i][l]);\n        }\n        vec.push_back(mem);\n    }\n    return vec;\n}\nstd::vector<std::vector<std::vector<char> > > kscan;\nstd::vector<std::vector<char> > others;\nstd::vector<char> kinds;\nint c_t(char c){\n    for(int i=0;i<kinds.size();++i){\n        if(kinds[i]==c)return i;\n    }\n    return -1;\n}\nbool find(std::vector<char> arr,char c){\n    for(int i=0;i<arr.size();++i){\n        if(arr[i]==c)return true;\n    }\n    return false;\n}\nbool lastcheck(std::vector<char> list,int num){\n    list.push_back(kinds[num]);\n    //std::cout<<\"Debug\"<<kinds[num]<<std::endl;\n    for(int i=0;i<others[num].size();++i){\n        if(find(list,others[num][i])){\n            return false;\n        }else{\n            if(!lastcheck(list,c_t(others[num][i]))){\n                return false;\n            }\n        }\n    }\n    return true;\n}\nbool check(std::vector<std::vector<char> > vec,char c){\n    bool ch=false;\n    for(int i=0;i<vec.size();++i){\n        for(int l=0;l<vec[i].size();++l){\n            if(vec[i][l]==c){\n                ch=true;\n            }\n        }\n    }\n    //存在する->true\n    return ch;\n}\nstd::vector<char> check2(std::vector<std::vector<char> > recv,char c){\n    std::vector<std::vector<char> > vec(1);\n    for(int i=0;i<recv.size();++i){\n        for(int l=0;l<recv[i].size();++l){\n            if(recv[i][l]!=c){\n                if(!check(vec,recv[i][l])){\n                    vec[0].push_back(recv[i][l]);\n                }\n            }\n        }\n    }\n    return vec[0];\n}\nint main(){\n    int num;\n    std::cin>>num;\n    while(num>0){\n        bool S=true;\n        kinds.clear();\n        int width,height;\n        std::cin>>height>>width;\n        std::vector<std::vector<char> > scan(height,std::vector<char> (width,' '));\n        for(int h=0;h<height;++h){\n            for(int w=0;w<width;++w){\n                char in;\n                std::cin>>in;\n                if(!check(scan,in)&&in!='.'){\n                    kinds.push_back(in);\n                }\n                scan[h][w]=in;\n            }\n        }\n        kscan.clear();\n        for(int i=0;i<kinds.size();++i){\n            kscan.push_back(move(scan,kinds[i]));\n        }\n        /*for(int i=0;i<kscan.size();++i){\n            for(int h=0;h<kscan[i].size();++h){\n                for(int w=0;w<kscan[i][h].size();++w){\n                    std::cout<<kscan[i][h][w];\n                }\n                std::cout<<std::endl;\n            }\n            std::cout<<std::endl;\n        }*/\n        others.clear();\n        std::vector<char> samvec;\n        samvec.clear();\n        for(int i=0;i<kscan.size();++i){\n            others.push_back(check2(kscan[i],kinds[i]));\n            for(int l=0;l<others[i].size();++l){\n                if(others[i][l]=='.'){\n                    S=false;\n                    goto end;\n                }\n            }\n        }\n        for(int i=0;i<kinds.size();++i){\n            samvec.clear();\n            samvec.push_back(kinds[i]);\n            for(int l=0;l<others[i].size();++l){\n                if(!lastcheck(samvec,c_t(kinds[i]))){\n                    S=false;\n                }\n            }\n        }\n    end:;\n        std::cout<<(S?\"SAFE\":\"SUSPICIOUS\")<<std::endl;\n        --num;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n\n#define all(c) (c).begin(),(c).end()\n#define f first\n#define s second\n#define INF (1<<29)\n\nusing namespace std;\n\ntypedef pair<int,int>pii;\ntypedef pair<pii,pii> P;\n\nstring s;\nint h,w;\nchar g[51][51],tmp[51][51];\nmap<char,P>v;\n\nvoid make(string s){\n\tfill(tmp[0],tmp[51],'.');\n\tfor(int i=0;i<s.size();i++){\n\t\tfor(int j=v[s[i]].f.s;j<=v[s[i]].s.s;j++){\n\t\t\tfor(int k=v[s[i]].f.f;k<=v[s[i]].s.f;k++){\n\t\t\t\ttmp[j][k]=s[i];\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool ok(){\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(g[i][j]!=tmp[i][j])return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(void){\n\n\tint tc;\n\tcin >> tc;\n\n\twhile(tc--){\n\t\tcin >> h >> w;\n\t\tfor(int i=0;i<h;i++)cin >> g[i];\n\n\t\ts.clear();\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tif(g[i][j]!='.')s+=g[i][j];\n\n\t\tsort(all(s));\n\t\ts.erase(unique(all(s)),s.end());\n\t\tv.clear();\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tint xmn=INF,ymn=INF,xmx=-1,ymx=-1;\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\t\tif(g[j][k]==s[i]){\n\t\t\t\t\t\txmn=min(xmn,k);\n\t\t\t\t\t\tymn=min(ymn,j);\n\t\t\t\t\t\txmx=max(xmx,k);\n\t\t\t\t\t\tymx=max(ymx,j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tv[s[i]]=P(pii(xmn,ymn),pii(xmx,ymx));\n\t\t}\n\n\t\tbool fg=false;\n\t\tdo{\n\t\t\tmake(s);\n\t\t\tif(ok()){fg=true;break;}\n\t\t}while(next_permutation(all(s)));\n\n\t\tif(fg)cout << \"SAFE\" << endl;\n\t\telse cout << \"SUSPICIOUS\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\nusing namespace std;\n#define fi first\n#define se second\ntypedef pair<pair<int,int>, pair<int,int> > Rect;\n\nvector<string> img;\nmap<char, Rect> item;\nint t, H, W;\n\nbool ok(Rect r, char c) {\n\tfor (int i=r.se.fi; i<=r.se.se; ++i) {\n\t\tfor (int j=r.fi.fi; j<=r.fi.se; ++j) {\n\t\t\tif (img[i][j] != c && img[i][j] != '#') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid fill(Rect r, char c) {\n\tfor (int i=r.se.fi; i<=r.se.se; ++i) {\n\t\tfor (int j=r.fi.fi; j<=r.fi.se; ++j) {\n\t\t\timg[i][j] = c;\n\t\t}\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> t;\n\twhile (t--) {\n\t\tcin >> H >> W;\n\t\timg.resize(H);\n\t\tfor (int i=0; i<H; ++i) {\n\t\t\tcin >> img[i];\n\t\t}\n\t\tfor (int i=0; i<H; ++i) {\n\t\t\tfor (int j=0; j<W; ++j) {\n\t\t\t\tchar c = img[i][j];\n\t\t\t\tif (c != '.') {\n\t\t\t\t\tif (item.count(c) == 0) {\n\t\t\t\t\t\titem[c] = make_pair(make_pair(j, j), make_pair(i, i));\n\t\t\t\t\t} else {\n\t\t\t\t\t\titem[c].fi.fi = min(item[c].fi.fi, j);\n\t\t\t\t\t\titem[c].fi.se = max(item[c].fi.se, j);\n\t\t\t\t\t\titem[c].se.fi = min(item[c].se.fi, i);\n\t\t\t\t\t\titem[c].se.se = max(item[c].se.se, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap<char, Rect>::iterator it = item.begin();\n\t\twhile (it != item.end()) {\n\t\t\tchar c = (*it).fi;\n\t\t\tRect r = (*it).se;\n\t\t\tif (ok(r, c)) {\n\t\t\t\tfill(r, '#');\n\t\t\t\titem.erase(c);\n\t\t\t\tit = item.begin();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t++ it;\n\t\t}\n\t\tbool safe = item.empty();\n\t\tcout << (safe ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n\t\titem.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl;\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct edge{int from, to; ll cost;};\n\nmap<char, bool> is_removed;\nint baggage_cnt = 0;\nint h,w;\nchar c = '*';\n\nbool is_rectangle(int si, int sj, int gi, int gj, char c, string s[]){\n\n    rep(h){\n        repp(j, w){\n            if(si <= i && i <= gi && sj <= j && j <= gj){\n                if(s[i][j] != c && !is_removed[s[i][j]]){\n                    return false;\n                }\n            }else{\n                if(s[i][j] == c) return false;\n            }\n        }\n    }\n    return true;\n}\n\nstring solve(string s[]){\n    set<char> st;\n    rep(h){\n        repp(j, w){\n            if(s[i][j] != '.') st.insert(s[i][j]);\n        }\n    }\n    baggage_cnt = (int)st.size();\n\n    bool change = false;\n    while(change){\n        change = false;\n        for(char c: st){\n            if(is_removed[c]) st.erase(c);\n        }\n        for(char c: st){\n            int si = INT_MAX, sj = INT_MAX, gi = -1, gj = -1;\n            rep(h){\n                repp(j, w){\n                    if(s[i][j] == c){\n                        si = min(i, si);\n                        sj = min(j, sj);\n                        gi = max(i, gi);\n                        gj = max(j, gj);\n                    }\n                }\n            }\n            if(gi == -1) continue;\n\n            if(is_rectangle(si, sj, gi, gj, c, s)){\n                is_removed[c] = true;\n                change = true;\n                baggage_cnt--;\n                if(!baggage_cnt) return \"SAFE\";\n            }\n        }\n    }\n    return \"SUSPICIOUS\";\n}\n\nint main() {\n    int t;\n    cin >> t;\n\n    repp(tt, t){\n        cin >> h >> w;\n        string s[h];\n        rep(h) cin >> s[i];\n        is_removed.clear();\n        baggage_cnt = 0;\n        cout << solve(s) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nstring str[60];\nint h,w;\nint num;\nbool flag;\nbool used[55][55];\nchar moji[10];\nint vx[4]={1,0,-1,0};\nint vy[4]={0,1,0,-1};\nvoid dfs(int Bit,int depth){\n  if(Bit==((1<<num)-1)){\n    flag=true;\n    return;\n  }\n  for(int i=0;i<num;i++){\n    if(!(Bit&(1<<i))){\n      bool used2[55][55]={};\n      int lemi=100,lema=0,rimi=100,rima=0;\n      for(int j=0;j<h;j++){\n\tfor(int k=0;k<w;k++){\n\t  if(str[j][k]==moji[i]){\n\t    used2[j][k]=true;\n\t    used[j][k]=true;\n\t    lemi=min(lemi,k);\n\t    lema=max(lema,k);\n\t    rima=max(rima,j);\n\t    rimi=min(rimi,j);\n\t  }\n\t}\n      }\n      bool fll=true;\n      for(int j=rimi;j<=rima;j++){\n\tfor(int k=lemi;k<=lema;k++){\n\t  if(!used[j][k]){\n\t    fll=false;\n\t  }\n\t}\n      }\n      if(fll)\n\tdfs(Bit+(1<<i),depth+1);\n      for(int j=rimi;j<=rima;j++){\n\tfor(int k=lemi;k<=lema;k++){\n\t  if(used2[j][k]){\n\t    used[j][k]=false;\n\t  }\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int n;cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>h>>w;\n    num=0;\n    for(int i=0;i<55;i++)\n      for(int j=0;j<55;j++)\n\tused[i][j]=false;\n    flag=false;\n    bool alfa[26]={};\n    for(int i=0;i<h;i++){\n      cin>>str[i];\n      for(int j=0;j<w;j++){\n\talfa[str[i][j]-'A']=true;\n      }\n    }\n    int cnt=0;\n    for(int i=0;i<26;i++){\n      if(alfa[i]){\n\tnum++;\n\tmoji[cnt]=(char)(i+'A');\n\tcnt++;\n      }\n    }\n    dfs(0,0);\n    if(flag)\n      cout<<\"SAFE\"<<endl;\n    else \n      cout<<\"SUSPICIOUS\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool ans;\n\n// 文字cの出現するx,y座標の最大値と最小値の保持に使う\nstruct range{\n\tint min_x, min_y, max_x, max_y;\n\trange(int min_x_ , int min_y_ , int max_x_ , int max_y_ ){\n\t\tmin_x = min_x_;\n\t\tmin_y = min_y_;\n\t\tmax_x = max_x_;\n\t\tmax_y = max_y_;\n\t}\n};\n\nvoid debug(const vector<string>& m){\n\tcout << \"[debug]\" << endl;\n\tfor(int y=0 ; y < m.size() ; y++ ){\n\t\tcout << m[y] << endl;\n\t}\n\tcout << endl;\n}\n\nvoid debug2(const vector<char>& vc, const vector<range>& vr){\n\tfor(int i=0 ; i < vc.size() ; i++ ){\n\t\trange r = vr[i];\n\t\tcout << vc[i] << \" \" << endl;\n\t\tcout << \"x => [\" << r.min_x << \",\" << r.max_x << \"] \";\n\t\tcout << \"y => [\" << r.min_y << \",\" << r.max_y << \"] \";\n\t\tcout << endl << endl;\n\t}\n}\n\n// 文字 c の出現する x,y 座標の最大値と最小値を求める\nrange search_range(const vector<string>& m, char c){\n\tint min_x = -1, min_y = -1, max_x = -1, max_y = -1;\n\tfor(int y = 0 ; y < m.size() ; y++ ){\n\t\tfor(int x=0 ; x < m[y].size() ; x++ ){\n\t\t\tif( m[y][x] == c ){\n\t\t\t\tmin_x = (min_x == -1)? x : min( min_x , x );\n\t\t\t\tmin_y = (min_y == -1)? y : min( min_y , y );\n\t\t\t\tmax_x = (max_x == -1)? x : max( max_x , x );\n\t\t\t\tmax_y = (max_y == -1)? y : max( max_y , y );\n\t\t\t}\n\t\t}\n\t}\n\trange r( min_x , min_y , max_x , max_y );\n\treturn r;\n}\n\n// 文字 c について長方形かどうか\nbool check(const vector<string>& m, range r, char c){\n\tint cnt = 0;\n\tfor(int y = r.min_y ; y <= r.max_y ; y++ ){\n\t\tfor(int x = r.min_x ; x <= r.max_x ; x++ ){\n\t\t\tif( m[y][x] == c || m[y][x] == '*' ){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//cout << \"search \" << c << \" cnt : \" << cnt << endl;\n\t//cout << \"(\" << r.min_x << \",\" << r.min_y << \") => (\" << r.max_x << \",\" << r.max_y << \")\" << endl; \n\t\n\tif( cnt != (r.max_x - r.min_x + 1) * (r.max_y - r.min_y + 1) ){\n\t\treturn false;\n\t}\n\t\n\tfor(int y = 0 ; y < m.size() ; y++ ){\n\t\tfor(int x = 0 ; x < m[y].size() ; x++ ){\n\t\t\tif( r.min_x <= x && r.min_y <= y && x <= r.max_x && y <= r.max_y ){\n\t\t\t}else if( m[y][x] == c ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\n// 文字 c を' *' に置き換える (荷物を取り除く) \nvoid remove(vector<string>& m, range r, char c){\n\tfor(int y = r.min_y ; y <= r.max_y ; y++ ){\n\t\tfor(int x = r.min_x ; x <= r.max_y ; x++ ){\n\t\t\tif( m[y][x] == c ){\n\t\t\t\tm[y][x] = '*';\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(int id, vector<bool> memo, vector<string> m, vector<char> vc, vector<range> vr){\n\tmemo[id] = true;\n\t\n\t// 長方形かどうか\n\tbool is_rect = check( m , vr[id] , vc[id] );\n\tif( is_rect == false ){\n\t\treturn;\n\t}\n\t\n\t// 文字 vc[id] を '*' に置き換える (荷物を取り除く) \n\tremove( m , vr[id] , vc[id] );\n\t\n\t//cout << vc[id] << \" is rectangle! \" << endl;\n\t//debug( m );\n\t\n\t// すべて調べたかどうか\n\tint cnt = 0;\n\tfor(int i=0 ; i < memo.size() ; i++ ){\n\t\tif( memo[i] )\n\t\t\tcnt++;\n\t}\n\tif( cnt == memo.size() && is_rect ){\n\t\tans = true;\n\t\treturn;\n\t}\n\t\n\tfor(int i=0 ; i < memo.size() ; i++ ){\n\t\tif( memo[i] == false ){\n\t\t\t//cout << \"next : \" << vc[i] << endl;\n\t\t\t//dfs( i , memo , m , vc , vr );\n\t\t}\n\t}\n}\n\nvoid solve(const vector<string>& m){\n\tchar ch[256] = {0};\n\tvector<char> vc;\n\tvector<range> vr;\n\tans = false;\n\t\n\t// 出現する文字を調べる\n\tfor(int y=0 ; y < m.size() ; y++ ){\n\t\tfor(int x=0 ; x < m[y].size() ; x++ ){\n\t\t\tif( m[y][x] >= 'A' && m[y][x] <= 'Z' ){\n\t\t\t\tch[ m[y][x] ] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(char c = 'A' ; c <= 'Z' ; c++ ){\n\t\tif( ch[c] )\n\t\t\tvc.push_back( c );\n\t}\n\t\n\t// 文字がなかったら \"SAFE\"\n\tif( vc.size() == 0 ){\n\t\tans = true;\n\t}\n\t\n\t// 各文字 c について x,y 座標の最大値と最小値を求める\n\tfor(int i=0 ; i < vc.size() ; i++ ){\n\t\trange r = search_range( m , vc[i] );\n\t\tvr.push_back( r );\n\t}\n\t//debug2( vc , vr );\n\t\n\t// DFSで重なる順番をすべて調べる\n\tvector<bool> memo( vc.size() );\n\tfor(int k=0 ; k < vc.size() ; k++ ){\n\t\tfor(int i=0 ; i < memo.size() ; i++ ){\n\t\t\tmemo[i] = false;\n\t\t}\n\t\tdfs( k , memo , m , vc , vr );\n\t}\n\t\n}\n\nint main(){\n\tint T;\n\tcin >> T;\n\tfor(int t_ = 0 ; t_ < T ; t_++ ){\n\t\tint w, h;\n\t\tcin >> h >> w;\n\t\t\n\t\tvector<string> m(h);\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> m[y];\n\t\t}\n\t\t\n\t\tsolve( m );\n\t\t\n\t\tif( ans ){\n\t\t\tcout << \"SAFE\" << endl;\n\t\t}else{\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define RFOR(i, a, b) for(int i = (b)-1; i >= (a); i--)\n#define REP(i, n) for(int i = 0; i < (n); i++)\n#define RREP(i, n) for(int i = (n)-1; i >= 0; i--)\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rrep(i, n) for(int i = (n)-1; i >= 0; i--)\n#define loop while(true)\n\n#define PB push_back\n#define pb push_back\n#define MP make_pair\n#define mp make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define all(a) (a).begin(),(a).end()\n\n#define PII pair<int, int>\n#define pii pair<int, int>\n#define VB vector<bool>\n#define VVB vector<vector<bool> >\n#define VI vector<int>\n#define VVI vector<vector<int> >\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n\n\n\nsigned main()\n{\n    int test_num;\n    cin >> test_num;\n    rep(test, test_num){\n        int h, w;\n        cin >> h >> w;\n\n        vector<vector<char> > image(h);\n        rep(y, h){\n            image[y].resize(w);\n        }\n        rep(y, h){\n            rep(x, w){\n                char ch;\n                cin >> ch;\n                image[y][x] = ch;\n            }\n        }\n        \n        int obj_num = 0;\n        map<char, int> objects;\n        vector<char> chars;\n        vector<array<int, 4> > obj_point; // h_min, w_min, h_max, w_max\n        \n        rep(y, h){\n            rep(x, w){\n                if(image[y][x] != '.'){\n                    char letter = image[y][x];\n                    if(objects.find(letter) != objects.end()){\n                        int index = objects[letter];\n                        obj_point[index].at(0) = min(obj_point[index].at(0), y);\n                        obj_point[index].at(1) = min(obj_point[index].at(1), x);\n                        obj_point[index].at(2) = max(obj_point[index].at(2), y);\n                        obj_point[index].at(3) = max(obj_point[index].at(3), x);\n                    } else {\n                        objects.insert(mp(letter, obj_num++));\n                        chars.pb(letter);\n                        array<int, 4> p = {y, x, y, x};\n                        obj_point.pb(p);\n                    }\n                }\n            }\n        }\n\n        bool flag = false;\n        VVB to_graph(obj_num);\n        rep(i, obj_num){\n            to_graph[i].resize(obj_num);\n        }\n        rep(n, obj_num){\n            VB over(obj_num, false);\n            FOR(y, obj_point[n].at(0), obj_point[n].at(2)+1){\n                FOR(x, obj_point[n].at(1), obj_point[n].at(3)+1){\n                    char letter = image[y][x];\n                    if(letter == '.'){\n                        flag = true;\n                        break;\n                    }\n                    else if(letter != chars[n]){\n                        int index = objects[letter];\n                        if(!over[index]){\n                            // cout << chars[n] << \" is coverred by \" << letter << endl;\n                            over[index] = true;\n                            to_graph[index][n] = true;\n                        }\n                    }\n                }\n                if(flag) break;\n            }\n            if(flag) break;\n        }\n\n        if(!flag){\n            queue<int> inits;\n            rep(i, obj_num){\n                bool non = true;\n                rep(j, obj_num){\n                    if(to_graph[j][i]) non = false;\n                }\n                if(non) inits.push(i);\n            }\n            \n            vector<int> top(obj_num);\n            while(!inits.empty()){\n                int n = inits.front();\n                inits.pop();\n                top.pb(n);\n                rep(i, obj_num){\n                    if(to_graph[n][i]){\n                        to_graph[n][i] = false;\n                        bool non = true;\n                        rep(j, obj_num){\n                            if(to_graph[j][i]) non = false;\n                        }\n                        if(non) inits.push(i);\n                    }\n                }\n            }\n\n            rep(i, obj_num){\n                rep(j, obj_num){\n                    if(to_graph[i][j]){\n                        flag = true;\n                        break;\n                    }\n                }\n                if(flag){\n                    break;\n                }\n            }\n        }\n        \n        if(flag){\n            cout << \"SUSPICIOUS\" << endl;\n        } else {\n            cout << \"SAFE\" << endl;\n        }\n        \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n\nusing namespace std;\n\nint h,w;\nchar field[51][51];\nbool passed[51];\n\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\nstruct nodeInfo{\n    int minx;\n    int miny;\n    int maxx;\n    int maxy;\n    char kind;\n};\n\nint minx,miny,maxx,maxy;\nmap<char,int> key;\nint node;\nvector<int> G[51];\nbool isClosing=false;\nnodeInfo recInfo[51];\n\nvoid findRecSize (int y,int x,char kind){\n    for(int i = 0;i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(field[i][j]==kind){\n                miny=min(miny,i);\n                minx=min(minx,j);\n                maxy=max(maxy,i);\n                maxx=max(maxx,j);\n            }\n        }\n    }\n}\n\nvoid findClose(int s){\n    if(isClosing)\n        return;\n    if(passed[s]){\n        isClosing=true;\n        return;\n    }\n    passed[s]=true;\n    for(int i = 0; i < G[s].size(); i++){\n        findClose(G[s][i]);\n    }\n}\n\n\nint main(){\n\n    int n;\n    cin>>n;\n    while(n--){\n        for(int i = 0; i < 51; i++)\n            G[i].clear();\n        node=0;\n        key.clear();\n        cin>>h>>w;\n        memset(passed,0,sizeof(passed));\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin>>field[i][j];\n            }\n        }\n        bool no=false;\n        // ·û`»è\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                char kind=field[i][j];\n                if(kind!='.'&&key.find(kind)==key.end()){\n                    // nodeðV½Éo^·é\n                    key[kind]=node;\n                    node++;\n                    minx=miny=100;\n                    maxx=maxy=-1;\n                    findRecSize(i,j,kind);\n                    recInfo[node-1].maxx=maxx;\n                    recInfo[node-1].maxy=maxy;\n                    recInfo[node-1].minx=minx;\n                    recInfo[node-1].miny=miny;\n                    recInfo[node-1].kind=kind;             \n                    // ß½x,y»ê¼êÌÀWîñ©ç¾çê½l¦¤é·û`Ì`ÌTõðs¤\n                    for(int k = miny; k <= maxy; k++){\n                        for(int l = minx; l <= minx; l++){\n                            // TõææÉ.ª¶Ýµ½êA·û`ÅÍÈ¢\n                            if(field[k][l]=='.'){\n                                no=true;\n                                break;\n                            }\n                        }\n                        if(no)\n                            break;\n                    }\n                    if(no)\n                        break;\n                }\n                if(no)\n                    break;\n            }\n        }\n        if(no){\n            cout<<\"SUSPICIOUS\"<<endl;\n            continue;\n        }\n\n        // dÈèÌ\n        // ãÌÙ¤©çºÌÙ¤ÖGbWð£é\n        bool isRootNode[101];\n        fill(isRootNode,isRootNode+101,true);\n        for(int l = 0; l < node; l++){\n            int mnx=recInfo[l].minx;\n            int mxx=recInfo[l].maxx;\n            int mny=recInfo[l].miny;\n            int mxy=recInfo[l].maxy;\n            char kind=recInfo[l].kind;\n            for(int i = mny; i <= mxy; i++){\n                for(int j = mnx; j <= mxx; j++){\n                    if(field[i][j]!=kind){\n                        int from=key[field[i][j]];\n                        int to=key[kind];\n                        // Ü¾GbWª¢o^\n                        if(find(G[from].begin(),G[from].end(),to)==G[from].end()){\n                            G[from].push_back(to);\n                            isRootNode[to]=false;\n                        }\n                    }\n                }\n            }\n        }\n        // ÂHª¶Ý·é©[gm[h©çTõ\n        memset(passed,0,sizeof(passed));\n        isClosing=false;\n        bool noRoot=true;\n        for(int i = 0; i < node; i++){\n            if(isRootNode[i]){\n                noRoot=false;\n                findClose(i);\n                if(isClosing){\n                    break;\n                }\n            }\n        }\n        if(key.size()!=0&&(isClosing||noRoot)){\n            cout<<\"SUSPICIOUS\"<<endl;\n            continue;\n        }\n        else\n            cout<<\"SAFE\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nstruct make\n{\n\tchar str;\n\tint posi,start[2];\n\tint high,wide,JUDGE;//JUDGE==1で長方形,==0で長方形以外,==2で未定\n\tstruct make *front;\n};\n\n\nint main()\n{\n\tint N,H,W,count,COUNT,judge,no_rect,NO_RECT,RECT_C=0;\n\tchar img[1000][51],RECT[8];\n\tstruct make M[8];\n\tint s1,s2,num,r;\n\t\n\tscanf(\"%d\",&N);//データの個数\n\tfor(int a=0;a<N;a++)\n\t{\n\t\tcount=0;//材質の個数\n\t\tCOUNT=0;\n\t\tNO_RECT=0;\n\t\tRECT_C=0;\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tscanf(\"%s\",img[b]);\n\t\t\timg[b][W]='\\0';\n\t\t}\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tfor(int d=0;d<count;d++) M[d].posi=-1;\n\t\t\tfor(int c=0;c<W;c++)\n\t\t\t{\n\t\t\t\tif(img[b][c]!='.')\n\t\t\t\t{\n\t\t\t\t\t//材質判定\n\t\t\t\t\tjudge=0;\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t\tif(count>0 && img[b][c]!=M[judge].str) judge++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}while(judge<count);\n\t\t\t\t\t//新しい材質の場合\n\t\t\t\t\tif(judge==count)\n\t\t\t\t\t{\n\t\t\t\t\t\tM[count].str=img[b][c];\n\t\t\t\t\t\tM[count].start[0]=b;\n\t\t\t\t\t\tM[count].start[1]=c;\n\t\t\t\t\t\tM[count].posi=c;\n\t\t\t\t\t\tM[count].high=1;\n\t\t\t\t\t\tM[count].wide=1;\n\t\t\t\t\t\tM[count].JUDGE=0;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\t//既出の材質の場合\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(M[judge].start[1]>c) M[judge].start[1]=c;\n\t\t\t\t\t\tif(M[judge].posi<0) M[judge].posi=c;\n\t\t\t\t\t\telse if(M[judge].wide<c-M[judge].posi+1) M[judge].wide=c-M[judge].posi+1;\n\t\t\t\t\t\tM[judge].high=b-M[judge].start[0]+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tno_rect=count;\n\t\t//printf(\"count=%d\\n\",count);\n\t\t//判定開始\n\t\twhile(count)//文字アリ\n\t\t{\n\t\t\tint p;\n\t\t\tp=getchar();\n\t\t\tCOUNT=0;\n\t\t\t//見えている部分が長方形かどうか判定\n\t\t\tfor(num=0;num<count;num++)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(M[num].JUDGE==1) continue;\n\t\t\t\tM[num].JUDGE=0;//長方形なら\n\t\t\t\t//printf(\"M[%d].str=%c\\nM[%d].high=%d\\nM[%d].wide=%d\\n\",num,M[num].str,num,M[num].high,num,M[num].wide);\n\t\t\t\t//printf(\"M[%d].start[0]=%d\\nM[%d].start[1]=%d\\n\",num,M[num].start[0],num,M[num].start[1]);\n\t\t\t\tfor(s1=0;s1<M[num].high;s1++)\n\t\t\t\t{\n\t\t\t\t\tfor(s2=0;s2<M[num].wide;s2++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//確実に長方形ではない場合\n\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]=='.')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNO_RECT=1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//長方形の可能性もある場合\n\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]!=M[num].str)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(r=0;r<RECT_C;)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tprintf(\"RECT[%d]='%c'\\n\",r,RECT[r]);\n\t\t\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]==RECT[r]) break;\n\t\t\t\t\t\t\t\tr++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]==RECT[r]) break;\n\t\t\t\t\t\t\tif(r==RECT_C)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tM[num].JUDGE=2;\n\t\t\t\t\t\t\t\tCOUNT++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(NO_RECT || M[num].JUDGE==2) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(NO_RECT || M[num].JUDGE==2) break;\n\t\t\t\t}\n\t\t\t\tif(NO_RECT) break;\n\t\t\t\t//長方形だった場合\n\t\t\t\tif(s1==M[num].high && s2==M[num].wide)\n\t\t\t\t{\n\t\t\t\t\tM[num].JUDGE=1;\n\t\t\t\t\tno_rect--;\n\t\t\t\t\tRECT[RECT_C]=M[num].str;\n\t\t\t\t\tRECT_C++;\n\t\t\t\t}\n\t\t\t\t//printf(\"M[%d].JUDGE=%d\\n\\n\",num,M[num].JUDGE);\n\t\t\t}\n\t\t\tfor(int n=0;n<num;)\n\t\t\t{\n\t\t\t\t//printf(\"#\\n\");\n\t\t\t\tif(M[n].JUDGE!=2) break;\n\t\t\t\tn++;\n\t\t\t\t//どれも長方形ではなかった場合\n\t\t\t\tif(n==num) NO_RECT=1;\n\t\t\t}\n\t\t\t\n\t\t\t//printf(\"NO_RECT=%d\\n\",NO_RECT);\n\t\t\tif(NO_RECT==1) break;\n\t\t\t//printf(\"#no_rect=%d\\n\\n\\n\",no_rect);\n\t\t\t//すべて長方形\n\t\t\tif(no_rect==0) break;\n\t\t}\n\t\t//出力\n\t\tif(NO_RECT) printf(\"SUSPICIOUS\\n\");\n\t\telse if(no_rect) printf(\"SUSPICIOUS\\n\");\n\t\telse printf(\"SAFE\\n\");\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\nint h,w;\nstring G[51];\nbool checked[51][51];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nbool isRect(int x,int y)\n{\n  int x1,x2,y1,y2;\n  x1 = x2 = x;\n  y1 = y2 = y;\n\n  rep(i,h)\n    rep(j,w)\n    {\n      if(G[i][j] == G[y][x])\n\t{\n\t  if(j < x1)x1 = j;\n\t  if(j > x2)x2 = j;\n\t  if(i < y1)y1 = i;\n\t  if(i > y2)y2 = i;\n\t}\n    }\n\n  REP(i,y1,y2+1)\n    REP(j,x1,x2+1)\n    if(G[i][j] != G[y][x] && !checked[i][j])return false;\n  return true;\n\n}\n\nvoid draw(int x,int y,char c)\n{\n  if(checked[y][x])return;\n  checked[y][x] = true;\n  rep(i,4)\n    {\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(G[ny][nx] != c)continue;\n      draw(nx,ny,c);\n    }\n}\n\nbool isSafe()\n{\n  rep(i,h)\n    rep(j,w)\n    if(G[i][j] != '.' && !checked[i][j])return false;\n  return true;\n}\n\nint main()\n{\n  int T;\n  cin >> T;\n  while(T-- > 0)\n    {\n      cin >> h >> w;\n      rep(i,h)\n\tcin >> G[i];\n      rep(i,51)rep(j,51)checked[i][j] = false;\n\n      while(true)\n\t{\n\t  bool Fin = true;\n\t  bool update = false;\n       \n\t  rep(i,h)\n\t    {\t\n\t      rep(j,w)\n\t\t{\n\t\t  if(G[i][j] == '.')continue;\n\t\t  if(checked[i][j])continue;\n\t\t  Fin = false;\n\t\t  if(isRect(j,i))\n\t\t    {\n\t\t      update = true;\n\t\t      draw(j,i,G[i][j]);\n\t\t    }\n\t\t}\n\t    }\n\t  if(Fin || !update)break;\n\t}\n   \n      isSafe()?cout << \"SAFE\" << endl:cout << \"SUSPICIOUS\" << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nint main()\n{\n    int n;\n    cin >> n;\n    while (n--) {\n        int w, h; cin >> w >> h;\n        vector<string> B(h);\n        loop (h, i) cin >> B[i];\n\n        unordered_set<char> alphs;\n        loop (h, i) loop (w, j) {\n            char c = B[i][j];\n            if (c != '.') alphs.insert(c);\n        }\n        vector<char> perm(all(alphs));\n        sort(all(perm));\n        int safe = 0;\n        do {\n            map<char, int> layer = {{ '.', 0 }};\n            loop (perm.size(), i) layer[perm[i]] = i+1;\n\n            for (char c : perm) {\n                int l = 100, r = 0, t = 100, b = 0;\n                loop (h, i) loop (w, j) if (B[i][j] == c) {\n                    l = min(j, l);\n                    r = max(j, r);\n                    t = min(i, t);\n                    b = max(i, b);\n                }\n                for (int i = t; i <= b; i++) {\n                    for (int j = l; j <= r; j++) {\n                        if (layer[B[i][j]] < layer[c]) goto NG;\n                    }\n                }\n            }\n            safe = 1;\n            break;\nNG:\n            continue;\n        } while (next_permutation(all(perm)));\n        if (safe) cout << \"SAFE\" << endl;\n        else cout << \"SUSPICIOUS\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cctype>\n\nusing namespace std;\n\nint const INF = 1<<28;\n\nint main() {\n  \n  int Tc; cin >> Tc;\n  while(Tc--) {\n    int H, W; cin >> H >> W;\n    vector<vector<char> > a(H+2, vector<char>(W+2));\n    vector<int> minX(128, INF), minY(128, INF);\n    vector<int> maxX(128, -INF), maxY(128, -INF);\n    vector<int> vec;\n    for(int i=0; i<H; i++) {\n      for(int j=0; j<W; j++) {\n        cin >> a[i][j];\n        if(!isalpha(a[i][j])) continue;\n        int b = a[i][j];\n        vec.push_back(b);\n        maxX[b] = max(maxX[b], j);\n        maxY[b] = max(maxY[b], i);\n        minX[b] = min(minX[b], j);\n        minY[b] = min(minY[b], i);\n      }\n    }\n    if(vec.empty()) {\n      cout << \"SAFE\" << endl;\n      goto EXIT;\n    }\n    sort(vec.begin(), vec.end());\n    vec.erase(unique(vec.begin(), vec.end()), vec.end());\n    \n    do {\n      bool good = true;\n      vector<vector<char> > work(a);\n      \n      for(int I=0; I<vec.size(); I++) {\n        bool ok = true;\n        for(int i=minY[vec[I]]; i<=maxY[vec[I]]; i++) {\n          for(int j=minX[vec[I]]; j<=maxX[vec[I]]; j++) {\n            if(work[i][j] == '#') {\n            }\n            if(work[i][j] != '#' && work[i][j] != (char)vec[I]) {\n              ok = false;\n              break;\n            }\n          }\n          if(!ok) break;\n        } // for i\n        if(!ok) { good = false; break; }\n        for(int i=minY[vec[I]]; i<=maxY[vec[I]]; i++)\n          for(int j=minX[vec[I]]; j<=maxX[vec[I]]; j++) {\n            work[i][j] = '#';\n          }\n      }\n      \n      if(good) {\n        cout << \"SAFE\" << endl;\n        goto EXIT;\n      }\n    } while(next_permutation(vec.begin(), vec.end()));\n    \n    cout << \"SUSPICIOUS\" << endl;\n    \n  EXIT:;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#define all(c) c.begin(),c.end()\n#define uni(c) c.erase(unique(all(c)),c.end())\n#define pb push_back\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w;\nvector<char> c;\nbool ret(int now,vector<string> &s){\n\tif(now==c.size())\n\t\treturn true;\n\tint x1=100,x2=0,y1=100,y2=0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[i][j]==c[now]){\n\t\t\t\tx1=min(x1,j);\n\t\t\t\tx2=max(x2,j);\n\t\t\t\ty1=min(y1,i);\n\t\t\t\ty2=max(y2,i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=y1;i<=y2;i++){\n\t\tfor(int j=x1;j<=x2;j++){\n\t\t\tif(s[i][j]==c[now]||s[i][j]=='*'){\n\t\t\t\ts[i][j]='*';\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret(now+1,s);\n\t\n}\nint main(){\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\tcin>>h>>w;\n\t\t//s.resize(h);\n\t\tvector<string> s(h);\n\t\tc.clear();\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>s[i];\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tc.pb(s[i][j]);\n\t\t\t}\n\t\t}\n\t\tsort(all(c));\n\t\tuni(c);\n\t\tbool flag=false;\n\t\tdo{\n\t\t\tvector<string> temp=s;\n\t\t\tif(ret(0,temp)){\n\t\t\t\tflag=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}while(next_permutation(all(c)));\n\t\tif(flag){\n\t\t\tcout<<\"SAFE\"<<endl;\n\t\t}else\n\t\tcout<<\"SUSPICIOUS\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60)+1e9; // ~ 1.15 * 1e18\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\n//INSERT ABOVE HERE\n\nsigned main(){\n  srand((unsigned)time(NULL));\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  Int num_test;\n  cin>>num_test;\n  while(num_test--){\n\n    Int H, W;\n    cin>>H>>W;\n    vector<string> mp(H);\n    cin>>mp;\n    vector<Int> ord;\n    for(Int i=0;i<H;i++)\n      for(Int j=0;j<W;j++)\n        if(mp[i][j] != '.') ord.push_back(mp[i][j]);\n\n    sort(ord.begin(), ord.end());\n    ord.erase(unique(ord.begin(), ord.end()), ord.end());\n\n    function<_int(Int, vector<string> mp)> check=[&](Int idx, vector<string> mp){\n      if(idx == (Int)ord.size()) return 1;\n\n      char ch = ord[idx];\n      Int left = 100, right = -100;\n      Int top = 100, bottom = -100;\n      for(Int i=0;i<H;i++)\n        for(Int j=0;j<W;j++)\n          if(mp[i][j] == ch){\n            Min(left, j);\n            Max(right, j);\n            Min(top, i);\n            Max(bottom, i);\n          }\n\n      Int valid = 1;\n      for(Int i=top;i<=bottom;i++)\n        for(Int j=left;j<=right;j++)\n          valid &= mp[i][j] == ch || mp[i][j] == '!';\n\n      if(!valid) return 0;\n\n      for(Int i=0;i<H;i++)\n        for(Int j=0;j<W;j++)\n          if(mp[i][j] == ch) mp[i][j] = '!' ;\n\n      return check(idx + 1, mp);\n    };\n\n    Int safe = 0;\n    do{\n      if(safe) break;\n      safe |= check(0, mp);\n    }while(next_permutation(ord.begin(), ord.end()));\n\n    cout<<(safe? \"SAFE\":\"SUSPICIOUS\")<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nvector<bool> visited;\nbool dfs(int v, const vector<vector<bool>> &E, int s){\n    if (visited[v] and v == s) return false;\n    if (visited[v]) return true;\n    visited[v] = true;\n    for (int i = 0; i < 26; i++){\n        if (!E[v][i]) continue;\n        if (!dfs(i, E, s)) return false;\n    }\n    return true;\n}\n\nbool solve(){\n    const int INF = 1e9;\n    int h, w;\n    cin >> h >> w;\n    vector<string> S(h);\n    vector<vector<bool>> C(26, vector<bool>(26, 0));\n    for (auto &s: S)\n        cin >> s;\n    for (char u = 'A'; u <= 'Z'; u++){\n        int min_h = INF, min_w = INF, max_h = -INF, max_w = -INF;\n        for (int i = 0; i < h; i++){\n            for (int j = 0; j < w; j++){\n                if (S[i][j] != u) continue;\n                min_h = min(min_h, i);\n                min_w = min(min_w, j);\n                max_h = max(max_h, i);\n                max_w = max(max_w, j);\n            }\n        }\n\n        for (int i = min_h; i <= max_h; i++){\n            for (int j = min_w; j <= max_w; j++){\n                auto t = S[i][j];\n                if (t == u) continue;\n                if (t == '.') return false;\n                C[u - 'A'][t - 'A'] = true;\n            }\n        }\n    }\n    for (int i = 0; i < 26; i++){\n        visited.assign(26, false);\n        if (!dfs(i, C, i)) return false;\n    }\n    return true;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n\tcin.tie(0);\n    cout << fixed << setprecision(20);\n    \n    int T_;\n    cin >> T_;\n    for (int t_ = 0; t_ < T_; t_++){\n        puts(solve() ? \"SAFE\" : \"SUSPICIOUS\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <string>\n#define loop(i, N) for(int i=0; i<(N); ++i)\nusing namespace std;\nint m[51][51], used[27], rf, a[27], b[27], c[27], d[27], h, w, t;\nstd::string st;\nint main() {\n\tauto check = [&](int t) {\n\t\tfor (int i = a[t]; i <= c[t]; ++i) {\n\t\t\tfor (int n = d[t]; n <= b[t]; ++n) {\n\t\t\t\tif (m[i][n] != '.' && !used[m[i][n]-'A']) continue;\n\t\t\t\tif (m[i][n] != t + 'A') return 0;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t};\n\tint __t;\n\tcin >> __t;\n\twhile (__t--) {\n\t\tloop(i, 27) {\n\t\t\ta[i] = d[i] = 50;\n\t\t\tb[i] = c[i] = 0;\n\t\t\tused[i] = 0;\n\t\t}\n\t\tcin >> h >> w;\n\t\tloop(i, h) {\n\t\t\tcin >> st;\n\t\t\tloop(n, w) {\n\t\t\t\tif ((m[i][n] = st[n]) != '.') {\n\t\t\t\t\tt = m[i][n] - 'A';\n\t\t\t\t\tused[t] = 1;\n\t\t\t\t\ta[t] = std::min(a[t], i);\n\t\t\t\t\tb[t] = std::max(b[t], n);\n\t\t\t\t\tc[t] = std::max(c[t], i);\n\t\t\t\t\td[t] = std::min(d[t], n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (;;) {\n\t\t\trf = 0;\n\t\t\tloop(i, 27) {\n\t\t\t\tif (!used[i]) continue;\n\t\t\t\tif (check(i)) {\n\t\t\t\t\trf = 1;\n\t\t\t\t\tused[i] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!rf) break;\n\t\t}\n\t\trf = 0;\n\t\tloop(i, 27) rf |= used[i];\n\t\tcout << (rf ? \"SUSPICIOUS\" : \"SAFE\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\nclass Object{\npublic:\n  Object(char col){ miny = minx = INF; maxy = maxx = -1; on.clear(); c = col; }\n  int miny, minx, maxy, maxx;\n  set<int> on;\n  char c;\n};\n\nint h, w;\nvector<Object> objects;\nbool used[26];\nchar input[50][50];\nbool visited[50][50];\nint index[50][50];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nbool dfs1(int y, int x, int n){\n  Object &obj = objects[n];\n  visited[y][x] = true;\n  index[y][x] = n;\n  if(obj.miny > y) obj.miny = y;\n  if(obj.minx > x) obj.minx = x;\n  if(obj.maxy < y) obj.maxy = y;\n  if(obj.maxx < x) obj.maxx = x;\n  for(int i=0;i<4;i++){\n    int ty = y + dy[i];\n    int tx = x + dx[i];\n    if(ty<0 || ty>=h) continue;\n    if(tx<0 || tx>=w) continue;\n    if(visited[ty][tx]) continue;\n    if(input[ty][tx] != input[y][x]) continue;\n    dfs1(ty, tx, n);\n  }\n  return true;\n}\n\nbool dfs2(int n){\n  used[objects[n].c - 'A'] = true;\n  set<int>::iterator ite = objects[n].on.begin();\n  for(;ite != objects[n].on.end();ite++){\n    if(used[objects[*ite].c - 'A']) return false;\n    if(!dfs2(*ite)) return false;\n  }\n  return true;\n}\n\nmain(){\n  int t;\n  cin >> t;\n  while(t--){\n    cin >> h >> w;\n    objects.clear();\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> input[i][j];\n      }\n    }\n\n\n    fill(index[0], index[50], -1);\n    fill(visited[0], visited[50], false);    \n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(input[i][j] != '.' && !visited[i][j]){\n\t  objects.push_back(Object(input[i][j]));\n\t  dfs1(i, j, (int)objects.size()-1);\n\t}\n      }\n    }\n\n    bool ans = true;\n\n    for(int i=0;i<objects.size();i++){\n      for(int j=objects[i].miny;j<=objects[i].maxy;j++){\n\tfor(int k=objects[i].minx;k<=objects[i].maxx;k++){\n\t  if(input[j][k] != '.' && input[j][k] != objects[i].c){\n\t    objects[i].on.insert(index[j][k]);\n\t  }else if(input[j][k] == '.'){\n\t    ans = false;\n\t    break;\n\t  }\n\t}\n\tif(!ans) break;\n      }\n      if(!ans) break;\n    }\n\n    //loop\n    for(int i=0;i<objects.size();i++){\n      fill(used, used+26, false);\n      if(!dfs2(i)){\n\tans = false;\n\tbreak;\n      }\n      /*cout << i << \"    \";\n      for(int i=0;i<26;i++){\n\tif(used[i]){\n\t  cout << (char)(i+'A')<< ' ';\n\t}\n      }\n      cout << endl;*/\n    }\n\n    /*for(int i=0;i<objects.size();i++){\n      cout << objects[i].c << endl;\n      set<int>::iterator ite = objects[i].on.begin();\n      for(;ite != objects[i].on.end();ite++){\n\tcout << objects[*ite].c << ' ';\n      }\n      cout << endl << endl;\n      }*/\n\n    //tyouhou\n\n    //for(int i=0;i<objects.size();i++){\n      \n    //}\n    if(ans){\n      cout << \"SAFE\" << endl;\n    }else{\n      cout << \"SUSPICIOUS\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((ULL)(n) >> (m) & 1)\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\nint n_dir = 4;\nint dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; /* CSS order */\nenum direction {\n\tUP, RIGHT, DOWN, LEFT\n};\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\nstruct article {\n\tchar material;\n\tbool is_removed;\n\tint topmost;\n\tint bottommost;\n\tint leftmost;\n\tint rightmost;\n};\n\ntypedef map<char, article> MCA;\n\nVVC image;\nMCA articles;\n\nbool remove_all()\n{\n\tbool all_removed = true;\n\tEACH (articles, itr) {\n\t\tarticle &art = itr->second;\n\t\tif (!art.is_removed) {\n\t\t\tall_removed = false;\n\t\t\t// Remove it and recurse\n\t\t\tVVC save = image;\n\t\t\tbool rect = true;\n\t\t\tFOR (i, art.topmost, art.bottommost + 1) {\n\t\t\t\tFOR (j, art.leftmost, art.rightmost + 1) {\n\t\t\t\t\tif (image[i][j] != '*' && image[i][j] != art.material) {\n\t\t\t\t\t\trect = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\timage[i][j] = '*';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rect) {\n\t\t\t\t// Recurse\n\t\t\t\tart.is_removed = true;\n\t\t\t\tif (remove_all()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Restore and continue trying\n\t\t\timage = save;\n\t\t}\n\t}\n\treturn all_removed;\n}\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\tint t; cin >> t;\n\tREP (_, t) {\n\t\tint h, w; cin >> h >> w;\n\t\timage = VVC(h, VC(w, '.'));\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tcin >> image[i][j];\n\t\t\t}\n\t\t}\n\n\t\t// Scan Image\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tif (image[i][j] != '.') {\n\t\t\t\t\tchar c = image[i][j];\n\t\t\t\t\tif (!EXIST(articles, c)) {\n\t\t\t\t\t\tarticle a = {c, false, 50, 0, 50, 0};\n\t\t\t\t\t\tarticles.insert(MCA::value_type(c, a));\n\t\t\t\t\t}\n\t\t\t\t\tarticles[c].topmost = min(articles[c].topmost, i);\n\t\t\t\t\tarticles[c].bottommost = max(articles[c].bottommost, i);\n\t\t\t\t\tarticles[c].leftmost = min(articles[c].leftmost, j);\n\t\t\t\t\tarticles[c].rightmost = max(articles[c].rightmost, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (remove_all()) {\n\t\t\tcout << \"SAFE\" << endl;\n\t\t} else {\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n\nconst int NICO = 252521;\nbool graph[26][26];\nint state[26];\n\nbool dfs(int u){\n    state[u] = 1;\n\n    bool f = false;\n    for(int v=0;v<26;v++){\n        if(!graph[u][v]){continue;}\n        \n        if(state[v] == 0){\n            f |= dfs(v);\n        }else if(state[v] == 1){\n            return true;\n        }\n    }\n    state[u] = 2;\n    return f;\n}\n\nbool hasCycle(){\n    for(int i=0;i<26;i++){\n        state[i] = 0;\n    }\n\n    bool f = false;\n    for(int i=0;i<26;i++){\n        if(!state[i]){f |= dfs(i);}\n    }\n\n    return f;\n}\n\nint main(){\n    int N;\n    std::cin >> N;\n\n    for(int i=0;i<N;i++){\n        int H, W;\n        std::cin >> H >> W;\n\n        std::string S[50];\n        int l[50], r[50], t[50], b[50];\n        std::fill(l, l+50, NICO);\n        std::fill(r, r+50, -NICO);\n        std::fill(t, t+50, NICO);    \n        std::fill(b, b+50, -NICO);\n        \n        std::fill(&graph[0][0], &graph[0][0]+26*26, false);\n    \n        for(int i=0;i<H;i++){\n            std::cin >> S[i];\n\n            for(int j=0;j<W;j++){\n                if(!std::isalpha(S[i][j])){continue;}\n\n                int index = S[i][j] - 'A';\n                l[index] = std::min(l[index], j);\n                r[index] = std::max(r[index], j);\n                t[index] = std::min(t[index], i);\n                b[index] = std::max(b[index], i);\n            }\n        }\n\n        bool f = true;\n        for(int i=0;i<26;i++){\n            if(l[i] == NICO){continue;}\n\n            for(int j=t[i];j<=b[i];j++){\n                for(int k=l[i];k<=r[i];k++){\n                    if(S[j][k] == '.'){f = false;}\n                    if(S[j][k] - 'A' != i){\n                        graph[i][S[j][k] - 'A'] = true;\n                    }\n                }\n            }\n        }\n\n        for(int i=0;i<26;i++){\n            for(int j=0;j<26;j++){\n                if(graph[i][j] && graph[j][i]){f = false;}\n            }\n        }\n\n        // for(int i=0;i<26;i++){\n        //     printf(\"%c:\", 'A'+i);\n        //     for(int j=0;j<26;j++){\n        //         printf(\"%d \", graph[i][j]);\n        //     }\n        //     puts(\"\");\n        // }\n        \n        if(f && !hasCycle()){\n            std::cout << \"SAFE\" << std::endl;\n        }else{\n            std::cout << \"SUSPICIOUS\" << std::endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define rrep(i, a, b) for (int i = ((int)a) - 1; i >= ((int)a); --i)\n#define all(x) x.begin(), x.end()\n#define sz(x) ((int)x.size())\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\nvoid dump_impl(string s) {}\ntemplate <class H, class... T>\nvoid dump_impl(string s, H head, T... tail) {\n    int p = 0;\n    rep(i, 0, sz(s)) {\n        char x = s[i];\n        if (p == 0 && x == ',') {\n            cerr << \"=\" << head << \", \";\n            dump_impl(s.substr(i + 1), tail...);\n            return;\n        } else {\n            cerr << x;\n            if (x == '(') p++;\n            if (x == ')') p--;\n        }\n    }\n}\n#ifdef LOCAL\n#define dump(...) do { cerr << \"\\x1b[33;1m\"; dump_impl(#__VA_ARGS__ \",\", __VA_ARGS__); cerr << \"\\x1b[0m\" << endl; } while (0) \n#else\n#define dump(...)\n#endif\n\nconstexpr int DY[8] = {-1, 0, 1, 0, -1, 1, 1, -1};\nconstexpr int DX[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nstruct Range {\n    int mn_x;\n    int mx_x;\n    int mn_y;\n    int mx_y;\n    Range() {\n        mn_x = 1000;\n        mn_y = 1000;\n        mx_x = -1000;\n        mx_y = -1000;\n    }\n    void update(int y, int x) {\n        mn_x = min(mn_x, x);\n        mx_x = max(mx_x, x);\n        mn_y = min(mn_y, y);\n        mx_y = max(mx_y, y);\n    }\n};\n\nvoid solve(int H, int W) {\n    vector<string> S(H); rep(i, 0, H) cin >> S[i];\n\n    vector<Range> range(26);\n    rep(i, 0, H) {\n        rep(j, 0, W) {\n            if (S[i][j] == '.') continue;\n            int x = S[i][j] - 'A';\n            range[x].update(i, j);\n        }\n    }\n\n    vector<vector<int>> G(26);\n    vector<int> deg(26);\n    rep(i, 0, 26) {\n        bool ng = false;\n        rep(y, range[i].mn_y, range[i].mx_y + 1) {\n            rep(x, range[i].mn_x, range[i].mx_x + 1) {\n                if (S[y][x] == '.') {\n                    ng = true;\n                } else if (S[y][x] - 'A' != i) {\n                    G[S[y][x] - 'A'].push_back(i);\n                    deg[i]++;\n                }\n            }\n        }\n        if (ng) {\n            cout << \"SUSPICIOUS\" << endl;\n            return;\n        }\n    }\n    queue<int> q;\n    rep(i, 0, 26) {\n        if (deg[i] == 0) {\n            q.push(i);\n        }\n    }\n    int cnt = 0;\n    while (sz(q)) {\n        int v = q.front(); q.pop();\n        cnt++;\n        for (int w : G[v]) {\n            deg[w]--;\n            if (deg[w] == 0) {\n                q.push(w);\n            }\n        }\n    }\n    if (cnt != 26) {\n        cout << \"SUSPICIOUS\" << endl;\n    } else {\n        cout << \"SAFE\" << endl;\n    }\n}\n\nsigned main() {\n    int T;\n    cin >> T;\n    rep(i, 0, T) {\n        int W, H;\n        cin >> H >> W;\n        if (W == 0 && H ==0) break;\n        solve(H, W);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\n\nint main(int argc, char *argv[]){\n  int n, w, h;\n  cin >> n;\n  for (int r = 0; r < n; r++) {\n    pair<int, int> p[7][2];\n    map<char, int> matrial;\n    cin >> h >> w;\n\n    char grid[h][w];\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> grid[i][j];\n        if(grid[i][j] != '.' &&\n           matrial.find(grid[i][j]) == matrial.end()){\n          matrial[grid[i][j]] = matrial.size();\n        }\n      }\n    }\n\n    vector<int> perm(matrial.size());\n    for (int i = 0; i < matrial.size(); i++) {\n      p[i][0].first = 1e9, p[i][0].second = 1e9;\n      p[i][1].first = 0,   p[i][1].second = 0;\n      perm[i] = i;\n    }\n\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if(matrial.find(grid[i][j]) != matrial.end()){\n          char tmp = matrial[grid[i][j]];\n          p[tmp][0].first  = min(p[tmp][0].first,  j);\n          p[tmp][0].second = min(p[tmp][0].second, i);\n          p[tmp][1].first  = max(p[tmp][1].first,  j);\n          p[tmp][1].second = max(p[tmp][1].second, i);\n        }\n      }\n    }\n    // for (auto &a: matrial){\n    //   std::cout << a.first << \" \" << a.second << std::endl;\n    // }\n    // for (int i = 0; i < matrial.size(); i++) {\n    //   std::cout << \"min:\" << std::endl;\n    //   std::cout << p[i][0].first << \" \" << p[i][0].second << std::endl;\n    //   std::cout << \"max:\" << std::endl;\n    //   std::cout << p[i][1].first << \" \" << p[i][1].second << std::endl;\n    // }\n    // std::cout << matrial.size() << std::endl;\n    \n    bool flag;\n    do{\n      flag = true;\n      for (int i = 0; i < matrial.size(); i++) {\n        for (int j = p[i][0].second; j <= p[i][1].second; j++) {\n          for (int k = p[i][0].first; k <= p[i][1].first; k++) {\n            if(grid[j][k] == '.' ||\n               perm[matrial[grid[j][k]]] > perm[i]){\n              flag = false;\n              i = 10;\n              j = p[i][1].second + 10;\n              k = p[i][1].first  + 10;\n            }\n          }\n        }\n      }\n    }while(next_permutation(perm.begin(), perm.end()) &&\n           flag == false);\n    if(flag){\n      std::cout << \"SAFE\" << std::endl;\n    }else{\n      std::cout << \"SUSPICIOUS\" << std::endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\nbool solve(int h, int w){\n    vector<string> v(h);\n    for (auto &&i : v) {\n        cin >> i;\n    }\n    int ok = 1;\n    while(ok){\n        ok = 0;\n        for (char i = 'A'; i < 'Z'; ++i) {\n            int maxy = 0, miny = h, maxx = 0, minx = w;\n            for (int j = 0; j < h; ++j) {\n                for (int k = 0; k < w; ++k) {\n                    if(v[j][k] == i) {\n                        maxy = max(maxy, j);\n                        miny = min(miny, j);\n                        maxx = max(maxx, k);\n                        minx = min(minx, k);\n                    }\n                }\n            }\n            if(miny == h) continue;\n            int filled = 1;\n            for (int j = miny; j <= maxy; ++j) {\n                for (int k = minx; k <= maxx; ++k) {\n                    if(v[j][k] != i && v[j][k] != '?') filled = 0;\n                }\n            }\n            if(filled){\n                ok = 1;\n                for (int j = miny; j <= maxy; ++j) {\n                    for (int k = minx; k <= maxx; ++k) {\n                        v[j][k] = '?';\n                    }\n                }\n            }\n        }\n    }\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            if(isalpha(v[i][j])) return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int q; cin >> q;\n    while(q--){\n        int h, w;\n        cin >> h >> w;\n        puts(solve(h, w) ? \"SAFE\" : \"SUSPICIOUS\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<set>\n#include<map>\n#include<string>\n#include<cctype>\n\n#define N 64\nusing namespace std;\n\nbool isrectangle(char c, map<char,int> &s,\n\t\t char M[][N], int mini, int maxi, int minj, int maxj)\n{\n  for(int i = mini; i <= maxi; ++i){\n    for(int j = minj; j <= maxj; ++j){\n      if( !isalpha(M[i][j]) ) return false;\n      if( s[c] < s[M[i][j]] ) return false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  int T;\n  cin >> T;\n  for(int tc=1;tc<=T;++tc){\n    int h,w;\n    bool suspicious=true;\n    map<char,int> s;\n    vector<int> xdepth;\n    bool susp[256];\n    char M[N][N];\n    cin >> h >> w;\n\n    for(int i = 0; i < 256; ++i){\n      susp[i]=true;\n    }\n    for(int i = 0; i < h; ++i){\n      for(int j = 0; j < w; ++j){\n\tcin >> M[i][j];\n\tif(isalpha(M[i][j])){\n\t  s[M[i][j]]=0;\n\t}\n      }\n    }\n\n    xdepth.resize(s.size());\n    for(int i = 0; i < s.size(); ++i){\n      xdepth[i]=i;\n    }\n\n    do{\n      bool ok=true;\n      map<char,int>::iterator its = s.begin();\n      for(int i = 0; i < xdepth.size(); ++i){\n\tits->second = xdepth[i];\n\t++its;\n      }\n      for(its = s.begin(); its != s.end(); ++its){\n\tint mini=N,maxi=-1,minj=N,maxj=-1;\n\tfor(int i = 0; i < h; ++i){\n\t  for(int j = 0; j < w; ++j){\n\t    if( M[i][j] == its->first ){\n\t      mini = min( mini, i );\n\t      maxi = max( maxi, i );\n\t      minj = min( minj, j );\n\t      maxj = max( maxj, j );\n\t    }\n\t  }\n\t}\n\tif( !isrectangle( its->first, s, M, mini, maxi, minj, maxj ) ){\n\t  ok=false;\n\t}\n      }\n      if(ok){\n\tsuspicious = false;\n      }\n    }while(next_permutation( xdepth.begin(), xdepth.end() ));\n\n    if( suspicious ){\n      cout << \"SUSPICIOUS\";\n    }else{\n      cout << \"SAFE\";\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n    int h,w;\nvector<int> dp;\n\nbool dfs(vector<char> &ch,vector<string> &c,int s){\n  if(dp[s]!=-1) return dp[s];\n  if(s==(1<<ch.size())-1){\n    return true;\n  }\n  bool isok=false;\n  for(int col=0;col<ch.size();col++){\n    bool piyo=true;\n    if(s&(1<<col)) continue; \n    int l=100;\n    int r=0;\n    int u=100;\n    int b=0;      \n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(c[i][j]==ch[col]){\n\t  l=min(l,j);\n\t  r=max(r,j);\n\t  u=min(u,i);\n\t  b=max(b,i);\n\t}\n      } \n    }\n    b++,r++;\n    stack<pair<int,int>> st;\n    for(int i=u;i<b;i++){\n      for(int j=l;j<r;j++){\n\tif(!isalpha(c[i][j])){\n\t  piyo=false;\n\t}\n\telse{\n\t  if(c[i][j]==ch[col]){\n\t    c[i][j]='.';\n\t    st.push(make_pair(i,j));\n\t  }\n\t}\t    \n      }\n    }\n    piyo&=dfs(ch,c,s+(1<<col));\n    while(!st.empty()){\n      pair<int,int> val=st.top();st.pop();\n      c[val.first][val.second]=ch[col];\n    }\n    isok|=piyo;\n  }\n  return dp[s]=isok;\n}\n\n\nint main(){\n  int n;\n  cin>>n;\n  for(int loop=0;loop<n;loop++){\n    dp.clear();\n\n    cin>>h>>w;\n    vector<string> c(h);\n    for(auto &v:c) cin>>v;\n    set<char> s;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(c[i][j]!='.') s.insert(c[i][j]);\n      }\n    }\n    vector<char> ch(s.begin(),s.end());\n    dp.resize((1<<ch.size())+1,-1);\n    bool res=dfs(ch,c,0); \n    cout<<(res ? \"SAFE\" : \"SUSPICIOUS\")<<endl;\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint H,W,T;\nstring str,u;\nbool used[26],flg;\n\nint A[26],B[26],C[26],D[26];\n\nchar t[50][50];\n\nchar tmp;\n\nvoid input();\nvoid init();\n\nbool check(char ch){\n  int z= ch-'A';\n  for(int i=A[z];i<=C[z];i++){\n    for(int j=D[z];j<=B[z];j++){\n      if(t[i][j]!='.'&&used[t[i][j]-'A']==false)continue;\n      if(t[i][j]!=ch)return false;\n    }\n  }\n  return true;\n}\n\n\n\nint main(){\n  cin>>T;\n  while(T--){\n    init();\n    input();\n\n    while(1){\n \n      flg=false;\n\n      for(int i=0;i<(int)u.size();i++){\n\t\n\tif(used[u[i]-'A']==false)continue;\n\tif(check(u[i])==true){\n\t  flg=true;\n\t  used[u[i]-'A']=false;\n\t  break;\n\t}\n      }\n      if(flg==false)break;\n    }\n\n    flg=false;\n    for(int i=0;i<26;i++)flg|=used[i];\n    cout<<(flg?\"SUSPICIOUS\":\"SAFE\")<<endl;\n  }\n  return 0;\n}\n\nvoid input(){\n  int X;\n  cin>>H>>W;\n  for(int i=0;i<H;i++){\n    cin>>str;\n    for(int j=0;j<W;j++){\n      t[i][j]=str[j];\n      if(t[i][j]=='.')continue;\n      X=t[i][j]-'A';\n      if(used[X]==false)u.push_back(t[i][j]);\n      used[X]=true;\n      A[X]=min(A[X],i);\n      B[X]=max(B[X],j);\n      C[X]=max(C[X],i);\n      D[X]=min(D[X],j);\n    }\n  }\n}\n\nvoid init(){\n  for(int i=0;i<26;i++){\n    A[i]=50;\n    B[i]=0;\n    C[i]=0;\n    D[i]=50;\n    used[i]=false;\n  }\n  u=\"\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n#include <functional>\n#include <chrono>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\nconst double EPS = 1e-9;\n\nconst int MAX = 55;\nint H, W;\nstring data[MAX], check[MAX];\nmap<char, pair<pair<int, int>, pair<int, int>>> mp;\n\nvoid solve() {\n    cin >> H >> W;\n    vector<char> cs;\n    for (int i = 0; i < H; ++i) {\n        cin >> data[i];\n        for (int j = 0; j < W; ++j) {\n            if (isalpha(data[i][j])) {\n                if (mp.count(data[i][j])) {\n                    chmin(mp[data[i][j]].first.first, i);\n                    chmin(mp[data[i][j]].first.second, j);\n                    chmax(mp[data[i][j]].second.first, i);\n                    chmax(mp[data[i][j]].second.second, j);\n                } else {\n                    cs.emplace_back(data[i][j]);\n                    mp[data[i][j]] = make_pair(make_pair(i, j), make_pair(i, j));\n                }\n            }\n        }\n    }\n    sort(cs.begin(), cs.end());\n    bool f = (mp.size() == 0);\n    do {\n        fill(check, check + MAX, string(MAX, '.'));\n        for (char c : cs) {\n            int mii, mij, mai, maj;\n            pair<int, int> mi, ma;\n            tie(mi, ma) = mp[c];\n            tie(mii, mij) = mi;\n            tie(mai, maj) = ma;\n            for (int i = mii; i <= mai; ++i) {\n                for (int j = mij; j <= maj; ++j) {\n                    check[i][j] = c;\n                }\n            }\n        }\n        if ([&]() {\n            for (int i = 0; i < H; ++i) {\n                for (int j = 0; j < W; ++j) {\n                    if (data[i][j] != check[i][j]) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }()) {\n            f = true;\n            break;\n        }\n    } while (next_permutation(cs.begin(), cs.end()));\n    cout << (f ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n    mp.clear();\n}\n\nint main(void) {\n    int test;\n    cin >> test;\n    REP(i, test) {\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint N;\nvector<string> g;\nint used[128],x1[128],x2[128],y1[128],y2[128];\nvector<int> p;\n\nvector<char> v;\nbool bt(){\n\n\tfor(int k=0;k<p.size();k++){\n\t\tfor(int i=y1[p[k]];i<=y2[p[k]];i++){\n\t\t\tfor(int j=x1[p[k]];j<=x2[p[k]];j++){\n\t\t\t\tchar c = g[i][j];\n\t\t\t\tif(c == '.')return false;\n\t\t\t\tif(find(p.begin(),p.end(),p[k]) > find(p.begin(),p.end(),c)){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\tfor(int k=0;k<v.size();k++){\n\t\tif(!used[v[k]]){\n\t\t\tused[v[k]] = true;\n\t\t\tp.push_back(v[k]);\n\t\t\tif( bt() ) return true;\n\t\t\tp.pop_back();\n\t\t\tused[v[k]] = false;\n\t\t}\n\t}\n\treturn p.size() == v.size();\n}\nint main(){\n\tint T;\n\t\n\tcin >> T;\n\twhile(T--){\n\t\tint W,H;\n\t\tcin >> H >> W;\n\t\tvector<string> data(H);\n\t\tfor(int i=0;i<H;i++)\n\t\t\tcin >> data[i];\n\t\t\t\n\t\tg = data;\n\t\t\n\t\tint check[128];\n\t\t\n\t\tfor(int i=0;i<128;i++)\n\t\t\tx1[i] = x2[i] = y1[i] = y2[i] = used[i] = check[i] = 0;\n\n\t\tfor(int i=0;i<128;i++)\n\t\t\tx1[i] = y1[i] = 9999;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tchar c = data[i][j];\n\t\t\t\tif(c != '.'){\n\t\t\t\t\tcheck[c] = true;\n\t\t\t\t\tx1[c] = min(j,x1[c]);\n\t\t\t\t\tx2[c] = max(j,x2[c]);\n\t\t\t\t\ty1[c] = min(i,y1[c]);\n\t\t\t\t\ty2[c] = max(i,y2[c]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tv.clear();\n\t\tp.clear();\n\t\t\n\t\tfor(int i=0;i<128;i++)\n\t\t\tif(check[i])v.push_back(i);\n\n\t\t\t\n\t\tcout << ( bt() ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint main(){\n  int T;\n  cin >> T;\n  while(T--){\n    int H, W;\n    cin >> H >> W;\n    vector<string> S(H);\n    bool app[26] = {};\n\n    for(int i = 0; i < H; ++i){\n      cin >> S[i];\n      for(int j = 0; j < W; ++j){\n        if(S[i][j] == '.') continue;\n        app[S[i][j]-'A'] = true;\n      }\n    }\n    string A;\n    for(int i = 0; i < 26; ++i)\n      if(app[i]) A.push_back('A'+i);\n    map<char,int> L, R, T, B;\n    const int INF = 1e9;\n    for(auto c : A){\n      L[c] = INF;\n      T[c] = INF;\n    }\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n        char c = S[i][j];\n        if(c == '.') continue;\n        L[c] = min(L[c],j);\n        R[c] = max(R[c],j);\n        T[c] = min(T[c],i);\n        B[c] = max(B[c],i);\n      }\n    }\n    \n    auto judge = [&](){\n                   map<char,size_t> O;\n                   for(size_t i = 0; i < A.length(); ++i)\n                     O[A[i]] = i;\n                   for(auto c : A){\n                     for(int i = T[c]; i <= B[c]; ++i){\n                       for(int j = L[c]; j <= R[c]; ++j){\n                         if(S[i][j] == '.' or O[S[i][j]] > O[c])\n                           return false;\n                       }\n                     }\n                   }\n                   return true;\n                 };\n    \n    string ans = \"SUSPICIOUS\";\n    do{\n      if(judge()){\n        ans = \"SAFE\";\n        break;\n      }\n    }while(next_permutation(A.begin(), A.end()));\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint w, h;\nint sy, sx, gy, gx;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nbool can(int y,int x) {\n\tif(0 <= y && y < h && 0 <= x && x < w) return true;\n\treturn false;\n}\n\nvector<string> s;\nchar c;\nbool used[55][55], visited[55][55];\n\nbool check() {\n\tREP(i, sy, gy+1){\n\t\tREP(j, sx, gx+1) {\n\t\t\tif(s[i][j] == c || used[i][j]) continue;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid f() {\n\tREP(i, sy, gy+1) {\n\t\tREP(j, sx, gx+1) {\n\t\t\tused[i][j] = true;\n\t\t}\n\t}\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\trep(q, n) {\n\t\tcin >> h >> w;\n\t\ts.resize(h);\n\t\trep(i, h) cin >> s[i];\n\n\t\tmemset(used, 0, sizeof(used));\n\t\tset<char> S;\n\n\t\tbool flag = true, update = true;\n\t\twhile(update) {\n\t\t\tupdate = false;\n\t\t\trep(i, h) {\n\t\t\t\trep(j, w) {\n\t\t\t\t\tif(s[i][j] == '.') continue;\n\n\t\t\t\t\tif(used[i][j]) continue;\n\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t\tgy = i;\n\t\t\t\t\tgx = j;\n\t\t\t\t\tc = s[i][j];\n\t\t\t\t\tmemset(visited, 0, sizeof(visited));\n\n\t\t\t\t\trep(k, h) {\n\t\t\t\t\t\trep(l, w) {\n\t\t\t\t\t\t\tif(s[k][l] == c) {\n\t\t\t\t\t\t\t\tsy = min(sy, k);\n\t\t\t\t\t\t\t\tsx = min(sx, l);\n\t\t\t\t\t\t\t\tgy = max(gy, k);\n\t\t\t\t\t\t\t\tgx = max(gx, l);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(S.find(c) == S.end() && check()) {\n\t\t\t\t\t\tf();\n\t\t\t\t\t\tS.insert(c);\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tif(used[i][j]) continue;\n\t\t\t\tif(s[i][j] == '.') continue;\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\n\t\tif(flag) cout << \"SAFE\" << endl;\n\t\telse cout << \"SUSPICIOUS\" << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n)-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(b)-1;i>=(a);--i)\n#define ALL(a) a.begin(),a.end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n    if (a > b) { a = b; return true; }\n    return false;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"{\";\n    int a = 0;\n    for (auto &tp : mp) {\n        if (a) os << \", \";\n        a = 1;\n        os << tp;\n    }\n    return os << \"}\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int T; cin >> T;\n    while (T--) {\n        int H, W; cin >> H >> W;\n        vector<string> S(H);\n        REP(i, H) cin >> S[i];\n        for (bool updated = 1; updated;) {\n            updated = 0;\n            vi top(26, H), bottom(26, -1), left(26, W), right(26, -1);\n            map<char,int> exist;\n            REP(i, H) {\n                REP(j, W) {\n                    if (S[i][j] == '.' or S[i][j] == '#') continue;\n                    chmin(top[S[i][j]-'A'], i);\n                    chmax(bottom[S[i][j]-'A'], i);\n                    chmin(left[S[i][j]-'A'], j);\n                    chmax(right[S[i][j]-'A'], j);\n                    exist[S[i][j]] = 1;\n                }\n            }\n            for (auto &tp : exist) {\n                char c = tp.first;\n                bool square = 1;\n                FOR(i, top[c-'A'], bottom[c-'A']+1) {\n                    FOR(j, left[c-'A'], right[c-'A']+1) {\n                        if (S[i][j] != c and S[i][j] != '#') {\n                            square = 0;\n                        }\n                    }\n                }\n                if (!square) continue;\n                FOR(i, top[c-'A'], bottom[c-'A']+1) {\n                    FOR(j, left[c-'A'], right[c-'A']+1) {\n                        S[i][j] = '#';\n                    }\n                }\n                updated = 1;\n            }\n        }\n\n        bool ans = 1;\n        REP(i, H) {\n            REP(j, W) {\n                if (S[i][j] != '.' and S[i][j] != '#') {\n                    ans = 0;\n                }\n            }\n        }\n        cout << (ans ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int T;\n  cin >> T;\n  for (int i = 0; i < T; i++){\n    int H, W;\n    cin >> H >> W;\n    vector<vector<char>> C(H, vector<char>(W));\n    for (int j = 0; j < H; j++){\n      for (int k = 0; k < W; k++){\n        cin >> C[j][k];\n      }\n    }\n    vector<int> Y_min(26, H);\n    vector<int> Y_max(26, -1);\n    vector<int> X_min(26, W);\n    vector<int> X_max(26, -1);\n    for (int j = 0; j < H; j++){\n      for (int k = 0; k < W; k++){\n        if (C[j][k] != '.'){\n          int c = C[j][k] - 'A';\n          Y_min[c] = min(Y_min[c], j);\n          Y_max[c] = max(Y_max[c], j);\n          X_min[c] = min(X_min[c], k);\n          X_max[c] = max(X_max[c], k);\n        }\n      }\n    }\n    bool ok = true;\n    vector<set<int>> E(26);\n    for (int j = 0; j < 26; j++){\n      if (Y_min[j] != H){\n        for (int k = Y_min[j]; k <= Y_max[j]; k++){\n          for (int l = X_min[j]; l <= X_max[j]; l++){\n            if (C[k][l] == '.'){\n              ok = false;\n            } else {\n              int c = C[k][l] - 'A';\n              if (c != j){\n                E[c].insert(j);\n              }\n            }\n          }\n        }\n      }\n    }\n    if (!ok){\n      cout << \"SUSPICIOUS\" << endl;\n    } else {\n      vector<int> deg(26, 0);\n      for (int j = 0; j < 26; j++){\n        for (int k : E[j]){\n          deg[k]++;\n        }\n      }\n      queue<int> Q;\n      for (int j = 0; j < 26; j++){\n        if (deg[j] == 0){\n          Q.push(j);\n        }\n      }\n      while (!Q.empty()){\n        int v = Q.front();\n        Q.pop();\n        for (int w : E[v]){\n          deg[w]--;\n          if (deg[w] == 0){\n            Q.push(w);\n          }\n        }\n      }\n      for (int j = 0; j < 26; j++){\n        if (deg[j] != 0){\n          ok = false;\n        }\n      }\n      if (ok){\n        cout << \"SAFE\" << endl;\n      } else {\n        cout << \"SUSPICIOUS\" << endl;\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\n\nint main(){\n\tint N;\n\tcin >> N;\n\twhile(N--){\n\t\tint H, W;\n\t\tcin >> H >> W;\n\t\tvector<string> bag(H);\n\t\tfor(int i = 0; i < H; ++i){ cin >> bag[i]; }\n\t\tbool flag = true;\n\t\twhile(flag){\n\t\t\tflag = false;\n\t\t\tint minx[26], miny[26], maxx[26], maxy[26];\n\t\t\tfor(int i = 0; i < 26; ++i){\n\t\t\t\tminx[i] = miny[i] = 10000;\n\t\t\t\tmaxx[i] = maxy[i] = 0;\n\t\t\t}\n\t\t\tbool found[26] = { false };\n\t\t\tfor(int i = 0; i < H; ++i){\n\t\t\t\tfor(int j = 0; j < W; ++j){\n\t\t\t\t\tif(isupper(bag[i][j])){\n\t\t\t\t\t\tint c = bag[i][j] - 'A';\n\t\t\t\t\t\tminx[c] = min(minx[c], j);\n\t\t\t\t\t\tminy[c] = min(miny[c], i);\n\t\t\t\t\t\tmaxx[c] = max(maxx[c], j);\n\t\t\t\t\t\tmaxy[c] = max(maxy[c], i);\n\t\t\t\t\t\tfound[c] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int c = 0; c < 26; ++c){\n\t\t\t\tif(!found[c]){ continue; }\n\t\t\t\tchar letter = c + 'A';\n\t\t\t\tbool accept = true;\n\t\t\t\tfor(int i = miny[c]; i <= maxy[c]; ++i){\n\t\t\t\t\tfor(int j = minx[c]; j <= maxx[c]; ++j){\n\t\t\t\t\t\tif(bag[i][j] != letter && bag[i][j] != '?'){\n\t\t\t\t\t\t\taccept = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(accept){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tfor(int i = miny[c]; i <= maxy[c]; ++i){\n\t\t\t\t\t\tfor(int j = minx[c]; j <= maxx[c]; ++j){\n\t\t\t\t\t\t\tbag[i][j] = '?';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tflag = true;\n\t\tfor(int i = 0; i < H; ++i){\n\t\t\tfor(int j = 0; j < W; ++j){\n\t\t\t\tif(bag[i][j] != '.' && bag[i][j] != '?'){ flag = false; }\n\t\t\t}\n\t\t}\n\t\tcout << (flag ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\n\nstring in[100];\nint H,W;\nint pos[1000];\nvoid solve(){\n  cin >> H >> W;\n  map<char,int> minx,miny,maxx,maxy;\n  rep(i, H) cin >> in[i];\n  rep(i, H) rep(j, W){\n    char ch=in[i][j];\n    if(ch=='.') continue;\n    if(minx.count(ch))\n      minx[ch]=min(minx[ch],i);\n    else minx[ch]=i;\n\n    if(miny.count(ch))\n      miny[ch]=min(miny[ch],j);\n    else miny[ch]=j;\n\n    maxx[ch] = max(maxx[ch],i);\n    maxy[ch] = max(maxy[ch],j);\n  }\n\n  string str;\n  FOR(it,maxx) str += it->F;\n  pos['.']=100;\n  do{\n    rep(i,SZ(str)) pos[(int)str[i]] = i;\n    bool ok=true;\n    rep(i,SZ(str)){\n      char ch=str[i];\n      int x1=minx[ch];\n      int x2=maxx[ch];\n      int y1=miny[ch];\n      int y2=maxy[ch];\n      for(int j=x1;j<=x2;++j)\n        for(int k=y1;k<=y2;++k)\n          if(pos[(int)in[j][k]]>i){\n            ok=false;\n            break;\n          }\n    }\n    \n    if(ok){\n      cout << \"SAFE\" << endl;\n      return;\n    }\n      \n  }while(next_permutation(ALL(str)));\n\n  cout << \"SUSPICIOUS\" << endl;\n}\n\nint main(int argc, char *argv[])\n{\n  int n;\n  cin >> n;\n  rep(i, n) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n#define USE_MATH_DEFINES\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 30;\nconst double EPS = 1E-9;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\n\nint h, w;\nchar field[50][50];\nbool used[50][50];\nbool per[8];\nchar ma[8];\nmap<char, int> mp;\nint c;\n\nbool dfs(int n, int rest){\n\tif(n == 0) {\n\t\treturn rest == 0 ? true : false;\n\t}\n\tbool res = false;\n\tfor(int i = 1; i < c; i++){\n\t\tif(per[i]) continue;\n\t\telse{\n\t\t\tper[i] = true;\n\t\t\tint ymax = 0;\n\t\t\tint ymin = INF;\n\t\t\tint xmax = 0;\n\t\t\tint xmin = INF;\n\t\t\tbool f = true;\n\t\t\tint cnt = 0;\n\t\t\tfor(int j = 0; j < h; j++){\n\t\t\t\tfor(int k = 0; k < w; k++){\n\t\t\t\t\tif(mp[field[j][k]] == i){\n\t\t\t\t\t\tymax = max(ymax, j);\n\t\t\t\t\t\tymin = min(ymin, j);\n\t\t\t\t\t\txmax = max(xmax, k);\n\t\t\t\t\t\txmin = min(xmin, k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = ymin; j <= ymax; j++){\n\t\t\t\tfor(int k = xmin; k <= xmax; k++){\n\t\t\t\t\tif(per[mp[field[j][k]]]){\n\t\t\t\t\t\tif(mp[field[j][k]] == i) cnt++;\n\t\t\t\t\t}else f = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tres |= dfs(n-1, rest - cnt);\n\t\t\t\tper[i] = false;\n\t\t\t}else{\n\t\t\t\tper[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\nusing namespace std;\n\nint N,H,W;\nchar Screen[51][51];\nstring ans;\nset<char> Set;\nset<char>::iterator it;\n\nvoid Check()\n{\n  while(1){\n    int sum=0;\n    for(it=Set.begin();it!=Set.end();it++){\n      char t=*it;\n      int a=H,b=0,c=W,d=0;\n      for(int i=0;i<H;i++){\n\tfor(int j=0;j<W;j++){\n\t  if(Screen[i][j]==t){\n\t    a=min(a,i);\n\t    b=max(b,i);\n\t    c=min(c,j);\n\t    d=max(d,j);\n\t  }\n\t}\n      }\n      if(a==H && b==0 && c==W && d==0)continue;\n      bool flag=true;\n      for(int i=a;i<=b;i++){\n\tfor(int j=c;j<=d;j++){\n\t  if(Screen[i][j]!=t && Screen[i][j]!='#')flag=false;\n\t}\n      }\n      if(!flag)continue;\n      sum++;\n      for(int i=a;i<=b;i++)for(int j=c;j<=d;j++)Screen[i][j]='#';\n    }\n    if(sum==0)return;\n  }\n}\n\nint main()\n{\n  cin>>N;\n  for(int i=0;i<N;i++){\n    cin>>H>>W;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin>>Screen[i][j];\n\tif(Screen[i][j]!='.')Set.insert(Screen[i][j]);\n      }\n    }\n    ans=\"SAFE\";\n    Check();\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tif(Screen[i][j]!='.' && Screen[i][j]!='#')ans=\"SUSPICIOUS\";\n      }\n    }\t\t\t\t\t\t    \n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint h, w;\nchar input[51][51];\nmap<char, int> m;\nvector<vector<int> > v;\n\nbool isfront(int now, char tgt, vector<int> range)\n{\n\tfor(int i = range[0]; i <= range[2]; i++){\n\t\tfor(int j = range[1]; j <= range[3]; j++){\n\t\t\tif(input[i][j] < 0 || (input[i][j] != tgt && (now & (1 << input[i][j])) != 0)) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool issafe()\n{\n\tint tmp = m.size();\n\t// cout << tmp << endl;\n\tif(tmp == 0) return true;\n\tvector<bool> result(1 << tmp, false);\n\tresult[0] = true;\n\tfor(int i = 0; i < (1 << tmp); i++){\n\t\tif(!result[i]) continue;\n\t\tfor(int j = 0; j < tmp; j++){\n\t\t\tif((i & (1 << j)) != 0) continue;\n\t\t\tvector<int> tmp = v[j];\n\t\t\t// cout << j << \" : \" << endl;\n\t\t\t// \tfor(int l = 0; l < 4; l++){\n\t\t\t// \t\tcout << tmp[l] << \" \";\n\t\t\t// \t}\n\t\t\t// \tcout << endl;\n\t\t\tresult[(i | (1 << j))] = result[(i | (1 << j))] || isfront(i, j, tmp);\n\t\t\t// cout << result[(i | (1 << j))] << endl;\n\t\t}\n\t}\n\treturn result[(1 << tmp) - 1];\n}\n\nint main()\n{\n\tint num;\n\tcin >> num;\n\tfor(int i = 0; i < num; i++){\n\t\tm.clear();\n\t\tv.clear();\n\t\tint cnt = 0;\n\t\tcin >> h >> w;\n\t\tfor(int j = 0; j < h; j++){\n\t\t\tfor(int k = 0; k < w; k++){\n\t\t\t\tchar tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tif(tmp == '.'){\n\t\t\t\t\tinput[j][k] = -1;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if(m.find(tmp) == m.end()){\n\t\t\t\t\tv.push_back(vector<int>{j, k, j, k});\n\t\t\t\t\tm[tmp] = cnt;\n\t\t\t\t\tcnt++;\n\t\t\t\t\t// cout << tmp << \"->\" << cnt-1 << endl;\n\t\t\t\t}\n\t\t\t\tinput[j][k] = m[tmp];\n\t\t\t\tv[m[tmp]][0] = min(v[m[tmp]][0], j);\n\t\t\t\tv[m[tmp]][1] = min(v[m[tmp]][1], k);\n\t\t\t\tv[m[tmp]][2] = max(v[m[tmp]][2], j);\n\t\t\t\tv[m[tmp]][3] = max(v[m[tmp]][3], k);\n\t\t\t}\n\t\t}\n\t\tif(issafe()) cout << \"SAFE\" << endl;\n\t\telse cout << \"SUSPICIOUS\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint l[26], r[26], top[26], bottom[26], h, w, d;\nbool flag[26], come[26];\nstring str[55];\nvector<int> front[26];\n\nvoid my_unique(vector<int>& x){\n    sort(x.begin(), x.end());\n    vector<int>::iterator it = unique(x.begin(), x.end());\n    x.erase(it, x.end());\n}\n\nint loop(int x){\n    if(come[x])return true;\n    bool res = false;\n    come[x] = true;\n    for(int i = 0;i < front[x].size();i++){\n\tres |= loop(front[x][i]);\n    }\n    come[x] = false;\n    return res;\n}\n\nint main(){\n    cin >> d;\n    while(d--){\n\tfill(l, l + 26, 100);\n\tfill(r, r + 26, -1);\n\tfill(bottom, bottom + 26, 100);\n\tfill(top, top + 26, -1);\n\tcin >> h >> w;\n\tfor(int i = 0;i < h;i++){\n\t    cin >> str[i];\n\t    for(int j = 0;j < w;j++){\n\t\tif(str[i][j] == '.')continue;\n\t\tint tmp = str[i][j] - 'A';\n\t\tflag[tmp] = true;\n\t\tl[tmp] = min(l[tmp], i);\n\t\tbottom[tmp] = min(bottom[tmp], j);\n\t\tr[tmp] = max(r[tmp], i);\n\t\ttop[tmp] = max(top[tmp], j);\n\t    }\n\t}\n\tbool res = true;\n\tfor(int s = 0;s < 26;s++){\n\t    front[s].clear();\n\t    if(!flag[s])continue;\n\t    for(int i = l[s];i <= r[s];i++){\n\t\tfor(int j = bottom[s];j <= top[s];j++){\n\t\t    if(str[i][j] == '.')res = false;\n\t\t    if(str[i][j] != 'A' + s){\n\t\t\tfront[s].push_back(str[i][j] - 'A');\n\t\t    }\n\t\t}\n\t    }\n\t    my_unique(front[s]);\n\t}\n\tfor(int i = 0;res && i < 26;i++){\n\t    if(loop(i))res = false;\n\t}\n\tif(res)\n\t    cout << \"SAFE\" << endl;\n\telse\n\t    cout << \"SUSPICIOUS\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\nint main() {\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tint Y, X; cin >> Y >> X;\n\t\tvector<vector<int>>field(Y, vector<int>(X));\n\t\tvector<int>chars;\n\t\tfor (int i = 0; i < Y; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < X; ++j) {\n\t\t\t\tif (st[j] == '.') {\n\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfield[i][j] = st[j];\n\t\t\t\t\tif (find(chars.begin(),chars.end(),st[j]) == chars.end()) {\n\t\t\t\t\t\tchars.push_back(st[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>perms(chars.size());\n\t\tiota(perms.begin(), perms.end(), 0);\n\t\tbool ans = false;\n\t\tdo {\n\t\t\tbool allok = true;\n\t\t\tvector<vector<int>>nfield(field);\n\t\t\tfor (int i = 0; i < perms.size(); ++i) {\n\t\t\t\tint nc = chars[i];\n\t\t\t\tint l = 100;\n\t\t\t\tint r = 0;\n\t\t\t\tint u = 100;\n\t\t\t\tint d = 0;\n\t\t\t\tfor (int j = 0; j < Y; ++j) {\n\t\t\t\t\tfor (int k = 0; k < X; ++k) {\n\t\t\t\t\t\tif (nfield[j][k] == nc ) {\n\t\t\t\t\t\t\tl = min(l, k); r = max(r, k);\n\t\t\t\t\t\t\tu = min(u, j); d = max(d, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int j = l; j <=r; ++j) {\n\t\t\t\t\tfor (int k = u; k <=d; ++k) {\n\t\t\t\t\t\tif (nfield[k][j] == nc || nfield[k][j] == 1000) {\n\t\t\t\t\t\t\tnfield[k][j] = 1000;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!ok) {\n\t\t\t\t\tallok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (allok) {\n\t\t\t\tans = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (next_permutation(perms.begin(), perms.end()));\n\t\tif (ans) {\n\t\t\tcout << \"SAFE\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nvector<char> a;\nbool af[33];\nint xma[33],xmi[33];\nint yma[33],ymi[33];\nint h,w;\nchar m[55][55];\nbool used[33];\n\nint dx[] = {0,1};\nint dy[] = {1,0};\nbool f[55][55];\nint dfs(char c,int x,int y){\n  if(f[x][y]) return 0;\n  f[x][y] = true;\n  int res = 1;\n  for(int i = 0; i < 2; i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(xma[c-'A'] < nx || yma[c-'A'] < ny || m[nx][ny] == '.' || !used[m[nx][ny]-'A'] ) continue;\n    res += dfs(c,nx,ny);\n  }\n  return res;\n}\n\nbool solve(int bit){\n  if(bit == (1<<(int)a.size())-1) return true;\n\n  for(int i = 0; i < (int)a.size(); i++){\n    memset(f,false,sizeof(f));\n    if(bit & 1<<i) continue;\n    int al = a[i] - 'A';\n    used[al] = true;\n    if(dfs(a[i],xmi[al],ymi[al]) != (xma[al]-xmi[al]+1) * (yma[al]-ymi[al]+1) ){\n      used[al] = false;\n      continue;\n    }\n    //cout << a[i] << \" = \" <<  dfs(a[i],xmi[al],ymi[al]) << endl;\n    if(solve(bit | 1<<i)) return true;\n    used[al] = false;\n  }\n  return false;\n}\n\nint main(void){\n  int n;\n  cin >> n;\n  for(int k = 0; k < n; k++){\n    a.clear();\n    for(int i = 0; i < 33; i++){\n      af[i] = used[i] = false;\n      xma[i] = yma[i] = -1;\n      xmi[i] = ymi[i] = 111;\n    }\n\n    cin >> h >> w;\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n\tcin >> m[j][i];\n\tif(m[j][i] < 'A' || 'Z' < m[j][i]) continue;\n\tif(!af[m[j][i]-'A']){\n\t  af[m[j][i]-'A'] = true;\n\t  a.push_back(m[j][i]);\n\t}\n\txma[m[j][i]-'A'] = max(xma[m[j][i]-'A'],j);\n\txmi[m[j][i]-'A'] = min(xmi[m[j][i]-'A'],j);\n\tyma[m[j][i]-'A'] = max(yma[m[j][i]-'A'],i);\n\tymi[m[j][i]-'A'] = min(ymi[m[j][i]-'A'],i);\n      }\n    }\n\n    if(solve(0)) cout << \"SAFE\" << endl;\n    else cout << \"SUSPICIOUS\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\nint main(){\n    int n; cin>>n;\n    while(n--){\n        int h, w; cin>>h>>w;\n        vector<string> s(h);\n        \n        set<char> st;\n        for(int i=0; i<h; i++){\n            cin>>s[i];\n            for(int j=0; j<w; j++){\n                if(s[i][j] != '.') st.insert(s[i][j]);\n            }\n        }\n\n        if(st.size() == 0){\n            cout << \"SAFE\" << endl;\n            continue;\n        }\n\n        vector<char> v;\n        for(auto i:st){\n            v.eb(i);\n        }\n\n        sort(v.begin(), v.end());\n\n        map<char, T> mp;\n        for(auto i:v){\n            get<0>(mp[i]) = 1e9;\n            get<1>(mp[i]) = 1e9;\n            get<2>(mp[i]) = 0;\n            get<3>(mp[i]) = 0;\n        }\n\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                for(int k=0; k<v.size(); k++){\n                    if(s[i][j] == v[k]){\n                        chmin(get<0>(mp[v[k]]), j);\n                        chmin(get<1>(mp[v[k]]), i);\n                        chmax(get<2>(mp[v[k]]), j);\n                        chmax(get<3>(mp[v[k]]), i);\n                        break;\n                    }\n                }\n            }\n        }\n\n        bool valid = false;\n        do{\n            auto cs = s;\n            for(int k=0; k<v.size(); k++){\n                int xmin=1e9, ymin=1e9, xmax=0, ymax=0;\n                int cnt=0;\n                for(int i=0; i<h; i++){\n                    for(int j=0; j<w; j++){\n                        if(cs[i][j] == v[k]){\n                            chmin(xmin, j);\n                            chmin(ymin, i);\n                            chmax(xmax, j);\n                            chmax(ymax, i);\n                            cnt++;\n\n                            for(int l=k+1; l<v.size(); l++){\n                                if(get<0>(mp[v[l]]) <= j && get<1>(mp[v[l]]) <= i && j <= get<2>(mp[v[l]]) && i <= get<3>(mp[v[l]])){\n                                    cs[i][j] = v[l];\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if((ymax - ymin + 1) * (xmax - xmin + 1) != cnt){\n                    break;\n                }\n\n                if(k == v.size() - 1){\n                    cout << \"SAFE\" << endl;\n                    valid = true;\n                }\n            }\n\n            if(valid) break;\n\n        }while(next_permutation(v.begin(), v.end()));\n\n        if(!valid) cout << \"SUSPICIOUS\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\nint h,w;\nchar c[51][51];\nmap<char,int> m;\nint lmin[7],lmax[7],umin[7],umax[7];\n\nbool rect(int index){\n  for(int y=umin[index];y<=umax[index];y++){\n    for(int x=lmin[index];x<=lmax[index];x++){\n      if(m[c[y][x]]!=index&&c[y][x]!='?')\n\treturn false;\n    }\n  }\n  return true;\n}\nvoid replaceToAny(int index){\n  for(int y=umin[index];y<=umax[index];y++){\n    for(int x=lmin[index];x<=lmax[index];x++){\n      c[y][x]='?';\n    }\n  }\n}\nvoid solve(){\n  m.clear();\n  REP(i,7){\n    lmin[i]=umin[i]=999;\n    lmax[i]=umax[i]=0;\n  }\n  cin>>h>>w;\n  REP(y,h){\n    REP(x,w){\n      cin>>c[y][x];\n      if(c[y][x]=='.')continue;\n      if(m.find(c[y][x])==m.end()){\n\tint sz=m.size();\n\tm[c[y][x]]=sz;\n      }\n      lmin[m[c[y][x]]]=min(lmin[m[c[y][x]]],x);\n      lmax[m[c[y][x]]]=max(lmax[m[c[y][x]]],x);\n      umin[m[c[y][x]]]=min(umin[m[c[y][x]]],y);\n      umax[m[c[y][x]]]=max(umax[m[c[y][x]]],y);\n      //      cout<<lmin[0]<<\" \"<<lmax[0]<<\" \"<<umin[0]<<\" \"<<umax[0];\n    }\n  }\n  while(m.size()>0){\n    for(auto i=m.begin();i!=m.end();i++){\n      if(rect((*i).second)){\n\treplaceToAny((*i).second);\n\tm.erase(i);\n\tgoto NEXT;\n      }\n    }\n    cout<<\"SUSPICIOUS\"<<endl;\n    return;\n  NEXT:;\n  }\n  cout<<\"SAFE\"<<endl;\n}\nint main(){ _;\n  int n;cin>>n;\n  REP(i,n){\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool solve(int H, int W) {\n    char s[H][W];\n    set<char> se;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> s[i][j];\n            if(s[i][j] != '.')se.insert(s[i][j]);\n        }\n    }\n    vector<char> v;\n    for (auto x : se) v.push_back(x);\n\n    sort(v.begin(), v.end());\n    map<char, int> lower, upper, left, right;\n    for (auto x : v) {\n        lower[x] = 0;\n        upper[x] = 100;\n        left[x] = 100;\n        right[x] = 0;\n    }\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (s[i][j] == '.') continue;\n            char tmp = s[i][j];\n            lower[tmp] = max(lower[tmp], i);\n            upper[tmp] = min(upper[tmp], i);\n            left[tmp] = min(left[tmp], j);\n            right[tmp] = max(right[tmp], j);\n        }\n    }\n    map<char, set<int>> adj;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            vector<char> tmp;\n            for (auto x : v) {\n                if (upper[x] <= i && i <= lower[x]) {\n                    if (left[x] <= j && j <= right[x]) {\n                        tmp.push_back(x);\n                        if(s[i][j] == '.')return false;\n                    }\n                }\n            }\n            if(s[i][j] == '.')continue;\n            bool flag = true;\n            for (auto x : tmp) {\n                if (x == s[i][j]) {\n                    flag = false;\n                } else {\n                    adj[x].insert(s[i][j]);\n                }\n            }\n            if (flag) return false;\n        }\n    }\n    do {\n        map<char, int> idx;\n        for (int i = 0; i < v.size(); i++) {\n            idx[v[i]] = i;\n        }\n        bool ok = true;\n        for (auto x : v) {\n            for (auto to : adj[x]) {\n                if (idx[x] < idx[to]) {\n                    ok = false;\n                }\n            }\n        }\n        if (ok) return true;\n    } while (next_permutation(v.begin(), v.end()));\n    return false;\n}\n\nint main() {\n    int T;\n    cin >> T;\n    for (int i = 0; i < T; i++) {\n        int H, W;\n        cin >> H >> W;\n        cout << (solve(H, W) ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint main(void)\n{\n  int n;\n  cin >> n;\n  REP(_,n){\n    int h,w;\n    cin >> h >> w;\n    if(!h) return 0;\n    vector<string> sc;\n    sc.resize(h);\n    REP(i,h) cin >> sc[i];\n    set<char> car;\n    car.clear();\n    REP(i,h) REP(j,w) if(sc[i][j]!='.') car.insert(sc[i][j]);\n    vector<char> carv(car.begin(),car.end());\n    string answer=\"SUSPICIOUS\";\n    do{\n      vector<string> prob;\n      prob.resize(h);\n      REP(i,h) prob[i].assign(w,'.');\n      REP(dep,carv.size()){\n\tint u=100,d=-1,l=100,r=-1;\n\tREP(i,h) REP(j,w) if(sc[i][j]==carv[dep]){\n\t  u=min(u,i);\n\t  d=max(d,i);\n\t  l=min(l,j);\n\t  r=max(r,j);\n\t}\n\tFOR(i,u,d+1) FOR(j,l,r+1){\n\t  prob[i][j]=carv[dep];\n\t}\n      }\n      bool flag=true;\n      REP(i,h) if(sc[i]!=prob[i]) flag=false;\n      if(flag){\n\tanswer=\"SAFE\";\n\tbreak;\n      }\n    }while(next_permutation(carv.begin(),carv.end()));\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvoid solve() {\n    int H, W;\n    cin >> H >> W;\n\n    vector<string> S(H);\n    for (auto& s : S) cin >> s;\n\n    vector<vector<bool>> on(26, vector<bool>(26, false));\n    // on[x][y] => xがyより上にある\n\n    bool judge = true;\n    for (char c = 'A'; c <= 'Z'; ++c) {\n        int lx = H, rx = -1, ly = W, ry = -1;\n        for (int x = 0; x < H; ++x) {\n            for (int y = 0; y < W; ++y) {\n                if (S[x][y] != c) continue;\n                lx = min(lx, x), rx = max(rx, x);\n                ly = min(ly, y), ry = max(ry, y);\n            }\n        }\n\n        for (int x = lx; x <= rx; ++x) {\n            for (int y = ly; y <= ry; ++y) {\n                if (S[x][y] == '.') {\n                    judge = false;\n                } else if (S[x][y] != c) {\n                    // S[x][y]はcの上にある\n                    on[S[x][y] - 'A'][c - 'A'] = true;\n                }\n            }\n        }\n    }\n\n    for (int k = 0; k < 26; ++k) {\n        for (int i = 0; i < 26; ++i) {\n            for (int j = 0; j < 26; ++j) {\n                if (on[i][k] && on[k][j]) on[i][j] = true;\n            }\n        }\n    }\n\n\n    for (int i = 0; i < 26; ++i) {\n        if (on[i][i]) judge = false;\n    }\n\n    cout << (judge ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    for (int i = 0; i < N; ++i) solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define int long long\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define REP(i, a, n) for (int i = (a); i <= (n); i++)\n#define all(a) (a).begin(), (a).end()\n\nusing namespace std;\n\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, -1, 0, 1 };\n\nint nextInt() {int a; cin >> a; return a;}\nchar nextChar() {char a; cin >> a; return a;}\ndouble nextDouble() {double a; cin >> a; return a;}\nstring nextString() {string a; cin >> a; return a;}\n\nvoid inputVector(vector<int> &v, int &n) {rep(i,n){v.push_back(nextInt());}}\nvoid inputVector(vector<double> &v, int &n) {rep(i,n){v.push_back(nextDouble());}}\nvoid inputVector(vector<string> &v, int &n) {rep(i,n){v.push_back(nextString());}}\n\nsigned main() {\n    int n;\n    cin >> n;\n\n    rep(loop, n) {\n\tint h, w;\n\tcin >> h >> w;\n\n\tvector<string> board;\n\tinputVector(board, h);\n\n\tint minX[27], maxX[27], minY[27], maxY[27];\n\trep(i, 27) {\n\t    minX[i] = INT_MAX;\n\t    maxX[i] = -INT_MAX;\n\t    minY[i] = INT_MAX;\n\t    maxY[i] = -INT_MAX;\n\t}\n\n\trep(y, h) {\n\t    rep(x, w) {\n\t\tif (board[y][x] == '.') continue;\n\t\tint arg = board[y][x] - 'A';\n\t\tminX[arg] = min(minX[arg], x);\n\t\tmaxX[arg] = max(maxX[arg], x);\n\t\tminY[arg] = min(minY[arg], y);\n\t\tmaxY[arg] = max(maxY[arg], y);\n\t    }\n\t}\n\n\tint cnt = 0;\n\trep(i, 27) if (minX[i] != INT_MAX) cnt++;\n\n\tbool ok = true;\n\trep(tmp, cnt) {\n\t    bool dflag = false;\n\t    rep(i, 27) {\n\t\tif (minX[i] == INT_MAX) continue;\n\t\tbool flag = true;\n\t\tREP(y, minY[i], maxY[i]) {\n\t\t    REP(x, minX[i], maxX[i]) {\n\t\t\tif (board[y][x] != '?' && board[y][x] != (char)(i + 'A')) {\n\t\t\t    flag = false;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (!flag) continue;\n\t\tdflag = true;\n\t\tREP(y, minY[i], maxY[i]) {\n\t\t    REP(x, minX[i], maxX[i]) {\n\t\t\tboard[y][x] = '?';\n\t\t    }\n\t\t}\n\t\tminX[i] = INT_MAX;\n\t\tbreak;\n\t    }\n\t    if (!dflag) {\n\t\tok = false;\n\t\tbreak;\n\t    }\n\t}\n\tcout << (ok ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nint H, W;\nchar grid[51][51];\n\nstruct Data {\n    int id, top, left, down, right;\n    Data() {\n        id = -1;\n        top = left = -1;\n        down = right = 100;\n    }\n};\n\nbool Loop(int dst, int src, const vector<vector<int>> &g)\n{\n    if (dst == src)\n        return true;\n\n    for (unsigned i = 0; i < g[src].size(); ++i)\n        if (Loop(dst, g[src][i], g))\n            return true;\n\n    return false;\n}\n\nbool Solve()\n{\n    unordered_map<char, Data> hash;\n    int id = 0;\n\n    // 登録\n    for (int i = 0; i < H; ++i)\n        for (int j = 0; j < W; ++j)\n            if (grid[i][j] != '.') {\n                char c = grid[i][j];\n\n                if (hash.count(c) == 0) {  // 未登録\n                    hash[c].id = id++;\n                    hash[c].top = hash[c].down = i;\n                    hash[c].left = hash[c].right = j;\n                }\n                else { // 登録済み\n                    hash[c].top = min(hash[c].top, i);\n                    hash[c].down = max(hash[c].down, i);\n                    hash[c].left = min(hash[c].left, j);\n                    hash[c].right = max(hash[c].right, j);\n                }\n            }\n\n    vector<vector<int>> g(id, vector<int>());\n    // 長方形の確認\n    auto it = hash.begin();\n    while (it != hash.end()) {\n        for (int y = it->second.top; y <= it->second.down; ++y)\n            for (int x = it->second.left; x <= it->second.right; ++x) {\n                int src = it->second.id;\n\n                if (grid[y][x] == '.')\n                    return false;\n                else if (grid[y][x] != it->first &&\n                         count(g[src].begin(), g[src].end(),\n                               hash[grid[y][x]].id) == 0)\n                    g[src].push_back(hash[grid[y][x]].id);\n            }\n        ++it;\n    }\n\n    // // ループが存在するかのチェック\n    // for (unsigned i = 0; i < g.size(); ++i)\n    //     for (unsigned j = 0; j < g[i].size(); ++j)\n    //         if (Loop(i, g[i][j], g))\n    //             return false;\n\n    return true;\n}\n\nint main()\n{\n    int T;\n\n    cin >> T;\n    while (T--) {\n        cin >> H >> W;\n\n        for (int i = 0; i < H; ++i)\n            for (int j = 0; j < W; ++j)\n                cin >> grid[i][j];\n\n        if (Solve())\n            cout << \"SAFE\\n\";\n        else\n            cout << \"SUSPICIOUS\\n\";\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\nint n;\nint H,W,T;\nstring str;\nbool used[26],flg;\nint A[26],B[26],C[26],D[26];\nchar t[50][50];\nchar tmp;\nvoid input();\nvoid init();\nbool check(char ch){\n  int z=ch-'A';\n  if(A[z]==-1){\n    int a=49,b=0,c=0,d=49;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tif(t[i][j]==ch){\n\t  a=min(a,i);\n\t  b=max(b,j);\n\t  c=max(c,i);\n\t  d=min(d,j);\n\t}\n      }\n    }\n    A[z]=a;  B[z]=b;  C[z]=c;  D[z]=d;\n  }\n  for(int i=A[z];i<=C[z];i++){\n    for(int j=D[z];j<=B[z];j++){\n      if(t[i][j]=='?')continue;\n      if(t[i][j]!=ch)return false;\n    }\n  }\n  return true;\n  \n}\n\nvoid draw(char ch){\n  int z=ch-'A';\n  for(int i=A[z];i<=C[z];i++){\n    for(int j=D[z];j<=B[z];j++){\n      t[i][j]='?';\n    }\n  }\n}\nint main(){\n  cin>>T;\n  while(T--){\n    init();\n    input();\n\n    while(1){\n      /*\n      for(int i=0;i<H;i++){\n\tfor(int j=0;j<W;j++){\n\t  cout<<t[i][j];\n\t}\n\tcout<<endl;\n      }\n      */\n      flg=false;\n\n      for(int i=0;i<26;i++){\n\tif(used[i]==false)continue;\n\tif(check(i+'A')==true){\n\t  flg=true;\n\t  draw(i+'A');\n\t  used[i]=false;\n\t  break;\n\t}\n      }\n      if(flg==false)break;\n    }\n    flg=false;\n    for(int i=0;i<26;i++)flg|=used[i];\n    cout<<(flg?\"SUSPICIOUS\":\"SAFE\")<<endl;\n  }\n  return 0;\n}\nvoid input(){\n  cin>>H>>W;\n  for(int i=0;i<H;i++){\n    cin>>str;\n    for(int j=0;j<W;j++){\n      t[i][j]=str[j];\n      used[t[i][j]-'A']=true;\n    }\n  }\n}\nvoid init(){\n  for(int i=0;i<26;i++){\n    A[i]=-1;\n    used[i]=false;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 28;\n\nstring table[50];\nint h,w;\n\nbool check(vector<char>& c){\n\tstring t[50];\n\trep(i,h) t[i]=table[i];\n\tint n=c.size();\n\trep(i,n){\n\t\tchar cur=c[i];\n\t\tint hmin=inf,hmax=-inf;\n\t\tint wmin=inf,wmax=-inf;\n\t\trep(j,h)rep(k,w){\n\t\t\tif(t[j][k]==cur){\n\t\t\t\thmin=min(hmin,j);\n\t\t\t\thmax=max(hmax,j);\n\t\t\t\twmin=min(wmin,k);\n\t\t\t\twmax=max(wmax,k);\n\t\t\t}\n\t\t}\n\n\t\tbool ok=true;\n\t\tfor(int j=hmin;j<=hmax;j++){\n\t\t\tfor(int k=wmin;k<=wmax;k++){\n\t\t\t\tif(t[j][k]==c[i]||t[j][k]=='*')\n\t\t\t\t\tt[j][k]='*';\n\t\t\t\telse\n\t\t\t\t\tok=false;\n\t\t\t}\n\t\t}\n\n\t\tif(!ok)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n\nint main(void){\n\tint t;\n\tcin >> t;\n\trep(nomeaning,t){\n\t\tcin >> h >> w;\n\t\trep(i,h)\n\t\t\tcin >> table[i];\n\t\tset<char> tmp;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(table[i][j]!='.')\n\t\t\t\ttmp.insert(table[i][j]);\n\t\t}\n\n\t\tvector<char> c;\n\t\teach(it,tmp)\n\t\t\tc.pb(*it);\n\t\tsort(c.begin(),c.end());\n\t\tbool safe=false;\n\t\tdo{\n\t\t\tif(safe)\n\t\t\t\tbreak;\n\t\t\tsafe|=check(c);\n\t\t}while(next_permutation(c.begin(),c.end()));\n\n\t\tif(safe||c.size()==0)\n\t\t\tcout << \"SAFE\" << endl;\n\t\telse\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n\nvector<int> topologicalSort(int v,const vector<int> edge[]){\n\tvector<int> zeros;\n\tvector<int> in(v),res;\n\tfor(int i=0;i<v;i++){\n\t\tfor(int j=0;j<(int)edge[i].size();j++)in[edge[i][j]]++;\n\t}\n\tfor(int i=0;i<v;i++)if(in[i]==0)zeros.push_back(i);\n\twhile(!zeros.empty()){\n\t\tint u=zeros.back();\n\t\tzeros.pop_back();\n\t\tres.push_back(u);\n\t\tfor(int i=0;i<(int)edge[u].size();i++){\n\t\t\tif(--in[edge[u][i]]==0)zeros.push_back(edge[u][i]);\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main(){\n\tint h,w;\n\tint xmin[26],ymin[26],xmax[26],ymax[26];\n\tchar image[50][50];\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tfill_n(xmin,26,51);\n\t\tfill_n(ymin,26,51);\n\t\tfill_n(xmax,26,-1);\n\t\tfill_n(ymax,26,-1);\n\t\tcin>>h>>w;\n\t\tbool ok=true;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar c;\n\t\t\t\tcin>>c;\n\t\t\t\timage[i][j]=c;\n\t\t\t\tint idx=c-'A';\n\t\t\t\tymin[idx]=min(ymin[idx],i);\n\t\t\t\tymax[idx]=max(ymax[idx],i);\n\t\t\t\txmin[idx]=min(xmin[idx],j);\n\t\t\t\txmax[idx]=max(xmax[idx],j);\n\t\t\t}\n\t\t}\n\t\tvector<int> edge[26];\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(ymax[i]==-1)continue;\n\t\t\tfor(int y=ymin[i];y<=ymax[i];y++){\n\t\t\t\tfor(int x=xmin[i];x<=xmax[i];x++){\n\t\t\t\t\tif(image[y][x]=='.'){\n\t\t\t\t\t\tok=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(i+'A'!=image[y][x])edge[i].push_back(image[y][x]-'A');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> order(topologicalSort(26,edge));\n\t\tif(ok&&order.size()==26)cout<<\"SAFE\"<<endl;\n\t\telse cout<<\"SUSPICIOUS\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint w, h;\nint sy, sx, gy, gx;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nbool can(int y,int x) {\n\tif(0 <= y && y < h && 0 <= x && x < w) return true;\n\treturn false;\n}\n\nvector<string> s;\nchar c;\nbool used[55][55], visited[55][55];\n\nvoid dfs(int i, int j) {\n\tvisited[i][j] = true;\n\tsy = min(sy, i);\n\tsx = min(sx, j);\n\tgy = max(gy, i);\n\tgx = max(gx, j);\n\n\trep(i, 4) {\n\t\tint y = i + dy[i];\n\t\tint x = j + dx[i];\n\n\t\tif(can(y, x) && !visited[y][x] && s[y][x] == c) {\n\t\t\tdfs(y, x);\n\t\t}\n\t}\n}\n\nbool check() {\n\tREP(i, sy, gy+1){\n\t\tREP(j, sx, gx+1) {\n\t\t\tif(s[i][j] == c || used[i][j]) continue;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid f() {\n\tREP(i, sy, gy+1) {\n\t\tREP(j, sx, gx+1) {\n\t\t\tused[i][j] = true;\n\t\t}\n\t}\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\trep(q, n) {\n\t\tcin >> h >> w;\n\t\ts.resize(h);\n\t\trep(i, h) cin >> s[i];\n\n\t\tmemset(used, 0, sizeof(used));\n\t\tset<char> S;\n\n\t\tbool flag = true;\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tif(used[i][j]) continue;\n\t\t\t\tif(s[i][j] == '.') continue;\n\n\t\t\t\tsy = i;\n\t\t\t\tsx = j;\n\t\t\t\tgy = i;\n\t\t\t\tgx = j;\n\t\t\t\tc = s[i][j];\n\t\t\t\tmemset(visited, 0, sizeof(visited));\n\t\t\t\tdfs(i, j);\n\n\t\t\t\tif(S.find(c) == S.end() && check()) {\n\t\t\t\t\tf();\n\t\t\t\t} else {\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!flag) break;\n\t\t}\n\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tif(used[i][j]) continue;\n\t\t\t\tif(s[i][j] == '.') continue;\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\n\t\tif(flag) cout << \"SAFE\" << endl;\n\t\telse cout << \"SUSPICIOUS\" << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nint adj[26][26];\n\nbool cycle(void){\n  int d[26];\n  for(int i=0;i<26;i++)d[i] = 0;\n\n  for(int i=0;i<26;i++){\n    for(int j=0;j<26;j++){\n      for(int k=0;k<26;k++){\n\tif(adj[k][j] && d[j] > d[k] + adj[k][j]){\n\t  d[j] = d[k] + adj[k][j];\n\t  if(i==25)return true;\n\t}\n      }\n    }\n  }\n  return false;\n}\n\nint main(){\n  int n,h,w;\n  string pict[50];\n  int rr,rd,lu,ll;\n  bool flag;\n\n  cin >> n;\n  while(n){\n    n--;\n    cin >> h >> w;\n    for(int i=0;i<h;i++)cin >> pict[i];\n    for(int i=0;i<26;i++){\n      for(int j=0;j<26;j++)adj[i][j] = 0;\n    }\n\n    flag = true;\n    for(int i='A';i<='Z';i++){\n      rr = 0;\n      rd = 0;\n      lu = h;\n      ll = w;\n      for(int j=0;j<h;j++){\n\tfor(int k=0;k<w;k++){\n\t  if(pict[j][k] == i){\n\t    rr = max(rr,k);\n\t    rd = max(rd,j);\n\t    lu = min(lu,j);\n\t    ll = min(ll,k);\n\t  }\n\t}\n      }\n\n      for(int j=lu;j<=rd;j++){\n\tfor(int k=ll;k<=rr;k++){\n\t  if(pict[j][k] == '.'){\n\t    flag = false;\n\t    break;\n\t  }else if(pict[j][k] != i){\n\t    if(!adj[pict[j][k] - 'A'][i - 'A']){\n\t      adj[pict[j][k] - 'A'][i - 'A'] = -1;\n\t      \n\t      if(cycle()){\n\t\tflag = false;\n\t\tbreak;\n\t      }\n\t    }\n\t  }\n\t}\n\tif(!flag)break;\n      }\n      if(!flag)break;\n    }\n\n    if(!flag)cout << \"SUSPICIOUS\" << endl;\n    else cout << \"SAFE\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define rep(i,N) for(ll i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nint n;\nint h, w;\nstring table[50];\n\nint main() {\n\tcin >> n;\n\trep(kk, n) {\n\t\tcin >> h >> w;\n\t\tvector<char> vi;\n\t\trep(i, h) {\n\t\t\tcin >> table[i];\n\t\t\trep(j, w) {\n\t\t\t\tif (table[i][j] != '.')vi.push_back(table[i][j]);\n\t\t\t}\n\t\t}\n\t\tsort(ALL(vi));\n\t\tvi.erase(unique(ALL(vi)), vi.end());\n\t\tbool f = 0;\n\t\tll mci[4][26] = {};\n\t\trep(i, 26) {\n\t\t\tmci[2][i] = h - 1;\n\t\t\tmci[3][i] = w - 1;\n\t\t}\n\t\tset<char> sc;\n\t\trep(i, vi.size()) {\n\t\t\trep(j, h) {\n\t\t\t\trep(k, w) {\n\t\t\t\t\tif (table[j][k] != '.') {\n\t\t\t\t\t\tmci[0][table[j][k] - 'A'] = max(mci[0][table[j][k] - 'A'], j);\n\t\t\t\t\t\tmci[1][table[j][k] - 'A'] = max(mci[1][table[j][k] - 'A'], k);\n\t\t\t\t\t\tmci[2][table[j][k] - 'A'] = min(mci[2][table[j][k] - 'A'], j);\n\t\t\t\t\t\tmci[3][table[j][k] - 'A'] = min(mci[3][table[j][k] - 'A'], k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, vi.size()) {\n\t\t\t\tbool ok = 1;\n\t\t\t\t//rep(i, 4) {\n\t\t\t\t//\tcout << mci[2][vi[j] - 'A'] << \" \" << mci[0][vi[j] - 'A'] << \" \"\n\t\t\t\t//\t\t<< mci[3][vi[j] - 'A'] << \" \" << mci[1][vi[j] - 'A'] << endl;\n\t\t\t\t//}\n\t\t\t\tfor (int k = mci[2][vi[j] - 'A']; k <= mci[0][vi[j] - 'A']; k++) {\n\t\t\t\t\tfor (int l = mci[3][vi[j] - 'A']; l <= mci[1][vi[j] - 'A']; l++) {\n\t\t\t\t\t\tif (table[k][l] != vi[j]) {\n\t\t\t\t\t\t\tif (sc.find(table[k][l]) == sc.end())ok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok)sc.insert(vi[j]);\n\t\t\t}\n\t\t}\n\t\tif (sc.size() == vi.size())cout << \"SAFE\" << endl;\n\t\telse cout << \"SUSPICIOUS\" << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <bitset>\nusing namespace std;\n#define INF\t100000000\n#define MOD 1000000007\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sec second\n#define lb lower_bound\n#define ub upper_bound\n#define SS stringstream\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define SORT(x) sort((x).begin(), (x).end())\n#define clr(a,b) memset((a),(b),sizeof(a))\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<P> Vp;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nint h, w;\nchar cell[50][50];\nchar check[7];\n\nint A(char x){\n\trep(i,7) if(check[i] == x) return i;\n\treturn -1;\n}\n\nstring solve(){\n\tscanf(\"%d%d\", &h, &w);\n\trep(i,h) rep(j,w) scanf(\" %c\", &cell[i][j]);\n\trep(i,7) check[i] = ' ';\n\trep(i,h) rep(j,w){\n\t\tif(cell[i][j] == '.') continue;\n\t\tbool ok = false;\n\t\trep(k,7){\n\t\t\tif(check[k] == cell[i][j]){\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok){\n\t\t\trep(k,7){\n\t\t\t\tif(check[k] == ' '){\n\t\t\t\t\tcheck[k] = cell[i][j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint maxx[7], minx[7], maxy[7], miny[7];\n\trep(i,7){\n\t\tmaxx[i] = -1;\n\t\tminx[i] = INF;\n\t\tmaxy[i] = -1;\n\t\tminy[i] = INF;\n\t}\n\trep(i,h) rep(j,w){\n\t\tif(cell[i][j] == '.') continue;\n\t\tint t = A(cell[i][j]);\n\t\tmaxx[t] = max(maxx[t],j);\n\t\tminx[t] = min(minx[t],j);\n\t\tmaxy[t] = max(maxy[t],i);\n\t\tminy[t] = min(miny[t],i);\n\t}\n\tVi v[7];\n\trep(i,7){\n\t\tif(check[i] == ' ') continue;\n\t\tfor(int j = miny[i]; j <= maxy[i]; j++){\n\t\t\tfor(int k = minx[i]; k <= maxx[i]; k++){\n\t\t\t\tif(cell[j][k] == '.') return \"SUSPICIOUS\";\n\t\t\t\tif(cell[j][k] != check[i]){\n\t\t\t\t\tbool exist = false;\n\t\t\t\t\trep(l,v[i].size()){\n\t\t\t\t\t\tif(v[i][l] == A(cell[j][k])){\n\t\t\t\t\t\t\texist = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!exist) v[i].pb(A(cell[j][k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i,7){\n\t\tbool used[7];\n\t\trep(j,7) used[j] = false;\n\t\tqueue<int> que;\n\t\tque.push(i);\n\t\tused[i] = true;\n\t\twhile(true){\n\t\t\tif(que.size() == 0) break;\n\t\t\tint p = que.front(); que.pop();\n\t\t\trep(j,v[p].size()){\n\t\t\t\tif(used[v[p][j]]) return \"SUSPICIOUS\";\n\t\t\t\tused[v[p][j]] = true;\n\t\t\t\tque.push(v[p][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"SAFE\";\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\trep(i,n) cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define dme cout<<\"IMPOSSIBLE\"<<endl;return 0\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\n//12:15~\nconst int mod=1e9+7;\nconst int big=1e9+100;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){return a/gcd(a,b)*b;}\nvoid solve(void){\n\tint h,w,i,j,c;cin>>h>>w;\n\tvector<string> kai(h);\n\tfor(i=0;i<h;i++){cin>>kai[i];}\n\tint dame[26][26]={};\n\tarray<int,26> up,dow,lef,rig;\n\tfor(c=0;c<26;c++){up[c]=h;lef[c]=w;dow[c]=0;rig[c]=0;}\n\tint has[26]={0};\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(kai[i][j]=='.'){continue;}\n\t\t\tmineq(up[kai[i][j]-'A'],i);\n\t\t\tmaxeq(dow[kai[i][j]-'A'],i);\n\t\t\tmineq(lef[kai[i][j]-'A'],j);\n\t\t\tmaxeq(rig[kai[i][j]-'A'],j);\n\t\t\thas[kai[i][j]-'A']=1;\n\t\t}\n\t}\n\tfor(c=0;c<26;c++){\n\t\tfor(i=up[c];i<=dow[c];i++){\n\t\t\tfor(j=lef[c];j<=rig[c];j++){\n\t\t\t\tif(kai[i][j]=='.'){cout<<\"SUSPICIOUS\"<<endl;return;}\n\t\t\t\tdame[c][kai[i][j]-'A']=1;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> pa;\n\tfor(c=0;c<26;c++){if(has[c]){pa.pub(c);}}\n\tint n=pa.size();\n\tdo{\n\t\tint ok=1;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\tif(dame[pa[i]][pa[j]]){ok=0;break;}\n\t\t\t}\n\t\t}\n\t\tif(ok==1){cout<<\"SAFE\"<<endl;return;}\n\t}while(next_permutation(pa.begin(),pa.end()));\n\tcout<<\"SUSPICIOUS\"<<endl;return;\n}\nint main(void){\n\tint n;cin>>n;\n\twhile(n--){solve();}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <sstream>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, P> RECT;\n\nint INF = 100000;\n\nint main(){\n\t\n\tint N;\n\t\n\tcin >> N;\n\t\n\tfor(int piyo = 0; piyo < N; piyo++){\n\t\t\n\t\tint H, W;\n\t\t\n\t\tcin >> H >> W;\n\t\t\n\t\tif(H == 0 && W == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tstring map[100];\n\t\t\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tcin >> map[i];\n\t\t}\n\t\t\n\t\tRECT rect[26];\n\t\t\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\trect[i].first.first = INF;\n\t\t\trect[i].first.second = INF;\n\t\t\trect[i].second.first = 0;\n\t\t\trect[i].second.second = 0;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tif(map[i][j] != '.'){\n\t\t\t\t\trect[map[i][j] - 'A'].first.first = min(i, rect[map[i][j] - 'A'].first.first);\n\t\t\t\t\trect[map[i][j] - 'A'].first.second = min(j, rect[map[i][j] - 'A'].first.second);\n\t\t\t\t\trect[map[i][j] - 'A'].second.first = max(i, rect[map[i][j] - 'A'].second.first);\n\t\t\t\t\trect[map[i][j] - 'A'].second.second = max(j, rect[map[i][j] - 'A'].second.second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int loop = 0; loop < 10; loop++){\n\t\t\tfor(int i = 0; i < 26; i++){\n\t\t\t\tbool flag = true;\n\t\t\t\tfor(int y = rect[i].first.first; y <= rect[i].second.first; y++){\n\t\t\t\t\tfor(int x = rect[i].first.second; x <= rect[i].second.second; x++){\n\t\t\t\t\t\tif(map[y][x] != 'A' + i && map[y][x] != 'a'){\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(flag){\n\t\t\t\t\tfor(int y = rect[i].first.first; y <= rect[i].second.first; y++){\n\t\t\t\t\t\tfor(int x = rect[i].first.second; x <= rect[i].second.second; x++){\n\t\t\t\t\t\t\tmap[y][x] = 'a';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool ans = true;\n\t\t\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tif(map[i][j] != '.' && map[i][j] != 'a'){\n\t\t\t\t\tans = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ans){\n\t\t\tcout << \"SAFE\" << endl;\n\t\t}else{\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#define all(c) c.begin(),c.end()\n#define uni(c) c.erase(unique(all(c)),c.end())\n#define pb push_back\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w;\nbool ret(int now,vector<char> c,vector<string> s){\n\tif(now==c.size())\n\t\treturn true;\n\tint x1=100,x2=0,y1=100,y2=0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[i][j]==c[now]){\n\t\t\t\tx1=min(x1,j);\n\t\t\t\tx2=max(x2,j);\n\t\t\t\ty1=min(y1,i);\n\t\t\t\ty2=max(y2,i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=y1;i<=y2;i++){\n\t\tfor(int j=x1;j<=x2;j++){\n\t\t\tif(s[i][j]==c[now]||s[i][j]=='*'){\n\t\t\t\ts[i][j]='*';\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret(now+1,c,s);\n\t\n}\nint main(){\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\tcin>>h>>w;\n\t\t//s.resize(h);\n\t\tvector<string> s(h);\n\t\tvector<char> c;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>s[i];\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tc.pb(s[i][j]);\n\t\t\t}\n\t\t}\n\t\tsort(all(c));\n\t\tuni(c);\n\t\tbool flag=false;\n\t\tdo{\n\t\t\tif(ret(0,c,s)){\n\t\t\t\tflag=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}while(next_permutation(all(c)));\n\t\tif(flag){\n\t\t\tcout<<\"SAFE\"<<endl;\n\t\t}else\n\t\tcout<<\"SUSPICIOUS\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <map>\n#include <algorithm>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nstruct rect { int ly, ry, lx, rx; };\n\nint T, H, W;\nchar S[55][55];\n\nint main(void) {\n  cin >> T;\n  while(T--) {\n    cin >> H >> W;\n    REP(i, 0, H) cin >> S[i];\n\n    set<char> st;\n    REP(i, 0, H) REP(j, 0, W) if(S[i][j] != '.') st.insert(S[i][j]);\n    map<char, int> ctoi;\n    for(char i : st) ctoi[i] = ctoi.size();\n\n    int a[10];\n    REP(i, 0, 10) a[i] = i;\n\n    map<char, rect> p;\n    REP(i, 0, H) REP(j, 0, W) if(S[i][j] != '.') p[S[i][j]] = (rect) { i, i, j, j };\n    REP(i, 0, H) REP(j, 0, W) {\n      if(S[i][j] != '.') {\n        p[S[i][j]].ly = min(p[S[i][j]].ly, i);\n        p[S[i][j]].ry = max(p[S[i][j]].ry, i);\n        p[S[i][j]].lx = min(p[S[i][j]].lx, j);\n        p[S[i][j]].rx = max(p[S[i][j]].rx, j);\n      }\n    }\n\n    bool ans = false;\n    do {\n      bool f = true;\n      for(pair<char, rect> r : p) {\n        char c = r.first;\n        rect q = r.second;\n        REP(i, q.ly, q.ry + 1) REP(j, q.lx, q.rx + 1) {\n          if(S[i][j] == '.' || a[ctoi[c]] < a[ctoi[S[i][j]]]) {\n            f = false;\n            goto END;\n          }\n        }\nEND:;\n      }\n      ans = ans || f;\n      if(ans) break;\n    } while(next_permutation(a, a + st.size()));\n\n    cout << (ans ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define csize 26\nusing namespace std;\n\nstruct data {\n  int l, r, u, d;\n};\nint h, w, t;\nstring s[55];\ndata dummy{10000, -1, 100000, -1};\nvector<data> lst(26);\nbool memo[30][30] = {0};\nvector<int> cperm;\n\nbool solve();\nvoid lstset(int x, int i, int j);\n\nint main() {\n  cin >> t;\n  for(int tt = 0; tt < t; ++tt) {\n    cin >> h >> w;\n    for(int i = 0; i < h; ++i) cin >> s[i];\n    for(int i = -0; i < csize; ++i) lst[i] = dummy;\n    if(solve())\n      cout << \"SUSPICIOUS\" << endl;\n    else\n      cout << \"SAFE\" << endl;\n    for(int i = 0; i < 26; ++i)\n      for(int j = 0; j < 26; ++j) memo[i][j] = 0;\n    cperm.erase(cperm.begin(), cperm.end());\n  }\n  return 0;\n}\n\nbool solve() {\n  for(int i = 0; i < h; ++i)\n    for(int j = 0; j < w; ++j)\n      if(s[i][j] != '.') lstset(s[i][j] - 'A', i, j);\n  for(int i = 0; i < csize; ++i)\n    if(lst[i].r != -1) {\n      for(int j = lst[i].u; j <= lst[i].d; ++j)\n        for(int k = lst[i].l; k <= lst[i].r; ++k) {\n          if(s[j][k] == '.')\n            return 1;\n          else if(s[j][k] - 'A' != i)\n            memo[s[j][k] - 'A'][i] = 1;\n        }\n      cperm.push_back(i);\n    }\n  int cpermsize = cperm.size();\n  do {\n    bool ok = 1;\n    for(int i = 0; i < cpermsize; ++i)\n      for(int j = i + 1; j < cpermsize; ++j)\n        if(memo[cperm[j]][cperm[i]]) ok = 0;\n    if(ok) return 0;\n  } while(next_permutation(cperm.begin(), cperm.end()));\n  return 1;\n}\n\nvoid lstset(int x, int i, int j) {\n  lst[x].l = min(lst[x].l, j);\n  lst[x].r = max(lst[x].r, j);\n  lst[x].u = min(lst[x].u, i);\n  lst[x].d = max(lst[x].d, i);\n}\n"
  },
  {
    "language": "C++",
    "code": "\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2002\n\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nstruct rect {\n\tint min_w, max_w;\n\tint min_h, max_h;\n\tvoid update(int w, int h) {\n\t\tmin_w = min(min_w, w); max_w = max(max_w, w);\n\t\tmin_h = min(min_h, h); max_h = max(max_h, h);\n\t}\n};\n\nint h, w;\nvector<vector<char>> bag;\nvector<vector<char>> tmp;\nvector<char> layer;\t\nmap<char, rect> rects;\n\nvoid fill_rect(char type) {\n\trect rt = rects[type];\n\tfor(int y = rt.min_h; y <= rt.max_h; ++y) {\n\t\tfor(int x = rt.min_w; x <= rt.max_w; ++x) {\n\t\t\ttmp[y][x] = type;\n\t\t}\n\t}\n\treturn;\n}\n\nbool is_safe() {\n\trep(y, h) {\n\t\trep(x, w) {\n\t\t\tif(tmp[y][x] != bag[y][x]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\tint T;\n\tcin >> T;\n\trep(i, T) {\n\t\tcin >> h >> w;\n\t\tbag.assign(h, vector<char>(w, '.'));\n\t\trects.clear(); layer.clear();\n\t\trep(y, h) {\n\t\t\trep(x, w) {\n\t\t\t\tcin >> bag[y][x];\n\t\t\t\tif(bag[y][x] == '.') continue;\n\t\t\t\tif(rects.count(bag[y][x]) == 0) {\n\t\t\t\t\trects[bag[y][x]] = {x, x, y, y};\n\t\t\t\t\tlayer.push_back(bag[y][x]);\n\t\t\t\t} else {\n\t\t\t\t\trects[bag[y][x]].update(x, y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool ok = false;\n\t\tsort(ALL(layer));\n\t\tdo {\n\t\t\ttmp = bag;\n\t\t\trep(i, layer.size()) {\n\t\t\t\tfill_rect(layer[i]);\n\t\t\t}\n\t\t\tif(is_safe()) { ok = true; break; }\n\t\t} while(next_permutation(ALL(layer)));\n\t\t\n\t\tcout << ((ok) ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> M;\nint H,W;\nint c_to_int[26];\nchar int_to_c[7];\nint num;\n\nvector<vector<vector<char> > > E;\n\nbool pre_check(){\n\tE.clear();\n\tE.resize(H,vector<vector<char> > (W,vector<char>()));\n\n\tfor(int k=0;k<num;k++){\n\t\tchar now=int_to_c[k];\n\t\tint minx=100,maxx=0,miny=100,maxy=0;\n\t\tfor(int y=0;y<H;y++){\n\t\t\tfor(int x=0;x<W;x++){\n\t\t\t\tif(M[y][x]==now){\n\t\t\t\t\tmaxx=max(maxx,x);minx=min(minx,x);\n\t\t\t\t\tmaxy=max(maxy,y);miny=min(miny,y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int y=miny;y<=maxy;y++){\n\t\t\tfor(int x=minx;x<=maxx;x++){\n\t\t\t\tif(M[y][x]=='.') return false;\n\t\t\t\tE[y][x].push_back(now);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nbool check(vector<int> perm){\n\n\tfor(int y=0;y<H;y++){\n\t\tfor(int x=0;x<W;x++){\n\t\t\tif(M[y][x]=='.') continue;\n\t\t\tint top=c_to_int[M[y][x]];\n\t\t\tfor(int i=0;i<E[y][x].size();i++){\n\t\t\t\tif(E[y][x].size()<2) continue;\n\t\t\t\tint now=c_to_int[E[y][x][i]];\n\t\t\t\tif(perm[top]>perm[now]) return false;\n\t\t\t}\n\t\t}\n\t}\n\n\n\treturn true;\n}\n\nbool solve(){\n\tcin>>H>>W;\n\tM.clear();\n\tset<char> S;\n\tnum=0;\n\n\tfor(int i=0;i<H;i++){\n\t\tstring s; cin>>s; M.push_back(s);\n\t\tfor(int k=0;k<s.size();k++){\n\t\t\tif(!S.count(s[k]) && s[k]!='.'){\n\t\t\t\tS.insert(s[k]);\n\t\t\t\tc_to_int[s[k]]=num;\n\t\t\t\tint_to_c[num]=s[k];\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif(!pre_check()) return false;\n\tif(num<2) return true;\n\tvector<int> perm;\n\tfor(int i=0;i<num;i++) perm.push_back(i);\n\tsort(perm.begin(),perm.end());\n\n\twhile(next_permutation(perm.begin(),perm.end())){\n\t\tif(check(perm)) return true;\n\t}\n\treturn false;\n}\n\n\nint main()\n{\n\tint n;cin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tif(solve()) cout<<\"SAFE\\n\";\n\t\telse cout<<\"SUSPICIOUS\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct point{\n  int x,y;\n};\n\nint main(int argc, char *argv[]){\n  int n, w, h;\n  cin >> n;\n  for (int r = 0; r < n; r++) {\n    point p[7][2];//min, max\n    map<char, int> matrial;\n    cin >> h >> w;\n\n    char grid[h][w];\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> grid[i][j];\n        if(grid[i][j] != '.' &&\n           matrial.find(grid[i][j]) == matrial.end()){\n          matrial[grid[i][j]] = matrial.size() - 1;\n        }\n      }\n    }\n\n    vector<int> perm(matrial.size());\n    for (int i = 0; i < matrial.size(); i++) {\n      p[i][0].x = 1e9, p[i][0].y = 1e9;\n      p[i][1].x =  -1, p[i][1].y =  -1;\n      perm[i] = i;\n    }\n\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if(matrial.find(grid[i][j]) != matrial.end()){\n          int tmp = matrial[grid[i][j]];\n          p[tmp][0].x  = min(p[tmp][0].x, j);\n          p[tmp][0].y  = min(p[tmp][0].y, i);\n          p[tmp][1].x  = max(p[tmp][1].x, j);\n          p[tmp][1].y  = max(p[tmp][1].y, i);\n        }\n      }\n    }\n    bool flag;\n    do{\n      flag = true;\n      for (int i = 0; i < matrial.size(); i++) {\n        for (int j = p[i][0].y; j <= p[i][1].y; j++) {\n          for (int k = p[i][0].x; k <= p[i][1].x; k++) {\n            if(grid[j][k] == '.'){\n              i = 10;\n              j = p[i][1].y + 10;\n              k = p[i][1].x + 10;\n              flag  = false;\n              break;\n            }\n            if(perm[matrial[grid[j][k]]] > perm[i]){\n              flag = false;\n              i = 10;\n              j = p[i][1].y + 10;\n              k = p[i][1].x + 10;\n            }\n          }\n        }\n      }\n    \n    }while(next_permutation(perm.begin(), perm.end()) &&\n           flag == false);\n    if(flag){\n      std::cout << \"SAFE\" << std::endl;\n    }else{\n      std::cout << \"SUSPICIOUS\" << std::endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((ULL)(n) >> (m) & 1)\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\nint n_dir = 4;\nint dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; /* CSS order */\nenum direction {\n\tUP, RIGHT, DOWN, LEFT\n};\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\nstruct article {\n\tchar material;\n\tbool is_removed;\n\tint topmost;\n\tint bottommost;\n\tint leftmost;\n\tint rightmost;\n};\n\ntypedef map<char, article> MCA;\n\nVVC image;\nMCA articles;\n\nbool remove_all()\n{\n\tbool all_removed = true;\n\tEACH (articles, itr) {\n\t\tarticle &art = itr->second;\n\t\tif (!art.is_removed) {\n\t\t\tall_removed = false;\n\t\t\t// Remove it and recurse\n\t\t\tVVC save = image;\n\t\t\tbool rect = true;\n\t\t\tFOR (i, art.topmost, art.bottommost + 1) {\n\t\t\t\tFOR (j, art.leftmost, art.rightmost + 1) {\n\t\t\t\t\tif (image[i][j] != '*' && image[i][j] != art.material) {\n\t\t\t\t\t\trect = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\timage[i][j] = '*';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rect) {\n\t\t\t\t// Recurse\n\t\t\t\tart.is_removed = true;\n\t\t\t\tif (remove_all()) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\t// Restore and continue trying\n\t\t\t\t\tart.is_removed = false;\n\t\t\t\t\timage = save;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn all_removed;\n}\n\nint main()\n{\n\tint t; cin >> t;\n\tREP (_, t) {\n\t\tint h, w; cin >> h >> w;\n\t\timage = VVC(h, VC(w, '.'));\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tcin >> image[i][j];\n\t\t\t}\n\t\t}\n\n\t\t// Scan Image\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tif (image[i][j] != '.') {\n\t\t\t\t\tchar c = image[i][j];\n\t\t\t\t\tif (!EXIST(articles, c)) {\n\t\t\t\t\t\tarticle a = {c, false, 50, 0, 50, 0};\n\t\t\t\t\t\tarticles.insert(MCA::value_type(c, a));\n\t\t\t\t\t}\n\t\t\t\t\tarticles[c].topmost = min(articles[c].topmost, i);\n\t\t\t\t\tarticles[c].bottommost = max(articles[c].bottommost, i);\n\t\t\t\t\tarticles[c].leftmost = min(articles[c].leftmost, j);\n\t\t\t\t\tarticles[c].rightmost = max(articles[c].rightmost, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (remove_all()) {\n\t\t\tcout << \"SAFE\" << endl;\n\t\t} else {\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tint N, H, W;\n\tcin >> N;\n\twhile (N--) {\n\t\tcin >> H >> W;\n\t\tvector<int> used(26), xma(26), xmi(26, 100), yma(26), ymi(26, 100);\n\t\tvector<vector<char>> a(H, vector<char>(W));\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tif (a[i][j] != '.') {\n\t\t\t\t\tint p = a[i][j] - 'A';\n\t\t\t\t\tused[p] = 1;\n\t\t\t\t\txma[p] = max(xma[p], i);\n\t\t\t\t\txmi[p] = min(xmi[p], i);\n\t\t\t\t\tyma[p] = max(yma[p], j);\n\t\t\t\t\tymi[p] = min(ymi[p], j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<int>> d(26, vector<int>(26, 1000));\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\td[i][i] = 0;\n\t\t}\n\t\tbool sus = false;\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\tif (used[i]) {\n\t\t\t\tfor (int x = xmi[i]; x <= xma[i]; x++) {\n\t\t\t\t\tfor (int y = ymi[i]; y <= yma[i]; y++) {\n\t\t\t\t\t\tif (a[x][y] == '.') {\n\t\t\t\t\t\t\tsus = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (a[x][y] - 'A' != i) {\n\t\t\t\t\t\t\td[i][a[x][y] - 'A'] = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < 26; k++) {\n\t\t\tfor (int i = 0; i < 26; i++) {\n\t\t\t\tfor (int j = 0; j < 26; j++) {\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\tif (d[i][i] < 0) {\n\t\t\t\tsus = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << (sus ? \"SUSPICIOUS\" : \"SAFE\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;/*{{{*/\n\n#include <iostream>\n#include <map>\n#include <vector>\n\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n/*}}}*/\n\nstruct article {\n\tchar material;\n\tbool is_removed;\n\tint topmost;\n\tint bottommost;\n\tint leftmost;\n\tint rightmost;\n};\n\ntypedef map<char, article> MCA;\n\nVVC image;\nMCA articles;\n\nbool remove_all()\n{\n\tbool all_removed = true;\n\tEACH (articles, itr) {\n\t\tarticle &art = itr->second;\n\t\tif (!art.is_removed) {\n\t\t\tall_removed = false;\n\t\t\t// Remove it and recurse\n\t\t\tVVC save = image;\n\t\t\tbool rect = true;\n\t\t\tFOR (i, art.topmost, art.bottommost + 1) {\n\t\t\t\tFOR (j, art.leftmost, art.rightmost + 1) {\n\t\t\t\t\tif (image[i][j] != '*' && image[i][j] != art.material) {\n\t\t\t\t\t\trect = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\timage[i][j] = '*';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rect) {\n\t\t\t\t// Recurse\n\t\t\t\tart.is_removed = true;\n\t\t\t\tif (remove_all()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Restore and continue trying\n\t\t\tart.is_removed = false;\n\t\t\timage = save;\n\t\t}\n\t}\n\treturn all_removed;\n}\n\nint main()\n{\n\tint t; cin >> t;\n\tREP (_, t) {\n\t\tint h, w; cin >> h >> w;\n\t\timage = VVC(h, VC(w, '.'));\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tcin >> image[i][j];\n\t\t\t}\n\t\t}\n\n\t\t// Scan Image\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tif (image[i][j] != '.') {\n\t\t\t\t\tchar c = image[i][j];\n\t\t\t\t\tif (!EXIST(articles, c)) {\n\t\t\t\t\t\tarticle a = {c, false, 50, 0, 50, 0};\n\t\t\t\t\t\tarticles[c] = a;\n\t\t\t\t\t}\n\t\t\t\t\tarticles[c].topmost = min(articles[c].topmost, i);\n\t\t\t\t\tarticles[c].bottommost = max(articles[c].bottommost, i);\n\t\t\t\t\tarticles[c].leftmost = min(articles[c].leftmost, j);\n\t\t\t\t\tarticles[c].rightmost = max(articles[c].rightmost, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (remove_all()) {\n\t\t\tcout << \"SAFE\" << endl;\n\t\t} else {\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconstexpr int INF = 1 << 29;\n\nint H, W;\nstring dat[50];\n\nstruct rect_dat {\n    int lh, rh, lw, rw;\n    rect_dat(): lh(INF), rh(-INF), lw(INF), rw(-INF) {}\n};\n\nint main() {\n    int N; cin >> N;\n    for (int _ = 0; _ < N; ++_) {\n        cin >> H >> W;\n        for (int j = 0; j < H; ++j) { cin >> dat[j]; }\n        \n        rect_dat rect[26];\n        int is_back[26][26];\n        for (int j = 0; j < 26; ++j) {\n            fill(is_back[j], is_back[j]+26, -1);\n            is_back[j][j] = 0;\n        }\n\n        for (int j = 0; j < H; ++j) {\n            for (int k = 0; k < W; ++k) {\n                if (dat[j][k] == '.') { continue; }\n                int ind = dat[j][k] - 'A';\n\n                rect[ind].lh = min(rect[ind].lh, j);\n                rect[ind].rh = max(rect[ind].rh, j);\n\n                rect[ind].lw = min(rect[ind].lw, k);\n                rect[ind].rw = max(rect[ind].rw, k);\n            }\n        }\n\n        const string SAFE = \"SAFE\", SUSPICIOUS = \"SUSPICIOUS\";\n        const string msg = [&]() -> string { \n            for (int x = 0; x < 26; ++x) {\n                char ch = x + 'A';\n                for (int j = rect[x].lh; j <= rect[x].rh; ++j) {\n                    for (int k = rect[x].lw; k <= rect[x].rw; ++k) {\n                        if (dat[j][k] == '.') {\n                            return SUSPICIOUS;\n                        }\n                        if (dat[j][k] == ch) { continue; }\n                        int y = dat[j][k] - 'A';\n                        if (is_back[x][y] < 0) {\n                            is_back[x][y] = 1;\n                            for (int j = 0; j < 26; ++j) {\n                                if (y == j) { continue; }\n                                if (is_back[y][j] == 1) {\n                                    if (is_back[x][j] == 0) {\n                                        return SUSPICIOUS;\n                                    }\n                                    is_back[x][j] = 1;\n                                }\n                            }\n                            is_back[y][x] = 0;\n                        } else if (is_back[x][y] == 0) {\n                            return SUSPICIOUS;\n                        }\n                    }\n                }\n            }\n            return \"SAFE\";\n        }();\n\n        cout << msg << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <set>\n#include <iomanip>\n#include <stack>\n#include <fstream>\n#include <cstdint>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <functional>\n\nusing namespace std;\n\n\ntypedef int64_t ll;\n\n\nclass rect{\n    static const int inf = 100000;\npublic:\n    int sx, sy; // 始点 左上\n    int ex, ey; // 終点 右下\n    rect() :sx(inf), sy(inf), ex(), ey() {}\n    \n    void modify(const int& i, const int& j){\n        sx = min(i, sx);\n        sy = min(j, sy);\n        \n        ex = max(i, ex);\n        ey = max(j, ey);\n    }\n};\n\nbool is_real_over(map<char, rect> shapes, vector<vector<char>>& v){\n    vector<char> chs;\n    for(auto && t : shapes){\n        chs.push_back(t.first);\n    }\n    if(chs.size() == 0)\n        return true;\n    do{\n        map<char, int> pos;\n        for (int i = 0; i < chs.size(); ++i) {\n            pos[chs[i]] = i;\n        }\n        bool do_next = [&]()\n        {\n            for(auto && rec_pair: shapes){\n                auto && rec = rec_pair.second;\n                auto && rec_name = rec_pair.first;\n                for (int i = rec.sx; i <= rec.ex; ++i) {\n                    for (int j = rec.sy; j <= rec.ey; ++j) {\n                        auto&& this_char = v[i][j];\n                        if(pos[this_char] > pos[rec_name]){\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }();\n        if(!do_next) return true;\n    }while(next_permutation(chs.begin(), chs.end()));\n    return false;\n}\n\n\nbool solve(){\n    int h, w;\n    cin >> h >> w;\n    vector<vector<char>> v;\n    map<char, rect> shapes;\n    for (int i = 0; i < h; ++i) {\n        v.push_back({});\n        for (int j = 0; j < w; ++j) {\n            char tmp;\n            cin >> tmp;\n            v[i].push_back(tmp);\n\n            if(tmp != '.')\n                shapes[tmp].modify(i, j);\n        }\n    }\n\n\n    // 矩形調査 yz\n    for(auto && rec_pair: shapes){\n        auto && rec = rec_pair.second;\n        auto && rec_name = rec_pair.first;\n//        cerr << \"NAME:\" << rec_name << '\\n';\n        for (int i = rec.sx; i <= rec.ex; ++i) {\n            for (int j = rec.sy; j <= rec.ey; ++j) {\n                auto&& this_char = v[i][j];\n                if(this_char != rec_name){\n                    if(this_char == '.'){\n//                        cerr << \"SHAPE MISS\\n\";\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return is_real_over(shapes, v);\n    \n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        cout << (!solve() ? \"SUSPICIOUS\" : \"SAFE\") << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 100000000;\n\nstruct Data{\n    int xa, xi, ya, yi;\n};\n\nint h, w;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nvoid dfs(char m[55][55], bool used[55][55], Data &d, int y, int x, char a){\n    d.xa = max(d.xa, x);\n    d.xi = min(d.xi, x);\n    d.ya = max(d.ya, y);\n    d.yi = min(d.yi, y);\n    used[y][x] = true;\n\n    rep(i,4){\n        int ny = y + dy[i];\n        int nx = x + dx[i];\n        if(y >= h || y < 0 || x >= w || x < 0) continue;\n        if(m[ny][nx] != a) continue;\n        if(used[ny][nx] == true) continue;\n        dfs(m,used,d,ny,nx,a);\n    }\n}\n\nbool isRect(char m[55][55], Data d, char a){\n    range(i,d.yi,d.ya + 1){\n        range(j,d.xi,d.xa + 1){\n            if(m[i][j] != a && m[i][j] != '@') return false;\n        }\n    }\n    return true;\n}\n\nbool check(char m[55][55]){\n    rep(i,h){\n        rep(j,w){\n            if(m[i][j] >= 'A' && m[i][j] <= 'Z') return false;\n        }\n    }\n    return true;\n}\n\nbool replace(char m[55][55], Data d){\n    //cout << d.yi << ' ' << d.ya << endl;\n    range(i,d.yi,d.ya + 1){\n        range(j,d.xi,d.xa + 1){\n            m[i][j] = '@';\n        }\n    }\n   //cout << endl; rep(i,h){ rep(j,w){ cout << m[i][j]; } cout << endl; }\n    return true;\n}\n\nint main(){\n    int t;\n    cin >> t;\n    while(t--){\n        cin >> h >> w;\n\n        char m[55][55];\n        rep(i,h) cin >> m[i];\n\n        while(true){\n            bool f = false;\n            bool used[55][55] = {0};\n            rep(i,h){\n                rep(j,w){\n                    if(m[i][j] != '.' && m[i][j] != '@' && used[i][j] == false){\n                        Data d = {-INF,INF,-INF,INF};\n                        dfs(m,used,d,i,j,m[i][j]);\n                        //cout << i << ' ' << j << endl;\n                        //cout << d.yi << ' ' << d.ya << endl;\n                        //cout << d.xi << ' ' << d.xa << endl;\n                        if(isRect(m,d,m[i][j])) f = replace(m,d);\n                    }\n                }\n            }\n            if(not f){\n                break;\n            }\n        }\n        cout << (check(m) ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\n#define pb push_back\n#define FOR(i, a, b) for (ll i = (signed)(a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define EREP(i, n) for (int i = (n)-1; i >= 0; --i)\n#define MOD 1000000007\n#define INF 93193111451418101\n#define MIN -93193111451418101\n#define EPS 1e-11\nusing namespace std;\n\nchar grid[51][51];\nll n, h, w;\n\nbool check(vector<ll> &v, ll lx[50], ll ly[50], ll rx[50], ll ry[50], ll c) {\n  ll itr = 0;\n  REP(i, (signed)v.size()) itr = (v[i] == c ? i : itr);\n  FOR(i, ly[c], ry[c] + 1) {\n    FOR(j, lx[c], rx[c] + 1) {\n      if (grid[i][j] == '.')\n        return 0;\n      if (grid[i][j] != c + 'A') {\n        REP(i, (signed)v.size()) {\n          if (v[i] + 'A' == grid[i][j] && i > itr)\n            return 0;\n        }\n      }\n    }\n  }\n  return 1;\n}\n\nint main() {\n  cin >> n;\n  REP(loop, n) {\n    ll lx[50] = {}, ly[50] = {}, rx[50] = {}, ry[50] = {};\n    REP(i, 50) { lx[i] = 100, ly[i] = 100; }\n    vector<ll> v;\n    cin >> h >> w;\n    REP(i, h) {\n      REP(j, w) { cin >> grid[i][j]; }\n    }\n    REP(i, h) REP(j, w) {\n      const char c = grid[i][j];\n      const ll cl = grid[i][j] - 'A';\n      if (c == '.')\n        continue;\n      v.pb(cl);\n      lx[cl] = min(lx[cl], j);\n      ly[cl] = min(ly[cl], i);\n      ry[cl] = max(ry[cl], i);\n      rx[cl] = max(rx[cl], j);\n    }\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    bool ff = 0;\n    do {\n      for (auto &a : v) {\n        if (check(v, lx, ly, rx, ry, a) == 0) {\n          ff = 1;\n          break;\n        }\n      }\n      if (!ff) {\n        cout << \"SAFE\" << endl;\n        break;\n      }\n    } while (next_permutation(v.begin(), v.end()));\n    if (ff)\n      cout << \"SUSPICIOUS\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "using namespace std;/*{{{*/\n\n#include <iostream>\n#include <map>\n#include <vector>\n\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n/*}}}*/\n\nstruct article {\n\tchar material;\n\tbool is_removed;\n\tint topmost;\n\tint bottommost;\n\tint leftmost;\n\tint rightmost;\n};\n\ntypedef map<char, article> MCA;\n\nVVC image;\nMCA articles;\n\nbool remove_all()\n{\n\tbool all_removed = true;\n\tEACH (articles, itr) {\n\t\tarticle &art = itr->second;\n\t\tif (!art.is_removed) {\n\t\t\tall_removed = false;\n\t\t\t// Remove it and recurse\n\t\t\tVVC save = image;\n\t\t\tbool rect = true;\n\t\t\tFOR (i, art.topmost, art.bottommost + 1) {\n\t\t\t\tFOR (j, art.leftmost, art.rightmost + 1) {\n\t\t\t\t\tif (image[i][j] != '*' && image[i][j] != art.material) {\n\t\t\t\t\t\trect = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\timage[i][j] = '*';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rect) {\n\t\t\t\t// Recurse\n\t\t\t\tart.is_removed = true;\n\t\t\t\tif (remove_all()) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\t// Restore and continue trying\n\t\t\t\t\tart.is_removed = false;\n\t\t\t\t\timage = save;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn all_removed;\n}\n\nint main()\n{\n\tint t; cin >> t;\n\tREP (_, t) {\n\t\tint h, w; cin >> h >> w;\n\t\timage = VVC(h, VC(w, '.'));\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tcin >> image[i][j];\n\t\t\t}\n\t\t}\n\n\t\t// Scan Image\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tif (image[i][j] != '.') {\n\t\t\t\t\tchar c = image[i][j];\n\t\t\t\t\tif (!EXIST(articles, c)) {\n\t\t\t\t\t\tarticle a = {c, false, 50, 0, 50, 0};\n\t\t\t\t\t\tarticles[c] = a;\n\t\t\t\t\t}\n\t\t\t\t\tarticles[c].topmost = min(articles[c].topmost, i);\n\t\t\t\t\tarticles[c].bottommost = max(articles[c].bottommost, i);\n\t\t\t\t\tarticles[c].leftmost = min(articles[c].leftmost, j);\n\t\t\t\t\tarticles[c].rightmost = max(articles[c].rightmost, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (remove_all()) {\n\t\t\tcout << \"SAFE\" << endl;\n\t\t} else {\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nstruct cminmax{\n\tchar c;\n\tint minx;\n\tint maxx;\n\tint miny;\n\tint maxy;\n};\nint main() {\n\tint n;\n\tcin >> n;\n\twhile (n--){\n\t\tbool safe = true;\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tvector<cminmax> vcmm;\n\t\tvector<vector<char>> vvc(h);\n\t\tREP(i, h){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tREP(j, w){\n\t\t\t\tvvc[i].push_back(s[j]);\n\t\t\t\tif (s[j] != '.'){\n\t\t\t\t\tif (vcmm.empty()){\n\t\t\t\t\t\tvcmm.push_back({ s[j], j, j, i, i });\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tint b = -1;\n\t\t\t\t\t\tREP(k, vcmm.size()){\n\t\t\t\t\t\t\tif (vcmm[k].c == s[j]){\n\t\t\t\t\t\t\t\tb = k;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (b == -1){\n\t\t\t\t\t\t\tvcmm.push_back({ s[j], j, j, i, i });\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tvcmm[b].maxx = max(vcmm[b].maxx, j);\n\t\t\t\t\t\t\tvcmm[b].minx = min(vcmm[b].minx, j);\n\t\t\t\t\t\t\tvcmm[b].maxy = max(vcmm[b].maxy, i);\n\t\t\t\t\t\t\tvcmm[b].miny = min(vcmm[b].miny, i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int l = 0; l < 10&&!vcmm.empty();l++){\n\t\t\tif (l == 9){\n\t\t\t\tsafe = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREP(i, vcmm.size()){\n\t\t\t\tbool rect = true;\n\t\t\t\tfor (int j = vcmm[i].miny; j <= vcmm[i].maxy&&rect; j++){\n\t\t\t\t\tfor (int k = vcmm[i].minx; k <= vcmm[i].maxx&&rect; k++){\n\t\t\t\t\t\tif (vvc[j][k] != vcmm[i].c && vvc[j][k] != '0')rect = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (rect){\n\t\t\t\t\tfor (int j = vcmm[i].miny; j <= vcmm[i].maxy&&rect; j++){\n\t\t\t\t\t\tfor (int k = vcmm[i].minx; k <= vcmm[i].maxx&&rect; k++){\n\t\t\t\t\t\t\tvvc[j][k] = '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvcmm.erase(vcmm.begin()+i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (safe)cout << \"SAFE\" << endl;\n\t\telse cout << \"SUSPICIOUS\" << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint h, w;\nchar input[51][51];\nmap<char, int> m;\nvector<vector<int> > v;\n\nbool isfront(int now, char tgt, vector<int> range)\n{\n\tfor(int i = range[0]; i <= range[2]; i++){\n\t\tfor(int j = range[1]; j <= range[3]; j++){\n\t\t\tif(input[i][j] < 0 || (input[i][j] != tgt && (now & (1 << input[i][j])) != 0)) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool issafe()\n{\n\tint tmp = m.size();\n\t// cout << tmp << endl;\n\tif(tmp == 0) return true;\n\tvector<bool> result(1 << tmp, false);\n\tresult[0] = true;\n\tfor(int i = 0; i < (1 << tmp); i++){\n\t\tif(!result[i]) continue;\n\t\tfor(int j = 0; j < tmp; j++){\n\t\t\tif((i & (1 << j)) != 0) continue;\n\t\t\tvector<int> tmp = v[j];\n\t\t\t// cout << j << \" : \" << endl;\n\t\t\t// \tfor(int l = 0; l < 4; l++){\n\t\t\t// \t\tcout << tmp[l] << \" \";\n\t\t\t// \t}\n\t\t\t// \tcout << endl;\n\t\t\tresult[(i | (1 << j))] = result[(i | (1 << j))] || isfront(i, j, tmp);\n\t\t\t// cout << result[(i | (1 << j))] << endl;\n\t\t}\n\t}\n\treturn result[(1 << tmp) - 1];\n}\n\nint main()\n{\n\tint num;\n\tcin >> num;\n\tfor(int i = 0; i < num; i++){\n\t\tm.clear();\n\t\tv.clear();\n\t\tint cnt = 0;\n\t\tcin >> h >> w;\n\t\tfor(int j = 0; j < h; j++){\n\t\t\tfor(int k = 0; k < w; k++){\n\t\t\t\tchar tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tif(tmp == '.'){\n\t\t\t\t\tinput[j][k] = -1;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if(m.find(tmp) == m.end()){\n\t\t\t\t\tv.push_back(vector<int>{j, k, j, k});\n\t\t\t\t\tm[tmp] = cnt;\n\t\t\t\t\tcnt++;\n\t\t\t\t\t// cout << tmp << \"->\" << cnt-1 << endl;\n\t\t\t\t}\n\t\t\t\tinput[j][k] = m[tmp];\n\t\t\t\tv[m[tmp]][0] = min(v[m[tmp]][0], j);\n\t\t\t\tv[m[tmp]][1] = min(v[m[tmp]][1], k);\n\t\t\t\tv[m[tmp]][2] = max(v[m[tmp]][2], j);\n\t\t\t\tv[m[tmp]][3] = max(v[m[tmp]][3], k);\n\t\t\t}\n\t\t}\n\t\tif(issafe()) cout << \"SAFE\" << endl;\n\t\telse cout << \"SUSPICIOUS\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\nint main()\n{\n\tint T;\n\tcin >> T;\n\twhile (T--)\n\t{\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tchar pix[64][64];\n\t\tfor (int i = 0; i < h; ++i)\n\t\t\tcin >> pix[i];\n\n\t\tbool safe = true;\n\t\twhile (true)\n\t\t{\n\t\t\tint x1[26], y1[26], x2[26], y2[26];\n\t\t\tfor (int i = 0; i < 26; ++i)\n\t\t\t{\n\t\t\t\tx1[i] = y1[i] = 333;\n\t\t\t\tx2[i] = y2[i] = -1;\n\t\t\t}\n\n\t\t\tfor (int y = 0; y < h; ++y)\n\t\t\t{\n\t\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\t{\n\t\t\t\t\tif (isalpha(pix[y][x]))\n\t\t\t\t\t{\n\t\t\t\t\t\tint c = pix[y][x] - 'A';\n\t\t\t\t\t\tmin_swap(x1[c], x);\n\t\t\t\t\t\tmin_swap(y1[c], y);\n\t\t\t\t\t\tmax_swap(x2[c], x);\n\t\t\t\t\t\tmax_swap(y2[c], y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbool no_obj = true;\n\t\t\tbool update = false;\n\t\t\tfor (int i = 0; i < 26; ++i)\n\t\t\t{\n\t\t\t\tif (x2[i] == -1)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tno_obj = false;\n\n\n\t\t\t\tbool rect = true;\n\t\t\t\tfor (int y = y1[i]; y <= y2[i]; ++y)\n\t\t\t\t\tfor (int x = x1[i]; x <= x2[i]; ++x)\n\t\t\t\t\t\tif (pix[y][x] != 'A' + i && pix[y][x] != '@')\n\t\t\t\t\t\t\trect = false;\n\n\t\t\t\tif (rect)\n\t\t\t\t{\n\t\t\t\t\tupdate = true;\n\t\t\t\t\tfor (int y = y1[i]; y <= y2[i]; ++y)\n\t\t\t\t\t\tfor (int x = x1[i]; x <= x2[i]; ++x)\n\t\t\t\t\t\t\tpix[y][x] = '@';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (no_obj)\n\t\t\t\tbreak;\n\t\t\telse if (!update)\n\t\t\t{\n\t\t\t\tsafe = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcout << (safe ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<60;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-14;\n#define rep(i,m,n) for(ll i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto itr=mp.begin();itr!=mp.end();itr++)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int t;cin>>t;\n    rep(i,0,t){\n        int h,w;cin>>h>>w;\n        string s[h];\n        int used[26];\n        fill(used,used+26,-1);\n        int now=1;\n        int a[h][w];\n        memset(a,0,sizeof a);\n        rep(j,0,h){\n            cin>>s[j];\n            rep(k,0,w){\n                if(s[j][k]=='.')continue;\n                int y=s[j][k]-'A';\n                if(used[y]>=0)a[j][k]=used[y];\n                else{\n                    used[y]=now;\n                    now++;\n                    a[j][k]=used[y];\n                }\n            }\n        }\n        int sum[h+1][w+1][8];\n        rep(j,0,h+1)rep(k,0,8)sum[j][0][k]=0;\n        rep(j,0,w+1)rep(k,0,8)sum[0][j][k]=0;\n        int minx[8],maxx[8],miny[8],maxy[8];\n        fill(minx,minx+8,1000000000);\n        fill(miny,miny+8,1000000000);\n        fill(maxx,maxx+8,-1);\n        fill(maxy,maxy+8,-1);\n        rep(j,0,h){\n            rep(k,0,w){\n                Min(minx[a[j][k]],(int)k);\n                Min(miny[a[j][k]],(int)j);\n                Max(maxx[a[j][k]],(int)k);\n                Max(maxy[a[j][k]],(int)j);\n                rep(l,0,8){\n                    sum[j+1][k+1][l]=sum[j][k+1][l]+sum[j+1][k][l]-sum[j][k][l];\n                    if(a[j][k]==l)sum[j+1][k+1][l]++;\n                }\n            }\n        }\n        //rep(j,1,now){\n           // cout<<minx[j]<<\" \"<<maxx[j]<<\" \"<<miny[j]<<\" \"<<maxy[j]<<endl;\n        //}\n        bool ok[8];\n        fill(ok,ok+8,false);\n        int rr=1;\n        rep(j,0,now-1){\n            int r=0;\n            rep(k,1,now){\n                if(ok[k])continue;\n                int cnt=sum[maxy[k]+1][maxx[k]+1][k]-sum[maxy[k]+1][minx[k]][k]\n                -sum[miny[k]][maxx[k]+1][k]+sum[miny[k]][minx[k]][k];\n                rep(l,1,now){\n                    if(ok[l]){\n                        cnt+=sum[maxy[k]+1][maxx[k]+1][l]-sum[maxy[k]+1][minx[k]][l]\n                        -sum[miny[k]][maxx[k]+1][l]+sum[miny[k]][minx[k]][l];\n                    }\n                }\n                //cout<<cnt<<endl;\n                if(cnt==(maxx[k]-minx[k]+1)*(maxy[k]-miny[k]+1)){\n                    r=1;\n                    ok[k]=true;\n                    break;\n                }\n            }\n            if(r==0){\n                rr=0;\n                break;\n            }\n        }\n        if(rr==0){\n            cout<<\"SUSPICIOUS\"<<endl;\n        }\n        else cout<<\"SAFE\"<<endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint h, w;\nchar field[100][100];\nbool visit[100][100];\nbool dfsvisit[50];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\nset<int> edges[50];\n\nbool dfs(int where, int from) {\n  if (where == from && dfsvisit[where]) { return false; }\n  if (dfsvisit[where]) { return true; }\n  dfsvisit[where] = true;\n  FORIT(it, edges[where]) {\n    if (!dfs(*it, from)) { return false; }\n  }\n  return true;\n}\n\nint main() {\n  int test;\n  scanf(\"%d\", &test);\n  while (test--) {\n    REP(i, 50) { edges[i].clear(); }\n    scanf(\"%d %d\", &h, &w);\n    MEMSET(visit, false);\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n    }\n    REP(y, h) {\n      REP(x, w) {\n        if (visit[y][x] || field[y][x] == '.') { continue; }\n        queue<pair<int, int> > que;\n        que.push(make_pair(x, y));\n        int minx = x;\n        int miny = y;\n        int maxx = x;\n        int maxy = y;\n        while (!que.empty()) {\n          int x = que.front().first;\n          int y = que.front().second;\n          que.pop();\n          if (visit[y][x]) { continue; }\n          visit[y][x] = true;\n          minx = min(minx, x);\n          miny = min(miny, y);\n          maxx = max(maxx, x);\n          maxy = max(maxy, y);\n          REP(i, 4) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (nx < 0 || nx >= w || ny < 0 || ny >= h) { continue; }\n            if (field[y][x] != field[ny][nx]) { continue; }\n            que.push(make_pair(nx, ny));\n          }\n        }\n        FOREQ(ny, miny, maxy) FOREQ(nx, minx, maxx) {\n          if (field[ny][nx] == '.') {\n            puts(\"SUSPICIOUS\");\n            goto next;\n          } else if (field[ny][nx] != field[y][x]) {\n            edges[(int)field[y][x] - 'A'].insert(field[ny][nx] - 'A');\n          }\n        }\n      }\n    }\n    REP(i, 50) {\n      MEMSET(dfsvisit, false);\n      if (!dfs(i, i)) {\n        puts(\"SUSPICIOUS\");\n        goto next;\n      }\n    }\n    puts(\"SAFE\");\nnext:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <string>\n#include <cmath>\n#include <map>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int inf = 100100100;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int number;\n  cin >> number;\n  rep(aaaaaaa,number){\n      int h,w;\n      bool flag =true;\n      cin >> h >> w;\n      string s[55]={};\n      map<char,bool> m;\n      rep(y,h){\n          cin >> s[y];\n      }\n      rep(y,h)rep(x,w){\n          if(s[y][x]!='.'){\n              if(m[s[y][x]]){\n                  flag = false;\n                  x=w;y=h;break;\n              }\n              int st = x;\n              char tc = s[y][x];\n              m[tc] = true;\n              while(s[y][x]==tc) x++;\n              int et = x;\n              int yy = y;\n              while(s[yy][st]==tc){\n                  REP(xx,st,et) {\n                      if(s[yy][xx]!=tc){flag=false;}\n                      s[yy][xx]='.';\n                  }\n                  yy+=1;\n              }\n              // rep(ya,h) cout << s[ya] << endl;\n              x--;\n          }\n      }\n      rep(y,h)rep(x,w){\n         if(s[y][x]!='.') flag = false;\n      }\n      if(flag) cout << \"SAFE\" << endl;\n      else cout << \"SUSPICIOUS\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif\n\nusing namespace std;\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<map>\n\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define SR first.first\n#define SC first.second\n#define GR second.first\n#define GC second.second\ntypedef vector<int> V;\ntypedef vector<V> VV;\n\ntemplate<typename T>\nbool chmin(T &l, T r) {\n\tbool f = l > r; if (f)l = r; return f;\n}\ntemplate<typename T>\nbool chmax(T &l, T r) {\n\tbool f = l < r; if (f)l = r; return f;\n}\nVV wrap(VV vs, int c) {\n\tint R = vs.size();\n\tint C = vs[0].size();\n\tVV ret(R + 2, V(C + 2, c));\n\tREP(i, R)REP(j, C)ret[i + 1][j + 1] = vs[i][j];\n\treturn ret;\n}\nconst int dr[] = { 0,0,-1,1 ,1,1,-1,-1 };\nconst int dc[] = { -1,1,0,0, -1,1,-1,1 };\nvector<string> g;\nbool check(int sr, int sc, int gr, int gc, char x) {\n\tFOR(i, sr, gr + 1)\n\t\tFOR(j, sc, gc + 1)\n\t\tif (g[i][j] != x&&g[i][j] != '*')\n\t\t\treturn false;\n\treturn true;\n}\nvoid f(int sr, int sc, int gr, int gc) {\n\tFOR(i, sr, gr + 1)\n\t\tFOR(j, sc, gc + 1)\n\t\tg[i][j] = '*';\n}\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\nint main() {\n\tint N;\n\tcin >> N;\n\tREP(_, N) {\n\t\tint R, C;\n\t\tcin >> R >> C;\n\t\tvector<string> in(R);\n\t\tREP(i, R)cin >> in[i];\n\t\tg = in;\n\t\tmap<int, PP> memo;\n\t\tREP(i, R)REP(j, C)\n\t\t\tif (in[i][j] != '.')memo[in[i][j]] = PP(P(100, 100), P(0, 0));\n\t\tREP(i, R)REP(j, C)\n\t\t\tif (in[i][j] != '.') {\n\t\t\t\tchmin(memo[in[i][j]].SR, i);\n\t\t\t\tchmax(memo[in[i][j]].GR, i);\n\t\t\t\tchmin(memo[in[i][j]].SC, j);\n\t\t\t\tchmax(memo[in[i][j]].GC, j);\n\t\t\t}\n\t\tbool update = true;\n\t\twhile (update) {\n\t\t\tupdate = false;\n\t\t\tstring s;\n\t\t\tfor (auto&it : memo) {\n\t\t\t\t//cout << it.second.SR<<\" \"<< it.second.SC<< \" \" << it.second.GR<< \" \" << it.second.GC << endl;\n\t\t\t\tif (check(it.second.SR, it.second.SC, it.second.GR, it.second.GC, it.first)) {\n\t\t\t\t\tf(it.second.SR, it.second.SC, it.second.GR, it.second.GC);\n\t\t\t\t\ts.push_back(it.first);\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdate = s.size() > 0;\n\t\t\tfor (auto &c : s) {\n\t\t\t\t//cout << c << endl;\n\t\t\t\tmemo.erase(c);\n\n\t\t\t}\n\t\t}\n\t\tif (memo.size())cout << \"SUSPICIOUS\" << endl;\n\t\telse cout << \"SAFE\" << endl;\n\n\n\t}\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint H,W,word_num,loc[128];\nchar map[50][51],word_table[8];\nbool isOK;\n\n\nvoid recursive(int work[8],int count){\n\n\tif(isOK)return;\n\n\tif(count == word_num){\n\n\t\tbool FLG = true;\n\t\tint most_left,most_right,most_top,most_bottom,rank;\n\t\tchar ch;\n\n\t\tfor(int i = 0; i < word_num; i++){\n\t\t\tch = word_table[i];\n\t\t\trank = work[i];\n\n\t\t\tmost_left = 51,most_right = -1,most_top = 51,most_bottom = -1;\n\n\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tif(map[row][col] == ch){\n\t\t\t\t\t\tmost_left = min(most_left,col);\n\t\t\t\t\t\tmost_right = max(most_right,col);\n\t\t\t\t\t\tmost_top = min(most_top,row);\n\t\t\t\t\t\tmost_bottom = max(most_bottom,row);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int row = most_top; row <= most_bottom; row++){\n\t\t\t\tfor(int col = most_left; col <= most_right; col++){\n\t\t\t\t\tif(map[row][col] != ch){\n\t\t\t\t\t\tif(rank > work[loc[map[row][col]-'0']]){\n\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!FLG)break;\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)isOK = true;\n\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < word_num; i++){\n\t\tif(work[i] == -1){\n\t\t\tint next_work[8];\n\t\t\tfor(int k = 0; k < 8; k++)next_work[k] = work[k];\n\t\t\tnext_work[i] = count;\n\n\t\t\trecursive(next_work,count+1);\n\t\t}\n\t}\n}\n\n\n\nvoid func(){\n\n\tfor(int i = 0; i < 128; i++)loc[i] = -1;\n\tword_num = 0;\n\n\tscanf(\"%d %d\",&H,&W);\n\tfor(int i = 0; i < H; i++){\n\t\tscanf(\"%s\",map[i]);\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tif(map[i][k] != '.'){\n\t\t\t\tif(loc[map[i][k]-'0'] == -1){ //????????´?????´???\n\t\t\t\t\tloc[map[i][k]-'0'] = word_num;\n\t\t\t\t\tword_table[word_num] = map[i][k];\n\t\t\t\t\tword_num++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool FLG = true;\n\tint most_left,most_right,most_top,most_bottom;\n\tchar ch;\n\n\tfor(int i = 0; i < word_num; i++){\n\t\tch = word_table[i];\n\n\t\tmost_left = 51,most_right = -1,most_top = 51,most_bottom = -1;\n\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(map[row][col] == ch){\n\t\t\t\t\tmost_left = min(most_left,col);\n\t\t\t\t\tmost_right = max(most_right,col);\n\t\t\t\t\tmost_top = min(most_top,row);\n\t\t\t\t\tmost_bottom = max(most_bottom,row);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int row = most_top; row <= most_bottom; row++){\n\t\t\tfor(int col = most_left; col <= most_right; col++){\n\t\t\t\tif(map[row][col] == '.'){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!FLG)break;\n\t\t}\n\t}\n\n\tif(!FLG){\n\t\tprintf(\"SUSPICIOUS\\n\");\n\t\treturn;\n\t}\n\n\tisOK = false;\n\tint work[8];\n\n\tfor(int i = 0; i < word_num; i++)work[i] = -1;\n\n\trecursive(work,0);\n\n\tif(isOK){\n\t\tprintf(\"SAFE\\n\");\n\t}else{\n\t\tprintf(\"SUSPICIOUS\\n\");\n\t}\n}\n\n\nint main(){\n\n\tint num;\n\tscanf(\"%d\",&num);\n\n\tfor(int i = 0; i < num; i++)func();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\n#define INF 20160307\n#define MAX_N 60\n#define MAX_C 26\n#define MAX_D 7\n\nchar T[MAX_C + 2] = \".ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nint x[MAX_N][MAX_N];\nint wa[MAX_D][MAX_N][MAX_N];\nint genkai[MAX_C + 1][2][2], aru[MAX_C + 1], g[MAX_C + 1][2][2];\nint H, W, N; char c; vector<int>aru2;\n\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int i = 0; i < MAX_D; i++) {\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\t\tx[j][k] = 0;\n\t\t\t\t\twa[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= MAX_C; i++) {\n\t\t\taru[i] = 0;\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tgenkai[i][j][0] = INF;\n\t\t\t\tgenkai[i][j][1] = -INF;\n\t\t\t\tg[i][j][0] = INF;\n\t\t\t\tg[i][j][1] = -INF;\n\t\t\t}\n\t\t}\n\t\tcin >> H >> W;\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcin >> c;\n\t\t\t\tfor (int k = 0; k < MAX_C + 1; k++) {\n\t\t\t\t\tif (T[k] == c) {\n\t\t\t\t\t\tx[i][j] = k;\n\t\t\t\t\t\tif (k != 0) {\n\t\t\t\t\t\t\tgenkai[k][0][0] = min(genkai[k][0][0], i);\n\t\t\t\t\t\t\tgenkai[k][0][1] = max(genkai[k][0][1], i);\n\t\t\t\t\t\t\tgenkai[k][1][0] = min(genkai[k][1][0], j);\n\t\t\t\t\t\t\tgenkai[k][1][1] = max(genkai[k][1][1], j);\n\t\t\t\t\t\t\taru[k] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\taru2.clear();\n\t\tfor (int i = 1; i <= MAX_C; i++) {\n\t\t\tif (aru[i] == 1) {\n\t\t\t\taru2.push_back(i);\n\t\t\t\tg[aru2.size() - 1][0][0] = genkai[i][0][0];\n\t\t\t\tg[aru2.size() - 1][0][1] = genkai[i][0][1];\n\t\t\t\tg[aru2.size() - 1][1][0] = genkai[i][1][0];\n\t\t\t\tg[aru2.size() - 1][1][1] = genkai[i][1][1];\n\t\t\t}\n\t\t}\n\t\tint cnt = aru2.size();\n\t\tfor (int i = 0; i < aru2.size(); i++) {\n\t\t\tfor (int j = 1; j <= H; j++) {\n\t\t\t\tfor (int k = 1; k <= W; k++) {\n\t\t\t\t\tif (x[j][k] == aru2[i]) {\n\t\t\t\t\t\twa[i][j][k] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 1; j <= H; j++) {\n\t\t\t\tfor (int k = 1; k <= W; k++) {\n\t\t\t\t\twa[i][j][k] += wa[i][j][k - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tfor (int k = 1; k <= H; k++) {\n\t\t\t\t\twa[i][k][j] += wa[i][k - 1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>a1(cnt, 0);\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\ta1[i] = i;\n\t\t}\n\t\tint X1, Y1, X2, Y2, menseki, cnt2, wa2;\n\t\tdo {\n\t\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\t\tX1 = g[a1[i]][0][0], X2 = g[a1[i]][0][1];\n\t\t\t\tY1 = g[a1[i]][1][0], Y2 = g[a1[i]][1][1];\n\t\t\t\tmenseki = (X2 - X1 + 1)*(Y2 - Y1 + 1);\n\t\t\t\tcnt2 = 0;\n\t\t\t\tfor (int j = 0; j <= i; j++) {\n\t\t\t\t\twa2 = wa[a1[j]][X1 - 1][Y1 - 1] + wa[a1[j]][X2][Y2] - wa[a1[j]][X1 - 1][Y2] - wa[a1[j]][X2][Y1 - 1];\n\t\t\t\t\tcnt2 += wa2;\n\t\t\t\t}\n\t\t\t\tif (menseki != cnt2) {\n\t\t\t\t\tgoto E;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << \"SAFE\" << endl;\n\t\t\tgoto owata;\n\t\tE:;\n\t\t} while (next_permutation(a1.begin(), a1.end()));\n\t\tcout << \"SUSPICIOUS\" << endl;\n\towata:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((ULL)(n) >> (m) & 1)\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\nint n_dir = 4;\nint dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; /* CSS order */\nenum direction {\n\tUP, RIGHT, DOWN, LEFT\n};\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\nstruct article {\n\tchar material;\n\tbool is_removed;\n\tint topmost;\n\tint bottommost;\n\tint leftmost;\n\tint rightmost;\n};\n\ntypedef map<char, article> MCA;\n\nVVC image;\nMCA articles;\n\nbool remove_all()\n{\n\tbool all_removed = true;\n\tEACH (articles, itr) {\n\t\tarticle &art = itr->second;\n\t\tif (!art.is_removed) {\n\t\t\tall_removed = false;\n\t\t\t// Remove it and recurse\n\t\t\tVVC save = image;\n\t\t\tbool rect = true;\n\t\t\tFOR (i, art.topmost, art.bottommost + 1) {\n\t\t\t\tFOR (j, art.leftmost, art.rightmost + 1) {\n\t\t\t\t\tif (image[i][j] != '*' && image[i][j] != art.material) {\n\t\t\t\t\t\trect = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\timage[i][j] = '*';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rect) {\n\t\t\t\t// Recurse\n\t\t\t\tart.is_removed = true;\n\t\t\t\tif (remove_all()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Restore and continue trying\n\t\t\timage = save;\n\t\t}\n\t}\n\treturn all_removed;\n}\n\nint main()\n{\n\tint t; cin >> t;\n\tREP (z, t) {\n\t\tint h, w; cin >> h >> w;\n\t\timage = VVC(h, VC(w, '.'));\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tcin >> image[i][j];\n\t\t\t}\n\t\t}\n\n\t\t// Scan Image\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tif (image[i][j] != '.') {\n\t\t\t\t\tchar c = image[i][j];\n\t\t\t\t\tif (!EXIST(articles, c)) {\n\t\t\t\t\t\tarticle a = {c, false, 50, 0, 50, 0};\n\t\t\t\t\t\tarticles.insert(MCA::value_type(c, a));\n\t\t\t\t\t}\n\t\t\t\t\tarticles[c].topmost = min(articles[c].topmost, i);\n\t\t\t\t\tarticles[c].bottommost = max(articles[c].bottommost, i);\n\t\t\t\t\tarticles[c].leftmost = min(articles[c].leftmost, j);\n\t\t\t\t\tarticles[c].rightmost = max(articles[c].rightmost, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (remove_all()) {\n\t\t\tcout << \"SAFE\" << endl;\n\t\t} else {\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nstring s[50];\nbool f[26];\npair<int,int> tyouten[26][2];//最初に見つかった位置と最後に見つかった位置\nint main()\n{\n\tint d;\n\tint h,w;\n\tcin>>d;\n\tfor(int cnt=0;cnt<d;cnt++)\n\t{\n\t\tcin>>h>>w;\n\t\tif(h==0)\n\t\t\tbreak;\n\t\tfor(int i=0;i<h;i++)\n\t\t\tcin>>s[i];\n\t\tfill(f,f+26,true);\n\t\tfill(tyouten[0],tyouten[26],make_pair(-1,-1));\n\t\t//sを全走査して使われている文字を列挙する\n\t\tfor(int i=0;i<h;i++)\n\t\t{\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t{\n\t\t\t\tif(s[i][j]!='.')\n\t\t\t\t{\n\t\t\t\t\tif(f[s[i][j]-'A'])\n\t\t\t\t\t{\n\t\t\t\t\t\tf[s[i][j]-'A']=false;\n\t\t\t\t\t\ttyouten[s[i][j]-'A'][0]=make_pair(i,j);\n\t\t\t\t\t\ttyouten[s[i][j]-'A'][1]=make_pair(i,j);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttyouten[s[i][j]-'A'][0]=make_pair(min(tyouten[s[i][j]-'A'][0].first,i),min(tyouten[s[i][j]-'A'][0].second,j));\n\t\t\t\t\t\ttyouten[s[i][j]-'A'][1]=make_pair(max(tyouten[s[i][j]-'A'][1].first,i),max(tyouten[s[i][j]-'A'][1].second,j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//使われている文字から最初から長方形のものを探す\n\t\tbool ans=true;\n\t\twhile(ans)\n\t\t{\n\t\t\tans=false;\n\t\t\tfor(int i=0;i<26;i++)\n\t\t\t{\n\t\t\t\tif(!f[i])\n\t\t\t\t{\n\t\t\t\t\tbool flag=true;\n\t\t\t\t\t//範囲を調べる\n\t\t\t\t\tfor(int j=tyouten[i][0].first;j<tyouten[i][1].first+1;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int k=tyouten[i][0].second;k<tyouten[i][1].second+1;k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(!(s[j][k]=='A'+i || s[j][k]=='?'))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!flag)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//無事長方形だったならその部分を?で埋める\n\t\t\t\t\tif(flag)\n\t\t\t\t\t{\n\t\t\t\t\t\tans=true;\n\t\t\t\t\t\tf[i]=true;\n\t\t\t\t\t\tfor(int j=tyouten[i][0].first;j<tyouten[i][1].first+1;j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int k=tyouten[i][0].second;k<tyouten[i][1].second+1;k++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ts[j][k]='?';\n\t\t\t\t\t\t\t}\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//処理終わり\n\t\tans=true;\n\t\tfor(int i=0;i<26;i++)\n\t\t{\n\t\t\tif(!f[i])\n\t\t\t\tans=false;\n\t\t}\n\t\tif(ans)\n\t\t\tcout<<\"SAFE\"<<endl;\n\t\telse\n\t\t\tcout<<\"SUSPICIOUS\"<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n\nusing namespace std;\n\nint h,w;\nchar field[51][51];\nbool passed[51];\n\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\nstruct nodeInfo{\n    int minx;\n    int miny;\n    int maxx;\n    int maxy;\n    char kind;\n};\n\nint minx,miny,maxx,maxy;\nmap<char,int> key;\nint node;\nvector<int> G[51];\nbool isClosing=false;\nnodeInfo recInfo[51];\n\nvoid findRecSize (int y,int x,char kind){\n    for(int i = 0;i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(field[i][j]==kind){\n                miny=min(miny,i);\n                minx=min(minx,j);\n                maxy=max(maxy,i);\n                maxx=max(maxx,j);\n            }\n        }\n    }\n}\n\nvoid findClose(int s){\n    if(isClosing)\n        return;\n    if(passed[s]){\n        isClosing=true;\n        return;\n    }\n    passed[s]=true;\n    for(int i = 0; i < G[s].size(); i++){\n        findClose(G[s][i]);\n    }\n}\n\n\nint main(){\n\n    int n;\n    cin>>n;\n    while(n--){\n        for(int i = 0; i < 51; i++)\n            G[i].clear();\n        node=0;\n        key.clear();\n        cin>>h>>w;\n        memset(passed,0,sizeof(passed));\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin>>field[i][j];\n            }\n        }\n        bool no=false;\n        // ·û`»è\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                char kind=field[i][j];\n                if(kind!='.'&&key.find(kind)==key.end()){\n                    // nodeðV½Éo^·é\n                    key[kind]=node;\n                    node++;\n                    minx=miny=100;\n                    maxx=maxy=-1;\n                    findRecSize(i,j,kind);\n                    recInfo[node-1].maxx=maxx;\n                    recInfo[node-1].maxy=maxy;\n                    recInfo[node-1].minx=minx;\n                    recInfo[node-1].miny=miny;\n                    recInfo[node-1].kind=kind;             \n                    // ß½x,y»ê¼êÌÀWîñ©ç¾çê½l¦¤é·û`Ì`ÌTõðs¤\n                    for(int k = miny; k <= maxy; k++){\n                        for(int l = minx; l <= minx; l++){\n                            // TõææÉ.ª¶Ýµ½êA·û`ÅÍÈ¢\n                            if(field[k][l]=='.'){\n                                no=true;\n                                break;\n                            }\n                        }\n                        if(no)\n                            break;\n                    }\n                    if(no)\n                        break;\n                }\n                if(no)\n                    break;\n            }\n        }\n        if(no){\n            cout<<\"SUSPICIOUS\"<<endl;\n            continue;\n        }\n\n        // dÈèÌ\n        // ãÌÙ¤©çºÌÙ¤ÖGbWð£é\n        bool isRootNode[101];\n        fill(isRootNode,isRootNode+101,true);\n        for(int l = 0; l < node; l++){\n            int mnx=recInfo[l].minx;\n            int mxx=recInfo[l].maxx;\n            int mny=recInfo[l].miny;\n            int mxy=recInfo[l].maxy;\n            char kind=recInfo[l].kind;\n            for(int i = mny; i <= mxy; i++){\n                for(int j = mnx; j <= mxx; j++){\n                    if(field[i][j]!=kind){\n                        int from=key[field[i][j]];\n                        int to=key[kind];\n                        // Ü¾GbWª¢o^\n                        if(find(G[from].begin(),G[from].end(),to)==G[from].end()){\n                            G[from].push_back(to);\n                            isRootNode[to]=false;\n                        }\n                    }\n                }\n            }\n        }\n       // ÂHª¶Ý·é©Tõ\n        isClosing=false;\n        bool noRoot=true;\n        for(int i = 0; i < node; i++){\n            noRoot=false;\n            memset(passed,0,sizeof(passed));\n            findClose(i);\n            if(isClosing){\n                break;\n            }\n        }\n        if(key.size()!=0&&(isClosing)){\n            cout<<\"SUSPICIOUS\"<<endl;\n            continue;\n        }\n        else\n            cout<<\"SAFE\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint main(int argc, char *argv[]){\n  int n, w, h;\n  vector<int> perm(7);\n  pair<int, int> p[8][4];\n  cin >> n;\n  for (int r = 0; r < n; r++) {\n    map<char, int> matrial;\n    for (int i = 0; i < 7; i++) {\n      perm[i] = i;\n    }\n    cin >> h >> w;\n\n    char grid[h][w];\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> grid[i][j];\n        if(grid[i][j] != '.' && matrial.find(grid[i][j]) == matrial.end()){\n          matrial[grid[i][j]] = matrial.size();\n        }\n      }\n    }\n\n    for (int i = 0; i < 7; i++) {\n      p[i][0].first = 1e9, p[i][0].second = 1e9;\n      p[i][1].first = 0,   p[i][1].second = 0;\n    }\n\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if(matrial.find(grid[i][j]) != matrial.end()){\n          int minx = p[matrial[grid[i][j]]][0].first;\n          int miny = p[matrial[grid[i][j]]][0].second;\n          int maxx = p[matrial[grid[i][j]]][1].first;\n          int maxy = p[matrial[grid[i][j]]][1].second;\n          p[matrial[grid[i][j]]][0].first  = min(minx, j);\n          p[matrial[grid[i][j]]][0].second = min(miny, i);\n          p[matrial[grid[i][j]]][1].first  = max(maxx, j);\n          p[matrial[grid[i][j]]][1].second = max(maxy, i);\n        }\n      }\n    }\n    // for (auto &a: matrial){\n    //   std::cout << a.first << \" \" << a.second << std::endl;\n    // }\n    // for (int i = 0; i < matrial.size(); i++) {\n    //   std::cout << \"min:\" << std::endl;\n    //   std::cout << p[i][0].first << \" \" << p[i][0].second << std::endl;\n    //   std::cout << \"max:\" << std::endl;\n    //   std::cout << p[i][1].first << \" \" << p[i][1].second << std::endl;\n    // }\n    bool flag = false;          \n    do{\n      for (int i = 0; i < matrial.size(); i++) {\n        for (int j = p[i][0].second; j <= p[i][1].second; j++) {\n          for (int k = p[i][0].first; k <= p[i][1].first; k++) {\n            //std::cout << grid[j][k];\n            if(grid[j][k] != '.' && perm[matrial[grid[j][k]]] <= perm[i])continue;\n            i = 10;\n            j = p[i][1].second + 1;\n            k = p[i][1].first  + 1;\n          }\n        }\n        if(i == matrial.size() - 1)flag = true;\n      }\n    }while(next_permutation(perm.begin(), perm.end()));\n    if(flag || matrial.size() == 0){\n      std::cout << \"SAFE\" << std::endl;\n    }else{\n      std::cout << \"SUSPICIOUS\" << std::endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n\nclass Goods{\npublic:\n\tint left;\n\tint right;\n\tint top;\n\tint bottom;\n\tchar material;\n\n\tvoid check(int h, int w);\n};\n\nvoid Goods::check(int h, int w){\n\tif (w < left){\n\t\tleft = w;\n\t}\n\tif (w > right){\n\t\tright = w;\n\t}\n\tif (h < top){\n\t\ttop = h;\n\t}\n\tif (h > bottom){\n\t\tbottom = h;\n\t}\n\treturn;\n}\n\n\nint main(){\n\tint N;\t//データセット数\n\tint H;\t//縦\n\tint W;\t//横\n\n\tconst int num = 7;\t//材質数上限\n\tint m;\t//登場材質数\n\tint g;\n\tchar read;\n\n\tcin >> N;\n\n\tfor (int n = 0; n < N; n++){\n\t\tm = 0;\n\n\t\tcin >> H >> W;\n\n\t\tGoods goods[num];\n\t\tint** image = new int*[H];\n\t\t\n\t\tfor (int h = 0; h < H; h++){\n\t\t\timage[h] = new int[W];\n\t\t\tfor (int w = 0; w < W; w++){\n\t\t\t\tcin >> read;\n\t\t\t\t\n\t\t\t\tif (read == '.'){\n\t\t\t\t\timage[h][w] = -1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tg = 0;\n\t\t\t\t\twhile (g < m){\n\t\t\t\t\t\tif (read == goods[g].material){\n\t\t\t\t\t\t\timage[h][w] = g;\n\t\t\t\t\t\t\tgoods[g].check(h, w);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tg++;\n\t\t\t\t\t}\n\t\t\t\t\tif (g == m){\n\t\t\t\t\t\timage[h][w] = g;\n\t\t\t\t\t\tgoods[m].material = read;\n\t\t\t\t\t\tgoods[m].left = w;\n\t\t\t\t\t\tgoods[m].right = w;\n\t\t\t\t\t\tgoods[m].top = h;\n\t\t\t\t\t\tgoods[m].bottom = h;\n\t\t\t\t\t\tm++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}//読み取り終了\n\n\n\t\t//for (int h = 0; h < H; h++){\n\t\t//\tfor (int w = 0; w < W; w++){\n\t\t//\t\tcout.width(2);\n\t\t//\t\tcout << image[h][w];\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\n\t\t//チェック\n\t\tbool** near = new bool*[m];\t//手前にあるか(長方形だとしたときに, 行より列が手前ならtrue)\n\t\tfor (g = 0; g < m; g++){\n\t\t\tnear[g] = new bool[m];\n\t\t\tfor (int g2 = 0; g2 < m; g2++){\n\t\t\t\tnear[g][g2] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (g = 0; g < m; g++){\n\t\t\tfor (int h = goods[g].top; h <= goods[g].bottom; h++){\n\t\t\t\tfor (int w = goods[g].left; w <= goods[g].right; w++){\n\t\t\t\t\tif (image[h][w] == -1){\n\t\t\t\t\t\tgoto SUSPICIOUS;\n\t\t\t\t\t}\n\t\t\t\t\telse if(image[h][w] != g){\n\t\t\t\t\t\tif (near[g][image[h][w]] == false){\n\t\t\t\t\t\t\tnear[g][image[h][w]] = true;\n\t\t\t\t\t\t\tfor (int g2 = 0; g2 < m; g2++){\n\t\t\t\t\t\t\t\tnear[g][g2] = (near[g][g2] || near[image[h][w]][g2]);\n\t\t\t\t\t\t\t\tnear[g2][image[h][w]] = (near[g2][g] || near[g2][image[h][w]]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}//1材質あたりのチェック\n\t\t}//全アイテムチェック\n\t\tfor (g = 0; g < m; g++){\n\t\t\tif (near[g][g] == true){\n\t\t\t\tgoto SUSPICIOUS;\n\t\t\t}\n\t\t}\n\t\tcout << \"SAFE\" << endl;\n\t\tcontinue;\n\t\t\n\tSUSPICIOUS:\n\t\tcout << \"SUSPICIOUS\" << endl;\n\t\tcontinue;\n\t\t\n\n\t}//1データセット\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef pair<ll,ll> P;\ntypedef pair<int,int> pii;\ntypedef vector<P> vpl;\ntypedef tuple<ll,ll,ll> tapu;\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nconst int inf = 1<<30;\nconst ll linf = 1LL<<62;\nconst int MAX = 2020000;\nll dy[8] = {1,-1,0,0,1,-1,1,-1};\nll dx[8] = {0,0,1,-1,1,-1,-1,1};\nconst double pi = acos(-1);\nconst double eps = 1e-7;\ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){\n\tif(a>b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){\n\tif(a<b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T> inline void print(T &a){\n    rep(i,a.size()) cout << a[i] << \" \";\n    cout << \"\\n\";\n}\ntemplate<typename T1,typename T2> inline void print2(T1 a, T2 b){cout << a << \" \" << b << \"\\n\";}\ntemplate<typename T1,typename T2,typename T3> inline void print3(T1 a, T2 b, T3 c){\n\tcout << a << \" \" << b << \" \" << c << \"\\n\";\n}\nll pcount(ll x) {return __builtin_popcount(x);};\nconst int mod = 1e9 + 7;\n//const int mod = 998244353;\n\ntemplate <typename T> struct Compress{\n\tvector<T> comp;\n \n\tCompress(vector<T> v) : comp(v){\n\t\tsort(comp.begin(), comp.end());\n\t\tcomp.erase(unique(comp.begin(), comp.end()), comp.end());\n\t}\n \n\tll get(T x){\n\t\treturn lower_bound(comp.begin(), comp.end(), x) - comp.begin();\n\t}\n \n\tT operator[](int id){\n\t\treturn comp[id];\n\t}\n \n\tll siz(){\n\t\treturn comp.size();\n\t}\n};\n\nint main(){\n    int t; cin >> t;\n    while(t--){\n        int h,w; cin >> h >> w;\n        vs s(h); rep(i,h) cin >> s[i];\n        vector<int> c;\n        rep(i,h){\n            rep(j,w) if(s[i][j] != '.') c.push_back(s[i][j]);\n        }\n        Compress<int> comp(c);\n        vvl v(h,vl(w,-1));\n        rep(i,h) rep(j,w){\n            if(s[i][j] != '.') v[i][j] = comp.get(s[i][j]);\n        }\n        int m = comp.siz();\n        vl nxt(m); rep(i,m) nxt[i] = i;\n        bool fin = false;\n        do{\n            vvl t(m,vl(m,0));\n            rep(i,m) REP(j,i+1,m) t[nxt[i]][nxt[j]] = 1;\n            vl l(m,inf),r(m,0),u(m,inf),d(m,0);\n            rep(i,h){\n                rep(j,w){\n                    if(s[i][j] == '.') continue;\n                    chmin(l[v[i][j]], j);\n                    chmax(r[v[i][j]], j);\n                    chmin(u[v[i][j]], i);\n                    chmax(d[v[i][j]], i);\n                }\n            }\n            bool f = true;\n            rep(k,m){\n                REP(i,u[k],d[k]+1){\n                    REP(j,l[k],r[k]+1){\n                        if(v[i][j] == k) continue;\n                        if(s[i][j] == '.') f = false;\n                        if(!t[k][v[i][j]]) f = false;\n                    }\n                }\n            }\n            if(f){\n                puts(\"SAFE\");\n                fin = true;\n            }\n            if(fin) break;\n        }while(next_permutation(all(nxt)));\n        if(fin) continue;\n        puts(\"SUSPICIOUS\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<string>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<climits>\n#include<set>\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\ntypedef pair<ll, ll> pll;\n//int dx[4] = { 1,0,0,-1 };\n//int dy[4] = { 0,1,-1,0 };\n#define MOD 1000000007\n#define ARRAY_MAX 55\n\nconst int INF = 1e9 + 7;\n\nint T, H, W, N;\nchar mp[ARRAY_MAX][ARRAY_MAX];\nint p[26][4];//p[][0]:xmini,p[][1]:xmax,p[][2]:ymini,p[][3]:ymax,\nbool ans;\nbool used[26];\n\n\nvoid dfs(int cnt) {\n\n\tif (ans)\n\t{\n\t\treturn;\n\t}\n\n\tif (cnt == N)\n\t{\n\t\t//最後まで調べられた(長方形以外のものがない)\n\t\tans = true;\n\t\treturn;\n\t}\n\n\t//1番上にあるものから順に取り除いていく\n\tfor (int k = 0; k < 26; k++)\n\t{\n\t\tif (used[k] == false)\n\t\t{\n\t\t\t//使わない文字なら飛ばす\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (int i = p[k][0]; i <= p[k][1]; i++)\n\t\t{\n\t\t\tfor (int j = p[k][2]; j <= p[k][3];j++)\n\t\t\t{\n\t\t\t\t//長方形になっていない場合はreturn\n\t\t\t\tif (mp[i][j] == '.')\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (mp[i][j] - 'A' != k && used[mp[i][j] - 'A'] == false)\n\t\t\t\t{\n\t\t\t\t\t//矩形内に別の材質のものがあった場合について\n\t\t\t\t\t//usedがtrueであれば上に乗っかっていた場合を考えているのでここは通過するが、\n\t\t\t\t\t//falseの場合は上に乗っていなかった場合であるためこの矩形は長方形ではない\n\t\t\t\t\t\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//以下矩形は長方形であった場合\n\n\t\tused[k] = false;//(ただ単に取り除いた)\n\t\tdfs(cnt + 1);\n\t\tused[k] = true;//取り除く（上に乗っていたケースと考えるので矩形内の別の材質は自身のマスと考えてよい）\n\t}\n}\n\n\nint main(){\n\n\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> T;\n\tfor (int i = 0; i < T; i++)\n\t{\n\t\tcin >> H >> W;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> mp[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 26; i++)\n\t\t{\n\t\t\tp[i][0] = p[i][2] = INF;//mini\n\t\t\tp[i][1] = p[i][3] = 0;//maxi\n\t\t}\n\n\t\tN = 0;\n\t\tans = false;\n\t\tmemset(used, false, sizeof(used));\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (mp[i][j] == '.')\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint index = mp[i][j] - 'A';\n\t\t\t\tp[index][0] = min(p[index][0], i);\n\t\t\t\tp[index][1] = max(p[index][1], i);\n\t\t\t\tp[index][2] = min(p[index][2], j);\n\t\t\t\tp[index][3] = max(p[index][3], j);\n\t\t\t\tif (used[index] == false) {\n\t\t\t\t\tN++;\n\t\t\t\t\tused[index] = true;//falseならこの文字を使用\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\n\t\tif (ans == true)\n\t\t{\n\t\t\tcout << \"SAFE\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> v;\nbool ngchars[256];\n\nbool check(int y, int x, int Y, int X, char C) {\n\tbool out;\n\tbool in;\n\tY++; X++;\n\tfor(int i = y; i < Y; i++) {\n\t\tfor(int j = x; j < X; j++) {\n\t\t\tif(ngchars[v[i][j]]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tfor(int iter = 0; iter < n; iter++) {\n\t\tint w, h;\n\t\tvector<char> cs;\n\t\tcin >> h >> w;\n\t\tv.clear();\n\t\tv.resize(h);\n\t\tfor(int i = 0; i < h; i++)\n\t\t\tcin >> v[i];\n\t\tfor(int i = 0; i < 256; i++)\n\t\t\tngchars[i] = false;\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tfor(int j = 0; j < v[i].size(); j++) {\n\t\t\t\tif(v[i][j] != '.') {\n\t\t\t\t\tcs.push_back(v[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint x[30], y[30], X[30], Y[30];\n\t\tfor(int i = 0; i < 30; i++) {\n\t\t\tx[i] = y[i] = 100;\n\t\t\tX[i] = Y[i] = -1;\n\t\t}\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tfor(int j = 0; j < v[i].size(); j++) {\n\t\t\t\tif(v[i][j] == '.') continue;\n\t\t\t\tint c;\n\t\t\t\tc = v[i][j] - 'A';\n\t\t\t\tx[c] = min(x[c], j);\n\t\t\t\tX[c] = max(X[c], j);\n\t\t\t\ty[c] = min(y[c], i);\n\t\t\t\tY[c] = max(Y[c], i);\n\t\t\t}\n\t\t}\n\n\t\tbool res = false;\n\t\tsort(cs.begin(), cs.end());\n\t\tcs.erase(unique(cs.begin(), cs.end()), cs.end());\n\t\tdo {\n\t\t\tfor(int i = 0; i < cs.size(); i++)\n\t\t\t\tngchars[cs[i]] = true;\n\t\t\tngchars['.'] = true;\n\t\t\tbool f = true;\n\t\t\tfor(int i = 0; i < cs.size(); i++) {\n\t\t\t\tngchars[cs[i]] = false;\n\t\t\t\tint c = cs[i] - 'A';\n\t\t\t\tif(!check(y[c],x[c],Y[c],X[c],'A'+c)) {\n\t\t\t\t\tf = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f)\n\t\t\t\tres = true;\n\t\t} while(next_permutation(cs.begin(), cs.end()));\n\t\tif(res)\n\t\t\tcout << \"SAFE\" << endl;\n\t\telse\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl;\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct edge{int from, to; ll cost;};\n\nmap<char, bool> is_removed;\nint baggage_cnt = 0;\nint h,w;\nchar c = '*';\n\nbool is_rectangle(int si, int sj, int gi, int gj, string s[]){\n    c = '*';\n    reppp(i, si, gi+1){\n        reppp(j, sj, gj+1){\n            if(s[i][j] != '.' && !is_removed[s[i][j]]){\n                c = s[i][j];\n                break;\n            }\n        }\n        if(c != '*') break;\n    }\n    if(c == '*') return false;\n\n    rep(h){\n        repp(j, w){\n            if(si <= i && i <= gi && sj <= j && j <= gj){\n                if(s[i][j] != c && !is_removed[s[i][j]]){\n                    return false;\n                }\n            }else{\n                if(s[i][j] == c) return false;\n            }\n        }\n    }\n    return true;\n}\n\nstring solve(string s[]){\n    set<char> st;\n    rep(h){\n        repp(j, w){\n            if(s[i][j] != '.') st.insert(s[i][j]);\n        }\n    }\n    baggage_cnt = (int)st.size();\n\n    while(true){\n        for(int si=0;si<h;++si){\n            for(int sj=0;sj<w;++sj){\n                if(s[si][sj] == '.') continue;\n                for(int gi=h-1;si<=gi;--gi){\n                    for(int gj=w-1;sj<=gj;--gj){\n                        if(s[gi][gj] == '.') continue;\n                        if(is_rectangle(si, sj, gi, gj, s)){\n                            /*\n                            debug(si);\n                            debug(sj);\n                            debug(gi);\n                            debug(gj);\n                            cerr << endl;\n                            */\n                            is_removed[c] = true;\n                            baggage_cnt--;\n                            if(!baggage_cnt) return \"SAFE\";\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return \"SUSPICIOUS\";\n}\n\nint main() {\n    int t;\n    cin >> t;\n\n    repp(tt, t){\n        cin >> h >> w;\n        string s[h];\n        rep(h) cin >> s[i];\n        is_removed.clear();\n        baggage_cnt = 0;\n        cout << solve(s) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<set>\n\nusing namespace std;\n\n#define MAX(X,Y) ((X)>(Y) ? (X) : (Y))\n#define MIN(X,Y) ((X)<(Y) ? (X) : (Y))\n\nvoid dfs(set<char> graph[], char now, int &k, int dst[]) {\n    if(dst[now] != -1) return;\n    dst[now] = 100000;\n    for(char cn : graph[now])\n        dfs(graph, cn, k, dst);\n    dst[now] = k++;\n}\n\nbool strong(set<char> graph[], set<char> rev[]) {\n    int ord[256];\n    memset(ord, 0xFF, sizeof(ord));\n    int k=0;\n    for(char c='A'; c<='Z'; c++)\n        dfs(graph, c, k, ord);\n    while(k >= 0) {\n        for(char c='A'; c<='Z'; c++)\n            if(ord[c] == k)\n                for(char cb : rev[c])\n                    if(ord[cb] < ord[c])\n                        return false;\n        k--;\n    }\n    return true;\n}\n\n\nint main(void) {\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=0; i<n; i++) {\n        char s[100][100];\n        int minx[256], maxx[256], miny[256], maxy[256];\n        set<char> cs[256], rev[256];\n\n        memset(s, 0, sizeof(s));\n        memset(maxx, 0xFF, sizeof(maxx));\n        memset(maxy, 0xFF, sizeof(maxy));\n        memset(minx, 0x7F, sizeof(minx));\n        memset(miny, 0x7F, sizeof(miny));\n\n        int h, w;\n        scanf(\"%d%d\",&h,&w);\n        for(int j=0; j<h; j++)\n            scanf(\"%s\",s[j]);\n\n        for(int ih=0; ih<h; ih++)\n            for(int iw=0; iw<w; iw++) {\n                minx[s[ih][iw]] = MIN(minx[s[ih][iw]] , iw);\n                miny[s[ih][iw]] = MIN(miny[s[ih][iw]] , ih);\n                maxx[s[ih][iw]] = MAX(maxx[s[ih][iw]] , iw);\n                maxy[s[ih][iw]] = MAX(maxy[s[ih][iw]] , ih);\n            }\n        bool safe = true;\n        for(char c='A'; c<='Z'; c++) {\n            if(minx[c] == 0x7F7F7F7F) continue;\n\n            for(int iw=minx[c]; iw<=maxx[c]; iw++)\n                for(int ih=miny[c]; ih<=maxy[c]; ih++) {\n                    if(s[ih][iw] == '.') { safe = false; continue; }\n                    if(c != s[ih][iw])\n                        cs[c].insert(s[ih][iw]), rev[s[ih][iw]].insert(c);\n                }\n        }\n\n/*        for(char c='A'; c<='Z'; c++) {\n            printf(\"%c: \", c);\n            for(char cn : cs[c])\n                printf(\"%c \", cn);\n            puts(\"\");\n        }*/\n        if(safe)\n            safe = strong(cs, rev);\n\n        puts(safe ? \"SAFE\" : \"SUSPICIOUS\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool ans;\n\n// 文字cの出現するx,y座標の最大値と最小値の保持に使う\nstruct range{\n\tint min_x, min_y, max_x, max_y;\n\trange(int min_x_ , int min_y_ , int max_x_ , int max_y_ ){\n\t\tmin_x = min_x_;\n\t\tmin_y = min_y_;\n\t\tmax_x = max_x_;\n\t\tmax_y = max_y_;\n\t}\n};\n\nvoid debug(const vector<string>& m){\n\tcout << \"[debug]\" << endl;\n\tfor(int y=0 ; y < m.size() ; y++ ){\n\t\tcout << m[y] << endl;\n\t}\n\tcout << endl;\n}\n\nvoid debug2(const vector<char>& vc, const vector<range>& vr){\n\tfor(int i=0 ; i < vc.size() ; i++ ){\n\t\trange r = vr[i];\n\t\tcout << vc[i] << \" \" << endl;\n\t\tcout << \"x => [\" << r.min_x << \",\" << r.max_x << \"] \";\n\t\tcout << \"y => [\" << r.min_y << \",\" << r.max_y << \"] \";\n\t\tcout << endl << endl;\n\t}\n}\n\n// 文字 c の出現する x,y 座標の最大値と最小値を求める\nrange search_range(const vector<string>& m, char c){\n\tint min_x = -1, min_y = -1, max_x = -1, max_y = -1;\n\tfor(int y = 0 ; y < m.size() ; y++ ){\n\t\tfor(int x=0 ; x < m[y].size() ; x++ ){\n\t\t\tif( m[y][x] == c ){\n\t\t\t\tmin_x = (min_x == -1)? x : min( min_x , x );\n\t\t\t\tmin_y = (min_y == -1)? y : min( min_y , y );\n\t\t\t\tmax_x = (max_x == -1)? x : max( max_x , x );\n\t\t\t\tmax_y = (max_y == -1)? y : max( max_y , y );\n\t\t\t}\n\t\t}\n\t}\n\trange r( min_x , min_y , max_x , max_y );\n\treturn r;\n}\n\n// 文字 c について長方形かどうか\nbool check(const vector<string>& m, range r, char c){\n\tint cnt = 0;\n\tfor(int y = r.min_y ; y <= r.max_y ; y++ ){\n\t\tfor(int x = r.min_x ; x <= r.max_x ; x++ ){\n\t\t\tif( m[y][x] == c || m[y][x] == '*' ){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//cout << \"search \" << c << \" cnt : \" << cnt << endl;\n\t//cout << \"(\" << r.min_x << \",\" << r.min_y << \") => (\" << r.max_x << \",\" << r.max_y << \")\" << endl; \n\t\n\tif( cnt != (r.max_x - r.min_x + 1) * (r.max_y - r.min_y + 1) ){\n\t\treturn false;\n\t}\n\t\n\tfor(int y = 0 ; y < m.size() ; y++ ){\n\t\tfor(int x = 0 ; x < m[y].size() ; x++ ){\n\t\t\tif( r.min_x <= x && r.min_y <= y && x <= r.max_x && y <= r.max_y ){\n\t\t\t}else if( m[y][x] == c ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\n// 文字 c を' *' に置き換える (荷物を取り除く) \nvoid remove(vector<string>& m, range r, char c){\n\tfor(int y = r.min_y ; y <= r.max_y ; y++ ){\n\t\tfor(int x = r.min_x ; x <= r.max_y ; x++ ){\n\t\t\tif( m[y][x] == c ){\n\t\t\t\tm[y][x] = '*';\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(int id, vector<bool> memo, vector<string> m, vector<char> vc, vector<range> vr){\n\tmemo[id] = true;\n\t\n\t// 長方形かどうか\n\tbool is_rect = check( m , vr[id] , vc[id] );\n\tif( is_rect == false ){\n\t\treturn;\n\t}\n\treturn ;\n\t// 文字 vc[id] を '*' に置き換える (荷物を取り除く) \n\tremove( m , vr[id] , vc[id] );\n\t\n\t//cout << vc[id] << \" is rectangle! \" << endl;\n\t//debug( m );\n\t\n\t// すべて調べたかどうか\n\tint cnt = 0;\n\tfor(int i=0 ; i < memo.size() ; i++ ){\n\t\tif( memo[i] )\n\t\t\tcnt++;\n\t}\n\tif( cnt == memo.size() && is_rect ){\n\t\tans = true;\n\t\treturn;\n\t}\n\t\n\tfor(int i=0 ; i < memo.size() ; i++ ){\n\t\tif( memo[i] == false ){\n\t\t\t//cout << \"next : \" << vc[i] << endl;\n\t\t\t//dfs( i , memo , m , vc , vr );\n\t\t}\n\t}\n}\n\nvoid solve(const vector<string>& m){\n\tchar ch[256] = {0};\n\tvector<char> vc;\n\tvector<range> vr;\n\tans = false;\n\t\n\t// 出現する文字を調べる\n\tfor(int y=0 ; y < m.size() ; y++ ){\n\t\tfor(int x=0 ; x < m[y].size() ; x++ ){\n\t\t\tif( m[y][x] >= 'A' && m[y][x] <= 'Z' ){\n\t\t\t\tch[ m[y][x] ] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(char c = 'A' ; c <= 'Z' ; c++ ){\n\t\tif( ch[c] )\n\t\t\tvc.push_back( c );\n\t}\n\t\n\t// 文字がなかったら \"SAFE\"\n\tif( vc.size() == 0 ){\n\t\tans = true;\n\t}\n\t\n\t// 各文字 c について x,y 座標の最大値と最小値を求める\n\tfor(int i=0 ; i < vc.size() ; i++ ){\n\t\trange r = search_range( m , vc[i] );\n\t\tvr.push_back( r );\n\t}\n\t//debug2( vc , vr );\n\t\n\t// DFSで重なる順番をすべて調べる\n\tvector<bool> memo( vc.size() );\n\tfor(int k=0 ; k < vc.size() ; k++ ){\n\t\tfor(int i=0 ; i < memo.size() ; i++ ){\n\t\t\tmemo[i] = false;\n\t\t}\n\t\tdfs( k , memo , m , vc , vr );\n\t}\n\t\n}\n\nint main(){\n\tint T;\n\tcin >> T;\n\tfor(int t_ = 0 ; t_ < T ; t_++ ){\n\t\tint w, h;\n\t\tcin >> h >> w;\n\t\t\n\t\tvector<string> m(h);\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> m[y];\n\t\t}\n\t\t\n\t\tsolve( m );\n\t\t\n\t\tif( ans ){\n\t\t\tcout << \"SAFE\" << endl;\n\t\t}else{\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define FOR(i,p,n) for(int i = p;i < (int)(n);i++)\n#define REP(i,n) FOR(i,0,n)\n\n\t\nusing namespace std;\n\nstruct rect \n{\n\tint min_w,max_w;\n\tint min_h,max_h;\n\tvoid update(int w,int h)\n\t{\n\t\tmin_w = min(min_w,w);max_w = max(max_w,w);\n\t\tmin_h = min(min_h,h);max_h = max(max_h,h);\n\t}\n};\n\nint h,w;\nvector<vector<char> > bag;\nvector<vector<char> > tmp;\nvector<char> layer;\nmap<char,rect> rects;\n\nvoid fill_rect(char type)\n{\n\trect rt = rects[type];\n\tfor(int y = rt.min_h;y <= rt.max_h ; y++)\n\t{\n\t\tfor(int x = rt.min_w; x <= rt.max_w;x++)\n\t\t{\n\t\t\ttmp[y][x] = type;\n\t\t}\n\t}\n\n\treturn ;\n}\n\n\nbool is_safe()\n{\n\tREP(y,h)REP(x,w)\n\t{\n\t\tif(tmp[y][x] != bag[y][x])return false;\n\t}\n\t\n\treturn true;\n}\n\n\nint main()\n{\n\tint T;\n\tcin >> T;\n\tREP(i,T)\n\t{\n\t\tcin >> h >> w;\n\t\tbag.assign(h,vector<char>(w, '.'));\n\t\trects.clear();layer.clear();\n\t\tREP(y,h)REP(x,w)\n\t\t{\n\t\t\tcin >> bag[y][x];\n\t\t\tif(bag[y][x] == '.')continue;\n\t\t\tif(rects.count(bag[y][x]) == 0)\n\t\t\t{\n\t\t\t\trects[bag[y][x]] = {x,x,y,y};\n\t\t\t\tlayer.push_back(bag[y][x]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trects[bag[y][x]].update(x,y);\n\t\t\t}\n\t\t}\n\n\t\n\t\tbool ok = false;\n\t\tsort(ALL(layer));\n\t\tdo\n\t\t{\n\t\t\ttmp = bag;\n\t\t\tREP(i,layer.size())\n\t\t\t{\n\t\t\t\tfill_rect(layer[i]);\n\t\t\t}\n\t\t\tif(is_safe()) { ok = true;break;}\n\t\t}while(next_permutation(ALL(layer)));\n\t\t\n\t\tcout <<  ((ok) ? \"SAFE\":\"SUSPICIOUS\") << endl;\n\t}\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nvector<string>in;\nint n,m;\nbool func(int a,int b,int c,int d,char e){\n\tloop(i,a,c+1)loop(j,b,d+1)if(in[i][j]!=e&&in[i][j]!='*')return 0;\n\treturn 1;\n}\nbool f(){\n\tloop(k,'A','Z'+1){\n\t\tint x1=inf,x2=-1,y1=inf,y2=-1;\n\t\tbool h=false;\n\t\trep(i,n)rep(j,m)if(in[i][j]==k){\n\t\t\tx1=min(x1,i);\n\t\t\ty1=min(y1,j);\n\t\t\tx2=max(x2,i);\n\t\t\ty2=max(y2,j);\n\t\t\th=true;\n\t\t}\n\t\tif(h&&func(x1,y1,x2,y2,k)){\n\t\t\tloop(i,x1,x2+1)loop(j,y1,y2+1)in[i][j]='*';\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint z;\n\tcin>>z;\n\twhile(z--){\n\t\tcin>>n>>m;\n\t\tin=vector<string>(n);\n\t\trep(i,n)cin>>in[i];\n\t\twhile(f());\n\t\tbool h=true;\n\t\trep(i,n)rep(j,m)if(in[i][j]!='.'&&in[i][j]!='*')h=false;\n\t\tif(h)cout<<\"SAFE\"<<endl;\n\t\telse cout<<\"SUSPICIOUS\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nstring str[60];\nint h,w;\nint num;\nbool flag;\nbool used[55][55];\nchar moji[10];\nint vx[4]={1,0,-1,0};\nint vy[4]={0,1,0,-1};\nvoid dfs(int Bit,int depth){\n  if(Bit==((1<<num)-1)){\n    flag=true;\n    return;\n  }\n\n  for(int i=0;i<num;i++){\n    if(!(Bit&(1<<i))){\n      bool used2[55][55]={};\n      int lemi=100,lema=0,rimi=100,rima=0;\n      for(int j=0;j<h;j++){\n\tfor(int k=0;k<w;k++){\n\t  if(str[j][k]==moji[i]){\n\t    used2[j][k]=true;\n\t    used[j][k]=true;\n\t    lemi=min(lemi,k);\n\t    lema=max(lema,k);\n\t    rima=max(rima,j);\n\t    rimi=min(rimi,j);\n\t  }\n\t}\n      }\n      bool fll=true;\n      //cout<<moji[i]<<\" \"<<lemi<<\" \"<<lema<<\" \"<<rimi<<\" \"<<rima<<endl;\n      for(int j=rimi;j<=rima;j++){\n\tfor(int k=lemi;k<=lema;k++){\n\t  if(!used[j][k]){\n\t    fll=false;\n\t  }\n\t}\n      }\n      if(fll)\n      dfs(Bit+(1<<i),depth+1);\n      for(int j=rimi;j<=rima;j++){\n\tfor(int k=lemi;k<=lema;k++){\n\t  if(used2[j][k]){\n\t    used[j][k]=false;\n\t  }\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int n;cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>h>>w;\n    num=0;\n    for(int i=0;i<55;i++)\n      for(int j=0;j<55;j++)\n\tused[i][j]=false;\n    flag=false;\n    bool alfa[26]={};\n    for(int i=0;i<h;i++){\n      cin>>str[i];\n      for(int j=0;j<w;j++){\n\talfa[str[i][j]-'A']=true;\n      }\n    }\n    int cnt=0;\n    for(int i=0;i<26;i++){\n      num+=alfa[i];\n      if(alfa[i]){\n\tmoji[cnt]=(char)(i+'A');\n\t//cout<<moji[cnt]<<endl;\n\tcnt++;\n      }\n    }\n    dfs(0,0);\n    if(flag)\n      cout<<\"SAFE\"<<endl;\n    else cout<<\"SUSPICIOUS\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<set>\n#include<map>\n#include<string>\n#include<cctype>\n\n#define N 64\nusing namespace std;\n\nbool isrectangle(char c, map<char,int> &s,\n\t\t char M[][N], int mini, int maxi, int minj, int maxj)\n{\n  for(int i = mini; i <= maxi; ++i){\n    for(int j = minj; j <= maxj; ++j){\n      if( !isalpha(M[i][j]) ) return false;\n      if( s[c] < s[M[i][j]] ) return false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  int T;\n  cin >> T;\n  for(int tc=1;tc<=T;++tc){\n    int h,w;\n    bool suspicious=true;\n    map<char,int> s;\n    vector<int> xdepth;\n    bool susp[256];\n    char M[N][N];\n    cin >> h >> w;\n\n    for(int i = 0; i < 256; ++i){\n      susp[i]=true;\n    }\n    for(int i = 0; i < h; ++i){\n      for(int j = 0; j < w; ++j){\n\tcin >> M[i][j];\n\tif(isalpha(M[i][j])){\n\t  s[M[i][j]]=0;\n\t}\n      }\n    }\n    if( s.size() == 0 ) suspicious = false;\n\n    for(int item = 0; item < s.size(); ++item){\n      for(int bit = 0; bit < (1<<s.size()); ++bit){\n\tbool ok=true;\n\tmap<char,int>::iterator its = s.begin();\n\tfor(int i = 0; i < s.size(); ++i){\n\t  if(i!=item){\n\t    its->second = (bit&(1<<i))?-1:1;\n\t  }else{\n\t    its->second = 0;\n\t  }\n\t  ++its;\n\t}\n\tfor(its = s.begin(); its != s.end(); ++its){\n\t  int mini=N,maxi=-1,minj=N,maxj=-1;\n\t  for(int i = 0; i < h; ++i){\n\t    for(int j = 0; j < w; ++j){\n\t      if( M[i][j] == its->first ){\n\t\tmini = min( mini, i );\n\t\tmaxi = max( maxi, i );\n\t\tminj = min( minj, j );\n\t\tmaxj = max( maxj, j );\n\t      }\n\t    }\n\t  }\n\t  if( !isrectangle( its->first, s, M, mini, maxi, minj, maxj ) ){\n\t    ok=false;\n\t  }\n\t}\n\tif(ok){\n\t  suspicious = false;\n\t}\n      }\n    }\n\n    if( suspicious ){\n      cout << \"SUSPICIOUS\";\n    }else{\n      cout << \"SAFE\";\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1e9;\n\nint d[51][51];\n\nint main(){\n    int tc;\n    cin >> tc;\n    rep(ij, 0, tc){\n        int h, w;\n        cin >> h >> w;\n        vector<string> s(h);\n        rep(i, 0, h){\n            cin >> s[i];\n        } \n        map<char, int> mp;\n        int n = 0;\n        rep(i, 0, h){\n            rep(j, 0, w){\n                if(s[i][j] == '.') continue;\n                if(!mp.count(s[i][j])){\n                    mp[s[i][j]] = n++;\n                }\n            }\n        }\n        vector<int> yMIN(n, INF), yMAX(n, -1), xMIN(n, INF), xMAX(n, -1);        \n        rep(i, 0, h){\n            rep(j, 0, w){\n                if(s[i][j] == '.') d[i][j] = -1;\n                else{\n                    d[i][j] = mp[s[i][j]]; \n                    chmin(yMIN[d[i][j]], i);\n                    chmax(yMAX[d[i][j]], i);\n                    chmin(xMIN[d[i][j]], j);\n                    chmax(xMAX[d[i][j]], j);\n                }\n            }\n        }\n        bool f = true;\n        bool isPut[10][10] = {};\n        rep(i, 0, n){\n            rep(j, yMIN[i], yMAX[i] + 1){\n                rep(k, xMIN[i], xMAX[i] + 1){\n                    if(d[j][k] != i){\n                        if(d[j][k] == -1) f = false;\n                        else{\n                            isPut[d[j][k]][i] = true;\n                        }\n                    }\n                }\n            }\n        }\n        if(!f){\n            cout << \"SUSPICIOUS\" << endl;\n            continue;\n        }\n        f = false;\n        vector<int> p(n);\n        rep(i, 0, n) p[i] = i;\n        do{\n            bool g = true;\n            rep(i, 0, n){\n                rep(j, 0, n){\n                    if(isPut[i][j]){\n                        if(p[i] < p[j]) g = false;\n                    }\n                }\n            }\n            if(g) f = true;\n            // for(int ii = 0; ii < p.size(); ii++){\n            //     if(ii) cout << ' ';\n            //     cout << p[ii];\n            // }\n            // cout << endl;\n        }while(next_permutation(p.begin(), p.end()));\n        if(f){\n            cout << \"SAFE\" << endl;\n        }else{\n            cout << \"SUSPICIOUS\" << endl;\n        }\n    }\n}   \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n\ntypedef long long lint;\ntypedef pair<int, int> pii;\n\nint H, W;\nstring pict[55];\n\nbool item[30];\nint l[30], t[30], r[30], b[30];\nint collision[30];\n\nbool look[30];\n\nbool rec(int i) {\n\tif (look[i]) return false;\n\t\n\tlook[i] = true;\n\t\n\tint col = collision[i];\n\tfor_(j,0,26) {\n\t\tif (col >> j & 1) {\n\t\t\tif (!rec(j)) return false;\n\t\t}\n\t}\n\t\n\tlook[i] = false;\n\t\n\treturn true;\n}\n\nbool is_safe() {\n\tminit(collision, 0);\n\t\n\tfor_(alph,0,26) {\n\t\tif (!item[alph]) continue;\n\t\t\n\t\tchar ALPH = 'A' + alph;\n\t\t\n\t\tfor_(y,t[alph],b[alph] + 1) for_(x,l[alph],r[alph] + 1) {\n\t\t\tif (pict[y][x] == '.') return false;\n\t\t\t\n\t\t\tif (pict[y][x] != ALPH) {\n\t\t\t\tint p = (int)(pict[y][x] - 'A');\n\t\t\t\tcollision[alph] |= 1 << p;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor_(alph,0,26) {\n\t\tif (!item[alph]) continue;\n\t\tminit(look,0);\n\t\tif (!rec(alph)) return false;\n\t}\n\t\n\treturn true;\n}\n\nvoid solve() {\n\tminit(item,0);\n\tfill(l, l + 30, W);\n\tfill(t, t + 30, H);\n\tfill(r, r + 30, 0);\n\tfill(b, b + 30, 0);\n\t\n\tfor_(i,0,H) for_(j,0,W) {\n\t\tchar c = pict[i][j];\n\t\tif (c == '.') continue;\n\t\tint ci = (int)(c - 'A');\n\t\t\n\t\titem[ci] = true;\n\t\tl[ci] = min(l[ci], j);\n\t\tt[ci] = min(t[ci], i);\n\t\tr[ci] = max(r[ci], j);\n\t\tb[ci] = max(b[ci], i);\n\t}\n\t\n\tif (is_safe()) cout << \"SAFE\" << endl;\n\telse cout << \"SUSPICIOUS\" << endl;\n}\n\nint main() {\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tcin >> H >> W;\n\t\tfor_(i,0,H) cin >> pict[i];\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n)-1;i>=(m);--i)\n#define repc(i,n) for(int i=0;i<=(n);++i)\n#define repcn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repcd(i,n) for(int i=(n);i>=0;--i)\n#define repcnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define repc0(i,n) for(i=0;i<=(n);++i)\n#define repcn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repcd0(i,n) for(i=(n);i>=0;--i)\n#define repcnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define p_queue(n) priority_queue<n,vector<n>,greater<n> >\n#define PUTLINE cout<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nstring str[60];\npair<pint, pint> b[30];\n\nint main() {\n\tint n, h, w;\n\tcin >> n;\n\twhile (--n >= 0) {\n\t\tcin >> h >> w;\n\t\trep (i, h) cin >> str[i];\n\t\trep (i, 30) {\n\t\t\tb[i].first.first = -1;\n\t\t\tb[i].first.second = -1;\n\t\t\tb[i].second.first = -1;\n\t\t\tb[i].second.second = -1;\n\t\t}\n\t\trep (i, h) rep (j, w) {\n\t\t\tif (isupper(str[i][j])) {\n\t\t\t\tint c = str[i][j] - 'A';\n\t\t\t\tif (b[c].first.first == -1) {\n\t\t\t\t\tb[c].first.first = i;\n\t\t\t\t\tb[c].first.second = j;\n\t\t\t\t}\n\t\t\t\tchmin(b[c].first.first, i);\n\t\t\t\tchmax(b[c].second.first, i);\n\t\t\t\tchmin(b[c].first.second, j);\n\t\t\t\tchmax(b[c].second.second, j);\n\t\t\t}\n\t\t}\n\t\tbool update = true;\n\t\twhile (update) {\n\t\t\tupdate = false;\n\t\t\trep (i, 30) {\n\t\t\t\tif (b[i].first.first == -1) continue;\n\t\t\t\tbool isbug = true;\n\t\t\t\trepcn (y, b[i].first.first, b[i].second.first) {\n\t\t\t\t\trepcn (x, b[i].first.second, b[i].second.second) {\n\t\t\t\t\t\tif (str[y][x] != i + 'A' && str[y][x] != '?') isbug = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isbug) {\n\t\t\t\t\trepcn (y, b[i].first.first, b[i].second.first) {\n\t\t\t\t\t\trepcn (x, b[i].first.second, b[i].second.second) {\n\t\t\t\t\t\t\tstr[y][x] = '?';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb[i].first.first = -1;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool safe = true;\n\t\trep (i, 30) {\n\t\t\tif (b[i].first.first != -1) safe = false;\n\t\t}\n\t\tcout <<(safe ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int N = 51;\nchar c[N][N];\nint imin[128], imax[128], jmin[128], jmax[128];\nbool f[128];\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint s, d; Weight w; Flow c;\n\tEdge() {};\n\tEdge(int s, int d, Weight w = 1) : s(s), d(d), w(w), c(w) {};\n};\nbool operator<(const Edge &e1, const Edge &e2) { return e1.w < e2.w; }\nbool operator>(const Edge &e1, const Edge &e2) { return e2 < e1; }\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid addArc(Graph &g, int s, int d, Weight w = 1) {\n\tg[s].emplace_back(s, d, w);\n}\nvoid addEdge(Graph &g, int a, int b, Weight w = 1) {\n\taddArc(g, a, b, w);\n\taddArc(g, b, a, w);\n}\n\nGraph reverse(const Graph &g) {\n\tGraph rg(g.size());\n\tfor (auto &es : g)\n\t\tfor (auto &e : es)\n\t\t\trg[e.d].emplace_back(e.d, e.s, e.w);\n\treturn rg;\n}\n\nvector<int> kosaraju(const Graph &g) {\n\tint n = g.size();\n\tGraph rg = reverse(g);\n\tvector<int> cc(n, -1);\n\tvector<int> post;\n\tfunction<void(int, int)> dfs_cc = [&](int u, int cc_id) {\n\t\tif (cc[u] != -1)return;\n\t\tcc[u] = cc_id;\n\t\tfor (auto &e : g[u])\n\t\t\tdfs_cc(e.d, cc_id);\n\t\tpost.emplace_back(u);\n\t};\n\tint count_cc = 0;\n\tfor (int u = 0; u < n; u++)\n\t\tif (cc[u] == -1)\n\t\t\tdfs_cc(u, count_cc++);\n\tvector<int> scc(n, -1);\n\tfunction<void(int, int, int)> dfs_scc = [&](int u, int scc_id, int cc_id) {\n\t\tif (scc[u] != -1)return;\n\t\tif (cc[u] != cc_id)return;\n\t\tscc[u] = scc_id;\n\t\tfor (auto &e : rg[u])\n\t\t\tdfs_scc(e.d, scc_id, cc_id);\n\t};\n\tint count_scc = 0;\n\treverse(post.begin(), post.end());\n\tfor (auto &u : post)\n\t\tif (scc[u] == -1)\n\t\t\tdfs_scc(u, count_scc++, cc[u]);\n\treturn scc;\n}\n\nbool detectCycle(const Graph &g) {\n\tvector<int> idx = kosaraju(g);\n\treturn find(all(idx), idx.size() - 1) == idx.end();\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N; cin >> N;\n\trep(i, 0, N) {\n\t\tint H, W; cin >> H >> W;\n\t\tmemset(c, 0, sizeof(c));\n\t\tmemset(imin, 0x3f, sizeof(imin));\n\t\tmemset(jmin, 0x3f, sizeof(jmin));\n\t\tmemset(imax, -1, sizeof(imax));\n\t\tmemset(jmax, -1, sizeof(jmax));\n\t\tmemset(f, 0, sizeof(f));\n\t\trep(i, 0, H)rep(j, 0, W) {\n\t\t\tcin >> c[i][j];\n\t\t\tchmin(imin[c[i][j]], i);\n\t\t\tchmax(imax[c[i][j]], i);\n\t\t\tchmin(jmin[c[i][j]], j);\n\t\t\tchmax(jmax[c[i][j]], j);\n\t\t\tf[c[i][j]] = true;\n\t\t}\n\t\tbool safe = true;\n\t\tGraph g(128);\n\t\trep(k, 'A', 'Z' + 1) {\n\t\t\tif (!f[k])continue;\n\t\t\trep(i, imin[k], imax[k] + 1) {\n\t\t\t\trep(j, jmin[k], jmax[k] + 1) {\n\t\t\t\t\tif (c[i][j] == '.') {\n\t\t\t\t\t\tsafe = false;\n\t\t\t\t\t}\n\t\t\t\t\telse if (c[i][j] != k) {\n\t\t\t\t\t\taddArc(g, k, c[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (detectCycle(g))safe = false;\n\t\tcout << (safe ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define fi first\n#define se second\n#define mk make_pair\nusing namespace std;\nmap<int,pair<int,int> >max_p,min_p;\nmap<char,int>mc;\nint h,w,c,vis[101];\nstring s[51];\nvoid mae(){\n  r(i,h)r(j,w)\n   if(s[i][j]=='.')s[i][j]='0';\n   else{\n    if(mc[s[i][j]])s[i][j]=mc[s[i][j]];\n    else{\n      mc[s[i][j]]=(c++)+'0';\n      s[i][j]=(c-1)+'0';\n    }\n   }\n}\nvoid in(){\n  for(int k=1;k<c;k++){\n    int px=0,py=0,mx=1000,my=1000;\n    r(i,h)r(j,w)\n      if(s[i][j]-'0'==k){\n        px=max(px,j);\n        py=max(py,i);\n        mx=min(mx,j);\n        my=min(my,i);\n      }\n    max_p[k]=mk(px,py);\n    min_p[k]=mk(mx,my);\n  }\n}\nbool chb(){\n  for(int k=1;k>c;k++){\n    pair<int,int>p1=min_p[k],p2=max_p[k];\n    for(int i=p1.se;i<=p2.se;i++)\n      for(int j=p1.fi;j<=p2.fi;j++)\n        if(s[i][j]=='0')return 1;\n  }\n  return 0;\n}\nbool dfs(int d,int x){\n  if(d){\n    pair<int,int>p1=min_p[x],p2=max_p[x];\n    for(int i=p1.se;i<=p2.se;i++)\n      for(int j=p1.fi;j<=p2.fi;j++)\n        if(!vis[s[i][j]-'0'])return 0;\n  }\n  if(d==c-1)return 1;\n  for(int i=1;i<c;i++)\n    if(!vis[i]){\n      vis[i]=1;\n      if(dfs(d+1,i))return 1;\n      vis[i]=0;\n    }\n  return 0;\n}\nint main(){\n  int n;\n  cin>>n;\n  while(n--){\n    memset(vis,0,sizeof(vis));\n    max_p.clear();\n    min_p.clear();\n    mc.clear();c=1;\n    cin>>h>>w;\n    r(i,h)cin>>s[i];\n    mae();\n    in();\n    if(chb())cout<<\"SUSPICIOUS\"<<endl;\n    else{\n      if(!dfs(0,0))cout<<\"SUSPICIOUS\"<<endl;\n      else cout<<\"SAFE\"<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstruct P {\n    int x, y, cost;\n\n    P(int x, int y, int cost): x(x), y(y), cost(cost) {}\n\n    bool operator >(const P& p) const {\n        return cost > p.cost;\n    }\n};\n\nconst int dx[] = {-1,0,1,0}; const int dy[] = {0,1,0,-1};\n\n#define X_MAX 50\n#define Y_MAX 50\n\nchar box[Y_MAX][X_MAX];\n\nstruct xy {\n    int x_min, x_max, y_min, y_max;\n};\n\nbool check_rect(vector<xy>& rect) {\n    for (auto r : rect) {\n        FOR(y, r.y_min, r.y_max+1) {\n        FOR(x, r.x_min, r.x_max+1) {\n            if (box[y][x] == '.') {\n                return false;\n            }\n        }\n        }\n    }\n    return true;\n}\n\nbool is_top(xy r, char c) {\n    FOR(y, r.y_min, r.y_max+1) {\n    FOR(x, r.x_min, r.x_max+1) {\n        if (box[y][x] != c && box[y][x] != '#') {\n            return false;\n        }\n    }\n    }\n    FOR(y, r.y_min, r.y_max+1) {\n    FOR(x, r.x_min, r.x_max+1) {\n        box[y][x] = '#';\n    }\n    }\n    return true;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    REP(i, n) {\n        int h, w;\n        cin >> h >> w;\n        fill_n((char *)box, Y_MAX*X_MAX, '.');\n\n        set<char> material_s;\n        REP(y, h) {\n        REP(x, w) {\n            cin >> box[y][x];\n            if (box[y][x] != '.') {\n                material_s.insert(box[y][x]);\n            }\n        }\n        }\n        map<char, int> material;\n        for (auto it = material_s.begin(); it != material_s.end(); it++) {\n            material.insert({*it, material.size()});\n        }\n\n        vector<xy> rect(material.size(), {X_MAX, 0, Y_MAX, 0});\n        REP(y, h) {\n        REP(x, w) {\n            if (box[y][x] != '.') {\n                int idx = material[box[y][x]];\n                rect[idx].x_min = min(rect[idx].x_min, x);\n                rect[idx].x_max = max(rect[idx].x_max, x);\n                rect[idx].y_min = min(rect[idx].y_min, y);\n                rect[idx].y_max = max(rect[idx].y_max, y);\n            }\n        }\n        }\n\n        if (!check_rect(rect)) {\n            cout << \"SUSPICIOUS\" << endl;\n            continue;\n        }\n\n        bool updated;\n        int n = 0;\n        vb seen(material.size());\n        do {\n            updated = false;\n            for (auto it = material.begin(); it != material.end(); it++) {\n                if (!seen[it->second] && is_top(rect[it->second], it->first)) {\n                    n++;\n                    seen[it->second] = true;\n                    updated = true;\n                }\n            }\n        } while (updated);\n\n        cout << (n == rect.size() ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <numeric>\n#include <functional>\n#include <cctype>\n#include <list>\n#include <limits>\n#include <cassert>\n//#include <boost/multiprecision/cpp_int.hpp>\n\n\n\nusing namespace std;\nusing Int = long long;\n//using namespace boost::multiprecision;\n\nconst double EPS = (1e-10);\nlong long const MOD = 1000000007;\n\nlong long mod_pow(long long x, long long n) {\n    long long res = 1;\n    for(int i = 0;i < 60; i++){\n        if(n >> i & 1) res = res * x % MOD;\n        x = x * x % MOD;\n    }\n    return res;\n}\n\ntemplate<typename T>\nT gcd(T a, T b) {\n    return b != 0 ? gcd(b, a % b) : a;\n}\n\ntemplate<typename T>\nT lcm(T a, T b) {\n    return a * b / gcd(a, b);\n}\n\nvoid fastInput() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n}\n\nstruct Baggage {\n    int lowerW, upperW, lowerH, upperH;\n};\n\nint solve(int H, int W) {\n    vector<vector<char>> field(H+1, vector<char>(W+1));\n\n    for (int h = 1; h <= H; h++) {\n        for (int w = 1; w <= W; w++) {\n            cin >> field[h][w];\n        }\n    }\n\n    vector<Baggage> vb(26, {1000, -1, 1000, -1});\n    for (int h = 1; h <= H; h++) {\n        for (int w = 1; w <= W; w++) {\n            if (field[h][w] == '.') continue;\n            vb[field[h][w] - 'A'].lowerH = min(vb[field[h][w] - 'A'].lowerH, h);\n            vb[field[h][w] - 'A'].upperH = max(vb[field[h][w] - 'A'].upperH, h);\n            vb[field[h][w] - 'A'].lowerW = min(vb[field[h][w] - 'A'].lowerW, w);\n            vb[field[h][w] - 'A'].upperW = max(vb[field[h][w] - 'A'].upperW, w);\n        }\n    }\n\n    int numOfBaggage = 0;\n    for (int i = 0; i < 26; i++) {\n        if (vb[i].upperW != -1) numOfBaggage++;\n    }\n\n    vector<vector<int>> covered(H+1, vector<int>(W+1));\n    for (int i = 0; i < numOfBaggage; i++) {\n        for (int j = 0; j < 26; j++) {\n            if (vb[j].upperW == -1) continue;\n            int lowerW = vb[j].lowerW;\n            int upperW = vb[j].upperW;\n            int lowerH = vb[j].lowerH;\n            int upperH = vb[j].upperH;\n            int flag = 1;\n            for (int h = 1; h <= H; h++) {\n                for (int w = 1; w <= W; w++) {\n                    if (lowerW <= w && w <= upperW && lowerH <= h && h <= upperH) {\n                        if (field[h][w] != 'A' + j && !covered[h][w]) {\n                            flag = 0;\n                        }\n                    } else {\n                        if (field[h][w] == 'A' + j) {\n                            flag = 0;\n                        }\n                    }\n                }\n            }\n            if (flag) {\n                vb[j] = {1000, -1, 1000, -1};\n                for (int h = lowerH; h <= upperH; h++) {\n                    for (int w = lowerW; w <= upperW; w++) {\n                        covered[h][w] = 1;\n                    }\n                }\n            }\n        }\n    }\n    int ret = 1;\n    for (int i = 0; i < 26; i++) {\n        if (vb[i].upperH != -1) ret = 0;\n    }\n    return ret;\n}\n\nint main(void) {\n    int N, H, W;\n    cin >> N;\n    vector<int> ans(N);\n    for (int i = 0; i < N; i++) {\n        cin >> H >> W;\n        ans[i] = (solve(H, W));\n    }\n    for (auto &i : ans) {\n        if (i) cout << \"SAFE\" << endl;\n        else cout << \"SUSPICIOUS\" << endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef double weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<vector<edge>> Graph;\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint h, w;\nvs fld;\n\nbool isend()\n{\n\tREP(i, h)REP(j, w) if (fld[i][j] != '.'&&fld[i][j] != '*') return false;\n\treturn true;\n}\n\nbool check(char c)\n{\n\tint ux = INF, uy = INF, lx = -1, ly = -1;\n\tREP(i, h)REP(j, w)\n\t{\n\t\tif (fld[i][j] == c)\n\t\t{\n\t\t\tchmin(ux, i); chmin(uy, j);\n\t\t\tchmax(lx, i); chmax(ly, j);\n\t\t}\n\t}\n\tif (ux == INF) return false;\n\n\tbool f = true;\n\tREP(i, h)REP(j, w)\n\t{\n\t\tif (i >= ux&&i <= lx&&j >= uy&&j <= ly)\n\t\t{\n\t\t\tif (fld[i][j] != c&&fld[i][j] != '*') f = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (fld[i][j] == c) f = false;\n\t\t}\n\t}\n\tif (f)\n\t{\n\t\tfor (int i = ux; i <= lx; i++)for (int j = uy; j <= ly; j++)\n\t\t{\n\t\t\tfld[i][j] = '*';\n\t\t}\n\t}\n\treturn f;\n}\n\nint main()\n{\n\tint n; cin >> n;\n\twhile (n--)\n\t{\n\t\tcin >> h >> w;\n\t\tfld.clear();\n\t\tfld.resize(h);\n\t\tREP(i, h) cin >> fld[i];\n\t\tbool update = true;\n\t\tbool f = false;\n\t\twhile (update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\tif (isend())\n\t\t\t{\n\t\t\t\tf = true;\n\t\t\t}\n\t\t\tREP(i, 26)\n\t\t\t{\n\t\t\t\tchar c = 'A' + i;\n\t\t\t\tif (check(c)) update = true;\n\t\t\t}\n\t\t}\n\t\tputs(f ? \"SAFE\" : \"SUSPICIOUS\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n\nusing namespace std;\n\nint h,w;\nchar field[51][51];\nbool passed[2501];\n\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\nstruct nodeInfo{\n    int minx;\n    int miny;\n    int maxx;\n    int maxy;\n    char kind;\n};\n\nint minx,miny,maxx,maxy;\nmap<char,int> key;\nint node;\nvector<int> G[2501];\nbool isClosing=false;\nnodeInfo recInfo[51];\n\nvoid findRecSize (int y,int x,char kind){\n    for(int i = 0;i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(field[i][j]==kind){\n                miny=min(miny,i);\n                minx=min(minx,j);\n                maxy=max(maxy,i);\n                maxx=max(maxx,j);\n            }\n        }\n    }\n}\n\nvoid findClose(int s){\n    if(isClosing)\n        return;\n    if(passed[s]){\n        isClosing=true;\n        return;\n    }\n    passed[s]=true;\n    for(int i = 0; i < G[s].size(); i++)\n        findClose(G[s][i]);\n}\n\nint main(){\n    int n;\n    cin>>n;\n    while(n--){\n        for(int i = 0; i < 2501; i++)\n            G[i].clear();\n        node=0;\n        key.clear();\n        cin>>h>>w;\n        memset(passed,0,sizeof(passed));\n        for(int i = 0; i < h; i++)\n            for(int j = 0; j < w; j++)\n                cin>>field[i][j];\n        bool no=false;\n        // ·û`»è\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                char kind=field[i][j];\n                if(kind!='.'&&(key.find(kind)==key.end())){\n                    // nodeðV½Éo^·é\n                    key[kind]=node;\n                    node++;\n                    minx=miny=100;\n                    maxx=maxy=-1;\n                    findRecSize(i,j,kind);\n                    recInfo[node-1].maxx=maxx;\n                    recInfo[node-1].maxy=maxy;\n                    recInfo[node-1].minx=minx;\n                    recInfo[node-1].miny=miny;\n                    recInfo[node-1].kind=kind;             \n                    // ß½x,y»ê¼êÌÀWîñ©ç¾çê½l¦¤é·û`Ì`ÌTõðs¤\n                    for(int k = miny; k <= maxy; k++){\n                        for(int l = minx; l <= maxx; l++){\n                            // TõææÉ.ª¶Ýµ½êA·û`ÅÍÈ¢\n                            if(field[k][l]=='.'){\n                                no=true;\n                                break;\n                            }\n                        }\n                        if(no)\n                            break;\n                    }\n                }\n                if(no)\n                    break;\n            }\n            if(no)\n                break;\n        }\n        if(no){\n            cout<<\"SUSPICIOUS\"<<endl;\n            continue;\n        }\n\n        // dÈèÌ\n        // ãÌÙ¤©çºÌÙ¤ÖGbWð£é\n        for(int l = 0; l < node; l++){\n            int mnx=recInfo[l].minx;\n            int mxx=recInfo[l].maxx;\n            int mny=recInfo[l].miny;\n            int mxy=recInfo[l].maxy;\n            char kind=recInfo[l].kind;\n            for(int i = mny; i <= mxy; i++){\n                for(int j = mnx; j <= mxx; j++){\n                    if(field[i][j]!=kind){\n                        int from=key[field[i][j]];\n                        int to=key[kind];\n                        // Ü¾GbWª¢o^\n                        if(find(G[from].begin(),G[from].end(),to)==G[from].end())\n                            G[from].push_back(to);\n                    }\n                }\n            }\n        }\n        // ÂHª¶Ý·é©Tõ\n        isClosing=false;\n        for(int i = 0; i < node; i++){\n            memset(passed,0,sizeof(passed));\n            findClose(i);\n            if(isClosing)\n                break;\n        }\n        if(key.size()!=0&&(isClosing)){\n            cout<<\"SUSPICIOUS\"<<endl;\n            continue;\n        }\n        else\n            cout<<\"SAFE\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ppii pair<pair<int,int>,pair<int,int>>\nusing namespace std;\n\nint h,w;\nvector<string> s;\n\nppii removeRect(char c){\n\tint minx = 50;\n\tint miny = 50;\n\tint maxx = 0;\n\tint maxy = 0;\n\tint cnt = 0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[i][j]==c){\n\t\t\t\tminx = min(minx,j);\n\t\t\t\tmaxx = max(maxx,j);\n\t\t\t\tminy = min(miny,i);\n\t\t\t\tmaxy = max(maxy,i);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\t//cout << cnt << \" \" << maxx-minx << \" \" << maxy-miny << endl;\n\tif(cnt != (maxx-minx+1)*(maxy-miny+1))return make_pair(make_pair(0,0),make_pair(0,0));\n\tfor(int i=miny;i<=maxy;i++){\n\t\tfor(int j=minx;j<=maxx;j++){\n\t\t\ts[i][j] = '.';\n\t\t}\n\t}\n\treturn make_pair(make_pair(minx,miny),make_pair(maxx,maxy));\n}\n\nvoid fillRect(char c,ppii p){\n\tint minx = 50;\n\tint miny = 50;\n\tint maxx = 0;\n\tint maxy = 0;\n\tint cnt = 0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[i][j]==c){\n\t\t\t\tminx = min(minx,j);\n\t\t\t\tmaxx = max(maxx,j);\n\t\t\t\tminy = min(miny,i);\n\t\t\t\tmaxy = max(maxy,i);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=miny;i<=maxy;i++){\n\t\tfor(int j=minx;j<=maxx;j++){\n\t\t\tif(p.first.first <= j && j<= p.second.first && p.first.second <= i && i <= p.second.second){\n\t\t\t\tif(s[i][j] == '.') s[i][j] = c;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool isEmpty(){\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[i][j] != '.') return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid show(){\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcout << s[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\ts.clear();\n\t\tcin >> h >> w;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\ts.emplace_back(str);\n\t\t}\n\t\tint cnt=0;\n\t\twhile(!isEmpty() && cnt<=25){\n\t\t\tchar c;\n\t\t\tfor(c='A';c<='Z';c++){\n\t\t\t\t//cout << c << endl;\n\t\t\t\tppii p = removeRect(c);\n\t\t\t\tfor(int c2 = 'A';c2<='Z';c2++){\n\t\t\t\t\tfillRect(c2,p);\n\t\t\t\t}\n\t\t\t\t//show();\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t\tif(isEmpty()){\n\t\t\tcout << \"SAFE\" << endl;\n\t\t} else {\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define MAX_H 50\n#define MAX_W 50\n\nconst int MAX_MATERIAL = 26; // A-Z\n\nstruct xy {\n    int ax, bx, ay, by;\n};\n\nchar box[MAX_H][MAX_W];\n\nbool check_rect(const vector<xy>& rect) {\n    REP(i, rect.size()) {\n        auto r = rect[i];\n        FOR(y, r.ay, r.by+1) FOR(x, r.ax, r.bx+1) {\n            if (box[y][x] == '.') {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nbool update_top_rect(const xy& r, char c) {\n    FOR(y, r.ay, r.by+1) FOR(x, r.ax, r.bx+1) {\n        if (box[y][x] != c && box[y][x] != '#') {\n            return false;\n        }\n    }\n    FOR(y, r.ay, r.by+1) FOR(x, r.ax, r.bx+1) {\n        box[y][x] = '#';\n    }\n    return true;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    REP(i, n) {\n        int h, w;\n        cin >> h >> w;\n        fill_n((char *)box, MAX_H*MAX_W, '.');\n\n        vb seen(MAX_MATERIAL, false);\n        vector<xy> rect(MAX_MATERIAL, {MAX_W, 0, MAX_H, 0});\n\n        REP(y, h) REP (x, w) {\n            cin >> box[y][x];\n            // ????????¢?????????????±???????\n            if (box[y][x] != '.') {\n                int idx = box[y][x] - 'A';\n                seen[idx] = true;\n                rect[idx].ax = min(rect[idx].ax, x);\n                rect[idx].bx = max(rect[idx].bx, x);\n                rect[idx].ay = min(rect[idx].ay, y);\n                rect[idx].by = max(rect[idx].by, y);\n            }\n        }\n\n        // ????????¢???????????????'.'????????£??????????????????\n        if (!check_rect(rect)) {\n            cout << \"SUSPICIOUS\" << endl;\n            continue;\n        }\n\n        bool updated;\n        do {\n            updated = false;\n            REP(i, rect.size()) {\n                auto r = rect[i];\n                // '#'????????????????????????\n                if (seen[i] && update_top_rect(r, i + 'A')) {\n                    seen[i] = false;\n                    updated = true;\n                }\n            }\n        } while (updated);\n        cout << (find(ALL(seen), true) != seen.end() ? \"SUSPICIOUS\" : \"SAFE\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\n#include <vector>\nusing namespace std;\n\ntypedef pair<char,char> P;\n\nint main(){\n\tint t;\n\tcin >> t;\n\tfor(int a = 0;a < t;a++){\n\t\tint h,w;\n\t\tmap<char,int> xmin,xmax,ymin,ymax,in;\n\t\tmap<char,bool> used;\n\t\tmap<char,vector<int> > G;\n\t\tmap<P,bool> already;\n\t\tstring field[50];\n\t\tcin >> h >> w;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tcin >> field[i];\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(field[i][j] != '.'){\n\t\t\t\t\tif(xmin.find(field[i][j]) == xmin.end()){\n\t\t\t\t\t\txmin[field[i][j]] = i;\n\t\t\t\t\t\txmax[field[i][j]] = i;\n\t\t\t\t\t\tymin[field[i][j]] = j;\n\t\t\t\t\t\tymax[field[i][j]] = j;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\txmin[field[i][j]] = min(i,xmin[field[i][j]]);\n\t\t\t\t\t\txmax[field[i][j]] = max(i,xmax[field[i][j]]);\n\t\t\t\t\t\tymin[field[i][j]] = min(j,ymin[field[i][j]]);\n\t\t\t\t\t\tymax[field[i][j]] = max(j,ymax[field[i][j]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag = true;\n\t\tfor(auto it = xmin.begin();it != xmin.end();it++) {\n\t\t\tin[it->first] = 0;\n\t\t\tused[it->first] = false;\n\t\t}\n\t\tfor(auto it = xmin.begin();it != xmin.end();it++){\n\t\t\tchar c = it->first;\n\t\t\tfor(int i = xmin[c];i <= xmax[c];i++){\n\t\t\t\tfor(int j = ymin[c];j <= ymax[c];j++){\n\t\t\t\t\tif(field[i][j] == '.') flag = false;\n\t\t\t\t\telse if(field[i][j] != c && !already[P(c,field[i][j])]){\n\t\t\t\t\t\tG[c].push_back(field[i][j]);\n\t\t\t\t\t\tin[field[i][j]]++;\n\t\t\t\t\t\talready[P(c,field[i][j])] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<char> que;\n\t\tfor(auto it = in.begin();it != in.end();it++){\n\t\t\tif(it->second == 0) que.push(it->first);\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tchar v = que.front();que.pop();\n\t\t\tused[v] = true;\n\t\t\tfor(int i = 0;i < G[v].size();i++){\n\t\t\t\tchar to = G[v][i];\n\t\t\t\tin[to]--;\n\t\t\t\tif(!in[to]){\n\t\t\t\t\tque.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(auto it = used.begin();it != used.end();it++){\n\t\t\tif(!it->second) flag = false;\n\t\t}\n\t\tif(flag) cout << \"SAFE\" << endl;\n\t\telse cout << \"SUSPICIOUS\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <cstdio>\n#include <ctime>\n#include <assert.h>\n#include <chrono>\n#include <random>\n#include <numeric>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long ull;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n    return (ull)rng() % B;\n}\n\nchar c[55][55];\nchar s[55][55];\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tint q; cin >> q;\n\twhile(q--){\n\t\tint h,w; cin >> h >> w;\n\t\tvector<char> v;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin >> c[i][j];\n\t\t\t\tif(c[i][j]!='.')v.push_back(c[i][j]);\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tv.erase(unique(v.begin(), v.end()),v.end());\n\t\tint k=v.size();\n\t\tmap<char,int> l,r,u,d;\n\t\tfor(int i=0;i<k;i++){\n\t\t\tl[v[i]]=1e9;\n\t\t\tu[v[i]]=1e9;\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tfor(int p=0;p<k;p++){\n\t\t\t\t\tif(c[i][j]==v[p]){\n\t\t\t\t\t\tl[v[p]]=min(l[v[p]],j);\n\t\t\t\t\t\tr[v[p]]=max(r[v[p]],j);\n\t\t\t\t\t\tu[v[p]]=min(u[v[p]],i);\n\t\t\t\t\t\td[v[p]]=max(d[v[p]],i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok=0;\n\t\tdo{\n\t\t\tif(ok)break;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\ts[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int p=0;p<k;p++){\n\t\t\t\tfor(int i=u[v[p]];i<=d[v[p]];i++){\n\t\t\t\t\tfor(int j=l[v[p]];j<=r[v[p]];j++){\n\t\t\t\t\t\ts[i][j]=v[p];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool check=1;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(c[i][j]!=s[i][j])check=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(check)ok=1;\n\t\t}while(next_permutation(v.begin(), v.end()));\n\t\tif(ok)printf(\"SAFE\\n\");\n\t\telse printf(\"SUSPICIOUS\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <map>\n#include <algorithm>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nstruct rect { int ly, ry, lx, rx; };\n\nint T, H, W;\nchar S[55][55];\n\nint main(void) {\n  cin >> T;\n  while(T--) {\n    cin >> H >> W;\n    REP(i, 0, H) cin >> S[i];\n\n    set<char> st;\n    REP(i, 0, H) REP(j, 0, W) if(S[i][j] != '.') st.insert(S[i][j]);\n    map<char, int> ctoi;\n    int t = 0;\n    for(char i : st) ctoi[i] = t++;\n\n    int a[10];\n    REP(i, 0, 10) a[i] = i;\n\n    map<char, rect> p;\n    REP(i, 0, H) REP(j, 0, W) if(S[i][j] != '.') p[S[i][j]] = (rect) { i, i, j, j };\n    REP(i, 0, H) REP(j, 0, W) {\n      if(S[i][j] != '.') {\n        p[S[i][j]].ly = min(p[S[i][j]].ly, i);\n        p[S[i][j]].ry = max(p[S[i][j]].ry, i);\n        p[S[i][j]].lx = min(p[S[i][j]].lx, j);\n        p[S[i][j]].rx = max(p[S[i][j]].rx, j);\n      }\n    }\n\n    bool ans = false;\n    do {\n      bool f = true;\n      for(auto r : p) {\n        char c = r.first;\n        rect q = r.second;\n        REP(i, q.ly, q.ry + 1) REP(j, q.lx, q.rx + 1) {\n          if(S[i][j] == '.' || a[ctoi[c]] < a[ctoi[S[i][j]]]) {\n            f = false;\n            goto END;\n          }\n        }\n      }\nEND:\n      ans = ans || f;\n      if(ans) break;\n    } while(next_permutation(a, a + (int) st.size()));\n    cout << (ans ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        char board[60][60];\n        int num[30] = {0};\n        int h, w;\n        cin >> h >> w;\n        for (int j = 0; j < h; ++j) {\n            scanf(\"%s\", board[j]);\n            for (int k = 0; k < w; ++k) {\n                ++num[board[j][k] - 'A'];\n            }\n        }\n        bool flag = true;\n\n        while (flag) {\n            flag = false;\n        for (int j = 0; j < 30; ++j) {\n            if (!num[j])\n                continue;\n            \n            int up = 100, dw = -1, lf = 100, ri = -1;\n            for (int k = 0; k < h; ++k) {\n                for (int l = 0; l < w; ++l) {\n                    if (board[k][l] == j + 'A') {\n                        lf = min(lf, l);\n                        dw = max(dw, k);\n                        up = min(up, k);\n                        ri = max(ri, l);\n                    }\n                }\n            }\n            for (int k = up; k <= dw; ++k) {\n                for (int l = lf; l <= ri; ++l) {\n                    if (board[k][l] != j + 'A' && board[k][l] != '#') {\n                        goto A;\n                    }\n                }\n            }\n            for (int k = up; k <= dw; ++k) {\n                for (int l = lf; l <= ri; ++l) {\n                    if (board[k][l] == j + 'A') {\n                        board[k][l] = '#';\n                        --num[j];\n                        flag = true;\n                    }\n                }\n            }\n            \n        A:\n            continue;\n\n        }\n        }\n        for (int j = 0; j < h; ++j) {\n            for (int k = 0; k < w; ++k) {\n                if (board[j][k] != '.' && board[j][k] != '#'){\n                    printf(\"SUSPICIOUS\\n\");\n                    goto B;\n                }\n            }\n        }\n        printf(\"SAFE\\n\");\n    B:\n        continue;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define\tpb\t\t\tpush_back\n#define\trep(i,n)\tfor(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef\tvector<int>\tvi;\n\nstruct Rect{\n\tint l,r,t,b;\n};\n\nint main(){\n\tint t;\tscanf(\"%d\",&t);\n\twhile(t--){\n\t\tint h,w;\tscanf(\"%d%d\",&h,&w);\n\t\tstatic char bag[50][51];\n\t\trep(i,h)\tscanf(\"%s\",bag[i]);\n\n\t\tint n=0;\t// number of goods\n\t\tvector<char> goods;\n\t\tint ginv[128];\n\t\trep(i,128)\tginv[i]=-1;\n\t\trep(i,h)rep(j,w){\n\t\t\tchar c=bag[i][j];\n\t\t\tif(c!='.' && ginv[c]==-1){\n\t\t\t\tgoods.pb(c);\n\t\t\t\tginv[c]=n++;\n\t\t\t}\n\t\t}\n\n\t\tRect rc[7];\n\t\trep(i,n){\n\t\t\trc[i].l=rc[i].t=100;\n\t\t\trc[i].r=rc[i].b=0;\n\t\t}\n\t\trep(i,h)rep(j,w){\n\t\t\tchar c=bag[i][j];\n\t\t\tint id=ginv[c];\n\t\t\tif(c!='.'){\n\t\t\t\trc[id].l=min(rc[id].l,j);\n\t\t\t\trc[id].r=max(rc[id].r,j);\n\t\t\t\trc[id].t=min(rc[id].t,i);\n\t\t\t\trc[id].b=max(rc[id].b,i);\n\t\t\t}\n\t\t}\n\n\t\tbool safe=false,badshape=false;\n\t\tvi ongoods[7];\n\t\trep(k,n){\n\t\t\tfor(int i=rc[k].t;i<=rc[k].b;i++)for(int j=rc[k].l;j<=rc[k].r;j++){\n\t\t\t\tchar c=bag[i][j];\n\t\t\t\tif(c=='.'){ badshape=true; goto BADSHAPE; }\n\t\t\t\tif(c!=goods[k])\tongoods[k].pb(ginv[c]);\n\t\t\t}\n\t\t\tsort(ongoods[k].begin(),ongoods[k].end());\n\t\t\tongoods[k].erase(unique(ongoods[k].begin(),ongoods[k].end()),ongoods[k].end()\t);\n\t\t}\n\t\tBADSHAPE:\n\n\t\tif(!badshape){\n\t\t\tint ord[]={0,1,2,3,4,5,6};\n\t\t\tdo{\n\t\t\t\tbool ok=true;\n\t\t\t\trep(i,n){\n\t\t\t\t\trep(j,ongoods[i].size()){\n\t\t\t\t\t\tint front,back;\n\t\t\t\t\t\trep(k,n){\n\t\t\t\t\t\t\tif(ord[k]==i)\t\t\t\tback=k;\n\t\t\t\t\t\t\tif(ord[k]==ongoods[i][j])\tfront=k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(front>back){ ok=false; goto BADORDER; }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tBADORDER:\n\t\t\t\tif(ok){ safe=true; break; }\n\t\t\t}while(next_permutation(ord,ord+n));\n\t\t}\n\n\t\tputs(safe?\"SAFE\":\"SUSPICIOUS\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n\ntypedef long long ll;\n\n\nint cnt[30][55][55];\nint cnt2[30][55][55];\nint val[30];\n\nint getcnt(int a,int b,int c,int d,int e,int cnt[30][55][55]){\n\tint ret = cnt[e][c][d];\n\tif(c) ret-=cnt[e][a-1][d];\n\tif(d) ret-=cnt[e][c][b-1];\n\tif(c&&d) ret+=cnt[e][a-1][b-1];\n\treturn ret;\n}\n\n\nint main(){\n\tint n;\n\tcin>>n;\n\trep(o,n){\n\t\tint h,w;\n\t\tcin>>h>>w;\n\t\tvector<string> v(h);\n\t\trep(i,h) cin>>v[i];\n\t\tbool update = true;\n\t\tbool ok=true;\n\t\tint ch[30];\n\t\twhile(update){\n\t\t\tok=true;\n\t\t\tupdate=false;\n\t\t\trep(i,h) rep(j,w) if(v[i][j]!='.'&&v[i][j]!='-') ok=false;\n\t\t\tif(ok){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i,30) rep(j,55) rep(k,55) cnt[i][j][k]=cnt2[i][j][k]=0;\n\t\t\trep(i,30){\n\t\t\t\tch[i]=0;\n\t\t\t\trep(j,h){\n\t\t\t\t\trep(k,w){\n\t\t\t\t\t\tif(v[j][k]==char('A'+i)||v[j][k]=='-'){\n\t\t\t\t\t\t\tcnt[i][j][k]=1;\n\t\t\t\t\t\t\tif(v[j][k]==char('A'+i)){\n\t\t\t\t\t\t\t\tch[i]++;\n\t\t\t\t\t\t\t\tcnt2[i][j][k]=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j) cnt[i][j][k]+=cnt[i][j-1][k];\n\t\t\t\t\t\tif(k) cnt[i][j][k]+=cnt[i][j][k-1];\n\t\t\t\t\t\tif(j&&k) cnt[i][j][k]-=cnt[i][j-1][k-1];\n\n\t\t\t\t\t\tif(j) cnt2[i][j][k]+=cnt2[i][j-1][k];\n\t\t\t\t\t\tif(k) cnt2[i][j][k]+=cnt2[i][j][k-1];\n\t\t\t\t\t\tif(j&&k) cnt2[i][j][k]-=cnt2[i][j-1][k-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// rep(i,h){\n\t\t\t// \tcout<<v[i]<<endl;\n\t\t\t// }\n\t\t\t// cout<<endl;\n\t\t\trep(i,30){\n\t\t\t\tif(!ch[i]) continue;\n\t\t\t\trep(y1,h){\n\t\t\t\t\trep(x1,w){\n\t\t\t\t\t\treep(y2,y1,h){\n\t\t\t\t\t\t\treep(x2,x1,w){\n\t\t\t\t\t\t\t\tif(getcnt(y1,x1,y2,x2,i,cnt2)==ch[i]&&getcnt(y1,x1,y2,x2,i,cnt)==(y2-y1+1)*(x2-x1+1)){\n\t\t\t\t\t\t\t\t\t// cout<<\"AAA\"<<endl;\n\t\t\t\t\t\t\t\t\t// cout<<y1<<\" \"<<x1<<\" \"<<y2<<\" \"<<x2<<\" \"<<char(i+'A')<<\" \"<<getcnt(y1,x1,y2,x2,i)<<endl;\n\t\t\t\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t\t\t\t\treep(j,y1,y2+1){\n\t\t\t\t\t\t\t\t\t\treep(k,x1,x2+1){\n\t\t\t\t\t\t\t\t\t\t\tv[j][k]='-';\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// goto end;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t// end:\n\t\t\t// update=update;\n\t\t\t}\n\t\t}\n\t\tif(ok) cout<<\"SAFE\"<<endl;\n\t\telse cout<<\"SUSPICIOUS\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int MAX_S = 51;\nconst int dx[4] = {1,0,-1,0};\nconst int dy[4] = {0,1,0,-1};\nint H, W;\nchar G[MAX_S][MAX_S];\nbool vis[MAX_S][MAX_S];\n\npair<P, P> rec(int x, int y, char c) {\n  vis[y][x] = true;\n  pair<P, P> p = make_pair(P(x, y), P(x, y));\n  for(int i = 0; i < 4; ++i) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(nx < 0 || nx >= W) continue;\n    if(ny < 0 || ny >= H) continue;\n    if(vis[ny][nx]) continue;\n    if(G[ny][nx] != c) continue;\n    pair<P, P> q = rec(nx, ny, c);\n    p.first.first = min(p.first.first, q.first.first);\n    p.first.second = min(p.first.second, q.first.second);\n    p.second.first = max(p.second.first, q.second.first);\n    p.second.second = max(p.second.second, q.second.second);\n  }\n  return p;\n}\n\nbool isShikaku(int sx, int sy, int ex, int ey, char c) {\n  for(int i = sy; i <= ey; ++i) {\n    for(int j = sx; j <= ex; ++j) {\n      if(G[i][j] != c && G[i][j] != '#') return false;\n    }\n  }\n  return true;\n}\n\nvoid fills(int sx, int sy, int ex, int ey) {\n  for(int i = sy; i <= ey; ++i) {\n    for(int j = sx; j <= ex; ++j) {\n      G[i][j] = '#';\n    }\n  }\n}\n\nbool notW(int sx, int sy, int ex, int ey) {\n  for(int i = sy; i <= ey; ++i) {\n    for(int j = sx; j <= ex; ++j) {\n      if(G[i][j] == '.') return false;\n    }\n  }\n  return true;\n}\n\nvoid show() {\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      cout << G[i][j];\n    }\n    cout << endl;\n  }\n}\n\nbool judge() {\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if(G[i][j] != '.' && G[i][j] != '#') return false;\n    }\n  }\n  return true;\n}\n\nbool ans() {\n  pair<P, P> p;\n  while(true) {\n    //if(H == 16) show();\n    for(int i = 0; i < H; ++i) {\n      fill(vis[i], vis[i]+W, false);\n    }\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tif(!vis[i][j] && G[i][j] != '.' && G[i][j] != '#') {\n\t  p = rec(j, i, G[i][j]);\n\t  if(isShikaku(p.first.first, p.first.second,\n\t\t       p.second.first, p.second.second, G[i][j])) {\n\t    fills(p.first.first, p.first.second,\n\t\t  p.second.first, p.second.second);\n\t    i = j = MAX_S*2;\n\t  }\n\t}\n      }\n      if(i+1 == H) {\n\treturn judge();\n      }\n    }\n  }\n}\n\n\nint main() {\n  int T;\n  cin >> T;\n  while(T--) {\n    cin >> H >> W;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tcin >> G[i][j];\n      }\n    }\n    if(ans()) cout << \"SAFE\" << endl;\n    else cout << \"SUSPICIOUS\" << endl;\n    //show();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int AtoZ = 'Z'-'A'+1;\nstruct limbox{\n    int u,d,l,r;\n    limbox():u(100),d(-1),l(100),r(-1){}\n};\n\nvector<vector<bool> > o;\nvector<bool> s;\nvector<bool> c;\n\nbool check(int k){\n    if(s[k]) return true;\n    if(c[k]) return false;\n    c[k] = true;\n    for(int i=0; i<AtoZ; i++){\n        if(o[k][i] && !check(i)){\n            return false;\n        }\n    }\n    c[k] = false;\n    s[k] = true;\n    return true;\n}\n            \n\nint main(){\n    int n;\n    cin >> n;\n    \n    for(int rep=0; rep<n; rep++){\n        int h,w;\n        cin >> h >> w;\n        vector<vector<char> > mat(h, vector<char>(w));\n        vector<limbox> dom(AtoZ);\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                cin >> mat[i][j];\n                if(mat[i][j]!='.'){\n                    int c = mat[i][j] - 'A';\n                    dom[c].u = min(dom[c].u, i);\n                    dom[c].d = max(dom[c].d, i);\n                    dom[c].l = min(dom[c].l, j);\n                    dom[c].r = max(dom[c].r, j);\n                }\n            }\n        }\n\n        vector<vector<bool> > ovl(AtoZ, vector<bool>(AtoZ, false));\n        vector<bool> safe(AtoZ, true);\n        bool suspicious = false;\n        for(int k=0; k<AtoZ; k++){\n            for(int i=dom[k].u; i<=dom[k].d; i++){\n                for(int j=dom[k].l; j<=dom[k].r; j++){\n                    if(mat[i][j]=='.'){\n                        suspicious = true;\n                        safe[k] = false;\n                    }else if(mat[i][j] != 'A'+k){\n                        ovl[k][mat[i][j]-'A'] = true;\n                        safe[k] = false;\n                    }\n                }\n            }\n        }\n        if(suspicious){\n            cout << \"SUSPICIOUS\" << endl;\n            continue;\n        }\n\n        vector<bool> checking(AtoZ, false);\n        o = ovl;\n        s = safe;\n        c = checking;\n        for(int i=0; i<AtoZ; i++){\n            if(!check(i)){\n                suspicious = true;\n            }\n        }\n        if(!suspicious){\n            cout << \"SAFE\" << endl;\n        }else{\n            cout << \"SUSPICIOUS\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <map>\n#include <algorithm>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nstruct rect { int ly, ry, lx, rx; };\n\nint T, H, W;\nchar S[55][55];\n\nint main(void) {\n  cin >> T;\n  while(T--) {\n    cin >> H >> W;\n    REP(i, 0, H) cin >> S[i];\n\n    set<char> st;\n    REP(i, 0, H) REP(j, 0, W) if(S[i][j] != '.') st.insert(S[i][j]);\n    map<char, int> ctoi;\n    for(char i : st) ctoi[i] = ctoi.size();\n\n    int a[7];\n    REP(i, 0, 7) a[i] = i;\n\n    int ans = false;\n    do {\n      map<char, rect> p;\n      REP(i, 0, H) REP(j, 0, W) if(S[i][j] != '.') p[S[i][j]] = (rect) { i, i, j, j };\n\n      REP(i, 0, H) REP(j, 0, W) {\n        if(S[i][j] != '.') {\n          p[S[i][j]].ly = min(p[S[i][j]].ly, i);\n          p[S[i][j]].ry = max(p[S[i][j]].ry, i);\n          p[S[i][j]].lx = min(p[S[i][j]].lx, j);\n          p[S[i][j]].rx = max(p[S[i][j]].rx, j);\n        }\n      }\n\n      bool f = true;\n      for(pair<char, rect> r : p) {\n        char c = r.first;\n        rect q = r.second;\n        REP(i, q.ly, q.ry + 1) REP(j, q.lx, q.rx + 1) {\n          if(S[i][j] == '.' || a[ctoi[c]] < a[ctoi[S[i][j]]]) {\n            f = false;\n            goto END;\n          }\n        }\nEND:;\n      }\n      ans = ans || f;\n      if(ans) break;\n    } while(next_permutation(a, a + st.size()));\n\n    cout << (ans ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n# define REP(i,n) for(int i=0; i<n;i++)\n\nusing namespace std;\n\nint h, w, n, d;\n\nbool check(vector<vector<int> >result, vector<int> p, int t){\n\tREP(i,n){\n\t\tif (t==2){\n\t\t\t/*/\n\t\t\tcout << endl << \"(\";\n\t\t\tREP(l,n) cout << p[l] << \",\";\n\t\t\tcout << \")\" << endl;\n\t\t\tREP(j,h){\n\t\t\t\tREP(k,w) printf(\"%02d \", result[j][k]);\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\t/*/\n\t\t}\n\t\tint maxj, maxk, minj, mink;\n\t\tmaxj = -1; maxk = -1; minj = h; mink = w;\n\t\tREP(j,h){\n\t\t\tREP(k,w){\n\t\t\t\tif (result[j][k]==p[i]){\n\t\t\t\t\tif (j>maxj) maxj = j;\n\t\t\t\t\tif (k>maxk) maxk = k;\n\t\t\t\t\tif (j<minj) minj = j;\n\t\t\t\t\tif (k<mink) mink = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//if (t==2) printf(\"p[i]=%d max:%d,%d min:%d,%d\\n\", p[i], maxj, maxk, minj, mink);\n\t\tfor (int j=minj; j<=maxj; j++){\n\t\t\tfor (int k=mink; k<=maxk; k++){\n\t\t\t\tif (result[j][k]<0){\n\t\t\t\t\treturn false;\n\t\t\t\t}else if (result[j][k]==p[i]){\n\t\t\t\t\tresult[j][k] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint solve(int t){\n\t//int d;\n\t//cin >> d;\n\t\n\t//REP(t,d){\n\t\tbool materials[27];\n\t\tstring input;\n\t\tchar letter;\n\t\tvector<int> p;\n\t\t\n\t\tcin >> h >> w;\n\t\tn = 0;\n\t\tREP(i,26) materials[i] = false;\n\t\t\n\t\tvector<vector<int> > result(h);\n\t\t\n\t\tREP(j,h){\n\t\t\tcin >> input;\n\t\t\tREP(k,w){\n\t\t\t\tletter = (int)input[k]-65;\n\t\t\t\tif (letter>=0){\n\t\t\t\t\tresult[j].push_back(letter);\n\t\t\t\t\tif (!materials[letter]){\n\t\t\t\t\t\tn++;\n\t\t\t\t\t\tp.push_back(letter);\n\t\t\t\t\t\tmaterials[letter] = true;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tresult[j].push_back(-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\tsort(p.begin(), p.end() );\n\t\t//REP(i,n) cout << p[i] << \" \";\n\t\t//cout << p.size();\n\t\t//cout << endl;\n\t\t\n\t\tdo{\n\t\t\tif (check(result, p, t)){\n\t\t\t\t//REP(i,n) cout << p[i] << \" \";\n\t\t\t\t//cout << endl;\n\t\t\t\tcout << \"SAFE\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} while(next_permutation(p.begin(), p.end() ) );\n\t\t\n\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t//}\n\treturn 0;\n\t\n}\n\nint main(){\n\tint d;\n\tcin >> d;\n\tREP(t,d) solve(t);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint h, w;\nchar field[50][50];\n\nstruct obj {\n  char pack;\n  vector<char> back;\n  int ux, uy, dx, dy;\n  bool is_visit;\n  obj(char pack, vector<char> back, int ux, int uy, int dx, int dy):\n  pack(pack), back(back), ux(ux), uy(uy), dx(dx), dy(dy){}\n  obj() {}\n};\n\nmap<char, obj> m;\n\nbool no_loop(char c)\n{\n  //printf(\"%c\\n\", c);\n  if (m[c].is_visit) {\n    return false;\n  }\n  m[c].is_visit = true;\n    \n  for (int i = 0; i < m[c].back.size(); i++) {\n    if (!no_loop(m[c].back[i])) {return false;}\n  }\n  return true;\n}\n\nvoid solve()\n{\n  //printf(\"ok\\n\");\n    \n  bool is_exist = false;\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      //printf(\"%c\", field[i][j]);\n      if (isalpha(field[i][j])) {\n        int c = field[i][j];\n        m[c].ux = m[c].uy = 0;\n        m[c].dx = m[c].dy = 100;\n        m[c].pack = c;\n        is_exist = true;\n        for (int k = 0; k < h; k++) {\n          for (int l = 0; l < w; l++) {\n            if (field[k][l] == c) {\n              m[c].ux = max(l, m[c].ux);\n              m[c].uy = max(k, m[c].uy);\n              m[c].dx = min(l, m[c].dx);\n              m[c].dy = min(k, m[c].dy); \n            }\n          }\n        }\n        for (int k = m[c].dy; k <= m[c].uy; k++) {\n          for (int l = m[c].dx; k <= m[c].ux; k++) {\n            if (!isalpha(field[k][l])) {\n              printf(\"SUSPICIOUS\\n\");\n              return;\n            }\n          }        \n        }\n      }\n    }\n    //printf(\"\\n\");                        \n  }\n  if (!is_exist) {\n    printf(\"SAFE\\n\");\n    return;\n  }\n  //printf(\"ok\\n\");\n  \n  for (map<char, obj>::iterator it = m.begin(); it != m.end(); it++) {\n    //printf(\"pack:%c\\n\", it->second.pack);\n    it->second.is_visit = false;\n    bool is_pushed[26];\n    fill(is_pushed, &is_pushed[26], false);\n    for (int i = it->second.dy; i <= it->second.uy; i++) {\n      for (int j = it->second.dx; j <= it->second.ux; j++) {\n        if (field[i][j] != it->second.pack && !is_pushed[field[i][j] - 'A']) {\n          m[field[i][j]].back.push_back(it->second.pack);\n          is_pushed[field[i][j] - 'A'] = true;\n        }\n      }\n    }\n  }\n  \n  char start = m.begin()->second.pack;\n  if (no_loop(start)) {\n    printf(\"SAFE\\n\");\n    return;\n  } else {\n    printf(\"SUSPICIOUS\\n\");\n    return;\n  }\n}\n\nint main()\n{\n  int nInput;\n  scanf(\"%d \", &nInput);\n  \n  for (int input = 0; input < nInput; input++) {\n    m.clear();\n    scanf(\"%d %d \", &h, &w);\n    \n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        scanf(\"%c \", &field[i][j]);\n      }\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,n1,n2) for(int i=n1;i<n2;i++)\n#define bFOR(i,n1,n2) for(int i=n1;i>=n2;i--)\n#define speed_up    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\ntypedef long long int ll;\ntypedef pair<ll,ll> Pi;\nconst int INF=(ll)(1LL<<30)-1;\nconst double INFd=100000000000.0;\nconst ll INFl=(ll)9223372036854775807;\nconst int MAX=10000;\nconst ll MOD=(ll)1e9+7;\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a, b)*b;}\nint dx[4]={0,-1,0,1},dy[4]={-1,0,1,0};\nint ddx[6]={0,1,0,-1,1,-1},ddy[6]={-1,0,1,0,1,-1};\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\n\nint n;\nint h,w;\nchar xray[55][55];\nint t;\n\nint main(){\n\tcin>>t;\n\tfor(int qu=0;qu<t;qu++){\n\t\tcin>>h>>w;\n\t\tREP(i,h)\n\t\t\tREP(j,w)\n\t\t\tcin>>xray[i][j];\n\t\t\n\t\tfor(int i=0;i<7;i++){\n\t\t\tfor(char c='A';c<='Z';c++){\n\t\t\t\tint y1=-1,y2=-1,x1=100,x2=-1;\n\t\t\t\tREP(k,h){\n\t\t\t\t\tREP(l,w){\n\t\t\t\t\t\tif(xray[k][l]==c){\n\t\t\t\t\t\t\tif(y1==-1)y1=k;\n\t\t\t\t\t\t\ty2=k;\n\t\t\t\t\t\t\tx1=min(x1,l);\n\t\t\t\t\t\t\tx2=max(x2,l);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(y1==-1)continue;\n\t\t\t\tint flag=1;\n\t\t\t\tfor(int k=y1;k<y2+1;k++){\n\t\t\t\t\tfor(int l=x1;l<x2+1;l++){\n\t\t\t\t\t\tif(xray[k][l]!=c&&xray[k][l]!='0'){\n\t\t\t\t\t\t\tflag=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//if(c=='W')cout<<x1<<\" \"<<x2<<\" \"<<y1<<\" \"<<y2<<endl<<i<<endl;;\n\t\t\t\tif(flag){\n\t\t\t\t\tREP(k,h){\n\t\t\t\t\t\tREP(l,w){\n\t\t\t\t\t\t\tif(xray[k][l]==c){\n\t\t\t\t\t\t\t\txray[k][l]='0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=1;\n\t\tREP(i,h)\n\t\t\tREP(j,w)\n\t\t\t\tif(xray[i][j]!='.'&&xray[i][j]!='0')ans=0;\n\t\tif(ans)cout<<\"SAFE\"<<endl;\n\t\telse cout<<\"SUSPICIOUS\"<<endl;\n\t}\n\treturn 0;\n}\n\t\t\t\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n\nint Y,X;\n\nstruct Item{\n    int x1,x2,y1,y2;\n    set<pair<int,int>> st;\n    Item(){\n        x1 = y1 = +100;\n        x2 = y2 = -100;\n    }\n    void update(int x,int y){\n        x1 = min(x1,x);\n        x2 = max(x2,x);\n        y1 = min(y1,y);\n        y2 = max(y2,y);\n        st.insert({x,y});\n    }\n\n    bool isRectangle(){\n        return (x2-x1+1)*(y2-y1+1) == (int) st.size();\n    }\n    bool isin(int x,int y){\n        return x1<=x && x<=x2 && y1<=y && y<=y2;\n    }\n};\n\nint main(void){\n    int T;\n    cin>>T;\n    while(T--){\n        cin>>Y>>X;\n        vector<string> s(Y);\n        rep(y,Y) cin>>s[y];\n        vector<Item> items(26);\n        rep(y,Y)rep(x,X){\n            if(s[y][x] == '.') continue;\n            int a = s[y][x] - 'A';\n            items[a].update(x,y);\n        }\n        for(auto it=items.begin(); it!=items.end();){\n            if((int)it->st.size() == 0){\n                it = items.erase(it);\n            }else ++it;\n        }\n\n        size_t prev = 0;\n        while(prev != items.size()){\n            prev = items.size();\n            for(auto it=items.begin(); it!=items.end();){\n                if(it->isRectangle()){\n                    for(int x=it->x1; x<=it->x2; x++){\n                        for(int y=it->y1; y<=it->y2; y++){\n                            for(auto &back : items){\n                                if(back.isin(x,y)){\n                                    back.update(x,y);\n                                }\n                            }\n                        }\n                    }\n                    it = items.erase(it);\n                }else ++it;\n            }\n        }\n        cout<<(items.size() ? \"SUSPICIOUS\" : \"SAFE\")<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define reps(i,j,k) for(int i = j; i < k; ++i)\n#define rep(i,j) reps(i,0,j)\n#define PB push_back\n#define fr first\n#define sc second\ntypedef pair<int ,int> Pii;\nint main(){\n\tint N;\n\tscanf(\"%d\",&N);\n\twhile(N--){\n\t\tchar stage[52][52];\n\t\tint H,W;\n\t\tscanf(\"%d%d\",&H,&W);\n\t\tbool alpha_memo[128] = {false};\n\t\trep(i,H){\n\t\t\tscanf(\"%s\",stage[i]);\n\t\t\trep(j,W){\n\t\t\t\talpha_memo[stage[i][j]] = true;\n\t\t\t}\n\t\t}\n\t\tvector < char > letter;\n\t\treps(i,'A','Z'+1){\n\t\t\tif(alpha_memo[i]){\n\t\t\t\tletter.PB(i);\n\t\t\t}\n\t\t}\n\t\tbool ans = true;\n\t\trep(c,letter.size()){\n\t\t\tPii rect[4];\n\t\t\trep(j,W){\n\t\t\t\tbool f = false;\n\t\t\t\trep(i,H){\n\t\t\t\t\tif(stage[i][j] == letter[c]){\n\t\t\t\t\t\trect[0].fr = i;\n\t\t\t\t\t\trect[0].sc = j;\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f)break;\n\t\t\t}\n\t\t\trep(j,W){\n\t\t\t\tbool f = false;\n\t\t\t\tfor(int i = H-1; i >= 0; --i){\n\t\t\t\t\tif(stage[i][j] == letter[c]){\n\t\t\t\t\t\trect[1].fr = i;\n\t\t\t\t\t\trect[1].sc = j;\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f)break;\n\t\t\t}\n\t\t\tfor(int j = W-1; j >= 0; --j){\n\t\t\t\tbool f = false;\n\t\t\t\trep(i,H){\n\t\t\t\t\tif(stage[i][j] == letter[c]){\n\t\t\t\t\t\trect[2].fr = i;\n\t\t\t\t\t\trect[2].sc = j;\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f)break;\n\t\t\t}\n\t\t\tfor(int j = W-1; j >= 0; --j){\n\t\t\t\tbool f = false;\n\t\t\t\tfor(int i = H-1; i >= 0; --i){\n\t\t\t\t\tif(stage[i][j] == letter[c]){\n\t\t\t\t\t\trect[3].fr = i;\n\t\t\t\t\t\trect[3].sc = j;\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f)break;\n\t\t\t}\n\t\t\treps(i,min(rect[0].fr,rect[1].fr),max(rect[2].fr,rect[3].fr)+1){\n\t\t\t\tbool f = false;\n\t\t\t\treps(j,min(rect[0].sc,rect[1].sc),max(rect[2].sc,rect[3].sc)+1){\n\t\t\t\t\tif(stage[i][j] == '.'){\n\t\t\t\t\t\tans = false;\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f)break;\n\t\t\t}\n\t\t\tif(!ans){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tans ? puts(\"SAFE\") : puts(\"SUSPICIOUS\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(const T x, const S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nconst int MAX_H = 55;\nconst int MAX_W = 55;\nint H, W;\nchar s[MAX_H][MAX_W+1];\nint d[MAX_H][MAX_W+1];\nbool flag[10][10];\nint N;\n\ninline bool check(int hx, int hy){ return 0 <= hx && hx < H && 0 <= hy && hy < W; }\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) : src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n\n// ??????????????????????????????????????¨?????????order??????????????\\???\n// O(V+E)\nbool visit(const Graph& g, int v, vi& order, vi& color)\n{\n  color[v] = 1;\n  vrep(e, g[v]) {\n    if (color[e->dst] == 2) continue;\n    if (color[e->dst] == 1) return false;\n    if (!visit(g, e->dst, order, color)) return false;\n  }\n  order.push_back(v); color[v] = 2;\n  return true;\n}\n\nbool TopologicalSort(const Graph& g)\n{\n  int n = g.size();\n  vi color(n);\n  vi order;\n  rep(u, n) if (!color[u] && !visit(g, u, order, color)) return false;\n  return true;\n}\n\n\nint main()\n{\n  cin >> N;\n\n  while(N--){\n    cin >> H >> W;\n    rep(i, H) rep(j, W) cin >> s[i][j];\n\n\n    map<char, int> hm;\n    int cnt = 0;\n    vector<char> vec;\n    rep(i, H) rep(j, W) if(s[i][j] != '.' && !hm[s[i][j]]){\n      hm[s[i][j]] = cnt++;\n      vec.push_back(s[i][j]);\n    }\n\n    rep(i, cnt) rep(j, cnt) flag[i][j] = false;\n    Graph g(cnt);\n    bool ok = true;\n    rep(k, vec.size()){\n      int sx = INF, tx = 0;\n      int sy = INF, ty = 0;\n      rep(i, H) rep(j, W) if(s[i][j] == vec[k]){\n        sx = min(sx, i);  tx = max(tx, i);\n        sy = min(sy, j);  ty = max(ty, j);\n      }\n\n      erep(i, sx, tx) erep(j, sy, ty){\n        ok &= s[i][j] != '.';\n        if(s[i][j] != vec[k] && !flag[hm[s[i][j]]][hm[vec[k]]]){ // A < B ?????? A ??? B\n          flag[hm[s[i][j]]][hm[vec[k]]] = true;\n          g[hm[s[i][j]]].pb(Edge(hm[s[i][j]], hm[vec[k]], 1));\n        }\n      }\n      if(!ok) break;\n    }\n\n    puts(ok && TopologicalSort(g) ? \"SAFE\" : \"SUSPICIOUS\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int T;\n  cin >> T;\n  for (int t=0; t<T; t++) {\n    int h, w;\n    cin >> h >> w;\n    int table[60][60];\n    map<char, int> Map;\n    int N = 0;\n    // 荷物を0からN-1の数字に置き換える。-1は何もない。\n    for (int i=0; i<h; i++) {\n      for (int j=0; j<w; j++) {\n\tchar c;\n\tscanf(\" %c\", &c);\n\tint num = -2;\n\tif (c == '.') num = -1;\n\telse {\n\t  if (Map.find(c) == Map.end()) {\n\t    Map[c] = (num = N);\n\t    N++;\n\t  } else {\n\t    num = Map[c];\n\t  }\n\t}\n\tassert(num > -2);\n\ttable[i][j] = num;\n      }\n    }\n    // 各材料に対し、最小の長方形のラッパーを求める。\n    int maxx[10], minx[10], maxy[10], miny[10];\n    for (auto i=0; i<N; i++) {\n      maxx[i] = 0;\n      minx[i] = 100;\n      maxy[i] = 0;\n      miny[i] = 100;\n    }\n    for (int i=0; i<h; i++) {\n      for (int j=0; j<w; j++) {\n\tint tij = table[i][j];\n\tif (tij >= 0) {\n\t  maxx[tij] = max(maxx[tij], i);\n\t  minx[tij] = min(minx[tij], i);\n\t  maxy[tij] = max(maxy[tij], j);\n\t  miny[tij] = min(miny[tij], j);\n\t}\n      }\n    }\n    int J[10];\n    for (auto i=0; i<N; i++) {\n      J[i] = i;\n    }\n    do {\n      int tempt[60][60];\n      for (int i=0; i<h; i++) {\n\tfor (int j=0; j<w; j++) {\n\t  tempt[i][j] = table[i][j];\n\t}\n      }\n      for (int k=0; k<N; k++) {\n\t// 荷物J[k]は長方形でありうるか？\n\tfor (int i=minx[J[k]]; i<=maxx[J[k]]; i++) {\n\t  for (int j=miny[J[k]]; j<=maxy[J[k]]; j++) {\n\t    if (tempt[i][j] != J[k] && tempt[i][j] != 9) {\n\t      goto EXIT;\n\t    }\n\t  }\n\t}\n\t// J[k]を取り除く。\n\tfor (int i=minx[J[k]]; i<=maxx[J[k]]; i++) {\n\t  for (int j=miny[J[k]]; j<=maxy[J[k]]; j++) {\n\t    tempt[i][j] = 9;\n\t  }\n\t}\n      }\n      cout << \"SAFE\" << endl;\n      goto NEXT;\n    EXIT: continue;\n    } while(next_permutation(J, J+N));\n    cout << \"SUSPICIOUS\" << endl;\n  NEXT: continue;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 100000000;\n\nstruct Data{\n    int xa, xi, ya, yi;\n};\n\nint h, w;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nvoid dfs(char m[55][55], bool used[55][55], Data &d, int y, int x, char a){\n    d.xa = max(d.xa, x);\n    d.xi = min(d.xi, x);\n    d.ya = max(d.ya, y);\n    d.yi = min(d.yi, y);\n    used[y][x] = true;\n\n    rep(i,4){\n        int ny = y + dy[i];\n        int nx = x + dx[i];\n        if(y >= h || y < 0 || x >= w || x < 0) continue;\n        if(m[ny][nx] != a) continue;\n        if(used[ny][nx] == true) continue;\n        dfs(m,used,d,ny,nx,a);\n    }\n}\n\nbool isRect(char m[55][55], Data d, char a){\n    range(i,d.yi,d.ya + 1){\n        range(j,d.xi,d.xa + 1){\n            if(m[i][j] != a && m[i][j] != '@') return false;\n        }\n    }\n    return true;\n}\n\nbool check(char m[55][55]){\n    rep(i,h){\n        rep(j,w){\n            if(m[i][j] >= 'A' && m[i][j] <= 'Z') return false;\n        }\n    }\n    return true;\n}\n\nbool replace(char m[55][55], Data d){\n    //cout << d.yi << ' ' << d.ya << endl;\n    range(i,d.yi,d.ya + 1){\n        range(j,d.xi,d.xa + 1){\n            m[i][j] = '@';\n        }\n    }\n   //cout << endl; rep(i,h){ rep(j,w){ cout << m[i][j]; } cout << endl; }\n    return true;\n}\n\nint main(){\n    int t;\n    cin >> t;\n    while(t--){\n        cin >> h >> w;\n\n        char m[55][55];\n        rep(i,h) cin >> m[i];\n\n        while(true){\n            bool f = false;\n            bool used[55][55] = {0};\n            rep(i,h){\n                rep(j,w){\n                    if(m[i][j] != '.' && m[i][j] != '@' && used[i][j] == false){\n                        Data d = {-INF,INF,-INF,INF};\n                        //dfs(m,used,d,i,j,m[i][j]);\n                        rep(I,h){\n                            rep(J,w){\n                                if(m[I][J] == m[i][j]){\n                                    d.xa = max(d.xa, J);\n                                    d.xi = min(d.xi, J);\n                                    d.ya = max(d.ya, I);\n                                    d.yi = min(d.yi, I);\n                                }\n                            }\n                        }\n                        //cout << i << ' ' << j << endl;\n                        //cout << d.yi << ' ' << d.ya << endl;\n                        //cout << d.xi << ' ' << d.xa << endl;\n                        if(isRect(m,d,m[i][j])) f = replace(m,d);\n                    }\n                }\n            }\n            if(not f){\n                break;\n            }\n        }\n        cout << (check(m) ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nstruct make\n{\n\tchar str;\n\tint posi,start[2];\n\tint high,wide,JUDGE;//JUDGE==1で長方形,==0で長方形以外,==2で未定\n\tstruct make *front;\n};\n\n\nint main()\n{\n\tint N,H,W,count,COUNT,judge,no_rect,NO_RECT,RECT_C=0;\n\tchar img[1000][51],RECT[8];\n\tstruct make M[8];\n\tint s1,s2,num;\n\t\n\tscanf(\"%d\",&N);//データの個数\n\tfor(int a=0;a<N;a++)\n\t{\n\t\tcount=0;//材質の個数\n\t\tCOUNT=0;\n\t\tNO_RECT=0;\n\t\tRECT_C=0;\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tscanf(\"%s\",img[b]);\n\t\t\timg[b][W]='\\0';\n\t\t}\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tfor(int d=0;d<count;d++) M[d].posi=-1;\n\t\t\tfor(int c=0;c<W;c++)\n\t\t\t{\n\t\t\t\tif(img[b][c]!='.')\n\t\t\t\t{\n\t\t\t\t\t//材質判定\n\t\t\t\t\tjudge=0;\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t\tif(count>0 && img[b][c]!=M[judge].str) judge++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}while(judge<count);\n\t\t\t\t\t//新しい材質の場合\n\t\t\t\t\tif(judge==count)\n\t\t\t\t\t{\n\t\t\t\t\t\tM[count].str=img[b][c];\n\t\t\t\t\t\tM[count].start[0]=b;\n\t\t\t\t\t\tM[count].start[1]=c;\n\t\t\t\t\t\tM[count].posi=c;\n\t\t\t\t\t\tM[count].high=1;\n\t\t\t\t\t\tM[count].wide=1;\n\t\t\t\t\t\tM[count].JUDGE=0;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\t//既出の材質の場合\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(M[judge].start[1]>c) M[judge].start[1]=c;\n\t\t\t\t\t\tif(M[judge].posi<0) M[judge].posi=c;\n\t\t\t\t\t\telse if(M[judge].wide<c-M[judge].posi+1) M[judge].wide=c-M[judge].posi+1;\n\t\t\t\t\t\tM[judge].high=b-M[judge].start[0]+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tno_rect=count;\n\t\t//printf(\"count=%d\\n\",count);\n\t\t//判定開始\n\t\twhile(count)//文字アリ\n\t\t{\n\t\t\tint p;\n\t\t\t//p=getchar();\n\t\t\tCOUNT=0;\n\t\t\t//見えている部分が長方形かどうか判定\n\t\t\tfor(num=0;num<count;num++)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(M[num].JUDGE==1) continue;\n\t\t\t\tM[num].JUDGE=0;//長方形なら\n\t\t\t\t//printf(\"M[%d].str=%c\\nM[%d].high=%d\\nM[%d].wide=%d\\n\",num,M[num].str,num,M[num].high,num,M[num].wide);\n\t\t\t\t//printf(\"M[%d].start[0]=%d\\nM[%d].start[1]=%d\\n\",num,M[num].start[0],num,M[num].start[1]);\n\t\t\t\tfor(s1=0;s1<M[num].high;s1++)\n\t\t\t\t{\n\t\t\t\t\tfor(s2=0;s2<M[num].wide;s2++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//確実に長方形ではない場合\n\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]=='.')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNO_RECT=1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//長方形の可能性もある場合\n\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]!=M[num].str)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int r=0;r<RECT_C;)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//printf(\"RECT[%d]='%c'\\n\",r,RECT[r]);\n\t\t\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]==RECT[r]) break;\n\t\t\t\t\t\t\t\tr++;\n\t\t\t\t\t\t\t\tif(r==count-no_rect)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tM[num].JUDGE=2;\n\t\t\t\t\t\t\t\t\tCOUNT++;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(NO_RECT || M[num].JUDGE==2) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(NO_RECT || M[num].JUDGE==2) break;\n\t\t\t\t}\n\t\t\t\tif(NO_RECT) break;\n\t\t\t\t//長方形だった場合\n\t\t\t\tif(s1==M[num].high && s2==M[num].wide)\n\t\t\t\t{\n\t\t\t\t\tM[num].JUDGE=1;\n\t\t\t\t\tno_rect--;\n\t\t\t\t\tRECT[RECT_C]=M[num].str;\n\t\t\t\t\tRECT_C++;\n\t\t\t\t}\n\t\t\t\t//printf(\"M[%d].JUDGE=%d\\n\\n\",num,M[num].JUDGE);\n\t\t\t}\n\t\t\tfor(int n=0;n<num;)\n\t\t\t{\n\t\t\t\tif(M[num].JUDGE!=2) break;\n\t\t\t\tn++;\n\t\t\t\t//どれも長方形ではなかった場合\n\t\t\t\tif(n==num) NO_RECT=1;\n\t\t\t}\n\t\t\t\n\t\t\t//printf(\"NO_RECT=%d\\n\",NO_RECT);\n\t\t\tif(NO_RECT==1) break;\n\t\t\t//printf(\"#no_rect=%d\\n\\n\\n\",no_rect);\n\t\t\t//すべて長方形\n\t\t\tif(no_rect==0) break;\n\t\t}\n\t\t//出力\n\t\tif(NO_RECT) printf(\"SUSPICIOUS\\n\");\n\t\telse if(no_rect) printf(\"SUSPICIOUS\\n\");\n\t\telse printf(\"SAFE\\n\");\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass Belongings {\npublic:\n  Belongings() : left(100),right(0),upper(100),lower(0){}\n  int left,right,upper,lower;\n};\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    for(int stage_idx = 0; stage_idx < N; stage_idx++){\n      int H,W;\n      \n      scanf(\"%d %d\",&H,&W);\n      char stage[2500];\n      char hypothesis[2500];\n      memset(stage,'.',sizeof(stage));\n\n      map<char,Belongings> layer;\n\n      for(int y=0;y<H;y++){\n\tchar line[51];\n\tscanf(\"%s\",line);\n\tfor(int x=0;x<W;x++){\n\t  stage[y*W+x] = line[x];\n\t  if(line[x] == '.') continue;\n\t  //x:0->...\n\t  //y:0\n\t  //  |\n\t  //  v\n\t  //  .\n\t  //  upper\n\t  //left right\n\t  //  lower\n\t  Belongings& be = layer[stage[y*W+x]];\n\t  be.left = min(be.left,x);\n\t  be.right = max(be.right,x);\n\t  be.upper = min(be.upper,y);\n\t  be.lower = max(be.lower,y);\n\t}\n      }\n\n      bool is_safe = false;\n\n      vector<char> order;\n      for(map<char,Belongings>::iterator it = layer.begin();\n\t  it != layer.end();\n\t  it++){\n\torder.push_back(it->first);\n      }\n      sort(order.begin(),order.end());\n\n\n      do{\n\tmemset(hypothesis,'.',sizeof(hypothesis));\n\n\tfor(int i=0;i<order.size();i++){\n\t  char c = order[i];\n\t  Belongings& be = layer[c];\n\t  for(int y=be.upper; y<=be.lower; y++){\n\t    for(int x=be.left; x<=be.right; x++){\n\t      hypothesis[y*W+x] = c;\n\t    }\n\t  }\n\t}\n\n\tif(strcmp(hypothesis,stage) == 0){\n\t  is_safe = true;\n\t  break;\n\t}\n      }while(next_permutation(order.begin(),order.end()));\n      printf(\"%s\\n\",is_safe ? \"SAFE\" : \"SUSPICIOUS\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint N;\nvector<string> g;\nmap<char,bool> used;\nmap<char,int> x1,x2,y1,y2;\n\nint numbering(char c){\n\tif(used[c])return 0;\n\telse used[c] = true;\n\tint ans = 0;\n\tfor(int i=y1[c];i<=y2[c];i++){\n\t\tfor(int j=x1[c];j<=x2[c];j++){\n\t\t\tif(g[i][j] != '.')\n\t\t\t\tans = max(ans,numbering(g[i][j]));\n\t\t}\t\t\t\n\t}\n\treturn ans+1;\n}\n\nint main(){\n\tint T;\n\t\n\tcin >> T;\n\twhile(T--){\n\t\tint W,H;\n\t\tcin >> H >> W;\n\t\tvector<string> data(H);\n\t\tfor(int i=0;i<H;i++)\n\t\t\tcin >> data[i];\n\t\tg = data;\n\t\tx1.clear(),x2.clear(),y1.clear(),y2.clear();\n\t\t\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tchar c = data[i][j];\n\t\t\t\tif(c != '.'){\n\t\t\t\t\tif(x1.find(c) == x1.end())\n\t\t\t\t\t\tx1[c] = j;\n\t\t\t\t\telse \n\t\t\t\t\t\tx1[c] = min(j,x1[c]);\n\t\t\t\t\tx2[c] = max(j,x2[c]);\n\t\t\t\t\tif(y1.find(c) == y1.end())\n\t\t\t\t\t\ty1[c] = i;\n\t\t\t\t\telse \n\t\t\t\t\t\ty1[c] = min(i,y1[c]);\n\t\t\t\t\t\t\n\t\t\t\t\ty2[c] = max(i,y2[c]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<char> v;\n\t\tfor(map<char,int>::iterator it = x1.begin();it != x1.end();++it)\n\t\t\tv.push_back(it->first);\n\t\tbool safe = true;\n\t\tsort(v.begin(),v.end());\n\t\tmap<char,int> memo;\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tused.clear();\n\t\t\tmemo[v[i]] = numbering(v[i]);\n\t\t}\n\t\tfor(int k=0;k<v.size();k++){\n\t\t\tfor(int i=y1[v[k]];i<=y2[v[k]];i++){\n\t\t\t\tfor(int j=x1[v[k]];j<=x2[v[k]];j++){\n\t\t\t\t\tchar c = data[i][j];\n\t\t\t\t\tif(c == '.'){safe = false;}\n\t\t\t\t\tif(c != v[k] && memo[c] >= memo[v[k]]){\n\t\t\t\t\t\tsafe = false;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\n\t\t\t}\n\t\t}\n\n\t\tcout << (safe ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\n\nint main(int argc, char *argv[]){\n  int n, w, h;\n  pair<int, int> p[7][4];\n  cin >> n;\n  for (int r = 0; r < n; r++) {\n    map<char, int> matrial;\n    cin >> h >> w;\n\n    char grid[h][w];\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> grid[i][j];\n        if(grid[i][j] != '.' && matrial.find(grid[i][j]) == matrial.end()){\n          matrial[grid[i][j]] = matrial.size();\n        }\n      }\n    }\n\n    for (int i = 0; i < matrial.size(); i++) {\n      p[i][0].first = 1e9, p[i][0].second = 1e9;\n      p[i][1].first = 0,   p[i][1].second = 0;\n    }\n    vector<int> perm(matrial.size());\n    for (int i = 0; i < matrial.size(); i++) {\n      perm[i] = i;\n    }\n\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if(matrial.find(grid[i][j]) != matrial.end()){\n          int minx = p[matrial[grid[i][j]]][0].first;\n          int miny = p[matrial[grid[i][j]]][0].second;\n          int maxx = p[matrial[grid[i][j]]][1].first;\n          int maxy = p[matrial[grid[i][j]]][1].second;\n          p[matrial[grid[i][j]]][0].first  = min(minx, j);\n          p[matrial[grid[i][j]]][0].second = min(miny, i);\n          p[matrial[grid[i][j]]][1].first  = max(maxx, j);\n          p[matrial[grid[i][j]]][1].second = max(maxy, i);\n        }\n      }\n    }\n    // for (auto &a: matrial){\n    //   std::cout << a.first << \" \" << a.second << std::endl;\n    // }\n    // for (int i = 0; i < matrial.size(); i++) {\n    //   std::cout << \"min:\" << std::endl;\n    //   std::cout << p[i][0].first << \" \" << p[i][0].second << std::endl;\n    //   std::cout << \"max:\" << std::endl;\n    //   std::cout << p[i][1].first << \" \" << p[i][1].second << std::endl;\n    // }\n    // std::cout << matrial.size() << std::endl;\n    \n    bool flag = false;\n    do{\n      for (int i = 0; i < matrial.size(); i++) {\n        for (int j = p[i][0].second; j <= p[i][1].second; j++) {\n          for (int k = p[i][0].first; k <= p[i][1].first; k++) {\n            if(grid[j][k] != '.' && perm[matrial[grid[j][k]]] <= perm[i])continue;\n            i = 10;\n            j = p[i][1].second + 1;\n            k = p[i][1].first  + 1;\n          }\n        }\n        if(i == matrial.size() - 1){\n          flag = true;\n          //   for (auto &a: perm) {\n          //     std::cout << a << \" \";\n          //   }\n          //   std::cout << std::endl;\n        } \n      }\n    }while(next_permutation(perm.begin(), perm.end()));\n    if(flag || matrial.size() == 0){\n      std::cout << \"SAFE\" << std::endl;\n    }else{\n      std::cout << \"SUSPICIOUS\" << std::endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n    int h,w;\nvector<int> dp;\n\nbool dfs(vector<char> &ch,vector<string> &c,int s){\n  if(dp[s]!=-1) return dp[s];\n  if(s==(1<<ch.size())-1){\n    return true;\n  }\n  bool isok=false;\n  for(int col=0;col<ch.size();col++){\n    bool piyo=true;\n    if(s&(1<<col)) continue; \n    int l=100;\n    int r=0;\n    int u=100;\n    int b=0;      \n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(c[i][j]==ch[col]){\n\t  l=min(l,j);\n\t  r=max(r,j);\n\t  u=min(u,i);\n\t  b=max(b,i);\n\t}\n      } \n    }\n    b++,r++;\n    for(int i=u;i<b;i++){\n      for(int j=l;j<r;j++){\n\tif(c[i][j]=='.'||c[i][j]=='&'){\n\t  piyo=false;\n\t}\n\telse{\n\t  if(c[i][j]==ch[col]){\n\t    c[i][j]='&';\n\t  }\n\t}\t    \n      }\n    }\n    piyo&=dfs(ch,c,s+(1<<col));\n    for(int i=u;i<b;i++){\n      for(int j=l;j<r;j++){\n\tif(c[i][j]=='&') c[i][j]=ch[col];\n      }\n    }\n    isok|=piyo;\n  }\n  return dp[s]=isok;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  for(int loop=0;loop<n;loop++){\n    dp.clear();\n\n    cin>>h>>w;\n    vector<string> c(h);\n    for(auto &v:c) cin>>v;\n    set<char> s;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(c[i][j]!='.') s.insert(c[i][j]);\n      }\n    }\n\n    vector<char> ch(s.begin(),s.end());\n    dp.resize((1<<ch.size()),-1);\n    bool res=dfs(ch,c,0);\n      \n    cout<<(res ? \"SAFE\" : \"SUSPICIOUS\")<<endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <string>\n#include <map>\n#include <cmath>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    while(n--) {\n        int w, h;\n        cin >> h >> w;\n        vector<string> v(h);\n        for(int i=0; i<h; ++i) {\n            cin >> v[i];\n        }\n        map<char, int> L, R, T, B;\n        for(int i=0; i<h; ++i) {\n            for(int j=0; j<w; ++j) {\n                char c = v[i][j];\n                if(c == '.') {\n                    continue;\n                }\n                if(L.count(c) == 0) {\n                    L[c] = R[c] = j;\n                    T[c] = B[c] = i;\n                } else {\n                    L[c] = min(L[c], j);\n                    R[c] = max(R[c], j);\n                    T[c] = min(T[c], i);\n                    B[c] = max(B[c], i);\n                }\n            }\n        }\n        // order[i][j] := j is on i\n        array<array<bool, 26>, 26> order;\n        for(int i=0; i<26; ++i) {\n            for(int j=0; j<26; ++j) {\n                order[i][j] = false;\n            }\n        }\n        bool ok = true;\n        for(auto p : L) {\n            char c = p.first;\n            int l = p.second, r = R[c], t = T[c], b = B[c];\n            for(int i=t; i<=b; ++i) {\n                for(int j=l; j<=r; ++j) {\n                    if(v[i][j] == '.') {\n                        ok = false;\n                    } else if(v[i][j] != c) {\n                        order[c-'A'][v[i][j] - 'A'] = true;\n                    }\n                }\n            }\n        }\n        for(int k=0; k<26; ++k) {\n            for(int i=0; i<26; ++i) {\n                for(int j=0; j<26; ++j) {\n                    order[i][j] |= order[i][k] & order[k][j];\n                }\n            }\n        }\n        for(int i=0; i<26; ++i) {\n            for(int j=0; j<26; ++j) {\n                if(order[i][j] && order[j][i]) {\n                    ok = false;\n                }\n            }\n        }\n        cout << (ok ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nbool check(int minx,int miny,int maxx,int maxy,int key,vector<vector<char>>& masu){\n    for(int i = minx; i <= maxx; i++){\n        for(int j = miny; j <= maxy;j++){\n            if(masu[i][j] == '*' || masu[i][j] == key) continue;\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid Fill(int minx,int miny,int maxx,int maxy,vector<vector<char>>& masu){\n    for(int i = minx; i <= maxx; i++){\n        for(int j = miny; j <= maxy;j++){\n            masu[i][j] = '*';\n        }\n    }\n}\n\nstring solve(){\n    ll H,W; cin >> H >> W;\n    vector<vector<char>> masu(H,vector<char>(W));\n    for(int i = 0; i < H;i++){\n        for(int j = 0; j < W;j++){\n            cin >> masu[i][j];\n        }\n    }\n    vector<pair<pii,pii>> X(26,{{INF,INF},{-INF,-INF}});\n    for(int i = 0; i < H;i++){\n        for(int j = 0; j < W;j++){\n            if(masu[i][j] == '.') continue;\n            masu[i][j] -= 'A';\n            pair<pii,pii>& piiii = X[masu[i][j]];\n            piiii.first.first = min(piiii.first.first,i);\n            piiii.first.second = min(piiii.first.second,j);\n            piiii.second.first = max(piiii.second.first,i);\n            piiii.second.second = max(piiii.second.second,j);\n        }\n    }\n    while(true){\n        bool update = [&]{\n            for(int i = 0; i < 26;i++){\n                if(X[i].first.first == INF) continue;\n                if(check(X[i].first.first,X[i].first.second,X[i].second.first,X[i].second.second,i,masu)){\n                    Fill(X[i].first.first,X[i].first.second,X[i].second.first,X[i].second.second,masu);\n                    X[i].first.first = INF;\n                    return true;\n                }\n            }\n            return false;\n        }();\n        if(update) continue;\n        else break;\n    }\n    \n    for(int i = 0; i < H;i++){\n        for(int j = 0; j < W;j++){\n            if(masu[i][j] == '.') continue;\n            if(masu[i][j] == '*') continue;\n            return \"SUSPICIOUS\";\n        }\n    }\n    return \"SAFE\";\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    ll T; cin >> T;\n    while(T--){\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <cctype>\nusing namespace std;\n\nint H, W;\nchar field[55][55];\nchar image[55][55];\nchar c;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid dfs(int y, int x){\n  image[y][x] = '#';\n  field[y][x] = '.';\n  \n  for(int i = 0 ; i < 4 ; i++){\n    int nx = x+dx[i], ny = y+dy[i];\n    if(0 <= nx && nx < W && 0 <= ny && ny < H && field[ny][nx] == c) dfs(ny, nx);\n  }\n  return;\n}\n\nbool checkSafe(){\n  int x = 0, y = 0;\n  for(int i = 0 ; i < H ; i++){\n    int l = 0;\n    for(int j = 0 ; j < W ; j++){\n      if(image[i][j] == '#') l++;\n    }\n    x = max(x, l);\n  }\n  \n  for(int i = 0 ; i < W ; i++){\n    int l = 0;\n    for(int j = 0 ; j < H ; j++){\n      if(image[j][i] == '#') l++;\n    }\n    y = max(y, l);\n  }\n  \n  //cout << \"x = \" << x << \", y = \" << y << endl;\n  \n  for(int i = 0 ; i < H ; i++){\n    int l = 0;\n    for(int j = 0 ; j < W ; j++){\n      if(image[i][j] == '#') l++;\n    }\n    if(l == 0 || l == 1) continue;\n    if(l == x || l == x-1) continue;\n    else return false;\n  }\n  \n  for(int i = 0 ; i < W ; i++){\n    int l = 0;\n    for(int j = 0 ; j < H ; j++){\n      if(image[j][i] == '#') l++;\n    }\n    if(l == 0 || l == 1) continue;\n    if(l == y || l == y-1) continue;\n    else return false;\n  }\n  return true;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  for(int tc = 0 ; tc < N ; tc++){\n    cin >> H >> W;\n    for(int i = 0 ; i < H ; i++){\n      cin >> field[i];\n    }\n    \n    bool safe = true;\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n\tif(isalpha(field[i][j])){\n\t  memset(image, '.', sizeof(image));\n\t  c = field[i][j];\n\t  dfs(i, j);\n\t  if(!checkSafe()){\n\t    safe = false;\n\t    goto F;\n\t  }\n\t}\n      }\n    }\n    \n  F:;\n    if(!safe) cout << \"SUSPICIOUS\" << endl;\n    else cout << \"SAFE\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define fi first\n#define se second\n#define mk make_pair\nusing namespace std;\nmap<int,pair<int,int> >max_p,min_p;\nmap<char,int>mc;\nint h,w,c,vis[101];\nstring s[51];\nvoid mae(){\n  r(i,h)r(j,w)\n   if(s[i][j]=='.')s[i][j]='0';\n   else{\n    if(mc[s[i][j]])s[i][j]=mc[s[i][j]];\n    else{\n      mc[s[i][j]]=(c++)+'0';\n      s[i][j]=(c-1)+'0';\n    }\n   }\n}\nvoid in(){\n  for(int k=1;k<c;k++){\n    int px=0,py=0,mx=1000,my=1000;\n    r(i,h)r(j,w)\n      if(s[i][j]-'0'==k){\n        px=max(px,j);\n        py=max(py,i);\n        mx=min(mx,j);\n        my=min(my,i);\n      }\n    max_p[k]=mk(px,py);\n    min_p[k]=mk(mx,my);\n  }\n}\nbool dfs(int d,int x){\n  if(d){\n    pair<int,int>p1=min_p[x],p2=max_p[x];\n    for(int i=p1.se;i<=p2.se;i++)\n      for(int j=p1.fi;j<=p2.fi;j++)\n        if(!vis[s[i][j]-'0'])return 0;\n  }\n  if(d==c-1)return 1;\n  for(int i=1;i<c;i++)\n    if(!vis[i]){\n      vis[i]=1;\n      if(dfs(d+1,i))return 1;\n      vis[i]=0;\n    }\n  return 0;\n}\nint main(){\n  int n;\n  cin>>n;\n  while(n--){\n    memset(vis,0,sizeof(vis));\n    max_p.clear();\n    min_p.clear();\n    mc.clear();c=1;\n    cin>>h>>w;\n    r(i,h)cin>>s[i];\n    mae();in();\n    if(dfs(0,0))cout<<\"SAFE\"<<endl;\n    else cout<<\"SUSPICIOUS\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvoid solve() {\n    int H, W;\n    cin >> H >> W;\n\n    vector<string> S(H);\n    for (auto& s : S) cin >> s;\n\n    vector<vector<bool>> on(26, vector<bool>(26, false));\n    // on[x][y] => xがyより上にある\n\n    bool judge = true;\n    for (char c = 'A'; c <= 'Z'; ++c) {\n        int lx = W, rx = -1, ly = H, ry = -1;\n        for (int x = 0; x < H; ++x) {\n            for (int y = 0; y < W; ++y) {\n                if (S[x][y] != c) continue;\n                lx = min(lx, x), rx = max(rx, x);\n                ly = min(ly, y), ry = max(ry, y);\n            }\n        }\n\n        for (int x = lx; x <= rx; ++x) {\n            for (int y = ly; y <= ry; ++y) {\n                if (S[x][y] == '.') {\n                    judge = false;\n                } else if (S[x][y] != c) {\n                    // S[x][y]はcの上にある\n                    on[S[x][y] - 'A'][c - 'A'] = true;\n                }\n            }\n        }\n    }\n\n    bool update;\n    do {\n        update = false;\n        for (int k = 0; k < 26; ++k) {\n            for (int i = 0; i < 26; ++i) {\n                for (int j = 0; j < 26; ++j) {\n                    if (on[i][k] && on[k][j] && !on[i][j]) {\n                        update = true;\n                        on[i][j] = true;\n                    }\n                }\n            }\n        }\n    } while (update);\n\n    for (int i = 0; i < 26; ++i) {\n        for (int j = 0; j < 26; ++j) {\n            if (on[i][j] && on[j][i]) judge = false;\n        }\n    }\n\n    cout << (judge ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    for (int i = 0; i < N; ++i) solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <string>\n#include <utility>\n#include <stdio.h>\n#include <stdlib.h>\n\nusing namespace std;\n\nvoid solve(){\n\n\tstring strs[] = { \"SAFE\", \"SUSPICIOUS\" };\n\n\tint h, w;\n\tcin >> h >> w;\n\n\tvector< string > screen( h );\n\tvector< bool > flg( 26, false );\n\n\tfor( int i = 0; i < h; i++ )\n\t\tcin >> screen[ i ];\n\t\n\tbool fig = true;\n\n\twhile( fig ) {\n\n\t\tfig = false;\n\n\t\tfor( int x = 0; x < w; x++ ) {\n\t\t\tfor( int y = 0; y < h; y++ ) {\n\t\t\t\tchar ch = screen[ y ][ x ];\n\t\t\t\tif( ch == '.' || ch == '*' ) continue;\n\t\t\t\tint stx = w, sty = h, edx = -1, edy = -1;\n\t\t\t\tfor( int tx = 0; tx < w; tx ++ ) {\n\t\t\t\t\tfor( int ty = 0; ty < h; ty ++ ) {\n\t\t\t\t\t\tif( screen[ty][tx] == ch ) {\n\t\t\t\t\t\t\tstx = min( stx, tx );\n\t\t\t\t\t\t\tsty = min( sty, ty );\n\t\t\t\t\t\t\tedx = max( edx, tx );\n\t\t\t\t\t\t\tedy = max( edy, ty );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//長方形判定\n\t\t\t\tbool fillflg = true;\n\t\t\t\tfor( int tx = stx; tx <= edx && fillflg; tx ++ ) {\n\t\t\t\t\tfor( int ty = sty; ty <= edy && fillflg; ty ++ ) {\n\t\t\t\t\t\tfillflg &= ( screen[ ty ][ tx ] == ch || screen[ ty ][ tx ] == '*' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfig |= fillflg;\n\t\t\t\tif( fillflg ) {\n\t\t\t\t\tflg[ ch - 'A' ] = false;\n\t\t\t\t\tfor( int tx = stx; tx <= edx && fillflg; tx ++ ) {\n\t\t\t\t\t\tfor( int ty = sty; ty <= edy && fillflg; ty ++ ) {\n\t\t\t\t\t\t\tscreen[ ty ][ tx ] = '*';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\t\n\t\t\n\t}\n\n\tbool b = false;\n\tfor( int x = 0; x < w; x++ ) {\n\t\tfor( int y = 0; y < h; y++ ) {\n\t\t\tb |= ( screen[ y ][ x ] != '.' && screen[ y ][ x ] != '*' );\n\t\t}\n\t}\n\tcout << strs[ b ] << endl;\n\n\n}\n\nint main( void ) {\n\n\n\tint n;\n\tcin >> n;\n\n\tfor( int i = 0; i < n; i++ )\n\t\tsolve();\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <deque>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <unordered_set>\n# include <unordered_map>\n# include <climits>\n# include <complex>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define MP make_pair\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define STRING(x) string x;cin>>x;\n# define STR(x) STRING(x);\n# define DOUBLE(x) double x;cin>>x;\n# define DBL(x) DOUBLE(x); \n# define ALL(x) begin(x),end(x)\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\":\"<<x<<endl\n# define INIT(a) memset(a,-1,sizeof a)\n# define CLR(a) memset(a,0,sizeof a)\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<int> vi;\ntypedef vector<lint> vl;\ntypedef vector<string> vs;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\n//const int dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\n//const int M = 1000000007;\ntemplate<class T> void debug(T a) { for ( auto i : a )cout << i << endl; }\n\nstruct P\n{\n\tint maxx = -1, maxy = -1;\n\tint minx = INF, miny = INF;\n\tvoid add_point(int x, int y)\n\t{\n\t\tmaxx = max(maxx, x);\n\t\tmaxy = max(maxy, y);\n\t\tminx = min(minx, x);\n\t\tminy = min(miny, y);\n\t}\n\tbool operator<(const P &other) const { return 1; }\n\tbool operator>(const P &other) const { return 1; }\n};\nint main()\n{\n\tint n;\n\tcin >> n;\n\tFOR(c, n)\n\t{\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tvs data;\n\t\tFOR(i, h)\n\t\t{\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tdata.push_back(s);\n\t\t}\n\t\tmap<char, P> m;\n\t\tFOR(i, h)\n\t\t{\n\t\t\tFOR(j, w)\n\t\t\t{\n\t\t\t\tif ( data[i][j] != '.' )\n\t\t\t\t{\n\t\t\t\t\tm[data[i][j]].add_point(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool safe = false;\n\t\tvector< pair<char, P> > order;\n\t\tfor ( auto it = m.begin(); it != m.end(); it++ )order.push_back(*it);\n\t\tsort(ALL(order));\n\t\tdo\n\t\t{\n\t\t\tvs temp = data;\n\t\t\tbool ok = true;\n\t\t\tfor ( auto s : order )\n\t\t\t{\n\t\t\t\tP a = s.second;\n\t\t\t\tfor ( int i = a.minx; i <= a.maxx; i++ )\n\t\t\t\t{\n\t\t\t\t\tfor ( int j = a.miny; j <= a.maxy; j++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( temp[i][j] != s.first&&temp[i][j] != '*' )ok = false;\n\t\t\t\t\t\ttemp[i][j] = '*';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsafe |= ok;\n\t\t} while ( next_permutation(ALL(order)) );\n\n\t\tcout << (safe ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint h,w;\nchar tbl[60][60];\nint ax[30],ay[30],Ax[30],Ay[30];\nint d[26];\nbool safe;\nbool visited[26];\n\nint depth(char c){\n  int i = c-'A';\n  if(d[i]!=0) return d[i];\n  if(visited[i]) return d[i]=-1;\n  visited[i]=true;\n  for(int y=ay[i];y<=Ay[i];++y)\n    for(int x=ax[i];x<=Ax[i];++x){\n      if(tbl[y][x]=='.'){\n\treturn d[i]=-1;\n      }\n      else if(tbl[y][x]!=c){\n\td[i]=max(d[i],depth(tbl[y][x])+1);\n      }\n    }\n  if(d[i]==0) return d[i]=1;\n  return d[i];\n}\nint main(){\n  int T;\n  cin>>T;\n  while(T--){\n    safe=true;\n    cin>>h>>w;\n    bool used[26]={};\n    for(int i=0;i<26;++i) ax[i]=ay[i]=100, Ax[i]=Ay[i]=0;\n    for(int i=0;i<h;++i) cin>>tbl[i];\n    for(int i=0;i<h;++i)\n      for(int j=0;j<w;++j){\n\tif('A'<=tbl[i][j] && tbl[i][j]<='Z'){\n\t  int c = tbl[i][j]-'A';\n\t  used[c]=true;\n\t  ax[c]=min(ax[c],j);\n\t  ay[c]=min(ay[c],i);\n\t  Ax[c]=max(Ax[c],j);\n\t  Ay[c]=max(Ay[c],i);\n\t}\n      }\n\n    for(int i=0;i<26;++i) d[i]=0;\n    for(int i=0;i<26;++i){\n      if(!used[i]) continue;\n      int t = depth('A'+i);\n      if(t==-1) safe=false;\n    }\n    if(safe) cout << \"SAFE\" << endl;\n    else cout << \"SUSPICIOUS\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <sstream>\nusing namespace std;\n\n#define REP(i,a,n) for(i=a; i<n; i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define foreach(it,x) for(typeof(x.begin()) it=x.begin(); it!=x.end(); it++)\n\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\nint H,W;\nchar field[55][55];\nbool kind[256], used[256];\n\n\n// ·û`©Ç¤©B©ªæèºÌ¨Ìª êÎfalse\nbool is_check(int x1, int y1, int x2, int y2, char mark){\n    int i,j;\n    for(i=y1; i<=y2; i++){\n        for(j=x1; j<=x2; j++){\n            if( field[i][j] == '.' ||\n                (field[i][j] != mark && used[field[i][j]]) ) return false;\n        }\n    }\n    return true;\n}\n\n\nbool solve(char mark){\n    int i,j,x1,x2,y1,y2;\n\n    x1 = y1 = 55;\n    x2 = y2 = 0;\n    rep(i,H){\n        rep(j,W){\n            if( field[i][j] == mark ){\n                x1 = min(x1, j), y1 = min(y1, i);\n                x2 = max(x2, j), y2 = max(y2, i);\n            }\n        }\n    }\n\n    //printf(\"mark=%c, rec=(%d,%d),(%d,%d)\\n\",mark,x1,y1,x2,y2);\n    if( !is_check(x1,y1,x2,y2,mark) ) return false;\n    //printf(\"   is_check = ok\\n\");\n\n    bool tmp[256];\n    rep(i,256) tmp[i] = used[i];\n\n    // Ü¾²×ÄÈ¢©ªæè¢¨Ì©çÄA\n    for(i=y1; i<=y2; i++){\n        for(j=x1; j<=x2; j++){\n            if( !tmp[field[i][j]] ){\n                //printf(\"     %c -> %c\\n\",mark,field[i][j]);\n                tmp[field[i][j]] = true;\n                used[field[i][j]] = true;\n                bool res = solve(field[i][j]);\n                used[field[i][j]] = false;\n                if( !res ) return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main(){\n    int T,i,j;\n    cin >> T;\n\n    while( T-- ){\n        cin >> H >> W;\n        memset(kind, false, sizeof(kind));\n\n        rep(i,H) cin >> field[i];\n\n        bool ok = true;\n        rep(i,H){\n            rep(j,W){\n                if( field[i][j] != '.' && !kind[field[i][j]] ){\n                    used[field[i][j]] = true;\n                    ok &= solve(field[i][j]);\n                    used[field[i][j]] = false;\n                    kind[field[i][j]] = true;\n                    //printf(\"___kinded %c, ok = %d\\n\",field[i][j],ok);\n                }\n            }\n        }\n\n        puts(ok ? \"SAFE\" : \"SUSPICIOUS\");\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\nint n;\nint H,W,T;\nstring str;\nbool used[26],flg;\n\nint A[26],B[26],C[26],D[26];\n\nchar t[50][50];\n\nchar tmp;\n\nvoid input();\nvoid init();\n\nbool check(char ch){\n  int z= ch-'A';\n  for(int i=A[z];i<=C[z];i++){\n    for(int j=D[z];j<=B[z];j++){\n      if(t[i][j]!='.'&&used[t[i][j]-'A']==false)continue;\n      if(t[i][j]!=ch)return false;\n    }\n  }\n  return true;\n}\n\n\n\nint main(){\n  cin>>T;\n  while(T--){\n    init();\n    input();\n\n    while(1){\n \n      flg=false;\n\n      for(int i=0;i<26;i++){\n\tif(used[i]==false)continue;\n\tif(check(i+'A')==true){\n\t  flg=true;\n\t  used[i]=false;\n\t  break;\n\t}\n      }\n      if(flg==false)break;\n    }\n\n    flg=false;\n    for(int i=0;i<26;i++)flg|=used[i];\n    cout<<(flg?\"SUSPICIOUS\":\"SAFE\")<<endl;\n  }\n  return 0;\n}\n\nvoid input(){\n  int X;\n  cin>>H>>W;\n  for(int i=0;i<H;i++){\n    cin>>str;\n    for(int j=0;j<W;j++){\n      t[i][j]=str[j];\n      if(t[i][j]=='.')continue;\n      X=t[i][j]-'A';\n      used[X]=true;\n      A[X]=min(A[X],i);\n      B[X]=max(B[X],j);\n      C[X]=max(C[X],i);\n      D[X]=min(D[X],j);\n    }\n  }\n}\n\nvoid init(){\n  for(int i=0;i<26;i++){\n    A[i]=50;\n    B[i]=0;\n    C[i]=0;\n    D[i]=50;\n    used[i]=false;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\nstruct item{\n    int left,right,up,down;\n    char num;\n};\nint h,w;\n\nbool canDelete(vector<string> data,item del){\n    for(int i=del.up;i<=del.down;i++){\n        for(int j=del.left;j<=del.right;j++){\n            if( data[i][j]!=del.num && data[i][j]!='*')return false;\n        }\n    }\n    return true;\n}\n\nvoid del(vector<string> &data, item del){\n    for(int i=del.up;i<=del.down;i++){\n        for(int j=del.left;j<=del.right;j++){\n            data[i][j] = '*';\n        }\n    }\n}\n\nstring solve(vector<string> data){\n    item pos[300];\n    rep(i,300){\n        pos[i] = item{INF,0,INF,0};\n    }\n    \n    rep(i,h){\n        rep(j,w){\n            char ch = data[i][j];\n            if(ch=='.')continue;\n            pos[ch].num     = (char)data[i][j];\n            pos[ch].left    = min<ll>(pos[ch].left  ,j);\n            pos[ch].right   = max<ll>(pos[ch].right ,j);\n            pos[ch].up      = min<ll>(pos[ch].up    ,i);\n            pos[ch].down    = max<ll>(pos[ch].down  ,i);\n        }\n    }\n    \n    vector<item> vec;\n    rep(i,300){\n        if(pos[i].left!=INF) vec.pb(pos[i]);\n    }\n    \n    bool deleted[10]={};\n    rep(i,vec.size()){\n        rep(j,vec.size()){\n            if(deleted[j])continue;\n            if( canDelete(data,vec[j]) ){\n                del( data ,vec[j] );\n                deleted[j]=true;\n                break;\n            }\n        }\n    }\n    \n    rep(i,vec.size()){\n        if(deleted[i]==false) return \"SUSPICIOUS\";\n    }\n    return \"SAFE\";\n}\n\n\nint main(){\n    int t;\n    cin>>t;\n    rep(loop,t){\n        cin>>h>>w;\n        vector<string> data(h);\n        rep(i,h){\n            cin>>data[i];\n        }\n        cout<<solve(data)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n\nint Y,X;\n\nstruct Item{\n    int x1,x2,y1,y2;\n    set<pair<int,int>> st;\n    Item(){\n        x1 = y1 = +100;\n        x2 = y2 = -100;\n    }\n    void update(int x,int y){\n        x1 = min(x1,x);\n        x2 = max(x2,x);\n        y1 = min(y1,y);\n        y2 = max(y2,y);\n        st.insert({x,y});\n    }\n\n    bool isRectangle(){\n        return (x2-x1+1)*(y2-y1+1) == (int) st.size();\n    }\n    bool isin(int x,int y){\n        return x1<=x && x<=x2 && y1<=y && y<=y2;\n    }\n};\n\nint main(void){\n    int T;\n    cin>>T;\n    while(T--){\n        cin>>Y>>X;\n        vector<string> s(Y);\n        rep(y,Y) cin>>s[y];\n        vector<Item> items(26);\n        rep(y,Y)rep(x,X){\n            if(s[y][x] == '.') continue;\n            int a = s[y][x] - 'A';\n            items[a].update(x,y);\n        }\n        for(auto it=items.begin(); it!=items.end();){\n            if((int)it->st.size() == 0){\n                it = items.erase(it);\n            }else ++it;\n        }\n\n        size_t prev = 0;\n        while(prev != items.size()){\n            prev = items.size();\n            for(auto it=items.begin(); it!=items.end();){\n                if(it->isRectangle()){\n                    for(int x=it->x1; x<=it->x2; x++){\n                        for(int y=it->y1; y<=it->y2; y++){\n                            for(auto &back : items){\n                                if(back.isin(x,y)){\n                                    back.update(x,y);\n                                }\n                            }\n                        }\n                    }\n                    it = items.erase(it);\n                }else ++it;\n            }\n        }\n        cout<<(items.size() ? \"SUSPICIOUS\" : \"SAFE\")<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define fi first\n#define se second\n#define mk make_pair\nusing namespace std;\nmap<int,pair<int,int> >max_p,min_p;\nmap<char,int>mc;\nint h,w,c,vis[101];\nstring s[51];\nvoid mae(){\n  r(i,h)r(j,w)\n   if(s[i][j]=='.')s[i][j]='0';\n   else{\n    if(mc[s[i][j]])s[i][j]=mc[s[i][j]];\n    else{\n      mc[s[i][j]]=(c++)+'0';\n      s[i][j]=(c-1)+'0';\n    }\n   }\n}\nvoid in(){\n  for(int k=1;k<c;k++){\n    int px=0,py=0,mx=1000,my=1000;\n    r(i,h)r(j,w)\n      if(s[i][j]-'0'==k){\n        px=max(px,j);\n        py=max(py,i);\n        mx=min(mx,j);\n        my=min(my,i);\n      }\n    max_p[k]=mk(px,py);\n    min_p[k]=mk(mx,my);\n  }\n}\nbool chb(){\n  for(int k=1;k<c;k++){\n    pair<int,int>p1=min_p[k],p2=max_p[k];\n    for(int i=p1.se;i<=p2.se;i++)\n      for(int j=p1.fi;j<=p2.fi;j++)\n        if(s[i][j]=='0')return 1;\n  }\n  return 0;\n}\nbool dfs(int d,int x){\n  if(d){\n    pair<int,int>p1=min_p[x],p2=max_p[x];\n    for(int i=p1.se;i<=p2.se;i++)\n      for(int j=p1.fi;j<=p2.fi;j++)\n        if(!vis[s[i][j]-'0'])return 0;\n  }\n  if(d==c-1)return 1;\n  for(int i=1;i<c;i++)\n    if(!vis[i]){\n      vis[i]=1;\n      if(dfs(d+1,i))return 1;\n      vis[i]=0;\n    }\n  return 0;\n}\nint main(){\n  int n;\n  cin>>n;\n  while(n--){\n    memset(vis,0,sizeof(vis));\n    max_p.clear();\n    min_p.clear();\n    mc.clear();c=1;\n    cin>>h>>w;\n    r(i,h)cin>>s[i];\n    mae();\n    in();\n    if(chb())cout<<\"SUSPICIOUS\"<<endl;\n    else{\n      if(dfs(0,0))cout<<\"SAFE\"<<endl;\n      else cout<<\"SUSPICIOUS\"<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nint h,w;\nchar s[100][100];\nbool used[100];\nbool d[300][300];\nbool check(char up,char m){\n    if(d[up][m])\n        return true;\n    for(int i = 'A';i <= 'Z';i++){\n        if(d[up][i]){\n            if(check(i,m))\n                return true;\n        }\n    }\n    return false;\n}\nvoid solve(){\n\n    bool f = true;\n    REP(i,100)\n        used[i] = false;\n    fill((bool*)d, (bool*)d + 300 * 300,false);\n    while(f){\n        f = false;\n        REP(i,h){\n            REP(j,w){\n                if(s[i][j] != '.' && !used[s[i][j] - 'A']){\n                    used[s[i][j] - 'A'] = true;\n                    f = true;\n                    int m = s[i][j];\n\n                    int maxi = 0,maxj = 0,mini = 100,minj = 100;\n                    REP(k,h){\n                        REP(l,w){\n                            if(s[k][l] == m){\n                                if(maxi < k)\n                                    maxi = k;\n                                if(maxj < l)\n                                    maxj = l;\n                                if(mini > k)\n                                    mini = k;\n                                if(minj > l)\n                                    minj = l;\n                            }\n                        }\n                    }\n                    FOR(k,mini,maxi + 1){\n                        FOR(l,minj,maxj + 1){\n                            if(s[k][l] == '.' || (m != s[k][l] && check(s[k][l],m))){\n                                printf(\"SUSPICIOUS\\n\");\n                                return;\n                            }\n                            if(m != s[k][l]){\n                                d[m][s[k][l]] = true;\n                            }\n                        }\n                    }\n                }\n                if(f)\n                    break;\n            }\n            if(f)\n                break;\n        }\n    }\n    printf(\"SAFE\\n\");\n}\n\nvoid input(){\n    scanf(\"%d%d\",&h,&w);\n    REP(i,h){\n        scanf(\"%s\",&s[i][0]);\n    }\n}\n\n\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for(int i = 0;i < n;i++){\n        input();\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n;\n  cin>>n;\n  for(int loop=0;loop<n;loop++){\n    int h,w;\n    cin>>h>>w;\n    vector<string> c(h);\n    for(auto &v:c) cin>>v;\n    set<char> s;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(c[i][j]!='.') s.insert(c[i][j]);\n      }\n    }\n\n    vector<char> ch(s.begin(),s.end());\n    sort(ch.begin(),ch.end());\n    bool res=(ch.size()==0);\n    do{\n      auto cp=c;\n      bool isok=true;\n      for(int col=0;col<ch.size();col++){\n\tint l=100;\n\tint r=0;\n\tint u=100;\n\tint b=0;      \n\tfor(int i=0;i<h;i++){\n\t  for(int j=0;j<w;j++){\n\t    if(cp[i][j]==ch[col]){\n\t      l=min(l,j);\n\t      r=max(r,j);\n\t      u=min(u,i);\n\t      b=max(b,i);\n\t    }\n\t  } \n\t}\n\tb++,r++;\n\tfor(int i=u;i<b;i++){\n\t  for(int j=l;j<r;j++){\n\t    if(cp[i][j]=='.'){\n\t      isok=false;\n\t    }\n\t    else{\n\t      if(cp[i][j]==ch[col]){\n\t\tcp[i][j]='.';\n\t      }\n\t    }\t    \n\t  }\n\t}\t\n      }\n      res|=isok;\n    }while(next_permutation(ch.begin(),ch.end()));\n      \n    cout<<(res ? \"SAFE\" : \"SUSPICIOUS\")<<endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass Belongings {\npublic:\n  Belongings() : left(100),right(0),upper(100),lower(0){}\n  int left,right,upper,lower;\n};\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    for(int stage_idx = 0; stage_idx < N; stage_idx++){\n      int H,W;\n      \n      scanf(\"%d %d\",&H,&W);\n      char stage[2500];\n      char hypothesis[2500];\n      memset(stage,'.',sizeof(stage));\n\n      map<char,Belongings> layer;\n\n      for(int y=0;y<H;y++){\n\tchar line[51];\n\tscanf(\"%s\",line);\n\tfor(int x=0;x<W;x++){\n\t  stage[y*W+x] = line[x];\n\t  if(line[x] == '.') continue;\n\t  //x:0->...\n\t  //y:0\n\t  //  |\n\t  //  v\n\t  //  .\n\t  //  upper\n\t  //left right\n\t  //  lower\n\t  Belongings& be = layer[stage[y*W+x]];\n\t  be.left = min(be.left,x);\n\t  be.right = max(be.right,x);\n\t  be.upper = min(be.upper,y);\n\t  be.lower = max(be.lower,y);\n\t}\n      }\n\n      bool is_safe = false;\n\n      vector<char> order;\n      for(map<char,Belongings>::iterator it = layer.begin();\n\t  it != layer.end();\n\t  it++){\n\torder.push_back(it->first);\n      }\n      sort(order.begin(),order.end());\n\n\n      do{\n\tmemset(hypothesis,'.',sizeof(hypothesis));\n\n\tfor(int i=0;i<order.size();i++){\n\t  char c = order[i];\n\t  Belongings& be = layer[c];\n\t  for(int y=be.upper; y<=be.lower; y++){\n\t    for(int x=be.left; x<=be.right; x++){\n\t      hypothesis[y*W+x] = c;\n\t    }\n\t  }\n\t}\n\n\tif(strcmp(hypothesis,stage) == 0){\n\t  is_safe = true;\n\t  break;\n\t}\n      }while(next_permutation(order.begin(),order.end()));\n      printf(\"%s\\n\",is_safe ? \"SAFE\" : \"SUSPICIOUS\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n\nvector<int> topologicalSort(int v,const vector<int> edge[]){\n\tvector<int> zeros;\n\tvector<int> in(v),res;\n\tfor(int i=0;i<v;i++){\n\t\tfor(int j=0;j<(int)edge[i].size();j++)in[edge[i][j]]++;\n\t}\n\tfor(int i=0;i<v;i++)if(in[i]==0)zeros.push_back(i);\n\twhile(!zeros.empty()){\n\t\tint u=zeros.back();\n\t\tzeros.pop_back();\n\t\tres.push_back(u);\n\t\tfor(int i=0;i<(int)edge[u].size();i++){\n\t\t\tif(--in[edge[u][i]]==0)zeros.push_back(edge[u][i]);\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main(){\n\tint h,w;\n\tint xmin[26],ymin[26],xmax[26],ymax[26];\n\tchar image[50][50];\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tfill_n(xmin,26,51);\n\t\tfill_n(ymin,26,51);\n\t\tfill_n(xmax,26,-1);\n\t\tfill_n(ymax,26,-1);\n\t\tcin>>h>>w;\n\t\tbool ok=true;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar c;\n\t\t\t\tcin>>c;\n\t\t\t\timage[i][j]=c;\n\t\t\t\tif(c=='.')continue;\n\t\t\t\tint idx=c-'A';\n\t\t\t\tymin[idx]=min(ymin[idx],i);\n\t\t\t\tymax[idx]=max(ymax[idx],i);\n\t\t\t\txmin[idx]=min(xmin[idx],j);\n\t\t\t\txmax[idx]=max(xmax[idx],j);\n\t\t\t}\n\t\t}\n\t\tvector<int> edge[26];\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(ymax[i]==-1)continue;\n\t\t\tfor(int y=ymin[i];y<=ymax[i];y++){\n\t\t\t\tfor(int x=xmin[i];x<=xmax[i];x++){\n\t\t\t\t\tif(image[y][x]=='.'){\n\t\t\t\t\t\tok=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(i+'A'!=image[y][x])edge[i].push_back(image[y][x]-'A');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> order(topologicalSort(26,edge));\n\t\tif(ok&&order.size()==26)cout<<\"SAFE\"<<endl;\n\t\telse cout<<\"SUSPICIOUS\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint H,W,word_num,loc[128];\nchar map[50][51],word_table[8];\nbool isOK;\n\n\nvoid recursive(int work[8],int count){\n\n\tif(isOK)return;\n\n\tif(count == word_num){\n\n\t\tbool FLG = true;\n\t\tint most_left,most_right,most_top,most_bottom,rank;\n\t\tchar ch;\n\n\t\tfor(int i = 0; i < word_num; i++){\n\t\t\tch = word_table[i];\n\t\t\trank = work[i];\n\n\t\t\tmost_left = 51,most_right = -1,most_top = 51,most_bottom = -1;\n\n\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tif(map[row][col] == ch){\n\t\t\t\t\t\tmost_left = min(most_left,col);\n\t\t\t\t\t\tmost_right = max(most_right,col);\n\t\t\t\t\t\tmost_top = min(most_top,row);\n\t\t\t\t\t\tmost_bottom = max(most_bottom,row);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int row = most_top; row <= most_bottom; row++){\n\t\t\t\tfor(int col = most_left; col <= most_right; col++){\n\t\t\t\t\tif(map[row][col] != ch){\n\t\t\t\t\t\tif(rank > work[loc[map[row][col]-'0']]){\n\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!FLG)break;\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)isOK = true;\n\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < word_num; i++){\n\t\tif(work[i] == -1){\n\t\t\tint next_work[8];\n\t\t\tfor(int k = 0; k < 8; k++)next_work[k] = work[k];\n\t\t\tnext_work[i] = count;\n\n\t\t\trecursive(next_work,count+1);\n\t\t}\n\t}\n}\n\n\n\nvoid func(){\n\n\tfor(int i = 0; i < 128; i++)loc[i] = -1;\n\tword_num = 0;\n\n\tscanf(\"%d %d\",&H,&W);\n\tfor(int i = 0; i < H; i++){\n\t\tscanf(\"%s\",map[i]);\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tif(map[i][k] != '.'){\n\t\t\t\tif(loc[map[i][k]-'0'] == -1){ //????????´?????´???\n\t\t\t\t\tloc[map[i][k]-'0'] = word_num;\n\t\t\t\t\tword_table[word_num] = map[i][k];\n\t\t\t\t\tword_num++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool FLG = true,dfs_FLG = true;\n\tint most_left,most_right,most_top,most_bottom;\n\tchar ch;\n\n\tfor(int i = 0; i < word_num; i++){\n\t\tch = word_table[i];\n\n\t\tmost_left = 51,most_right = -1,most_top = 51,most_bottom = -1;\n\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(map[row][col] == ch){\n\t\t\t\t\tmost_left = min(most_left,col);\n\t\t\t\t\tmost_right = max(most_right,col);\n\t\t\t\t\tmost_top = min(most_top,row);\n\t\t\t\t\tmost_bottom = max(most_bottom,row);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int row = most_top; row <= most_bottom; row++){\n\t\t\tfor(int col = most_left; col <= most_right; col++){\n\t\t\t\tif(map[row][col] != ch){\n\t\t\t\t\tdfs_FLG = false;\n\t\t\t\t\tif(map[row][col] == '.'){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!FLG)break;\n\t\t}\n\t}\n\n\tif(!FLG){\n\t\tprintf(\"SUSPICIOUS\\n\");\n\t\treturn;\n\t}\n\n\tif(dfs_FLG){\n\t\tprintf(\"SAFE\\n\");\n\t}\n\n\tisOK = false;\n\n\tint work[8];\n\n\tfor(int i = 0; i < word_num; i++)work[i] = -1;\n\n\trecursive(work,0);\n\n\tif(isOK){\n\t\tprintf(\"SAFE\\n\");\n\t}else{\n\t\tprintf(\"SUSPICIOUS\\n\");\n\t}\n}\n\n\nint main(){\n\n\tint num;\n\tscanf(\"%d\",&num);\n\n\tfor(int i = 0; i < num; i++)func();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint t;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tvector<int> l(30, INF), r(30, 0), u(30, INF), d(30, 0);\n\t\tset<int> st;\n\t\tvector<string> s(h);\n\t\tfor (int i = 0; i < h; i++)\n\t\t{\n\t\t\tcin >> s[i];\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tif (s[i][j] == '.')\n\t\t\t\t\tcontinue;\n\t\t\t\tint idx = s[i][j] - 'A';\n\t\t\t\tst.insert(idx);\n\t\t\t\tl[idx] = min(l[idx], j);\n\t\t\t\tr[idx] = max(r[idx], j);\n\t\t\t\tu[idx] = min(u[idx], i);\n\t\t\t\td[idx] = max(d[idx], i);\n\t\t\t}\n\t\t}\n\t\tvector<int> v;\n\t\tfor (auto val : st)\n\t\t{\n\t\t\tv.push_back(val);\n\t\t}\n\t\tint sz = v.size();\n\t\tbool f = false;\n\t\tdo\n\t\t{\n\t\t\tvector<int> pri(30, INF);\n\t\t\tfor (int i = 0; i < sz; i++)\n\t\t\t{\n\t\t\t\tpri[v[i]] = i;\n\t\t\t}\n\t\t\tbool ftmp = true;\n\t\t\tfor (int i = 0; i < 26; i++)\n\t\t\t{\n\t\t\t\tif (l[i] == INF)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (int x = u[i]; x <= d[i]; x++)\n\t\t\t\t{\n\t\t\t\t\tfor (int y = l[i]; y <= r[i]; y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (s[x][y] == '.')\n\t\t\t\t\t\t\tftmp = false;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint gt = s[x][y] - 'A';\n\t\t\t\t\t\t\tif (pri[gt] >= pri[i])\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tftmp = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ftmp)\n\t\t\t\tf = true;\n\t\t} while (next_permutation(v.begin(), v.end()));\n\t\tif (!f)\n\t\t{\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"SAFE\" << endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nstring str[60];\nint h,w;\nint num;\nbool flag;\nbool used[55][55];\nchar moji[10];\nint vx[4]={1,0,-1,0};\nint vy[4]={0,1,0,-1};\nvoid dfs(int Bit,int depth){\n  if(Bit==((1<<num)-1)){\n    flag=true;\n    return;\n  }\n  for(int i=0;i<num;i++){\n    if(!(Bit&(1<<i))){\n      bool used2[55][55]={};\n      int lemi=100,lema=0,rimi=100,rima=0;\n      for(int j=0;j<h;j++){\n\tfor(int k=0;k<w;k++){\n\t  if(str[j][k]==moji[i]){\n\t    used2[j][k]=true;\n\t    used[j][k]=true;\n\t    lemi=min(lemi,k);\n\t    lema=max(lema,k);\n\t    rima=max(rima,j);\n\t    rimi=min(rimi,j);\n\t  }\n\t}\n      }\n      bool fll=true;\n      for(int j=rimi;j<=rima;j++){\n\tfor(int k=lemi;k<=lema;k++){\n\t  if(!used[j][k]){\n\t    fll=false;\n\t  }\n\t}\n      }\n      if(fll)\n      dfs(Bit+(1<<i),depth+1);\n      for(int j=rimi;j<=rima;j++){\n\tfor(int k=lemi;k<=lema;k++){\n\t  if(used2[j][k]){\n\t    used[j][k]=false;\n\t  }\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int n;cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>h>>w;\n    num=0;\n    for(int i=0;i<55;i++)\n      for(int j=0;j<55;j++)\n\tused[i][j]=false;\n    flag=false;\n    bool alfa[26]={};\n    for(int i=0;i<h;i++){\n      cin>>str[i];\n      for(int j=0;j<w;j++){\n\talfa[str[i][j]-'A']=true;\n      }\n    }\n    int cnt=0;\n    for(int i=0;i<26;i++){\n      num+=alfa[i];\n      if(alfa[i]){\n\tmoji[cnt]=(char)(i+'A');\n\tcnt++;\n      }\n    }\n    dfs(0,0);\n    if(flag)\n      cout<<\"SAFE\"<<endl;\n    else \n      cout<<\"SUSPICIOUS\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define INF 1e9\n#define EPS 1e-9\n#define MOD (1e9+7)\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\n\n#define xmin first.first\n#define xmax first.second\n#define ymin second.first\n#define ymax second.second\n\nint main(){\n\tint n;\n\tcin>>n;\n\trep(datasets,n){\n\t\tmap<char,int> mp;\n\t\tmap<int,pair<pii,pii>> pt;\n\n\t\tint h,w;\n\t\tcin>>h>>w;\n\t\tmp['.']=0;\n\t\tpt[0]={{w,0},{h,0}};\n\t\tvvi f(h,vi(w));\n\t\trep(i,h)rep(j,w){\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tif(mp.find(c)==mp.end()){\n\t\t\t\tmp[c]=mp.size()-1;\n\t\t\t\tpt[mp[c]]={{w,0},{h,0}};\n\t\t\t}\n\t\t\tf[i][j]=mp[c];\n\t\t\tpt[mp[c]].xmin=min(pt[mp[c]].xmin,j);\n\t\t\tpt[mp[c]].xmax=max(pt[mp[c]].xmax,j);\n\t\t\tpt[mp[c]].ymin=min(pt[mp[c]].ymin,i);\n\t\t\tpt[mp[c]].ymax=max(pt[mp[c]].ymax,i);\n\t\t}\n\t\t\n\t\tvi perm(mp.size()-1);\n\t\tiota(all(perm),1);\n\t\tbool ok=false;\n\t\tdo{\n\t\t\tauto p=f;\n\t\t\tfor(auto key:perm){\n\t\t\t\tfor(int i=pt[key].ymin;i<=pt[key].ymax;i++){\n\t\t\t\t\tfor(int j=pt[key].xmin;j<=pt[key].xmax;j++){\n\t\t\t\t\t\tif(p[i][j]!=key and p[i][j]!=-1){\n\t\t\t\t\t\t\tgoto next;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tp[i][j]=-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tok=true;\n\t\t\tbreak;\n\t\t\tnext:;\n\t\t}while(next_permutation(all(perm)));\n\t\tif(ok){\n\t\t\tcout<<\"SAFE\"<<endl;\n\t\t}else{\n\t\t\tcout<<\"SUSPICIOUS\"<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n\ntypedef long long lint;\ntypedef pair<int, int> pii;\n\nint H, W;\nstring pict[55];\n\nbool item[30];\nint l[30], t[30], r[30], b[30];\nint collision[30];\n\nbool look[30];\n\nbool rec(int i) {\n\tif (look[i]) return false;\n\t\n\tlook[i] = true;\n\t\n\tint col = collision[i];\n\tfor_(j,0,26) {\n\t\tif (col >> j & 1) {\n\t\t\tif (!rec(j)) return false;\n\t\t}\n\t}\n\t\n\tlook[i] = false;\n\t\n\treturn true;\n}\n\nbool is_safe() {\n\tminit(collision, 0);\n\t\n\tfor_(alph,0,26) {\n\t\tif (!item[alph]) continue;\n\t\t\n\t\tchar ALPH = 'A' + alph;\n\t\t\n\t\tfor_(y,t[alph],b[alph] + 1) for_(x,l[alph],r[alph] + 1) {\n\t\t\tif (pict[y][x] == '.') return false;\n\t\t\t\n\t\t\tif (pict[y][x] != ALPH) {\n\t\t\t\tint p = (int)(pict[y][x] - 'A');\n\t\t\t\tcollision[alph] |= 1 << p;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor_(alph,0,26) {\n\t\tif (!item[alph]) continue;\n\t\tif (!rec(alph)) return false;\n\t}\n\t\n\treturn true;\n}\n\nvoid solve() {\n\tminit(item,0);\n\tfill(l, l + 30, W);\n\tfill(t, t + 30, H);\n\tfill(r, r + 30, 0);\n\tfill(b, b + 30, 0);\n\t\n\tfor_(i,0,H) for_(j,0,W) {\n\t\tchar c = pict[i][j];\n\t\tif (c == '.') continue;\n\t\tint ci = (int)(c - 'A');\n\t\t\n\t\titem[ci] = true;\n\t\tl[ci] = min(l[ci], j);\n\t\tt[ci] = min(t[ci], i);\n\t\tr[ci] = max(r[ci], j);\n\t\tb[ci] = max(b[ci], i);\n\t}\n\t\n\tif (is_safe()) cout << \"SAFE\" << endl;\n\telse cout << \"SUSPICIOUS\" << endl;\n}\n\nint main() {\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tcin >> H >> W;\n\t\tfor_(i,0,H) cin >> pict[i];\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ll long long\n#define fi first\n#define se second\n#define pb push_back\n#define rep(i, s, n) for (int i = s; i < n; i++)\n#define rrep(i, s, n) for (int i = (n)-1; i >= (s); i--)\n#define REP(i,n) for(int i = 0;i < n; i++)\n#define all(a) a.begin(),a.end()\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\nconst long long MOD = 1000000007, INF = 1e18;\n \n#define endl '\\n'\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0)\n \ntemplate<class T>inline bool chmax(T& a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>inline bool chmin(T& a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>vector<T>\nmake_v(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n\treturn vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n \ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n \ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n\tfor(auto &e:t) fill_v(e,v);\n}\n\n/*bool operator<(const data &d)const{\n\treturn hoge;\n}*/\n\nstruct zahyou{\n\tint xma,xmi,yma,ymi,num;\n}z;\n \nsigned main(){\n\tIOS();\n\tint H,W;\n\tvector<int>ans;\n\tint N;\n\tcin>>N;\n\twhile(N--){\n\t\tcin>>H>>W;\n\t\tstring s[H];\n\t\trep(i,0,H)cin>>s[i];\n\t\tmap<char,zahyou>mp;\n\t\tvector<char>c;\n\t\trep(i,0,H){\n\t\t\trep(j,0,W){\n\t\t\t\tif(s[i][j]=='.')continue;\n\t\t\t\tif(mp.count(s[i][j])){\n\t\t\t\t\tchmin(mp[s[i][j]].xmi,j);\n\t\t\t\t\tchmax(mp[s[i][j]].xma,j);\n\t\t\t\t\tchmin(mp[s[i][j]].ymi,i);\n\t\t\t\t\tchmax(mp[s[i][j]].yma,i);\n\t\t\t\t}else{\n\t\t\t\t\tmp[s[i][j]].xma=mp[s[i][j]].xmi=j;\n\t\t\t\t\tmp[s[i][j]].yma=mp[s[i][j]].ymi=i;\n\t\t\t\t\tc.push_back(s[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>rank(mp.size());\n\t\tmap<char,int>inv;\n\t\tint cnt=0;\n\t\tfor(auto e:c){\n\t\t\tinv[e]=cnt;\n\t\t\tcnt++;\n\t\t}\n\t\tiota(all(rank),0);\n\t\tint end = 0;\n\t\trep(i,0,c.size()){\n\t\t\t//cout<<mp[c[i]].xmi<<\" \"<<mp[c[i]].xma<<endl;\n\t\t}\n\t\t\n\t\tdo{\n\t\t\tint ok=1;\n\t\t\trep(i,0,rank.size()){\n\t\t\t\tint sx = mp[c[i]].xmi;\n\t\t\t\tint gx = mp[c[i]].xma;\n\t\t\t\tint sy = mp[c[i]].ymi;\n\t\t\t\tint gy = mp[c[i]].yma;\n\t\t\t\tint flg = 1;\n\t\t\t\trep(j,sy,gy+1){\n\t\t\t\t\trep(k,sx,gx+1){\n\t\t\t\t\t\tif(s[j][k]=='.')flg=0;\n\t\t\t\t\t\telse if(rank[inv[s[j][k]]]>=rank[inv[c[i]]])continue;\n\t\t\t\t\t\telse flg=0;\n\t\t\t\t\t\tif(flg==0)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(flg==0)break;\n\t\t\t\t}\n\t\t\t\tif(flg==0)ok=0;\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tans.push_back(1);\n\t\t\t\tend = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(end)break;\n\t\t}while(next_permutation(all(rank)));\n\t\tif(end==0)ans.push_back(0);\n\t\t\n\t}\n\tfor(auto e:ans){\n\t\tif(e)cout<<\"SAFE\"<<endl;\n\t\telse cout<<\"SUSPICIOUS\"<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define fi first\n#define se second\n#define rep(i, j, k) for (auto i = j; i < k; i++)\n#define rrep(i, j, k) for (auto i = j; i > k; i--)\nusing namespace std;\n\nvoid solve() {\n  int h, w; cin >> h >> w;\n  char a[51][51], b[51][51];\n  set<char> set1;\n  rep(i, 0, h) rep(j, 0, w) {\n    cin >> a[i][j];\n    if (a[i][j] == '.') continue;\n    set1.insert(a[i][j]);\n  }\n  if (set1.size() < 1) {\n    cout << \"SAFE\" << endl;\n    return;\n  }\n  assert(set1.size() < 8);\n  vector<char> v;\n  for (auto ite : set1) v.push_back(ite);\n  sort(v.begin(), v.end());\n  do {\n    rep(i, 0, h) rep(j, 0, w) b[i][j] = a[i][j];\n    bool ok = true;\n    rep(nowi, 0, (int)v.size()) {\n      int left = INT_MAX, right = INT_MIN;\n      rep(j, 0, w) rep(i, 0, h) {\n        if (b[i][j] == v[nowi]) {\n          left = min(left, j);\n          right = max(right, j);\n        }\n      }\n      int up = INT_MAX, down = INT_MIN;\n      rep(i, 0, h) rep(j, 0, w) {\n        if (b[i][j] == v[nowi]) {\n          up = min(up, i);\n          down = max(down, i);\n        }\n      }\n      [&]{\n        rep(i, up, down + 1) rep(j, left, right + 1) {\n          if (b[i][j] != v[nowi] && b[i][j] != '*') {\n            ok = false;\n            return;\n          }\n        }\n      }();\n      if (ok) {\n        rep(i, up, down + 1) rep(j, left, right + 1) {\n          if (b[i][j] == v[nowi]) b[i][j] = '*';\n        }\n      } else {\n        break;\n      }\n    }\n    if (ok) {\n      cout << \"SAFE\" << endl;\n      return;\n    }\n  } while (next_permutation(v.begin(), v.end()));\n  cout << \"SUSPICIOUS\" << endl;\n}\n\nint main() {\n  int n; cin >> n;\n  rep(i, 0, n) solve();\n}\n\n//////////////////////////////////////////////////////////////////////////\n//NOTE\n//////////////////////////////////////////////////////////////////////////\n// 一つのカバンに入っている物の数は7種類以下とわかっているので、\n// どんな順でx座標が大きくなっていくのかを、全通り試していければ良い.\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvoid solve() {\n    int H, W;\n    cin >> H >> W;\n\n    vector<string> S(H);\n    for (auto& s : S) cin >> s;\n\n    vector<vector<bool>> on(26, vector<bool>(26, false));\n    // on[x][y] => xがyより上にある\n\n    bool judge = true;\n    for (char c = 'A'; c <= 'Z'; ++c) {\n        int lx = W, rx = -1, ly = H, ry = -1;\n        for (int x = 0; x < H; ++x) {\n            for (int y = 0; y < W; ++y) {\n                if (S[x][y] != c) continue;\n                lx = min(lx, x), rx = max(rx, x);\n                ly = min(ly, y), ry = max(ry, y);\n            }\n        }\n\n        for (int x = lx; x <= rx; ++x) {\n            for (int y = ly; y <= ry; ++y) {\n                if (S[x][y] == '.') {\n                    judge = false;\n                } else if (S[x][y] != c) {\n                    // S[x][y]はcの上にある\n                    on[S[x][y] - 'A'][c - 'A'] = true;\n                }\n            }\n        }\n    }\n\n    bool update;\n    do {\n        update = false;\n        for (int k = 0; k < 26; ++k) {\n            for (int i = 0; i < 26; ++i) {\n                for (int j = 0; j < 26; ++j) {\n                    if (on[i][k] && on[k][j] && !on[i][j]) {\n                        update = true;\n                        on[i][j] = true;\n                    }\n                }\n            }\n        }\n    } while (update);\n\n    for (int i = 0; i < 26; ++i) {\n        if (on[i][i]) judge = false;\n    }\n\n    cout << (judge ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    for (int i = 0; i < N; ++i) solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stdlib.h>\n#include <map>\n#include <algorithm>\n#define llint long long\n#define inf 1e9\n\nusing namespace std;\n\nint T;\nint h, w;\nchar c[55][55];\nint a[55][55];\nmap<char, int> mp;\n\nint main(void)\n{\n  cin >> T;\n  for(int t = 0; t < T; t++){\n    cin >> h >> w;\n    mp.clear();\n    for(int y = 1; y <= h; y++){\n      for(int x = 1; x <= w; x++){\n        cin >> c[x][y];\n        if(c[x][y] != '.') mp[c[x][y]];\n      }\n    }\n\n    int id = 0;\n    for(auto it = mp.begin(); it != mp.end(); it++) it->second = id++;\n\n    for(int y = 1; y <= h; y++){\n      for(int x = 1; x <= w; x++){\n        if(c[x][y] == '.') a[x][y] = -1;\n        else a[x][y] = mp[c[x][y]];\n      }\n    }\n    int n = mp.size();\n\n    int perm[7], iperm[7];\n    for(int i = 0; i < n; i++) perm[i] = i;\n    bool ans = false;\n    do{\n      for(int i = 0; i < n; i++) iperm[perm[i]] = i;\n      bool flag = true;\n      for(int i = 0; i < n; i++){\n        int lx = inf, rx = -inf, ly = inf, ry = -inf;\n        for(int y = 1; y <= h; y++){\n          for(int x = 1; x <= w; x++){\n            if(a[x][y] == perm[i]){\n              lx = min(lx, x);\n              rx = max(rx, x);\n              ly = min(ly, y);\n              ry = max(ry, y);\n            }\n          }\n        }\n        for(int y = ly; y <= ry; y++){\n          for(int x = lx; x <= rx; x++){\n            if(a[x][y] == -1) flag = false;\n            else if(iperm[a[x][y]] < i) flag = false;\n          }\n        }\n      }\n      if(flag) ans = true;\n    }while(next_permutation(perm, perm+n));\n\n    if(ans) cout << \"SAFE\" << endl;\n    else cout << \"SUSPICIOUS\" << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nstruct make\n{\n\tchar str;\n\tint posi,start[2];\n\tint high,wide,JUDGE;//JUDGE==1で長方形,==0で長方形以外,==2で未定\n\tstruct make *front[8];\n};\n\n\nint main()\n{\n\tint N,H,W,count,COUNT,judge,no_rect,NO_RECT;\n\tchar img[1000][51];\n\tstruct make M[8];\n\tint s1,s2,num;\n\t\n\tscanf(\"%d\",&N);//データの個数\n\tfor(int a=0;a<N;a++)\n\t{\n\t\tcount=0;//材質の個数\n\t\tCOUNT=0;\n\t\tNO_RECT=0;\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tscanf(\"%s\",img[b]);\n\t\t\timg[b][W]='\\0';\n\t\t}\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tfor(int d=0;d<count;d++) M[d].posi=-1;\n\t\t\tfor(int c=0;c<W;c++)\n\t\t\t{\n\t\t\t\tif(img[b][c]!='.')\n\t\t\t\t{\n\t\t\t\t\t//材質判定\n\t\t\t\t\tjudge=0;\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t\tif(count>0 && img[b][c]!=M[judge].str) judge++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}while(judge<count);\n\t\t\t\t\t//新しい材質の場合\n\t\t\t\t\tif(judge==count)\n\t\t\t\t\t{\n\t\t\t\t\t\tM[count].str=img[b][c];\n\t\t\t\t\t\tM[count].start[0]=b;\n\t\t\t\t\t\tM[count].start[1]=c;\n\t\t\t\t\t\tM[count].posi=c;\n\t\t\t\t\t\tM[count].high=1;\n\t\t\t\t\t\tM[count].wide=1;\n\t\t\t\t\t\tM[count].JUDGE=0;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\t//既出の材質の場合\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(M[judge].start[1]>c) M[judge].start[1]=c;\n\t\t\t\t\t\tif(M[judge].posi<0) M[judge].posi=c;\n\t\t\t\t\t\telse if(M[judge].wide<c-M[judge].posi+1) M[judge].wide=c-M[judge].posi+1;\n\t\t\t\t\t\tM[judge].high=b-M[judge].start[0]+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tno_rect=count;\n\t\t//printf(\"count=%d\\n\",count);\n\t\t//判定開始\n\t\twhile(count)//文字アリ\n\t\t{\n\t\t\tCOUNT=0;\n\t\t\t//見えている部分が長方形かどうか判定\n\t\t\tfor(num=0;num<count;num++)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(M[num].JUDGE==1) continue;\n\t\t\t\tM[num].JUDGE=0;//長方形なら\n\t\t\t\t//printf(\"M[%d].str=%c\\nM[%d].high=%d\\nM[%d].wide=%d\\n\",num,M[num].str,num,M[num].high,num,M[num].wide);\n\t\t\t\t//printf(\"M[%d].start[0]=%d\\nM[%d].start[1]=%d\\n\",num,M[num].start[0],num,M[num].start[1]);\n\t\t\t\tfor(s1=0;s1<M[num].high;s1++)\n\t\t\t\t{\n\t\t\t\t\tfor(s2=0;s2<M[num].wide;s2++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//確実に長方形ではない場合\n\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]=='.')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNO_RECT=1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//長方形の可能性もある場合\n\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]!=M[num].str && img[s1+M[num].start[0]][s2+M[num].start[1]]!='#' )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//printf(\"s1=%d s2=%d\\n\",s1,s2);\n\t\t\t\t\t\t\tM[num].JUDGE=2;\n\t\t\t\t\t\t\tCOUNT++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(NO_RECT || M[num].JUDGE==2) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(NO_RECT || M[num].JUDGE==2) break;\n\t\t\t\t}\n\t\t\t\tif(NO_RECT) break;\n\t\t\t\t//長方形だった場合\n\t\t\t\tif(s1==M[num].high && s2==M[num].wide)\n\t\t\t\t{\n\t\t\t\t\tM[num].JUDGE=1;\n\t\t\t\t\tno_rect--;\n\t\t\t\t\tfor(int s1=0;s1<M[num].high;s1++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int s2=0;s2<M[num].wide;s2++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\timg[s1+M[num].start[0]][s2+M[num].start[1]]='#';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//printf(\"M[%d].JUDGE=%d\\n\\n\",num,M[num].JUDGE);\n\t\t\t\tfor(int n=0;n<num;)\n\t\t\t\t{\n\t\t\t\t\tif(M[num].JUDGE!=2 && M[num].JUDGE!=1) break;\n\t\t\t\t\tn++;\n\t\t\t\t\t//どれも長方形ではなかった場合\n\t\t\t\t\tif(n==num) NO_RECT=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t//printf(\"NO_RECT=%d\\n\",NO_RECT);\n\t\t\tif(NO_RECT==1) break;\n\t\t\t//printf(\"#no_rect=%d\\n\\n\\n\",no_rect);\n\t\t\t//すべて長方形\n\t\t\tif(no_rect==0) break;\n\t\t}\n\t\t//出力\n\t\tif(NO_RECT) printf(\"SUSPICIOUS\\n\");\n\t\telse if(no_rect) printf(\"SUSPICIOUS\\n\");\n\t\telse printf(\"SAFE\\n\");\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\ntemplate <typename T>\nvector<int> tpsort_Kahn(const vector< vector< T > > &g) {\n    const int V = g.size();\n    vector<int> indeg(V, 0);\n    stack<int> S;\n\n    rep(i,0,V) rep(j,0,g[i].size())\n        indeg[ g[i][j] ]++;\n    rep(i,0,V) if(indeg[i] == 0) S.push(i);\n\n    vector<int> ans;\n    while(S.size() > 0) {\n        int u = S.top(); S.pop();\n        ans.push_back(u);\n        rep(i,0,g[u].size()) {\n            indeg[ g[u][i] ]--;\n            if(indeg[ g[u][i] ] ==  0)\n                S.push( g[u][i] );\n        }\n    }\n    return ans;\n}\n\nint H, W;\nchar board[60][60];\nint min_x[35], max_x[35], min_y[35], max_y[35];\n\nsigned main() {\n    int DATA; cin >> DATA;\n    while(DATA--) {\n        // initialize\n        fill(min_x, min_x + 35, INF);\n        fill(min_y, min_y + 35, INF);\n\n        fill(max_x, max_x + 35, -1);\n        fill(max_y, max_y + 35, -1);\n\n        cin >> H >> W;\n        rep(i,0,H) rep(j,0,W) {\n            cin >> board[i][j];\n            if(board[i][j] == '.') continue;\n            int alph = board[i][j] - 'A';\n\n            chmin(min_x[alph], i);\n            chmin(min_y[alph], j);\n\n            chmax(max_x[alph], i+1);\n            chmax(max_y[alph], j+1);\n        }\n\n        bool ng = false;\n        vector< vector<int> > G(30);\n        rep(f,0,26) {\n            if(min_x[f] == INF) continue;\n            // printf(\"search: character %c\\n\", (char)('A' + f));\n            // printf(\"debug: min_x = %lld, max_x = %lld, min_y = %lld, max_y = %lld\\n\", min_x[f], max_x[f], min_y[f], max_y[f]);\n            rep(i,min_x[f],max_x[f]) {\n                rep(j,min_y[f],max_y[f]) {\n                    if(board[i][j] == '.') ng = true;\n                    else if(board[i][j] - 'A' != f) {\n                        int v = board[i][j] - 'A';\n                        G[f].push_back(v);\n                    }\n                }\n            }\n        }\n\n        vector<int> ans = tpsort_Kahn(G);\n        if(ans.size() != 30) ng = true;\n\n        cout << (ng ? \"SUSPICIOUS\" : \"SAFE\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define ALL(X) (X).begin(),(X).end()\n\nusing namespace std;\n\nconst int INF = 1000000000;\nconst double eps = 1e-8;\n\nint main(void) {\n\tint n;\n\tcin>>n;\n\tREP(i,n)\n\t{\n\t\tint h,w;\n\t\tcin>>h>>w;\n\t\tvector<string> table(h);\n\t\tset<char> s;\n\t\tREP(j,h)\n\t\t{\n\t\t\tcin>>table[j];\n\t\t\tREP(k,w)\n\t\t\t{\n\t\t\t\ts.insert(table[j][k]);\n\t\t\t}\n\t\t}\n\t\ts.erase('.');\n\t\tvector<char> mats;\n\t\tFORIT(j,s)\n\t\t\tmats.push_back(*j);\n\t\tif(mats.size())\n\t\t{\n\t\t\tbool flg = true;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tflg = true;\n\t\t\t\tvector<string> cp(h);\n\t\t\t\tREP(k,h)cp[k]=string(table[k]);\n\t\t\t\tREP(j,mats.size())\n\t\t\t\t{\n\t\t\t\t\tint top=h,bottom=0,left=w,right=0;\n\t\t\t\t\tREP(k,h)REP(l,w)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(cp[k][l] == mats[j])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttop=min(top,k);\n\t\t\t\t\t\t\tbottom=max(bottom,k);\n\t\t\t\t\t\t\tleft=min(left,l);\n\t\t\t\t\t\t\tright=max(right,l);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tFOR(k,top,bottom+1)\n\t\t\t\t\t{\n\t\t\t\t\t\tFOR(l,left,right+1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(cp[k][l]=='.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(cp[k][l]==mats[j])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcp[k][l] = '.';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!flg)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!flg)break;\n\t\t\t\t}\n\t\t\t\tif(flg)break;\n\t\t\t}while(next_permutation(ALL(mats)));\n\t\t\tif(flg)\n\t\t\t\tcout << \"SAFE\" << endl;\n\t\t\telse\n\t\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t\telse\n\t\t\tcout << \"SAFE\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nint main(){\n  int n; cin>>n;\n  while(n --> 0){\n    int w,h; cin>>h>>w;\n    char buff[h][w+1];\n    bool flag[30][30] = {{false}};\n    bool ans = true;\n    REP(i,h) cin>>buff[i];\n    for(char c = 'A'; c <= 'Z'; c++){\n      int cnt = 0;\n      int maxx = 0, maxy = 0;\n      int minx = w, miny = h;\n      REP(i,h) REP(j,w){\n        if(buff[i][j] == c){\n          cnt++;\n          maxx = max(maxx, j);\n          maxy = max(maxy, i);\n          minx = min(minx, j);\n          miny = min(miny, i);\n        }\n      }\n      if(cnt == 0) continue;\n      //printf(\"%c: (%d,%d) => (%d,%d)\\n\",c,minx,miny,maxx,maxy);\n      for(int i = miny; i<=maxy; i++){\n        for(int j = minx; j<=maxx; j++){\n          char tmp = buff[i][j];\n          if(tmp == c) continue;\n          if(tmp == '.'){\n            ans = false;\n            break;\n          }\n          if(flag[c-'A'][tmp-'A']){\n            ans = false;\n          }else{\n            flag[tmp-'A'][c-'A'] = true;\n          }\n        }\n      }\n      if(!ans) break;\n    }\n    if(ans){\n      REP(k,30)REP(i,30)REP(j,30)\n        flag[i][j] |= (flag[i][k] & flag[k][j]);\n      REP(i,30) REP(j,30)\n        if(flag[i][j] && flag[j][i])\n          ans = false;\n    }\n    puts(ans?\"SAFE\":\"SUSPICIOUS\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nvoid safe() { puts(\"SAFE\"); }\nvoid susp() { puts(\"SUSPICIOUS\"); }\n\nint NUM_CASES, H, W;\nstring img[55];\n\nint lft[26], top[26], rgt[26], bot[26];\nchar c_img[55][55];\n\nvoid solve() {\n\tfor_(i,0,26) {\n\t\tlft[i] = top[i] = 55;\n\t\trgt[i] = bot[i] = -1;\n\t}\n\t\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (img[y][x] != '.') {\n\t\t\tint c = img[y][x] - 'A';\n\t\t\tlft[c] = min(lft[c], x);\n\t\t\ttop[c] = min(top[c], y);\n\t\t\trgt[c] = max(rgt[c], x);\n\t\t\tbot[c] = max(bot[c], y);\n\t\t}\n\t}\n\t\n\tvector< int > obj;\n\tfor_(i,0,26) if (rgt[i] != -1) obj.push_back(i);\n\t\n\tif (obj.size() == 0) {\n\t\tsafe();\n\t\treturn;\n\t}\n\t\n\tdo {\n\t\tfor_(y,0,H) for_(x,0,W) c_img[y][x] = '.';\n\t\tfor (int o : obj) for_(y,top[o],bot[o]+1) for_(x,lft[o],rgt[o]+1) c_img[y][x] = char('A' + o);\n\t\tbool isok = true;\n\t\tfor_(y,0,H) for_(x,0,W) isok &= (img[y][x] == c_img[y][x]);\n\t\t\n\t\tif (isok) {\n\t\t\tsafe();\n\t\t\treturn;\n\t\t}\n\t} while (next_permutation(obj.begin(), obj.end()));\n\t\n\tsusp();\n}\n\nint main() {\n\tcin >> NUM_CASES;\n\tfor_(t,0,NUM_CASES) {\n\t\tcin >> H >> W;\n\t\tfor_(i,0,H) cin >> img[i];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing P = pair<ll, ll>;\nusing namespace std;\n\ntemplate<class t> void vin(vector<t>& v, int n) {\n    v.resize(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n}\n\nstruct rect {\n    int miw, maw, mih, mah;\n    rect() {}\n    rect(int h, int w) :miw(w), maw(w), mih(h), mah(h) {}\n    void update(int h, int w) {\n        miw = min(miw, w); maw = max(maw, w);\n        mih = min(mih, h); mah = max(mah, h);\n    }\n};\nint h, w;\nvector<string> bag;\nvector<string> tmp;\nvector<char> layer;\nmap<char, rect> rects;\n\nvoid fill(char type) {\n    rect rt = rects[type];\n    for (int y=rt.mih; y<=rt.mah; ++y) {\n        for (int x=rt.miw; x<=rt.maw; ++x) {\n            tmp[y][x] = type;\n        }\n    }\n    return;\n}\n\nbool is_safe() {\n    rep(r, h) rep(c, w) {\n        if (tmp[r][c] != bag[r][c]) return false;\n    }\n    return true;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    rep(i, n) {\n        cin >> h >> w;\n        bag.resize(h);\n        rects.clear();\n        layer.clear();\n\n        rep(r, h) {\n            cin >> bag[r];\n            rep(c, w) {\n                if (bag[r][c] == '.') continue;\n                if (rects.count(bag[r][c]) == 0) {\n                    rects[bag[r][c]] = rect(r, c);\n                    layer.push_back(bag[r][c]);\n                }\n                else {\n                    rects[bag[r][c]].update(r, c);\n                }\n            }\n        }\n\n        bool ok = false;\n        sort(layer.begin(), layer.end());\n        do {\n            tmp = bag;\n            rep(i, layer.size()) {\n                fill(layer[i]);\n            }\n            if (is_safe()) {\n                ok = true;\n                break;\n            }\n        } while (next_permutation(layer.begin(), layer.end()));\n\n        cout << (ok ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={1,0,0,-1,1,-1,-1,1};\nconst int dy[]={0,1,-1,0,1,1,-1,-1};\nconst int INF = 1e8;\nconst double EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fr first\n#define sc second\n#define reps(i,j,k) for(int i = (j); i < (k); ++i)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> Pii;\ntypedef pair<int,vi > P;\ntypedef unsigned long long ll;\nchar stage[52][52];\nint H,W;\nPii rect[8][2];\nvector < char > letter;\nbool isRect(int c){\n\treps(i,rect[c][0].fr,rect[c][1].fr+1){\n\t\treps(j,rect[c][0].sc,rect[c][1].sc+1){\n\t\t\tif(stage[i][j]  == letter[c] || stage[i][j] == '*'){\n\t\t\t\t;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nvoid fill(int c){\n\treps(i,rect[c][0].fr,rect[c][1].fr+1){\n\t\treps(j,rect[c][0].sc,rect[c][1].sc+1){\n\t\t\tstage[i][j] = '*';\n\t\t}\n\t}\n}\nint main(){\n    int N;\n    scanf(\"%d\",&N);\n    int x = 0;\n    while(N--){\n    \tletter.clear();\n    \trep(i,8){\n    \t\trect[i][0] = Pii(INF,INF);\n    \t\trect[i][1] = Pii(0,0);\n    \t}\n        scanf(\"%d%d\",&H,&W);\n        bool alpha_memo[128] = {false};\n        rep(i,H){\n            scanf(\"%s\",stage[i]);\n            rep(j,W){\n                alpha_memo[stage[i][j]] = true;\n            }\n        }\n \t\treps(i,'A','Z'+1){\n            if(alpha_memo[i]){\n                letter.PB(i);\n            }\n        }\n        rep(c,letter.size()){\n            rep(i,H){\n            \trep(j,W){\n            \t\tif(stage[i][j] == letter[c]){\n            \t\t\trect[c][0].fr = min(rect[c][0].fr,i);\n            \t\t\trect[c][0].sc = min(rect[c][0].sc,j);\n            \t\t\trect[c][1].fr = max(rect[c][1].fr,i);\n            \t\t\trect[c][1].sc = max(rect[c][1].sc,j);\n            \t\t\t\t\n            \t\t}\n            \t}\n            }\n        }\n        bool ans = true;\n        int cnt = letter.size();\n        while(cnt--){\n        \trep(i,letter.size()){\n        \t\tif(isRect(i)){\n        \t\t\tfill(i);\n        \t\t\t/*puts(\"******\");\n\t\t        \trep(i,H){\n\t\t\t        \trep(j,W){\n\t\t\t        \t\tprintf(\"%c\",stage[i][j]);\n\t\t\t        \t}\n\t\t\t        \tputs(\"\");\n\t\t\t        }*/\n        \t\t}\n        \t}\n        }\n\n        rep(i,H){\n        \trep(j,W){\n        \t\tif(isalpha(stage[i][j])){\n        \t\t\tans = false;\n        \t\t\tbreak;\n        \t\t}\n        \t}\n        \tif(!ans){\n        \t\tbreak;\n        \t}\n        }\n        ans ? puts(\"SAFE\") : puts(\"SUSPICIOUS\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint h,w;\nstring s[50];\nmain()\n{\n\tint t;cin>>t;\n\twhile(t--)\n\t{\n\t\tcin>>h>>w;\n\t\tfor(int i=0;i<h;i++)cin>>s[i];\n\t\tbool flag=1;\n\t\twhile(flag)\n\t\t{\n\t\t\tflag=0;\n\t\t\tfor(char c='A';c<='Z';c++)\n\t\t\t{\n\t\t\t\tint sx=h,sy=w,gx=0,gy=0;\n\t\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if(s[i][j]==c)\n\t\t\t\t{\n\t\t\t\t\tsx=min(sx,i);\n\t\t\t\t\tsy=min(sy,j);\n\t\t\t\t\tgx=max(gx,i);\n\t\t\t\t\tgy=max(gy,j);\n\t\t\t\t}\n\t\t\t\tbool f=sx<=gx&&sy<=gy;\n\t\t\t\tfor(int i=sx;f&&i<=gx;i++)for(int j=sy;f&&j<=gy;j++)\n\t\t\t\t{\n\t\t\t\t\tif(!(s[i][j]==c||s[i][j]=='?'))f=false;\n\t\t\t\t}\n\t\t\t\tif(f)\n\t\t\t\t{\n\t\t\t\t\tflag=true;\n\t\t\t\t\tfor(int i=sx;i<=gx;i++)for(int j=sy;j<=gy;j++)s[i][j]='?';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ans=true;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)\n\t\t{\n\t\t\tif(s[i][j]!='.'&&s[i][j]!='?')ans=false;\n\t\t}\n\t\tcout<<(ans?\"SAFE\":\"SUSPICIOUS\")<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 110\n\nbool solve(){\n  int h,w;\n  char c[SIZE][SIZE];\n  string s;\n  bool f[26] = {};\n  \n  scanf(\"%d%d\",&h,&w);\n\n  if(h == 0) return false;\n\n  for(int i=0;i<h;i++){\n    scanf(\"%s\",c[i]);\n\n    for(int j=0;j<w;j++){\n      if(f[c[i][j]-'A'] == false){\n        f[c[i][j]-'A'] = true;\n        s += c[i][j];\n      }\n    }\n  }\n\n  sort(s.begin(),s.end());\n  \n  do{\n    char copy_c[SIZE][SIZE];\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        copy_c[i][j] = c[i][j];\n      }\n    }\n\n    bool check = true;\n\n    for(int p=0;p<s.size();p++){\n      int min_h = INF, max_h = -1 ,min_w = INF,max_w = -1;\n      \n      for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n          if(copy_c[i][j] == s[p]){\n            min_h = min(min_h, i);\n            max_h = max(max_h, i);\n            min_w = min(min_w, j);\n            max_w = max(max_w, j);\n          }\n        }\n      }\n\n      for(int i=min_h;i<=max_h;i++){\n        for(int j=min_w;j<=max_w;j++){\n          if(copy_c[i][j] != s[p] && copy_c[i][j] != '#')\n            check = false;\n          copy_c[i][j] = '#';\n        }\n      }\n      \n    }\n\n    if(check){\n      puts(\"SAFE\");\n      return true;\n    }\n    \n  }while(next_permutation(s.begin(),s.end()));\n  \n  puts(\"SUSPICIOUS\");\n  return true;\n\n}\n\nint main(){\n  int t;\n\n  scanf(\"%d\",&t);\n  \n  while(t--) solve();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint N;\nvector<string> g;\nint used[128],x1[128],x2[128],y1[128],y2[128];\nvector<int> p;\n\nvector<char> v;\nbool bt(){\n\n\tfor(int k=0;k<p.size();k++){\n\t\tfor(int i=y1[p[k]];i<=y2[p[k]];i++){\n\t\t\tfor(int j=x1[p[k]];j<=x2[p[k]];j++){\n\t\t\t\tchar c = g[i][j];\n\t\t\t\tif(c == '.')return false;\n\t\t\t\tif(find(p.begin(),p.end(),p[k]) > find(p.begin(),p.end(),c)){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\n\tfor(int k=0;k<v.size();k++){\n\t\tif(!used[v[k]]){\n\t\t\tused[v[k]] = true;\n\t\t\tp.push_back(v[k]);\n\t\t\tif( bt() ) return true;\n\t\t\tp.pop_back();\n\t\t\tused[v[k]] = false;\n\t\t}\n\t}\n\treturn p.size() == v.size();\n}\nint main(){\n\tint T;\n\t\n\tcin >> T;\n\twhile(T--){\n\t\tint W,H;\n\t\tcin >> H >> W;\n\t\tvector<string> data(H);\n\t\tfor(int i=0;i<H;i++)\n\t\t\tcin >> data[i];\n\t\t\t\n\t\tg = data;\n\t\t\n\t\tint check[128];\n\t\t\n\t\tfor(int i=0;i<128;i++)\n\t\t\tx1[i] = x2[i] = y1[i] = y2[i] = used[i] = check[i] = 0;\n\n\t\tfor(int i=0;i<128;i++)\n\t\t\tx1[i] = y1[i] = 9999;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tchar c = data[i][j];\n\t\t\t\tif(c != '.'){\n\t\t\t\t\tcheck[c] = true;\n\t\t\t\t\tx1[c] = min(j,x1[c]);\n\t\t\t\t\tx2[c] = max(j,x2[c]);\n\t\t\t\t\ty1[c] = min(i,y1[c]);\n\t\t\t\t\ty2[c] = max(i,y2[c]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tv.clear();\n\t\tp.clear();\n\t\t\n\t\tfor(int i=0;i<128;i++)\n\t\t\tif(check[i])v.push_back(i);\n\n\t\t\t\n\t\tcout << ( bt() ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<map>\n#include<cassert>\n\nusing namespace std;\n\nconst int MAX = 51;\nconst int GOODS = 8;\nstruct data{\n  char c;\n  int maxX,maxY,minX,minY;\n};\nvector<data> V;\nmap<char,int> M;\nbool come[MAX][MAX];\nchar field[MAX][MAX];\nint W,H,cnt;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nbool Edge[GOODS][GOODS];\n\nvoid init(){\n  cnt=0;\n  V.clear();\n  M.clear();\n  memset(come,false,sizeof(come));\n  memset(Edge,false,sizeof(Edge));\n}\n\nvoid input(){\n  cin >> H >> W;\n  for(int i = 0; i < H; i++)\n    for(int j = 0; j < W; j++) cin >> field[i][j];\n}\n\nvoid set(char c, int x, int y){\n  for(int i = 0; i < V.size(); i++)\n    if(c == V[i].c){\n      V[i].maxX = max(V[i].maxX,x);\n      V[i].maxY = max(V[i].maxY,y);\n      V[i].minX = min(V[i].minX,x);\n      V[i].minY = min(V[i].minY,y);\n      return;\n    }\n  \n  V.push_back((data){c,x,y,x,y});\n  M[c] = ++cnt;\n}\n\nbool isInside(int x, int y){ return 0<=x&&x<W&&0<=y&&y<H;}\n\nvoid rec(int x, int y, char c){\n  \n  if(come[y][x]) return;\n  come[y][x] = true;\n  set(c,x,y);\n\n  for(int i = 0; i < 4; i++){\n    int nx = x+dx[i];\n    int ny = y+dy[i];\n    if(isInside(nx,ny) && field[ny][nx] == c) rec(nx,ny,c);\n  }\n}\n\nbool check(data d){\n  for(int i = d.minY; i <= d.maxY; i++)\n    for(int j = d.minX; j <= d.maxX; j++)\n      if(field[i][j] == '.') return false;\n      else if(d.c != field[i][j]) Edge[M[d.c]][M[field[i][j]]] = true;\n  return true;\n}\n\nbool circle(){\n\n  for(int i = 1; i <= cnt; i++)\n    for(int j = 1; j <= cnt; j++)\n      for(int k = 1; k <= cnt; k++) Edge[i][j] = Edge[i][j]||Edge[i][k]&&Edge[k][j];\n\n  for(int i = 1; i <= cnt; i++)\n    if(Edge[i][i]) return true;\n  return false;\n}\n\nvoid solve(){\n  for(int i = 0; i < H; i++)\n    for(int j = 0; j < W; j++)\n      if(!come[i][j] && field[i][j] != '.') rec(j,i,field[i][j]);\n    \n\n  for(int i = 0; i < V.size(); i++)\n    if(!check(V[i])){\n      cout << \"SUSPICIOUS\" << endl;\n      return;\n    }\n\n  if(!circle()) cout << \"SAFE\" << endl;\n  else cout << \"SUSPICIOUS\" << endl;\n}\n\nint main(){\n  int T;\n  cin >> T;\n  while(T--){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nint H, W;\nchar grid[51][51];\n\nstruct Data {\n    int id, top, left, down, right;\n    Data() {\n        id = -1;\n        top = left = -1;\n        down = right = 100;\n    }\n};\n\nbool Loop(int dst, int src, const vector<vector<int>> &g,\n          vector<bool> &visit)\n{\n    if (dst == src)\n        return true;\n\n    if (visit[src])\n        return false;\n\n    visit[src] = true;\n    for (unsigned i = 0; i < g[src].size(); ++i) {\n        if (Loop(dst, g[src][i], g, visit))\n            return true;\n    }\n\n    return false;\n}\n\nbool Solve()\n{\n    unordered_map<char, Data> hash;\n    int id = 0;\n\n    // 登録\n    for (int i = 0; i < H; ++i)\n        for (int j = 0; j < W; ++j)\n            if (grid[i][j] != '.') {\n                char c = grid[i][j];\n\n                if (hash.count(c) == 0) {  // 未登録\n                    hash[c].id = id++;\n                    hash[c].top = hash[c].down = i;\n                    hash[c].left = hash[c].right = j;\n                }\n                else { // 登録済み\n                    hash[c].top = min(hash[c].top, i);\n                    hash[c].down = max(hash[c].down, i);\n                    hash[c].left = min(hash[c].left, j);\n                    hash[c].right = max(hash[c].right, j);\n                }\n            }\n\n    vector<vector<int>> g(id, vector<int>());\n    // 長方形の確認\n    auto it = hash.begin();\n    while (it != hash.end()) {\n        for (int y = it->second.top; y <= it->second.down; ++y)\n            for (int x = it->second.left; x <= it->second.right; ++x) {\n                int src = it->second.id;\n\n                if (grid[y][x] == '.')\n                    return false;\n                else if (grid[y][x] != it->first &&\n                         count(g[src].begin(), g[src].end(),\n                               hash[grid[y][x]].id) == 0)\n                    g[src].push_back(hash[grid[y][x]].id);\n            }\n        ++it;\n    }\n\n    // ループが存在するかのチェック\n    for (unsigned i = 0; i < g.size(); ++i)\n        for (unsigned j = 0; j < g[i].size(); ++j) {\n            vector<bool> visit(id, false);\n            visit[i] = true;\n\n            if (Loop(i, g[i][j], g, visit))\n                return false;\n        }\n\n    return true;\n}\n\nint main()\n{\n    int T;\n\n    cin >> T;\n    while (T--) {\n        cin >> H >> W;\n\n        for (int i = 0; i < H; ++i)\n            for (int j = 0; j < W; ++j)\n                cin >> grid[i][j];\n\n        if (Solve())\n            cout << \"SAFE\\n\";\n        else\n            cout << \"SUSPICIOUS\\n\";\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n#define USE_MATH_DEFINES\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 30;\nconst double EPS = 1E-9;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\n\nint h, w;\nchar field[50][50];\nbool used[50][50];\nbool per[8];\nchar ma[8];\nmap<char, int> mp;\nint c;\n\nbool dfs(int n, int rest){\n\tif(n == 0) {\n\t\treturn rest == 0 ? true : false;\n\t}\n\tbool res = false;\n\tfor(int i = 1; i < c; i++){\n\t\tif(per[i]) continue;\n\t\telse{\n\t\t\tper[i] = true;\n\t\t\tint ymax = 0;\n\t\t\tint ymin = INF;\n\t\t\tint xmax = 0;\n\t\t\tint xmin = INF;\n\t\t\tbool f = true;\n\t\t\tint cnt = 0;\n\t\t\tfor(int j = 0; j < h; j++){\n\t\t\t\tfor(int k = 0; k < w; k++){\n\t\t\t\t\tif(mp[field[j][k]] == i){\n\t\t\t\t\t\tymax = max(ymax, j);\n\t\t\t\t\t\tymin = min(ymin, j);\n\t\t\t\t\t\txmax = max(xmax, k);\n\t\t\t\t\t\txmin = min(xmin, k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = ymin; j <= ymax; j++){\n\t\t\t\tfor(int k = xmin; k <= xmax; k++){\n\t\t\t\t\tif(per[mp[field[j][k]]]){\n\t\t\t\t\t\tif(mp[field[j][k]] == i) cnt++;\n\t\t\t\t\t}else f = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tres |= dfs(n-1, rest - cnt);\n\t\t\t\tper[i] = false;\n\t\t\t}else{\n\t\t\t\tper[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n ;\n\tcin >> n;\n\twhile(n--){\n\t\tcin >> h >> w;\n\t\tmp.clear();\n\t\tc = 1;\n\t\tint cnt = 0;\n\t\tfor(int i = 0;i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tif(field[i][j] != '.') cnt++;\n\t\t\t\tif(mp[field[i][j]] == 0 && field[i][j] != '.') mp[field[i][j]] = c++;\n\t\t\t}\n\t\t}\n\t\tmemset(per, false, sizeof(per));\n\t\tbool safe = dfs(c-1, cnt);\n\t\tif(safe){\n\t\t\tcout << \"SAFE\" << endl;\n\t\t}else{\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring S[] = {\"SUSPICIOUS\", \"SAFE\"};\n\nint h, w;\nstring grid[50];\nint sx[1 << 8], ex[1 << 8], sy[1 << 8], ey[1 << 8];\nint g[26][26];\n\nstring solve()\n{\n\tfor (int i = 0; i < (1 << 8); i++){\n\t\tsx[i] = sy[i] = 50;\n\t\tex[i] = ey[i] = 0;\n\t}\n\tfill_n(*g, 26 * 26, 1 << 28);\n\tfor (int i = 0; i < 26; i++) g[i][i] = 0;\n\t\n\tfor (int i = 0; i < h; i++){\n\t\tfor (int j = 0; j < w; j++){\n\t\t\tchar c = grid[i][j];\n\t\t\tsx[c] = min(sx[c], i);\n\t\t\tsy[c] = min(sy[c], j);\n\t\t\tex[c] = max(ex[c], i);\n\t\t\tey[c] = max(ey[c], j);\n\t\t}\n\t}\n\t\n\tfor (char c = 'A'; c <= 'Z'; c++){\n\t\tfor (int x = sx[c]; x <= ex[c]; x++){\n\t\t\tfor (int y = sy[c]; y <= ey[c]; y++){\n\t\t\t\tif (grid[x][y] == '.'){\n\t\t\t\t\treturn S[0];\n\t\t\t\t}\n\t\t\t\telse if (grid[x][y] != c){\n\t\t\t\t\tg[c - 'A'][grid[x][y] - 'A'] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int k = 0; k < 26; k++){\n\t\tfor (int i = 0; i < 26; i++){\n\t\t\tfor (int j = 0; j < 26; j++){\n\t\t\t\tg[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < 26; i++){\n\t\tif (g[i][i] < 0){\n\t\t\treturn S[0];\n\t\t}\n\t}\n\treturn S[1];\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\", &h, &w);\n\t\t\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tcin >> grid[i];\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int AtoZ = 'Z'-'A'+1;\nstruct limbox{\n    int u,d,l,r;\n    limbox():u(100),d(-1),l(100),r(-1){}\n};\n\nvector<vector<bool> > o;\nvector<bool> s;\nvector<bool> c;\n\nbool check(int k){\n    if(s[k]) return true;\n    if(c[k]) return false;\n    c[k] = true;\n    for(int i=0; i<AtoZ; i++){\n        if(o[k][i] && !check(i)){\n            return false;\n        }\n    }\n    c[k] = false;\n    s[k] = true;\n    return true;\n}\n            \n\nint main(){\n    int n;\n    cin >> n;\n\n    for(int rep=0; rep<n; rep++){\n        int h,w;\n        cin >> h >> w;\n        vector<vector<char> > mat(h, vector<char>(w));\n        vector<limbox> dom(AtoZ);\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                cin >> mat[i][j];\n                if(mat[i][j]!='.'){\n                    int c = mat[i][j] - 'A';\n                    dom[c].u = min(dom[c].u, i);\n                    dom[c].d = max(dom[c].d, i);\n                    dom[c].l = min(dom[c].l, j);\n                    dom[c].r = max(dom[c].r, j);\n                }\n            }\n        }\n\n        vector<vector<bool> > ovl(AtoZ, vector<bool>(AtoZ, false));\n        vector<bool> safe(AtoZ, true);\n        bool suspicious = false;\n        for(int k=0; k<AtoZ; k++){\n            for(int i=dom[k].u; i<=dom[k].d; i++){\n                for(int j=dom[k].l; j<dom[k].r; j++){\n                    if(mat[i][j]=='.'){\n                        suspicious = true;\n                        safe[k] = false;\n                    }else if(mat[i][j] != 'A'+k){\n                        ovl[k][mat[i][j]-'A'] = true;\n                        safe[k] = false;\n                    }\n                }\n            }\n        }\n        if(suspicious){\n            cout << \"SUSPICIOUS\" << endl;\n            continue;\n        }\n\n        vector<bool> checking(AtoZ, false);\n        o = ovl;\n        s = safe;\n        c = checking;\n        for(int i=0; i<AtoZ; i++){\n            if(!check(i)){\n                suspicious = true;\n            }\n        }\n        if(!suspicious){\n            cout << \"SAFE\" << endl;\n        }else{\n            cout << \"SUSPICIOUS\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){\n    rep(i,v.size()) os << v[i] << (i+1==v.size()?\"\":\" \");\n    return os;\n}\n\nll lx[256], rx[256], ly[256], ry[256];\nint h,w;\nchar g[55][55];\n\nint main(){\n    int n; cin >> n;\n    while(n--){\n        cin >> h >> w;\n        rep(i,h) cin >> g[i];\n        loop(i,'A','Z'+1){\n            lx[i] = ly[i] = 1000;\n            rx[i] = ry[i] = -1;\n        }\n        rep(i,h)rep(j,w){\n            lx[g[i][j]] = min(j, lx[g[i][j]]);\n            ly[g[i][j]] = min(i, ly[g[i][j]]);\n            rx[g[i][j]] = max(j, rx[g[i][j]]);\n            ry[g[i][j]] = max(i, ry[g[i][j]]);\n        }\n        while(1){\n            bool update = false;\n            loop(c,'A','Z'+1){\n                if(lx[c]==1000) continue;\n                bool rect = true;\n                loop(i,ly[c],ry[c]+1){\n                    loop(j,lx[c],rx[c]+1){\n                        if(g[i][j]!=c && g[i][j]!='-'){\n                            rect = false;\n                            goto OUT;\n                        }\n                    }\n                }\n            OUT:;\n                if(!rect) continue;\n                loop(i,ly[c],ry[c]+1){\n                    loop(j,lx[c],rx[c]+1){\n                        g[i][j] = '-';\n                    }\n                }\n                update = true;\n                lx[c] = 1000;\n            }\n            if(!update) break;\n        }\n        bool ok = true;\n        loop(i,'A','Z'+1) if(lx[i]!=1000) ok = false;\n        puts(ok ? \"SAFE\" : \"SUSPICIOUS\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\ntypedef long long ll;\n\nint h,w;\nchar mp[52][52];\nbool hid[52][52];\n\nvoid solve(){\n  scanf(\"%d%d\",&h,&w);\n  REP(i,h)scanf(\"%s\",mp[i]);\n  set<char> S;\n  REP(i,h)REP(j,w)if(mp[i][j]!='.')S.insert(mp[i][j]);\n  int n = S.size();\n  if(n==0){\n    puts(\"SAFE\");\n    return;\n  }\n  vector<int> p(n);\n  REP(i,n)p[i] = i;\n  vector<char> cc;\n  for(char c : S){\n    cc.push_back(c);\n  }\n  do{\n    REP(i,h)REP(j,w)hid[i][j] = false;\n    bool ok = true;\n    REP(x,n){\n      char c = cc[p[x]];\n      int umost = w, dmost = 0, lmost = w, rmost = 0;\n      REP(i,h)REP(j,w)if(mp[i][j]==c){\n        umost = min(umost, i);\n        dmost = max(dmost, i);\n        lmost = min(lmost, j);\n        rmost = max(rmost, j);\n      }\n      // printf(\"%d %d %d %d\\n\",umost,dmost,lmost,rmost);\n      for(int i=umost; i<=dmost; i++){\n        for(int j=lmost; j<=rmost; j++){\n          if(mp[i][j] == c){\n            hid[i][j] = true;\n          }\n          if(!hid[i][j]){\n            ok = false;\n          }\n        }\n      }\n      if(!ok)break;\n    }\n    if(ok){\n      puts(\"SAFE\");\n      return;\n    }\n    // break;\n  }while(next_permutation(p.begin(), p.end()));\n  puts(\"SUSPICIOUS\");\n  return;\n}\n\nint main(){\n  int t;\n  scanf(\"%d\",&t);\n  while(t--)solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nusing namespace std;\n\n#define MAX 50\n\nint main(){\n\n\tint n;\n\tint H,W;\n\n\tstring pict[MAX];\n\tint zai['Z'-'A'+1][MAX][MAX];\n\t/*\n\t0..??????\n\t1..?????????\n\t2..??°\n\t3..??????\n\t*/\n\tbool zok['Z'-'A'+1];\n\n\tcin>>n;\n\twhile(n--){\n\t\tcin>>H>>W;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tcin>>pict[i];\n\t\t}\n\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tfor(int k=0;k<='Z'-'A';k++){\n\t\t\t\t\tzai[k][i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<='Z'-'A';i++){\n\t\t\tzok[i]=false;\n\t\t}\n\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tif(pict[i][j]!='.'){\n\t\t\t\t\tzai[pict[i][j]-'A'][i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(1){\n\t\t\tbool ex=true;\n\t\t\tfor(int i=0;i<='Z'-'A';i++){\n\t\t\t\tif(zok[i]) continue;\n\t\t\t\tbool fok=true;\n\t\t\t\tfor(int j=0;j<H;j++){\n\t\t\t\t\tfor(int k=0;k<W;k++){\n\t\t\t\t\t\tif(zai[i][j][k]==1) fok=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(fok) zok[i]=true;\n\t\t\t}\n\t\t\tfor(int i=0;i<='Z'-'A';i++){\n\t\t\t\tif(zok[i]) continue;\n\t\t\t\tfor(int j=0;j<H;j++){\n\t\t\t\t\tfor(int k=0;k<W;k++){\n\t\t\t\t\t\tif(zai[i][j][k]==1){\n\t\t\t\t\t\t\tint lz=0;\n\t\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\t\tif(k-lz==0) break;\n\t\t\t\t\t\t\t\tif(zai[i][j][k-lz-1]!=0) lz++;\n\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint fu=-1;\n\t\t\t\t\t\t\tint fuu=-1;\n\t\t\t\t\t\t\tint dzz=-1;\n\t\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\t\tif(k-lz==W) break;\n\t\t\t\t\t\t\t\tint dz=0;\n\t\t\t\t\t\t\t\tbool ff=false;\n\t\t\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\t\t\tif(j+dz==H-1) break;\n\t\t\t\t\t\t\t\t\tif(fu!=-1&&zai[i][j+dz][k-lz]==1&&dz>=fu) break;\n\t\t\t\t\t\t\t\t\tif(zai[i][j+dz][k-lz]==1) zai[i][j+dz][k-lz]=3,ff=true,dzz=dz;\n\t\t\t\t\t\t\t\t\tif(zai[i][j+dz][k-lz]!=0) dz++;\n\n\t\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif(fu==-1){\n\t\t\t\t\t\t\t\t\tif(ff) fu=dz,fuu=dzz;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tif(fuu>dz){\n\t\t\t\t\t\t\t\t\t\twhile(dz!=-1){\n\t\t\t\t\t\t\t\t\t\t\tif(zai[i][j+dz][k-lz]==3) zai[i][j+dz][k-lz]=1;\n\t\t\t\t\t\t\t\t\t\t\tdz--;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlz--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbool okf=true;\n\t\t\t\t\t\t\tfor(int m=0;m<H;m++){\n\t\t\t\t\t\t\t\tfor(int o=0;o<W;o++){\n\t\t\t\t\t\t\t\t\tif(zai[i][m][o]==1) okf=false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(okf){\n\t\t\t\t\t\t\t\tex=false;\n\t\t\t\t\t\t\t\tfor(int m=0;m<H;m++){\n\t\t\t\t\t\t\t\t\tfor(int o=0;o<W;o++){\n\t\t\t\t\t\t\t\t\t\tif(zai[i][m][o]==3){\n\t\t\t\t\t\t\t\t\t\t\tfor(int p=0;p<='Z'-'A';p++){\n\t\t\t\t\t\t\t\t\t\t\t\tzai[p][m][o]=2;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tzai[i][m][o]=0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tfor(int m=0;m<H;m++){\n\t\t\t\t\t\t\t\t\tfor(int o=0;o<W;o++){\n\t\t\t\t\t\t\t\t\t\tif(zai[i][m][o]==3) zai[i][m][o]=1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tj=99;\n\t\t\t\t\t\t\tk=99;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ex) break;\n\t\t}\n\t\tbool ansf=true;\n\t\tfor(int i=0;i<='Z'-'A';i++){\n\t\t\tfor(int j=0;j<H;j++){\n\t\t\t\tfor(int k=0;k<W;k++){\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!zok[i]) ansf=false;\n\t\t}\n\t\tif(ansf) cout<<\"SAFE\"<<endl;\n\t\telse cout<<\"SUSPICIOUS\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ppii pair<pair<int,int>,pair<int,int>>\nusing namespace std;\n\nint h,w;\nvector<string> s;\n\nppii removeRect(char c){\n\tint minx = 50;\n\tint miny = 50;\n\tint maxx = 0;\n\tint maxy = 0;\n\tint cnt = 0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[i][j]==c){\n\t\t\t\tminx = min(minx,j);\n\t\t\t\tmaxx = max(maxx,j);\n\t\t\t\tminy = min(miny,i);\n\t\t\t\tmaxy = max(maxy,i);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\t//cout << cnt << \" \" << maxx-minx << \" \" << maxy-miny << endl;\n\tif(cnt != (maxx-minx+1)*(maxy-miny+1))return make_pair(make_pair(0,0),make_pair(0,0));\n\tfor(int i=miny;i<=maxy;i++){\n\t\tfor(int j=minx;j<=maxx;j++){\n\t\t\ts[i][j] = '.';\n\t\t}\n\t}\n\treturn make_pair(make_pair(minx,miny),make_pair(maxx,maxy));\n}\n\nvoid fillRect(char c,ppii p){\n\tint minx = 50;\n\tint miny = 50;\n\tint maxx = 0;\n\tint maxy = 0;\n\tint cnt = 0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[i][j]==c){\n\t\t\t\tminx = min(minx,j);\n\t\t\t\tmaxx = max(maxx,j);\n\t\t\t\tminy = min(miny,i);\n\t\t\t\tmaxy = max(maxy,i);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=miny;i<=maxy;i++){\n\t\tfor(int j=minx;j<=maxx;j++){\n\t\t\tif(p.first.first <= j && j<= p.second.first && p.first.second <= i && i <= p.second.second){\n\t\t\t\tif(s[i][j] == '.') s[i][j] = c;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool isEmpty(){\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[i][j] != '.') return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid show(){\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcout << s[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\ts.clear();\n\t\tcin >> h >> w;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\ts.emplace_back(str);\n\t\t}\n\t\tint cnt=0;\n\t\twhile(!isEmpty() && cnt<=25){\n\t\t\tchar c;\n\t\t\tfor(c='A';c<='Z';c++){\n\t\t\t\t//cout << c << endl;\n\t\t\t\tppii p = removeRect(c);\n\t\t\t\tfor(int c2 = 'A';c2<='Z';c2++){\n\t\t\t\t\tfillRect(c2,p);\n\t\t\t\t}\n\t\t\t\t//show();\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t\tif(isEmpty()){\n\t\t\tcout << \"SAFE\" << endl;\n\t\t} else {\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool ans;\n\n// 文字cの出現するx,y座標の最大値と最小値の保持に使う\nstruct range{\n\tint min_x, min_y, max_x, max_y;\n\trange(int min_x_ , int min_y_ , int max_x_ , int max_y_ ){\n\t\tmin_x = min_x_;\n\t\tmin_y = min_y_;\n\t\tmax_x = max_x_;\n\t\tmax_y = max_y_;\n\t}\n};\n\nvoid debug(const vector<string>& m){\n\tcout << \"[debug]\" << endl;\n\tfor(int y=0 ; y < m.size() ; y++ ){\n\t\tcout << m[y] << endl;\n\t}\n\tcout << endl;\n}\n\nvoid debug2(const vector<char>& vc, const vector<range>& vr){\n\tfor(int i=0 ; i < vc.size() ; i++ ){\n\t\trange r = vr[i];\n\t\tcout << vc[i] << \" \" << endl;\n\t\tcout << \"x => [\" << r.min_x << \",\" << r.max_x << \"] \";\n\t\tcout << \"y => [\" << r.min_y << \",\" << r.max_y << \"] \";\n\t\tcout << endl << endl;\n\t}\n}\n\n// 文字 c の出現する x,y 座標の最大値と最小値を求める\nrange search_range(const vector<string>& m, char c){\n\tint h = m.size();\n\tint w = m[0].size();\n\t\n\tint min_x = -1, min_y = -1, max_x = -1, max_y = -1;\n\tfor(int y = 0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( m[y][x] == c ){\n\t\t\t\tmin_x = (min_x == -1)? x : min( min_x , x );\n\t\t\t\tmin_y = (min_y == -1)? y : min( min_y , y );\n\t\t\t\tmax_x = (max_x == -1)? x : max( max_x , x );\n\t\t\t\tmax_y = (max_y == -1)? y : max( max_y , y );\n\t\t\t}\n\t\t}\n\t}\n\trange r( min_x , min_y , max_x , max_y );\n\treturn r;\n}\n\n// 文字 c について長方形かどうか\nbool check(const vector<string>& m, range r, char c){\n\tint cnt = 0;\n\tfor(int y = r.min_y ; y <= r.max_y ; y++ ){\n\t\tfor(int x = r.min_x ; x <= r.max_x ; x++ ){\n\t\t\tif( m[y][x] == c || m[y][x] == '*' ){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//cout << \"search \" << c << \" cnt : \" << cnt << endl;\n\t//cout << \"(\" << r.min_x << \",\" << r.min_y << \") => (\" << r.max_x << \",\" << r.max_y << \")\" << endl; \n\t\n\tif( cnt != (r.max_x - r.min_x + 1) * (r.max_y - r.min_y + 1) ){\n\t\treturn false;\n\t}\n\t\n\tfor(int y = 0 ; y < m.size() ; y++ ){\n\t\tfor(int x = 0 ; x < m[y].size() ; x++ ){\n\t\t\tif( r.min_x <= x && r.min_y <= y && x <= r.max_x && y <= r.max_y ){\n\t\t\t}else if( m[y][x] == c ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\n// 文字 c を' *' に置き換える (荷物を取り除く) \nvoid remove(vector<string>& m, range r, char c){\n\tfor(int y = r.min_y ; y <= r.max_y ; y++ ){\n\t\tfor(int x = r.min_x ; x <= r.max_y ; x++ ){\n\t\t\tif( m[y][x] == c ){\n\t\t\t\tm[y][x] = '*';\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(int id, vector<bool> memo, vector<string> m, vector<char> vc, vector<range> vr){\n\tmemo[id] = true;\n\t\n\t// 長方形かどうか\n\tbool is_rect = check( m , vr[id] , vc[id] );\n\tif( is_rect == false ){\n\t\treturn;\n\t}\n\t\n\t// 文字 vc[id] を '*' に置き換える (荷物を取り除く) \n\tremove( m , vr[id] , vc[id] );\n\t\n\t//cout << vc[id] << \" is rectangle! \" << endl;\n\t//debug( m );\n\t\n\t// すべて調べたかどうか\n\tint cnt = 0;\n\tfor(int i=0 ; i < memo.size() ; i++ ){\n\t\tif( memo[i] )\n\t\t\tcnt++;\n\t}\n\tif( cnt == memo.size() && is_rect ){\n\t\tans = true;\n\t\treturn;\n\t}\n\t\n\tfor(int i=0 ; i < memo.size() ; i++ ){\n\t\tif( memo[i] == false ){\n\t\t\t//cout << \"next : \" << vc[i] << endl;\n\t\t\tdfs( i , memo , m , vc , vr );\n\t\t}\n\t}\n}\n\nvoid solve(const vector<string>& m){\n\tchar ch[256] = {0};\n\tvector<char> vc;\n\tvector<range> vr;\n\tint h = m.size();\n\tint w = m[0].size();\n\tans = false;\n\t\n\t// 出現する文字を調べる\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( m[y][x] >= 'A' && m[y][x] <= 'Z' ){\n\t\t\t\tch[ m[y][x] ] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(char c = 'A' ; c <= 'Z' ; c++ ){\n\t\tif( ch[c] )\n\t\t\tvc.push_back( c );\n\t}\n\t\n\t// 文字がなかったら \"SAFE\"\n\tif( vc.size() == 0 ){\n\t\tans = true;\n\t}\n\t\n\t// 各文字 c について x,y 座標の最大値と最小値を求める\n\tfor(int i=0 ; i < vc.size() ; i++ ){\n\t\trange r = search_range( m , vc[i] );\n\t\tvr.push_back( r );\n\t}\n\t//debug2( vc , vr );\n\t\n\t// DFSで重なる順番をすべて調べる\n\tvector<bool> memo( vc.size() );\n\tfor(int k=0 ; k < vc.size() ; k++ ){\n\t\tfor(int i=0 ; i < memo.size() ; i++ ){\n\t\t\tmemo[i] = false;\n\t\t}\n\t\tdfs( k , memo , m , vc , vr );\n\t}\n\t\n}\n\nint main(){\n\tint T;\n\tcin >> T;\n\tfor(int t_ = 0 ; t_ < T ; t_++ ){\n\t\tint w, h;\n\t\tcin >> h >> w;\n\t\t\n\t\tvector<string> m(h);\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> m[y];\n\t\t}\n\t\t\n\t\tsolve( m );\n\t\t\n\t\tif( ans ){\n\t\t\tcout << \"SAFE\" << endl;\n\t\t}else{\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool ans;\n\n// 文字cの出現するx,y座標の最大値と最小値の保持に使う\nstruct range{\n\tint min_x, min_y, max_x, max_y;\n\trange(int min_x_ , int min_y_ , int max_x_ , int max_y_ ){\n\t\tmin_x = min_x_;\n\t\tmin_y = min_y_;\n\t\tmax_x = max_x_;\n\t\tmax_y = max_y_;\n\t}\n};\n\nvoid debug(const vector<string>& m){\n\tcout << \"[debug]\" << endl;\n\tfor(int y=0 ; y < m.size() ; y++ ){\n\t\tcout << m[y] << endl;\n\t}\n\tcout << endl;\n}\n\nvoid debug2(const vector<char>& vc, const vector<range>& vr){\n\tfor(int i=0 ; i < vc.size() ; i++ ){\n\t\trange r = vr[i];\n\t\tcout << vc[i] << \" \" << endl;\n\t\tcout << \"x => [\" << r.min_x << \",\" << r.max_x << \"] \";\n\t\tcout << \"y => [\" << r.min_y << \",\" << r.max_y << \"] \";\n\t\tcout << endl << endl;\n\t}\n}\n\n// 文字 c の出現する x,y 座標の最大値と最小値を求める\nrange search_range(const vector<string>& m, char c){\n\tint min_x = -1, min_y = -1, max_x = -1, max_y = -1;\n\tfor(int y = 0 ; y < m.size() ; y++ ){\n\t\tfor(int x=0 ; x < m[y].size() ; x++ ){\n\t\t\tif( m[y][x] == c ){\n\t\t\t\tmin_x = (min_x == -1)? x : min( min_x , x );\n\t\t\t\tmin_y = (min_y == -1)? y : min( min_y , y );\n\t\t\t\tmax_x = (max_x == -1)? x : max( max_x , x );\n\t\t\t\tmax_y = (max_y == -1)? y : max( max_y , y );\n\t\t\t}\n\t\t}\n\t}\n\trange r( min_x , min_y , max_x , max_y );\n\treturn r;\n}\n\n// 文字 c について長方形かどうか\nbool check(const vector<string>& m, range r, char c){\n\tint cnt = 0;\n\tfor(int y = r.min_y ; y <= r.max_y ; y++ ){\n\t\tfor(int x = r.min_x ; x <= r.max_x ; x++ ){\n\t\t\tif( m[y][x] == c || m[y][x] == '*' ){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//cout << \"search \" << c << \" cnt : \" << cnt << endl;\n\t//cout << \"(\" << r.min_x << \",\" << r.min_y << \") => (\" << r.max_x << \",\" << r.max_y << \")\" << endl; \n\t\n\tif( cnt != (r.max_x - r.min_x + 1) * (r.max_y - r.min_y + 1) ){\n\t\treturn false;\n\t}\n\t\n\tfor(int y = 0 ; y < m.size() ; y++ ){\n\t\tfor(int x = 0 ; x < m[y].size() ; x++ ){\n\t\t\tif( r.min_x <= x && r.min_y <= y && x <= r.max_x && y <= r.max_y ){\n\t\t\t}else if( m[y][x] == c ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\n// 文字 c を' *' に置き換える (荷物を取り除く) \nvoid remove(vector<string>& m, range r, char c){\n\tfor(int y = r.min_y ; y <= r.max_y ; y++ ){\n\t\tfor(int x = r.min_x ; x <= r.max_y ; x++ ){\n\t\t\tif( m[y][x] == c ){\n\t\t\t\tm[y][x] = '*';\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(int id, vector<bool> memo, vector<string> m, vector<char> vc, vector<range> vr){\n\tmemo[id] = true;\n\t\n\t// 長方形かどうか\n\tbool is_rect = check( m , vr[id] , vc[id] );\n\tif( is_rect == false ){\n\t\treturn;\n\t}\n\t\n\t// 文字 vc[id] を '*' に置き換える (荷物を取り除く) \n\tremove( m , vr[id] , vc[id] );\n\t\n\t//cout << vc[id] << \" is rectangle! \" << endl;\n\t//debug( m );\n\t\n\t// すべて調べたかどうか\n\tint cnt = 0;\n\tfor(int i=0 ; i < memo.size() ; i++ ){\n\t\tif( memo[i] )\n\t\t\tcnt++;\n\t}\n\tif( cnt == memo.size() && is_rect ){\n\t\tans = true;\n\t\treturn;\n\t}\n\t\n\tfor(int i=0 ; i < memo.size() ; i++ ){\n\t\tif( memo[i] == false ){\n\t\t\t//cout << \"next : \" << vc[i] << endl;\n\t\t\t//dfs( i , memo , m , vc , vr );\n\t\t}\n\t}\n}\n\nvoid solve(const vector<string>& m){\n\tchar ch[256] = {0};\n\tvector<char> vc;\n\tvector<range> vr;\n\tans = false;\n\t\n\t// 出現する文字を調べる\n\tfor(int y=0 ; y < m.size() ; y++ ){\n\t\tfor(int x=0 ; x < m[y].size() ; x++ ){\n\t\t\tif( m[y][x] >= 'A' && m[y][x] <= 'Z' ){\n\t\t\t\tch[ m[y][x] ] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(char c = 'A' ; c <= 'Z' ; c++ ){\n\t\tif( ch[c] )\n\t\t\tvc.push_back( c );\n\t}\n\t\n\t// 文字がなかったら \"SAFE\"\n\tif( vc.size() == 0 ){\n\t\tans = true;\n\t}\n\t\n\t// 各文字 c について x,y 座標の最大値と最小値を求める\n\tfor(int i=0 ; i < vc.size() ; i++ ){\n\t\trange r = search_range( m , vc[i] );\n\t\tvr.push_back( r );\n\t}\n\t//debug2( vc , vr );\n\t\n\t// DFSで重なる順番をすべて調べる\n\tvector<bool> memo( vc.size() );\n\tfor(int k=0 ; k < vc.size() ; k++ ){\n\t\tfor(int i=0 ; i < memo.size() ; i++ ){\n\t\t\tmemo[i] = false;\n\t\t}\n\t\t//dfs( k , memo , m , vc , vr );\n\t}\n\t\n}\n\nint main(){\n\tint T;\n\tcin >> T;\n\tfor(int t_ = 0 ; t_ < T ; t_++ ){\n\t\tint w, h;\n\t\tcin >> h >> w;\n\t\t\n\t\tvector<string> m(h);\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> m[y];\n\t\t}\n\t\t\n\t\tsolve( m );\n\t\t\n\t\tif( ans ){\n\t\t\tcout << \"SAFE\" << endl;\n\t\t}else{\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <queue>\nusing namespace std;\nstruct po{int l,r,u,d;};\npo al[31];\nint u[31],d[31];\nstring mp[51];\n\nbool check1(int num,po t){\n  if(t.l==100)return 1;\n  for(int i=t.u;i<=t.d;i++)\n    for(int j=t.l;j<=t.r;j++){\n      if(mp[i][j]==num+'A')continue;\n      if(mp[i][j]=='.')return 0;\n      u[num] |= (1<<(mp[i][j]-'A'));\n      d[mp[i][j]-'A'] |= (1<<num);\n    }\n}\n\nbool topological(){\n  queue <int> Q;\n  for(int i=0;i<30;i++)if(!d[i])Q.push(i);\n  while(!Q.empty()){\n    int t=Q.front(); Q.pop();\n    for(int i=0;i<30;i++)\n      if(((1<<i)&u[t])){\n\td[i] -= (d[i]&(1<<t));\n\tif(!d[i])Q.push(i);\n      }\n  }\n  for(int i=0;i<30;i++)if(d[i])return 0;\n  return 1;\n}\n\nint main() {\n  int q,h,w;\n  cin>>q;\n  while(q--){\n    cin>>h>>w;\n    for(int i=0;i<h;i++)cin>>mp[i];\n    for(int i=0;i<30;i++){\n      u[i]=d[i]=0;\n      al[i].l=al[i].u=100;\n      al[i].r=al[i].d=-1;\n    }\n    \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tif(mp[i][j]!='.'){\n\t  int k=mp[i][j]-'A';\n\t  al[k].u=min(al[k].u,i);\n\t  al[k].l=min(al[k].l,j);\n\t  al[k].d=max(al[k].d,i);\n\t  al[k].r=max(al[k].r,j);\n\t}\n\n    bool ans=1;\n    for(int i=0;i<30;i++)ans = min(ans,check1(i,al[i]));\n    if(min(ans,topological()))cout<<\"SAFE\"<<endl;\n    else cout<<\"SUSPICIOUS\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;/*{{{*/\n\n#include <iostream>\n#include <map>\n#include <vector>\n\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n/*}}}*/\n\nstruct article {\n\tchar material;\n\tbool is_removed;\n\tint topmost;\n\tint bottommost;\n\tint leftmost;\n\tint rightmost;\n};\n\ntypedef map<char, article> MCA;\n\nVVC image;\nMCA articles;\n\nbool remove_all()\n{\n\tbool all_removed = true;\n\tEACH (articles, itr) {\n\t\tarticle &art = itr->second;\n\t\tif (!art.is_removed) {\n\t\t\tall_removed = false;\n\t\t\t// Remove it and recurse\n\t\t\tVVC save = image;\n\t\t\tbool rect = true;\n\t\t\tFOR (i, art.topmost, art.bottommost + 1) {\n\t\t\t\tFOR (j, art.leftmost, art.rightmost + 1) {\n\t\t\t\t\tif (image[i][j] != '*' && image[i][j] != art.material) {\n\t\t\t\t\t\trect = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\timage[i][j] = '*';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rect) {\n\t\t\t\t// Recurse\n\t\t\t\tart.is_removed = true;\n\t\t\t\tif (remove_all()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Restore and continue trying\n\t\t\tart.is_removed = false;\n\t\t\timage = save;\n\t\t}\n\t}\n\treturn all_removed;\n}\n\nint main()\n{\n\tint t; cin >> t;\n\tREP (_, t) {\n\t\t// Initialize\n\t\tarticles.clear();\n\n\t\tint h, w; cin >> h >> w;\n\t\timage = VVC(h, VC(w, '.'));\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tcin >> image[i][j];\n\t\t\t}\n\t\t}\n\n\t\t// Scan Image\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tif (image[i][j] != '.') {\n\t\t\t\t\tchar c = image[i][j];\n\t\t\t\t\tif (!EXIST(articles, c)) {\n\t\t\t\t\t\tarticle a = {c, false, 50, 0, 50, 0};\n\t\t\t\t\t\tarticles[c] = a;\n\t\t\t\t\t}\n\t\t\t\t\tarticles[c].topmost = min(articles[c].topmost, i);\n\t\t\t\t\tarticles[c].bottommost = max(articles[c].bottommost, i);\n\t\t\t\t\tarticles[c].leftmost = min(articles[c].leftmost, j);\n\t\t\t\t\tarticles[c].rightmost = max(articles[c].rightmost, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (remove_all()) {\n\t\t\tcout << \"SAFE\" << endl;\n\t\t} else {\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\nstruct po{int l,r,u,d;};\npo al[31];\nint h,w,u[31],d[31];\nstring mp[51];\n\nbool check1(int num,po t){\n  if(t.l==100)return 1;\n  for(int i=t.u;i<=t.d;i++)\n    for(int j=t.l;j<=t.r;j++){\n      if(mp[i][j]==num+'A')continue;\n      if(mp[i][j]=='.')return 0;\n      u[num] |= (1<<(mp[i][j]-'A'));\n      d[mp[i][j]-'A'] |= (1<<num);\n    }\n}\n\nbool topological(){\n  queue <int> Q;\n  for(int i=0;i<30;i++)if(!d[i])Q.push(i);\n  while(!Q.empty()){\n    int t=Q.front(); Q.pop();\n    for(int i=0;i<30;i++)\n      if(((1<<i)&u[t])){\n\td[i] -= (d[i]&(1<<t));\n\tif(!d[i])Q.push(i);\n      }\n  }\n  for(int i=0;i<30;i++)if(d[i])return 0;\n  return 1;\n}\n\nint main() {\n  int q;\n  cin>>q;\n  while(q--){\n    cin>>h>>w;\n    for(int i=0;i<h;i++)cin>>mp[i];\n    for(int i=0;i<30;i++){\n      u[i]=d[i]=0;\n      al[i].l=al[i].u=100;\n      al[i].r=al[i].d=-1;\n    }\n    \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tif(mp[i][j]!='.'){\n\t  int k=mp[i][j]-'A';\n\t  al[k].u=min(al[k].u,i);\n\t  al[k].l=min(al[k].l,j);\n\t  al[k].d=max(al[k].d,i);\n\t  al[k].r=max(al[k].r,j);\n\t}\n    bool ans=1;\n    for(int i=0;i<30;i++)ans = min(ans,check1(i,al[i]));\n    ans = min(ans,topological());\n    if(ans)cout<<\"SAFE\"<<endl;\n    else cout<<\"SUSPICIOUS\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\n\nint H, W;\nvector<string> s(51);\n\nbool is_rectangle(int sy, int sx, int gy, int gx) {\n    char c = '#';\n    for(int y=sy;y<=gy;++y) {\n        for(int x=sx;x<=gx;++x) {\n            if(s[y][x] != '#') {\n                if(c == '#') {\n                    c = s[y][x];\n                } else if(s[y][x] != c){\n                    return false;\n                }\n            }\n        }\n    }\n    for(int i=0;i<H;++i) {\n        if(sy <= i && i<= gy) continue;\n        for(int j=0;j<W;++j) {\n            if(sx <= j && j <= gx) continue;\n            if(s[i][j] == c) return false;\n        }\n    }\n    return true;\n}\n\nbool solve() {\n    cin >> H >> W;\n    for(int i=0;i<H;++i) {\n        cin >> s[i];\n    }\n\n    map<char, int> sy, sx, gy, gx;\n    set<char> st;\n    for(int y=0;y<H;++y) {\n        for(int x=0;x<W;++x) {\n            if(s[y][x] == '.') continue;\n            char  c = s[y][x];\n            if(st.find(c) == st.end()) {\n                st.insert(c);\n                sy[c] = y;\n                sx[c] = x;\n            }\n            sy[c] = min(y, sy[c]);\n            sx[c] = min(x, sx[c]);\n            gy[c] = max(y, gy[c]);\n            gx[c] = max(x, gx[c]);\n        }\n    }\n\n    bool changed = true;\n    while(changed) {\n        changed = false;\n        vector<char> cc;\n        for(char c: st) {\n            if(is_rectangle(sy[c], sx[c], gy[c], gx[c])) {\n                changed = true;\n                cc.push_back(c);\n                for(int y=sy[c];y<=gy[c];++y) {\n                    for(int x=sx[c];x<=gx[c];++x) {\n                        s[y][x] = '#';\n                    }\n                }\n            }\n        }\n        for(char ccc: cc) st.erase(ccc);\n    }\n    return st.empty();\n}\n\nint main() {\n    int n;\n    cin >> n;\n    while(n--) {\n        cout << (solve()?\"SAFE\\n\":\"SUSPICIOUS\\n\");\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\n#define int long long\n\nconst int NUM = 26;\nconst int INF = (int)(1e17);\n\n\nstruct in{\n  int ymax, ymin, xmax, xmin;\n};\n\nsigned main(){\n  int N;\n\n  cin>>N;\n  \n  for(int nn = 0; nn < N; nn++){\n    vector<string> field;\n    vector<int> count;\n    vector<in> info;\n    vector<vector<int>> con1;\n    vector<vector<vector<int>>> con2;\n    vector<int> used;\n    bool flag = true;\n    int temp = 0;\n\n    int H, W;\n\n    cin>>H>>W;\n\n\n    field.resize(H);\n    count.resize(NUM);\n    info.resize(NUM,{-INF,INF,-INF,INF});\n    used.resize(NUM,0);\n    \n    for(int i = 0; i < H; i++){\n      cin>>field[i];\n      for(int j = 0; j < W; j++){\n\tif(field[i][j] != '.'){\n\t  count[field[i][j] - 'A']++;\n\t  info[field[i][j] - 'A'].ymax = max(info[field[i][j] - 'A'].ymax, i);\n\t  info[field[i][j] - 'A'].xmax = max(info[field[i][j] - 'A'].xmax, j);\n\t  info[field[i][j] - 'A'].ymin = min(info[field[i][j] - 'A'].ymin, i);\n\t  info[field[i][j] - 'A'].xmin = min(info[field[i][j] - 'A'].xmin, j);\n\t}\n      }\n    }\n\n    for(int i = 0; i < NUM; i++){//cout<<\"i = \"<<i<<\" count \"<<count[i]<<\" temp \"<<temp<<endl;\n      if(!count[i]) continue;\n      temp++;\n    }\n     \n    for(int i = 0; temp; i = (i + 1)%NUM){ //cout<<\"i = \"<<i<<\" temp \"<<temp<<endl;\n      int cona = 0, conb = 0, conc = 0;\n      if(!count[i]) continue;\n      // cout<<\"COUTN \"<<count[i]<<endl;\n      \n      if(used[i]){\n\t//\tcout<<\"USED \"<<endl;\n\tflag = false;\n\tbreak;\n      }\n      \n      used[i] = true;\n      // cout<<info[i].ymin<<\" <>  \"<<info[i].ymax<<endl;\n      // cout<<info[i].xmin<<\" <> \"<<info[i].xmax<<endl;\n      for(int j = info[i].ymin; j <= info[i].ymax; j++){\n\tfor(int k = info[i].xmin; k <= info[i].xmax; k++){\n\n\t  if(field[j][k] - 'A' == i || field[j][k] == ','){\n\t    cona++;\n\t  } else{\n\t    conc++;\n\t    break;\n\t  } \n\n\t  if(conc) break;\n\t}\n\tif(conc) break;\n      }\n      //   cout<<cona<<\" \"<<conc<<endl;\n      \n      if(conc){\n\tcontinue;\n      }\n\n      //     cout<<\"IIII = \"<<i<<endl;\n      \n      used.clear();\n      used.resize(NUM,0);\n      temp--;\n      count[i] = 0;\n      \n      for(int j = info[i].ymin; j <= info[i].ymax; j++){\n\tfor(int k = info[i].xmin; k <= info[i].xmax; k++){\n\n\t  if(field[j][k] - 'A' == i){\n\t    field[j][k] = ',';\n\t  }\n\t  \n\t}\n      }\n      \n    }\n    \n    cout<<(flag?\"SAFE\":\"SUSPICIOUS\")<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n#define inf 1e9\n\n\nstruct item{\n    int l = inf, r = 0, t = inf, b = 0;\n};\n\nvector<string> g(51);\nvector<item> a(27);\nvector<int> x;\nbool f;\n\nvoid perm(vector<int> p, int bit, int n) {\n    if (n == x.size()) {\n        bool ff = true;\n        for (int i = 0; i < p.size(); i++) {\n            int ho = x[p[i]];\n            set<int> se;\n            for (int j = i; j < x.size(); j++) se.insert(x[p[j]]);\n            \n            for (int h = a[ho].t; h < a[ho].b + 1; h++) {\n                for (int w = a[ho].l; w < a[ho].r + 1; w++) {\n                    int c = g[h][w]-'A';\n                    set<int>::iterator it = se.find(c);\n                    if (it == se.end()) ff = false;\n                    if (!ff) break;\n                }\n                if (!ff) break;\n            }\n            if (!ff) break;\n        }\n        if (ff) f = true;\n        return ;\n    }\n    \n    for (int i = 0; i < x.size(); i++) {\n        if (bit & 1<<i) continue;\n        vector<int> a = p;\n        a.push_back(i);\n        perm(a, bit | 1<<i, n+1);\n    }\n}\n\n\nint main(void){\n    int n;\n    cin >> n;\n    while (n--) {\n        int h, w;\n        cin >> h >> w;\n        g.clear();\n        a.clear();\n        x.clear();\n        f = false;\n        for (int i = 0; i < h; i++) {\n            cin >> g[i];\n            for (int j = 0; j < w; j++) if (g[i][j] != '.') {\n                char c = g[i][j];\n                int  t = c - 'A';\n                a[t].l = min(a[t].l, j);\n                a[t].r = max(a[t].r, j);\n                a[t].t = min(a[t].t, i);\n                a[t].b = max(a[t].b, i);\n                t = g[i][j]-'A';\n                x.push_back(t);\n            } \n        }\n        sort(x.begin(), x.end());\n        x.erase(unique(x.begin(), x.end()), x.end());\n        vector<int> t;\n        \n        perm(t,0,0);\n        if (f) cout << \"SAFE\" << endl;\n        else cout << \"SUSPICIOUS\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n\nint Y,X;\n\nstruct Item{\n    int x1,x2,y1,y2,cnt;\n    Item(){\n        x1 = y1 = +100;\n        x2 = y2 = -100;\n        cnt = 0;\n    }\n    void update(int x,int y){\n        x1 = min(x1,x);\n        x2 = max(x2,x);\n        y1 = min(y1,y);\n        y2 = max(y2,y);\n        cnt++;\n    }\n\n    bool isRectangle(){\n        return (x2-x1+1)*(y2-y1+1) == cnt;\n    }\n    bool isin(int x,int y){\n        return x1<=x && x<=x2 && y1<=y && y<=y2;\n    }\n};\n\nint main(void){\n    int T;\n    cin>>T;\n    while(T--){\n        cin>>Y>>X;\n        vector<string> s(Y);\n        rep(y,Y) cin>>s[y];\n        vector<Item> items(26);\n        rep(y,Y)rep(x,X){\n            if(s[y][x] == '.') continue;\n            int a = s[y][x] - 'A';\n            items[a].update(x,y);\n        }\n        for(auto it=items.begin(); it!=items.end();){\n            if(it->cnt == 0){\n                it = items.erase(it);\n            }else ++it;\n        }\n\n        size_t prev = 0;\n        while(prev != items.size()){\n            prev = items.size();\n            for(auto it=items.begin(); it!=items.end();){\n                if(it->isRectangle()){\n                    for(int x=it->x1; x<=it->x2; x++){\n                        for(int y=it->y1; y<=it->y2; y++){\n                            for(auto &back : items){\n                                if(back.isin(x,y)){\n                                    back.cnt++;\n                                }\n                            }\n                        }\n                    }\n                    it = items.erase(it);\n                }else ++it;\n            }\n        }\n        cout<<(items.size() ? \"SUSPICIOUS\" : \"SAFE\")<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> v;\nbool ngchars[256];\n\nbool check(int y, int x, int Y, int X, char C) {\n\tbool out;\n\tbool in;\n\tY++; X++;\n\tfor(int i = y; i < Y; i++) {\n\t\tfor(int j = x; j < X; j++) {\n\t\t\tif(ngchars[v[i][j]]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tfor(int iter = 0; iter < n; iter++) {\n\t\tint w, h;\n\t\tvector<char> cs;\n\t\tcin >> h >> w;\n\t\tv.clear();\n\t\tv.resize(h);\n\t\tfor(int i = 0; i < h; i++)\n\t\t\tcin >> v[i];\n\t\tfor(int i = 0; i < 256; i++)\n\t\t\tngchars[i] = false;\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tfor(int j = 0; j < v[i].size(); j++) {\n\t\t\t\tif(v[i][j] != '.') {\n\t\t\t\t\tcs.push_back(v[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint x[30], y[30], X[30], Y[30];\n\t\tfor(int i = 0; i < 30; i++) {\n\t\t\tx[i] = y[i] = 100;\n\t\t\tX[i] = Y[i] = -1;\n\t\t}\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tfor(int j = 0; j < v[i].size(); j++) {\n\t\t\t\tif(v[i][j] == '.') continue;\n\t\t\t\tint c;\n\t\t\t\tc = v[i][j] - 'A';\n\t\t\t\tx[c] = min(x[c], j);\n\t\t\t\tX[c] = max(X[c], j);\n\t\t\t\ty[c] = min(y[c], i);\n\t\t\t\tY[c] = max(Y[c], i);\n\t\t\t}\n\t\t}\n\n\t\tbool res = false;\n\t\tsort(cs.begin(), cs.end());\n\t\tcs.erase(unique(cs.begin(), cs.end()), cs.end());\n\t\tdo {\n\t\t\tfor(int i = 0; i < cs.size(); i++)\n\t\t\t\tngchars[cs[i]] = true;\n\t\t\tngchars['.'] = true;\n\t\t\tbool f = true;\n\t\t\tfor(int i = 0; i < cs.size(); i++) {\n\t\t\t\tngchars[cs[i]] = false;\n\t\t\t\tint c = cs[i] - 'A';\n\t\t\t\tif(!check(y[c],x[c],Y[c],X[c],'A'+c)) {\n\t\t\t\t\tf = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f)\n\t\t\t\tres = true;\n\t\t} while(next_permutation(cs.begin(), cs.end()));\n\t\tif(res)\n\t\t\tcout << \"SAFE\" << endl;\n\t\telse\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nstd::vector<std::vector<char> > move(std::vector<std::vector<char> > recv,char c){\n    std::vector<std::vector<char> > vec;\n    int le=0,ri=recv[0].size()-1,up=0,dow=recv.size()-1;\n    //left\n    for(;le<recv[0].size();++le){\n        bool del=false;\n        for(int count=0;count<recv.size();++count){\n            if(recv[count][le]==c){\n                del=true;\n                break;\n            }\n        }\n        if(del){\n            le--;\n            break;\n        }\n    }\n    //right\n    for(;ri>=0;--ri){\n        bool del=false;\n        for(int count=0;count<recv.size();++count){\n            if(recv[count][ri]==c){\n                del=true;\n                break;\n            }\n        }\n        if(del){\n            ri++;\n            break;\n        }\n    }\n    //up\n    for(;up<recv.size();++up){\n        bool del=false;\n        for(int count=0;count<recv[0].size();++count){\n            if(recv[up][count]==c){\n                del=true;\n                break;\n            }\n        }\n        if(del){\n            up--;\n            break;\n        }\n    }\n    //down\n    for(;dow>0;--dow){\n        bool del=false;\n        for(int count=0;count<recv[0].size();++count){\n            if(recv[dow][count]==c){\n                del=true;\n                break;\n            }\n        }\n        if(del){\n            dow++;\n            break;\n        }\n    }\n    for(int i=up+1;i<dow;++i){\n        std::vector<char> mem;\n        for(int l=le+1;l<ri;++l){\n            mem.push_back(recv[i][l]);\n        }\n        vec.push_back(mem);\n    }\n    return vec;\n}\nstd::vector<std::vector<std::vector<char> > > kscan;\nstd::vector<std::vector<char> > others;\nstd::vector<char> kinds;\nint c_t(char c){\n    for(int i=0;i<kinds.size();++i){\n        if(kinds[i]==c)return i;\n    }\n    return -1;\n}\nbool find(std::vector<char> arr,char c){\n    for(int i=0;i<arr.size();++i){\n        if(arr[i]==c)return true;\n    }\n    return false;\n}\nbool lastcheck(std::vector<char> list,int num){\n    list.push_back(kinds[num]);\n    //std::cout<<\"Debug\"<<kinds[num]<<std::endl;\n    for(int i=0;i<others[num].size();++i){\n        if(find(list,others[num][i])){\n            return false;\n        }else{\n            if(!lastcheck(list,c_t(others[num][i]))){\n                return false;\n            }\n        }\n    }\n    return true;\n}\nbool check(std::vector<std::vector<char> > vec,char c){\n    bool ch=false;\n    for(int i=0;i<vec.size();++i){\n        for(int l=0;l<vec[i].size();++l){\n            if(vec[i][l]==c){\n                ch=true;\n            }\n        }\n    }\n    //存在する->true\n    return ch;\n}\nstd::vector<char> check2(std::vector<std::vector<char> > recv,char c){\n    std::vector<std::vector<char> > vec(1);\n    for(int i=0;i<recv.size();++i){\n        for(int l=0;l<recv[i].size();++l){\n            if(recv[i][l]!=c){\n                if(!check(vec,recv[i][l])){\n                    vec[0].push_back(recv[i][l]);\n                }\n            }\n        }\n    }\n    return vec[0];\n}\nint main(){\n    int num;\n    std::cin>>num;\n    while(num>0){\n        bool S=true;\n        kinds.clear();\n        int width,height;\n        std::cin>>height>>width;\n        std::vector<std::vector<char> > scan(height,std::vector<char> (width,' '));\n        for(int h=0;h<height;++h){\n            for(int w=0;w<width;++w){\n                char in;\n                std::cin>>in;\n                if(!check(scan,in)&&in!='.'){\n                    kinds.push_back(in);\n                }\n                scan[h][w]=in;\n            }\n        }\n        kscan.clear();\n        for(int i=0;i<kinds.size();++i){\n            kscan.push_back(move(scan,kinds[i]));\n        }\n        /*for(int i=0;i<kscan.size();++i){\n            for(int h=0;h<kscan[i].size();++h){\n                for(int w=0;w<kscan[i][h].size();++w){\n                    std::cout<<kscan[i][h][w];\n                }\n                std::cout<<std::endl;\n            }\n            std::cout<<std::endl;\n        }*/\n        others.clear();\n        std::vector<char> samvec;\n        samvec.clear();\n        for(int i=0;i<kscan.size();++i){\n            others.push_back(check2(kscan[i],kinds[i]));\n            for(int l=0;l<others[i].size();++l){\n                if(others[i][l]=='.'){\n                    S=false;\n                    goto end;\n                }\n            }\n        }\n        for(int i=0;i<kinds.size();++i){\n            samvec.clear();\n            samvec.push_back(kinds[i]);\n            for(int l=0;l<others[i].size();++l){\n                if(!lastcheck(samvec,c_t(kinds[i]))){\n                    S=false;\n                }\n            }\n        }\n    end:;\n        std::cout<<(S?\"SAFE\":\"SUSPICIOUS\")<<std::endl;\n        --num;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define RFOR(i, a, b) for(int i = (b)-1; i >= (a); i--)\n#define REP(i, n) for(int i = 0; i < (n); i++)\n#define RREP(i, n) for(int i = (n)-1; i >= 0; i--)\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rrep(i, n) for(int i = (n)-1; i >= 0; i--)\n#define loop while(true)\n\n#define PB push_back\n#define pb push_back\n#define MP make_pair\n#define mp make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define all(a) (a).begin(),(a).end()\n\n#define PII pair<int, int>\n#define pii pair<int, int>\n#define VB vector<bool>\n#define VVB vector<vector<bool> >\n#define VI vector<int>\n#define VVI vector<vector<int> >\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n\n\n\nsigned main()\n{\n    int test_num;\n    cin >> test_num;\n    rep(test, test_num){\n        int h, w;\n        cin >> h >> w;\n\n        vector<vector<char> > image(h);\n        rep(y, h){\n            image[y].resize(w);\n        }\n        rep(y, h){\n            rep(x, w){\n                char ch;\n                cin >> ch;\n                image[y][x] = ch;\n            }\n        }\n        \n        int obj_num = 0;\n        map<char, int> objects;\n        vector<char> chars;\n        vector<array<int, 4> > obj_point; // h_min, w_min, h_max, w_max\n        \n        rep(y, h){\n            rep(x, w){\n                if(image[y][x] != '.'){\n                    char letter = image[y][x];\n                    if(objects.find(letter) != objects.end()){\n                        int index = objects[letter];\n                        obj_point[index].at(0) = min(obj_point[index].at(0), y);\n                        obj_point[index].at(1) = min(obj_point[index].at(1), x);\n                        obj_point[index].at(2) = max(obj_point[index].at(2), y);\n                        obj_point[index].at(3) = max(obj_point[index].at(3), x);\n                    } else {\n                        objects.insert(mp(letter, obj_num++));\n                        chars.pb(letter);\n                        array<int, 4> p = {y, x, y, x};\n                        obj_point.pb(p);\n                    }\n                }\n            }\n        }\n\n        bool flag = false;\n        VVB to_graph(obj_num);\n        rep(i, obj_num){\n            to_graph[i].resize(obj_num);\n        }\n        rep(n, obj_num){\n            VB over(obj_num, false);\n            FOR(y, obj_point[n].at(0), obj_point[n].at(2)+1){\n                FOR(x, obj_point[n].at(1), obj_point[n].at(3)+1){\n                    char letter = image[y][x];\n                    if(letter == '.'){\n                        flag = true;\n                        break;\n                    }\n                    else if(letter != chars[n]){\n                        int index = objects[letter];\n                        if(!over[index]){\n                            // cout << chars[n] << \" is coverred by \" << letter << endl;\n                            over[index] = true;\n                            to_graph[index][n] = true;\n                        }\n                    }\n                }\n                if(flag) break;\n            }\n            if(flag) break;\n        }\n\n        if(!flag){\n            queue<int> inits;\n            rep(i, obj_num){\n                bool non = true;\n                rep(j, obj_num){\n                    if(to_graph[j][i]) non = false;\n                }\n                if(non) inits.push(i);\n            }\n            \n            vector<int> top(obj_num);\n            while(!inits.empty()){\n                int n = inits.front();\n                inits.pop();\n                top.pb(n);\n                rep(i, obj_num){\n                    if(to_graph[n][i]){\n                        to_graph[n][i] = false;\n                        bool non = true;\n                        rep(j, obj_num){\n                            if(to_graph[j][i]) non = false;\n                        }\n                        if(non) inits.push(i);\n                    }\n                }\n            }\n\n            rep(i, obj_num){\n                rep(j, obj_num){\n                    if(to_graph[i][j]){\n                        flag = true;\n                        break;\n                    }\n                }\n                if(flag){\n                    break;\n                }\n            }\n        }\n        \n        if(flag){\n            cout << \"SUSPICIOUS\" << endl;\n        } else {\n            cout << \"SAFE\" << endl;\n        }\n        \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\nusing namespace std;\n#define fi first\n#define se second\ntypedef pair<pair<int,int>, pair<int,int>> Rect;\n\nvector<string> img;\nmap<char, Rect> item;\nint t, H, W;\n\nbool ok(Rect r, char c) {\n\tfor (int i=r.se.fi; i<=r.se.se; ++i) {\n\t\tfor (int j=r.fi.fi; j<=r.fi.se; ++j) {\n\t\t\tif (img[i][j] != c && img[i][j] != '#') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid fill(Rect r, char c) {\n\tfor (int i=r.se.fi; i<=r.se.se; ++i) {\n\t\tfor (int j=r.fi.fi; j<=r.fi.se; ++j) {\n\t\t\timg[i][j] = c;\n\t\t}\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> t;\n\twhile (t--) {\n\t\tcin >> H >> W;\n\t\timg.resize(H);\n\t\tfor (int i=0; i<H; ++i) {\n\t\t\tcin >> img[i];\n\t\t}\n\t\tfor (int i=0; i<H; ++i) {\n\t\t\tfor (int j=0; j<W; ++j) {\n\t\t\t\tchar c = img[i][j];\n\t\t\t\tif (c != '.') {\n\t\t\t\t\tif (item.count(c) == 0) {\n\t\t\t\t\t\titem[c] = make_pair(make_pair(j, j), make_pair(i, i));\n\t\t\t\t\t} else {\n\t\t\t\t\t\titem[c].fi.fi = min(item[c].fi.fi, j);\n\t\t\t\t\t\titem[c].fi.se = max(item[c].fi.se, j);\n\t\t\t\t\t\titem[c].se.fi = min(item[c].se.fi, i);\n\t\t\t\t\t\titem[c].se.se = max(item[c].se.se, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap<char, Rect>::iterator it = item.begin();\n\t\twhile (it != item.end()) {\n\t\t\tchar c = (*it).fi;\n\t\t\tRect r = (*it).se;\n\t\t\tif (ok(r, c)) {\n\t\t\t\tfill(r, '#');\n\t\t\t\titem.erase(c);\n\t\t\t\tit = item.begin();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t++ it;\n\t\t}\n\t\tbool safe = item.empty();\n\t\tcout << (safe ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n\t\titem.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define REP(i, n) for(int i = 0; i < (int)n; ++i)\n#include<iostream>\n#include<vector>\n#include<string>\n#include<set>\n#include<algorithm>\n\nusing namespace std;\n\nstring ogrid[50];\nstring grid[50];\nvoid solve() {\n    int h, w;\n    vector<char> types;\n    set<char> st;\n    cin >> h >> w;\n    REP(i, h) {\n        cin >> ogrid[i];\n    }\n    REP(i, h) REP(j, w) {\n        if (ogrid[i][j] != '.' && st.find(ogrid[i][j]) == st.end()) {\n            st.insert(ogrid[i][j]);\n            types.push_back(ogrid[i][j]);\n        }\n    }\n    sort(types.begin(), types.end());\n    bool safe = false;\n    do {\n        REP(i, h) grid[i] = ogrid[i];\n        bool allok = true;\n        // REP(i, types.size()) cout << types[i] << \"\\t\";\n        // cout << endl;\n        for(auto ti : types) {\n            bool ok = true;\n            int l = w, r = -1, t = h, b = -1;\n            REP(i, h) REP(j, w) {\n                if (grid[i][j] == ti) {\n                    l = min(l, j);\n                    r = max(r, j);\n                    t = min(t, i);\n                    b = max(b, i);\n                }\n            }\n            REP(i, h) REP(j, w) {\n                if (!ok) break;\n                if (grid[i][j] == '?') continue;\n                if (grid[i][j] == ti) {\n                    if (!(i >= t && i <= b && j >= l && j <= r)) {\n                        ok = false;\n                    }\n                        grid[i][j] = '?';\n                } else {\n                    if (i >= t && i <= b && j >= l && j <= r) ok = false;\n                }\n            }\n            allok &= ok;\n            if (!allok) {\n            // cout << ti << endl;\n            break;\n            }\n        }\n        if (allok) {\n            safe = true;\n            break;\n        }\n    } while (next_permutation(types.begin(), types.end()));\n    cout << (safe ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n\n}\nint dddd;\nint main() {\n    cin >> dddd;\n    REP(hoge, dddd) {\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass Belongings {\npublic:\n  Belongings() : left(100),right(0),upper(100),lower(0){}\n  int left,right,upper,lower;\n};\n\nbool check(char hypothesis[50][50],char stage[50][50],int W,int H){\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      if (hypothesis[y][x] != stage[y][x]) return false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    for(int stage_idx = 0; stage_idx < N; stage_idx++){\n      int H,W;\n      char stage[50][50];\n      scanf(\"%d %d\",&H,&W);\n      map<char,Belongings> layer;\n    \n      for(int y=0;y<H;y++){\n\tchar line[51];\n\tscanf(\"%s\",line);\n\tfor(int x=0;x<W;x++){\n\t  stage[y][x] = line[x];\n\t  //x:0->...\n\t  //y:0\n\t  //  |\n\t  //  v\n\t  //  .\n\t  //  upper\n\t  //left right\n\t  //  lower\n\t  layer[stage[y][x]].left = min(layer[stage[y][x]].left,x);\n\t  layer[stage[y][x]].right = max(layer[stage[y][x]].right,x);\n\t  layer[stage[y][x]].upper = min(layer[stage[y][x]].upper,y);\n\t  layer[stage[y][x]].lower = max(layer[stage[y][x]].lower,y);\n\t}\n      }\n\n      string res = \"SUSPICIOUS\";\n    \n      vector<char> order;\n      for(map<char,Belongings>::iterator it = layer.begin();\n\t  it != layer.end();\n\t  it++){\n\torder.push_back(it->first);\n      }\n      sort(order.begin(),order.end());\n      char hypothesis[50][50];\n\n      do{\n\tmemset(hypothesis,'.',sizeof(hypothesis));\n\n\tfor(int i=0;i<order.size();i++){\n\t  int c = order[i];\n\t  Belongings& it = layer[c];\n\t  for(int y=it.upper; y<=it.lower; y++){\n\t    for(int x=it.left; x<=it.right; x++){\n\t      hypothesis[y][x] = c;\n\t    }\n\t  }\n\t}\n\n\tif(check(hypothesis,stage,W,H)){\n\t  res = \"SAFE\";\n\t  break;\n\t}\n      }while(next_permutation(order.begin(),order.end()));\n      cout << res << \"\\n\";\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n#include <map>\n#define rep(i,n) for(int i=0; i<n; ++i)\n\nusing namespace std;\n\nint N, n;\nint H,W;\n\nchar m[50][50];\nbool used[26];\nint U[26],D[26],L[26],R[26];\n\n\nbool check(char ch){\n  int z = ch-'A';\n  for(int i=U[z]; i<D[z]; ++i){\n    for(int j=L[z]; j<R[z]; ++j){\n      if(m[i][j] != '.' && used[z] == false) continue;\n      if(m[i][j]!=ch) return false;\n    }\n  }\n  return true;\n}\nvoid input(){\n  int x;\n  string str;\n  cin >> H >> W;\n  rep(i,H){\n    cin>>str;\n    rep(j,W){\n      m[i][j] = str[j];\n      if(m[i][j]=='.')continue;\n      x=m[i][j]-'A';\n      used[x] = true;\n      U[x]=min(U[x],i);\n      D[x]=max(D[x],i);\n      L[x]=min(L[x],j);\n      R[x]=max(R[x],j);\n    }\n  }\n}\n\nvoid init(){\n  rep(i,26){\n    U[i] = 50;\n    D[i] = 0;\n    L[i] = 50;\n    R[i] = 0;\n    used[i] = false;\n  }\n}\nint main(){\n  cin >> N;\n  while(N--){\n    init();\n    input();\n    while(1){\n      bool flag = false;\n      rep(i,26){\n        if(used[i]==false)continue;\n        if(check(i+'A')==true){\n          used[i] = false;\n          flag = true;\n          break;\n        }\n      }\n      if(flag == false) break;\n    }\n      bool flag = false;\n      rep(i,26) flag |= used[i];\n      cout << (flag ? \"SUSPICIOUS\" : \"SAFE\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <fstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nstatic const double EPS = 1e-5;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\nint H,W;\nbool exist(char c,set<char> &head,vector<string> &grid){\n  int begin=100,end=-1;\n  int ybegin=100,yend=-1;\n  REP(y,H)REP(x,W)if(grid[y][x]==c)begin = min(begin,x),end = max(end,x)\n    ,ybegin=min(ybegin,y),yend=max(yend,y);\n  FOR(y,ybegin,yend+1)FOR(x,begin,end+1)if(grid[y][x]!=c&&head.find(grid[y][x])==head.end()) return false;\n  return true;\n}\n\nint main(void){\n  int n;\n  cin>>n;\n  while(n--){\n    cin>>H>>W;\n    vector<string> grid(H);\n    set<char> mat;\n    set<char> head;\n    REP(i,H)cin>>grid[i];\n    REP(y,H)REP(x,W)if(grid[y][x]!='.')mat.insert(grid[y][x]);\n    bool ans = true;\n    while(!mat.empty()){\n      bool f= false;\n      set<char>::iterator it = mat.begin();\n      for(;it!=mat.end();it++){\n        if(exist(*it,head,grid)){\n          f = true;\n          head.insert(*it);\n          mat.erase(it);\n          break;\n        }\n      }\n      if(!f){\n        ans = false;\n        break;\n      }\n    }\n    if(!ans) cout<<\"SUSPICIOUS\"<<endl;\n    else cout<<\"SAFE\"<<endl;\n  }\n    \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((ULL)(n) >> (m) & 1)\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\nint n_dir = 4;\nint dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; /* CSS order */\nenum direction {\n\tUP, RIGHT, DOWN, LEFT\n};\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\nstruct article {\n\tchar material;\n\tbool is_removed;\n\tint topmost;\n\tint bottommost;\n\tint leftmost;\n\tint rightmost;\n};\n\ntypedef map<char, article> MCA;\n\nVVC image;\nMCA articles;\n\nbool remove_all()\n{\n\tbool all_removed = true;\n\tEACH (articles, itr) {\n\t\tarticle &art = itr->second;\n\t\tif (!art.is_removed) {\n\t\t\tall_removed = false;\n\t\t\t// Remove it and recurse\n\t\t\tVVC save = image;\n\t\t\tbool rect = true;\n\t\t\tFOR (i, art.topmost, art.bottommost + 1) {\n\t\t\t\tFOR (j, art.leftmost, art.rightmost + 1) {\n\t\t\t\t\tif (image[i][j] != '*' && image[i][j] != art.material) {\n\t\t\t\t\t\trect = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\timage[i][j] = '*';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rect) {\n\t\t\t\t// Recurse\n\t\t\t\tart.is_removed = true;\n\t\t\t\tif (remove_all()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Restore and continue trying\n\t\t\timage = save;\n\t\t}\n\t}\n\treturn all_removed;\n}\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\tint t; cin >> t;\n\tREP (_, t) {\n\t\tint h, w; cin >> h >> w;\n\t\timage = VVC(h, VC(w, '.'));\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tcin >> image[i][j];\n\t\t\t}\n\t\t}\n\n\t\t// Scan Image\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tif (image[i][j] != '.') {\n\t\t\t\t\tchar c = image[i][j];\n\t\t\t\t\tif (!EXIST(articles, c)) {\n\t\t\t\t\t\tarticle a = {c, false, 50, 0, 50, 0};\n\t\t\t\t\t\tarticles[c] = a;\n\t\t\t\t\t}\n\t\t\t\t\tarticles[c].topmost = min(articles[c].topmost, i);\n\t\t\t\t\tarticles[c].bottommost = max(articles[c].bottommost, i);\n\t\t\t\t\tarticles[c].leftmost = min(articles[c].leftmost, j);\n\t\t\t\t\tarticles[c].rightmost = max(articles[c].rightmost, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (remove_all()) {\n\t\t\tcout << \"SAFE\" << endl;\n\t\t} else {\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cctype>\n\nusing namespace std;\n\nint const INF = 1<<28;\n\nint main() {\n  \n  int Tc; cin >> Tc;\n  while(Tc--) {\n    int H, W; cin >> H >> W;\n    vector<vector<char> > a(H+2, vector<char>(W+2));\n    vector<int> minX(128, INF), minY(128, INF);\n    vector<int> maxX(128, -INF), maxY(128, -INF);\n    vector<int> vec;\n    for(int i=0; i<H; i++) {\n      for(int j=0; j<W; j++) {\n        cin >> a[i][j];\n        if(!isalpha(a[i][j])) continue;\n        int b = a[i][j];\n        vec.push_back(b);\n        maxX[b] = max(maxX[b], j);\n        maxY[b] = max(maxY[b], i);\n        minX[b] = min(minX[b], j);\n        minY[b] = min(minY[b], i);\n      }\n    }\n    if(vec.empty()) {\n      cout << \"SAFE\" << endl;\n      goto EXIT;\n    }\n    sort(vec.begin(), vec.end());\n    vec.erase(unique(vec.begin(), vec.end()), vec.end());\n    \n    do {\n      bool good = true;\n      vector<vector<char> > work(a);\n      \n      for(int I=0; I<vec.size(); I++) {\n        bool ok = true;\n        for(int i=minY[vec[I]]; i<=maxY[vec[I]]; i++) {\n          for(int j=minX[vec[I]]; j<=maxX[vec[I]]; j++) {\n            if(work[i][j] == '#') {\n            }\n            if(work[i][j] != '#' && work[i][j] != (char)vec[I]) {\n              ok = false;\n              break;\n            }\n          }\n          if(!ok) break;\n        } // for i\n        if(!ok) { good = false; break; }\n        for(int i=minY[vec[I]]; i<=maxY[vec[I]]; i++)\n          for(int j=minX[vec[I]]; j<=maxX[vec[I]]; j++) {\n            work[i][j] = '#';\n          }\n      }\n      \n      if(good) {\n        cout << \"SAFE\" << endl;\n        goto EXIT;\n      }\n    } while(next_permutation(vec.begin(), vec.end()));\n    \n    cout << \"SUSPICIOUS\" << endl;\n    \n  EXIT:;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\nint n;\nint H,W,T;\nstring str;\nbool used[26],flg;\n\nint A[26],B[26],C[26],D[26];\n\nchar t[50][50];\n\nchar tmp;\n\nvoid input();\nvoid init();\n\nbool check(char ch){\n  int z= ch-'A';\n  for(int i=A[z];i<=C[z];i++){\n    for(int j=D[z];j<=B[z];j++){\n      if(t[i][j]=='?')continue;\n      if(t[i][j]!=ch)return false;\n    }\n  }\n  return true;\n}\n\nvoid draw(char ch){\n  int z=ch-'A';\n  for(int i=A[z];i<=C[z];i++){\n    for(int j=D[z];j<=B[z];j++){\n      t[i][j]='?';\n    }\n  }\n}\n\nint main(){\n  cin>>T;\n  while(T--){\n    init();\n    input();\n\n    while(1){\n \n      flg=false;\n\n      for(int i=0;i<26;i++){\n\tif(used[i]==false)continue;\n\tif(check(i+'A')==true){\n\t  flg=true;\n\t  draw(i+'A');\n\t  used[i]=false;\n\t  break;\n\t}\n      }\n      if(flg==false)break;\n    }\n\n    flg=false;\n    for(int i=0;i<26;i++)flg|=used[i];\n    cout<<(flg?\"SUSPICIOUS\":\"SAFE\")<<endl;\n  }\n  return 0;\n}\n\nvoid input(){\n  int X;\n  cin>>H>>W;\n  for(int i=0;i<H;i++){\n    cin>>str;\n    for(int j=0;j<W;j++){\n      t[i][j]=str[j];\n      if(t[i][j]=='.')continue;\n      X=t[i][j]-'A';\n      used[X]=true;\n      A[X]=min(A[X],i);\n      B[X]=max(B[X],j);\n      C[X]=max(C[X],i);\n      D[X]=min(D[X],j);\n    }\n  }\n}\n\nvoid init(){\n  for(int i=0;i<26;i++){\n    A[i]=50;\n    B[i]=0;\n    C[i]=0;\n    D[i]=50;\n    used[i]=false;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\nclass Object{\npublic:\n  Object(char col){ miny = minx = INF; maxy = maxx = -1; on.clear(); c = col; }\n  int miny, minx, maxy, maxx;\n  set<int> on;\n  char c;\n};\n\nint h, w;\nvector<Object> objects;\nbool used[26];\nmap<char, int> ctoi;\nchar input[50][50];\nbool visited[50][50];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nbool dfs1(int y, int x){\n  Object &obj = objects[ctoi[input[y][x]]];\n  visited[y][x] = true;\n  if(obj.miny > y) obj.miny = y;\n  if(obj.minx > x) obj.minx = x;\n  if(obj.maxy < y) obj.maxy = y;\n  if(obj.maxx < x) obj.maxx = x;\n  for(int i=0;i<4;i++){\n    int ty = y + dy[i];\n    int tx = x + dx[i];\n    if(ty<0 || ty>=h) continue;\n    if(tx<0 || tx>=w) continue;\n    if(visited[ty][tx]) continue;\n    if(input[ty][tx] != input[y][x]) continue;\n    dfs1(ty, tx);\n  }\n  return true;\n}\n\nbool dfs2(int n){\n  used[objects[n].c - 'A'] = true;\n  set<int>::iterator ite = objects[n].on.begin();\n  for(;ite != objects[n].on.end();ite++){\n    if(used[objects[*ite].c - 'A']) return false;\n    if(!dfs2(*ite)) return false;\n  }\n  return true;\n}\n\n/*void dfs(int y, int x){\n  for(int i=0;i<4;i++){\n    int ty = y + dy[i];\n    int tx = x + dx[i];\n    if(ty<0 || ty>=h) continue;\n    if(tx<0 || tx>=w) continue;\n    if(data[ty][tx] != -1) continue;\n    if(input[ty][tx] != input[y][x]) continue;\n    \n  }\n  }*/\n\nmain(){\n  int t;\n  cin >> t;\n  while(t--){\n    cin >> h >> w;\n    objects.clear();\n    ctoi.clear();\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> input[i][j];\n      }\n    }\n\n    fill(visited[0], visited[50], false);    \n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(input[i][j] != '.' && !visited[i][j]){\n\t  if(ctoi.find(input[i][j]) == ctoi.end()){\n\t    ctoi[input[i][j]] = objects.size();\n\t    objects.push_back(Object(input[i][j]));\n\t  }\n\t  dfs1(i, j);\n\t}\n      }\n    }\n\n    bool ans = true;\n\n    for(int i=0;i<objects.size();i++){\n      for(int j=objects[i].miny;j<=objects[i].maxy;j++){\n\tfor(int k=objects[i].minx;k<=objects[i].maxx;k++){\n\t  if(input[j][k] != '.' && input[j][k] != objects[i].c){\n\t    objects[i].on.insert(ctoi[input[j][k]]);\n\t  }else if(input[j][k] == '.'){\n\t    ans = false;\n\t    break;\n\t  }\n\t}\n\tif(!ans) break;\n      }\n      if(!ans) break;\n    }\n\n    //loop\n    for(int i=0;i<objects.size();i++){\n      fill(used, used+26, false);\n      if(!dfs2(i)){\n\tans = false;\n\tbreak;\n      }\n      /*cout << i << \"    \";\n      for(int i=0;i<26;i++){\n\tif(used[i]){\n\t  cout << (char)(i+'A')<< ' ';\n\t}\n      }\n      cout << endl;*/\n    }\n\n    /*for(int i=0;i<objects.size();i++){\n      cout << objects[i].c << endl;\n      set<int>::iterator ite = objects[i].on.begin();\n      for(;ite != objects[i].on.end();ite++){\n\tcout << objects[*ite].c << ' ';\n      }\n      cout << endl << endl;\n      }*/\n\n    //tyouhou\n\n    //for(int i=0;i<objects.size();i++){\n      \n    //}\n    if(ans){\n      cout << \"SAFE\" << endl;\n    }else{\n      cout << \"SUSPICIOUS\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nvoid chmin(int& x, int y)\n{\n  x = min(x, y);\n}\nvoid chmax(int& x, int y)\n{\n  x = max(x, y);\n}\n \nint main()\n{\n  int Q, H, W;\n  string S[50];\n  int proc = 1;\n  int used[50][50] = {{}};\n \n  cin >> Q;\n  while(Q--) {\n    cin >> H >> W;\n \n    string chars = \"\";\n    for(int i = 0; i < H; i++) {\n      cin >> S[i];\n      chars += S[i];\n    }\n    sort(chars.begin(), chars.end());\n    chars.erase(unique(chars.begin(), chars.end()), chars.end());\n    vector< int > x1(chars.size(), W), x2(chars.size(), 0);\n    vector< int > y1(chars.size(), H), y2(chars.size(), 0);\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        int pos = chars.find(S[i][j]);\n        chmin(x1[pos], j);\n        chmax(x2[pos], j);\n        chmin(y1[pos], i);\n        chmax(y2[pos], i);\n      }\n    }\n    map< char, int > xx1, xx2, yy1, yy2;\n    for(int i = 0; i < chars.size(); i++) {\n      xx1[chars[i]] = x1[i];\n      xx2[chars[i]] = x2[i];\n      yy1[chars[i]] = y1[i];\n      yy2[chars[i]] = y2[i];\n    }\n \n    bool Judge = false;\n \n    do {\n      Judge = true;\n      for(int i = 0; i < chars.size(); i++) {\n        for(int j = xx1[chars[i]]; j <= xx2[chars[i]]; j++) {\n          for(int k = yy1[chars[i]]; k <= yy2[chars[i]]; k++) {\n            if(used[j][k] == proc) continue;\n            used[j][k] = proc;\n            if(S[k][j] != chars[i]) {\n              Judge = false;\n              goto myon;\n            }\n          }\n        }\n      }\n    myon: ;\n      ++proc;\n    } while(!Judge && next_permutation(chars.begin() + 1, chars.end()));\n    if(Judge) cout << \"SAFE\" << endl;\n    else cout << \"SUSPICIOUS\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) REP(i, 0, (n))\n#define REP(i, a, n) for(int i=(a); i<(n); i++)\n\nstruct Area {\n    int tly, tlz, bry, brz;\n    Area(): tly(100), tlz(100), bry(-1), brz(-1) {}\n};\n\nint w, h;\nchar C[50][50];\nmap<char, set<char>> rels;\nbool visited[26];\n\nbool dfs(char c) {\n    if(visited[c-'A']) return false;\n    visited[c-'A'] = true;\n    bool ret = true;\n    for(char u: rels[c]) ret = ret && dfs(u);\n    visited[c-'A'] = false;\n    return ret;\n}\n\nint main() {\n\tint n; cin >> n;\n\trep(i, n) {\n\t    cin >> h >> w;\n\t    rep(i, h) scanf(\"%s\", &C[i]);\n\n\t    map<char, Area> objs;\n\t    rep(i, h) {\n\t        rep(j, w) {\n\t            if(C[i][j] == '.') continue;\n\t            objs[C[i][j]].tly = min(i, objs[C[i][j]].tly);\n\t            objs[C[i][j]].tlz = min(j, objs[C[i][j]].tlz);\n\t            objs[C[i][j]].bry = max(i, objs[C[i][j]].bry);\n\t            objs[C[i][j]].brz = max(j, objs[C[i][j]].brz);\n\t        }\n\t    }\n\t    bool issafe = true;\n\t    for(auto o: objs) {\n\t        rels[o.first].clear();\n\t        REP(i, o.second.tly, o.second.bry+1) {\n\t            REP(j, o.second.tlz, o.second.brz+1) {\n\t                if(C[i][j] == '.') issafe = false;\n\t                else if(C[i][j] != o.first) {\n                        rels[o.first].insert(C[i][j]);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    memset(visited, false, 26);\n\t    for(auto o: objs) issafe = issafe && dfs(o.first);\n\t    cout << (issafe? \"SAFE\":\"SUSPICIOUS\") << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\nbool used[64][64];\nstring s[64];\nint main(){\n\tint n;\tcin>>n;\n\twhile(n--){\n\t\tint h,w;\tcin>>h>>w;\n\t\tfor(int i=0;i<h;i++)\tfor(int j=0;j<w;j++)\tused[i][j]=false;\n\t\tfor(int i=0;i<h;i++)\tcin>>s[i];\n\t\tmap<char,int> u,d,l,r;\n\t\tfor(int i=0;i<h;i++)\tfor(int j=0;j<w;j++){\n\t\t\tif(s[i][j]!='.'){\n\t\t\t\tif(u.find(s[i][j])==u.end())\tu[s[i][j]]=i;\n\t\t\t\td[s[i][j]]=i;\n\t\t\t\tif(l.find(s[i][j])==l.end())\tl[s[i][j]]=j;\n\t\t\t\telse \tl[s[i][j]]=min(l[s[i][j]],j);\n\t\t\t\tif(r.find(s[i][j])==r.end())\tr[s[i][j]]=j;\n\t\t\t\telse \tr[s[i][j]]=max(r[s[i][j]],j);\n\t\t\t}\n\t\t}\n\t\tbool ok=true;\n\t\tint m=l.size();\n\t\twhile(m){\n\t\t\tbool end=true;\n\t\t\tfor(auto it:l){\n\t\t\t\tchar key=it.first;\n\t\t\t\tint L=it.second;\n\t\t\t\tint R=r[key],U=u[key],D=d[key];\n\t\t\t\t//cout<<key<<\" \"<<U<<\"-\"<<D<<\" \"<<L<<\"-\"<<R<<endl;\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(int i=U;i<=D;i++){\n\t\t\t\t\tfor(int j=L;j<=R;j++){\n\t\t\t\t\t\tif(s[i][j]==key||used[i][j])\tcontinue;\n\t\t\t\t\t\tok=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(!ok)\tbreak;\n\t\t\t\t}\n\t\t\t\tif(ok){\n\t\t\t\t\tm--;\n\t\t\t\t\tfor(int i=U;i<=D;i++)\tfor(int j=L;j<=R;j++){\n\t\t\t\t\t\tused[i][j]=true;\n\t\t\t\t\t}\n\t\t\t\t\tu.erase(key);\td.erase(key);\n\t\t\t\t\tl.erase(key);\tr.erase(key);\n\t\t\t\t\tend=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(end){\n\t\t\t\tcout<<\"SUSPICIOUS\"<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(m==0)\tcout<<\"SAFE\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nstring str[60];\nint h,w;\nint num;\nbool flag;\nbool used[55][55];\nchar moji[10];\nint vx[4]={1,0,-1,0};\nint vy[4]={0,1,0,-1};\nvoid dfs(int Bit,int depth){\n  if(depth==((1<<num)-1)){\n    flag=true;\n    return;\n  }\n  for(int i=0;i<num;i++){\n    if(!(Bit&(1<<i))){\n      bool used2[55][55]={};\n      for(int j=0;j<h;j++){\n\tfor(int k=0;k<w;k++){\n\t  if(moji[i]==str[j][k]){\n\t    queue<pair<int,int> >que;\n\t    que.push(mp(j,k));\n\t    used2[j][k]=true;\n\t    used[j][k]=true;\n\t    while(!(que.empty())){\n\t      pair<int,int>now=que.front();\n\t      que.pop();\n\t      for(int l=0;l<4;l++){\n\t\tint x=now.F+vx[l],y=now.S+vy[l];\n\t\tif(x>=0&&x<h&&y>=0&&y<w&&(!used2[x][y])){\n\t\t  que.push(mp(x,y));\n\t\t  if(used[x][y]==false)\n\t\t    used2[x][y]=true;\n\t\t  used[x][y]=true;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      int lemi=100,lema=0,rimi=100,rima=0;\n      for(int j=0;i<h;i++){\n\tfor(int k=0;k<w;k++){\n\t  if(used2[j][k]){\n\t    lemi=min(lemi,k);\n\t    lema=max(lema,k);\n\t    rima=max(rima,j);\n\t    rimi=max(rimi,j);\n\t  }\n\t}\n      }\n      for(int j=rimi;j<=rima;j++){\n\tfor(int k=lemi;k<=lema;k++){\n\t  if(used[j][k])\n\t    return;\n\t}\n      }\n      dfs(Bit+(1<<i),depth+1);\n      for(int j=0;j<h;j++){\n\tfor(int k=0;k<w;k++){\n\t  if(used2[j][k]){\n\t    used[j][k]=false;\n\t  }\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int n;cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>h>>w;\n    num=0;\n    for(int i=0;i<55;i++)\n      for(int j=0;j<55;j++)\n\tused[i][j]=false;\n    flag=false;\n    bool alfa[26]={};\n    for(int i=0;i<h;i++){\n      cin>>str[i];\n      for(int j=0;j<w;j++){\n\talfa[str[i][j]-'A']=true;\n      }\n    }\n    int cnt=0;\n    for(int i=0;i<26;i++){\n      num+=alfa[i];\n      if(alfa[i]){\n\tmoji[cnt]=(char)(i+'A');\n\tcnt++;\n      }\n    }\n    dfs(0,0);\n    if(flag)\n      cout<<\"SAFE\"<<endl;\n    else cout<<\"SUSPICIOUS\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <string>\n#include <cmath>\n#include <map>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int inf = 100100100;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int number;\n  cin >> number;\n  rep(aaaaaaa,number){\n      int h,w;\n      bool flag =true;\n      cin >> h >> w;\n      string s[55]={};\n      map<char,bool> m;\n      rep(y,h){\n          cin >> s[y];\n      }\n      rep(y,h)rep(x,w){\n          if(s[y][x]!='.'){\n              if(m[s[y][x]]){\n                  flag = false;\n                  x=w;y=h;break;\n              }\n              int st = x;\n              char tc = s[y][x];\n              m[tc] = true;\n              while(s[y][x]==tc) x++;\n              int et = x;\n              int yy = y;\n              while(s[yy][st]==tc){\n                  REP(xx,st,et) {\n                      if(s[yy][xx]!=tc){flag=false;}\n                      s[yy][xx]='.';\n                  }\n                  yy+=1;\n              }\n              rep(ya,h) cout << s[ya] << endl;\n              x--;\n          }\n      }\n      rep(y,h)rep(x,w){\n         if(s[y][x]!='.') flag = false;\n      }\n      if(flag) cout << \"SAFE\" << endl;\n      else cout << \"SUSPICIOUS\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \nvoid chmin(int& x, int y)\n{\n  x = min(x, y);\n}\nvoid chmax(int& x, int y)\n{\n  x = max(x, y);\n}\n  \nint main()\n{\n  int Q, H, W;\n  string S[50];\n  int proc = 1;\n  int used[50][50] = {{}};\n  \n  cin >> Q;\n  while(Q--) {\n    cin >> H >> W;\n  \n    string chars = \"\";\n    for(int i = 0; i < H; i++) {\n      cin >> S[i];\n      chars += S[i];\n    }\n    sort(chars.begin(), chars.end());\n    chars += \".\";\n    chars.erase(unique(chars.begin(), chars.end()), chars.end());\n    vector< int > x1(chars.size(), W), x2(chars.size(), 0);\n    vector< int > y1(chars.size(), H), y2(chars.size(), 0);\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        int pos = chars.find(S[i][j]);\n        chmin(x1[pos], j);\n        chmax(x2[pos], j);\n        chmin(y1[pos], i);\n        chmax(y2[pos], i);\n      }\n    }\n    int xx1[128], xx2[128], yy1[128], yy2[128];\n    for(int i = 0; i < chars.size(); i++) {\n      xx1[chars[i]] = x1[i];\n      xx2[chars[i]] = x2[i];\n      yy1[chars[i]] = y1[i];\n      yy2[chars[i]] = y2[i];\n    }\n    \n    bool Judge = chars.size() == 1;\n    do {\n      if(chars[chars.size() - 1] != '.') continue;\n      Judge = true;\n      for(int i = 0; i < chars.size(); i++) {\n        for(int j = xx1[chars[i]]; j <= xx2[chars[i]]; j++) {\n          for(int k = yy1[chars[i]]; k <= yy2[chars[i]]; k++) {\n            if(used[j][k] == proc) continue;\n            used[j][k] = proc;\n            if(S[k][j] != chars[i]) {\n              Judge = false;\n              goto myon;\n            }\n          }\n        }\n      }\n    myon: ;\n      ++proc;\n    } while(!Judge && next_permutation(chars.begin(), chars.end()));\n    if(Judge) cout << \"SAFE\" << endl;\n    else cout << \"SUSPICIOUS\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nusing namespace std;\n\n#define MAX 50\n\nint main(){\n\n\tint n;\n\tint H,W;\n\n\tstring pict[MAX];\n\tint zai['Z'-'A'+1][MAX][MAX];\n\t/*\n\t0..??????\n\t1..?????????\n\t2..??°\n\t3..??????\n\t*/\n\tbool zok['Z'-'A'+1];\n\n\tcin>>n;\n\twhile(n--){\n\t\tcin>>H>>W;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tcin>>pict[i];\n\t\t}\n\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tfor(int k=0;k<='Z'-'A';k++){\n\t\t\t\t\tzai[k][i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<='Z'-'A';i++){\n\t\t\tzok[i]=false;\n\t\t}\n\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tif(pict[i][j]!='.'){\n\t\t\t\t\tzai[pict[i][j]-'A'][i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(1){\n\t\t\tbool ex=true;\n\t\t\tfor(int i=0;i<='Z'-'A';i++){\n\t\t\t\tif(zok[i]) continue;\n\t\t\t\tbool fok=true;\n\t\t\t\tfor(int j=0;j<H;j++){\n\t\t\t\t\tfor(int k=0;k<W;k++){\n\t\t\t\t\t\tif(zai[i][j][k]==1) fok=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(fok) zok[i]=true;\n\t\t\t}\n\t\t\tfor(int i=0;i<='Z'-'A';i++){\n\t\t\t\tif(zok[i]) continue;\n\t\t\t\tint mu=-1,mb=-1,mr=-1,ml=-1;\n\t\t\t\tfor(int j=0;j<H&&mu==-1;j++){\n\t\t\t\t\tfor(int k=0;k<W&&mu==-1;k++){\n\t\t\t\t\t\tif(zai[i][j][k]==1) mu=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j=H-1;j>=0&&mb==-1;j--){\n\t\t\t\t\tfor(int k=0;k<W&&mb==-1;k++){\n\t\t\t\t\t\tif(zai[i][j][k]==1) mb=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<W&&ml==-1;j++){\n\t\t\t\t\tfor(int k=0;k<H&&ml==-1;k++){\n\t\t\t\t\t\tif(zai[i][k][j]==1) ml=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j=W-1;j>=0&&mr==-1;j--){\n\t\t\t\t\tfor(int k=0;k<H&&mr==-1;k++){\n\t\t\t\t\t\tif(zai[i][k][j]==1) mr=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbool sqf=true;\n\t\t\t\tfor(int j=mu;j<=mb;j++){\n\t\t\t\t\tfor(int k=ml;k<=mr;k++){\n\t\t\t\t\t\tif(zai[i][j][k]==0) sqf=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(sqf){\n\t\t\t\t\tex=false;\n\t\t\t\t\tfor(int j=mu;j<=mb;j++){\n\t\t\t\t\t\tfor(int k=ml;k<=mr;k++){\n\t\t\t\t\t\t\tfor(int l=0;l<='Z'-'A';l++){\n\t\t\t\t\t\t\t\tif(l!=i) zai[l][j][k]=2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tzai[i][j][k]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ex) break;\n\t\t}\n\t\tbool ansf=true;\n\t\tfor(int i=0;i<='Z'-'A';i++){\n\t\t\tfor(int j=0;j<H;j++){\n\t\t\t\tfor(int k=0;k<W;k++){\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!zok[i]) ansf=false;\n\t\t}\n\t\tif(ansf) cout<<\"SAFE\"<<endl;\n\t\telse cout<<\"SUSPICIOUS\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int n,h,w;\n  string pict[50];\n  int rr,rd,lu,ll;\n  bool flag;\n  set<int> child[26];\n\n  cin >> n;\n  while(n){\n    n--;\n    cin >> h >> w;\n    for(int i=0;i<h;i++)cin >> pict[i];\n    for(int i=0;i<26;i++)child[i].clear();\n\n    flag = true;\n    for(int i='A';i<='Z';i++){\n      rr = 0;\n      rd = 0;\n      lu = h;\n      ll = w;\n      for(int j=0;j<h;j++){\n\tfor(int k=0;k<w;k++){\n\t  if(pict[j][k] == i){\n\t    rr = max(rr,k);\n\t    rd = max(rd,j);\n\t    lu = min(lu,j);\n\t    ll = min(ll,k);\n\t  }\n\t}\n      }\n\n      for(int j=lu;j<=rd;j++){\n\tfor(int k=ll;k<=rr;k++){\n\t  if(pict[j][k] == '.'){\n\t    flag = false;\n\t    break;\n\t  }else if(pict[j][k] != i){\n\t    child[pict[j][k] - 'A'].insert(i-'A');\n\n\t    bool f = false;\n\n\t    queue<int> par;\n\t    par.push(i - 'A');\n\t    while(!par.empty()){\n\t      int now = par.front();\n\t      par.pop();\n\t      if(now == pict[j][k] - 'A'){\n\t\tf = true;\n\t\tbreak;\n\t      }\n\n\t      set<int>::iterator ite;\n\t      for(ite = child[now].begin();ite!=child[now].end();ite++){\n\t\tpar.push(*ite);\n\t      }\n\t    }\n\t    if(f){\n\t      flag = false;\n\t      break;\n\t    }\n\t  }\n\t}\n\tif(!flag)break;\n      }\n      if(!flag)break;\n    }\n    if(!flag)cout << \"SUSPICOUS\" << endl;\n    else cout << \"SAFE\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nstruct make\n{\n\tchar str;\n\tint posi,start[2];\n\tint high,wide,JUDGE;//JUDGE==1で長方形,==0で長方形以外,==2で未定\n\tstruct make *front[8];\n};\n\n\nint main()\n{\n\tint N,H,W,count,COUNT,judge,no_rect,NO_RECT;\n\tchar img[1000][51];\n\tstruct make M[8];\n\tint s1,s2,num;\n\t\n\tscanf(\"%d\",&N);//データの個数\n\tfor(int a=0;a<N;a++)\n\t{\n\t\tcount=0;//材質の個数\n\t\tCOUNT=0;\n\t\tNO_RECT=0;\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tscanf(\"%s\",img[b]);\n\t\t\timg[b][W]='\\0';\n\t\t}\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tfor(int d=0;d<count;d++) M[d].posi=-1;\n\t\t\tfor(int c=0;c<W;c++)\n\t\t\t{\n\t\t\t\tif(img[b][c]!='.')\n\t\t\t\t{\n\t\t\t\t\t//材質判定\n\t\t\t\t\tjudge=0;\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t\tif(count>0 && img[b][c]!=M[judge].str) judge++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}while(judge<count);\n\t\t\t\t\t//新しい材質の場合\n\t\t\t\t\tif(judge==count)\n\t\t\t\t\t{\n\t\t\t\t\t\tM[count].str=img[b][c];\n\t\t\t\t\t\tM[count].start[0]=b;\n\t\t\t\t\t\tM[count].start[1]=c;\n\t\t\t\t\t\tM[count].posi=c;\n\t\t\t\t\t\tM[count].high=1;\n\t\t\t\t\t\tM[count].wide=1;\n\t\t\t\t\t\tM[count].JUDGE=0;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\t//既出の材質の場合\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(M[judge].start[1]>c) M[judge].start[1]=c;\n\t\t\t\t\t\tif(M[judge].posi<0) M[judge].posi=c;\n\t\t\t\t\t\telse if(M[judge].wide<c-M[judge].posi+1) M[judge].wide=c-M[judge].posi+1;\n\t\t\t\t\t\tM[judge].high=b-M[judge].start[0]+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tno_rect=count;\n\t\t//printf(\"count=%d\\n\",count);\n\t\t//判定開始\n\t\twhile(count)//文字アリ\n\t\t{\n\t\t\tCOUNT=0;\n\t\t\t//見えている部分が長方形かどうか判定\n\t\t\tfor(num=0;num<count;num++)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(M[num].JUDGE==1) continue;\n\t\t\t\tM[num].JUDGE=0;//長方形なら\n\t\t\t\t//printf(\"M[%d].str=%c\\nM[%d].high=%d\\nM[%d].wide=%d\\n\",num,M[num].str,num,M[num].high,num,M[num].wide);\n\t\t\t\t//printf(\"M[%d].start[0]=%d\\nM[%d].start[1]=%d\\n\",num,M[num].start[0],num,M[num].start[1]);\n\t\t\t\tfor(s1=0;s1<M[num].high;s1++)\n\t\t\t\t{\n\t\t\t\t\tfor(s2=0;s2<M[num].wide;s2++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//確実に長方形ではない場合\n\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]=='.')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNO_RECT=1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//長方形の可能性もある場合\n\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]!=M[num].str && img[s1+M[num].start[0]][s2+M[num].start[1]]!='#' )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//printf(\"s1=%d s2=%d\\n\",s1,s2);\n\t\t\t\t\t\t\tM[num].JUDGE=2;\n\t\t\t\t\t\t\tCOUNT++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(NO_RECT || M[num].JUDGE==2) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(NO_RECT || M[num].JUDGE==2) break;\n\t\t\t\t}\n\t\t\t\tif(NO_RECT) break;\n\t\t\t\t//長方形だった場合\n\t\t\t\tif(s1==M[num].high && s2==M[num].wide)\n\t\t\t\t{\n\t\t\t\t\tM[num].JUDGE=1;\n\t\t\t\t\tno_rect--;\n\t\t\t\t\tfor(int s1=0;s1<M[num].high;s1++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int s2=0;s2<M[num].wide;s2++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\timg[s1+M[num].start[0]][s2+M[num].start[1]]='#';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//printf(\"M[%d].JUDGE=%d\\n\\n\",num,M[num].JUDGE);\n\t\t\t}\n\t\t\tfor(int n=0;n<num;)\n\t\t\t{\n\t\t\t\tif(M[num].JUDGE!=2) break;\n\t\t\t\tn++;\n\t\t\t\t//どれも長方形ではなかった場合\n\t\t\t\tif(n==num) NO_RECT=1;\n\t\t\t}\n\t\t\t\n\t\t\t//printf(\"NO_RECT=%d\\n\",NO_RECT);\n\t\t\tif(NO_RECT==1) break;\n\t\t\t//printf(\"#no_rect=%d\\n\\n\\n\",no_rect);\n\t\t\t//すべて長方形\n\t\t\tif(no_rect==0) break;\n\t\t}\n\t\t//出力\n\t\tif(NO_RECT) printf(\"SUSPICIOUS1\\n\");\n\t\telse if(no_rect) printf(\"SUSPICIOUS2\\n\");\n\t\telse printf(\"SAFE1\\n\");\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nstruct node {\n  vector<char> v;\n  int mx, my, Mx, My;\n  node() {}\n  node(vector<char> v, int mx, int my, int Mx, int My):\n    v(v), mx(mx), my(mx), Mx(Mx), My(My) {}\n  bool operator < (const node & n) const {\n    return mx < n.mx;\n  }\n};\n\nmap<char, node> G;\n\nchar field[50 + 2][50 + 2];\n\nint main()\n{\n  int numberOfInput;\n  scanf(\"%d \", &numberOfInput);\n  for (int caseIndex = 0; caseIndex < numberOfInput; caseIndex++) {\n    int H, W;\n    scanf(\"%d %d \", &H, &W);\n    for (int i = 0; i < H; i++) {\n      fill(field[i], &field[i][52], '.');\n    }\n    for (int i = 1; i <= H; i++) {\n      for (int j = 1; j <= W; j++) {\n\tscanf(\"%c \", &field[i][j]);\n\tif (field[i][j] != '.') {\n\t  G[field[i][j]] = node(vector<char>(), 0, 0, 0, 0);\n\t}\n      }\n    }\n    \n    for (map<char, node>::iterator it = G.begin(); \n\t it != G.end(); it++) {\n      char c = it->first;\n      int mx = 50, my = 50, Mx = -1, My = -1;\n      for (int i = 1; i <= H; i++) {\n\tfor (int j = 1; j <= W; j++) {\n\t  if (field[i][j] == c) {\n\t    mx = min(mx, j);\n\t    my = min(my, i);\n\t    Mx = max(Mx, j);\n\t    My = max(My, i);\n\t  }\n\t}\n      }\n      G[c] = node(vector<char>(), mx, my, Mx, My);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nstring str[100];\nint h,w;\nint num;\nbool flag;\nbool used[55][55];\nchar moji[10];\nint vx[4]={1,0,-1,0};\nint vy[4]={0,1,0,-1};\nvoid dfs(int Bit,int depth){\n  if(Bit==((1<<num)-1)){\n    flag=true;\n    return;\n  }\n  for(int i=0;i<num;i++){\n    if(!(Bit&(1<<i))){\n      bool used2[100][100]={};\n      int lemi=100,lema=0,rimi=100,rima=0;\n      for(int j=0;j<h;j++){\n\tfor(int k=0;k<w;k++){\n\t  if(str[j][k]==moji[i]){\n\t    used2[j][k]=true;\n\t    used[j][k]=true;\n\t    lemi=min(lemi,k);\n\t    lema=max(lema,k);\n\t    rima=max(rima,j);\n\t    rimi=min(rimi,j);\n\t  }\n\t}\n      }\n      bool fll=true;\n      for(int j=rimi;j<=rima;j++){\n\tfor(int k=lemi;k<=lema;k++){\n\t  if(!used[j][k]){\n\t    fll=false;\n\t  }\n\t}\n      }\n      if(fll)\n\tdfs(Bit+(1<<i),depth+1);\n      for(int j=rimi;j<=rima;j++){\n\tfor(int k=lemi;k<=lema;k++){\n\t  if(used2[j][k]){\n\t    used[j][k]=false;\n\t  }\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int n;cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>h>>w;\n    num=0;\n    for(int i=0;i<55;i++)\n      for(int j=0;j<55;j++)\n\tused[i][j]=false;\n    flag=false;\n    bool alfa[26]={};\n    for(int i=0;i<h;i++){\n      cin>>str[i];\n      for(int j=0;j<w;j++){\n\talfa[str[i][j]-'A']=true;\n      }\n    }\n    int cnt=0;\n    for(int i=0;i<26;i++){\n      if(alfa[i]){\n\tnum++;\n\tmoji[cnt]=(char)(i+'A');\n\tcnt++;\n      }\n    }\n    dfs(0,0);\n    if(flag)\n      cout<<\"SAFE\"<<endl;\n    else \n      cout<<\"SUSPICIOUS\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define out(S) cout<<(S)<<endl;\n#define ShowAll(collection) for(auto i:collection){out(i);}\n#define beginend(v) v.begin(),v.end()\n\nusing pii=pair<int,int>;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvc=vector<vector<char>>;\ntemplate<typename T> void removeAt(vector<T>& v, int index) { v.erase(v.begin() + index); }\n\n\nbool isRect(const vvc& sq,int l,int r,int t,int b,char c){\n  for(int y=t;y<=b;++y)for(int x=l;x<=r;++x){\n    if(sq[y][x]!='-'&&sq[y][x]!=c) return false;\n  }\n  return true;\n}\n\nvoid trim(vvc& sq,int l,int r,int t,int b){\n  for(int y=t;y<=b;++y)for(int x=l;x<=r;++x) sq[y][x]='-';\n}\n\nbool isClear(vvc& sq,int h,int w){\n  rep(y,h)rep(x,w) if(sq[y][x]!='.'&&sq[y][x]!='-') return false;\n  return true;\n}\n\nbool solve3(vvc& sq,int h,int w,char c){\n  int t=h,b=0,l=w,r=0;\n  rep(y,h) rep(x,w) if(sq[y][x]==c){\n    t=min(t,y);\n    b=max(b,y);\n    l=min(l,x);\n    r=max(r,x);\n  }\n\n\n  if(isRect(sq,l,r,t,b,c)){\n    trim(sq,l,r,t,b);\n    return true;\n  }\n  return false;\n}\n\nbool solve2(vvc& sq,int h,int w){\n  map<char,bool> hash;\n  hash['-']=true;\n  hash['.']=true;\n  for(char c='A';c<='Z';c++) hash[c]=false;\n  rep(y,h)rep(x,w) {\n    if(!hash[sq[y][x]]){\n      if(solve3(sq,h,w,sq[y][x])) return true;\n    }\n    hash[sq[y][x]]=true;\n  }\n  return false;\n}\n\nbool solve(){\n  int h,w;\n  cin >> h>>w;\n  vvc box(h,vector<char>(w));\n  rep(y,h)rep(x,w){\n    cin >> box[y][x];\n  }\n\n  while(solve2(box,h,w));\n  \n\n  return isClear(box,h,w);\n}\n\nint main(){\n  int n;\n  cin >> n;\n  rep(i,n) if(solve()) cout << \"SAFE\" << endl; else cout << \"SUSPICIOUS\" << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nbool u[256][256],used[256];\n\nbool dfs(int x){\n  if(used[x])return 0;\n  used[x]=1;\n  bool res=1;\n  for(int i='A';i<='Z';i++)if(u[x][i])res&=dfs(i);\n  used[x]=0;\n  return res;\n}\n\nint main(){\n  int T;\n  cin>>T;\n  while(T--){\n    int h,w;\n    cin>>h>>w;\n    char c[50][50],d;\n    int x1[256],x2[256],y1[256],y2[256];\n    for(int i='A';i<='Z';i++){\n      x1[i]=y1[i]=1e9;\n      x2[i]=y2[i]=-1;\n    }\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tcin>>d;\n\tc[i][j]=d;\n\tx1[d]=min(x1[d],j);\n\ty1[d]=min(y1[d],i);\n\tx2[d]=max(x2[d],j);\n\ty2[d]=max(y2[d],i);\n      }\n    \n    bool ans=1;\n    memset(u,0,sizeof(u));\n    memset(used,0,sizeof(used));\n    for(int i='A';i<='Z';i++)\n      for(int y=y1[i];y<=y2[i];y++)\n\tfor(int x=x1[i];x<=x2[i];x++){\n\t  if(c[y][x]=='.')ans=0;\n\t  else if(c[y][x]!=i)u[c[y][x]][i]=1;\n\t}\n    \n    for(int i='A';i<='Z';i++){\n      memset(used,0,sizeof(used));\n      ans&=dfs(i);\n    }\n    cout<<(ans?\"SAFE\":\"SUSPICIOUS\")<<endl;  \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\n\nconst int INF = 1e9;\n\nstruct R {\n    int h1, w1, h2, w2;\n    R() : h1(INF), w1(INF), h2(-INF), w2(-INF) {}\n    void update(int h, int w) {\n        h1 = min(h1, h);\n        w1 = min(w1, w);\n        h2 = max(h2, h);\n        w2 = max(w2, w);\n    }\n    void print() {\n        cout << h1 << \" \" << w1 << \" \" << h2 << \" \" << w2 << endl;\n    }\n};\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int T;\n    cin >> T;\n    rep(testcase, T) {\n        int H, W;\n        cin >> H >> W;\n        vector<string> s(H);\n        set<char> itemset;\n        rep(i, H) {\n            cin >> s[i];\n            rep(j, W) {\n                if (s[i][j] != '.') {\n                    itemset.insert(s[i][j]);\n                }\n            }\n        }\n\n        if (itemset.empty()) {\n            cout << \"SAFE\" << endl;\n            continue;\n        }\n\n        map<char, R> mprect;\n        for (auto c : itemset) {\n            R r;\n            rep(i, H) rep(j, W) {\n                if (s[i][j] == c) {\n                    r.update(i, j);\n                }\n            }\n            mprect[c] = r;\n        }\n\n        vector<char> items(all(itemset));\n        auto check = [&]{\n            sort(all(items));\n            do {\n                vector<string> t(H, string(W, '.'));\n\n                for (auto c : items) {\n                    auto r = mprect[c];\n                    rep2(i, r.h1, r.h2 + 1) rep2(j, r.w1, r.w2 + 1) {\n                        t[i][j] = c;\n                    }\n                }\n\n                if (s == t) {\n                    cout << \"SAFE\" << endl;\n                    return true;\n                }\n            } while (next_permutation(all(items)));\n            return false;\n        };\n\n        if (!check()) {\n            cout << \"SUSPICIOUS\" << endl;\n        }\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n\nusing namespace std;\n\nint h,w;\nchar field[51][51];\nbool passed[51];\n\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\nint minx,miny,maxx,maxy;\n\nmap<char,int> key;\n\nint node;\n\nstruct nodeInfo{\n    int minx;\n    int miny;\n    int maxx;\n    int maxy;\n    char kind;\n};\n\nnodeInfo recInfo[51];\n\nvoid findRecSize (int y,int x,char kind){\n    for(int i = 0;i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(field[i][j]==kind){\n                miny=min(miny,i);\n                minx=min(minx,j);\n                maxy=max(maxy,i);\n                maxx=max(maxx,j);\n            }\n        }\n    }\n}\n\nvector<int> G[51];\n\nbool isClosing=false;\n\nvoid findClose(int s){\n    if(isClosing)\n        return;\n    if(passed[s]){\n        isClosing=true;\n        return;\n    }\n    passed[s]=true;\n    for(int i = 0; i < G[s].size(); i++){\n        findClose(G[s][i]);\n    }\n}\n\n\nint main(){\n\n    int n;\n    cin>>n;\n    while(n--){\n        for(int i = 0; i < 51; i++)\n            G[i].clear();\n        node=0;\n        key.clear();\n        cin>>h>>w;\n        memset(passed,0,sizeof(passed));\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin>>field[i][j];\n            }\n        }\n        bool no=false;\n        // ·û`»è\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                //if(!passed[i][j]&&field[i][j]!='.'){\n                char kind=field[i][j];\n                if(kind!='.'&&key.find(kind)==key.end()){\n                    // nodeðV½Éo^·é\n                    key[kind]=node;\n                    node++;\n                    minx=miny=100;\n                    maxx=maxy=-1;\n                    findRecSize(i,j,kind);\n                    recInfo[node-1].maxx=maxx;\n                    recInfo[node-1].maxy=maxy;\n                    recInfo[node-1].minx=minx;\n                    recInfo[node-1].miny=miny;\n                    recInfo[node-1].kind=kind;             \n                    // ß½x,y»ê¼êÌÀWîñ©ç¾çê½l¦¤é·û`Ì`ÌTõðs¤\n                    for(int k = miny; k <= maxy; k++){\n                        for(int l = minx; l <= minx; l++){\n                            // TõææÉ.ª¶Ýµ½êA·û`ÅÍÈ¢\n                            if(field[miny][minx]=='.'){\n                                no=true;\n                                break;\n                            }\n                        }\n                        if(no)\n                            break;\n                    }\n                    if(no)\n                        break;\n                }\n                if(no)\n                    break;\n            }\n        }\n        if(no){\n            cout<<\"SUSPICIOUS\"<<endl;\n            continue;\n        }\n\n        // dÈèÌ\n        // ãÌÙ¤©çºÌÙ¤ÖGbWð£é\n        bool isRootNode[101];\n        fill(isRootNode,isRootNode+101,true);\n        for(int l = 0; l < node; l++){\n            int mnx=recInfo[l].minx;\n            int mxx=recInfo[l].maxx;\n            int mny=recInfo[l].miny;\n            int mxy=recInfo[l].maxy;\n            char kind=recInfo[l].kind;\n            for(int i = mny; i <= mxy; i++){\n                for(int j = mnx; j <= mxx; j++){\n                    if(field[i][j]!=kind){\n                        int from=key[field[i][j]];\n                        int to=key[kind];\n                        // Ü¾GbWª¢o^\n                        if(find(G[from].begin(),G[from].end(),to)==G[from].end()){\n                            G[from].push_back(to);\n                            isRootNode[to]=false;\n                        }\n                    }\n                }\n            }\n        }\n        // ÂHª¶Ý·é©[gm[h©çTõ\n        memset(passed,0,sizeof(passed));\n        isClosing=false;\n        bool noRoot=true;\n        for(int i = 0; i < node; i++){\n            if(isRootNode[i]){\n                noRoot=false;\n                findClose(i);\n                if(isClosing){\n                    break;\n                }\n            }\n        }\n        if(key.size()!=0&&(isClosing||noRoot)){\n            cout<<\"SUSPICIOUS\"<<endl;\n            continue;\n        }\n        else\n            cout<<\"SAFE\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<iostream>\n#include<cmath>\n#include<map>\n#include<set>\n#include<climits>\n#include<ctime>\n#include<complex>\n#include<sstream>\n#include<cstring>\nusing namespace std;\ntypedef vector<string>vs;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\ntypedef vector<double>vd;\ntypedef pair<int,int>pii;\ntypedef long long ll;\ntypedef pair<ll,ll>pll;\ntypedef vector<ll>vl;\n#define rrep(i,x,n) for(int i=(x);i<(n);++i)\n#define rep(i,x) rrep(i,0,(x))\n#define fi first\n#define se second\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define maxs(a,b) (a)=max(a,b)\n#define mins(a,b) (a)=min(a,b)\n\nstruct data{\n    int x1,y1,x2,y2;\n    data(){\n        x1=y1=100;\n        x2=y2=-1;\n    }\n    void update(int x,int y){\n        x1=min(x1,x);x2=max(x2,x);\n        y1=min(y1,y);y2=max(y2,y);\n    }\n};\n\n\nbool used[26];\nint root;\nvi G[26];\nbool dfs(int pos){\n    if(used[pos]){\n        if(pos==root)return false;\n        return true;\n    }\n    used[pos]=true;\n    bool ret=true;\n    rep(i,G[pos].size()){\n        ret&=dfs(G[pos][i]);\n    }\n    return ret;\n}\nbool solve(){\n    int H,W;\n    char fld[64][64];\n    scanf(\"%d%d\",&H,&W);\n    rep(i,H)scanf(\"%s\",fld[i]);\n\n    map<char,data>M;\n\n    rep(i,H){\n        rep(j,W){\n            if(fld[i][j]=='.')continue;\n            data d=M[fld[i][j]];\n            d.update(j,i);\n            M[fld[i][j]]=d;\n        }\n    }\n\n    bool flag=true;\n\n    each(it,M){\n        data d=it->se;\n\n        for(int i=d.y1;i<=d.y2;i++){\n            for(int j=d.x1;j<=d.x2;j++){\n                if(fld[i][j]=='.'){\n                    flag=false;\n                    break;\n                }\n                if(fld[i][j]==it->fi)continue;\n                G[fld[i][j]-'A'].pb(it->fi-'A');\n            }\n        }\n    }\n\n    rep(i,26){\n        fill_n(used,26,false);\n        root=i;\n        flag&=dfs(i);\n    }\n    return flag;\n}\nint main(){\n    int N;\n    scanf(\"%d\",&N);\n    while(N--){\n        puts((solve()?\"SAFE\":\"SUSPICIOUS\"));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int T; cin >> T;\n    while (T--) {\n        int h, w; cin >> h >> w;\n        vector<string> grid(h);\n        vector<int> Top(26, h), Bottom(26, -1);\n        vector<int> Left(26, w), Right(26, -1);\n        for (int i = 0; i < h; i++) {\n            cin >> grid[i];\n            for (int j = 0; j < w; j++) if (grid[i][j] != '.') {\n                char c = grid[i][j] - 'A';\n                Top[c] = min(Top[c], i);\n                Bottom[c] = max(Bottom[c], i);\n                Left[c] = min(Left[c], j);\n                Right[c] = max(Right[c], j);\n            }\n        }\n        bool update = true;\n        while (update) {\n            update = false;\n            for (int k = 0; k < 26; k++) if (Bottom[k] + 1) {\n                bool is_rectangle = true;\n                for (int i = Top[k]; is_rectangle && i <= Bottom[k]; i++) {\n                    for (int j = Left[k]; is_rectangle && j <= Right[k]; j++) {\n                        if (grid[i][j] != 'A' + k && grid[i][j] != '#') {\n                            is_rectangle = false;\n                        }\n                    }\n                }\n                if (is_rectangle) {\n                    update = true;\n                    for (int i = Top[k]; i <= Bottom[k]; i++) {\n                        for (int j = Left[k]; j <= Right[k]; j++) {\n                            grid[i][j] = '#';\n                        }\n                    }\n                    Bottom[k] = -1;\n                }\n            }\n        }\n        bool ok = true;\n        for (int i = 0; i < h; i++) for (int j = 0; j < w; j++) {\n            ok &= grid[i][j] == '.' || grid[i][j] == '#';\n        }\n        puts(ok ? \"SAFE\" : \"SUSPICIOUS\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n#include <queue>\n#include <map>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, a, b) for(int i = a; i < b; i++)\n#define all(v) (v).begin(), (v).end()\n#define MP make_pair\n#define f first\n#define s second\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> P;\n\nvoid pp(vi v){\n\trep(i, v.size()){\n\t\tcout << v[i] << ' ';\n\t}\n\tcout << endl;\n}\n\nvoid pp(vector<string> v){\n\trep(i, v.size()){\n\t\tcout << v[i] << endl;\n\t}\n}\n\nvoid pp(int (*f)[21]){\n\trep(i, 21){\n\t\trep(j, 21){\n\t\t\tcout << f[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nbool checkIsRect(vector<string> &data, int leftx, int topy, int rightx, int bottomy, const char mat){\n\t// 外周\n\tfor(int j = topy-1; j <= bottomy+1; j++){\n\t\tif(data[j][leftx-1] == 'mat') return false;\n\t\tif(data[j][rightx+1] == 'mat') return false;\n\t}\n\tfor(int i = leftx-1; i <= rightx+1; i++){\n\t\tif(data[topy-1][i] == 'mat') return false;\n\t\tif(data[bottomy+1][i] == 'mat') return false;\n\t}\n\n\t// 内部\n\tfor(int j = topy; j <= bottomy; j++){\n\t\tfor(int i = leftx; i <= rightx; i++){\n\t\t\tif(data[j][i] != mat && data[j][i] != '#')return false;\n\t\t}\n\t}\n\n\t// 長方形が確定したら、物体のあった場所を影とする\n\tfor(int j = topy; j <= bottomy; j++){\n\t\tfor(int i = leftx; i <= rightx; i++){\n\t\t\tdata[j][i] = '#';\n\t\t}\n\t}\n\n\treturn true;\n}\n\nclass Edge{\npublic:\n\tint leftx;\n\tint topy;\n\tint rightx;\n\tint bottomy;\n\n\tbool ischecked;\n\n\tEdge(int x, int y){\n\t\tleftx = rightx = x;\n\t\ttopy = bottomy = y;\n\t\tischecked = false;\n\t}\n\n\tvoid updateEdge(int x, int y){\n\t\tleftx = min(leftx, x);\n\t\trightx = max(rightx, x);\n\t\ttopy = min(topy, y);\n\t\tbottomy = max(bottomy, y);\n\t}\n};\n\nbool checkBag(vector<pair<char, Edge> > &item, vector<string> &data){\n\t// 全ての荷物を調べる\n\tbool retry = false;\n\tbool safe = true;\n\trep(i, item.size()){\n\t\tEdge *e = &item[i].second;\n\t\tif(e->ischecked != true){\n\t\t\te->ischecked = checkIsRect(data, e->leftx, e->topy, e->rightx, e->bottomy, item[i].first);\n\t\t\tretry |= e->ischecked;\n\t\t}\n\t\tsafe &= e->ischecked;\n\t}\n\tif(safe) return true;\n\tif(retry) return checkBag(item, data);\n\treturn false;\n}\n\n\nvoid updateItem(vector<pair<char, Edge> > &item, char c, int y, int x){\n\trep(i, item.size()){\n\t\tif(item[i].first == c){ // 端点の更新\n\t\t\titem[i].second.updateEdge(x, y);\n\t\t\treturn;\n\t\t}\n\t}\n\titem.push_back(MP(c, Edge(x, y)));\n}\n\nint main(){\n\tint sets;\n\tcin >> sets;\n\twhile(sets--){\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tvector<string> data(h+2);\n\n\t\trep(i,w+2) data[0] += '.';\n\t\tdata[h+1] = data[0];\n\t\tFOR(i, 1, h+1){\n\t\t\tcin >> data[i];\n\t\t\tdata[i] = '.' + data[i] + '.';\n\t\t}\n\n\t\t// それぞれの文字について、左上、右下(と推測される座標)を得る\n\t\tvector<pair<char, Edge> > item;\n\t\trep(i, h+2){\n\t\t\trep(j, w+2){\n\t\t\t\tif(data[i][j] != '.' && data[i][j] != '#'){\n\t\t\t\t\tupdateItem(item, data[i][j], i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(item.size() == 0) cout << \"SAFE\" << endl;\n\t\telse{\n\t\t\tcout << (checkBag(item, data)?\"SAFE\":\"SUSPICIOUS\") << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <string>\n#include <cmath>\n#include <map>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int inf = 100100100;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int number;\n  cin >> number;\n  rep(aaaaaaa,number){\n      int h,w;\n      bool flag =true;\n      cin >> h >> w;\n      string s[55]={};\n      map<char,bool> m;\n      m['.'] = false;\n      rep(y,h){\n          cin >> s[y];\n      }\n      rep(y,h)rep(x,w){\n          if(s[y][x]!='.'){\n              if(m[s[y][x]]){\n                  flag = false;\n                  x=w;y=h;break;\n              }\n              int st = x;\n              char tc = s[y][x];\n              m[tc] = true;\n              while(s[y][x]==tc) x++;\n              int et = x;\n              int yy = y;\n              while(yy<h && s[yy][st]==tc){\n                  REP(xx,st,et) {\n                      if(s[yy][xx]!=tc){flag=false;}\n                      s[yy][xx]='.';\n                  }\n                  yy+=1;\n              }\n              // rep(ya,h) cout << s[ya] << endl;\n              x--;\n          }\n      }\n      rep(y,h)rep(x,w){\n         if(s[y][x]!='.') flag = false;\n      }\n      if(flag) cout << \"SAFE\" << endl;\n      else cout << \"SUSPICIOUS\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n#define EPS 1e-6\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nvoid search(vector<string> &s, char c){\n    int h = s.size(), w = s[0].size();\n    int l = 100, r = -1, t = 100, b = -1;\n    REP(i,h) REP(j,w){\n        if (s[i][j] == c){\n            l = min(l,j);\n            r = max(r,j);\n            t = min(t,i);\n            b = max(b,i);\n        }\n    }\n    if (l == 100) return;\n    bool rec = 1;\n    FOR(i,t,b) FOR(j,l,r){\n        if (s[i][j] != c && s[i][j] != '_') rec = 0;\n    }\n    if (!rec) return;\n    FOR(i,t,b) FOR(j,l,r){\n        s[i][j] = '_';\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    while (n--){\n        int h, w;\n        cin >> h >> w;\n        vector<string> s(h);\n        REP(i,h) cin >> s[i];\n        REP(z,7){\n            for (char c = 'A'; c <= 'Z'; c++){\n                search(s, c);\n            }\n        }\n        bool sup = 0;\n        REP(i,h) REP(j,w){\n            if (s[i][j] != '.' && s[i][j] != '_') sup = 1;\n        }\n        cout << (sup ? \"SUSPICIOUS\" : \"SAFE\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<set>\n\nusing namespace std;\n\n#define MAX(X,Y) ((X)>(Y) ? (X) : (Y))\n#define MIN(X,Y) ((X)<(Y) ? (X) : (Y))\n\nvoid dfs(set<char> graph[], char now, int &k, int dst[]) {\n    if(dst[now] != -1) return;\n    dst[now] = 100000;\n    for(char cn : graph[now])\n        dfs(graph, cn, k, dst);\n    dst[now] = k++;\n}\n\nbool strong(set<char> graph[], set<char> rev[]) {\n    int ord[256];\n    memset(ord, 0xFF, sizeof(ord));\n    int k=0;\n    for(char c='A'; c<='Z'; c++)\n        dfs(graph, c, k, ord);\n    while(k >= 0) {\n        for(char c='A'; c<='Z'; c++)\n            if(ord[c] == k)\n                for(char cb : rev[c])\n                    if(ord[cb] < ord[c])\n                        return false;\n        k--;\n    }\n    return true;\n}\n\n\nint main(void) {\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=0; i<n; i++) {\n        char s[100][100];\n        int minx[256], maxx[256], miny[256], maxy[256];\n        set<char> cs[256], rev[256];\n\n        memset(s, 0, sizeof(s));\n        memset(maxx, 0xFF, sizeof(maxx));\n        memset(maxy, 0xFF, sizeof(maxy));\n        memset(minx, 0x7F, sizeof(minx));\n        memset(miny, 0x7F, sizeof(miny));\n\n        int h, w;\n        scanf(\"%d%d\",&h,&w);\n        for(int j=0; j<h; j++)\n            scanf(\"%s\",s[j]);\n\n        for(int ih=0; ih<h; ih++)\n            for(int iw=0; iw<w; iw++) {\n                minx[s[ih][iw]] = MIN(minx[s[ih][iw]] , iw);\n                miny[s[ih][iw]] = MIN(miny[s[ih][iw]] , ih);\n                maxx[s[ih][iw]] = MAX(maxx[s[ih][iw]] , iw);\n                maxy[s[ih][iw]] = MAX(maxy[s[ih][iw]] , ih);\n            }\n        bool safe = true;\n        for(char c='A'; c<='Z'; c++) {\n            if(minx[c] == 0x7F7F7F7F) continue;\n\n            for(int iw=minx[c]; iw<=maxx[c]; iw++)\n                for(int ih=miny[c]; ih<=maxy[c]; ih++) {\n                    if(s[ih][iw] == '.') { safe = false; continue; }\n                    if(c != s[ih][iw])\n                        cs[c].insert(s[ih][iw]), rev[s[ih][iw]].insert(c);\n                }\n        }\n\n/*        for(char c='A'; c<='Z'; c++) {\n            printf(\"%c: \", c);\n            for(char cn : cs[c])\n                printf(\"%c \", cn);\n            puts(\"\");\n        }*/\n        if(safe)\n            safe = strong(cs, rev);\n\n        puts(safe ? \"SAFE\" : \"SUSPICIOUS\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\n\nint main(int argc, char *argv[]){\n  int n, w, h;\n  cin >> n;\n  for (int r = 0; r < n; r++) {\n    pair<int, int> p[7][2];\n    map<char, int> matrial;\n    cin >> h >> w;\n\n    char grid[h][w];\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> grid[i][j];\n        if(grid[i][j] != '.' &&\n           matrial.find(grid[i][j]) == matrial.end()){\n          matrial[grid[i][j]] = matrial.size();\n        }\n      }\n    }\n\n    vector<int> perm(matrial.size());\n    for (int i = 0; i < matrial.size(); i++) {\n      p[i][0].first = 1e9, p[i][0].second = 1e9;\n      p[i][1].first = 0,   p[i][1].second = 0;\n      perm[i] = i;\n    }\n\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if(matrial.find(grid[i][j]) != matrial.end()){\n          char tmp = matrial[grid[i][j]];\n          p[tmp][0].first  = min(p[tmp][0].first,  j);\n          p[tmp][0].second = min(p[tmp][0].second, i);\n          p[tmp][1].first  = max(p[tmp][1].first,  j);\n          p[tmp][1].second = max(p[tmp][1].second, i);\n        }\n      }\n    }\n    // for (auto &a: matrial){\n    //   std::cout << a.first << \" \" << a.second << std::endl;\n    // }\n    // for (int i = 0; i < matrial.size(); i++) {\n    //   std::cout << \"min:\" << std::endl;\n    //   std::cout << p[i][0].first << \" \" << p[i][0].second << std::endl;\n    //   std::cout << \"max:\" << std::endl;\n    //   std::cout << p[i][1].first << \" \" << p[i][1].second << std::endl;\n    // }\n    // std::cout << matrial.size() << std::endl;\n    \n    bool flag = true;\n    do{\n\n      for (int i = 0; i < matrial.size(); i++) {\n        for (int j = p[i][0].second; j <= p[i][1].second; j++) {\n          for (int k = p[i][0].first; k <= p[i][1].first; k++) {\n            if(grid[j][k] == '.' ||\n               perm[matrial[grid[j][k]]] > perm[i]){\n              flag = false;\n            i = 10;\n            j = p[i][1].second + 10;\n            k = p[i][1].first  + 10;\n            }\n          }\n        }\n      }\n    }while(next_permutation(perm.begin(), perm.end()));\n    if(flag){\n      std::cout << \"SAFE\" << std::endl;\n    }else{\n      std::cout << \"SUSPICIOUS\" << std::endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\nvoid solve() {\n  int64 H, W;\n  cin >> H >> W;\n  vector<string> f(H);\n  REP(i, H) {\n    cin >> f[i];\n    REP(j, W) {\n      if (f[i][j] != '.') {\n        f[i][j] -= 'A';\n      }\n    }\n  }\n  vector<pair<PII, PII>> mp(26, make_pair(PII(INF, INF), PII(-INF, -INF)));\n  REP(i, H) {\n    REP(j, W) {\n      if (f[i][j] != '.') {\n        PLL lu, rd;\n        tie(lu, rd) = mp[f[i][j]];\n        lu = PII(min(lu.fs, i), min(lu.sc, j));\n        rd = PII(max(rd.fs, i), max(rd.sc, j));\n        mp[f[i][j]] = make_pair(lu, rd);\n      }\n    }\n  }\n  vector<int64> in(26, 0);\n  vector<int64> G[26];\n  REP(c, 26) {\n    PII lu, rd;\n    tie(lu, rd) = mp[c];\n//    cout << x.fs << \" (\" << lu.fs << \" \" << lu.sc << \") (\" << rd.fs << \" \" << rd.sc << \") \" << endl;\n    FOR(i, lu.fs, rd.fs+1) {\n      FOR(j, lu.sc, rd.sc+1) {\n        if (c != f[i][j]) {\n          if (f[i][j] == '.') {\n            cout << \"SUSPICIOUS\" << endl;\n            return;\n          } else {\n            G[f[i][j]].push_back(c);\n            in[c]++;\n          }\n        }\n      }\n    }\n  }\n  queue<int> fr;\n  REP(i, 26) if (in[i]==0) fr.push(i);\n  int64 rest = 26-fr.size();\n  while (fr.size()) {\n    int v = fr.front(); fr.pop();\n    for (auto& u : G[v]) {\n      in[u]--;\n      if (in[u] == 0) {\n        fr.push(u);\n        rest--;\n      }\n    }\n  }\n  if (rest == 0) {\n    cout << \"SAFE\" << endl;\n  } else {\n    cout << \"SUSPICIOUS\" << endl;\n  }\n}\n\nint main(void) {\n\n  int64 T;\n  cin >> T;\n  REP(_, T) {\n    solve();\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define MAX_LEN 50\n\nstring solve()\n{\n\tint h, w;\n\tcin >> h >> w;\n\tchar figure[MAX_LEN][MAX_LEN];\n\trep(y, 0, h)\n\t{\n\t\tstring s; cin >> s;\n\t\trep(x, 0, w) figure[y][x] = s[x];\n\t}\n\n\tset<char> items, ok_items;\n\tmap<char, int> xmin, xmax, ymin, ymax;\n\trep(y, 0, h) rep(x, 0, w)\n\t{\n\t\tchar c = figure[y][x];\n\t\tif (items.find(c) == items.end())\n\t\t{\n\t\t\titems.insert(c);\n\t\t\txmin[c] = xmax[c] = x;\n\t\t\tymin[c] = ymax[c] = y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\txmin[c] = min(xmin[c], x);\n\t\t\txmax[c] = max(xmax[c], x);\n\t\t\tymin[c] = min(ymin[c], y);\n\t\t\tymax[c] = max(ymax[c], y);\n\t\t}\n\t}\n\n\tfor (char c : items)\n\t{\n\t\tbool ok = true;\n\t\trep(y, ymin[c], ymax[c] + 1) rep(x, xmin[c], xmax[c] + 1)\n\t\t{\n\t\t\tif (figure[y][x] != c) ok = false;\n\t\t}\n\t\tif (ok) ok_items.insert(c);\n\t}\n\n\twhile (items.size() != ok_items.size())\n\t{\n\t\tbool change = false;\n\n\t\tfor (char c : items)\n\t\t{\n\t\t\tif (ok_items.find(c) != ok_items.end()) continue;\n\t\t\t\n\t\t\tbool ok = true;\n\t\t\trep(y, ymin[c], ymax[c] + 1) rep(x, xmin[c], xmax[c] + 1)\n\t\t\t{\n\t\t\t\tif (figure[y][x] == c)\n\t\t\t\t{\n\t\t\t\t\t// do nothing\n\t\t\t\t}\n\t\t\t\telse if (ok_items.find(figure[y][x]) != ok_items.end())\n\t\t\t\t{\n\t\t\t\t\t// do nothing\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok)\n\t\t\t{\n\t\t\t\tok_items.insert(c);\n\t\t\t\tchange = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!change) return \"SUSPICIOUS\";\n\t}\n\n\treturn \"SAFE\";\n}\n\nint main()\n{\n\tint n; cin >> n;\n\trep(nn, 0, n)\n\t{\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_H 55\n#define MAX_W 55\n\nint H,W,sx,sy,gx,gy;\nbool visited[MAX_H][MAX_W];\nchar field[MAX_H][MAX_W];\nset<char> st;\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n\nvoid getPos(int x,int y,char ch){\n  if(visited[y][x]){ return; }\n  visited[y][x] = true;\n  if(field[y][x] == ch){\n    sx = min(sx,x); gx = max(gx,x);\n    sy = min(sy,y); gy = max(gy,y);\n  }\n  for(int i = 0 ; i < 4 ; i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(0 <= nx && nx < W && 0 <= ny && ny < H){\n      getPos(nx,ny,ch);\n    }\n  }\n}\n\nbool remove(char ch){\n  for(int i = sy ; i <= gy ; i++){\n    for(int j = sx ; j <= gx ; j++){\n      if(field[i][j] != ch && field[i][j] != '*'){\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nvoid change(){\n  for(int i = sy ; i <= gy ; i++){\n    for(int j = sx ; j <= gx ; j++){\n      field[i][j] = '*';\n    }\n  }\n}\n\nbool check(){\n  int N = st.size();\n  while(N--){\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        if(field[i][j] == '.'){ continue; }\n        if(field[i][j] == '*'){ continue; }\n        memset(visited,false,sizeof(visited));\n        sx = sy = 1e9; gx = gy = 0;\n        getPos(j,i,field[i][j]);\n        if(remove(field[i][j])){\n          change();\n          goto next;\n        }\n      }\n    }\n    return false;\n  next:;\n  }\n  return true;\n}\n\nint main(){\n  int Tc;\n  cin >> Tc;\n  while(Tc--){\n    cin >> H >> W;\n    st.clear();\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        cin >> field[i][j];\n        if(isupper(field[i][j])){\n          st.insert(field[i][j]);\n        }\n      }\n    }\n    cout << (check() ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nstring str[100];\nint h,w;\nint num;\nbool flag;\nbool used[100][100];\nchar moji[100];\nint vx[4]={1,0,-1,0};\nint vy[4]={0,1,0,-1};\nvoid dfs(int Bit,int depth){\n  if(Bit==((1<<num)-1)){\n    flag=true;\n    return;\n  }\n  for(int i=0;i<num;i++){\n    if(!(Bit&(1<<i))){\n      bool used2[100][100]={};\n      int lemi=100,lema=0,rimi=100,rima=0;\n      for(int j=0;j<h;j++){\n\tfor(int k=0;k<w;k++){\n\t  if(str[j][k]==moji[i]){\n\t    used2[j][k]=true;\n\t    used[j][k]=true;\n\t    lemi=min(lemi,k);\n\t    lema=max(lema,k);\n\t    rima=max(rima,j);\n\t    rimi=min(rimi,j);\n\t  }\n\t}\n      }\n      bool fll=true;\n      for(int j=rimi;j<=rima;j++){\n\tfor(int k=lemi;k<=lema;k++){\n\t  if(!used[j][k]){\n\t    fll=false;\n\t  }\n\t}\n      }\n      if(fll)\n\tdfs(Bit+(1<<i),depth+1);\n      for(int j=rimi;j<=rima;j++){\n\tfor(int k=lemi;k<=lema;k++){\n\t  if(used2[j][k]){\n\t    used[j][k]=false;\n\t  }\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int n;cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>h>>w;\n    num=0;\n    for(int i=0;i<55;i++)\n      for(int j=0;j<55;j++)\n\tused[i][j]=false;\n    flag=false;\n    bool alfa[26]={};\n    for(int i=0;i<h;i++){\n      cin>>str[i];\n      for(int j=0;j<w;j++){\n\talfa[str[i][j]-'A']=true;\n      }\n    }\n    int cnt=0;\n    for(int i=0;i<26;i++){\n      if(alfa[i]){\n\tnum++;\n\tmoji[cnt]=(char)(i+'A');\n\tcnt++;\n      }\n    }\n    dfs(0,0);\n    if(flag)\n      cout<<\"SAFE\"<<endl;\n    else \n      cout<<\"SUSPICIOUS\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <bitset>\nusing namespace std;\n#define INF\t100000000\n#define MOD 1000000007\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sec second\n#define lb lower_bound\n#define ub upper_bound\n#define SS stringstream\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define SORT(x) sort((x).begin(), (x).end())\n#define clr(a,b) memset((a),(b),sizeof(a))\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<P> Vp;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nint h, w;\nchar cell[50][50];\nchar check[7];\n\nint A(char x){\n\trep(i,7) if(check[i] == x) return i;\n\treturn -1;\n}\n\nstring solve(){\n\tscanf(\"%d%d\", &h, &w);\n\trep(i,h) rep(j,w) scanf(\" %c\", &cell[i][j]);\n\trep(i,7) check[i] = ' ';\n\trep(i,h) rep(j,w){\n\t\tif(cell[i][j] == '.') continue;\n\t\tbool ok = false;\n\t\trep(k,7){\n\t\t\tif(check[k] == cell[i][j]){\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok){\n\t\t\trep(k,7){\n\t\t\t\tif(check[k] == ' '){\n\t\t\t\t\tcheck[k] = cell[i][j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint maxx[7], minx[7], maxy[7], miny[7];\n\trep(i,7){\n\t\tmaxx[i] = -1;\n\t\tminx[i] = INF;\n\t\tmaxy[i] = -1;\n\t\tminy[i] = INF;\n\t}\n\trep(i,h) rep(j,w){\n\t\tif(cell[i][j] == '.') continue;\n\t\tint t = A(cell[i][j]);\n\t\tmaxx[t] = max(maxx[t],j);\n\t\tminx[t] = min(minx[t],j);\n\t\tmaxy[t] = max(maxy[t],i);\n\t\tminy[t] = min(miny[t],i);\n\t}\n\tVi v[7];\n\trep(i,7){\n\t\tif(check[i] == ' ') continue;\n\t\tfor(int j = miny[i]; j <= maxy[i]; j++){\n\t\t\tfor(int k = minx[i]; k <= maxx[i]; k++){\n\t\t\t\tif(cell[j][k] == '.') return \"SUSPICIOUS\";\n\t\t\t\tif(cell[j][k] != check[i]){\n\t\t\t\t\tbool exist = false;\n\t\t\t\t\trep(l,v[i].size()){\n\t\t\t\t\t\tif(v[i][l] == A(cell[j][k])){\n\t\t\t\t\t\t\texist = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!exist) v[i].pb(A(cell[j][k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i,7){\n\t\tbool used[7];\n\t\trep(j,7) used[j] = false;\n\t\tqueue<int> que;\n\t\tque.push(i);\n\t\tused[i] = true;\n\t\twhile(true){\n\t\t\tif(que.size() == 0) break;\n\t\t\tint p = que.front(); que.pop();\n\t\t\trep(j,v[p].size()){\n\t\t\t\tif(v[p][j] == i) return \"SUSPICIOUS\";\n\t\t\t\tif(used[v[p][j]]) continue;\n\t\t\t\tused[v[p][j]] = true;\n\t\t\t\tque.push(v[p][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"SAFE\";\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\trep(i,n) cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 50;\n\nclass State{\npublic:\n  int mx, my, Mx, My;\n  State() {}\n  State(int mx, int my, int Mx, int My) : mx(mx), my(my), Mx(Mx), My(My) {}\n};\n\nint h, w, col, mx, my, Mx, My, A[7], dy[] = {-1, 0, 1, 0}, dx[] = {0, 1, 0, -1};\nState state[7];\nchar data[N][N];\nbool used[N][N], ans;\nmap<char, int> number;\nmap<int, char> material;\n\nmain(){\n  int t;\n  cin >> t;\n  while(t--){\n    set<int> upper[7];\n    number.clear();\n    material.clear();\n    cin >> h >> w;\n    col = 0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> data[i][j];\n        if(data[i][j] != '.' && number.find(data[i][j]) == number.end()){\n          number[data[i][j]] = col;\n          material[col++] = data[i][j];\n        }\n      }\n    }\n    for(int k=0;k<col;k++){\n      state[k] = State(N, N, 0, 0);\n      for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n          if(data[i][j] == material[k]){\n            state[k].mx = min(state[k].mx, j);\n            state[k].my = min(state[k].my, i);\n            state[k].Mx = max(state[k].Mx, j);\n            state[k].My = max(state[k].My, i);\n          }\n        }\n      }\n    }\n    for(int k=0;k<col;k++){\n      for(int i=state[k].my;i<=state[k].My;i++){\n        for(int j=state[k].mx;j<=state[k].Mx;j++){\n          if(data[i][j] == '.'){\n            cout << \"SUSPICIOUS\" << endl;\n            goto CONT;\n          }\n          else if(data[i][j] != material[k]) upper[k].insert(number[data[i][j]]);\n        }\n      }\n    }\n    for(int i=0;i<col;i++) A[i] = i;\n    ans = false;\n    do{\n      for(int i=0;i<col;i++){\n        for(set<int>::iterator j=upper[i].begin();j!=upper[i].end();j++){\n          if(A[i] < A[*j]) goto FAILD;\n        }\n      }\n      ans = true;\n      FAILD:;\n    }while(next_permutation(A, A+col));\n    if(ans || !col) cout << \"SAFE\" << endl;\n    else cout << \"SUSPICIOUS\" << endl;\n    CONT:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<(S)<<endl\n#define F first\n#define S second\nusing namespace std;\n\nint main(){\n\tint N;\n\tcin>>N;\n\tREP(n,0,N){\n\t\tint H,W;\n\t\tcin>>H>>W;\n\t\tbool safe=true;\n\t\tmap<char,int> xmin,xmax,ymin,ymax;\n\t\tchar field[51][51];\n\t\tset<char> s;\n\t\tREP(i,0,H){\n\t\t\tREP(j,0,W){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tchar c=field[i][j];\n\t\t\t\tif(c=='.') continue;\n\t\t\t\tif(s.find(c)==s.end()){\n\t\t\t\t\ts.insert(c);\n\t\t\t\t\txmin[c]=xmax[c]=j;\n\t\t\t\t\tymin[c]=ymin[c]=i;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\txmin[c]=min(xmin[c],j);\n\t\t\t\t\txmax[c]=max(xmax[c],j);\n\t\t\t\t\tymin[c]=min(ymin[c],i);\n\t\t\t\t\tymax[c]=max(ymax[c],i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tset<char> oks;\n\t\tfor(char c:s){\n\t\t\tbool flag=true;\n\t\t\tREP(i,ymin[c],ymax[c]+1) REP(j,xmin[c],xmax[c]+1){\n\t\t\t\tif(field[i][j]!=c) flag=false;\n\t\t\t}\n\t\t\tif(flag) oks.insert(c);\n\t\t}\n\t\twhile(s.size()!=oks.size()){\n\t\t\tbool flag2=false;\n\n\t\t\tfor(char c:s){\n\t\t\t\tif(oks.find(c)!=oks.end()) continue;\n\t\t\t\tbool flag=true;\n\t\t\t\tREP(i,ymin[c],ymax[c]+1) REP(j,xmin[c],xmax[c]+1){\n\t\t\t\t\tif(field[i][j]!=c&&oks.find(field[i][j])==oks.end()) flag=false;\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\toks.insert(c);\n\t\t\t\t\tflag2=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag2) {\n\t\t\t\tsafe=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp(safe?\"SAFE\":\"SUSPICIPUS\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        char board[50][50];\n        int num[26] = {0};\n        int h, w;\n        cin >> h >> w;\n        for (int j = 0; j < h; ++j) {\n            scanf(\"%s\", board[j]);\n            for (int k = 0; k < w; ++k) {\n                ++num[board[j][k] - 'A'];\n            }\n        }\n        bool flag = true;\n\n        while (flag) {\n            flag = false;\n        for (int j = 0; j < 26; ++j) {\n            if (!num[j])\n                continue;\n            \n            int up = 100, dw = -1, lf = 100, ri = -1;\n            for (int k = 0; k < h; ++k) {\n                for (int l = 0; l < w; ++l) {\n                    if (board[k][l] == j + 'A') {\n                        lf = min(lf, l);\n                        dw = max(dw, k);\n                        up = min(up, k);\n                        ri = max(ri, l);\n                    }\n                }\n            }\n            for (int k = up; k <= dw; ++k) {\n                for (int l = lf; l <= ri; ++l) {\n                    if (board[k][l] != j + 'A' && board[k][l] != '#') {\n                        goto A;\n                    }\n                }\n            }\n            for (int k = up; k <= dw; ++k) {\n                for (int l = lf; l <= ri; ++l) {\n                    if (board[k][l] == j + 'A') {\n                        board[k][l] = '#';\n                        --num[j];\n                        flag = true;\n                    }\n                }\n            }\n            \n        A:\n            continue;\n\n        }\n        }\n        for (int j = 0; j < h; ++j) {\n            for (int k = 0; k < w; ++k) {\n                if (board[j][k] != '.' && board[j][k] != '#'){\n                    printf(\"SUSPICIOUS\\n\");\n                    goto B;\n                }\n            }\n        }\n        printf(\"SAFE\\n\");\n    B:\n        continue;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass Belongings {\npublic:\n  Belongings() : left(100),right(0),upper(100),lower(0){}\n  int left,right,upper,lower;\n};\n\n\nbool check(char hypothesis[50][50],char stage[50][50],int W,int H){\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      if(hypothesis[y][x] != stage[y][x]) return false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    for(int stage_idx = 0; stage_idx < N; stage_idx++){\n      int H,W;\n      \n      scanf(\"%d %d\",&H,&W);\n\n      char stage[50][50];\n      char hypothesis[50][50];\n\n      memset(stage,'.',sizeof(stage));\n\n      map<char,Belongings> layer;\n\n      for(int y=0;y<H;y++){\n\tchar line[51];\n\tscanf(\"%s\",line);\n\tfor(int x=0;x<W;x++){\n\t  stage[y][x] = line[x];\n\t  if(line[x] == '.') continue;\n\t  //x:0->...\n\t  //y:0\n\t  //  |\n\t  //  v\n\t  //  .\n\t  //  upper\n\t  //left right\n\t  //  lower\n\t  Belongings& be = layer[stage[y][x]];\n\t  be.left = min(be.left,x);\n\t  be.right = max(be.right,x);\n\t  be.upper = min(be.upper,y);\n\t  be.lower = max(be.lower,y);\n\t}\n      }\n\n      bool is_safe = false;\n\n      vector<char> order;\n      for(map<char,Belongings>::iterator it = layer.begin();\n\t  it != layer.end();\n\t  it++){\n\torder.push_back(it->first);\n      }\n      sort(order.begin(),order.end());\n\n\n      do{\n\tmemset(hypothesis,'.',sizeof(hypothesis));\n\n\tfor(int i=0;i<order.size();i++){\n\t  char c = order[i];\n\t  Belongings& be = layer[c];\n\t  for(int y=be.upper; y<=be.lower; y++){\n\t    for(int x=be.left; x<=be.right; x++){\n\t      hypothesis[y][x] = c;\n\t    }\n\t  }\n\t}\n\n\tif(check(hypothesis,stage,W,H)){\n\t  is_safe = true;\n\t  break;\n\t}\n      }while(next_permutation(order.begin(),order.end()));\n      printf(\"%s\\n\",is_safe ? \"SAFE\" : \"SUSPICIOUS\");\n      \n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nstruct info {\n\tchar c;\n\tpii u, d;\n\tinfo(char c, pii u, pii d) : c(c), u(u), d(d) {};\n\tbool operator<(const info &o)const {\n\t\treturn o.c<c;\n\t}\n};\n\nint main() {\n\tint n;\n\tcin >> n;\n\tREP(_, n) {\n\t\tint H, W;\n\t\tcin >> H >> W;\n\t\tvs field(H);\n\t\tvi flag(26);\n\t\tREP(i, H) {\n\t\t\tcin >> field[i];\n\t\t\tREP(j, W) {\n\t\t\t\tif(field[i][j] != '.') {\n\t\t\t\t\tflag[field[i][j]-'A'] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<info> data;\n\t\tREP(i, 26) {\n\t\t\tif(flag[i]) {\n\t\t\t\tdata.push_back(info('A'+i, pii(INF, INF), pii(0, 0)));\n\t\t\t}\n\t\t}\n\n\t\tint size = data.size();\n\t\tREP(i, size) {\n\t\t\tREP(j, H) {\n\t\t\t\tREP(k, W) {\n\t\t\t\t\tif(field[j][k] == data[i].c) {\n\t\t\t\t\t\tdata[i].u.first = min(data[i].u.first, j);\n\t\t\t\t\t\tdata[i].u.second = min(data[i].u.second, k);\n\t\t\t\t\t\tdata[i].d.first = max(data[i].d.first, j);\n\t\t\t\t\t\tdata[i].d.second = max(data[i].d.second, k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsort(ALL(data));\n\t\tbool safe = false;\n\t\tdo {\n\t\t\tREP(i, size-1) {\n\t\t\t\tFOR(j, i+1, size-1) {\n\t\t\t\t\tFOR(y, data[j].u.first, data[j].d.first) {\n\t\t\t\t\t\tFOR(x, data[j].u.second, data[j].d.second) {\n\t\t\t\t\t\t\tif(field[y][x] == data[i].c) {\n\t\t\t\t\t\t\t\tgoto next;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(field[y][x] == '.') {\n\t\t\t\t\t\t\t\tgoto show;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsafe = true;\n\t\t\tbreak;\n\t\t\tnext:;\n\t\t} while(next_permutation(ALL(data)));\n\t\t\n\t\tshow:;\n\t\tcout << (safe ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <map>\n#include <algorithm>\n\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\nusing namespace std;\n\nint used[8];\nchar fie[50][50];\nmap<char, int> dict;\nint minx[7], maxx[7], miny[7], maxy[7];\nint c;\n\nint H, W;\n\nbool ok(int d) {\n\tif(d==c) return true;\n\trep(i, c) if(used[i]==0) {\n\t\tused[i] = 1;\n\t\tbool f = true;\n\t\tfor(int x=minx[i]; x<=maxx[i]; x++) {\n\t\t\tfor(int y=miny[i]; y<=maxy[i]; y++) {\n\t\t\t\tif(used[dict[fie[x][y]]]==0) {\n\t\t\t\t\tf = false;\n\t\t\t\t\tgoto loop_end;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tloop_end:\n\t\tif(f) f = ok(d+1);\n\t\tused[i] = 0;\n\t\tif(f) return true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tint N;\n\tscanf(\"%d\", &N);\n\trep(q, N) {\n\t\tdict.clear();\n\t\tfill_n(used, 8, 0);\n\t\tscanf(\"%d%d\", &H, &W);\n\t\tc=0;\n\t\trep(i, H) rep(j, W) {\n\t\t\tscanf(\" %c\", fie[j]+i);\n\t\t\tif(fie[j][i]!='.') {\n\t\t\t\tif(dict.find(fie[j][i])==dict.end()) {\n\t\t\t\t\tminx[c] = maxx[c] = j;\n\t\t\t\t\tminy[c] = maxy[c] = i;\n\t\t\t\t\tdict[fie[j][i]] = c++;\n\t\t\t\t}\n\t\t\t\tint d = dict[fie[j][i]];\n\t\t\t\tminx[d] = min(minx[d], j);\n\t\t\t\tmaxx[d] = max(maxx[d], j);\n\t\t\t\tminy[d] = min(miny[d], i);\n\t\t\t\tmaxy[d] = max(maxy[d], i);\n\t\t\t}\n\t\t}\n\t\tdict['.'] = 7;\n\t\tprintf(\"%s\\n\", ok(0) ? \"SAFE\" : \"SUSPICIOUS\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <map>\n#include <functional>\n#define N 50\nusing namespace std;\n\ntypedef pair<int,int> pii;\nclass aa{\n\tpublic:\n\t\tint u,d,l,r;\n\t\taa(){\n\t\t\tu=-1;\n\t\t\td=999;\n\t\t\tl=999;\n\t\t\tr=-1;\n\t\t}\n\n\t\taa(int i,int j){\n\t\t\tu=i;\n\t\t\td=i;\n\t\t\tl=j;\n\t\t\tr=j;\n\t\t}\n\n\t\tvoid cousin(int i,int j){\n\t\t\tif(u<i)u=i;\n\t\t\tif(d>i)d=i;\n\t\t\tif(r<j)r=j;\n\t\t\tif(l>j)l=j;\n\t\t}\n};\n\nmap<char,aa> k;\nchar m[51][51];\nint w,h;\n\nint main(void){\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\tcin>>w>>h;\n\t\tfor(int i=0;i<w;i++){\n\t\t\tscanf(\"%s\",m[i]);\n\t\t}\n\t\tk.clear();\n\t\tfor(int i=0;i<w;i++){\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tif(m[i][j]!='.'){\n\t\t\t\t\t// if(0<k.count(m[i][j]))k[m[i][j]].cousin(i,j);\n\t\t\t\t\tk[m[i][j]].cousin(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag=true;\n\t\tbool bf=false;\n\t\tif(k.size()==0)bf=true;\n\t\tfor(map<char,aa>::iterator it=k.begin();it!=k.end();it++){\n\t\t\tchar c=it->first;\n\t\t\taa s=it->second;\n\t\t\tint u=s.u,d=s.d,l=s.l,r=s.r;\n\t\t\t// cout<<\"char:\"<<c<<\" from:\"<<d<<\" \"<<l<<\" to:\"<<u<<\" \"<<r<<endl;\n\t\t\tfor(int i=d;i<=u;i++){\n\t\t\t\tfor(int j=l;j<=r;j++){\n\t\t\t\t// cout<<i<<\":\"<<j<<endl;\n\t\t\t\t\tif(m[i][j]=='.'){\n\t\t\t\t\t\t// cout<<\"susp:\"<<c<<\" \"<<i<<\" \"<<j<<endl;\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\tgoto LABEL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool nf=true;\n\t\t\tfor(int i=d;i<=u;i++){\n\t\t\t\tfor(int j=l;j<=r;j++){\n\t\t\t\t\tif(m[i][j]!=c){\n\t\t\t\t\t\tnf=false;\n\t\t\t\t\t\tgoto kke;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\nkke:\n\t\t\tif(nf)bf=true;\n\t\t}\nLABEL:\n\t\tcout<<((flag&&bf)?(\"SAFE\"):(\"SUSPICIOUS\"))<<endl;\n\t\t/*\n\t\t\t for(map<char,aa>::iterator it=k.begin();it!=k.end();it++){\n\t\t\t char c=it->first;\n\t\t\t aa s=it->second;\n\t\t\t cout<<c<<\"++\"<<s.u<<\":\"<<s.d<<\":\"<<s.l<<\":\"<<s.r<<endl;\n\t\t\t }\n\t\t\t */\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint h, w;\nchar field[50][50];\n\nstruct obj {\n  char pack;\n  vector<char> back;\n  int ux, uy, dx, dy;\n  bool is_visit;\n  obj(char pack, vector<char> back, int ux, int uy, int dx, int dy):\n  pack(pack), back(back), ux(ux), uy(uy), dx(dx), dy(dy){}\n  obj() {}\n};\n\nmap<char, obj> m;\n\nbool no_loop(char c)\n{\n  if (m[c].is_visit) {\n    return false;\n  }\n  m[c].is_visit = true;\n    \n  for (int i = 0; i < m[c].back.size(); i++) {\n    if (!no_loop(m[c].back[i])) {return false;}\n  }\n  return true;\n}\n\nvoid solve()\n{\n  //printf(\"ok\\n\");\n    \n  bool is_exist = false;\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      //printf(\"%c\", field[i][j]);\n      if (isalpha(field[i][j])) {\n        int c = field[i][j];\n        m[c].ux = m[c].uy = 0;\n        m[c].dx = m[c].dy = 100;\n        m[c].pack = c;\n        is_exist = true;\n        for (int k = 0; k < h; k++) {\n          for (int l = 0; l < w; l++) {\n            if (field[k][l] == c) {\n              m[c].ux = max(l, m[c].ux);\n              m[c].uy = max(k, m[c].uy);\n              m[c].dx = min(l, m[c].dx);\n              m[c].dy = min(k, m[c].dy); \n            }\n          }\n        }\n        for (int k = m[c].dy; k <= m[c].uy; k++) {\n          for (int l = m[c].dx; k <= m[c].ux; k++) {\n            if (!isalpha(field[k][l])) {\n              printf(\"SUSPICIOUS\\n\");\n              return;\n            }\n          }        \n        }\n      }\n    }\n    //printf(\"\\n\");                        \n  }\n  if (!is_exist) {\n    printf(\"SAFE\\n\");\n    return;\n  }\n  //printf(\"ok\\n\");\n  \n  for (map<char, obj>::iterator it = m.begin(); it != m.end(); it++) {\n    it->second.is_visit = false;\n    bool is_pushed[26];\n    fill(is_pushed, &is_pushed[26], false);\n    for (int i = it->second.dy; i <= it->second.uy; i++) {\n      for (int j = it->second.dx; j <= it->second.ux; j++) {\n        if (field[i][j] != it->second.pack && !is_pushed[field[i][j] - 'A']) {\n          m[field[i][j]].back.push_back(it->second.pack);\n          is_pushed[field[i][j] - 'A'] = true;\n        }\n      }\n    }\n  }\n  \n  char start = m.begin()->second.pack;\n  if (no_loop(start)) {\n    printf(\"SAFE\\n\");\n    return;\n  } else {\n    printf(\"SUSPICIOUS\\n\");\n    return;\n  }\n}\n\nint main()\n{\n  int nInput;\n  scanf(\"%d \", &nInput);\n  \n  for (int input = 0; input < nInput; input++) {\n    scanf(\"%d %d \", &h, &w);\n    \n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        scanf(\"%c \", &field[i][j]);\n      }\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tint work[8],count;\n};\n\nint H,W,word_num,loc[128];\nchar map[50][51],word_table[8];\nbool isOK;\n\n\nvoid func(){\n\n\tfor(int i = 0; i < 128; i++)loc[i] = -1;\n\tword_num = 0;\n\n\tscanf(\"%d %d\",&H,&W);\n\tfor(int i = 0; i < H; i++){\n\t\tscanf(\"%s\",map[i]);\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tif(map[i][k] != '.'){\n\t\t\t\tif(loc[map[i][k]-'0'] == -1){ //????????´?????´???\n\t\t\t\t\tloc[map[i][k]-'0'] = word_num;\n\t\t\t\t\tword_table[word_num] = map[i][k];\n\t\t\t\t\tword_num++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool FLG = true;\n\tint most_left,most_right,most_top,most_bottom;\n\tchar ch;\n\n\tfor(int i = 0; i < word_num; i++){\n\t\tch = word_table[i];\n\n\t\tmost_left = 51,most_right = -1,most_top = 51,most_bottom = -1;\n\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(map[row][col] == ch){\n\t\t\t\t\tmost_left = min(most_left,col);\n\t\t\t\t\tmost_right = max(most_right,col);\n\t\t\t\t\tmost_top = min(most_top,row);\n\t\t\t\t\tmost_bottom = max(most_bottom,row);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int row = most_top; row <= most_bottom; row++){\n\t\t\tfor(int col = most_left; col <= most_right; col++){\n\t\t\t\tif(map[row][col] == '.'){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!FLG)break;\n\t\t}\n\t}\n\n\tif(!FLG){\n\t\tprintf(\"SUSPICIOUS\\n\");\n\t\treturn;\n\t}\n\n\tisOK = false;\n\n\tqueue<Info> Q;\n\n\tInfo first;\n\tfirst.count = 0;\n\tfor(int i = 0; i < word_num; i++)first.work[i] = -1;\n\tQ.push(first);\n\tint rank;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().count == word_num){\n\n\t\t\tFLG = true;\n\n\t\t\tfor(int i = 0; i < word_num; i++){\n\t\t\t\tch = word_table[i];\n\t\t\t\trank = Q.front().work[i];\n\n\t\t\t\tmost_left = 51,most_right = -1,most_top = 51,most_bottom = -1;\n\n\t\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\t\tif(map[row][col] == ch){\n\t\t\t\t\t\t\tmost_left = min(most_left,col);\n\t\t\t\t\t\t\tmost_right = max(most_right,col);\n\t\t\t\t\t\t\tmost_top = min(most_top,row);\n\t\t\t\t\t\t\tmost_bottom = max(most_bottom,row);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int row = most_top; row <= most_bottom; row++){\n\t\t\t\t\tfor(int col = most_left; col <= most_right; col++){\n\t\t\t\t\t\tif(map[row][col] != ch){\n\t\t\t\t\t\t\tif(rank > Q.front().work[loc[map[row][col]-'0']]){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG)break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(FLG){\n\t\t\t\tisOK = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < word_num; i++){\n\t\t\tif(Q.front().work[i] == -1){\n\t\t\t\tInfo next;\n\t\t\t\tfor(int k = 0; k < 8; k++)next.work[k] = Q.front().work[k];\n\t\t\t\tnext.work[i] = Q.front().count;\n\t\t\t\tnext.count = Q.front().count+1;\n\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\n\t\tQ.pop();\n\t}\n\n\tif(isOK){\n\t\tprintf(\"SAFE\\n\");\n\t}else{\n\t\tprintf(\"SUSPICIOUS\\n\");\n\t}\n}\n\n\nint main(){\n\n\tint num;\n\tscanf(\"%d\",&num);\n\n\tfor(int i = 0; i < num; i++)func();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n    int n;\n    cin >> n;\n    while(n-- > 0){\n        int h, w;\n        cin >> h >> w;\n        int si[26], ei[26], sj[26], ej[26];\n        for(int i = 0; i < 26; i++) si[i] = h, sj[i] = w, ei[i] = ej[i] = -1;\n        char mat[h][w];\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> mat[i][j];\n                if(mat[i][j] == '.')    continue;\n                int ind = mat[i][j]-'A';\n                si[ind] = min(si[ind], i);\n                sj[ind] = min(sj[ind], j);\n                ei[ind] = max(ei[ind], i);\n                ej[ind] = max(ej[ind], j);\n            }\n        }\n        bool safe = true;\n        int dp[26][26] = {};\n        for(int x = 0; x < 26; x++){\n            if(ei[x] == -1) continue;\n            for(int i = si[x]; i <= ei[x]; i++){\n                for(int j = sj[x]; j <= ej[x]; j++){\n                    if(mat[i][j] == '.'){\n                        safe = false;\n                        continue;\n                    }\n                    if(mat[i][j]-'A' == x)  continue;\n                    dp[x][mat[i][j]-'A'] = -1;\n                }\n            }\n        }\n        for(int k = 0; k < 26; k++){\n            for(int i = 0; i < 26; i++){\n                for(int j = 0; j < 26; j++){\n                    if(dp[i][k] == 0 || dp[k][j] == 0)  continue;\n                    dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j]);\n                }\n            }\n        }\n        for(int i = 0; i < 26; i++) safe &= (dp[i][i] == 0);\n        cout << (safe ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid chmin(int& x, int y)\n{\n  x = min(x, y);\n}\nvoid chmax(int& x, int y)\n{\n  x = max(x, y);\n}\n\nint main()\n{\n  int Q, H, W;\n  string S[50];\n\n  cin >> Q;\n  while(Q--) {\n    cin >> H >> W;\n\n    string chars = \"\";\n    for(int i = 0; i < H; i++) {\n      cin >> S[i];\n      chars += S[i];\n    }\n    sort(chars.begin(), chars.end());\n    chars.erase(unique(chars.begin(), chars.end()), chars.end());\n    vector< int > x1(chars.size(), W), x2(chars.size(), 0);\n    vector< int > y1(chars.size(), H), y2(chars.size(), 0);\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        int pos = chars.find(S[i][j]);\n        chmin(x1[pos], j);\n        chmax(x2[pos], j);\n        chmin(y1[pos], i);\n        chmax(y2[pos], i);\n      }\n    }\n    map< char, int > xx1, xx2, yy1, yy2;\n    // ???????????¨???????????????????????¨???????????????\n    for(int i = 0; i < chars.size(); i++) {\n      xx1[chars[i]] = x1[i];\n      xx2[chars[i]] = x2[i];\n      yy1[chars[i]] = y1[i];\n      yy2[chars[i]] = y2[i];\n    }\n\n    bool Judge = false;\n    bool used[50][50];\n\n    do {\n      Judge = true;\n      memset(used, false, sizeof(used));\n      for(int i = 0; i < chars.size(); i++) {\n        for(int j = xx1[chars[i]]; j <= xx2[chars[i]]; j++) {\n          for(int k = yy1[chars[i]]; k <= yy2[chars[i]]; k++) {\n            if(used[j][k]++) continue;\n            if(S[k][j] != chars[i]) {\n              Judge = false;\n              goto myon;\n            }\n          }\n        }\n      }\n    myon: ;\n    } while(!Judge && next_permutation(chars.begin(), chars.end()));\n    if(Judge) cout << \"SAFE\" << endl;\n    else cout << \"SUSPICIOUS\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nstruct xy{\n  int x;\n  int y;\n  xy(int xx,int yy):x(xx),y(yy){}\n};\n\nstruct Aset{\n  xy ld,ru;\n  bool flg;\n  Aset():ld(100,100),ru(0,0),flg(false){}\n  void set(xy t){\n    ld.x = min(ld.x,t.x);\n    ld.y = min(ld.y,t.y);\n    ru.x = max(ru.x,t.x);\n    ru.y = max(ru.y,t.y);\n    flg = true;\n  }\n};\n\nint nlist[26][26];\n\nbool acs[26];\n\nbool dfs(int p){\n  if(acs[p]) return true;\n  acs[p]=true;\n  for(int i=0;i<26;i++){\n    if(nlist[p][i] && dfs(i)) return true;\n  }\n  acs[p]=false;\n  return false;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  while(n--){\n    int H,W;\n    cin>>H>>W;\n    for(int i=0;i<26;i++){\n      for(int j=0;j<26;j++){\n\tnlist[i][j]=0;\n      }\n      acs[i]=0;\n    }\n\n    Aset aset[26];\n    vector<vector<char> > v(H,vector<char>(W));\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin>>v[i][j];\n\tif(v[i][j] != '.'){\n\t  aset[v[i][j]-'A'].set(xy(j,i));\n\t}\n      }\n    }\n    bool check = false;\n    for(int i=0;i<26;i++){\n      if(!aset[i].flg) continue;\n      for(int j=aset[i].ld.y;j<=aset[i].ru.y;j++){\n\tfor(int k=aset[i].ld.x;k<=aset[i].ru.x;k++){\n\t  if(v[j][k] == '.'){\n\t    check = true;\n\t    for(int t=0;t<26;t++) nlist[i][t]=0;\n\t    break;\n\t  }\n\t  if(i+'A' != v[j][k]){\n\t    nlist[i][v[j][k]-'A']=1;\n\t  }\n\t}\n\n\tif(check) break;\n      }\n    }\n    if(!check)\n      for(int i=0;i<26;i++) check |= dfs(i);\n \n    if(check) cout<<\"SUSPICIOUS\"<<endl;\n    else cout<<\"SAFE\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\n\n\nvoid output_field(vector< vector<char> >& field, int h, int w) {\n    for (int i=0; i<h; i++) {\n        for (int j=0; j<w; j++) {\n            cout << field[i][j];\n        }\n        cout << endl;\n    }\n}\n\nbool is_rectangle(vector< vector<char> >& field, int top, int bot, int lef, int rig, char c) {\n    for (int i=top; i<=bot; i++) {\n        for (int j=lef; j<=rig; j++) {\n            if (field[i][j] != '*' && field[i][j] != c) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nvoid paint(vector< vector<char> >& field, int top, int bot, int lef, int rig) {\n    for (int i=top; i<=bot; i++) {\n        for (int j=lef; j<=rig; j++) {\n            field[i][j] = '*';\n        }\n    }\n}\n\nint main() {\n    int n, i;\n    cin >> n;\n    for (i=0; i<n; i++) {\n        // dataset\n        int h, w, j, k;\n        char c;\n        vector< vector<char> > field;\n        string s;\n        cin >> h >> w;\n        field = vector< vector<char> > (h, vector<char>(w, '.'));\n        set<char> se;\n        set<char>::iterator it;\n\n        // input field\n        for (j=0; j<h; j++) {\n            cin >> s;\n            for (k=0; k<w; k++) {\n                field[j][k] = s[k];\n                se.insert(s[k]);\n            }\n        }\n\n        // output field (function)\n        // output_field(field, h, w);\n\n        // for each char\n        se.erase('.');\n        while (1) {\n            char delc = '-';\n            for (it=se.begin(); it!=se.end(); it++) {\n                if (*it != '.') {\n                    int lef = 100, top = 100, rig = -1, bot = -1;\n                    for (j=0; j<h; j++) {\n                        for (k=0; k<w; k++) {\n                            if (field[j][k] == *it) {\n                                lef = min(lef, k);\n                                top = min(top, j);\n                                rig = max(rig, k);\n                                bot = max(bot, j);\n                            }\n                        }\n                    }\n                    bool isr = is_rectangle(field, top, bot, lef, rig, *it);\n                    if (isr) {\n                        delc = *it;\n                        paint(field, top, bot, lef, rig);\n                        break;\n                    }\n                }\n            }\n            if (delc != '-') {\n                se.erase(delc);\n                if (!se.size()) {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n        if (!se.size()) {\n            cout << \"SAFE\" << endl;\n        } else {\n            cout << \"SUSPICIOUS\" << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n#define USE_MATH_DEFINES\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 30;\nconst double EPS = 1E-9;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\n\nint h, w;\nchar field[50][50];\nbool used[50][50];\nbool per[8];\nchar ma[8];\nmap<char, int> mp;\nint c;\n\nbool dfs(int n, int rest){\n\tif(n == 0) {\n\t\treturn rest == 0 ? true : false;\n\t}\n\tbool res = false;\n\tfor(int i = 1; i < c; i++){\n\t\tif(per[i]) continue;\n\t\telse{\n\t\t\tper[i] = true;\n\t\t\tint ymax = 0;\n\t\t\tint ymin = INF;\n\t\t\tint xmax = 0;\n\t\t\tint xmin = INF;\n\t\t\tbool f = true;\n\t\t\tint cnt = 0;\n\t\t\tfor(int j = 0; j < h; j++){\n\t\t\t\tfor(int k = 0; k < w; k++){\n\t\t\t\t\tif(mp[field[j][k]] == i){\n\t\t\t\t\t\tymax = max(ymax, j);\n\t\t\t\t\t\tymin = min(ymin, j);\n\t\t\t\t\t\txmax = max(xmax, k);\n\t\t\t\t\t\txmin = min(xmin, k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = ymin; j <= ymax; j++){\n\t\t\t\tfor(int k = xmin; k <= xmax; k++){\n\t\t\t\t\tif(per[mp[field[j][k]]]){\n\t\t\t\t\t\tif(mp[field[j][k]] == i) cnt++;\n\t\t\t\t\t}else f = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tres |= dfs(n-1, rest - cnt);\n\t\t\t\tper[i] = false;\n\t\t\t}else{\n\t\t\t\tper[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\n\nint main() {\n\tint n;\n\tcin >> n;\n\trep (i, n) {\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tvector <string> s(h);\n\t\trep (i, h) cin >> s[i];\n\n\t\tvector <int> t, b, l, r;\n\t\tt = l = vector <int> (26, 1e9);\n\t\tb = r = vector <int> (26, 0);\n\t\trep (i, h) rep (j, w) {\n\t\t\tif (s[i][j] == '.') continue;\n\t\t\tt[s[i][j] - 'A'] = min(t[s[i][j] - 'A'], i);\n\t\t\tb[s[i][j] - 'A'] = max(b[s[i][j] - 'A'], i);\n\t\t\tl[s[i][j] - 'A'] = min(l[s[i][j] - 'A'], j);\n\t\t\tr[s[i][j] - 'A'] = max(r[s[i][j] - 'A'], j);\n\t\t}\n\n\t\tvector <vector <int>> list (26, vector <int> (26, 1e9));\n\t\trep (i, 26) list[i][i] = 0;\n\t\tbool flag = true;\n\t\trep (i, 26) {\n\t\t\trange (j, t[i], b[i] + 1) range (k, l[i], r[i] + 1) {\n\t\t\t\tif (s[j][k] == '.') {\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t\tif (s[j][k] != ('A' + i)) {\n\t\t\t\t\tlist[i][s[j][k] - 'A'] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep (k, 26) rep (i, 26) rep (j, 26) {\n\t\t\tlist[i][j] = min(list[i][j], list[i][k] + list[k][j]);\n\t\t}\n\t\trep (i, 26) {\n\t\t\tflag &= list[i][i] >= 0;\n\t\t}\n\t\tcout << (flag ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_H 55\n#define MAX_W 55\n \nint H,W,sx,sy,gx,gy;\nbool visited[MAX_H][MAX_W];\nchar field[MAX_H][MAX_W];\nset<char> st;\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n \nvoid getPos(int x,int y,char ch){\n    if(visited[y][x]) return;\n    visited[y][x] = true;\n    if(field[y][x] == ch){\n\tsx = min(sx,x); gx = max(gx,x);\n\tsy = min(sy,y); gy = max(gy,y);\n    }\n    for(int i = 0 ; i < 4 ; i++){\n\tint nx = x + dx[i];\n\tint ny = y + dy[i];\n\tif(0 <= nx && nx < W && 0 <= ny && ny < H){\n\t    getPos(nx,ny,ch);\n\t}\n    }\n}\n \nbool remove(char ch){\n    for(int i = sy ; i <= gy ; i++){\n\tfor(int j = sx ; j <= gx ; j++){\n\t    if(field[i][j] != ch && field[i][j] != '*'){\n\t\treturn false;\n\t    }\n\t}\n    }\n    return true;\n}\n \nvoid change(){\n    for(int i = sy ; i <= gy ; i++){\n\tfor(int j = sx ; j <= gx ; j++){\n\t    field[i][j] = '*';\n\t}\n    }\n}\n \nbool check(){\n    int N = st.size();\n    while(N--){\n\tfor(int i = 0 ; i < H ; i++){\n\t    for(int j = 0 ; j < W ; j++){\n\t\tif(field[i][j] == '.') continue;\n\t\tif(field[i][j] == '*') continue;\n\t\tmemset(visited,false,sizeof(visited));\n\t\tsx = sy = 1e9; gx = gy = 0;\n\t\tgetPos(j,i,field[i][j]);\n\t\tif(remove(field[i][j])){\n\t\t    change();\n\t\t    goto next;\n\t\t}\n\t    }\n\t}\n\treturn false;\n    next:;\n    }\n    return true;\n}\n \nint main(){\n    int Tc;\n    cin >> Tc;\n    while(Tc--){\n\tcin >> H >> W;\n\tst.clear();\n\tfor(int i = 0 ; i < H ; i++){\n\t    for(int j = 0 ; j < W ; j++){\n\t\tcin >> field[i][j];\n\t\tif(isupper(field[i][j])){\n\t\t    st.insert(field[i][j]);\n\t\t}\n\t    }\n\t}\n\tcout << (check() ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\nint N, M;\n\nbool check(vector<vector<char> > &v) {\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            if (v[i][j] != '.' && v[i][j] != 'x') return true;\n        }\n    }\n\n    return false;\n}\n\nbool check2(vector<vector<char> > &v, int sx, int sy, int gx, int gy) {\n    set<char> res;\n    for (int i = sx; i <= gx; i++) {\n        for (int j = sy; j <= gy; j++) {\n            if (v[i][j] != 'x') res.insert(v[i][j]);\n        }\n    }\n\n    if (res.size() == 1) {\n        char s;\n        for (auto i : res) s = i;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                if (!(sx <= i && i <= gx && sy <= j && j <= gy) && v[i][j] == s) return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\n\nvector<int> found(vector<vector<char> > &v) {\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            if (v[i][j] == '.') continue;\n            for (int k = N - 1; k >= i; k--) {\n                for (int l = M - 1; l >= j; l--) {\n                    bool flag = check2(v, i, j, k, l);\n                    if (flag) return (vector<int>{i, j, k, l});\n                }\n            }\n        }\n    }\n\n    return vector<int>{-1, -1, -1, -1};\n}\n\nvoid solve() {\n    cin >> N >> M;\n    vector<vector<char> > v(N, vector<char>(M));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            cin >> v[i][j];\n        }\n    }\n\n    bool res = true;\n\n    while (check(v)) {\n        auto L = found(v);\n\n        if (L[0] < 0) {\n            res = false;\n            break;\n        }\n        for (int i = L[0]; i <= L[2]; i++)\n            for (int j = L[1]; j <= L[3]; j++)\n                v[i][j] = 'x';\n    }\n\n    cout << (res ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n}\n\nint main() {\n    int Q; cin >> Q;\n    for (int q = 0; q < Q; q++) {\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#define rep(i,j) for(int i=0;i<j;i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define ms(i,j) memset(i,j,sizeof(i))\nusing namespace std;\nint n,h,w;\nchar m[50][51];\nbool e[26];\nbool dfs(int p,bool f[26][26]){\n\tif(e[p])return false;\n\te[p]=true;\n\tbool r=true;\n\trep(i,26)if(i!=p&&f[p][i]&&!dfs(i,f))r=false;\n\te[p]=false;\n\treturn r;\n}\nint main(){\n    scanf(\"%d\",&n);\n    while(n--){\n        scanf(\"%d%d\",&h,&w);\n        bool a=true;\n            int t[26],l[26],r[26]={0},b[26]={0};\n            rep(i,26)t[i]=l[i]=55;\n            bool f[26][26];\n            ms(f,0);\n        rep(i,h){\n            scanf(\"%s\",m[i]);\n            rep(j,w)if(m[i][j]!='.'){\n                char c=m[i][j]-'A';\n                f[c][c]=true;\n                t[c]=min(t[c],i);\n                l[c]=min(l[c],j);\n                r[c]=max(r[c],j);\n                b[c]=max(b[c],i);\n            }\n        }\n\t\tint cnt[26]={0};\n        rep(i,26)if(f[i][i]){\n            reps(j,t[i],b[i])reps(k,l[i],r[i]){\n                if(m[j][k]!=i+'A'){\n                    if(m[j][k]=='.')a=false;\n                    else f[i][m[j][k]-'A']=true;\n                }\n            }\n        }\n\t\trep(i,26)if(!dfs(i,f))a=false;\n\t\t\n        puts(a?\"SAFE\":\"SUSPICIOUS\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#define all(c) c.begin(),c.end()\n#define uni(c) c.erase(unique(all(c)),c.end())\n#define pb push_back\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint h,w;\nvector<char> c;\nmap<char,PP> mp;\nbool ret(int now,vector<string> &s){\n\tif(now==c.size())\n\t\treturn true;\n\t/*int x1=100,x2=0,y1=100,y2=0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[i][j]==c[now]){\n\t\t\t\tx1=min(x1,j);\n\t\t\t\tx2=max(x2,j);\n\t\t\t\ty1=min(y1,i);\n\t\t\t\ty2=max(y2,i);\n\t\t\t}\n\t\t}\n\t}*/\n\tPP p=mp[c[now]];\n\tfor(int i=p.first.first;i<=p.first.second;i++){\n\t\tfor(int j=p.second.first;j<=p.second.second;j++){\n\t\t\tif(s[i][j]==c[now]||s[i][j]=='*'){\n\t\t\t\ts[i][j]='*';\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret(now+1,s);\n\t\n}\nint main(){\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\tcin>>h>>w;\n\t\tvector<string> s(h);\n\t\tc.clear();\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>s[i];\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(find(all(c),s[i][j])==c.end()){\n\t\t\t\t\tc.pb(s[i][j]);\n\t\t\t\t\tmp[s[i][j]]=PP(P(i,i),P(j,j));\n\t\t\t\t}else{\n\t\t\t\t\tmp[s[i][j]]=PP(P(min(i,mp[s[i][j]].first.first),max(i,mp[s[i][j]].first.second)),P(min(j,mp[s[i][j]].second.first),max(j,mp[s[i][j]].second.second)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(all(c));\n\t\tuni(c);\n\t\tbool flag=false;\n\t\tdo{\n\t\t\tvector<string> temp=s;\n\t\t\tif(ret(0,temp)){\n\t\t\t\tflag=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}while(next_permutation(all(c)));\n\t\tif(flag){\n\t\t\tcout<<\"SAFE\"<<endl;\n\t\t}else\n\t\tcout<<\"SUSPICIOUS\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]){\n  int n, w, h;\n  cin >> n;\n  for (int r = 0; r < n; r++) {\n    pair<int, int> p[7][2];\n    map<char, int> matrial;\n    cin >> h >> w;\n\n    char grid[h][w];\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> grid[i][j];\n        if(grid[i][j] != '.' &&\n           matrial.find(grid[i][j]) == matrial.end()){\n          matrial[grid[i][j]] = matrial.size();\n        }\n      }\n    }\n\n    vector<int> perm(matrial.size());\n    for (int i = 0; i < matrial.size(); i++) {\n      p[i][0].first = 1e9, p[i][0].second = 1e9;\n      p[i][1].first = 0,   p[i][1].second = 0;\n      perm[i] = i;\n    }\n\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if(matrial.find(grid[i][j]) != matrial.end()){\n          int tmp = matrial[grid[i][j]];\n          p[tmp][0].first  = min(p[tmp][0].first,  j);\n          p[tmp][0].second = min(p[tmp][0].second, i);\n          p[tmp][1].first  = max(p[tmp][1].first,  j);\n          p[tmp][1].second = max(p[tmp][1].second, i);\n        }\n      }\n    }\n    // for (auto &a: matrial){\n    //   std::cout << a.first << \" \" << a.second << std::endl;\n    // }\n    // for (int i = 0; i < matrial.size(); i++) {\n    //   std::cout << \"min:\" << std::endl;\n    //   std::cout << p[i][0].first << \" \" << p[i][0].second << std::endl;\n    //   std::cout << \"max:\" << std::endl;\n    //   std::cout << p[i][1].first << \" \" << p[i][1].second << std::endl;\n    // }\n    // std::cout << matrial.size() << std::endl;\n    bool flag;\n    do{\n      flag = true;\n      for (int i = 0; i < matrial.size(); i++) {\n        for (int j = p[i][0].second; j <= p[i][1].second; j++) {\n          for (int k = p[i][0].first; k <= p[i][1].first; k++) {\n            //std::cout << j << \" \" << k << \" \" << grid[j][k]\n            //<< \" \" << matrial[grid[j][k]] << std::endl;\n            if(grid[j][k] == '.'){\n              i = 10;\n              j = p[i][1].second + 10;\n              k = p[i][1].first  + 10;\n              flag  = false;\n              break;\n            }\n            if(perm[matrial[grid[j][k]] - 1] > perm[i]){\n              flag = false;\n              i = 10;\n              j = p[i][1].second + 10;\n              k = p[i][1].first  + 10;\n            }\n          }\n        }\n      }\n    \n    }while(next_permutation(perm.begin(), perm.end()) &&\n           flag == false);\n    if(flag){\n      std::cout << \"SAFE\" << std::endl;\n    }else{\n      std::cout << \"SUSPICIOUS\" << std::endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n\nint H,W;\nchar fld[50][50];\nint A[50][50];\nbool mark[50][50];\nvoid solve(){\n    cin>>H>>W;\n    rep(i,H)rep(j,W)cin>>fld[i][j];\n    vector<char>vec;\n    rep(i,H)rep(j,W)if(isalpha(fld[i][j]))vec.pb(fld[i][j]);\n    sort(all(vec));vec.erase(unique(all(vec)),vec.end());\n    rep(i,H)rep(j,W){\n        if(isalpha(fld[i][j]))A[i][j]=lower_bound(all(vec),fld[i][j])-vec.begin();\n        else A[i][j]=vec.size();\n    }\n\n    int max_x[10],max_y[10],min_x[10],min_y[10];\n    rep(i,vec.size()){\n        max_x[i]=max_y[i]=-1001001001;\n        min_x[i]=min_y[i]=1001001001;\n    }\n\n    rep(i,H)rep(j,W){\n        chmax(max_x[A[i][j]],j);\n        chmax(max_y[A[i][j]],i);\n        chmin(min_x[A[i][j]],j);\n        chmin(min_y[A[i][j]],i);\n    }\n\n    vint p(vec.size());\n    rep(i,vec.size())p[i]=i;\n    do{\n        memset(mark,0,sizeof(mark));\n        bool ok=true;\n        for(int c:p){\n            reps(i,min_y[c],max_y[c]+1){\n                reps(j,min_x[c],max_x[c]+1){\n                    if(!mark[i][j]&&A[i][j]!=c)ok=false;\n                    mark[i][j]=true;\n                }\n            }\n        }\n        if(ok){\n            cout<<\"SAFE\"<<endl;\n            return;\n        }\n    }while(next_permutation(all(p)));\n    cout<<\"SUSPICIOUS\"<<endl;\n}\n\nsigned main(){\n    int T;\n    cin>>T;\n    while(T--)solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<stack>\n#include<cmath>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<sstream>\n#include<random>\n#include<cassert>\n#include<climits>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\nusing pii = pair<int, int>;\nconst int inf = 1e9 + 7;\nint dy[] = {0, 0, -1, 1, -1, 1, -1, 1};\nint dx[] = {1, -1, 0, 0, -1, 1, 1, -1};\n#define ceil(a, b) a / b + !!(a % b)\n#define chmax(a, b) a = max(a, b)\n#define chmin(a, b) a = min(a, b)\n\nstruct Node {\n    char self;\n    set<char> parent;\n};\nint l, r, u, b;\nint h, w;\nchar table[51][51];\nqueue<pii> q;\nint reached[51][51];\nint num = 0;\nNode node[7];\nint flg = 0;\nset<char> s;\nint check[7];\nmap<char, int> mp;\n\nvoid getlrub(char e) {\n    reached[q.front().first][q.front().second] = 1;\n    while (!q.empty()) {\n        int y = q.front().first;\n        int x = q.front().second;\n        q.pop();\n        rep(i, 4) {\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if (ny >= h || ny < 0 || nx >= w || nx < 0) continue;\n            if (reached[ny][nx] || table[ny][nx] != e) continue;\n            //if (e == 'A') cout << ny << \" \" << nx << endl;\n            reached[ny][nx] = 1;\n            chmin(l, nx); chmax(r, nx); chmax(u, ny); chmin(b, ny);\n            q.push({ny, nx});\n        }\n    }\n}\nint aftergetlrub(char e) {\n    //cout << l << \" \" << r << \" \" << b << \" \" << u << endl;\n    rep(i, h) {\n        rep(j, w) {\n            if (i >= b && i <= u && j >= l && j <= r) {\n                if (table[i][j] != e) {\n                    node[num].parent.insert(table[i][j]);\n                }\n                if (table[i][j] == '.') {\n                    return -1;\n                }\n            }\n        }\n    }\n    return 0;\n}\nvoid check_() {\n    rep(i, s.size()) {\n        cout << \"self \" << node[i].self << endl;\n        for (auto e2 : node[i].parent) cout << e2 << \" \";\n        cout << endl;\n    }\n}\nint getinfiniteloop() {\n    queue<char> qq;\n    int count = 0;\n    rep(i, s.size()) {\n        for (auto e : node[i].parent) {\n            qq.push(e);\n        }\n        while (!qq.empty()) {\n            char now = qq.front();\n            qq.pop();\n            for (auto e : node[mp[now]].parent) {\n                qq.push(e);\n                count++;\n                //cout << count << endl;\n                if (count > 100) return -1;\n            }\n        }\n    }\n    return 0;\n}\nint main() {\n    int n; cin >> n;\n    while (n--) {\n        flg = 0;\n        //cout << n << endl;\n        cin >> h >> w;\n        s.clear();\n        rep(i, h) rep(j, w) {cin >> table[i][j]; if (table[i][j] != '.') s.insert(table[i][j]);}\n        num = 0;\n        for (auto e : s) {\n            node[num].self = e;\n            node[num].parent.clear();\n            num++;\n        }\n        if (num == 0) {cout << \"SAFE\" << endl; continue;}\n        num = 0;\n        for (auto e : s) {\n            l = inf; r = -inf; u = -inf; b = inf;\n            rep(i, h) rep(j, w) reached[i][j] = 0;\n            rep(i, h) {\n                rep(j, w) {\n                    if (table[i][j] == e && reached[i][j] == 0) {\n                        //cout << i << \" \" << j << endl;\n                        q.push({i, j}); //y, x\n                        chmin(l, j); chmax(r, j); chmax(u, i); chmin(b, i);\n                        getlrub(e);\n                    }\n                }\n            }\n            if (aftergetlrub(e) == -1) {\n                cout << \"SUSPICIOUS\" << endl;\n                flg = 1;\n                break;\n            }\n            num++;\n        } //for (auto e : s)\n        if (flg) continue;\n        //check_();\n        //すべての点をみて、親を辿ると無限ループになるやつ探す\n        int c = 0;\n        mp.clear();\n        for (auto e : s) mp[e] = c++;\n        if (getinfiniteloop() == -1) cout << \"SUSPICIOUS\" << endl;\n        else cout << \"SAFE\" << endl;\n    } //datasets\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <map>\n#include <iostream>\nusing namespace std;\nint main(){\n  int n;\n  cin >> n;\n  for(int i = 0; i < n; ++i){\n    int h, w;\n    cin >> h >> w;\n    vector<string> V(h);\n    for(int i = 0; i < h; ++i){\n      cin >> V[i];\n    }\n    vector<int> T(26,h), L(26,w), R(26,-1), B(26,-1);\n    for(int i = 0; i < h; ++i){\n      for(int j = 0; j < w; ++j){\n        char c = V[i][j];\n        if(c != '.'){\n          T[c-'A'] = min(i,T[c-'A']);\n          L[c-'A'] = min(j,L[c-'A']);\n          B[c-'A'] = max(i,B[c-'A']);\n          R[c-'A'] = max(j,R[c-'A']);\n        }\n      }\n    }\n    vector<int> C;\n    for(int i = 0; i < 26; ++i){\n      if(B[i] >= 0) C.push_back(i);\n    }\n    string ans = \"SAFE\";\n    vector< vector<bool> > G(26,vector<bool>(26,false));\n    for(int i = 0; i < C.size(); ++i){\n      for(int j = T[C[i]]; j <= B[C[i]]; ++j){\n        for(int k = L[C[i]]; k <= R[C[i]]; ++k){\n          if(V[j][k] == '.'){\n            ans = \"SUSPICIOUS\";\n          }else if(V[j][k] != 'A'+C[i]){\n            G[C[i]][V[j][k]-'A'] = true;\n          }\n        }\n      }\n    }\n    if(ans == \"SUSPICIOUS\"){\n      cout << ans << endl;\n      continue;\n    }\n    ans = \"SUSPICIOUS\";\n    do{\n      map<int,int> M;\n      for(int i = 0; i < C.size(); ++i) M[C[i]] = i;\n      bool f = true;\n      for(int i = 0; i < 26; ++i){\n        if(!f) break;\n        for(int j = 0; j < 26; ++j){\n          if(G[i][j] && M[i] > M[j]){\n            f = false;\n            break;\n          }\n        }\n      }\n      if(f){\n        ans = \"SAFE\";\n      }\n    }while(next_permutation(C.begin(),C.end()));\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\n\tint h,w;\nbool dfs(vs &m,vi &usedChars,char c){\n\tusedChars[c-'A']=1;\n\tint x1=INT_MAX,x2=INT_MIN,y1=INT_MAX,y2=INT_MIN;\n\tfor (int i = 0; i < h; i++)\n\t{\n\t\tfor (int j = 0; j < w; j++)\n\t\t{\n\t\t\tif(m[i][j]==c){\n\t\t\t\tx1=min(x1,j);\n\t\t\t\tx2=max(x2,j);\n\t\t\t\ty1=min(y1,i);\n\t\t\t\ty2=max(y2,i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = y1; i <= y2; i++)\n\t{\n\t\tfor (int j = x1; j <= x2; j++)\n\t\t{\n\t\t\tif(m[i][j]!=c){\n\t\t\t\tif(m[i][j]=='.'||usedChars[m[i][j]-'A']){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif(!dfs(m,usedChars,m[i][j])){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor (int c = 0; c < n; c++)\n\t{\n\t\tcin>>h>>w;\n\t\tvs m(h);\n\t\tfor (int i = 0; i < h; i++)\n\t\t{\n\t\t\tcin>>m[i];\n\t\t}\n\t\tvi usedChars('Z'-'A'+1);\n\t\tbool ok=true;\n\t\tfor (int i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tif(m[i][j]!='.'){\n\t\t\t\t\tif(!dfs(m,usedChars,m[i][j])){\n\t\t\t\t\t\tok=false;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\nend:\n\t\tcout<<(ok?\"SAFE\":\"SUSPICIOUS\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <map>\n#include <cctype>\nusing namespace std;\nconst int MAX_M = 7;\nconst int INF = 1<<29;\nstruct min_max{\n  int x_min,x_max,y_min,y_max;\npublic:\n  min_max(){\n    x_min = INF,x_max = -1,y_min = INF,y_max = -1;\n  }\n  void cal(int x,int y){\n    x_min = min(x,x_min);\n    y_min = min(y,y_min);\n    x_max = max(x,x_max);\n    y_max = max(y,y_max);\n    //    cout << \"x \" << x_min << \" y \" << y_min << endl;\n  }\n  bool check(){\n    if(x_min == INF)return false;\n    return true;\n  }\n};\nvoid dfs(const vector<vector<int> > relate,vector<pair<int,int> > &used,int c,int &cnt){\n  if(used[c].second == 1)return;\n  used[c].second = 1;\n  for(int i = 0;i < relate[c].size();i++){\n    if(used[relate[c][i]].second == 0){\n      dfs(relate,used,relate[c][i],cnt);\n    }\n  }\n  cnt++;\n  used[c].first = cnt;\n}\nint main(){\n  int n;\n  cin >> n;\n  for(int cnt = 0;cnt < n;cnt++){\n    int h,w;\n    cin >> h >> w;\n    map<char,int> che;\n    vector<vector<int> > image(h,vector<int>(w,0));\n    vector<min_max> keep(MAX_M,min_max());\n    for(int i = 0;i < h;i++){\n      for(int j = 0;j < w;j++){\n\tchar tmp;\n\tcin >> tmp;\n\tif(isupper(tmp)){\n\t  if(che.count(tmp) == 0){\n\t    che.insert(make_pair(tmp,che.size()));\n\t  }\n\t  keep[che[tmp]].cal(j,i);\n\t  //cout << keep[che[tmp]].x_min << \"ddd\" << endl;\n\t  image[i][j] = che[tmp];\n\t}else{\n\t  image[i][j] = -1;\n\t}\n      }\n    }\n    /*    for(int i = 0;i < keep.size();i++){\n      cout << keep[i].x_min << \" \" << keep[i].x_max << \" \" << keep[i].y_min << \" \" << keep[i].y_max << endl;\n      }\n    */\n    \n    int flag = 0;\n    int size = che.size();\n    vector<vector<int> > relate(size);\n    map<char,int>::iterator it = che.begin();\n    while(it != che.end()){\n      int i = (*it).second;\n      for(int x = keep[i].x_min;x <= keep[i].x_max;x++){\n\tfor(int y = keep[i].y_min;y <= keep[i].y_max;y++){\n\t  if(image[y][x] != i && image[y][x] >= 0 && image[y][x] < size ){\n\t    relate[i].push_back(image[y][x]);\n\t  }else{\n\t    if(image[y][x] == -1)flag = 1;\n\t  }\n\t}\n      }\n      it++;\n    }\n    if(flag){cout << \"SUSPICIOUS\" << endl;continue;}\n    vector<pair<int,int> > used(size,pair<int,int>(0,0));\n    int a = 0;\n    for(int i = 0;i < used.size();i++){\n      dfs(relate,used,i,a);\n    }/*\n    for(int i = 0;i < size;i++){\n      cout << used[i].first <<\"kkkk\"<< endl;\n      }*/\n    for(int i = 0;i < relate.size();i++){\n      for(int j = 0;j < relate[i].size();j++){\n\t//cout << relate[i][j] << \"ddddddd \" <<i<<\" fff\"<<cnt<< endl;\n\tif(used[i].first < used[relate[i][j]].first){\n\t  flag = 1;\n\t}\n      }\n    }\n    if(flag)cout << \"SUSPICIOUS\" << endl;\n    else cout << \"SAFE\" << endl;\n  }\n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "//Is input file is the same as the below link?\n//http://acm-icpc.aitea.net/index.php?plugin=attach&refer=2006%2FPractice%2F%CC%CF%B5%BC%B9%F1%C6%E2%CD%BD%C1%AA%2F%CC%E4%C2%EA%CA%B8%A4%C8%A5%C7%A1%BC%A5%BF%A5%BB%A5%C3%A5%C8&openfile=judge-data.zip\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n \n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define ALL(X) (X).begin(),(X).end()\n \nusing namespace std;\n \nconst int INF = 1000000000;\nconst double eps = 1e-8;\n \nint main(void) {\n    int n;\n    cin>>n;\n    REP(i,n)\n    {\n        int h,w;\n        cin>>h>>w;\n        vector<string> table(h);\n        set<char> s;\n        REP(j,h)\n        {\n            cin>>table[j];\n            REP(k,w)\n            {\n                s.insert(table[j][k]);\n            }\n        }\n        s.erase('.');\n        vector<char> mats;\n        FORIT(j,s)\n            mats.push_back(*j);\n        if(mats.size())\n        {\n            bool flg = true;\n            do\n            {\n                flg = true;\n                vector<string> cp(h);\n                REP(k,h)cp[k]=string(table[k]);\n                REP(j,mats.size())\n                {\n                    int top=h,bottom=0,left=w,right=0;\n                    REP(k,h)REP(l,w)\n                    {\n                        if(cp[k][l] == mats[j])\n                        {\n                            top=min(top,k);\n                            bottom=max(bottom,k);\n                            left=min(left,l);\n                            right=max(right,l);\n                        }\n                    }\n                    FOR(k,top,bottom+1)\n                    {\n                        FOR(l,left,right+1)\n                        {\n                            if(cp[k][l]=='.')\n                            {\n                                flg = false;\n                                break;\n                            }\n                            else if(cp[k][l]==mats[j])\n                            {\n                                cp[k][l] = '.';\n                            }\n                        }\n                        if(!flg)break;\n                    }\n                    if(!flg)break;\n                }\n                if(flg)break;\n            }while(next_permutation(ALL(mats)));\n            if(flg)\n                cout << \"SAFE\" << endl;\n            else\n                cout << \"SUSPICIOUS\" << endl;\n        }\n        else\n            cout << \"SAFE\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint h, w;\nchar field[100][100];\nbool visit[100][100];\nbool dfsvisit[10];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\nset<int> edges[10];\n\nbool dfs(int where, int from) {\n  if (where == from && dfsvisit[where]) { return false; }\n  if (dfsvisit[where]) { return true; }\n  dfsvisit[where] = true;\n  FORIT(it, edges[where]) {\n    if (!dfs(*it, from)) { return false; }\n  }\n  return true;\n}\n\nint main() {\n  int test;\n  scanf(\"%d\", &test);\n  while (test--) {\n    REP(i, 10) { edges[i].clear(); }\n    scanf(\"%d %d\", &h, &w);\n    MEMSET(visit, false);\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n    }\n    REP(y, h) {\n      REP(x, w) {\n        if (visit[y][x] || field[y][x] == '.') { continue; }\n        queue<pair<int, int> > que;\n        que.push(make_pair(x, y));\n        int minx = x;\n        int miny = y;\n        int maxx = x;\n        int maxy = y;\n        while (!que.empty()) {\n          int x = que.front().first;\n          int y = que.front().second;\n          que.pop();\n          if (visit[y][x]) { continue; }\n          visit[y][x] = true;\n          minx = min(minx, x);\n          miny = min(miny, y);\n          maxx = max(maxx, x);\n          maxy = max(maxy, y);\n          REP(i, 4) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (nx < 0 || nx >= w || ny < 0 || ny >= h) { continue; }\n            if (field[y][x] != field[ny][nx]) { continue; }\n            que.push(make_pair(nx, ny));\n          }\n        }\n        FOREQ(ny, miny, maxy) FOREQ(nx, minx, maxx) {\n          if (field[ny][nx] == '.') {\n            puts(\"SUSPICIOUS\");\n            goto next;\n          } else if (field[ny][nx] != field[y][x]) {\n            edges[(int)field[y][x] - 'A'].insert(field[ny][nx] - 'A');\n          }\n        }\n      }\n    }\n    REP(i, 10) {\n      MEMSET(dfsvisit, false);\n      if (!dfs(i, i)) {\n        puts(\"SUSPICIOUS\");\n        goto next;\n      }\n    }\n    puts(\"SAFE\");\nnext:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define max(a,b) a > b ? a : b\n#define min(a,b) a < b ? a : b\n\nvoid getstr(char str[]){\n\tchar c;\n\tint i = 0;\n\twhile((c = getchar()) != '\\n')\n\t\tstr[i++] = c;\n\tstr[i] = '\\0';\n}\n\nint dfs(int a[26][26],char c){\n\tstatic int flag[26] = {0};\n\tint j, ret = 0;\n\tflag[c - 'A'] = 1;\n\tfor(j = 0;j < 26;j++){\n\t\tif(a[c - 'A'][j]){\n\t\t\tif(flag[j]){\n\t\t\t\tflag[c - 'A'] = 0;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tret += dfs(a,'A' + j);\n\t\t}\n\t}\n\tflag[c - 'A'] = 0;\n\treturn ret;\n}\nint main(void){\n\tint h, w, flag, hmin, wmin, hmax, wmax, i, j, k, n, a[26][26];\n\tchar c, str[50][51];\n\tscanf(\"%d\",&n);\n\tfor(k = 0;k < n;k++){\n\t\tscanf(\"%d%d%*c\",&h,&w);\n\t\tfor(i = 0;i < h;i++)\n\t\t\tgetstr(str[i]);\n\t\tmemset(a,0,sizeof(a));\n\t\tfor(c = 'A';c <= 'Z';c++){\n\t\t\tflag = 0;\n\t\t\tfor(i = 0;i < h;i++){\n\t\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\t\tif(str[i][j] == c) flag = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\thmax = wmax = 0;\n\t\t\t\thmin = h - 1;\n\t\t\t\twmin = w - 1;\n\t\t\t\tfor(i = 0;i < h;i++){\n\t\t\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\t\t\tif(str[i][j] == c){\n\t\t\t\t\t\t\thmax = max(hmax,i);\n\t\t\t\t\t\t\twmax = max(wmax,j);\n\t\t\t\t\t\t\thmin = min(hmin,i);\n\t\t\t\t\t\t\twmin = min(wmin,j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(i = hmin;i <= hmax;i++){\n\t\t\t\t\tfor(j = wmin;j <= wmax;j++){\n\t\t\t\t\t\tif(str[i][j] == '.') break;\n\t\t\t\t\t\telse if(str[i][j] != c) a[str[i][j] - 'A'][c - 'A'] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(j != wmax + 1) break;\n\t\t\t\t}\n\t\t\t\tif(i != hmax + 1)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tflag = 0;\n\t\tfor(i = 0;i < 26;i++)\n\t\t\tflag += dfs(a,c);\n\t\tif(c == 'Z' + 1 && !flag)\n\t\t\tprintf(\"SAFE\\n\");\n\t\telse\n\t\t\tprintf(\"SUSPICIOUS\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nstring str[60];\nint h,w;\nint num;\nbool flag;\nbool used[55][55];\nchar moji[10];\nint vx[4]={1,0,-1,0};\nint vy[4]={0,1,0,-1};\nvoid dfs(int Bit,int depth){\n  if(Bit==((1<<num)-1)){\n    flag=true;\n    return;\n  }\n  for(int i=0;i<num;i++){\n    if(!(Bit&(1<<i))){\n      bool used2[55][55]={};\n      int lemi=100,lema=0,rimi=100,rima=0;\n      for(int j=0;j<h;j++){\n\tfor(int k=0;k<w;k++){\n\t  if(str[j][k]==moji[i]){\n\t    used2[j][k]=true;\n\t    used[j][k]=true;\n\t    lemi=min(lemi,k);\n\t    lema=max(lema,k);\n\t    rima=max(rima,j);\n\t    rimi=min(rimi,j);\n\t  }\n\t}\n      }\n      bool fll=true;\n      for(int j=rimi;j<=rima;j++){\n\tfor(int k=lemi;k<=lema;k++){\n\t  if(!used[j][k]){\n\t    fll=false;\n\t  }\n\t}\n      }\n      if(fll)\n      dfs(Bit+(1<<i),depth+1);\n      for(int j=rimi;j<=rima;j++){\n\tfor(int k=lemi;k<=lema;k++){\n\t  if(used2[j][k]){\n\t    used[j][k]=false;\n\t  }\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int n;cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>h>>w;\n    num=0;\n    for(int i=0;i<55;i++)\n      for(int j=0;j<55;j++)\n\tused[i][j]=false;\n    flag=false;\n    bool alfa[26]={};\n    for(int i=0;i<h;i++){\n      cin>>str[i];\n      for(int j=0;j<w;j++){\n\talfa[str[i][j]-'A']=true;\n      }\n    }\n    int cnt=0;\n    for(int i=0;i<26;i++){\n      num+=alfa[i];\n      if(alfa[i]){\n\tmoji[cnt]=(char)(i+'A');\n\tcnt++;\n      }\n    }\n    dfs(0,0);\n    if(flag)\n      cout<<\"SAFE\"<<endl;\n    else \n      cout<<\"SUSPICIOUS\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool ans;\n\n// 文字cの出現するx,y座標の最大値と最小値の保持に使う\nstruct range{\n\tint min_x, min_y, max_x, max_y;\n\trange(int min_x_ , int min_y_ , int max_x_ , int max_y_ ){\n\t\tmin_x = min_x_;\n\t\tmin_y = min_y_;\n\t\tmax_x = max_x_;\n\t\tmax_y = max_y_;\n\t}\n};\n\nvoid debug(const vector<string>& m){\n\tcout << \"[debug]\" << endl;\n\tfor(int y=0 ; y < m.size() ; y++ ){\n\t\tcout << m[y] << endl;\n\t}\n\tcout << endl;\n}\n\nvoid debug2(const vector<char>& vc, const vector<range>& vr){\n\tfor(int i=0 ; i < vc.size() ; i++ ){\n\t\trange r = vr[i];\n\t\tcout << vc[i] << \" \" << endl;\n\t\tcout << \"x => [\" << r.min_x << \",\" << r.max_x << \"] \";\n\t\tcout << \"y => [\" << r.min_y << \",\" << r.max_y << \"] \";\n\t\tcout << endl << endl;\n\t}\n}\n\n// 文字 c の出現する x,y 座標の最大値と最小値を求める\nrange search_range(const vector<string>& m, char c){\n\tint min_x = -1, min_y = -1, max_x = -1, max_y = -1;\n\tfor(int y = 0 ; y < m.size() ; y++ ){\n\t\tfor(int x=0 ; x < m[y].size() ; x++ ){\n\t\t\tif( m[y][x] == c ){\n\t\t\t\tmin_x = (min_x == -1)? x : min( min_x , x );\n\t\t\t\tmin_y = (min_y == -1)? y : min( min_y , y );\n\t\t\t\tmax_x = (max_x == -1)? x : max( max_x , x );\n\t\t\t\tmax_y = (max_y == -1)? y : max( max_y , y );\n\t\t\t}\n\t\t}\n\t}\n\trange r( min_x , min_y , max_x , max_y );\n\treturn r;\n}\n\n// 文字 c について長方形かどうか\nbool check(const vector<string>& m, range r, char c){\n\tint cnt = 0;\n\tfor(int y = r.min_y ; y <= r.max_y ; y++ ){\n\t\tfor(int x = r.min_x ; x <= r.max_x ; x++ ){\n\t\t\tif( m[y][x] == c || m[y][x] == '*' ){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//cout << \"search \" << c << \" cnt : \" << cnt << endl;\n\t//cout << \"(\" << r.min_x << \",\" << r.min_y << \") => (\" << r.max_x << \",\" << r.max_y << \")\" << endl; \n\t\n\tif( cnt != (r.max_x - r.min_x + 1) * (r.max_y - r.min_y + 1) ){\n\t\treturn false;\n\t}\n\t\n\tfor(int y = 0 ; y < m.size() ; y++ ){\n\t\tfor(int x = 0 ; x < m[y].size() ; x++ ){\n\t\t\tif( r.min_x <= x && r.min_y <= y && x <= r.max_x && y <= r.max_y ){\n\t\t\t}else if( m[y][x] == c ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\n// 文字 c を' *' に置き換える (荷物を取り除く) \nvoid remove(vector<string>& m, range r, char c){\n\tfor(int y = r.min_y ; y <= r.max_y ; y++ ){\n\t\tfor(int x = r.min_x ; x <= r.max_y ; x++ ){\n\t\t\tif( m[y][x] == c ){\n\t\t\t\tm[y][x] = '*';\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(int id, vector<bool> memo, vector<string> m, vector<char> vc, vector<range> vr){\n\tmemo[id] = true;\n\t\n\t// 長方形かどうか\n\tbool is_rect = check( m , vr[id] , vc[id] );\n\tif( is_rect == false ){\n\t\treturn;\n\t}\n\t\n\t// 文字 vc[id] を '*' に置き換える (荷物を取り除く) \n\tremove( m , vr[id] , vc[id] );\n\t\n\t//cout << vc[id] << \" is rectangle! \" << endl;\n\t//debug( m );\n\t\n\t// すべて調べたかどうか\n\tint cnt = 0;\n\tfor(int i=0 ; i < memo.size() ; i++ ){\n\t\tif( memo[i] )\n\t\t\tcnt++;\n\t}\n\tif( cnt == memo.size() && is_rect ){\n\t\tans = true;\n\t\treturn;\n\t}\n\t\n\tfor(int i=0 ; i < memo.size() ; i++ ){\n\t\tif( memo[i] == false ){\n\t\t\t//cout << \"next : \" << vc[i] << endl;\n\t\t\tdfs( i , memo , m , vc , vr );\n\t\t}\n\t}\n}\n\nvoid solve(const vector<string>& m){\n\tchar ch[256] = {0};\n\tvector<char> vc;\n\tvector<range> vr;\n\tans = false;\n\t\n\t// 出現する文字を調べる\n\tfor(int y=0 ; y < m.size() ; y++ ){\n\t\tfor(int x=0 ; x < m[y].size() ; x++ ){\n\t\t\tif( m[y][x] >= 'A' && m[y][x] <= 'Z' ){\n\t\t\t\tch[ m[y][x] ] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(char c = 'A' ; c <= 'Z' ; c++ ){\n\t\tif( ch[c] )\n\t\t\tvc.push_back( c );\n\t}\n\t\n\t// 文字がなかったら \"SAFE\"\n\tif( vc.size() == 0 ){\n\t\tans = true;\n\t}\n\t\n\t// 各文字 c について x,y 座標の最大値と最小値を求める\n\tfor(int i=0 ; i < vc.size() ; i++ ){\n\t\trange r = search_range( m , vc[i] );\n\t\tvr.push_back( r );\n\t}\n\t//debug2( vc , vr );\n\t\n\t// DFSで重なる順番をすべて調べる\n\tvector<bool> memo( vc.size() );\n\tfor(int k=0 ; k < vc.size() ; k++ ){\n\t\tfor(int i=0 ; i < memo.size() ; i++ ){\n\t\t\tmemo[i] = false;\n\t\t}\n\t\tdfs( k , memo , m , vc , vr );\n\t}\n\t\n}\n\nint main(){\n\tint T;\n\tcin >> T;\n\tfor(int t_ = 0 ; t_ < T ; t_++ ){\n\t\tint w, h;\n\t\tcin >> h >> w;\n\t\t\n\t\tvector<string> m(h);\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> m[y];\n\t\t}\n\t\t\n\t\tsolve( m );\n\t\t\n\t\tif( ans ){\n\t\t\tcout << \"SAFE\" << endl;\n\t\t}else{\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n#define inf 1e9\n\n\nstruct item{\n    int l = inf, r = 0, t = inf, b = 0;\n};\n\nvector<string> g(50);\nvector<item> a(26);\nvector<int> x;\nbool f;\n\nvoid perm(vector<int> p, int bit, int n) {\n    if (n == x.size()) {\n        bool ff = true;\n        for (int i = 0; i < p.size(); i++) {\n            int ho = x[p[i]];\n            set<int> se;\n            for (int j = i; j < x.size(); j++) se.insert(x[p[j]]);\n            \n            for (int h = a[ho].t; h < a[ho].b + 1; h++) {\n                for (int w = a[ho].l; w < a[ho].r + 1; w++) {\n                    int c = g[h][w]-'A';\n                    set<int>::iterator it = se.find(c);\n                    if (it == se.end()) ff = false;\n                    if (!ff) break;\n                }\n                if (!ff) break;\n            }\n            if (!ff) break;\n        }\n        if (ff) f = true;\n        return ;\n    }\n    \n    for (int i = 0; i < x.size(); i++) {\n        if (bit & 1<<i) continue;\n        vector<int> a = p;\n        a.push_back(i);\n        perm(a, bit | 1<<i, n+1);\n    }\n}\n\n\nint main(void){\n    int n;\n    cin >> n;\n    while (n--) {\n        int h, w;\n        cin >> h >> w;\n        g.clear();\n        a.clear();\n        x.clear();\n        f = false;\n        for (int i = 0; i < h; i++) {\n            cin >> g[i];\n            for (int j = 0; j < w; j++) if (g[i][j] != '.') {\n                char c = g[i][j];\n                int  t = c - 'A';\n                a[t].l = min(a[t].l, j);\n                a[t].r = max(a[t].r, j);\n                a[t].t = min(a[t].t, i);\n                a[t].b = max(a[t].b, i);\n                t = g[i][j]-'A';\n                x.push_back(t);\n            } \n        }\n        sort(x.begin(), x.end());\n        x.erase(unique(x.begin(), x.end()), x.end());\n        vector<int> t;\n        \n        perm(t,0,0);\n        if (f) cout << \"SAFE\" << endl;\n        else cout << \"SUSPICIOUS\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \nvoid chmin(int& x, int y)\n{\n  x = min(x, y);\n}\nvoid chmax(int& x, int y)\n{\n  x = max(x, y);\n}\n  \nint main()\n{\n  int Q, H, W;\n  string S[50];\n  int proc = 1;\n  int used[50][50] = {{}};\n  \n  cin >> Q;\n  while(Q--) {\n    cin >> H >> W;\n  \n    string chars = \"\";\n    for(int i = 0; i < H; i++) {\n      cin >> S[i];\n      chars += S[i];\n    }\n    sort(chars.begin(), chars.end());\n    chars += \".\";\n    chars.erase(unique(chars.begin(), chars.end()), chars.end());\n\n    int xx1[128], xx2[128] = {}, yy1[128], yy2[128] = {};\n    fill_n(xx1, 128, W);\n    fill_n(yy1, 128, H);\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        int pos = chars.find(S[i][j]);\n        chmin(xx1[S[i][j]], j);\n        chmax(xx2[S[i][j]], j);\n        chmin(yy1[S[i][j]], i);\n        chmax(yy2[S[i][j]], i);\n      }\n    }\n    \n    bool Judge = chars.size() == 1;\n    do {\n      if(chars[chars.size() - 1] != '.') continue;\n      Judge = true;\n      for(int i = 0; i < chars.size(); i++) {\n        for(int j = xx1[chars[i]]; j <= xx2[chars[i]]; j++) {\n          for(int k = yy1[chars[i]]; k <= yy2[chars[i]]; k++) {\n            if(used[j][k] == proc) continue;\n            used[j][k] = proc;\n            if(S[k][j] != chars[i]) {\n              Judge = false;\n              goto myon;\n            }\n          }\n        }\n      }\n    myon: ;\n      ++proc;\n    } while(!Judge && next_permutation(chars.begin(), chars.end()));\n    if(Judge) cout << \"SAFE\" << endl;\n    else cout << \"SUSPICIOUS\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <set>\n#include <iomanip>\n#include <stack>\n#include <fstream>\n#include <cstdint>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <functional>\n\nusing namespace std;\n\n\ntypedef int64_t ll;\n\n\nclass rect{\n    static const int inf = 100000;\npublic:\n    int sx, sy; // 始点 左上\n    int ex, ey; // 終点 右下\n    rect() :sx(inf), sy(inf), ex(), ey() {}\n    \n    void modify(const int& i, const int& j){\n        sx = min(i, sx);\n        sy = min(j, sy);\n        \n        ex = max(i, ex);\n        ey = max(j, ey);\n    }\n};\n\nbool is_real_over(char T, map<char, set<char>>& overs, set<char> pre){\n    for (auto && top : overs[T]) {\n        if(pre.count(top) > 0) {\n//            cerr << \"CROSS ERROrR\\n\";\n            return false;\n        }\n        pre.insert(top);\n        return is_real_over(top, overs, pre);\n    }\n    return true;\n\n}\n\n\nbool solve(){\n    int h, w;\n    cin >> h >> w;\n    vector<vector<char>> v;\n    map<char, rect> shapes;\n    for (int i = 0; i < h; ++i) {\n        v.push_back({});\n        for (int j = 0; j < w; ++j) {\n            char tmp;\n            cin >> tmp;\n            v[i].push_back(tmp);\n\n            if(tmp != '.')\n                shapes[tmp].modify(i, j);\n        }\n    }\n\n\n    // 矩形調査 yz\n    map<char, set<char>> overs;\n    for(auto && rec_pair: shapes){\n        auto && rec = rec_pair.second;\n        auto && rec_name = rec_pair.first;\n//        cerr << \"NAME:\" << rec_name << '\\n';\n        for (int i = rec.sx; i <= rec.ex; ++i) {\n            for (int j = rec.sy; j <= rec.ey; ++j) {\n                auto&& this_char = v[i][j];\n                if(this_char != rec_name){\n                    if(this_char == '.'){\n//                        cerr << \"SHAPE MISS\\n\";\n                        return false;\n                    }\n                    overs[this_char].insert(rec_name);\n                }\n            }\n        }\n    }\n//    cerr << \"OVERS::\\n\";\n//    for(auto && m : overs){\n//        cerr << m.first << ':';\n//        for(auto && t : m.second){\n//            cerr << ' ' << t;\n//        }\n//        cerr << '\\n';\n//    }\n\n    // 重なり調査\n    for(auto&& op: overs){\n        if(!is_real_over(op.first, overs, {op.first}))\n            return false;\n    }\n\n\n    return true;\n    \n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        cout << (!solve() ? \"SUSPICIOUS\" : \"SAFE\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\nchar **data;\n//char **datab;\nchar done[7];\nint donen;\nint h,w;\n\nint r(char);\nint inc(char);\nvoid sear(char,int*,int*,int*,int*);\n\nint main(){\n\tint n;\n\tint i,j;\n\tchar s[50];\n\tchar *ps;\n\tint size;\n\tint error;\n\tfgets(s,sizeof(s),stdin);\n\tsize=atoi(s);\n\tfor(n=0;n<size;n++){\n\t\tfgets(s,sizeof(s),stdin);\n\t\tps=strtok(s,\" \");\n\t\th=atoi(ps);\n\t\tps=strtok(NULL,\" \");\n\t\tw=atoi(ps);\n\n\t\tdata=new char*[h];\n\t\t//datab=new char*[h];\n\t\tfor(i=0;i<h;i++){\n\t\t\tdata[i]=new char[w];\n\t\t\t//datab[i]=new char[w];\n\t\t\tfgets(s,sizeof(s),stdin);\n\t\t\tmemcpy(data[i],s,w);\n\t\t\t//memcpy(datab[i],s,w);\n\t\t}\n\t\tmemset(done,0,sizeof(done));\n\t\tdonen=0;\n\t\terror=0;\n\t\tfor(i=0;i<h;i++){\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tif(data[i][j]!='.' && data[i][j]!=' '){\n\t\t\t\t\tif(r(data[i][j])==1){\n\t\t\t\t\t\terror=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}/*\n\t\t\t\t\tfor(int k=0;k<h;k++){\n\t\t\t\t\t\tfor(int l=0;l<w;l++){\n\t\t\t\t\t\t\tif(data[k][l]==' ') data[k][l]='.';\n\t\t\t\t\t\t}\n\t\t\t\t\t}*/\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(error==1) break;\n\t\t}\n\t\tif(error==0) cout<<\"SAFE\"<<endl;\n\t\telse cout<<\"SUSPICIOUS\"<<endl;\n\t\tfor(i=0;i<h;i++) delete []data[i];\n\t\tdelete []data;\n\t}\n\treturn 0;\n}\n\nint r(char c){\n\tint i,j;\n\tint x1,x2,y1,y2;\n\tsear(c,&x1,&y1,&x2,&y2);\n\tfor(i=y1;i<=y2;i++){\n\t\tfor(j=x1;j<=x2;j++){\n\t\t\t//if(data[i][j]==c) data[i][j]=' ';\n\t\t\tif(data[i][j]=='.') return 1;\n\t\t\telse if(inc(data[i][j])==1) return 1;\n\t\t}\n\t}\n\tdone[donen++]=c;\n\tfor(i=y1;i<=y2;i++){\n\t\tfor(j=x1;j<=x2;j++){\n\t\t\tif(data[i][j]!=c &&data[i][j]!=' '){\n\t\t\t\tif(r(data[i][j])==1) return 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=y1;i<=y2;i++){\n\t\tfor(j=x1;j<=x2;j++){\n\t\t\tif(data[i][j]==c) data[i][j]=' ';\n\t\t}\n\t}\n\treturn 0;\n}\n\nint inc(char c){\n\tfor(int i=0;i<donen;i++) if(done[i]==c) return 1;\n\treturn 0;\n}\n\nvoid sear(char c,int *x1,int *y1,int *x2,int *y2){\n\tint i,j;\n\t*x1=*x2=*y1=*y2=-1;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(data[i][j]==c){\n\t\t\t\t*y1=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(*y1!=-1) break;\n\t}\n\tfor(i=h-1;i>=0;i--){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(data[i][j]==c){\n\t\t\t\t*y2=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(*y2!=-1) break;\n\t}\n\tfor(i=0;i<w;i++){\n\t\tfor(j=0;j<h;j++){\n\t\t\tif(data[j][i]==c){\n\t\t\t\t*x1=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(*x1!=-1) break;\n\t}\n\tfor(i=w-1;i>=0;i--){\n\t\tfor(j=0;j<h;j++){\n\t\t\tif(data[j][i]==c){\n\t\t\t\t*x2=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(*x2!=-1) break;\n\t}\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nstring str[60];\nint h,w;\nint num;\nbool flag;\nbool used[55][55];\nchar moji[10];\nint vx[4]={1,0,-1,0};\nint vy[4]={0,1,0,-1};\nvoid dfs(int Bit,int depth){\n  if(Bit==((1<<num)-1)){\n    flag=true;\n    return;\n  }\n\n  for(int i=0;i<num;i++){\n    if(!(Bit&(1<<i))){\n      bool used2[55][55]={};\n      int lemi=100,lema=0,rimi=100,rima=0;\n      for(int j=0;j<h;j++){\n\tfor(int k=0;k<w;k++){\n\t  if(str[j][k]==moji[i]){\n\t    used2[j][k]=true;\n\t    used[j][k]=true;\n\t    lemi=min(lemi,k);\n\t    lema=max(lema,k);\n\t    rima=max(rima,j);\n\t    rimi=min(rimi,j);\n\t  }\n\t}\n      }\n      for(int j=rimi;j<=rima;j++){\n\tfor(int k=lemi;k<=lema;k++){\n\t  if(!used[j][k]){\n\t    return;\n\t  }\n\t}\n      }\n      dfs(Bit+(1<<i),depth+1);\n      for(int j=rimi;j<=rima;j++){\n\tfor(int k=lemi;k<=lema;k++){\n\t  if(used2[j][k]){\n\t    used[j][k]=false;\n\t  }\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int n;cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>h>>w;\n    num=0;\n    for(int i=0;i<55;i++)\n      for(int j=0;j<55;j++)\n\tused[i][j]=false;\n    flag=false;\n    bool alfa[26]={};\n    for(int i=0;i<h;i++){\n      cin>>str[i];\n      for(int j=0;j<w;j++){\n\talfa[str[i][j]-'A']=true;\n      }\n    }\n    int cnt=0;\n    for(int i=0;i<26;i++){\n      num+=alfa[i];\n      if(alfa[i]){\n\tmoji[cnt]=(char)(i+'A');\n\t//cout<<moji[cnt]<<endl;\n\tcnt++;\n      }\n    }\n    dfs(0,0);\n    if(flag)\n      cout<<\"SAFE\"<<endl;\n    else cout<<\"SUSPICIOUS\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<set>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a,i<b;++i)\n#define rep(i,n) REP(i,0,n)\n\nstruct P {\n  int maxx,maxy,minx,miny;\n  P() {\n    maxx = maxy = -1;\n    minx = miny = 51;\n  }\n};\n\nint dist[26][26];\nint visited[26];\n\nbool visit(int i) {\n  if(i<0 || i>25) return false;\n  visited[i] = 2;\n  for(int j=0; j<26; ++j) {\n    if(dist[i][j] == 0) continue;\n    if(visited[j] != 0) {\n      if(visited[j] == 2) return false;\n    } else if (!visit(j)) return false;\n  }\n  visited[i] = 1;\n  return true;\n}\n\nint main() {\n  int h,w,n,k,l,start,now,i,j;\n  string s;\n  cin>>n;\n  while(n--) {\n    cin>>h>>w;\n    vector<string> in;\n    for(i=0; i<h; ++i) {\n      cin>>s;\n      in.push_back(s);\n    }\n\n    for(k=0; k<26; ++k) {\n      for(l=0; l<26; ++l) {\n\tdist[k][l] = 0;\n      }\n    }\n\n    set<char> badget;\n    map<char, P> mp;\n    queue<int> Q;\n    for(i=0; i<h; ++i) {\n      for(j=0; j<w; ++j) {\n\tif(in[i].at(j) != '.') {\n\t  badget.insert(in[i].at(j));\n\t  mp[in[i].at(j)].maxx = max(mp[in[i].at(j)].maxx, j);\n\t  mp[in[i].at(j)].maxy = max(mp[in[i].at(j)].maxy, i);\n\t  mp[in[i].at(j)].minx = min(mp[in[i].at(j)].minx, j);\n\t  mp[in[i].at(j)].miny = min(mp[in[i].at(j)].miny, i);\n\t}\n      }\n    }\n\n    if(badget.size() == 0) {\n      cout<<\"SAFE\"<<endl;\n      goto NEXT;\n    }\n\n    memset(dist, 0, sizeof(dist));\n    for(set<char>::iterator it = badget.begin(); it != badget.end(); ++it) {\n      int maxx = mp[(*it)].maxx,maxy = mp[(*it)].maxy;\n      int minx = mp[(*it)].minx,miny = mp[(*it)].miny;\n      for(i=miny; i<=maxy; ++i) {\n\tfor(j=minx; j<maxx; ++j) {\n\t  if(in[i].at(j) == '.') {\n\t    cout<<\"SUSPICOUS\"<<endl;\n\t    goto NEXT;\n\t  }else if(in[i].at(j) != (*it)) {\n\t    dist[(*it)-'A'][in[i].at(j)-'A'] = 1;\n\t  }\n\t}\n      }\n    }\n\n    //±±Ég|WJ\\[gð­\n    //dist[i][j] Í iÌãÉjªæÁÄ¢éÆ¢¤ÖWð\\·\n    memset(visited, 0, sizeof(visited));\n    for(i=0; i<26; ++i) {\n      if(!visit(i)) {\n\tcout<<\"SUSPICOUS\"<<endl;\n\tgoto NEXT;\n      }\n    }\n    cout<<\"SAFE\"<<endl;\n\n  NEXT:\n    ;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\n#define pb push_back\n#define FOR(i, a, b) for (ll i = (signed)(a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define EREP(i, n) for (int i = (n)-1; i >= 0; --i)\n#define MOD 1000000007\n#define INF 93193111451418101\n#define MIN -93193111451418101\n#define EPS 1e-11\nusing namespace std;\n\nchar grid[51][51];\nll n, h, w;\n\nbool check(vector<ll> &v, ll lx[50], ll ly[50], ll rx[50], ll ry[50], ll c) {\n  ll itr = 0;\n  REP(i, (signed)v.size()) itr = (v[i] == c ? i : itr);\n  FOR(i, ly[c], ry[c] + 1) {\n    FOR(j, lx[c], rx[c] + 1) {\n      if (grid[i][j] == '.')\n        return 0;\n      if (grid[i][j] != c + 'A') {\n        REP(i, (signed)v.size()) {\n          if (v[i] + 'A' == grid[i][j] && i > itr)\n            return 0;\n        }\n      }\n    }\n  }\n  return 1;\n}\n\nint main() {\n  cin >> n;\n  string str = \"\";\n  REP(loop, n) {\n    ll lx[50] = {}, ly[50] = {}, rx[50] = {}, ry[50] = {};\n    REP(i, 50) { lx[i] = 100, ly[i] = 100; }\n    vector<ll> v;\n    cin >> h >> w;\n    REP(i, h) {\n      REP(j, w) { cin >> grid[i][j]; }\n    }\n    REP(i, h) REP(j, w) {\n      const char c = grid[i][j];\n      const ll cl = grid[i][j] - 'A';\n      if (c == '.')\n        continue;\n      v.pb(cl);\n      lx[cl] = min(lx[cl], j);\n      ly[cl] = min(ly[cl], i);\n      ry[cl] = max(ry[cl], i);\n      rx[cl] = max(rx[cl], j);\n    }\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    bool ff = 0;\n    do {\n      ff = 0;\n      for (auto &a : v) {\n        if (check(v, lx, ly, rx, ry, a) == 0) {\n          ff = 1;\n          break;\n        }\n      }\n      if (!ff) {\n        str += \"SAFE\\n\";\n        break;\n      }\n    } while (next_permutation(v.begin(), v.end()));\n    if (ff)\n      str += \"SUSPICIOUS\\n\";\n  }\n  cout << str << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#define INF (1e9)\n#define H 50\n#define A 26\nusing namespace std;\nint n,h,w,x1[A],x2[A],y1[A],y2[A];\nstring s[H];\nbool used[H][H],e[A],ans;\nvector<int> v;\n\nvoid solve(){\n  do{\n    bool f=true;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) used[i][j]=false;\n    for(int i=0;i<v.size();i++){\n      int l=v[i];\n      for(int j=y1[l];j<=y2[l];j++)\n\tfor(int k=x1[l];k<=x2[l];k++){\n\t  if(!used[j][k]&&s[j][k]-'A'!=l) f=false;\n\t  used[j][k]=true;\n\t}\n    }\n    if(f) ans=true;\n  }while(next_permutation(v.begin(),v.end()));\n}\n\nint main(){\n  cin>>n;\n  while(n--){\n    cin>>h>>w;\n    for(int i=0;i<A;i++) x1[i]=INF,x2[i]=-1,y1[i]=INF,y2[i]=-1,e[i]=false;\n    for(int i=0;i<h;i++) cin>>s[i];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tchar c=s[i][j];\n\tif(c!='.'){\n\t  int idx=c-'A';\n\t  e[idx]=true;\n\t  x1[idx]=min(x1[idx],j);\n\t  x2[idx]=max(x2[idx],j);\n\t  y1[idx]=min(y1[idx],i);\n\t  y2[idx]=max(y2[idx],i);\n\t}\n      }\n    for(int i=0;i<A;i++)\n      if(e[i]) v.push_back(i);\n    ans=false;\n    solve();\n    if(ans) cout<<\"SAFE\"<<endl;\n    else cout<<\"SUSPICIOUS\"<<endl;\n    v.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int XMAX = 50;\nconst int YMAX = 50;\n\n#define NONE '.'\n#define SOME '#'\n\nchar box[YMAX][XMAX];\n\nstruct rect{\n    int l, u, r, d;\n};\n\nvoid print_rects(vector<rect>& rects){\n    for(auto r:rects){\n        LOG(\"%d %d %d %d\\n\", r.l, r.u, r.r,r.d);\n        FOR(y, r.u, r.d + 1){\n            FOR(x, r.l, r.r + 1) {\n                LOG(\"%c\", box[y][x]);\n            }\n            LOG(\"\\n\");\n        }\n    }\n}\n\nbool check_rects(vector<rect>& rects){\n    for(auto r:rects) {\n        FOR(y, r.u, r.d + 1) {\n            FOR(x, r.l, r.r + 1) {\n                if (box[y][x] == NONE) return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nbool is_top(rect& r, char material){\n    FOR(y, r.u, r.d + 1){\n        FOR(x, r.l, r.r + 1) {\n            if(box[y][x] != material && box[y][x] != SOME) return false;\n        }\n    }\n\n    FOR(y, r.u, r.d + 1){\n        FOR(x, r.l, r.r + 1) {\n            box[y][x] = SOME;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    int n, h ,w;\n    cin >> n;\n    REP(k, n){\n        fill_n((char *)box, YMAX * XMAX, NONE);\n        map<char, int> material;\n        vector<rect> rects;\n\n        cin >> h >> w;\n        REP(y, h) {\n            REP(x, w) {\n                cin >> box[y][x];\n                if(box[y][x] == NONE) continue;\n                if (material.find(box[y][x]) == material.end()) {\n                    material.insert({box[y][x], material.size()});\n                    rects.push_back({XMAX, YMAX, 0, 0});\n                }\n                int idx = material[box[y][x]];\n                rects[idx].l = min(rects[idx].l, x);\n                rects[idx].u = min(rects[idx].u, y);\n                rects[idx].r = max(rects[idx].r, x);\n                rects[idx].d = max(rects[idx].d, y);\n            }\n        }\n\n        if (!check_rects(rects)) {\n            cout << \"SUSPICIOUS\" << endl;\n            continue;\n        }\n\n        bool updated;\n        int n = 0;\n        vb seen(material.size());\n        do{\n            updated = false;\n            for(auto it = material.begin(); it != material.end();++it) {\n                if(!seen[it->second] && is_top(rects[it->second], it->first)){\n                    n++;\n                    seen[it->second] = true;\n                    updated = true;\n                }\n            }\n        }while(updated);\n\n        cout << (n == material.size() ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid chmin(int &a, int b) { a = min(a, b); }\nvoid chmax(int &a, int b) { a = max(a, b); }\n\nint n;\nint h, w;\nstring s[50];\n\nvoid solve() {\n\tint minX[26];\n\tint minY[26];\n\tint maxX[26];\n\tint maxY[26];\n\tstatic int rui[26][51][51];\n\tint i, j, k;\n\t\n\tfor (i = 0; i < 26; i++) {\n\t\tminX[i] = 114;\n\t\tminY[i] = 114;\n\t\tmaxX[i] = -114;\n\t\tmaxY[i] = -114;\n\t}\n\t\n\tfor (i = 0; i < 26; i++) {\n\t\tfor (j = 0; j <= h; j++) {\n\t\t\tfor (k = 0; k <= w; k++) {\n\t\t\t\trui[i][j][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tif ('A' <= s[i][j] && s[i][j] <= 'Z') {\n\t\t\t\tchmin(minX[s[i][j] - 'A'], j);\n\t\t\t\tchmax(maxX[s[i][j] - 'A'], j);\n\t\t\t\tchmin(minY[s[i][j] - 'A'], i);\n\t\t\t\tchmax(maxY[s[i][j] - 'A'], i);\n\t\t\t\trui[s[i][j] - 'A'][i + 1][j + 1]++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < 26; i++) {\n\t\tfor (j = 0; j <= h; j++) {\n\t\t\tfor (k = 1; k <= w; k++) rui[i][j][k] += rui[i][j][k - 1];\n\t\t}\n\t\tfor (j = 0; j <= w; j++) {\n\t\t\tfor (k = 1; k <= h; k++) rui[i][k][j] += rui[i][k - 1][j];\n\t\t}\n\t}\n\t\n\tstring chars;\n\tbool used[26] = {false};\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tif (s[i][j] == '.') continue;\n\t\t\tif (!used[s[i][j] - 'A']) {\n\t\t\t\tchars += s[i][j];\n\t\t\t\tused[s[i][j] - 'A'] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int> perm;\n\tfor (i = 0; i < chars.length(); i++) { perm.push_back(i); }\n\tdo {\n\t\tint z[26] = {0};\t//??????????????????\n\t\tint j;\n\t\tfor (i = 0; i < chars.length(); i++) {\n\t\t\tz[chars[i] - 'A'] = perm[i] + 1;\n\t\t}\n\t\t\n\t\tfor (i = 0; i < chars.length(); i++) {\n\t\t\tint id = chars[i] - 'A';\n\t\t\tint area = (maxY[id] - minY[id] + 1) * (maxX[id] - minX[id] + 1);\n\t\t\tfor (j = 0; j < 26; j++) {\n\t\t\t\tif (z[j] < z[chars[i] - 'A']) continue;\n\t\t\t\tint a = rui[j][maxY[id] + 1][maxX[id] + 1];\n\t\t\t\tint b = rui[j][maxY[id] + 1][minX[id]];\n\t\t\t\tint c = rui[j][minY[id]][maxX[id] + 1];\n\t\t\t\tint d = rui[j][minY[id]][minX[id]];\n\t\t\t\tarea -= a - b - c + d;\n\t\t\t}\n\t\t\tif (area != 0) { break; }\n\t\t}\n\t\t\n\t\tif (i == chars.length()) {\n\t\t\tcout << \"SAFE\" << endl;\n\t\t\treturn;\n\t\t}\n\t} while (next_permutation(perm.begin(), perm.end()));\n\t\n\tcout << \"SUSPICIOUS\" << endl;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> h >> w;\n\t\tfor (int j = 0; j < h; j++) cin >> s[j];\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <complex>\n#include <queue>\n#include <stack>\n#include <string>\n#include <cmath>\n#include <bitset>\n\n#define rep(i,a) for(int i = 0;i < (a); i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\n#define INF 1e10\n#define EPS 1e-10\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nint H, W;\nvector<string> board;\n\n\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl;\nbool solve()\n{\n  cin >> H >> W;\n  board.clear();\n  board.resize(H);\n  for (int i = 0; i < H; ++i)\n    cin >> board[i];\n\n  map<char,int> mx, my, Mx, My;\n  for (int y = 0; y < H; ++y) {\n    for (int x = 0; x < W; ++x) {\n      char c = board[y][x];\n      if (c != '.') {\n\tif (mx.find(c) != mx.end())\n\t  mx[c] = min(mx[c], x);\n\telse\n\t  mx[c] = x;\n\tif (my.find(c) != my.end())\n\t  my[c] = min(my[c], y);\n\telse\n\t  my[c] = y;\n\tMx[c] = max(Mx[c], x);\n\tMy[c] = max(My[c], y);\n      }\n    }\n  }\n\n  while (true) {\n    bool exists = false;\n    repit(it,mx) {\n      char c = it->first;\n\n      //dump(c)dump(mx[c])dump(Mx[c])dump(my[c])dump(My[c])\n\n      for (int y = my[c]; y <= My[c]; ++y)\n\tfor (int x = mx[c]; x <= Mx[c]; ++x)\n\t  if (board[y][x] != c && board[y][x] != '?')\n\t    goto fail;\n      for (int y = my[c]; y <= My[c]; ++y)\n\tfor (int x = mx[c]; x <= Mx[c]; ++x)\n\t  board[y][x] = '?';\n      mx.erase(mx.find(c));\n      my.erase(my.find(c));\n      Mx.erase(Mx.find(c));\n      My.erase(My.find(c));\n      exists = true;\n      goto outer;\n    fail:;\n    }\n\n    //    rep(y,H)cerr<<board[y]<<endl;\n    //    cerr<<endl;\n\n  outer:;\n    if (!exists) break;\n  }\n\n  for (int y = 0; y < H; ++y)\n    for (int x = 0; x < W; ++x)\n      if (board[y][x] != '.' && board[y][x] != '?')\n\treturn false;\n\n  return true;\n}\n\nint main() {\n  int T; cin >> T;\n  while (T --> 0)\n    cout << (solve() ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\", &T);\n\n\twhile (T--){\n\t\tint H, W;\n\t\tchar m[64][64];\n\n\t\tscanf(\"%d %d\", &H, &W);\n\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tscanf(\"%s\", &m[i][1]);\n\t\t}\n\n\t\tfor (int t = 0; t < 7; t++){\n\t\t\tint ct[27][64][64];\n\n\t\t\tmemset(ct, 0, sizeof(ct));\n\n\t\t\tfor (int ch = 26; ch >= 0; ch--){\n\t\t\t\tint top, left, down, right;\n\t\t\t\ttop = left = down = right = -1;\n\t\t\t\tchar alpha = (ch == 26 ? '?' : 'A' + ch);\n\n\t\t\t\tfor (int i = 1; i <= H; i++){\n\t\t\t\t\tfor (int j = 1; j <= W; j++){\n\t\t\t\t\t\tct[ch][i][j] = (alpha == m[i][j]) + ct[ch][i - 1][j] + ct[ch][i][j - 1] - ct[ch][i - 1][j - 1];\n\n\t\t\t\t\t\tif (alpha == m[i][j]){\n\t\t\t\t\t\t\tif (top   == -1 ||   top > i) top = i;\n\t\t\t\t\t\t\tif (left  == -1 ||  left > j) left = j;\n\t\t\t\t\t\t\tif (down  == -1 ||  down < i) down = i;\n\t\t\t\t\t\t\tif (right == -1 || right < j) right = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (top == -1 || ch == 26) continue;\n\t\t\t\tint cnt = ct[ch][down][right] - ct[ch][down][left - 1] - ct[ch][top - 1][right] + ct[ch][top - 1][left - 1]\n\t\t\t\t\t\t+ ct[26][down][right] - ct[26][down][left - 1] - ct[26][top - 1][right] + ct[26][top - 1][left - 1];\n\n\t\t\t\tif (cnt == (down - top + 1) * (right - left + 1)){\n\t\t\t\t\tfor (int i = top; i <= down; i++){\n\t\t\t\t\t\tfor (int j = left; j <= right; j++){\n\t\t\t\t\t\t\tm[i][j] = '?';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmemset(ct[26], 0, sizeof(ct[26]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool safe = true;\n\t\tfor (int i = 1; i <= H; i++){\n\t\t\tfor (int j = 1; j <= W; j++){\n\t\t\t\tsafe &= !isalpha(m[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%s\\n\", safe ? \"SAFE\" : \"SUSPICIOUS\");\n\t}\n\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n#include <map>\n#define rep(i,n) for(int i=0; i<n; ++i)\n\nusing namespace std;\n\nint N, n;\nint H,W;\n\nchar m[50][50];\nbool used[26];\nint U[26],D[26],L[26],R[26];\n\n\nbool check(char ch){\n  int z = ch-'A';\n  for(int i=U[z]; i<D[z]; ++i){\n    for(int j=L[z]; j<R[z]; ++j){\n      if(m[i][j] != '.' && used[z] == false) continue;\n      if(m[i][j]!=ch) return false;\n    }\n  }\n  return true;\n}\nvoid input(){\n  int x;\n  string str;\n  cin >> H >> W;\n  rep(i,H){\n    cin>>str;\n    rep(j,W){\n      m[i][j] = str[j];\n      if(m[i][j]=='.')continue;\n      x=m[i][j]-'A';\n      used[x] = true;\n      U[x]=min(U[x],i);\n      D[x]=max(D[x],i);\n      L[x]=min(L[x],j);\n      R[x]=max(R[x],j);\n    }\n  }\n}\n\nvoid init(){\n  rep(i,26){\n    U[i] = 50;\n    D[i] = 0;\n    L[i] = 50;\n    R[i] = 0;\n    used[i] = false;\n  }\n}\nint main(){\n  cin >> N;\n  while(N--){\n    init();\n    input();\n    while(1){\n      bool flag = false;\n      rep(i,26){\n        if(used[i]==false)continue;\n        if(check(i+'A')==true){\n          used[i] = false;\n          flag = true;\n          break;\n        }\n        \n      }\n      flag = false;\n      rep(i,26) flag |= used[i];\n      cout <<flag ? \"SUSPICIOUS\" : \"SAFE\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stdio.h>\n\nusing namespace std;\n\nvoid solve(){\n\n\tstring strs[] = { \"SAFE\", \"SUSPICIOUS\" };\n\n\tint h, w;\n\tcin >> h >> w;\n\n\tvector< string > screen( h );\n\tvector< int > maxx( 26, 0 );\n\tvector< int > maxy( 26, 0 );\n\tvector< int > minx( 26, w );\n\tvector< int > miny( 26, h );\n\n\tfor( int i = 0; i < h; i++ )\n\t\tcin >> screen[ i ];\n\t\n\tbool fig = true;\n\n\tfor( int x = 0; x < w; x++ ) {\n\t\tfor( int y = 0; y < h; y++ ) {\n\t\t\tif( screen[y][x] != '.' ) {\n\t\t\t\tint i = screen[y][x] - 'A';\n\t\t\t\tmaxx[i] = max( maxx[i], x );\n\t\t\t\tminx[i] = min( minx[i], x );\n\t\t\t\tmaxy[i] = max( maxy[i], y );\n\t\t\t\tminy[i] = min( miny[i], y );\n\t\t\t}\n\t\t}\n\t}\n\n\n\twhile( fig ) {\n\n\t\tfig = false;\n\n\t\tfor( int x = 0; x < w; x++ ) {\n\t\t\tfor( int y = 0; y < h; y++ ) {\n\n\t\t\t\t\tchar ch = screen[ y ][ x ];\n\t\t\t\t\tif( ch == '.' || ch == '*' ) continue;\n\t\t\t\t\tint i = ch - 'A';\n\n\t\t\t\t\tbool fflg = true;\n\t\t\t\t\tfor( int tx = minx[i]; tx <= maxx[i] && fflg; tx ++ )\n\t\t\t\t\t\tfor( int ty = miny[i]; ty <= maxy[i] && fflg; ty ++ )\n\t\t\t\t\t\t\tfflg &= ( screen[ ty ][ tx ] == ch || screen[ ty ][ tx ] == '*' );\n\t\t\t\t\t\n\t\t\t\t\tfig |= fflg;\n\t\t\t\t\tif( !fflg ) continue;\n\n\t\t\t\t\tfor( int tx = minx[i]; tx <= maxx[i]; tx ++ )\n\t\t\t\t\t\tfor( int ty = miny[i]; ty <= maxy[i]; ty ++ ) \n\t\t\t\t\t\t\tscreen[ ty ][ tx ] = '*';\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\n\tbool b = false;\n\tfor( int x = 0; x < w; x++ )\n\t\tfor( int y = 0; y < h; y++ )\n\t\t\tb |= ( screen[ y ][ x ] != '.' && screen[ y ][ x ] != '*' );\n\tcout << strs[ b ] << endl;\n}\n\nint main( void ) {\n\tint n;\n\tcin >> n;\n\tfor( int i = 0; i < n; i++ )\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nint h, w;\nbool ans;\n\nvoid debug(vector<string> s){\n\tcout << \"[debug]\" << endl;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tcout << s[y] << endl;\n\t}\n\tcout << endl;\n}\n\n// ツ債カツ湘」ツづ?右ツ可コツづ個催?標ツづーツ陛板つキ\npair<P,P> get_size(const vector<string>& s, char c){\n\tint max_x=0, max_y=0, min_x=1e+8, min_y=1e+8;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( s[y][x] == c ){\n\t\t\t\tmax_x = max( max_x , x );\n\t\t\t\tmax_y = max( max_y , y );\n\t\t\t\tmin_x = min( min_x , x );\n\t\t\t\tmin_y = min( min_y , y );\n\t\t\t}\n\t\t}\n\t}\n\treturn pair<P,P>( P(min_x,min_y) , P(max_x,max_y) );\n}\n\n// ツ陳キツ陛サツ形ツつゥツ陳イツづ猟づゥ\nbool is_rect(const vector<string>& s, char c){\n\tpair<P,P> pp = get_size( s , c );\n\t\n\tint min_x = pp.first.first;\n\tint min_y = pp.first.second;\n\tint max_x = pp.second.first;\n\tint max_y = pp.second.second;\n\t//cout << \"char c : \" << c << \" (\" << min_x << \",\" << min_y << \") , (\" << max_x << \",\" << max_y << \")\" << endl;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( min_x <= x && min_y <= y && x <= max_x && y <= max_y ){\n\t\t\t\tif( s[y][x] == c || s[y][x] == '*' ){\n\t\t\t\t}else{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif( s[y][x] == c ) return false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\n// ツ嘉猟閉ィツづーツ偲ヲツづィツ渉慊つュ\nvector<string> remove(vector<string> s, char c){\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( s[y][x] == c ){\n\t\t\t\ts[y][x] = '*';\n\t\t\t}\n\t\t}\n\t}\n\treturn s;\n}\n\n// memo[i] : iツ氾板姪堋づ個嘉猟閉ィツづーツ陳イツづ猟つスツつゥツづ?つ、ツつゥ, vc[i] : iツ氾板姪堋づ個嘉猟閉ィツづーツ表ツつキツ閉カツ篠?\n// s : w*hツづ個湘ウツ妥? cnt : ツ偲ヲツづィツ渉慊つ「ツつスツ嘉猟閉ィツづ個青?\nvoid solve(vector<bool> memo, vector<char> vc, vector<string> s, int cnt){\n\tif( ans ) return;\n\tif( cnt == vc.size() ){\n\t\tans = true;\n\t\treturn;\n\t}\n\t\n\tfor(int i=0 ; i < vc.size() ; i++ ){\n\t\tif( memo[i] ) continue;\n\t\t//debug( s );\n\t\tchar c = vc[i];\n\t\tif( is_rect( s , c ) ){\n\t\t\tmemo[i] = true;\n\t\t\ts = remove( s , c );\n\t\t\t//debug( s );\n\t\t\tsolve( memo , vc , s , cnt+1 );\n\t\t\tmemo[i] = false;\n\t\t}\n\t}\n}\n\nint main(){\n\tint T;\n\tcin >> T;\n\tfor(int i = 0 ; i < T ; i++ ){\n\t\tcin >> h >> w;\n\t\tvector<string> s;\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tstring s_;\n\t\t\tcin >> s_;\n\t\t\ts.push_back( s_ );\n\t\t}\n\n\t\tint f[256] = {0};\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tchar c = s[y][x];\n\t\t\t\tif( c >= 'A' && c <= 'Z' ){\n\t\t\t\t\tf[c] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<char> vc;\n\t\tfor(char c='A' ; c <= 'Z' ; c++ ){\n\t\t\tif( f[c] ){\n\t\t\t\tvc.push_back( c );\n\t\t\t}\n\t\t}\n\n\t\t//debug( s );\n\t\tif( vc.size() == 0 ){\n\t\t\tcout << \"SAFE\" << endl;\n\t\t}else{\n\t\t\tans = false;\n\t\t\tvector<bool> memo( (int)vc.size() , false );\n\t\t\tsolve( memo , vc , s , 0 );\n\t\t\tif( ans ){\n\t\t\t\tcout << \"SAFE\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\nint h,w;\nint top[7];\nint under[7];\nint lf[7];\nint rg[7];\n\nbool dfs(const vector<int> &a, const vector<string> &b)\n{\n    bool ret=false;\n    int A=a.size();\n\n    int ct=0;\n    rep(i,A) ct+=a[i];\n    if(ct==A) return true;\n\n    //i??????????????????????????§???????????????????????¨??????\n    rep(i,A)\n    {\n        //??¢????????£???\n        if(a[i]==1) continue;\n\n        bool ok=true;\n        char focus='0'+i;\n        for(int y=top[i]; y<=under[i]; ++y)\n        {\n            for(int x=lf[i]; x<=rg[i]; ++x)\n            {\n                if(b[y][x]!=focus && b[y][x]!='S')\n                {\n                    ok=false;\n                    break;\n                }\n            }\n            if(!ok) break;\n        }\n\n        if(ok)\n        {\n            vector<int> na(a);\n            vector<string> nb(b);\n            na[i]=1;\n\n            for(int y=top[i]; y<=under[i]; ++y)\n            for(int x=lf[i]; x<=rg[i]; ++x)\n            {\n                if(nb[y][x]==focus) nb[y][x]='S';\n            }\n\n            ret|=dfs(na,nb);\n        }\n    }\n\n    return ret;\n}\n\nint main()\n{\n    int n;\n    cin >>n;\n    rep(T,n)\n    {\n        cin >>h >>w;\n\n        vector<string> f(h);\n        rep(i,h) cin >>f[i];\n\n        int im[26];\n        fill(im,im+26,-1);\n\n        int ct=0;\n        rep(i,h)rep(j,w)\n        {\n            if(f[i][j]!='.')\n            {\n                int idx=f[i][j]-'A';\n                if(im[idx]==-1) im[idx]=ct++;\n            }\n        }\n\n        rep(i,h)rep(j,w)\n        {\n            if(f[i][j]!='.') f[i][j]=im[f[i][j]-'A']+'0';\n        }\n\n        fill(top,top+7,h);\n        fill(under,under+7,0);\n        fill(lf,lf+7,w);\n        fill(rg,rg+7,0);\n        rep(i,h)rep(j,w)\n        {\n            if(f[i][j]!='.')\n            {\n                int idx=f[i][j]-'0';\n\n                top[idx]=min(top[idx],i);\n                under[idx]=max(under[idx],i);\n                lf[idx]=min(lf[idx],j);\n                rg[idx]=max(rg[idx],j);\n            }\n        }\n\n        vector<int> use(ct,0);\n        bool valid=dfs(use,f);\n\n        string ans=\"SUSPICIOUS\";\n        if(valid) ans=\"SAFE\";\n        std::cout << ans << std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n#include <map>\n#define rep(i,n) for(int i=0; i<n; ++i)\n\nusing namespace std;\n\nint N, n;\nint H,W;\n\nchar m[50][50];\nbool used[26];\nint U[26],D[26],L[26],R[26];\n\n\nbool check(char ch){\n  int z = ch-'A';\n  for(int i=U[z]; i<=D[z]; ++i){\n    for(int j=L[z]; j<=R[z]; ++j){\n      if(m[i][j] != '.' && used[m[i][j]-'A'] == false) continue;\n      if(m[i][j]!=ch) return false;\n    }\n  }\n  return true;\n}\nvoid input(){\n  int x;\n  string str;\n  cin >> H >> W;\n  rep(i,H){\n    cin>>str;\n    rep(j,W){\n      m[i][j] = str[j];\n      if(m[i][j]=='.')continue;\n      x=m[i][j]-'A';\n      used[x] = true;\n      U[x]=min(U[x],i);\n      D[x]=max(D[x],i);\n      L[x]=min(L[x],j);\n      R[x]=max(R[x],j);\n    }\n  }\n}\n\nvoid init(){\n  rep(i,26){\n    U[i] = 50;\n    D[i] = 0;\n    L[i] = 50;\n    R[i] = 0;\n    used[i] = false;\n  }\n}\nint main(){\n  cin >> N;\n  while(N--){\n    init();\n    input();\n    while(1){\n      bool flag = false;\n      rep(i,26){\n        if(used[i]==false)continue;\n        if(check(i+'A')==true){\n          used[i] = false;\n          flag = true;\n          break;\n        }\n      }\n      if(flag == false) break;\n    }\n      bool flag = false;\n      rep(i,26) flag |= used[i];\n      cout << (flag ? \"SUSPICIOUS\" : \"SAFE\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n#define enld '\\n'\n#define rep(i,n) for(int i=0; i<(n); i++)\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"Ofast\")\nconstexpr ll INF = 1e18;\nconstexpr int inf = 1e9;\nconstexpr ll mod = 1000000007;\nconstexpr ll mod2 = 998244353;\nconst double PI = 3.1415926535897932384626433832795028841971;\nconst int dx[6] = {1, 0, -1, 0,1,1};\nconst int dy[6] = {0, 1, 0, -1,1,-1};\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n// ---------------------------------------------------------------------------\n\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int _;\n    cin >> _;\n    while(_--){\n        int H,W;\n        cin >> H >> W;\n        vector<string> G(H);\n        for(int i=0; i<H; i++){\n            cin >> G[i];\n        }\n        set<char> se;\n        for(int i=0; i<H; i++){\n            for(int j=0; j<W; j++){\n                if(isupper(G[i][j])){\n                    se.insert(G[i][j]);\n                }\n            }\n        }\n        vector<set<int>> suzu(se.size());\n        int now = 0;\n        vector<int> vec;\n        for(char c: se){\n            for(int i=0; i<H; i++){\n                for(int j=0; j<W; j++){\n                    if(G[i][j] == c){\n                        G[i][j] = now + '0';\n                    }\n                }\n            }\n            vec.push_back(now);\n            now++;\n        }\n        bool ok = true;\n        for(int k=0; k<suzu.size(); k++){\n            int n=inf,e=0,w=inf,s=0;\n            for(int i=0; i<H; i++){\n                for(int j=0; j<W; j++){\n                    if(G[i][j] == k+'0'){\n                        chmax(s,i);\n                        chmax(e,j);\n                        chmin(n,i);\n                        chmin(w,j);\n                    }\n                }\n            }\n            for(int i=n; i<=s; i++){\n                for(int j=w; j<=e; j++){\n                    if(G[i][j] == '.'){\n                        ok = false;\n                    }else if(G[i][j] != k+'0'){\n                        suzu[k].insert(G[i][j] - '0');\n                    }\n                }\n            }\n        }\n        // for(int i=0; i<suzu.size(); i++){\n        //     for(auto x: suzu[i]){\n        //         cout << x << \" \";\n        //     }\n        //     cout << enld;\n        // }\n        for(int i=0; i<suzu.size(); i++){\n            queue<int> que;\n            for(int v: suzu[i]){\n                que.push(v);\n            }\n            while(que.size()){\n                int v = que.front();\n                que.pop();\n                for(int nv:suzu[v]){\n                    if(suzu[i].count(nv)) continue;\n                    suzu[i].insert(nv);\n                    que.push(nv);\n                }\n            }\n        }\n        bool can = true;\n        for(int i=0; i<suzu.size(); i++){\n            if(suzu[i].count(i)){\n                can = false;\n                break;\n            }\n        }\n        if(ok and can){\n            cout << \"SAFE\" << enld;\n        }else{\n            cout << \"SUSPICIOUS\" << enld;\n        }\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<queue>\nusing namespace std;\n\nint main(){\n  int n,h,w;\n  string pict[50];\n  int rr,rd,lu,ll;\n  bool flag;\n  set<int> child[26];\n\n  cin >> n;\n  while(n){\n    n--;\n    cin >> h >> w;\n    for(int i=0;i<h;i++)cin >> pict[i];\n    for(int i=0;i<26;i++)child[i].clear();\n\n    flag = true;\n    for(int i='A';i<='Z';i++){\n      rr = 0;\n      rd = 0;\n      lu = h;\n      ll = w;\n      for(int j=0;j<h;j++){\n\tfor(int k=0;k<w;k++){\n\t  if(pict[j][k] == i){\n\t    rr = max(rr,k);\n\t    rd = max(rd,j);\n\t    lu = min(lu,j);\n\t    ll = min(ll,k);\n\t  }\n\t}\n      }\n\n      for(int j=lu;j<=rd;j++){\n\tfor(int k=ll;k<=rr;k++){\n\t  if(pict[j][k] == '.'){\n\t    flag = false;\n\t    break;\n\t  }else if(pict[j][k] != i){\n\t    child[pict[j][k] - 'A'].insert(i-'A');\n\n\t    bool f = false;\n\n\t    queue<int> par;\n\t    par.push(i - 'A');\n\t    while(!par.empty()){\n\t      int now = par.front();\n\t      par.pop();\n\t      if(now == pict[j][k] - 'A'){\n\t\tf = true;\n\t\tbreak;\n\t      }\n\n\t      set<int>::iterator ite;\n\t      for(ite = child[now].begin();ite!=child[now].end();ite++){\n\t\tpar.push(*ite);\n\t      }\n\t    }\n\t    if(f){\n\t      flag = false;\n\t      break;\n\t    }\n\t  }\n\t}\n\tif(!flag)break;\n      }\n      if(!flag)break;\n    }\n    if(!flag)cout << \"SUSPICOUS\" << endl;\n    else cout << \"SAFE\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nbool u[256][256];\nint used[256],kai;\n\nbool dfs(int x){\n  if(used[x]){\n    if(used[x]==kai)return 0;\n    else return 1;\n  }\n  used[x]=kai;\n  bool res=1;\n  for(int i='A';i<='Z';i++)if(u[x][i])res&=dfs(i);\n  return res;\n}\n\nint main(){\n  int T;\n  cin>>T;\n  while(T--){\n    int h,w;\n    cin>>h>>w;\n    char c[50][50],d;\n    int x1[256],x2[256],y1[256],y2[256];\n    for(int i='A';i<='Z';i++){\n      x1[i]=y1[i]=1e9;\n      x2[i]=y2[i]=-1;\n    }\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tcin>>d;\n\tc[i][j]=d;\n\tx1[d]=min(x1[d],j);\n\ty1[d]=min(y1[d],i);\n\tx2[d]=max(x2[d],j);\n\ty2[d]=max(y2[d],i);\n      }\n    \n    bool ans=1;\n    memset(u,0,sizeof(u));\n    memset(used,0,sizeof(used));\n    for(int i='A';i<='Z';i++)\n      for(int y=y1[i];y<=y2[i];y++)\n\tfor(int x=x1[i];x<=x2[i];x++){\n\t  if(c[y][x]=='.')ans=0;\n\t  else if(c[y][x]!=i){\n\t    if(u[c[y][x]][i])ans=0;\n\t    else u[i][c[y][x]]=1;\n\t  }\n\t}\n    \n    kai=1;\n    for(int i='A';i<='Z';i++)if(!used[i])ans&=dfs(i),kai++;  \n    \n    cout<<(ans?\"SAFE\":\"SUSPICIOUS\")<<endl;  \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\n\nint main(int argc, char *argv[]){\n  int n, w, h;\n  pair<int, int> p[7][4];\n  cin >> n;\n  for (int r = 0; r < n; r++) {\n    map<char, int> matrial;\n    cin >> h >> w;\n\n    char grid[h][w];\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> grid[i][j];\n        if(grid[i][j] != '.' && matrial.find(grid[i][j]) == matrial.end()){\n          matrial[grid[i][j]] = matrial.size();\n        }\n      }\n    }\n\n    for (int i = 0; i < matrial.size(); i++) {\n      p[i][0].first = 1e9, p[i][0].second = 1e9;\n      p[i][1].first = 0,   p[i][1].second = 0;\n    }\n    vector<int> perm(matrial.size());\n    for (int i = 0; i < matrial.size(); i++) {\n      perm[i] = i;\n    }\n\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if(matrial.find(grid[i][j]) != matrial.end()){\n          int minx = p[matrial[grid[i][j]]][0].first;\n          int miny = p[matrial[grid[i][j]]][0].second;\n          int maxx = p[matrial[grid[i][j]]][1].first;\n          int maxy = p[matrial[grid[i][j]]][1].second;\n          p[matrial[grid[i][j]]][0].first  = min(minx, j);\n          p[matrial[grid[i][j]]][0].second = min(miny, i);\n          p[matrial[grid[i][j]]][1].first  = max(maxx, j);\n          p[matrial[grid[i][j]]][1].second = max(maxy, i);\n        }\n      }\n    }\n    // for (auto &a: matrial){\n    //   std::cout << a.first << \" \" << a.second << std::endl;\n    // }\n    // for (int i = 0; i < matrial.size(); i++) {\n    //   std::cout << \"min:\" << std::endl;\n    //   std::cout << p[i][0].first << \" \" << p[i][0].second << std::endl;\n    //   std::cout << \"max:\" << std::endl;\n    //   std::cout << p[i][1].first << \" \" << p[i][1].second << std::endl;\n    // }\n    // std::cout << matrial.size() << std::endl;\n    \n     bool flag = false;\n    do{\n      for (int i = 0; i < matrial.size(); i++) {\n        for (int j = p[i][0].second; j <= p[i][1].second; j++) {\n          for (int k = p[i][0].first; k <= p[i][1].first; k++) {\n            if(grid[j][k] != '.' && perm[matrial[grid[j][k]]] <= perm[i])continue;\n            i = 10;\n            j = p[i][1].second + 1;\n            k = p[i][1].first  + 1;\n          }\n        }\n        if(i == matrial.size() - 1){\n          flag = true;\n        //   for (auto &a: perm) {\n        //     std::cout << a << \" \";\n        //   }\n        //   std::cout << std::endl;\n        // } \n      }\n    }while(next_permutation(perm.begin(), perm.end()));\n    if(flag || matrial.size() == 0){\n      std::cout << \"SAFE\" << std::endl;\n    }else{\n      std::cout << \"SUSPICIOUS\" << std::endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\nclass Object{\npublic:\n  Object(char col){ miny = minx = INF; maxy = maxx = -1; on.clear(); c = col; }\n  int miny, minx, maxy, maxx;\n  set<int> on;\n  char c;\n};\n\nint h, w;\nvector<Object> objects;\nset<int> used;\nchar input[50][50];\nbool visited[50][50];\nint index[50][50];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nbool dfs1(int y, int x, int n){\n  Object &obj = objects[n];\n  visited[y][x] = true;\n  index[y][x] = n;\n  if(obj.miny > y) obj.miny = y;\n  if(obj.minx > x) obj.minx = x;\n  if(obj.maxy < y) obj.maxy = y;\n  if(obj.maxx < x) obj.maxx = x;\n  for(int i=0;i<4;i++){\n    int ty = y + dy[i];\n    int tx = x + dx[i];\n    if(ty<0 || ty>=h) continue;\n    if(tx<0 || tx>=w) continue;\n    if(visited[ty][tx]) continue;\n    if(input[ty][tx] != input[y][x]) continue;\n    dfs1(ty, tx, n);\n  }\n  return true;\n}\n\nbool dfs2(int n){\n  set<int>::iterator ite = objects[n].on.begin();\n  for(;ite != objects[n].on.end();ite++){\n    if(used.find(*ite) != used.end()) return false;\n    used.insert(*ite);\n    if(!dfs2(*ite)) return false;\n    used.erase(used.find(*ite));\n  }\n  return true;\n}\n\nmain(){\n  int t;\n  //cin >> t;\n  while(cin >> t){\n  while(t--){\n    cin >> h >> w;\n    objects.clear();\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> input[i][j];\n      }\n    }\n\n\n    fill(index[0], index[50], -1);\n    fill(visited[0], visited[50], false);    \n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(input[i][j] != '.' && !visited[i][j]){\n\t  objects.push_back(Object(input[i][j]));\n\t  dfs1(i, j, (int)objects.size()-1);\n\t}\n      }\n    }\n\n    bool ans = true;\n\n    for(int i=0;i<objects.size();i++){\n      for(int j=objects[i].miny;j<=objects[i].maxy;j++){\n\tfor(int k=objects[i].minx;k<=objects[i].maxx;k++){\n\t  if(input[j][k] != '.' && input[j][k] != objects[i].c){\n\t    objects[i].on.insert(index[j][k]);\n\t  }else if(input[j][k] == '.'){\n\t    ans = false;\n\t    break;\n\t  }\n\t}\n\tif(!ans) break;\n      }\n      if(!ans) break;\n    }\n\n    for(int i=0;i<objects.size();i++){\n      used.clear();\n      used.insert(i);\n      if(!dfs2(i)){\n\tans = false;\n\tbreak;\n      }\n    }\n    if(ans){\n      cout << \"SAFE\" << endl;\n    }else{\n      cout << \"SUSPICIOUS\" << endl;\n    }\n  }}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <set>\n#include <iomanip>\n#include <stack>\n#include <fstream>\n#include <cstdint>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <functional>\n\nusing namespace std;\n\n\ntypedef int64_t ll;\n\n\nclass rect{\n    static const int inf = 100000;\npublic:\n    int sx, sy; // 始点 左上\n    int ex, ey; // 終点 右下\n    rect() :sx(inf), sy(inf), ex(), ey() {}\n    \n    void modify(const int& i, const int& j){\n        sx = min(i, sx);\n        sy = min(j, sy);\n        \n        ex = max(i, ex);\n        ey = max(j, ey);\n    }\n};\n\nbool is_real_over(char T, map<char, set<char>>& overs, set<char> pre){\n    for (auto && top : overs[T]) {\n        if(pre.count(top) > 0) {\n//            cerr << \"CROSS ERROrR\\n\";\n            return false;\n        }\n        pre.insert(top);\n        if(!is_real_over(top, overs, pre))  return false;\n    }\n    return true;\n\n}\n\n\nbool solve(){\n    int h, w;\n    cin >> h >> w;\n    vector<vector<char>> v;\n    map<char, rect> shapes;\n    for (int i = 0; i < h; ++i) {\n        v.push_back({});\n        for (int j = 0; j < w; ++j) {\n            char tmp;\n            cin >> tmp;\n            v[i].push_back(tmp);\n\n            if(tmp != '.')\n                shapes[tmp].modify(i, j);\n        }\n    }\n\n\n    // 矩形調査 yz\n    map<char, set<char>> overs;\n    for(auto && rec_pair: shapes){\n        auto && rec = rec_pair.second;\n        auto && rec_name = rec_pair.first;\n//        cerr << \"NAME:\" << rec_name << '\\n';\n        for (int i = rec.sx; i <= rec.ex; ++i) {\n            for (int j = rec.sy; j <= rec.ey; ++j) {\n                auto&& this_char = v[i][j];\n                if(this_char != rec_name){\n                    if(this_char == '.'){\n//                        cerr << \"SHAPE MISS\\n\";\n                        return false;\n                    }\n                    overs[this_char].insert(rec_name);\n                }\n            }\n        }\n    }\n//    cerr << \"OVERS::\\n\";\n//    for(auto && m : overs){\n//        cerr << m.first << ':';\n//        for(auto && t : m.second){\n//            cerr << ' ' << t;\n//        }\n//        cerr << '\\n';\n//    }\n\n    // 重なり調査\n    for(auto&& op: overs){\n        if(!is_real_over(op.first, overs, {op.first}))\n            return false;\n    }\n\n\n    return true;\n    \n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        cout << (!solve() ? \"SUSPICIOUS\" : \"SAFE\") << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX = 50;\n\nstruct Part {\n\tchar mozi;\n\tint right, left, up, down;\n\tint height, width;\n};\n\nint kaijou(unsigned int num)\n{\n\tint ret = 1;\n\n\tfor (unsigned int i = num; i > 1; i--) {\n\t\tret *= i;\n\t}\n\n\treturn ret;\n}\n\nstring solve()\n{\n\tint H, W;\n\tchar grid[MAX][MAX];\n\tbool flag = false;\n\tvector<Part> parts;\n\n\tcin >> H >> W;\n\t\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> grid[i][j];\n\t\t}\n\t}\n\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (grid[i][j] != '.') {\n\t\t\t\tbool f = true;\n\t\t\t\tfor (unsigned int k = 0; k < parts.size(); k++) {\n\t\t\t\t\tif (grid[i][j] == parts[k].mozi) {\n\t\t\t\t\t\tparts[k].up = min(i, parts[k].up);\n\t\t\t\t\t\tparts[k].down = max(i, parts[k].down);\n\t\t\t\t\t\tparts[k].left = min(j, parts[k].left);\n\t\t\t\t\t\tparts[k].right = max(j, parts[k].right);\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (f == true) {\n\t\t\t\t\tPart part;\n\t\t\t\t\tpart.mozi = grid[i][j];\n\t\t\t\t\tpart.up = i;\n\t\t\t\t\tpart.down = i;\n\t\t\t\t\tpart.right = j;\n\t\t\t\t\tpart.left = j;\n\t\t\t\t\tparts.push_back(part);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (parts.empty() == true) {\n\t\treturn \"SAFE\";\n\t}\n\telse {\n\t\tfor (unsigned int i = 0; i < parts.size(); i++) {\n\t\t\tparts[i].height = parts[i].right - parts[i].left + 1;\n\t\t\tparts[i].width = parts[i].down - parts[i].up + 1;\n\t\t}\n\t}\n\n\tvector<vector<int>> permutation(kaijou(parts.size()));\n\tvector<int> p;\n\tfor (int i = 0; i < parts.size(); i++) {\n\t\tp.push_back(i);\n\t}\n\n\tint cur = 0;\n\tdo {\n\t\tpermutation[cur] = p;\n\t\tcur++;\n\t} while (next_permutation(p.begin(), p.end()));\n\n\tfor (int i = 0; i < kaijou(parts.size()); i++) {\n\t\tvector<vector<char>> temp(H, vector<char>(W, '.'));\n\t\tfor (int j = 0; j < parts.size(); j++) {\n\t\t\tfor (int y = parts[permutation[i][j]].up; y <= parts[permutation[i][j]].down; y++) {\n\t\t\t\tfor (int x = parts[permutation[i][j]].left; x <= parts[permutation[i][j]].right; x++) {\n\t\t\t\t\ttemp[y][x] = parts[permutation[i][j]].mozi;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tbool f = true;\n\t\tfor (int k = 0; k < H; k++) {\n\t\t\tfor (int l = 0; l < W; l++) {\n\t\t\t\tif (grid[k][l] != temp[k][l]) {\n\t\t\t\t\tf = false;\n\t\t\t\t\tgoto Label;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tLabel:\n\t\tif (f == true) {\n\t\t\treturn \"SAFE\";\n\t\t}\n\t}\n\n\treturn \"SUSPICIOUS\";\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << solve() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\nint mat[7][7];\nbool visited[7];\n\nbool find_cycle(int idx) {\n\tvisited[idx] = true;\n\tfor(int i = 0; i < 7; ++i)\n\t\tif(mat[idx][i] && (visited[i] || find_cycle(i)))\n\t\t\treturn true;\n\n\tvisited[idx] = false;\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\twhile(n--) {\n\t\tint h, w;\n\t\tcin >> h >> w;\n\n\t\tvector<string> field(h);\n\t\tmap<char, int> convert;\n\t\tfor(int i = 0; i < h; ++i)\n\t\t\tcin >> field[i];\n\n\t\tvector<int> mx_x(7, -1), mx_y(7, -1), mn_x(7, w), mn_y(7, h);\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tif(field[i][j] == '.')\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif(!convert.count(field[i][j]))\n\t\t\t\t\tconvert.insert(make_pair(field[i][j], convert.size()));\n\n\t\t\t\tconst int idx = convert[field[i][j]];\n\t\t\t\tchmax(mx_x[idx], j);\n\t\t\t\tchmax(mx_y[idx], i);\n\t\t\t\tchmin(mn_x[idx], j);\n\t\t\t\tchmin(mn_y[idx], i);\n\t\t\t}\n\t\t}\n\n\t\tconst int num = (int)convert.size();\n\n\t\tmemset(mat, false, sizeof(mat));\n\t\tFOR(it, convert) {\n\t\t\tconst char target = it->first;\n\t\t\tconst int idx = it->second;\n\t\t\tcout << target << \": \" << idx << endl;\n\t\t\tfor(int i = mn_y[idx]; i <= mx_y[idx]; ++i) {\n\t\t\t\tfor(int j = mn_x[idx]; j <= mx_x[idx]; ++j) {\n\t\t\t\t\tif(field[i][j] == '.')\n\t\t\t\t\t\tgoto ng;\n\n\t\t\t\t\tif(field[i][j] != target)\n\t\t\t\t\t\tmat[convert[field[i][j]]][idx] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tfor(int i = 0; i < num; ++i)\n\t\t\tfor(int j = 0; j < num; ++j)\n\t\t\t\tcout << mat[i][j] << (j + 1 == num ? \"\\n\" : \" \");\n\n\t\tmemset(visited, false, sizeof(visited));\n\t\tfor(int i = 0; i < num; ++i)\n\t\t\tif(find_cycle(i))\n\t\t\t\tgoto ng;\n\n\t\tcout << \"SAFE\" << endl;\n\t\tcontinue;\n\n\tng:;\n\t\tcout << \"SUSPICIOUS\" << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n\ntypedef long long ll;\n\n\nint cnt[30][55][55];\nint val[30];\n\nint getcnt(int a,int b,int c,int d,int e){\n\tint ret = cnt[e][c][d];\n\tif(c) ret-=cnt[e][c-1][b];\n\tif(d) ret-=cnt[e][a][d-1];\n\tif(c&&d) ret+=cnt[e][c-1][d-1];\n\treturn ret;\n}\n\n\nint main(){\n\tint n;\n\tcin>>n;\n\trep(o,n){\n\t\tint h,w;\n\t\tcin>>h>>w;\n\t\tvector<string> v(h);\n\t\trep(i,h) cin>>v[i];\n\t\tbool update = true;\n\t\tbool ok=true;\n\t\tbool ch[30];\n\t\twhile(update){\n\t\t\tok=true;\n\t\t\tupdate=false;\n\t\t\trep(i,h) rep(j,w) if(v[i][j]!='.'&&v[i][j]!='-') ok=false;\n\t\t\tif(ok){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i,30) rep(j,55) rep(k,55) cnt[i][j][k]=0;\n\t\t\trep(i,30){\n\t\t\t\tch[i]=false;\n\t\t\t\trep(j,h){\n\t\t\t\t\trep(k,w){\n\t\t\t\t\t\tif(v[j][k]==char('A'+i)||v[j][k]=='-'){\n\t\t\t\t\t\t\tcnt[i][j][k]=1;\n\t\t\t\t\t\t\tif(v[j][k]==char('A'+i)) ch[i]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j) cnt[i][j][k]+=cnt[i][j-1][k];\n\t\t\t\t\t\tif(k) cnt[i][j][k]+=cnt[i][j][k-1];\n\t\t\t\t\t\tif(j&&k) cnt[i][j][k]-=cnt[i][j-1][k-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,30){\n\t\t\t\tif(!ch[i]) continue;\n\t\t\t\trep(y1,h){\n\t\t\t\t\trep(x1,w){\n\t\t\t\t\t\treep(y2,y1,h){\n\t\t\t\t\t\t\treep(x2,x1,w){\n\t\t\t\t\t\t\t\tif((y2-y1+1)*(x2-x1+1)==cnt[i][h-1][w-1]&&getcnt(y1,x1,y2,x2,i)==cnt[i][h-1][w-1]){\n\t\t\t\t\t\t\t\t\t// cout<<\"AAA\"<<endl;\n\t\t\t\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t\t\t\t\treep(j,y1,y2+1){\n\t\t\t\t\t\t\t\t\t\treep(k,x1,x2+1){\n\t\t\t\t\t\t\t\t\t\t\tv[j][k]='-';\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok) cout<<\"SAFE\"<<endl;\n\t\telse cout<<\"SUSPICIOUS\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass Belongings {\npublic:\n  Belongings() : left(100),right(0),upper(100),lower(0){}\n  int left,right,upper,lower;\n};\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    for(int stage_idx = 0; stage_idx < N; stage_idx++){\n      int H,W;\n      \n      scanf(\"%d %d\",&H,&W);\n      char stage[2500];\n      char hypothesis[2500];\n      memset(stage,'.',sizeof(stage));\n\n      map<char,Belongings> layer;\n\n      for(int y=0;y<H;y++){\n\tchar line[51];\n\tscanf(\"%s\",line);\n\tfor(int x=0;x<W;x++){\n\t  stage[y*W+x] = line[x];\n\t  if(line[x] == '.') continue;\n\t  //x:0->...\n\t  //y:0\n\t  //  |\n\t  //  v\n\t  //  .\n\t  //  upper\n\t  //left right\n\t  //  lower\n\t  Belongings& be = layer[stage[y*W+x]];\n\t  be.left = min(be.left,x);\n\t  be.right = max(be.right,x);\n\t  be.upper = min(be.upper,y);\n\t  be.lower = max(be.lower,y);\n\t}\n      }\n\n      bool is_safe = false;\n\n      vector<char> order;\n      for(map<char,Belongings>::iterator it = layer.begin();\n\t  it != layer.end();\n\t  it++){\n\torder.push_back(it->first);\n      }\n      sort(order.begin(),order.end());\n\n\n      do{\n\tmemset(hypothesis,'.',sizeof(hypothesis));\n\n\tfor(int i=0;i<order.size();i++){\n\t  char c = order[i];\n\t  Belongings& be = layer[c];\n\t  for(int y=be.upper; y<=be.lower; y++){\n\t    for(int x=be.left; x<=be.right; x++){\n\t      hypothesis[y*W+x] = c;\n\t    }\n\t  }\n\t}\n\n\tif(strcmp(hypothesis,stage) == 0){\n\t  is_safe = true;\n\t  break;\n\t}\n      }while(next_permutation(order.begin(),order.end()));\n      printf(\"%s\\n\",is_safe ? \"SAFE\" : \"SUSPICIOUS\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <string>\n#include <cmath>\n#include <map>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int inf = 100100100;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int number;\n  cin >> number;\n  rep(aaaaaaa,number){\n      int h,w;\n      bool flag =true;\n      cin >> h >> w;\n      string s[55]={};\n      map<char,bool> m;\n      m['.'] = false;\n      rep(y,h){\n          cin >> s[y];\n      }\n      rep(y,h)rep(x,w){\n          if(s[y][x]!='.'){\n              if(m[s[y][x]]){\n                  flag = false;\n                  x=w;y=h;break;\n              }\n              int st = x;\n              char tc = s[y][x];\n              m[tc] = true;\n              while(s[y][x]==tc) x++;\n              int et = x;\n              int yy = y;\n              while(yy<h && s[yy][st]==tc){\n                  REP(xx,st,et) {\n                      if(s[yy][xx]!=tc){flag=false;}\n                      s[yy][xx]='.';\n                  }\n                  yy+=1;\n              }\n              // rep(ya,h) cout << s[ya] << endl;\n              x--;\n          }\n      }\n      rep(y,h)rep(x,w){\n         if(s[y][x]!='.') flag = false;\n      }\n      if(flag) cout << \"SAFE\" << endl;\n      else cout << \"SUSPICIOUS\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tint N, H, W;\n\tcin >> N;\n\twhile (N--) {\n\t\tcin >> H >> W;\n\t\tvector<int> used(26), xma(26), xmi(26, 100), yma(26), ymi(26, 100);\n\t\tvector<vector<char>> a(H, vector<char>(W));\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tif (a[i][j] != '.') {\n\t\t\t\t\tint p = a[i][j] - 'A';\n\t\t\t\t\tused[p] = 1;\n\t\t\t\t\txma[p] = max(xma[p], i);\n\t\t\t\t\txmi[p] = min(xmi[p], i);\n\t\t\t\t\tyma[p] = max(yma[p], j);\n\t\t\t\t\tymi[p] = min(ymi[p], j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<int>> d(26, vector<int>(26, 1000));\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\td[i][i] = 0;\n\t\t}\n\t\tbool sus = false;\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\tif (used[i]) {\n\t\t\t\tfor (int x = xmi[i]; x <= xma[i]; x++) {\n\t\t\t\t\tfor (int y = ymi[i]; y <= yma[i]; y++) {\n\t\t\t\t\t\tif (a[x][y] == '.') {\n\t\t\t\t\t\t\tsus = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (a[x][y] - 'A' != i) {\n\t\t\t\t\t\t\td[i][a[x][y] - 'A'] = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < 26; k++) {\n\t\t\tfor (int i = 0; i < 26; i++) {\n\t\t\t\tfor (int j = 0; j < 26; j++) {\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\tif (d[i][i] < 0) {\n\t\t\t\tsus = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << (sus ? \"SUSPICIOUS\" : \"SAFE\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<stdio.h>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\n\nint main(void) {\n\n\tint n;\n\n\tcin >> n;\n\n\tFOR(i, 1, n) {\n\t\tint h, w;\n\t\tvector<bool> check(27, false);\n\t\t\n\t\t\n\t\tbool ok = true;\n\t\t\n\n\t\tcin >> h >> w;\n\n\t\tvector<string> s(h);\n\n\t\tFOR(j, 0, h - 1) {\n\t\t\tcin >> s[j];\n\t\t}\n\n\n\t\tFOR(j, 0, h - 1) {\n\t\t\tFOR(k, 0, w - 1) {\n\t\t\t\tif (s[j][k] >= 'A'&&s[j][k] <= 'Z') {\n\t\t\t\t\tcheck[s[j][k] - 'A'+1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (ok == true) {\n\t\t\tok = false;\n\t\t\tvector<bool> flag(27, false);\n\t\t\tvector<int> xf(27, -1);\n\t\t\tvector<int> xl(27, -1);\n\t\t\tvector<int> yf(27, -1);\n\t\t\tvector<int> yl(27, -1);\n\t\t\t//cout << 'c' << endl;\n\t\t\tFOR(j, 1, 26) {\n\t\t\t\tif (check[j] == false) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tFOR(k, 0, h - 1) {\n\t\t\t\t\tFOR(l, 0, w - 1) {\n\t\t\t\t\t\tif (s[k][l] == j - 1 + 'A') {\n\t\t\t\t\t\t\tyf[j] = k;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (yf[j] != -1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tRFOR(k, h - 1, 0) {\n\t\t\t\t\tRFOR(l, w - 1, 0) {\n\t\t\t\t\t\tif (s[k][l] == j - 1 + 'A') {\n\t\t\t\t\t\t\tyl[j] = k;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (yl[j] != -1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tFOR(k, 0, w - 1) {\n\t\t\t\t\tFOR(l, 0, h - 1) {\n\t\t\t\t\t\tif (s[l][k] == j - 1 + 'A') {\n\t\t\t\t\t\t\txf[j] = k;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (xf[j] != -1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tRFOR(k, w - 1, 0) {\n\t\t\t\t\tRFOR(l, h - 1, 0) {\n\t\t\t\t\t\tif (s[l][k] == j - 1 + 'A') {\n\t\t\t\t\t\t\txl[j] = k;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (xl[j] != -1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t\n\n\t\t\t\t//cout << 'd' << endl;\n\t\t\t\tFOR(k, 0, h - 1) {\n\t\t\t\t\tFOR(l, 0, w - 1) {\n\t\t\t\t\t\t//cout << k << \" \" << l << endl;\n\t\t\t\t\t\tif (l >= xf[j] && l <= xl[j] && k >= yf[j] && k <= yl[j]) {\n\t\t\t\t\t\t\tif (s[k][l] != 'A' + j - 1&&s[k][l]!='o') {\n\t\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (s[k][l] == 'A' + j - 1) {\n\t\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (k == h - 1) {\n\t\t\t\t\t\tflag[j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tend:;\n\n\t\t\t}\n\n\t\t\t//cout << 'e' << endl;\n\t\t\tFOR(j, 1, 26) {\n\t\t\t\tif (flag[j] == true) {\n\t\t\t\t\tFOR(k, 0, h - 1) {\n\t\t\t\t\t\tFOR(l, 0, w - 1) {\n\t\t\t\t\t\t\tif (s[k][l] == 'A' + j - 1) {\n\t\t\t\t\t\t\t\ts[k][l] = 'o';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << 'f' << endl;\n\n\t\t\tFOR(j, 1, 26) {\n\t\t\t\tif (flag[j] == true) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tcheck[j] = false;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t/*cout << endl;\n\t\t\tFOR(j, 0, h - 1) {\n\t\t\t\tFOR(k, 0, w - 1) {\n\t\t\t\t\tcout << s[j][k];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\tcout << endl;*/\n\t\t}\n\t\t\n\t\tok = true;;\n\t\tFOR(j, 1, 26) {\n\t\t\tif (check[j] == true) {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\n\t\tif (ok) {\n\t\t\tcout << \"SAFE\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nint h, w;\nbool ans;\n\nvoid debug(vector<string> s){\n\tcout << \"[debug]\" << endl;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tcout << s[y] << endl;\n\t}\n\tcout << endl;\n}\n\n// ツ債カツ湘」ツづ?右ツ可コツづ個催?標ツづーツ陛板つキ\npair<P,P> get_size(const vector<string>& s, char c){\n\tint max_x=0, max_y=0, min_x=1e+8, min_y=1e+8;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( s[y][x] == c ){\n\t\t\t\tmax_x = max( max_x , x );\n\t\t\t\tmax_y = max( max_y , y );\n\t\t\t\tmin_x = min( min_x , x );\n\t\t\t\tmin_y = min( min_y , y );\n\t\t\t}\n\t\t}\n\t}\n\treturn pair<P,P>( P(min_x,min_y) , P(max_x,max_y) );\n}\n\n// ツ陳キツ陛サツ形ツつゥツ陳イツづ猟づゥ\nbool is_rect(const vector<string>& s, char c){\n\tpair<P,P> pp = get_size( s , c );\n\t\n\tint min_x = pp.first.first;\n\tint min_y = pp.first.second;\n\tint max_x = pp.second.first;\n\tint max_y = pp.second.second;\n\t//cout << \"char c : \" << c << \" (\" << min_x << \",\" << min_y << \") , (\" << max_x << \",\" << max_y << \")\" << endl;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( min_x <= x && min_y <= y && x <= max_x && y <= max_y ){\n\t\t\t\tif( s[y][x] == c || s[y][x] == '*' ){\n\t\t\t\t}else{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif( s[y][x] == c ) return false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\n// ツ嘉猟閉ィツづーツ偲ヲツづィツ渉慊つュ\nvector<string> remove(vector<string> s, char c){\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( s[y][x] == c ){\n\t\t\t\ts[y][x] = '*';\n\t\t\t}\n\t\t}\n\t}\n\treturn s;\n}\n\n// memo[i] : iツ氾板姪堋づ個嘉猟閉ィツづーツ陳イツづ猟つスツつゥツづ?つ、ツつゥ, vc[i] : iツ氾板姪堋づ個嘉猟閉ィツづーツ表ツつキツ閉カツ篠?\n// s : w*hツづ個湘ウツ妥? cnt : ツ偲ヲツづィツ渉慊つ「ツつスツ嘉猟閉ィツづ個青?\nvoid solve(vector<bool> memo, vector<char> vc, vector<string> s, int cnt){\n\tif( ans ) return;\n\tif( cnt == vc.size() ){\n\t\tans = true;\n\t\treturn;\n\t}\n\t\n\tfor(int i=0 ; i < vc.size() ; i++ ){\n\t\tif( memo[i] ) continue;\n\t\t//debug( s );\n\t\tchar c = vc[i];\n\t\tif( is_rect( s , c ) ){\n\t\t\tmemo[i] = true;\n\t\t\ts = remove( s , c );\n\t\t\t//debug( s );\n\t\t\tsolve( memo , vc , s , cnt+1 );\n\t\t\tmemo[i] = false;\n\t\t}\n\t}\n}\n\nint main(){\n\tint T;\n\tcin >> T;\n\tfor(int i = 0 ; i < T ; i++ ){\n\t\tcin >> w >> h;\n\t\tvector<string> s;\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tstring s_;\n\t\t\tcin >> s_;\n\t\t\ts.push_back( s_ );\n\t\t}\n\n\t\tint f[256] = {0};\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tchar c = s[y][x];\n\t\t\t\tif( c >= 'A' && c <= 'Z' ){\n\t\t\t\t\tf[c] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<char> vc;\n\t\tfor(char c='A' ; c <= 'Z' ; c++ ){\n\t\t\tif( f[c] ){\n\t\t\t\tvc.push_back( c );\n\t\t\t}\n\t\t}\n\n\t\t//debug( s );\n\t\tif( vc.size() == 0 ){\n\t\t\tcout << \"SAFE\" << endl;\n\t\t}else{\n\t\t\tans = false;\n\t\t\tvector<bool> memo( (int)vc.size() , false );\n\t\t\tsolve( memo , vc , s , 0 );\n\t\t\tif( ans ){\n\t\t\t\tcout << \"SAFE\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct region {\n  int xmin = 51;\n  int xmax = -1;\n  int ymin = 51;\n  int ymax = -1;\n};\n\n\nbool hoge(int h, int w, vector<vector<char>> &image, vector<region> regions, vector<int> indexes)\n{\n  bool flag = false;\n\n  do {\n    vector<vector<int>> image2(50, vector<int>(50));\n\n    for (int i = 0; i < h; ++i)\n      for (int j = 0; j < w; ++j)\n        image2[i][j] = '.';\n\n    for (auto &idx : indexes) {\n      char c = char(idx + 'A');\n      region r = regions[idx];\n      for (int x = r.xmin; x <= r.xmax; ++x)\n        for (int y = r.ymin; y <= r.ymax; ++y)\n          image2[x][y] = c;\n    }\n\n    flag = true;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        if (image[i][j] != image2[i][j]) {\n          flag = false;\n          break;\n        }\n      }\n    }\n    if (flag)\n      break;\n  } while (next_permutation(indexes.begin(), indexes.end()));\n\n  return flag;\n}\n\nint main() {\n  int h, w;\n\n  cin >> h; // dummy\n\n  while (cin >> h >> w) {\n    vector<vector<char>> image(50, vector<char>(50));\n    vector<region> regions(25);\n    vector<int> indexes;\n\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        cin >> image[i][j];\n\n        if (image[i][j] == '.')\n          continue;\n\n        int idx = int(image[i][j] - 'A');\n        regions[idx].xmin = (i < regions[idx].xmin) ? i : regions[idx].xmin;\n        regions[idx].xmax = (regions[idx].xmax < i) ? i : regions[idx].xmax;\n        regions[idx].ymin = (j < regions[idx].ymin) ? j : regions[idx].ymin;\n        regions[idx].ymax = (regions[idx].ymax < j) ? j : regions[idx].ymax;\n        indexes.push_back(image[i][j] - 'A');\n      }\n    }\n\n    sort(indexes.begin(), indexes.end());\n    indexes.erase(unique(indexes.begin(), indexes.end()), indexes.end());\n\n    cout << (hoge(h, w, image, regions, indexes) ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\nconst double PI = acos(-1);\n\nstruct Input\n{\n\tint n;char c;char str[1024];string s;ll l;\n\tint nextInt(){scanf(\"%d\", &n);return n;}\n\tll nextLong(){scanf(\"%lld\", &l);return l;}\n\tchar nextChar(){scanf(\"%c\", &c);return c;}\n\tstring next(){scanf(\"%s\", str);return string(str);}\n\tstring nextLine(){getline(cin, s);return s;}\n};\nInput in;\n\n\n\nint h, w;\nstring s[50];\nmap<char, int> x, X, y, Y;\nmap<char, int> d[65][65];\n\nint count(int sx, int sy, int ex, int ey, char c){\n\treturn d[ey][ex][c] - d[sy][ex][c] - d[ey][sx][c] + d[sy][sx][c]; \n}\n\nbool calc(vector<char> &v){\n\tint n = v.size();\n\tfor(int i = 0; i < n; i++){\n\t\tchar c = v[i];\n\t\tif(count(x[c], y[c], X[c] + 1, Y[c] + 1, '.') > 0) return false;\n\t\tfor(int j = 0; j < i; j++){\n\t\t\tif(count(x[c], y[c], X[c] + 1, Y[c] + 1, v[j]) > 0) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tint n = in.nextInt();\n\twhile(n--){\n\t\th = in.nextInt(); w = in.nextInt();\n\t\trep(i, h) s[i] = in.next();\n\t\tx.clear(); X.clear(); y.clear(); Y.clear();\n\t\trep(i, h + 1) rep(j, w + 1) d[i][j].clear();\n\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(x.find(s[i][j]) == x.end()){\n\t\t\t\t\tx[s[i][j]] = X[s[i][j]] = j;\n\t\t\t\t\ty[s[i][j]] = Y[s[i][j]] = i;\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tx[s[i][j]] = min(x[s[i][j]], j);\n\t\t\t\t\tX[s[i][j]] = max(X[s[i][j]], j);\n\n\t\t\t\t\ty[s[i][j]] = min(y[s[i][j]], i);\n\t\t\t\t\tY[s[i][j]] = max(Y[s[i][j]], i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tfor(auto p : x){\n\t\t\t\t\td[i][j][p.fi] += d[i-1][j][p.fi];\n\t\t\t\t\tif(p.fi == s[i-1][j-1]) d[i][j][p.fi]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tfor(auto p : x){\n\t\t\t\t\td[i][j][p.fi] += d[i][j-1][p.fi];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<char> v;\n\t\tfor(auto p : x) if(p.fi != '.') v.pb(p.fi);\n\n\n\t\tbool f = false;\n\t\tdo{\n\t\t\tf |= calc(v);\n\t\t\t// if(calc(v)){\n\t\t\t// \tfor(int i = 0; i < v.size(); i++)cout<<\" \"<<v[i];\n\t\t\t// \tcout<<endl;\n\t\t\t// }\n\t\t}while(next_permutation(all(v)));\n\n\t\tprintf(\"%s\\n\", (f?\"SAFE\":\"SUSPICIOUS\"));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <map>\n#include <functional>\n#define N 50\nusing namespace std;\n\ntypedef pair<int,int> pii;\nclass aa{\n\tpublic:\n\t\tint u,d,l,r;\n\t\taa(){\n\t\t\tu=-1;\n\t\t\td=999;\n\t\t\tl=999;\n\t\t\tr=-1;\n\t\t}\n\n\t\taa(int i,int j){\n\t\t\tu=i;\n\t\t\td=i;\n\t\t\tl=j;\n\t\t\tr=j;\n\t\t}\n\n\t\tvoid cousin(int i,int j){\n\t\t\tif(u<i)u=i;\n\t\t\tif(d>i)d=i;\n\t\t\tif(r<j)r=j;\n\t\t\tif(l>j)l=j;\n\t\t}\n};\n\nmap<char,aa> k;\nchar m[51][51];\nint w,h;\n\nint main(void){\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\tcin>>w>>h;\n\t\tfor(int i=0;i<w;i++){\n\t\t\tscanf(\"%s\",m[i]);\n\t\t}\n\t\tk.clear();\n\t\tfor(int i=0;i<w;i++){\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tif(m[i][j]!='.'){\n\t\t\t\t\t// if(0<k.count(m[i][j]))k[m[i][j]].cousin(i,j);\n\t\t\t\t\tk[m[i][j]].cousin(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag=true;\n\t\tfor(map<char,aa>::iterator it=k.begin();it!=k.end();it++){\n\t\t\tchar c=it->first;\n\t\t\taa s=it->second;\n\t\t\tint u=s.u,d=s.d,l=s.l,r=s.r;\n\t\t\t// cout<<\"char:\"<<c<<\" from:\"<<d<<\" \"<<l<<\" to:\"<<u<<\" \"<<r<<endl;\n\t\t\tfor(int i=d;i<=u;i++){\n\t\t\t\tfor(int j=l;j<=r;j++){\n\t\t\t\t// cout<<i<<\":\"<<j<<endl;\n\t\t\t\t\tif(m[i][j]=='.'){\n\t\t\t\t\t\t// cout<<\"susp:\"<<c<<\" \"<<i<<\" \"<<j<<endl;\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\tgoto LABEL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\nLABEL:\n\t\tcout<<((flag)?(\"SAFE\"):(\"SUSPICIOUS\"))<<endl;\n\t\t/*\n\t\t\t for(map<char,aa>::iterator it=k.begin();it!=k.end();it++){\n\t\t\t char c=it->first;\n\t\t\t aa s=it->second;\n\t\t\t cout<<c<<\"++\"<<s.u<<\":\"<<s.d<<\":\"<<s.l<<\":\"<<s.r<<endl;\n\t\t\t }\n\t\t\t */\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <map>\n#include <algorithm>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nstruct rect { int ly, ry, lx, rx; };\n\nint T, H, W;\nchar S[55][55];\n\nint main(void) {\n  cin >> T;\n  while(T--) {\n    cin >> H >> W;\n    REP(i, 0, H) cin >> S[i];\n\n    set<char> st;\n    REP(i, 0, H) REP(j, 0, W) if(S[i][j] != '.') st.insert(S[i][j]);\n    map<char, int> ctoi;\n    for(char i : st) ctoi[i] = ctoi.size();\n\n    int a[10];\n    REP(i, 0, 10) a[i] = i;\n\n    map<char, rect> p;\n    REP(i, 0, H) REP(j, 0, W) if(S[i][j] != '.') p[S[i][j]] = (rect) { i, i, j, j };\n\n    REP(i, 0, H) REP(j, 0, W) {\n      if(S[i][j] != '.') {\n        p[S[i][j]].ly = min(p[S[i][j]].ly, i);\n        p[S[i][j]].ry = max(p[S[i][j]].ry, i);\n        p[S[i][j]].lx = min(p[S[i][j]].lx, j);\n        p[S[i][j]].rx = max(p[S[i][j]].rx, j);\n      }\n    }\n\n    int ans = false;\n    do {\n      bool f = true;\n      for(pair<char, rect> r : p) {\n        char c = r.first;\n        rect q = r.second;\n        REP(i, q.ly, q.ry + 1) REP(j, q.lx, q.rx + 1) {\n          if(S[i][j] == '.' || a[ctoi[c]] < a[ctoi[S[i][j]]]) {\n            f = false;\n            goto END;\n          }\n        }\nEND:;\n      }\n      ans = ans || f;\n      if(ans) break;\n    } while(next_permutation(a, a + st.size()));\n\n    cout << (ans ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\n\nint main() {\n\tlong long int N;\n\tcin >> N;\n\tfor( long long int index = 0; index < N; index++ ) {\n\t\tlong long int A, B;\n\t\tcin >> A >> B;\n\t\tvector<string>D( A );\n\t\tmap<char, pair<pair<int, int>, pair<int, int>>>memo;\n\t\tfor( int i = 0; i < A; i++ ) {\n\t\t\tcin >> D[i];\n\t\t\tfor( int j = 0; j < B; j++ ) {\n\t\t\t\tif( D[i][j] != '.' ) {\n\t\t\t\t\tif( memo.count( D[i][j] ) ) {\n\t\t\t\t\t\tmemo[D[i][j]].first.first = min( memo[D[i][j]].first.first, i );\n\t\t\t\t\t\tmemo[D[i][j]].first.second = min( memo[D[i][j]].first.second, j );\n\t\t\t\t\t\tmemo[D[i][j]].second.first = max( memo[D[i][j]].second.first, i + 1 );\n\t\t\t\t\t\tmemo[D[i][j]].second.second = max( memo[D[i][j]].second.second, j + 1 );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmemo[D[i][j]] = make_pair( make_pair( i, j ), make_pair( i, j ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool f = true;\n\t\twhile( f ) {\n\t\t\tf = false;\n\t\t\tfor( auto now : memo ) {\n\t\t\t\tif( now.second != make_pair( make_pair( 0, 0 ), make_pair( 0, 0 ) ) ) {\n\n\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\tfor( int i = now.second.first.first; flag&& i < now.second.second.first; i++ ) {\n\t\t\t\t\t\tfor( int j = now.second.first.second; j < now.second.second.second; j++ ) {\n\t\t\t\t\t\t\tif( D[i][j] != '#' &&D[i][j] != now.first ) {\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( flag ) {\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tfor( int i = now.second.first.first; flag&& i < now.second.second.first; i++ ) {\n\t\t\t\t\t\t\tfor( int j = now.second.first.second; j < now.second.second.second; j++ ) {\n\t\t\t\t\t\t\t\tif( D[i][j] == now.first ) {\n\t\t\t\t\t\t\t\t\tD[i][j] = '#';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemo[now.first] = make_pair( make_pair( 0, 0 ), make_pair( 0, 0 ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf = true;\n\t\tfor( auto now : memo ) {\n\t\t\t//cout << now.first << endl;\n\t\t\t//cout << now.second.first.first << \" \" << now.second.first.second << \" \" << now.second.second.first << \" \" << now.second.second.second << endl;\n\t\t\tif( now.second != make_pair( make_pair( 0, 0 ), make_pair( 0, 0 ) ) ) {\n\t\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t\t\tf = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( f ) {\n\t\t\tcout << \"SAFE\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint w, h;\nint sy, sx, gy, gx;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nbool can(int y,int x) {\n\tif(0 <= y && y < h && 0 <= x && x < w) return true;\n\treturn false;\n}\n\nvector<string> s;\nchar c;\nbool used[55][55], visited[55][55], alpha[30];\n\nvoid dfs(int i, int j) {\n\tvisited[i][j] = true;\n\tsy = min(sy, i);\n\tsx = min(sx, j);\n\tgy = max(gy, i);\n\tgx = max(gx, j);\n\n\trep(i, 4) {\n\t\tint y = i + dy[i];\n\t\tint x = j + dx[i];\n\n\t\tif(can(y, x) && !visited[y][x] && s[y][x] == c) {\n\t\t\tdfs(y, x);\n\t\t}\n\t}\n}\n\nbool check() {\n\tREP(i, sy, gy+1){\n\t\tREP(j, sx, gx+1) {\n\t\t\tif(s[i][j] == c || used[i][j]) continue;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid f() {\n\tREP(i, sy, gy+1) {\n\t\tREP(j, sx, gx+1) {\n\t\t\tused[i][j] = true;\n\t\t}\n\t}\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\trep(q, n) {\n\t\tcin >> h >> w;\n\t\ts.resize(h);\n\t\trep(i, h) cin >> s[i];\n\n\t\tmemset(used, 0, sizeof(used));\n\t\tmemset(alpha, 0, sizeof(alpha));\n\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tif(used[i][j]) continue;\n\t\t\t\tif(s[i][j] == '.') continue;\n\n\t\t\t\tsy = i;\n\t\t\t\tsx = j;\n\t\t\t\tgy = i;\n\t\t\t\tgx = j;\n\t\t\t\tc = s[i][j];\n\t\t\t\tmemset(visited, 0, sizeof(visited));\n\t\t\t\tdfs(i, j);\n\n\t\t\t\tif(check() && alpha[c - 'A']) {\n\t\t\t\t\tf();\n\t\t\t\t\talpha[c - 'A'] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tif(used[i][j]) continue;\n\t\t\t\tif(s[i][j] == '.') continue;\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\n\t\tif(flag) cout << \"SAFE\" << endl;\n\t\telse cout << \"SUSPICIOUS\" << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct pos{\n  int x, y;\n};\nstruct rect{\n  pos lt, rb;\n};\n\nint H, W;\nchar pjt[55][55];\n\nmap<char, rect> bg;\n\nbool judge(const vector<char> &vec)\n{\n  string ex = \"\";\n  for(auto &v : vec){\n    ex += v;\n    for(int i = bg[v].lt.y; i <= bg[v].rb.y; i++){\n      for(int j = bg[v].lt.x; j <= bg[v].rb.x; j++){\n\tif(ex.find(pjt[i][j]) == string::npos) return false;\n      }\n    }\n  }\n  return true;\n}\n\nint main()\n{\n  int N; cin >> N;\n  while(N--){\n    bg.clear();\n    cin >> H >> W;\n    vector<char> mtl;\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n\tcin >> pjt[i][j];\n\tif(pjt[i][j] == '.') continue;\n\tif(bg.count(pjt[i][j]) == 0){\t  \n\t  mtl.push_back(pjt[i][j]);\n\t  bg[pjt[i][j]].lt.x = j;\n\t  bg[pjt[i][j]].lt.y = i;\n\t  bg[pjt[i][j]].rb.x = j;\n\t  bg[pjt[i][j]].rb.y = i;\n\t} else {\n\t  bg[pjt[i][j]].lt.x = min(bg[pjt[i][j]].lt.x, j);\n\t  bg[pjt[i][j]].lt.y = min(bg[pjt[i][j]].lt.y, i);\n\t  bg[pjt[i][j]].rb.x = max(bg[pjt[i][j]].rb.x, j);\n\t  bg[pjt[i][j]].rb.y = max(bg[pjt[i][j]].rb.y, i);\n\t}\n      }\n    }\n    sort(mtl.begin(), mtl.end());\n    bool flag = false;\n    do{\n      flag |= judge(mtl);\n      if(flag) break;\n    }while(next_permutation(mtl.begin(), mtl.end()));\n    if(!flag) cout << \"SUSPICIOUS\" << endl;\n    else cout << \"SAFE\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <string>\n#include <cmath>\n#include <map>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int inf = 100100100;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int number;\n  cin >> number;\n  rep(aaaaaaa,number){\n      int h,w;\n      bool flag =true;\n      cin >> h >> w;\n      string s[55]={};\n      map<char,bool> m;\n      m['.'] = false;\n      rep(y,h){\n          cin >> s[y];\n      }\n      rep(y,h)rep(x,w){\n          if(s[y][x]!='.'){\n              if(m[s[y][x]]){\n                  flag = false;\n                  x=w;y=h;break;\n              }\n              int st = x;\n              char tc = s[y][x];\n              m[tc] = true;\n              while(s[y][x]==tc) x++;\n              int et = x;\n              int yy = y;\n              while(yy<h && s[yy][st]==tc){\n                  REP(xx,st,et) {\n                      if(s[yy][xx]!=tc){flag=false;}\n                      s[yy][xx]='.';\n                  }\n                  yy+=1;\n              }\n              // rep(ya,h) cout << s[ya] << endl;\n              x--;\n          }\n      }\n      rep(y,h)rep(x,w){\n         if(s[y][x]!='.') flag = false;\n      }\n      if(flag) cout << \"SAFE\" << endl;\n      else cout << \"SUSPICIOUS\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool issquare(vector<string> m, vector<char> &c, int k){\n\tif(k >= c.size()){\n\t\treturn true;\n\t}\n\tint n = (int)c.size();\n\tint h = (int)m.size();\n\tint w = (int)m[0].size();\n\tint r = 0, l = w, u = h, d = 0;\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tif(m[i][j] == c[k]){\n\t\t\t\tr = max(r, j);\n\t\t\t\tl = min(l, j);\n\t\t\t\tu = min(u, i);\n\t\t\t\td = max(d, i);\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"(%d, %d), (%d, %d)\\n\",r,l,u,d);\n\tbool flag = true;\n\tfor(int i = u; i <= d; i++){\n\t\tfor(int j = l; j <= r; j++){\n\t\t\tif(m[i][j] != '?' && m[i][j] != c[k]){\n\t\t\t\tflag = false;\n\t\t\t\ti = j = (int)1e9;\n\t\t\t}\n\t\t}\n\t}\n\tif(!flag)return false;\n\tfor(int i = u; i <= d; i++){\n\t\tfor(int j = l; j <= r; j++){\n\t\t\tif(m[i][j] == c[k]){\n\t\t\t\tm[i][j] = '?';\n\t\t\t}\n\t\t}\n\t}\n\treturn issquare(m, c, k+1);\n}\n\n\n\n\nint main(){\n\tint nn; cin >> nn;\n\tfor(int z = 0; z < nn; z++){\n\t\tint h,w; cin >> h >> w;\n\t\tvector<string> m(h);\n\t\tvector<char> c;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tcin >> m[i];\n\t\t}\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(m[i][j] == '.')continue;\n\t\t\t\tbool flag1 = true;\n\t\t\t\tfor(int k = 0; k < c.size(); k++){\n\t\t\t\t\tif(m[i][j] == c[k]){\n\t\t\t\t\t\tflag1 = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag1)c.push_back(m[i][j]);\n\t\t\t}\n\t\t}\n\t\tsort(c.begin(), c.end());/*\n\t\tfor(int i = 0; i < c.size(); i++){\n\t\t\tcout << c[i] << \" \";\n\t\t}\n\t\tcout << endl;*/\n\t\tbool flag = false;\n\t\tdo{\n\t\t\tif(issquare(m, c, 0)){\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}while(next_permutation(c.begin(), c.end()));\n\t\tif(flag){\n\t\t\tcout << \"SAFE\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144*2LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nunsigned long xor128() {\n\tstatic unsigned long x = 123456789, y = 362436069, z = 521288629, w = time(NULL);\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\n#define int ll\n\nvoid solve(){\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> inputs;\n\tREP(i, h) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tinputs.push_back(s);\n\t}\n\tint erased = 1;\n\twhile (erased) {\n\t\terased = 0;\n\t\tfor (char target = 'A'; target <= 'Z'; ++target) {\n\t\t\tpair<int, int> left = mp(10000, 10000);\n\t\t\tpair<int, int> right = mp(-1, -1);\n\t\t\tREP(i, h) {\n\t\t\t\tREP(q, w) {\n\t\t\t\t\tif (inputs[i][q] == target) {\n\t\t\t\t\t\tleft.first = min(left.first, i);\n\t\t\t\t\t\tleft.second = min(left.second, q);\n\t\t\t\t\t\tright.first = max(right.first, i);\n\t\t\t\t\t\tright.second = max(right.second, q);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (right.first == -1) continue;\n\t\t\tint ok = 1;\n\t\t\tfor (int i = left.first; i <= right.first; ++i) {\n\t\t\t\tfor (int q = left.second; q <= right.second; ++q) {\n\t\t\t\t\tif (inputs[i][q] != target && inputs[i][q] != '?') {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok == 0) continue;\n\t\t\terased = 1;\n\t\t\tfor (int i = left.first; i <= right.first; ++i) {\n\t\t\t\tfor (int q = left.second; q <= right.second; ++q) {\n\t\t\t\t\tinputs[i][q] = '?';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, h) {\n\t\tREP(q, w) {\n\t\t\tif (inputs[i][q] != '.' && inputs[i][q] != '?') {\n\t\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"SAFE\" << endl;\n}\n\n#undef int\nint main() {\n\tinit();\n\tint t;\n\tcin >> t;\n\tREP(tea,t)\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n#include <map>\n#define rep(i,n) for(int i=0; i<n; ++i)\n\nusing namespace std;\n\nint N, n;\nint H,W;\n\nchar m[50][50];\nbool used[26];\nint U[26],D[26],L[26],R[26];\n\n\nbool check(char ch){\n  int z = ch-'A';\n  for(int i=U[z]; i<D[z]; ++i){\n    for(int j=L[z]; j<R[z]; ++j){\n      if(m[i][j] != '.' && used[m[i][j]-'A'] == false) continue;\n      if(m[i][j]!=ch) return false;\n    }\n  }\n  return true;\n}\nvoid input(){\n  int x;\n  string str;\n  cin >> H >> W;\n  rep(i,H){\n    cin>>str;\n    rep(j,W){\n      m[i][j] = str[j];\n      if(m[i][j]=='.')continue;\n      x=m[i][j]-'A';\n      used[x] = true;\n      U[x]=min(U[x],i);\n      D[x]=max(D[x],i);\n      L[x]=min(L[x],j);\n      R[x]=max(R[x],j);\n    }\n  }\n}\n\nvoid init(){\n  rep(i,26){\n    U[i] = 50;\n    D[i] = 0;\n    L[i] = 50;\n    R[i] = 0;\n    used[i] = false;\n  }\n}\nint main(){\n  cin >> N;\n  while(N--){\n    init();\n    input();\n    while(1){\n      bool flag = false;\n      rep(i,26){\n        if(used[i]==false)continue;\n        if(check(i+'A')==true){\n          used[i] = false;\n          flag = true;\n          break;\n        }\n      }\n      if(flag == false) break;\n    }\n      bool flag = false;\n      rep(i,26) flag |= used[i];\n      cout << (flag ? \"SUSPICIOUS\" : \"SAFE\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint minX[26], maxX[26], minY[26], maxY[26];\nbool has[26];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tint t, H, W;\n\tcin >> t;\n\twhile (t--) {\n\t\tfor (int i=0; i<26; ++i) {\n\t\t\tminX[i] = minY[i] = 51;\n\t\t\tmaxX[i] = maxY[i] = -1;\n\t\t\thas[i] = false;\n\t\t}\n\t\tcin >> H >> W;\n\t\tvector<string> img(H, \"\");\n\t\tfor (int i=0; i<H; ++i) {\n\t\t\tcin >> img[i];\n\t\t\tfor (int j=0; j<W; ++j) {\n\t\t\t\tchar c = img[i][j];\n\t\t\t\tif (c != '.') {\n\t\t\t\t\tminX[c - 'A'] = min(minX[c - 'A'], j);\n\t\t\t\t\tmaxX[c - 'A'] = max(maxX[c - 'A'], j);\n\t\t\t\t\tminY[c - 'A'] = min(minY[c - 'A'], i);\n\t\t\t\t\tmaxY[c - 'A'] = max(maxY[c - 'A'], i);\n\t\t\t\t\thas[c - 'A'] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint k = 0;\n\t\twhile (k <= 26) {\n\t\t\tif (has[k]) {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int i=minY[k]; i<=maxY[k] && ok; ++i) {\n\t\t\t\t\tfor (int j=minX[k]; j<=maxX[k] && ok; ++j) {\n\t\t\t\t\t\tif (img[i][j] - 'A' != k && img[i][j] != '#') {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tfor (int i=minY[k]; i<=maxY[k]; ++i) {\n\t\t\t\t\t\tfor (int j=minX[k]; j<=maxX[k]; ++j) {\n\t\t\t\t\t\t\timg[i][j] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\thas[k] = false;\n\t\t\t\t\tk = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t++ k;\n\t\t}\n\t\tbool safe = true;\n\t\tfor (int i=0; i<26; ++i) {\n\t\t\tif (has[i]) {\n\t\t\t\tsafe = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << (safe ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nstruct make\n{\n\tchar str;\n\tint posi,start[2];\n\tint high,wide,JUDGE;\n\tstruct make *front[8];\n\tint f_count;\n};\n\nint main()\n{\n\tint N,H,W,count,COUNT,judge,no_rect[7],NO_RECT;\n\tchar img[1000][51];\n\tstruct make M[8];\n\tstruct make *MP;\n\t\n\tscanf(\"%d\",&N);//データの個数\n\tfor(int a=0;a<N;a++)\n\t{\n\t\tcount=0;//材質の個数\n\t\tCOUNT=0;\n\t\tNO_RECT=0;\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tscanf(\"%s\",img[b]);\n\t\t\timg[b][W]='\\0';\n\t\t}\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tfor(int d=0;d<count;d++) M[d].posi=-1;\n\t\t\tfor(int c=0;c<W;c++)\n\t\t\t{\n\t\t\t\tif(img[b][c]!='.')\n\t\t\t\t{\n\t\t\t\t\t//材質判定\n\t\t\t\t\tjudge=0;\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t\tif(count>0 && img[b][c]!=M[judge].str) judge++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}while(judge<count);\n\t\t\t\t\t//新しい材質の場合\n\t\t\t\t\tif(judge==count)\n\t\t\t\t\t{\n\t\t\t\t\t\tM[count].str=img[b][c];\n\t\t\t\t\t\tM[count].start[0]=b;\n\t\t\t\t\t\tM[count].start[1]=c;\n\t\t\t\t\t\tM[count].posi=c;\n\t\t\t\t\t\tM[count].high=1;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\t//既出の材質の場合\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(M[judge].start[1]>c) M[judge].start[1]=c;\n\t\t\t\t\t\tif(M[judge].posi<0) M[judge].posi=c;\n\t\t\t\t\t\telse if(M[judge].wide<c-M[judge].posi+1) M[judge].wide=c-M[judge].posi+1;\n\t\t\t\t\t\tM[judge].high=b-M[judge].start[0]+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//判定開始\n\t\tif(count)\n\t\t{\n\t\t\t//見えている部分が長方形かどうか判定\n\t\t\tfor(int b=0;b<count;b++)\n\t\t\t{\n\t\t\t\tM[b].JUDGE=1;\n\t\t\t\tM[b].f_count=0;\n\t\t\t\tfor(int c=0;c<8;c++) M[b].front[c]=NULL;\n\t\t\t\tfor(int s1=0;s1<M[b].high;s1++)\n\t\t\t\t{\n\t\t\t\t\tfor(int s2=0;s2<M[b].wide;s2++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//確実に長方形ではない場合\n\t\t\t\t\t\tif(img[s1+M[b].start[0]][s2+M[b].start[1]]=='.')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNO_RECT=1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//長方形の可能性もある場合\n\t\t\t\t\t\tif(img[s1+M[b].start[0]][s2+M[b].start[1]]!=M[b].str)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int c=0;c<count;c++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint e=0;\n\t\t\t\t\t\t\t\tfor(int d=0;d<M[b].f_count;)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif(img[s1+M[b].start[0]][s2+M[b].start[1]]==M[b].front[d]->str) break;\n\t\t\t\t\t\t\t\t\td++;\n\t\t\t\t\t\t\t\t\te=d;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//今いる座標のもじと比べる\n\t\t\t\t\t\t\t\tif(img[s1+M[b].start[0]][s2+M[b].start[1]]==M[c].str && e==M[b].f_count)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tM[b].front[M[b].f_count]=&M[c];\n\t\t\t\t\t\t\t\t\tM[b].f_count++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(M[b].JUDGE!=0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tno_rect[COUNT]=b;\n\t\t\t\t\t\t\t\tCOUNT++;\n\t\t\t\t\t\t\t\tM[b].JUDGE=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(NO_RECT==1) break;\n\t\t\t\t}\n\t\t\t\tif(M[b].JUDGE)M[b].front[M[b].f_count]=NULL;\n\t\t\t}\n\t\t\tif(NO_RECT) printf(\"SUSPICIOUS\\n\");\n\t\t\telse if(COUNT)\n\t\t\t{\n\t\t\t\tif(count!=COUNT)\n\t\t\t\t{\n\t\t\t\t\t//循環していないか確認\n\t\t\t\t\tfor(int b=0;b<COUNT;b++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int c=0;c<M[no_rect[b]].f_count;c++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMP=M[no_rect[b]].front[c];\n\t\t\t\t\t\t\tfor(int d=0;;d++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(MP==NULL) break;\n\t\t\t\t\t\t\t\tif(d>count)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tprintf(\"SUSPICIOUS\\n\");\n\t\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMP=(MP->front[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"SAFE\\n\");\n\t\t\t\t}\n\t\t\t\telse printf(\"SUSPICIOUS\\n\");\n\t\t\t}\n\t\t\telse printf(\"SAFE\\n\");\n\t\t}\n\t\telse printf(\"SAFE\\n\");\n\t}\n\treturn 0;\n}\n//printf(\"#\\n\");\n//printf(\"#1 count=%d\\n\",count);\n//printf(\"#1 COUNT=%d\\n\",COUNT);\n//printf(\"#1 NO_RECT=%d\\n\",NO_RECT);\n//printf(\"M[%d].str=%c\\nM[%d].high=%d\\nM[%d].wide=%d\\n\\n\",b,M[b].str,b,M[b].high,b,M[b].wide);\n//printf(\"#1\\nM[%d].start[0]=%d\\nM[%d].start[1]=%d\\n\\n\",b,M[b].start[0],b,M[b].start[1]);\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\nint h,w;\nstring G[51];\nbool checked[51][51];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nbool isRect(int x,int y)\n{\n  int x1,x2,y1,y2;\n  x1 = x2 = x;\n  y1 = y2 = y;\n\n  rep(i,h)\n    rep(j,w)\n    {\n      if(G[i][j] == G[y][x])\n\t{\n\t  if(j < x1)x1 = j;\n\t  if(j > x2)x2 = j;\n\t  if(i < y1)y1 = i;\n\t  if(i > y2)y2 = i;\n\t}\n    }\n\n  REP(i,y1,y2+1)\n    REP(j,x1,x2+1)\n    if(G[i][j] != G[y][x] && !checked[i][j])return false;\n  return true;\n\n}\n\nvoid draw(int x,int y,char c)\n{\n  if(checked[y][x])return;\n  checked[y][x] = true;\n  rep(i,4)\n    {\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(G[ny][nx] != c)continue;\n      draw(nx,ny,c);\n    }\n}\n\nbool isSafe()\n{\n  rep(i,h)\n    rep(j,w)\n    if(G[i][j] != '.' && !checked[i][j])return false;\n  return true;\n}\n\nint main()\n{\n  int T;\n  cin >> T;\n  while(T-- > 0)\n    {\n      cin >> h >> w;\n      rep(i,h)\n\tcin >> G[i];\n      rep(i,51)rep(j,51)checked[i][j] = false;\n\n      while(true)\n\t{\n\t  bool Fin = true;\n\t  bool update = false;\n       \n\t  rep(i,h)\n\t    {\t\n\t      rep(j,w)\n\t\t{\n\t\t  if(G[i][j] == '.')continue;\n\t\t  if(checked[i][j])continue;\n\t\t  Fin = false;\n\t\t  if(isRect(j,i))\n\t\t    {\n\t\t      update = true;\n\t\t      draw(j,i,G[i][j]);\n\t\t    }\n\t\t}\n\t    }\n\t  if(Fin || !update)break;\n\t}\n   \n      isSafe()?cout << \"SAFE\" << endl:cout << \"SUSPICIOUS\" << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nstruct make\n{\n\tchar str;\n\tint posi,start[2];\n\tint high,wide,JUDGE;//JUDGE==1で長方形,==0で長方形以外,==2で未定\n\tstruct make *front[8];\n};\n\n\nint main()\n{\n\tint N,H,W,count,COUNT,judge,no_rect,NO_RECT;\n\tchar img[1000][51];\n\tstruct make M[8];\n\tint s1,s2,num;\n\t\n\tscanf(\"%d\",&N);//データの個数\n\tfor(int a=0;a<N;a++)\n\t{\n\t\tcount=0;//材質の個数\n\t\tCOUNT=0;\n\t\tNO_RECT=0;\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tscanf(\"%s\",img[b]);\n\t\t\timg[b][W]='\\0';\n\t\t}\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tfor(int d=0;d<count;d++) M[d].posi=-1;\n\t\t\tfor(int c=0;c<W;c++)\n\t\t\t{\n\t\t\t\tif(img[b][c]!='.')\n\t\t\t\t{\n\t\t\t\t\t//材質判定\n\t\t\t\t\tjudge=0;\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t\tif(count>0 && img[b][c]!=M[judge].str) judge++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}while(judge<count);\n\t\t\t\t\t//新しい材質の場合\n\t\t\t\t\tif(judge==count)\n\t\t\t\t\t{\n\t\t\t\t\t\tM[count].str=img[b][c];\n\t\t\t\t\t\tM[count].start[0]=b;\n\t\t\t\t\t\tM[count].start[1]=c;\n\t\t\t\t\t\tM[count].posi=c;\n\t\t\t\t\t\tM[count].high=1;\n\t\t\t\t\t\tM[count].wide=1;\n\t\t\t\t\t\tM[count].JUDGE=0;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\t//既出の材質の場合\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(M[judge].start[1]>c) M[judge].start[1]=c;\n\t\t\t\t\t\tif(M[judge].posi<0) M[judge].posi=c;\n\t\t\t\t\t\telse if(M[judge].wide<c-M[judge].posi+1) M[judge].wide=c-M[judge].posi+1;\n\t\t\t\t\t\tM[judge].high=b-M[judge].start[0]+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tno_rect=count;\n\t\t//printf(\"count=%d\\n\",count);\n\t\t//判定開始\n\t\twhile(count)//文字アリ\n\t\t{\n\t\t\tCOUNT=0;\n\t\t\t//見えている部分が長方形かどうか判定\n\t\t\tfor(num=0;num<count;num++)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(M[num].JUDGE==1) continue;\n\t\t\t\tM[num].JUDGE=0;//長方形なら\n\t\t\t\t//printf(\"M[%d].str=%c\\nM[%d].high=%d\\nM[%d].wide=%d\\n\",num,M[num].str,num,M[num].high,num,M[num].wide);\n\t\t\t\t//printf(\"M[%d].start[0]=%d\\nM[%d].start[1]=%d\\n\",num,M[num].start[0],num,M[num].start[1]);\n\t\t\t\tfor(s1=0;s1<M[num].high;s1++)\n\t\t\t\t{\n\t\t\t\t\tfor(s2=0;s2<M[num].wide;s2++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//確実に長方形ではない場合\n\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]=='.')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNO_RECT=1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//長方形の可能性もある場合\n\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]!=M[num].str && img[s1+M[num].start[0]][s2+M[num].start[1]]!='#' )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//printf(\"s1=%d s2=%d\\n\",s1,s2);\n\t\t\t\t\t\t\tM[num].JUDGE=2;\n\t\t\t\t\t\t\tCOUNT++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(NO_RECT || M[num].JUDGE==2) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(NO_RECT || M[num].JUDGE==2) break;\n\t\t\t\t}\n\t\t\t\tif(NO_RECT) break;\n\t\t\t\t//長方形だった場合\n\t\t\t\tif(s1==M[num].high && s2==M[num].wide)\n\t\t\t\t{\n\t\t\t\t\tM[num].JUDGE=1;\n\t\t\t\t\tno_rect--;\n\t\t\t\t\tfor(int s1=0;s1<M[num].high;s1++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int s2=0;s2<M[num].wide;s2++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\timg[s1+M[num].start[0]][s2+M[num].start[1]]='#';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//printf(\"M[%d].JUDGE=%d\\n\\n\",num,M[num].JUDGE);\n\t\t\t}\n\t\t\tfor(int n=0;n<num;)\n\t\t\t{\n\t\t\t\tif(M[num].JUDGE!=2 && M[num].JUDGE!=1) break;\n\t\t\t\tn++;\n\t\t\t\t//どれも長方形ではなかった場合\n\t\t\t\tif(n==num) NO_RECT=1;\n\t\t\t}\n\t\t\t\n\t\t\t//printf(\"NO_RECT=%d\\n\",NO_RECT);\n\t\t\tif(NO_RECT==1) break;\n\t\t\t//printf(\"#no_rect=%d\\n\\n\\n\",no_rect);\n\t\t\t//すべて長方形\n\t\t\tif(no_rect==0) break;\n\t\t}\n\t\t//出力\n\t\tif(NO_RECT) printf(\"SUSPICIOUS1\\n\");\n\t\telse if(no_rect) printf(\"SUSPICIOUS2\\n\");\n\t\telse printf(\"SAFE1\\n\");\n\t}\n\t\n\treturn 0;\n}\n//printf(\"#1\");\n//printf(\"M[%d].str=%c\\nM[%d].high=%d\\nM[%d].wide=%d\\n\",num,M[num].str,num,M[num].high,num,M[num].wide);\n//printf(\"M[%d].start[0]=%d\\nM[%d].start[1]=%d\\n\\n\",num,M[num].start[0],num,M[num].start[1]);\n//printf(\"M[%d].JUDGE=%d\\n\\n\",num,M[num].JUDGE);\n//printf(\"s1=%d s2=%d\\n\",s1,s2);\n//printf(\"#no_rect=%d\\n\\n\\n\",no_rect);\n//printf(\"#s1=%d\\n#s2=%d\\n\",s1,s2);\n/*\n1\n10 10\n..........\n.DDDDDD...\n.DDDDCCC..\n.DDDDCCC..\nADDDDCCC..\nAAA..CCC..\nAAABBBBC..\nAAABBBB...\n..BBBBB...\n..........\n*/\n/*\n1\n10 10\n..........\n.DDDDCCC..\n.DDDDCCC..\n.DDDDCCC..\nADDDDCCC..\nAAA..CCC..\nAAABBBBC..\nAAABBBB...\n..BBBBB...\n..........\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl;\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct edge{int from, to; ll cost;};\n\nmap<char, bool> is_removed;\nint baggage_cnt = 0;\nint h,w;\nchar c = '*';\n\nbool is_rectangle(int si, int sj, int gi, int gj, char c, string s[]){\n\n    rep(h){\n        repp(j, w){\n            if(si <= i && i <= gi && sj <= j && j <= gj){\n                if(s[i][j] != c && !is_removed[s[i][j]]){\n                    return false;\n                }\n            }else{\n                if(s[i][j] == c) return false;\n            }\n        }\n    }\n    return true;\n}\n\nstring solve(string s[]){\n    set<char> st;\n    rep(h){\n        repp(j, w){\n            if(s[i][j] != '.') st.insert(s[i][j]);\n        }\n    }\n    baggage_cnt = (int)st.size();\n\n    while(true){\n        for(char c: st){\n            if(is_removed[c]) st.erase(c);\n        }\n        for(char c: st){\n            int si = -1, sj = -1, gi = -1, gj = -1;\n            rep(h){\n                repp(j, w){\n                    if(s[i][j] == c){\n                        if(si == -1){\n                            si = i; sj = j;\n                            gi = i; gj = j;\n                        }else{\n                            si = min(i, si);\n                            sj = min(j, sj);\n                            gi = max(i, gi);\n                            gj = max(j, gj);\n                        }\n                    }\n                }\n            }\n            if(si == -1)continue;\n\n            if(is_rectangle(si, sj, gi, gj, c, s)){\n                is_removed[c] = true;\n                baggage_cnt--;\n                if(!baggage_cnt) return \"SAFE\";\n            }\n        }\n    }\n    return \"SUSPICIOUS\";\n}\n\nint main() {\n    int t;\n    cin >> t;\n\n    repp(tt, t){\n        cin >> h >> w;\n        string s[h];\n        rep(h) cin >> s[i];\n        is_removed.clear();\n        baggage_cnt = 0;\n        cout << solve(s) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 110\n\nbool solve(){\n  int h,w;\n  char c[SIZE][SIZE];\n  string s;\n  bool f[26] = {};\n  \n  scanf(\"%d%d\",&h,&w);\n\n  if(h == 0) return false;\n\n  for(int i=0;i<h;i++){\n    scanf(\"%s\",c[i]);\n\n    for(int j=0;j<w;j++){\n      if(c[i][j]!='.' && f[c[i][j]-'A'] == false){\n        f[c[i][j]-'A'] = true;\n        s += c[i][j];\n      }\n    }\n  }\n\n  sort(s.begin(),s.end());\n  \n  do{\n    char copy_c[SIZE][SIZE];\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        copy_c[i][j] = c[i][j];\n      }\n    }\n\n    bool check = true;\n\n    for(int p=0;p<s.size();p++){\n      int min_h = INF, max_h = -1 ,min_w = INF,max_w = -1;\n      \n      for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n          if(copy_c[i][j] == s[p]){\n            min_h = min(min_h, i);\n            max_h = max(max_h, i);\n            min_w = min(min_w, j);\n            max_w = max(max_w, j);\n          }\n        }\n      }\n\n      for(int i=min_h;i<=max_h;i++){\n        for(int j=min_w;j<=max_w;j++){\n          if(copy_c[i][j] != s[p] && copy_c[i][j] != '#')\n            check = false;\n          copy_c[i][j] = '#';\n        }\n      }\n      \n    }\n\n    if(check){\n      puts(\"SAFE\");\n      return true;\n    }\n    \n  }while(next_permutation(s.begin(),s.end()));\n  \n  puts(\"SUSPICIOUS\");\n  return true;\n\n}\n\nint main(){\n  int t;\n\n  scanf(\"%d\",&t);\n  \n  while(t--) solve();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <sstream>\nusing namespace std;\n\n#define REP(i,a,n) for(i=a; i<n; i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define foreach(it,x) for(typeof(x.begin()) it=x.begin(); it!=x.end(); it++)\n\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\nint H,W;\nchar field[55][55];\nbool kind[256], used[256];\n\n\n// ·û`©Ç¤©B©ªæèºÌ¨Ìª êÎfalse\nbool is_check(int x1, int y1, int x2, int y2, char mark){\n    int i,j;\n    for(i=y1; i<=y2; i++){\n        for(j=x1; j<=x2; j++){\n            if( field[i][j] == '.' || used[field[i][j]] ) return false;\n        }\n    }\n    return true;\n}\n\n\nbool solve(char mark){\n    int i,j,x1,x2,y1,y2;\n\n    x1 = y1 = 55;\n    x2 = y2 = 0;\n    rep(i,H){\n        rep(j,W){\n            if( field[i][j] == mark ){\n                x1 = min(x1, j), y1 = min(y1, i);\n                x2 = max(x2, j), y2 = max(y2, i);\n            }\n        }\n    }\n\n    //printf(\"mark=%c, rec=(%d,%d),(%d,%d)\\n\",mark,x1,y1,x2,y2);\n    if( !is_check(x1,y1,x2,y2,mark) ) return false;\n    //printf(\"   is_check = ok\\n\");\n    used[mark] = true;\n\n    // Ü¾²×ÄÈ¢©ªæè¢¨Ì©çÄA\n    for(i=y1; i<=y2; i++){\n        for(j=x1; j<=x2; j++){\n            if( !used[field[i][j]] ){\n                //printf(\"     %c -> %c\\n\",mark,field[i][j]);\n                if( !solve(field[i][j]) ) return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main(){\n    int T,i,j;\n    cin >> T;\n\n    while( T-- ){\n        cin >> H >> W;\n        memset(kind, false, sizeof(kind));\n\n        rep(i,H) cin >> field[i];\n\n        bool ok = true;\n        rep(i,H){\n            rep(j,W){\n                if( field[i][j] != '.' && !kind[field[i][j]] ){\n                    memset(used, false, sizeof(used));\n                    //printf(\"used[D] = %d\\n\",used['D']);\n                    ok &= solve(field[i][j]);\n                    kind[field[i][j]] = true;\n                    //printf(\"___kinded %c, ok = %d\\n\",field[i][j],ok);\n                }\n            }\n        }\n\n        puts(ok ? \"SAFE\" : \"SUSPICIOUS\");\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n\ntypedef long long lint;\ntypedef pair<int, int> pii;\n\nint H, W;\nstring pict[55];\n\nbool item[30];\nint l[30], t[30], r[30], b[30];\nint collision[30];\n\nbool look[30];\n\nbool rec(int i) {\n\tif (look[i]) return false;\n\t\n\tlook[i] = true;\n\t\n\tint col = collision[i];\n\tfor_(j,0,26) {\n\t\tif (col >> j & 1) {\n\t\t\tif (!rec(j)) return false;\n\t\t}\n\t}\n\t\n\tlook[i] = false;\n\t\n\treturn true;\n}\n\nbool is_safe() {\n\tminit(collision, 0);\n\t\n\tfor_(alph,0,26) {\n\t\tif (!item[alph]) continue;\n\t\t\n\t\tchar ALPH = 'A' + alph;\n\t\t\n\t\tfor_(y,t[alph],b[alph] + 1) for_(x,l[alph],r[alph] + 1) {\n\t\t\tif (pict[y][x] == '.') return false;\n\t\t\t\n\t\t\tif (pict[y][x] != ALPH) {\n\t\t\t\tint p = (int)(pict[y][x] - 'A');\n\t\t\t\tcollision[alph] |= 1 << p;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor_(alph,0,26) {\n\t\tif (!item[alph]) continue;\n\t\tminit(look,0);\n\t\tif (!rec(alph)) return false;\n\t}\n\t\n\treturn true;\n}\n\nvoid solve() {\n\tminit(item,0);\n\tfill(l, l + 30, W);\n\tfill(t, t + 30, H);\n\tfill(r, r + 30, 0);\n\tfill(b, b + 30, 0);\n\t\n\tfor_(i,0,H) for_(j,0,W) {\n\t\tchar c = pict[i][j];\n\t\tif (c == '.') continue;\n\t\tint ci = (int)(c - 'A');\n\t\t\n\t\titem[ci] = true;\n\t\tl[ci] = min(l[ci], j);\n\t\tt[ci] = min(t[ci], i);\n\t\tr[ci] = max(r[ci], j);\n\t\tb[ci] = max(b[ci], i);\n\t}\n\t\n\tif (is_safe()) cout << \"SAFE\" << endl;\n\telse cout << \"SUSPICIOUS\" << endl;\n}\n\nint main() {\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tcin >> H >> W;\n\t\tfor_(i,0,H) cin >> pict[i];\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               class pas{\n                                        \tpublic:\n                                        \tint x,y,h;\n                                        \tpas(int x=0,int y=0,int h=0):x(x),y(y),h(h) {}\n                                        \tbool operator < (const pas &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pas &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            /*\n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n\nstring s[60];\n\nbool ch(int r,int x1,int y1,int x2,int y2){\n\tfor(int i=x1;i<=x2;i++)for(int j=y1;j<=y2;j++){\n\t\tif(s[i][j]!='*' && s[i][j]!=('0'+r)) return false;\n\t}\n\tfor(int i=x1;i<=x2;i++)for(int j=y1;j<=y2;j++){\n\t\ts[i][j]='*';\n\t}\n\treturn true;\n}\n\n   signed main(){\n   \t\n   \tint n;\n   cin>>n;\n   \t\n   \t\n   \tfor(int hj=0;hj<n;hj++){\n   \tint h,w;\n   \t\tcin>>h>>w;\n   \t\tmap<char,int>ma;\n   \t\tint x1[10],y1[10],x2[10],y2[10];\n   \t\tfor(int i=0;i<10;i++)x1[i]=100,y1[i]=100,x2[i]=-100,y2[i]=-100;\n   \t\t\n   \t\t\n   \t\tfor(int i=0;i<h;i++)cin>>s[i];\n   \t\tint cnt=1;\n   \t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n   \t\t\tif(s[i][j]=='.')continue;\n   \t\t\tif(ma.find(s[i][j])==ma.end()){\n   \t\t\t\tma[s[i][j]]=cnt;\n   \t\t\t\tcnt++;\n   \t\t\t}\n   \t\t\ts[i][j]='0'+ma[s[i][j]];\n   \t\t\t\n   \t\t}\n   \t\t//for(int i=0;i<h;i++)cout<<s[i]<<endl;\n   \t\t//\t\tcout<<endl;\n   \t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n   \t\t\tif(s[i][j]=='.')continue;\n   \t\t\tx1[s[i][j]-'0']=min(x1[s[i][j]-'0'],i);\n   \t\t\ty1[s[i][j]-'0']=min(y1[s[i][j]-'0'],j);\n   \t\t\tx2[s[i][j]-'0']=max(x2[s[i][j]-'0'],i);\n   \t\t\ty2[s[i][j]-'0']=max(y2[s[i][j]-'0'],j);\n   \t\t}\n   \t\tint memo[10]={0};\n   \t\tfor(int g=0;g<10;g++)for(int i=1;i<cnt;i++){\n   \t\t\tif(ch(i,x1[i],y1[i],x2[i],y2[i])){\n   \t\t\t\tmemo[i]=1;\n   \t\t//\t\tfor(int i=0;i<h;i++)cout<<s[i]<<endl;\n   \t\t//\t\tcout<<endl;\n   \t\t\t}\n   \t\t}\n   \t\tint ans=0;\n   \t\tfor(int i=1;i<cnt;i++)if(memo[i]==0)ans+=1;\n   \t\tif(ans>0)cout<<\"SUSPICIOUS\"<<endl;\n   \t\telse cout<<\"SAFE\"<<endl;\n   \t}\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i=a;i<n;i++)\n#define REP(i,n) rep(i,0,n)\n#define ALL(a) a.begin(), a.end()\nusing namespace std;\ntypedef long long ll;\n\nint n, w, h;\nchar field[100][100];\nbool ok[100][100];\nvector<char> vc;\n\nbool check(int y, int x, char c) {\n\tbool f = 1, s = 1;\n\tint posx = x, posy = y, wide = 0;\n\twhile(field[posy][posx]==c){\n\t\tif (s == 1) {\n\t\t\twhile (field[posy][posx] == c) {\n\t\t\t\twide++;\n\t\t\t\tposy++;\n\t\t\t}\n\t\t\ts = 0;\n\t\t}\n\t\telse {\n\t\t\tint co = 0;\n\t\t\twhile (field[posy][posx] == c ) {\n\t\t\t\tco++;\n\t\t\t\tposy++;\n\t\t\t}\n\t\t\tif (co != wide)f = 0;\n\t\t\twhile (ok[posy][posx]){\n\t\t\t\tposy++;\n\t\t\t\tco++;\n\t\t\t\tif (co == wide) {\n\t\t\t\t\tf = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tposy = y;\n\t\tposx++;\n\t}\n\tif (f == 0)return false;\n\trep(i, x, posx + 1) {\n\t\trep(j, y, posy + 1) {\n\t\t\tok[i][j] = 1;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tcin >> n;\n\tREP(q,n){\n\t\tbool F[10];\n\t\tfill(F, F + 10, 1);\n\t\tbool f = 1;\n\t\tcin >> h >> w;\n\t\tREP(i, h) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tREP(j, w) {\n\t\t\t\tfield[i][j] = s[j];\n\t\t\t\tif (field[i][j] != '.'\n\t\t\t\t\t&&find(ALL(vc), field[i][j]) == vc.end()) {\n\t\t\t\t\tvc.push_back(field[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint co = 0;\n\t\twhile(1){\n\t\t\tbool f2 = 0, nk = 0;\n\t\t\tREP(j, vc.size()) {\n\t\t\t\tif (F[j])break;\n\t\t\t\tif (j == vc.size() - 1)nk = 1;\n\t\t\t}\n\t\t\tif (nk)break;\n\t\t\tREP(j, h) {\n\t\t\t\tREP(k, w) {\n\t\t\t\t\tif (field[j][k] == vc[co]) {\n\t\t\t\t\t\tif (!check(j, k, vc[co]))f = 0;\n\t\t\t\t\t\t//else F[co] = 0;\n\t\t\t\t\t\tf2 = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (f2)break;\n\t\t\t\t}\n\t\t\t\tif (f2)break;\n\t\t\t}\n\t\t\tco++;\n\t\t\tif (co == vc.size())co = 0;\n\t\t}\n\t\tif (f)cout << \"SAFE\" << endl;\n\t\telse cout << \"SUSPICIOUS\" << endl;\n\t\tvc.clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\n#define ll long long\n#define lld long double\n#ifdef DEBUG\n#define line() cout << \"[\" << __LINE__ << \"] \";\n#define dump(i) cout << #i \": \" << i << \" \";\n#define dumpl(i) cout << #i \": \" << i << endl;\n#else\n#define ALL(x) x.begin(), x.end()\n#define line(i)\n#define dump(i)\n#define dumpl(i)\n#endif\nusing namespace std;\n\ninline int toInt(string s)\n{\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\nstruct xy\n{\n    int r, l, h, d;\n};\nint main()\n{\n    int n;\n    cin >> n;\n    int h, w;\n    rep(y, n)\n    {\n\n        cin >> h >> w;\n        string board[h];\n        rep(i, h)\n        {\n            cin >> board[i];\n        }\n        bool okflag = false;\n        rep(z, 8)\n        {\n            map<char, struct xy> mp;\n            map<char, bool> mp2;\n            rep(i, h)\n            {\n                rep(j, w)\n                {\n                    if (board[i][j] != '.' && board[i][j] != '*')\n                    {\n                        if (mp2[board[i][j]] == false)\n                        {\n                            mp[board[i][j]].r = -1;\n                            mp[board[i][j]].l = 50;\n                            mp[board[i][j]].h = 50;\n                            mp[board[i][j]].d = -1;\n                            mp2[board[i][j]] = true;\n                        }\n                        mp[board[i][j]].r = max(mp[board[i][j]].r, j);\n                        mp[board[i][j]].l = min(mp[board[i][j]].l, j);\n                        mp[board[i][j]].h = min(mp[board[i][j]].h, i);\n                        mp[board[i][j]].d = max(mp[board[i][j]].d, i);\n                    }\n                }\n            }\n            // cerr << mp.size() << endl;\n            if (mp.size() == 0)\n            {\n                okflag = true;\n            }\n\n            for (auto alph : mp)\n            {\n                bool flag = true;\n                rep(i, alph.second.h, alph.second.d + 1)\n                {\n                    rep(j, alph.second.l, alph.second.r + 1)\n                    {\n                        if (board[i][j] == alph.first || board[i][j] == '*')\n                            continue;\n                        else\n                            flag = false;\n                    }\n                }\n                // cout << 'h' << mp['W'].h << endl;\n                // cout << 'd' << mp['W'].d << endl;\n                // cout << 'r' << mp['W'].r << endl;\n                // cout << 'l' << mp['W'].l << endl;\n\n                if (flag)\n                {\n                    rep(i, alph.second.h, alph.second.d + 1)\n                    {\n                        rep(j, alph.second.l, alph.second.r + 1)\n                        {\n                            board[i][j] = '*';\n                        }\n                    }\n                    break;\n                }\n            }\n            mp.clear();\n            mp2.clear();\n        }\n        if (okflag)\n        {\n            cout << \"SAFE\" << endl;\n        }\n        else\n        {\n            cout << \"SUSPICIOUS\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<cmath>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef long long ll;\nset<string> cands;\nint n;\nint h,w;\nbool exist[30];\nstring board[55];\nbool completerec;\nbool alldot;\nstruct element\n{\n  element(){};\n  int minx,maxx,miny,maxy;\n  char al;\n  element(int _minx,int _maxx,int _miny,int _maxy,char _al)\n  {\n    minx=_minx;\n    maxx=_maxx;\n    miny=_miny;\n    maxy=_maxy;\n    al=_al;\n  }\n};\nint main()\n{\n  bool miss=false;\n  cin >> n;\n  for(int i=0;i<n;i++)\n    {\n      cin >> h>> w;\n      for(int j=0;j<h;j++)\n\t{\n\t  cin >> board[j];\n\t}\n      vector<element> mono;\n      memset(exist,false,sizeof(exist));\n      for(int j=0;j<26;j++)\n\t{\n\t  int minx=1000,maxx=-1,miny=1000,maxy=-1;\n\t  char al='A'+j;\n\t  for(int tate=0;tate<h;tate++)\n\t    {\n\t      for(int yoko=0;yoko<w;yoko++)\n\t\t{\n\t\t  if(board[tate][yoko]=='A'+j)\n\t\t    {\n\t\t      exist[j]=true;\n\t\t      minx=min(minx,yoko);\n\t\t      maxx=max(maxx,yoko);\n\t\t      miny=min(miny,tate);\n\t\t      maxy=max(maxy,tate);\n\t\t    }\n\t\t}\n\t    }\n\t  if(exist[j])\n\t    {\n\t      element item=element(minx,maxx,miny,maxy,al);\n\t      mono.push_back(item);\n\t    }\n\t}\n      bool next=false;\n      int eraseindex=-1;\n      for(int j=0;j<mono.size();j++)\n\t{\n\t  bool indot=false;\n\t  bool completerec=true;\n\t  for(int tate=mono[j].miny;tate<=mono[j].maxy;tate++)\n\t    {\n\t      for(int yoko=mono[j].minx;yoko<=mono[j].maxx;yoko++)\n\t\t{\n\t\t  if(board[tate][yoko]=='.')\n\t\t    {\n\t\t      indot=true;\n\t\t    }\n\t\t  else if(board[tate][yoko]!=mono[j].al)\n\t\t    {\n\t\t      completerec=false;\n\t\t    }\n\t\t}\n\t    }\n\t  if(completerec)\n\t    {\n\t      next=true;\n\t      for(int tate=mono[j].miny;tate<=mono[j].maxy;tate++)\n\t\t{\n\t\t  for(int yoko=mono[j].minx;yoko<=mono[j].maxx;yoko++)\n\t\t    {\n\t\t      if(board[tate][yoko]==mono[j].al)\n\t\t\t{\n\t\t\t  board[tate][yoko]='*';\n\t\t\t}\n\t\t    }\n\t\t}\n\t      eraseindex=j;\n\t    }\n\t  if(indot)\n\t    {\n\t      cout << \"SUSPICIOUS\" << endl;\n\t      miss=true;\n\t      break;\n\t    }\n\t}\n      if(miss) continue;\n      if(eraseindex!=-1) mono.erase(mono.begin()+eraseindex);\n      if(!next && mono.size()!=0)\n\t{\n\t  cout << \"SUSPICIOUS\" << endl;\n\t  continue;\n\t}\n      while(mono.size()!=0)\n\t{\n\t  bool onedestroy=false;\n\t  for(int j=0;j<mono.size();j++)\n\t    {\n\t      bool candestroy=true;\n\t      for(int tate=mono[j].miny;tate<=mono[j].maxy;tate++)\n\t\t{\n\t\t  for(int yoko=mono[j].minx;yoko<=mono[j].maxx;yoko++)\n\t\t    {\n\t\t      if(board[tate][yoko]!=mono[j].al && board[tate][yoko]!='*')\n\t\t\t{\n\t\t\t  candestroy=false;\n\t\t\t}\n\t\t    }\n\t\t}\n\t      if(candestroy)\n\t\t{\n\t\t  for(int tate=mono[j].miny;tate<=mono[j].maxy;tate++)\n\t\t    {\n\t\t      for(int yoko=mono[j].minx;yoko<=mono[j].maxx;yoko++)\n\t\t\t{\n\t\t\t  board[tate][yoko]='*';\t\t\t   \n\t\t\t}\n\t\t    }\n\t\t  mono.erase(mono.begin()+j);\n\t\t  onedestroy=true;\n\t\t}  \n\t    }\n\t  if(!onedestroy)\n\t    {\n\t      cout << \"SUSPICIOUS\" << endl;\n\t      miss=true;\n\t      break;\n\t    }\n\t}\n      bool notall=false;\n      for(int tate=0;tate<h;tate++)\n\t{\n\t  for(int yoko=0;yoko<w;yoko++)\n\t    {\n\t      if(board[tate][yoko]!='.' && board[tate][yoko]!='*')\n\t\t{\n\t\t  notall=true;\n\t\t}\n\t    }\n\t}\n      if(notall && !miss )\n\t{\n\t  cout << \"SUSPICIOUS\" << endl;\n\t  miss=true;\n\t}\n      else if(!miss) cout << \"SAFE\" << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nclass Point\n{\npublic:\n  int x, y;\n  Point(int xx = -1, int yy = -1)\n    :x(xx), y(yy) {}\n};\n\nclass Rect\n{\npublic:\n  char sign;\n  Point lu, rd;\n  Rect(char s, Point a, Point b)\n    :sign(s), lu(a), rd(b) {}\n};\n\nint main()\n{\n  int N;\n  cin >> N;\n  while (N--) {\n    int H, W;\n    cin >> H >> W;\n\n    vector<string> s(H);\n    for (int i = 0; i < H; ++i)\n      cin >> s[i];\n\n    set<char> alpha;\n    for (int i = 0; i < H; ++i) {\n      for (int j = 0; j < W; ++j) {\n\tif (s[i][j] != '.')\n\t  alpha.insert(s[i][j]);\n      }\n    }\n\n    \n    vector<Rect> rec;\n    for (set<char>::iterator it = alpha.begin(); it != alpha.end(); ++it) {\n      Point lu, rd;\n      // y\n      for (int y = 0; y < H; ++y) {\n\tfor (int x = 0; x < W; ++x) {\n\t  if (s[y][x] == (*it)) {\n\t    if (lu.y == -1)\n\t      lu.y = y;\n\t    rd.y = y;\n\t  }\n\t}\n      }\n\n      // x\n      for (int x = 0; x < W; ++x) {\n\tfor (int y = 0; y < H; ++y) {\n\t  if (s[y][x] == (*it)) {\n\t    if (lu.x == -1)\n\t      lu.x = x;\n\t    rd.x = x;\n\t  }\n\t}\n      }\n\n      rec.push_back(Rect(*it, lu, rd));\n    }\n\n    for ( ; ; ) {\n      bool op = false;\n\n      for (int i = 0; i < rec.size(); ++i) {\n\tbool ok = true, found = false;\n\tfor (int y = rec[i].lu.y; y <= rec[i].rd.y && ok; ++y) {\n\t  for (int x = rec[i].lu.x; x <= rec[i].rd.x; ++x) {\n\t    if (s[y][x] == rec[i].sign)\n\t      found = true;\n\t    if (s[y][x] != rec[i].sign && s[y][x] != '$') {\n\t      ok = false;\n\t      break;\n\t    }\n\t  }\n\t}\n\n\tif (ok && found) {\n\t  op = true;\n\t  for (int y = rec[i].lu.y; y <= rec[i].rd.y; ++y) {\n\t    for (int x = rec[i].lu.x; x <= rec[i].rd.x; ++x)\n\t      s[y][x] = '$';\n\t  }\n\t}\n      }\n\n      if (!op)\n\tbreak;\n    }\n    \n    bool safe = true;\n    for (int i = 0; i < H && safe; ++i) {\n      if (s[i].find_first_not_of(\"$.\", 0) != string::npos)\n\tsafe = false;\n    }\n\n    if (safe)\n      cout << \"SAFE\" << endl;\n    else\n      cout << \"SUSPICIOUS\" << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\ntypedef long long ll;\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define rep(i,m,n) for(int i = (m);i < (n);i++)\n#define P pair<int,int>\n#define pb push_back\n#define mk make_pair\nusing namespace std;\n#define Vec(a) vector <int> a\nconst int INF = 1 << 20;\nconst int MOD = 1e9+7;\n\n\n\n\n\nint main(){\n  int n;\n  cin >> n;\n\n  REP(i,n){\n\n    int h,w;\n    cin >> h >> w;\n    bool f[h][w] = {};\n    string s[h];\n    REP(i,h){\n      cin >> s[i];\n    }\n    vector <char> c;\n    REP(i,h){\n      REP(j,w){\n\tif(s[i][j] != '.'){\n\t  if(c.empty()){\n\t    c.pb(s[i][j]);\n\t  }\n\t  else{\n\t    bool t = false;\n\t    REP(k,c.size()){\n\t      if(c[k] == s[i][j]){\n\t\tt = true;\n\t      }\n\t    }\n\t    if(!t){\n\t      c.pb(s[i][j]);\n\t    }\n\t  }\n\t}\n\n      }\n    }\n    \n      REP(m,c.size()){\n\tbool b[h][w];\n\t\n\tint l = 100,d = -1,r = -1, u= 100;\n\tbool q[h][w] = {};\n\tREP(j,h){\n\t  REP(k,w){\n\t    if(s[j][k] == c[m]){\n\t      l = min(k,l);\n\t      r = max(k,r);\n\t      d = max(j,d);\n\t      u = min(j,u);\n\t      q[j][k] = true;\n\t    }\n\t    \n\t    \n\t  }\n\t}\n      \n      bool v = true;\n      rep(j,u,d+1){\n\trep(k,l,r+1){\n\t  if(!q[j][k] && !f[j][k]){\n\t    v = false;\n\t  }\n\t}\n      }\n      //cout << u << \"    \" << d << \"   \" << l << \"    \" << r << endl;\n      if(v){\n\tc.erase(c.begin()+m);\n\tm = -1;\n\trep(j,u,d+1){\n\t  rep(k,l,r+1){\n\t    f[j][k] = true;\n\t  }\n\t}\n      }\n      \n    }\n      /*\n    REP(m,h){\n      REP(j,w){\n\tcout << f[m][j] << \"  \"; \n      }\n      cout << endl;\n      }*/\n    bool rr = true;\n    REP(m,h){\n      REP(mm,w){\n\tif(s[m][mm] != '.' && !f[m][mm]){\n\t  rr = false;\n\t}\n\t\n\t\n      }\n    }\n    if(rr){\n      cout << \"SAFE\" << endl;\n    }\n    else{\n      cout << \"SUSPICIOUS\" << endl;\n    }\n\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\n\nconst int INF = 1e9;\n\nstruct R {\n    int h1, w1, h2, w2;\n    R() : h1(INF), w1(INF), h2(-INF), w2(-INF) {}\n    void update(int h, int w) {\n        h1 = min(h1, h);\n        w1 = min(w1, w);\n        h2 = max(h2, h);\n        w2 = max(w2, w);\n    }\n    void print() {\n        cout << h1 << \" \" << w1 << \" \" << h2 << \" \" << w2 << endl;\n    }\n};\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int T;\n    cin >> T;\n    rep(testcase, T) {\n        // cout << endl;\n        // cout << \"case \" << testcase << \":\" << endl;\n\n        int H, W;\n        cin >> H >> W;\n        vector<string> s(H);\n        set<char> itemset;\n        rep(i, H) {\n            cin >> s[i];\n            rep(j, W) {\n                if (s[i][j] != '.') {\n                    itemset.insert(s[i][j]);\n                }\n            }\n        }\n\n        // rep(i, H) cout << s[i] << endl;\n        // cout << endl;\n\n        if (itemset.empty()) {\n            cout << \"SAFE\" << endl;\n            continue;\n        }\n\n        map<char, R> mprect;\n        for (auto c : itemset) {\n            R r;\n            rep(i, H) rep(j, W) {\n                if (s[i][j] == c) {\n                    r.update(i, j);\n                }\n            }\n            mprect[c] = r;\n        }\n\n        // for (auto p : mprect) {\n        //     cout << p.first << \":\";\n        //     p.second.print();\n        // }\n\n        vector<char> items(all(itemset));\n\n        auto check = [&]{\n            sort(all(items));\n            do {\n                vector<string> t(H, string(W, '.'));\n\n                for (auto c : items) {\n                    auto r = mprect[c];\n                    rep2(i, r.h1, r.h2 + 1) rep2(j, r.w1, r.w2 + 1) {\n                        t[i][j] = c;\n                    }\n                }\n\n                // rep(i, H) cout << t[i] << endl;\n                // cout << endl;\n\n                if (s == t) {\n                    cout << \"SAFE\" << endl;\n                    return true;\n                }\n            } while (next_permutation(all(items)));\n            return false;\n        };\n\n        if (!check()) {\n            cout << \"SUSPICIOUS\" << endl;\n        }\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#define rep(i,j) for(int i=0;i<j;i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define ms(i,j) memset(i,j,sizeof(i))\nusing namespace std;\nint n,h,w;\nchar m[50][51];\nint main(){\n    scanf(\"%d\",&n);\n    while(n--){\n        scanf(\"%d%d\",&h,&w);\n        bool a=true;\n            int t[26],l[26],r[26]={0},b[26]={0};\n            rep(i,26)t[i]=l[i]=55;\n            bool f[26][26];\n            ms(f,0);\n        rep(i,h){\n            scanf(\"%s\",m[i]);\n            rep(j,w)if(m[i][j]!='.'){\n                char c=m[i][j]-'A';\n                f[c][c]=true;\n                t[c]=min(t[c],i);\n                l[c]=min(l[c],j);\n                r[c]=max(r[c],j);\n                b[c]=max(b[c],i);\n            }\n        }\n        bool rf=false;\n        bool hoge=true;\n        rep(i,26)if(f[i][i]){\n            hoge=false;\n            reps(j,t[i],b[i])reps(k,l[i],r[i]){\n                if(m[j][k]!=i+'A'){\n                    if(m[j][k]=='.')a=false;\n                    else f[i][m[j][k]-'A']=true;\n                }\n            }\n            int cnt=0;\n            rep(j,26)cnt+=f[i][j];\n            if(cnt==1)rf=true;\n            printf(\"%c %d %d %d %d %d\\n\",i+'A',t[i],l[i],r[i],b[i],cnt);\n        }\n\n        puts(a&&(rf||hoge)?\"SAFE\":\"SUSPICIOUS\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <string>\n#include <cmath>\n#include <map>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int inf = 100100100;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int number;\n  cin >> number;\n  rep(aaaaaaa,number){\n      int h,w;\n      bool flag =true;\n      cin >> h >> w;\n      string s[55]={};\n      map<char,bool> m;\n      m['.'] = false;\n      rep(y,h){\n          cin >> s[y];\n      }\n      rep(y,h)rep(x,w){\n          if(s[y][x]!='.'){\n              if(m[s[y][x]]){\n                  flag = false;\n                  x=w;y=h;break;\n              }\n              int st = x;\n              char tc = s[y][x];\n              m[tc] = true;\n              while(s[y][x]==tc) x++;\n              int et = x;\n              int yy = y;\n              while(yy<h && s[yy][st]==tc){\n                  REP(xx,st,et) {\n                      if(s[yy][xx]!=tc){flag=false;}\n                      s[yy][xx]='.';\n                  }\n                  yy+=1;\n              }\n              // rep(ya,h) cout << s[ya] << endl;\n              x--;\n          }\n      }\n      rep(y,h)rep(x,w){\n         if(s[y][x]!='.') flag = false;\n      }\n      if(flag) cout << \"SAFE\" << endl;\n      else cout << \"SUSPICIOUS\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nstruct make\n{\n\tchar str;\n\tint posi,start[2];\n\tint high,wide,JUDGE;//JUDGE==1で長方形,==0で長方形以外,==2で未定\n\tstruct make *front;\n};\n\n\nint main()\n{\n\tint N,H,W,count,COUNT,judge,no_rect,NO_RECT;\n\tchar img[1000][51],RECT[8];\n\tstruct make M[8];\n\tint s1,s2,num;\n\t\n\tscanf(\"%d\",&N);//データの個数\n\tfor(int a=0;a<N;a++)\n\t{\n\t\tcount=0;//材質の個数\n\t\tCOUNT=0;\n\t\tNO_RECT=0;\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tscanf(\"%s\",img[b]);\n\t\t\timg[b][W]='\\0';\n\t\t}\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tfor(int d=0;d<count;d++) M[d].posi=-1;\n\t\t\tfor(int c=0;c<W;c++)\n\t\t\t{\n\t\t\t\tif(img[b][c]!='.')\n\t\t\t\t{\n\t\t\t\t\t//材質判定\n\t\t\t\t\tjudge=0;\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t\tif(count>0 && img[b][c]!=M[judge].str) judge++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}while(judge<count);\n\t\t\t\t\t//新しい材質の場合\n\t\t\t\t\tif(judge==count)\n\t\t\t\t\t{\n\t\t\t\t\t\tM[count].str=img[b][c];\n\t\t\t\t\t\tM[count].start[0]=b;\n\t\t\t\t\t\tM[count].start[1]=c;\n\t\t\t\t\t\tM[count].posi=c;\n\t\t\t\t\t\tM[count].high=1;\n\t\t\t\t\t\tM[count].wide=1;\n\t\t\t\t\t\tM[count].JUDGE=0;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\t//既出の材質の場合\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(M[judge].start[1]>c) M[judge].start[1]=c;\n\t\t\t\t\t\tif(M[judge].posi<0) M[judge].posi=c;\n\t\t\t\t\t\telse if(M[judge].wide<c-M[judge].posi+1) M[judge].wide=c-M[judge].posi+1;\n\t\t\t\t\t\tM[judge].high=b-M[judge].start[0]+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tno_rect=count;\n\t\t//printf(\"count=%d\\n\",count);\n\t\t//判定開始\n\t\twhile(count)//文字アリ\n\t\t{\n\t\t\tCOUNT=0;\n\t\t\t//見えている部分が長方形かどうか判定\n\t\t\tfor(num=0;num<count;num++)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(M[num].JUDGE==1) continue;\n\t\t\t\tM[num].JUDGE=0;//長方形なら\n\t\t\t\t//printf(\"M[%d].str=%c\\nM[%d].high=%d\\nM[%d].wide=%d\\n\",num,M[num].str,num,M[num].high,num,M[num].wide);\n\t\t\t\t//printf(\"M[%d].start[0]=%d\\nM[%d].start[1]=%d\\n\",num,M[num].start[0],num,M[num].start[1]);\n\t\t\t\tfor(s1=0;s1<M[num].high;s1++)\n\t\t\t\t{\n\t\t\t\t\tfor(s2=0;s2<M[num].wide;s2++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//確実に長方形ではない場合\n\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]=='.')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNO_RECT=1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//長方形の可能性もある場合\n\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]!=M[num].str)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int r=0;r<count-no_rect;)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]==RECT[r]) break;\n\t\t\t\t\t\t\t\tr++;\n\t\t\t\t\t\t\t\tif(r==count-no_rect)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tM[num].JUDGE=2;\n\t\t\t\t\t\t\t\t\tCOUNT++;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(NO_RECT || M[num].JUDGE==2) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(NO_RECT || M[num].JUDGE==2) break;\n\t\t\t\t}\n\t\t\t\tif(NO_RECT) break;\n\t\t\t\t//長方形だった場合\n\t\t\t\tif(s1==M[num].high && s2==M[num].wide)\n\t\t\t\t{\n\t\t\t\t\tM[num].JUDGE=1;\n\t\t\t\t\tno_rect--;\n\t\t\t\t\tM[num].front=NULL;\n\t\t\t\t\tRECT[num]=M[num].str;\n\t\t\t\t}\n\t\t\t\t//printf(\"M[%d].JUDGE=%d\\n\\n\",num,M[num].JUDGE);\n\t\t\t}\n\t\t\tfor(int n=0;n<num;)\n\t\t\t{\n\t\t\t\tif(M[num].JUDGE!=2 && M[num].JUDGE!=1) break;\n\t\t\t\tn++;\n\t\t\t\t//どれも長方形ではなかった場合\n\t\t\t\tif(n==num) NO_RECT=1;\n\t\t\t}\n\t\t\t\n\t\t\t//printf(\"NO_RECT=%d\\n\",NO_RECT);\n\t\t\tif(NO_RECT==1) break;\n\t\t\t//printf(\"#no_rect=%d\\n\\n\\n\",no_rect);\n\t\t\t//すべて長方形\n\t\t\tif(no_rect==0) break;\n\t\t}\n\t\t//出力\n\t\tif(NO_RECT) printf(\"SUSPICIOUS1\\n\");\n\t\telse if(no_rect) printf(\"SUSPICIOUS2\\n\");\n\t\telse printf(\"SAFE1\\n\");\n\t}\n\t\n\treturn 0;\n}\n//printf(\"#1\");\n//printf(\"M[%d].str=%c\\nM[%d].high=%d\\nM[%d].wide=%d\\n\",num,M[num].str,num,M[num].high,num,M[num].wide);\n//printf(\"M[%d].start[0]=%d\\nM[%d].start[1]=%d\\n\\n\",num,M[num].start[0],num,M[num].start[1]);\n//printf(\"M[%d].JUDGE=%d\\n\\n\",num,M[num].JUDGE);\n//printf(\"s1=%d s2=%d\\n\",s1,s2);\n//printf(\"#no_rect=%d\\n\\n\\n\",no_rect);\n//printf(\"#s1=%d\\n#s2=%d\\n\",s1,s2);\n/*\n1\n10 10\n..........\n.DDDDDD...\n.DDDDCCC..\n.DDDDCCC..\nADDDDCCC..\nAAA..CCC..\nAAABBBBC..\nAAABBBB...\n..BBBBB...\n..........\n*/\n/*\n1\n10 10\n..........\n.DDDDCCC..\n.DDDDCCC..\n.DDDDCCC..\nADDDDCCC..\nAAA..CCC..\nAAABBBBC..\nAAABBBB...\n..BBBBB...\n..........\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int MAX_S = 51;\nconst int dx[4] = {1,0,-1,0};\nconst int dy[4] = {0,1,0,-1};\nint H, W;\nchar G[MAX_S][MAX_S];\nbool vis[MAX_S][MAX_S];\n\npair<P, P> rec(int x, int y, char c) {\n  vis[y][x] = true;\n  pair<P, P> p = make_pair(P(x, y), P(x, y));\n  for(int i = 0; i < 4; ++i) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(nx < 0 || nx >= W) continue;\n    if(ny < 0 || ny >= H) continue;\n    if(vis[ny][nx]) continue;\n    if(G[ny][nx] != c) continue;\n    pair<P, P> q = rec(nx, ny, c);\n    p.first.first = min(p.first.first, q.first.first);\n    p.first.second = min(p.first.second, q.first.second);\n    p.second.first = max(p.second.first, q.second.first);\n    p.second.second = max(p.second.second, q.second.second);\n  }\n  return p;\n}\n\nbool isShikaku(int sx, int sy, int ex, int ey) {\n  char c = 0;\n  for(int i = sy; i <= ey; ++i) {\n    for(int j = sx; j <= ex; ++j) {\n      if(G[i][j] == '.') return false;\n      if(c == 0) {\n\tif(G[i][j] != '#') c = G[i][j];\n      } else if(G[i][j] != c && G[i][j] != '#') {\n\treturn false;\n      }\n    }\n  }\n  return true;\n}\n\nvoid fills(int sx, int sy, int ex, int ey) {\n  for(int i = sy; i <= ey; ++i) {\n    for(int j = sx; j <= ex; ++j) {\n      G[i][j] = '#';\n    }\n  }\n}\n\nvoid show() {\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      cout << G[i][j];\n    }\n    cout << endl;\n  }\n}\n\nbool judge() {\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if(G[i][j] != '.' && G[i][j] != '#') return false;\n    }\n  }\n  return true;\n}\n\nvoid make(vector<pair<P, P> >&v) {\n  for(int i = 0; i < H; ++i) {\n    fill(vis[i], vis[i]+W, false);\n  }\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if(!vis[i][j] && G[i][j] != '.') {\n\tpair<P, P> p = rec(j, i, G[i][j]);\n\tv.push_back(p);\n      }\n    }\n  }\n}\n\nbool ans() {\n  vector<pair<P, P> > v;\n  make(v);\n  while(true) {\n    bool flag = true;\n    for(vector<pair<P, P> >::iterator it = v.begin(); it != v.end(); ++it) {\n      pair<P, P> &p = *it;\n      if(isShikaku(p.first.first, p.first.second,\n\t\t   p.second.first, p.second.second)) {\n\n\tfills(p.first.first, p.first.second,\n\t      p.second.first, p.second.second);\n\tv.erase(it);\n\tflag = false;\n\tbreak;\n      }\n    }\n    if(flag) return judge();\n    /*\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tif(!vis[i][j] && G[i][j] != '.' && G[i][j] != '#') {\n\t  p = rec(j, i, G[i][j]);\n\t  if(isShikaku(p.first.first, p.first.second,\n\t\t       p.second.first, p.second.second, G[i][j])) {\n\t    fills(p.first.first, p.first.second,\n\t\t  p.second.first, p.second.second);\n\t    i = j = MAX_S*2;\n\t    flag = false;\n\t  }\n\t}\n      }\n      }*/\n  }\n}\n\n\nint main() {\n  int T;\n  cin >> T;\n  while(T--) {\n    cin >> H >> W;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tcin >> G[i][j];\n      }\n    }\n    if(ans()) cout << \"SAFE\" << endl;\n    else cout << \"SUSPICIOUS\" << endl;\n    //show();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\nint main(){\n    int n,w,h;\n    cin>>n;\n    while(n--){\n        cin>>h>>w;\n        char bo[51][51];\n        int dis[26][26];\n        int ma[27][4];\n        for(int i=0;i<26;i++){\n            ma[i][0]=51;\n            ma[i][1]=51;\n            ma[i][2]=0;\n            ma[i][3]=0;\n        }\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin>>bo[i][j];\n                if(bo[i][j]=='.')continue;\n                ma[bo[i][j]-'A'][0]=min(ma[bo[i][j]-'A'][0],j);\n                ma[bo[i][j]-'A'][1]=min(ma[bo[i][j]-'A'][1],i);\n                ma[bo[i][j]-'A'][2]=max(ma[bo[i][j]-'A'][2],j);\n                ma[bo[i][j]-'A'][3]=max(ma[bo[i][j]-'A'][3],i);\n            }\n        }\n        memset(dis,0,sizeof(dis));\n        for(int k=0;k<26;k++){\n            for(int i=ma[k][0];i<=ma[k][2];i++){\n                for(int j=ma[k][1];j<=ma[k][3];j++){\n                    if(bo[j][i]=='.'){\n                        cout<<\"SUSPICIOUS\"<<endl;\n                        goto next;\n                    }\n                    if(bo[j][i]-'A'!=k)\n                        dis[k][bo[j][i]-'A']=-1;\n                }\n            }\n        }\n        for(int k=0;k<26;k++)\n            for(int i=0;i<26;i++)\n                for(int j=0;j<26;j++)\n                    if(dis[i][k]<0&&dis[k][j]<0)\n                        dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);\n        for(int i=0;i<26;i++)\n            if(dis[i][i]<0){\n                cout<<\"SUSPICIOUS\"<<endl;\n                goto next;\n            }\n        cout<<\"SAFE\"<<endl;\n    next:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint h, w;\nchar field[100][100];\nbool visit[100][100];\nbool dfsvisit[50];\nbool charvisit[200];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\nset<int> edges[50];\n\nbool dfs(int where, int from) {\n  if (where == from && dfsvisit[where]) { return false; }\n  if (dfsvisit[where]) { return true; }\n  dfsvisit[where] = true;\n  FORIT(it, edges[where]) {\n    if (!dfs(*it, from)) { return false; }\n  }\n  return true;\n}\n\nint main() {\n  int test;\n  scanf(\"%d\", &test);\n  while (test--) {\n    REP(i, 50) { edges[i].clear(); }\n    scanf(\"%d %d\", &h, &w);\n    MEMSET(charvisit, false);\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n    }\n    REP(iniy, h) {\n      REP(inix, w) {\n        if (field[iniy][inix] == '.') { continue; }\n        if (charvisit[(int)field[iniy][inix]]) { continue; }\n        charvisit[(int)field[iniy][inix]] = true;\n        MEMSET(visit, false);\n        queue<pair<int, int> > que;\n        que.push(make_pair(inix, iniy));\n        int minx = inix;\n        int miny = iniy;\n        int maxx = inix;\n        int maxy = iniy;\n        while (!que.empty()) {\n          int x = que.front().first;\n          int y = que.front().second;\n          que.pop();\n          if (visit[y][x]) { continue; }\n          visit[y][x] = true;\n          if (field[y][x] == field[iniy][inix]) {\n            minx = min(minx, x);\n            miny = min(miny, y);\n            maxx = max(maxx, x);\n            maxy = max(maxy, y);\n          }\n          REP(i, 4) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (nx < 0 || nx >= w || ny < 0 || ny >= h) { continue; }\n            que.push(make_pair(nx, ny));\n          }\n        }\n        FOREQ(ny, miny, maxy) FOREQ(nx, minx, maxx) {\n          if (field[ny][nx] == '.') {\n            puts(\"SUSPICIOUS\");\n            goto next;\n          } else if (field[ny][nx] != field[iniy][inix]) {\n            edges[(int)field[iniy][inix] - 'A'].insert(field[ny][nx] - 'A');\n          }\n        }\n      }\n    }\n    REP(i, 50) {\n      MEMSET(dfsvisit, false);\n      if (!dfs(i, i)) {\n        puts(\"SUSPICIOUS\");\n        goto next;\n      }\n    }\n    puts(\"SAFE\");\nnext:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<set>\n#include<map>\n#include<string>\n#include<cctype>\n\n#define N 64\nusing namespace std;\n\nbool isrectangle(char c, map<char,int> &s, map<char, set<char> > &cont)\n{\n  set<char>::iterator its = cont[c].begin();\n  while(its!=cont[c].end()){\n    if( *its == '.' ) return false;\n    if( s[c] < s[*its] ) return false;\n    ++its;\n  }\n  return true;\n}\n\nint main(){\n  int T;\n  cin >> T;\n  for(int tc=1;tc<=T;++tc){\n    int h,w;\n    bool suspicious=true;\n    map<char,int> s;\n    map<char,set<char> > cont;\n    char M[N][N];\n    vector<int> x;\n    cin >> h >> w;\n\n    for(int i = 0; i < h; ++i){\n      for(int j = 0; j < w; ++j){\n\tcin >> M[i][j];\n\tif(isalpha(M[i][j])){\n\t  s[M[i][j]]=0;\n\t}\n      }\n    }\n    \n    for(int i = 0; i < s.size(); ++i){\n      x.push_back( i );\n    }\n    \n    map<char,int>::iterator itm = s.begin();\n    while(itm!=s.end()){\n      int mini=N,maxi=-1,minj=N,maxj=-1;\n      for(int i = 0; i < h; ++i){\n\tfor(int j = 0; j < w; ++j){\n\t  if( M[i][j] == itm->first ){\n\t    mini = min( mini, i );\n\t    maxi = max( maxi, i );\n\t    minj = min( minj, j );\n\t    maxj = max( maxj, j );\n\t  }\n\t}\n      }\n      for(int i = mini; i <= maxi; ++i){\n\tfor(int j = minj; j <= maxj; ++j){\n\t  if( M[i][j] != itm->first ){\n\t    cont[ itm->first ].insert( M[i][j] );\n\t  }\n\t}\n      }\n      ++itm;\n    }\n    \n    do{\n      bool ok=true;\n      map<char,int>::iterator its = s.begin();\n      for(int i = 0; i < s.size(); ++i){\n\tits->second = x[i];\n\t++its;\n      }\n      for(its = s.begin(); its != s.end(); ++its){\n\tif( !isrectangle( its->first, s, cont ) ){\n\t  ok=false;\n\t}\n      }\n      if(ok){\n\tsuspicious = false;\n      }\n    }while(next_permutation(x.begin(),x.end()));\n\n    if( suspicious ){\n      cout << \"SUSPICIOUS\";\n    }else{\n      cout << \"SAFE\";\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<set>\nusing namespace std;\n#define REP(i, a, n) for(int i=a; i<n; i++)\n#define RREP(i, a, n) for(int i=n-1; i>=a; i--)\n\nstruct St {\n\tint xmin, xmax, ymin, ymax;\n\tSt() :xmin(100), xmax(-100), ymin(100), ymax(-100) {}\n\n\tvoid check(int h, int w) {\n\t\txmin = min(xmin, w);\n\t\txmax = max(xmax, w);\n\t\tymin = min(ymin, h);\n\t\tymax = max(ymax, h);\n\t}\n};\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tREP(k, 0, N) {\n\t\tint H, W;\n\t\tcin >> H >> W;\n\n\t\tvector< vector<char> > mater(H, vector<char>(W));\n\t\tset<char> c;\n\t\tmap<char, St> rect;\n\t\tREP(i, 0, H) REP(j, 0, W) {\n\t\t\tcin >> mater[i][j];\n\t\t\tif (mater[i][j] != '.') c.insert(mater[i][j]);\n\t\t}\n\t\tif (c.empty()) {\n\t\t\tcout << \"SAFE\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvector<char> nc;\n\t\tfor (auto itr : c) {\n\t\t\tnc.push_back(itr);\n\t\t}\n\t\t\n\t\tfor(auto itr : nc){\n\t\t\tSt state;\n\t\t\tREP(i, 0, H) {\n\t\t\t\tREP(j, 0, W) {\n\t\t\t\t\tif (mater[i][j] == itr) {\n\t\t\t\t\t\tstate.check(i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trect[itr] = state;\n\t\t}\n\t\t\n\t\tbool safe_flag = false;\n\t\tdo {\n\t\t\tvector< vector<char> > nmater(H, vector<char>(W, '.'));\n\t\t\tfor (auto itr : nc) {\n\t\t\t\tREP(i, rect[itr].ymin, rect[itr].ymax + 1) {\n\t\t\t\t\tREP(j, rect[itr].xmin, rect[itr].xmax + 1) {\n\t\t\t\t\t\tnmater[i][j] = itr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nmater == mater) {\n\t\t\t\tsafe_flag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (next_permutation(nc.begin(), nc.end()));\n\t\t\n\t\tif (safe_flag) cout << \"SAFE\" << endl;\n\t\telse cout << \"SUSPICIOUS\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=2000003,INF=1<<30;\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int Q;cin>>Q;\n    while(Q--){\n        int H,W;cin>>H>>W;\n        vector<string> S(H);\n        for(int i=0;i<H;i++) cin>>S[i];\n        \n        vector<int> le(26,INF),ri(26,-INF),up(26,INF),lo(26,-INF);\n        \n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if(S[i][j]=='.') continue;\n                int c=int(S[i][j]-'A');\n                \n                le[c]=min(le[c],j);\n                ri[c]=max(ri[c],j);\n                up[c]=min(up[c],i);\n                lo[c]=max(lo[c],i);\n            }\n        }\n        \n        vector<int> use;\n        \n        for(int i=0;i<26;i++) if(le[i]!=INF) use.push_back(i);\n        \n        bool ok=false;\n        do{\n            \n            vector<vector<char>> T(H,vector<char>(W,'.'));\n            \n            for(int q=0;q<use.size();q++){\n                int k=use[q];\n                \n                for(int i=up[k];i<=lo[k];i++){\n                    for(int j=le[k];j<=ri[k];j++){\n                        T[i][j]=char('A'+k);\n                    }\n                }\n            }\n            \n            ok=true;\n            \n            for(int i=0;i<H;i++){\n                for(int j=0;j<W;j++){\n                    if(S[i][j]!=T[i][j]) ok=false;\n                }\n            }\n            \n            if(ok) break;\n            \n        }while(next_permutation(all(use)));\n        \n        if(ok) cout<<\"SAFE\"<<endl;\n        else cout<<\"SUSPICIOUS\"<<endl;\n        \n    }\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N,H,W;\nint visited[26] = {};\nchar F[51][51];\n\nbool dfs(int n,vector<vector<int>>& v){\n    visited[n] = -1;\n    bool ok = true;\n    for(auto x:v[n]){\n        if(visited[x]==0) ok = (ok & dfs(x,v));\n        if(visited[x]==-1) return false;\n    }\n    visited[n] = 1;\n    return ok;\n}\n\nint main(){\n    cin >> N;\n    for(int t=0;t<N;t++){\n        cin >> H >> W;\n        bool ok = true;\n        map<char,int> mi_x,mi_y,ma_x,ma_y;\n        vector<char> a;\n        vector<vector<int>> v(26);\n        for(int i=1;i<=H;i++){\n            for(int j=1;j<=W;j++){\n                cin >> F[i][j];\n                if(F[i][j]!='.'){\n                    if(!mi_x.count(F[i][j])){\n                        mi_x[F[i][j]] = i; a.push_back(F[i][j]);\n                    }else mi_x[F[i][j]] = min(mi_x[F[i][j]],i);\n                    if(!ma_x.count(F[i][j])) ma_x[F[i][j]] = i;\n                    else ma_x[F[i][j]] = max(ma_x[F[i][j]],i);\n                    if(!mi_y.count(F[i][j])) mi_y[F[i][j]] = j;\n                    else mi_y[F[i][j]] = min(mi_y[F[i][j]],j);\n                    if(!ma_y.count(F[i][j])) ma_y[F[i][j]] = j;\n                    else ma_y[F[i][j]] = max(ma_y[F[i][j]],j);\n                }\n            }\n        }\n        int n = v.size();\n        for(auto x:a){\n            for(int r=mi_x[x];r<=ma_x[x];r++){\n                for(int c=mi_y[x];c<=ma_y[x];c++){\n                    if(F[r][c]=='.') ok = false;\n                    else if(F[r][c]!=x){\n                        v[x-'A'].push_back(F[r][c]-'A');\n                    }\n                }\n            }\n        }\n        for(int i=0;i<26;i++){\n            for(int j=0;j<26;j++) visited[j] = 0;\n            if(!dfs(i,v)) ok = false;\n        }\n        cout << (ok? \"SAFE\":\"SUSPICIOUS\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#define all(c) c.begin(),c.end()\n#define uni(c) c.erase(unique(all(c)),c.end())\n#define pb push_back\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint h,w;\nvector<char> c;\nmap<char,PP> mp;\nbool ret(vector<string> s,int bit,int now){\n\tPP p=mp[c[now]];\n\tfor(int i=p.first.first;i<=p.first.second;i++){\n\t\tfor(int j=p.second.first;j<=p.second.second;j++){\n\t\t\tif(s[i][j]==c[now]||s[i][j]=='*'){\n\t\t\t\ts[i][j]='*';\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tif(bit==(1<<c.size())-1)\n\t\treturn true;\n\t\n\tfor(int i=0;i<c.size();i++){\n\t\tif(!((1<<i)&bit)&&ret(s,bit|(1<<i),i))\n\t\treturn true;\n\t}\n\treturn false;\n\t\n}\nint main(){\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\tcin>>h>>w;\n\t\tvector<string> s(h);\n\t\tc.clear();\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>s[i];\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(find(all(c),s[i][j])==c.end()){\n\t\t\t\t\tc.pb(s[i][j]);\n\t\t\t\t\tmp[s[i][j]]=PP(P(i,i),P(j,j));\n\t\t\t\t}else{\n\t\t\t\t\tmp[s[i][j]]=PP(P(min(i,mp[s[i][j]].first.first),max(i,mp[s[i][j]].first.second)),P(min(j,mp[s[i][j]].second.first),max(j,mp[s[i][j]].second.second)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(all(c));\n\t\tbool flag=false;\n\t\tfor(int i=0;i<c.size();i++){\n\t\t\tif(ret(s,1<<i,i)){\n\t\t\t\tcout<<\"SAFE\"<<endl;\n\t\t\t\tflag=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag)\n\t\tcout<<\"SUSPICIOUS\"<<endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define MAX_N 60\n#define MAX_C 26\n\nint H,W,N;\nint s[MAX_C];\nint t[MAX_C];\nint x[MAX_N][MAX_N];\nint y[MAX_N][MAX_N];\nint p[MAX_C][MAX_N][MAX_N];\nchar V[MAX_C+1]=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nchar c;\n\nvoid _memset(){\n\tfor(int i=0;i<MAX_C;i++){\n\t\ts[i]=0;\n\t\tt[i]=0;\n\t}\n\tfor(int i=0;i<MAX_N;i++){\n\t\tfor(int j=0;j<MAX_N;j++){\n\t\t\tx[i][j]=MAX_C;\n\t\t\ty[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<MAX_N;i++){\n\t\tfor(int j=0;j<MAX_N;j++){\n\t\t\tfor(int k=0;k<MAX_C;k++){\n\t\t\t\tp[k][i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tcin>>N;\n\tfor(int times=0;times<N;times++){\n\t\t_memset();\n\t\tcin>>H>>W;\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\tcin>>c;\n\t\t\t\tfor(int k=0;k<MAX_C;k++){\n\t\t\t\t\tif(V[k]==c){\n\t\t\t\t\t\tx[i][j]=k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\tif(x[i][j]<MAX_C){\n\t\t\t\t\tp[x[i][j]][i][j]+=1;\n\t\t\t\t\ts[x[i][j]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<MAX_C;i++){\n\t\t\tfor(int j=1;j<=H;j++){\n\t\t\t\tfor(int k=1;k<=W;k++){\n\t\t\t\t\tp[i][j][k]+=p[i][j][k-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<MAX_C;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\tfor(int k=1;k<=H;k++){\n\t\t\t\t\tp[i][j][k]+=p[i][j-1][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\tif(x[i][j]<MAX_C){\n\t\t\t\t\ty[i][j]+=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\ty[i][j]+=y[i][j-1];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=W;i++){\n\t\t\tfor(int j=1;j<=H;j++){\n\t\t\t\ty[i][j]+=y[i-1][j];\n\t\t\t}\n\t\t}\n\t\tint cnt1=0;\n\t\tfor(int i=0;i<MAX_C;i++){\n\t\t\tcnt1+=s[i];\n\t\t}\n\t\tif(cnt1==0){\n\t\t\tfor(int i=0;i<MAX_C;i++){\n\t\t\t\tt[i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tfor(int k=i+1;k<=H;k++){\n\t\t\t\t\tfor(int l=j+1;l<=W;l++){\n\t\t\t\t\t\tint menseki=(k-i)*(l-j);\n\t\t\t\t\t\tint kuro=y[i][j]+y[k][l]-y[i][l]-y[k][j];\n\t\t\t\t\t\tif(kuro==menseki){\n\t\t\t\t\t\t\tfor(int m=0;m<26;m++){\n\t\t\t\t\t\t\t\tint menseki2=p[m][i][j]+p[m][k][l]-p[m][i][l]-p[m][k][j];\n\t\t\t\t\t\t\t\tif(menseki2==s[m]){\n\t\t\t\t\t\t\t\t\tt[m]=1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt2=0;\n\t\tfor(int i=0;i<MAX_C;i++){\n\t\t\tcnt2+=t[i];\n\t\t}\n\t\tif(cnt2==MAX_C){\n\t\t\tcout<<\"SAFE\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<\"SUSPICIOUS\"<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nbool check(int minx,int miny,int maxx,int maxy,int key,vector<vector<char>>& masu){\n    for(int i = minx; i <= maxx; i++){\n        for(int j = miny; j <= maxy;j++){\n            if(masu[i][j] == '*' || masu[i][j] == key) continue;\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid Fill(int minx,int miny,int maxx,int maxy,vector<vector<char>>& masu){\n    for(int i = minx; i <= maxx; i++){\n        for(int j = miny; j <= maxy;j++){\n            masu[i][j] = '*';\n        }\n    }\n}\n\nstring solve(){\n    ll H,W; cin >> H >> W;\n    vector<vector<char>> masu(H,vector<char>(W));\n    for(int i = 0; i < H;i++){\n        for(int j = 0; j < W;j++){\n            cin >> masu[i][j];\n        }\n    }\n    vector<pair<pii,pii>> X(26,{{INF,INF},{-INF,-INF}});\n    for(int i = 0; i < H;i++){\n        for(int j = 0; j < W;j++){\n            if(masu[i][j] == '.') continue;\n            masu[i][j] -= 'A';\n            pair<pii,pii>& piiii = X[masu[i][j]];\n            piiii.first.first = min(piiii.first.first,i);\n            piiii.first.second = min(piiii.first.second,j);\n            piiii.second.first = max(piiii.second.first,i);\n            piiii.second.second = max(piiii.second.second,j);\n        }\n    }\n    while(true){\n        bool update = [&]{\n            for(int i = 0; i < 26;i++){\n                if(X[i].first.first == INF) continue;\n                if(check(X[i].first.first,X[i].first.second,X[i].second.first,X[i].second.second,i,masu)){\n                    Fill(X[i].first.first,X[i].first.second,X[i].second.first,X[i].second.second,masu);\n                    X[i].first.first = INF;\n                    return true;\n                }\n            }\n            return false;\n        }();\n        if(update) continue;\n        else break;\n    }\n    \n    for(int i = 0; i < H;i++){\n        for(int j = 0; j < W;j++){\n            if(masu[i][j] == '.') continue;\n            if(masu[i][j] == '*') continue;\n            return \"SUSPICIOUS\";\n        }\n    }\n    return \"SAFE\";\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    ll T; cin >> T;\n    while(T--){\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nint h,w;\nchar field[51][51];\nbool passed[10];\n\nstruct nodeInfo{\n    int minx;\n    int miny;\n    int maxx;\n    int maxy;\n    char kind;\n    set<char> chars;\n};\n\nint minx,miny,maxx,maxy;\nmap<char,int> key;\nint node;\nvector<int> G[10];\nbool isClosing=false;\nnodeInfo recInfo[10];\n\nvoid findRecSize (int y,int x,char kind){\n    for(int i = 0;i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(field[i][j]==kind){\n                miny=min(miny,i);\n                minx=min(minx,j);\n                maxy=max(maxy,i);\n                maxx=max(maxx,j);\n            }\n        }\n    }\n}\n\nvoid findClose(int s){\n    if(isClosing)\n        return;\n    //if(passed[s]){\n    //    isClosing=true;\n    //    return;\n    //}\n    for(int i = 0; i < G[s].size(); i++){\n        if(passed[G[s][i]]){\n            isClosing=true;\n            return;\n        }\n        passed[G[s][i]]=true;\n        findClose(G[s][i]);\n        passed[G[s][i]]=false;\n    }\n}\n\nvoid dfs(int node,set<char> s){\n\n}\n\nint main(){\n    int n;\n    cin>>n;\n    while(n--){\n        for(int i = 0; i < 10; i++){\n            recInfo[i].chars.clear();\n            G[i].clear();\n        }\n        node=0;\n        key.clear();\n        cin>>h>>w;\n        memset(passed,0,sizeof(passed));\n        for(int i = 0; i < h; i++)\n            for(int j = 0; j < w; j++)\n                cin>>field[i][j];\n        bool no=false;\n        vector<int> roots;\n        // ·û`»è\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                char kind=field[i][j];\n                if(kind!='.'&&(key.find(kind)==key.end())){\n                    // nodeðV½Éo^·é\n                    key[kind]=node;\n                    node++;\n                    minx=miny=100;\n                    maxx=maxy=-1;\n                    findRecSize(i,j,kind);\n                    recInfo[node-1].maxx=maxx;\n                    recInfo[node-1].maxy=maxy;\n                    recInfo[node-1].minx=minx;\n                    recInfo[node-1].miny=miny;\n                    recInfo[node-1].kind=kind;\n                    bool isRoot=true;\n                    // ß½x,y»ê¼êÌÀWîñ©ç¾çê½l¦¤é·û`Ì`ÌTõðs¤\n                    for(int k = miny; k <= maxy; k++){\n                        for(int l = minx; l <= maxx; l++){\n                            // TõææÉ.ª¶Ýµ½êA·û`ÅÍÈ¢\n                            if(field[k][l]=='.'){\n                                no=true;\n                                break;\n                            }\n                            else if(field[k][l]!=kind){\n                                isRoot=false;\n                            }\n                            recInfo[node-1].chars.insert(field[k][l]);\n                        }\n                        if(no)\n                            break;\n                    }\n                    if(isRoot)\n                        roots.push_back(node-1);\n                }\n                if(no)\n                    break;\n            }\n            if(no)\n                break;\n        }\n        if(no){\n            cout<<\"SUSPICIOUS\"<<endl;\n            continue;\n        }\n        \n\n        // dÈèÌ\n        // ãÌÙ¤©çºÌÙ¤ÖGbWð£é\n        for(int l = 0; l < node; l++){\n            int mnx=recInfo[l].minx;\n            int mxx=recInfo[l].maxx;\n            int mny=recInfo[l].miny;\n            int mxy=recInfo[l].maxy;\n            char kind=recInfo[l].kind;\n            for(int i = mny; i <= mxy; i++){\n                for(int j = mnx; j <= mxx; j++){\n                    if(field[i][j]!=kind){\n                        int from=key[field[i][j]];\n                        int to=key[kind];\n                        // Ü¾GbWª¢o^\n                        if(find(G[from].begin(),G[from].end(),to)==G[from].end())\n                            G[from].push_back(to);\n                    }\n                }\n            }\n        }\n        \n        //memset(passed,0,sizeof(passed));\n        //// ª©çÔÉºÖ½ÇÁÄ¢­\n        //// SÌm[hÉ½Çè¯È¢ÌÅ êÎAfalse\n        //for(int l = 0; l < roots.size(); l++){\n        //    int cr=roots[l];\n        //    set<char> s;\n        //    s.insert(recInfo[cr].kind);\n        //    dfs(cr,s);\n        //}\n\n        // ÂHª¶Ý·é©Tõ\n        isClosing=false;\n        for(int i = 0; i < node; i++){\n            memset(passed,0,sizeof(passed));\n            passed[i]=true;\n            findClose(i);\n            if(isClosing)\n                break;\n        }\n        if(key.size()!=0&&(isClosing)){\n            cout<<\"SUSPICIOUS\"<<endl;\n            continue;\n        }\n        else{\n\n            cout<<\"SAFE\"<<endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint h,w;\nchar tbl[60][60];\nint ax[30],ay[30],Ax[30],Ay[30];\nint d[26];\nbool safe;\nbool visited[26];\n \nint depth(char c){\n  int i = c-'A';\n  if(d[i]!=0) return d[i];\n  if(visited[i]) return d[i]=-1;\n  visited[i]=true;\n  bool f = true;\n  for(int y=ay[i];y<=Ay[i];++y)\n    for(int x=ax[i];x<=Ax[i];++x){\n      if(tbl[y][x]=='.'){\n\treturn d[i]=-1;\n      }\n      else if(tbl[y][x]!=c){\n\tf=false;\n\tint u = depth(tbl[y][x]);\n\tif(u==-1) return d[i]=-1;\n\telse d[i]=max(d[i],depth(tbl[y][x])+1);\n      }\n    }\n  if(f) return d[i]=1;\n  return d[i];\n}\nint main(){\n  int T;\n  cin>>T;\n  while(T--){\n    safe=true;\n    cin>>h>>w;\n    bool used[26]={};\n    for(int i=0;i<26;++i) ax[i]=ay[i]=100, Ax[i]=Ay[i]=0;\n    for(int i=0;i<h;++i) cin>>tbl[i];\n    for(int i=0;i<h;++i)\n      for(int j=0;j<w;++j){\n\tif('A'<=tbl[i][j] && tbl[i][j]<='Z'){\n\t  int c = tbl[i][j]-'A';\n\t  used[c]=true;\n\t  ax[c]=min(ax[c],j);\n\t  ay[c]=min(ay[c],i);\n\t  Ax[c]=max(Ax[c],j);\n\t  Ay[c]=max(Ay[c],i);\n\t}\n      }\n \n    for(int i=0;i<26;++i) d[i]=0,visited[i]=false;\n    for(int i=0;i<26;++i){\n      if(!used[i]) continue;\n      int t = depth('A'+i);\n      //      cout << t << \" \";\n      if(t==-1) safe=false;\n    }\n    //    cout << endl;\n    if(safe) cout << \"SAFE\" << endl;\n    else cout << \"SUSPICIOUS\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\nclass Object{\npublic:\n  Object(char col){ miny = minx = INF; maxy = maxx = -1; on.clear(); c = col; }\n  int miny, minx, maxy, maxx;\n  set<int> on;\n  char c;\n};\n\nint h, w;\nvector<Object> objects;\nset<int> used;\nchar input[50][50];\nbool visited[50][50];\nint index[50][50];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nbool dfs1(int y, int x, int n){\n  Object &obj = objects[n];\n  visited[y][x] = true;\n  index[y][x] = n;\n  if(obj.miny > y) obj.miny = y;\n  if(obj.minx > x) obj.minx = x;\n  if(obj.maxy < y) obj.maxy = y;\n  if(obj.maxx < x) obj.maxx = x;\n  for(int i=0;i<4;i++){\n    int ty = y + dy[i];\n    int tx = x + dx[i];\n    if(ty<0 || ty>=h) continue;\n    if(tx<0 || tx>=w) continue;\n    if(visited[ty][tx]) continue;\n    if(input[ty][tx] != input[y][x]) continue;\n    dfs1(ty, tx, n);\n  }\n  return true;\n}\n\nbool dfs2(int n){\n  set<int>::iterator ite = objects[n].on.begin();\n  for(;ite != objects[n].on.end();ite++){\n    if(used.find(*ite) != used.end()) return false;\n    used.insert(*ite);\n    if(!dfs2(*ite)) return false;\n    used.erase(used.find(*ite));\n  }\n  return true;\n}\n\nmain(){\n  int t;\n  cin >> t;\n  while(t--){\n    cin >> h >> w;\n    objects.clear();\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> input[i][j];\n      }\n    }\n\n\n    fill(index[0], index[50], -1);\n    fill(visited[0], visited[50], false);    \n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(input[i][j] != '.' && !visited[i][j]){\n\t  objects.push_back(Object(input[i][j]));\n\t  dfs1(i, j, (int)objects.size()-1);\n\t}\n      }\n    }\n\n    bool ans = true;\n\n    for(int i=0;i<objects.size();i++){\n      for(int j=objects[i].miny;j<=objects[i].maxy;j++){\n\tfor(int k=objects[i].minx;k<=objects[i].maxx;k++){\n\t  if(input[j][k] != '.' && input[j][k] != objects[i].c){\n\t    objects[i].on.insert(index[j][k]);\n\t  }else if(input[j][k] == '.'){\n\t    ans = false;\n\t    break;\n\t  }\n\t}\n\tif(!ans) break;\n      }\n      if(!ans) break;\n    }\n\n    for(int i=0;i<objects.size();i++){\n      set<int>::iterator ite = objects[i].on.begin();\n      used.clear();\n      ite = used.begin();\n      used.insert(i);\n      if(!dfs2(i)){\n\tans = false;\n\tbreak;\n      }\n    }\n    if(ans){\n      cout << \"SAFE\" << endl;\n    }else{\n      cout << \"SUSPICIOUS\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\nint main() {\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tint Y, X; cin >> Y >> X;\n\t\tvector<vector<int>>field(Y, vector<int>(X));\n\t\tvector<int>chars;\n\t\tfor (int i = 0; i < Y; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < X; ++j) {\n\t\t\t\tif (st[j] == '.') {\n\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfield[i][j] = st[j];\n\t\t\t\t\tif (find(chars.begin(),chars.end(),st[j]) == chars.end()) {\n\t\t\t\t\t\tchars.push_back(st[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>perms(chars.size());\n\t\tiota(perms.begin(), perms.end(), 0);\n\t\tbool ans = false;\n\t\tdo {\n\t\t\tbool allok = true;\n\t\t\tvector<vector<int>>nfield(field);\n\t\t\tfor (int i = 0; i < perms.size(); ++i) {\n\t\t\t\tint nc = chars[perms[i]];\n\t\t\t\tint l = 100;\n\t\t\t\tint r = 0;\n\t\t\t\tint u = 100;\n\t\t\t\tint d = 0;\n\t\t\t\tfor (int j = 0; j < Y; ++j) {\n\t\t\t\t\tfor (int k = 0; k < X; ++k) {\n\t\t\t\t\t\tif (nfield[j][k] == nc ) {\n\t\t\t\t\t\t\tl = min(l, k); r = max(r, k);\n\t\t\t\t\t\t\tu = min(u, j); d = max(d, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int j = l; j <=r; ++j) {\n\t\t\t\t\tfor (int k = u; k <=d; ++k) {\n\t\t\t\t\t\tif (nfield[k][j] == nc || nfield[k][j] == 1000) {\n\t\t\t\t\t\t\tnfield[k][j] = 1000;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!ok) {\n\t\t\t\t\tallok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (allok) {\n\t\t\t\tans = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (next_permutation(perms.begin(), perms.end()));\n\t\tif (ans) {\n\t\t\tcout << \"SAFE\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n#define all(c) (c).begin(), (c).end()\n\ntemplate<typename T>\ninline bool chmin(T& t, T f) { if (t <= f) return false; t = f; return true; }\n\ntemplate<typename T>\ninline bool chmax(T& t, T f) { if (t >= f) return false; t = f; return true; }\n\nbool valid(vector<string>& sc, vector<vector<int>>& range, string& bagg) {\n    int used = 0;\n    rep(k, bagg.size()) {\n        int l = bagg[k] - 'A';\n        used |= 1 << l;\n        for (int i = range[l][0]; i <= range[l][1]; ++i) {\n            for (int j = range[l][2]; j <= range[l][3]; ++j) {\n                if (sc[i][j] == '.' || !(used >> (sc[i][j] - 'A') & 1)) return false;\n            }\n        }\n    }\n    return true;\n}\n\nchar const *check(int H, int W, vector<string>& sc) {\n    int used = 0;\n    vector<vector<int>> range(26, {H, 0, W, 0});\n    string bagg = \"\";\n    rep(i, H) rep(j, W) if (sc[i][j] != '.') {\n        int l = sc[i][j] - 'A';\n        if (used >> l & 1) {\n            chmin(range[l][0], i);\n            chmax(range[l][1], i);\n            chmin(range[l][2], j);\n            chmax(range[l][3], j);\n        }\n        else {\n            used |= 1 << l;\n            bagg += sc[i][j];\n            range[l][0] = range[l][1] = i;\n            range[l][2] = range[l][3] = j;\n        }\n    }\n    sort(all(bagg));\n    do {\n        if (valid(sc, range, bagg)) return \"SAFE\";\n    } while (next_permutation(all(bagg)));\n    return \"SUSPICIOUS\";\n}\n\nint main() {\n    int n;\n    cin >> n;\n    while (n--) {\n        int H, W;\n        cin >> H >> W;\n        vector<string> sc(H);\n        for (auto& e: sc) cin >> e;\n        cout << check(H, W, sc) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\nint n;\nint H,W,T;\nstring str;\nbool used[26],flg;\n\nint A[26],B[26],C[26],D[26];\n\nchar t[500][500];\n\nchar tmp;\n\nvoid input();\nvoid init();\n\nbool check(char ch){\n\n  int z=ch-'A';\n  if(A[z]==-1){\n    int a=49,b=0,c=0,d=49;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tif(t[i][j]==ch){\n\t  a=min(a,i);\n\t  b=max(b,j);\n\t  c=max(c,i);\n\t  d=min(d,j);\n\t}\n      }\n    }\n    A[z]=a;  B[z]=b;  C[z]=c;  D[z]=d;\n  }\n\n  for(int i=A[z];i<=C[z];i++){\n    for(int j=D[z];j<=B[z];j++){\n      if(t[i][j]=='?')continue;\n      if(t[i][j]!=ch)return false;\n    }\n  }\n  return true;\n  \n}\n\nvoid draw(char ch){\n  int z=ch-'A';\n\n  if(A[z]==-1){\n    int a=49,b=0,c=0,d=49;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tif(t[i][j]==ch){\n\t  a=min(a,i);\n\t  b=max(b,j);\n\t  c=max(c,i);\n\t  d=min(d,j);\n\t}\n      }\n    }\n    A[z]=a;  B[z]=b;  C[z]=c;  D[z]=d;\n  }\n\n  for(int i=A[z];i<=C[z];i++){\n    for(int j=D[z];j<=B[z];j++){\n      t[i][j]='?';\n    }\n  }\n}\nint main(){\n  cin>>T;\n  while(T--){\n    init();\n    input();\n\n    while(1){\n \n      flg=false;\n\n      for(int i=0;i<26;i++){\n\tif(used[i]==false)continue;\n\tif(check(i+'A')==true){\n\t  flg=true;\n\t  draw(i+'A');\n\t  used[i]=false;\n\t  break;\n\t}\n      }\n      if(flg==false)break;\n    }\n\n    flg=false;\n    for(int i=0;i<26;i++)flg|=used[i];\n    cout<<(flg?\"SUSPICIOUS\":\"SAFE\")<<endl;\n  }\n  return 0;\n}\n\nvoid input(){\n  cin>>H>>W;\n  for(int i=0;i<H;i++){\n    cin>>str;\n    for(int j=0;j<W;j++){\n      t[i][j]=str[j];\n      if(t[i][j]!='.')\n      used[t[i][j]-'A']=true;\n    }\n  }\n}\nvoid init(){\n  for(int i=0;i<26;i++){\n    A[i]=-1;\n    used[i]=false;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\nstring f[50];\nint maxX[26], maxY[26], minX[26], minY[26];\nbool on[26][26];\nbool used[26];\n\nbool dfs(int n, int prev) {\n\tif(used[n]) {\n\t\treturn false;\n\t}\n\tused[n] = true;\n\tfor(int i = 0; i < 26; i++) {\n\t\tif(on[n][i] && i != prev && i != n) {\n\t\t\tif(!dfs(i, n)) return false;\n\t\t}\n\t}\n\tused[n] = false;\n\treturn true;\n}\n\nvoid check() {\n\tmemset(on, 0, sizeof on);\n\tmemset(used, 0, sizeof used);\n\tfor(int i = 0; i < 26; i++) {\n\t\tif(maxX[i] == -1) continue;\n\t\tfor(int y = minY[i]; y <= maxY[i]; y++) {\n\t\t\tfor(int x = minX[i]; x <= maxX[i]; x++) {\n\t\t\t\tif(f[y][x] == '.') {\n\t\t\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(f[y][x] != 'A' + i) {\n\t\t\t\t\ton[i][f[y][x] - 'A'] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int k = 0; k < 26; k++) {\n\t\tfor(int i = 0; i < 26; i++) {\n\t\t\tfor(int j = 0; j < 26; j++) {\n\t\t\t\ton[i][j] |= on[i][k] & on[k][j];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 26; i++) {\n\t\tfor(int j = 0; j < 26; j++) {\n\t\t\tif(on[i][j] && on[j][i]) {\n\t\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"SAFE\" << endl;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint T, H, W;\n\tcin >> T;\n\twhile(T--) {\n\t\tcin >> H >> W;\n\t\tfor(int i = 0; i < H; i++) {\n\t\t\tcin >> f[i];\n\t\t}\n\n\t\tfor(int i = 0; i < 26; i++) {\n\t\t\tmaxX[i] = maxY[i] = -1;\n\t\t\tminX[i] = minY[i] = 100000;\n\t\t}\n\n\t\tfor(int y = 0; y < H; y++) {\n\t\t\tfor(int x = 0; x < W; x++) {\n\t\t\t\tif(f[y][x] == '.') continue;\n\t\t\t\tint c = f[y][x] - 'A';\n\t\t\t\tmaxX[c] = max(maxX[c], x);\n\t\t\t\tmaxY[c] = max(maxY[c], y);\n\t\t\t\tminX[c] = min(minX[c], x);\n\t\t\t\tminY[c] = min(minY[c], y);\n\t\t\t}\n\t\t}\n\n\t\tcheck();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<set>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a,i<b;++i)\n#define rep(i,n) REP(i,0,n)\n\nstruct P {\n  int maxx,maxy,minx,miny;\n  P() {\n    maxx = maxy = -1;\n    minx = miny = 51;\n  }\n};\n\nint dist[26][26];\nint visited[26];\n\nbool visit(int i) {\n  if(i<0 || i>25) return false;\n  visited[i] = 2;\n  for(int j=0; j<26; ++j) {\n    if(dist[i][j] == 0) continue;\n    if(visited[j] != 0) {\n      if(visited[j] == 2) return false;\n    } else if (!visit(j)) return false;\n  }\n  visited[i] = 1;\n  return true;\n}\n\nint main() {\n  int h,w,n,k,l,start,now,i,j;\n  string s;\n  cin>>n;\n  while(n--) {\n    cin>>h>>w;\n    vector<string> in;\n    memset(dist, 0, sizeof(dist));\n    memset(visited, 0, sizeof(visited));\n    for(i=0; i<h; ++i) {\n      cin>>s;\n      in.push_back(s);\n    }\n\n    for(k=0; k<26; ++k) {\n      for(l=0; l<26; ++l) {\n\tdist[k][l] = 0;\n      }\n    }\n\n    set<char> badget;\n    map<char, P> mp;\n    queue<int> Q;\n    for(i=0; i<h; ++i) {\n      for(j=0; j<w; ++j) {\n\tif(in[i].at(j) != '.') {\n\t  badget.insert(in[i].at(j));\n\t  mp[in[i].at(j)].maxx = max(mp[in[i].at(j)].maxx, j);\n\t  mp[in[i].at(j)].maxy = max(mp[in[i].at(j)].maxy, i);\n\t  mp[in[i].at(j)].minx = min(mp[in[i].at(j)].minx, j);\n\t  mp[in[i].at(j)].miny = min(mp[in[i].at(j)].miny, i);\n\t}\n      }\n    }\n\n    if(badget.size() == 0) {\n      cout<<\"SAFE\"<<endl;\n      goto NEXT;\n    }\n\n    for(set<char>::iterator it = badget.begin(); it != badget.end(); ++it) {\n      int maxx = mp[(*it)].maxx,maxy = mp[(*it)].maxy;\n      int minx = mp[(*it)].minx,miny = mp[(*it)].miny;\n      for(i=miny; i<=maxy; ++i) {\n\tfor(j=minx; j<=maxx; ++j) {\n\t  if(in[i].at(j) == '.') {\n\t    cout<<\"SUSPICIOUS\"<<endl;\n\t    goto NEXT;\n\t  }else if(in[i].at(j) != (*it)) {\n\t    dist[(*it)-'A'][in[i].at(j)-'A'] = 1;\n\t  }\n\t}\n      }\n    }\n\n    //±±Ég|WJ\\[gð­\n    //dist[i][j] Í iÌãÉjªæÁÄ¢éÆ¢¤ÖWð\\·\n    for(i=0; i<26; ++i) {\n      if(!visit(i)) {\n\tcout<<\"SUSPICIOUS\"<<endl;\n\tgoto NEXT;\n      }\n    }\n    cout<<\"SAFE\"<<endl;\n\n  NEXT:\n    ;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <map>\n#include <algorithm>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nstruct rect { int ly, ry, lx, rx; };\n\nint T, H, W;\nchar S[55][55];\n\nint main(void) {\n  cin >> T;\n  while(T--) {\n    cin >> H >> W;\n    REP(i, 0, H) cin >> S[i];\n\n    set<char> st;\n    REP(i, 0, H) REP(j, 0, W) if(S[i][j] != '.') st.insert(S[i][j]);\n    map<char, int> ctoi;\n    for(char i : st) ctoi[i] = ctoi.size();\n\n    int a[7];\n    REP(i, 0, 7) a[i] = i;\n\n    map<char, rect> p;\n    REP(i, 0, H) REP(j, 0, W) if(S[i][j] != '.') p[S[i][j]] = (rect) { i, i, j, j };\n\n    REP(i, 0, H) REP(j, 0, W) {\n      if(S[i][j] != '.') {\n        p[S[i][j]].ly = min(p[S[i][j]].ly, i);\n        p[S[i][j]].ry = max(p[S[i][j]].ry, i);\n        p[S[i][j]].lx = min(p[S[i][j]].lx, j);\n        p[S[i][j]].rx = max(p[S[i][j]].rx, j);\n      }\n    }\n\n    int ans = false;\n    do {\n      bool f = true;\n      for(pair<char, rect> r : p) {\n        char c = r.first;\n        rect q = r.second;\n        REP(i, q.ly, q.ry + 1) REP(j, q.lx, q.rx + 1) {\n          if(S[i][j] == '.' || a[ctoi[c]] < a[ctoi[S[i][j]]]) {\n            f = false;\n            goto END;\n          }\n        }\nEND:;\n      }\n      ans = ans || f;\n      if(ans) break;\n    } while(next_permutation(a, a + st.size()));\n\n    cout << (ans ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n\nusing namespace std;\n\nint h,w;\nchar field[51][51];\nbool passed[2501];\n\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\nstruct nodeInfo{\n    int minx;\n    int miny;\n    int maxx;\n    int maxy;\n    char kind;\n};\n\nint minx,miny,maxx,maxy;\nmap<char,int> key;\nint node;\nvector<int> G[2501];\nbool isClosing=false;\nnodeInfo recInfo[51];\n\nvoid findRecSize (int y,int x,char kind){\n    for(int i = 0;i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(field[i][j]==kind){\n                miny=min(miny,i);\n                minx=min(minx,j);\n                maxy=max(maxy,i);\n                maxx=max(maxx,j);\n            }\n        }\n    }\n}\n\nvoid findClose(int s){\n    if(isClosing)\n        return;\n    if(passed[s]){\n        isClosing=true;\n        return;\n    }\n    passed[s]=true;\n    for(int i = 0; i < G[s].size(); i++)\n        findClose(G[s][i]);\n}\n\nint main(){\n    int n;\n    cin>>n;\n    while(n--){\n        for(int i = 0; i < 2501; i++)\n            G[i].clear();\n        node=0;\n        key.clear();\n        cin>>h>>w;\n        memset(passed,0,sizeof(passed));\n        for(int i = 0; i < h; i++)\n            for(int j = 0; j < w; j++)\n                cin>>field[i][j];\n        bool no=false;\n        // ·û`»è\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                char kind=field[i][j];\n                if(kind!='.'&&key.find(kind)==key.end()){\n                    // nodeðV½Éo^·é\n                    key[kind]=node;\n                    node++;\n                    minx=miny=100;\n                    maxx=maxy=-1;\n                    findRecSize(i,j,kind);\n                    recInfo[node-1].maxx=maxx;\n                    recInfo[node-1].maxy=maxy;\n                    recInfo[node-1].minx=minx;\n                    recInfo[node-1].miny=miny;\n                    recInfo[node-1].kind=kind;             \n                    // ß½x,y»ê¼êÌÀWîñ©ç¾çê½l¦¤é·û`Ì`ÌTõðs¤\n                    for(int k = miny; k <= maxy; k++){\n                        for(int l = minx; l <= minx; l++){\n                            // TõææÉ.ª¶Ýµ½êA·û`ÅÍÈ¢\n                            if(field[k][l]=='.'){\n                                no=true;\n                                break;\n                            }\n                        }\n                        if(no)\n                            break;\n                    }\n                    if(no)\n                        break;\n                }\n                if(no)\n                    break;\n            }\n        }\n        if(no){\n            cout<<\"SUSPICIOUS\"<<endl;\n            continue;\n        }\n\n        // dÈèÌ\n        // ãÌÙ¤©çºÌÙ¤ÖGbWð£é\n        for(int l = 0; l < node; l++){\n            int mnx=recInfo[l].minx;\n            int mxx=recInfo[l].maxx;\n            int mny=recInfo[l].miny;\n            int mxy=recInfo[l].maxy;\n            char kind=recInfo[l].kind;\n            for(int i = mny; i <= mxy; i++){\n                for(int j = mnx; j <= mxx; j++){\n                    if(field[i][j]!=kind){\n                        int from=key[field[i][j]];\n                        int to=key[kind];\n                        // Ü¾GbWª¢o^\n                        if(find(G[from].begin(),G[from].end(),to)==G[from].end())\n                            G[from].push_back(to);\n                    }\n                }\n            }\n        }\n        // ÂHª¶Ý·é©Tõ\n        isClosing=false;\n        for(int i = 0; i < node; i++){\n            memset(passed,0,sizeof(passed));\n            findClose(i);\n            if(isClosing)\n                break;\n        }\n        if(key.size()!=0&&(isClosing)){\n            cout<<\"SUSPICIOUS\"<<endl;\n            continue;\n        }\n        else\n            cout<<\"SAFE\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\nclass Object{\npublic:\n  Object(char col){ miny = minx = INF; maxy = maxx = -1; on.clear(); c = col; }\n  int miny, minx, maxy, maxx;\n  set<int> on;\n  char c;\n};\n\nint h, w;\nvector<Object> objects;\nset<int> used;\nchar input[50][50];\nbool visited[50][50];\nint index[50][50];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nbool dfs1(int y, int x, int n){\n  Object &obj = objects[n];\n  visited[y][x] = true;\n  index[y][x] = n;\n  if(obj.miny > y) obj.miny = y;\n  if(obj.minx > x) obj.minx = x;\n  if(obj.maxy < y) obj.maxy = y;\n  if(obj.maxx < x) obj.maxx = x;\n  for(int i=0;i<4;i++){\n    int ty = y + dy[i];\n    int tx = x + dx[i];\n    if(ty<0 || ty>=h) continue;\n    if(tx<0 || tx>=w) continue;\n    if(visited[ty][tx]) continue;\n    if(input[ty][tx] != input[y][x]) continue;\n    dfs1(ty, tx, n);\n  }\n  return true;\n}\n\nbool dfs2(int n){\n  used.insert(n);\n  set<int>::iterator ite = objects[n].on.begin();\n  for(;ite != objects[n].on.end();ite++){\n    if(used.find(*ite) != used.end()) return false;\n    if(!dfs2(*ite)) return false;\n  }\n  return true;\n}\n\nmain(){\n  int t;\n  cin >> t;\n  while(t--){\n    cin >> h >> w;\n    objects.clear();\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> input[i][j];\n      }\n    }\n\n\n    fill(index[0], index[50], -1);\n    fill(visited[0], visited[50], false);    \n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(input[i][j] != '.' && !visited[i][j]){\n\t  objects.push_back(Object(input[i][j]));\n\t  dfs1(i, j, (int)objects.size()-1);\n\t}\n      }\n    }\n\n    bool ans = true;\n\n    for(int i=0;i<objects.size();i++){\n      for(int j=objects[i].miny;j<=objects[i].maxy;j++){\n\tfor(int k=objects[i].minx;k<=objects[i].maxx;k++){\n\t  if(input[j][k] != '.' && input[j][k] != objects[i].c){\n\t    objects[i].on.insert(index[j][k]);\n\t  }else if(input[j][k] == '.'){\n\t    ans = false;\n\t    break;\n\t  }\n\t}\n\tif(!ans) break;\n      }\n      if(!ans) break;\n    }\n\n    for(int i=0;i<objects.size();i++){\n      used.clear();\n      if(!dfs2(i)){\n\tans = false;\n\tbreak;\n      }\n    }\n\n    if(ans){\n      cout << \"SAFE\" << endl;\n    }else{\n      cout << \"SUSPICIOUS\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <map>\n#include <iostream>\nusing namespace std;\nint main(){\n  int n;\n  cin >> n;\n  for(int i = 0; i < n; ++i){\n    int h, w;\n    cin >> h >> w;\n    vector<string> V(h);\n    for(int i = 0; i < h; ++i){\n      cin >> V[i];\n    }\n    vector<int> T(26,h), L(26,w), R(26,-1), B(26,-1);\n    for(int i = 0; i < h; ++i){\n      for(int j = 0; j < w; ++j){\n        char c = V[i][j];\n        if(c != '.'){\n          T[c-'A'] = min(i,T[c-'A']);\n          L[c-'A'] = min(j,L[c-'A']);\n          B[c-'A'] = max(i,B[c-'A']);\n          R[c-'A'] = max(j,R[c-'A']);\n        }\n      }\n    }\n    vector<int> C;\n    for(int i = 0; i < 26; ++i){\n      if(B[i] > 0) C.push_back(i);\n    }\n    string ans = \"SAFE\";\n    vector< vector<bool> > G(26,vector<bool>(26,false));\n    for(int i = 0; i < C.size(); ++i){\n      for(int j = T[C[i]]; j <= B[C[i]]; ++j){\n        for(int k = L[C[i]]; k <= R[C[i]]; ++k){\n          if(V[j][k] == '.'){\n            ans = \"SUSPICIOUS\";\n          }else if(V[j][k] != 'A'+C[i]){\n            G[C[i]][V[j][k]-'A'] = true;\n          }\n        }\n      }\n    }\n    if(ans == \"SUSPICIOUS\"){\n      cout << ans << endl;\n      continue;\n    }\n    ans = \"SUSPICIOUS\";\n    do{\n      map<int,int> M;\n      for(int i = 0; i < C.size(); ++i) M[C[i]] = i;\n      bool f = true;\n      for(int i = 0; i < 26; ++i){\n        if(!f) break;\n        for(int j = 0; j < 26; ++j){\n          if(G[i][j] && M[i] > M[j]){\n            f = false;\n            break;\n          }\n        }\n      }\n      if(f){\n        ans = \"SAFE\";\n      }\n    }while(next_permutation(C.begin(),C.end()));\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvoid solve() {\n    int H, W;\n    cin >> H >> W;\n\n    vector<string> S(H);\n    for (auto& s : S) cin >> s;\n\n    vector<vector<bool>> on(26, vector<bool>(26, false));\n    // on[x][y] => xがyより上にある\n\n    bool judge = true;\n    for (char c = 'A'; c <= 'Z'; ++c) {\n        int lx = H, rx = -1, ly = W, ry = -1;\n        for (int x = 0; x < H; ++x) {\n            for (int y = 0; y < W; ++y) {\n                if (S[x][y] != c) continue;\n                lx = min(lx, x), rx = max(rx, x);\n                ly = min(ly, y), ry = max(ry, y);\n            }\n        }\n\n        for (int x = lx; x <= rx; ++x) {\n            for (int y = ly; y <= ry; ++y) {\n                if (S[x][y] == '.') {\n                    judge = false;\n                } else if (S[x][y] != c) {\n                    // S[x][y]はcの上にある\n                    on[S[x][y] - 'A'][c - 'A'] = true;\n                }\n            }\n        }\n    }\n\n    bool update;\n    do {\n        update = false;\n        for (int k = 0; k < 26; ++k) {\n            for (int i = 0; i < 26; ++i) {\n                for (int j = 0; j < 26; ++j) {\n                    if (on[i][k] && on[k][j] && !on[i][j]) {\n                        update = true;\n                        on[i][j] = true;\n                    }\n                }\n            }\n        }\n    } while (update);\n\n    for (int i = 0; i < 26; ++i) {\n        if (on[i][i]) judge = false;\n    }\n\n    cout << (judge ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    for (int i = 0; i < N; ++i) solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\n//const int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\nconst int dx[8]={-1,0,1,0,-1,-1,1,1},dy[8]={0,-1,0,1,-1,1,-1,1};\n\nclass Graph{\n\tprivate:\n\tint n;\n\tvvi g,rg;\n\tvi scc,used;\n\tstack<int> stc;\n\tvoid Order(int v){\n\t\tused[v]=1;\n\t\tfor(auto u:g[v]) if(!used[u]) Order(u);\n\t\tstc.push(v);\n\t}\n\tvoid DFS(int v,int t){\n\t\tused[v]=1;\n\t\tfor(auto u:rg[v]) if(!used[u]) DFS(u,t);\n\t\tscc[v]=t;\n\t}\n\tpublic:\n\tint SCC(){\n\t\tscc=used=vi(n);\n\t\trg=vvi(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(!used[i]) Order(i);\n\t\t\tfor(auto v:g[i]) rg[v].push_back(i);\n\t\t}\n\t\tint t=0;\n\t\tused=vi(n);\n\t\twhile(!stc.empty()){\n\t\t\tint v=stc.top();\n\t\t\tstc.pop();\n\t\t\tif(!used[v]) DFS(v,t++);\n\t\t}\n\t\treturn t;\n\t}\n\tGraph(int v){\n\t\tn=v;\n\t\tg=vvi(v);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tg[s].push_back(t);\n\t}\n};\n\nconst int N=16;\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint q;\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tint h,w;\n\t\tcin>>h>>w;\n\t\tGraph g(26);\n\t\tvs a(h);\n\t\tvi mx(26,inf),MX(26,-inf),my(26,inf),MY(26,-inf);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>a[i];\n\t\t\tfor(int j=0;j<w;j++) if(isalpha(a[i][j])){\n\t\t\t\tint I=a[i][j]-'A';\n\t\t\t\tmx[I]=min(mx[I],i);\n\t\t\t\tMX[I]=max(MX[I],i);\n\t\t\t\tmy[I]=min(my[I],j);\n\t\t\t\tMY[I]=max(MY[I],j);\n\t\t\t}\n\t\t}\n\t\tbool B=1;\n\t\tfor(int k=0;k<26;k++) if(mx[k]<inf){\n\t\t\tfor(int i=mx[k];i<=MX[k];i++) for(int j=my[k];j<=MY[k];j++){\n\t\t\t\tif(a[i][j]=='.') B=0;\n\t\t\t\tif(a[i][j]-'A'!=k){\n\t\t\t\t\tg.add_edge(k,a[i][j]-'A');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<(B&&g.SCC()==26?\"SAFE\":\"SUSPICIOUS\")<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nstring str[100];\nint h,w;\nint num;\nbool flag;\nbool used[100][100];\nchar moji[100];\nint vx[4]={1,0,-1,0};\nint vy[4]={0,1,0,-1};\nvoid dfs(int Bit,int depth){\n  if(Bit==((1<<num)-1)){\n    flag=true;\n    return;\n  }\n  for(int i=0;i<num;i++){\n    if(!(Bit&(1<<i))){\n      bool used2[100][100]={};\n      int lemi=100,lema=0,rimi=100,rima=0;\n      for(int j=0;j<h;j++){\n\tfor(int k=0;k<w;k++){\n\t  if(str[j][k]==moji[i]){\n\t    used2[j][k]=true;\n\t    used[j][k]=true;\n\t    lemi=min(lemi,k);\n\t    lema=max(lema,k);\n\t    rima=max(rima,j);\n\t    rimi=min(rimi,j);\n\t  }\n\t}\n      }\n      bool fll=true;\n      for(int j=rimi;j<=rima;j++){\n\tfor(int k=lemi;k<=lema;k++){\n\t  if(!used[j][k]){\n\t    fll=false;\n\t  }\n\t}\n      }\n      if(fll)\n\tdfs(Bit+(1<<i),depth+1);\n      for(int j=rimi;j<=rima;j++){\n\tfor(int k=lemi;k<=lema;k++){\n\t  if(used2[j][k]){\n\t    used[j][k]=false;\n\t  }\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int n;cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>h>>w;\n    num=0;\n    for(int i=0;i<55;i++)\n      for(int j=0;j<55;j++)\n\tused[i][j]=false;\n    flag=false;\n    bool alfa[26]={};\n    for(int i=0;i<h;i++){\n      cin>>str[i];\n      for(int j=0;j<w;j++){\n\talfa[str[i][j]-'A']=true;\n      }\n    }\n    int cnt=0;\n    for(int i=0;i<26;i++){\n      if(alfa[i]){\n\tnum++;\n\tmoji[cnt]=((char)(i+'A'));\n\tcnt++;\n      }\n    }\n    dfs(0,0);\n    if(flag)\n      cout<<\"SAFE\"<<endl;\n    else \n      cout<<\"SUSPICIOUS\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define rep(i,N) for(ll i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nint n;\nint h, w;\nstring table[50];\n\nint main() {\n\tcin >> n;\n\trep(kk, n) {\n\t\tcin >> h >> w;\n\t\tvector<char> vi;\n\t\trep(i, h) {\n\t\t\tcin >> table[i];\n\t\t\trep(j, w) {\n\t\t\t\tif (table[i][j] != '.')vi.push_back(table[i][j]);\n\t\t\t}\n\t\t}\n\t\tsort(ALL(vi));\n\t\tvi.erase(unique(ALL(vi)), vi.end());\n\t\tbool f = 0;\n\t\tdo {\n\t\t\tmap<char, int> mci;\n\t\t\tmci['.'] = 0;\n\t\t\trep(i, vi.size()) {\n\t\t\t\tmci[vi[i]] = i + 1;\n\t\t\t}\n\t\t\tbool ng = 0;\n\t\t\trep(i, vi.size()) {\n\t\t\t\tll l = w - 1, r = 0, d = h - 1, u = 0;\n\t\t\t\trep(j, h) {\n\t\t\t\t\trep(k, w) {\n\t\t\t\t\t\tif (table[j][k] == vi[i]) {\n\t\t\t\t\t\t\t//cout << j << \" \" << k << endl;\n\t\t\t\t\t\t\tl = min(l, k);\n\t\t\t\t\t\t\tr = max(r, k);\n\t\t\t\t\t\t\td = min(d, j);\n\t\t\t\t\t\t\tu = max(u, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//cout << d << \" \" << u << \" \" << l << \" \" << r << endl;\n\t\t\t\tfor (int j = d; j <= u; j++) {\n\t\t\t\t\tfor (int k = l; k <= r; k++) {\n\t\t\t\t\t\tif (table[j][k] != vi[i]) {\n\t\t\t\t\t\t\tif (mci[table[j][k]] < mci[vi[i]])ng = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ng)break;\n\t\t\t\t\t}\n\t\t\t\t\tif (ng)break;\n\t\t\t\t}\n\t\t\t\tif (ng)break;\n\t\t\t}\n\t\t\tif (!ng)f = 1;\n\t\t} while (next_permutation(ALL(vi)));\n\t\tif (f)cout << \"SAFE\" << endl;\n\t\telse cout << \"SUSPICIOUS\" << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint h, w;\nchar field[50][50];\n\nstruct obj {\n  char pack;\n  vector<char> back;\n  int ux, uy, dx, dy;\n  bool is_visit;\n  obj(char pack, vector<char> back, int ux, int uy, int dx, int dy):\n    pack(pack), back(back), ux(ux), uy(uy), dx(dx), dy(dy){}\n  obj():back(), ux(0), uy(0), dx(100), dy(100), is_visit(false) {}\n};\n\nmap<char, obj> m;\n\nbool no_loop(char c)\n{\n  //printf(\"%c\\n\", c);\n  if (m[c].is_visit) {\n    return false;\n  }\n  m[c].is_visit = true;\n    \n  for (int i = 0; i < m[c].back.size(); i++) {\n    if (!no_loop(m[c].back[i])) {return false;}\n  }\n  return true;\n}\n\nvoid solve()\n{\n  //printf(\"ok\\n\");\n  /*\n  bool is_exist = false;\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      //printf(\"%c\", field[i][j]);\n      if (isalpha(field[i][j])) {\n        int c = field[i][j];\n        m[c].ux = m[c].uy = 0;\n        m[c].dx = m[c].dy = 100;\n        m[c].pack = c;\n        is_exist = true;\n        for (int k = 0; k < h; k++) {\n          for (int l = 0; l < w; l++) {\n            if (field[k][l] == c) {\n              m[c].ux = max(l, m[c].ux);\n              m[c].uy = max(k, m[c].uy);\n              m[c].dx = min(l, m[c].dx);\n              m[c].dy = min(k, m[c].dy); \n            }\n          }\n        }\n        for (int k = m[c].dy; k <= m[c].uy; k++) {\n          for (int l = m[c].dx; k <= m[c].ux; k++) {\n            if (!isalpha(field[k][l])) {\n              printf(\"SUSPICIOUS\\n\");\n              return;\n            }\n          }        \n        }\n      }\n    }\n    //printf(\"\\n\");                        \n  }\n  */\n  //*\n  bool is_exist = false;\n  for (int k = 0; k < h; k++) {\n    for (int l = 0; l < w; l++) {\n      char c;\n      if (isalpha(c = field[k][l])) {\n        is_exist = true;\n        m[c].ux = max(l, m[c].ux);\n        m[c].uy = max(k, m[c].uy);\n        m[c].dx = min(l, m[c].dx);\n        m[c].dy = min(k, m[c].dy);\n        m[c].pack = c;\n      }\n    }\n  }\n  for(map<char, obj>::iterator itr = m.begin(); itr != m.end(); itr++){\n    for (int k = itr -> second.dy; k <= itr -> second.uy; k++) {\n      for (int l = itr -> second.dx; l <= itr -> second.ux; l++) {\n        if (!isalpha(field[k][l])) {\n          printf(\"SUSPICIOUS\\n\");\n          return;\n        }\n      }    \n    }    \n  }\n  //*/\n  if (!is_exist) {\n    printf(\"SAFE\\n\");\n    return;\n  }\n  //printf(\"ok\\n\");\n  \n  for (map<char, obj>::iterator it = m.begin(); it != m.end(); it++) {\n    //printf(\"pack:%c\\n\", it->first);\n    it->second.is_visit = false;\n    bool is_pushed[26];\n    fill(is_pushed, &is_pushed[26], false);\n    for (int i = it->second.dy; i <= it->second.uy; i++) {\n      for (int j = it->second.dx; j <= it->second.ux; j++) {\n        if (field[i][j] != it->first && !is_pushed[field[i][j] - 'A']) {\n          m[field[i][j]].back.push_back(it->first);\n          is_pushed[field[i][j] - 'A'] = true;\n        }\n      }\n    }\n  }\n  \n  char start = m.begin()->first;\n  if (no_loop(start)) {\n    printf(\"SAFE\\n\");\n    return;\n  } else {\n    printf(\"SUSPICIOUS\\n\");\n    return;\n  }\n}\n\nint main()\n{\n  int nInput;\n  scanf(\"%d \", &nInput);\n  \n  for (int input = 0; input < nInput; input++) {\n    m.clear();\n    scanf(\"%d %d \", &h, &w);\n    \n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        scanf(\"%c \", &field[i][j]);\n      }\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint h, w;\nchar field[50][50];\n\nstruct obj {\n  char pack;\n  vector<char> back;\n  int ux, uy, dx, dy;\n  bool is_visit;\n  obj(char pack, vector<char> back, int ux, int uy, int dx, int dy):\n    pack(pack), back(back), ux(ux), uy(uy), dx(dx), dy(dy){}\n  obj():back(), ux(0), uy(0), dx(100), dy(100), is_visit(false) {}\n};\n\nmap<char, obj> m;\n\nbool no_loop(char c)\n{\n  //printf(\"%c\\n\", c);\n  if (m[c].is_visit) {\n    return false;\n  }\n  m[c].is_visit = true;\n    \n  for (int i = 0; i < m[c].back.size(); i++) {\n    if (!no_loop(m[c].back[i])) {return false;}\n  }\n  m[c].is_visit = false;\n  return true;\n}\n\nvoid solve()\n{\n  bool is_exist = false;\n  for (int k = 0; k < h; k++) {\n    for (int l = 0; l < w; l++) {\n      char c;\n      if (isalpha(c = field[k][l])) {\n        is_exist = true;\n        m[c].ux = max(l, m[c].ux);\n        m[c].uy = max(k, m[c].uy);\n        m[c].dx = min(l, m[c].dx);\n        m[c].dy = min(k, m[c].dy);\n        m[c].pack = c;\n      }\n    }\n  }\n  for(map<char, obj>::iterator itr = m.begin(); itr != m.end(); itr++){\n    for (int k = itr -> second.dy; k <= itr -> second.uy; k++) {\n      for (int l = itr -> second.dx; l <= itr -> second.ux; l++) {\n        if (!isalpha(field[k][l])) {\n          printf(\"SUSPICIOUS\\n\");\n          return;\n        }\n      }    \n    }    \n  }\n  //*/\n  if (!is_exist) {\n    printf(\"SAFE\\n\");\n    return;\n  }\n  //printf(\"ok\\n\");\n  \n  for (map<char, obj>::iterator it = m.begin(); it != m.end(); it++) {\n    //printf(\"pack:%c\\n\", it->first);\n    it->second.is_visit = false;\n    bool is_pushed[26];\n    fill(is_pushed, &is_pushed[26], false);\n    for (int i = it->second.dy; i <= it->second.uy; i++) {\n      for (int j = it->second.dx; j <= it->second.ux; j++) {\n        if (field[i][j] != it->first && !is_pushed[field[i][j] - 'A']) {\n          m[field[i][j]].back.push_back(it->first);\n          is_pushed[field[i][j] - 'A'] = true;\n        }\n      }\n    }\n  }\n  \n  for(map<char, obj>::iterator start = m.begin(); start != m.end(); start++){\n    if (!no_loop(start -> first)) {\n      printf(\"SUSPICIOUS\\n\");\n      return;\n    }\n    /*\n    for (map<char, obj>::iterator itr = m.begin(); itr != m.end(); itr++) {\n      itr->second.is_visit = false;\n    }\n    */\n  }\n  printf(\"SAFE\\n\");\n  return;\n}\n\nint main()\n{\n  int nInput;\n  scanf(\"%d \", &nInput);\n  \n  for (int input = 0; input < nInput; input++) {\n    m.clear();\n    scanf(\"%d %d \", &h, &w);\n    \n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        scanf(\"%c \", &field[i][j]);\n      }\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint h, w;\nvector<string> s(50);\nvector<PP> v(26);\nvector<char> vc;\n\nbool ok() {\n  char tmp[h][w];\n  rep(i, h)rep(j, w) tmp[i][j] = '.';\n\n  rep(i, vc.size()) {\n    repl(j, v[vc[i] - 'A'].se.fi, v[vc[i] - 'A'].se.se + 1) {\n      repl(k, v[vc[i] - 'A'].fi.fi, v[vc[i] - 'A'].fi.se + 1) {\n        tmp[j][k] = vc[i];\n      }\n    }\n  }\n\n  rep(i, h)rep(j, w) if (s[i][j] != tmp[i][j]) return false;\n  return true;\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  int t;\n  cin >> t;\n  rep(ii, t) {\n    cin >> h >> w;\n    rep(i, h) cin >> s[i];\n\n    vc.clear();\n    rep(i, 26) v[i] = PP(P(INF, 0), P(INF, 0));\n    rep(i, h)rep(j, w) {\n      if (s[i][j] != '.') {\n        minch(v[s[i][j] - 'A'].fi.fi, j), maxch(v[s[i][j] - 'A'].fi.se, j);\n        minch(v[s[i][j] - 'A'].se.fi, i), maxch(v[s[i][j] - 'A'].se.se, i);\n        vc.pb(s[i][j]);\n      }\n    }\n\n    sort(all(vc));\n    uni(vc);\n    bool ans = false;\n    do {\n      if (ok()) {\n        ans = true;\n        break;\n      }\n    } while(next_permutation(all(vc)));\n\n    cout << ((ans) ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <map>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nstruct rect { int ly, ry, lx, rx; };\n\nint T, H, W;\nchar S[55][55];\n\nint main(void) {\n  cin >> T;\n  while(T--) {\n    cin >> H >> W;\n    REP(i, 0, H) cin >> S[i];\n\n    set<char> st;\n    REP(i, 0, H) REP(j, 0, W) if(S[i][j] != '.') st.insert(S[i][j]);\n    map<char, int> ctoi;\n    for(char i : st) ctoi[i] = ctoi.size();\n\n    int a[7];\n    REP(i, 0, 7) a[i] = i;\n\n    int ans = false;\n    do {\n      map<char, rect> p;\n      REP(i, 0, H) REP(j, 0, W) if(S[i][j] != '.') p[S[i][j]] = (rect) { i, i, j, j };\n\n      REP(i, 0, H) REP(j, 0, W) {\n        if(S[i][j] != '.') {\n          p[S[i][j]].ly = min(p[S[i][j]].ly, i);\n          p[S[i][j]].ry = max(p[S[i][j]].ry, i);\n          p[S[i][j]].lx = min(p[S[i][j]].lx, j);\n          p[S[i][j]].rx = max(p[S[i][j]].rx, j);\n        }\n      }\n\n      bool f = true;\n      for(pair<char, rect> r : p) {\n        char c = r.first;\n        rect q = r.second;\n        REP(i, q.ly, q.ry + 1) REP(j, q.lx, q.rx + 1) {\n          if(S[i][j] == '.' || a[ctoi[c]] < a[ctoi[S[i][j]]]) f = false;\n        }\n      }\n      ans = ans || f;\n    } while(next_permutation(a, a + st.size()));\n\n    cout << (ans ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<iostream>\n#include<cmath>\n#include<map>\n#include<set>\n#include<climits>\n#include<ctime>\n#include<complex>\n#include<sstream>\n#include<cstring>\nusing namespace std;\ntypedef vector<string>vs;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\ntypedef vector<double>vd;\ntypedef pair<int,int>pii;\ntypedef long long ll;\ntypedef pair<ll,ll>pll;\ntypedef vector<ll>vl;\n#define rrep(i,x,n) for(int i=(x);i<(n);++i)\n#define rep(i,x) rrep(i,0,(x))\n#define fi first\n#define se second\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define maxs(a,b) (a)=max(a,b)\n#define mins(a,b) (a)=min(a,b)\n\nstruct data{\n    int x1,y1,x2,y2;\n    data(){\n        x1=y1=100;\n        x2=y2=-1;\n    }\n    void update(int x,int y){\n        x1=min(x1,x);x2=max(x2,x);\n        y1=min(y1,y);y2=max(y2,y);\n    }\n};\n\nbool solve(){\n    int H,W;\n    char fld[64][64];\n    scanf(\"%d%d\",&H,&W);\n    rep(i,H)scanf(\"%s\",fld[i]);\n\n    map<char,data>M;\n\n    rep(i,H){\n        rep(j,W){\n            if(fld[i][j]=='.')continue;\n            data d=M[fld[i][j]];\n            d.update(j,i);\n            M[fld[i][j]]=d;\n        }\n    }\n\n    bool flag=true;\n\n    each(it,M){\n        data d=it->se;\n\n        for(int i=d.y1;i<=d.y2;i++){\n            for(int j=d.x1;j<=d.x2;j++){\n                if(fld[i][j]=='.')flag=false;\n            }\n        }\n    }\n\n    return flag;\n}\nint main(){\n    int N;\n    scanf(\"%d\",&N);\n    while(N--){\n        puts((solve()?\"SAFE\":\"SUSPICIOUS\"));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\nint N, M;\n\nbool check(vector<vector<char> > &v) {\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            if (v[i][j] != '.' && v[i][j] != 'x') return true;\n        }\n    }\n\n    return false;\n}\n\nbool check2(vector<vector<char> > &v, int sx, int sy, int gx, int gy, char str) {\n    set<char> res;\n    for (int i = sx; i <= gx; i++) {\n        for (int j = sy; j <= gy; j++) {\n            if (v[i][j] == 'x' || v[i][j] == str);\n            else return false;\n        }\n    }\n\n    return true;\n}\n\nvector<int> found(vector<vector<char> > &v, char str) {\n    int sx = 1 << 28, sy = 1 << 28, gx = -1, gy = -1;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            if (v[i][j] == str) {\n                sx = min(sx, i);\n                gx = max(gx, i);\n                sy = min(sy, j);\n                gy = max(gy, j);\n            }\n        }\n    }\n\n    if (check2(v, sx, sy, gx, gy, str)) {\n        return vector<int>{sx, sy, gx, gy};\n    }\n\n    return vector<int>{-1, -1, -1, -1};\n}\n\nvoid solve() {\n    cin >> N >> M;\n    vector<vector<char> > v(N, vector<char>(M));\n    set<int> s;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            cin >> v[i][j];\n            if (v[i][j] != '.') s.insert(v[i][j]);\n        }\n    }\n\n    bool res = true;\n\n    while (check(v)) {\n        bool flag = false;\n        auto tmp = s;\n        for (auto str : tmp) {\n            auto L = found(v, str);\n\n            if (L[0] < 0) {\n                continue;\n            }\n            s.erase(str);\n            flag = true;\n            for (int i = L[0]; i <= L[2]; i++)\n                for (int j = L[1]; j <= L[3]; j++)\n                    v[i][j] = 'x';\n        }\n        if (!flag) {\n            res = false;\n            break;\n        }\n    }\n\n    cout << (res ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n}\n\nint main() {\n    int Q; cin >> Q;\n    for (int q = 0; q < Q; q++) {\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<set>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a,i<b;++i)\n#define rep(i,n) REP(i,0,n)\n\nstruct P {\n  int maxx,maxy,minx,miny;\n  P() {\n    maxx = maxy = -1;\n    minx = miny = 51;\n  }\n};\n\nint dist[26][26];\nint visited[26];\n\nint main() {\n  int h,w,n,k,l,start,now,i,j;\n  string s;\n  cin>>n;\n  while(n--) {\n    cin>>h>>w;\n    vector<string> in;\n    for(i=0; i<h; ++i) {\n      cin>>s;\n      in.push_back(s);\n    }\n\n    for(k=0; k<26; ++k) {\n      for(l=0; l<26; ++l) {\n\tdist[k][l] = 0;\n      }\n    }\n\n    set<char> badget;\n    map<char, P> mp;\n    queue<int> Q;\n    for(i=0; i<h; ++i) {\n      for(j=0; j<w; ++j) {\n\tif(in[i].at(j) != '.') {\n\t  badget.insert(in[i].at(j));\n\t  mp[in[i].at(j)].maxx = max(mp[in[i].at(j)].maxx, j);\n\t  mp[in[i].at(j)].maxy = max(mp[in[i].at(j)].maxy, i);\n\t  mp[in[i].at(j)].minx = min(mp[in[i].at(j)].minx, j);\n\t  mp[in[i].at(j)].miny = min(mp[in[i].at(j)].miny, i);\n\t}\n      }\n    }\n\n    if(badget.size() == 0) {\n      cout<<\"SAFE\"<<endl;\n      goto NEXT;\n    }\n\n    for(set<char>::iterator it = badget.begin(); it != badget.end(); ++it) {\n      int maxx = mp[(*it)].maxx,maxy = mp[(*it)].maxy;\n      int minx = mp[(*it)].minx,miny = mp[(*it)].miny;\n      for(i=miny; i<=maxy; ++i) {\n\tfor(j=minx; j<maxx; ++j) {\n\t  if(in[i].at(j) == '.') {\n\t    cout<<\"SUSPICOUS\"<<endl;\n\t    goto NEXT;\n\t  }else if(in[i].at(j) != (*it)) {\n\t    dist[(*it)-'A'][in[i].at(j)-'A'] = 1;\n\t  }\n\t}\n      }\n    }\n\n    //±±Ég|WJ\\[gð­\n    //dist[i][j] Í iÌãÉjªæÁÄ¢éÆ¢¤ÖWð\\·\n    start = (*badget.begin()) - 'A';\n    memset(visited, 0, sizeof(visited));\n    Q.push(start);\n    while(!Q.empty()) {\n      now = Q.front(); Q.pop();\n      if(visited[now]) {\n\tcout<<\"SUSPICOUS\"<<endl;\n\tgoto NEXT;\n      }\n      visited[now] = 1;\n      for(i=0; i<26; ++i) {\n\tif(dist[now][i]) {\n\t  Q.push(i);\n\t}\n      }\n    }\n\n    Q.push(start);\n    while(!Q.empty()) {\n      now = Q.front(); Q.pop();\n      if(now != start && visited[now]) {\n\tcout<<\"SUSPICOUS\"<<endl;\n\tgoto NEXT;\n      }\n      visited[now] = 1;\n      for(i=0; i<26; ++i) {\n\tif(dist[i][now]) {\n\t  Q.push(i);\n\t}\n      }\n    }\n\n    cout<<\"SAFE\"<<endl;\n  NEXT:\n    ;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <map>\n#include <algorithm>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nstruct rect { int ly, ry, lx, rx; };\n\nint T, H, W;\nchar S[55][55];\n\nint main(void) {\n  cin >> T;\n  while(T--) {\n    cin >> H >> W;\n    REP(i, 0, H) cin >> S[i];\n\n    set<char> st;\n    REP(i, 0, H) REP(j, 0, W) if(S[i][j] != '.') st.insert(S[i][j]);\n    map<char, int> ctoi;\n    for(char i : st) ctoi[i] = ctoi.size();\n\n    int a[10];\n    REP(i, 0, 10) a[i] = i;\n\n    map<char, rect> p;\n    REP(i, 0, H) REP(j, 0, W) if(S[i][j] != '.') p[S[i][j]] = (rect) { i, i, j, j };\n    REP(i, 0, H) REP(j, 0, W) {\n      if(S[i][j] != '.') {\n        p[S[i][j]].ly = min(p[S[i][j]].ly, i);\n        p[S[i][j]].ry = max(p[S[i][j]].ry, i);\n        p[S[i][j]].lx = min(p[S[i][j]].lx, j);\n        p[S[i][j]].rx = max(p[S[i][j]].rx, j);\n      }\n    }\n\n    bool ans = false;\n    do {\n      bool f = true;\n      for(pair<char, rect> r : p) {\n        char c = r.first;\n        rect q = r.second;\n        REP(i, q.ly, q.ry + 1) REP(j, q.lx, q.rx + 1) {\n          if(S[i][j] == '.' || a[ctoi[c]] < a[ctoi[S[i][j]]]) {\n            f = false;\n            goto END;\n          }\n        }\n      }\nEND:\n      ans = ans || f;\n      if(ans) break;\n    } while(next_permutation(a, a + st.size()));\n\n    cout << (ans ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\n#define pb push_back\n#define FOR(i, a, b) for (ll i = (signed)(a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define EREP(i, n) for (int i = (n)-1; i >= 0; --i)\n#define MOD 1000000007\n#define INF 93193111451418101\n#define MIN -93193111451418101\n#define EPS 1e-11\nusing namespace std;\n\nchar grid[51][51];\nll n, h, w;\n\nbool check(vector<ll> &v, ll lx[50], ll ly[50], ll rx[50], ll ry[50], ll c) {\n  ll itr = 0;\n  itr = find(v.begin(), v.end(), c) - v.begin();\n  FOR(i, ly[c], ry[c] + 1) {\n    FOR(j, lx[c], rx[c] + 1) {\n      if (grid[i][j] == '.')\n        return 0;\n      if (grid[i][j] != c + 'A') {\n        REP(k, (signed)v.size()) {\n          if (v[k] + 'A' == grid[i][j] && k > itr)\n            return 0;\n        }\n      }\n    }\n  }\n  return 1;\n}\n\nint main() {\n  cin >> n;\n  string str = \"\";\n  REP(loop, n) {\n    ll lx[50] = {}, ly[50] = {}, rx[50] = {}, ry[50] = {};\n    REP(i, 50) { lx[i] = 100, ly[i] = 100; }\n    vector<ll> v;\n    cin >> h >> w;\n    REP(i, h) {\n      REP(j, w) { cin >> grid[i][j]; }\n    }\n    REP(i, h) REP(j, w) {\n      const char c = grid[i][j];\n      const ll cl = grid[i][j] - 'A';\n      if (c == '.')\n        continue;\n      v.pb(cl);\n      lx[cl] = min(lx[cl], j);\n      ly[cl] = min(ly[cl], i);\n      ry[cl] = max(ry[cl], i);\n      rx[cl] = max(rx[cl], j);\n    }\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    bool ff = 0;\n    do {\n      ff = 0;\n      for (auto &a : v) {\n        if (check(v, lx, ly, rx, ry, a) == 0) {\n          ff = 1;\n          break;\n        }\n      }\n      if (!ff) {\n        str += \"SAFE\\n\";\n        break;\n      }\n    } while (next_permutation(v.begin(), v.end()));\n    if (ff)\n      str += \"SUSPICIOUS\\n\";\n  }\n  cout << str << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nstruct make\n{\n\tchar str;\n\tint posi,start[2];\n\tint high,wide,JUDGE;//JUDGE==1で長方形,==0で長方形以外,==2で未定\n\tstruct make *front;\n};\n\n\nint main()\n{\n\tint N,H,W,count,COUNT,judge,no_rect,NO_RECT;\n\tchar img[1000][51],RECT[8];\n\tstruct make M[8];\n\tint s1,s2,num;\n\t\n\tscanf(\"%d\",&N);//データの個数\n\tfor(int a=0;a<N;a++)\n\t{\n\t\tcount=0;//材質の個数\n\t\tCOUNT=0;\n\t\tNO_RECT=0;\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tscanf(\"%s\",img[b]);\n\t\t\timg[b][W]='\\0';\n\t\t}\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tfor(int d=0;d<count;d++) M[d].posi=-1;\n\t\t\tfor(int c=0;c<W;c++)\n\t\t\t{\n\t\t\t\tif(img[b][c]!='.')\n\t\t\t\t{\n\t\t\t\t\t//材質判定\n\t\t\t\t\tjudge=0;\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t\tif(count>0 && img[b][c]!=M[judge].str) judge++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}while(judge<count);\n\t\t\t\t\t//新しい材質の場合\n\t\t\t\t\tif(judge==count)\n\t\t\t\t\t{\n\t\t\t\t\t\tM[count].str=img[b][c];\n\t\t\t\t\t\tM[count].start[0]=b;\n\t\t\t\t\t\tM[count].start[1]=c;\n\t\t\t\t\t\tM[count].posi=c;\n\t\t\t\t\t\tM[count].high=1;\n\t\t\t\t\t\tM[count].wide=1;\n\t\t\t\t\t\tM[count].JUDGE=0;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\t//既出の材質の場合\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(M[judge].start[1]>c) M[judge].start[1]=c;\n\t\t\t\t\t\tif(M[judge].posi<0) M[judge].posi=c;\n\t\t\t\t\t\telse if(M[judge].wide<c-M[judge].posi+1) M[judge].wide=c-M[judge].posi+1;\n\t\t\t\t\t\tM[judge].high=b-M[judge].start[0]+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tno_rect=count;\n\t\t//printf(\"count=%d\\n\",count);\n\t\t//判定開始\n\t\twhile(count)//文字アリ\n\t\t{\n\t\t\tCOUNT=0;\n\t\t\t//見えている部分が長方形かどうか判定\n\t\t\tfor(num=0;num<count;num++)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(M[num].JUDGE==1) continue;\n\t\t\t\tM[num].JUDGE=0;//長方形なら\n\t\t\t\t//printf(\"M[%d].str=%c\\nM[%d].high=%d\\nM[%d].wide=%d\\n\",num,M[num].str,num,M[num].high,num,M[num].wide);\n\t\t\t\t//printf(\"M[%d].start[0]=%d\\nM[%d].start[1]=%d\\n\",num,M[num].start[0],num,M[num].start[1]);\n\t\t\t\tfor(s1=0;s1<M[num].high;s1++)\n\t\t\t\t{\n\t\t\t\t\tfor(s2=0;s2<M[num].wide;s2++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//確実に長方形ではない場合\n\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]=='.')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNO_RECT=1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//長方形の可能性もある場合\n\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]!=M[num].str)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int r=0;r<count-no_rect;)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]==RECT[r]) break;\n\t\t\t\t\t\t\t\tr++;\n\t\t\t\t\t\t\t\tif(r==count-no_rect)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tM[num].JUDGE=2;\n\t\t\t\t\t\t\t\t\tCOUNT++;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(NO_RECT || M[num].JUDGE==2) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(NO_RECT || M[num].JUDGE==2) break;\n\t\t\t\t}\n\t\t\t\tif(NO_RECT) break;\n\t\t\t\t//長方形だった場合\n\t\t\t\tif(s1==M[num].high && s2==M[num].wide)\n\t\t\t\t{\n\t\t\t\t\tM[num].JUDGE=1;\n\t\t\t\t\tno_rect--;\n\t\t\t\t\tM[num].front=NULL;\n\t\t\t\t\tRECT[num]=M[num].str;\n\t\t\t\t}\n\t\t\t\t//printf(\"M[%d].JUDGE=%d\\n\\n\",num,M[num].JUDGE);\n\t\t\t}\n\t\t\tfor(int n=0;n<num;)\n\t\t\t{\n\t\t\t\tif(M[num].JUDGE!=2 && M[num].JUDGE!=1) break;\n\t\t\t\tn++;\n\t\t\t\t//どれも長方形ではなかった場合\n\t\t\t\tif(n==num) NO_RECT=1;\n\t\t\t}\n\t\t\t\n\t\t\t//printf(\"NO_RECT=%d\\n\",NO_RECT);\n\t\t\tif(NO_RECT==1) break;\n\t\t\t//printf(\"#no_rect=%d\\n\\n\\n\",no_rect);\n\t\t\t//すべて長方形\n\t\t\tif(no_rect==0) break;\n\t\t}\n\t\t//出力\n\t\tif(NO_RECT) printf(\"SUSPICIOUS1\\n\");\n\t\telse if(no_rect) printf(\"SUSPICIOUS2\\n\");\n\t\telse printf(\"SAFE1\\n\");\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define FOR(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(x) x.begin(),x.end()\n#define ll long long\ntypedef pair<int,int> pii;\n\nint H,W;\nchar A[101][101];\nint B[101][101];\nint L[10],R[10],U[10],D[10];\nint C[101][101];\nvoid solve(){\n\tcin>>H>>W;\n\tset<char>st;\n\tREP(i,H){\n\t\tREP(j,W){\n\t\t\tcin>>A[i][j];\n\t\t\tif(A[i][j]!='.')st.insert(A[i][j]);\n\t\t}\n\t}\n\tmap<char,int>mp;\n\tint id=0;\n\tfor(auto c:st){\n\t\tmp[c]=id;\n\t\tid++;\n\t}\n\tREP(i,10){\n\t\tL[i]=1e9,R[i]=-1,U[i]=1e9,D[i]=-1;\n\t}\n\tREP(i,H){\n\t\tREP(j,W){\n\t\t\tif(A[i][j]=='.')B[i][j]=-1;\n\t\t\telse {\n\t\t\t\tB[i][j]=mp[A[i][j]];\n\t\t\t\tint id = mp[A[i][j]];\n\t\t\t\tL[id]=min(L[id],j);\n\t\t\t\tR[id]=max(R[id],j);\n\t\t\t\tU[id]=min(U[id],i);\n\t\t\t\tD[id]=max(D[id],i);\n\t\t\t}\n\t\t}\n\t}\n\tint perm[10];\n\tint M=st.size();\n\tREP(i,M)perm[i]=i;\n\tbool safe = false;\n\tdo{\n\t\tREP(i,H){\n\t\t\tREP(j,W){\n\t\t\t\tC[i][j]=B[i][j];\n\t\t\t}\n\t\t}\n\t\tbool ok = true;\n\t\tREP(i,M){\n\t\t\tint id = perm[i];\n\t\t\tFOR(i,U[id],D[id]+1){\n\t\t\t\tFOR(j,L[id],R[id]+1){\n\t\t\t\t\tif(C[i][j]!=id&&C[i][j]!=-2){\n\t\t\t\t\t\tok=false;\n\t\t\t\t\t\t//goto END;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tFOR(i,U[id],D[id]+1){\n\t\t\t\tFOR(j,L[id],R[id]+1){\n\t\t\t\t\tC[i][j]=-2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tEND:;\n\t\tif(ok){\n\t\t\tsafe=true;\n\t\t}\n\t}while(next_permutation(perm,perm+M));\n\tif(safe)cout<<\"SAFE\"<<endl;\n\telse cout<<\"SUSPICIOUS\"<<endl;\n}\n\nsigned main() {\n\tint q;cin>>q;\n\twhile (q--) {\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint main(void)\n{\n  int n;\n  cin >> n;\n  REP(_,n){\n    int h,w;\n    cin >> h >> w;\n    if(!h) return 0;\n    vector<string> sc;\n    sc.resize(h);\n    REP(i,h) cin >> sc[i];\n    set<char> car;\n    car.clear();\n    REP(i,h) REP(j,w) if(sc[i][j]!='.') car.insert(sc[i][j]);\n    vector<char> carv(car.begin(),car.end());\n    string answer=\"SUSPICIOUS\";\n    map<char,int> u,d,l,r;\n    REP(dep,carv.size()){\n      u[carv[dep]]=100;\n      d[carv[dep]]=-1;\n      l[carv[dep]]=100;\n      r[carv[dep]]=-1;\n    }\n    REP(dep,carv.size()) REP(i,h) REP(j,w) if(sc[i][j]==carv[dep]){\n      u[carv[dep]]=min(u[carv[dep]],i);\n      d[carv[dep]]=max(d[carv[dep]],i);\n      l[carv[dep]]=min(l[carv[dep]],j);\n      r[carv[dep]]=max(r[carv[dep]],j);\n    }\n    do{\n      vector<string> prob;\n      prob.resize(h);\n      REP(i,h) prob[i].assign(w,'.');\n      REP(dep,carv.size()){\n\tFOR(i,u[carv[dep]],d[carv[dep]]+1) FOR(j,l[carv[dep]],r[carv[dep]]+1){\n\t  prob[i][j]=carv[dep];\n\t}\n      }\n      bool flag=true;\n      REP(i,h) if(sc[i]!=prob[i]) flag=false;\n      if(flag){\n\tanswer=\"SAFE\";\n\tbreak;\n      }\n    }while(next_permutation(carv.begin(),carv.end()));\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\nusing namespace std;\n \ntypedef pair<int, int> P;\n \nconst int MAX_S = 51;\nconst int dx[4] = {1,0,-1,0};\nconst int dy[4] = {0,1,0,-1};\nint H, W;\nchar G[MAX_S][MAX_S];\nbool vis[MAX_S][MAX_S];\n \nvoid show() {\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      cout << G[i][j];\n    }\n    cout << endl;\n  }\n}\n \npair<P, P> rec(int x, int y, char c) {\n  vis[y][x] = true;\n  pair<P, P> p = make_pair(P(x, y), P(x, y));\n  for(int i = 0; i < 4; ++i) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(nx < 0 || nx >= W) continue;\n    if(ny < 0 || ny >= H) continue;\n    if(vis[ny][nx]) continue;\n    if(G[ny][nx] != c) continue;\n    pair<P, P> q = rec(nx, ny, c);\n    p.first.first = min(p.first.first, q.first.first);\n    p.first.second = min(p.first.second, q.first.second);\n    p.second.first = max(p.second.first, q.second.first);\n    p.second.second = max(p.second.second, q.second.second);\n  }\n  return p;\n}\n \nvoid make(map<char, pair<P, P> > &m) {\n  for(int i = 0; i < H; ++i) fill(vis[i], vis[i]+W, false);\n \n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if(!vis[i][j] && G[i][j] != '.') {\n        pair<P, P> q = rec(j, i, G[i][j]);\n        //v.push_back(q);\n        if(m.find(G[i][j]) == m.end()) {\n          m[G[i][j]] = q;\n        } else {\n          pair<P, P> &p = m[G[i][j]];\n          p.first.first = min(p.first.first, q.first.first);\n          p.first.second = min(p.first.second, q.first.second);\n          p.second.first = max(p.second.first, q.second.first);\n          p.second.second = max(p.second.second, q.second.second);\n        }\n      }\n    }\n  }\n}\n \nbool isShikaku(int sx, int sy, int ex, int ey) {\n  char c = 0;\n  for(int i = sy; i <= ey; ++i) {\n    for(int j = sx; j <= ex; ++j) {\n      if(G[i][j] == '.') return false;\n      if(c == 0) {\n        if(G[i][j] != '#') c = G[i][j];\n      } else if(G[i][j] != c && G[i][j] != '#') {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n \nvoid fills(int sx, int sy, int ex, int ey) {\n  for(int i = sy; i <= ey; ++i) {\n    for(int j = sx; j <= ex; ++j) {\n      G[i][j] = '#';\n    }\n  }\n}\n \nbool ans() {\n  vector<pair<P, P> > v;\n  map<char, pair<P, P > > m;\n  make(m);\n  v.clear();\n  for(map<char, pair<P, P> >::iterator it = m.begin(); it != m.end(); ++it) {\n    v.push_back(it->second);\n  }\n  for(;;) {\n    bool flag = true;\n    for(vector<pair<P, P> >::iterator it = v.begin(); it != v.end();) {\n      pair<P, P> p = *it;\n      if(isShikaku(p.first.first, p.first.second,\n                   p.second.first, p.second.second)) {\n \n        fills(p.first.first, p.first.second,\n              p.second.first, p.second.second);\n \n        it = v.erase(it);\n        flag = false;\n      } else {\n        ++it;\n      }\n    }\n    if(flag) return v.size() == 0;\n  }\n}\n \nint main() {\n  int T;\n  cin >> T;\n  while(T--) {\n    cin >> H >> W;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n      }\n    }\n    if(ans()) cout << \"SAFE\" << endl;\n    else cout << \"SUSPICIOUS\" << endl;\n    //show();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nstring str[100];\nint h,w;\nint num;\nbool flag;\nbool used[100][100];\nchar moji[10];\nint vx[4]={1,0,-1,0};\nint vy[4]={0,1,0,-1};\nvoid dfs(int Bit,int depth){\n  if(Bit==((1<<num)-1)){\n    flag=true;\n    return;\n  }\n  for(int i=0;i<num;i++){\n    if(!(Bit&(1<<i))){\n      bool used2[100][100]={};\n      int lemi=100,lema=0,rimi=100,rima=0;\n      for(int j=0;j<h;j++){\n\tfor(int k=0;k<w;k++){\n\t  if(str[j][k]==moji[i]){\n\t    used2[j][k]=true;\n\t    used[j][k]=true;\n\t    lemi=min(lemi,k);\n\t    lema=max(lema,k);\n\t    rima=max(rima,j);\n\t    rimi=min(rimi,j);\n\t  }\n\t}\n      }\n      bool fll=true;\n      for(int j=rimi;j<=rima;j++){\n\tfor(int k=lemi;k<=lema;k++){\n\t  if(!used[j][k]){\n\t    fll=false;\n\t  }\n\t}\n      }\n      if(fll)\n\tdfs(Bit+(1<<i),depth+1);\n      for(int j=rimi;j<=rima;j++){\n\tfor(int k=lemi;k<=lema;k++){\n\t  if(used2[j][k]){\n\t    used[j][k]=false;\n\t  }\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int n;cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>h>>w;\n    num=0;\n    for(int i=0;i<55;i++)\n      for(int j=0;j<55;j++)\n\tused[i][j]=false;\n    flag=false;\n    bool alfa[26]={};\n    for(int i=0;i<h;i++){\n      cin>>str[i];\n      for(int j=0;j<w;j++){\n\talfa[str[i][j]-'A']=true;\n      }\n    }\n    int cnt=0;\n    for(int i=0;i<26;i++){\n      if(alfa[i]){\n\tnum++;\n\tmoji[cnt]=(char)(i+'A');\n\tcnt++;\n      }\n    }\n    dfs(0,0);\n    if(flag)\n      cout<<\"SAFE\"<<endl;\n    else \n      cout<<\"SUSPICIOUS\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <string>\n#include <cmath>\n#include <map>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int inf = 100100100;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int number;\n  cin >> number;\n  rep(aaaaaaa,number){\n      int h,w;\n      bool flag =true;\n      cin >> h >> w;\n      string s[55]={};\n      map<char,bool> m;\n      rep(y,h){\n          cin >> s[y];\n      }\n      rep(y,h)rep(x,w){\n          if(s[y][x]!='.'){\n              if(m[s[y][x]]){\n                  flag = false;\n                  x=w;y=h;break;\n              }\n              int st = x;\n              char tc = s[y][x];\n              m[tc] = true;\n              while(s[y][x]==tc) x++;\n              int et = x;\n              int yy = y;\n              while(s[yy][st]==tc){\n                  REP(xx,st,et) {\n                      if(s[yy][xx]!=tc){flag=false;}\n                      s[yy][xx]='.';\n                  }\n                  yy+=1;\n              }\n              // rep(ya,h) cout << s[ya] << endl;\n              x--;\n          }\n      }\n      rep(y,h)rep(x,w){\n         if(s[y][x]!='.') flag = false;\n      }\n      if(flag) cout << \"SAFE\" << endl;\n      else cout << \"SUSPICIOUS\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nstruct make\n{\n\tchar str;\n\tint posi,start[2];\n\tint high,wide,JUDGE;\n\tstruct make *front[8];\n\tint f_count;\n};\n\nint main()\n{\n\tint N,H,W,count,COUNT,judge,no_rect[7],NO_RECT;\n\tchar img[1000][51];\n\tstruct make M[8];\n\tstruct make *MP;\n\t\n\tscanf(\"%d\",&N);//データの個数\n\tfor(int a=0;a<N;a++)\n\t{\n\t\tcount=0;//材質の個数\n\t\tCOUNT=0;\n\t\tNO_RECT=0;\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tscanf(\"%s\",img[b]);\n\t\t\timg[b][W]='\\0';\n\t\t}\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tfor(int d=0;d<count;d++) M[d].posi=-1;\n\t\t\tfor(int c=0;c<W;c++)\n\t\t\t{\n\t\t\t\tif(img[b][c]!='.')\n\t\t\t\t{\n\t\t\t\t\t//材質判定\n\t\t\t\t\tjudge=0;\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t\tif(count>0 && img[b][c]!=M[judge].str) judge++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}while(judge<count);\n\t\t\t\t\t//新しい材質の場合\n\t\t\t\t\tif(judge==count)\n\t\t\t\t\t{\n\t\t\t\t\t\tM[count].str=img[b][c];\n\t\t\t\t\t\tM[count].start[0]=b;\n\t\t\t\t\t\tM[count].start[1]=c;\n\t\t\t\t\t\tM[count].posi=c;\n\t\t\t\t\t\tM[count].high=1;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\t//既出の材質の場合\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(M[judge].start[1]>c) M[judge].start[1]=c;\n\t\t\t\t\t\tif(M[judge].posi<0) M[judge].posi=c;\n\t\t\t\t\t\telse if(M[judge].wide<c-M[judge].posi+1) M[judge].wide=c-M[judge].posi+1;\n\t\t\t\t\t\tM[judge].high=b-M[judge].start[0]+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//判定開始\n\t\tif(count)\n\t\t{\n\t\t\t//見えている部分が長方形かどうか判定\n\t\t\tfor(int b=0;b<count;b++)\n\t\t\t{\n\t\t\t\tM[b].JUDGE=1;\n\t\t\t\tM[b].f_count=0;\n\t\t\t\tfor(int c=0;c<8;c++) M[b].front[c]=NULL;\n\t\t\t\tfor(int s1=0;s1<M[b].high;s1++)\n\t\t\t\t{\n\t\t\t\t\tfor(int s2=0;s2<M[b].wide;s2++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//確実に長方形ではない場合\n\t\t\t\t\t\tif(img[s1+M[b].start[0]][s2+M[b].start[1]]=='.')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNO_RECT=1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//長方形の可能性もある場合\n\t\t\t\t\t\tif(img[s1+M[b].start[0]][s2+M[b].start[1]]!=M[b].str)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int c=0;c<count;c++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint e=0;\n\t\t\t\t\t\t\t\tfor(int d=0;d<M[b].f_count;)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif(img[s1+M[b].start[0]][s2+M[b].start[1]]==M[b].front[d]->str) break;\n\t\t\t\t\t\t\t\t\td++;\n\t\t\t\t\t\t\t\t\te=d;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//今いる座標のもじと比べる\n\t\t\t\t\t\t\t\tif(img[s1+M[b].start[0]][s2+M[b].start[1]]==M[c].str && e==M[b].f_count)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tM[b].front[M[b].f_count]=&M[c];\n\t\t\t\t\t\t\t\t\tM[b].f_count++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(M[b].JUDGE!=0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tno_rect[COUNT]=b;\n\t\t\t\t\t\t\t\tCOUNT++;\n\t\t\t\t\t\t\t\tM[b].JUDGE=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(NO_RECT==1) break;\n\t\t\t\t}\n\t\t\t\tif(M[b].JUDGE)M[b].front[M[b].f_count]=NULL;\n\t\t\t}\n\t\t\tif(NO_RECT) printf(\"SUSPICIOUS\\n\");\n\t\t\telse if(COUNT)\n\t\t\t{\n\t\t\t\tif(count!=COUNT)\n\t\t\t\t{\n\t\t\t\t\t//循環していないか確認\n\t\t\t\t\tfor(int b=0;b<COUNT;b++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int c=0;c<M[no_rect[b]].f_count;c++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMP=M[no_rect[b]].front[c];\n\t\t\t\t\t\t\tfor(int d=0;;d++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(MP==NULL) break;\n\t\t\t\t\t\t\t\tif(d>count)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tprintf(\"SUSPICIOUS\\n\");\n\t\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tMP=(MP->front[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"SAFE\\n\");\n\t\t\t\t}\n\t\t\t\telse printf(\"SUSPICIOUS\\n\");\n\t\t\t}\n\t\t\telse printf(\"SAFE\\n\");\n\t\t}\n\t\telse printf(\"SAFE\\n\");\n\t}\n\treturn 0;\n}\n//printf(\"#\\n\");\n//printf(\"#1 count=%d\\n\",count);\n//printf(\"#1 COUNT=%d\\n\",COUNT);\n//printf(\"#1 NO_RECT=%d\\n\",NO_RECT);\n//printf(\"M[%d].str=%c\\nM[%d].high=%d\\nM[%d].wide=%d\\n\\n\",b,M[b].str,b,M[b].high,b,M[b].wide);\n//printf(\"#1\\nM[%d].start[0]=%d\\nM[%d].start[1]=%d\\n\\n\",b,M[b].start[0],b,M[b].start[1]);\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nvoid solve(){\n\tint H,W;\n\tcin>>H>>W;\n\tvector<string>v(H);\n\tmap<char,int>sheets;\n\tmap<char,pair<int,int>>ma;\n\tmap<char,pair<int,int>>mi;\n\tfor(int i=0;i<H;i++){\n\t\tcin>>v[i];\n\t\tfor(int j=0;j<W;j++)if(v[i][j]!='.'){\n\t\t\tsheets[v[i][j]]++;\n\t\t\tif(ma.find(v[i][j])==ma.end())ma[v[i][j]]={i,j};\n\t\t\tif(mi.find(v[i][j])==mi.end())mi[v[i][j]]={i,j};\n\t\t\tma[v[i][j]].first=max(ma[v[i][j]].first,i);\n\t\t\tma[v[i][j]].second=max(ma[v[i][j]].second,j);\n\t\t\tmi[v[i][j]].first=min(mi[v[i][j]].first,i);\n\t\t\tmi[v[i][j]].second=min(mi[v[i][j]].second,j);\n\t\t}\n\t}\n\tfor(;!sheets.empty();){\n\t\tbool f=false;\n\t\tfor(auto &e:sheets){\n\t\t\tint hs=mi[e.first].first,ws=mi[e.first].second;\n\t\t\tint he=ma[e.first].first+1,we=ma[e.first].second+1;\n\t\t\tint h=hs,z=0;\n\t\t\tfor(;h<he;h++){int w=ws;for(;w<we;w++){\n\t\t\t\tif(v[h][w]==e.first)z++;\n\t\t\t\telse if(v[h][w]-'0')break;\n\t\t\t}if(w<we)break;}\n\t\t\tif(h==he && z==e.second){\n\t\t\t\tfor(int h=hs;h<he;h++)for(int w=ws;w<we;w++)v[h][w]='0';\n\t\t\t\tsheets.erase(e.first);\n\t\t\t\tf=true;break;\n\t\t\t}\n\t\t}\n\t\tif(!f)break;\n\t}\n\tcout<<(sheets.empty()?\"SAFE\":\"SUSPICIOUS\")<<endl;\n}\nint main(){int T;for(cin>>T;T--;)solve();}\n"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define INF 1e9\n#define EPS 1e-9\n#define MOD (1e9+7)\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\n\n#define xmin first.first\n#define xmax first.second\n#define ymin second.first\n#define ymax second.second\n\nint main(){\n\tint n;\n\tcin>>n;\n\trep(datasets,n){\n\t\tmap<char,int> mp;\n\t\tmap<int,pair<pii,pii>> pt;\n\n\t\tint h,w;\n\t\tcin>>h>>w;\n\t\tmp['.']=0;\n\t\tpt[0]={{w,0},{h,0}};\n\t\tvvi f(h,vi(w));\n\t\trep(i,h)rep(j,w){\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tif(mp.find(c)==mp.end()){\n\t\t\t\tmp[c]=mp.size()-1;\n\t\t\t\tpt[mp[c]]={{w,0},{h,0}};\n\t\t\t}\n\t\t\tf[i][j]=mp[c];\n\t\t\tpt[mp[c]].xmin=min(pt[mp[c]].xmin,j);\n\t\t\tpt[mp[c]].xmax=max(pt[mp[c]].xmax,j);\n\t\t\tpt[mp[c]].ymin=min(pt[mp[c]].ymin,i);\n\t\t\tpt[mp[c]].ymax=max(pt[mp[c]].ymax,i);\n\t\t}\n\t\t\n\t\tvi perm(mp.size()-1);\n\t\tiota(all(perm),1);\n\t\tbool ok=false;\n\t\tdo{\n\t\t\tauto p=f;\n\t\t\tfor(auto key:perm){\n\t\t\t\tfor(int i=pt[key].ymin;i<=pt[key].ymax;i++){\n\t\t\t\t\tfor(int j=pt[key].xmin;j<=pt[key].xmax;j++){\n\t\t\t\t\t\tif(f[i][j]!=key and f[i][j]!=-1){\n\t\t\t\t\t\t\tgoto next;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tf[i][j]=-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tok=true;\n\t\t\tbreak;\n\t\t\tnext:;\n\t\t}while(next_permutation(all(perm)));\n\t\tif(ok){\n\t\t\tcout<<\"SAFE\"<<endl;\n\t\t}else{\n\t\t\tcout<<\"SUSPICIOUS\"<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint c[26][26],d[26];\nint fn(int p){\n  int i;\n  if(d[p]){\n    return 1;\n  }else{\n    d[p]=-1;\n    for(i=0;i<26;i++){\n      if(c[p][i]){\n\tif(fn(i))\n\t  return 1;\n      }\n    }\n    return 0;\n  }\n}\nint main(){\n  int i,j,k;\n  int n;\n  cin>>n;\n  for(k=0;k<n;k++){//\n    int w,h;\n    cin>>w>>h;\n    char a[50][50];\n    map<char,pair<pair<int,int>,pair<int,int> > > b;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tcin>>a[i][j];\n\tif(a[i][j]!='.'){\n\t  if(b.count(a[i][j])){\n\t    b[a[i][j]].first.first=min(b[a[i][j]].first.first,j);\n\t    b[a[i][j]].first.second=min(b[a[i][j]].first.second,i);\n\t    b[a[i][j]].second.first=max(b[a[i][j]].second.first,j);\n\t    b[a[i][j]].second.second=max(b[a[i][j]].second.second,i);\n\t  }else{\n\t    b[a[i][j]].first.first=j;\n\t    b[a[i][j]].first.second=i;\n\t    b[a[i][j]].second.first=j;\n\t    b[a[i][j]].second.second=i;\n\t  }\n\t}\n      }\n    }\n    memset(c,0,sizeof(c));\n    map<char,pair<pair<int,int>,pair<int,int> > >::iterator it;\n    for(it=b.begin();it!=b.end();it++){\n      for(i=(*it).second.first.second;i<=(*it).second.second.second;i++){\n\tfor(j=(*it).second.first.first;j<=(*it).second.second.first;j++){\n\t  if(0){\n\t  }else if(a[i][j]=='.'){\n\t    break;\n\t  }else if(a[i][j]!=(*it).first){\n\t    c[a[i][j]-'A'][(*it).first-'A']=-1;\n\t  }\n\t}\n\tif(j<=(*it).second.second.first)\n\t  break;\n      }\n      if(i<=(*it).second.second.second)\n\tbreak;\n    }\n    if(it!=b.end()){\n      cout<<\"SUSPICIOUS\"<<endl;\n    }else{\n      map<char,pair<pair<int,int>,pair<int,int> > >::iterator it;\n      for(it=b.begin();it!=b.end();it++){\n\tmemset(d,0,sizeof(d));\n\tif(fn((*it).first-'A'))\n\t  break;\n      }\n      if(it!=b.end())\n\tcout<<\"SUSPICIOUS\"<<endl;\n      else\n\tcout<<\"SAFE\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  int n;\n  cin >> n;\n  while(n--) {\n    int h,w;\n    cin >> h >> w;\n    char ba[w][h];    \n    map<char, int> minx;\n    map<char, int> maxx;\n    map<char, int> miny;\n    map<char, int> maxy;\n    vector<char> v;\n    REP(y,h) {\n      REP(x,w) {\n        char c;\n        cin >> c;\n        ba[x][y] = c;\n        if (c == '.') continue;\n        if (minx.count(c) == 0) {\n          v.push_back(c);\n          minx[c] = x;\n          maxx[c] = x;\n          miny[c] = y;\n          maxy[c] = y;\n        } else {\n          minx[c] = min(minx[c], x);\n          maxx[c] = max(maxx[c], x);\n          miny[c] = min(miny[c], y);\n          maxy[c] = max(maxy[c], y);\n        }\n      }\n    }\n    // FOR(it, v) {\n    //   cout << *it << endl;\n    //   printf(\"%d,%d  %d,%d\\n\", minx[*it], miny[*it], maxx[*it], maxy[*it]);\n    // }\n    sort(ALL(v));\n    bool dame;\n    do {\n      char tmp[w][h];\n      memcpy(tmp, ba, sizeof(ba));\n      dame = 0;\n      FOR(it, v) {\n        char c = *it;\n        // REP(y,h) {\n        //   REP(x,w) {\n        //     cout << tmp[x][y];\n        //   }\n        //   cout << endl;\n        // }\n        for (int y = miny[c]; y<= maxy[c]; ++y) {\n          for (int x = minx[c]; x<= maxx[c]; ++x) {\n            if (tmp[x][y] == c || tmp[x][y] == '*') {\n              tmp[x][y] = '*';\n            } else {\n              dame = 1;\n            }\n          }\n        }\n      }\n      if (!dame)\n        break;\n    }while(next_permutation(ALL(v)));\n    if (dame) {\n      cout << \"SUSPICIOUS\" << endl;\n    } else {\n      cout << \"SAFE\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\nint mat[7][7];\nbool visited[7];\n\nbool find_cycle(int idx) {\n\tvisited[idx] = true;\n\tfor(int i = 0; i < 7; ++i)\n\t\tif(mat[idx][i] && (visited[i] || find_cycle(i)))\n\t\t\treturn true;\n\n\tvisited[idx] = false;\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\twhile(n--) {\n\t\tint h, w;\n\t\tcin >> h >> w;\n\n\t\tvector<string> field(h);\n\t\tmap<char, int> convert;\n\t\tfor(int i = 0; i < h; ++i)\n\t\t\tcin >> field[i];\n\n\t\tvector<int> mx_x(7, -1), mx_y(7, -1), mn_x(7, w), mn_y(7, h);\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tif(field[i][j] == '.')\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif(!convert.count(field[i][j]))\n\t\t\t\t\tconvert.insert(make_pair(field[i][j], convert.size()));\n\n\t\t\t\tconst int idx = convert[field[i][j]];\n\t\t\t\tchmax(mx_x[idx], j);\n\t\t\t\tchmax(mx_y[idx], i);\n\t\t\t\tchmin(mn_x[idx], j);\n\t\t\t\tchmin(mn_y[idx], i);\n\t\t\t}\n\t\t}\n\n\t\tconst int num = (int)convert.size();\n\n\t\tmemset(mat, false, sizeof(mat));\n\t\tFOR(it, convert) {\n\t\t\tconst char target = it->first;\n\t\t\tconst int idx = it->second;\n\t\t\tfor(int i = mn_y[idx]; i <= mx_y[idx]; ++i) {\n\t\t\t\tfor(int j = mn_x[idx]; j <= mx_x[idx]; ++j) {\n\t\t\t\t\tif(field[i][j] == '.')\n\t\t\t\t\t\tgoto ng;\n\n\t\t\t\t\tif(field[i][j] != target)\n\t\t\t\t\t\tmat[convert[field[i][j]]][idx] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(visited, false, sizeof(visited));\n\t\tfor(int i = 0; i < num; ++i)\n\t\t\tif(find_cycle(i))\n\t\t\t\tgoto ng;\n\n\t\tcout << \"SAFE\" << endl;\n\t\tcontinue;\n\n\tng:;\n\t\tcout << \"SUSPICIOUS\" << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\n#define For(i,a,n)\tfor(int i = a;i < n;i++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(n)\t\tmemset(n,0,sizeof n)\n#define all(n)\t\t(n).begin(),(n).end()\n\nconst int INF = 1e9;\nint dx[4] = { 0, 1, 0, -1 }, dy[4] = { 1, 0, -1, 0 };\nbool cheak(int x, int y, int mx, int my){\n\treturn x >= 0 && y >= 0 && x < mx &&  y < my;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\trep(_, n){\n\t\tint h, w;\n\t\tchar d[51][51];\n\t\tcin >> h >> w;\n\t\trep(y, h)rep(x, w){\n\t\t\tcin >> d[y][x];\n\t\t}\n\n\t\tbool f = false;\n\t\tset<char> vs[256];\n\t\tFor(ct, 'A', 'Z' + 1){\n\t\t\tint rx = -1, ry = -1;\n\t\t\tint lx = 51, ly = 51;\n\t\t\trep(y, h)rep(x, w){\n\t\t\t\tif (d[y][x] == ct){\n\t\t\t\t\tlx = min(lx, x), ly = min(ly, y);\n\t\t\t\t\trx = max(rx, x), ry = max(ry, y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tset<char> v;\n\t\t\tFor(y, ly, ry + 1)For(x, lx, rx + 1){\n\t\t\t\tif (d[y][x] == '.'){\n\t\t\t\t\tf = true; goto End;\n\t\t\t\t}\n\t\t\t\tif (d[y][x] != ct){\n\t\t\t\t\tv.insert(d[y][x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvs[ct] = v;\n\t\t}\n\t\trep(i, 256){\n\t\t\tif (vs[i].size()){\n\t\t\t\tqueue<pair<char,vector<bool>>> q;\n\t\t\t\tfor (auto j : vs[i]){\n\t\t\t\t\tvector<bool> cf(256, 0);\n\t\t\t\t\tcf[i] = true;\n\t\t\t\t\tcf[j] = true;\n\t\t\t\t\tq.push(make_pair(j,cf));\n\t\t\t\t}\n\t\t\t\twhile (q.size()){\n\t\t\t\t\tauto now = q.front(); q.pop();\n\t\t\t\t\tfor (auto j : vs[now.first]){\n\t\t\t\t\t\tauto tf = now.second;\n\t\t\t\t\t\tif (tf[j]){\n\t\t\t\t\t\t\tf = true; goto End;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttf[j] = true;\n\t\t\t\t\t\tq.push(make_pair(j,tf));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tEnd:;\n\n\t\tif (f)cout << \"SUSPICIOUS\" << endl;\n\t\telse  cout << \"SAFE\" << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <cstdio>\nusing namespace std;\n\ntemplate <typename F>\ninline void update(map<char, int>& m, char key, int val, F f) {\n  if (m.count(key)) {\n    m[key] = f(m[key], val);\n  } else {\n    m[key] = val;\n  }\n}\n\nbool solve() {\n  typedef const int& (*F)(const int&, const int&);\n  int H, W; scanf(\"%d%d\", &H, &W);\n  vector<string> field(H, string(W, '.'));\n  for (int y = 0; y < H; ++y) {\n    for (int x = 0; x < W; ++x) {\n      scanf(\" %c\", &field[y][x]);\n    }\n  }\n  for (;;) {\n    map<char, int> left, right, top, bottom;\n    bool end = true;\n    for (int y = 0; y < H; ++y) {\n      for (int x = 0; x < W; ++x) {\n        const char ch = field[y][x];\n        if (ch != '.' && ch != '*') {\n          update(left, ch, x, (F)min);\n          update(top, ch, y, (F)min);\n          update(right, ch, x, (F)max);\n          update(bottom, ch, y, (F)max);\n          end = false;\n        }\n      }\n    }\n    if (end) { return true; }\n    bool bad = true;\n    for (auto p : left) {\n      const char ch = p.first;\n      const int l = p.second, r = right[ch], t = top[ch], b = bottom[ch];\n      bool ok = true;\n      for (int y = t; y <= b; ++y) {\n        for (int x = l; x <= r; ++x) {\n          if (field[y][x] != ch && field[y][x] != '*') {\n            ok = false;\n            break;\n          }\n        }\n      }\n      if (ok) {\n        for (int y = t; y <= b; ++y) {\n          for (int x = l; x <= r; ++x) {\n            field[y][x] = '*';\n          }\n        }\n        bad = false;\n        break;\n      }\n    }\n    if (bad) { return false; }\n  }\n}\n\nint main() {\n  int T; scanf(\"%d\", &T);\n  while (T--) {\n    puts(solve() ? \"SAFE\" : \"SUSPICIOUS\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\n\nint h,w,n,co;\nchar bo[52][52];\nint dx[26];\nbool check(int y, int x){\n    for(int i=x+1;i<w;i++){\n        if(bo[i][y]==bo[x][y]){\n            if(y<h-1&&bo[x][y+1]==bo[x][y]){\n                if (bo[i][y+1]=='.')return true;\n                else if(y<h-1&&bo[x][y+1]==bo[x][y]&&bo[i][y+1]!=bo[x][y]){\n                    if(dx[bo[i][y+1]-'A']!=0&&dx[bo[i][y+1]-'A']!=dx[bo[x][y]-'A']+1){\n                        \n                        return true;\n                    }\n                    else{\n                        dx[bo[i][y+1]-'A']=dx[bo[x][y]-'A']+1;\n                    }\n                }\n            }\n            if(y>0&&bo[x][y-1]==bo[x][y]){\n                if(bo[i][y-1]=='.')return true;\n                else if(y>0&&bo[x][y-1]==bo[x][y]&&bo[i][y-1]!=bo[x][y]){\n                    if(dx[bo[i][y-1]-'A']!=0&&dx[bo[i][y-1]-'A']!=dx[bo[x][y]-'A']+1){\n                        return true;\n                    }\n                    else{\n                        \n                        dx[bo[i][y-1]-'A']=dx[bo[x][y]-'A']+1;\n                    }\n                }\n            }\n            \n        }\n        else break;\n    }\n    return false;\n}\n\nint main(){\n    cin>>n;\n    while(n--){\n        co=0;\n        memset(dx,0,sizeof(dx));\n        cin>>h>>w;\n        for(int i=0;i<h;i++)\n            for(int j=0;j<w;j++)\n                cin>>bo[i][j];\n        int fir=0;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                \n                if(bo[i][j]!='.'){\n                    if(fir==0){\n                        dx[bo[i][j]-'A']=5;\n                        fir=1;\n                    }\n                    if(check(i,j)){\n                        cout<<\"SUSPICIOUS\"<<endl;\n                        goto next;\n                    }\n                }\n            }\n        }\n        cout<<\"SAFE\"<<endl;\n    next:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<deque>\n#include<iomanip>\n#include<tuple>\n#include<cassert>\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<int,int> P;\ntypedef pair<LL,int> LP;\nconst int INF=1<<30;\nconst LL MAX=1e9+7;\n\nvoid array_show(int *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%d%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid array_show(LL *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%lld%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid array_show(vector<int> &vec_s,int vec_n=-1,char middle=' '){\n\tif(vec_n==-1)vec_n=vec_s.size();\n\tfor(int i=0;i<vec_n;i++)printf(\"%d%c\",vec_s[i],(i!=vec_n-1?middle:'\\n'));\n}\nvoid array_show(vector<LL> &vec_s,int vec_n=-1,char middle=' '){\n\tif(vec_n==-1)vec_n=vec_s.size();\n\tfor(int i=0;i<vec_n;i++)printf(\"%lld%c\",vec_s[i],(i!=vec_n-1?middle:'\\n'));\n}\n\nvoid init(){\n\t\n}\n\nbool solve(){\n\tint n,m;\n\tint i,j,k;\n\tint a,b,c,d;\n\tstring sa[70];\n\tvector<int> path[10];\n\tmap<char,int> m1;\n\tbool used[11][11];\n\tmemset(used,false,sizeof(used));\n\tcin>>n>>m;\n\tfor(i=0;i<n;i++){\n\t\tcin>>sa[i];\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<m;j++){\n\t\t\tif(sa[i][j]=='.')continue;\n\t\t\tif(m1.find(sa[i][j])==m1.end()){\n\t\t\t\ta=m1.size();\n\t\t\t\tm1[sa[i][j]]=a;\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto node:m1){\n\t\ta=100,b=0,c=100,d=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<m;j++){\n\t\t\t\tif(sa[i][j]!=node.first)continue;\n\t\t\t\ta=min(a,i),b=max(b,i);\n\t\t\t\tc=min(c,j),d=max(d,j);\n\t\t\t}\n\t\t}\n\t\tfor(i=a;i<=b;i++){\n\t\t\tfor(j=c;j<=d;j++){\n\t\t\t\tif(sa[i][j]=='.')return false;\n\t\t\t\tif(sa[i][j]==node.first || used[node.second][m1[sa[i][j]]])continue;\n\t\t\t\tused[node.second][m1[sa[i][j]]]=true;\n\t\t\t\tpath[m1[sa[i][j]]].push_back(node.second);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> path_cnt(10,0);\n\tqueue<int> q1;\n\tn=10;\n\tfor(i=0;i<10;i++){\n\t\tfor(auto to:path[i])path_cnt[to]++;\n\t}\n\tfor(i=0;i<10;i++){\n\t\tif(path_cnt[i]==0)q1.push(i);\n\t}\n\twhile(!q1.empty()){\n\t\ta=q1.front(),q1.pop();\n\t\tn--;\n\t\tfor(auto to:path[a]){\n\t\t\tpath_cnt[to]--;\n\t\t\tif(path_cnt[to]==0)q1.push(to);\n\t\t}\n\t}\n\tif(n)return false;\n\treturn true;\n}\n\nint main(){\n\tint n,i;\n\tinit();\n\tcin>>n;\n\tfor(i=0;i<n;i++){\n\t\tif(solve())cout<<\"SAFE\"<<endl;\n\t\telse cout<<\"SUSPICIOUS\"<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nbool check(int minx,int miny,int maxx,int maxy,int key,vector<vector<char>>& masu){\n    for(int i = minx; i <= maxx; i++){\n        for(int j = miny; j <= maxy;j++){\n            if(masu[i][j] == '*' || masu[i][j] == key) continue;\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid Fill(int minx,int miny,int maxx,int maxy,vector<vector<char>>& masu){\n    for(int i = minx; i <= maxx; i++){\n        for(int j = miny; j <= maxy;j++){\n            masu[i][j] = '*';\n        }\n    }\n}\n\nstring solve(){\n    ll H,W; cin >> H >> W;\n    vector<vector<char>> masu(H,vector<char>(W));\n    for(int i = 0; i < H;i++){\n        for(int j = 0; j < W;j++){\n            cin >> masu[i][j];\n        }\n    }\n    vector<pair<pii,pii>> X(26,{{INF,INF},{-INF,-INF}});\n    for(int i = 0; i < H;i++){\n        for(int j = 0; j < W;j++){\n            if(masu[i][j] == '.') continue;\n            masu[i][j] -= 'A';\n            pair<pii,pii>& piiii = X[masu[i][j]];\n            piiii.first.first = min(piiii.first.first,i);\n            piiii.first.second = min(piiii.first.second,j);\n            piiii.second.first = max(piiii.second.first,i);\n            piiii.second.second = max(piiii.second.second,j);\n        }\n    }\n    while(true){\n        bool update = [&]{\n            for(int i = 0; i < 26;i++){\n                if(X[i].first.first == INF) continue;\n                if(check(X[i].first.first,X[i].first.second,X[i].second.first,X[i].second.second,i,masu)){\n                    Fill(X[i].first.first,X[i].first.second,X[i].second.first,X[i].second.second,masu);\n                    X[i].first.first = INF;\n                    return true;\n                }\n            }\n            return false;\n        }();\n        if(update) continue;\n        else break;\n    }\n    \n    for(int i = 0; i < H;i++){\n        for(int j = 0; j < W;j++){\n            if(masu[i][j] == '.') continue;\n            if(masu[i][j] == '*') continue;\n            return \"SUSPICIOUS\";\n        }\n    }\n    return \"SAFE\";\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    ll T; cin >> T;\n    while(T--){\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl;\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct edge{int from, to; ll cost;};\n\nmap<char, bool> is_removed;\nint baggage_cnt = 0;\nint h,w;\nchar c = '*';\n\nbool is_rectangle(int si, int sj, int gi, int gj, char c, string s[]){\n\n    rep(h){\n        repp(j, w){\n            if(si <= i && i <= gi && sj <= j && j <= gj){\n                if(s[i][j] != c && !is_removed[s[i][j]]){\n                    return false;\n                }\n            }else{\n                if(s[i][j] == c) return false;\n            }\n        }\n    }\n    return true;\n}\n\nstring solve(string s[]){\n    set<char> st;\n    rep(h){\n        repp(j, w){\n            if(s[i][j] != '.') st.insert(s[i][j]);\n        }\n    }\n    baggage_cnt = (int)st.size();\n    if(!baggage_cnt) return \"SAFE\";\n\n    bool change = true;\n    while(change){\n        change = false;\n        for(char c: st){\n            if(is_removed[c]) st.erase(c);\n        }\n        for(char c: st){\n            int si = INT_MAX, sj = INT_MAX, gi = -1, gj = -1;\n            rep(h){\n                repp(j, w){\n                    if(s[i][j] == c){\n                        si = min(i, si);\n                        sj = min(j, sj);\n                        gi = max(i, gi);\n                        gj = max(j, gj);\n                    }\n                }\n            }\n            if(gi == -1) continue;\n\n            if(is_rectangle(si, sj, gi, gj, c, s)){\n                is_removed[c] = true;\n                change = true;\n                baggage_cnt--;\n                if(!baggage_cnt) return \"SAFE\";\n            }\n        }\n    }\n    return \"SUSPICIOUS\";\n}\n\nint main() {\n    int t;\n    cin >> t;\n\n    repp(tt, t){\n        cin >> h >> w;\n        string s[h];\n        rep(h) cin >> s[i];\n        is_removed.clear();\n        baggage_cnt = 0;\n        cout << solve(s) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\n#define double long double\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\nusing grid = vector<vector<char>>;\n\nbool check(grid &c, int L, int R, int U, int D, vector<bool> &used){\n    For(i, U, D+1)For(j, L, R+1){\n        if(c[i][j] == '.' || !used[c[i][j]-'A']) return false;\n    }\n    return true;\n}\n\nvoid solve(){\n    int h, w;\n    scanf(\"%d%d\", &h, &w);\n    grid c(h, vector<char>(w));\n    int L[26], R[26], U[26], D[26];\n    rep(i, 26){\n        L[i] = w; U[i] = h;\n        R[i] = D[i] = -1;\n    }\n    vector<char> v;\n    rep(i, h)rep(j, w){\n        scanf(\" %c\", &c[i][j]);\n        if(c[i][j] != '.'){\n            v.push_back(c[i][j]);\n            int t = c[i][j] - 'A';\n            chmin(U[t], i); chmin(L[t], j);\n            chmax(D[t], i); chmax(R[t], j);\n        }\n    }\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n\n    bool flag = false;\n    do{\n        bool tmp = true;\n        vector<bool> used(26, false);\n        for(auto x: v){\n            int t = x - 'A';\n            used[t] = true;\n            if(!check(c, L[t], R[t], U[t], D[t], used)){\n                tmp = false;\n                break;\n            }\n        }\n        if(tmp){\n            flag = true;\n            break;\n        }\n    }while(next_permutation(v.begin(), v.end()));\n\n    puts(flag ? \"SAFE\" : \"SUSPICIOUS\");\n}\n\nint main(){\n    int t;\n    scanf(\"%d\", &t);\n    rep(tt, t){\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nbool topologicalSort(const vector<vector<bool> >& graph, vector<int>& node)\n{\n    int n = graph.size();\n    node.resize(n);\n\n    vector<int> restEdges(n, 0);\n    for(int i=0; i<n; ++i){\n        for(int j=0; j<n; ++j){\n            if(graph[i][j])\n                ++ restEdges[j];\n        }\n    }\n\n    int restNodes = n;\n    queue<int> q;\n    for(int i=0; i<n; ++i){\n        if(restEdges[i] == 0){\n            node[n-restNodes] = i;\n            q.push(i);\n            -- restNodes;\n        }\n    }\n\n    while(restNodes > 0){\n        if(q.empty()){\n            node.clear();\n            return false;\n        }\n        int i = q.front();\n        q.pop();\n\n        for(int j=0; j<n; ++j){\n            if(!graph[i][j])\n                continue;\n            -- restEdges[j];\n            if(restEdges[j] == 0){\n                node[n-restNodes] = j;\n                q.push(j);\n                -- restNodes;\n            }\n        }\n    }\n\n    return true;\n}\n\nint solve(vector<string>& s)\n{\n    int h = s.size();\n    int w = s[0].size();\n\n    vector<int> y1(26, INT_MAX), y2(26, INT_MIN), x1(26, INT_MAX), x2(26, INT_MIN);\n    for(int i=0; i<h; ++i){\n        for(int j=0; j<w; ++j){\n            if(isalpha(s[i][j])){\n                int k = s[i][j] - 'A';\n                y1[k] = min(y1[k], i);\n                y2[k] = max(y2[k], i);\n                x1[k] = min(x1[k], j);\n                x2[k] = max(x2[k], j);\n            }\n        }\n    }\n\n    vector<vector<bool> > graph(26, vector<bool>(26, false));\n    for(int i=0; i<26; ++i){\n        for(int y=y1[i]; y<=y2[i]; ++y){\n            for(int x=x1[i]; x<=x2[i]; ++x){\n                if(s[y][x] == '.')\n                    return false;\n                int j = s[y][x] - 'A';\n                if(j != i)\n                    graph[i][j] = true;\n            }\n        }\n    }\n\n    vector<int> node;\n    return topologicalSort(graph, node);\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n\n    while(--n >= 0){\n        int h, w;\n        cin >> h >> w;\n\n        vector<string> s(h);\n        for(int i=0; i<h; ++i)\n            cin >> s[i];\n\n        if(solve(s))\n            cout << \"SAFE\" << endl;\n        else\n            cout << \"SUSPICIOUS\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nint xmin[256];\nint xmax[256];\nint ymin[256];\nint ymax[256];\nchar gchar[10];\n\nint main(void){\n\tint h,w,n,tcase;\n\tcin >> tcase;\n\tREP(t,tcase){\n\t\tcin >> h >>w;\n\t\tn=0;\n\t\tVS b(h);\n\t\tREP(i,h)cin>>b[i];\n\t\tmemset(xmin, -1,sizeof(xmin));\n\t\tmemset(xmax, -1,sizeof(xmax));\n\t\tmemset(ymin, -1,sizeof(ymin));\n\t\tmemset(ymax, -1,sizeof(ymax));\n\t\tREP(i,h){\n\t\t\tREP(j,w){\n\t\t\t\tif(b[i][j] != '.'){\n\t\t\t\t\tif(xmin[b[i][j]]==-1)xmin[b[i][j]]=j;\n\t\t\t\t\tif(xmax[b[i][j]]==-1)xmax[b[i][j]]=j;\n\t\t\t\t\tif(ymin[b[i][j]]==-1)ymin[b[i][j]]=i;\n\t\t\t\t\tif(ymax[b[i][j]]==-1)ymax[b[i][j]]=i;\n\t\t\t\t\txmin[b[i][j]] = min(xmin[b[i][j]], j);\n\t\t\t\t\txmax[b[i][j]] = max(xmax[b[i][j]], j);\n\t\t\t\t\tymin[b[i][j]] = min(ymin[b[i][j]], i);\n\t\t\t\t\tymax[b[i][j]] = max(ymax[b[i][j]], i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFOR(i,'A','Z'+1)if(xmin[i]!=-1)gchar[n++]=i;\n\t\tint cnt = 0;\n\t\tREP(i,n){\n\t\t\tREP(j,n){\n\t\t\t\tif(gchar[j]!=0){\n\t\t\t\t\tchar c = gchar[j];\n\t\t\t\t\tint flag = 1;\n\t\t\t\t\tFOR(x, xmin[c], xmax[c]+1){\n\t\t\t\t\t\tFOR(y, ymin[c], ymax[c]+1){\n\t\t\t\t\t\t\tif(b[y][x]!='x' && b[y][x]!=c){\n\t\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!flag)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\tFOR(x, xmin[c], xmax[c]+1)\n\t\t\t\t\t\t\tFOR(y, ymin[c], ymax[c]+1)\n\t\t\t\t\t\t\t\tb[y][x]='x';\n\t\t\t\t\t\tgchar[j]=0;\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(cnt == n)cout << \"SAFE\" << endl;\n\t\telse cout << \"SUSPICIOUS\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-7;\nconst double PI  = acos(-1.0);\n\n#define CH(a) ((a)+'A')\n#define IND(a) ((a)-'A')\n\nbool dfs(vvi &g,vi used,int index){\n\tused[index]=1;\n\tREP(i,27){\n\t\tif(g[index][i]){\n\t\t\tif(used[i]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(!dfs(g,used,i)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tint datasets;\n\tcin>>datasets;\n\tREP(data,datasets){\n\t\tint h,w;\n\t\tcin>>h>>w;\n\t\tvs f(h);\n\t\tREP(i,h){\n\t\t\tcin>>f[i];\n\t\t}\n\t\tvector<pii> minimum(26,make_pair(INT_MAX,INT_MAX)),maximum(26,make_pair(INT_MIN,INT_MIN));\n\t\tREP(i,h){\n\t\t\tREP(j,w){\n\t\t\t\tREP(c,26){\n\t\t\t\t\tif(f[i][j]==CH(c)){\n\t\t\t\t\t\tif(minimum[c].first>i){\n\t\t\t\t\t\t\tminimum[c].first=i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(minimum[c].second>j){\n\t\t\t\t\t\t\tminimum[c].second=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(maximum[c].first<i){\n\t\t\t\t\t\t\tmaximum[c].first=i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(maximum[c].second<j){\n\t\t\t\t\t\t\tmaximum[c].second=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvi g(27,vi(27));\n\t\tREP(i,26){\n\t\t\tg[26][i]=1;\n\t\t}\n\t\tREP(c,26){\n\t\t\tFOR(i,minimum[c].first,maximum[c].first+1){\n\t\t\t\tFOR(j,minimum[c].second,maximum[c].second+1){\n\t\t\t\t\tif(f[i][j]!=CH(c)){\n\t\t\t\t\t\tif(f[i][j]=='.'){\n\t\t\t\t\t\t\tg[c][26]=1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tg[c][IND(f[i][j])]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok=true;\n\t\tREP(i,27){\n\t\t\tvi used(27);\n\t\t\tif(!dfs(g,used,i)){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<(ok?\"SAFE\":\"SUSPICIOUS\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint h, w;\nchar field[50][50];\n\nstruct obj {\n  char pack;\n  vector<char> back;\n  int ux, uy, dx, dy;\n  bool is_visit;\n  obj(char pack, vector<char> back, int ux, int uy, int dx, int dy):\n    pack(pack), back(back), ux(ux), uy(uy), dx(dx), dy(dy){}\n  obj():back(), ux(0), uy(0), dx(100), dy(100), is_visit(false) {}\n};\n\nmap<char, obj> m;\n\nbool no_loop(char c)\n{\n  //printf(\"%c\\n\", c);\n  if (m[c].is_visit) {\n    return false;\n  }\n  m[c].is_visit = true;\n    \n  for (int i = 0; i < m[c].back.size(); i++) {\n    if (!no_loop(m[c].back[i])) {return false;}\n  }\n  return true;\n}\n\nvoid solve()\n{\n  //printf(\"ok\\n\");\n  /*\n  bool is_exist = false;\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      //printf(\"%c\", field[i][j]);\n      if (isalpha(field[i][j])) {\n        int c = field[i][j];\n        m[c].ux = m[c].uy = 0;\n        m[c].dx = m[c].dy = 100;\n        m[c].pack = c;\n        is_exist = true;\n        for (int k = 0; k < h; k++) {\n          for (int l = 0; l < w; l++) {\n            if (field[k][l] == c) {\n              m[c].ux = max(l, m[c].ux);\n              m[c].uy = max(k, m[c].uy);\n              m[c].dx = min(l, m[c].dx);\n              m[c].dy = min(k, m[c].dy); \n            }\n          }\n        }\n        for (int k = m[c].dy; k <= m[c].uy; k++) {\n          for (int l = m[c].dx; k <= m[c].ux; k++) {\n            if (!isalpha(field[k][l])) {\n              printf(\"SUSPICIOUS\\n\");\n              return;\n            }\n          }        \n        }\n      }\n    }\n    //printf(\"\\n\");                        \n  }\n  */\n  //*\n  bool is_exist = false;\n  for (int k = 0; k < h; k++) {\n    for (int l = 0; l < w; l++) {\n      char c;\n      if (isalpha(c = field[k][l])) {\n        is_exist = true;\n        m[c].ux = max(l, m[c].ux);\n        m[c].uy = max(k, m[c].uy);\n        m[c].dx = min(l, m[c].dx);\n        m[c].dy = min(k, m[c].dy);\n        m[c].pack = c;\n      }\n    }\n  }\n  for(map<char, obj>::iterator itr = m.begin(); itr != m.end(); itr++){\n    for (int k = itr -> second.dy; k <= itr -> second.uy; k++) {\n      for (int l = itr -> second.dx; l <= itr -> second.ux; l++) {\n        if (!isalpha(field[k][l])) {\n          printf(\"SUSPICIOUS\\n\");\n          return;\n        }\n      }    \n    }    \n  }\n  //*/\n  if (!is_exist) {\n    printf(\"SAFE\\n\");\n    return;\n  }\n  //printf(\"ok\\n\");\n  \n  for (map<char, obj>::iterator it = m.begin(); it != m.end(); it++) {\n    //printf(\"pack:%c\\n\", it->first);\n    it->second.is_visit = false;\n    bool is_pushed[26];\n    fill(is_pushed, &is_pushed[26], false);\n    for (int i = it->second.dy; i <= it->second.uy; i++) {\n      for (int j = it->second.dx; j <= it->second.ux; j++) {\n        if (field[i][j] != it->first && !is_pushed[field[i][j] - 'A']) {\n          m[field[i][j]].back.push_back(it->first);\n          is_pushed[field[i][j] - 'A'] = true;\n        }\n      }\n    }\n  }\n  \n  for(map<char, obj>::iterator start = m.begin(); start != m.end(); start++){\n    if (!no_loop(start -> first)) {\n      printf(\"SUSPICIOUS\\n\");\n      return;\n    }\n    for (map<char, obj>::iterator itr = m.begin(); itr != m.end(); itr++) {\n      itr->second.is_visit = false;\n    }\n  }\n  printf(\"SAFE\\n\");\n  return;\n}\n\nint main()\n{\n  int nInput;\n  scanf(\"%d \", &nInput);\n  \n  for (int input = 0; input < nInput; input++) {\n    m.clear();\n    scanf(\"%d %d \", &h, &w);\n    \n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        scanf(\"%c \", &field[i][j]);\n      }\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n#define USE_MATH_DEFINES\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 30;\nconst double EPS = 1E-9;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\n\nint h, w;\nchar field[50][50];\nbool used[50][50];\nbool per[8];\nchar ma[8];\nmap<char, int> mp;\nint c;\n\nbool dfs(int n, int rest){\n\tif(n == 0) {\n\t\treturn rest == 0 ? true : false;\n\t}\n\tbool res = false;\n\tfor(int i = 1; i < c; i++){\n\t\tif(per[i]) continue;\n\t\telse{\n\t\t\tper[i] = true;\n\t\t\tint ymax = 0;\n\t\t\tint ymin = INF;\n\t\t\tint xmax = 0;\n\t\t\tint xmin = INF;\n\t\t\tbool f = true;\n\t\t\tint cnt = 0;\n\t\t\tfor(int j = 0; j < h; j++){\n\t\t\t\tfor(int k = 0; k < w; k++){\n\t\t\t\t\tif(mp[field[j][k]] == i){\n\t\t\t\t\t\tymax = max(ymax, j);\n\t\t\t\t\t\tymin = min(ymin, j);\n\t\t\t\t\t\txmax = max(xmax, k);\n\t\t\t\t\t\txmin = min(xmin, k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = ymin; j <= ymax; j++){\n\t\t\t\tfor(int k = xmin; k <= xmax; k++){\n\t\t\t\t\tif(per[mp[field[j][k]]]){\n\t\t\t\t\t\tif(mp[field[j][k]] == i) cnt++;\n\t\t\t\t\t}else f = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tres |= dfs(n-1, rest - cnt);\n\t\t\t\tper[i] = false;\n\t\t\t}else{\n\t\t\t\tper[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((ULL)(n) >> (m) & 1)\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\nint n_dir = 4;\nint dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; /* CSS order */\nenum direction {\n\tUP, RIGHT, DOWN, LEFT\n};\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\nstruct article {\n\tchar material;\n\tbool is_removed;\n\tint topmost;\n\tint bottommost;\n\tint leftmost;\n\tint rightmost;\n};\n\ntypedef map<char, article> MCA;\n\nVVC image;\nMCA articles;\n\nbool remove_all()\n{\n\tbool all_removed = true;\n\tEACH (articles, itr) {\n\t\tarticle &art = itr->second;\n\t\tif (!art.is_removed) {\n\t\t\tall_removed = false;\n\t\t\t// Remove it and recurse\n\t\t\tVVC save = image;\n\t\t\tbool rect = true;\n\t\t\tFOR (i, art.topmost, art.bottommost + 1) {\n\t\t\t\tFOR (j, art.leftmost, art.rightmost + 1) {\n\t\t\t\t\tif (image[i][j] != '*' && image[i][j] != art.material) {\n\t\t\t\t\t\trect = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\timage[i][j] = '*';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rect) {\n\t\t\t\t// Recurse\n\t\t\t\tart.is_removed = true;\n\t\t\t\tif (remove_all()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Restore and continue trying\n\t\t\timage = save;\n\t\t}\n\t}\n\treturn all_removed;\n}\n\nint main()\n{\n\tint t; cin >> t;\n\tREP (_, t) {\n\t\tint h, w; cin >> h >> w;\n\t\timage = VVC(h, VC(w, '.'));\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tcin >> image[i][j];\n\t\t\t}\n\t\t}\n\n\t\t// Scan Image\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tif (image[i][j] != '.') {\n\t\t\t\t\tchar c = image[i][j];\n\t\t\t\t\tif (!EXIST(articles, c)) {\n\t\t\t\t\t\tarticle a = {c, false, 50, 0, 50, 0};\n\t\t\t\t\t\tarticles.insert(MCA::value_type(c, a));\n\t\t\t\t\t}\n\t\t\t\t\tarticles[c].topmost = min(articles[c].topmost, i);\n\t\t\t\t\tarticles[c].bottommost = max(articles[c].bottommost, i);\n\t\t\t\t\tarticles[c].leftmost = min(articles[c].leftmost, j);\n\t\t\t\t\tarticles[c].rightmost = max(articles[c].rightmost, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (remove_all()) {\n\t\t\tcout << \"SAFE\" << endl;\n\t\t} else {\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\n# define max_n 40\n\nint main(void) {\n    int i,j;\n    int n;\n    cin >> n;\n    while(n--){\n        int h, w;\n        cin >> h >> w;\n        vs s(h);\n        rep(i,h) cin >> s[i];\n\n        int a[26][4]; // left,right,top,bottom\n        rep(i,26)rep(j,4)\n            if(j%2) a[i][j] = 0;\n            else a[i][j] = INF;\n        rep(i,h)rep(j,w)if(s[i][j] >= 'A' && s[i][j] <= 'Z'){\n            int alph = s[i][j] - 'A';\n            a[alph][0] = min(a[alph][0], j);\n            a[alph][1] = max(a[alph][1], j);\n            a[alph][2] = min(a[alph][2], i);\n            a[alph][3] = max(a[alph][3], i);\n        }\n        int cnt = 0;\n        rep(i,26) if(a[i][0] < INF) cnt++;\n\n        int t;\n        bool ans = true;\n        rep(t,cnt){\n            if(ans == false)break;\n            rep(i,26)if(a[i][0] < INF){\n                int p,q;\n                bool c = true;\n                for(p = a[i][2]; p <= a[i][3]; p++){\n                    for(q = a[i][0]; q <= a[i][1]; q++){\n                        if(s[p][q] != ('A' + i) && s[p][q] != '*' ) c = false;\n                    }\n                }\n                if(c){\n                    for(p = a[i][2]; p <= a[i][3]; p++){\n                        for(q = a[i][0]; q <= a[i][1]; q++){\n                            s[p][q] = '*';\n                        }\n                    }\n                    a[i][0] = INF;\n                    break;\n                }\n            }\n            if(i == 26) ans = false;\n        }\n        if(ans)\n            cout << \"SAFE\" << endl;\n        else\n            cout << \"SUSPICIOUS\" << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\nclass Object{\npublic:\n  Object(char col){ miny = minx = INF; maxy = maxx = -1; on.clear(); c = col; }\n  int miny, minx, maxy, maxx;\n  set<int> on;\n  char c;\n};\n\nint h, w;\nvector<Object> objects;\nset<int> used;\nchar input[50][50];\nbool visited[50][50];\nint index[50][50];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nbool dfs1(int y, int x, int n){\n  Object &obj = objects[n];\n  visited[y][x] = true;\n  index[y][x] = n;\n  if(obj.miny > y) obj.miny = y;\n  if(obj.minx > x) obj.minx = x;\n  if(obj.maxy < y) obj.maxy = y;\n  if(obj.maxx < x) obj.maxx = x;\n  for(int i=0;i<4;i++){\n    int ty = y + dy[i];\n    int tx = x + dx[i];\n    if(ty<0 || ty>=h) continue;\n    if(tx<0 || tx>=w) continue;\n    if(visited[ty][tx]) continue;\n    if(input[ty][tx] != input[y][x]) continue;\n    dfs1(ty, tx, n);\n  }\n  return true;\n}\n\nbool dfs2(int n){\n  set<int>::iterator ite = objects[n].on.begin();\n  for(;ite != objects[n].on.end();ite++){\n    if(used.find(*ite) != used.end()) return false;\n    used.insert(*ite);\n    if(!dfs2(*ite)) return false;\n    used.erase(used.find(*ite));\n  }\n  return true;\n}\n\nmain(){\n  int t;\n  cin >> t;\n  while(t--){\n    cin >> h >> w;\n    objects.clear();\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> input[i][j];\n      }\n    }\n\n\n    fill(index[0], index[50], -1);\n    fill(visited[0], visited[50], false);    \n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(input[i][j] != '.' && !visited[i][j]){\n\t  objects.push_back(Object(input[i][j]));\n\t  dfs1(i, j, (int)objects.size()-1);\n\t}\n      }\n    }\n\n    bool ans = true;\n\n    for(int i=0;i<objects.size();i++){\n      for(int j=objects[i].miny;j<=objects[i].maxy;j++){\n\tfor(int k=objects[i].minx;k<=objects[i].maxx;k++){\n\t  if(input[j][k] != '.' && input[j][k] != objects[i].c){\n\t    objects[i].on.insert(index[j][k]);\n\t  }else if(input[j][k] == '.'){\n\t    ans = false;\n\t    break;\n\t  }\n\t}\n\tif(!ans) break;\n      }\n      if(!ans) break;\n    }\n    for(int i=0;i<objects.size();i++){\n      set<int>::iterator ite = objects[i].on.begin();\n      used.clear();\n      ite = used.begin();\n      used.insert(i);\n      if(!dfs2(i)){\n\tans = false;\n\tbreak;\n      }\n    }\n    if(ans){\n      cout << \"SAFE\" << endl;\n    }else{\n      cout << \"SUSPICIOUS\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nstruct make\n{\n\tchar str;\n\tint posi,start[2];\n\tint high,wide,JUDGE;//JUDGE==1で長方形,==0で長方形以外,==2で未定\n\tstruct make *front;\n};\n\n\nint main()\n{\n\tint N,H,W,count,COUNT,judge,no_rect,NO_RECT,RECT_C=0;\n\tchar img[1000][51],RECT[8];\n\tstruct make M[8];\n\tint s1,s2,num,r;\n\t\n\tscanf(\"%d\",&N);//データの個数\n\tfor(int a=0;a<N;a++)\n\t{\n\t\tcount=0;//材質の個数\n\t\tCOUNT=0;\n\t\tNO_RECT=0;\n\t\tRECT_C=0;\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tscanf(\"%s\",img[b]);\n\t\t\timg[b][W]='\\0';\n\t\t}\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tfor(int d=0;d<count;d++) M[d].posi=-1;\n\t\t\tfor(int c=0;c<W;c++)\n\t\t\t{\n\t\t\t\tif(img[b][c]!='.')\n\t\t\t\t{\n\t\t\t\t\t//材質判定\n\t\t\t\t\tjudge=0;\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t\tif(count>0 && img[b][c]!=M[judge].str) judge++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}while(judge<count);\n\t\t\t\t\t//新しい材質の場合\n\t\t\t\t\tif(judge==count)\n\t\t\t\t\t{\n\t\t\t\t\t\tM[count].str=img[b][c];\n\t\t\t\t\t\tM[count].start[0]=b;\n\t\t\t\t\t\tM[count].start[1]=c;\n\t\t\t\t\t\tM[count].posi=c;\n\t\t\t\t\t\tM[count].high=1;\n\t\t\t\t\t\tM[count].wide=1;\n\t\t\t\t\t\tM[count].JUDGE=0;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\t//既出の材質の場合\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(M[judge].start[1]>c) M[judge].start[1]=c;\n\t\t\t\t\t\tif(M[judge].posi<0) M[judge].posi=c;\n\t\t\t\t\t\telse if(M[judge].wide<c-M[judge].posi+1) M[judge].wide=c-M[judge].posi+1;\n\t\t\t\t\t\tM[judge].high=b-M[judge].start[0]+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tno_rect=count;\n\t\t//printf(\"count=%d\\n\",count);\n\t\t//判定開始\n\t\twhile(count)//文字アリ\n\t\t{\n\t\t\tint p;\n\t\t\tp=getchar();\n\t\t\tCOUNT=0;\n\t\t\t//見えている部分が長方形かどうか判定\n\t\t\tfor(num=0;num<count;num++)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(M[num].JUDGE==1) continue;\n\t\t\t\tM[num].JUDGE=0;//長方形なら\n\t\t\t\t//printf(\"M[%d].str=%c\\nM[%d].high=%d\\nM[%d].wide=%d\\n\",num,M[num].str,num,M[num].high,num,M[num].wide);\n\t\t\t\t//printf(\"M[%d].start[0]=%d\\nM[%d].start[1]=%d\\n\",num,M[num].start[0],num,M[num].start[1]);\n\t\t\t\tfor(s1=0;s1<M[num].high;s1++)\n\t\t\t\t{\n\t\t\t\t\tfor(s2=0;s2<M[num].wide;s2++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//確実に長方形ではない場合\n\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]=='.')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNO_RECT=1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//長方形の可能性もある場合\n\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]!=M[num].str)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(r=0;r<RECT_C;)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tprintf(\"RECT[%d]='%c'\\n\",r,RECT[r]);\n\t\t\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]==RECT[r]) break;\n\t\t\t\t\t\t\t\tr++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]==RECT[r]) break;\n\t\t\t\t\t\t\tif(r==RECT_C)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tM[num].JUDGE=2;\n\t\t\t\t\t\t\t\tCOUNT++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(NO_RECT || M[num].JUDGE==2) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(NO_RECT || M[num].JUDGE==2) break;\n\t\t\t\t}\n\t\t\t\tif(NO_RECT) break;\n\t\t\t\t//長方形だった場合\n\t\t\t\tif(s1==M[num].high && s2==M[num].wide)\n\t\t\t\t{\n\t\t\t\t\tM[num].JUDGE=1;\n\t\t\t\t\tno_rect--;\n\t\t\t\t\tRECT[RECT_C]=M[num].str;\n\t\t\t\t\tRECT_C++;\n\t\t\t\t}\n\t\t\t\t//printf(\"M[%d].JUDGE=%d\\n\\n\",num,M[num].JUDGE);\n\t\t\t}\n\t\t\tfor(int n=0;n<num;)\n\t\t\t{\n\t\t\t\t//printf(\"#\\n\");\n\t\t\t\tif(M[n].JUDGE!=2) break;\n\t\t\t\tn++;\n\t\t\t\t//どれも長方形ではなかった場合\n\t\t\t\tif(n==num) NO_RECT=1;\n\t\t\t}\n\t\t\t\n\t\t\t//printf(\"NO_RECT=%d\\n\",NO_RECT);\n\t\t\tif(NO_RECT==1) break;\n\t\t\t//printf(\"#no_rect=%d\\n\\n\\n\",no_rect);\n\t\t\t//すべて長方形\n\t\t\tif(no_rect==0) break;\n\t\t}\n\t\t//出力\n\t\tif(NO_RECT) printf(\"SUSPICIOUS\\n\");\n\t\telse if(no_rect) printf(\"SUSPICIOUS\\n\");\n\t\telse printf(\"SAFE\\n\");\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n#define USE_MATH_DEFINES\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 30;\nconst double EPS = 1E-9;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\n\nint h, w;\nchar field[50][50];\nbool used[50][50];\nbool per[8];\nchar ma[8];\nmap<char, int> mp;\nint c;\n\nbool dfs(int n, int rest){\n\tif(n == 0) {\n\t\treturn rest == 0 ? true : false;\n\t}\n\tbool res = false;\n\tfor(int i = 1; i < c; i++){\n\t\tif(per[i]) continue;\n\t\telse{\n\t\t\tper[i] = true;\n\t\t\tint ymax = 0;\n\t\t\tint ymin = INF;\n\t\t\tint xmax = 0;\n\t\t\tint xmin = INF;\n\t\t\tbool f = true;\n\t\t\tint cnt = 0;\n\t\t\tfor(int j = 0; j < h; j++){\n\t\t\t\tfor(int k = 0; k < w; k++){\n\t\t\t\t\tif(mp[field[j][k]] == i){\n\t\t\t\t\t\tymax = max(ymax, j);\n\t\t\t\t\t\tymin = min(ymin, j);\n\t\t\t\t\t\txmax = max(xmax, k);\n\t\t\t\t\t\txmin = min(xmin, k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = ymin; j <= ymax; j++){\n\t\t\t\tfor(int k = ymin; k <= ymax; k++){\n\t\t\t\t\tif(per[mp[field[j][k]]]){\n\t\t\t\t\t\tif(mp[field[j][k]] = i) cnt++;\n\t\t\t\t\t}else f = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tres |= dfs(n-1, rest - cnt);\n\t\t\t\tper[i] = false;\n\t\t\t}else{\n\t\t\t\tper[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n ;\n\tcin >> n;\n\twhile(n--){\n\t\tcin >> h >> w;\n\t\tmp.clear();\n\t\tc = 1;\n\t\tint cnt = 0;\n\t\tfor(int i = 0;i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tif(field[i][j] != '.') cnt++;\n\t\t\t\tif(mp[field[i][j]] == 0 && field[i][j] != '.') mp[field[i][j]] = c++;\n\t\t\t}\n\t\t}\n\t\tmemset(per, false, sizeof(per));\n\t\tbool safe = dfs(c-1, cnt);\n\t\tif(safe){\n\t\t\tcout << \"SAFE\" << endl;\n\t\t}else{\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing db = double;\nusing ll = long long;\nusing vi = vector <int>;\n#define op operator\n#define pb push_back\n\nconst int N = 53;\nstring s[N];\n\nvector <int> e[N];\n\nint deg[N];\nbool solve() {\n\tmemset(deg, 0, sizeof deg);\n\tqueue <int> q;\n\tfor(int i = 0; i < N; i ++)\n\t\tfor(int j : e[i])\n\t\t\tdeg[j] ++;\n\tfor(int i = 0; i < N; i ++)\n\t\tif(!deg[i]) q.push(i);\n\twhile(!q.empty()) {\n\t\tint x = q.front(); q.pop();\n\t\tfor(int i : e[x]) {\n\t\t\tdeg[i] --;\n\t\t\tif(!deg[i])\n\t\t\t\tq.push(i);\n\t\t}\n\t}\n\tfor(int i = 0; i < N; i ++)\n\t\tif(deg[i]) return 0;\n\treturn 1;\n}\n\nint main() {\n\tcout << fixed << setprecision(9);\n\tios :: sync_with_stdio(0);\n\n\tint t; cin >> t;\n\twhile(t --) {\n\t\tint n, m; cin >> n >> m;\n\t\tfor(int i = 1; i <= n; i ++) {\n\t\t\tcin >> s[i];\n\t\t\ts[i] = '\\0' + s[i];\n\t\t}\n\n\t\tfor(int i = 0; i < N; i ++) e[i].clear();\t\n\t\tfor(char c = 'A'; c <= 'Z'; c ++) {\n\t\t\tint ix = N, iy = N;\n\t\t\tint ax = 0, ay = 0;\n\t\t\tfor(int i = 1; i <= n; i ++)\n\t\t\t\tfor(int j = 1; j <= m; j ++) if(s[i][j] == c) {\n\t\t\t\t\tix = min(ix, i); ax = max(ax, i);\n\t\t\t\t\tiy = min(iy, j); ay = max(ay, j);\n\t\t\t\t}\n\t\t\tfor(int i = ix; i <= ax; i ++)\n\t\t\t\tfor(int j = iy; j <= ay; j ++)\n\t\t\t\t\tif(s[i][j] == '.') e[c - 'A'].pb(c - 'A');\n\t\t\t\t\telse if(s[i][j] != c) e[s[i][j] - 'A'].pb(c - 'A');\n\t\t}\n\t\tcout << (solve() ? \"SAFE\" : \"SUSPICIOUS\") << '\\n';\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\nint n;\nint H,W,T;\nstring str;\nbool used[26],flg;\n\nint A[26],B[26],C[26],D[26];\n\nchar t[50][50];\n\nchar tmp;\n\nvoid input();\nvoid init();\nbool check(char ch){\n\n  int z=ch-'A';\n  if(A[z]==-1){\n    int a=49,b=0,c=0,d=49;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tif(t[i][j]==ch){\n\t  a=min(a,i);\n\t  b=max(b,j);\n\t  c=max(c,i);\n\t  d=min(d,j);\n\t}\n      }\n    }\n    A[z]=a;  B[z]=b;  C[z]=c;  D[z]=d;\n  }\n\n  for(int i=A[z];i<=C[z];i++){\n    for(int j=D[z];j<=B[z];j++){\n      if(t[i][j]=='?')continue;\n      if(t[i][j]!=ch)return false;\n    }\n  }\n  return true;\n  \n}\n\nvoid draw(char ch){\n  int z=ch-'A';\n\n  if(A[z]==-1){\n    int a=49,b=0,c=0,d=49;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tif(t[i][j]==ch){\n\t  a=min(a,i);\n\t  b=max(b,j);\n\t  c=max(c,i);\n\t  d=min(d,j);\n\t}\n      }\n    }\n    A[z]=a;  B[z]=b;  C[z]=c;  D[z]=d;\n  }\n\n  for(int i=A[z];i<=C[z];i++){\n    for(int j=D[z];j<=B[z];j++){\n      t[i][j]='?';\n    }\n  }\n}\nint main(){\n  cin>>T;\n  while(T--){\n    init();\n    input();\n\n    while(1){\n \n      flg=false;\n\n      for(int i=0;i<26;i++){\n\tif(used[i]==false)continue;\n\tif(check(i+'A')==true){\n\t  flg=true;\n\t  draw(i+'A');\n\t  used[i]=false;\n\t  break;\n\t}\n      }\n      if(flg==false)break;\n    }\n\n    flg=false;\n    for(int i=0;i<26;i++)flg|=used[i];\n    cout<<(flg?\"SUSPICIOUS\":\"SAFE\")<<endl;\n  }\n  return 0;\n}\nvoid input(){\n  cin>>H>>W;\n  for(int i=0;i<H;i++){\n    cin>>str;\n    for(int j=0;j<W;j++){\n      t[i][j]=str[j];\n      used[t[i][j]-'A']=true;\n    }\n  }\n}\nvoid init(){\n  for(int i=0;i<26;i++){\n    A[i]=-1;\n    used[i]=false;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint k;\n\tcin >> k;\n\tREP(f, k) {\n\t\tvvi d(26, vi(26, INF));\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tvector<string> v(h);\n\t\tREP(i, h)cin >> v[i];\n\t\tFOR(c,'A','Z'+1){\n\t\t\tint minh = INF, maxh = -INF,minw=INF,maxw=-INF;\n\t\t\tREP(i, h) {\n\t\t\t\tREP(j, w) {\n\t\t\t\t\tif (v[i][j] == c) {\n\t\t\t\t\t\tminh = min(minh, i);\n\t\t\t\t\t\tmaxh = max(maxh, i);\n\t\t\t\t\t\tminw = min(minw, j);\n\t\t\t\t\t\tmaxw = max(maxw, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (minh == INF)continue;\n\t\t\n\t\t\tFOR(i, minh, maxh + 1) {\n\t\t\t\tFOR(j, minw, maxw + 1) {\n\t\t\t\t\tif (v[i][j] == '.') {\n\t\t\t\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t\t\t\t\tgoto a;\n\t\t\t\t\t}\n\t\t\t\t\telse if (v[i][j] != c) {\n\t\t\t\t\t\td[v[i][j]-'A'][c - 'A'] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(i, 26)d[i][i] = 0;\n\t\t\tREP(k, 26) {\n\t\t\t\tREP(i, 26) {\n\t\t\t\t\tREP(j, 26) {\n\t\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tREP(i, 26) {\n\t\t\tif (d[i][i] < 0) {\n\t\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t\t\tgoto a;\n\t\t\t}\n\n\t\t}\n\t\tcout << \"SAFE\" << endl;\n\ta:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\nint main(){\n  int h,w,n;\n  int i,j,k;\n  cin>>n;\n  while(n--){\n    cin >> h >> w;\n    string st[60];\n    for(i=0;i<h;i++) cin >> st[i];\n    bool f=true;\n    while(f){\n      f=false;\n      vector<char> v;\n      for(i=0;i<h;i++){\n\tfor(j=0;j<w;j++){\n\t  if(st[i][j]!='.'&&st[i][j]!='?') v.push_back(st[i][j]);\n\t}\n      }\n      for(k=0;k<v.size();k++){\n\tint r=0,l=w,u=h,d=0;\n\tfor(i=0;i<h;i++){\n\t  for(j=0;j<w;j++){\n\t    if(st[i][j]==v[k]){\n\t      r=max(r,j);\n\t      l=min(l,j);\n\t      u=min(u,i);\n\t      d=max(d,i);\n\t    }\n\t  }\n\t}\n\tbool e = true;\n\tfor(i=u;i<=d;i++){\n\t  for(j=l;j<=r;j++){\n\t    if(st[i][j]!=v[k]&&st[i][j]!='?') e =false;\n\t  }\n\t}\n\tif(!e) continue;\n\tf=true;\n\tfor(i=u;i<=d;i++){\n\t  for(j=l;j<=r;j++){\n\t    st[i][j]='?';\n\t  }\n\t}\n      }\n      //for(i=0;i<h;i++) cout << st[i] << endl;\n    }\n    vector<char> v;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(st[i][j]!='.'&&st[i][j]!='?') v.push_back(st[i][j]);\n      }\n    }\n    if(v.size()==0) cout << \"SAFE\" << endl;\n    else cout << \"SUSPICIOUS\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint N;\nvector<string> g;\nint used[128],x1[128],x2[128],y1[128],y2[128];\nvector<int> p;\n\nvector<char> v;\nbool bt(){\n\n\tfor(int k=p.size()-1;k<p.size();k++){\n\t\tfor(int i=y1[p[k]];i<=y2[p[k]];i++){\n\t\t\tfor(int j=x1[p[k]];j<=x2[p[k]];j++){\n\t\t\t\tchar c = g[i][j];\n\t\t\t\tif(c == '.')return false;\n\t\t\t\tif(find(p.begin(),p.end(),p[k]) > find(p.begin(),p.end(),c)){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\tfor(int k=0;k<v.size();k++){\n\t\tif(!used[v[k]]){\n\t\t\tused[v[k]] = true;\n\t\t\tp.push_back(v[k]);\n\t\t\tif( bt() ) return true;\n\t\t\tp.pop_back();\n\t\t\tused[v[k]] = false;\n\t\t}\n\t}\n\treturn p.size() == v.size();\n}\nint main(){\n\tint T;\n\t\n\tcin >> T;\n\twhile(T--){\n\t\tint W,H;\n\t\tcin >> H >> W;\n\t\tvector<string> data(H);\n\t\tfor(int i=0;i<H;i++)\n\t\t\tcin >> data[i];\n\t\t\t\n\t\tg = data;\n\t\t\n\t\tint check[128];\n\t\t\n\t\tfor(int i=0;i<128;i++)\n\t\t\tx1[i] = x2[i] = y1[i] = y2[i] = used[i] = check[i] = 0;\n\n\t\tfor(int i=0;i<128;i++)\n\t\t\tx1[i] = y1[i] = 9999;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tchar c = data[i][j];\n\t\t\t\tif(c != '.'){\n\t\t\t\t\tcheck[c] = true;\n\t\t\t\t\tx1[c] = min(j,x1[c]);\n\t\t\t\t\tx2[c] = max(j,x2[c]);\n\t\t\t\t\ty1[c] = min(i,y1[c]);\n\t\t\t\t\ty2[c] = max(i,y2[c]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tv.clear();\n\t\tp.clear();\n\t\t\n\t\tfor(int i=0;i<128;i++)\n\t\t\tif(check[i])v.push_back(i);\n\n\t\t\t\n\t\tcout << ( bt() ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvoid solve() {\n    int H, W;\n    cin >> H >> W;\n\n    vector<string> S(H);\n    for (auto& s : S) cin >> s;\n\n    vector<vector<bool>> on(26, vector<bool>(26, false));\n    // on[x][y] => xがyより上にある\n\n    bool judge = true;\n    for (char c = 'A'; c <= 'Z'; ++c) {\n        int lx = W, rx = -1, ly = H, ry = -1;\n        for (int x = 0; x < H; ++x) {\n            for (int y = 0; y < W; ++y) {\n                if (S[x][y] != c) continue;\n                lx = min(lx, x), rx = max(rx, x);\n                ly = min(ly, y), ry = max(ry, y);\n            }\n        }\n\n        for (int x = lx; x <= rx; ++x) {\n            for (int y = ly; y <= ry; ++y) {\n                if (S[x][y] == '.') {\n                    judge = false;\n                } else if (S[x][y] != c) {\n                    // S[x][y]はcの上にある\n                    on[S[x][y] - 'A'][c - 'A'] = true;\n                }\n            }\n        }\n    }\n\n    for (int k = 0; k < 26; ++k) {\n        for (int i = 0; i < 26; ++i) {\n            for (int j = 0; j < 26; ++j) {\n                if (on[i][k] && on[k][j]) on[i][j] = true;\n            }\n        }\n    }\n\n    for (int i = 0; i < 26; ++i) {\n        for (int j = 0; j < 26; ++j) {\n            if (on[i][j] && on[j][i]) judge = false;\n        }\n    }\n\n    cout << (judge ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    for (int i = 0; i < N; ++i) solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint main(void)\n{\n  int n;\n  cin >> n;\n  REP(_,n){\n    int h,w;\n    cin >> h >> w;\n    if(!h) return 0;\n    vector<string> sc;\n    sc.resize(h);\n    REP(i,h) cin >> sc[i];\n    set<char> car;\n    car.clear();\n    REP(i,h) REP(j,w) if(sc[i][j]!='.') car.insert(sc[i][j]);\n    vector<char> carv(car.begin(),car.end());\n    string answer=\"SUSPICIOUS\";\n    do{\n      bool flag=true;\n      REP(dep,carv.size()){\n\tint u=100,d=-1,l=100,r=-1;\n\tREP(i,h) REP(j,w) if(sc[i][j]==carv[dep]){\n\t  u=min(u,i);\n\t  d=max(d,i);\n\t  l=min(l,j);\n\t  r=max(r,j);\n\t}\n\tFOR(i,u,d+1) FOR(j,l,r+1){\n\t  if(sc[i][j]=='.') flag=false;\n\t  REP(k,dep)if(sc[i][j]==carv[k]) flag=false;\n\t}\n      }\n      if(flag) answer=\"SAFE\";\n    }while(next_permutation(carv.begin(),carv.end()));\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint h, w;\nbool rectangle;\nvector<string> s(50);\nvector<PP> v(50);\nvector<char> vc;\nint dd[] = {0, 1, 0, -1, 0};\nbool visited[50][50];\n\nbool range(int x, int y) {\n  return 0 <= x && x < w && 0 <= y && y < h;\n}\n\nvoid wfs(int y, int x, char c) {\n  deque<P> q;\n  q.pb(P(y, x));\n  visited[y][x] = true;\n\n  int minx = INF, maxx = 0, miny = INF, maxy = 0;\n  while(!q.empty()) {\n    P p = q.front(); q.pop_front();\n    minch(minx, p.se), maxch(maxx, p.se);\n    minch(miny, p.fi), maxch(maxy, p.fi);\n\n    rep(i, 4) {\n      int xx = p.se + dd[i], yy = p.fi + dd[i + 1];\n      if (range(xx, yy) && s[yy][xx] == c && !visited[yy][xx]) {\n        q.pb(P(yy, xx));\n        visited[yy][xx] = true;\n      }\n    }\n  }\n\n  v[c - 'A'] = PP(P(minx, maxx), P(miny, maxy));\n  vc.pb(c);\n}\n\nbool ok() {\n  char tmp[h][w];\n  rep(i, h)rep(j, w) tmp[i][j] = '.';\n\n  rep(i, vc.size()) {\n    repl(j, v[vc[i] - 'A'].se.fi, v[vc[i] - 'A'].se.se + 1) {\n      repl(k, v[vc[i] - 'A'].fi.fi, v[vc[i] - 'A'].fi.se + 1) {\n        tmp[j][k] = vc[i];\n      }\n    }\n  }\n\n  rep(i, h)rep(j, w) if (s[i][j] != tmp[i][j]) return false;\n  return true;\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  int t;\n  cin >> t;\n  rep(ii, t) {\n    vc.clear();\n    cin >> h >> w;\n    rep(i, h) cin >> s[i];\n\n    rectangle = false;\n    rep(i, h)rep(j, w) visited[i][j] = false;\n    rep(i, h)rep(j, w) {\n      if (s[i][j] != '.' && !visited[i][j]) wfs(i, j, s[i][j]);\n    }\n\n    sort(all(vc));\n    bool ans = false;\n    do {\n      if (ok()) {\n        ans = true;\n        break;\n      }\n    } while(next_permutation(all(vc)));\n\n    cout << ((ans) ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<set>\n\nusing namespace std;\n\n#define MAX(X,Y) ((X)>(Y) ? (X) : (Y))\n#define MIN(X,Y) ((X)<(Y) ? (X) : (Y))\n\nvoid dfs(set<char> graph[], char now, int &k, int dst[]) {\n    if(dst[now] != -1) return;\n    dst[now] = 100000;\n    for(char cn : graph[now])\n        dfs(graph, cn, k, dst);\n    dst[now] = k++;\n}\n\nbool strong(set<char> graph[], set<char> rev[]) {\n    int ord[256];\n    memset(ord, 0xFF, sizeof(ord));\n    int k=0;\n    for(char c='A'; c<='Z'; c++)\n        dfs(graph, c, k, ord);\n    while(k >= 0) {\n        for(char c='A'; c<='Z'; c++)\n            if(ord[c] == k)\n                for(char cb : rev[c])\n                    if(ord[cb] < ord[c])\n                        return false;\n        k--;\n    }\n    return true;\n}\n\n\nint main(void) {\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=0; i<n; i++) {\n        char s[100][100];\n        int minx[256], maxx[256], miny[256], maxy[256];\n        set<char> cs[256], rev[256];\n\n        memset(s, 0, sizeof(s));\n        memset(maxx, 0xFF, sizeof(maxx));\n        memset(maxy, 0xFF, sizeof(maxy));\n        memset(minx, 0x7F, sizeof(minx));\n        memset(miny, 0x7F, sizeof(miny));\n\n        int h, w;\n        scanf(\"%d%d\",&h,&w);\n        for(int j=0; j<h; j++)\n            scanf(\"%s\",s[j]);\n\n        for(int ih=0; ih<h; ih++)\n            for(int iw=0; iw<w; iw++) {\n                minx[s[ih][iw]] = MIN(minx[s[ih][iw]] , iw);\n                miny[s[ih][iw]] = MIN(miny[s[ih][iw]] , ih);\n                maxx[s[ih][iw]] = MAX(maxx[s[ih][iw]] , iw);\n                maxy[s[ih][iw]] = MAX(maxy[s[ih][iw]] , ih);\n            }\n        bool safe = true;\n        for(char c='A'; c<='Z'; c++) {\n            if(minx[c] == 0x7F7F7F7F) continue;\n\n            for(int iw=minx[c]; iw<=maxx[c]; iw++)\n                for(int ih=miny[c]; ih<=maxy[c]; ih++) {\n                    if(s[ih][iw] == '.') { safe = false; continue; }\n                    if(c != s[ih][iw])\n                        cs[c].insert(s[ih][iw]), rev[s[ih][iw]].insert(c);\n                }\n        }\n\n/*        for(char c='A'; c<='Z'; c++) {\n            printf(\"%c: \", c);\n            for(char cn : cs[c])\n                printf(\"%c \", cn);\n            puts(\"\");\n        }*/\n        if(safe)\n            safe = strong(cs, rev);\n\n        puts(safe ? \"SAFE\" : \"SUSPICIOUS\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint w, h;\nint sy, sx, gy, gx;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nbool can(int y,int x) {\n\tif(0 <= y && y < h && 0 <= x && x < w) return true;\n\treturn false;\n}\n\nvector<string> s;\nchar c;\nbool used[55][55], visited[55][55];\n\nvoid dfs(int i, int j) {\n\tvisited[i][j] = true;\n\tsy = min(sy, i);\n\tsx = min(sx, j);\n\tgy = max(gy, i);\n\tgx = max(gx, j);\n\n\trep(k, 4) {\n\t\tint y = i + dy[k];\n\t\tint x = j + dx[k];\n\n\t\tif(can(y, x) && !visited[y][x] && s[y][x] == c) {\n\t\t\tdfs(y, x);\n\t\t}\n\t}\n}\n\nbool check() {\n\tREP(i, sy, gy+1){\n\t\tREP(j, sx, gx+1) {\n\t\t\tif(s[i][j] == c || used[i][j]) continue;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid f() {\n\tREP(i, sy, gy+1) {\n\t\tREP(j, sx, gx+1) {\n\t\t\tused[i][j] = true;\n\t\t}\n\t}\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\trep(q, n) {\n\t\tcin >> h >> w;\n\t\ts.resize(h);\n\t\trep(i, h) cin >> s[i];\n\n\t\tmemset(used, 0, sizeof(used));\n\t\tset<char> S;\n\n\t\tbool flag = true, update = true;\n\t\twhile(update) {\n\t\t\tupdate = false;\n\t\t\trep(i, h) {\n\t\t\t\trep(j, w) {\n\t\t\t\t\tif(s[i][j] == '.') continue;\n\n\t\t\t\t\tif(used[i][j]) continue;\n\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t\tgy = i;\n\t\t\t\t\tgx = j;\n\t\t\t\t\tc = s[i][j];\n\t\t\t\t\tmemset(visited, 0, sizeof(visited));\n\t\t\t\t\tdfs(i, j);\n\n\t\t\t\t\tif(S.find(c) == S.end() && check()) {\n\t\t\t\t\t\tf();\n\t\t\t\t\t\tS.insert(c);\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tif(used[i][j]) continue;\n\t\t\t\tif(s[i][j] == '.') continue;\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\n\t\tif(flag) cout << \"SAFE\" << endl;\n\t\telse cout << \"SUSPICIOUS\" << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\nint h,w,datac,cnt;\nint fie[51][51];\nint num[30];\nint up[30],used[30];\nint min_x[30],min_y[30],max_x[30],max_y[30];\nbool flag;\n\nvoid check(int v){\n\tif(flag)return;\n\tif(v==cnt){\n\t\tbool ok=true;\n\t\tfor(int i=0;i<cnt;i++){\n\t\t\tif(max_x[i]>=min_x[i]){\n\t\t\t\tfor(int j=min_x[i];j<=max_x[i];j++){\n\t\t\t\t\tfor(int k=min_y[i];k<=max_y[i];k++){\n\t\t\t\t\t\tif(fie[j][k]==-1)ok=false;\n\t\t\t\t\t\telse if(up[i]>up[fie[j][k]])ok=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok)flag=true;\n\t}else{\n\t\tfor(int i=0;i<cnt;i++){\n\t\t\tif(used[i]==0){\n\t\t\t\tused[i]=1;\n\t\t\t\tup[v]=i;\n\t\t\t\tcheck(v+1);\n\t\t\t\tup[v]=-1;\n\t\t\t\tused[i]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\tscanf(\"%d\",&datac);\n\tfor(int ddd=0;ddd<datac;ddd++){\n\t\tscanf(\"%d %d\",&h,&w);\n\t\tfor(int i=0;i<30;i++){\n\t\t\tmin_x[i]=min_y[i]=51;\n\t\t\tmax_x[i]=max_y[i]=-1;\n\t\t}\n\t\tcnt=0;\n\t\tmemset(fie,-1,sizeof(fie));\n\t\tmemset(num,-1,sizeof(num));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\t\tif(num[str[j]-'A']==-1)num[str[j]-'A']=cnt++;\n\t\t\t\t\tfie[j][i]=num[str[j]-'A'];\n\t\t\t\t\tmin_x[fie[j][i]]=min(min_x[fie[j][i]],j);\n\t\t\t\t\tmin_y[fie[j][i]]=min(min_y[fie[j][i]],i);\n\t\t\t\t\tmax_x[fie[j][i]]=max(max_x[fie[j][i]],j);\n\t\t\t\t\tmax_y[fie[j][i]]=max(max_y[fie[j][i]],i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tflag=false;\n\t\tcheck(0);\n\t\tprintf(\"%s\\n\",flag?\"SAFE\":\"SUSPICIOUS\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nint H, W;\nchar grid[51][51];\n\nstruct Data {\n    int id, top, left, down, right;\n    Data() {\n        id = -1;\n        top = left = -1;\n        down = right = 100;\n    }\n};\n\nbool Loop(int dst, int src, vector<vector<int>> &g)\n{\n    if (dst == src)\n        return true;\n\n    for (unsigned i = 0; i < g[src].size(); ++i)\n        if (Loop(dst, g[src][i], g))\n            return true;\n\n    return false;\n}\n\nbool Solve()\n{\n    unordered_map<char, Data> hash;\n    int id = 0;\n\n    // 登録\n    for (int i = 0; i < H; ++i)\n        for (int j = 0; j < W; ++j)\n            if (grid[i][j] != '.') {\n                char c = grid[i][j];\n\n                if (hash.count(c) == 0) {  // 未登録\n                    hash[c].id = id++;\n                    hash[c].top = hash[c].down = i;\n                    hash[c].left = hash[c].right = j;\n                }\n                else { // 登録済み\n                    hash[c].top = min(hash[c].top, i);\n                    hash[c].down = max(hash[c].down, i);\n                    hash[c].left = min(hash[c].left, j);\n                    hash[c].right = max(hash[c].right, j);\n                }\n            }\n\n    vector<vector<int>> g(id, vector<int>());\n    // 長方形の確認\n    auto it = hash.begin();\n    while (it != hash.end()) {\n        for (int y = it->second.top; y <= it->second.down; ++y)\n            for (int x = it->second.left; x <= it->second.right; ++x) {\n                int src = it->second.id;\n\n                if (grid[y][x] == '.')\n                    return false;\n                else if (grid[y][x] != it->first &&\n                         count(g[src].begin(), g[src].end(),\n                               hash[grid[y][x]].id) == 0)\n                    g[src].push_back(hash[grid[y][x]].id);\n            }\n        ++it;\n    }\n\n    // ループが存在するかのチェック\n    for (unsigned i = 0; i < g.size(); ++i)\n        for (unsigned j = 0; j < g[i].size(); ++j)\n            if (Loop(i, g[i][j], g))\n                return false;\n\n    return true;\n}\n\nint main()\n{\n    int T;\n\n    cin >> T;\n    while (T--) {\n        cin >> H >> W;\n        for (int i = 0; i < H; ++i)\n            for (int j = 0; j < W; ++j)\n                cin >> grid[i][j];\n\n        if (Solve())\n            cout << \"SAFE\\n\";\n        else\n            cout << \"SUSPICIOUS\\n\";\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "if(A[z]==-1){\n    int a=49,b=0,c=0,d=49;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tif(t[i][j]==ch){\n\t  a=min(a,i);\n\t  b=max(b,j);\n\t  c=max(c,i);\n\t  d=min(d,j);\n\t}\n      }\n    }\n    A[z]=a;  B[z]=b;  C[z]=c;  D[z]=d;\n  }"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint main() {\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint H, W; cin >> H >> W;\n\t\tvector<string> s(H);\n\t\tfor (int i = 0; i < H; i++)\n\t\t\tcin >> s[i];\n\t\tfor (;;) {\n\t\t\tchar c;\n\t\t\tint l, r, u, d;\n\t\t\tfor (c = 'A'; c <= 'Z'; c++) {\n\t\t\t\tl = W; r = 0; u = H; d = 0;\n\t\t\t\tfor (int i = 0; i < H; i++)\n\t\t\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t\t\t\tif (s[i][j] == c) {\n\t\t\t\t\t\t\tl = min(l, j); r = max(r, j + 1);\n\t\t\t\t\t\t\tu = min(u, i); d = max(d, i + 1);\n\t\t\t\t\t\t}\n\t\t\t\tif (l == W) continue;\n\t\t\t\tbool rect = true;\n\t\t\t\tfor (int i = u; i < d; i++)\n\t\t\t\t\tfor (int j = l; j < r; j++)\n\t\t\t\t\t\tif (s[i][j] != c && s[i][j] != '?')\n\t\t\t\t\t\t\trect = false;\n\t\t\t\tif (rect) break;\n\t\t\t}\n\t\t\tif (c > 'Z') break;\n\t\t\tfor (int i = u; i < d; i++)\n\t\t\t\tfor (int j = l; j < r; j++)\n\t\t\t\t\ts[i][j] = '?';\n\t\t}\n\t\tbool safe = true;\n\t\tfor (int i = 0; i < H; i++)\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t\tif (s[i][j] != '.' && s[i][j] != '?')\n\t\t\t\t\tsafe = false;\n\t\tcout << (safe ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nstruct make\n{\n\tchar str;\n\tint posi,start[2];\n\tint high,wide,JUDGE;//JUDGE==1で長方形,==0で長方形以外,==2で未定\n\tstruct make *front[8];\n};\n\n\nint main()\n{\n\tint N,H,W,count,COUNT,judge,no_rect,NO_RECT;\n\tchar img[1000][51];\n\tstruct make M[8];\n\tint s1,s2,num;\n\t\n\tscanf(\"%d\",&N);//データの個数\n\tfor(int a=0;a<N;a++)\n\t{\n\t\tcount=0;//材質の個数\n\t\tCOUNT=0;\n\t\tNO_RECT=0;\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tscanf(\"%s\",img[b]);\n\t\t\timg[b][W]='\\0';\n\t\t}\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tfor(int d=0;d<count;d++) M[d].posi=-1;\n\t\t\tfor(int c=0;c<W;c++)\n\t\t\t{\n\t\t\t\tif(img[b][c]!='.')\n\t\t\t\t{\n\t\t\t\t\t//材質判定\n\t\t\t\t\tjudge=0;\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t\tif(count>0 && img[b][c]!=M[judge].str) judge++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}while(judge<count);\n\t\t\t\t\t//新しい材質の場合\n\t\t\t\t\tif(judge==count)\n\t\t\t\t\t{\n\t\t\t\t\t\tM[count].str=img[b][c];\n\t\t\t\t\t\tM[count].start[0]=b;\n\t\t\t\t\t\tM[count].start[1]=c;\n\t\t\t\t\t\tM[count].posi=c;\n\t\t\t\t\t\tM[count].high=1;\n\t\t\t\t\t\tM[count].wide=1;\n\t\t\t\t\t\tM[count].JUDGE=0;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\t//既出の材質の場合\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(M[judge].start[1]>c) M[judge].start[1]=c;\n\t\t\t\t\t\tif(M[judge].posi<0) M[judge].posi=c;\n\t\t\t\t\t\telse if(M[judge].wide<c-M[judge].posi+1) M[judge].wide=c-M[judge].posi+1;\n\t\t\t\t\t\tM[judge].high=b-M[judge].start[0]+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tno_rect=count;\n\t\t//printf(\"count=%d\\n\",count);\n\t\t//判定開始\n\t\twhile(count)//文字アリ\n\t\t{\n\t\t\tCOUNT=0;\n\t\t\t//見えている部分が長方形かどうか判定\n\t\t\tfor(num=0;num<count;num++)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(M[num].JUDGE==1) continue;\n\t\t\t\tM[num].JUDGE=0;//長方形なら\n\t\t\t\t//printf(\"M[%d].str=%c\\nM[%d].high=%d\\nM[%d].wide=%d\\n\",num,M[num].str,num,M[num].high,num,M[num].wide);\n\t\t\t\t//printf(\"M[%d].start[0]=%d\\nM[%d].start[1]=%d\\n\",num,M[num].start[0],num,M[num].start[1]);\n\t\t\t\tfor(s1=0;s1<M[num].high;s1++)\n\t\t\t\t{\n\t\t\t\t\tfor(s2=0;s2<M[num].wide;s2++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//確実に長方形ではない場合\n\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]=='.')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNO_RECT=1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//長方形の可能性もある場合\n\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]!=M[num].str && img[s1+M[num].start[0]][s2+M[num].start[1]]!='#' )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//printf(\"s1=%d s2=%d\\n\",s1,s2);\n\t\t\t\t\t\t\tM[num].JUDGE=2;\n\t\t\t\t\t\t\tCOUNT++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(NO_RECT || M[num].JUDGE==2) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(NO_RECT || M[num].JUDGE==2) break;\n\t\t\t\t}\n\t\t\t\tif(NO_RECT) break;\n\t\t\t\t//長方形だった場合\n\t\t\t\tif(s1==M[num].high && s2==M[num].wide)\n\t\t\t\t{\n\t\t\t\t\tM[num].JUDGE=1;\n\t\t\t\t\tno_rect--;\n\t\t\t\t\tfor(int s1=0;s1<M[num].high;s1++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int s2=0;s2<M[num].wide;s2++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\timg[s1+M[num].start[0]][s2+M[num].start[1]]='#';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//printf(\"M[%d].JUDGE=%d\\n\\n\",num,M[num].JUDGE);\n\t\t\t}\n\t\t\tfor(int n=0;n<num;)\n\t\t\t{\n\t\t\t\tif(M[num].JUDGE!=2) break;\n\t\t\t\tn++;//どれも長方形ではなかった場合\n\t\t\t\tif(n==num) NO_RECT=1;\n\t\t\t}\n\t\t\t\n\t\t\t//printf(\"NO_RECT=%d\\n\",NO_RECT);\n\t\t\tif(NO_RECT==1) break;\n\t\t\t//printf(\"#no_rect=%d\\n\\n\\n\",no_rect);\n\t\t\t//すべて長方形\n\t\t\tif(no_rect==0) break;\n\t\t}\n\t\t//出力\n\t\tif(NO_RECT) printf(\"SUSPICIOUS1\\n\");\n\t\telse if(no_rect) printf(\"SUSPICIOUS2\\n\");\n\t\telse printf(\"SAFE1\\n\");\n\t}\n\t\n\treturn 0;\n}\n//printf(\"#1\");\n//printf(\"M[%d].str=%c\\nM[%d].high=%d\\nM[%d].wide=%d\\n\",num,M[num].str,num,M[num].high,num,M[num].wide);\n//printf(\"M[%d].start[0]=%d\\nM[%d].start[1]=%d\\n\\n\",num,M[num].start[0],num,M[num].start[1]);\n//printf(\"M[%d].JUDGE=%d\\n\\n\",num,M[num].JUDGE);\n//printf(\"s1=%d s2=%d\\n\",s1,s2);\n//printf(\"#no_rect=%d\\n\\n\\n\",no_rect);\n//printf(\"#s1=%d\\n#s2=%d\\n\",s1,s2);\n/*\n1\n10 10\n..........\n.DDDDDD...\n.DDDDCCC..\n.DDDDCCC..\nADDDDCCC..\nAAA..CCC..\nAAABBBBC..\nAAABBBB...\n..BBBBB...\n..........\n*/\n/*\n1\n10 10\n..........\n.DDDDCCC..\n.DDDDCCC..\n.DDDDCCC..\nADDDDCCC..\nAAA..CCC..\nAAABBBBC..\nAAABBBB...\n..BBBBB...\n..........\n*/\n"
  },
  {
    "language": "C++",
    "code": "using namespace std;/*{{{*/\n\n#include <iostream>\n#include <map>\n#include <vector>\n\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n/*}}}*/\n\nstruct article {\n\tchar material;\n\tbool is_removed;\n\tint topmost;\n\tint bottommost;\n\tint leftmost;\n\tint rightmost;\n};\n\n// typedef map<char, article> MCA;\ntypedef vector<article> VA;\n\nVVC image;\nVA articles;\n\nbool remove_all()\n{\n\tbool all_removed = true;\n\tREP (ai, articles.size()) {\n\t\tarticle &art = articles[ai];\n\t\tif (!art.is_removed) {\n\t\t\tall_removed = false;\n\t\t\t// Remove it and recurse\n\t\t\tVVC save = image;\n\t\t\tbool rect = true;\n\t\t\tFOR (i, art.topmost, art.bottommost + 1) {\n\t\t\t\tFOR (j, art.leftmost, art.rightmost + 1) {\n\t\t\t\t\tif (image[i][j] != '*' && image[i][j] != art.material) {\n\t\t\t\t\t\trect = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\timage[i][j] = '*';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rect) {\n\t\t\t\t// Recurse\n\t\t\t\tart.is_removed = true;\n\t\t\t\tif (remove_all()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Restore and continue trying\n\t\t\tart.is_removed = false;\n\t\t\timage = save;\n\t\t}\n\t}\n\treturn all_removed;\n}\n\nint main()\n{\n\tint t; cin >> t;\n\tREP (_, t) {\n\t\tint h, w; cin >> h >> w;\n\t\timage = VVC(h, VC(w, '.'));\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tcin >> image[i][j];\n\t\t\t}\n\t\t}\n\n\t\t// Scan Image\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tif (image[i][j] != '.') {\n\t\t\t\t\tchar c = image[i][j];\n\t\t\t\t\tbool exists = false;\n\t\t\t\t\tREP (ai, articles.size()) {\n\t\t\t\t\t\tif (articles[ai].material == c) {\n\t\t\t\t\t\t\texists = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!exists) {\n\t\t\t\t\t\tarticle a = {c, false, 50, 0, 50, 0};\n\t\t\t\t\t\tarticles.push_back(a);\n\t\t\t\t\t}\n\t\t\t\t\tint arti = 0;\n\t\t\t\t\tREP (ai, articles.size()) {\n\t\t\t\t\t\tif (articles[ai].material == c) {\n\t\t\t\t\t\t\tarti = ai;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tarticles[arti].topmost = min(articles[arti].topmost, i);\n\t\t\t\t\tarticles[arti].bottommost = max(articles[arti].bottommost, i);\n\t\t\t\t\tarticles[arti].leftmost = min(articles[arti].leftmost, j);\n\t\t\t\t\tarticles[arti].rightmost = max(articles[arti].rightmost, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (remove_all()) {\n\t\t\tcout << \"SAFE\" << endl;\n\t\t} else {\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint w, h;\n\nstruct Rect{\n    int up;\n    int down;\n    int left;\n    int right;\n\n    Rect()\n    : up(inf),\n      down(-inf),\n      left(inf),\n      right(-inf) {}\n};\n\nint main(void){\n    int n; cin >> n;\n\n    while(n--){\n        cin >> h >> w;\n        string res = \"SAFE\";\n\n        vs bag(h);\n        rep(y, h) cin >> bag[y];\n\n        map<char, Rect> rects;\n        set<char> s;\n        rep(y, h){\n            rep(x, w){\n                if(bag[y][x] != '.'){\n                    rects[bag[y][x]].up = min(rects[bag[y][x]].up, y);\n                    rects[bag[y][x]].down = max(rects[bag[y][x]].down, y);\n                    rects[bag[y][x]].left = min(rects[bag[y][x]].left, x);\n                    rects[bag[y][x]].right = max(rects[bag[y][x]].right, x);\n\n                    s.insert(bag[y][x]);\n                }\n            }\n        }\n\n        int cnt = 0;\n        rep(i, s.size()){\n            each(itr, s){\n                char c = *itr;\n                bool pass = false;\n                bool in = false;\n                range(y, rects[c].up, rects[c].down + 1){\n                    range(x, rects[c].left, rects[c].right + 1){\n                        if(bag[y][x] == '.' || (bag[y][x] != c && bag[y][x] != '*')){\n                            pass = true;\n                            break;\n                        }\n                        if(bag[y][x] == c) in = true;\n                    }\n                    if(pass) break;\n                }\n                if(pass || !in) continue;\n\n                cnt++;\n                range(y, rects[c].up, rects[c].down + 1){\n                    range(x, rects[c].left, rects[c].right + 1){\n                        bag[y][x] = '*';\n                    }\n                }\n            }\n        }\n\n        if(cnt != s.size()){\n            res = \"SUSPICIOUS\";\n        }\n        cout << res << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass Belongings {\npublic:\n  Belongings() : left(100),right(0),upper(100),lower(0){}\n  int left,right,upper,lower;\n};\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    for(int stage_idx = 0; stage_idx < N; stage_idx++){\n      int H,W;\n      char stage[50*50];\n      memset(stage,'.',sizeof(stage));\n      \n      scanf(\"%d %d\",&H,&W);\n      map<char,Belongings> layer;\n    \n      for(int y=0;y<H;y++){\n\tchar line[51];\n\tscanf(\"%s\",line);\n\tfor(int x=0;x<W;x++){\n\t  stage[y*W+x] = line[x];\n\t  //x:0->...\n\t  //y:0\n\t  //  |\n\t  //  v\n\t  //  .\n\t  //  upper\n\t  //left right\n\t  //  lower\n\t  Belongings& it = layer[stage[y*W+x]];\n\t  it.left = min(it.left,x);\n\t  it.right = max(it.right,x);\n\t  it.upper = min(it.upper,y);\n\t  it.lower = max(it.lower,y);\n\t}\n      }\n\n      bool is_safe = false;\n\n      vector<char> order;\n      for(map<char,Belongings>::iterator it = layer.begin();\n\t  it != layer.end();\n\t  it++){\n\torder.push_back(it->first);\n      }\n      sort(order.begin(),order.end());\n      char hypothesis[50*50];\n\n      do{\n\tmemset(hypothesis,'.',sizeof(hypothesis));\n\n\tfor(int i=0;i<order.size();i++){\n\t  int c = order[i];\n\t  Belongings& it = layer[c];\n\t  for(int y=it.upper; y<=it.lower; y++){\n\t    for(int x=it.left; x<=it.right; x++){\n\t      hypothesis[y*W+x] = c;\n\t    }\n\t  }\n\t}\n\n\tif(strcmp(hypothesis,stage) == 0){\n\t  is_safe = true;\n\t  break;\n\t}\n      }while(next_permutation(order.begin(),order.end()));\n      printf(\"%s\\n\",is_safe ? \"SAFE\" : \"SUSPICIOUS\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  int n;\n  cin >> n;\n  for(int t=0;t<n;t++){\n    int h,w;\n    cin >> h >> w;\n    vector<string> f(h);\n    for(int i=0;i<h;i++) cin >> f[i];\n    vector<bool> use(26,false);\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        if(f[i][j]!='.') use[f[i][j]-'A']=true;\n      }\n    }\n    int count=0;\n    for(int i=0;i<26;i++) if(use[i]) count++;\n    vector<char> alpha(count);\n    int now=0;\n    for(int i=0;i<26;i++) if(use[i]) alpha[now]='A'+i,now++;\n    for(int i=0;i<count;i++){\n      for(int j=0;j<count;j++){\n        int maxx=-1,maxy=-1,miny=h,minx=w;\n        for(int y=0;y<h;y++){\n          for(int x=0;x<w;x++){\n            if(f[y][x]==alpha[j]){\n              maxx=max(maxx,x);\n              maxy=max(maxy,y);\n              minx=min(minx,x);\n              miny=min(miny,y);\n            }\n          }\n        }\n        for(int y=miny;y<=maxy;y++){\n          for(int x=minx;x<=maxx;x++){\n            if(f[y][x]!=alpha[j]&&f[y][x]!='?') goto next;\n          }\n        }\n        for(int y=miny;y<=maxy;y++){\n          for(int x=minx;x<=maxx;x++){\n            f[y][x]='?';\n          }\n        }\n        next:\n        continue;\n      }\n      // for(int i=0;i<h;i++){\n      //   cout << f[i] << endl;\n      // }\n    }\n    bool okflag=true;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        if(f[i][j]!='.'&&f[i][j]!='?') okflag=false;\n      }\n    }\n    if(okflag) cout << \"SAFE\" << endl;\n    else cout << \"SUSPICIOUS\" << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <cctype>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <climits>\nusing namespace std;\n\n#ifdef __linux\n#define _U(s) s##_unlocked\n#else\n#define _U(s) _##s##_nolock\n#define _CRT_DISABLE_PERFCRIT_LOCKS\n#endif\n#define gcu _U(getchar)\n#define pcu _U(putchar)\n#define _DEF(r, n, ...) inline r n(__VA_ARGS__) noexcept\n#define _T template <typename T>\n#define _HT template <typename H,typename... T>\n#define _OP(t) inline operator t()\nstruct _in {\n#ifdef _GLIBCXX_STRING\n\t_OP(string){string s;char c;while(isspace(c = gcu()));do{s+=c;}while(c=gcu(),c!=' '&&c!='\\n'&&c!=EOF);return s;}\n#define _S\n#endif\n\t_OP(char){char c=gcu();gcu();return c;}\n\t_OP(double){double d; scanf(\"%lf\",&d); gcu();return d;}\n\t_T _OP(T){T n{},m{1},c;while(isspace(c = gcu()));if(c=='-')m=-1,c=gcu();do{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m*n;}\n} in;\n#define _SCAN(...) _DEF(bool,scan,__VA_ARGS__)\n#ifdef _S\n_SCAN(string &o) {int c{gcu()};if(c==EOF)return false;else{ungetc(c,stdin);string t=move(in);o=t;return true;}}\n#endif\n_T _SCAN(T &o) {int c{gcu()};return c==EOF?false:(ungetc(c,stdin),o=in,true);}\n_HT _SCAN(H &h,T&&... t){return scan(h)&&scan(t...);}\n#define _OUT(...) _DEF(void,out,__VA_ARGS__)\n#define _OUTL(...) _DEF(void,outl,__VA_ARGS__)\n_OUT(bool b){pcu('0'+b);}\n_OUT(const char *s){while(*s)pcu(*s++);}\n_OUT(char c){pcu(c);}\n#ifdef _S\n_OUT(string &s){for(char c:s)pcu(c);}\n#endif\n_T _OUT(T n){static char b[20];char *p=b;T m=n<0?pcu('-'),-1:1;\n\tif(!n)*p++='0';else while(n)*p++=(char)(n%10*m+'0'),n/=10;while(p!=b)pcu(*--p);}\n_OUTL(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n\t_T _OUT(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);}\n#endif\n_HT _OUT(H &&h, T... t){out(h);out(t...);}\ntemplate <typename... T> _OUTL(T... t){out(t...);outl();}\n#define dbg(...) fprintf(stderr,__VA_ARGS__);\nstruct range{\n\tint e,b=0,s=1;range(int b,int e,int s):e(e),b(b),s(s){} range(int b,int e): e(e), b(b){} range(int e):e(e){}\n\tstruct it{int v,s; it(int v,int s):v(v),s(s){} operator int()const{return v;} operator int&(){return v;}int operator*()const{return v;}\n\t\tit& operator++(){v+=s;return *this;} }; it begin(){return {b,s};} it end(){return {e,s};}};\n#define times(i,n) for(int i=n;i;i--)\n\n_T using V = vector<T>;\n\nstruct M {\n\tint t, b, l, r;\n};\nusing MM = unordered_map<char, M>;\n\nint main() {\n\ttimes(n, in) {\n\t\tint H {in}, W {in};\n\t\tV<V<char>> S(H, V<char>(W));\n\t\tMM m;\n\t\tfor (int i: range(H)) {\n\t\t\tfor (int j: range(W)) {\n\t\t\t\tchar c = gcu();\n\t\t\t\tS[i][j] = c;\n\t\t\t\tif (c != '.') {\n\t\t\t\t\tif (m.count(c))\n\t\t\t\t\t\tm[c] = {m[c].t, i, min(m[c].l, j), max(m[c].r, j)};\n\t\t\t\t\telse\n\t\t\t\t\t\tm[c] = {i, i, j, j};\n\t\t\t\t}\n\t\t\t}\n\t\t\tgcu();\n\t\t}\n\t\tauto find = [&] {\n\t\t\tfor (auto p: m) {\n\t\t\t\tint r = [&] {\n\t\t\t\t\tM t = p.second;\n\t\t\t\t\tfor (int i: range(t.t, t.b + 1))\n\t\t\t\t\t\tfor (int j: range(t.l, t.r + 1))\n\t\t\t\t\t\t\tif (S[i][j] == '.')\n\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\telse if (S[i][j] != p.first && S[i][j] != '?')\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\treturn 1;\n\t\t\t\t}();\n\t\t\t\tif (r == 1)\n\t\t\t\t\treturn p.first;\n\t\t\t\telse if (r == -1)\n\t\t\t\t\treturn '.';\n\t\t\t}\n\t\t\treturn '.';\n\t\t};\n\t\toutl([&] {\n\t\t\twhile (!m.empty()) {\n\t\t\t\tchar c = find();\n\t\t\t\tif (c == '.')\n\t\t\t\t\treturn \"SUSPICIOUS\";\n\t\t\t\tM t = m[c];\n\t\t\t\tfor (int i: range(t.t, t.b + 1))\n\t\t\t\t\tfor (int j: range(t.l, t.r + 1))\n\t\t\t\t\t\tS[i][j] = '?';\n\t\t\t\tm.erase(c);\n\t\t\t}\n\t\t\treturn \"SAFE\";\n\t\t}());\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\n\nusing namespace std;\nstring enumerate(int,int,int,int);\nvoid range(char);\nbool consistent_order(string);\n\nchar datas[50][50];\nint data;\nchar moji;\nint min_x[256];\nint max_x[256];\nint min_y[256];\nint max_y[256];\nstring include_moji[256];\n//string datas[50][50];\n\nint main(){\n  //  char c = word[1];\n  //  long int a;\n  int h,w,tmp;\n  //  char datas[50][50];\n  //word3[3] = 'K';\n  //  cout << word << \" \" << word2 << \" \" << word3 << \" \"  <<c << endl;\n  //cin >> word;\n  //cout << word.size() << endl;\n  while(cin >> tmp){\n    //cout << tmp << endl;\n    for(int kaisu=0;kaisu<tmp;kaisu++){\n      //cout << tmp << endl;//\\¦p\n      cin >> h >> w;\n      //cout << endl <<\"Size:\"<<h << \"*\"<< w << endl;//¯¶­\\¦p\n      \n      for(int i=0;i<256;i++){\n\tmin_x[i] = max_x[i] = min_y[i] = max_y[i] = -1;\n      }\n      \n      for(int i=0;i<h;i++){\n\tfor(int j=0;j<w;j++){\n\t  cin >> datas[i][j];\n\t  data=int(datas[i][j]);\n\t  if(min_x[data]==-1){\n\t    min_x[data] = max_x[data] = i;\n\t    min_y[data] = max_y[data] = j;\n\t  }\n\t  if(max_x[data] < i){\n\t    max_x[data] = i;\n\t    //cout << \"max_xXV\" << endl;\n\t  }else if(min_x[data] > i){\n\t    min_x[data]  = i;\n\t  }\n\t  if(max_y[data] < j){\n\t    max_y[data] = j;\n\t    //cout << \"max_yXV\" << endl;\n\t  }else if(min_y[data] > j){\n\t    min_y[data]  = j;\n\t  }\n\t  //cout << datas[i][j];// <<\" \";\\¦p\n\t}\n\t//cout << endl;\n      }\n\n      \n      string enume = enumerate(0,0,w-1,h-1);\n      //cout << enume << endl;\n      sort(enume.begin(), enume.end());\n      //cout << enume << endl;\n      if(enume == \".\"){\n\tcout << \"SAFE\" << endl;\n      }else{\n\t//cout << enume[0] << endl;\n\tif(enume[0]=='.'){\n\t  enume.erase(0,1);\n\t  //cout << \"erased\" << enume << endl;\n\t}\n\t//cout << enume << endl;\n\t//cin >> w >> h >> endl;\n\t//cout << enumerate(0,0,w,h) << endl;\n\t//cout << enume.size() << \"enume.size()\" << endl;\n\tstring all =\" \";\n\t\n\tfor(unsigned int k=0;k<enume.size();k++){\n\t  moji = enume[k];\n\t  all+=enumerate(min_y[moji],min_x[moji],max_y[moji],max_x[moji]);\n\t}\n\t\n\tif(all.find('.') != string::npos){ //àµ·û`àÉ.ª Á½çAâßé\n\t  cout << \"SUSPICIOUS\" << endl;\n\t}else{\n\t  for(unsigned int k=0;k<enume.size();k++){\n\t    moji = enume[k];\n\t    include_moji[moji] = enumerate(min_y[moji],\n\t\t\t\t\t   min_x[moji],max_y[moji],max_x[moji]);\n\t    //range(enume[k]);\n\t    //sort(include_moji.begin(),include_moji.end());\n\t    //string include_moji = enumerate(min_y[moji],\n\t    //min_x[moji],max_y[moji],max_x[moji]);\n\t    //cout << moji << \" \" << include_moji[moji] << endl;\n\t  }\n\t  \n\t  //cout << enume << endl;\n\t  \n\t  if(!consistent_order(enume)){\n\t    cout << \"SUSPICIOUS\" << endl;\n\t  }\t\n\t}\n      }\n      \n    }    \n  }\n}\n\n\nstring enumerate(int left, int top, int right, int bottom){\n  string all=\"\";\n  for(int i=top;i <= bottom; i++){\n    for(int j=left;j <= right;j++){\n      //±ÌªÌL@ªöµ¢ ±±©ç\n      if(all.find(datas[i][j])==string::npos){\n\tall += datas[i][j];\n\t//±±ÜÅ\n\t//cout << datas[i][j];\n      }\n    }\n  }\n  return all;\t\n}\n\nvoid range(char c){\n  int l,t,r,b;\n  l=min_x[int(c)];\n  t=min_y[int(c)];\n  r=max_x[int(c)];\n  b=max_y[int(c)];\n  \n  cout << c << \"; l:\" << l << \" t:\" << t << \" r:\" << r << \" b:\" << b << endl;\n}\n\nbool consistent_order(string order){\n  int i;\n  int order_size = order.size();\n  do{\n    for(i=0 ; i<order_size;i++){\n      string wa = \"\";\n      for(int j=i+1;j<order_size;j++){\n\twa += include_moji[order[j]];\t\n      }\n      //cout << \"iÈ~\" << i << \" a\" << wa << endl; \n      if(wa.find(order[i])!= string::npos/*false*//*½©ðð­*/){\n\t//if(false){\n\tbreak;\n      }\n      continue;\n    }\n    if(i==order_size){\n      cout <<\"SAFE\" << endl;\n      return true;\n    }\n  }while(next_permutation(order.begin(),order.end()));\n  //cout << \"\\¦³êÈ¢Í¸\";\n  return false;\n}\n\n//cout <<\"i:\"<<i<<\" includemoji_i\"<<include_moji[i] << endl;\n//cout << order[i] << \" \" << int(include_moji[i].find(order[i])!= string::npos) << endl;\n\n/*\n  do{\n  if(consistent_order(enume)){\n  //cout << \"SAFE\" << endl;\n    break;\n    }\n    //cout << \"SUSPICIOUS\" << endl;\n    //cout << enume << endl;\n    }while(next_permutation(enume.begin(),enume.end()));\n*/\n/*\n  if(word.find(\"A\") != string::npos){}\n  wrod.erase(word.begin() +n);\n  sort(word.begin(), word.end());\n  word.erase(unique(word.begin(), word.end() ), word.end());\n  sort(word.begin(), word.end());\n  do{\n  cout << word << endl;\n  }while(next_permutation(word.begin(),word.end()));\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int MAX_S = 51;\nconst int dx[4] = {1,0,-1,0};\nconst int dy[4] = {0,1,0,-1};\nconst int INF = 1<<24;\nint H, W;\nchar G[MAX_S][MAX_S];\nint vis[MAX_S][MAX_S];\nbool vis2[MAX_S][MAX_S];\n\npair<P, P> rec(int x, int y, char c, int level) {\n  vis[y][x] = level;\n  vis2[y][x] = true;\n  pair<P, P> p = make_pair(P(x, y), P(x, y));\n  for(int i = 0; i < 4; ++i) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(nx < 0 || nx >= W) continue;\n    if(ny < 0 || ny >= H) continue;\n    if(vis2[ny][nx]) continue;\n    if(G[ny][nx] != c) continue;\n    pair<P, P> q = rec(nx, ny, c, level);\n    p.first.first = min(p.first.first, q.first.first);\n    p.first.second = min(p.first.second, q.first.second);\n    p.second.first = max(p.second.first, q.second.first);\n    p.second.second = max(p.second.second, q.second.second);\n  }\n  return p;\n}\n\nbool notW(int sx, int sy, int ex, int ey, char c, int level, vector<P> &v) {\n  v.clear();\n  for(int y = sy; y <= ey; ++y) {\n    for(int x = sx; x <= ex; ++x) {\n      if(G[y][x] == '.') return false;\n      if(G[y][x] != c) {\n\tif(vis[y][x]) {\n\t  if(vis[y][x] < level) return false;\n\t} else {\n\t  v.push_back(P(x, y));\n\t}\n      }\n    }\n  }\n  return true;\n}\n\nvoid show() {\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      cout << vis[i][j];\n    }\n    cout << endl;\n  }\n}\n\nbool solve(int j, int i, int level) {\n  pair<P, P> p = rec(j, i, G[i][j], level);\n  vector<P> v;\n  if(! notW(p.first.first, p.first.second\n\t    , p.second.first, p.second.second, G[i][j], level, v)) {\n    return false;\n  }\n\n  for(int i = 0; i < v.size(); ++i) {\n    if(!vis2[v[i].second][v[i].first]) {\n      if(!solve(v[i].first, v[i].second, level+1)) return false;\n    }\n  }\n  return true;\n}\n\nbool ans() {\n  for(int i = 0; i < H; ++i) {\n    fill(vis2[i], vis2[i]+W, false);\n  }\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if(!vis2[i][j] && G[i][j] != '.') {\n\tfor(int k = 0; k < H; ++k) {\n\t  fill(vis[k], vis[k]+W, 0);\n\t}\n\tif(!solve(j, i, 1)) return false;\n      }\n    }\n  }\n  return true;\n}\n\nint main() {\n  int T;\n  cin >> T;\n  while(T--) {\n    cin >> H >> W;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tcin >> G[i][j];\n      }\n    }\n    if(ans()) cout << \"SAFE\" << endl;\n    else cout << \"SUSPICIOUS\" << endl;\n    //show();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint minX[26], maxX[26], minY[26], maxY[26];\nbool has[26];\n\nint main() {\n\tint t, H, W;\n\tcin >> t;\n\twhile (t--) {\n\t\tfor (int i=0; i<26; ++i) {\n\t\t\tminX[i] = minY[i] = 51;\n\t\t\tmaxX[i] = maxY[i] = -1;\n\t\t\thas[i] = false;\n\t\t}\n\t\tcin >> H >> W;\n\t\tvector<string> img(H, \"\");\n\t\tfor (int i=0; i<H; ++i) {\n\t\t\tcin >> img[i];\n\t\t\tfor (int j=0; j<W; ++j) {\n\t\t\t\tchar c = img[i][j];\n\t\t\t\tif (c != '.') {\n\t\t\t\t\tminX[c - 'A'] = min(minX[c - 'A'], j);\n\t\t\t\t\tmaxX[c - 'A'] = max(maxX[c - 'A'], j);\n\t\t\t\t\tminY[c - 'A'] = min(minY[c - 'A'], i);\n\t\t\t\t\tmaxY[c - 'A'] = max(maxY[c - 'A'], i);\n\t\t\t\t\thas[c - 'A'] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint k = 0;\n\t\twhile (k <= 26) {\n\t\t\tif (has[k]) {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int i=minY[k]; i<=maxY[k] && ok; ++i) {\n\t\t\t\t\tfor (int j=minX[k]; j<=maxX[k] && ok; ++j) {\n\t\t\t\t\t\tif (img[i][j] - 'A' != k && img[i][j] != '#') {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tfor (int i=minY[k]; i<=maxY[k]; ++i) {\n\t\t\t\t\t\tfor (int j=minX[k]; j<=maxX[k]; ++j) {\n\t\t\t\t\t\t\timg[i][j] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\thas[k] = false;\n\t\t\t\t\tk = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t++ k;\n\t\t}\n\t\tbool safe = true;\n\t\tfor (int i=0; i<26; ++i) {\n\t\t\tif (has[i]) {\n\t\t\t\tsafe = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << (safe ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n\ntypedef long long ll;\n\n\nint cnt[30][55][55];\nint val[30];\n\nint getcnt(int a,int b,int c,int d,int e){\n\tint ret = cnt[e][c][d];\n\tif(c) ret-=cnt[e][c-1][b];\n\tif(d) ret-=cnt[e][a][d-1];\n\tif(c&&d) ret+=cnt[e][c-1][d-1];\n\treturn ret;\n}\n\n\nint main(){\n\tint n;\n\tcin>>n;\n\trep(o,n){\n\t\tint h,w;\n\t\tcin>>h>>w;\n\t\tvector<string> v(h);\n\t\trep(i,h) cin>>v[i];\n\t\tbool update = true;\n\t\tbool ok=true;\n\t\twhile(update){\n\t\t\tok=true;\n\t\t\tupdate=false;\n\t\t\trep(i,h) rep(j,w) if(v[i][j]!='.'&&v[i][j]!='-') ok=false;\n\t\t\tif(ok){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i,30) rep(j,55) rep(k,55) cnt[i][j][k]=0;\n\t\t\trep(i,30){\n\t\t\t\trep(j,h){\n\t\t\t\t\trep(k,w){\n\t\t\t\t\t\tif(v[j][k]==char('A'+i)||v[j][k]=='-'){\n\t\t\t\t\t\t\tcnt[i][j][k]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j) cnt[i][j][k]+=cnt[i][j-1][k];\n\t\t\t\t\t\tif(k) cnt[i][j][k]+=cnt[i][j][k-1];\n\t\t\t\t\t\tif(j&&k) cnt[i][j][k]-=cnt[i][j-1][k-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,30){\n\t\t\t\trep(y1,h){\n\t\t\t\t\trep(x1,w){\n\t\t\t\t\t\treep(y2,y1,h){\n\t\t\t\t\t\t\treep(x2,x1,w){\n\t\t\t\t\t\t\t\tif((y2-y1+1)*(x2-x1+1)==cnt[i][h-1][w-1]&&getcnt(y1,x1,y2,x2,i)==cnt[i][h-1][w-1]){\n\t\t\t\t\t\t\t\t\t// cout<<\"AAA\"<<endl;\n\t\t\t\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t\t\t\t\treep(j,y1,y2+1){\n\t\t\t\t\t\t\t\t\t\treep(k,x1,x2+1){\n\t\t\t\t\t\t\t\t\t\t\tv[j][k]='-';\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok) cout<<\"SAFE\"<<endl;\n\t\telse cout<<\"SUSPICIOUS\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\nusing namespace std;\n#define FOR(i,a,n) for(int i=(a); i<(n); ++i)\n\nstruct Rect {\n\tint x1, x2, y1, y2;\n};\nmap<char, Rect> item;\nvector<string> img;\nint t, H, W;\n\nbool ok(Rect &r, char c) {\n\tFOR(i,r.y1,r.y2+1) FOR(j,r.x1,r.x2+1) {\n\t\tif (img[i][j] != c && img[i][j] != '#') {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid fill(Rect &r, char c) {\n\tFOR(i,r.y1,r.y2+1) FOR(j,r.x1,r.x2+1) img[i][j] = c;\n}\n\nint main() {\n\tcin >> t;\n\twhile (t--) {\n\t\tcin >> H >> W;\n\t\timg.resize(H);\n\t\tFOR(i,0,H) cin >> img[i];\n\n\t\tFOR(i,0,H) FOR(j,0,W) {\n\t\t\tchar c = img[i][j];\n\t\t\tif (c != '.') {\n\t\t\t\tif ( ! item.count(c)) {\n\t\t\t\t\titem[c] = (Rect){j, j, i, i};\n\t\t\t\t} else {\n\t\t\t\t\titem[c].x1 = min(item[c].x1, j);\n\t\t\t\t\titem[c].x2 = max(item[c].x2, j);\n\t\t\t\t\titem[c].y1 = min(item[c].y1, i);\n\t\t\t\t\titem[c].y2 = max(item[c].y2, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmap<char, Rect>::iterator it = item.begin();\n\t\twhile (it != item.end()) {\n\t\t\tchar c = (*it).first;\n\t\t\tRect &r = (*it).second;\n\t\t\tif (ok(r, c)) {\n\t\t\t\tfill(r, '#');\n\t\t\t\titem.erase(c);\n\t\t\t\tit = item.begin();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t++ it;\n\t\t}\n\t\tcout << (item.empty() ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n\t\titem.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii>pipi;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint N;\nint H,W;\nmap<char, int>m;\nint kind;\nchar obj[8];\nvector<string>p;\npipi pi[8]; // miny, maxy, minx, maxx\n\nint judge(vector<string>s){ return s==p; }\n\nint dfs(int n, int bit, vector<string>s){\n  if(n==kind) return judge(s);\n\n  rep(i,kind){\n    if((bit>>i)&1) continue;\n    for(int y=pi[i].Fi.Fi;y<=pi[i].Fi.Se;y++) for(int x=pi[i].Se.Fi;x<=pi[i].Se.Se;x++) s[y][x] = obj[i];\n    if(dfs(n+1, bit | (1<<i), s)) return 1;\n    for(int y=pi[i].Fi.Fi;y<=pi[i].Fi.Se;y++) for(int x=pi[i].Se.Fi;x<=pi[i].Se.Se;x++) s[y][x] = '.';\n  }\n  return 0;\n}\n\nstring dot(int w){\n  string res=\"\";\n  rep(i,w) res += \".\";\n  return res;\n}\n\nint main(){\n  cin >> N;\n  while(N--){\n    kind=0;\n    rep(i, 8) pi[i] = MP(MP(64,-1),MP(64,-1));\n    m.clear();\n    cin >> H >> W;\n    p.resize(H);\n    rep(i,H) cin >> p[i];\n\n    rep(i,H) rep(j,W){\n      if(p[i][j]=='.') continue;\n      if(m.find(p[i][j]) == m.end()){\n\tm[p[i][j]] = kind;\n\tobj[kind] = p[i][j];\n\tkind++;\n      }\n\n      int pos = m[p[i][j]];\n      pi[pos].Fi.Fi = min(pi[pos].Fi.Fi, i); pi[pos].Fi.Se = max(pi[pos].Fi.Se, i);\n      pi[pos].Se.Fi = min(pi[pos].Se.Fi, j); pi[pos].Se.Se = max(pi[pos].Se.Se, j);\n    }\n\n    if(!kind) cout << \"SAFE\\n\";\n    else{\n      vector<string>s(H, dot(W));\n      if(dfs(0, 0, s)) cout << \"SAFE\\n\";\n      else cout << \"SUSPICIOUS\\n\";\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool impossible(char ch1, set<char> has, map<char, set<char> > mp) {\n  if (has.find(ch1) != has.end()) return true;\n  has.insert(ch1);\n\n  bool res = false;\n  for (auto ch2 : mp[ch1]) {\n    res |= impossible(ch2, has, mp);\n  }\n  return res;\n}\n\nvoid solve(void) {\n  int h, w;\n  cin >> h >> w;\n\n  vector<string> s(h);\n  for (int i = 0; i < h; i++) {\n    cin >> s[i];\n  }\n\n  set<char> st;\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if (s[i][j] != '.') {\n        st.insert(s[i][j]);\n      }\n    }\n  }\n\n  bool ng = false;\n  map<char, set<char> > mp;\n  for (auto ch : st) {\n    int u = 51, d = -1, l = 51, r = -1;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if (s[i][j] == ch) {\n          u = min(u, i);\n          d = max(d, i);\n          l = min(l, j);\n          r = max(r, j);\n        }\n      }\n    }\n\n    for (int i = u; i <= d; i++) {\n      for (int j = l; j <= r; j++) {\n        if (s[i][j] == '.') {\n          ng = true;\n        } else if (s[i][j] != ch) {\n          mp[ch].insert(s[i][j]);\n        }\n      }\n    }\n  }\n\n  for (auto ch1 : st) {\n    set<char> has;\n    has.insert(ch1);\n    for (auto ch2 : mp[ch1]) {\n      ng |= impossible(ch2, has, mp);\n    }\n  }\n\n  cout << (ng ? \"SUSPICIOUS\" : \"SAFE\") << endl;\n}\n\nint main(void) {\n  int n;\n  cin >> n;\n\n  for (int i = 0; i < n; i++) {\n    solve();\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "using namespace std;/*{{{*/\n\n#include <iostream>\n#include <map>\n#include <vector>\n\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n/*}}}*/\n\nstruct article {\n\tchar material;\n\tbool is_removed;\n\tint topmost;\n\tint bottommost;\n\tint leftmost;\n\tint rightmost;\n};\n\ntypedef map<char, article> MCA;\n\nVVC image;\nMCA articles;\n\nbool remove_all()\n{\n\tbool all_removed = true;\n\tEACH (articles, itr) {\n\t\tarticle &art = itr->second;\n\t\tif (!art.is_removed) {\n\t\t\tall_removed = false;\n\t\t\t// Remove it and recurse\n\t\t\tVVC save = image;\n\t\t\tbool rect = true;\n\t\t\tFOR (i, art.topmost, art.bottommost + 1) {\n\t\t\t\tFOR (j, art.leftmost, art.rightmost + 1) {\n\t\t\t\t\tif (image[i][j] != '*' && image[i][j] != art.material) {\n\t\t\t\t\t\trect = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\timage[i][j] = '*';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rect) {\n\t\t\t\t// Recurse\n\t\t\t\tart.is_removed = true;\n\t\t\t\tif (remove_all()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Restore and continue trying\n\t\t\tart.is_removed = false;\n\t\t\timage = save;\n\t\t}\n\t}\n\treturn all_removed;\n}\n\nint main()\n{\n\tint t; cin >> t;\n\tREP (_, t) {\n\t\tint h, w; cin >> h >> w;\n\t\timage = VVC(h, VC(w, '.'));\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tcin >> image[i][j];\n\t\t\t}\n\t\t}\n\n\t\t// Scan Image\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tif (image[i][j] != '.') {\n\t\t\t\t\tchar c = image[i][j];\n\t\t\t\t\tif (!EXIST(articles, c)) {\n\t\t\t\t\t\tarticle a;\n\t\t\t\t\t\ta.material = c;\n\t\t\t\t\t\ta.is_removed = false;\n\t\t\t\t\t\ta.topmost = 50;\n\t\t\t\t\t\ta.bottommost = 0;\n\t\t\t\t\t\ta.leftmost = 50;\n\t\t\t\t\t\ta.rightmost = 0;\n\t\t\t\t\t\tarticles[c] = a;\n\t\t\t\t\t}\n\t\t\t\t\tarticles[c].topmost = min(articles[c].topmost, i);\n\t\t\t\t\tarticles[c].bottommost = max(articles[c].bottommost, i);\n\t\t\t\t\tarticles[c].leftmost = min(articles[c].leftmost, j);\n\t\t\t\t\tarticles[c].rightmost = max(articles[c].rightmost, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (remove_all()) {\n\t\t\tcout << \"SAFE\" << endl;\n\t\t} else {\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={1,0,0,-1,1,-1,-1,1};\nconst int dy[]={0,1,-1,0,1,1,-1,-1};\nconst int INF = 1e8;\nconst double EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fr first\n#define sc second\n#define reps(i,j,k) for(int i = (j); i < (k); ++i)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> Pii;\ntypedef pair<int,vi > P;\ntypedef unsigned long long ll;\nint main(){\n    int N;\n    scanf(\"%d\",&N);\n    while(N--){\n        char stage[52][52];\n        int H,W;\n        scanf(\"%d%d\",&H,&W);\n        bool alpha_memo[128] = {false};\n        rep(i,H){\n            scanf(\"%s\",stage[i]);\n            rep(j,W){\n                alpha_memo[stage[i][j]] = true;\n            }\n        }\n        vector < char > letter;\n        map <char,int> idx;\n        reps(i,'A','Z'+1){\n            if(alpha_memo[i]){\n                letter.PB(i);\n            }\n        }\n\n        rep(i,letter.size()){\n        \tidx[letter[i]] = i;\n        }\n\n        int bit[52][52] = {{0}};\n        rep(c,letter.size()){\n            Pii rect[4];\n            rep(j,W){\n                bool f = false;\n                rep(i,H){\n                    if(stage[i][j] == letter[c]){\n                        rect[0].fr = i;\n                        rect[0].sc = j;\n                        f = true;\n                        break;\n                    }\n                }\n                if(f)break;\n            }\n            rep(j,W){\n                bool f = false;\n                for(int i = H-1; i >= 0; --i){\n                    if(stage[i][j] == letter[c]){\n                        rect[1].fr = i;\n                        rect[1].sc = j;\n                        f = true;\n                        break;\n                    }\n                }\n                if(f)break;\n            }\n            for(int j = W-1; j >= 0; --j){\n                bool f = false;\n                rep(i,H){\n                    if(stage[i][j] == letter[c]){\n                        rect[2].fr = i;\n                        rect[2].sc = j;\n                        f = true;\n                        break;\n                    }\n                }\n                if(f)break;\n            }\n            for(int j = W-1; j >= 0; --j){\n                bool f = false;\n                for(int i = H-1; i >= 0; --i){\n                    if(stage[i][j] == letter[c]){\n                        rect[3].fr = i;\n                        rect[3].sc = j;\n                        f = true;\n                        break;\n                    }\n                }\n                if(f)break;\n            }\n            reps(i,min(rect[0].fr,rect[2].fr),max(rect[1].fr,rect[3].fr)+1){\n                bool f = false;\n                reps(j,min(rect[0].sc,rect[2].sc),max(rect[1].sc,rect[3].sc)+1){\n                    bit[i][j] |= 1<<c;\n                }\n            }\n        }\n        bool ans = true;\n        rep(i,H){\n        \tbool f = false;\n        \trep(j,W){\n        \t\tif(stage[i][j] == '.'){\n        \t\t\tif(bit[i][j]){\n        \t\t\t\tf = true;\n        \t\t\t\tbreak;\n        \t\t\t}\n        \t\t}\n        \t\tif(!(bit[i][j] & ~(1<<idx[stage[i][j]]))){\n        \t\t\tbit[i][j] = bit[i][j] & ~(1<<idx[stage[i][j]]);\n        \t\t}\n        \t}\n        \tif(f){\n        \t\tans = false;\n        \t\tbreak;\n        \t}\n        }\n        if(ans){\n\t       \tset < int > memo;\n\t        rep(i,H){\n\t        \trep(j,W){\n\t        \t\tif(bit[i][j]){\n\t        \t\t\tmemo.insert(bit[i][j]);\n\t        \t\t}\n\t        \t\t//printf(\"%d\",bit[i][j]);\n\t        \t}\n\t        \t//puts(\"\");\n\t        }\n\t        int res[10]={0};\n\t        set < int > :: iterator it;\n\t        for(it = memo.begin();it != memo.end(); ++it){\n\t        \trep(i,letter.size()){\n\t        \t\tif(1&(*it>>i)){\n\t        \t\t\tres[i]++;\n\t        \t\t}\n\t        \t}\n\t        }\n\t        sort(res,res+letter.size());\n\t        if(res[0] == 2){\n\t        \tans = false;\n\t        }\n    \t}\n    \tans ? puts(\"SAFE\") : puts(\"SUSPICIOUS\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nint H, W;\nchar grid[51][51];\n\nstruct Data {\n    int id, top, left, down, right;\n    Data() {\n        id = -1;\n        top = left = -1;\n        down = right = 100;\n    }\n};\n\nbool Loop(int dst, int src, const vector<vector<int>> &g,\n          vector<bool> &visit)\n{\n    if (dst == src)\n        return true;\n\n    if (visit[src])\n        return false;\n\n    visit[src] = true;\n    for (unsigned i = 0; i < g[src].size(); ++i) {\n        if (Loop(dst, g[src][i], g, visit))\n            return true;\n    }\n\n    return false;\n}\n\nbool Solve()\n{\n    unordered_map<char, Data> hash;\n    int id = 0;\n\n    // 登録\n    for (int i = 0; i < H; ++i)\n        for (int j = 0; j < W; ++j)\n            if (grid[i][j] != '.') {\n                char c = grid[i][j];\n\n                if (hash.count(c) == 0) {  // 未登録\n                    hash[c].id = id++;\n                    hash[c].top = hash[c].down = i;\n                    hash[c].left = hash[c].right = j;\n                }\n                else { // 登録済み\n                    hash[c].top = min(hash[c].top, i);\n                    hash[c].down = max(hash[c].down, i);\n                    hash[c].left = min(hash[c].left, j);\n                    hash[c].right = max(hash[c].right, j);\n                }\n            }\n\n    vector<vector<int>> g(id, vector<int>());\n    // 長方形の確認\n    auto it = hash.begin();\n    while (it != hash.end()) {\n        for (int y = it->second.top; y <= it->second.down; ++y)\n            for (int x = it->second.left; x <= it->second.right; ++x) {\n                int src = it->second.id;\n\n                if (grid[y][x] == '.')\n                    return false;\n                else if (grid[y][x] != it->first &&\n                         count(g[src].begin(), g[src].end(),\n                               hash[grid[y][x]].id) == 0)\n                    g[src].push_back(hash[grid[y][x]].id);\n            }\n        ++it;\n    }\n\n    // ループが存在するかのチェック\n    for (unsigned i = 0; i < g.size(); ++i) {\n        vector<bool> visit(id, false);\n        visit[i] = true;\n\n        for (unsigned j = 0; j < g[i].size(); ++j)\n            if (Loop(i, g[i][j], g, visit))\n                return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    int T;\n\n    cin >> T;\n    while (T--) {\n        cin >> H >> W;\n\n        for (int i = 0; i < H; ++i)\n            for (int j = 0; j < W; ++j)\n                cin >> grid[i][j];\n\n        if (Solve())\n            cout << \"SAFE\\n\";\n        else\n            cout << \"SUSPICIOUS\\n\";\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl;\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct edge{int from, to; ll cost;};\n\nmap<char, bool> is_removed;\nint baggage_cnt = 0;\nint h,w;\nchar c = '*';\n\nbool is_rectangle(int si, int sj, int gi, int gj, string s[]){\n    c = '*';\n    reppp(i, si, gi+1){\n        reppp(j, sj, gj+1){\n            if(s[i][j] != '.' && !is_removed[s[i][j]]){\n                c = s[i][j];\n                break;\n            }\n        }\n        if(c != '*') break;\n    }\n    if(c == '*') return false;\n\n    rep(h){\n        repp(j, w){\n            if(si <= i && i <= gi && sj <= j && j <= gj){\n                if(s[i][j] != c && !is_removed[s[i][j]]){\n                    return false;\n                }\n            }else{\n                if(s[i][j] == c) return false;\n            }\n        }\n    }\n    return true;\n}\n\nstring solve(string s[]){\n    set<char> st;\n    rep(h){\n        repp(j, w){\n            if(s[i][j] != '.') st.insert(s[i][j]);\n        }\n    }\n    baggage_cnt = (int)st.size();\n\n    bool change = true;\n    while(change){\n        change = false;\n        for(int si=0;si<h;++si){\n            for(int sj=0;sj<w;++sj){\n                for(int gi=h-1;si<=gi;--gi){\n                    for(int gj=w-1;sj<=gj;--gj){\n                        if(is_rectangle(si, sj, gi, gj, s)){\n                            change = true;\n                            is_removed[c] = true;\n                            baggage_cnt--;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return (baggage_cnt?\"SUSPICIOUS\":\"SAFE\");\n}\n\nint main() {\n    int t;\n    cin >> t;\n\n    repp(tt, t){\n        cin >> h >> w;\n        string s[h];\n        rep(h) cin >> s[i];\n        is_removed.clear();\n        baggage_cnt = 0;\n        cout << solve(s) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps=1e-8;\nint d1[4] = { 0,1,0,-1 };\nint d2[4] = { 1,0,-1,0 };\nint main() {\n\tint n; cin >> n;\n\trep(loooooooooooooook, n) {\n\t\tint h, w; cin >> h >> w;\n\t\tchar bag[52][52]; int del[26] = {};\n\t\tint alf[26][2][2] = {};\n\t\trep(i, 26) {\n\t\t\talf[i][0][0] = alf[i][1][0] = max(h, w) + 1;\n\t\t\talf[i][0][1] = alf[i][1][1] = -1;\n\t\t}\n\t\tfill(del, del + 26, 1);\n\t\tstring s;\n\t\trep(i, h) {\n\t\t\tcin >> s;\n\t\t\trep(j, w) {\n\t\t\t\tbag[i][j]=s[j];\n\t\t\t\tif ('A' <= bag[i][j] && bag[i][j] <= 'Z') {\n\t\t\t\t\tdel[bag[i][j] - 'A'] = 0;\n\t\t\t\t\tint x = s[j] - 'A';\n\t\t\t\t\talf[x][0][0] = min(alf[x][0][0], i);\n\t\t\t\t\talf[x][1][0] = min(alf[x][1][0], j);\n\t\t\t\t\talf[x][0][1] = max(alf[x][0][1], i);\n\t\t\t\t\talf[x][1][1] = max(alf[x][1][1], j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool f = true;\n\t\twhile (f) {\n\t\t\tbool g = false;\n\t\t\trep(i, 26) {\n\t\t\t\tif (del[i])continue;\n\t\t\t\tbool fg=true;\n\t\t\t\tRep1(j, alf[i][0][0], alf[i][0][1]) {\n\t\t\t\t\tRep1(k, alf[i][1][0], alf[i][1][1]) {\n\t\t\t\t\t\tchar x = bag[j][k];\n\t\t\t\t\t\tif (x != 'A' + i && x != '#') {\n\t\t\t\t\t\t\tfg = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (fg) {\n\t\t\t\t\tRep1(j, alf[i][0][0], alf[i][0][1]) {\n\t\t\t\t\t\tRep1(k, alf[i][1][0], alf[i][1][1]) {\n\t\t\t\t\t\t\tbag[j][k] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdel[i] = 1; g = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!g)f = false;\n\t\t}\n\t\tf = true;\n\t\trep(i,h) {\n\t\t\trep(j, w) {\n\t\t\t\tif ('A' <= bag[i][j] && bag[i][j] <= 'Z') {\n\t\t\t\t\tf = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (f) {\n\t\t\tcout << \"SAFE\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int MAX_S = 51;\nconst int dx[4] = {1,0,-1,0};\nconst int dy[4] = {0,1,0,-1};\nconst int INF = 1<<24;\nint H, W;\nchar G[MAX_S][MAX_S];\nint vis[MAX_S][MAX_S];\nbool vis2[MAX_S][MAX_S];\n\npair<P, P> rec(int x, int y, char c, int level) {\n  vis[y][x] = level;\n  vis2[y][x] = true;\n  pair<P, P> p = make_pair(P(x, y), P(x, y));\n  for(int i = 0; i < 4; ++i) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(nx < 0 || nx >= W) continue;\n    if(ny < 0 || ny >= H) continue;\n    if(vis2[ny][nx]) continue;\n    if(G[ny][nx] != c) continue;\n    pair<P, P> q = rec(nx, ny, c, level);\n    p.first.first = min(p.first.first, q.first.first);\n    p.first.second = min(p.first.second, q.first.second);\n    p.second.first = max(p.second.first, q.second.first);\n    p.second.second = max(p.second.second, q.second.second);\n  }\n  return p;\n}\n\nbool notW(int sx, int sy, int ex, int ey, char c, int level, vector<P> &v) {\n  v.clear();\n  for(int y = sy; y <= ey; ++y) {\n    for(int x = sx; x <= ex; ++x) {\n      if(G[y][x] == '.') return false;\n      if(G[y][x] != c) {\n\tif(vis[y][x] && vis[y][x] <= level) return false;\n\tv.push_back(P(x, y));\n      }\n    }\n  }\n  return true;\n}\n\nvoid show() {\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      cout << vis[i][j];\n    }\n    cout << endl;\n  }\n}\n\nbool solve(int j, int i, int level) {\n  pair<P, P> p = rec(j, i, G[i][j], level);\n  vector<P> v;\n  if(! notW(p.first.first, p.first.second\n\t    , p.second.first, p.second.second, G[i][j], level, v)) {\n    return false;\n  }\n\n  for(int i = 0; i < v.size(); ++i) {\n    if(!vis2[v[i].second][v[i].first])\n      if(!solve(v[i].first, v[i].second, level+1)) return false;\n  }\n  return true;\n}\n\nbool ans() {\n  for(int i = 0; i < H; ++i) {\n    fill(vis2[i], vis2[i]+W, false);\n  }\n\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if(!vis2[i][j] && G[i][j] != '.') {\n\tfor(int k = 0; k < H; ++k) {\n\t  fill(vis[k], vis[k]+W, 0);\n\t}\n\tif(!solve(j, i, 1)) return false;\n      }\n    }\n  }\n  return true;\n}\n\nint main() {\n  int T;\n  cin >> T;\n  while(T--) {\n    cin >> H >> W;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tcin >> G[i][j];\n      }\n    }\n    if(ans()) cout << \"SAFE\" << endl;\n    else cout << \"SUSPICIOUS\" << endl;\n    //show();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\nint h,w;\nstring G[51];\nbool checked[51][51];\nbool visited[51][51];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\n/*\nvoid dfs(int x,int y,char c,int &x1,int &x2,int &y1,int &y2)\n{\n  if(visited[y][x])return;\n  visited[y][x] = true;\n  if(x < x1)x1 = x;\n  if(x > x2)x2 = x;\n  if(y < y1)y1 = y;\n  if(y > y2)y2 = y;\n  rep(i,4)\n    {\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(G[ny][nx] != c)continue;\n      dfs(nx,ny,c,x1,x2,y1,y2);\n    }\n}\n*/\nbool isRect(int x,int y)\n{\n  int x1,x2,y1,y2;\n  x1 = x2 = x;\n  y1 = y2 = y;\n  //rep(i,h)rep(j,w)visited[i][j] = false;\n  //dfs(x,y,G[y][x],x1,x2,y1,y2);\n  rep(i,h)\n    rep(j,w)\n    {\n      if(G[i][j] == G[y][x])\n\t{\n\t  if(j < x1)x1 = j;\n\t  if(j > x2)x2 = j;\n\t  if(i < y1)y1 = i;\n\t  if(i > y2)y2 = i;\n\t}\n    }\n\n  REP(i,y1,y2+1)\n    REP(j,x1,x2+1)\n    if(G[i][j] != G[y][x] && !checked[i][j])return false;\n  return true;\n\n}\n\nvoid draw(int x,int y,char c)\n{\n  if(checked[y][x])return;\n  checked[y][x] = true;\n  rep(i,4)\n    {\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(G[ny][nx] != c)continue;\n      draw(nx,ny,c);\n    }\n}\n\nbool isSafe()\n{\n  rep(i,h)\n    rep(j,w)\n    if(G[i][j] != '.' && !checked[i][j])return false;\n  return true;\n}\n\nint main()\n{\n  int T;\n  cin >> T;\n  while(T-- > 0)\n    {\n      cin >> h >> w;\n      rep(i,h)\n\tcin >> G[i];\n      rep(i,51)rep(j,51)checked[i][j] = false;\n\n      while(true)\n\t{\n\t  bool Fin = true;\n\t  bool update = false;\n       \n\t  rep(i,h)\n\t    {\t\n\t      rep(j,w)\n\t\t{\n\t\t  if(G[i][j] == '.')continue;\n\t\t  if(checked[i][j])continue;\n\t\t  Fin = false;\n\t\t  if(isRect(j,i))\n\t\t    {\n\t\t      update = true;\n\t\t      draw(j,i,G[i][j]);\n\t\t    }\n\t\t}\n\t    }\n\t  if(Fin || !update)break;\n\t}\n   \n      isSafe()?cout << \"SAFE\" << endl:cout << \"SUSPICIOUS\" << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define INF 1e9\n#define EPS 1e-9\n#define MOD (1e9+7)\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\n\n#define xmin first.first\n#define xmax first.second\n#define ymin second.first\n#define ymax second.second\n\nint main(){\n\tint n;\n\tcin>>n;\n\trep(datasets,n){\n\t\tmap<char,int> mp;\n\t\tmap<int,pair<pii,pii>> pt;\n\n\t\tint h,w;\n\t\tcin>>h>>w;\n\t\tmp['.']=0;\n\t\tpt[0]={{w,0},{h,0}};\n\t\tvvi f(h,vi(w));\n\t\trep(i,h)rep(j,w){\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tif(mp.find(c)==mp.end()){\n\t\t\t\tmp[c]=mp.size()-1;\n\t\t\t\tpt[mp[c]]={{w,0},{h,0}};\n\t\t\t}\n\t\t\tf[i][j]=mp[c];\n\t\t\tpt[mp[c]].xmin=min(pt[mp[c]].xmin,j);\n\t\t\tpt[mp[c]].xmax=max(pt[mp[c]].xmax,j);\n\t\t\tpt[mp[c]].ymin=min(pt[mp[c]].ymin,i);\n\t\t\tpt[mp[c]].ymax=max(pt[mp[c]].ymax,i);\n\t\t}\n\t\t\n\t\tvi perm(mp.size()-1);\n\t\tiota(all(perm),1);\n\t\tbool ok=false;\n\t\tdo{\n\t\t\tauto p=f;\n\t\t\tfor(auto key:perm){\n\t\t\t\tfor(int i=pt[key].ymin;i<=pt[key].ymax;i++){\n\t\t\t\t\tfor(int j=pt[key].xmin;j<=pt[key].xmax;j++){\n\t\t\t\t\t\tif(p[i][j]!=key and p[i][j]!=-1){\n\t\t\t\t\t\t\tgoto next;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tp[i][j]=-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tok=true;\n\t\t\tbreak;\n\t\t\tnext:;\n\t\t}while(next_permutation(all(perm)));\n\t\tif(ok){\n\t\t\tcout<<\"SAFE\"<<endl;\n\t\t}else{\n\t\t\tcout<<\"SUSPICIOUS\"<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\n#define pb push_back\n#define FOR(i, a, b) for (ll i = (signed)(a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define EREP(i, n) for (int i = (n)-1; i >= 0; --i)\n#define MOD 1000000007\n#define INF 93193111451418101\n#define MIN -93193111451418101\n#define EPS 1e-11\nusing namespace std;\n\nchar grid[51][51];\nll n, h, w;\n\nbool check(vector<ll> &v, ll lx[50], ll ly[50], ll rx[50], ll ry[50], ll c) {\n  ll itr = 0;\n  itr = find(v.begin(), v.end(), c) - v.begin();\n  FOR(i, ly[c], ry[c] + 1) {\n    FOR(j, lx[c], rx[c] + 1) {\n      if (grid[i][j] == '.')\n        return 0;\n      if (grid[i][j] != c + 'A') {\n        REP(k, (signed)v.size()) {\n          if (v[k] + 'A' == grid[i][j] && k > itr)\n            return 0;\n        }\n      }\n    }\n  }\n  return 1;\n}\n\nint main() {\n  cin >> n;\n  string str = \"\";\n  REP(loop, n) {\n    ll lx[50] = {}, ly[50] = {}, rx[50] = {}, ry[50] = {};\n    REP(i, 50) { lx[i] = 100, ly[i] = 100; }\n    vector<ll> v;\n    cin >> h >> w;\n    REP(i, h) {\n      REP(j, w) { cin >> grid[i][j]; }\n    }\n    REP(i, h) REP(j, w) {\n      const char c = grid[i][j];\n      const ll cl = grid[i][j] - 'A';\n      if (c == '.')\n        continue;\n      v.pb(cl);\n      lx[cl] = min(lx[cl], j);\n      ly[cl] = min(ly[cl], i);\n      ry[cl] = max(ry[cl], i);\n      rx[cl] = max(rx[cl], j);\n    }\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    bool ff = 0;\n    do {\n      ff = 0;\n      for (auto &a : v) {\n        if (check(v, lx, ly, rx, ry, a) == 0) {\n          ff = 1;\n          break;\n        }\n      }\n      if (!ff) {\n        printf(\"%s\\n\", \"SAFE\");\n        break;\n      }\n    } while (next_permutation(v.begin(), v.end()));\n    if (ff)\n      printf(\"%s\\n\", \"SUSPICIOUS\");\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n\n#define REP(i,n)for (int i=0;i<(n);i++)\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define ll long long\nusing namespace std;\ntypedef pair<int,int> P;\n\nint main(){\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\tint h,w;\n\t\tcin>>h>>w;\n\t\tint x1[26],x2[26],y1[26],y2[26];\n\n\t\tREP(i,26){\n\t\t\tx1[i]=w;\n\t\t\tx2[i]=-1;\n\t\t\ty1[i]=h;\n\t\t\ty2[i]=-1;\n\t\t}\n\n\t\tchar fld[h][w];\n\n\t\tREP(i,h){\n\t\t\tREP(j,w){\n\t\t\t\tcin>>fld[i][j];\n\t\t\t\tif(fld[i][j]=='.')continue;\n\t\t\t\tint a=fld[i][j]-'A';\n\t\t\t\tx1[a]=min(x1[a],j);\n\t\t\t\tx2[a]=max(x2[a],j);\n\t\t\t\ty1[a]=min(y1[a],i);\n\t\t\t\ty2[a]=max(y2[a],i);\n\t\t\t}\n\t\t}\n\n\t\tvector<int>v;\n\t\tREP(i,26)if(x1[i]!=w)v.PB(i);\n\t\tstring ans=\"SUSPICIOUS\";\n\n\t\tdo{\n\t\t\tbool f=true;\n\t\t\tchar tmp[h][w];\n\t\t\tREP(i,h)REP(j,w)tmp[i][j]='.';\n\t\t\tREP(i,v.size()){\n\t\t\t\tfor(int x=x1[v[i]];x<=x2[v[i]];x++){\n\t\t\t\t\tfor(int y=y1[v[i]];y<=y2[v[i]];y++){\n\t\t\t\t\t\ttmp[y][x]=(char)('A'+v[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(i,h)REP(j,w)if(tmp[i][j]!=fld[i][j])f=false;\n\t\t\tif(f)ans=\"SAFE\";\n\t\t}while(next_permutation(v.begin(),v.end()));\n\n\t\tcout<<ans<<endl;\n\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint main() {\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint H, W; cin >> H >> W;\n\t\tvector<string> s(H);\n\t\tfor (int i = 0; i < H; i++)\n\t\t\tcin >> s[i];\n\t\tset<char> st;\n\t\tfor (int i = 0; i < H; i++)\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t\tif (s[i][j] != '.')\n\t\t\t\t\tst.insert(s[i][j]);\n\t\tvector<char> v(st.begin(), st.end());\n\t\tfor (;;) {\n\t\t\tint k, l, r, u, d;\n\t\t\tfor (k = 0; k < v.size(); k++) {\n\t\t\t\tchar c = v[k];\n\t\t\t\tl = W; r = 0; u = H; d = 0;\n\t\t\t\tfor (int i = 0; i < H; i++)\n\t\t\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t\t\t\tif (s[i][j] == c) {\n\t\t\t\t\t\t\tl = min(l, j); r = max(r, j + 1);\n\t\t\t\t\t\t\tu = min(u, i); d = max(d, i + 1);\n\t\t\t\t\t\t}\n\t\t\t\tif (l == W) continue;\n\t\t\t\tbool rect = true;\n\t\t\t\tfor (int i = u; i < d; i++)\n\t\t\t\t\tfor (int j = l; j < r; j++)\n\t\t\t\t\t\tif (s[i][j] != c && s[i][j] != '?')\n\t\t\t\t\t\t\trect = false;\n\t\t\t\tif (rect) break;\n\t\t\t}\n\t\t\tif (k == v.size()) break;\n\t\t\tfor (int i = u; i < d; i++)\n\t\t\t\tfor (int j = l; j < r; j++)\n\t\t\t\t\ts[i][j] = '?';\n\t\t}\n\t\tbool safe = true;\n\t\tfor (int i = 0; i < H; i++)\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t\tif (s[i][j] != '.' && s[i][j] != '?')\n\t\t\t\t\tsafe = false;\n\t\tcout << (safe ? \"SAFE\" : \"SUSPICIOUS\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nint h, w;\nbool isRectangle(vector<string> &image, char target) \n{\n    int left = w, right = 0, top = h, botton = 0;\n    for(int i = 0; i < h; i++)\n    {\n        for(int j = 0; j < w; j++)\n        {\n            if(image[i][j] == target)\n            {\n                left = min(left, j);\n                right = max(right, j);\n                top = min(top, i);\n                botton = max(botton, i);\n            }\n        }\n    }\n    for(int i = top; i <= botton; i++)\n    {\n        for(int j = left; j <= right; j++)\n        {\n            if(image[i][j] == target || image[i][j] == '?') continue;\n            return false;\n        }\n    }\n    for(int i = top; i <= botton; i++)\n    {\n        for(int j = left; j <= right; j++)\n        {\n            image[i][j] = '?';\n        }\n    }\n    return true;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n; cin >> n;\n    while(n--)\n    {\n        cin >> h >> w;\n        vector<string> image(h);\n        for(int i = 0; i < h; i++) cin >> image[i];\n        while(true)\n        {\n            // for(int i = 0; i < h; i++)\n            // {\n            //     for(int j = 0; j < w; j++) cout << image[i][j]; cout << endl;\n            // }\n            bool success = false;\n            bool object = false;\n            for(int i = 0; i < h; i++)\n            {\n                for(int j = 0; j < w; j++)\n                {\n                    if(image[i][j] == '.' || image[i][j] == '?') continue;\n                    object = true;\n                    if(isRectangle(image, image[i][j]))\n                    {\n                        success = true;\n                    }\n                }\n            }\n            if(object == false)\n            {\n                cout << \"SAFE\" << endl;\n                break;\n            }\n            if(not success)\n            {\n                cout << \"SUSPICIOUS\" << endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nstruct make\n{\n\tchar str;\n\tint posi,start[2];\n\tint high,wide,JUDGE;//JUDGE==1で長方形,==0で長方形以外,==2で未定\n\tstruct make *front;\n};\n\n\nint main()\n{\n\tint N,H,W,count,COUNT,judge,no_rect,NO_RECT;\n\tchar img[1000][51],RECT[8];\n\tstruct make M[8];\n\tint s1,s2,num;\n\t\n\tscanf(\"%d\",&N);//データの個数\n\tfor(int a=0;a<N;a++)\n\t{\n\t\tcount=0;//材質の個数\n\t\tCOUNT=0;\n\t\tNO_RECT=0;\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tscanf(\"%s\",img[b]);\n\t\t\timg[b][W]='\\0';\n\t\t}\n\t\tfor(int b=0;b<H;b++)\n\t\t{\n\t\t\tfor(int d=0;d<count;d++) M[d].posi=-1;\n\t\t\tfor(int c=0;c<W;c++)\n\t\t\t{\n\t\t\t\tif(img[b][c]!='.')\n\t\t\t\t{\n\t\t\t\t\t//材質判定\n\t\t\t\t\tjudge=0;\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t\tif(count>0 && img[b][c]!=M[judge].str) judge++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}while(judge<count);\n\t\t\t\t\t//新しい材質の場合\n\t\t\t\t\tif(judge==count)\n\t\t\t\t\t{\n\t\t\t\t\t\tM[count].str=img[b][c];\n\t\t\t\t\t\tM[count].start[0]=b;\n\t\t\t\t\t\tM[count].start[1]=c;\n\t\t\t\t\t\tM[count].posi=c;\n\t\t\t\t\t\tM[count].high=1;\n\t\t\t\t\t\tM[count].wide=1;\n\t\t\t\t\t\tM[count].JUDGE=0;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\t//既出の材質の場合\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(M[judge].start[1]>c) M[judge].start[1]=c;\n\t\t\t\t\t\tif(M[judge].posi<0) M[judge].posi=c;\n\t\t\t\t\t\telse if(M[judge].wide<c-M[judge].posi+1) M[judge].wide=c-M[judge].posi+1;\n\t\t\t\t\t\tM[judge].high=b-M[judge].start[0]+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tno_rect=count;\n\t\t//printf(\"count=%d\\n\",count);\n\t\t//判定開始\n\t\twhile(count)//文字アリ\n\t\t{\n\t\t\tCOUNT=0;\n\t\t\t//見えている部分が長方形かどうか判定\n\t\t\tfor(num=0;num<count;num++)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(M[num].JUDGE==1) continue;\n\t\t\t\tM[num].JUDGE=0;//長方形なら\n\t\t\t\t//printf(\"M[%d].str=%c\\nM[%d].high=%d\\nM[%d].wide=%d\\n\",num,M[num].str,num,M[num].high,num,M[num].wide);\n\t\t\t\t//printf(\"M[%d].start[0]=%d\\nM[%d].start[1]=%d\\n\",num,M[num].start[0],num,M[num].start[1]);\n\t\t\t\tfor(s1=0;s1<M[num].high;s1++)\n\t\t\t\t{\n\t\t\t\t\tfor(s2=0;s2<M[num].wide;s2++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//確実に長方形ではない場合\n\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]=='.')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNO_RECT=1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//長方形の可能性もある場合\n\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]!=M[num].str)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int r=0;r<count-no_rect;)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(img[s1+M[num].start[0]][s2+M[num].start[1]]==RECT[r]) break;\n\t\t\t\t\t\t\t\tr++;\n\t\t\t\t\t\t\t\tif(r==count-no_rect)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tM[num].JUDGE=2;\n\t\t\t\t\t\t\t\t\tCOUNT++;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(NO_RECT || M[num].JUDGE==2) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(NO_RECT || M[num].JUDGE==2) break;\n\t\t\t\t}\n\t\t\t\tif(NO_RECT) break;\n\t\t\t\t//長方形だった場合\n\t\t\t\tif(s1==M[num].high && s2==M[num].wide)\n\t\t\t\t{\n\t\t\t\t\tM[num].JUDGE=1;\n\t\t\t\t\tno_rect--;\n\t\t\t\t\tM[num].front=NULL;\n\t\t\t\t\tRECT[num]=M[num].str;\n\t\t\t\t}\n\t\t\t\t//printf(\"M[%d].JUDGE=%d\\n\\n\",num,M[num].JUDGE);\n\t\t\t}\n\t\t\tfor(int n=0;n<num;)\n\t\t\t{\n\t\t\t\tif(M[num].JUDGE!=2 && M[num].JUDGE!=1) break;\n\t\t\t\tn++;\n\t\t\t\t//どれも長方形ではなかった場合\n\t\t\t\tif(n==num) NO_RECT=1;\n\t\t\t}\n\t\t\t\n\t\t\t//printf(\"NO_RECT=%d\\n\",NO_RECT);\n\t\t\tif(NO_RECT==1) break;\n\t\t\t//printf(\"#no_rect=%d\\n\\n\\n\",no_rect);\n\t\t\t//すべて長方形\n\t\t\tif(no_rect==0) break;\n\t\t}\n\t\t//出力\n\t\tif(NO_RECT) printf(\"SUSPICIOUS1\\n\");\n\t\telse if(no_rect) printf(\"SUSPICIOUS2\\n\");\n\t\telse printf(\"SAFE1\\n\");\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass Belongings {\npublic:\n  Belongings() : left(100),right(0),upper(100),lower(0){}\n  int left,right,upper,lower;\n};\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    for(int stage_idx = 0; stage_idx < N; stage_idx++){\n      int H,W;\n      char stage[50*50];\n      memset(stage,'.',sizeof(stage));\n      \n      scanf(\"%d %d\",&H,&W);\n      map<char,Belongings> layer;\n    \n      for(int y=0;y<H;y++){\n\tchar line[51];\n\tscanf(\"%s\",line);\n\tfor(int x=0;x<W;x++){\n\t  stage[y*W+x] = line[x];\n\t  //x:0->...\n\t  //y:0\n\t  //  |\n\t  //  v\n\t  //  .\n\t  //  upper\n\t  //left right\n\t  //  lower\n\t  char c = stage[y*W+x];\n\t  layer[c].left = min(layer[c].left,x);\n\t  layer[c].right = max(layer[c].right,x);\n\t  layer[c].upper = min(layer[c].upper,y);\n\t  layer[c].lower = max(layer[c].lower,y);\n\t}\n      }\n\n      string res = \"SUSPICIOUS\";\n    \n      vector<char> order;\n      for(map<char,Belongings>::iterator it = layer.begin();\n\t  it != layer.end();\n\t  it++){\n\torder.push_back(it->first);\n      }\n      sort(order.begin(),order.end());\n      char hypothesis[50*50];\n\n      do{\n\tmemset(hypothesis,'.',sizeof(hypothesis));\n\n\tfor(int i=0;i<order.size();i++){\n\t  int c = order[i];\n\t  Belongings& it = layer[c];\n\t  for(int y=it.upper; y<=it.lower; y++){\n\t    for(int x=it.left; x<=it.right; x++){\n\t      hypothesis[y*W+x] = c;\n\t    }\n\t  }\n\t}\n\n\tif(strcmp(hypothesis,stage) == 0){\n\t  res = \"SAFE\";\n\t  break;\n\t}\n      }while(next_permutation(order.begin(),order.end()));\n      cout << res << \"\\n\";\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 1010\n\nbool solve(){\n  int h,w;\n  char c[SIZE][SIZE];\n  string s;\n  bool f[26] = {};\n  \n  scanf(\"%d%d\",&h,&w);\n\n  if(h == 0) return false;\n\n  for(int i=0;i<h;i++){\n    scanf(\"%s\",c[i]);\n\n    for(int j=0;j<w;j++){\n      if(f[c[i][j]-'A'] == false){\n        f[c[i][j]-'A'] = true;\n        s += c[i][j];\n      }\n    }\n  }\n\n  sort(s.begin(),s.end());\n  \n  do{\n    char copy_c[SIZE][SIZE];\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        copy_c[i][j] = c[i][j];\n      }\n    }\n\n    bool check = true;\n\n    for(int p=0;p<s.size();p++){\n      int min_h = INF, max_h = -1 ,min_w = INF,max_w = -1;\n      \n      for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n          if(copy_c[i][j] == s[p]){\n            min_h = min(min_h, i);\n            max_h = max(max_h, i);\n            min_w = min(min_w, j);\n            max_w = max(max_w, j);\n          }\n        }\n      }\n\n      for(int i=min_h;i<=max_h;i++){\n        for(int j=min_w;j<=max_w;j++){\n          if(copy_c[i][j] != s[p] && copy_c[i][j] != '#')\n            check = false;\n          copy_c[i][j] = '#';\n        }\n      }\n      \n    }\n\n    if(check){\n      puts(\"SAFE\");\n      return true;\n    }\n    \n  }while(next_permutation(s.begin(),s.end()));\n  \n  puts(\"SUSPICIOUS\");\n  return true;\n\n}\n\nint main(){\n  int t;\n\n  scanf(\"%d\",&t);\n  \n  while(t--) solve();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\n#include<vector>\n\nusing namespace std;\n\n\nint main(void){\n\n  int n;\n  int h,w;\n  char screen[50][50];\n\n  int item[26][5]; //A~Z //min_x,min_y,max_x,max_y\n  //char layer[7];\n  //vector<list<int>> obj(26);\n  int layer[26][26];\n\n  cin>>n;\n  //cout << n << endl;\n\n  for(int i=0;i<n;i++){\n    cin>>h;\n    //cout << \"h:\"<<h << endl;\n    cin>>w;\n    //cout << \"w:\"<<w << endl;\n\n    for(int j=0;j<50;j++){\n      for(int k=0;k<50;k++){\n        screen[j][k]=0;\n      }\n    }\n\n    for(int j=0;j<26;j++){\n      item[j][0]=0;\n    }\n\n    for(int j=0;j<26;j++){\n      for(int k=0;k<26;k++){\n        layer[j][k]=0;\n      }\n    }\n\n    for(int j=0;j<h;j++){\n      for(int k=0;k<w;k++){\n        cin>>screen[j][k];\n      }\n    }\n\n\n    for(int j=0;j<h;j++){\n      for(int k=0;k<w;k++){\n        //cout<<screen[j][k];\n      }\n      //cout << endl;\n    }\n    //cout << endl;\n\n    for(int j=0;j<h;j++){\n      for(int k=0;k<w;k++){\n        if(screen[j][k]>='A' && screen[j][k]<= 'Z'){\n          if(item[screen[j][k]-'A'][0]==0){\n            item[screen[j][k]-'A'][0]=1;\n            item[screen[j][k]-'A'][1]=k;//min_x\n            item[screen[j][k]-'A'][2]=j;//min_y\n            item[screen[j][k]-'A'][3]=k;//max_x\n            item[screen[j][k]-'A'][4]=j;//max_y\n          }\n          else if(item[screen[j][k]-'A'][0]==1){\n            if(k<item[screen[j][k]-'A'][1]) item[screen[j][k]-'A'][1]=k;//min_x\n            if(j<item[screen[j][k]-'A'][2]) item[screen[j][k]-'A'][2]=j;//min_y\n            if(k>item[screen[j][k]-'A'][3]) item[screen[j][k]-'A'][3]=k;//max_x\n            if(j>item[screen[j][k]-'A'][4]) item[screen[j][k]-'A'][4]=j;//max_y\n          }\n        }\n      }\n    }\n\n    for(int j=0;j<26;j++){\n      if(item[j][0]==1){\n        //cout<<(char)(j+'A')<<\":\"<<endl;\n        //cout<<\"(min_x,min_y)=(\" <<item[j][1] << \",\" <<item[j][2]  << \")\" << endl;\n        //cout<<\"(max_x,max_y)=(\" <<item[j][3] << \",\" <<item[j][4]  << \")\" << endl;\n\n        int min_x=item[j][1];\n        int min_y=item[j][2];\n        int max_x=item[j][3];\n        int max_y=item[j][4];\n\n\n        for(int cnt1=min_y;cnt1<=max_y;cnt1++){\n          for(int cnt2=min_x;cnt2<=max_x;cnt2++){\n            //cout << cnt2 << \",\" << cnt1 << endl;\n            if(screen[cnt1][cnt2] != j+'A' ){\n              //cout << (char)(j+'A');\n              //cout << screen[cnt1][cnt2];\n\n              if(screen[cnt1][cnt2] >= 'A' && screen[cnt1][cnt2] <= 'Z'){\n\n                int upper_c = screen[cnt1][cnt2]-'A';\n                //cout << (char) (upper_c+'A') << endl;\n                //cout << j << endl;\n                if(layer[j][upper_c] == -1){\n                  //cout << \"SUSPICIOUS1\" << endl;\n                  goto SUS;\n                }\n                else{\n                  if(layer[j][upper_c] == -1){\n                    //cout << \"SUSPICIOUS2\" << endl;\n                    goto SUS;\n                  }\n                  else{\n                    layer[j][upper_c] = 1;\n                    //cout << \"added!\" << endl;\n                  }\n                  for(int cnt3=0;cnt3<26;cnt3++){\n                    if(layer[upper_c][cnt3]==1){\n                      layer[j][cnt3]=layer[upper_c][cnt3];\n                    }\n                  }\n                }\n                for(int cnt3=0;cnt3<26;cnt3++){\n                  for(int cnt4=0;cnt4<26;cnt4++){\n                    if(layer[cnt3][cnt4]*layer[cnt4][cnt3] == 1 ){\n                      //cout << \"SUSPICIOUS3\" << endl;\n                      goto SUS;\n                    }\n                    else{\n                      if(layer[cnt4][cnt3]!=0){\n                        layer[cnt3][cnt4] = layer[cnt4][cnt3]*-1;\n                      }\n                    }\n                  }\n                }\n\n                for(int cnt3=0;cnt3<26;cnt3++){\n                  for(int cnt4=0;cnt4<26;cnt4++){\n                      //cout << layer[cnt3][cnt4] << \" \";\n                  }\n                  //cout << endl;\n                }\n\n              }\n\n              else{\n                //cout << \"SUSPICIOUS4\" << endl;\n                goto SUS;\n                break;\n              }\n            }\n          }\n        }\n        //cout << endl;\n      }\n    }\n    //cout << \"This is Safe\" << endl;\n    cout << \"SAFE\" << endl;\n    continue;\n    SUS:\n      //cout << \"This is SUSPICIOUS!\" << endl;\n      cout << \"SUSPICIOUS\" << endl;\n\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass Belongings {\npublic:\n  Belongings() : left(100),right(0),upper(100),lower(0){}\n  int left,right,upper,lower;\n};\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    for(int stage_idx = 0; stage_idx < N; stage_idx++){\n      int H,W;\n      \n      scanf(\"%d %d\",&H,&W);\n      char* stage = new char[W*H];\n      char* hypothesis = new char[W*H];\n      memset(stage,'.',sizeof(stage));\n\n      map<char,Belongings> layer;\n    \n      for(int y=0;y<H;y++){\n\tchar line[51];\n\tscanf(\"%s\",line);\n\tfor(int x=0;x<W;x++){\n\t  stage[y*W+x] = line[x];\n\t  //x:0->...\n\t  //y:0\n\t  //  |\n\t  //  v\n\t  //  .\n\t  //  upper\n\t  //left right\n\t  //  lower\n\t  Belongings& it = layer[stage[y*W+x]];\n\t  it.left = min(it.left,x);\n\t  it.right = max(it.right,x);\n\t  it.upper = min(it.upper,y);\n\t  it.lower = max(it.lower,y);\n\t}\n      }\n\n      bool is_safe = false;\n\n      vector<char> order;\n      for(map<char,Belongings>::iterator it = layer.begin();\n\t  it != layer.end();\n\t  it++){\n\torder.push_back(it->first);\n      }\n      sort(order.begin(),order.end());\n\n\n      do{\n\tmemset(hypothesis,'.',sizeof(hypothesis));\n\n\tfor(int i=0;i<order.size();i++){\n\t  int c = order[i];\n\t  Belongings& it = layer[c];\n\t  for(int y=it.upper; y<=it.lower; y++){\n\t    for(int x=it.left; x<=it.right; x++){\n\t      hypothesis[y*W+x] = c;\n\t    }\n\t  }\n\t}\n\n\tif(strcmp(hypothesis,stage) == 0){\n\t  is_safe = true;\n\t  break;\n\t}\n      }while(next_permutation(order.begin(),order.end()));\n      printf(\"%s\\n\",is_safe ? \"SAFE\" : \"SUSPICIOUS\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nint main()\n{\n    int n;\n    cin >> n;\n    while (n--) {\n        int h, w; cin >> h >> w;\n        vector<string> B(h);\n        loop (h, i) cin >> B[i];\n\n        unordered_set<char> alphs;\n        loop (h, i) loop (w, j) {\n            char c = B[i][j];\n            if (c != '.') alphs.insert(c);\n        }\n        vector<char> perm(all(alphs));\n        sort(all(perm));\n        int safe = 0;\n        do {\n            map<char, int> layer = {{ '.', 0 }};\n            loop (perm.size(), i) layer[perm[i]] = i+1;\n\n            for (char c : perm) {\n                int l = 100, r = 0, t = 100, b = 0;\n                loop (h, i) loop (w, j) if (B[i][j] == c) {\n                    l = min(j, l);\n                    r = max(j, r);\n                    t = min(i, t);\n                    b = max(i, b);\n                }\n                for (int i = t; i <= b; i++) {\n                    for (int j = l; j <= r; j++) {\n                        if (layer[B[i][j]] < layer[c]) goto NG;\n                    }\n                }\n            }\n            safe = 1;\n            break;\nNG:\n            continue;\n        } while (next_permutation(all(perm)));\n        if (safe) cout << \"SAFE\" << endl;\n        else cout << \"SUSPICIOUS\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint H, W;\n\nint g[27][27];\n\nbool solve(vector<string> s){\n\tfor(char c='A';c<='Z';c++){\n\t\tint x1=W,x2=-1,y1=H,y2=-1;\n\t\tREP(y, H)REP(x, W) if(s[y][x] == c){\n\t\t\tchmin(x1, x);\n\t\t\tchmin(y1, y);\n\t\t\tchmax(x2, x);\n\t\t\tchmax(y2, y);\n\t\t}\n\t\tif(x2 == -1) continue;\n\t\tfor(int y=y1;y<=y2;y++)for(int x=x1;x<=x2;x++){\n\t\t\tif(s[y][x] == '.') return true;\n\t\t\tif(s[y][x] != c) g[c-'A'][s[y][x]-'A'] = 1;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nbool check(){\n\tint n =27;\n\tREP(k, n)REP(i, n)REP(j, n) g[i][j] |= g[i][k] & g[k][j];\n\tREP(i, n) if(g[i][i]) return true;\n\treturn false;\n}\n\nmain(){\n\tint n;\n\tcin >> n;\n\twhile(n --){\n\t\tmemset(g, 0, sizeof(g));\n\t\tcin >> H >> W;\n\t\tvector<string> s(H);\n\t\tREP(i, H) cin >> s[i];\n\t\tcout << (solve(s) || check() ? \"SUSPICIOUS\" : \"SAFE\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#define rep(i,j) for(int i=0;i<j;i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define ms(i,j) memset(i,j,sizeof(i))\nusing namespace std;\nint n,h,w;\nchar m[50][51];\nint main(){\n    scanf(\"%d\",&n);\n    while(n--){\n        scanf(\"%d%d\",&h,&w);\n        bool a=true;\n            int t[26],l[26],r[26]={0},b[26]={0};\n            rep(i,26)t[i]=l[i]=55;\n            bool f[26][26];\n            ms(f,0);\n        rep(i,h){\n            scanf(\"%s\",m[i]);\n            rep(j,w)if(m[i][j]!='.'){\n                char c=m[i][j]-'A';\n                f[c][c]=true;\n                t[c]=min(t[c],i);\n                l[c]=min(l[c],j);\n                r[c]=max(r[c],j);\n                b[c]=max(b[c],i);\n            }\n        }\n        bool rf=false;\n        bool hoge=true;\n        rep(i,26)if(f[i][i]){\n            hoge=false;\n            reps(j,t[i],b[i])reps(k,l[i],r[i]){\n                if(m[j][k]!=i+'A'){\n                    if(m[j][k]=='.')a=false;\n                    else f[i][m[j][k]-'A']=true;\n                }\n            }\n            int cnt=0;\n            rep(j,26)cnt+=f[i][j];\n            if(cnt==1)rf=true;\n            //printf(\"%c %d %d %d %d %d\\n\",i+'A',t[i],l[i],r[i],b[i],cnt);\n        }\n\n        puts(a&&(rf||hoge)?\"SAFE\":\"SUSPICIOUS\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define fi first\n#define se second\n#define mk make_pair\nusing namespace std;\nmap<int,pair<int,int> >max_p,min_p;\nmap<char,int>mc;\nint h,w,c,vis[101];\nstring s[51];\ninline void mae(){\n  r(i,h)r(j,w)\n   if(s[i][j]=='.')s[i][j]='0';\n   else{\n    if(mc[s[i][j]])s[i][j]=mc[s[i][j]];\n    else{\n      mc[s[i][j]]=(c++)+'0';\n      s[i][j]=(c-1)+'0';\n    }\n   }\n}\ninline void in(){\n  for(int k=1;k<c;k++){\n    int px=0,py=0,mx=1000,my=1000;\n    r(i,h)r(j,w)\n      if(s[i][j]-'0'==k){\n        px=max(px,j);\n        py=max(py,i);\n        mx=min(mx,j);\n        my=min(my,i);\n      }\n    max_p[k]=mk(px,py);\n    min_p[k]=mk(mx,my);\n  }\n}\ninline bool dfs(int d,int x){\n  if(d){\n    pair<int,int>p1=min_p[x],p2=max_p[x];\n    for(int i=p1.se;i<=p2.se;i++)\n      for(int j=p1.fi;j<=p2.fi;j++)\n        if(!vis[s[i][j]-'0'])return 0;\n  }\n  if(d==c-1)return 1;\n  for(int i=1;i<c;i++)\n    if(!vis[i]){\n      vis[i]=1;\n      if(dfs(d+1,i))return 1;\n      vis[i]=0;\n    }\n  return 0;\n}\nint main(){\n  int n;\n  cin>>n;\n  while(n--){\n    memset(vis,0,sizeof(vis));\n    max_p.clear();\n    min_p.clear();\n    mc.clear();c=1;\n    cin>>h>>w;\n    r(i,h)cin>>s[i];\n    mae();in();\n    if(dfs(0,0))cout<<\"SAFE\"<<endl;\n    else cout<<\"SUSPICIOUS\"<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\n\nint main() {\n  cin.tie(nullptr); ios_base::sync_with_stdio(false);\n  int q; cin >> q;\n  while (q--) {\n    int h, w; cin >> h >> w;\n    V<string> s(h);\n    for (auto&& e : s) cin >> e;\n    V<> idx;\n    for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) {\n      if (s[i][j] != '.') {\n        idx.push_back(s[i][j] - 'A');\n      }\n    }\n    sort(begin(idx), end(idx));\n    idx.erase(unique(begin(idx), end(idx)), end(idx));\n    int n = idx.size();\n    V<> il(26, h), ir(26, -1), jl(26, w), jr(26, -1);\n    for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) if (s[i][j] != '.') {\n      int x = s[i][j] - 'A';\n      il[x] = min(il[x], i);\n      ir[x] = max(ir[x], i);\n      jl[x] = min(jl[x], j);\n      jr[x] = max(jr[x], j);\n    }\n    bool safe = [&] {\n      do {\n        V<string> t(h, string(w, '.'));\n        for (int k = 0; k < n; ++k) {\n          for (int i = il[idx[k]]; i <= ir[idx[k]]; ++i) for (int j = jl[idx[k]]; j <= jr[idx[k]]; ++j) {\n            t[i][j] = 'A' + idx[k];\n          }\n        }\n        if (s == t) return true;\n      } while (next_permutation(begin(idx), end(idx)));\n      return false;\n    }();\n    cout << (safe ? \"SAFE\\n\" : \"SUSPICIOUS\\n\");\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<set>\n#include<map>\n#include<string>\n#include<cctype>\n\n#define N 64\nusing namespace std;\n\nbool isrectangle(char c, map<char,int> &s,\n\t\t char M[][N], int mini, int maxi, int minj, int maxj)\n{\n  for(int i = mini; i <= maxi; ++i){\n    for(int j = minj; j <= maxj; ++j){\n      if( !isalpha(M[i][j]) ) return false;\n      if( s[c] < s[M[i][j]] ) return false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  int T;\n  cin >> T;\n  for(int tc=1;tc<=T;++tc){\n    int h,w;\n    bool suspicious=true;\n    map<char,int> s;\n    char M[N][N];\n    cin >> h >> w;\n\n    for(int i = 0; i < h; ++i){\n      for(int j = 0; j < w; ++j){\n\tcin >> M[i][j];\n\tif(isalpha(M[i][j])){\n\t  s[M[i][j]]=0;\n\t}\n      }\n    }\n    if( s.size() == 0 ) suspicious = false;\n\n    for(int bit = 0; bit < (1<<s.size()); ++bit){\n      for(int item = 0; item < s.size(); ++item){\n\tif(bit&(1<<item))continue;\n\tbool ok=true;\n\tmap<char,int>::iterator its = s.begin();\n\tfor(int i = 0; i < s.size(); ++i){\n\t  if(i!=item){\n\t    its->second = (bit&(1<<i))?-1:1;\n\t  }else{\n\t    its->second = 0;\n\t  }\n\t  ++its;\n\t}\n\tfor(its = s.begin(); its != s.end(); ++its){\n\t  int mini=N,maxi=-1,minj=N,maxj=-1;\n\t  for(int i = 0; i < h; ++i){\n\t    for(int j = 0; j < w; ++j){\n\t      if( M[i][j] == its->first ){\n\t\tmini = min( mini, i );\n\t\tmaxi = max( maxi, i );\n\t\tminj = min( minj, j );\n\t\tmaxj = max( maxj, j );\n\t      }\n\t    }\n\t  }\n\t  if( !isrectangle( its->first, s, M, mini, maxi, minj, maxj ) ){\n\t    ok=false;\n\t  }\n\t}\n\tif(ok){\n\t  suspicious = false;\n\t}\n      }\n    }\n\n    if( suspicious ){\n      cout << \"SUSPICIOUS\";\n    }else{\n      cout << \"SAFE\";\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvoid solve(){\n\n\tstring strs[] = { \"SAFE\", \"SUSPICIOUS\" };\n\n\tint h, w;\n\tcin >> h >> w;\n\n\tvector< string > screen( h );\n\tvector< bool > flg( 26, false );\n\n\tfor( int i = 0; i < h; i++ )\n\t\tcin >> screen[ i ];\n\t\n\tbool fig = true;\n\n\twhile( fig ) {\n\n\t\tfig = false;\n\n\t\tfor( int x = 0; x < w; x++ ) {\n\t\t\tfor( int y = 0; y < h; y++ ) {\n\t\t\t\tchar ch = screen[ y ][ x ];\n\n\t\t\t\tif( ch == '.' || ch == '*' ) continue;\n\t\t\t\tif( flg[ ch - 'A' ] ) continue;\n\n\t\t\t\tint stx = w, sty = h, edx = -1, edy = -1;\n\t\t\t\tfor( int tx = 0; tx < w; tx ++ ) {\n\t\t\t\t\tfor( int ty = 0; ty < h; ty ++ ) {\n\t\t\t\t\t\tif( screen[ty][tx] != ch ) continue;\n\t\t\t\t\t\tstx = min( stx, tx );\n\t\t\t\t\t\tsty = min( sty, ty );\n\t\t\t\t\t\tedx = max( edx, tx );\n\t\t\t\t\t\tedy = max( edy, ty );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbool fillflg = true;\n\t\t\t\tfor( int tx = stx; tx <= edx && fillflg; tx ++ ) {\n\t\t\t\t\tfor( int ty = sty; ty <= edy && fillflg; ty ++ ) {\n\t\t\t\t\t\tfillflg &= ( screen[ ty ][ tx ] == ch || screen[ ty ][ tx ] == '*' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfig |= fillflg;\n\t\t\t\tif( fillflg ) {\n\t\t\t\t\tflg[ ch - 'A' ] = true;\n\t\t\t\t\tfor( int tx = stx; tx <= edx; tx ++ ) {\n\t\t\t\t\t\tfor( int ty = sty; ty <= edy; ty ++ ) {\n\t\t\t\t\t\t\tscreen[ ty ][ tx ] = '*';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool b = false;\n\tfor( int x = 0; x < w; x++ ) {\n\t\tfor( int y = 0; y < h; y++ ) {\n\t\t\tb |= ( screen[ y ][ x ] != '.' && screen[ y ][ x ] != '*' );\n\t\t}\n\t}\n\tcout << strs[ b ] << endl;\n}\n\nint main( void ) {\n\n\tint n;\n\tcin >> n;\n\n\tfor( int i = 0; i < n; i++ )\n\t\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(ll i = 0; i < ll(n); ++i)\n#define FOR(i,a,b) for(ll i = (a); i <= ll(b); ++i)\n#define ROF(i,a,b) for(ll i = (a)-1; i >= ll(b); --i) \n#define all(a) (a).begin(),(a).end()\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef vector<ll> vi;\nconst ll inf = 1ll<<10;\n\nstruct info{\n  char c;\n  ll minx,miny,maxx,maxy,count;\n\n  info():minx(inf),miny(inf),maxx(0),maxy(0),count(0){}\n\n  ll size(){\n    return (maxx - minx + 1) * (maxy - miny + 1);\n  }\n\n  bool isin(ll x,ll y){\n    bool res = false;\n    if(minx <= x and x <= maxx and miny <= y and y <= maxy) res = true;\n    return res;\n  }\n};\n\nmain(){\n  ll n; cin >> n;\n  ll h,w;\n  rep(l,n){\n    cin >> h >> w;\n    vector<info> alpha(26);\n    rep(i,26) alpha[i].c = 'A' + i;\n    vector<string> xray(h); rep(i,h) cin >> xray[i];\n    rep(i,h) rep(j,w){\n      if(isalpha(xray[i][j])){\n\talpha[ xray[i][j] - 'A' ].minx = min(i, alpha[ xray[i][j] - 'A' ].minx);\n\talpha[ xray[i][j] - 'A' ].miny = min(j, alpha[ xray[i][j] - 'A' ].miny);\n\talpha[ xray[i][j] - 'A' ].maxx = max(i, alpha[ xray[i][j] - 'A' ].maxx);\n\talpha[ xray[i][j] - 'A' ].maxy = max(j, alpha[ xray[i][j] - 'A' ].maxy);\n\talpha[ xray[i][j] - 'A' ].count++;\n      }\n    }\n    //rep(i,26) cout << alpha[i].size() << endl;\n    ROF(i,26,0){\n      if(alpha[i].count == 0) alpha.erase(alpha.begin() + i);\n    }\n    ll prevsz;\n    do{\n      prevsz = alpha.size();\n      rep(k,alpha.size()){\n\tif(alpha[k].size() == alpha[k].count){ // 長方形\n\n\t  // 領域内の各文字について\n\t  FOR(i,alpha[k].minx,alpha[k].maxx){\n\t    FOR(j,alpha[k].miny,alpha[k].maxy){\n\t      if(xray[i][j] == alpha[k].c){ // 消したい文字なら\n\t\trep(m,alpha.size()){ // 所属する文字のcount++\n\t\t  if(alpha[m].isin(i,j)) alpha[m].count++;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t  alpha.erase(alpha.begin() + k);\n\t  break;\n\t}\n      }\t  \n    }while(prevsz != alpha.size());\n\n    if(alpha.size())\n      cout << \"SUSPICIOUS\\n\";\n    else\n      cout << \"SAFE\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint c[26][26],d[26];\nint fn(int p){\n  int i;\n  if(d[p]){\n    return 1;\n  }else{\n    d[p]=-1;\n    for(i=0;i<26;i++){\n      if(c[p][i]){\n\tif(fn(i))\n\t  return 1;\n      }\n    }\n    d[p]=0;\n    return 0;\n  }\n}\nint main(){\n  int i,j,k;\n  int n;\n  cin>>n;\n  for(k=0;k<n;k++){//\n    int w,h;\n    cin>>w>>h;\n    char a[50][50];\n    map<char,pair<pair<int,int>,pair<int,int> > > b;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tcin>>a[i][j];\n\tif(a[i][j]!='.'){\n\t  if(b.count(a[i][j])){\n\t    b[a[i][j]].first.first=min(b[a[i][j]].first.first,j);\n\t    b[a[i][j]].first.second=min(b[a[i][j]].first.second,i);\n\t    b[a[i][j]].second.first=max(b[a[i][j]].second.first,j);\n\t    b[a[i][j]].second.second=max(b[a[i][j]].second.second,i);\n\t  }else{\n\t    b[a[i][j]].first.first=j;\n\t    b[a[i][j]].first.second=i;\n\t    b[a[i][j]].second.first=j;\n\t    b[a[i][j]].second.second=i;\n\t  }\n\t}\n      }\n    }\n    memset(c,0,sizeof(c));\n    map<char,pair<pair<int,int>,pair<int,int> > >::iterator it;\n    for(it=b.begin();it!=b.end();it++){\n      for(i=(*it).second.first.second;i<=(*it).second.second.second;i++){\n\tfor(j=(*it).second.first.first;j<=(*it).second.second.first;j++){\n\t  if(0){\n\t  }else if(a[i][j]=='.'){\n\t    break;\n\t  }else if(a[i][j]!=(*it).first){\n\t    c[a[i][j]-'A'][(*it).first-'A']=-1;\n\t  }\n\t}\n\tif(j<=(*it).second.second.first)\n\t  break;\n      }\n      if(i<=(*it).second.second.second)\n\tbreak;\n    }\n    if(it!=b.end()){\n      cout<<\"SUSPICIOUS\"<<endl;\n    }else{\n      map<char,pair<pair<int,int>,pair<int,int> > >::iterator it;\n      for(it=b.begin();it!=b.end();it++){\n\tmemset(d,0,sizeof(d));\n\tif(fn((*it).first-'A'))\n\t  break;\n      }\n      if(it!=b.end())\n\tcout<<\"SUSPICIOUS\"<<endl;\n      else\n\tcout<<\"SAFE\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool issquare(vector<string> m, vector<char> &c, int k){\n\tif(k >= c.size()){\n\t\treturn true;\n\t}\n\tint n = (int)c.size();\n\tint h = (int)m.size();\n\tint w = (int)m[0].size();\n\tint r = 0, l = w, u = h, d = 0;\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tif(m[i][j] == c[k]){\n\t\t\t\tr = max(r, j);\n\t\t\t\tl = min(l, j);\n\t\t\t\tu = min(u, i);\n\t\t\t\td = max(d, i);\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"(%d, %d), (%d, %d)\\n\",r,l,u,d);\n\tbool flag = true;\n\tfor(int i = u; i <= d; i++){\n\t\tfor(int j = l; j <= r; j++){\n\t\t\tif(m[i][j] != '?' && m[i][j] != c[k]){\n\t\t\t\tflag = false;\n\t\t\t\ti = j = (int)1e9;\n\t\t\t}\n\t\t}\n\t}\n\tif(!flag)return false;\n\tfor(int i = u; i <= d; i++){\n\t\tfor(int j = l; j <= r; j++){\n\t\t\tif(m[i][j] == c[k]){\n\t\t\t\tm[i][j] = '?';\n\t\t\t}\n\t\t}\n\t}\n\treturn issquare(m, c, k+1);\n}\n\n\n\n\nint main(){\n\tint nn; cin >> nn;\n\tfor(int z = 0; z < nn; z++){\n\t\tint h,w; cin >> h >> w;\n\t\tvector<string> m(h);\n\t\tvector<char> c;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tcin >> m[i];\n\t\t}\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(m[i][j] == '.')continue;\n\t\t\t\tbool flag1 = true;\n\t\t\t\tfor(int k = 0; k < c.size(); k++){\n\t\t\t\t\tif(m[i][j] == c[k]){\n\t\t\t\t\t\tflag1 = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag1)c.push_back(m[i][j]);\n\t\t\t}\n\t\t}\n\t\tsort(c.begin(), c.end());/*\n\t\tfor(int i = 0; i < c.size(); i++){\n\t\t\tcout << c[i] << \" \";\n\t\t}\n\t\tcout << endl;*/\n\t\tbool flag = false;\n\t\tdo{\n\t\t\tif(issquare(m, c, 0)){\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}while(next_permutation(c.begin(), c.end()));\n\t\tif(flag){\n\t\t\tcout << \"SAFE\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\n\nint main(int argc, char *argv[]){\n  int n, w, h;\n  pair<int, int> p[8][4];\n  cin >> n;\n  for (int r = 0; r < n; r++) {\n    map<char, int> matrial;\n    cin >> h >> w;\n\n    char grid[h][w];\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> grid[i][j];\n        if(grid[i][j] != '.' && matrial.find(grid[i][j]) == matrial.end()){\n          matrial[grid[i][j]] = matrial.size();\n        }\n      }\n    }\n\n    for (int i = 0; i < matrial.size(); i++) {\n      p[i][0].first = 1e9, p[i][0].second = 1e9;\n      p[i][1].first = 0,   p[i][1].second = 0;\n    }\n    vector<int> perm(matrial.size());\n    for (int i = 0; i < matrial.size(); i++) {\n      perm[i] = i;\n    }\n\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if(matrial.find(grid[i][j]) != matrial.end()){\n          int minx = p[matrial[grid[i][j]]][0].first;\n          int miny = p[matrial[grid[i][j]]][0].second;\n          int maxx = p[matrial[grid[i][j]]][1].first;\n          int maxy = p[matrial[grid[i][j]]][1].second;\n          p[matrial[grid[i][j]]][0].first  = min(minx, j);\n          p[matrial[grid[i][j]]][0].second = min(miny, i);\n          p[matrial[grid[i][j]]][1].first  = max(maxx, j);\n          p[matrial[grid[i][j]]][1].second = max(maxy, i);\n        }\n      }\n    }\n    // for (auto &a: matrial){\n    //   std::cout << a.first << \" \" << a.second << std::endl;\n    // }\n    // for (int i = 0; i < matrial.size(); i++) {\n    //   std::cout << \"min:\" << std::endl;\n    //   std::cout << p[i][0].first << \" \" << p[i][0].second << std::endl;\n    //   std::cout << \"max:\" << std::endl;\n    //   std::cout << p[i][1].first << \" \" << p[i][1].second << std::endl;\n    // }\n    // std::cout << matrial.size() << std::endl;\n    \n     bool flag = false;\n    do{\n      for (int i = 0; i < matrial.size(); i++) {\n        for (int j = p[i][0].second; j <= p[i][1].second; j++) {\n          for (int k = p[i][0].first; k <= p[i][1].first; k++) {\n            //std::cout << grid[j][k];            \n            if(grid[j][k] != '.' && perm[matrial[grid[j][k]]] <= perm[i])continue;\n            i = 10;\n            j = p[i][1].second + 1;\n            k = p[i][1].first  + 1;\n          }\n        }\n        if(i == matrial.size() - 1){\n          flag = true;\n        //   for (auto &a: perm) {\n        //     std::cout << a << \" \";\n        //   }\n        //   std::cout << std::endl;\n        }\n      }\n    }while(next_permutation(perm.begin(), perm.end()));\n    if(flag || matrial.size() == 0){\n      std::cout << \"SAFE\" << std::endl;\n    }else{\n      std::cout << \"SUSPICIOUS\" << std::endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  \n  int t;\n  cin >> t;\n  \n  while (t--) {\n    int h, w;\n    cin >> h >> w;\n    vector<vector<char>> x(h, vector<char>(w));\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> x.at(i).at(j);\n      }\n    }\n    \n    vector<vector<int>> y(26, vector<int>(4));\n    for (int i = 0; i < 26; i++) {\n      y.at(i).at(0) = y.at(i).at(2) = 50;\n      y.at(i).at(1) = y.at(i).at(3) = -1;\n    }\n    \n   for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if (x.at(i).at(j) == '.') continue;\n        int keep = x.at(i).at(j) - 'A';\n        y.at(keep).at(0) = min(y.at(keep).at(0), i);\n        y.at(keep).at(1) = max(y.at(keep).at(1), i);\n        y.at(keep).at(2) = min(y.at(keep).at(2), j);\n        y.at(keep).at(3) = max(y.at(keep).at(3), j);\n      }\n    }\n    \n    vector<bool> z(26, false);\n    while (true) {\n      bool flag = false;\n      for (int k = 0; k < 26; k++) {\n        if (z.at(k)) continue;\n        if (y.at(k).at(0) <= y.at(k).at(1)) {\n          bool flag2 = true;\n          for (int i = y.at(k).at(0); i <= y.at(k).at(1); i++) {\n            for (int j = y.at(k).at(2); j <= y.at(k).at(3); j++) {\n              if (x.at(i).at(j) != (char) (k + 'A') && x.at(i).at(j) != '#') flag2 = false;\n            }\n          }\n          if (flag2) {\n            flag = true;\n            z.at(k) = true;\n            for (int i = y.at(k).at(0); i <= y.at(k).at(1); i++) {\n              for (int j = y.at(k).at(2); j <= y.at(k).at(3); j++) {\n                x.at(i).at(j) = '#';\n              }\n            }\n          }\n        }\n      }\n      if (!flag) break;\n    }\n    \n    bool flag3 = true;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if (x.at(i).at(j) != '.' && x.at(i).at(j) != '#') flag3 = false;\n      }\n    }\n    \n    if (flag3) cout << \"SAFE\\n\";\n    else cout << \"SUSPICIOUS\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        char board[50][50];\n        int num[26] = {0};\n        int h, w;\n        cin >> h >> w;\n        for (int j = 0; j < h; ++j) {\n            scanf(\"%s\", board[j]);\n            for (int k = 0; k < w; ++k) {\n                ++num[board[j][k] - 'A'];\n            }\n        }\n        for (int p = 0; p < 10; ++p) {\n        for (int j = 0; j < 26; ++j) {\n            if (!num[j])\n                continue;\n            \n            int up = 100, dw = -1, lf = 100, ri = -1;\n            for (int k = 0; k < h; ++k) {\n                for (int l = 0; l < w; ++l) {\n                    if (board[k][l] == j + 'A') {\n                        lf = min(lf, l);\n                        dw = max(dw, k);\n                        up = min(up, k);\n                        ri = max(ri, l);\n                    }\n                }\n            }\n            for (int k = up; k <= dw; ++k) {\n                for (int l = lf; l <= ri; ++l) {\n                    if (board[k][l] != j + 'A' && board[k][l] != '#') {\n                        goto A;\n                    }\n                }\n            }\n            for (int k = up; k <= dw; ++k) {\n                for (int l = lf; l <= ri; ++l) {\n                    if (board[k][l] == j + 'A') {\n                        board[k][l] = '#';\n                        --num[j];\n                    }\n                }\n            }\n            \n        A:\n            continue;\n\n        }\n        }\n        for (int j = 0; j < h; ++j) {\n            for (int k = 0; k < w; ++k) {\n                if (board[j][k] != '.' && board[j][k] != '#'){\n                    printf(\"SUSPICIOUS\\n\");\n                    goto B;\n                }\n            }\n        }\n        printf(\"SAFE\\n\");\n    B:\n        continue;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[50][64];\nchar val[7];\nbool v[7];\nint main(){\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%s\",str[i]);\n\t\t}\n\t\tfor(int i=0;i<7;i++)v[i]=false;\n\t\tint now=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(str[i][j]!='.'){\n\t\t\t\t\tbool p=false;\n\t\t\t\t\tfor(int k=0;k<now;k++)if(str[i][j]==val[k])p=true;\n\t\t\t\t\tif(!p)val[now++]=str[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<now;i++){\n\t\t\tfor(int j=0;j<now;j++){\n\t\t\t\tif(v[j])continue;\n\t\t\t\tint top=100;\n\t\t\t\tint bottom=0;\n\t\t\t\tint left=100;\n\t\t\t\tint right=0;\n\t\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\t\tfor(int l=0;l<b;l++)if(val[j]==str[k][l]){\n\t\t\t\t\t\ttop=min(top,k);\n\t\t\t\t\t\tbottom=max(top,k);\n\t\t\t\t\t\tleft=min(left,l);\n\t\t\t\t\t\tright=max(right,l);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(int k=top;k<=bottom;k++){\n\t\t\t\t\tfor(int l=left;l<=right;l++){\n\t\t\t\t\t\tif(str[k][l]!=val[j]&&str[k][l]!=':')ok=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok){\n\t\t\t\t\tv[j]=true;\n\t\t\t\t\tfor(int k=top;k<=bottom;k++){\n\t\t\t\t\t\tfor(int l=left;l<=right;l++){\n\t\t\t\t\t\t\tstr[k][l]=':';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ret=true;\n\t\tfor(int i=0;i<now;i++)if(!v[i])ret=false;\n\t\tif(ret)printf(\"SAFE\\n\");\n\t\telse printf(\"SUSPICIOUS\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i = 0 ; i < n ; ++i)\n#define ALL(v) (v).begin(),v.end()\nusing namespace std;\n\n#ifdef _DEBUG\n#define debug_io fstream cin(\"input.txt\");ofstream cout(\"output.txt\");\n#else\n#define debug_io ;\n#endif\nusing pii = pair<int, int>;\nbool check(string tile[], vector<string> ot, int n)\n{\n\tREP(i, n) {\n\t\tif (tile[i] != ot[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint bet[30][4];\nint main()\n{\n\tdebug_io;\n\tint n;\n\tcin >> n;\n\tREP(i, n) {\n\t\tint xn, yn;\n\t\tstring tile[53];\n\t\tREP(i, 30)REP(j,4) {\n\t\t\tbet[i][j] = -1;\n\t\t}\n\t\tcin >> yn >> xn;\n\t\tREP(y, yn) {\n\t\t\tcin >> tile[y];\n\t\t}\n\t\tREP(y, yn) {\n\t\t\tREP(x, xn) {\n\t\t\t\tif (tile[y][x] != '.') {\n\t\t\t\t\tauto it = tile[y][x] - 'A';\n\t\t\t\t\tREP(i, 4) {\n\t\t\t\t\t\tif (bet[it][i] == -1) {\n\t\t\t\t\t\t\tif (i == 0 || i ==1) {\n\t\t\t\t\t\t\t\tbet[it][i] =  y;\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t\t\t\telse if (i == 2 || i ==3) {\n\t\t\t\t\t\t\t\tbet[it][i] =  x;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t\t\tbet[it][i] = min(bet[it][i], y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(i == 1){\n\t\t\t\t\t\t\t\tbet[it][i] = max(bet[it][i], y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (i == 2) {\n\t\t\t\t\t\t\t\tbet[it][i] = min(bet[it][i], x);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (i == 3) {\n\t\t\t\t\t\t\t\tbet[it][i] = max(bet[it][i], x);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}//if\n\t\t\t}//xn\n\t\t}//yn\n\t\tvector<int> ats;\n\t\tREP(i, 30) {\n\t\t\tif (bet[i][0] != -1) {\n\t\t\t\tats.push_back(i);\n\t\t\t}\n\t\t}\n\t\tbool ok = false;\n\t\tdo {\n\t\t\tvector<string> ot(yn);\n\t\t\tREP(i, yn) {\n\t\t\t\tot[i] = string(xn,'.');\n\t\t\t}\n\t\t\tREP(i, ats.size()) {\n\t\t\t\tfor(int j = bet[ats[i]][0];j <= bet[ats[i]][1];++j)\n\t\t\t\t\tfor (int k = bet[ats[i]][2]; k <= bet[ats[i]][3]; ++k) {\n\t\t\t\t\t\tot[j][k] = ats[i] + 'A';\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tok |= check(tile, ot, yn);\n\t\t} while (next_permutation(ALL(ats)));\n\n\t\tif (ok) {\n\t\t\tcout << \"SAFE\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}//n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <map>\n#include <cstring>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\n\nstruct rect {\n\tint t, b, l, r;\n\trect() : t(100),b(0),l(100),r(0){}\n};\n\nint main() {\n\tint n;\n\tcin >> n;\n\trep(nn, n) {\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tmap<char, rect> mp;\n\t\tvector<string> in(h);\n\t\tint f[50][50];\n\t\tmemset( f, 0, sizeof(f) );\n\t\trep(y, h) {\n\t\t\tcin >> in[y];\n\t\t\trep(x, w) {\n\t\t\t\tmp[in[y][x]].t = min(mp[in[y][x]].t, y);\n\t\t\t\tmp[in[y][x]].b = max(mp[in[y][x]].b, y);\n\t\t\t\tmp[in[y][x]].l = min(mp[in[y][x]].l, x);\n\t\t\t\tmp[in[y][x]].r = max(mp[in[y][x]].r, x);\n\t\t\t}\n\t\t}\n\t\tbool safe = false;\n\t\tfor(int i=0; i<7; i++) {\n\t\t\tbool allok = true;\n\t\t\tfor(map<char,rect>::iterator it=mp.begin(); it!=mp.end(); it++) {\n\t\t\t\trect r = it->second;\n\t\t\t\tbool ok = true;\n\t\t\t\tfor(int y=r.t; y<=r.b; y++) {\n\t\t\t\t\tfor(int x=r.l; x<=r.r; x++) {\n\t\t\t\t\t\tif( in[y][x] != it->first && in[y][x] != '*' ) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok) {\n\t\t\t\t\tfor(int y=r.t; y<=r.b; y++) {\n\t\t\t\t\t\tfor(int x=r.l; x<=r.r; x++) {\n\t\t\t\t\t\t\tin[y][x] = '*';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tallok &= ok;\n\t\t\t}\n\t\t\tif(allok) {\n\t\t\t\tsafe = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(safe) {\n\t\t\tcout << \"SAFE\" << endl;\n\t\t} else {\n\t\t\tcout << \"SUSPICIOUS\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Data.List as List\nimport Debug.Trace\nimport Data.Map as Map hiding (map, filter)\nimport Data.Sequence (elemIndexR)\n\ntype Region = (Int, Int, Int, Int)\n\nmain = do\n  n <- liftM read getLine\n  replicateM n analyze\n\nanalyze = do\n  [h, w] <- liftM (map read . words) getLine\n  image <- getImage h w\n  let (suspicious, m) = nonRect image\n  let (suspicious', _) = nonRect $ transpose image\n  let tiles = nub $ concat $ image\n  let loops = any (\\a -> overlayLoops image tiles a []) tiles\n  putStrLn $ if suspicious || suspicious' || loops then \"SUSPICIOUS\" else \"SAFE\"\n\noverlayLoops image tiles a visited =\n  any (\\b -> b `elem` visited || overlayLoops image tiles b (b:visited)) $ filter (\\b -> overlays image b a) $ filter ((/=) a) tiles\n\n-- a overlays b\noverlays :: [[Char]] -> Char -> Char -> Bool\noverlays image a b =\n  let y0 = minimum $ findIndices (elem b) image\n      y1 = maximum $ findIndices (elem b) image\n      x0 = minimum $ concatMap (elemIndices b) image\n      x1 = maximum $ concatMap (elemIndices b) image\n  in a `elem` [ image !! y !! x | y <- [y0..y1], x <- [x0..x1] ]\n\nnonRect :: [[Char]] -> (Bool, Map (Char, Char) Int)\nnonRect xs = nonRect' (zipWith (\\xs ys -> xs `zip` ys) (init xs) (tail xs)) 0 empty\n\nnonRect' :: [[(Char, Char)]] -> Int -> Map (Char, Char) Int -> (Bool, Map (Char, Char) Int)\nnonRect' [] _ m = (False, m)\nnonRect' (trans:tt) i m =\n  let (newM, ok) = List.foldl ( \\(m, ok) (x, y) ->\n                            if not ok\n                              then (m, False)\n                              else\n                                if x == y\n                                  then (m, True)\n                                  else if i /= findWithDefault i (x, y) m\n                                    then (m, False)\n                                    else (Map.insert (x, y) i m, True)\n                          ) (m, True) trans\n  in\n    if not ok\n      then (True, newM)\n      else nonRect' tt (i+1) newM\n\ngetImage h w = do\n  replicateM h getLine"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Data.List\n\ntype Region = (Int, Int, Int, Int)\n\nmain = do\n  n <- liftM read getLine\n  replicateM n analyze\n\nanalyze = do\n  [h, w] <- liftM (map read . words) getLine\n  image <- getImage h w\n  let tiles = nub $ concat $ image\n  let loops = any (\\a -> overlayLoops image tiles a []) tiles\n  putStrLn $ if loops then \"SUSPICIOUS\" else \"SAFE\"\n\noverlayLoops image tiles a visited =\n  any (\\b -> b `elem` visited || overlayLoops image tiles b (b:visited)) $ filter (\\b -> overlays image b a) $ filter ((/=) a) tiles\n\n-- a overlays b\noverlays :: [[Char]] -> Char -> Char -> Bool\noverlays image a b =\n  let y0 = minimum $ findIndices (elem b) image\n      y1 = maximum $ findIndices (elem b) image\n      x0 = minimum $ concatMap (elemIndices b) image\n      x1 = maximum $ concatMap (elemIndices b) image\n  in a `elem` [ image !! y !! x | y <- [y0..y1], x <- [x0..x1] ]\n\ngetImage h w = do\n  replicateM h getLine"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2002\nX Ray\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\nint Nchar;\nint N,W,H;\nchar A[100][100];\n\nchar chars[9];\nstruct RECT {\n  int top;\n  int left;\n  int bottom;\n  int right;\n  int nk;\n  char nori[8];\n} rects[8];\n\n//int flag[8];\n\nstruct RECT find_corner1(char c)\n{\n  int i,j;\n  struct RECT r;\n  \n  r.left = W;r.right = 0;r.top = H;r.bottom=0;\n\n  for(i=0;i<H;i++)\n    for(j=0;j<W;j++)\n      if(A[i][j] == c)\n\t{\n\t  if(i<r.top)r.top = i;\n\t  if(i>r.bottom)r.bottom = i;\n\t  if(j<r.left)r.left = j;\n\t  if(j>r.right)r.right = j;\n\t}\n  r.nori[0]='\\0';\n  r.nk=0;\n  return(r);\n}\nvoid find_corner()\n{\n  int i;\n  for(i=0;i<Nchar;i++)\n    rects[i] = find_corner1(chars[i]);\n}\nvoid Registchar(char c)\n{\n  int i;\n\n  if(Nchar)\n    {\n      for(i=0;i<Nchar;i++)\n\tif(chars[i] == c)\n\t  return;\n    }\n  chars[Nchar] = c;\n  Nchar ++;\n\n}\nvoid find_chars()\n{\n  int i,j;\n  char c;\n\n  Nchar =0;\n  for(i=0;i<H;i++)\n    for(j=0;j<W;j++)\n      {\n\tc = A[i][j];\n\tRegistchar(c);\t  \n      }\n}\nshow_corner()\n{\n  int i;\n\n  for(i=0;i<Nchar;i++)\n    {\n    printf(\"%c:\",chars[i]);\n    printf(\"l:%d\",rects[i].left);\n    printf(\"t:%d\",rects[i].top);\n    printf(\"r:%d\",rects[i].right);\n    printf(\"b:%d\",rects[i].bottom);\n    printf(\"\\n\");\n    }\n}\nshow_rect()\n{\n  int i;\n\n  for(i=0;i<Nchar;i++)\n    {\n    printf(\"%c:\",chars[i]);\n    /*    printf(\"l:%d\",rects[i].left);\n    printf(\"t:%d\",rects[i].top);\n    printf(\"r:%d\",rects[i].right);\n    printf(\"b:%d\",rects[i].bottom);\n    */\n    printf(\"NO UE NI:%s\",rects[i].nori);\n    \n    printf(\"\\n\");\n    }\n}\nvoid regist_nori(char c,struct RECT * rp)\n{\n  int i;\n  for(i=0;i<rp->nk;i++)\n    if(rp->nori[i] == c)\n      return;\n  rp->nori[rp->nk]=c;\n  (rp->nk)++;\n  rp->nori[rp->nk]='\\0';\n}\nvoid check_nori2(char c,struct RECT * rp)\n{\n  //printf(\"::CKNR2:%c\",c);\n\n  int i,j;\n  for(i=rp->top;i<=rp->bottom;i++)\n    for(j=rp->left;j<=rp->right;j++)\n      if(A[i][j] != c)\n\t{\n\t  //printf(\"*:%c %c\",A[i][j],c);\n\tregist_nori(A[i][j],rp);\n\t}\n}\nvoid check_nori()\n{\n  int i;\n\n  for(i=0;i<Nchar;i++)\n    check_nori2(chars[i],&(rects[i]));\n}\nint c2num(char c)\n{\n  char *re;\n  re=strchr(chars,c);\n  if(re==NULL)\n    return(-1);\n  else\n    return(re-chars);\n}\nint check_circular2(int n,int depth)\n{\n  int i;\n\n  //printf(\"CC %c;\",chars[n]);\n  if(depth >= 7)\n    return(-1);\n\n  for(i=0;i<rects[n].nk;i++)\n    {\n      if(check_circular2(c2num(rects[n].nori[i]),depth+1))\n\treturn(1);\n    }\n  return(0);\n}\nint check_circular()\n{\n  int s,ret;\n  s=c2num('.');\n  if(s == -1)\n    s = 0;\n  ret=check_circular2(s,1);\n  return(ret);\n}\n\nint check()\n{\n  int ret;\n\n  find_chars();\n  find_corner();\n  //printf(\"CHRS:%s\\n\",chars);\n  check_nori();\n  //show_rect();\n  ret=check_circular();\n  return(ret);\n}\n\nmain()\n{\n  int i,j,ret;\n\n  scanf(\"%d\",&N);\n\n  for(i=0;i<N;i++)\n    {\n      scanf(\"%d %d\",&H,&W);\n      for(j=0;j<H;j++)\n\tscanf(\"%s\",&(A[j][0]));\n\n      ret=check();\n\n      if(ret)\n\tprintf(\"SUSPISIOUS\\n\");\n      else\n\tprintf(\"SAFE\\n\");\n    }\n\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2002\nX Ray\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\nint Nchar;\nint N,W,H;\nchar A[100][100];\n\nchar chars[9];\nstruct RECT {\n  int top;\n  int left;\n  int bottom;\n  int right;\n  int nk;\n  char nori[8];\n} rects[8];\n\n//int flag[8];\n\nstruct RECT find_corner1(char c)\n{\n  int i,j;\n  struct RECT r;\n  \n  r.left = W;r.right = 0;r.top = H;r.bottom=0;\n\n  for(i=0;i<H;i++)\n    for(j=0;j<W;j++)\n      if(A[i][j] == c)\n\t{\n\t  if(i<r.top)r.top = i;\n\t  if(i>r.bottom)r.bottom = i;\n\t  if(j<r.left)r.left = j;\n\t  if(j>r.right)r.right = j;\n\t}\n  r.nori[0]='\\0';\n  r.nk=0;\n  return(r);\n}\nvoid find_corner()\n{\n  int i;\n  for(i=0;i<Nchar;i++)\n    rects[i] = find_corner1(chars[i]);\n}\nvoid Registchar(char c)\n{\n  int i;\n\n  if(Nchar)\n    {\n      for(i=0;i<Nchar;i++)\n\tif(chars[i] == c)\n\t  return;\n    }\n  chars[Nchar] = c;\n  Nchar ++;\n\n}\nvoid find_chars()\n{\n  int i,j;\n  char c;\n\n  Nchar =0;\n  for(i=0;i<H;i++)\n    for(j=0;j<W;j++)\n      {\n\tc = A[i][j];\n\tRegistchar(c);\t  \n      }\n}\nshow_corner()\n{\n  int i;\n\n  for(i=0;i<Nchar;i++)\n    {\n    printf(\"%c:\",chars[i]);\n    printf(\"l:%d\",rects[i].left);\n    printf(\"t:%d\",rects[i].top);\n    printf(\"r:%d\",rects[i].right);\n    printf(\"b:%d\",rects[i].bottom);\n    printf(\"\\n\");\n    }\n}\nshow_rect()\n{\n  int i;\n\n  for(i=0;i<Nchar;i++)\n    {\n    printf(\"%c:\",chars[i]);\n    printf(\"l:%d\",rects[i].left);\n    printf(\"t:%d\",rects[i].top);\n    printf(\"r:%d\",rects[i].right);\n    printf(\"b:%d\",rects[i].bottom);\n    \n    printf(\"NO UE NI:%s\",rects[i].nori);\n    \n    printf(\"\\n\");\n    }\n}\nvoid regist_nori(char c,struct RECT * rp)\n{\n  int i;\n  for(i=0;i<rp->nk;i++)\n    if(rp->nori[i] == c)\n      return;\n  rp->nori[rp->nk]=c;\n  (rp->nk)++;\n  rp->nori[rp->nk]='\\0';\n}\nvoid check_nori2(char c,struct RECT * rp)\n{\n  //printf(\"::CKNR2:%c\",c);\n\n  int i,j;\n  for(i=rp->top;i<=rp->bottom;i++)\n    for(j=rp->left;j<=rp->right;j++)\n      if(A[i][j] != c)\n\t{\n\t  //printf(\"*:%c %c\",A[i][j],c);\n\tregist_nori(A[i][j],rp);\n\t}\n}\nvoid check_nori()\n{\n  int i;\n\n  for(i=0;i<Nchar;i++)\n    check_nori2(chars[i],&(rects[i]));\n}\nint c2num(char c)\n{\n  char *re;\n  re=strchr(chars,c);\n  if(re==NULL)\n    return(-1);\n  else\n    return(re-chars);\n}\nint check_circular2(int n,int depth)\n{\n  int i;\n\n  //printf(\"CC %c;\",chars[n]);\n  if(depth >= 7)\n    return(-1);\n\n  for(i=0;i<rects[n].nk;i++)\n    {\n      if(check_circular2(c2num(rects[n].nori[i]),depth+1))\n\treturn(1);\n    }\n  return(0);\n}\nint check_circular()\n{\n  int s,ret;\n  s=c2num('.');\n  if(s == -1)\n    s = 0;\n  ret=check_circular2(s,1);\n  return(ret);\n}\n\nint check()\n{\n  int ret;\n\n  find_chars();\n  find_corner();\n  //printf(\"CHRS:%s\\n\",chars);\n  check_nori();\n  //show_rect();\n  ret=check_circular();\n  return(ret);\n}\n\nmain()\n{\n  int i,j,ret;\n\n  scanf(\"%d\",&N);\n\n  for(i=0;i<N;i++)\n    {\n      scanf(\"%d %d\",&H,&W);\n      for(j=0;j<H;j++)\n\tscanf(\"%s\",&(A[j][0]));\n\n      ret=check();\n\n      if(ret)\n\tprintf(\"SUSPICIOUS\\n\");\n      else\n\tprintf(\"SAFE\\n\");\n    }\n\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX_H 50\n#define MAX_W 50\n\ntypedef struct {\n\tint top, bottom, left, right;\n} EDGE;\n\n\nint n;\nint h, w;\nchar img[MAX_H][MAX_W];\n\n\nvoid edge_check( EDGE *edge, int ximg[MAX_H][MAX_W], int y, int x, char alfa )\n{\n\tximg[y][x] = 1;\n\tif ( y < edge->top ) edge->top = y;\n\telse if ( y > edge->bottom ) edge->bottom = y;\n\telse if ( x > edge->right ) edge->right = x;\n\telse if ( x < edge->left ) edge->left = x;\n\t\n\tif ( img[y+1][x] == alfa && ximg[y+1][x] == 0 && y+1 < h ) edge_check( edge, ximg, y+1, x, alfa );\n\tif ( img[y-1][x] == alfa && ximg[y-1][x] == 0 && y-1 >= 0) edge_check( edge, ximg, y-1, x, alfa );\n\tif ( img[y][x+1] == alfa && ximg[y][x+1] == 0 && x+1 < w ) edge_check( edge, ximg, y, x+1, alfa );\n\tif ( img[y][x-1] == alfa && ximg[y][x-1] == 0 && x-1 >= 0) edge_check( edge, ximg, y, x-1, alfa);\n\t\n}\n\nint scanx( void )\n{\n\tint i, j, k, item_n;\n\tchar alfa[7];\n\tEDGE edge[7];\n\tint ximg[MAX_H][MAX_W];\n\t\n\titem_n = 0;\n\t\n\tfor( i=0; i<h; i++ ) {\n\t\tfor( j=0; j<w; j++ ) {\n\t\t\tximg[i][j] = 0;\n\t\t}\n\t}\n\t\n\tfor( i=0; i<h; i++ ) {\n\t\tfor( j=0; j<w; j++ ) {\n\t\t\tif ( ximg[i][j] == 0 && img[i][j] != '.' ) {\n\t\t\t\tedge[item_n].top = edge[item_n].bottom = i;\n\t\t\t\tedge[item_n].left = edge[item_n].right = j;\n\t\t\t\talfa[item_n] = img[i][j];\n\t\t\t\tedge_check( &edge[item_n], ximg, i, j, alfa[item_n]);\n\t\t\t\titem_n++;\n\t\t\t\t}\n\t\t}\n\t}\n\n\tfor( i=0; i<item_n; i++ ) {\n\t\t\n\t\tfor( j=edge[i].top; j<=edge[i].bottom; j++ ) {\t\t//????????¢???????????????\n\t\t\tfor( k=edge[i].left; k<=edge[i].right; k++ ) {\n\t\t\t\tif ( img[j][k] != alfa[i] && img[j][k] != '0' )\n\t\t\t\t\tgoto _exit;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor( j=edge[i].top; j<=edge[i].bottom; j++ ) {\n\t\t\tfor( k=edge[i].left; k<=edge[i].right; k++ ) {\n\t\t\t\timg[j][k] = '0';\n\t\t\t}\n\t\t}\n\t\t\n\t\titem_n--;\t\t\t//????????????????¬?????????¢???\n\t\tfor( j=i; j<=item_n; j++ ) {\n\t\t\tedge[j] = edge[j+1];\n\t\t\talfa[j] = alfa[j+1];\n\t\t}\n\t\ti = -1;\n\t\t\n\t\t_exit:;\n\t}\n\t\n\tif( item_n == 0 ) return 0;\n\telse return 1;\n}\n\nint main(void)\n{\n\tint i;\n\t\n\tscanf( \"%d\", &n );\n\t\n\twhile( n-- ) {\n\t\t\n\t\tscanf( \"%d %d\", &h, &w );\n\t\t\n\t\tfor( i=0; i<h; i++ ) {\n\t\t\tscanf( \"%s\", img[i] );\n\t\t}\n\t\t\n\t\tif ( scanx() == 0 ) printf( \"SAFE\\n\" );\n\t\telse printf( \"SUSPICIOUS\\n\" );\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\ntypedef struct g{int p[4][2],z;char c;}g;//up,left,right,down\nint H,W,i,j,k,N,p[128],o,q;\ng G[7];\nchar X[51][51];\nint dfs(int d)\n{\n\tint i,j,k,r=0;\n\tif(d==o)\n\t{\n\t\tfor(k=0;k<o;k++)\n\t\t\tfor (i=G[k].p[0][0];i<=G[k].p[3][0];i++)\n\t\t\t\tfor (j=G[k].p[1][1];j<=G[k].p[2][1];j++)\n\t\t\t\t\tif(X[i][j]=='.'||G[p[X[i][j]]].z>G[k].z)\n\t\t\t\t\t\treturn 0;\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\tfor(i=0;i<o;i++)\n\t\t{\n\t\t\tif(G[i].z==-1)\n\t\t\t{\n\t\t\t\tG[i].z=d;\n\t\t\t\tr|=dfs(d+1);\n\t\t\t\tG[i].z=-1;\n\t\t\t}\n\t\t}\n\t}\n\treturn r;\n}\nint main()\n{\n\tfor(scanf(\"%d\",&N);N--;)\n\t{\n\t\tscanf(\"%d%d\\n\",&H,&W);\n\t\tmemset(p,-1,sizeof(p));\n\t\tmemset(G,-1,sizeof(G));\n\t\tfor(i=o=0;i<H;i++)\n\t\t\tgets(X[i]);\n\t\tfor(i=0;i<H;i++)\n\t\t\tfor(j=0;j<W;j++)\n\t\t\t{\n\t\t\t\tif((q=X[i][j])!='.')\n\t\t\t\t{\n\t\t\t\t\tif(p[q]==-1)\n\t\t\t\t\t{\n\t\t\t\t\t\tp[q]=o++;\n\t\t\t\t\t\tG[p[q]].c=X[i][j];\n\t\t\t\t\t\tG[p[q]].p[0][0]=G[p[q]].p[1][0]=G[p[q]].p[2][0]=G[p[q]].p[3][0]=i;\n\t\t\t\t\t\tG[p[q]].p[0][1]=G[p[q]].p[1][1]=G[p[q]].p[2][1]=G[p[q]].p[3][1]=j;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(G[p[q]].p[0][0]>i)//up\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tG[p[q]].p[0][0]=i;\n\t\t\t\t\t\t\tG[p[q]].p[0][1]=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(G[p[q]].p[1][1]>j)//left\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tG[p[q]].p[1][0]=i;\n\t\t\t\t\t\t\tG[p[q]].p[1][1]=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(G[p[q]].p[2][1]<j)//right\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tG[p[q]].p[2][0]=i;\n\t\t\t\t\t\t\tG[p[q]].p[2][1]=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(G[p[q]].p[3][0]<i)//down\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tG[p[q]].p[3][0]=i;\n\t\t\t\t\t\t\tG[p[q]].p[3][1]=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tputs(dfs(0)?\"SAFE\":\"SUSPICIOUS\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define REP(i,n,m) for(i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nint h,w;\nint mt[26][4]; //[i][0]:¶[ [1]:E[ [2]:ã[ [3]:º[\nint used[26];\nchar t[54][54];\n\n//(a+'A') Ì¶ª (b+'B') Ì¶æèOÉ é©Ì»è\n//»Ì»èÆ¯É, a ª·û`Å é©à»è·é\nint isFront(int a,int b){\n\tint i,j;\n\tREP(i,mt[a][2],mt[a][3]+1){\n\t\tREP(j,mt[a][0],mt[a][1]+1){\n\t\t\tif(t[i][j] == b + 'A' || t[i][j] == '.'){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\n//SafeÅ é©Ç¤©Ì»è\nint isSafe(int idx,int rem){\n\tint i,j;\n\tint okFlg;\n\n\tif(rem == 0){\n\t\t//ÅãÌLª·û`©»è·é½ßÉisFrontðg¤\n\t\treturn isFront(idx,-1);\n\t}\n\n\tused[idx] = 1;\n\trep(i,26){\n\t\tif(mt[i][1]!=-1 && !used[i]){\n\n\t\t\t//¡ÜÅgpµ½LSÄæèãëÉ é©»è\n\t\t\tokFlg = 1;\n\t\t\trep(j,26) if(used[j] && !isFront(j,i)){\n\t\t\t\tokFlg = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(okFlg && isSafe(i,rem-1)) return 1;\n\t\t}\n\t}\n\tused[idx] = 0;\n\n\treturn 0;\n}\n\nint main(void){\n\tint i,j;\n\tint n,idx,count;\n\n\tscanf(\"%d\",&n);\n\twhile(n--){\n\t\tscanf(\"%d%d\",&h,&w);\n\n\t\trep(i,26){\n\t\t\tmt[i][0] = w+1;\n\t\t\tmt[i][1] = -1;\n\t\t\tmt[i][2] = h+1;\n\t\t\tmt[i][3] = -1;\n\t\t}\n\n\t\tcount = 0;\n\t\trep(i,h){\n\t\t\tscanf(\"%s\",t[i]);\n\t\t\trep(j,w) if(t[i][j] != '.') {\n\t\t\t\tidx = t[i][j] - 'A';\n\n\t\t\t\t//LÌíÞJEg\n\t\t\t\tif(mt[idx][1] == -1) count++;\n\n\t\t\t\t//LÌ¶[,E[,ã[,º[ðXV\n\t\t\t\tif(mt[idx][0] > j) mt[idx][0] = j;\n\t\t\t\tif(mt[idx][1] < j) mt[idx][1] = j;\n\t\t\t\tif(mt[idx][2] > i) mt[idx][2] = i;\n\t\t\t\tif(mt[idx][3] < i) mt[idx][3] = i;\n\t\t\t}\n\t\t}\n\n\t\trep(i,26) used[i] = 0;\n\t\trep(i,26) if(mt[i][1] != -1 && isSafe(i,count-1)) break;\n\n\t\tprintf(\"%s\\n\",count!=0 && i==26 ? \"SUSPICIOUS\" : \"SAFE\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void){\n    int n;\n    scanf(\"%d\",&n);\n    for(int unko=0;unko<n;unko++){\n        \n        \n        int h,w;\n        scanf(\"%d %d\",&h,&w);\n        char po[100][100];\n        for(int i=0;i<h;i++)scanf(\"%s\",po[i]);\n        while(1){\n            int hdrue[26][2];\n            for(int i=0;i<26;i++){hdrue[i][0]=-1;hdrue[i][1]=-1;}\n            int mgst[26][2];\n            for(int i=0;i<26;i++){mgst[i][0]=-1;mgst[i][1]=-1;}\n            for(int i=0;i<h;i++)for(int j=0;j<w;j++){\n                if(po[i][j]!='.'&&po[i][j]!='#'){\n                    int nari=po[i][j]%26;\n                    if(hdrue[nari][0]==-1){\n                        hdrue[nari][0]=i;\n                        hdrue[nari][1]=j;\n                        mgst[nari][0]=i;\n                        mgst[nari][1]=j;\n                    }\n                    if(hdrue[nari][0]>i)hdrue[nari][0]=i;\n                    if(hdrue[nari][1]>j)hdrue[nari][1]=j;\n                    if(mgst[nari][0]<i)mgst[nari][0]=i;\n                    if(mgst[nari][1]<j)mgst[nari][1]=j;\n                }\n            }\n            int flag=1;\n            for(int i=0;i<26;i++)if(hdrue[i][0]!=-1)flag=0;\n            if(flag==1){printf(\"SAFE\\n\");break;}\n            flag=0;\n            for(int i=0;i<26;i++){if(hdrue[i][0]!=-1){\n                int flag3=1;\n                for(int k=0;k<h;k++)for(int l=0;l<w;l++){\n                    if(hdrue[i][0]<=k&&mgst[i][0]>=k&&hdrue[i][1]<=l&&mgst[i][1]>=l){if(!(po[k][l]!='.'&&(po[k][l]%26==i||po[k][l]=='#'))){flag3=0;}}\n                    else if(po[k][l]!='.'&&po[k][l]!='#'&&po[k][l]%26==i){flag3=0;}\n                }\n                if(flag3==1){\n                    flag=1;\n                    for(int k=hdrue[i][0];k<=mgst[i][0];k++)for(int l=hdrue[i][1];l<=mgst[i][1];l++)po[k][l]='#';\n                }\n            }}\n            if(flag==0){printf(\"SUSPICIOUS\\n\");/*for(int i=0;i<h;i++)printf(\"%s\\n\",po[i]);*/break;}\n        }\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint h,w;\nchar nimotu[52][52];\nint nimotu_data[27][52][52];\nstruct {\n\tint xmin,xmax;\n\tint ymin,ymax;\n} nimotu_range[26];\n\nint solve(void) {\n\tint i;\n\tint x,y;\n\tint kousinn_atta;\n\tif(scanf(\"%d%d\",&h,&w)!=2)return 0;\n\tfor(i=1;i<=h;i++) {\n\t\tif(scanf(\"%s\",nimotu[i]+1)!=1)return 0;\n\t}\n\tmemset(nimotu_data,0,sizeof(nimotu_data));\n\tfor(i=0;i<26;i++) {\n\t\tnimotu_range[i].xmin=w+2;\n\t\tnimotu_range[i].xmax=-1;\n\t\tnimotu_range[i].ymin=h+2;\n\t\tnimotu_range[i].ymax=-1;\n\t}\n\tfor(y=1;y<=h;y++) {\n\t\tfor(x=1;x<=w;x++) {\n\t\t\tif(nimotu[y][x]!='.') {\n\t\t\t\t/* ASCII code wo katei */\n\t\t\t\tint m=nimotu[y][x]-'A';\n\t\t\t\tnimotu_data[m][y][x]++;\n\t\t\t\tif(nimotu_range[m].xmin>x)nimotu_range[m].xmin=x;\n\t\t\t\tif(nimotu_range[m].xmax<x)nimotu_range[m].xmax=x;\n\t\t\t\tif(nimotu_range[m].ymin>y)nimotu_range[m].ymin=y;\n\t\t\t\tif(nimotu_range[m].ymax<y)nimotu_range[m].ymax=y;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<26;i++) {\n\t\tfor(y=1;y<=h;y++) {\n\t\t\tfor(x=1;x<=w;x++)nimotu_data[i][y][x]+=nimotu_data[i][y][x-1];\n\t\t}\n\t\tfor(x=1;x<=w;x++) {\n\t\t\tfor(y=1;y<=h;y++)nimotu_data[i][y][x]+=nimotu_data[i][y-1][x];\n\t\t}\n\t}\n\tdo {\n\t\tkousinn_atta=0;\n\t\tfor(i=0;i<26;i++) {\n\t\t\tif(nimotu_range[i].xmin<=nimotu_range[i].xmax) {\n\t\t\t\tint xs=nimotu_range[i].xmin-1;\n\t\t\t\tint xt=nimotu_range[i].xmax;\n\t\t\t\tint ys=nimotu_range[i].ymin-1;\n\t\t\t\tint yt=nimotu_range[i].ymax;\n\t\t\t\tint n=nimotu_data[i][yt][xt]-nimotu_data[i][yt][xs]\n\t\t\t\t\t-nimotu_data[i][ys][xt]+nimotu_data[i][ys][xs];\n\t\t\t\tint v=nimotu_data[26][yt][xt]-nimotu_data[26][yt][xs]\n\t\t\t\t\t-nimotu_data[26][ys][xt]+nimotu_data[26][ys][xs];\n\t\t\t\tif(n+v==(xt-xs)*(yt-ys)) {\n\t\t\t\t\tkousinn_atta=1;\n\t\t\t\t\t/* kono nimotu wo hazusu */\n\t\t\t\t\tnimotu_range[i].xmin=w+2;\n\t\t\t\t\tnimotu_range[i].xmax=-1;\n\t\t\t\t\t/* ruisekiwa wo kaizyo */\n\t\t\t\t\tfor(x=1;x<=w;x++) {\n\t\t\t\t\t\tfor(y=h;y>=1;y--) {\n\t\t\t\t\t\t\tnimotu_data[i][y][x]-=nimotu_data[i][y-1][x];\n\t\t\t\t\t\t\tnimotu_data[26][y][x]-=nimotu_data[26][y-1][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(y=1;y<=h;y++) {\n\t\t\t\t\t\tfor(x=w;x>=1;x--) {\n\t\t\t\t\t\t\tnimotu_data[i][y][x]-=nimotu_data[i][y][x-1];\n\t\t\t\t\t\t\tnimotu_data[26][y][x]-=nimotu_data[26][y][x-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* nurinaosu */\n\t\t\t\t\tfor(y=1;y<=h;y++) {\n\t\t\t\t\t\tfor(x=1;x<=w;x++) {\n\t\t\t\t\t\t\tnimotu_data[i][y][x]+=nimotu_data[i][y][x-1];\n\t\t\t\t\t\t\tnimotu_data[26][y][x]+=nimotu_data[26][y][x-1];\n\t\t\t\t\t\t\tif(nimotu[y][x]-'A'==i) {\n\t\t\t\t\t\t\t\tnimotu_data[i][y][x]--;\n\t\t\t\t\t\t\t\tnimotu_data[26][y][x]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(x=1;x<=w;x++) {\n\t\t\t\t\t\tfor(y=1;y<=h;y++) {\n\t\t\t\t\t\t\tnimotu_data[i][y][x]+=nimotu_data[i][y-1][x];\n\t\t\t\t\t\t\tnimotu_data[26][y][x]+=nimotu_data[26][y-1][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while(kousinn_atta);\n\tfor(i=0;i<26;i++) {\n\t\tif(nimotu_range[i].xmin<=nimotu_range[i].xmax) {\n\t\t\t/* nimotu ga nokotteru */\n\t\t\tputs(\"SUSPICIOUS\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\tputs(\"SAFE\");\n\treturn 1;\n}\n\nint main(void) {\n\tint n,i;\n\tif(scanf(\"%d\",&n)!=1)return 1;\n\tfor(i=0;i<n;i++) {\n\t\tif(!solve())return 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 50;\n\nclass State{\npublic:\n  int mx, my, Mx, My;\n  State() {}\n  State(int mx, int my, int Mx, int My) : mx(mx), my(my), Mx(Mx), My(My) {}\n};\n\nint h, w, col, mx, my, Mx, My, A[7], dy[] = {-1, 0, 1, 0}, dx[] = {0, 1, 0, -1};\nState state[7];\nchar data[N][N];\nbool used[N][N], ans;\nmap<char, int> number;\nmap<int, char> material;\n\nmain(){\n  int t;\n  cin >> t;\n  while(t--){\n    set<int> upper[7];\n    number.clear();\n    material.clear();\n    cin >> h >> w;\n    col = 0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> data[i][j];\n        if(data[i][j] != '.' && number.find(data[i][j]) == number.end()){\n          number[data[i][j]] = col;\n          material[col++] = data[i][j];\n        }\n      }\n    }\n    for(int k=0;k<col;k++){\n      state[k] = State(N, N, 0, 0);\n      for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n          if(data[i][j] == material[k]){\n            state[k].mx = min(state[k].mx, j);\n            state[k].my = min(state[k].my, i);\n            state[k].Mx = max(state[k].Mx, j);\n            state[k].My = max(state[k].My, i);\n          }\n        }\n      }\n    }\n    for(int k=0;k<col;k++){\n      for(int i=state[k].my;i<=state[k].My;i++){\n        for(int j=state[k].mx;j<=state[k].Mx;j++){\n          if(data[i][j] == '.'){\n            cout << \"SUSPICIOUS\" << endl;\n            goto CONT;\n          }\n          else if(data[i][j] != material[k]) upper[k].insert(number[data[i][j]]);\n        }\n      }\n    }\n    for(int i=0;i<col;i++) A[i] = i;\n    ans = false;\n    do{\n      for(int i=0;i<col;i++){\n        for(set<int>::iterator j=upper[i].begin();j!=upper[i].end();j++){\n          if(A[i] < A[*j]) goto FAILD;\n        }\n      }\n      ans = true;\n      FAILD:;\n    }while(next_permutation(A, A+col));\n    if(ans || !col) cout << \"SAFE\" << endl;\n    else cout << \"SUSPICIOUS\" << endl;\n    CONT:;\n  }\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2002\nX Ray\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\nint Nchar;\nint N,W,H;\nchar A[100][100];\n\nchar chars[9];\nstruct RECT {\n  int top;\n  int left;\n  int bottom;\n  int right;\n  int nk;\n  char nori[8];\n} rects[8];\n\n//int flag[8];\n\nstruct RECT find_corner1(char c)\n{\n  int i,j;\n  struct RECT r;\n  \n  r.left = W;r.right = 0;r.top = H;r.bottom=0;\n\n  for(i=0;i<H;i++)\n    for(j=0;j<W;j++)\n      if(A[i][j] == c)\n\t{\n\t  if(i<r.top)r.top = i;\n\t  if(i>r.bottom)r.bottom = i;\n\t  if(j<r.left)r.left = j;\n\t  if(j>r.right)r.right = j;\n\t}\n  r.nori[0]='\\0';\n  r.nk=0;\n  return(r);\n}\nvoid find_corner()\n{\n  int i;\n  for(i=0;i<Nchar;i++)\n    rects[i] = find_corner1(chars[i]);\n}\nvoid Registchar(char c)\n{\n  int i;\n\n  if(Nchar)\n    {\n      for(i=0;i<Nchar;i++)\n\tif(chars[i] == c)\n\t  return;\n    }\n  chars[Nchar] = c;\n  Nchar ++;\n\n}\nvoid find_chars()\n{\n  int i,j;\n  char c;\n\n  Nchar =0;\n  for(i=0;i<H;i++)\n    for(j=0;j<W;j++)\n      {\n\tc = A[i][j];\n\tRegistchar(c);\t  \n      }\n}\nshow_corner()\n{\n  int i;\n\n  for(i=0;i<Nchar;i++)\n    {\n    printf(\"%c:\",chars[i]);\n    printf(\"l:%d\",rects[i].left);\n    printf(\"t:%d\",rects[i].top);\n    printf(\"r:%d\",rects[i].right);\n    printf(\"b:%d\",rects[i].bottom);\n    printf(\"\\n\");\n    }\n}\nshow_rect()\n{\n  int i;\n\n  for(i=0;i<Nchar;i++)\n    {\n    printf(\"%c:\",chars[i]);\n    printf(\"l:%d\",rects[i].left);\n    printf(\"t:%d\",rects[i].top);\n    printf(\"r:%d\",rects[i].right);\n    printf(\"b:%d\",rects[i].bottom);\n    \n    printf(\"NO UE NI:%s\",rects[i].nori);\n    \n    printf(\"\\n\");\n    }\n}\nvoid regist_nori(char c,struct RECT * rp)\n{\n  int i;\n  for(i=0;i<rp->nk;i++)\n    if(rp->nori[i] == c)\n      return;\n  rp->nori[rp->nk]=c;\n  (rp->nk)++;\n  rp->nori[rp->nk]='\\0';\n}\nvoid check_nori2(char c,struct RECT * rp)\n{\n  //printf(\"::CKNR2:%c\",c);\n\n  int i,j;\n  for(i=rp->top;i<=rp->bottom;i++)\n    for(j=rp->left;j<=rp->right;j++)\n      if(A[i][j] != c)\n\t{\n\t  //printf(\"*:%c %c\",A[i][j],c);\n\tregist_nori(A[i][j],rp);\n\t}\n}\nvoid check_nori()\n{\n  int i;\n\n  for(i=0;i<Nchar;i++)\n    check_nori2(chars[i],&(rects[i]));\n}\nint c2num(char c)\n{\n  char *re;\n  re=strchr(chars,c);\n  if(re==NULL)\n    return(-1);\n  else\n    return(re-chars);\n}\nint check_circular2(int n,int depth)\n{\n  int i;\n\n  //printf(\"CC %c;\",chars[n]);\n  if(depth > 7)\n    return(-1);\n\n  for(i=0;i<rects[n].nk;i++)\n    {\n      if(check_circular2(c2num(rects[n].nori[i]),depth+1))\n\treturn(1);\n    }\n  return(0);\n}\nint check_circular()\n{\n  int s,ret;\n  s=c2num('.');\n  if(s == -1)\n    s = 0;\n  ret=check_circular2(s,1);\n  return(ret);\n}\nvoid set_ji()\n{\n  int s;\n\n  s=c2num('.');\n  if(s != -1)\n    {\n      rects[s].left=0;rects[s].top=0;\n      rects[s].right=W-1;rects[s].bottom=H-1;\n    }\n}\nint check()\n{\n  int ret;\n\n  find_chars();\n  find_corner();\n  set_ji();\n  //printf(\"CHRS:%s\\n\",chars);\n  check_nori();\n  //show_rect();\n  ret=check_circular();\n  return(ret);\n}\n\nmain()\n{\n  int i,j,ret;\n\n  scanf(\"%d\",&N);\n\n  for(i=0;i<N;i++)\n    {\n      scanf(\"%d %d\",&H,&W);\n      for(j=0;j<H;j++)\n\tscanf(\"%s\",&(A[j][0]));\n\n      ret=check();\n\n      if(ret)\n\tprintf(\"SUSPICIOUS\\n\");\n      else\n\tprintf(\"SAFE\\n\");\n    }\n\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "h,l[26],t[26],r[26],b[26],x,y,c,s;char m[50][51];S(){s=1;for(y=t[c];y<=b[c];y++)for(x=l[c];x<=r[c];x++)if(m[y][x]&&m[y][x]-65-c)s=0;}main(n){for(scanf(\"%*d\");~scanf(\"%d%*d\",&h);puts(n?\"SUSPICIOUS\":\"SAFE\")){int e[26]={n=0};for(y=h;y--;)for(x=-scanf(\"%s\",m[y]);c=m[y][++x];)c>64?e[c-=65]?x<l[c]?l[c]=x:0,x>r[c]?r[c]=x:0,y<t[c]?t[c]=y:0,y>b[c]?b[c]=y:0:(l[c]=r[c]=x,t[c]=b[c]=y,e[c]=++n):0;for(;n&&~c;)for(c=26;c--;)if(e[c]&&(S(),s)){for(y=t[c];y<=b[c];)bzero(m[y++]+l[c],r[c]-l[c]+1);e[c]=!n--;break;}}}"
  },
  {
    "language": "C",
    "code": "#define min(a,b)((a)<(b)?(a):(b))\n#define max(a,b)((a)>(b)?(a):(b))\nint h,w,e[26],x1[26],y1[26],x2[26],y2[26];\nchar m[50][51];\nissafe(c){\n\tint x,y;\n\tfor(y=y1[c];y<=y2[c];y++){\n\t\tfor(x=x1[c];x<=x2[c];x++){\n\t\t\tif(m[y][x]!='A'+c&&m[y][x]!='@')\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\ndel(c){\n\tint x,y;\n\tfor(y=y1[c];y<=y2[c];y++){\n\t\tfor(x=x1[c];x<=x2[c];x++){\n\t\t\tm[y][x]='@';\n\t\t}\n\t}\n\te[c]=0;\n}\ndisp(){\n\tint y;\n\treturn;\n\tputs(\"\");\n\tfor(y=0;y<h;y++)\n\t\tputs(m[y]);\n}\nmain(c){\n\tint x,y,n;\n\tscanf(\"%*d\");\n\tfor(;~scanf(\"%d%d\",&h,&w);){\n\t\tmemset(e,0,sizeof(e));\n\t\tn=0;\n\t\tfor(y=0;y<h;y++){\n\t\t\tscanf(\"%s\",m[y]);\n\t\t\tfor(x=0;c=m[y][x];x++){\n\t\t\t\tif(c>='A'){\n\t\t\t\t\tc-='A';\n\t\t\t\t\tif(e[c]){\n\t\t\t\t\t\tx1[c]=min(x1[c],x);\n\t\t\t\t\t\tx2[c]=max(x2[c],x);\n\t\t\t\t\t\ty1[c]=min(y1[c],y);\n\t\t\t\t\t\ty2[c]=max(y2[c],y);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tx1[c]=x2[c]=x;\n\t\t\t\t\t\ty1[c]=y2[c]=y;\n\t\t\t\t\t\te[c]=1;\n\t\t\t\t\t\tn++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(;n;){\n\t\t\tdisp();\n\t\t\tfor(c=0;c<26;c++){\n\t\t\t\tif(e[c]){\n\t\t\t\t\tif(issafe(c)){\n\t\t\t\t\t\tdel(c);\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c==26){\n\t\t\t\tdisp();\n\t\t\t\tputs(\"SUSPICIOUS\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(n==0){\n\t\t\tdisp();\n\t\t\tputs(\"SAFE \");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2002\nX Ray\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\nint Nchar;\nint N,W,H;\nchar A[100][100];\n\nchar chars[9];\nstruct RECT {\n  int top;\n  int left;\n  int bottom;\n  int right;\n  int nk;\n  char nori[8];\n} rects[8];\n\n//int flag[8];\n\nstruct RECT find_corner1(char c)\n{\n  int i,j;\n  struct RECT r;\n  \n  r.left = W;r.right = 0;r.top = H;r.bottom=0;\n\n  for(i=0;i<H;i++)\n    for(j=0;j<W;j++)\n      if(A[i][j] == c)\n\t{\n\t  if(i<r.top)r.top = i;\n\t  if(i>r.bottom)r.bottom = i;\n\t  if(j<r.left)r.left = j;\n\t  if(j>r.right)r.right = j;\n\t}\n  r.nori[0]='\\0';\n  r.nk=0;\n  return(r);\n}\nvoid find_corner()\n{\n  int i;\n  for(i=0;i<Nchar;i++)\n    rects[i] = find_corner1(chars[i]);\n}\nvoid Registchar(char c)\n{\n  int i;\n\n  if(Nchar)\n    {\n      for(i=0;i<Nchar;i++)\n\tif(chars[i] == c)\n\t  return;\n    }\n  chars[Nchar] = c;\n  Nchar ++;\n\n}\nvoid find_chars()\n{\n  int i,j;\n  char c;\n\n  Nchar =0;\n  for(i=0;i<H;i++)\n    for(j=0;j<W;j++)\n      {\n\tc = A[i][j];\n\tRegistchar(c);\t  \n      }\n}\nshow_corner()\n{\n  int i;\n\n  for(i=0;i<Nchar;i++)\n    {\n    printf(\"%c:\",chars[i]);\n    printf(\"l:%d\",rects[i].left);\n    printf(\"t:%d\",rects[i].top);\n    printf(\"r:%d\",rects[i].right);\n    printf(\"b:%d\",rects[i].bottom);\n    printf(\"\\n\");\n    }\n}\nshow_rect()\n{\n  int i;\n\n  for(i=0;i<Nchar;i++)\n    {\n    printf(\"%c:\",chars[i]);\n    printf(\"l:%d\",rects[i].left);\n    printf(\"t:%d\",rects[i].top);\n    printf(\"r:%d\",rects[i].right);\n    printf(\"b:%d\",rects[i].bottom);\n    \n    printf(\"NO UE NI:%s\",rects[i].nori);\n    \n    printf(\"\\n\");\n    }\n}\nvoid regist_nori(char c,struct RECT * rp)\n{\n  int i;\n  for(i=0;i<rp->nk;i++)\n    if(rp->nori[i] == c)\n      return;\n  rp->nori[rp->nk]=c;\n  (rp->nk)++;\n  rp->nori[rp->nk]='\\0';\n}\nvoid check_nori2(char c,struct RECT * rp)\n{\n  //printf(\"::CKNR2:%c\",c);\n\n  int i,j;\n  for(i=rp->top;i<=rp->bottom;i++)\n    for(j=rp->left;j<=rp->right;j++)\n      if(A[i][j] != c)\n\t{\n\t  //printf(\"*:%c %c\",A[i][j],c);\n\tregist_nori(A[i][j],rp);\n\t}\n}\nvoid check_nori()\n{\n  int i;\n\n  for(i=0;i<Nchar;i++)\n    check_nori2(chars[i],&(rects[i]));\n}\nint c2num(char c)\n{\n  char *re;\n  re=strchr(chars,c);\n  if(re==NULL)\n    return(-1);\n  else\n    return(re-chars);\n}\nint check_circular2(int n,int depth)\n{\n  int i;\n\n  printf(\"CC %c  DP %d;\",chars[n],depth);\n  if(depth > 8)\n    return(-1);\n\n  for(i=0;i<rects[n].nk;i++)\n    {\n      if(check_circular2(c2num(rects[n].nori[i]),depth+1))\n\treturn(1);\n    }\n  return(0);\n}\nint check_circular()\n{\n  int s,ret;\n  s=c2num('.');\n  if(s == -1)\n    s = 0;\n  ret=check_circular2(s,1);\n  return(ret);\n}\nvoid set_ji()\n{\n  int s;\n\n  s=c2num('.');\n  if(s != -1)\n    {\n      rects[s].left=0;rects[s].top=0;\n      rects[s].right=W-1;rects[s].bottom=H-1;\n    }\n}\nint check()\n{\n  int ret;\n\n  find_chars();\n  find_corner();\n  set_ji();\n  //printf(\"CHRS:%s\\n\",chars);\n  check_nori();\n  show_rect();\n  ret=check_circular();\n  return(ret);\n}\n\nmain()\n{\n  int i,j,ret;\n\n  scanf(\"%d\",&N);\n\n  for(i=0;i<N;i++)\n    {\n      scanf(\"%d %d\",&H,&W);\n      for(j=0;j<H;j++)\n\tscanf(\"%s\",&(A[j][0]));\n\n      ret=check();\n\n      if(ret)\n\tprintf(\"SUSPICIOUS\\n\");\n      else\n\tprintf(\"SAFE\\n\");\n    }\n\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define REP(i,n,m) for(i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nint h,w;\nint mt[26][4]; //[i][0]:左端 [1]:右端 [2]:上端 [3]:下端\nint used[26];\nchar t[54][54];\n\n//(a+'A') の文字が (b+'B') の文字より前にあるかの判定\n//その判定と同時に, a が長方形であるかも判定する\nint isFront(int a,int b){\n    int i,j;\n    REP(i,mt[a][2],mt[a][3]+1){\n        REP(j,mt[a][0],mt[a][1]+1){\n            if(t[i][j] == b + 'A' || t[i][j] == '.'){\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\n//Safeであるかどうかの判定\nint isSafe(int idx,int rem){\n    int i,j;\n    int okFlg;\n    \n    if(rem == 0){\n        //最後の記号が長方形か判定するためにisFrontを使う\n        return isFront(idx,-1);\n    }\n    \n    used[idx] = 1;\n    rep(i,26){\n        if(mt[i][1]!=-1 && !used[i]){\n            \n            //今まで使用した記号全てより後ろにあるか判定\n            okFlg = 1;\n            rep(j,26) if(used[j] && !isFront(j,i)){\n                okFlg = 0;\n                break;\n            }\n            \n            if(okFlg && isSafe(i,rem-1)) return 1;\n        }\n    }\n    used[idx] = 0;\n    \n    return 0;\n}\n\nint main(void){\n    int i,j;\n    int n,idx,count;\n    \n    scanf(\"%d\",&n);\n    while(n--){\n        scanf(\"%d%d\",&h,&w);\n        \n        rep(i,26){\n            mt[i][0] = w+1;\n            mt[i][1] = -1;\n            mt[i][2] = h+1;\n            mt[i][3] = -1;\n        }\n        \n        count = 0;\n        rep(i,h){\n            scanf(\"%s\",t[i]);\n            rep(j,w) if(t[i][j] != '.') {\n                idx = t[i][j] - 'A';\n                \n                //記号の種類カウント\n                if(mt[idx][1] == -1) count++;\n                \n                //記号の左端,右端,上端,下端を更新\n                if(mt[idx][0] > j) mt[idx][0] = j;\n                if(mt[idx][1] < j) mt[idx][1] = j;\n                if(mt[idx][2] > i) mt[idx][2] = i;\n                if(mt[idx][3] < i) mt[idx][3] = i;\n            }\n        }\n        \n        rep(i,26) used[i] = 0;\n        rep(i,26) if(mt[i][1] != -1 && isSafe(i,count-1)) break;\n        \n        printf(\"%s\\n\",count!=0 && i==26 ? \"SUSPICIOUS\" : \"SAFE\");\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2002\nX Ray\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\nint Nchar;\nint N,W,H;\nchar A[100][100];\n\nchar chars[9];\nstruct RECT {\n  int top;\n  int left;\n  int bottom;\n  int right;\n  int nk;\n  char nori[8];\n} rects[8];\n\n//int flag[8];\n\nstruct RECT find_corner1(char c)\n{\n  int i,j;\n  struct RECT r;\n  \n  r.left = W;r.right = 0;r.top = H;r.bottom=0;\n\n  for(i=0;i<H;i++)\n    for(j=0;j<W;j++)\n      if(A[i][j] == c)\n\t{\n\t  if(i<r.top)r.top = i;\n\t  if(i>r.bottom)r.bottom = i;\n\t  if(j<r.left)r.left = j;\n\t  if(j>r.right)r.right = j;\n\t}\n  r.nori[0]='\\0';\n  r.nk=0;\n  return(r);\n}\nvoid find_corner()\n{\n  int i;\n  for(i=0;i<Nchar;i++)\n    rects[i] = find_corner1(chars[i]);\n}\nvoid Registchar(char c)\n{\n  int i;\n\n  if(Nchar)\n    {\n      for(i=0;i<Nchar;i++)\n\tif(chars[i] == c)\n\t  return;\n    }\n  chars[Nchar] = c;\n  Nchar ++;\n\n}\nvoid find_chars()\n{\n  int i,j;\n  char c;\n\n  Nchar =0;\n  for(i=0;i<H;i++)\n    for(j=0;j<W;j++)\n      {\n\tc = A[i][j];\n\tRegistchar(c);\t  \n      }\n}\nshow_corner()\n{\n  int i;\n\n  for(i=0;i<Nchar;i++)\n    {\n    printf(\"%c:\",chars[i]);\n    printf(\"l:%d\",rects[i].left);\n    printf(\"t:%d\",rects[i].top);\n    printf(\"r:%d\",rects[i].right);\n    printf(\"b:%d\",rects[i].bottom);\n    printf(\"\\n\");\n    }\n}\nshow_rect()\n{\n  int i;\n\n  for(i=0;i<Nchar;i++)\n    {\n    printf(\"%c:\",chars[i]);\n    printf(\"l:%d\",rects[i].left);\n    printf(\"t:%d\",rects[i].top);\n    printf(\"r:%d\",rects[i].right);\n    printf(\"b:%d\",rects[i].bottom);\n    \n    printf(\"NO UE NI:%s\",rects[i].nori);\n    \n    printf(\"\\n\");\n    }\n}\nvoid regist_nori(char c,struct RECT * rp)\n{\n  int i;\n  for(i=0;i<rp->nk;i++)\n    if(rp->nori[i] == c)\n      return;\n  rp->nori[rp->nk]=c;\n  (rp->nk)++;\n  rp->nori[rp->nk]='\\0';\n}\nvoid check_nori2(char c,struct RECT * rp)\n{\n  //printf(\"::CKNR2:%c\",c);\n\n  int i,j;\n  for(i=rp->top;i<=rp->bottom;i++)\n    for(j=rp->left;j<=rp->right;j++)\n      if(A[i][j] != c)\n\t{\n\t  //printf(\"*:%c %c\",A[i][j],c);\n\tregist_nori(A[i][j],rp);\n\t}\n}\nvoid check_nori()\n{\n  int i;\n\n  for(i=0;i<Nchar;i++)\n    check_nori2(chars[i],&(rects[i]));\n}\nint c2num(char c)\n{\n  char *re;\n  re=strchr(chars,c);\n  if(re==NULL)\n    return(-1);\n  else\n    return(re-chars);\n}\nint check_circular2(int n,int depth)\n{\n  int i;\n\n  //printf(\"CC %c;\",chars[n]);\n  if(depth >= 7)\n    return(-1);\n\n  for(i=0;i<rects[n].nk;i++)\n    {\n      if(check_circular2(c2num(rects[n].nori[i]),depth+1))\n\treturn(1);\n    }\n  return(0);\n}\nint check_circular()\n{\n  int s,ret;\n  s=c2num('.');\n  if(s == -1)\n    s = 0;\n  ret=check_circular2(s,1);\n  return(ret);\n}\nvoid set_ji()\n{\n  int s;\n\n  s=c2num('.');\n  if(s != -1)\n    {\n      rects[s].left=0;rects[s].top=0;\n      rects[s].right=W-1;rects[s].bottom=H-1;\n    }\n}\nint check()\n{\n  int ret;\n\n  find_chars();\n  find_corner();\n  set_ji();\n  //printf(\"CHRS:%s\\n\",chars);\n  check_nori();\n  //show_rect();\n  ret=check_circular();\n  return(ret);\n}\n\nmain()\n{\n  int i,j,ret;\n\n  scanf(\"%d\",&N);\n\n  for(i=0;i<N;i++)\n    {\n      scanf(\"%d %d\",&H,&W);\n      for(j=0;j<H;j++)\n\tscanf(\"%s\",&(A[j][0]));\n\n      ret=check();\n\n      if(ret)\n\tprintf(\"SUSPICIOUS\\n\");\n      else\n\tprintf(\"SAFE\\n\");\n    }\n\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define max(p,q)((p)>(q)?(p):(q))\n#define min(p,q)((p)<(q)?(p):(q))\n\nint b[30][4];\n\nint main(){\n\tll q;\n\tscanf(\"%lld\",&q);\n\twhile(q--){\n\t\trep(i,0,26){\n\t\t\tb[i][0]=100;\n\t\t\tb[i][1]=-1;\n\t\t\tb[i][2]=100;\n\t\t\tb[i][3]=-1;\n\t\t}\n\t\tll h,w;\n\t\tscanf(\"%lld%lld\",&h,&w);\n\n\t\tint cnt=0;\n\t\tchar s[60][60]={};\n\t\trep(i,0,h)rep(j,0,w){\n\t\t\tscanf(\" %c\",&s[i][j]);\n\t\t\tif(s[i][j]!='.'){\n\t\t\t\tint c=s[i][j]-'A';\n\t\t\t\tif(b[c][0]==100)cnt++;\n\t\t\t\tb[c][0]=min(b[c][0],i);\n\t\t\t\tb[c][1]=max(b[c][1],i);\n\t\t\t\tb[c][2]=min(b[c][2],j);\n\t\t\t\tb[c][3]=max(b[c][3],j);\n\t\t\t}\n\t\t}\n\t\t//cnt種\n\t\tint flag=1;\n\t\twhile(flag){\n\t\t\tflag=0;\n\t\t\trep(c,0,26)if(b[c][0]!=100){\n\t\t\t\tint temp=1;\n\t\t\t\trep(i,b[c][0],b[c][1]+1)rep(j,b[c][2],b[c][3]+1){\n\t\t\t\t\tif(s[i][j]!=' '&&s[i][j]!=c+'A'){\n\t\t\t\t\t\ttemp=0;i=j=100;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(temp){\n\t\t\t\t\trep(i,b[c][0],b[c][1]+1)rep(j,b[c][2],b[c][3]+1)s[i][j]=' ';\n\t\t\t\t\tcnt--;\n\t\t\t\t\tflag=1;\n\t\t\t\t\tb[c][0]=100;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\trep(i,0,h)puts(s[i]);\n\t\tputs(cnt?\"SUSPICIOUS\":\"SAFE\");\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <math.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define REP(i, n) for((i) = 0; (i) < (n); (i)++)\n#define READ1(n1) scanf(\"%d\", &(n1))\n#define READ2(n1, n2) scanf(\"%d%d\", &(n1), &(n2))\n#define READ3(n1, n2, n3) scanf(\"%d%d%d\", &(n1), &(n2), &(n3))\n#define P1(n1) printf(\"%d\\n\", (n1))\n#define P2(n1, n2) printf(\"%d, %d\\n\", (n1), (n2))\n#define P3(n1, n2, n3) printf(\"%d, %d, %d\\n\", (n1), (n2), (n3))\n#define CLEAR(p) memset((p), 0, sizeof((p)))\n#define MAX_WIDTH 50\n#define MAX_HEIGHT 50\n#define MAX_ITEMS 8\n\ntypedef struct {\n\tint x1, y1, x2, y2;\n\tchar c;\n\tint overlay[MAX_ITEMS];\n} item_t;\n\nitem_t items[MAX_ITEMS];\nint item_num;\n\nchar image[MAX_HEIGHT][MAX_WIDTH+1];\n\nint put_item_under(int a, int b) {\n\t//Insert a under b\n\tint i;\n\tif(items[b].overlay[a] > 0) {\n\t\treturn -1;\n\t}\n\titems[b].overlay[a] = -1;\n\titems[a].overlay[b] = 1;\n\tREP(i, item_num) {\n\t\tif(items[b].overlay[i] > 0) {\n\t\t\tif(put_item_under(a, i) < 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint put_item_above(int a, int b) {\n\t//Insert a above b\n\tint i;\n\tif(items[b].overlay[a] < 0) {\n\t\treturn -1;\n\t}\n\titems[b].overlay[a] = 1;\n\tREP(i, item_num) {\n\t\tif(items[b].overlay[i] < 0) {\n\t\t\tif(put_item_above(a, i) < 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nmain()\n{\n\tint i, j, k, x, y, data_num;\n\n\tREAD1(data_num);\n\n\tREP(i, data_num) {\n\t\tint width, height;\n\n\t\tREAD2(height, width);\n\n\t\tREP(j, height) {\n\t\t\tscanf(\"%s\", image[j]);\n\t\t}\n\n\t\titem_num = 0;\n\n\t\tREP(y, height) {\n\t\t\tREP(x, width) {\n\t\t\t\tREP(j, item_num) {\n\t\t\t\t\tif(items[j].c == image[y][x]) {\n\t\t\t\t\t\tif(x > items[j].x2) items[j].x2 = x;\n\t\t\t\t\t\tif(x < items[j].x1) items[j].x1 = x;\n\t\t\t\t\t\tif(y > items[j].y2) items[j].y2 = y;\n\t\t\t\t\t\tif(y < items[j].y1) items[j].y1 = y;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(j == item_num) {\n\t\t\t\t\titems[item_num].x1 = x;\n\t\t\t\t\titems[item_num].x2 = x;\n\t\t\t\t\titems[item_num].y1 = y;\n\t\t\t\t\titems[item_num].y2 = y;\n\t\t\t\t\titems[item_num].c = image[y][x];\n\t\t\t\t\titem_num++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tREP(j, item_num) {\n\t\t\tCLEAR(items[j].overlay);\n\t\t}\n\n\t\t/*REP(j, item_num) {\n\t\t\tprintf(\"%c: (%d, %d) - (%d, %d)\\n\", items[j].c, items[j].x1, items[j].y1, items[j].x2, items[j].y2);\n\t\t}*/\n\n\t\tREP(j, item_num) {\n\t\t\tfor(x = items[j].x1; x <= items[j].x2; x++) {\n\t\t\t\tfor(y = items[j].y1; y <= items[j].y2; y++) {\n\t\t\t\t\tif(image[y][x] != items[j].c) {\n\t\t\t\t\t\tREP(k, item_num) {\n\t\t\t\t\t\t\tif(items[k].c == image[y][x]) {\n\t\t\t\t\t\t\t\tif(put_item_under(j, k) < 0) {\n\t\t\t\t\t\t\t\t\tgoto suspicious;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"SAFE\\n\");\n\t\tcontinue;\n\tsuspicious:\n\t\tprintf(\"SUSPICIOUS\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint h,w;\nchar nimotu[52][52];\nint nimotu_data[27][52][52];\nstruct {\n\tint xmin,xmax;\n\tint ymin,ymax;\n} nimotu_range[26];\n\nint solve(void) {\n\tint i;\n\tint x,y;\n\tint kousinn_atta;\n\tif(scanf(\"%d%d\",&h,&w)!=2)return 0;\n\tfor(i=1;i<=h;i++) {\n\t\tif(scanf(\"%s\",nimotu[i]+1)!=1)return 0;\n\t}\n\tmemset(nimotu_data,0,sizeof(nimotu_data));\n\tfor(i=0;i<26;i++) {\n\t\tnimotu_range[i].xmin=w+2;\n\t\tnimotu_range[i].xmax=-1;\n\t\tnimotu_range[i].ymin=h+2;\n\t\tnimotu_range[i].ymax=-1;\n\t}\n\tfor(y=1;y<=h;y++) {\n\t\tfor(x=1;x<=w;x++) {\n\t\t\tif(nimotu[y][x]!='.') {\n\t\t\t\t/* ASCII code wo katei */\n\t\t\t\tint m=nimotu[y][x]-'A';\n\t\t\t\tnimotu_data[m][y][x]++;\n\t\t\t\tif(nimotu_range[m].xmin>x)nimotu_range[m].xmin=x;\n\t\t\t\tif(nimotu_range[m].xmax<x)nimotu_range[m].xmax=x;\n\t\t\t\tif(nimotu_range[m].ymin>y)nimotu_range[m].ymin=y;\n\t\t\t\tif(nimotu_range[m].ymax<y)nimotu_range[m].ymax=y;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<26;i++) {\n\t\tfor(y=1;y<=h;y++) {\n\t\t\tfor(x=1;x<=w;x++)nimotu_data[i][y][x]+=nimotu_data[i][y][x-1];\n\t\t}\n\t\tfor(x=1;x<=w;x++) {\n\t\t\tfor(y=1;y<=h;y++)nimotu_data[i][y][x]+=nimotu_data[i][y-1][x];\n\t\t}\n\t}\n\tdo {\n\t\tkousinn_atta=0;\n\t\tfor(i=0;i<26;i++) {\n\t\t\tif(nimotu_range[i].xmin<=nimotu_range[i].xmax) {\n\t\t\t\tint xs=nimotu_range[i].xmin-1;\n\t\t\t\tint xt=nimotu_range[i].xmax;\n\t\t\t\tint ys=nimotu_range[i].ymin-1;\n\t\t\t\tint yt=nimotu_range[i].ymax;\n\t\t\t\tint n=nimotu_data[i][yt][xt]-nimotu_data[i][yt][xs]\n\t\t\t\t\t-nimotu_data[i][ys][xt]+nimotu_data[i][ys][xs];\n\t\t\t\tint v=nimotu_data[26][yt][xt]-nimotu_data[26][yt][xs]\n\t\t\t\t\t-nimotu_data[26][ys][xt]+nimotu_data[26][ys][xs];\n\t\t\t\tif(n+v==(xt-xs)*(yt-ys)) {\n\t\t\t\t\tkousinn_atta=1;\n\t\t\t\t\t/* kono nimotu wo hazusu */\n\t\t\t\t\tnimotu_range[i].xmin=w+2;\n\t\t\t\t\tnimotu_range[i].xmax=-1;\n\t\t\t\t\t/* ruisekiwa wo kaizyo */\n\t\t\t\t\tfor(x=1;x<=w;x++) {\n\t\t\t\t\t\tfor(y=h;y>=1;y--) {\n\t\t\t\t\t\t\tnimotu_data[i][y][x]-=nimotu_data[i][y-1][x];\n\t\t\t\t\t\t\tnimotu_data[26][y][x]-=nimotu_data[26][y-1][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(y=1;y<=h;y++) {\n\t\t\t\t\t\tfor(x=w;x>=1;x--) {\n\t\t\t\t\t\t\tnimotu_data[i][y][x]-=nimotu_data[i][y][x-1];\n\t\t\t\t\t\t\tnimotu_data[26][y][x]-=nimotu_data[26][y][x-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* nurinaosu */\n\t\t\t\t\tfor(y=1;y<=h;y++) {\n\t\t\t\t\t\tfor(x=1;x<=w;x++) {\n\t\t\t\t\t\t\tnimotu_data[i][y][x]+=nimotu_data[i][y][x-1];\n\t\t\t\t\t\t\tnimotu_data[26][y][x]+=nimotu_data[26][y][x-1];\n\t\t\t\t\t\t\tif(xs<x && x<=xt && ys<y && y<=yt) {\n\t\t\t\t\t\t\t\tnimotu_data[i][y][x]--;\n\t\t\t\t\t\t\t\tnimotu_data[26][y][x]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(x=1;x<=w;x++) {\n\t\t\t\t\t\tfor(y=1;y<=h;y++) {\n\t\t\t\t\t\t\tnimotu_data[i][y][x]+=nimotu_data[i][y-1][x];\n\t\t\t\t\t\t\tnimotu_data[26][y][x]+=nimotu_data[26][y-1][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while(kousinn_atta);\n\tfor(i=0;i<26;i++) {\n\t\tif(nimotu_range[i].xmin<=nimotu_range[i].xmax) {\n\t\t\t/* nimotu ga nokotteru */\n\t\t\tputs(\"SUSPICIOUS\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\tputs(\"SAFE\");\n\treturn 1;\n}\n\nint main(void) {\n\tint n,i;\n\tif(scanf(\"%d\",&n)!=1)return 1;\n\tfor(i=0;i<n;i++) {\n\t\tif(!solve())return 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2002\nX Ray\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n#define DEBUG 1\n//Global data section\nint Nchar;\nint N,W,H;\nchar A[100][100];\n\nchar chars[9];\nstruct RECT {\n  int top;\n  int left;\n  int bottom;\n  int right;\n  int nk;\n  char nori[8];\n} rects[8];\n\n//int flag[8];\n\nstruct RECT find_corner1(char c)\n{\n  int i,j;\n  struct RECT r;\n  \n  r.left = W;r.right = 0;r.top = H;r.bottom=0;\n\n  for(i=0;i<H;i++)\n    for(j=0;j<W;j++)\n      if(A[i][j] == c)\n\t{\n\t  if(i<r.top)r.top = i;\n\t  if(i>r.bottom)r.bottom = i;\n\t  if(j<r.left)r.left = j;\n\t  if(j>r.right)r.right = j;\n\t}\n  r.nori[0]='\\0';\n  r.nk=0;\n  return(r);\n}\nvoid find_corner()\n{\n  int i;\n  for(i=0;i<Nchar;i++)\n    rects[i] = find_corner1(chars[i]);\n}\nvoid Registchar(char c)\n{\n  int i;\n\n  if(Nchar)\n    {\n      for(i=0;i<Nchar;i++)\n\tif(chars[i] == c)\n\t  return;\n    }\n  chars[Nchar] = c;\n  Nchar ++;\n\n}\nvoid find_chars()\n{\n  int i,j;\n  char c;\n\n  Nchar =0;\n  for(i=0;i<H;i++)\n    for(j=0;j<W;j++)\n      {\n\tc = A[i][j];\n\tRegistchar(c);\t  \n      }\n}\nshow_corner()\n{\n  int i;\n\n  for(i=0;i<Nchar;i++)\n    {\n    printf(\"%c:\",chars[i]);\n    printf(\"l:%d\",rects[i].left);\n    printf(\"t:%d\",rects[i].top);\n    printf(\"r:%d\",rects[i].right);\n    printf(\"b:%d\",rects[i].bottom);\n    printf(\"\\n\");\n    }\n}\nshow_rect()\n{\n  int i;\n\n  for(i=0;i<Nchar;i++)\n    {\n    printf(\"%c:\",chars[i]);\n    printf(\"l:%d\",rects[i].left);\n    printf(\"t:%d\",rects[i].top);\n    printf(\"r:%d\",rects[i].right);\n    printf(\"b:%d\",rects[i].bottom);\n    \n    printf(\"NO UE NI:%s\",rects[i].nori);\n    \n    printf(\"\\n\");\n    }\n}\nvoid regist_nori(char c,struct RECT * rp)\n{\n  int i;\n  for(i=0;i<rp->nk;i++)\n    if(rp->nori[i] == c)\n      return;\n  rp->nori[rp->nk]=c;\n  (rp->nk)++;\n  rp->nori[rp->nk]='\\0';\n}\nvoid check_nori2(char c,struct RECT * rp)\n{\n  //printf(\"::CKNR2:%c\",c);\n\n  int i,j;\n  for(i=rp->top;i<=rp->bottom;i++)\n    for(j=rp->left;j<=rp->right;j++)\n      if(A[i][j] != c)\n\t{\n\t  //printf(\"*:%c %c\",A[i][j],c);\n\tregist_nori(A[i][j],rp);\n\t}\n}\nvoid check_nori()\n{\n  int i;\n\n  for(i=0;i<Nchar;i++)\n    check_nori2(chars[i],&(rects[i]));\n}\nint c2num(char c)\n{\n  char *re;\n  re=strchr(chars,c);\n  if(re==NULL)\n    return(-1);\n  else\n    return(re-chars);\n}\nint check_circular2(int n,int depth)\n{\n  int i;\n\n  //printf(\"CC %c;\",chars[n]);\n  if(depth > 8){\n    //printf(\"CC D: %d;\",depth);\n    return(-1);\n  }\n  for(i=0;i<rects[n].nk;i++)\n    {\n      if(check_circular2(c2num(rects[n].nori[i]),depth+1))\n\treturn(1);\n    }\n  return(0);\n}\nint check_circular()\n{\n  int s,ret;\n  s=c2num('.');\n  if(s == -1)\n    s = 0;\n  ret=check_circular2(s,1);\n  return(ret);\n}\nvoid set_ji()\n{\n  int s;\n\n  s=c2num('.');\n  if(s != -1)\n    {\n      rects[s].left=0;rects[s].top=0;\n      rects[s].right=W-1;rects[s].bottom=H-1;\n    }\n}\nint check()\n{\n  int ret;\n\n  find_chars();\n  find_corner();\n  set_ji();\n  //printf(\"CHRS:%s\\n\",chars);\n  check_nori();\n#ifdef DEBUG\n  //show_rect();\n#endif\n  ret=check_circular();\n  return(ret);\n}\n\nmain()\n{\n  int i,j,ret;\n\n  scanf(\"%d\",&N);\n\n  for(i=0;i<N;i++)\n    {\n      scanf(\"%d %d\",&H,&W);\n      for(j=0;j<H;j++)\n\tscanf(\"%s\",&(A[j][0]));\n\n      ret=check();\n\n      if(ret)\n\tprintf(\"SUSPICIOUS\\n\");\n      else\n\tprintf(\"SAFE\\n\");\n    }\n\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2002: X-Ray Screening System\n// 2017.11.23 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nchar m[51][52];\nchar tbl['Z'+1]; int sz;\nint  rmin[7], rmax[7], cmin[7], cmax[7];\nchar f[7];\n\nint rec(int k)\n{\n\tint i, r, c, ii;\n\tchar tmp[51][52];\n\n\tif (k == sz) return 1;\n\tfor (ii = 1, i = 0; i < sz; i++, ii <<= 1) {\n\t\tif (f[i]) continue;\n\t\tf[i] = 1;\n\t\tfor (r = rmin[i]; r <= rmax[i]; r++) for (c = cmin[i]; c <= cmax[i]; c++) {\n\t\t\tif (!(m[r][c] & ii)) goto next;\n\t\t}\n\t\tmemcpy(tmp, m, sizeof(tmp));\n\t\tfor (r = rmin[i]; r <= rmax[i]; r++) for (c = cmin[i]; c <= cmax[i]; c++) {\n\t\t\tm[r][c] = 0xff;\n\t\t}\n\t\tif (rec(k+1)) return 1;\n\t\tmemcpy(m, tmp, sizeof(tmp));\nnext:\tf[i] = 0;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint T, H, W, r, c, i, a;\n\n\tscanf(\"%d\", &T);\n\twhile (T--) {\n\t\tsz = 0, memset(tbl, -1, sizeof(tbl));\n\t\tfor (i = 0; i < 7; i++) rmin[i] = cmin[i] = 50, rmax[i] = cmax[i] = 0, \n\t\tscanf(\"%d%d\", &H, &W);\n\t\tfor (r = 0; r < H; r++) {\n\t\t\tscanf(\"%s\", m[r]);\n\t\t\tfor (c = 0; c < W; c++) {\n\t\t\t\tif (m[r][c] == '.') m[r][c] = 0;\n\t\t\t\telse {\n\t\t\t\t\ta = m[r][c];\n\t\t\t\t\tif ((i = tbl[a]) < 0) i = tbl[a] = sz++;\n\t\t\t\t\tm[r][c] = 1 << i;\n\t\t\t\t\tif (rmin[i] > r) rmin[i] = r;\n\t\t\t\t\tif (rmax[i] < r) rmax[i] = r;\n\t\t\t\t\tif (cmin[i] > c) cmin[i] = c;\n\t\t\t\t\tif (cmax[i] < c) cmax[i] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(f, 0, sz);\n\t\tputs(rec(0) ? \"SAFE\" : \"SUSPICIOUS\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\ntypedef struct g{int p[4][2],z;char c;}g;//up,left,right,down\nint H,W,i,j,k,N,p[128],o,q,r[51][51];\ng G[7];\nchar X[51][51];\nint main()\n{\n\tfor(scanf(\"%d\",&N);N--;)\n\t{\n\t\tscanf(\"%d%d\\n\",&H,&W);\n\t\tmemset(p,-1,sizeof(p));\n\t\tmemset(G,-1,sizeof(G));\n\t\tmemset(X,0,sizeof(X));\n\t\tmemset(r,0,sizeof(r));\n\t\tG[0].z=0;\n\t\tfor(i=o=0;i<H;i++)\n\t\t\tgets(X[i]);\n\t\tfor(i=0;i<H;i++)\n\t\t\tfor(j=0;j<W;j++)\n\t\t\t{\n\t\t\t\tif((q=X[i][j])!='.')\n\t\t\t\t{\n\t\t\t\t\tif(p[q]==-1)\n\t\t\t\t\t{\n\t\t\t\t\t\tp[q]=o++;\n\t\t\t\t\t\tG[p[q]].c=X[i][j];\n\t\t\t\t\t\tG[p[q]].p[0][0]=G[p[q]].p[1][0]=G[p[q]].p[2][0]=G[p[q]].p[3][0]=i;\n\t\t\t\t\t\tG[p[q]].p[0][1]=G[p[q]].p[1][1]=G[p[q]].p[2][1]=G[p[q]].p[3][1]=j;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(G[p[q]].p[0][0]>i)//up\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tG[p[q]].p[0][0]=i;\n\t\t\t\t\t\t\tG[p[q]].p[0][1]=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(G[p[q]].p[1][1]>j)//left\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tG[p[q]].p[1][0]=i;\n\t\t\t\t\t\t\tG[p[q]].p[1][1]=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(G[p[q]].p[2][1]<j)//right\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tG[p[q]].p[2][0]=i;\n\t\t\t\t\t\t\tG[p[q]].p[2][1]=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(G[p[q]].p[3][0]<i)//down\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tG[p[q]].p[3][0]=i;\n\t\t\t\t\t\t\tG[p[q]].p[3][1]=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tfor(k=0;k<o;k++)\n\t\t{\n\t\t\t\n\t\t\tfor(i=G[k].p[0][0];i<=G[k].p[3][0];i++)\n\t\t\t\tfor(j=G[k].p[1][1];j<=G[k].p[2][1];j++)\n\t\t\t\t{\n\t\t\t\t\tif(X[i][j]=='.')\n\t\t\t\t\t\tgoto e;\n\t\t\t\t\telse if(X[i][j]!=G[k].c)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(G[k].z==-1)\n\t\t\t\t\t\t\tr[i][j]=G[k].z=G[p[X[i][j]]].z-1;\n\t\t\t\t\t\telse if(G[p[X[i][j]]].z==-1)\n\t\t\t\t\t\t\tG[p[X[i][j]]].z=G[k].z+1;\n\t\t\t\t\t\telse if(G[p[X[i][j]]].z<G[k].z||r[i][j]<G[k].z)\n\t\t\t\t\t\t\tgoto e;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tr[i][j]=G[k].z;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\ne:\t\tputs(k==o?\"SAFE\":\"SUSPICIOUS\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.*\n\nfun main(args:Array<String>):Unit {\n    repeat(readLine()!!.toInt()){\n        val (h, w) = readLine()!!.split(' ').map(String::toInt)\n        val suspects = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ.\".associate { if(it == '.') Pair(it, NoObject) else Pair(it, SuspiciousObject() as Suspect) }\n        val state = Array(h){readLine()!!.toCharArray().map{suspects[it]!!}.toTypedArray()}\n        for (i in 1 until h){\n            for (j in 1 until w){\n                if (state[i][j] == state[i - 1][j - 1]){\n                    if (state[i][j - 1] != state[i][j])\n                        setOverlap(state[i][j - 1], state[i][j])\n                    if (state[i - 1][j] != state[i][j])\n                        setOverlap(state[i - 1][j], state[i][j])\n                }\n                if (state[i - 1][j] == state[i][j - 1]){\n                    if (state[i][j] != state[i - 1][j])\n                        setOverlap(state[i][j], state[i - 1][j])\n                    if (state[i - 1][j - 1] != state[i - 1][j])\n                        setOverlap(state[i - 1][j - 1], state[i - 1][j])\n                }\n            }\n        }\n        var sus = suspects.map{it.value}\n        var top = sus.filter{it.isCanBeTop}\n        sus = sus.filterNot{ it.isCanBeTop }\n        while (top.isNotEmpty()){\n            top.forEach { it.useAsTop() }\n            top = sus.filter { it.isCanBeTop }\n            sus = sus.filterNot { it.isCanBeTop }\n        }\n        println(if (sus.size == 1) \"SAFE\" else \"SUSPICIOUS\")\n    }\n}\nfun setOverlap(upper:Suspect, lower:Suspect):Unit{\n    upper.addLowerOrder(lower)\n    lower.addUpperOrder(upper)\n}\ndata class Point(val x:Int, val y:Int){\n    fun map(transformer:(Int) -> Int):Point = Point(transformer(x), transformer(y))\n    operator fun plus(other:Point):Point = Point(x + other.x, y + other.y)\n}\ninterface Suspect{\n    fun addLowerOrder(other:Suspect):Unit\n    fun addUpperOrder(other:Suspect):Unit\n    val isCanBeTop:Boolean\n    fun useAsTop():Unit\n}\nobject NoObject:Suspect{\n    override fun addLowerOrder(other: Suspect) {}\n\n    override fun addUpperOrder(other: Suspect) {}\n\n    override val isCanBeTop: Boolean\n        get() = false\n\n    override fun useAsTop() {}\n\n}\nclass SuspiciousObject() :Suspect{\n    override val isCanBeTop: Boolean\n        get() = mUpperCount == 0\n    override fun useAsTop() {\n        mLower.forEach {\n            when(it){\n                is SuspiciousObject -> --it.mUpperCount\n                else -> {}\n            }\n        }\n    }\n\n    override fun addLowerOrder(other: Suspect) {\n        mLower.push(other)\n    }\n\n    override fun addUpperOrder(other: Suspect) {\n        ++mUpperCount\n    }\n\n    private val mLower: Stack<Suspect> = Stack()\n    private var mUpperCount:Int = 0\n\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.*\n\n\nfun main(args:Array<String>):Unit{\n    repeat(readLine()!!.toInt()){\n        val (h, w) = readLine()!!.split(' ').map(String::toInt)\n        val objectsMap = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ.\".associate {\n            if (it == '.') Pair(it, NoObject as SuspiciousObject) else Pair(it, Something())\n        }\n        val state = Array(h){readLine()!!.map{objectsMap[it]!!}.toTypedArray()}\n        val objects = objectsMap.map{it.value}\n        for (i in 0 until h) for (j in 0 until w) state[i][j].addAppearPoint(Point(i, j))\n        for (i in 0 until h) for (j in 0 until w){\n            objects.filter{it.isOverlapPosition(Point(i, j))}.forEach {\n                state[i][j].addOverlapObjectUnlessSame(it)\n                it.addCoverObjectUnlessSame(state[i][j])\n            }\n        }\n        var canBeTop = objects.filter(SuspiciousObject::isCanBeTop)\n        var rest = objects.filterNot(SuspiciousObject::isCanBeTop)\n        while (canBeTop.isNotEmpty()){\n            canBeTop.forEach { it.useAsTop() }\n            canBeTop = rest.filter(SuspiciousObject::isCanBeTop)\n            rest = rest.filterNot(SuspiciousObject::isCanBeTop)\n        }\n        println(if (rest.size == 1) \"SAFE\" else \"SUSPICIOUS\")\n    }\n}\n\ndata class Point(val x:Int, val y:Int)\ninterface SuspiciousObject{\n    fun addAppearPoint(point:Point):Unit\n    fun addOverlapObjectUnlessSame(other:SuspiciousObject):Unit\n    fun addCoverObjectUnlessSame(other:SuspiciousObject):Unit\n    val isCanBeTop:Boolean\n    fun useAsTop():Unit\n    fun isOverlapPosition(point:Point):Boolean\n}\n\nobject NoObject:SuspiciousObject {\n    override fun addAppearPoint(point: Point) {}\n    override fun addOverlapObjectUnlessSame(other: SuspiciousObject) {}\n    override fun addCoverObjectUnlessSame(other: SuspiciousObject) {}\n    override val isCanBeTop: Boolean\n            get() = false\n    override fun useAsTop() {}\n    override fun isOverlapPosition(point: Point): Boolean = true\n}\n\nclass Something:SuspiciousObject {\n    private var minX:Int = Int.MAX_VALUE\n    private var maxX:Int = Int.MIN_VALUE\n    private var minY:Int = Int.MAX_VALUE\n    private var maxY:Int = Int.MIN_VALUE\n    private val mUnder:Stack<SuspiciousObject> = Stack()\n    private var mOverCount:Int = 0\n    private val mOver:Stack<SuspiciousObject> = Stack()\n    override fun addAppearPoint(point: Point) {\n        if (minX > point.x)\n            minX = point.x\n        if (maxX < point.x)\n            maxX = point.x\n        if (minY > point.y)\n            minY = point.y\n        if (maxY < point.y)\n            maxY = point.y\n    }\n\n    override fun addOverlapObjectUnlessSame(other: SuspiciousObject) {\n        if (this == other || mUnder.contains(other)) return\n        mUnder.push(other)\n    }\n\n    override fun addCoverObjectUnlessSame(other: SuspiciousObject) {\n        if (this == other || mOver.contains(other)) return\n        mOver.push(other)\n        ++mOverCount\n    }\n\n    override val isCanBeTop: Boolean\n        get() = mOverCount == 0\n\n    override fun useAsTop() {\n        mUnder.forEach {\n            when(it){\n                is Something -> it.mOverCount--\n                else ->{}\n            }\n        }\n    }\n\n    override fun isOverlapPosition(point: Point): Boolean {\n        return point.x in (minX .. maxX) && point.y in (minY .. maxY)\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\n\nimport static java.lang.System.*;\nimport static java.lang.Math.*;\n\nclass Main {\n\tpublic static Random rand=new Random();\n\n\tstatic boolean next_permutation(int[]as) {//早い\n\t\tint n = as.length;\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tif (as[i - 1] < as[i]) {\n\t\t\t\tint j = n;\n\t\t\t\twhile (as[i - 1] >= as[--j]);\n\t\t\t\tswap(as, i - 1, j);\n\t\t\t\treverse(as, i, n);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic void swap(int[] is, int i, int j) {\n\t\tint t = is[i];\n\t\tis[i] = is[j];\n\t\tis[j] = t;\n\t}\n\tstatic void reverse(int[] is, int s, int t) {\n\t\twhile (s < --t) swap(is, s++, t);\n\t}\n\n\tpublic void run() {\n\t\tint n=sc.nextInt();\n\t\tCase:while(n--!=0){\n\t\t\tint H=sc.nextInt(),W=sc.nextInt();\n\t\t\tchar[][] map=new char[H][W];\n\t\t\tfor(int i=0;i<H;i++)map[i]=sc.next().toCharArray();\n\n\t\t\t//全探索\n\t\t\tSet<Character> keys=new HashSet<Character>();\n\t\t\tfor(int h=0;h<H;h++)for(int w=0;w<W;w++){\n\t\t\t\tif(Character.isUpperCase(map[h][w])){\n\t\t\t\t\tkeys.add(map[h][w]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint N=keys.size();\n\t\t\tint[] p=new int[N];for(int i=0;i<N;i++)p[i]=i;\n\n\t\t\tchecking:do{\n\t\t\t\tSet<Character> usechar=new HashSet<Character>();\n\t\t\t\t//check\n\t\t\t\tfor(char key:keys){\n\t\t\t\t\tusechar.add(key);\n\t\t\t\t\tint wmin=Integer.MAX_VALUE,hmin=Integer.MAX_VALUE,\n\t\t\t\t\twmax=0,hmax=0;\n\t\t\t\t\tfor(int _h=0;_h<H;_h++)for(int _w=0;_w<W;_w++){\n\t\t\t\t\t\tif(map[_h][_w]==key){\n\t\t\t\t\t\t\twmin=min(_w,wmin);\n\t\t\t\t\t\t\twmax=max(_w,wmax);\n\t\t\t\t\t\t\thmin=min(_h,hmin);\n\t\t\t\t\t\t\thmax=max(_h,hmax);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t                //rectangle check\n\t                boolean isRect=true;\n\t                for(int _h=hmin;_h<=hmax;_h++)for(int _w=wmin;_w<=wmax;_w++){\n\t                \t if(!usechar.contains(map[_h][_w]))isRect=false;\n\t                }\n\t                 if(!isRect)continue checking;\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tln(\"SAFE\");continue Case;\n\t\t\t}while(next_permutation(p));\n\t\t\tln(\"SUSPICIOUS\");\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t// from this\n//\t\tstatic BufferedReader in;\n//\t\tstatic PrintWriter out;\n//\t\tstatic {\n//\t    \ttry {\n//\t\t\t\tin =new BufferedReader(new FileReader(\"file.in\")); Project/file.in\n//\t\t\t\tout=new PrintWriter(new BufferedWriter(new FileWriter(\"file.out\")));\n//\t    \t} catch (IOException e) {\n//\t\t\t\te.printStackTrace();\n//\t\t\t}\n\t//  }\n\t// end\n\n\tstatic Scanner sc=new Scanner(in);\n\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\t//depth ex A[10]…1 A[10][10]…2 exception A[0]…0 A[10][0]…1 A[0][0]…0\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\n\t\t\tchar[][] result = new char[h][];\n\t\t\tfor (int j = 0; j < result.length; j++) {\n\t\t\t\tString line = sc.next();\n\t\t\t\tresult[j] = line.toCharArray();\n\t\t\t}\n\n\t\t\tMap<Character, Integer[]> map = new HashMap<Character, Integer[]>();\n\t\t\tMap<Character, Boolean> isUsed = new HashMap<Character, Boolean>();\n\t\t\tDeque<Character> deque = new ArrayDeque<Character>();\n\t\t\tchar first = '.';\n\t\t\tfor (int j = 0; j < result.length; j++) {\n\t\t\t\tfor (int k = 0; k < result[j].length; k++) {\n\t\t\t\t\tif (result[j][k] != '.') {\n\t\t\t\t\t\tif (map.get(result[j][k]) == null) {\n\t\t\t\t\t\t\tInteger[] put = { j, k, j, k };\n\t\t\t\t\t\t\tmap.put(result[j][k], put);\n\t\t\t\t\t\t\tisUsed.put(result[j][k], false);\n\t\t\t\t\t\t\tif (deque.isEmpty()) {\n\t\t\t\t\t\t\t\tdeque.add(result[j][k]);\n\t\t\t\t\t\t\t\tfirst = result[j][k];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tInteger[] get = map.get(result[j][k]);\n\t\t\t\t\t\t\tmap.get(result[j][k])[0] = Math.min(get[0], j);\n\t\t\t\t\t\t\tmap.get(result[j][k])[1] = Math.min(get[1], k);\n\t\t\t\t\t\t\tmap.get(result[j][k])[2] = Math.max(get[2], j);\n\t\t\t\t\t\t\tmap.get(result[j][k])[3] = Math.max(get[3], k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean safe = true;\n\t\t\tcheck: while (!deque.isEmpty()) {\n\t\t\t\tchar key = deque.poll();\n\t\t\t\tInteger[] get = map.get(key);\n\t\t\t\tif (isUsed.get(key)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisUsed.put(key, true);\n\n\t\t\t\tfor (int j = get[0]; j <= get[2]; j++) {\n\t\t\t\t\tfor (int k = get[1]; k <= get[3]; k++) {\n\t\t\t\t\t\tif (result[j][k] == '.'\n\t\t\t\t\t\t\t\t|| (result[j][k] != key && result[j][k] == first)) {\n\t\t\t\t\t\t\t// 明らかに長方形でない時、もう見た文字の時\n\t\t\t\t\t\t\tSystem.out.println(\"SUSPICIOUS\");\n\t\t\t\t\t\t\tsafe = false;\n\t\t\t\t\t\t\tbreak check;\n\t\t\t\t\t\t} else if (result[j][k] != key) {\n\t\t\t\t\t\t\t// 別の文字がかぶっている時\n\t\t\t\t\t\t\tdeque.add(result[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (deque.isEmpty()) {\n\t\t\t\t\tfor (Character nextKey : map.keySet()) {\n\t\t\t\t\t\tif (!isUsed.get(nextKey)) {\n\t\t\t\t\t\t\tdeque.add(nextKey);\n\t\t\t\t\t\t\tfirst = nextKey;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (safe) {\n\t\t\t\tSystem.out.println(\"SAFE\");\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package p2002;\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\n\nimport static java.lang.System.*;\nimport static java.lang.Math.*;\n\nclass Main {\n\tpublic static Random rand=new Random();\n\n\tstatic boolean next_permutation(int[]as) {//早い\n\t\tint n = as.length;\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tif (as[i - 1] < as[i]) {\n\t\t\t\tint j = n;\n\t\t\t\twhile (as[i - 1] >= as[--j]);\n\t\t\t\tswap(as, i - 1, j);\n\t\t\t\treverse(as, i, n);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic void swap(int[] is, int i, int j) {\n\t\tint t = is[i];\n\t\tis[i] = is[j];\n\t\tis[j] = t;\n\t}\n\tstatic void reverse(int[] is, int s, int t) {\n\t\twhile (s < --t) swap(is, s++, t);\n\t}\n\n\tpublic void run() {\n\t\tint n=sc.nextInt();\n\t\tCase:while(n--!=0){\n\t\t\tint H=sc.nextInt(),W=sc.nextInt();\n\t\t\tchar[][] map=new char[H][W];\n\t\t\tfor(int i=0;i<H;i++)map[i]=sc.next().toCharArray();\n\n\t\t\t//全探索\n\t\t\tSet<Character> keys=new HashSet<Character>();\n\n\t\t\tfor(int h=0;h<H;h++)for(int w=0;w<W;w++){\n\t\t\t\tif(Character.isUpperCase(map[h][w])){\n\t\t\t\t\tkeys.add(map[h][w]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint N=keys.size();\n\t\t\tint[] p=new int[N];for(int i=0;i<N;i++)p[i]=i;\n\n\t\t\tchecking:do{\n\t\t\t\tSet<Character> usechar=new HashSet<Character>();\n\t\t\t\t//check\n\t\t\t\tfor(char key:keys){\n\t\t\t\t\tusechar.add(key);\n\t\t\t\t\tint wmin=Integer.MAX_VALUE,hmin=Integer.MAX_VALUE,\n\t\t\t\t\twmax=0,hmax=0;\n\t\t\t\t\tfor(int _h=0;_h<H;_h++)for(int _w=0;_w<W;_w++){\n\t\t\t\t\t\tif(map[_h][_w]==key){\n\t\t\t\t\t\t\twmin=min(_w,wmin);\n\t\t\t\t\t\t\twmax=max(_w,wmax);\n\t\t\t\t\t\t\thmin=min(_h,hmin);\n\t\t\t\t\t\t\thmax=max(_h,hmax);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t                //rectangle check\n\t                boolean isRect=true;\n\t                for(int _h=hmin;_h<=hmax;_h++)for(int _w=wmin;_w<wmax;_w++){\n\t                \t if(!usechar.contains(map[_h][_w]))isRect=false;\n\t                }\n\t                 if(!isRect)continue checking;\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tln(\"SAFE\");continue Case;\n\t\t\t}while(next_permutation(p));\n\t\t\tln(\"SUSPICIOUS\");\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t// from this\n//\t\tstatic BufferedReader in;\n//\t\tstatic PrintWriter out;\n//\t\tstatic {\n//\t    \ttry {\n//\t\t\t\tin =new BufferedReader(new FileReader(\"file.in\")); Project/file.in\n//\t\t\t\tout=new PrintWriter(new BufferedWriter(new FileWriter(\"file.out\")));\n//\t    \t} catch (IOException e) {\n//\t\t\t\te.printStackTrace();\n//\t\t\t}\n\t//  }\n\t// end\n\n\tstatic Scanner sc=new Scanner(in);\n\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\t//depth ex A[10]…1 A[10][10]…2 exception A[0]…0 A[10][0]…1 A[0][0]…0\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain p = new Main();\n\t}\n\n\tint h;\n\tint w;\n\tStringBuilder map;\n\tList<int[]> c;\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tc = new LinkedList<int[]>();\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tmap = new StringBuilder();\n\t\t\tfor(int j=0;j<h;j++)\n\t\t\t\tmap.append(sc.next());\n\t\t\t\n\t\t\tSystem.out.println(solve() ? \"SAFE\" : \"SUSPICIOUS\");\n\t\t}\n\t\t\n\t}\n\n\tpublic boolean solve() {\n\t\tint[][] alpha = new int[26][5];\n\t\tfor(int i=0;i<alpha.length;i++){\n\t\t\talpha[i][1] = alpha[i][2] = 10000000;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tint ch = map.charAt(i*w+j) - 'A';\n\t\t\t\tif(ch+'A'=='.')\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\talpha[ch][0]++;\n\t\t\t\talpha[ch][1] = Math.min(alpha[ch][1], i);\n\t\t\t\talpha[ch][2] = Math.min(alpha[ch][2], j);\n\t\t\t\talpha[ch][3] = Math.max(alpha[ch][3], i);\n\t\t\t\talpha[ch][4] = Math.max(alpha[ch][4], j);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<alpha.length;i++){\n\t\t\tif(alpha[i][0]>0){\n\t\t\t\talpha[i][0] = i+'A';\n\t\t\t\tc.add(alpha[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cur = 0;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0;i<h*w;i++)\n\t\t\tsb.append('.');\n\t\treturn rec(cur, sb);\n\t\t\n\t}\n\n\tprivate boolean rec(int cur, StringBuilder sb) {\n\t\tif(cur == (1<<c.size())-1)\n\t\t\treturn isOk(sb.toString());\n\t\t\n\t\tboolean res = false;\n//\t\tStringBuilder sb = new StringBuilder(s);\n\t\t\n\t\tfor(int i=0;i<c.size();i++){\n\t\t\tif(((1<<i) & cur) > 0)\n\t\t\t\tcontinue;\n//\t\t\t\n//\t\t\tsb.delete(0, sb.length());\n//\t\t\tsb.append(s);\n\t\t\t\n\t\t\t\n\t\t\tint[] ca = c.get(i);\n\t\t\tchar ch = (char) ca[0];\n\t\t\tfor(int j=ca[1];j<=ca[3];j++){\n\t\t\t\tfor(int k=ca[2];k<=ca[4];k++){\n\t\t\t\t\tsb.setCharAt(j*w+k, ch);\n\t\t\t\t}\n\t\t\t}\n\t\t\tres |= rec(cur|(1<<i), sb);\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\n\tprivate boolean isOk(String string) {\n\t\treturn map.toString().equals(string);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  class Rect {\n    char id;\n    int index;\n    int xmin;\n    int xmax;\n    int ymin;\n    int ymax;\n  }\n\n  int w, h;\n  char[][] field;\n\n  boolean check(ArrayList<Rect> list) {\n    HashMap<Character, Integer> map = new HashMap<>();\n    for (Rect rect : list) {\n      map.put(rect.id, rect.index);\n    }\n    map.put('.', INF);\n    boolean ans = true;\n    for (Rect rect : list) {\n      for (int i = rect.ymin; i <= rect.ymax; ++i) {\n        for (int j = rect.xmin; j <= rect.xmax; ++j) {\n          char c = field[i][j];\n          ans &= map.get(c) <= rect.index;\n        }\n      }\n    }\n    return ans;\n  }\n\n  boolean dfs(ArrayList<Rect> list, boolean[] done, int depth) {\n    if (depth >= list.size()) {\n      return check(list);\n    }\n    boolean ans = false;\n    for (int i = 0; i < list.size(); ++i) {\n      if (!done[i]) {\n        done[i] = true;\n        list.get(depth).index = i;\n        ans |= dfs(list, done, depth + 1);\n        done[i] = false;\n      }\n    }\n    return ans;\n  }\n\n  void run() {\n    int n = ni();\n    for (int t = 0; t < n; ++t) {\n      h = ni();\n      w = ni();\n      field = new char[h][w];\n      HashSet<Character> set = new HashSet<>();\n      for (int i = 0; i < h; ++i) {\n        String str = sc.next();\n        for (int j = 0; j < w; ++j) {\n          field[i][j] = str.charAt(j);\n          if (field[i][j] != '.') {\n            set.add(field[i][j]);\n          }\n        }\n      }\n      boolean[] done = new boolean[set.size()];\n      ArrayList<Rect> list = new ArrayList<>();\n      HashMap<Character, Rect> map = new HashMap<>();\n      for (Character c : set) {\n        Rect rect = new Rect();\n        rect.id = c;\n        rect.index = -1;\n        rect.xmax = rect.ymax = -INF;\n        rect.xmin = rect.ymin = INF;\n        list.add(rect);\n        map.put(c, rect);\n      }\n      for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n          if (field[i][j] != '.') {\n            Rect rect = map.get(field[i][j]);\n            rect.xmax = Math.max(rect.xmax, j);\n            rect.xmin = Math.min(rect.xmin, j);\n            rect.ymax = Math.max(rect.ymax, i);\n            rect.ymin = Math.min(rect.ymin, i);\n          }\n        }\n      }\n      System.out.println(dfs(list, done, 0) ? \"SAFE\" : \"SUSPICIOUS\");\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Rectangle;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic Rectangle[] rec = new Rectangle[26];\n\tstatic boolean[] check = new boolean[26];\n\t\n\tpublic static void main(String[] args) {\n\t\tint n;\n\t\tn = sc.nextInt();\t// input\n\t\twhile(n-- > 0) {\n\t\t\tfor(int i=0; i < 26; i++) {\t// initialize\n\t\t\t\trec[i] = new Rectangle();\n\t\t\t\trec[i].x = rec[i].y = 50;\n\t\t\t\trec[i].width = rec[i].height = 0;\n\t\t\t\tcheck[i] = false;\n\t\t\t}\n\t\t\tHashSet<Integer> count = new HashSet<Integer>();\n\t\t\tint h, w;\n\t\t\th = sc.nextInt();\t// input\n\t\t\tw = sc.nextInt();\t// input\n\t\t\tint map[][] = new int[h][w];\n\t\t\tfor(int y=0; y < h; y++) {\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor(int x=0; x < w; x++) {\n\t\t\t\t\tmap[y][x] = (int)str.charAt(x); // input\n\t\t\t\t\tif(map[y][x] == '.') continue;\n\t\t\t\t\tint idx = map[y][x] - 'A';\n\t\t\t\t\tif(rec[idx].x > x) rec[idx].x = x;\t\t\t\t// start\n\t\t\t\t\tif(rec[idx].y > y) rec[idx].y = y;\t\t\t\t// start\n\t\t\t\t\tif(rec[idx].width < x) rec[idx].width = x;\t\t// end\n\t\t\t\t\tif(rec[idx].height < h) rec[idx].height = y;\t// end\n\t\t\t\t\tcheck[idx] = true; count.add(idx);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = 0;\n\t\t\tboolean flg = true;\n\t\t\twhile(flg) {\n\t\t\t\tflg = false;\n\t\t\t\tfor(int i=0; i < 26; i++) {\n\t\t\t\t\tif(check[i]){\n\t\t\t\t\t\tint mozi = 'A' + i;\n\t\t\t\t\t\tboolean success = true;\n\t\t\t\t\t\tfor(int y=rec[i].y; y <= rec[i].height; y++)\n\t\t\t\t\t\t\tfor(int x=rec[i].x; x <= rec[i].width; x++){\n\t\t\t\t\t\t\t\tif(map[y][x] != mozi && map[y][x] != -1) {\n\t\t\t\t\t\t\t\t\tsuccess = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tif(success){\n\t\t\t\t\t\t\tfor(int y=rec[i].y; y <= rec[i].height; y++)\n\t\t\t\t\t\t\t\tfor(int x=rec[i].x; x <= rec[i].width; x++){\n\t\t\t\t\t\t\t\t\tmap[y][x] = -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\tcheck[i] = false;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt == count.size())\n\t\t\t\tSystem.out.println(\"SAFE\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"SUSPICIOUS\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.ReadableByteChannel;\n\npublic class Main {\n    static final ByteBuffer buf = ByteBuffer.allocate(1000000);\n    static final ReadableByteChannel in = Channels.newChannel(System.in);\n    static final int NAME = 0;\n    static final int T = 1;// top;\n    static final int B = 2;// Bottom;\n    static final int L = 3;// left;\n    static final int R = 4;// right;\n    static final int UNDERS = 5;\n\n    public static void main(String[] args) throws IOException {\n\tinit();\n\tint n = getInt();\n\tfor (int i = 0; i < n; i++) {\n\t    int h = getInt();\n\t    int w = getInt();\n\t    byte[][] box = new byte[h][w];\n\t    int[][] item = new int[7][6];\n\t    int count = 0;\n\t    for (int y = 0; y < h; y++) {\n\t\tgetLine(box[y]);\n\t\tfor (int x = 0; x < w; x++) {\n\t\t    final byte c = box[y][x];\n\t\t    if (c != '.') {\n\t\t\tfor (int k = 0; k < 7; k++) {\n\t\t\t    if (item[k][NAME] == 0) {\n\t\t\t\titem[k][NAME] = c;\n\t\t\t\titem[k][T] = item[k][B] = y;\n\t\t\t\titem[k][L] = item[k][R] = x;\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t    } else if (item[k][NAME] == c) {\n\t\t\t\tif (item[k][B] != y) {\n\t\t\t\t    item[k][B] = y;\n\t\t\t\t}\n\t\t\t\tif (x < item[k][L]) {\n\t\t\t\t    item[k][L] = x;\n\t\t\t\t} else if (item[k][R] < x) {\n\t\t\t\t    item[k][R] = x;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    boolean isSUSPICIOUS = false;\n\t    for (int num = 0; !isSUSPICIOUS && num < count; num++) {\n\t\tfor (int y = item[num][T]; !isSUSPICIOUS && y <= item[num][B]; y++) {\n\t\t    for (int x = item[num][L]; !isSUSPICIOUS\n\t\t\t    && x <= item[num][R]; x++) {\n\t\t\tfinal byte parts = box[y][x];\n\t\t\tif (parts != item[num][NAME]) {\n\t\t\t    if (parts == '.') {\n\t\t\t\tisSUSPICIOUS = true;\n\t\t\t    } else {\n\t\t\t\tint partsNum;\n\t\t\t\tfor (int j = 0; j < count; j++) {\n\t\t\t\t    if (item[j][0] == parts) {\n\t\t\t\t\tpartsNum = j;\n\t\t\t\t\tisSUSPICIOUS = !setUnders(item, num,\n\t\t\t\t\t\tpartsNum);\n\t\t\t\t\tbreak;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    System.out.println(isSUSPICIOUS ? \"SUSPICIOUS\" : \"SAFE\");\n\n\t}\n\n    }\n\n    private static boolean setUnders(int[][] item, int num, int partsNum) {\n\tif (num == partsNum) {\n\t    return false;\n\t}\n\tfor (int i = 0; i < 7; i++) {\n\t    if ((item[num][UNDERS] & getLayer(i)) != 0) {\n\t\tif (!setUnders(item, i, partsNum)) {\n\t\t    return false;\n\t\t}\n\t    }\n\t}\n\titem[partsNum][UNDERS] |= getLayer(num);\n\treturn true;\n    }\n\n    static int getLayer(int i) {\n\treturn 1 << i;\n    }\n\n    static void init() throws IOException {\n\tbuf.clear();\n\tin.read(buf);\n\tbuf.flip();\n    }\n\n    static int getInt() {\n\tbyte b = buf.get();\n\twhile (b < '0' || '9' < b) {\n\t    b = buf.get();\n\t}\n\tint result = 0;\n\twhile ('0' <= b && b <= '9') {\n\t    result = result * 10 + (b - '0');\n\t    b = buf.get();\n\t}\n\treturn result;\n    }\n\n    static void getLine(byte[] array) {\n\tbyte b = buf.get();\n\twhile (b != '.' && (b < 'A' || 'Z' < b)) {\n\t    b = buf.get();\n\t}\n\tbuf.position(buf.position() - 1);\n\tbuf.get(array);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain p = new Main();\n\t}\n\n\tint h;\n\tint w;\n\tStringBuilder map;\n\tList<int[]> c;\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tc = new LinkedList<int[]>();\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tmap = new StringBuilder();\n\t\t\tfor(int j=0;j<h;j++)\n\t\t\t\tmap.append(sc.next());\n\t\t\t\n\t\t\tSystem.out.println(solve() ? \"SAFE\" : \"SUSPICIOUS\");\n\t\t}\n\t\t\n\t}\n\n\tpublic boolean solve() {\n\t\tint[][] alpha = new int[26][5];\n\t\tfor(int i=0;i<alpha.length;i++){\n\t\t\talpha[i][1] = alpha[i][2] = 10000000;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tint ch = map.charAt(i*w+j) - 'A';\n\t\t\t\tif(ch+'A'=='.')\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\talpha[ch][0]++;\n\t\t\t\talpha[ch][1] = Math.min(alpha[ch][1], i);\n\t\t\t\talpha[ch][2] = Math.min(alpha[ch][2], j);\n\t\t\t\talpha[ch][3] = Math.max(alpha[ch][3], i);\n\t\t\t\talpha[ch][4] = Math.max(alpha[ch][4], j);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<alpha.length;i++){\n\t\t\tif(alpha[i][0]>0){\n\t\t\t\talpha[i][0] = i+'A';\n\t\t\t\tc.add(alpha[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cur = 0;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0;i<h*w;i++)\n\t\t\tsb.append('.');\n\t\treturn rec(cur, sb);\n\t\t\n\t}\n\n\tprivate boolean rec(int cur, StringBuilder sb) {\n\t\tif(cur == (1<<c.size())-1)\n\t\t\treturn isOk(sb);\n\t\t\n\t\tboolean res = false;\n\t\t\n\t\tfor(int i=0;i<c.size();i++){\n\t\t\tif(((1<<i) & cur) > 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint[] ca = c.get(i);\n\t\t\tchar ch = (char) ca[0];\n\t\t\tfor(int j=ca[1];j<=ca[3];j++){\n\t\t\t\tfor(int k=ca[2];k<=ca[4];k++){\n\t\t\t\t\tsb.setCharAt(j*w+k, ch);\n\t\t\t\t}\n\t\t\t}\n\t\t\tres |= rec(cur|(1<<i), sb);\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\n\tprivate boolean isOk(StringBuilder sb) {\n\t\tfor(int i=0;i<sb.length();i++)\n\t\t\tif(map.charAt(i) != sb.charAt(i))\n\t\t\t\treturn false;\n\t\t\n\t\treturn true;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic int h;\n\tstatic int w;\n\tstatic char[][] map;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor(int z = 0; z < n; z++) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tmap = new char[h][w];\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tIN:while(!clear()) {\n\t\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\t\tif(map[i][j] != '.') {\n\t\t\t\t\t\t\tif(isRect(i,j)) {\n\t\t\t\t\t\t\t\tremove(i,j);\n\t\t\t\t\t\t\t\tcontinue IN;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println((clear())?\"SAFE\":\"SUSPICIOUS\");\n\t\t\t\n\t\t}\n\t}\n\tpublic static void remove(int a, int b) {\n\t\tchar t = map[a][b];\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(map[i][j] == t) {\n\t\t\t\t\tmap[i][j] = '0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static boolean isRect(int a, int b) {\n\t\tchar c = map[a][b];\n\t\tchar[][] map = new char[h][w];\n\t\t\n\t\tIN:for(int k = a; k < h; k++) {\n\t\t\tIX:for(int l = b; l < w; l++) {\n\t\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\t\tmap[i] = Arrays.copyOf(Main.map[i],w);\n\t\t\t\t}\n\t\t\t\tfor(int i = a; i <= k; i++) {\n\t\t\t\t\tfor(int j = b; j <= l; j++) {\n\t\t\t\t\t\tif(c == '0' && map[i][j] != c) {\n\t\t\t\t\t\t\tc = map[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map[i][j] == c) {\n\t\t\t\t\t\t\tmap[i][j] = '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map[i][j] != c && map[i][j] != '0') continue IN;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\t\tif(map[i][j] == c) continue IX;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tMain.map[a][b] = c;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static boolean clear() {\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(map[i][j] != '.' && map[i][j] != '0') return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.lang.ArrayIndexOutOfBoundsException;\nimport java.math.BigInteger;\n\n/**\n * @author yoshikyoto\n */\nclass Main extends MyUtil{\n\tpublic static void main(String[] args) throws Exception{\n\t\tint n = readInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint h = readIntMap(0);\n\t\t\tint w = readIntMap(1);\n\t\t\tchar[][] c = new char[h][];\n\t\t\tfor (int j = 0; j < h; j++) {\n\t\t\t\tc[j] = readLine().toCharArray();\n\t\t\t}\n\t\t\tif(solve(c, h, w)){\n\t\t\t\tSystem.out.println(\"SAFE\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"SUSPICIOUS\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic boolean solve(char[][] c, int h, int w){\n\t\t// System.out.println(\"solve\");\n\t\twhile(checkThisTurn(c, h, w));\n\t\t// 全部消えたかチェック\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif(c[i][j] != '.' && c[i][j] != '*'){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic boolean checkThisTurn(char[][] c, int h, int w){\n\t\t// System.out.println(\"turn check\");\n\t\tHashSet<Character> checked = new HashSet<Character>();\n\t\tchecked.add('.');\n\t\tchecked.add('*');\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif(!checked.contains(c[i][j])){\n\t\t\t\t\t// System.out.println(c[i][j]);\n\t\t\t\t\tif(checkRect(c, h, w, c[i][j])){\n\t\t\t\t\t\t// 長方形だったら\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// 長方形でなかったら\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// このターンでは確認済み\n\t\t\t\tchecked.add(c[i][j]);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tstatic boolean checkRect(char[][] c, int h, int w, char target){\n\t\tint top = h, bottom = 0, left = w, right = 0;\n\t\t// 上下左右の端を確認\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif(c[i][j] == target){\n\t\t\t\t\ttop = Math.min(top, i);\n\t\t\t\t\tbottom = Math.max(bottom, i);\n\t\t\t\t\tleft = Math.min(left, j);\n\t\t\t\t\tright = Math.max(right, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// そこが埋まっているか確認\n\t\tif(isFilled(c, h, w, target, top, bottom, left, right)){\n\t\t\t//埋まってる\n\t\t\tfor(int i = top; i <= bottom; i++){\n\t\t\t\tfor(int j = left; j <= right; j++){\n\t\t\t\t\t// 次からワイルとカードとして扱える\n\t\t\t\t\tc[i][j] = '*';\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}else{\n\t\t\t//埋まってない\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tstatic boolean isFilled(char[][] c, int h, int w, int target,\n\t\t\tint top, int bottom, int left, int right){\n\t\tfor(int i = top; i <= bottom; i++){\n\t\t\tfor(int j = left; j <= right; j++){\n\t\t\t\tif(c[i][j] != target && c[i][j] != '*'){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\n\n\nclass BinaryIndexedTree{\n    int n;\n    int[] bit;\n    BinaryIndexedTree(int n){\n        this.n = n;\n        bit = new int[n+1];\n    }\n    int sum(int i){\n        int sum = 0;\n        while(i > 0){\n            sum += bit[i];\n            i -= i & -i;\n        }\n        return sum;\n    }\n    void add(int i, int v){\n        while(i <= n){\n            bit[i] += v;\n            i += i & -i;\n        }\n    }\n}\n\n\n// --- ここから下はライブラリ ----------\n/**\n * MyUtil\n * @author yoshikyoto\n */\nclass MyUtil {\n\tpublic static int toInt(boolean[] a){\n\t\tint pow = 1, ret = 0, l = a.length;\n\t\tfor(int i = 0; i < l; i++){\n\t\t\tif(a[i]) ret += pow;\n\t\t\tpow *= 2;\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static int ins[];\n\tpublic static int[] readIntMap() throws IOException{return parseInt(readLine().split(\" \"));}\n\tpublic static int readIntMap(int i) throws Exception{\n\t\tif(i == 0) ins = readIntMap();\n\t\treturn ins[i];\n\t}\n\tpublic static int[][] readIntMap(int n, int m) throws IOException{\n\t\tint[][] ret = new int[n][];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readIntMap();\n\t\treturn ret;\n\t}\n\tpublic static int[] readIntToMap(int n) throws IOException{\n\t\tint[] ret = new int[n];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readInt();\n\t\treturn ret;\n\t}\n\tpublic static int[] readNoDistIntMap() throws IOException{\n\t\tString[] strs = readLine().split(\"\");\n\t\tint l = strs.length;\n\t\tint[] ret = new int[l-1];\n\t\tfor(int i = 1; i < l; i++)\n\t\t\tret[i-1] = parseInt(strs[i]);\n\t\treturn ret;\n\t}\n\tpublic static String readLine() throws IOException{return br.readLine();}\n\tpublic static int readInt() throws IOException{return Integer.parseInt(br.readLine());}\n\tpublic static int[] parseInt(String[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static double[] parseDouble(String[] arr){\n\t\tdouble[] res = new double[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Double.parseDouble(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static boolean[] parseBool(String[] arr){\n\t\tint[] t = parseInt(arr);\n\t\tboolean[] res = new boolean[t.length];\n\t\tfor(int i = 0; i < t.length; i++){\n\t\t\tif(t[i] == 1){res[i] = true;\n\t\t\t}else{res[i] = false;}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int parseInt(Object o){\n\t\treturn Integer.parseInt(o.toString());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic char[][] f;\n\tstatic int H, W;\n\tstatic char FILL = '!';\n\n\tpublic static void main(String[] args) {\n\t\tint N = sc.nextInt();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tH = sc.nextInt();\n\t\t\tW = sc.nextInt();\n\t\t\tf = new char[H][W];\n\t\t\tfor (int j = 0; j < H; ++j) {\n\t\t\t\tf[j] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tSystem.out.println(solve() ? \"SUSPICIOUS\" : \"SAFE\");\n\t\t}\n\t}\n\n\tstatic boolean solve() {\n\t\tint[] t = new int[26];\n\t\tint[] b = new int[26];\n\t\tint[] l = new int[26];\n\t\tint[] r = new int[26];\n\t\tboolean[] exist = new boolean[26];\n\t\tArrays.fill(t, 99);\n\t\tArrays.fill(b, -1);\n\t\tArrays.fill(l, 99);\n\t\tArrays.fill(r, -1);\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (Character.isUpperCase(f[i][j])) {\n\t\t\t\t\tint pos = f[i][j] - 'A';\n\t\t\t\t\tt[pos] = Math.min(t[pos], i);\n\t\t\t\t\tb[pos] = Math.max(b[pos], i);\n\t\t\t\t\tl[pos] = Math.min(l[pos], j);\n\t\t\t\t\tr[pos] = Math.max(r[pos], j);\n\t\t\t\t\texist[pos] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 8; ++i) {\n\t\t\tfor (int j = 0; j < 26; ++j) {\n\t\t\t\tif (!exist[j]) continue;\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor (int row = t[j]; row <= b[j]; ++row) {\n\t\t\t\t\tfor (int col = l[j]; col <= r[j]; ++col) {\n\t\t\t\t\t\tif (f[row][col] != (char) (j + 'A') && f[row][col] != FILL) ok = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tfor (int row = t[j]; row <= b[j]; ++row) {\n\t\t\t\t\t\tfor (int col = l[j]; col <= r[j]; ++col) {\n\t\t\t\t\t\t\tf[row][col] = FILL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\texist[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 26; ++i) {\n\t\t\tif (exist[i]) return true;\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint MAX = 7;\n\tint MAXL = 50;\n\tint h, w, n;\n\tchar[][] map;\n\tUnknown[] unknowns;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\tfor(;t>0;t--) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tif( (h|w) == 0 ) break;\n\t\t\t\n\t\t\tmap = new char[h][w];\n\t\t\tunknowns = new Unknown[MAX];\n\t\t\tn = 0;\n\t\t\tfor(int i=0;i<h;i++) {\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor(int j=0;j<w;j++) {\n\t\t\t\t\tmap[i][j] = str.charAt(j);\n\t\t\t\t\tif( map[i][j] != '.' ) {\n\t\t\t\t\t\tchar c = map[i][j];\n\t\t\t\t\t\tfor(int k=0;k<n;k++) {\n\t\t\t\t\t\t\tif( c == unknowns[k].c) {\n\t\t\t\t\t\t\t\tc = '#';\n\t\t\t\t\t\t\t\tunknowns[k].set(j, i);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( c != '#' ) {\n\t\t\t\t\t\t\tunknowns[n] = new Unknown(c);\n\t\t\t\t\t\t\tunknowns[n++].set(j,i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println( (isRect()? \"SAFE\": \"SUSPICIOUS\") );\n\t\t}\n\t}\n\t\n\tboolean isRect() {\n\t\tHashMap<Character, Integer> char2int = new HashMap<Character, Integer>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tchar2int.put(unknowns[i].c, i);\n\t\t\tfor(int x=unknowns[i].minx;x<=unknowns[i].maxx;x++)\n\t\t\tfor(int y=unknowns[i].miny;y<=unknowns[i].maxy;y++) {\n\t\t\t\tif(map[y][x] == '.') {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif(unknowns[i].c != map[y][x]) unknowns[i].on(map[y][x]);\n\t\t\t}\t\t\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tboolean[] visited = new boolean[n];\n\t\t\tLinkedList<Integer> que = new LinkedList<Integer>();\n\t\t\tfor(char c: unknowns[i].on) que.add(char2int.get(c));\n\t\t\twhile(!que.isEmpty()) {\n\t\t\t\tint now = que.removeFirst();\n//\t\t\t\tdebug(i, now);\n\t\t\t\tif(now == i) return false;\n\t\t\t\tfor(char c: unknowns[now].on) if(!visited[char2int.get(c)]){\n\t\t\t\t\tvisited[char2int.get(c)] = true;\n\t\t\t\t\tque.add(char2int.get(c));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tclass Unknown {\n\t\tchar c;\n\t\tint minx, miny, maxx, maxy;\n\t\tHashSet<Character> on;\n\t\tUnknown(char c) {\n\t\t\ton = new HashSet<Character>();\n\t\t\tminx = miny = MAXL;\n\t\t\tmaxx = maxy = 0;\n\t\t\tthis.c = c;\n\t\t}\n\t\tvoid set(int x, int y) {\n\t\t\tminx = min(minx, x);\n\t\t\tminy = min(miny, y);\n\t\t\tmaxx = max(maxx, x);\n\t\t\tmaxy = max(maxy, y);\n\t\t}\n\t\tvoid on(char c) {\n\t\t\ton.add(c);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain p = new Main();\n\t}\n\n\tint h;\n\tint w;\n\tStringBuilder map;\n\tList<int[]> c;\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tc = new LinkedList<int[]>();\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tmap = new StringBuilder();\n\t\t\tfor(int j=0;j<h;j++)\n\t\t\t\tmap.append(sc.next());\n\t\t\t\n\t\t\tSystem.out.println(solve() ? \"SAFE\" : \"SUSPICIOUS\");\n\t\t}\n\t\t\n\t}\n\n\tpublic boolean solve() {\n\t\tint[][] alpha = new int[26][5];\n\t\tfor(int i=0;i<alpha.length;i++){\n\t\t\talpha[i][1] = alpha[i][2] = 10000000;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tint ch = map.charAt(i*w+j) - 'A';\n\t\t\t\tif(ch+'A'=='.')\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\talpha[ch][0]++;\n\t\t\t\talpha[ch][1] = Math.min(alpha[ch][1], i);\n\t\t\t\talpha[ch][2] = Math.min(alpha[ch][2], j);\n\t\t\t\talpha[ch][3] = Math.max(alpha[ch][3], i);\n\t\t\t\talpha[ch][4] = Math.max(alpha[ch][4], j);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<alpha.length;i++){\n\t\t\tif(alpha[i][0]>0){\n\t\t\t\talpha[i][0] = i+'A';\n\t\t\t\tc.add(alpha[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cur = 0;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0;i<h*w;i++)\n\t\t\tsb.append('.');\n\t\treturn rec(cur, sb.toString());\n\t\t\n\t}\n\n\tprivate boolean rec(int cur, String s) {\n\t\tif(cur == (1<<c.size())-1)\n\t\t\treturn isOk(s);\n\t\t\n\t\tboolean res = false;\n\t\tStringBuilder sb = new StringBuilder(s);\n\t\tfor(int i=0;i<c.size();i++){\n\t\t\tif(((1<<i) & cur) > 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tsb.delete(0, sb.length());\n\t\t\tsb.append(s);\n\t\t\t\n\t\t\t\n\t\t\tint[] ca = c.get(i);\n\t\t\tchar ch = (char) ca[0];\n\t\t\tfor(int j=ca[1];j<=ca[3];j++){\n\t\t\t\tfor(int k=ca[2];k<=ca[4];k++){\n\t\t\t\t\tsb.setCharAt(j*w+k, ch);\n\t\t\t\t}\n\t\t\t}\n\t\t\tres |= rec(cur|(1<<i), sb.toString());\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\n\tprivate boolean isOk(String string) {\n\t\treturn map.toString().equals(string);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint [] order;\n\tboolean [] used;\n\tint kind;\n\tboolean flg;\n\tint [][] pos;\n\tchar [][] data;\n\tArrayList<Character> kindchar;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint dataset = sc.nextInt();\n\t\twhile(dataset-- > 0){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif((h|w) == 0) break;\n\t\t\tdata = new char[h][w];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tdata[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\t\n\t\t\tint [] freq = new int[26];\n\t\t\tpos = new int[26][4]; //minx, miny, maxx, maxy\n\t\t\tfor(int i = 0; i < 26; i++){\n\t\t\t\tArrays.fill(pos[i], -1);\n\t\t\t}\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(data[i][j] == '.') continue;\n\t\t\t\t\tint ind = data[i][j] - 'A';\n\t\t\t\t\tfreq[ind]++;\n\t\t\t\t\tif(pos[ind][0] == -1){\n\t\t\t\t\t\tpos[ind][0] = j;\n\t\t\t\t\t\tpos[ind][2] = j;\n\t\t\t\t\t\tpos[ind][1] = i;\n\t\t\t\t\t\tpos[ind][3] = i;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpos[ind][0] = Math.min(pos[ind][0], j);\n\t\t\t\t\t\tpos[ind][1] = Math.min(pos[ind][1], i);\n\t\t\t\t\t\tpos[ind][2] = Math.max(pos[ind][2], j);\n\t\t\t\t\t\tpos[ind][3] = Math.max(pos[ind][3], i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tkind = 0;\n\t\t\tkindchar = new ArrayList<Character>();\n\t\t\tfor(int i = 0; i < 26; i++){\n\t\t\t\tif(freq[i] > 0){\n\t\t\t\t\tkindchar.add((char) (i + 'A'));\n\t\t\t\t}\n\t\t\t}\n\t\t\tkind = kindchar.size();\n\t\t\torder = new int[kind];\n\t\t\tused = new boolean[kind];\n\t\t\tflg = false;\n\t\t\tdfs(0);\n\t\t\tSystem.out.println(flg ? \"SAFE\" : \"SUSPICIOUS\");\n\t\t}\n\t}\n\n\tprivate void dfs(int deep) {\n\t\tif(deep == kind){\n\t\t\tif(check()) flg = true;\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < kind; i++){\n\t\t\tif(used[i]) continue;\n\t\t\tused[i] = true;\n\t\t\torder[deep] = i;\n\t\t\tdfs(deep + 1);\n\t\t\tused[i] = false;\n\t\t}\n\t}\n\n\tprivate boolean check() {\n\t\tboolean [] checked = new boolean[26];\n\t\tfor(int orderi = 0; orderi < order.length; orderi++){\n\t\t\tint nowind = order[orderi];\n\t\t\tchar nowchar = kindchar.get(nowind);\n\t\t\tint nowcharind = nowchar - 'A';\n\t\t\tchecked[nowcharind] = true;\n\t\t\t\n\t\t\tfor(int i = pos[nowcharind][1]; i <= pos[nowcharind][3]; i++){\n\t\t\t\tfor(int j = pos[nowcharind][0]; j <= pos[nowcharind][2]; j++){\n\t\t\t\t\tif(data[i][j] == '.') return false;\n\t\t\t\t\tif(checked[data[i][j] - 'A'] == false) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\tint n = sc.nextInt();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tcalc(h,w);\n\t\t\t\n\t\t}\n\t}\n\tHashMap<String, int[]> hash;\n\tHashMap<String, Integer> checkMap;\n\tString[][] map;\n\t\n\tpublic void calc(int h, int w){\n\t\thash = new HashMap<String, int[]>();\n\t\tcheckMap = new HashMap<String, Integer>();\n\t\tmap = new String[h][w];\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tString line = sc.next();\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tString now = line.substring(j, j+1);\n\t\t\t\tmap[i][j] = now;\n\t\t\t\tif(!hash.containsKey(now)) {\n\t\t\t\t\thash.put(now, new int[]{i, j, i, j});\n\t\t\t\t\tcheckMap.put(now, 0);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint[] ele = hash.get(now);\n\t\t\t\t\tif(ele[0] > i) ele[0] = i;\n\t\t\t\t\tif(ele[1] < j) ele[1] = j;\n\t\t\t\t\tif(ele[2] < i) ele[2] = i;\n\t\t\t\t\tif(ele[3] > j) ele[3] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tboolean ans = true;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(!map[i][j].equals(\".\")){\n\t\t\t\t\tif(checkMap.get(map[i][j]) == 0){\n\t\t\t\t\t\tans = check(map[i][j]);\n\t\t\t\t\t\tif(!ans) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ans) break;\n\t\t}\n\t\t\n\t\tif(ans) System.out.println(\"SAFE\");\n\t\telse System.out.println(\"SUSPICIOUS\");\n\t}\n\tpublic boolean check(String now){\n\t\tcheckMap.put(now, 2);\n\t\tint[] ele = hash.get(now);\n\t\tfor(int i = ele[0]; i <= ele[2]; i++){\n\t\t\tfor(int j = ele[3]; j <= ele[1]; j++){\n\t\t\t\tif(map[i][j].equals(\".\")) {\n\t\t\t\t\tcheckMap.put(now, -1);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse if(!map[i][j].equals(now)){\n\t\t\t\t\tif(checkMap.get(map[i][j]) == 0){\n\t\t\t\t\t\tboolean c = check(map[i][j]);\n\t\t\t\t\t}\n\t\t\t\t\telse if(checkMap.get(map[i][j]) == -1 || checkMap.get(map[i][j]) == 2){\n\t\t\t\t\t\tcheckMap.put(now, -1);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcheckMap.put(now, 1);\n\t\treturn true;\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.ReadableByteChannel;\n\npublic class Main {\n    static final ByteBuffer buf = ByteBuffer.allocate(1000000);\n    static final ReadableByteChannel in = Channels.newChannel(System.in);\n    static final int NAME = 0;\n    static final int T = 1;// top;\n    static final int B = 2;// Bottom;\n    static final int L = 3;// left;\n    static final int R = 4;// right;\n    static final int UNDERS = 5;\n\n    public static void main(String[] args) throws IOException {\n\tinit();\n\tint n = getInt();\n\tfor (int i = 0; i < n; i++) {\n\t    int h = getInt();\n\t    int w = getInt();\n\t    byte[][] box = new byte[h][w];\n\t    int[][] item = new int[7][6];\n\t    int count = 0;\n\t    for (int y = 0; y < h; y++) {\n\t\tgetLine(box[y]);\n\t\tfor (int x = 0; x < w; x++) {\n\t\t    final byte c = box[y][x];\n\t\t    if (c != '.') {\n\t\t\tfor (int k = 0; k < 7; k++) {\n\t\t\t    if (item[k][NAME] == 0) {\n\t\t\t\titem[k][NAME] = c;\n\t\t\t\titem[k][T] = item[k][B] = y;\n\t\t\t\titem[k][L] = item[k][R] = x;\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t    } else if (item[k][NAME] == c) {\n\t\t\t\tif (item[k][B] != y) {\n\t\t\t\t    item[k][B] = y;\n\t\t\t\t}\n\t\t\t\tif (x < item[k][L]) {\n\t\t\t\t    item[k][L] = x;\n\t\t\t\t} else if (item[k][R] < x) {\n\t\t\t\t    item[k][R] = x;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    boolean isSUSPICIOUS = false;\n\t    for (int num = 0; !isSUSPICIOUS && num < count; num++) {\n\t\tfor (int y = item[num][T]; !isSUSPICIOUS && y <= item[num][B]; y++) {\n\t\t    for (int x = item[num][L]; !isSUSPICIOUS\n\t\t\t    && x <= item[num][R]; x++) {\n\t\t\tfinal byte parts = box[y][x];\n\t\t\tif (parts != item[num][NAME]) {\n\t\t\t    if (parts == '.') {\n\t\t\t\tisSUSPICIOUS = true;\n\t\t\t    } else {\n\t\t\t\tint partsNum;\n\t\t\t\tfor (int j = 0; j < count; j++) {\n\t\t\t\t    if (item[j][0] == parts) {\n\t\t\t\t\tpartsNum = j;\n\t\t\t\t\tisSUSPICIOUS = !setUnders(item, partsNum,\n\t\t\t\t\t\tnum);\n\t\t\t\t\tbreak;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    System.out.println(isSUSPICIOUS?\"SUSPICIOUS\":\"SAFE\");\n\n\t}\n\n    }\n\n    private static boolean setUnders(int[][] item, int upperNum, int underNum) {\n\tif (underNum == upperNum) {\n\t    return false;\n\t}\n\tfor (int i = 0; i < 7; i++) {\n\t    if ((item[underNum][UNDERS] & getLayer(i)) != 0) {\n\t\tif (!setUnders(item, upperNum, i)) {\n\t\t    return false;\n\t\t}\n\t    }\n\t}\n\titem[upperNum][UNDERS] |= getLayer(underNum);\n\treturn true;\n    }\n\n    static int getLayer(int i) {\n\treturn 1 << i;\n    }\n\n    static void init() throws IOException {\n\tbuf.clear();\n\tin.read(buf);\n\tbuf.flip();\n    }\n\n    static int getInt() {\n\tbyte b = buf.get();\n\twhile (b < '0' || '9' < b) {\n\t    b = buf.get();\n\t}\n\tint result = 0;\n\twhile ('0' <= b && b <= '9') {\n\t    result = result * 10 + (b - '0');\n\t    b = buf.get();\n\t}\n\treturn result;\n    }\n\n    static void getLine(byte[] array) {\n\tbyte b = buf.get();\n\twhile (b != '.' && (b < 'A' || 'Z' < b)) {\n\t    b = buf.get();\n\t}\n\tbuf.position(buf.position() - 1);\n\tbuf.get(array);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\n\nimport static java.lang.System.*;\nimport static java.lang.Math.*;\n\nclass Main {\n\tpublic static Random rand=new Random();\n\n\tstatic boolean next_permutation(int[]as) {//早い\n\t\tint n = as.length;\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tif (as[i - 1] < as[i]) {\n\t\t\t\tint j = n;\n\t\t\t\twhile (as[i - 1] >= as[--j]);\n\t\t\t\tswap(as, i - 1, j);\n\t\t\t\treverse(as, i, n);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic void swap(int[] is, int i, int j) {\n\t\tint t = is[i];\n\t\tis[i] = is[j];\n\t\tis[j] = t;\n\t}\n\tstatic void reverse(int[] is, int s, int t) {\n\t\twhile (s < --t) swap(is, s++, t);\n\t}\n\n\tpublic void run() {\n\t\tint n=sc.nextInt();\n\t\tCase:while(n--!=0){\n\t\t\tint H=sc.nextInt(),W=sc.nextInt();\n\t\t\tchar[][] map=new char[H][W];\n\t\t\tfor(int i=0;i<H;i++)map[i]=sc.next().toCharArray();\n\n\t\t\t//全探索\n\t\t\tSet<Character> keys=new HashSet<Character>();\n\n\t\t\tfor(int h=0;h<H;h++)for(int w=0;w<W;w++){\n\t\t\t\tif(Character.isUpperCase(map[h][w])){\n\t\t\t\t\tkeys.add(map[h][w]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint N=keys.size();\n\t\t\tint[] p=new int[N];for(int i=0;i<N;i++)p[i]=i;\n\n\t\t\tchecking:do{\n\t\t\t\tSet<Character> usechar=new HashSet<Character>();\n\t\t\t\t//check\n\t\t\t\tfor(char key:keys){\n\t\t\t\t\tusechar.add(key);\n\t\t\t\t\tint wmin=Integer.MAX_VALUE,hmin=Integer.MAX_VALUE,\n\t\t\t\t\twmax=0,hmax=0;\n\t\t\t\t\tfor(int _h=0;_h<H;_h++)for(int _w=0;_w<W;_w++){\n\t\t\t\t\t\tif(map[_h][_w]==key){\n\t\t\t\t\t\t\twmin=min(_w,wmin);\n\t\t\t\t\t\t\twmax=max(_w,wmax);\n\t\t\t\t\t\t\thmin=min(_h,hmin);\n\t\t\t\t\t\t\thmax=max(_h,hmax);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t                //rectangle check\n\t                boolean isRect=true;\n\t                for(int _h=hmin;_h<=hmax;_h++)for(int _w=wmin;_w<wmax;_w++){\n\t                \t if(!usechar.contains(map[_h][_w]))isRect=false;\n\t                }\n\t                 if(!isRect)continue checking;\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tln(\"SAFE\");continue Case;\n\t\t\t}while(next_permutation(p));\n\t\t\tln(\"SUSPICIOUS\");\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t// from this\n//\t\tstatic BufferedReader in;\n//\t\tstatic PrintWriter out;\n//\t\tstatic {\n//\t    \ttry {\n//\t\t\t\tin =new BufferedReader(new FileReader(\"file.in\")); Project/file.in\n//\t\t\t\tout=new PrintWriter(new BufferedWriter(new FileWriter(\"file.out\")));\n//\t    \t} catch (IOException e) {\n//\t\t\t\te.printStackTrace();\n//\t\t\t}\n\t//  }\n\t// end\n\n\tstatic Scanner sc=new Scanner(in);\n\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\t//depth ex A[10]…1 A[10][10]…2 exception A[0]…0 A[10][0]…1 A[0][0]…0\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.ReadableByteChannel;\n\npublic class Main {\n    static final ByteBuffer buf = ByteBuffer.allocate(1000000);\n    static final ReadableByteChannel in = Channels.newChannel(System.in);\n    static final int NAME = 0;\n    static final int T = 1;// top;\n    static final int B = 2;// Bottom;\n    static final int L = 3;// left;\n    static final int R = 4;// right;\n    static final int UNDERS = 5;\n\n    public static void main(String[] args) throws IOException {\n\tinit();\n\tint n = getInt();\n\tfor (int i = 0; i < n; i++) {\n\t    int h = getInt();\n\t    int w = getInt();\n\t    byte[][] box = new byte[h][w];\n\t    int[][] item = new int[7][6];\n\t    int count = 0;\n\t    for (int y = 0; y < h; y++) {\n\t\tgetLine(box[y]);\n\t\tfor (int x = 0; x < w; x++) {\n\t\t    final byte c = box[y][x];\n\t\t    if (c != '.') {\n\t\t\tfor (int k = 0; k < 7; k++) {\n\t\t\t    if (item[k][NAME] == 0) {\n\t\t\t\titem[k][NAME] = c;\n\t\t\t\titem[k][T] = item[k][B] = y;\n\t\t\t\titem[k][L] = item[k][R] = x;\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t    } else if (item[k][NAME] == c) {\n\t\t\t\tif (item[k][B] != y) {\n\t\t\t\t    item[k][B] = y;\n\t\t\t\t}\n\t\t\t\tif (x < item[k][L]) {\n\t\t\t\t    item[k][L] = x;\n\t\t\t\t} else if (item[k][R] < x) {\n\t\t\t\t    item[k][R] = x;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    boolean isSUSPICIOUS = false;\n\t    for (int num = 0; !isSUSPICIOUS && num < count; num++) {\n\t\tfor (int y = item[num][T]; !isSUSPICIOUS && y <= item[num][B]; y++) {\n\t\t    for (int x = item[num][L]; !isSUSPICIOUS\n\t\t\t    && x <= item[num][R]; x++) {\n\t\t\tfinal byte parts = box[y][x];\n\t\t\tif (parts != item[num][NAME]) {\n\t\t\t    if (parts == '.') {\n\t\t\t\tisSUSPICIOUS = true;\n\t\t\t    } else {\n\t\t\t\tint partsNum;\n\t\t\t\tfor (int j = 0; j < count; j++) {\n\t\t\t\t    if (item[j][0] == parts) {\n\t\t\t\t\tpartsNum = j;\n\t\t\t\t\tisSUSPICIOUS = !setUnders(item, partsNum,\n\t\t\t\t\t\tnum);\n\t\t\t\t\tbreak;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    System.out.println(isSUSPICIOUS?\"SUSPICIOUS\":\"SAFE\");\n\n\t}\n\n    }\n\n    private static boolean setUnders(int[][] item, int upperNum, int underNum) {\n\tif (underNum == upperNum) {\n\t    return false;\n\t}\n\tfor (int i = 0; i < 7; i++) {\n\t    if ((item[underNum][UNDERS] & getLayer(i)) != 0) {\n\t\tif (!setUnders(item, upperNum, i)) {\n\t\t    return false;\n\t\t}\n\t    }\n\t}\n\titem[upperNum][UNDERS] |= getLayer(underNum);\n\treturn true;\n    }\n\n    static int getLayer(int i) {\n\treturn 1 << i;\n    }\n\n    static void init() throws IOException {\n\tbuf.clear();\n\tin.read(buf);\n\tbuf.flip();\n    }\n\n    static int getInt() {\n\tbyte b = buf.get();\n\twhile (b < '0' || '9' < b) {\n\t    b = buf.get();\n\t}\n\tint result = 0;\n\twhile ('0' <= b && b <= '9') {\n\t    result = result * 10 + (b - '0');\n\t    b = buf.get();\n\t}\n\treturn result;\n    }\n\n    static void getLine(byte[] array) {\n\tbyte b = buf.get();\n\twhile (b != '.' && (b < 'A' || 'Z' < b)) {\n\t    b = buf.get();\n\t}\n\tbuf.position(buf.position() - 1);\n\tbuf.get(array);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\tint n = sc.nextInt();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tcalc(h,w);\n\t\t\t\n\t\t}\n\t}\n\tHashMap<String, int[]> hash;\n\tString[] stringlist;\n\tString[][] map;\n\t\n\tpublic void calc(int h, int w){\n\t\thash = new HashMap<String, int[]>();\n\t\tstringlist = new String[7];\n\t\tmap = new String[h][w];\n\t\tint count = 0;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tString line = sc.next();\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tString now = line.substring(j, j+1);\n\t\t\t\tmap[i][j] = now;\n\t\t\t\tif(!now.equals(\".\")){\n\t\t\t\t\tif(!hash.containsKey(now)) {\n\t\t\t\t\t\thash.put(now, new int[]{i, j, i, j});\n\t\t\t\t\t\tstringlist[count] = now;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tint[] ele = hash.get(now);\n\t\t\t\t\t\tif(ele[0] > i) ele[0] = i;\n\t\t\t\t\t\tif(ele[1] < j) ele[1] = j;\n\t\t\t\t\t\tif(ele[2] < i) ele[2] = i;\n\t\t\t\t\t\tif(ele[3] > j) ele[3] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArrayList<String> list = new ArrayList<String>();\n\t\tfor(int i = 0; i < count; i++){\n\t\t\tlist.add(stringlist[i]);\n\t\t}\n\t\tboolean ans = check(count, list);\n\t\t\n\t\tif(ans) System.out.println(\"SAFE\");\n\t\telse System.out.println(\"SUSPICIOUS\");\n\t}\n\tpublic boolean check(int count, ArrayList<String> list){\n\t\tif(list.size() == 0) return true;\n\t\telse{\n\t\t\tfor(int k = 0; k < count; k++){\n\t\t\t\tString now = list.get(k);\n\t\t\t\tint[] ele = hash.get(now);\n\t\t\t\tboolean ans = true;\n\t\t\t\tfor(int i = ele[0]; i <= ele[2]; i++){\n\t\t\t\t\tfor(int j = ele[3]; j <= ele[1]; j++){\n\t\t\t\t\t\tif(map[i][j].equals(\".\")) return false;\n\t\t\t\t\t\telse if(!map[i][j].equals(now) && list.contains(map[i][j])){\n\t\t\t\t\t\t\tans = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ans) {\n\t\t\t\t\tlist.remove(k);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(list.size() == count) return false;\n\t\t\telse return check(count-1, list);\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\n\nimport static java.lang.System.*;\nimport static java.lang.Math.*;\n\nclass Main {\n\tpublic static Random rand=new Random();\n\n\tstatic boolean next_permutation(int[]as) {//早い\n\t\tint n = as.length;\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tif (as[i - 1] < as[i]) {\n\t\t\t\tint j = n;\n\t\t\t\twhile (as[i - 1] >= as[--j]);\n\t\t\t\tswap(as, i - 1, j);\n\t\t\t\treverse(as, i, n);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic void swap(int[] is, int i, int j) {\n\t\tint t = is[i];\n\t\tis[i] = is[j];\n\t\tis[j] = t;\n\t}\n\tstatic void reverse(int[] is, int s, int t) {\n\t\twhile (s < --t) swap(is, s++, t);\n\t}\n\n\tpublic void run() {\n\t\tint n=sc.nextInt();\n\t\tCase:while(n--!=0){\n\t\t\tint H=sc.nextInt(),W=sc.nextInt();\n\t\t\tchar[][] map=new char[H][W];\n\t\t\tfor(int i=0;i<H;i++)map[i]=sc.next().toCharArray();\n\n\t\t\t//全探索\n\t\t\tSet<Character> keys=new HashSet<Character>();\n\t\t\tfor(int h=0;h<H;h++)for(int w=0;w<W;w++){\n\t\t\t\tif(Character.isUpperCase(map[h][w])){\n\t\t\t\t\tkeys.add(map[h][w]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint N=keys.size();\n\t\t\tint[] p=new int[N];for(int i=0;i<N;i++)p[i]=i;\n\n\t\t\tchecking:do{\n\t\t\t\tSet<Character> usechar=new HashSet<Character>();\n\t\t\t\t//check\n\t\t\t\tfor(char key:keys){\n\t\t\t\t\tusechar.add(key);\n\t\t\t\t\tint wmin=Integer.MAX_VALUE,hmin=Integer.MAX_VALUE,\n\t\t\t\t\twmax=0,hmax=0;\n\t\t\t\t\tfor(int _h=0;_h<H;_h++)for(int _w=0;_w<W;_w++){\n\t\t\t\t\t\tif(map[_h][_w]==key){\n\t\t\t\t\t\t\twmin=min(_w,wmin);\n\t\t\t\t\t\t\twmax=max(_w,wmax);\n\t\t\t\t\t\t\thmin=min(_h,hmin);\n\t\t\t\t\t\t\thmax=max(_h,hmax);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t                //rectangle check\n\t                boolean isRect=true;\n\t                wh:for(int _h=hmin;_h<=hmax;_h++)for(int _w=wmin;_w<=wmax;_w++){\n\t                \t if(!usechar.contains(map[_h][_w])){\n\t                \t\t isRect=false;break wh;\n\t                \t }\n\t                }\n\t                 if(!isRect)continue checking;\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tln(\"SAFE\");continue Case;\n\t\t\t}while(next_permutation(p));\n\t\t\tln(\"SUSPICIOUS\");\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t// from this\n//\t\tstatic BufferedReader in;\n//\t\tstatic PrintWriter out;\n//\t\tstatic {\n//\t    \ttry {\n//\t\t\t\tin =new BufferedReader(new FileReader(\"file.in\")); Project/file.in\n//\t\t\t\tout=new PrintWriter(new BufferedWriter(new FileWriter(\"file.out\")));\n//\t    \t} catch (IOException e) {\n//\t\t\t\te.printStackTrace();\n//\t\t\t}\n\t//  }\n\t// end\n\n\tstatic Scanner sc=new Scanner(in);\n\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\t//depth ex A[10]…1 A[10][10]…2 exception A[0]…0 A[10][0]…1 A[0][0]…0\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n\tstatic final int INF = 2 << 28;\n\tstatic final long INF_L = 2L << 60;\n\tstatic final int  MOD = 1000000007;\n\tstatic final long MOD_L = 1000000007L;\n\tstatic final int[] vx_4 = {1,0,-1,0};\n\tstatic final int[] vy_4 = {0,1,0,-1};\n\tstatic final int[] vx_5 = {1,0,-1,0,0};\n\tstatic final int[] vy_5 = {0,1,0,-1,0};\n\tstatic final int[] vx_8 = {1,1,1,0,0,-1,-1,-1};\n\tstatic final int[] vy_8 = {1,0,-1,1,-1,1,0,-1};\n\tstatic final int[] vx_9 = {1,1,1,0,0,0,-1,-1,-1};\n\tstatic final int[] vy_9 = {1,0,-1,1,0,-1,1,0,-1};\n\t\n\tstatic char[] check;\n\tstatic int idx;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint dataSet = sc.nextInt();\n\t\twhile(dataSet-- > 0) {\n\t\t\tint H = sc.nextInt();\n\t\t\tint W = sc.nextInt();\n\t\t\tchar[][] map = new char[H][W];\n\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tboolean[] ATZ = new boolean[26];\n\t\t\tint[] yMax    = new int[26];\n\t\t\tint[] yMin    = new int[26];\n\t\t\tint[] xMax    = new int[26];\n\t\t\tint[] xMin    = new int[26];\n\t\t\tArrays.fill(xMax, -1);\n\t\t\tArrays.fill(yMax, -1);\n\t\t\tArrays.fill(xMin, INF);\n\t\t\tArrays.fill(yMin, INF);\n\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\t\tif(map[i][j] != '.') {\n\t\t\t\t\t\tint tmp = map[i][j] - 'A';\n\t\t\t\t\t\tif(!ATZ[tmp]) {\n\t\t\t\t\t\t\tATZ[tmp] = true;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tyMax[tmp] = Math.max(i,yMax[tmp]);\n\t\t\t\t\t\tyMin[tmp] = Math.min(i,yMin[tmp]);\n\t\t\t\t\t\txMax[tmp] = Math.max(j,xMax[tmp]);\n\t\t\t\t\t\txMin[tmp] = Math.min(j,xMin[tmp]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean ok = true;\n\t\t\tint pre = -1;\n\t\t\twhile(count != 0 && ok) {\n\t\t\t\tpre = count;\n\t\t\t\tIN:for(int i = 0; i < 26; i++) {\n\t\t\t\t\tif(!ATZ[i]) continue;\n\t\t\t\t\tfor(int y = yMin[i]; y <= yMax[i]; y++) {\n\t\t\t\t\t\tfor(int x = xMin[i]; x <= xMax[i]; x++) {\n\t\t\t\t\t\t\tif(map[y][x] == '.') {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(map[y][x] != ('A' + i) && map[y][x] != '?') continue IN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int y = yMin[i]; y <= yMax[i]; y++) {\n\t\t\t\t\t\tfor(int x = xMin[i]; x <= xMax[i]; x++) {\n\t\t\t\t\t\t\tmap[y][x] = '?';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tATZ[i] = false;\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\t\t\t\tif(pre == count) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok) System.out.println(\"SAFE\");\n\t\t\telse System.out.println(\"SUSPICIOUS\");\n\t\t}\n\t}\n\n}\n\n\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n    \tif (!hasNext()) throw new NoSuchElementException();\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static int n;\n\tpublic static char[] table;\n\tpublic static Rect[] rect;\n\tpublic static char[][] map;\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint test = in.nextInt();\n\t\tfor(int t=0; t<test; t++){\n\t\t\tint h = in.nextInt();\n\t\t\tint w = in.nextInt();\n//\t\t\tif(h == 0) break;\n\t\t\tmap = new char[h][w];\n\t\t\tint alps = 0;\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tmap[i] = in.next().toCharArray();\n\t\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\t\tif('A' <= map[i][j] && map[i][j] <= 'Z')\n\t\t\t\t\t\talps |= 1<<map[i][j]-'A';\n\t\t\t\t}\n\t\t\t}\n\t\t\tn = Integer.bitCount(alps);\n\t\t\ttable = new char[n];\n\t\t\tint idx = 0;\n\t\t\tfor(int i=0; i<26; i++){\n\t\t\t\tif((alps&1<<i)==0) continue;\n\t\t\t\ttable[idx++] = (char)('A'+i);\n\t\t\t}\n\t\t\trect = new Rect[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint left = w;\n\t\t\t\tint right = 0;\n\t\t\t\tint up = h;\n\t\t\t\tint down = 0;\n\t\t\t\tchar c = table[i];\n\t\t\t\tfor(int y=0; y<h; y++){\n\t\t\t\t\tfor(int x=0; x<w; x++){\n\t\t\t\t\t\tif(map[y][x] != c) continue;\n\t\t\t\t\t\tleft = Math.min(left, x);\n\t\t\t\t\t\tright = Math.max(right, x);\n\t\t\t\t\t\tup = Math.min(up, y);\n\t\t\t\t\t\tdown = Math.max(down, y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trect[i] = new Rect(left, right, up, down);\n\t\t\t}\n\t\t\tp = new int[n];\n\t\t\tSystem.out.println(dfs(0, 0) ? \"SAFE\" : \"SUSPICIOUS\");\n\t\t}\n\t}\n\t\n\tpublic static int[] p;\n\tpublic static boolean dfs(int idx, int used){\n\t\tif(idx == n){\n\t\t\tif(check(p)) return true;\n\t\t}\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif((used&1<<i)>0) continue;\n\t\t\tp[idx] = i;\n\t\t\tif(dfs(idx+1, used|1<<i)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static boolean check(int[] order){\n\t\tint used = 0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tchar c = table[order[i]];\n\t\t\tused |= 1<<c-'A';\n\t\t\tRect r = rect[order[i]];\n\t\t\tfor(int y=r.up; y<=r.down; y++){\n\t\t\t\tfor(int x=r.left; x<=r.right; x++){\n\t\t\t\t\tchar p = map[y][x];\n\t\t\t\t\tif(p == '.' || (used&1<<p-'A')==0)\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nclass Rect{\n\tint left, right;\n\tint up, down;\n\tpublic Rect(int l, int r, int u, int d){\n\t\tleft = l;\n\t\tright = r;\n\t\tup = u;\n\t\tdown = d;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic int h;\n\tstatic int w;\n\tstatic char[][] map;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor(int z = 0; z < n; z++) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tmap = new char[h][w];\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tIN:while(!clear()) {\n\t\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\t\tif(map[i][j] != '.') {\n\t\t\t\t\t\t\tif(isRect(i,j)) {\n\t\t\t\t\t\t\t\tremove(i,j);\n\t\t\t\t\t\t\t\tcontinue IN;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println((clear())?\"SAFE\":\"SUSPICIOUS\");\n\t\t\t\n\t\t}\n\t}\n\tpublic static void remove(int a, int b) {\n\t\tchar t = map[a][b];\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(map[i][j] == t) {\n\t\t\t\t\tmap[i][j] = '0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static boolean isRect(int a, int b) {\n\t\tchar c = map[a][b];\n\t\tchar[][] map = new char[h][w];\n\t\t\n\t\tfor(int k = a; k < h; k++) {\n\t\t\tIN:for(int l = b; l < w; l++) {\n\t\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\t\tmap[i] = Arrays.copyOf(Main.map[i],w);\n\t\t\t\t}\n\t\t\t\tfor(int i = a; i <= k; i++) {\n\t\t\t\t\tfor(int j = b; j <= l; j++) {\n\t\t\t\t\t\tif(c == '0' && map[i][j] != c) {\n\t\t\t\t\t\t\tc = map[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map[i][j] == c) {\n\t\t\t\t\t\t\tmap[i][j] = '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map[i][j] != c && map[i][j] != '0') continue IN;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\t\tif(map[i][j] == c) continue IN;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tMain.map[a][b] = c;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static boolean clear() {\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(map[i][j] != '.' && map[i][j] != '0') return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package p2002;\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\n\nimport static java.lang.System.*;\nimport static java.lang.Math.*;\n\nclass Main {\n\tpublic static Random rand=new Random();\n\n\tstatic boolean next_permutation(int[]as) {//早い\n\t\tint n = as.length;\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tif (as[i - 1] < as[i]) {\n\t\t\t\tint j = n;\n\t\t\t\twhile (as[i - 1] >= as[--j]);\n\t\t\t\tswap(as, i - 1, j);\n\t\t\t\treverse(as, i, n);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic void swap(int[] is, int i, int j) {\n\t\tint t = is[i];\n\t\tis[i] = is[j];\n\t\tis[j] = t;\n\t}\n\tstatic void reverse(int[] is, int s, int t) {\n\t\twhile (s < --t) swap(is, s++, t);\n\t}\n\n\tpublic void run() {\n\t\tint n=sc.nextInt();\n\t\tCase:while(n--!=0){\n\t\t\tint H=sc.nextInt(),W=sc.nextInt();\n\t\t\tchar[][] map=new char[H][W];\n\t\t\tfor(int i=0;i<H;i++)map[i]=sc.next().toCharArray();\n\n\t\t\t//全探索\n\t\t\tSet<Character> keys=new HashSet<Character>();\n\t\t\tfor(int h=0;h<H;h++)for(int w=0;w<W;w++){\n\t\t\t\tif(Character.isUpperCase(map[h][w])){\n\t\t\t\t\tkeys.add(map[h][w]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint N=keys.size();\n\t\t\tint[] p=new int[N];for(int i=0;i<N;i++)p[i]=i;\n\t\t\tCharacter[] kys=keys.toArray(new Character[0]);\n\t\t\tchecking:do{\n\t\t\t\tSet<Character> usechar=new HashSet<Character>();\n\t\t\t\t//check\n\t\t\t\tfor(int i=0;i<kys.length;i++){\n\t\t\t\t\tchar key=kys[p[i]];\n\t\t\t\t\tusechar.add(key);\n\t\t\t\t\tint wmin=Integer.MAX_VALUE,hmin=Integer.MAX_VALUE,\n\t\t\t\t\twmax=0,hmax=0;\n\t\t\t\t\tfor(int _h=0;_h<H;_h++)for(int _w=0;_w<W;_w++){\n\t\t\t\t\t\tif(map[_h][_w]==key){\n\t\t\t\t\t\t\twmin=min(_w,wmin);\n\t\t\t\t\t\t\twmax=max(_w,wmax);\n\t\t\t\t\t\t\thmin=min(_h,hmin);\n\t\t\t\t\t\t\thmax=max(_h,hmax);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t                //rectangle check\n\t                boolean isRect=true;\n\t                wh:for(int _h=hmin;_h<=hmax;_h++)for(int _w=wmin;_w<=wmax;_w++){\n\t                \t if(!usechar.contains(map[_h][_w])){\n\t                \t\t isRect=false;break wh;\n\t                \t }\n\t                }\n\t                 if(!isRect)continue checking;\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tln(\"SAFE\");continue Case;\n\t\t\t}while(next_permutation(p));\n\t\t\tln(\"SUSPICIOUS\");\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t// from this\n//\t\tstatic BufferedReader in;\n//\t\tstatic PrintWriter out;\n//\t\tstatic {\n//\t    \ttry {\n//\t\t\t\tin =new BufferedReader(new FileReader(\"file.in\")); Project/file.in\n//\t\t\t\tout=new PrintWriter(new BufferedWriter(new FileWriter(\"file.out\")));\n//\t    \t} catch (IOException e) {\n//\t\t\t\te.printStackTrace();\n//\t\t\t}\n\t//  }\n\t// end\n\n\tstatic Scanner sc=new Scanner(in);\n\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\t//depth ex A[10]…1 A[10][10]…2 exception A[0]…0 A[10][0]…1 A[0][0]…0\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int n;\n\tstatic int h, w;\n\tstatic int xline[][];\n\n\tpublic static void check(int mark) {\n\t\tint right = 0, left = w - 1, top = 0, bottom = h - 1;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (xline[i][j] == mark) {\n\t\t\t\t\tright = Math.max(right, j);\n\t\t\t\t\tleft = Math.min(left, j);\n\t\t\t\t\ttop = Math.max(top, i);\n\t\t\t\t\tbottom = Math.min(bottom, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = bottom; i <= top; i++) {\n\t\t\tfor (int j = left; j <= right; j++) {\n\t\t\t\tif (xline[i][j] != mark && xline[i][j] != '@') {\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = bottom; i <= top; i++) {\n\t\t\tfor (int j = left; j <= right; j++) {\n\t\t\t\tif (xline[i][j] == mark) {\n\t\t\t\t\txline[i][j] = '@';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n;\n\n\t\tn = sc.nextInt();\n\t\twhile (n-- != 0) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\txline = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\txline[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int q = 0; q < 7; q++) {\n\t\t\t\tfor (int r = 'A'; r <= 'Z'; r++) {\n\t\t\t\t\tcheck(r);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean f = true;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (xline[i][j] != '.' && xline[i][j] != '@') {\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (f) {\n\t\t\t\tSystem.out.println(\"SAFE\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"SUSPICIOUS\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\n\t\t\tchar[][] result = new char[h][];\n\t\t\tfor (int j = 0; j < result.length; j++) {\n\t\t\t\tString line = sc.next();\n\t\t\t\tresult[j] = line.toCharArray();\n\t\t\t}\n\n\t\t\tMap<Character, Integer[]> map = new HashMap<Character, Integer[]>();\n\t\t\tHashMap<Character, ArrayList<Character>> underBy = new HashMap<Character, ArrayList<Character>>();\n\t\t\tfor (int j = 0; j < result.length; j++) {\n\t\t\t\tfor (int k = 0; k < result[j].length; k++) {\n\t\t\t\t\tif (result[j][k] != '.') {\n\t\t\t\t\t\tif (map.get(result[j][k]) == null) {\n\t\t\t\t\t\t\tInteger[] put = { j, k, j, k };\n\t\t\t\t\t\t\tmap.put(result[j][k], put);\n\t\t\t\t\t\t\tunderBy.put(result[j][k],\n\t\t\t\t\t\t\t\t\tnew ArrayList<Character>());\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tInteger[] get = map.get(result[j][k]);\n\t\t\t\t\t\t\tmap.get(result[j][k])[0] = Math.min(get[0], j);\n\t\t\t\t\t\t\tmap.get(result[j][k])[1] = Math.min(get[1], k);\n\t\t\t\t\t\t\tmap.get(result[j][k])[2] = Math.max(get[2], j);\n\t\t\t\t\t\t\tmap.get(result[j][k])[3] = Math.max(get[3], k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean safe = true;\n\n\t\t\tcheck: for (Map.Entry<Character, Integer[]> entry : map.entrySet()) {\n\t\t\t\tchar key = entry.getKey();\n\t\t\t\tInteger[] get = map.get(key);\n\n\t\t\t\tfor (int j = get[0]; j <= get[2]; j++) {\n\t\t\t\t\tfor (int k = get[1]; k <= get[3]; k++) {\n\t\t\t\t\t\tif (result[j][k] == '.') {\n\t\t\t\t\t\t\t// 明らかに長方形でない時\n\t\t\t\t\t\t\tSystem.out.println(\"SUSPICIOUS\");\n\t\t\t\t\t\t\tsafe = false;\n\t\t\t\t\t\t\tbreak check;\n\t\t\t\t\t\t} else if (result[j][k] != key) {\n\t\t\t\t\t\t\t// 別の文字がかぶっている時\n\t\t\t\t\t\t\t// keyの上にresult[j][k]\n\t\t\t\t\t\t\tunderBy.get(key).add(result[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!safe) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcheck: for (Map.Entry<Character, ArrayList<Character>> entry : underBy\n\t\t\t\t\t.entrySet()) {\n\t\t\t\tDeque<Character> deque = new ArrayDeque<Character>();\n\t\t\t\tDeque<Character> checked = new ArrayDeque<Character>();\n\t\t\t\tfor (Character character : entry.getValue()) {\n\t\t\t\t\tdeque.add(character);\n\t\t\t\t}\n\t\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\t\tchar poll = deque.poll();\n\t\t\t\t\tchecked.add(poll);\n\t\t\t\t\tif (poll == entry.getKey()) {\n\t\t\t\t\t\t// 明らかに長方形でない時\n\t\t\t\t\t\tSystem.out.println(\"SUSPICIOUS\");\n\t\t\t\t\t\tsafe = false;\n\t\t\t\t\t\tbreak check;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (Character character : underBy.get(poll)) {\n\t\t\t\t\t\tif (!deque.contains(character)\n\t\t\t\t\t\t\t\t&& !checked.contains(character)) {\n\t\t\t\t\t\t\tdeque.add(character);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif (safe) {\n\t\t\t\tSystem.out.println(\"SAFE\");\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String args[]){\n\t\tString st;\n\t\tScanner sc = new Scanner(System.in);\n\t\tHashSet<Character> hs = new HashSet<Character>();\n\t\ths.add('.');\n\t\ths.add('*');\n\t\tint n= sc.nextInt();\n\t\tfor(int T=0;T<n;T++){\n\t\t\tint H=sc.nextInt(),W=sc.nextInt();\n\t\t\tchar[][] field = new char[H][W];\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tst = sc.next();\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tfield[i][j] = st.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tchar temp;\n\t\t\tint min_i,min_j,max_i=0,max_j=0;\n\t\t\tint check;\n\t\t\tfor(int k=0;k<7;k++){\n\t\t\t\t/*for(int i=0;i<H;i++){\n\t\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\t\tSystem.out.print(field[i][j]);\n\t\t\t\t\t}\t\t\n\t\t\t\t\tSystem.out.print(\"\\n\");\n\t\t\t\t}\n\t\t\t\tSystem.out.print(\"\\n\");*/\n\t\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\t\tmax_i=0;max_j=0;\n\t\t\t\t\t\tcheck=0;\n\t\t\t\t\t\tif(!hs.contains(field[i][j])){\n\t\t\t\t\t\t\ttemp = field[i][j];\n\t\t\t\t\t\t\ths.add(temp);\n\t\t\t\t\t\t\tmin_i = i;\n\t\t\t\t\t\t\tmin_j =j;\n\t\t\t\t\t\t\tfor(int ii=0;ii<H;ii++){\n\t\t\t\t\t\t\t\tfor(int jj=0;jj<W;jj++){\n\t\t\t\t\t\t\t\t\tif(field[ii][jj]==temp){\n\t\t\t\t\t\t\t\t\t\tif(min_i>ii){\n\t\t\t\t\t\t\t\t\t\t\tmin_i = ii;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(min_j>jj){\n\t\t\t\t\t\t\t\t\t\t\tmin_j= jj;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(max_i<ii){\n\t\t\t\t\t\t\t\t\t\t\tmax_i = ii;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(max_j<jj){\n\t\t\t\t\t\t\t\t\t\t\tmax_j= jj;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor(int ii=min_i;ii<=max_i;ii++){\n\t\t\t\t\t\t\t\tfor(int jj=min_j;jj<=min_j;jj++){\n\t\t\t\t\t\t\t\t\tif(field[ii][jj]!=temp&&field[ii][jj]!='*'){\n\t\t\t\t\t\t\t\t\t\tcheck++;\n\t\t\t\t\t\t\t\t\t\ths.remove(temp);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(check!=0) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(check==0){//*におきかえ\n\t\t\t\t\t\t\t\tfor(int ii=min_i;ii<=max_i;ii++){\n\t\t\t\t\t\t\t\t\tfor(int jj=min_j;jj<=max_j;jj++){\n\t\t\t\t\t\t\t\t\t\tfield[ii][jj] = '*';\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcheck =0;\n\t\t\t//全てが'.' or '*'の判定\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(field[i][j]!='.'&&field[i][j]!='*'){\n\t\t\t\t\t\tcheck = -1;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t\tif(check==-1){\n\t\t\t\t//OK\n\t\t\t\tSystem.out.println(\"SUSPICIOUS\");\n\t\t\t}else if(check==0){\n\t\t\t\t//No\n\t\t\t\tSystem.out.println(\"SAFE\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String args[]){\n\t\tString st;\n\t\tScanner sc = new Scanner(System.in);\n\t\tHashSet<Character> hs = new HashSet<Character>();\n\t\tHashSet<Character> hs2 = new HashSet<Character>();\n\t\ths.add('.');\n\t\ths.add('*');\n\t\tint n= sc.nextInt();\n\t\tfor(int T=0;T<n;T++){\n\t\t\tint H=sc.nextInt(),W=sc.nextInt();\n\t\t\tchar[][] field = new char[H][W];\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tst = sc.next();\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tfield[i][j] = st.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchar temp;\n\t\t\tint min_i,min_j,max_i=0,max_j=0;\n\t\t\tint check;\n\t\t\tfor(int k=0;k<7;k++){\n\t\t\t\ths2.clear();\n\t\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\t\tmax_i=0;max_j=0;\n\t\t\t\t\t\tcheck=0;\n\t\t\t\t\t\tif(!hs.contains(field[i][j])&&!hs2.contains(field[i][j])){\n\t\t\t\t\t\t\tfor(int iii=0;iii<H;iii++){\n\t\t\t\t\t\t\t\tfor(int jjj=0;jjj<W;jjj++){\n\t\t\t\t\t\t\t\t\tSystem.out.print(field[iii][jjj]);\n\t\t\t\t\t\t\t\t}\t\t\n\t\t\t\t\t\t\t\tSystem.out.print(\"\\n\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tSystem.out.print(\"\\n\");\n\n\t\t\t\t\t\t\ttemp = field[i][j];\n\t\t\t\t\t\t\ths.add(temp);\n\t\t\t\t\t\t\tmin_i = i;\n\t\t\t\t\t\t\tmin_j =j;\n\t\t\t\t\t\t\tfor(int ii=0;ii<H;ii++){\n\t\t\t\t\t\t\t\tfor(int jj=0;jj<W;jj++){\n\t\t\t\t\t\t\t\t\tif(field[ii][jj]==temp){\n\t\t\t\t\t\t\t\t\t\tif(min_i>ii){\n\t\t\t\t\t\t\t\t\t\t\tmin_i = ii;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(min_j>jj){\n\t\t\t\t\t\t\t\t\t\t\tmin_j= jj;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(max_i<ii){\n\t\t\t\t\t\t\t\t\t\t\tmax_i = ii;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(max_j<jj){\n\t\t\t\t\t\t\t\t\t\t\tmax_j= jj;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor(int ii=min_i;ii<=max_i;ii++){\n\t\t\t\t\t\t\t\tfor(int jj=min_j;jj<=max_j;jj++){\n\t\t\t\t\t\t\t\t\tif(field[ii][jj]!=temp&&field[ii][jj]!='*'){\n\t\t\t\t\t\t\t\t\t\tcheck++;\n\t\t\t\t\t\t\t\t\t\ths.remove(temp);\n\t\t\t\t\t\t\t\t\t\ths2.add(temp);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(check!=0) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(check==0){//*におきかえ\n\t\t\t\t\t\t\t\ths2.remove(temp);\n\t\t\t\t\t\t\t\tfor(int ii=min_i;ii<=max_i;ii++){\n\t\t\t\t\t\t\t\t\tfor(int jj=min_j;jj<=max_j;jj++){\n\t\t\t\t\t\t\t\t\t\tfield[ii][jj] = '*';\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//i=0;\n\t\t\t\t\t\t\t\t//j=0;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheck =0;\n\t\t\t//全てが'.' or '*'の判定\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(field[i][j]!='.'&&field[i][j]!='*'){\n\t\t\t\t\t\tcheck = -1;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t\tif(check==-1){\n\t\t\t\t//OK\n\t\t\t\tSystem.out.println(\"SUSPICIOUS\");\n\t\t\t}else if(check==0){\n\t\t\t\t//No\n\t\t\t\tSystem.out.println(\"SAFE\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String args[]){\n\t\tString st;\n\t\tScanner sc = new Scanner(System.in);\n\t\tHashSet<Character> hs = new HashSet<Character>();\n\t\tHashSet<Character> hs2 = new HashSet<Character>();\n\t\ths.add('.');\n\t\ths.add('*');\n\t\tint n= sc.nextInt();\n\t\tfor(int T=0;T<n;T++){\n\t\t\tint H=sc.nextInt(),W=sc.nextInt();\n\t\t\tchar[][] field = new char[H][W];\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tst = sc.next();\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tfield[i][j] = st.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tchar temp;\n\t\t\tint min_i,min_j,max_i=0,max_j=0;\n\t\t\tint check;\n\t\t\tfor(int k=0;k<7;k++){\n\t\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\t\tmax_i=0;max_j=0;\n\t\t\t\t\t\tcheck=0;\n\t\t\t\t\t\tif(!hs.contains(field[i][j])&&!hs2.contains(field[i][j])){\n\t\t\t\t\t\t\t/*for(int iii=0;iii<H;iii++){\n\t\t\t\t\t\t\t\tfor(int jjj=0;jjj<W;jjj++){\n\t\t\t\t\t\t\t\t\tSystem.out.print(field[iii][jjj]);\n\t\t\t\t\t\t\t\t}\t\t\n\t\t\t\t\t\t\t\tSystem.out.print(\"\\n\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tSystem.out.print(\"\\n\");*/\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttemp = field[i][j];\n\t\t\t\t\t\t\ths.add(temp);\n\t\t\t\t\t\t\tmin_i = i;\n\t\t\t\t\t\t\tmin_j =j;\n\t\t\t\t\t\t\tfor(int ii=0;ii<H;ii++){\n\t\t\t\t\t\t\t\tfor(int jj=0;jj<W;jj++){\n\t\t\t\t\t\t\t\t\tif(field[ii][jj]==temp){\n\t\t\t\t\t\t\t\t\t\tif(min_i>ii){\n\t\t\t\t\t\t\t\t\t\t\tmin_i = ii;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(min_j>jj){\n\t\t\t\t\t\t\t\t\t\t\tmin_j= jj;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(max_i<ii){\n\t\t\t\t\t\t\t\t\t\t\tmax_i = ii;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(max_j<jj){\n\t\t\t\t\t\t\t\t\t\t\tmax_j= jj;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor(int ii=min_i;ii<=max_i;ii++){\n\t\t\t\t\t\t\t\tfor(int jj=min_j;jj<=max_j;jj++){\n\t\t\t\t\t\t\t\t\tif(field[ii][jj]!=temp&&field[ii][jj]!='*'){\n\t\t\t\t\t\t\t\t\t\tcheck++;\n\t\t\t\t\t\t\t\t\t\ths.remove(temp);\n\t\t\t\t\t\t\t\t\t\ths2.add(temp);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(check!=0) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(check==0){//*におきかえ\n\t\t\t\t\t\t\t\ths2.remove(temp);\n\t\t\t\t\t\t\t\tfor(int ii=min_i;ii<=max_i;ii++){\n\t\t\t\t\t\t\t\t\tfor(int jj=min_j;jj<=max_j;jj++){\n\t\t\t\t\t\t\t\t\t\tfield[ii][jj] = '*';\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//i=0;\n\t\t\t\t\t\t\t\t//j=0;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcheck =0;\n\t\t\t//全てが'.' or '*'の判定\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(field[i][j]!='.'&&field[i][j]!='*'){\n\t\t\t\t\t\tcheck = -1;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t\tif(check==-1){\n\t\t\t\t//OK\n\t\t\t\tSystem.out.println(\"SUSPICIOUS\");\n\t\t\t}else if(check==0){\n\t\t\t\t//No\n\t\t\t\tSystem.out.println(\"SAFE\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int w, h;\n    char[][] bag;\n    ArrayList<Character> list;\n    ArrayList<int[]> seven;\n    boolean[] used;\n    int[] order;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        int T = sc.nextInt();\n        while(T-->0){\n            h = sc.nextInt();\n            w = sc.nextInt();\n            bag = new char[h][w];\n            list = new ArrayList<Character>();\n            for(int i=0; i<h; i++){\n                String s = sc.next();\n                for(int j=0; j<w; j++){\n                    bag[i][j] = s.charAt(j);\n                    if(!list.contains(bag[i][j]) && bag[i][j]!='.') list.add(bag[i][j]);\n                }\n            }\n            \n            seven = new ArrayList<int[]>();\n            used = new boolean[list.size()];\n            order = new int[list.size()];\n            dfs(0);\n            \n            if(!boo()) System.out.println(\"SUSPICIOUS\");\n            else System.out.println(\"SAFE\");\n        }\n    }\n\n\n    void dfs(int cnt){\n        if(cnt==list.size()){\n            int[] neworder = new int[list.size()];\n            for(int i=0; i<list.size(); i++) neworder[i] = order[i];\n            seven.add(neworder);\n            return;\n        }\n\n        for(int i=0; i<list.size(); i++){\n            if(used[i]) continue;\n            used[i] = true;\n            order[cnt] = i;\n            dfs(cnt+1);\n            used[i] = false;\n        }\n    }\n\n    boolean boo(){\n        boolean boo = true;\n        for(int ii=0; ii<seven.size(); ii++){\n            boo = true;\n            for(int i=0; i<list.size(); i++){\n                int minX = 100, maxX = 0;\n                int minY = 100, maxY = 0;\n                for(int j=0; j<h; j++){\n                    for(int k=0; k<w; k++){\n                        if(bag[j][k]==list.get(i)){\n                            minX = Math.min(minX, k);\n                            maxX = Math.max(maxX, k);\n                            minY = Math.min(minY, j);\n                            maxY = Math.max(maxY, j);\n                            \n                        }\n                    }\n                }\n                for(int l=minY; l<=maxY; l++){\n                    for(int m=minX; m<=maxX; m++){\n                        if(bag[l][m]!=list.get(i)){\n                            if(bag[l][m]=='.'){\n                                boo = false;\n                                break;\n                            }\n                            int idx1 = 0, idx2 = 0;\n                            for(int jj=0; jj<list.size(); jj++){\n                                int[] po = seven.get(ii);\n                                if(po[jj]==i) idx1 = jj;\n                                if(po[jj]==list.indexOf(bag[l][m])) idx2 = jj;\n                            }\n                            if(idx1>idx2){\n                                boo = false;\n                                break;\n                            }\n                        }\n                    }\n                    if(!boo) break;\n                }\n\n            } \n            if(boo) return true;   \n        }\n        return false;\n    }\n        \n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String args[]){\n\t\tString st;\n\t\tScanner sc = new Scanner(System.in);\n\t\tHashSet<Character> hs = new HashSet<Character>();\n\t\tHashSet<Character> hs2 = new HashSet<Character>();\n\t\ths.add('.');\n\t\ths.add('*');\n\t\tint n= sc.nextInt();\n\t\tfor(int T=0;T<n;T++){\n\t\t\tint H=sc.nextInt(),W=sc.nextInt();\n\t\t\tchar[][] field = new char[H][W];\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tst = sc.next();\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tfield[i][j] = st.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tchar temp;\n\t\t\tint min_i,min_j,max_i=0,max_j=0;\n\t\t\tint check;\n\t\t\t//for(int k=0;k<7;k++){\n\t\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\t\tmax_i=0;max_j=0;\n\t\t\t\t\t\tcheck=0;\n\t\t\t\t\t\tif(!hs.contains(field[i][j])&&!hs2.contains(field[i][j])){\n\t\t\t\t\t\t\ttemp = field[i][j];\n\t\t\t\t\t\t\ths.add(temp);\n\t\t\t\t\t\t\tmin_i = i;\n\t\t\t\t\t\t\tmin_j =j;\n\t\t\t\t\t\t\tfor(int ii=0;ii<H;ii++){\n\t\t\t\t\t\t\t\tfor(int jj=0;jj<W;jj++){\n\t\t\t\t\t\t\t\t\tif(field[ii][jj]==temp){\n\t\t\t\t\t\t\t\t\t\tif(min_i>ii){\n\t\t\t\t\t\t\t\t\t\t\tmin_i = ii;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(min_j>jj){\n\t\t\t\t\t\t\t\t\t\t\tmin_j= jj;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(max_i<ii){\n\t\t\t\t\t\t\t\t\t\t\tmax_i = ii;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(max_j<jj){\n\t\t\t\t\t\t\t\t\t\t\tmax_j= jj;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor(int ii=min_i;ii<=max_i;ii++){\n\t\t\t\t\t\t\t\tfor(int jj=min_j;jj<=max_j;jj++){\n\t\t\t\t\t\t\t\t\tif(field[ii][jj]!=temp&&field[ii][jj]!='*'){\n\t\t\t\t\t\t\t\t\t\tcheck++;\n\t\t\t\t\t\t\t\t\t\ths.remove(temp);\n\t\t\t\t\t\t\t\t\t\ths2.add(temp);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(check!=0) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(check==0){//*におきかえ\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tfor(int ii=min_i;ii<=max_i;ii++){\n\t\t\t\t\t\t\t\t\tfor(int jj=min_j;jj<=max_j;jj++){\n\t\t\t\t\t\t\t\t\t\tfield[ii][jj] = '*';\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ti=0;\n\t\t\t\t\t\t\t\tj=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t//}\n\n\t\t\tcheck =0;\n\t\t\t//全てが'.' or '*'の判定\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(field[i][j]!='.'&&field[i][j]!='*'){\n\t\t\t\t\t\tcheck = -1;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t\tif(check==-1){\n\t\t\t\t//OK\n\t\t\t\tSystem.out.println(\"SUSPICIOUS\");\n\t\t\t}else if(check==0){\n\t\t\t\t//No\n\t\t\t\tSystem.out.println(\"SAFE\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String args[]){\n\t\tString st;\n\t\tScanner sc = new Scanner(System.in);\n\t\tHashSet<Character> hs = new HashSet<Character>();\n\t\tHashSet<Character> hs2 = new HashSet<Character>();\n\t\ths.add('.');\n\t\ths.add('*');\n\t\tint n= sc.nextInt();\n\t\tfor(int T=0;T<n;T++){\n\t\t\tint H=sc.nextInt(),W=sc.nextInt();\n\t\t\tchar[][] field = new char[H][W];\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tst = sc.next();\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tfield[i][j] = st.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchar temp;\n\t\t\tint min_i,min_j,max_i=0,max_j=0;\n\t\t\tint check;\n\t\t\tfor(int k=0;k<7;k++){\n\t\t\t\ths2.clear();\n\t\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\t\tmax_i=0;max_j=0;\n\t\t\t\t\t\tcheck=0;\n\t\t\t\t\t\tif(!hs.contains(field[i][j])&&!hs2.contains(field[i][j])){\n\t\t\t\t\t\t/*\tfor(int iii=0;iii<H;iii++){\n\t\t\t\t\t\t\t\tfor(int jjj=0;jjj<W;jjj++){\n\t\t\t\t\t\t\t\t\tSystem.out.print(field[iii][jjj]);\n\t\t\t\t\t\t\t\t}\t\t\n\t\t\t\t\t\t\t\tSystem.out.print(\"\\n\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tSystem.out.print(\"\\n\");\n*/\n\t\t\t\t\t\t\ttemp = field[i][j];\n\t\t\t\t\t\t\ths.add(temp);\n\t\t\t\t\t\t\tmin_i = i;\n\t\t\t\t\t\t\tmin_j =j;\n\t\t\t\t\t\t\tfor(int ii=0;ii<H;ii++){\n\t\t\t\t\t\t\t\tfor(int jj=0;jj<W;jj++){\n\t\t\t\t\t\t\t\t\tif(field[ii][jj]==temp){\n\t\t\t\t\t\t\t\t\t\tif(min_i>ii){\n\t\t\t\t\t\t\t\t\t\t\tmin_i = ii;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(min_j>jj){\n\t\t\t\t\t\t\t\t\t\t\tmin_j= jj;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(max_i<ii){\n\t\t\t\t\t\t\t\t\t\t\tmax_i = ii;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(max_j<jj){\n\t\t\t\t\t\t\t\t\t\t\tmax_j= jj;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor(int ii=min_i;ii<=max_i;ii++){\n\t\t\t\t\t\t\t\tfor(int jj=min_j;jj<=max_j;jj++){\n\t\t\t\t\t\t\t\t\tif(field[ii][jj]!=temp&&field[ii][jj]!='*'){\n\t\t\t\t\t\t\t\t\t\tcheck++;\n\t\t\t\t\t\t\t\t\t\ths.remove(temp);\n\t\t\t\t\t\t\t\t\t\ths2.add(temp);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(check!=0) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(check==0){//*におきかえ\n\t\t\t\t\t\t\t\ths2.remove(temp);\n\t\t\t\t\t\t\t\tfor(int ii=min_i;ii<=max_i;ii++){\n\t\t\t\t\t\t\t\t\tfor(int jj=min_j;jj<=max_j;jj++){\n\t\t\t\t\t\t\t\t\t\tfield[ii][jj] = '*';\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//i=0;\n\t\t\t\t\t\t\t\t//j=0;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheck =0;\n\t\t\t//全てが'.' or '*'の判定\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(field[i][j]!='.'&&field[i][j]!='*'){\n\t\t\t\t\t\tcheck = -1;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t\tif(check==-1){\n\t\t\t\t//OK\n\t\t\t\tSystem.out.println(\"SUSPICIOUS\");\n\t\t\t}else if(check==0){\n\t\t\t\t//No\n\t\t\t\tSystem.out.println(\"SAFE\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int h,w;\n\tstatic int minx,miny,maxx,maxy;\n\tstatic int[][] field,alpha;\n\tstatic int[] v1={1,0,-1,0};\n\tstatic int[] v2={0,-1,0,1};\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tlabel2:for(int T=cin.nextInt();T--!=0;){\n\t\t\th=cin.nextInt();\t\n\t\t\tw=cin.nextInt();\n\t\t\tfield=new int[h][w];\n\t\t\t\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tchar[] s=cin.next().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(s[j]=='.')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfield[i][j]=s[j];\n//\t\t\t\t\tSystem.out.println(field[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean ans=true;\n\t\t\tlabel:while(true){\n\t\t\t\talpha=new int[26][4];\n\t\t\t\tans=true;\n\t\t\t\tboolean canBreak=true;\n\t\t\t\tfor(int i=0;i<26;i++){\n\t\t\t\t\talpha[i][0]=alpha[i][1]=1<<30;\n\t\t\t\t\talpha[i][2]=alpha[i][3]=-1;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\t\tif(field[i][j]>0){\n\t\t\t\t\t\t\talpha[field[i][j]-'A'][0]=Math.min(i, alpha[field[i][j]-'A'][0]);\n\t\t\t\t\t\t\talpha[field[i][j]-'A'][1]=Math.min(j, alpha[field[i][j]-'A'][1]);\n\t\t\t\t\t\t\talpha[field[i][j]-'A'][2]=Math.max(i, alpha[field[i][j]-'A'][2]);\n\t\t\t\t\t\t\talpha[field[i][j]-'A'][3]=Math.max(j, alpha[field[i][j]-'A'][3]);\n//\t\t\t\t\t\t\tSystem.out.println(alpha[field[i][j]-'A'][0]=Math.min(i, alpha[field[i][j]-'A'][0]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<26;k++){\n\t\t\t\t\tif(alpha[k][0]==1<<30){\n//\t\t\t\t\t\tSystem.out.println((char)(k+'A'));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint color='A'+k;\n\t\t\t\t\tboolean f=true;\n\t\t\t\t\tfor(int i=alpha[k][0];i<=alpha[k][2];i++){\n//\t\t\t\t\t\tSystem.out.println(color);\n\t\t\t\t\t\tfor(int j=alpha[k][1];j<=alpha[k][3];j++){\n//\t\t\t\t\t\t\tSystem.out.print(field[i][j]+\" \");\n\t\t\t\t\t\t\tif(color==field[i][j]||field[i][j]==-1){\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tf=false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n//\t\t\t\t\t\tSystem.out.println();\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tcanBreak=false;\n\t\t\t\t\t\tfor(int i=alpha[k][0];i<=alpha[k][2];i++){\n\t\t\t\t\t\t\tfor(int j=alpha[k][1];j<=alpha[k][3];j++){\n\t\t\t\t\t\t\t\tfield[i][j]=-1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\toutput();\n\t\t\t\tif(canBreak){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(field[i][j]>0){\n\t\t\t\t\t\tSystem.out.println(\"SUSPICIOUS\");\n\t\t\t\t\t\tcontinue label2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\"SAFE\");\n\t\t}\n\t}\n\tstatic void output(){\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(field[i][j]<=0){\n\t\t\t\t\tSystem.out.print(\".\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.print((char)field[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\tstatic void c(){\n\t\tfor(int i=miny;i<=maxy;i++){\n\t\t\tfor(int j=minx;j<=maxx;j++){\n\t\t\t\tfield[i][j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tstatic boolean b(int color){\n\t\tfor(int i=miny;i<=maxy;i++){\n\t\t\tfor(int j=minx;j<=maxx;j++){\n\t\t\t\tif(field[i][j]!=color)return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Rectangle;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic Rectangle[] rec = new Rectangle[26];\n\tstatic boolean[] check = new boolean[26];\n\t\n\tpublic static void main(String[] args) {\n\t\tint n;\n\t\tn = sc.nextInt();\t// input\n\t\twhile(n-- > 0) {\n\t\t\tfor(int i=0; i < 26; i++) {\t// initialize\n\t\t\t\trec[i] = new Rectangle();\n\t\t\t\trec[i].x = rec[i].y = 50;\n\t\t\t\trec[i].width = rec[i].height = 0;\n\t\t\t\tcheck[i] = false;\n\t\t\t}\n\t\t\tint h, w, cnt = 0;\n\t\t\th = sc.nextInt();\t// input\n\t\t\tw = sc.nextInt();\t// input\n\t\t\tint map[][] = new int[h][w];\n\t\t\tfor(int y=0; y < h; y++) {\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor(int x=0; x < w; x++) {\n\t\t\t\t\tmap[y][x] = (int)str.charAt(x); // input\n\t\t\t\t\tif(map[y][x] == '.') continue;\n\t\t\t\t\tint idx = map[y][x] - 'A';\n\t\t\t\t\tif(rec[idx].x > x) rec[idx].x = x;\t\t\t\t// start\n\t\t\t\t\tif(rec[idx].y > y) rec[idx].y = y;\t\t\t\t// start\n\t\t\t\t\tif(rec[idx].width < x) rec[idx].width = x;\t\t// end\n\t\t\t\t\tif(rec[idx].height < h) rec[idx].height = y;\t// end\n\t\t\t\t\tcheck[idx] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i < 26; i++) if(check[i]) cnt++;\n\t\t\tboolean flg = true;\n\t\t\twhile(flg) {\n\t\t\t\tflg = false;\n\t\t\t\tfor(int i=0; i < 26; i++) {\n\t\t\t\t\tif(check[i]){\n\t\t\t\t\t\tint mozi = 'A' + i;\n\t\t\t\t\t\tboolean success = true;\n\t\t\t\t\t\tfor(int y=rec[i].y; y <= rec[i].height && success; y++)\n\t\t\t\t\t\t\tfor(int x=rec[i].x; x <= rec[i].width && success; x++){\n\t\t\t\t\t\t\t\tif(map[y][x] != mozi && map[y][x] != -1) {\n\t\t\t\t\t\t\t\t\tsuccess = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tif(success){\n\t\t\t\t\t\t\tfor(int y=rec[i].y; y <= rec[i].height; y++)\n\t\t\t\t\t\t\t\tfor(int x=rec[i].x; x <= rec[i].width; x++){\n\t\t\t\t\t\t\t\t\tmap[y][x] = -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\tcheck[i] = false;\n\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt == 0)\n\t\t\t\tSystem.out.println(\"SAFE\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"SUSPICIOUS\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n  \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n  \n    public static void main(String[] args) {\n        new Main(); \n    }\n  \n    public Main() {\n        new aoj2002().doIt();\n    }\n    class aoj2002{\n    \tchar map[][] = new char[51][51];\n    \tSize size[] = new Size[128];\n    \tArrayList<Character> array = new ArrayList<Character>();\n    \tvoid set(int H,int W){\n    \t\tfor(int i = 0;i < H;i++){\n    \t\t\tString str = sc.next();\n    \t\t\tchar ctr[] = str.toCharArray();\n    \t\t\tfor(int j = 0;j < W;j++){\n    \t\t\t\tmap[i][j] = ctr[j];\n//    \t\t\t\tSystem.out.print(map[i][j]+\" \");\n    \t\t\t\tif(map[i][j] != '.'){\n    \t\t\t\t\tSize s = size[map[i][j]];\n    \t\t\t\t\tsize[map[i][j]] = new Size(Math.min(s.minx,j),Math.max(s.maxx,j+1),Math.min(s.miny,i),Math.max(s.maxy,i+1));\n    \t\t\t\t}\n    \t\t\t}\n//    \t\t\tSystem.out.println();\n    \t\t}\n    \t\t\n    \t}\n    \tvoid clear(){\n    \t\tfor(char c = 'A';c <= 'Z';c++){\n    \t\t\tsize[c] = new Size(100,0,100,0);\n    \t\t}\n    \t\tarray.clear();\n    \t}\n    \tboolean alf(char c){\n    \t\tfor(int i = size[c].miny;i < size[c].maxy;i++){\n\t\t\t\tfor(int j = size[c].minx;j < size[c].maxx;j++){\n\t\t\t\t\tif(map[i][j] == '.')return false;\n\t\t\t\t}\n\t\t\t}\n    \t\treturn true;\n    \t}\n    \tboolean alf_check(char c){\n    \t\tfor(int i = size[c].miny;i < size[c].maxy;i++){\n\t\t\t\tfor(int j = size[c].minx;j < size[c].maxx;j++){\n\t\t\t\t\tif(map[i][j] != c){\n\t\t\t\t\t\tif(map[i][j] != '1')return false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n    \t\treturn true;\n    \t}\n    \tvoid same(char c){\n    \t\tfor(int i = size[c].miny;i < size[c].maxy;i++){\n\t\t\t\tfor(int j = size[c].minx;j < size[c].maxx;j++){\n\t\t\t\t\tmap[i][j] = '1';\n\t\t\t\t}\n\t\t\t}\n    \t}\n    \tString check(){\n    \t\tfor(char c = 'A';c <= 'Z';c++){\n    \t\t\tif(size[c].maxx - size[c].minx < 0 || size[c].maxy - size[c].miny < 0)continue;\n    \t\t\tif(!alf(c))return \"SUSPICIOUS\";\n    \t\t\tarray.add(c);\n//    \t\t\tSystem.out.println(c+\" \"+size[c].minx+\" \"+size[c].maxx+\" \"+size[c].miny+\" \"+size[c].maxy);\n    \t\t}\n//    \t\tSystem.out.println(array.toString());\n    \t\tint cnt = array.size();\n    \t\twhile(cnt > 0){\n//    \t\t\tSystem.out.println(array.toString());\n    \t\t\tfor(int i = 0;i < array.size();i++){\n    \t\t\t\tif(alf_check(array.get(i))){\n    \t\t\t\t\tsame(array.get(i));\n    \t\t\t\t\tarray.remove(i);\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tif(cnt == array.size())return \"SUSPICIOUS\";\n    \t\t\tcnt = array.size();\n    \t\t}\n//    \t\tfor(int i = 0;i < array.size();i++){\n//    \t\t\tSystem.out.print(array.get(i)+\" \");\n//    \t\t}\n//    \t\tSystem.out.println();\n    \t\treturn \"SAFE\";\n    \t}\n        void doIt(){\n        \tint n = sc.nextInt();\n        \tfor(int i = 0;i < n;i++){\n        \t\tint h = sc.nextInt();\n        \t\tint w = sc.nextInt();\n        \t\tclear();\n        \t\tset(h,w);\n        \t\tSystem.out.println(check());\n        \t}\n        }\n        class Size{\n            int minx,maxx,miny,maxy;\n            public Size(int minx,int maxx,int miny,int maxy) {\n                this.minx = minx;\n                this.maxx = maxx;\n                this.miny = miny;\n                this.maxy = maxy;\n            }\n        }\n     }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\n\t\t\tchar[][] result = new char[h][];\n\t\t\tfor (int j = 0; j < result.length; j++) {\n\t\t\t\tString line = sc.next();\n\t\t\t\tresult[j] = line.toCharArray();\n\t\t\t}\n\n\t\t\tMap<Character, Integer[]> map = new HashMap<Character, Integer[]>();\n\t\t\tfor (int j = 0; j < result.length; j++) {\n\t\t\t\tfor (int k = 0; k < result[j].length; k++) {\n\t\t\t\t\tif (result[j][k] != '.') {\n\t\t\t\t\t\tif (map.get(result[j][k]) == null) {\n\t\t\t\t\t\t\tInteger[] put = { j, k, j, k };\n\t\t\t\t\t\t\tmap.put(result[j][k], put);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tInteger[] get = map.get(result[j][k]);\n\t\t\t\t\t\t\tmap.get(result[j][k])[0] = Math.min(get[0], j);\n\t\t\t\t\t\t\tmap.get(result[j][k])[1] = Math.min(get[1], k);\n\t\t\t\t\t\t\tmap.get(result[j][k])[2] = Math.max(get[2], j);\n\t\t\t\t\t\t\tmap.get(result[j][k])[3] = Math.max(get[3], k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean safe = true;\n\t\t\tcheck: for (Entry<Character, Integer[]> e : map.entrySet()) {\n\t\t\t\tInteger[] get = e.getValue();\n\t\t\t\tDeque<Character> deque = new ArrayDeque<Character>();\n\t\t\t\tfor (int j = get[0]; j <= get[2]; j++) {\n\t\t\t\t\tfor (int k = get[1]; k <= get[3]; k++) {\n\t\t\t\t\t\tif (result[j][k] == '.') {\n\t\t\t\t\t\t\t// 明らかに長方形でない時\n\t\t\t\t\t\t\tSystem.out.println(\"SUSPICIOUS\");\n\t\t\t\t\t\t\tsafe = false;\n\t\t\t\t\t\t\tbreak check;\n\t\t\t\t\t\t} else if (result[j][k] != e.getKey()\n\t\t\t\t\t\t\t\t&& !deque.contains(result[j][k])) {\n\t\t\t\t\t\t\t// 別の文字がかぶっている時\n\t\t\t\t\t\t\tdeque.add(result[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twhile (!deque.isEmpty() && safe) {\n\t\t\t\t\tchar poll = deque.poll();\n\t\t\t\t\tInteger[] cget = map.get(poll);\n\t\t\t\t\tfor (int j = cget[0]; j <= cget[2]; j++) {\n\t\t\t\t\t\tfor (int k = cget[1]; k <= cget[3]; k++) {\n\t\t\t\t\t\t\tif (result[j][k] == '.'\n\t\t\t\t\t\t\t\t\t|| result[j][k] == e.getKey()) {\n\t\t\t\t\t\t\t\t// 明らかに長方形でない時\n\t\t\t\t\t\t\t\t// 再び同じ文字が出てきた時\n\t\t\t\t\t\t\t\tSystem.out.println(\"SUSPICIOUS\");\n\t\t\t\t\t\t\t\tsafe = false;\n\t\t\t\t\t\t\t\tbreak check;\n\t\t\t\t\t\t\t} else if (result[j][k] != poll\n\t\t\t\t\t\t\t\t\t&& !deque.contains(result[j][k])) {\n\t\t\t\t\t\t\t\t// 別の文字がかぶっている時\n\t\t\t\t\t\t\t\tdeque.add(result[j][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (safe) {\n\t\t\t\tSystem.out.println(\"SAFE\");\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n    int INF=1<<28;\n    int H,W;\n    int[][] k;\n    char[][] s;\n\n    void run(){\n\tScanner sc=new Scanner(System.in);\n\tint tt=sc.nextInt();\n\twhile(tt-->0){\n\t    H=sc.nextInt();W=sc.nextInt();\n\t    k=new int[200][200];\n\t    s=new char[H+2][W+2];\n\n\t    for(int i=0;i<s.length;i++)\n\t\tfor(int j=0;j<s[0].length;j++)\n\t\t    s[i][j]='.';\n\t\t\t\n\t    for(int i=1;i<H+1;i++){\n\t\tString ss=sc.next();\n\t\tfor(int j=1;j<W+1;j++){\n\t\t    s[i][j]=ss.charAt(j-1);\n\t\t}\n\t    }\n\n\t    System.out.println(check()?\"SAFE\":\"SUSPICIOUS\");\n\t}\n    }\n\n    boolean check(){\n\n\tfor(char c='A';c<='Z';c++){\n\t    int xmin=INF,ymin=INF;\n\t    int xmax=-1,ymax=-1;\n\n\t    for(int i=0;i<H+2;i++){\n\t\tfor(int j=0;j<W+2;j++){\n\t\t    if(s[i][j]==c){\n\t\t\txmin=Math.min(xmin,j);\n\t\t\txmax=Math.max(xmax,j);\n\t\t\tymin=Math.min(ymin,i);\n\t\t\tymax=Math.max(ymax,i);\n\t\t    }\n\t\t}\n\t    }\n\n\t    for(int i=ymin;i<=ymax;i++){\n\t\tfor(int j=xmin;j<=xmax;j++){\n\t\t    if(s[i][j]=='.')return false;\n\t\t    else if(s[i][j]!=c){\n\t\t\tchar cc=s[i][j];\n\t\t\tif(k[c][cc]==1)return false;\n\t\t\tk[c][cc]=-1;k[cc][c]=1;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\t    //テ、ツスツ催ァツスツョテゥツ鳴「テ、ツソツづ」ツ?古ァツ淞崚ァツ崢セテ」ツ?療」ツ?ヲテ」ツ??」ツ?ェテ」ツ??」ツ??\n\t    for(int z=0;z<10;z++){ //テゥツォツ佚」ツ??テァツィツョテゥツ。ツ?\n\t\tfor(char i='A';i<='Z';i++){\n\t\t    for(char j='A';j<='Z';j++){\n\t\t\tif(k[i][j]==1 || k[j][i]==-1){\n\t\t\t    //テ」ツつづ」ツ?擁テ」ツ?桂テ」ツつ暗」ツつ甘、ツクツ甘」ツ?ォテ」ツ?づ」ツつ古」ツ?ー\n\t\t\t    for(char t='A';t<='Z';t++){\n\t\t\t\tif(k[t][i]==1 || k[i][t]==-1){\n\t\t\t\tif(k[t][j]==-1 || k[j][t]==1)return false;\n\t\t\t\tk[t][j]=1;k[j][t]=-1;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    return true;\n    }\n\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n}\n\n\t"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\n\t\t\tchar[][] result = new char[h][];\n\t\t\tfor (int j = 0; j < result.length; j++) {\n\t\t\t\tString line = sc.next();\n\t\t\t\tresult[j] = line.toCharArray();\n\t\t\t}\n\n\t\t\tMap<Character, Integer[]> map = new HashMap<Character, Integer[]>();\n\t\t\tHashMap<Character, ArrayList<Character>> underBy = new HashMap<Character, ArrayList<Character>>();\n\t\t\tfor (int j = 0; j < result.length; j++) {\n\t\t\t\tfor (int k = 0; k < result[j].length; k++) {\n\t\t\t\t\tif (result[j][k] != '.') {\n\t\t\t\t\t\tif (map.get(result[j][k]) == null) {\n\t\t\t\t\t\t\tInteger[] put = { j, k, j, k };\n\t\t\t\t\t\t\tmap.put(result[j][k], put);\n\t\t\t\t\t\t\tunderBy.put(result[j][k],\n\t\t\t\t\t\t\t\t\tnew ArrayList<Character>());\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tInteger[] get = map.get(result[j][k]);\n\t\t\t\t\t\t\tmap.get(result[j][k])[0] = Math.min(get[0], j);\n\t\t\t\t\t\t\tmap.get(result[j][k])[1] = Math.min(get[1], k);\n\t\t\t\t\t\t\tmap.get(result[j][k])[2] = Math.max(get[2], j);\n\t\t\t\t\t\t\tmap.get(result[j][k])[3] = Math.max(get[3], k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean safe = true;\n\n\t\t\tcheck: for (Map.Entry<Character, Integer[]> entry : map.entrySet()) {\n\t\t\t\tchar key = entry.getKey();\n\t\t\t\tInteger[] get = map.get(key);\n\n\t\t\t\tfor (int j = get[0]; j <= get[2]; j++) {\n\t\t\t\t\tfor (int k = get[1]; k <= get[3]; k++) {\n\t\t\t\t\t\tif (result[j][k] == '.') {\n\t\t\t\t\t\t\t// 明らかに長方形でない時\n\t\t\t\t\t\t\tSystem.out.println(\"SUSPICIOUS\");\n\t\t\t\t\t\t\tsafe = false;\n\t\t\t\t\t\t\tbreak check;\n\t\t\t\t\t\t} else if (result[j][k] != key) {\n\t\t\t\t\t\t\t// 別の文字がかぶっている時\n\t\t\t\t\t\t\t// keyの上にresult[j][k]\n\t\t\t\t\t\t\tunderBy.get(key).add(result[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!safe) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcheck: for (Map.Entry<Character, ArrayList<Character>> entry : underBy\n\t\t\t\t\t.entrySet()) {\n\t\t\t\tDeque<Character> deque = new ArrayDeque<Character>();\n\t\t\t\tfor (Character character : entry.getValue()) {\n\t\t\t\t\tdeque.add(character);\n\t\t\t\t}\n\t\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\t\tchar poll = deque.poll();\n\t\t\t\t\tif (poll == entry.getKey()) {\n\t\t\t\t\t\t// 明らかに長方形でない時\n\t\t\t\t\t\tSystem.out.println(\"SUSPICIOUS\");\n\t\t\t\t\t\tsafe = false;\n\t\t\t\t\t\tbreak check;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (Character character : underBy.get(poll)) {\n\t\t\t\t\t\tdeque.add(character);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif (safe) {\n\t\t\t\tSystem.out.println(\"SAFE\");\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.ReadableByteChannel;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class Main {\n    static final ByteBuffer buf = ByteBuffer.allocate(1000000);\n    static final ReadableByteChannel in = Channels.newChannel(System.in);\n    static final int NAME = 0;\n    static final int T = 1;// top;\n    static final int B = 2;// Bottom;\n    static final int L = 3;// left;\n    static final int R = 4;// right;\n    static final int UNDERS = 5;\n\n    public static void main(String[] args) throws IOException {\n\tinit();\n\tint n = getInt();\n\tfor (int i = 0; i < n; i++) {\n\t    int h = getInt();\n\t    int w = getInt();\n\t    byte[][] box = new byte[h][w];\n\t    int[][] item = new int[7][6];\n\t    int count = 0;\n\t    for (int y = 0; y < h; y++) {\n\t\tgetLine(box[y]);\n\t\tfor (int x = 0; x < w; x++) {\n\t\t    final byte c = box[y][x];\n\t\t    if (c != '.') {\n\t\t\tfor (int k = 0; k < 7; k++) {\n\t\t\t    if (item[k][NAME] == 0) {\n\t\t\t\titem[k][NAME] = c;\n\t\t\t\titem[k][T] = item[k][B] = y;\n\t\t\t\titem[k][L] = item[k][R] = x;\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t    } else if (item[k][NAME] == c) {\n\t\t\t\tif (item[k][B] != y) {\n\t\t\t\t    item[k][B] = y;\n\t\t\t\t}\n\t\t\t\tif (x < item[k][L]) {\n\t\t\t\t    item[k][L] = x;\n\t\t\t\t} else if (item[k][R] < x) {\n\t\t\t\t    item[k][R] = x;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    boolean isSUSPICIOUS = false;\n\t    for (int num = 0; !isSUSPICIOUS && num < count; num++) {\n\t\tfor (int y = item[num][T]; !isSUSPICIOUS && y <= item[num][B]; y++) {\n\t\t    for (int x = item[num][L]; !isSUSPICIOUS\n\t\t\t    && x <= item[num][R]; x++) {\n\t\t\tfinal byte parts = box[y][x];\n\t\t\tif (parts != item[num][NAME]) {\n\t\t\t    if (parts == '.') {\n\t\t\t\tisSUSPICIOUS = true;\n\t\t\t    } else {\n\t\t\t\tint partsNum;\n\t\t\t\tfor (int j = 0; j < count; j++) {\n\t\t\t\t    if (item[j][0] == parts) {\n\t\t\t\t\tpartsNum = j;\n\t\t\t\t\tisSUSPICIOUS = !setUnders(item, num,\n\t\t\t\t\t\tpartsNum);\n\t\t\t\t\tbreak;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t}\n\t\t    }\n\t\t}\n\t\t// System.out.println(\"p=\" + (char) item[num][NAME] + \":\"\n\t\t// + item[num][T] + \":\" + item[num][B] + \":\"\n\t\t// + item[num][L] + \":\" + item[num][R] + \"->\"\n\t\t// + item[num][UNDERS]);\n\t    }\n\t    System.out.println(isSUSPICIOUS?\"SUSPICIOUS\":\"SAFE\");\n\n\t}\n\n    }\n\n    private static boolean setUnders(int[][] item, int num, int partsNum) {\n\tif (num == partsNum) {\n\t    return false;\n\t}\n\tfor (int i = 0; i < 7; i++) {\n\t    if ((item[num][UNDERS] & getLayer(i)) != 0) {\n\t\t// System.out.println((char)item[num][0]+\" > \"+(char)item[i][0]);\n\t\tif (!setUnders(item, i, partsNum)) {\n\t\t    return false;\n\t\t}\n\t\t;\n\t    }\n\t}\n\titem[partsNum][UNDERS] |= getLayer(num);\n\treturn true;\n    }\n\n    static int getLayer(int i) {\n\treturn 1 << i;\n    }\n\n    static void init() throws IOException {\n\tbuf.clear();\n\tin.read(buf);\n\tbuf.flip();\n    }\n\n    static int getInt() {\n\tbyte b = buf.get();\n\twhile (b < '0' || '9' < b) {\n\t    b = buf.get();\n\t}\n\tint result = 0;\n\twhile ('0' <= b && b <= '9') {\n\t    result = result * 10 + (b - '0');\n\t    b = buf.get();\n\t}\n\t// System.out.println(\"i=\" + result);\n\treturn result;\n    }\n\n    static void getLine(byte[] array) {\n\tbyte b = buf.get();\n\twhile (b != '.' && (b < 'A' || 'Z' < b)) {\n\t    b = buf.get();\n\t}\n\tbuf.position(buf.position() - 1);\n\tbuf.get(array);\n\t// for(int i=0;i<array.length;i++){\n\t// System.out.print((char)array[i]);\n\t// }\n\t// System.out.println();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//X-Ray Screening System\npublic class Main{\n\n\tint h, w, n;\n\tchar[][] map;\n\tint[][] r;//0: top 1:bottom 2:left 3:bottom\n\tint[] order;\n\tboolean[] u;\n\tboolean[] used;\n\t\n\tboolean check(){\n\t\tboolean[] checked = new boolean[26];\n\t\tfor(int k=0;k<n;k++){\n\t\t\tint x = order[k];\n\t\t\tchecked[x] = true;\n\t\t\tfor(int i=r[x][0];i<=r[x][1];i++){\n\t\t\t\tfor(int j=r[x][2];j<=r[x][3];j++){\n\t\t\t\t\tif(map[i][j]=='.')return false;\n\t\t\t\t\tint c = map[i][j] - 'A';\n\t\t\t\t\tif(!checked[c])return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tboolean dfs(int k){\n\t\tif(k==n){\n\t\t\treturn check();\n\t\t}\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(u[i]&&!used[i]){\n\t\t\t\tused[i] = true;\n\t\t\t\torder[k] = i;\n\t\t\t\tif(dfs(k+1))return true;\n\t\t\t\tused[i] = false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\twhile(t--!=0){\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tmap = new char[h][w];\n\t\t\tu = new boolean[26];\n\t\t\tr = new int[26][4];\n\t\t\tn = 0;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tchar[] ch = sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tmap[i][j] = ch[j];\n\t\t\t\t\tif(map[i][j]=='.')continue;\n\t\t\t\t\tint x = map[i][j]-'A';\n\t\t\t\t\tif(!u[x]){\n\t\t\t\t\t\tn++;\n\t\t\t\t\t\tu[x] = true;\n\t\t\t\t\t\tr[x][0] = r[x][1] = i;\n\t\t\t\t\t\tr[x][2] = r[x][3] = j;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tr[x][0] = Math.min(r[x][0], i);\n\t\t\t\t\t\tr[x][1] = Math.max(r[x][1], i);\n\t\t\t\t\t\tr[x][2] = Math.min(r[x][2], j);\n\t\t\t\t\t\tr[x][3] = Math.max(r[x][3], j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\torder = new int[n];\n\t\t\tused = new boolean[26];\n\t\t\tSystem.out.println(dfs(0)?\"SAFE\":\"SUSPICIOUS\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\n\t\t\tchar[][] result = new char[h][];\n\t\t\tfor (int j = 0; j < result.length; j++) {\n\t\t\t\tString line = sc.next();\n\t\t\t\tresult[j] = line.toCharArray();\n\t\t\t}\n\n\t\t\tMap<Character, Integer[]> map = new HashMap<Character, Integer[]>();\n\t\t\tMap<Character, Boolean> isUsed = new HashMap<Character, Boolean>();\n\t\t\tDeque<Character> deque = new ArrayDeque<Character>();\n\t\t\tfor (int j = 0; j < result.length; j++) {\n\t\t\t\tfor (int k = 0; k < result[j].length; k++) {\n\t\t\t\t\tif (result[j][k] != '.') {\n\t\t\t\t\t\tif (map.get(result[j][k]) == null) {\n\t\t\t\t\t\t\tInteger[] put = { j, k, j, k };\n\t\t\t\t\t\t\tmap.put(result[j][k], put);\n\t\t\t\t\t\t\tisUsed.put(result[j][k], false);\n\t\t\t\t\t\t\tif (deque.isEmpty()) {\n\t\t\t\t\t\t\t\tdeque.add(result[j][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tInteger[] get = map.get(result[j][k]);\n\t\t\t\t\t\t\tmap.get(result[j][k])[0] = Math.min(get[0], j);\n\t\t\t\t\t\t\tmap.get(result[j][k])[1] = Math.min(get[1], k);\n\t\t\t\t\t\t\tmap.get(result[j][k])[2] = Math.max(get[2], j);\n\t\t\t\t\t\t\tmap.get(result[j][k])[3] = Math.max(get[3], k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean safe = true;\n\t\t\tDeque<Character> checked = new ArrayDeque<Character>();\n\t\t\tcheck: while (!deque.isEmpty()) {\n\t\t\t\tchar key = deque.poll();\n\t\t\t\tInteger[] get = map.get(key);\n\t\t\t\tif (isUsed.get(key)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisUsed.put(key, true);\n\n\t\t\t\tfor (int j = get[0]; j <= get[2]; j++) {\n\t\t\t\t\tfor (int k = get[1]; k <= get[3]; k++) {\n\t\t\t\t\t\tif (result[j][k] == '.'\n\t\t\t\t\t\t\t\t|| (result[j][k] != key && checked\n\t\t\t\t\t\t\t\t\t\t.contains(result[j][k]))) {\n\t\t\t\t\t\t\t// 明らかに長方形でない時、もう見た文字の時\n\t\t\t\t\t\t\tSystem.out.println(\"SUSPICIOUS\");\n\t\t\t\t\t\t\tsafe = false;\n\t\t\t\t\t\t\tbreak check;\n\t\t\t\t\t\t} else if (result[j][k] != key) {\n\t\t\t\t\t\t\t// 別の文字がかぶっている時\n\t\t\t\t\t\t\tdeque.add(result[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchecked.add(key);\n\n\t\t\t\tif (deque.isEmpty()) {\n\t\t\t\t\tfor (Character nextKey : map.keySet()) {\n\t\t\t\t\t\tif (!isUsed.get(nextKey)) {\n\t\t\t\t\t\t\tdeque.add(nextKey);\n\t\t\t\t\t\t\tchecked.clear();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (safe) {\n\t\t\t\tSystem.out.println(\"SAFE\");\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain p = new Main();\n\t}\n\n\tint h;\n\tint w;\n\tStringBuilder map;\n\tList<int[]> c;\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tc = new LinkedList<int[]>();\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tmap = new StringBuilder();\n\t\t\tfor(int j=0;j<h;j++)\n\t\t\t\tmap.append(sc.next());\n\t\t\t\n\t\t\tSystem.out.println(solve() ? \"SAFE\" : \"SUSPICIOUS\");\n\t\t}\n\t\t\n\t}\n\n\tpublic boolean solve() {\n\t\tint[][] alpha = new int[26][5];\n\t\tfor(int i=0;i<alpha.length;i++){\n\t\t\talpha[i][1] = alpha[i][2] = 10000000;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tint ch = map.charAt(i*w+j) - 'A';\n\t\t\t\tif(ch+'A'=='.')\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\talpha[ch][0]++;\n\t\t\t\talpha[ch][1] = Math.min(alpha[ch][1], i);\n\t\t\t\talpha[ch][2] = Math.min(alpha[ch][2], j);\n\t\t\t\talpha[ch][3] = Math.max(alpha[ch][3], i);\n\t\t\t\talpha[ch][4] = Math.max(alpha[ch][4], j);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<alpha.length;i++){\n\t\t\tif(alpha[i][0]>0){\n\t\t\t\talpha[i][0] = i+'A';\n\t\t\t\tc.add(alpha[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cur = 0;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0;i<h*w;i++)\n\t\t\tsb.append('.');\n\t\treturn rec(cur, sb.toString());\n\t\t\n\t}\n\n\tprivate boolean rec(int cur, String s) {\n\t\tif(cur == (1<<c.size())-1)\n\t\t\treturn isOk(s);\n\t\t\n\t\tboolean res = false;\n\t\tfor(int i=0;i<c.size();i++){\n\t\t\tif(((1<<i) & cur) > 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tStringBuilder sb = new StringBuilder(s);\n\t\t\tint[] ca = c.get(i);\n\t\t\tchar ch = (char) ca[0];\n\t\t\tfor(int j=ca[1];j<=ca[3];j++){\n\t\t\t\tfor(int k=ca[2];k<=ca[4];k++){\n\t\t\t\t\tsb.setCharAt(j*w+k, ch);\n\t\t\t\t}\n\t\t\t}\n\t\t\tres |= rec(cur|(1<<i), sb.toString());\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\n\tprivate boolean isOk(String string) {\n\t\treturn map.toString().equals(string);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Rectangle;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic Rectangle[] rec = new Rectangle[26];\n\tstatic boolean[] check = new boolean[26];\n\t\n\tpublic static void main(String[] args) {\n\t\tint n;\n\t\tn = sc.nextInt();\t// input\n\t\twhile(n-- > 0) {\n\t\t\tfor(int i=0; i < 26; i++) {\t// initialize\n\t\t\t\trec[i] = new Rectangle();\n\t\t\t\trec[i].x = rec[i].y = 50;\n\t\t\t\trec[i].width = rec[i].height = 0;\n\t\t\t\tcheck[i] = false;\n\t\t\t}\n\t\t\tint h, w, cnt = 0;\n\t\t\th = sc.nextInt();\t// input\n\t\t\tw = sc.nextInt();\t// input\n\t\t\tint map[][] = new int[h][w];\n\t\t\tfor(int y=0; y < h; y++) {\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor(int x=0; x < w; x++) {\n\t\t\t\t\tmap[y][x] = (int)str.charAt(x); // input\n\t\t\t\t\tif(map[y][x] == '.') continue;\n\t\t\t\t\tint idx = map[y][x] - 'A';\n\t\t\t\t\tif(rec[idx].x > x) rec[idx].x = x;\t\t\t\t// start\n\t\t\t\t\tif(rec[idx].y > y) rec[idx].y = y;\t\t\t\t// start\n\t\t\t\t\tif(rec[idx].width < x) rec[idx].width = x;\t\t// end\n\t\t\t\t\tif(rec[idx].height < h) rec[idx].height = y;\t// end\n\t\t\t\t\tcheck[idx] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i < 26; i++) if(check[i]) cnt++;\n\t\t\tboolean flg = true;\n\t\t\twhile(flg) {\n\t\t\t\tflg = false;\n\t\t\t\tfor(int i=0; i < 26; i++) {\n\t\t\t\t\tif(check[i]){\n\t\t\t\t\t\tint mozi = 'A' + i;\n\t\t\t\t\t\tboolean success = true;\n\t\t\t\t\t\tfor(int y=rec[i].y; y <= rec[i].height; y++)\n\t\t\t\t\t\t\tfor(int x=rec[i].x; x <= rec[i].width; x++){\n\t\t\t\t\t\t\t\tif(map[y][x] != mozi && map[y][x] != -1) {\n\t\t\t\t\t\t\t\t\tsuccess = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tif(success){\n\t\t\t\t\t\t\tfor(int y=rec[i].y; y <= rec[i].height; y++)\n\t\t\t\t\t\t\t\tfor(int x=rec[i].x; x <= rec[i].width; x++){\n\t\t\t\t\t\t\t\t\tmap[y][x] = -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\tcheck[i] = false;\n\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt == 0)\n\t\t\t\tSystem.out.println(\"SAFE\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"SUSPICIOUS\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\n\t\t\tchar[][] result = new char[h][];\n\t\t\tfor (int j = 0; j < result.length; j++) {\n\t\t\t\tString line = sc.next();\n\t\t\t\tresult[j] = line.toCharArray();\n\t\t\t}\n\n\t\t\tMap<Character, Integer[]> map = new HashMap<Character, Integer[]>();\n\t\t\tMap<Character, Boolean> isUsed = new HashMap<Character, Boolean>();\n\t\t\tDeque<Character> deque = new ArrayDeque<Character>();\n\t\t\tfor (int j = 0; j < result.length; j++) {\n\t\t\t\tfor (int k = 0; k < result[j].length; k++) {\n\t\t\t\t\tif (result[j][k] != '.') {\n\t\t\t\t\t\tif (map.get(result[j][k]) == null) {\n\t\t\t\t\t\t\tInteger[] put = { j, k, j, k };\n\t\t\t\t\t\t\tmap.put(result[j][k], put);\n\t\t\t\t\t\t\tisUsed.put(result[j][k], false);\n\t\t\t\t\t\t\tif (deque.isEmpty()) {\n\t\t\t\t\t\t\t\tdeque.add(result[j][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tInteger[] get = map.get(result[j][k]);\n\t\t\t\t\t\t\tmap.get(result[j][k])[0] = Math.min(get[0], j);\n\t\t\t\t\t\t\tmap.get(result[j][k])[1] = Math.min(get[1], k);\n\t\t\t\t\t\t\tmap.get(result[j][k])[2] = Math.max(get[2], j);\n\t\t\t\t\t\t\tmap.get(result[j][k])[3] = Math.max(get[3], k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean safe = true;\n\t\t\tDeque<Character> checked = new ArrayDeque<Character>();\n\t\t\tcheck: while (!deque.isEmpty()) {\n\t\t\t\tchar key = deque.poll();\n\t\t\t\tInteger[] get = map.get(key);\n\t\t\t\tif (isUsed.get(key)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisUsed.put(key, true);\n\n\t\t\t\tfor (int j = get[0]; j <= get[2]; j++) {\n\t\t\t\t\tfor (int k = get[1]; k <= get[3]; k++) {\n\t\t\t\t\t\tif (result[j][k] == '.'\n\t\t\t\t\t\t\t\t|| (result[j][k] != key && checked\n\t\t\t\t\t\t\t\t\t\t.contains(result[j][k]))) {\n\t\t\t\t\t\t\t// 明らかに長方形でない時、もう見た文字の時\n\t\t\t\t\t\t\tSystem.out.println(\"SUSPICIOUS\");\n\t\t\t\t\t\t\tsafe = false;\n\t\t\t\t\t\t\tbreak check;\n\t\t\t\t\t\t} else if (result[j][k] != key) {\n\t\t\t\t\t\t\t// 別の文字がかぶっている時\n\t\t\t\t\t\t\tdeque.add(result[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (deque.isEmpty()) {\n\t\t\t\t\tfor (Character nextKey : map.keySet()) {\n\t\t\t\t\t\tif (!isUsed.get(nextKey)) {\n\t\t\t\t\t\t\tdeque.add(nextKey);\n\t\t\t\t\t\t\tchecked.clear();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (safe) {\n\t\t\t\tSystem.out.println(\"SAFE\");\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tfor(int ds=0;ds<n;ds++){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tchar[][] map = new char[h][w];\n\t\t\tfor(int i=0;i<h;i++) map[i] = sc.next().toCharArray();\n\t\t\t\n\t\t\tint[] maxx = new int[7];\n\t\t\tint[] minx = new int[7];\n\t\t\tint[] maxy = new int[7];\n\t\t\tint[] miny = new int[7];\n\t\t\tArrays.fill(minx, 51);\n\t\t\tArrays.fill(miny, 51);\n\t\t\tArrayList<Character> list = new ArrayList<Character>();\n\t\t\t\n\t\t\tint p, q;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(map[i][j]!='.'){\n\t\t\t\t\t\tif(list.contains(map[i][j])==false) list.add(map[i][j]);\n\t\t\t\t\t\tp = list.indexOf(map[i][j]);\n\t\t\t\t\t\tmaxx[p] = Math.max(maxx[p], j);\n\t\t\t\t\t\tminx[p] = Math.min(minx[p], j);\n\t\t\t\t\t\tmaxy[p] = Math.max(maxy[p], i);\n\t\t\t\t\t\tminy[p] = Math.min(miny[p], i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean flag = true;\n\t\t\tArrayList<Integer> z = new ArrayList<Integer>();\n\t\t\tp = list.size();\n\t\t\tfor(int k=0;k<p;k++){\n\t\t\t\tfor(int i=miny[k];i<=maxy[k];i++){\n\t\t\t\t\tfor(int j=minx[k];j<=maxx[k];j++){\n\t\t\t\t\t\tif(map[i][j]=='.'){\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\ti = maxy[k]+1;\n\t\t\t\t\t\t\tj = maxx[k]+1;\n\t\t\t\t\t\t\tk = p;\n\t\t\t\t\t\t}else if(map[i][j]!=list.get(k)){\n\t\t\t\t\t\t\tq = 10*k + list.indexOf(map[i][j]);\n\t\t\t\t\t\t\tif(z.contains(q)==false) z.add(q);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(flag==true){\n\t\t\t\tq = z.size();\n\t\t\t\tint[] a = new int[q];\n\t\t\t\tint[] b = new int[q];\n\t\t\t\tint[] c = new int[p];\n\t\t\t\tfor(int i=0;i<q;i++){\n\t\t\t\t\ta[i] = z.get(i)/10;\n\t\t\t\t\tb[i] = z.get(i)%10;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<p;i++) c[i] = i;\n\t\t\t\tz.clear();\n\t\t\t\t\n\t\t\t\tboolean check;\n\t\t\t\tint rec;\n\t\t\t\tint temp;\n\t\t\t\twhile(true){\n\t\t\t\t\ttemp = 1;\n\t\t\t\t\trec = 0;\n\t\t\t\t\tfor(int i=0;i<p;i++){\n\t\t\t\t\t\trec += c[i]*temp;\n\t\t\t\t\t\ttemp *= 10;\n\t\t\t\t\t}\n\t\t\t\t\tif(z.contains(rec)==true){\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tz.add(rec);\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tfor(int i=0;i<q;i++){\n\t\t\t\t\t\t\tcheck = false;\n\t\t\t\t\t\t\tfor(int j=0;j<p;j++){\n\t\t\t\t\t\t\t\tif(c[j]==b[i]){\n\t\t\t\t\t\t\t\t\tcheck = true;\n\t\t\t\t\t\t\t\t\trec = j;\n\t\t\t\t\t\t\t\t}else if(c[j]==a[i]){\n\t\t\t\t\t\t\t\t\tif(check==true){\n\t\t\t\t\t\t\t\t\t\ttemp = c[rec];\n\t\t\t\t\t\t\t\t\t\tc[rec] = c[j];\n\t\t\t\t\t\t\t\t\t\tc[j] = temp;\n\t\t\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flag==true) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(flag==true) System.out.println(\"SAFE\");\n\t\t\telse System.out.println(\"SUSPICIOUS\");\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String args[]){\n\t\tString st;\n\t\tScanner sc = new Scanner(System.in);\n\t\tHashSet<Character> hs = new HashSet<Character>();\n\t\ths.add('.');\n\t\ths.add('*');\n\t\tint n= sc.nextInt();\n\t\tfor(int T=0;T<n;T++){\n\t\t\tint H=sc.nextInt(),W=sc.nextInt();\n\t\t\tchar[][] field = new char[H][W];\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tst = sc.next();\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tfield[i][j] = st.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tchar temp;\n\t\t\tint min_i,min_j,max_i=0,max_j=0;\n\t\t\tint check;\n\t\t\tfor(int k=0;k<7;k++){\n\t\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\t\tcheck=0;\n\t\t\t\t\t\tif(!hs.contains(field[i][j])){\n\t\t\t\t\t\t\ttemp = field[i][j];\n\t\t\t\t\t\t\ths.add(temp);\n\t\t\t\t\t\t\tmin_i = i;\n\t\t\t\t\t\t\tmin_j =j;\n\t\t\t\t\t\t\tfor(int ii=i;ii<H;ii++){\n\t\t\t\t\t\t\t\tfor(int jj=j;jj<W;jj++){\n\t\t\t\t\t\t\t\t\tif(field[ii][jj]==temp){\n\t\t\t\t\t\t\t\t\t\tif(max_i<ii){\n\t\t\t\t\t\t\t\t\t\t\tmax_i = ii;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(max_j<jj){\n\t\t\t\t\t\t\t\t\t\t\tmax_j= jj;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor(int ii=min_i;ii<max_i;ii++){\n\t\t\t\t\t\t\t\tfor(int jj=min_j;jj<min_j;jj++){\n\t\t\t\t\t\t\t\t\tif(field[ii][jj]!=temp&&field[i][j]!='*'){\n\t\t\t\t\t\t\t\t\t\tcheck++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(check!=0) break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(check==0){//*におきかえ\n\t\t\t\t\t\t\t\tfor(int ii=min_i;ii<=max_i;ii++){\n\t\t\t\t\t\t\t\t\tfor(int jj=min_j;jj<=max_j;jj++){\n\t\t\t\t\t\t\t\t\t\tfield[ii][jj] = '*';\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcheck =0;\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(field[i][j]!='.'&&field[i][j]!='*'){\n\t\t\t\t\t\tcheck = -1;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t\tif(check==-1){\n\t\t\t\t//OK\n\t\t\t\tSystem.out.println(\"SUSPICIOUS\");\n\t\t\t}else if(check==0){\n\t\t\t\t//No\n\t\t\t\tSystem.out.println(\"SAFE\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\n\nimport static java.lang.System.*;\n\nclass Main {\n\tpublic static Random rand=new Random();\n\n\tpublic void run() {\n\t\tint n=sc.nextInt();\n\t\twhile(n--!=0){\n\t\t\tint H=sc.nextInt(),W=sc.nextInt();\n\t\t\tchar[][] map=new char[H][W];\n\t\t\tfor(int i=0;i<H;i++)map[i]=sc.next().toCharArray();\n\n\t\t\t//長方形が見つかれば、除いていく。\n\n\t\t\tint M=7;\n\t\t\tFind:while(M--!=0){\n\t\t\t\tfor(int h=0;h<H;h++)for(int w=0;w<W;w++){\n\t\t\t\t\tif(Character.isUpperCase(map[h][w])){\n\t\t\t\t\t\tchar v=map[h][w];\n\t\t\t\t\t\tint wd=0;\n\t\t\t\t\t\twhile(w+wd<W && map[h][w+wd]==v)wd++;\n\t\t\t\t\t\tint hd=0;\n\t\t\t\t\t\twhile(h+hd<H && map[h+hd][w]==v)hd++;\n\t\t\t\t\t\tboolean isRect=true;\n\t\t\t\t\t\tfor(int _h=h;_h<h+hd;_h++)for(int _w=w;_w<w+wd;_w++)\n\t\t\t\t\t\t\tif(map[_h][_w]!=v && map[_h][_w]!='_')isRect=false;\n\t\t\t\t\t\tif(isRect){\n\t\t\t\t\t\t\tfor(int _h=h;_h<h+hd;_h++)for(int _w=w;_w<w+wd;_w++){\n\t\t\t\t\t\t\t\tmap[_h][_w]='_';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue Find;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean isSafe=true;\n\t\t\tfor(int h=0;h<H;h++)for(int w=0;w<W;w++){\n\t\t\t\tif(!(map[h][w]=='_' || map[h][w]=='.'))isSafe=false;\n\t\t\t}\n\t\t\tln(isSafe?\"SAFE\":\"SUSPICIOUS\");\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t// from this\n//\t\tstatic BufferedReader in;\n//\t\tstatic PrintWriter out;\n//\t\tstatic {\n//\t    \ttry {\n//\t\t\t\tin =new BufferedReader(new FileReader(\"file.in\")); Project/file.in\n//\t\t\t\tout=new PrintWriter(new BufferedWriter(new FileWriter(\"file.out\")));\n//\t    \t} catch (IOException e) {\n//\t\t\t\te.printStackTrace();\n//\t\t\t}\n\t//  }\n\t// end\n\n\tstatic Scanner sc=new Scanner(in);\n\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\t//depth ex A[10]…1 A[10][10]…2 exception A[0]…0 A[10][0]…1 A[0][0]…0\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tvoid run() {\n\t\tint n = sc.nextInt();\n\t\tchar[][] baggage = new char[50][50];\n\t\tint[][] r = new int[26][26];\n\t\tint[] d = new int[26];\n\t\tZ:for (int z = 0; z < n; z++) {\n\t\t\tint h = sc.nextInt(), w = sc.nextInt();\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tbaggage[i][j] = s.charAt(j);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < 26; i++)\n\t\t\t\tArrays.fill(r[i], 0);\n\t\t\t\n\t\t\tchar t = '.';\n\t\t\tfor (char c = 'A'; c <= 'Z'; c++) {\n\t\t\t\tint minx, miny, maxx, maxy;\n\t\t\t\tmaxx = maxy = -1;\n\t\t\t\tminx = miny = 100;\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\tif (baggage[i][j] == c) {\n\t\t\t\t\t\t\tminx = Math.min(minx, j);\n\t\t\t\t\t\t\tminy = Math.min(miny, i);\n\t\t\t\t\t\t\tmaxx = Math.max(maxx, j);\n\t\t\t\t\t\t\tmaxy = Math.max(maxy, i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (maxx >= 0) {\n\t\t\t\t\tfor (int i = miny; i <= maxy; i++) {\n\t\t\t\t\t\tfor (int j = minx; j <= maxx; j++) {\n\t\t\t\t\t\t\tif (baggage[i][j] == '.') {\n\t\t\t\t\t\t\t\tout.println(\"SUSPICIOUS\");\n\t\t\t\t\t\t\t\tcontinue Z;\n\t\t\t\t\t\t\t} else if (baggage[i][j] != c) {\n\t\t\t\t\t\t\t\tr[c-'A'][baggage[i][j]-'A'] = -1;\n\t\t\t\t\t\t\t\tt = c;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (t == '.') out.println(\"SAFE\");\n\t\t\telse {\n//\t\t\t\tfor (int i = 0; i < 26; i++) {\n//\t\t\t\t\tfor (int j = 0; j < 26; j++) {\n//\t\t\t\t\t\tout.printf(\"%2d \", r[i][j]);\n//\t\t\t\t\t}\n//\t\t\t\t\tout.println();\n//\t\t\t\t}\n\t\t\t\tArrays.fill(d, 0);\n\t\t\t\tfor (int i = 0; i < 26; i++) {\n\t\t\t\t\tfor (int j = 0; j < 26; j++) {\n\t\t\t\t\t\tfor (int k = 0; k < 26; k++) {\n\t\t\t\t\t\t\tif (r[j][k] < 0) {\n\t\t\t\t\t\t\t\tif (d[j] + r[j][k] < d[k]) {\n\t\t\t\t\t\t\t\t\td[k] = d[j] + r[j][k];\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif (i == 25) {\n\t\t\t\t\t\t\t\t\t\tout.println(\"SUSPICIOUS\");\n\t\t\t\t\t\t\t\t\t\tcontinue Z;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.println(\"SAFE\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tint h, w;\n\tint[] minX = new int[26], minY = new int[26];\n\tint[] maxX = new int[26], maxY = new int[26];\n\tboolean[][] covered = new boolean[26][26];\n\tchar[][] result;\n\tboolean ans;\n\t\n\tpublic void run() {\n\t\tint n = in.nextInt();\n\t\tfor (int loopN = 0; loopN < n; loopN++) {\n\t\t\tans = true;\n\t\t\th = in.nextInt(); w = in.nextInt();\n\t\t\tArrays.fill(maxX, -1);\n\t\t\tArrays.fill(maxY, -1);\n\t\t\tArrays.fill(minX, 101);\n\t\t\tArrays.fill(minY, 101);\n\t\t\tfor (int i = 0; i < covered.length; i++) {\n\t\t\t\tArrays.fill(covered[i], false);\n\t\t\t}\n\t\t\t\n\t\t\tresult = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tresult[i] = in.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (result[i][j] == '.') continue;\n\t\t\t\t\tint index = result[i][j] - 'A';\n\t\t\t\t\tminX[index] = Math.min(j, minX[index]);\n\t\t\t\t\tminY[index] = Math.min(i, minY[index]);\n\t\t\t\t\tmaxX[index] = Math.max(j, maxX[index]);\n\t\t\t\t\tmaxY[index] = Math.max(i, maxY[index]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tend : for (int i = 0; i < maxX.length; i++) {\n\t\t\t\tif (minX[i] == 101 || maxX[i] == -1 || minY[i] == 101 || maxY[i] == -1)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tfor (int j = minY[i]; j <= maxY[i]; j++) {\n\t\t\t\t\tfor (int k = minX[i]; k <= maxX[i]; k++) {\n\t\t\t\t\t\tif (result[j][k] == '.') {\n\t\t\t\t\t\t\tans = false;\n\t\t\t\t\t\t\tbreak end;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint c = result[j][k] - 'A';\n\t\t\t\t\t\tif (i != c) {\n\t\t\t\t\t\t\tif (isCovered(i, c)) {\n\t\t\t\t\t\t\t\tans = false;\n\t\t\t\t\t\t\t\tbreak end;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println((ans) ? \"SAFE\" : \"SUSPICIOUS\");\n\t\t}\n\t}\n\t\n\tpublic boolean isCovered(int c1, int c2) {\n\t\tif (covered[c1][c2]) return true;\n\t\t\n\t\tfor (int i = 0; i < covered.length; i++) {\n\t\t\tif (covered[c1][i]) {\n\t\t\t\tif (isCovered(i, c2)) return true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcovered[c2][c1] = true;\n\t\treturn false;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n    boolean debug=true;\n    int INF=1<<28;\n    int H,W;\n    int[][] k;\n    char[][] s;\n\n    void run(){\n\tScanner sc=new Scanner(System.in);\n\tint tt=sc.nextInt();\n\twhile(tt-->0){\n\t    H=sc.nextInt();W=sc.nextInt();\n\t    k=new int[200][200];\n\t    s=new char[H+2][W+2];\n\n\t    for(int i=0;i<s.length;i++)\n\t\tfor(int j=0;j<s[0].length;j++)\n\t\t    s[i][j]='.';\n\t\t\t\n\t    for(int i=1;i<H+1;i++){\n\t\tString ss=sc.next();\n\t\tfor(int j=1;j<W+1;j++){\n\t\t    s[i][j]=ss.charAt(j-1);\n\t\t}\n\t    }\n\n\t    System.out.println(check()?\"SAFE\":\"SUSPICIOUS\");\n\t}\n    }\n\n    boolean check(){\n\n\tfor(char c='A';c<='Z';c++){\n\t    int xmin=INF,ymin=INF;\n\t    int xmax=-1,ymax=-1;\n\n\t    for(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t    if(s[i][j]==c){\n\t\t\txmin=Math.min(xmin,j);\n\t\t\txmax=Math.max(xmax,j);\n\t\t\tymin=Math.min(ymin,i);\n\t\t\tymax=Math.max(ymax,i);\n\t\t    }\n\t\t}\n\t    }\n\n\t    for(int i=ymin;i<=ymax;i++){\n\t\tfor(int j=xmin;j<=xmax;j++){\n\t\t    if(s[i][j]=='.')return false;\n\t\t    else if(s[i][j]!=c){\n\t\t\tchar cc=s[i][j];\n\t\t\tif(k[c][cc]==1)return false;\n\t\t\tk[c][cc]=-1;k[cc][c]=1;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\t    //テ、ツスツ催ァツスツョテゥツ鳴「テ、ツソツづ」ツ?古ァツ淞崚ァツ崢セテ」ツ?療」ツ?ヲテ」ツ??」ツ?ェテ」ツ??」ツ??\n\t    for(int z=0;z<10;z++){ //テゥツォツ佚」ツ??テァツィツョテゥツ。ツ?\n\t\tfor(char i='A';i<='Z';i++){\n\t\t    for(char j='A';j<='Z';j++){\n\t\t\tif(k[i][j]==1 || k[j][i]==-1){\n\t\t\t    //テ」ツつづ」ツ?擁テ」ツ?桂テ」ツつ暗」ツつ甘、ツクツ甘」ツ?ォテ」ツ?づ」ツつ古」ツ?ー\n\t\t\t    for(char t='A';t<='Z';t++){\n\t\t\t\tif(k[t][i]==1 || k[i][t]==-1){\n\t\t\t\tif(k[t][j]==-1 || k[j][t]==1)return false;\n\t\t\t\tk[t][j]=1;k[j][t]=-1;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    return true;\n    }\n\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n}\n\n\t"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic char[][] f;\n\tstatic int H, W;\n\tstatic char FILL = '!';\n\n\tpublic static void main(String[] args) {\n\t\tint N = sc.nextInt();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tH = sc.nextInt();\n\t\t\tW = sc.nextInt();\n\t\t\tf = new char[H][W];\n\t\t\tfor (int j = 0; j < H; ++j) {\n\t\t\t\tf[j] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tSystem.out.println(solve() ? \"SUSPICIOUS\" : \"SAFE\");\n\t\t}\n\t}\n\n\tstatic boolean solve() {\n\t\tint[] t = new int[26];\n\t\tint[] b = new int[26];\n\t\tint[] l = new int[26];\n\t\tint[] r = new int[26];\n\t\tboolean[] exist = new boolean[26];\n\t\tArrays.fill(t, 99);\n\t\tArrays.fill(b, -1);\n\t\tArrays.fill(l, 99);\n\t\tArrays.fill(r, -1);\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (Character.isAlphabetic(f[i][j])) {\n\t\t\t\t\tint pos = f[i][j] - 'A';\n\t\t\t\t\tt[pos] = Math.min(t[pos], i);\n\t\t\t\t\tb[pos] = Math.max(b[pos], i);\n\t\t\t\t\tl[pos] = Math.min(l[pos], j);\n\t\t\t\t\tr[pos] = Math.max(r[pos], j);\n\t\t\t\t\texist[pos] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 8; ++i) {\n\t\t\tfor (int j = 0; j < 26; ++j) {\n\t\t\t\tif (!exist[j]) continue;\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor (int row = t[j]; row <= b[j]; ++row) {\n\t\t\t\t\tfor (int col = l[j]; col <= r[j]; ++col) {\n\t\t\t\t\t\tif (f[row][col] != (char) (j + 'A') && f[row][col] != FILL) ok = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tfor (int row = t[j]; row <= b[j]; ++row) {\n\t\t\t\t\t\tfor (int col = l[j]; col <= r[j]; ++col) {\n\t\t\t\t\t\t\tf[row][col] = FILL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\texist[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 26; ++i) {\n\t\t\tif (exist[i]) return true;\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\n/**\n * X-Ray Screening System\n *  URL:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2002\n *\n * @author Igari Kazuya\n *\n */\npublic class Main {\n\tprivate static ArrayList<Integer> usemapint;\n\n\tpublic static void addList(int num){\n\t\tfor(int i=0;i<usemapint.size();i++){\n\t\t\tif(usemapint.get(i) == num){\n\t\t\t\treturn ;\n\t\t\t}\n\t\t}\n\t\tusemapint.add(num);\n\t}\n\n\tpublic static boolean check(int[][] map, int num){\n\t\tint startX = map[0].length;\n\t\tint endX = -1;\n\t\tint startY = map.length;\n\t\tint endY = -1;\n\t\tfor(int y=0;y<map.length;y++){\n\t\t\tfor(int x=0; x < map[0].length ;x++){\n\t\t\t\tif(map[y][x] == num){\n\t\t\t\t\tif(x < startX){\n\t\t\t\t\t\tstartX = x;\n\t\t\t\t\t}\n\t\t\t\t\tif(endX < x){\n\t\t\t\t\t\tendX = x;\n\t\t\t\t\t}\n\t\t\t\t\tif(y < startY){\n\t\t\t\t\t\tstartY = y;\n\t\t\t\t\t}\n\t\t\t\t\tif(endY < y){\n\t\t\t\t\t\tendY = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int y=startY;y<=endY;y++){\n\t\t\tfor(int x=startX;x<=endX;x++){\n\t\t\t\tif(map[y][x] != num && map[y][x] != -1){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int y=startY;y<=endY;y++){\n\t\t\tfor(int x=startX;x<=endX;x++){\n\t\t\t\tmap[y][x] = -1;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint loop;\n\t\tloop = sc.nextInt();\n\n\t\tfor(int i=0;i<loop;i++){\n\t\t\tint h,w;\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tint[][] map = new int[h][w];\n\t\t\tusemapint = new ArrayList<Integer>();\n\t\t\tboolean flag = true;\n\n\t\t\tfor(int y=0;y<h;y++){\n\t\t\t\tString buf;\n\t\t\t\tbuf = sc.nextLine();\n\t\t\t\tif(buf.equals(\"\")){\n\t\t\t\t\tbuf = sc.nextLine();\n\t\t\t\t}\n\t\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\t\tif(buf.charAt(x) == '.'){\n\t\t\t\t\t\tmap[y][x] = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmap[y][x] = buf.charAt(x) - ('A' - 1);\n\t\t\t\t\t\taddList(map[y][x]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile(flag){\n\t\t\t\tflag = false;\n\t\t\t\tfor(int j=0; j<usemapint.size();j++){\n\t\t\t\t\tif(check(map,usemapint.get(j))){\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tusemapint.remove(j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(usemapint.isEmpty()){\n\t\t\t\tSystem.out.println(\"SAFE\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"SUSPICIOUS\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\n\nimport static java.lang.System.*;\nimport static java.lang.Math.*;\n\nclass Main {\n\tpublic static Random rand=new Random();\n\n\tstatic boolean next_permutation(int[]as) {//早い\n\t\tint n = as.length;\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tif (as[i - 1] < as[i]) {\n\t\t\t\tint j = n;\n\t\t\t\twhile (as[i - 1] >= as[--j]);\n\t\t\t\tswap(as, i - 1, j);\n\t\t\t\treverse(as, i, n);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic void swap(int[] is, int i, int j) {\n\t\tint t = is[i];\n\t\tis[i] = is[j];\n\t\tis[j] = t;\n\t}\n\tstatic void reverse(int[] is, int s, int t) {\n\t\twhile (s < --t) swap(is, s++, t);\n\t}\n\n\tpublic void run() {\n\t\tint n=sc.nextInt();\n\t\tCase:while(n--!=0){\n\t\t\tint H=sc.nextInt(),W=sc.nextInt();\n\t\t\tchar[][] map=new char[H][W];\n\t\t\tfor(int i=0;i<H;i++)map[i]=sc.next().toCharArray();\n\n\t\t\t//全探索\n\t\t\tSet<Character> keys=new HashSet<Character>();\n\t\t\tfor(int h=0;h<H;h++)for(int w=0;w<W;w++){\n\t\t\t\tif(Character.isUpperCase(map[h][w])){\n\t\t\t\t\tkeys.add(map[h][w]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint N=keys.size();\n\t\t\tint[] p=new int[N];for(int i=0;i<N;i++)p[i]=i;\n\t\t\tCharacter[] kys=keys.toArray(new Character[0]);\n\t\t\tchecking:do{\n\t\t\t\tSet<Character> usechar=new HashSet<Character>();\n\t\t\t\t//check\n\t\t\t\tfor(int i=0;i<kys.length;i++){\n\t\t\t\t\tchar key=kys[p[i]];\n\t\t\t\t\tusechar.add(key);\n\t\t\t\t\tint wmin=Integer.MAX_VALUE,hmin=Integer.MAX_VALUE,\n\t\t\t\t\twmax=0,hmax=0;\n\t\t\t\t\tfor(int _h=0;_h<H;_h++)for(int _w=0;_w<W;_w++){\n\t\t\t\t\t\tif(map[_h][_w]==key){\n\t\t\t\t\t\t\twmin=min(_w,wmin);\n\t\t\t\t\t\t\twmax=max(_w,wmax);\n\t\t\t\t\t\t\thmin=min(_h,hmin);\n\t\t\t\t\t\t\thmax=max(_h,hmax);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t                //rectangle check\n\t                boolean isRect=true;\n\t                wh:for(int _h=hmin;_h<=hmax;_h++)for(int _w=wmin;_w<=wmax;_w++){\n\t                \t if(!usechar.contains(map[_h][_w])){\n\t                \t\t isRect=false;break wh;\n\t                \t }\n\t                }\n\t                 if(!isRect)continue checking;\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tln(\"SAFE\");continue Case;\n\t\t\t}while(next_permutation(p));\n\t\t\tln(\"SUSPICIOUS\");\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t// from this\n//\t\tstatic BufferedReader in;\n//\t\tstatic PrintWriter out;\n//\t\tstatic {\n//\t    \ttry {\n//\t\t\t\tin =new BufferedReader(new FileReader(\"file.in\")); Project/file.in\n//\t\t\t\tout=new PrintWriter(new BufferedWriter(new FileWriter(\"file.out\")));\n//\t    \t} catch (IOException e) {\n//\t\t\t\te.printStackTrace();\n//\t\t\t}\n\t//  }\n\t// end\n\n\tstatic Scanner sc=new Scanner(in);\n\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\t//depth ex A[10]…1 A[10][10]…2 exception A[0]…0 A[10][0]…1 A[0][0]…0\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static boolean ok(int x, int y, int w, int h){\n\t\tif(x < 0 || x >= w || y < 0 || y >= h){\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static boolean get_rect(int w, int h, int[][] map, int count, int[][] rect, boolean[][] checked){\n\t\tint color = 0;\n\t\tint left = Integer.MAX_VALUE;\n\t\tint right = Integer.MIN_VALUE;\n\t\tint up = Integer.MIN_VALUE;\n\t\tint down = Integer.MAX_VALUE;\n\t\t\n\t\t\n\t\tfor(int y = 0; y < h; y++){\n\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\tif(checked[y][x]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(map[y][x] == 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(color == 0){\n\t\t\t\t\tcolor = map[y][x];\n\t\t\t\t\tchecked[y][x] = true;\n\t\t\t\t\tleft = right = x;\n\t\t\t\t\tup = down = y;\n\t\t\t\t}else if(map[y][x] == color){\n\t\t\t\t\tchecked[y][x] = true;\n\t\t\t\t\tleft = Math.min(left, x);\n\t\t\t\t\tright = Math.max(right, x);\n\t\t\t\t\tup = Math.min(up, y);\n\t\t\t\t\tdown = Math.max(down, y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(color != 0){\n\t\t\trect[count][0] = left;\n\t\t\trect[count][1] = up;\n\t\t\trect[count][2] = right;\n\t\t\trect[count][3] = down;\n\t\t\trect[count][4] = color;\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\t\n\tpublic static boolean check_rect(int w, int h, int[][] map, int len, int[][] rect, boolean[][] adj){\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tfinal int sx = rect[i][0];\n\t\t\tfinal int sy = rect[i][1];\n\t\t\tfinal int gx = rect[i][2];\n\t\t\tfinal int gy = rect[i][3];\n\t\t\tfinal int color = rect[i][4];\n\t\t\t\n\t\t\tboolean[] checked = new boolean[27];\n\t\t\t\n\t\t\tfor(int y = sy; y <= gy; y++){\n\t\t\t\tfor(int x = sx; x <= gx; x++){\n\t\t\t\t\tif(map[y][x] == 0){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}else if(map[y][x] != color){\n\t\t\t\t\t\tif(!checked[map[y][x]]){\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor(int c = 0; c < len; c++){\n\t\t\t\t\t\t\t\tif(c == i){\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}else if(rect[c][4] == map[y][x]){\n\t\t\t\t\t\t\t\t\tadj[i][c] = true;\n\t\t\t\t\t\t\t\t\tchecked[map[y][x]] = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static final int unvisited = 0;\n\tpublic static final int visiting = 1;\n\tpublic static final int visited = 2;\n\tpublic static boolean dfs(int node, boolean[][] adj, int[] state){\n\t\tstate[node] = visiting;\n\t\t\n\t\tfor(int i = 0; i < adj.length; i++){\n\t\t\tif(!adj[node][i]){\n\t\t\t\tcontinue;\n\t\t\t}else if(state[i] == unvisited){\n\t\t\t\tif(!dfs(i, adj, state)){\n\t\t\t\t\tstate[node] = visited;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}else if(state[i] == visiting){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tstate[node] = visited;\n\t\treturn true;\n\t}\n\t\n\tpublic static boolean find_cycle(boolean[][] adj){\n\t\tint[] state = new int[adj.length];\n\t\tfor(int i = 0; i < adj.length; i++){\n\t\t\tstate[i] = unvisited;\n\t\t}\n\t\tfor(int i = 0; i < adj.length; i++){\n\t\t\tif(state[i] == unvisited){\n\t\t\t\tif(!dfs(i, adj, state)){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static boolean do_it(int h, int w, int[][] map){\n\t\tint cur = 0;\n\t\tint[][] rect = new int[7][5];\n\t\tboolean[][] checked = new boolean[h][w];\n\t\t\n\t\twhile(get_rect(w, h, map, cur, rect, checked)){\n\t\t\tcur++;\n\t\t}\n\t\t\n\t\tboolean[][] adj = new boolean[cur][cur];\n\t\tif(!check_rect(w, h, map, cur, rect, adj)){\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif(!find_cycle(adj)){\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int T = sc.nextInt();\n\t\t\n\t\tfor(int tt = 0; tt < T; tt++){\n\t\t\tfinal int h = sc.nextInt();\n\t\t\tfinal int w = sc.nextInt();\n\t\t\t\n\t\t\tint[][] map = new int[h][w];\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tchar[] input = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(input[j] == '.'){\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmap[i][j] = input[j] - 'A' + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(do_it(h, w, map) ? \"SAFE\" : \"SUSPICIOUS\");\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class Rec\n{\n    public int[] x { get; set; }\n    public int[] y { get; set; }\n    public int now { get; set; }\n    public bool delete { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var n = int.Parse(Console.ReadLine().Trim());\n        for (int i = 0; i < n; i++)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var h = int.Parse(line[0]);\n            var w = int.Parse(line[1]);\n            var map = new char[h, w];\n            var hs = new HashSet<char>();\n            for (int j = 0; j < h; j++)\n            {\n                var s = Console.ReadLine().Trim();\n                for (int k = 0; k < w; k++)\n                {\n                    if (s[k] != '.') hs.Add(s[k]);\n                    map[j, k] = s[k];\n                }\n            }\n            var d = new Dictionary<char, Rec>();\n            foreach (var x in hs)\n                d[x] = new Rec { x = new int[4], y = new int[4], now = -1 };\n            writeDict(d, map);\n            if (d.Count() == 0) { Console.WriteLine(\"SAFE\"); goto end; }\n            rewriteDict(d);\n\n            if (!checkFront(d, map)) { Console.WriteLine(\"SUSPICIOUS\"); goto end; }\n            int ret;\n            while (true)\n            {\n                ret = checkBack(d, map);\n                if (ret == -1) { Console.WriteLine(\"SUSPICIOUS\"); break; }\n                else if (ret == 0) { Console.WriteLine(\"SAFE\"); break; }\n            }\n            end:;\n        }\n    }\n    public static void print(char[,] map)\n    {\n        var h = map.GetLength(0);\n        var w = map.GetLength(1);\n        for (int i = 0; i < h; i++)\n        {\n            var tt = new char[w];\n            for (int j = 0; j < w; j++) tt[j] = map[i, j];\n            Console.WriteLine(new string(tt));\n        }\n    }\n    public static void writeDict(Dictionary<char, Rec> d, char[,] map)\n    {\n        var h = map.GetLength(0);\n        var w = map.GetLength(1);\n        for (int i = 0; i < h; i++)\n            for (int j = 0; j < w; j++)\n            {\n                var t = map[i, j];\n                if (t != '.')\n                {\n                    var dt = d[t].now;\n                    if (dt == -1) { d[t].x[0] = i; d[t].y[0] = j; d[t].now = 0; }\n                    else if (dt == 0 && d[t].x[0] == i) { d[t].x[1] = i; d[t].y[1] = j; d[t].now = 1; }\n                    else if (dt == 0 && d[t].x[0] != i) { d[t].x[2] = i; d[t].y[2] = j; d[t].now = 2; }\n                    else if (dt == 1 && d[t].x[1] == i) { d[t].x[1] = i; d[t].y[1] = j; d[t].now = 1; }\n                    else if (dt == 1 && d[t].x[1] != i) { d[t].x[2] = i; d[t].y[2] = j; d[t].now = 2; }\n                    else if (dt == 2 && d[t].x[2] == i) { d[t].x[3] = i; d[t].y[3] = j; d[t].now = 3; }\n                    else if (dt == 2 && d[t].x[2] != i) { d[t].x[2] = i; d[t].y[2] = j; d[t].now = 2; }\n                    else if (dt == 3 && d[t].x[3] == i) { d[t].x[3] = i; d[t].y[3] = j; d[t].now = 3; }\n                    else if (dt == 3 && d[t].x[3] != i) { d[t].x[2] = i; d[t].y[2] = j; d[t].now = 2; }\n                }\n            }\n    }\n    public static void rewriteDict(Dictionary<char, Rec> d)\n    {\n        foreach (var x in d)\n        {\n            if (x.Value.x[1] == 0 && x.Value.x[3] == 0 && x.Value.y[1] == 0 && x.Value.y[3] == 0)\n            {\n                x.Value.x[1] = x.Value.x[0];\n                x.Value.x[3] = x.Value.x[2];\n                x.Value.y[1] = x.Value.y[0];\n                x.Value.y[3] = x.Value.y[2];\n                continue;\n            }\n            if (x.Value.x[2] == 0 && x.Value.x[3] == 0 && x.Value.y[2] == 0 && x.Value.y[3] == 0)\n            {\n                x.Value.x[2] = x.Value.x[0];\n                x.Value.x[3] = x.Value.x[1];\n                x.Value.y[2] = x.Value.y[0];\n                x.Value.y[3] = x.Value.y[1];\n                continue;\n            }\n            var xlist = new List<int>();\n            var ylist = new List<int>();\n            xlist.Add(x.Value.x[0]); ylist.Add(x.Value.y[0]);\n            if (x.Value.x[1] != 0 && x.Value.y[1] != 0) { xlist.Add(x.Value.x[1]); ylist.Add(x.Value.y[1]); }\n            if (x.Value.x[2] != 0 && x.Value.y[2] != 0) { xlist.Add(x.Value.x[2]); ylist.Add(x.Value.y[2]); }\n            if (x.Value.x[3] != 0 && x.Value.y[3] != 0) { xlist.Add(x.Value.x[3]); ylist.Add(x.Value.y[3]); }\n            var xmax = xlist.Max(); var xmin = xlist.Min();\n            var ymax = ylist.Max(); var ymin = ylist.Min();\n            x.Value.x[0] = xmin; x.Value.y[0] = ymin;\n            x.Value.x[1] = xmin; x.Value.y[1] = ymax;\n            x.Value.x[2] = xmax; x.Value.y[2] = ymin;\n            x.Value.x[3] = xmax; x.Value.y[3] = ymax;\n        }\n    }\n    public static bool checkFront(Dictionary<char, Rec> d, char[,] map)\n    {\n        var count = 0;\n        foreach (var x in d)\n        {\n            for (int i = x.Value.x[0]; i <= x.Value.x[2]; i++)\n                for (int j = x.Value.y[0]; j <= x.Value.y[1]; j++)\n                    if (map[i, j] != x.Key) goto next;\n            putAster(d, map, x.Key);\n            d[x.Key].delete = true;\n            count++;\n            next:;\n        }\n        return count >= 1;\n    }\n    public static int checkBack(Dictionary<char, Rec> d, char[,] map)\n    {\n        var count = 0;\n        foreach (var x in d)\n        {\n            if (!x.Value.delete)\n            {\n                var ok = true;\n                for (int i = x.Value.x[0]; i <= x.Value.x[2]; i++)\n                    for (int j = x.Value.y[0]; j <= x.Value.y[1]; j++)\n                    {\n                        if (map[i, j] == '.')\n                        {\n                            return -1;\n                        }\n                        if (map[i, j] != x.Key && map[i, j] != '*') ok = false;\n                    }\n                if (ok)\n                {\n                    putAster(d, map, x.Key);\n                    d[x.Key].delete = true;\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n    public static void putAster(Dictionary<char, Rec> d, char[,] map, char c)\n    {\n        for (int i = d[c].x[0]; i <= d[c].x[2]; i++)\n            for (int j = d[c].y[0]; j <= d[c].y[1]; j++)\n                map[i, j] = '*';\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class Rec\n{\n    public int[] x { get; set; }\n    public int[] y { get; set; }\n    public int now { get; set; }\n    public bool delete { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var n = int.Parse(Console.ReadLine().Trim());\n        for (int i = 0; i < n; i++)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var h = int.Parse(line[0]);\n            var w = int.Parse(line[1]);\n            var map = new char[h, w];\n            var hs = new HashSet<char>();\n            for (int j = 0; j < h; j++)\n            {\n                var s = Console.ReadLine().Trim();\n                for (int k = 0; k < w; k++)\n                {\n                    if (s[k] != '.') hs.Add(s[k]);\n                    map[j, k] = s[k];\n                }\n            }\n            var d = new Dictionary<char, Rec>();\n            foreach (var x in hs)\n                d[x] = new Rec { x = new int[4], y = new int[4], now = -1 };\n            writeDict(d, map);\n            if (d.Count() == 0) { Console.WriteLine(\"SAFE\"); goto end; }\n            rewriteDict(d);\n\n            if (!checkFront(d, map)) { Console.WriteLine(\"SUSPICIOUS\"); goto end; }\n            int ret;\n            while (true)\n            {\n                ret = checkBack(d, map);\n                if (ret == -1) { Console.WriteLine(\"SUSPICIOUS\"); break; }\n                else if (ret == 0) { Console.WriteLine(\"SAFE\"); break; }\n            }\n            end:;\n        }\n    }\n    public static void print(char[,] map)\n    {\n        var h = map.GetLength(0);\n        var w = map.GetLength(1);\n        for (int i = 0; i < h; i++)\n        {\n            var tt = new char[w];\n            for (int j = 0; j < w; j++) tt[j] = map[i, j];\n            Console.WriteLine(new string(tt));\n        }\n    }\n    public static void writeDict(Dictionary<char, Rec> d, char[,] map)\n    {\n        var h = map.GetLength(0);\n        var w = map.GetLength(1);\n        for (int i = 0; i < h; i++)\n            for (int j = 0; j < w; j++)\n            {\n                var t = map[i, j];\n                if (t != '.')\n                {\n                    var dt = d[t].now;\n                    if (dt == -1) { d[t].x[0] = i; d[t].y[0] = j; d[t].now = 0; }\n                    else if (dt == 0 && d[t].x[0] == i) { d[t].x[1] = i; d[t].y[1] = j; d[t].now = 1; }\n                    else if (dt == 0 && d[t].x[0] != i) { d[t].x[2] = i; d[t].y[2] = j; d[t].now = 2; }\n                    else if (dt == 1 && d[t].x[1] == i) { d[t].x[1] = i; d[t].y[1] = j; d[t].now = 1; }\n                    else if (dt == 1 && d[t].x[1] != i) { d[t].x[2] = i; d[t].y[2] = j; d[t].now = 2; }\n                    else if (dt == 2 && d[t].x[2] == i) { d[t].x[3] = i; d[t].y[3] = Math.Max(d[t].y[3],   j); d[t].now = 3; }\n                    else if (dt == 2 && d[t].x[2] != i) { d[t].x[2] = i; d[t].y[2] = j; d[t].now = 2; }\n                    else if (dt == 3 && d[t].x[3] == i) { d[t].x[3] = i; d[t].y[3] = Math.Max(d[t].y[3], j); d[t].now = 3; }\n                    else if (dt == 3 && d[t].x[3] != i) { d[t].x[2] = i; d[t].y[2] = j; d[t].now = 2; }\n                }\n            }\n    }\n    public static void rewriteDict(Dictionary<char, Rec> d)\n    {\n        foreach (var x in d)\n        {\n            if (x.Value.x[1] == 0 && x.Value.x[3] == 0 && x.Value.y[1] == 0 && x.Value.y[3] == 0)\n            {\n                x.Value.x[1] = x.Value.x[0];\n                x.Value.x[3] = x.Value.x[2];\n                x.Value.y[1] = x.Value.y[0];\n                x.Value.y[3] = x.Value.y[2];\n                continue;\n            }\n            if (x.Value.x[2] == 0 && x.Value.x[3] == 0 && x.Value.y[2] == 0 && x.Value.y[3] == 0)\n            {\n                x.Value.x[2] = x.Value.x[0];\n                x.Value.x[3] = x.Value.x[1];\n                x.Value.y[2] = x.Value.y[0];\n                x.Value.y[3] = x.Value.y[1];\n                continue;\n            }\n            if (x.Value.x[1] == 0 && x.Value.x[2] == 0 && x.Value.x[3] == 0 && x.Value.y[1] == 0 && x.Value.y[2] == 0 && x.Value.y[3] == 0)\n            {\n                x.Value.x[1] = x.Value.x[0];\n                x.Value.x[2] = x.Value.x[0];\n                x.Value.x[3] = x.Value.x[0];\n                x.Value.y[1] = x.Value.y[0];\n                x.Value.y[2] = x.Value.y[0];\n                x.Value.y[3] = x.Value.y[0];\n                continue;\n            }\n            var xlist = new List<int>();\n            var ylist = new List<int>();\n            xlist.Add(x.Value.x[0]); ylist.Add(x.Value.y[0]);\n            if (x.Value.x[1] != 0 && x.Value.y[1] != 0) { xlist.Add(x.Value.x[1]); ylist.Add(x.Value.y[1]); }\n            if (x.Value.x[2] != 0 && x.Value.y[2] != 0) { xlist.Add(x.Value.x[2]); ylist.Add(x.Value.y[2]); }\n            if (x.Value.x[3] != 0 && x.Value.y[3] != 0) { xlist.Add(x.Value.x[3]); ylist.Add(x.Value.y[3]); }\n            var xmax = xlist.Max(); var xmin = xlist.Min();\n            var ymax = ylist.Max(); var ymin = ylist.Min();\n            x.Value.x[0] = xmin; x.Value.y[0] = ymin;\n            x.Value.x[1] = xmin; x.Value.y[1] = ymax;\n            x.Value.x[2] = xmax; x.Value.y[2] = ymin;\n            x.Value.x[3] = xmax; x.Value.y[3] = ymax;\n        }\n    }\n    public static bool checkFront(Dictionary<char, Rec> d, char[,] map)\n    {\n        var count = 0;\n        foreach (var x in d)\n        {\n            for (int i = x.Value.x[0]; i <= x.Value.x[2]; i++)\n                for (int j = x.Value.y[0]; j <= x.Value.y[1]; j++)\n                    if (map[i, j] != x.Key) goto next;\n            putAster(d, map, x.Key);\n            d[x.Key].delete = true;\n            count++;\n            next:;\n        }\n        return count >= 1;\n    }\n    public static int checkBack(Dictionary<char, Rec> d, char[,] map)\n    {\n        var count = 0;  var notdel = 0;\n        foreach (var x in d)\n        {\n            if (!x.Value.delete)\n            {\n                notdel++;\n                var ok = true;\n                for (int i = x.Value.x[0]; i <= x.Value.x[2]; i++)\n                    for (int j = x.Value.y[0]; j <= x.Value.y[1]; j++)\n                    {\n                        if (map[i, j] == '.')\n                        {\n                            return -1;\n                        }\n                        if (map[i, j] != x.Key && map[i, j] != '*') ok = false;\n                    }\n                if (ok)\n                {\n                    putAster(d, map, x.Key);\n                    d[x.Key].delete = true;\n                    count++;\n                }\n            }\n        }\n        if (notdel > 0 && count > 0) return count;\n        else if (notdel > 0 && count == 0) return -1;\n        else return 0;\n    }\n    public static void putAster(Dictionary<char, Rec> d, char[,] map, char c)\n    {\n        for (int i = d[c].x[0]; i <= d[c].x[2]; i++)\n            for (int j = d[c].y[0]; j <= d[c].y[1]; j++)\n                map[i, j] = '*';\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class Rec\n{\n    public int[] x { get; set; }\n    public int[] y { get; set; }\n    public int now { get; set; }\n    public bool delete { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var n = int.Parse(Console.ReadLine().Trim());\n        for (int i = 0; i < n; i++)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var h = int.Parse(line[0]);\n            var w = int.Parse(line[1]);\n            var map = new char[h, w];\n            var hs = new HashSet<char>();\n            for (int j = 0; j < h; j++)\n            {\n                var s = Console.ReadLine().Trim();\n                for (int k = 0; k < w; k++)\n                {\n                    if (s[k] != '.') hs.Add(s[k]);\n                    map[j, k] = s[k];\n                }\n            }\n            var d = new Dictionary<char, Rec>();\n            foreach (var x in hs)\n                d[x] = new Rec { x = new int[4], y = new int[4], now = -1 };\n            writeDict(d, map);\n            if (d.Count() == 0) { Console.WriteLine(\"SAFE\"); goto end; }\n            rewriteDict(d);\n\n            if (!checkFront(d, map)) { Console.WriteLine(\"SUSPICIOUS\"); goto end; }\n            int ret;\n            while (true)\n            {\n                ret = checkBack(d, map);\n                if (ret == -1) { Console.WriteLine(\"SUSPICIOUS\"); break; }\n                else if (ret == 0) { Console.WriteLine(\"SAFE\"); break; }\n            }\n            end:;\n        }\n    }\n    public static void print(char[,] map)\n    {\n        var h = map.GetLength(0);\n        var w = map.GetLength(1);\n        for (int i = 0; i < h; i++)\n        {\n            var tt = new char[w];\n            for (int j = 0; j < w; j++) tt[j] = map[i, j];\n            Console.WriteLine(new string(tt));\n        }\n    }\n    public static void writeDict(Dictionary<char, Rec> d, char[,] map)\n    {\n        var h = map.GetLength(0);\n        var w = map.GetLength(1);\n        for (int i = 0; i < h; i++)\n            for (int j = 0; j < w; j++)\n            {\n                var t = map[i, j];\n                if (t != '.')\n                {\n                    var dt = d[t].now;\n                    if (dt == -1) { d[t].x[0] = i; d[t].y[0] = j; d[t].now = 0; }\n                    else if (dt == 0 && d[t].x[0] == i) { d[t].x[1] = i; d[t].y[1] = j; d[t].now = 1; }\n                    else if (dt == 0 && d[t].x[0] != i) { d[t].x[2] = i; d[t].y[2] = j; d[t].now = 2; }\n                    else if (dt == 1 && d[t].x[1] == i) { d[t].x[1] = i; d[t].y[1] = j; d[t].now = 1; }\n                    else if (dt == 1 && d[t].x[1] != i) { d[t].x[2] = i; d[t].y[2] = j; d[t].now = 2; }\n                    else if (dt == 2 && d[t].x[2] == i) { d[t].x[3] = i; d[t].y[3] = j; d[t].now = 3; }\n                    else if (dt == 2 && d[t].x[2] != i) { d[t].x[2] = i; d[t].y[2] = j; d[t].now = 2; }\n                    else if (dt == 3 && d[t].x[3] == i) { d[t].x[3] = i; d[t].y[3] = j; d[t].now = 3; }\n                    else if (dt == 3 && d[t].x[3] != i) { d[t].x[2] = i; d[t].y[2] = j; d[t].now = 2; }\n                }\n            }\n    }\n    public static void rewriteDict(Dictionary<char, Rec> d)\n    {\n        foreach (var x in d)\n        {\n            if (x.Value.x[1] == 0 && x.Value.x[3] == 0 && x.Value.y[1] == 0 && x.Value.y[3] == 0)\n            {\n                x.Value.x[1] = x.Value.x[0];\n                x.Value.x[3] = x.Value.x[2];\n                x.Value.y[1] = x.Value.y[0];\n                x.Value.y[3] = x.Value.y[2];\n                continue;\n            }\n            if (x.Value.x[2] == 0 && x.Value.x[3] == 0 && x.Value.y[2] == 0 && x.Value.y[3] == 0)\n            {\n                x.Value.x[2] = x.Value.x[0];\n                x.Value.x[3] = x.Value.x[1];\n                x.Value.y[2] = x.Value.y[0];\n                x.Value.y[3] = x.Value.y[1];\n                continue;\n            }\n            if (x.Value.x[1] == 0 && x.Value.x[2] == 0 && x.Value.x[3] == 0 && x.Value.y[1] == 0 && x.Value.y[2] == 0 && x.Value.y[3] == 0)\n            {\n                x.Value.x[1] = x.Value.x[0];\n                x.Value.x[2] = x.Value.x[0];\n                x.Value.x[3] = x.Value.x[0];\n                x.Value.y[1] = x.Value.y[0];\n                x.Value.y[2] = x.Value.y[0];\n                x.Value.y[3] = x.Value.y[0];\n                continue;\n            }\n            var xlist = new List<int>();\n            var ylist = new List<int>();\n            xlist.Add(x.Value.x[0]); ylist.Add(x.Value.y[0]);\n            if (x.Value.x[1] != 0 && x.Value.y[1] != 0) { xlist.Add(x.Value.x[1]); ylist.Add(x.Value.y[1]); }\n            if (x.Value.x[2] != 0 && x.Value.y[2] != 0) { xlist.Add(x.Value.x[2]); ylist.Add(x.Value.y[2]); }\n            if (x.Value.x[3] != 0 && x.Value.y[3] != 0) { xlist.Add(x.Value.x[3]); ylist.Add(x.Value.y[3]); }\n            var xmax = xlist.Max(); var xmin = xlist.Min();\n            var ymax = ylist.Max(); var ymin = ylist.Min();\n            x.Value.x[0] = xmin; x.Value.y[0] = ymin;\n            x.Value.x[1] = xmin; x.Value.y[1] = ymax;\n            x.Value.x[2] = xmax; x.Value.y[2] = ymin;\n            x.Value.x[3] = xmax; x.Value.y[3] = ymax;\n        }\n    }\n    public static bool checkFront(Dictionary<char, Rec> d, char[,] map)\n    {\n        var count = 0;\n        foreach (var x in d)\n        {\n            for (int i = x.Value.x[0]; i <= x.Value.x[2]; i++)\n                for (int j = x.Value.y[0]; j <= x.Value.y[1]; j++)\n                    if (map[i, j] != x.Key) goto next;\n            putAster(d, map, x.Key);\n            d[x.Key].delete = true;\n            count++;\n            next:;\n        }\n        return count >= 1;\n    }\n    public static int checkBack(Dictionary<char, Rec> d, char[,] map)\n    {\n        var count = 0;  var notdel = 0;\n        foreach (var x in d)\n        {\n            if (!x.Value.delete)\n            {\n                notdel++;\n                var ok = true;\n                for (int i = x.Value.x[0]; i <= x.Value.x[2]; i++)\n                    for (int j = x.Value.y[0]; j <= x.Value.y[1]; j++)\n                    {\n                        if (map[i, j] == '.')\n                        {\n                            return -1;\n                        }\n                        if (map[i, j] != x.Key && map[i, j] != '*') ok = false;\n                    }\n                if (ok)\n                {\n                    putAster(d, map, x.Key);\n                    d[x.Key].delete = true;\n                    count++;\n                }\n            }\n        }\n        if (notdel > 0 && count > 0) return count;\n        else if (notdel > 0 && count == 0) return -1;\n        else return 0;\n    }\n    public static void putAster(Dictionary<char, Rec> d, char[,] map, char c)\n    {\n        for (int i = d[c].x[0]; i <= d[c].x[2]; i++)\n            for (int j = d[c].y[0]; j <= d[c].y[1]; j++)\n                map[i, j] = '*';\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class Rec\n{\n    public int[] x { get; set; }\n    public int[] y { get; set; }\n    public int now { get; set; }\n    public bool delete { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var n = int.Parse(Console.ReadLine().Trim());\n        for (int i = 0; i < n; i++)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var h = int.Parse(line[0]);\n            var w = int.Parse(line[1]);\n            if (i == 394) Console.WriteLine(\"h = {0} w = {1}\", h, w);\n            var map = new char[h, w];\n            var hs = new HashSet<char>();\n            for (int j = 0; j < h; j++)\n            {\n                var s = Console.ReadLine().Trim();\n                for (int k = 0; k < w; k++)\n                {\n                    if (s[k] != '.') hs.Add(s[k]);\n                    map[j, k] = s[k];\n                }\n            }\n            var d = new Dictionary<char, Rec>();\n            foreach (var x in hs)\n                d[x] = new Rec { x = new int[4], y = new int[4], now = -1 };\n            writeDict(d, map);\n            if (d.Count() == 0) { Console.WriteLine(\"SAFE\"); goto end; }\n            rewriteDict(d);\n\n            if (!checkFront(d, map)) { Console.WriteLine(\"SUSPICIOUS\"); goto end; }\n            int ret;\n            while (true)\n            {\n                ret = checkBack(d, map);\n                if (ret == -1) { Console.WriteLine(\"SUSPICIOUS\"); break; }\n                else if (ret == 0) { Console.WriteLine(\"SAFE\"); break; }\n            }\n            end:;\n        }\n    }\n    public static void print(char[,] map)\n    {\n        var h = map.GetLength(0);\n        var w = map.GetLength(1);\n        for (int i = 0; i < h; i++)\n        {\n            var tt = new char[w];\n            for (int j = 0; j < w; j++) tt[j] = map[i, j];\n            Console.WriteLine(new string(tt));\n        }\n    }\n    public static void writeDict(Dictionary<char, Rec> d, char[,] map)\n    {\n        var h = map.GetLength(0);\n        var w = map.GetLength(1);\n        for (int i = 0; i < h; i++)\n            for (int j = 0; j < w; j++)\n            {\n                var t = map[i, j];\n                if (t != '.')\n                {\n                    var dt = d[t].now;\n                    if (dt == -1) { d[t].x[0] = i; d[t].y[0] = j; d[t].now = 0; }\n                    else if (dt == 0 && d[t].x[0] == i) { d[t].x[1] = i; d[t].y[1] = j; d[t].now = 1; }\n                    else if (dt == 0 && d[t].x[0] != i) { d[t].x[2] = i; d[t].y[2] = j; d[t].now = 2; }\n                    else if (dt == 1 && d[t].x[1] == i) { d[t].x[1] = i; d[t].y[1] = j; d[t].now = 1; }\n                    else if (dt == 1 && d[t].x[1] != i) { d[t].x[2] = i; d[t].y[2] = Math.Min(d[t].y[2], j); d[t].now = 2; }\n                    else if (dt == 2 && d[t].x[2] == i) { d[t].x[3] = i; d[t].y[3] = Math.Max(d[t].y[3], j); d[t].now = 3; }\n                    else if (dt == 2 && d[t].x[2] != i) { d[t].x[2] = i; d[t].y[2] = Math.Min(d[t].y[2], j); d[t].now = 2; }\n                    else if (dt == 3 && d[t].x[3] == i) { d[t].x[3] = i; d[t].y[3] = Math.Max(d[t].y[3], j); d[t].now = 3; }\n                    else if (dt == 3 && d[t].x[3] != i) { d[t].x[2] = i; d[t].y[2] = Math.Min(d[t].y[2], j); d[t].now = 2; }\n                }\n            }\n    }\n    public static void rewriteDict(Dictionary<char, Rec> d)\n    {\n        foreach (var x in d)\n        {\n            if (x.Value.x[1] == 0 && x.Value.x[3] == 0 && x.Value.y[1] == 0 && x.Value.y[3] == 0)\n            {\n                x.Value.x[1] = x.Value.x[0];\n                x.Value.x[3] = x.Value.x[2];\n                x.Value.y[1] = x.Value.y[0];\n                x.Value.y[3] = x.Value.y[2];\n                continue;\n            }\n            if (x.Value.x[2] == 0 && x.Value.x[3] == 0 && x.Value.y[2] == 0 && x.Value.y[3] == 0)\n            {\n                x.Value.x[2] = x.Value.x[0];\n                x.Value.x[3] = x.Value.x[1];\n                x.Value.y[2] = x.Value.y[0];\n                x.Value.y[3] = x.Value.y[1];\n                continue;\n            }\n            if (x.Value.x[1] == 0 && x.Value.x[2] == 0 && x.Value.x[3] == 0 && x.Value.y[1] == 0 && x.Value.y[2] == 0 && x.Value.y[3] == 0)\n            {\n                x.Value.x[1] = x.Value.x[0];\n                x.Value.x[2] = x.Value.x[0];\n                x.Value.x[3] = x.Value.x[0];\n                x.Value.y[1] = x.Value.y[0];\n                x.Value.y[2] = x.Value.y[0];\n                x.Value.y[3] = x.Value.y[0];\n                continue;\n            }\n            var xlist = new List<int>();\n            var ylist = new List<int>();\n            xlist.Add(x.Value.x[0]); ylist.Add(x.Value.y[0]);\n            if (!(x.Value.x[1] == 0 && x.Value.y[1] == 0)) { xlist.Add(x.Value.x[1]); ylist.Add(x.Value.y[1]); }\n            if (!(x.Value.x[2] == 0 && x.Value.y[2] == 0))\n            {\n                xlist.Add(x.Value.x[2]);\n                ylist.Add(x.Value.y[2]);\n            }\n            if (!(x.Value.x[3] == 0 && x.Value.y[3] == 0)) { xlist.Add(x.Value.x[3]); ylist.Add(x.Value.y[3]); }\n            var xmax = xlist.Max(); var xmin = xlist.Min();\n            var ymax = ylist.Max(); var ymin = ylist.Min();\n            x.Value.x[0] = xmin; x.Value.y[0] = ymin;\n            x.Value.x[1] = xmin; x.Value.y[1] = ymax;\n            x.Value.x[2] = xmax; x.Value.y[2] = ymin;\n            x.Value.x[3] = xmax; x.Value.y[3] = ymax;\n        }\n    }\n    public static bool checkFront(Dictionary<char, Rec> d, char[,] map)\n    {\n        var count = 0;\n        foreach (var x in d)\n        {\n            for (int i = x.Value.x[0]; i <= x.Value.x[2]; i++)\n                for (int j = x.Value.y[0]; j <= x.Value.y[1]; j++)\n                    if (map[i, j] != x.Key) goto next;\n            putAster(d, map, x.Key);\n            d[x.Key].delete = true;\n            count++;\n            next:;\n        }\n        return count >= 1;\n    }\n    public static int checkBack(Dictionary<char, Rec> d, char[,] map)\n    {\n        var count = 0; var notdel = 0;\n        foreach (var x in d)\n        {\n            if (!x.Value.delete)\n            {\n                notdel++;\n                var ok = true;\n                for (int i = x.Value.x[0]; i <= x.Value.x[2]; i++)\n                    for (int j = x.Value.y[0]; j <= x.Value.y[1]; j++)\n                    {\n                        if (map[i, j] == '.')\n                        {\n                            return -1;\n                        }\n                        if (map[i, j] != x.Key && map[i, j] != '*') ok = false;\n                    }\n                if (ok)\n                {\n                    putAster(d, map, x.Key);\n                    d[x.Key].delete = true;\n                    count++;\n                }\n            }\n        }\n        if (notdel > 0 && count > 0) return count;\n        else if (notdel > 0 && count == 0) return -1;\n        else return 0;\n    }\n    public static void putAster(Dictionary<char, Rec> d, char[,] map, char c)\n    {\n        for (int i = d[c].x[0]; i <= d[c].x[2]; i++)\n            for (int j = d[c].y[0]; j <= d[c].y[1]; j++)\n                map[i, j] = '*';\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using static System.Math;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n    public int xmax { get; set; }\n    public int xmin { get; set; }\n    public int ymax { get; set; }\n    public int ymin { get; set; }\n}\n\npublic class hello\n{\n    public static int h, w;\n    public static void Main()\n    {\n        var n = int.Parse(Console.ReadLine().Trim());\n        var p = 0;\n        while (p++ < n)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            h = int.Parse(line[0]);\n            w = int.Parse(line[1]);\n            var map = new int[h, w];\n            var d = new Dictionary<char, int>();\n            var dp = 0;\n            for (int i = 0; i < h; i++)\n            {\n                var s = Console.ReadLine().Trim();\n                for (int j = 0; j < w; j++)\n                {\n                    var ss = s[j];\n                    if (ss != '.')\n                    {\n                        if (!d.ContainsKey(ss)) d[ss] = dp++;\n                        map[i, j] = d[ss];\n                    }\n                    else map[i, j] = 9;\n                }\n            }\n            var ps = getPs(map, dp);\n            getAns(map, dp, ps);\n        }\n    }\n    static bool check (int[,] map, P[] ps, int t)\n    {\n        for (int i = ps[t].xmin; i <= ps[t].xmax; i++)\n            for (int j = ps[t].ymin; j <= ps[t].ymax; j++)\n            {\n                if (!(map[i, j] == t | map[i, j] == 8)) return false;\n            }\n        for (int i = ps[t].xmin; i <= ps[t].xmax; i++)\n            for (int j = ps[t].ymin; j <= ps[t].ymax; j++)\n                map[i, j] = 8;\n        return true;\n\n    }\n    static void getAns (int[,] map, int dp, P[] ps )\n    {\n        var count = 0;\n        while (true)\n        {\n            var change= false;\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    var t = map[i, j];\n                    if (t <= 6)\n                    {\n                        if (check(map, ps, t)) { change = true; count++; }\n                    }\n                }\n            }\n            if (!change) break;\n        }\n        Console.WriteLine(count == dp? \"SAFE\": \"SUSPICIOUS\");\n    }\n    static P[] getPs(int[,] map, int dp)\n    {\n        var ps = new P[dp];\n        for (int i = 0; i < dp; i++)\n            ps[i] = new P { xmax = 0, ymax = 0, xmin = int.MaxValue, ymin = int.MaxValue };\n        for (int i = 0; i < h; i++)\n        {\n            for (int j = 0; j < w; j++)\n            {\n                var mp = map[i, j];\n                if (mp <= 6)\n                {\n                    ps[mp].xmax = Max(ps[mp].xmax, i);\n                    ps[mp].ymax = Max(ps[mp].ymax, j);\n                    ps[mp].xmin = Min(ps[mp].xmin, i);\n                    ps[mp].ymin = Min(ps[mp].ymin, j);\n                }\n            }\n        }\n        return ps;\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace X_Ray_Screening_System\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            for (int i = 0; i < n; i++)\n            {\n                string[] strs = Console.ReadLine().Split(' ');\n                int height = int.Parse(strs[0]);\n                int width = int.Parse(strs[1]);\n\n                Screen screen = new Screen(width, height);\n                for (int y = 0; y < height; y++)\n                {\n                    char[] marks = Console.ReadLine().ToCharArray();\n                    for (int x = 0; x < marks.Length; x++)\n                    {\n                        screen.SetShadow(x, y, marks[x]);\n                    }\n                }\n                screen.Scan();\n                if (screen.IsSafe()) Console.WriteLine(\"SAFE\");\n                else Console.WriteLine(\"SUSPICIOUS\");\n            }\n        }\n    }\n\n    public class Point {\n        public int X { get; set;}\n        public int Y { get; set;}\n\n        public Point(int x, int y)\n        {\n            X = x;\n            Y = y;\n        }\n    }\n\n    public class Baggage\n    {\n        public char Mark { get; private set; }\n\n        public Point LeftTop { get; private set; }\n        public Point RightBottom { get; private set; }\n\n        public Baggage(int x, int y , char mark)\n        {\n            Mark = mark;\n            LeftTop = new Point(x, y);\n            RightBottom = new Point(x, y);\n        }\n\n        public void SetExpectedMark(int x, int y)\n        {\n            if (LeftTop.X > x) LeftTop.X = x;\n            if (LeftTop.Y > y) LeftTop.Y = y;\n\n            if (RightBottom.X < x) RightBottom.X = x;\n            if (RightBottom.Y < y) RightBottom.Y = y;\n        }\n\n    }\n\n    public class Screen\n    {\n        private int width;\n        private int height;\n        private char[,] grids;\n        private List<Baggage> baggages;\n\n        public Screen(int width, int height)\n        {\n            this.width = width;\n            this.height = height;\n\n            baggages = new List<Baggage>();\n\n            grids = new char[width, height];\n            for (int y = 0; y < height; y++)\n            {\n                for (int x = 0; x < width; x++)\n                {\n                    grids[x, y] = '.';\n                }\n            }\n        }\n\n        public void Scan()\n        {\n            for (int y = 0; y < height; y++)\n            {\n                for (int x = 0; x < width; x++)\n                {\n                    if (grids[x, y] != '.')\n                    {\n                        bool isFirst = true;\n                        foreach (Baggage baggage in baggages)\n                        {\n                            if (baggage.Mark.Equals(grids[x, y])){\n                                baggage.SetExpectedMark(x, y);\n                                isFirst = false;\n                                break;\n                            }\n                        }\n                        if (isFirst)\n                        {\n                            baggages.Add(new Baggage(x, y, grids[x, y]));\n                        }\n                    }\n                }\n            }\n        }\n\n        public bool IsSafe()\n        {\n            foreach (Baggage baggage in baggages)\n            {\n                Console.WriteLine(\"baggageMark:\" + baggage.Mark +\n                    \"(\" + baggage.LeftTop.X + \".\" + baggage.LeftTop.Y + \")\" +\n                    \"(\" + baggage.RightBottom.X + \".\" + baggage.RightBottom.Y + \")\"\n                    );\n                for (int y = baggage.LeftTop.Y; y < baggage.RightBottom.Y; y++)\n                {\n                    for (int x = baggage.LeftTop.X; x < baggage.RightBottom.X; x++)\n                    {\n                        if (grids[x, y] == '.') return false;\n                    }\n                }\n            }\n            return true;\n        }\n\n        public void SetShadow(int x, int y, char mark)\n        {\n            grids[x, y] = mark;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class Rec\n{\n    public int[] x { get; set; }\n    public int[] y { get; set; }\n    public int now { get; set; }\n    public bool delete { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var n = int.Parse(Console.ReadLine().Trim());\n        for (int i = 0; i < n; i++)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var h = int.Parse(line[0]);\n            var w = int.Parse(line[1]);\n            var map = new char[h, w];\n            var hs = new HashSet<char>();\n            for (int j = 0; j < h; j++)\n            {\n                var s = Console.ReadLine().Trim();\n                for (int k = 0; k < w; k++)\n                {\n                    if (s[k] != '.') hs.Add(s[k]);\n                    map[j, k] = s[k];\n                }\n            }\n            var d = new Dictionary<char, Rec>();\n            foreach (var x in hs)\n                d[x] = new Rec { x = new int[4], y = new int[4], now = -1 };\n            writeDict(d, map);\n            if (d.Count() == 0) { Console.WriteLine(\"SAFE\"); goto end; }\n            rewriteDict(d);\n\n            if (!checkFront(d, map)) { Console.WriteLine(\"SUSPICIOUS\"); goto end; }\n            int ret;\n            while (true)\n            {\n                ret = checkBack(d, map);\n                if (ret == -1) { Console.WriteLine(\"SUSPICIOUS\"); break; }\n                else if (ret == 0) { Console.WriteLine(\"SAFE\"); break; }\n            }\n            end:;\n        }\n    }\n    public static void print(char[,] map)\n    {\n        var h = map.GetLength(0);\n        var w = map.GetLength(1);\n        for (int i = 0; i < h; i++)\n        {\n            var tt = new char[w];\n            for (int j = 0; j < w; j++) tt[j] = map[i, j];\n            Console.WriteLine(new string(tt));\n        }\n    }\n    public static void writeDict(Dictionary<char, Rec> d, char[,] map)\n    {\n        var h = map.GetLength(0);\n        var w = map.GetLength(1);\n        for (int i = 0; i < h; i++)\n            for (int j = 0; j < w; j++)\n            {\n                var t = map[i, j];\n                if (t != '.')\n                {\n                    var dt = d[t].now;\n                    if (dt == -1) { d[t].x[0] = i; d[t].y[0] = j; d[t].now = 0; }\n                    else if (dt == 0 && d[t].x[0] == i) { d[t].x[1] = i; d[t].y[1] = j; d[t].now = 1; }\n                    else if (dt == 0 && d[t].x[0] != i) { d[t].x[2] = i; d[t].y[2] = j; d[t].now = 2; }\n                    else if (dt == 1 && d[t].x[1] == i) { d[t].x[1] = i; d[t].y[1] = j; d[t].now = 1; }\n                    else if (dt == 1 && d[t].x[1] != i) { d[t].x[2] = i; d[t].y[2] = j; d[t].now = 2; }\n                    else if (dt == 2 && d[t].x[2] == i) { d[t].x[3] = i; d[t].y[3] = Math.Max(d[t].y[3], j); d[t].now = 3; }\n                    else if (dt == 2 && d[t].x[2] != i) { d[t].x[2] = i; d[t].y[2] = Math.Min(d[t].y[2], j); d[t].now = 2; }\n                    else if (dt == 3 && d[t].x[3] == i) { d[t].x[3] = i; d[t].y[3] = Math.Max(d[t].y[3], j); d[t].now = 3; }\n                    else if (dt == 3 && d[t].x[3] != i) { d[t].x[2] = i; d[t].y[2] = Math.Min(d[t].y[2], j); d[t].now = 2; }\n                }\n            }\n    }\n    public static void rewriteDict(Dictionary<char, Rec> d)\n    {\n        foreach (var x in d)\n        {\n            if (x.Value.x[1] == 0 && x.Value.x[3] == 0 && x.Value.y[1] == 0 && x.Value.y[3] == 0)\n            {\n                x.Value.x[1] = x.Value.x[0];\n                x.Value.x[3] = x.Value.x[2];\n                x.Value.y[1] = x.Value.y[0];\n                x.Value.y[3] = x.Value.y[2];\n                continue;\n            }\n            if (x.Value.x[2] == 0 && x.Value.x[3] == 0 && x.Value.y[2] == 0 && x.Value.y[3] == 0)\n            {\n                x.Value.x[2] = x.Value.x[0];\n                x.Value.x[3] = x.Value.x[1];\n                x.Value.y[2] = x.Value.y[0];\n                x.Value.y[3] = x.Value.y[1];\n                continue;\n            }\n            if (x.Value.x[1] == 0 && x.Value.x[2] == 0 && x.Value.x[3] == 0 && x.Value.y[1] == 0 && x.Value.y[2] == 0 && x.Value.y[3] == 0)\n            {\n                x.Value.x[1] = x.Value.x[0];\n                x.Value.x[2] = x.Value.x[0];\n                x.Value.x[3] = x.Value.x[0];\n                x.Value.y[1] = x.Value.y[0];\n                x.Value.y[2] = x.Value.y[0];\n                x.Value.y[3] = x.Value.y[0];\n                continue;\n            }\n            var xlist = new List<int>();\n            var ylist = new List<int>();\n            xlist.Add(x.Value.x[0]); ylist.Add(x.Value.y[0]);\n            if (x.Value.x[1] != 0 && x.Value.y[1] != 0) { xlist.Add(x.Value.x[1]); ylist.Add(x.Value.y[1]); }\n            if (x.Value.x[2] != 0 && x.Value.y[2] != 0) { xlist.Add(x.Value.x[2]); ylist.Add(x.Value.y[2]); }\n            if (x.Value.x[3] != 0 && x.Value.y[3] != 0) { xlist.Add(x.Value.x[3]); ylist.Add(x.Value.y[3]); }\n            var xmax = xlist.Max(); var xmin = xlist.Min();\n            var ymax = ylist.Max(); var ymin = ylist.Min();\n            x.Value.x[0] = xmin; x.Value.y[0] = ymin;\n            x.Value.x[1] = xmin; x.Value.y[1] = ymax;\n            x.Value.x[2] = xmax; x.Value.y[2] = ymin;\n            x.Value.x[3] = xmax; x.Value.y[3] = ymax;\n        }\n    }\n    public static bool checkFront(Dictionary<char, Rec> d, char[,] map)\n    {\n        var count = 0;\n        foreach (var x in d)\n        {\n            for (int i = x.Value.x[0]; i <= x.Value.x[2]; i++)\n                for (int j = x.Value.y[0]; j <= x.Value.y[1]; j++)\n                    if (map[i, j] != x.Key) goto next;\n            putAster(d, map, x.Key);\n            d[x.Key].delete = true;\n            count++;\n            next:;\n        }\n        return count >= 1;\n    }\n    public static int checkBack(Dictionary<char, Rec> d, char[,] map)\n    {\n        var count = 0; var notdel = 0;\n        foreach (var x in d)\n        {\n            if (!x.Value.delete)\n            {\n                notdel++;\n                var ok = true;\n                for (int i = x.Value.x[0]; i <= x.Value.x[2]; i++)\n                    for (int j = x.Value.y[0]; j <= x.Value.y[1]; j++)\n                    {\n                        if (map[i, j] == '.')\n                        {\n                            return -1;\n                        }\n                        if (map[i, j] != x.Key && map[i, j] != '*') ok = false;\n                    }\n                if (ok)\n                {\n                    putAster(d, map, x.Key);\n                    d[x.Key].delete = true;\n                    count++;\n                }\n            }\n        }\n        if (notdel > 0 && count > 0) return count;\n        else if (notdel > 0 && count == 0) return -1;\n        else return 0;\n    }\n    public static void putAster(Dictionary<char, Rec> d, char[,] map, char c)\n    {\n        for (int i = d[c].x[0]; i <= d[c].x[2]; i++)\n            for (int j = d[c].y[0]; j <= d[c].y[1]; j++)\n                map[i, j] = '*';\n    }\n}\n\n\n"
  },
  {
    "language": "JavaScript",
    "code": "var q, n, m;\nvar x = [];\nvar s, t, g, d;\n\nfunction dfs(i){\n\td[i] = 1;\n\tfor(var j in g[i]){\n\t\tif(!d[j]){\n\t\t\tif(dfs(j)){\n\t\t\t\treturn true;\n\t\t\t} \n\t\t}\n\t\telse if(d[j] === 1){\n\t\t\treturn true;\n\t\t}\n\t}\n\td[i] = 2;\n\treturn false;\n}\n\nfunction main(){\n\tq = scan();\n\trep(q, function(z){\n\t\ts = {};\n\t\tt = {};\n\t\tg = {};\n\t\td = {};\n\n\t\tn = scan();\n\t\tm = scan();\n\t\trep(n, function(i){\n\t\t\tx[i] = scan_string().split('');\n\t\t});\n\n\t\trep(n, function(i){\n\t\t\trep(m, function(j){\n\t\t\t\tvar a = x[i][j];\n\t\t\t\tif(a == '.'){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(!s[a]){\n\t\t\t\t\ts[a] = [i, j];\n\t\t\t\t\tt[a] = [i, j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ts[a] = [Math.min(i, s[a][0]), Math.min(j, s[a][1])];\n\t\t\t\t\tt[a] = [Math.max(i, t[a][0]), Math.max(j, t[a][1])];\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\tfor(var a in s){\n\t\t\tg[a] = {};\n\t\t}\n\n\t\tvar b = true;\n\t\tfor(var a in s){\n\t\t\trep(s[a][0], t[a][0] + 1, function(i){\n\t\t\t\trep(s[a][1], t[a][1] + 1, function(j){\n\t\t\t\t\tif(x[i][j] == '.'){\n\t\t\t\t\t\tb = false;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\telse if(x[i][j] != a){\n\t\t\t\t\t\tg[a][x[i][j]] = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif(!b){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif(!b){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!b){\n\t\t\tprint('SUSPICIOUS');\n\t\t\treturn;\n\t\t}\n\n\t\tfor(var a in s){\n\t\t\tif(!d[a] && dfs(a)){\n\t\t\t\tprint('SUSPICIOUS');\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tprint('SAFE');\n\t});\n}\n\nfunction rep(a, b, c){\n\tif(c === undefined){\n\t\tc = b;\n\t\tb = a;\n\t\ta = 0;\n\t}\n\tfor(var i = a; i < b; ++i){\n\t\tif(c(i) === false){\n\t\t\tbreak;\n\t\t}\n\t}\n}\n \nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\n \nvar input = '';\nvar input_index = 0;\n \nfunction scan(){\n\treturn +input[input_index++];\n}\n\nfunction scan_string(){\n\treturn input[input_index++];\n}\n \nfunction print(val){\n\tconsole.log(val);\n}\n \nprocess.stdin.on('data', function(chunk){\n\tinput += chunk;\n});\nprocess.stdin.on('end', function(){\n\tinput = input.trim().split(/\\s+/);\n\tmain();\n});"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef over?(ovws, m, i, k)\n  for j in (0...m)\n    if ovws[i][j]\n      return true if j == k\n      return true if over?(ovws, m, j, k)\n    end\n  end\n  false\nend\n\n### main\n\nn = gets.to_i\n\nn.times do\n  h, w = gets.split.map(&:to_i)\n  lines = Array.new(h){gets.strip}\n  \n  m = 0\n  mchs = []\n  mchhash = {}\n  mrects = []\n\n  for y in (0...h)\n    for x in (0...w)\n      ch = lines[y][x]\n      if ch >= 'A' && ch <= 'Z'\n        if mchhash[ch].nil?\n          mchhash[ch] = m\n          mchs[m] = ch\n          mrects[m] = [x, y, x, y]\n          m += 1\n        end\n\n        k = mchhash[ch]\n        mrects[k][0] = x if mrects[k][0] > x\n        mrects[k][1] = y if mrects[k][1] > y\n        mrects[k][2] = x if mrects[k][2] < x\n        mrects[k][3] = y if mrects[k][3] < y\n      end\n    end\n  end\n  #p mrects\n\n  ovws = Array.new(m){Array.new(m){false}}\n  ok = true\n\n  for i in (0...m)\n    mch = mchs[i]\n    x0, y0, x1, y1 = mrects[i]\n    for y in (y0..y1)\n      for x in (x0..x1)\n        ch = lines[y][x]\n        if ch != mch\n          if ch == '.'\n            ok = false\n            break\n          end\n\n          k = mchhash[ch]\n          if over?(ovws, m, k, i)\n            ok = false\n            break\n          end\n          ovws[i][k] = true\n        end\n      end\n\n      break if ! ok\n    end\n  end\n\n  puts ok ? \"SAFE\" : \"SUSPICIOUS\"\nend"
  },
  {
    "language": "Ruby",
    "code": "def solve(f, p)\n    p.each do |c|\n        t = l = 100\n        b = r = -1\n        f.each_with_index do |row, i|\n            row.each_char.with_index do |ch, j|\n                if ch == c\n                    t = i if i < t\n                    l = j if j < l\n                    b = i if i > b\n                    r = j if j > r\n                end\n            end\n        end\n        for i in t..b\n            for j in l..r\n                return false if f[i][j] != c && f[i][j] != \"*\"\n                f[i][j] = \"*\"\n            end\n        end\n    end\n    return true\nend\n\nn = gets.to_i\nn.times do\n    h, w = gets.split.map(&:to_i)\n    f = h.times.map{gets.chomp}\n    keys = Array.new\n    f.each do |r|\n        r.each_char do |c|\n            keys.push(c) if !keys.include?(c) && c != \".\"\n        end\n    end\n    if keys.empty?\n        puts \"SAFE\"\n        next\n    end\n    b = false\n    keys.permutation(keys.size) do |p|\n        b = solve(Marshal.load(Marshal.dump(f)), p)\n        break if b\n    end\n    puts b ? \"SAFE\" : \"SUSPICIOUS\"\nend"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\nn.times do\n    h, w = gets.split.map(&:to_i)\n    f = h.times.map{gets.chomp}\n    keys = Array.new\n    f.each do |r|\n        r.each_char do |c|\n            keys.push(c) if !keys.include?(c) && c != \".\"\n        end\n    end\n    if keys.empty?\n        puts \"SAFE\"\n        next\n    end\n    b = true\n    keys.permutation(keys.size) do |p|\n        b = true\n        done = Array.new\n        p.each do |c|\n            t = l = 100\n            b = r = -1\n            f.each_with_index do |row, i|\n                row.each_char.with_index do |ch, j|\n                    if ch == c\n                        t = i if i < t\n                        l = j if j < l\n                        b = i if i > b\n                        r = j if j > r\n                    end\n                end\n            end\n            for i in t..b\n                for j in l..r\n                    if f[i][j] != c && !done.include?(f[i][j])\n                        b = false\n                    end\n                    break if !b\n                end\n            end\n            break if !b\n            done.push(c)\n        end\n        break if b\n    end\n    puts b ? \"SAFE\" : \"SUSPICIOUS\"\nend"
  },
  {
    "language": "Ruby",
    "code": "def get_rect(c)\n\tx1 = x2 = y1 = y2 = -1\n\n\t0.upto($h-1) do |y|\n\t\t0.upto($w-1) do |x|\n\t\t\tif $d[y][x] == c then\n\t\t\t\ty2 = y\n\t\t\t\tnext\n\t\t\tend\n\t\tend\n\tend\n\n\t($h-1).downto(0) do |y|\n\t\t0.upto($w-1) do |x|\n\t\t\tif $d[y][x] == c then\n\t\t\t\ty1 = y\n\t\t\t\tnext\n\t\t\tend\n\t\tend\n\tend\n\n\t0.upto($w-1) do |x|\n\t\t0.upto($h-1) do |y|\n\t\t\tif $d[y][x] == c then\n\t\t\t\tx2 = x\n\t\t\t\tnext\n\t\t\tend\n\t\tend\n\tend\n\n\t($w-1).downto(0) do |x|\n\t\t0.upto($h-1) do |y|\n\t\t\tif $d[y][x] == c then\n\t\t\t\tx1 = x\n\t\t\t\tnext\n\t\t\tend\n\t\tend\n\tend\n\n\treturn x1, x2, y1, y2\nend\n\ndef check(c)\n\tx1, x2, y1, y2 = get_rect(c)\n\n\tfor y in y1 .. y2\n\t\tfor x in x1 .. x2\n\t\t\tif $d[y][x] == '.' then\n\t\t\t\treturn false\n\t\t\telsif $mt.find_index($d[y][x]) != nil then\n\t\t\t\treturn false\n\t\t\tend\n\t\tend\n\tend\n\n\t$mt.push c\n\n\tfor y in y1 .. y2\n\t\tfor x in x1 .. x2\n\t\t\tif $d[y][x] != c && $d[y][x] != ' ' then\n\t\t\t\tif check($d[y][x]) == false then\n\t\t\t\t\treturn false\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\tfor y in y1 .. y2\n\t\tfor x in x1 .. x2\n\t\t\tif $d[y][x] == c then\n\t\t\t\t$d[y][x] = ' '\n\t\t\tend\n\t\tend\n\tend\n\n\treturn true\nend\n\ndef search()\n\t$h.times do |y|\n\t\t$w.times do |x|\n\t\t\tif $d[y][x] != '.' && $d[y][x] != ' ' then\n\t\t\t\tif check($d[y][x]) == false then\n\t\t\t\t\treturn false\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\treturn true\nend\n\nn = gets.to_i\n\nn.times do\n\t$h, $w = gets.split.map(&:to_i)\n\n\t$d = []\n\t$h.times do\n\t\t$d.push gets.chomp.split('')\n\tend\n\n\t$mt = []\n\n\tputs search() ? \"SAFE\" : \"SUSPICIOUS\"\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\ndef scan_field f\n  loc_dic = {}\n  f.each_with_index {|row, rowi|\n    row.each_with_index {|v, coli|\n      loc_dic[v] = (loc_dic[v] || [[INF, INF], [-INF, -INF]]).zip([:min, :max]).map {|(pos, p)| pos.zip([rowi, coli]).map(&p) }  unless v == '.'\n    }\n  }\n\n  remain = Set.new loc_dic.keys\n  unsafe = false\n  until remain.empty?\n    before_remain = remain.dup\n    remain.each {|v|\n      case scan_object f, loc_dic[v], v, remain\n      when :safe\n        remain.delete v\n      when :unsafe\n        return :unsafe\n      end\n    }\n    return :unsafe if remain == before_remain\n  end\n  :safe\nend\n\ndef scan_object f, loc, expect, remain\n  row_range = loc[0][0]..loc[1][0]\n  col_range = loc[0][1]..loc[1][1]\n  row_range.each {|rowi|\n    col_range.each {|coli|\n      v = f[rowi][coli]\n      return :unsafe if v == '.'\n      return :indeterminate if v != expect && remain.include?(v)\n    }\n  }\n  return :safe\nend\n\nINF = 2 << 32\ngets.to_i.times {\n  h, w = gets.split(' ').map(&:to_i)\n  f = h.times.map { gets.chomp.each_char.to_a }\n  puts(scan_field(f) == :safe ? 'SAFE' : 'SUSPICIOUS')\n}"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\nn.times do\n    h, w = gets.split.map(&:to_i)\n    f = h.times.map{gets.chomp}\n    keys = Array.new\n    f.each do |r|\n        r.each_char do |c|\n            keys.push(c) if !keys.include?(c) && c != \".\"\n        end\n    end\n    if keys.empty?\n        puts \"SAFE\"\n        next\n    end\n    b = true\n    rec = Hash.new(Array.new(4))\n    f.each_with_index do |row, i|\n        row.each_char.with_index do |ch, j|\n            if !rec.has_key?(ch)\n                rec[ch] = [i,j,i,j]\n            else\n                rec[ch][0] = i if i < rec[ch][0]\n                rec[ch][1] = j if j < rec[ch][1]\n                rec[ch][2] = i if i > rec[ch][2]\n                rec[ch][3] = j if j > rec[ch][3]\n            end\n        end\n    end\n    keys.permutation(keys.size) do |p|\n        b = true\n        done = Hash.new(false)\n        p.each do |c|\n            for i in rec[c][0]..rec[c][2]\n                for j in rec[c][1]..rec[c][3]\n                    if f[i][j] != c && !done[f[i][j]]\n                        b = false\n                    end\n                    break if !b\n                end\n            end\n            break if !b\n            done[c] = true\n        end\n        break if b\n    end\n    puts b ? \"SAFE\" : \"SUSPICIOUS\"\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nn = gets.to_i\nn.times do\n\th, w = gets.split.map(&:to_i)\n\ta = (1..h).map { gets.chomp }\n\tchars = a.join.split(\"\").uniq - [?.]\n\tprior = {}\n\t\n\tsafe = true\n\tcatch :exit do\n\t\tchars.each do |c|\n\t\t\tprior[c] = Set.new\n\t\t\ty1 = a.index {|row| row =~ /#{c}/}\n\t\t\ty2 = a.rindex {|row| row =~ /#{c}/}\n\t\t\tx1 = a.map {|row| (row =~ /#{c}/) || w}.min\n\t\t\tx2 = a.map {|row| w - 1 - (row.reverse =~ /#{c}/ || w)}.max\n\t\t\t(y1..y2).each do |i|\n\t\t\t\t(x1..x2).each do |j|\n\t\t\t\t\tif a[i][j] == ?.\n\t\t\t\t\t\tsafe = false\n\t\t\t\t\t\tthrow :exit\n\t\t\t\t\telsif a[i][j] != c\n\t\t\t\t\t\tprior[c] << a[i][j]\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\tif !safe\n\t\tputs 'SUSPICIOUS'\n\t\tnext\n\tend\n\n\tsafe = chars.empty? ? true : false\n\tchars.permutation(chars.size) do |perm|\n\t\torder = {}\n\t\tperm.each.with_index {|c, i| order[c] = i}\n\t\t\n\t\tif chars.all? {|c| prior[c].all?{|p| order[p] < order[c]}}\n\t\t\tsafe = true\n\t\t\tbreak\n\t\tend\n\tend\n\tputs safe ? 'SAFE' : 'SUSPICIOUS'\nend"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\nn.times do\n    h, w = gets.split.map(&:to_i)\n    a = (1..h).map { gets.chomp }\n    chars = a.join.split(\"\").uniq - [?.]\n    safe = chars.empty? ? true : false\n    chars.permutation(chars.size) do |perm|\n        b = Marshal.load(Marshal.dump(a))\n        catch :exit do\n            perm.each do |c| \n                y1 = b.index {|row| row =~ /#{c}/}\n                y2 = b.rindex {|row| row =~ /#{c}/}\n                x1 = b.map {|row| (row =~ /#{c}/) || w}.min\n                x2 = b.map {|row| w - 1 - (row.reverse =~ /#{c}/ || w)}.max\n                (y1..y2).each do |i| \n                    (x1..x2).each do |j| \n                        if b[i][j] == c\n                            b[i][j] = ??\n                        elsif b[i][j] != ??\n                            throw :exit\n                        end\n                    end\n                end\n            end\n            safe = true\n            throw :exit\n        end\n        break if safe\n    end \n    puts safe ? 'SAFE' : 'SUSPICIOUS'\nend"
  },
  {
    "language": "Ruby",
    "code": "INF = 1<<29\nN = 26\ndef check(bag, h, w)\n  t = {}; b = {}; l = {}; r = {}; arr = []\n  for y in (0...h)\n    for x in (0...w)\n      unless (c = bag[y][x]) == \".\"\n        if arr.include?(c)\n          t[c] = [t[c], y].min; b[c] = [b[c], y].max\n          l[c] = [l[c], x].min; r[c] = [r[c], x].max\n        else t[c] = y; b[c] = y; l[c] = x; r[c] = x; arr << c\n        end\n      end\n    end\n  end\n  d = N.times.map{ [INF] * N }\n  arr.each do |c|\n    (t[c]..b[c]).each do |y|\n      (l[c]..r[c]).each do |x|\n        if bag[y][x] == \".\" then return false\n        else \n          p = c.ord - \"A\".ord\n          q = bag[y][x].ord - \"A\".ord\n          d[p][q] = (c == bag[y][x]) ? 0 : -1\n        end\n      end\n    end\n  end\n  (0...N).each do |i|\n    (0...N).each do |j|\n      (0...N).each do |k|\n        d[j][k] = [d[j][k], d[j][i] + d[i][k]].min\n      end\n    end\n  end\n  (0...N).all?{|i| d[i][i] >= 0}\nend\ngets.to_i.times do\n  h, w = gets.split.map(&:to_i)\n  bag = h.times.map{ gets.chomp.split(\"\") }\n  if check(bag, h, w) then puts \"SAFE\"\n  else puts \"SUSPICIOUS\"\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "def solve(f, p)\n    done = Array.new\n    p.each do |c|\n        t = l = 100\n        b = r = -1\n        f.each_with_index do |row, i|\n            row.each_char.with_index do |ch, j|\n                if ch == c\n                    t = i if i < t\n                    l = j if j < l\n                    b = i if i > b\n                    r = j if j > r\n                end\n            end\n        end\n        for i in t..b\n            for j in l..r\n                return false if f[i][j] != c && !done.include?(f[i][j])\n            end\n        end\n        done.push(c)\n    end\n    return true\nend\n\nn = gets.to_i\nn.times do\n    h, w = gets.split.map(&:to_i)\n    f = h.times.map{gets.chomp}\n    keys = Array.new\n    f.each do |r|\n        r.each_char do |c|\n            keys.push(c) if !keys.include?(c) && c != \".\"\n        end\n    end\n    if keys.empty?\n        puts \"SAFE\"\n        next\n    end\n    b = false\n    keys.permutation(keys.size) do |p|\n        b = solve(f, p)\n        break if b\n    end\n    puts b ? \"SAFE\" : \"SUSPICIOUS\"\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\n\nbool test(int[][] s, int n) {\n\tbool f = true;\n\tforeach(i; 0..n) {\n\t\tulong xmin, ymin, xmax, ymax;\n\t\txmin = s[0].length;\n\t\tymin = s.length;\n\t\txmax = 0;\n\t\tymax = 0;\n\t\tforeach(j; 0..s.length) {\n\t\t\tforeach(k; 0..s[0].length) {\n\t\t\t\tif(s[j][k] == i) {\n\t\t\t\t\txmin = min(xmin, k);\n\t\t\t\t\tymin = min(ymin, j);\n\t\t\t\t\txmax = max(xmax, k);\n\t\t\t\t\tymax = max(ymax, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(xmax >= xmin && ymax >= ymin) {\n\t\t\tforeach(j; ymin..ymax+1) {\n\t\t\t\tforeach(k; xmin..xmax+1) {\n\t\t\t\t\tf &= s[j][k] <= i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn f;\n}\n\nvoid main() {\n\tint n = to!int(readln().strip());\n\tforeach(_; 0..n) {\n\t\tauto hw = map!(to!int)(readln().strip().split());\n\t\tint h = hw[0];\n\t\tint w = hw[1];\n\t\tstring[] s;\n\t\tint[char] c;\n\t\tint cn;\n\t\tforeach(i; 0..h) {\n\t\t\ts ~= readln().strip();\n\t\t}\n\t\tforeach(i; 0..h) {\n\t\t\tforeach(j; 0..w) {\n\t\t\t\tif(s[i][j] != '.' && s[i][j] !in c)\n\t\t\t\t\tc[s[i][j]] = cn++;\n\t\t\t}\n\t\t}\n\t\tc['.'] = cn;\n\t\tauto t = new int[][](h,w);\n\t\tforeach(i; 0..h) {\n\t\t\tforeach(j; 0..w) {\n\t\t\t\tt[i][j] = c[s[i][j]];\n\t\t\t}\n\t\t}\n\t\tauto p = new int[](cn);\n\t\tforeach(i; 0..cn){\n\t\t\tp[i] = i;\n\t\t}\n\t\tbool f;\n\t\tdo{\n\t\t\tauto u = t.dup;\n\t\t\tforeach(i; 0..h) {\n\t\t\t\tforeach(j; 0..w) {\n\t\t\t\t\tif(t[i][j] < cn)\n\t\t\t\t\t\tu[i][j] = p[t[i][j]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tf |= test(u, cn);\n\t\t}while(p.nextPermutation);\n\t\twriteln(f?\"SAFE\":\"SUSPICIOUS\");\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nint H, W;\nchar[][] F;\nvoid input() {\n    scanf(\"%d %d\\n\", &H, &W);\n    F = new char[][H];\n    foreach (h; 0 .. H) {\n        F[h] = cast(char[])(readln.chomp);\n    }\n}\n\nbool check() {\n    int[char] sx, sy, gx, gy;\n    bool[char] used;\n    foreach (y; 0 .. H) {\n        foreach (x; 0 .. W) {\n            if (F[y][x] == '.') continue;\n            char c = F[y][x];\n            if (c in used) {\n                sx[c] = min(sx[c], x);\n                sy[c] = min(sy[c], y);\n                gx[c] = max(gx[c], x);\n                gy[c] = max(gy[c], y);\n            } else {\n                used[c] = true;\n                sx[c] = x;\n                sy[c] = y;\n                gx[c] = x;\n                gy[c] = y;\n            }\n        }\n    }\n    auto G = new bool[][](26, 26);\n    foreach (c, p; used) {\n        for (int y = sy[c]; y <= gy[c]; y++) {\n            for (int x = sx[c]; x <= gx[c]; x++) {\n                if (F[y][x] == '.') {\n                    return false;\n                }\n                if (F[y][x] != c) {\n                    char d = F[y][x];\n                    int xc = c - 'A',\n                        xd = d - 'A';\n                    if (G[xd][xc]) return false;\n                    G[xc][xd] = true;\n                }\n            }\n        }\n    }\n    /*\n    foreach (i; 0 .. 26) {\n        foreach (j; 0 .. 26) {\n            if (G[i][j]) {\n                writeln(i, \" -> \", j);\n            }\n        }\n    }\n    */\n\n    foreach (i; 0 .. 26) {\n        bool used1[26];\n        bool dfs(int x) {\n            if (used1[x]) return false;\n            used1[x] = true;\n            foreach (j; 0 .. 26) {\n                if (G[x][j] && (!dfs(j))) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        if (!dfs(i)) return false;\n    }\n    return true;\n}\n\nvoid solve() {\n    writeln(check ? \"SAFE\" : \"SUSPICIOUS\");\n}\n\n \nvoid main() {\n    int T; scanf(\"%d\\n\", &T);\n    foreach (t; 0 .. T) {\n        input; solve;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\n\nbool test(int[][] s, int[] p, int n) {\n\tif(p.length == n) {\n\t\tauto q = p~n;\n\t\tbool f = true;\n\t\tforeach(i; 0..n) {\n\t\t\tulong xmin, ymin, xmax, ymax;\n\t\t\txmin = s[0].length;\n\t\t\tymin = s.length;\n\t\t\txmax = 0;\n\t\t\tymax = 0;\n\t\t\tforeach(j; 0..s.length) {\n\t\t\t\tforeach(k; 0..s[0].length) {\n\t\t\t\t\tif(q[s[j][k]] == i) {\n\t\t\t\t\t\txmin = min(xmin, k);\n\t\t\t\t\t\tymin = min(ymin, j);\n\t\t\t\t\t\txmax = max(xmax, k);\n\t\t\t\t\t\tymax = max(ymax, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(xmax >= xmin && ymax >= ymin) {\n\t\t\t\tforeach(j; ymin..ymax+1) {\n\t\t\t\t\tforeach(k; xmin..xmax+1) {\n\t\t\t\t\t\tf &= q[s[j][k]] <= i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn f;\n\t} else {\n\t\tbool f;\n\t\tforeach(i; 0..n) {\n\t\t\tif(!p.canFind(i)) {\n\t\t\t\tf |= test(s, p~i, n);\n\t\t\t}\n\t\t}\n\t\treturn f;\n\t}\n}\n\nvoid main() {\n\tint n = to!int(readln().strip());\n\tforeach(_; 0..n) {\n\t\tauto hw = map!(to!int)(readln().strip().split());\n\t\tint h = hw[0];\n\t\tint w = hw[1];\n\t\tstring[] s;\n\t\tint[char] c;\n\t\tint cn;\n\t\tforeach(i; 0..h) {\n\t\t\ts ~= readln().strip();\n\t\t}\n\t\tforeach(i; 0..h) {\n\t\t\tforeach(j; 0..w) {\n\t\t\t\tif(s[i][j] != '.' && s[i][j] !in c)\n\t\t\t\t\tc[s[i][j]] = cn++;\n\t\t\t}\n\t\t}\n\t\tc['.'] = cn;\n\t\tauto t = new int[][](h,w);\n\t\tforeach(i; 0..h) {\n\t\t\tforeach(j; 0..w) {\n\t\t\t\tt[i][j] = c[s[i][j]];\n\t\t\t}\n\t\t}\n\t\twriteln(test(t, new int[](0), cn)?\"SAFE\":\"SUSPICIOUS\");\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\n\nbool test(int[][] s, int n) {\n\tauto rect = new bool[](n+1);\n\trect[n] = true;\n\tforeach(_; 0..n) {\n\t\tforeach(i; 0..n) {\n\t\t\tulong xmin, ymin, xmax, ymax;\n\t\t\txmin = s[0].length;\n\t\t\tymin = s.length;\n\t\t\txmax = 0;\n\t\t\tymax = 0;\n\t\t\tforeach(j; 0..s.length) {\n\t\t\t\tforeach(k; 0..s[0].length) {\n\t\t\t\t\tif(s[j][k] == i) {\n\t\t\t\t\t\txmin = min(xmin, k);\n\t\t\t\t\t\tymin = min(ymin, j);\n\t\t\t\t\t\txmax = max(xmax, k);\n\t\t\t\t\t\tymax = max(ymax, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool f = true;\n\t\t\tif(xmax >= xmin && ymax >= ymin) {\n\t\t\t\tforeach(j; ymin..ymax+1) {\n\t\t\t\t\tforeach(k; xmin..xmax+1) {\n\t\t\t\t\t\tf &= s[j][k] == i || rect[s[j][k]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trect[i] |= f;\n\t\t\t}\n\t\t}\n\t}\n\treturn n && reduce!(\"a&&b\")(rect);\n}\n\nvoid main() {\n\tint n = to!int(readln().strip());\n\tforeach(_; 0..n) {\n\t\tauto hw = map!(to!int)(readln().strip().split());\n\t\tint h = hw[0];\n\t\tint w = hw[1];\n\t\tstring[] s;\n\t\tint[char] c;\n\t\tint cn;\n\t\tforeach(i; 0..h) {\n\t\t\ts ~= readln().strip();\n\t\t}\n\t\tforeach(i; 0..h) {\n\t\t\tforeach(j; 0..w) {\n\t\t\t\tif(s[i][j] != '.' && s[i][j] !in c)\n\t\t\t\t\tc[s[i][j]] = cn++;\n\t\t\t}\n\t\t}\n\t\tc['.'] = cn;\n\t\tauto t = new int[][](h,w);\n\t\tforeach(i; 0..h) {\n\t\t\tforeach(j; 0..w) {\n\t\t\t\tt[i][j] = c[s[i][j]];\n\t\t\t}\n\t\t}\n\t\twriteln(test(t, cn)?\"SAFE\":\"SUSPICIOUS\");\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nint H, W;\nchar[][] F;\nvoid input() {\n    scanf(\"%d %d\\n\", &H, &W);\n    F = new char[][H];\n    foreach (h; 0 .. H) {\n        F[h] = cast(char[])(readln.chomp);\n    }\n}\n\nbool check() {\n    int[char] sx, sy, gx, gy;\n    bool[char] used;\n    foreach (y; 0 .. H) {\n        foreach (x; 0 .. W) {\n            if (F[y][x] == '.') continue;\n            char c = F[y][x];\n            if (c in used) {\n                sx[c] = min(sx[c], x);\n                sy[c] = min(sy[c], y);\n                gx[c] = max(gx[c], x);\n                gy[c] = max(gy[c], y);\n            } else {\n                used[c] = true;\n                sx[c] = x;\n                sy[c] = y;\n                gx[c] = x;\n                gy[c] = y;\n            }\n        }\n    }\n    auto G = new bool[][](26, 26);\n    foreach (c, p; used) {\n        for (int y = sy[c]; y <= gy[c]; y++) {\n            for (int x = sx[c]; x <= gx[c]; x++) {\n                if (F[y][x] == '.') {\n                    return false;\n                }\n                if (F[y][x] != c) {\n                    char d = F[y][x];\n                    int xc = c - 'A',\n                        xd = d - 'A';\n                    if (G[xd][xc]) return false;\n                    G[xc][xd] = true;\n                }\n            }\n        }\n    }\n\n    version(Debug) {\n        foreach (i; 0 .. 26) {\n            foreach (j; 0 .. 26) {\n                if (G[i][j]) {\n                    writefln(\"%c -> %c\", cast(char)(i + 'A'), cast(char)(j + 'A'));\n                }\n            }\n        }\n    }\n\n    foreach (i; 0 .. 26) {\n        bool flag = false;\n        bool dfs(int x) {\n            if (i == x) {\n                if (flag) return false;\n                flag = true;\n            }\n            foreach (j; 0 .. 26) {\n                if (G[x][j] && (!dfs(j))) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        if (!dfs(i)) return false;\n    }\n    return true;\n}\n\nvoid solve() {\n    writeln(check ? \"SAFE\" : \"SUSPICIOUS\");\n}\n\n \nvoid main() {\n    int T; scanf(\"%d\\n\", &T);\n    foreach (t; 0 .. T) {\n        input; solve;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.array;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.container;\nimport std.bigint;\n\nalias Tuple!(int, int, int, int) Data;\n\nvoid main()\n{\n\tstring[] results;\n\tint size = to!int(readln.split[0]);\n\tData[26] dataList;\n\tforeach (i; 0..size) {\n\t\tauto strs = readln.split;\n\t\tint H = to!int(strs[0]);\n\t\tint W = to!int(strs[1]);\n\t\tint[][] area;\n\t\tarea.length = W;\n\t\tforeach (ref b; area) {\n\t\t\tb.length = H;\n\t\t}\n\t\t//??????????????????\n\t\tforeach (y; 0..H) {\n\t\t\tauto str = readln;\n\t\t\tforeach (x; 0..W) {\n\t\t\t\tchar c = str[x];\n\t\t\t\tint a = c - 'A';\n\t\t\t\tif (c != '.') {\n\t\t\t\t\tif (dataList[a] != Data.init) {\n\t\t\t\t\t\tdataList[a][0] = min(dataList[a][0], x);\n\t\t\t\t\t\tdataList[a][1] = max(dataList[a][1], x);\n\t\t\t\t\t\tdataList[a][2] = min(dataList[a][2], y);\n\t\t\t\t\t\tdataList[a][3] = max(dataList[a][3], y);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdataList[a] = tuple(x, x, y, y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tarea[x][y] = a;\n\t\t\t}\n\t\t}\n\t\tTuple!(int, int)[] priority; //A is in front of B;\n\t\tbool success = true;\n\tloop:\n\t\tforeach (j; 0..26) {\n\t\t\tif (dataList[j] == Data.init) continue;\n\t\t\tauto data = dataList[j];\n\t\t\tforeach (x; data[0]..data[1]+1) {\n\t\t\t\tforeach (y; data[2]..data[3]+1) {\n\t\t\t\t\tif (area[x][y] == '.') {\n\t\t\t\t\t\tsuccess = false;\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t} else if (area[x][y] != j) {\n\t\t\t\t\t\tforeach (p; priority) {\n\t\t\t\t\t\t\tif (p[0] == j && p[1] == area[x][y]) {\n\t\t\t\t\t\t\t\tsuccess = false;\n\t\t\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpriority ~= tuple(area[x][y], j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (success) results ~= \"SAFE\";\n\t\telse results ~= \"SUSPICIOUS\";\n\t}\n\tforeach (r; results)\n\t\tr.writeln;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\n\nbool test(int[][] s, int n) {\n\tauto rect = new bool[](n+1);\n\trect[n] = false;\n\tforeach(_; 0..n) {\n\t\tforeach(i; 0..n) {\n\t\t\tulong xmin, ymin, xmax, ymax;\n\t\t\txmin = s[0].length;\n\t\t\tymin = s.length;\n\t\t\txmax = 0;\n\t\t\tymax = 0;\n\t\t\tforeach(j; 0..s.length) {\n\t\t\t\tforeach(k; 0..s[0].length) {\n\t\t\t\t\tif(s[j][k] == i) {\n\t\t\t\t\t\txmin = min(xmin, k);\n\t\t\t\t\t\tymin = min(ymin, j);\n\t\t\t\t\t\txmax = max(xmax, k);\n\t\t\t\t\t\tymax = max(ymax, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool f = true;\n\t\t\tif(xmax >= xmin && ymax >= ymin) {\n\t\t\t\tforeach(j; ymin..ymax+1) {\n\t\t\t\t\tforeach(k; xmin..xmax+1) {\n\t\t\t\t\t\tf &= s[j][k] == i || rect[s[j][k]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trect[i] |= f;\n\t\t\t}\n\t\t}\n\t}\n\trect[n] = true;\n\treturn !n || reduce!(\"a&&b\")(rect);\n}\n\nvoid main() {\n\tint n = to!int(readln().strip());\n\tforeach(_; 0..n) {\n\t\tauto hw = map!(to!int)(readln().strip().split());\n\t\tint h = hw[0];\n\t\tint w = hw[1];\n\t\tstring[] s;\n\t\tint[char] c;\n\t\tint cn;\n\t\tforeach(i; 0..h) {\n\t\t\ts ~= readln().strip();\n\t\t}\n\t\tforeach(i; 0..h) {\n\t\t\tforeach(j; 0..w) {\n\t\t\t\tif(s[i][j] != '.' && s[i][j] !in c)\n\t\t\t\t\tc[s[i][j]] = cn++;\n\t\t\t}\n\t\t}\n\t\tc['.'] = cn;\n\t\tauto t = new int[][](h,w);\n\t\tforeach(i; 0..h) {\n\t\t\tforeach(j; 0..w) {\n\t\t\t\tt[i][j] = c[s[i][j]];\n\t\t\t}\n\t\t}\n\t\twriteln(test(t, cn)?\"SAFE\":\"SUSPICIOUS\");\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n#aoj b\nimport re\nfrom collections import defaultdict\n\ndef check(i):#メモ化再帰\n    if d[i] > 0:\n        return d[i]\n    d[i] = 1#チェック状態\n    for y in range(p[i][0],p[i][1]+1):\n        for x in range(p[i][2],p[i][3]+1):\n            if s[y][x] == \".\":#長方形内部に空の部分が存在\n                d[i] = 3 #SUSPICIOUS\n                return d[i]\n            elif s[y][x] != i:#長方形内部に他の物質が存在\n                if d[s[y][x]] == 1:#その物質がチェック状態\n                    d[i] = 3 #SUSPICIOUS(循環参照 テストケース4)\n                    return d[i]\n                c = check(s[y][x])#そいつの状態確認の再帰\n                if c == 3:\n                    d[i] == 3\n                    return d[i]\n    d[i] = 2#SAFE\n    return 2\n\nN = int(input())\nfor _ in range(N):\n    h,w = map(int,input().split())\n    s = [list(input()) for _ in range(h)]\n    p = defaultdict(list)\n    #p[0]:上端,p[1]:下端,p[2]:左端,p[3]:右端\n    #y座標の追加は横方向で見る(上端は上から、下端は下から)\n    for y in range(h):#上端\n        for x in range(w):\n            if s[y][x] != '.' and len(p[s[y][x]]) < 1:\n                p[s[y][x]].append(y)\n    for y in range(h)[::-1]:#下端\n        for x in range(w):\n            if s[y][x] != '.' and len(p[s[y][x]]) < 2:\n                p[s[y][x]].append(y)\n    #x座標の追加は縦方向で見る(左端は左から、右端は右から)\n    for x in range(w):#左端\n        for y in range(h):\n            if s[y][x] != '.' and len(p[s[y][x]]) < 3:\n                p[s[y][x]].append(x)\n    for x in range(w)[::-1]:#右端\n        for y in range(h):\n            if s[y][x] != '.' and len(p[s[y][x]]) < 4:\n                p[s[y][x]].append(x)\n    d = defaultdict(lambda : 0)#メモ化再帰用dict\n    for i in p.keys():\n        if check(i) == 3:\n            print('SUSPICIOUS')\n            break\n    else:\n        print('SAFE')\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inp(): return int(input())\ndef inpl(): return list(map(int, input().split()))\ndef inpl_str(): return list(input().split())\n\n\ndef dfs(s,cnt):\n    global ans\n    if cnt > 10:\n        ans = False\n        return\n    for t in lines[s]:\n        dfs(t,cnt+1)\n\n\nN = inp()\nfor _ in range(N):\n    H,W = inpl()\n    MAP = [['.']*(W+2)] + [['.']+list(input())+['.'] for y in range(H)] + [['.']*(W+2)]\n\n    als = set([])\n    almm = [[INF,0,INF,0] for _ in range(30)]\n    for y in range(1,H+1):\n        for x in range(1,W+1):\n            tmp = MAP[y][x]\n            if tmp != '.':\n                tmp = ord(tmp) - ord('A')\n                als.add(tmp)\n                almm[tmp][0] = min(almm[tmp][0],x)\n                almm[tmp][1] = max(almm[tmp][1],x)\n                almm[tmp][2] = min(almm[tmp][2],y)\n                almm[tmp][3] = max(almm[tmp][3],y)\n\n    ans = True\n    lines = defaultdict(set)\n    for a in als:\n        xl,xr,yl,yr = almm[a]\n        alpha = chr(a+ord('A'))\n        for x in range(xl,xr+1):\n            for y in range(yl,yr+1):\n                if MAP[y][x] == '.':\n                    ans = False\n                    break\n                elif MAP[y][x] != alpha:\n                    lines[a].add(ord(MAP[y][x])-ord('A'))\n\n    for a in als:\n        dfs(a,0)\n\n\n    if not ans:\n        print('SUSPICIOUS')\n    else:\n        print('SAFE')\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 998244353\ndd = [(0,-1),(1,0),(0,1),(-1,0)]\nddn = [(0,-1),(1,-1),(1,0),(1,1),(0,1),(-1,-1),(-1,0),(-1,1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n    n = I()\n    ni = 0\n\n    while ni < n:\n        ni += 1\n        h,w = LI()\n        s = [[c for c in S()] for _ in range(h)]\n        d = collections.defaultdict(lambda: [inf,-inf,inf,-inf])\n        for i in range(h):\n            for j in range(w):\n                if s[i][j] == '.':\n                    continue\n                t = d[s[i][j]]\n                if t[0] > i:\n                    t[0] = i\n                if t[1] < i:\n                    t[1] = i\n                if t[2] > j:\n                    t[2] = j\n                if t[3] < j:\n                    t[3] = j\n        f = True\n        k = set(d.keys())\n        while f:\n            f = False\n            for t in list(k):\n                hi,ha,wi,wa = d[t]\n                ff = True\n                for i in range(hi,ha+1):\n                    for j in range(wi,wa+1):\n                        if s[i][j] != t and s[i][j] != '?':\n                            ff = False\n                            break\n                    if not ff:\n                        break\n                if ff:\n                    k.remove(t)\n                    f = True\n                    for i in range(hi,ha+1):\n                        for j in range(wi,wa+1):\n                            s[i][j] = '?'\n        if not k:\n            rr.append('SAFE')\n        else:\n            rr.append('SUSPICIOUS')\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n\n"
  },
  {
    "language": "Python",
    "code": "from itertools import permutations\nfrom collections import defaultdict\nimport copy\n \ndef judge(field, c):\n    for y in xrange(corner[c][2], corner[c][3] + 1):\n        for x in xrange(corner[c][0], corner[c][1] + 1):\n            if field[y][x] != c and field[y][x] != \"*\":\n                return False\n            field[y][x] = \"*\"\n    return True\n\nN = int(raw_input()) \nfor loop in xrange(N):\n    h, w = map(int, raw_input().split())\n\n    field = [list(raw_input()) for i in xrange(h)]\n    chars = set([])\n    corner = defaultdict(lambda :[101,-1,101,-1])\n\n    for y in xrange(h):\n        for x in xrange(w):\n            c = field[y][x]\n            if c == \".\": continue\n            chars.add(c)\n            corner[c][0] = min(corner[c][0], x)\n            corner[c][1] = max(corner[c][1], x)\n            corner[c][2] = min(corner[c][2], y)\n            corner[c][3] = max(corner[c][3], y)\n\n    for order in permutations(chars):\n        cp = copy.deepcopy(field)\n        for c in order:\n            if not judge(cp, c):\n                break\n        else:\n            print \"SAFE\"\n            break\n    else:\n        print \"SUSPICIOUS\""
  },
  {
    "language": "Python",
    "code": "for t in xrange(input()):\n    h, w = map(int, raw_input().split())\n    A = [list(raw_input()) for i in xrange(h)]\n    xmin = {}; xmax = {}\n    ymin = {}; ymax = {}\n    obj = set()\n    for i in xrange(h):\n        for j in xrange(w):\n            c = A[i][j]\n            if c == '.': continue\n            xmin[c] = min(xmin.get(c, 99), j)\n            xmax[c] = max(xmax.get(c, -1), j)\n            ymin[c] = min(ymin.get(c, 99), i)\n            ymax[c] = max(ymax.get(c, -1), i)\n            obj.add(c)\n    if not obj:\n        print \"SAFE\"\n        continue\n    ok = 1\n    g = {e: set() for e in obj}\n    deg = {e: 0 for e in obj}\n    for q in obj:\n        for i in xrange(ymin[q], ymax[q]+1):\n            for j in xrange(xmin[q], xmax[q]+1):\n                c = A[i][j]\n                if c == '.':\n                    ok = 0\n                    break\n                if c != q:\n                    g[q].add(c)\n            if not ok: break\n        if not ok: break\n    if not ok:\n        print \"SUSPICIOUS\"\n        continue\n    for e in obj:\n        for t in g[e]:\n            deg[t] += 1\n    cnt = len(obj)\n    used = set()\n    for e in obj:\n        for e in obj:\n            if not deg[e] and e not in used:\n                for t in g[e]:\n                    deg[t] -= 1\n                used.add(e)\n                cnt -= 1\n    if cnt:\n        print \"SUSPICIOUS\"\n    else:\n        print \"SAFE\""
  },
  {
    "language": "Python",
    "code": "n = int(input())\nfor _ in range(n):\n  h, w = map(int, input().split())\n  mp = [list(input()) for _ in range(h)]\n  range_dic = {}\n  keys = []\n  for y in range(h):\n    for x in range(w):\n      c = mp[y][x]\n      if c in range_dic:\n        x1, x2, y1, y2 = range_dic[c]\n        range_dic[c] = (min(x, x1), max(x, x2), min(y, y1), max(y, y2))\n      else:\n        range_dic[c] = (x, x, y, y)\n        keys.append(c)\n  \n  while keys:\n    tmp = keys[:]\n    for key in keys:\n      break_flag = False\n      x1, x2, y1, y2 = range_dic[key]\n      for x in range(x1, x2 + 1):\n        for y in range(y1, y2 + 1):\n          if not mp[y][x] in (key, \"#\"):\n            break_flag = True\n            break\n        if break_flag:\n          break\n      else:\n        for y in range(y1, y2 + 1):\n          mp[y][x1:x2 + 1] = [\"#\"] * (x2 - x1 + 1)\n        keys.remove(key)\n    \n    if tmp == keys:\n      print(\"SUSPICIOUS\")\n      break\n  \n  else:\n    print(\"SAFE\")\n"
  },
  {
    "language": "Python",
    "code": "from itertools import permutations\nfrom collections import defaultdict\nimport copy\n \ndef judge(field, c):\n    for y in xrange(corner[c][2], corner[c][3] + 1):\n        for x in xrange(corner[c][0], corner[c][1] + 1):\n            if field[y][x] != c and field[y][x] != \"*\":\n                return False\n            field[y][x] = \"*\"\n    return True\n\nN = int(raw_input()) \nfor loop in xrange(N):\n    h, w = map(int, raw_input().split())\n\n    field = [list(raw_input()) for i in xrange(h)]\n    chars = set([])\n    corner = defaultdict(lambda :[49,0,49,0])\n\n    for y in xrange(h):\n        for x in xrange(w):\n            c = field[y][x]\n            if c == \".\": continue\n            chars.add(c)\n            corner[c][0] = min(corner[c][0], x)\n            corner[c][1] = max(corner[c][1], x)\n            corner[c][2] = min(corner[c][2], y)\n            corner[c][3] = max(corner[c][3], y)\n\n    for order in permutations(chars):\n        cp = copy.deepcopy(field)\n        for c in order:\n            if not judge(cp, c):\n                break\n        else:\n            print \"SAFE\"\n            break\n    else:\n        print \"SUSPICIOUS\""
  },
  {
    "language": "Python",
    "code": "class Baggage:\n\n    height = 0\n    width = 0\n    contentsdata = [[]]\n\n    def __init__(self, H, W):\n        self.height = H\n        self.width = W\n        self.contentsdata = [[\".\" for i in range(0, H)] for j in range(0, W)]\n\n    def setContents(self, x, y, cnt):\n        self.contentsdata[x][y] = cnt\n\n\ndef contentscheck(baggage, checkwords):  # ????????? => 0???????????¢???????????§???=> 1 ?????¨???????????¢???=> 2\n    left = 0\n    right = 0\n    up = 0\n    bottom = 0\n    for x in range(0, baggage.width):  # ???????????????????????¨?????????????????????????????????\n        if(baggage.contentsdata[x].count(checkwords) > 0):\n            left = x\n            break\n    for x in sorted([int(i) for i in range(0, baggage.width)], reverse=True):  # ???????????????????????¨?????????????????????????????????\n        if(baggage.contentsdata[x].count(checkwords) > 0):\n            right = x\n            break\n    for y in range(0, baggage.height):  # ???????????????????????¨?????????????????????????????????\n        for x in range(0, baggage.width):\n            if(baggage.contentsdata[x][y] == checkwords):\n                up = y\n                break\n        else:\n            continue\n        break\n    for y in sorted([int(i) for i in range(0, baggage.height)], reverse=True):  # ???????????????????????¨?????????????????????????????????\n        for x in range(0, baggage.width):\n            if(baggage.contentsdata[x][y] == checkwords):\n                bottom = y\n                break\n        else:\n            continue\n        break\n    # print(checkwords + \": (left, right, up, bottom) = (\" + str(left) + \", \" + str(right) + \", \" + str(up) + \", \" + str(bottom) + \")\")\n    complite = 1\n    for x in range(left, right + 1):\n        for y in range(up, bottom + 1):\n            # print(checkwords + \":\" + baggage.contentsdata[x][y])\n            if(baggage.contentsdata[x][y] != checkwords):\n                complite = 0\n            if(baggage.contentsdata[x][y] == \".\"):\n                return 0\n                break\n        else:\n            continue\n        break\n    if(complite == 0):\n        return 1\n    else:\n        return 2\n\n\nn = int(input())\nusedwordslist = []\n\nfor k in range(0, n):\n    cmp = False\n    try:\n        size = [int(i) for i in input().split(\" \")]  # size = [H, W]\n        checkingbaggage = Baggage(size[0], size[1])\n        for i in range(0, size[0]):\n            data = list(input())\n            for j in range(0, size[1]):\n                checkingbaggage.contentsdata[j][i] = data[j]\n                if(data[j] != \".\" and usedwordslist.count(data[j]) == 0):\n                    usedwordslist.append(data[j])\n        usedwordslist.sort()\n\n        for i in usedwordslist:\n            jdg = int(contentscheck(checkingbaggage, i))\n            if(jdg == 0):\n                print(\"SUSPICIOUS\")\n                break\n            if(jdg == 2):\n                cmp = True\n        else:\n            print(\"cmp \" + str(cmp))\n            if(cmp):\n                print(\"SAFE\")\n            elif(len(usedwordslist) == 0):\n                print(\"SAFE\")\n            else:\n                print(\"SUSPICIOUS\")\n    except:\n        raise\n        exit()\n    '''???????????\\????¢??????¨\n    for i in range(0, size[0]):\n            for j in range(0, size[1]):\n                print(checkingbaggage.contentsdata[j][i])\n    print(usedwordslist)'''\n    usedwordslist.clear()"
  },
  {
    "language": "Python",
    "code": "class Baggage:\n\n    height = 0\n    width = 0\n    contentsdata = [[]]\n\n    def __init__(self, H, W):\n        self.height = H\n        self.width = W\n        self.contentsdata = [[\".\" for i in range(0, H)] for j in range(0, W)]\n\n    def setContents(self, x, y, cnt):\n        self.contentsdata[x][y] = cnt\n\n\ndef contentscheck(baggage, checkwords):  # ????????? => 0???????????¢???????????§???=> 1 ?????¨???????????¢???=> 2\n    left = 0\n    right = 0\n    up = 0\n    bottom = 0\n    for x in range(0, baggage.width):  # ???????????????????????¨?????????????????????????????????\n        if(baggage.contentsdata[x].count(checkwords) > 0):\n            left = x\n            break\n    for x in sorted([int(i) for i in range(0, baggage.width)], reverse=True):  # ???????????????????????¨?????????????????????????????????\n        if(baggage.contentsdata[x].count(checkwords) > 0):\n            right = x\n            break\n    for y in range(0, baggage.height):  # ???????????????????????¨?????????????????????????????????\n        for x in range(0, baggage.width):\n            if(baggage.contentsdata[x][y] == checkwords):\n                up = y\n                break\n        else:\n            continue\n        break\n    for y in sorted([int(i) for i in range(0, baggage.height)], reverse=True):  # ???????????????????????¨?????????????????????????????????\n        for x in range(0, baggage.width):\n            if(baggage.contentsdata[x][y] == checkwords):\n                bottom = y\n                break\n        else:\n            continue\n        break\n    # print(checkwords + \": (left, right, up, bottom) = (\" + str(left) + \", \" + str(right) + \", \" + str(up) + \", \" + str(bottom) + \")\")\n    complite = 1\n    for x in range(left, right + 1):\n        for y in range(up, bottom + 1):\n            # print(checkwords + \":\" + baggage.contentsdata[x][y])\n            if(baggage.contentsdata[x][y] != checkwords):\n                complite = 0\n            if(baggage.contentsdata[x][y] == \".\"):\n                return 0\n                break\n        else:\n            continue\n        break\n    if(complite == 0):\n        return 1\n    else:\n        return 2\n\n\nn = int(input())\nusedwordslist = []\n\nfor k in range(0, n):\n    cmp = False\n    try:\n        size = [int(i) for i in input().split(\" \")]  # size = [H, W]\n        checkingbaggage = Baggage(size[0], size[1])\n        for i in range(0, size[0]):\n            data = list(input())\n            for j in range(0, size[1]):\n                checkingbaggage.contentsdata[j][i] = data[j]\n                if(data[j] != \".\" and usedwordslist.count(data[j]) == 0):\n                    usedwordslist.append(data[j])\n        usedwordslist.sort()\n\n        for i in usedwordslist:\n            jdg = int(contentscheck(checkingbaggage, i))\n            if(jdg == 0):\n                print(\"SUSPICIOUS\")\n                break\n            if(jdg == 2):\n                cmp = True\n        else:\n            if(cmp):\n                print(\"SAFE\")\n            elif(len(usedwordslist) == 0):\n                print(\"SAFE\")\n            else:\n                print(\"SUSPICIOUS\")\n    except:\n        raise\n        exit()\n    '''???????????\\????¢??????¨\n    for i in range(0, size[0]):\n            for j in range(0, size[1]):\n                print(checkingbaggage.contentsdata[j][i])\n    print(usedwordslist)'''\n    usedwordslist.clear()"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nfor _ in range(n):\n  h, w = map(int, input().split())\n  mp = [list(input()) for _ in range(h)]\n  range_dic = {}\n  keys = []\n  for y in range(h):\n    for x in range(w):\n      c = mp[y][x]\n      if c in range_dic:\n        x1, x2, y1, y2 = range_dic[c]\n        range_dic[c] = (min(x, x1), max(x, x2), min(y, y1), max(y, y2))\n      else:\n        range_dic[c] = (x, x, y, y)\n        keys.append(c)\n  \n  while keys:\n    tmp = keys[:]\n    for key in keys:\n      break_flag = False\n      x1, x2, y1, y2 = range_dic[key]\n      for x in range(x1, x2 + 1):\n        for y in range(y1, y2 + 1):\n          if not mp[y][x] in (key, \"#\"):\n            break_flag = True\n            break\n        if break_flag:\n          break\n      else:\n        for x in range(x1, x2 + 1):\n          for y in range(y1, y2 + 1):\n            mp[y][x] = \"#\"\n        keys.remove(key)\n    \n    if tmp == keys:\n      print(\"SUSPICIOUS\")\n      break\n  \n  else:\n    print(\"SAFE\")\n"
  },
  {
    "language": "Python",
    "code": "from itertools import permutations\n\ndef solve():    \n    for ch in permutations(set(list(\"\".join(field))) - set([\".\"])):\n        cp = map(list,field[:])\n        for c in ch:\n            if check(cp, c) == False:\n                break\n        else:\n            return \"SAFE\"\n    return \"SUSPICIOUS\"\n            \ndef check(field, c):\n    for y in xrange(corner[c][2], corner[c][3] + 1):\n        for x in xrange(corner[c][0], corner[c][1] + 1):\n            if field[y][x] != c and field[y][x] != \"*\":\n                return False\n            field[y][x] = \"*\"\n    return True\n\nfor _ in xrange(input()):\n    h, w = map(int, raw_input().split())\n    if h | w == 0:\n        break    \n    field = [raw_input() for _ in xrange(h)]\n    corner = {}\n    for y in xrange(h):\n        for x in xrange(w):\n            if field[y][x] == \".\":\n                continue\n            if field[y][x] not in corner:\n                corner[field[y][x]] = [x, x, y, y] # left right top buto\n            else:\n                corner[field[y][x]][0] = min(corner[field[y][x]][0], x)\n                corner[field[y][x]][1] = max(corner[field[y][x]][1], x)\n                corner[field[y][x]][2] = min(corner[field[y][x]][2], y)\n                corner[field[y][x]][3] = max(corner[field[y][x]][3], y)\n    print solve()"
  },
  {
    "language": "Python",
    "code": "class Baggage:\n\n    height = 0\n    width = 0\n    contentsdata = [[]]\n\n    def __init__(self, H, W):\n        self.height = H\n        self.width = W\n        self.contentsdata = [[\".\" for i in range(0, H)] for j in range(0, W)]\n\n    def setContents(self, x, y, cnt):\n        self.contentsdata[x][y] = cnt\n\n\ndef contentscheck(baggage, checkwords):  # ????????? => True???????????¢???=> False\n    left = 10000\n    right = 10000\n    up = 1000\n    bottom = 1000\n    for x in range(0, baggage.width):  # ???????????????????????¨?????????????????????????????????\n        if(baggage.contentsdata[x].count(checkwords) > 0):\n            left = x\n            break\n    for x in sorted([int(i) for i in range(0, baggage.width)], reverse=True):  # ???????????????????????¨?????????????????????????????????\n        if(baggage.contentsdata[x].count(checkwords) > 0):\n            right = x\n            break\n    for y in range(0, baggage.height):  # ???????????????????????¨?????????????????????????????????\n        for x in range(0, baggage.width):\n            if(baggage.contentsdata[x][y] == checkwords):\n                up = y\n                break\n        else:\n            continue\n        break\n    for y in sorted([int(i) for i in range(0, baggage.height)], reverse=True):  # ???????????????????????¨?????????????????????????????????\n        for x in range(0, baggage.width):\n            if(baggage.contentsdata[x][y] == checkwords):\n                bottom = y\n                break\n        else:\n            continue\n        break\n    # print(checkwords + \": (left, right, up, bottom) = (\" + str(left) + \", \" + str(right) + \", \" + str(up) + \", \" + str(bottom) + \")\")\n    for x in range(left, right + 1):\n        for y in range(up, bottom + 1):\n            if(baggage.contentsdata[x][y] == \".\"):\n                return True\n                break\n        else:\n            continue\n        break\n    return False\n\n\nn = int(input())\nusedwordslist = []\n\nfor k in range(0, n):\n    try:\n        size = [int(i) for i in input().split(\" \")]  # size = [H, W]\n        checkingbaggage = Baggage(size[0], size[1])\n        for i in range(0, size[0]):\n            data = list(input())\n            for j in range(0, size[1]):\n                checkingbaggage.contentsdata[j][i] = data[j]\n                if(data[j] != \".\" and usedwordslist.count(data[j]) == 0):\n                    usedwordslist.append(data[j])\n        usedwordslist.sort()\n        for i in usedwordslist:\n            if(contentscheck(checkingbaggage, i)):\n                print(\"SUSPICIOUS\")\n                break\n        else:\n            print(\"SAFE\")\n    except:\n        raise\n        exit()\n    '''???????????\\????¢??????¨\n    for i in range(0, size[0]):\n            for j in range(0, size[1]):\n                print(checkingbaggage.contentsdata[j][i])\n    print(usedwordslist)'''\n    usedwordslist.clear()"
  },
  {
    "language": "Python",
    "code": "class Baggage:\n\n    height = 0\n    width = 0\n    contentsdata = [[]]\n\n    def __init__(self, H, W):\n        self.height = H\n        self.width = W\n        self.contentsdata = [[\".\" for i in range(0, H)] for j in range(0, W)]\n\n    def setContents(self, x, y, cnt):\n        self.contentsdata[x][y] = cnt\n\n\ndef contentscheck(baggage, checkwords):  # ????????? => 0???????????¢???????????§???=> 1 ?????¨???????????¢???=> 2\n    left = 0\n    right = 0\n    up = 0\n    bottom = 0\n    for x in range(0, baggage.width):  # ???????????????????????¨?????????????????????????????????\n        if(baggage.contentsdata[x].count(checkwords) > 0):\n            left = x\n            break\n    for x in sorted([int(i) for i in range(0, baggage.width)], reverse=True):  # ???????????????????????¨?????????????????????????????????\n        if(baggage.contentsdata[x].count(checkwords) > 0):\n            right = x\n            break\n    for y in range(0, baggage.height):  # ???????????????????????¨?????????????????????????????????\n        for x in range(0, baggage.width):\n            if(baggage.contentsdata[x][y] == checkwords):\n                up = y\n                break\n        else:\n            continue\n        break\n    for y in sorted([int(i) for i in range(0, baggage.height)], reverse=True):  # ???????????????????????¨?????????????????????????????????\n        for x in range(0, baggage.width):\n            if(baggage.contentsdata[x][y] == checkwords):\n                bottom = y\n                break\n        else:\n            continue\n        break\n    # print(checkwords + \": (left, right, up, bottom) = (\" + str(left) + \", \" + str(right) + \", \" + str(up) + \", \" + str(bottom) + \")\")\n    complite = 1\n    for x in range(left, right + 1):\n        for y in range(up, bottom + 1):\n            # print(checkwords + \":\" + baggage.contentsdata[x][y])\n            if(baggage.contentsdata[x][y] != checkwords):\n                complite = 0\n            if(baggage.contentsdata[x][y] == \".\"):\n                return 0\n                break\n        else:\n            continue\n        break\n    if(complite == 0):\n        return 1\n    else:\n        return 2\n\n\nn = int(input())\nusedwordslist = []\n\nfor k in range(0, n):\n    cmp = False\n    try:\n        size = [int(i) for i in input().split(\" \")]  # size = [H, W]\n        checkingbaggage = Baggage(size[0], size[1])\n        for i in range(0, size[0]):\n            data = list(input())\n            for j in range(0, size[1]):\n                checkingbaggage.contentsdata[j][i] = data[j]\n                if(data[j] != \".\" and usedwordslist.count(data[j]) == 0):\n                    usedwordslist.append(data[j])\n        usedwordslist.sort()\n\n        for i in usedwordslist:\n            jdg = int(contentscheck(checkingbaggage, i))\n            if(jdg == 0):\n                print(\"SUSPICIOUS\")\n                break\n            if(jdg == 2):\n                cmp = True\n        else:\n            if(cmp):\n                print(\"SAFE\")\n            elif(len(usedwordslist) == 0):\n                print(\"SAFE\")\n            else:\n                print(\"SUSPICIOUS\")\n    except:\n        raise\n        exit()\n    '''???????????\\????¢??????¨\n    for i in range(0, size[0]):\n            for j in range(0, size[1]):\n                print(checkingbaggage.contentsdata[j][i])\n    print(usedwordslist)'''\n    usedwordslist.clear()"
  },
  {
    "language": "Python",
    "code": "def isRect(data,dic):\n  for d in dic.items():\n    isValid=True\n    for i in xrange(d[1][0],d[1][2]+1):\n      for j in xrange(d[1][1],d[1][3]+1):\n        if not (data[i][j]==d[0] or data[i][j]==\"*\") :\n          isValid=False\n    if isValid: return d[0]\n  return \"-\"\n\ndef checker(data,dic):\n  while len(dic)>0:\n    r=isRect(data,dic)\n    if r==\"-\":\n      print \"SUSPICIOUS\"\n      return\n    else:\n      for i in xrange(dic[r][0],dic[r][2]+1):\n        for j in xrange(dic[r][1],dic[r][3]+1):\n          data[i][j]=\"*\"\n      del dic[r]\n  print \"SAFE\"\n\n\nT=int(raw_input())\nfor _ in xrange(T):\n  H,W=map(int,raw_input().split())\n  data=[[\"-\"]*W for _ in xrange(H)]\n  dic={}\n  for i in xrange(H):\n    s=raw_input()\n    for j in xrange(W):\n      data[i][j]=s[j]\n      if s[j] not in dic:\n        dic[s[j]]=(i,j,i,j)\n      else:\n        dic[s[j]]=(min(dic[s[j]][0],i),min(dic[s[j]][1],j),max(dic[s[j]][2],i),max(dic[s[j]][3],j))\n  checker(data, dic)"
  },
  {
    "language": "Python",
    "code": "from itertools import permutations\nfrom collections import defaultdict\n \ndef judge(field, c):\n    for y in xrange(corner[c][2], corner[c][3] + 1):\n        for x in xrange(corner[c][0], corner[c][1] + 1):\n            if field[y][x] != c and field[y][x] != \"*\":\n                return False\n            field[y][x] = \"*\"\n    return True\n\nN = int(raw_input()) \nfor loop in xrange(N):\n    h, w = map(int, raw_input().split())\n\n    field = [raw_input() for i in xrange(h)]\n    chars = set([])\n    corner = defaultdict(lambda :[49,0,49,0])\n\n    for y in xrange(h):\n        for x in xrange(w):\n            c = field[y][x]\n            if c == \".\": continue\n            chars.add(c)\n            corner[c][0] = min(corner[c][0], x)\n            corner[c][1] = max(corner[c][1], x)\n            corner[c][2] = min(corner[c][2], y)\n            corner[c][3] = max(corner[c][3], y)\n\n    for order in permutations(chars):\n        cp = map(list, field)\n        for c in order:\n            if not judge(cp, c):\n                break\n        else:\n            print \"SAFE\"\n            break\n    else:\n        print \"SUSPICIOUS\""
  },
  {
    "language": "Python",
    "code": "from itertools import permutations\nfrom collections import defaultdict\n \ndef judge(field, c):\n    for y in xrange(corner[c][2], corner[c][3] + 1):\n        for x in xrange(corner[c][0], corner[c][1] + 1):\n            if field[y][x] != c and field[y][x] != \"*\":\n                return False\n            field[y][x] = \"*\"\n    return True\n\nN = int(raw_input()) \nfor loop in xrange(N):\n    h, w = map(int, raw_input().split())\n\n    field = [raw_input() for i in xrange(h)]\n    chars = set([])\n    corner = defaultdict(lambda :[49,0,49,0])\n\n    for y in xrange(h):\n        for x in xrange(w):\n            c = field[y][x]\n            if c == \".\": continue\n            chars.add(c)\n            corner[c][0] = min(corner[c][0], x)\n            corner[c][1] = max(corner[c][1], x)\n            corner[c][2] = min(corner[c][2], y)\n            corner[c][3] = max(corner[c][3], y)\n\n    for order in permutations(chars):\n        cp = map(list, field)\n        for c in order:\n            if not judge(cp, c):\n                break\n        else:\n            print(\"SAFE\")\n            break\n    else:\n        print(\"SUSPICIOUS\")"
  },
  {
    "language": "Python",
    "code": "class Baggage:\n\n    height = 0\n    width = 0\n    contentsdata = [[]]\n\n    def __init__(self, H, W):\n        self.height = H\n        self.width = W\n        self.contentsdata = [[\".\" for i in range(0, H)] for j in range(0, W)]\n\n    def setContents(self, x, y, cnt):\n        self.contentsdata[x][y] = cnt\n\n\ndef contentscheck(baggage, checkwords):  # ????????? => True???????????¢???=> False\n    left = 10000\n    right = 10000\n    up = 1000\n    bottom = 1000\n    for x in range(0, baggage.width):  # ???????????????????????¨?????????????????????????????????\n        if(baggage.contentsdata[x].count(checkwords) > 0):\n            left = x\n            break\n    for x in sorted([int(i) for i in range(0, baggage.width)], reverse=True):  # ???????????????????????¨?????????????????????????????????\n        if(baggage.contentsdata[x].count(checkwords) > 0):\n            right = x\n            break\n    for y in range(0, baggage.height):  # ???????????????????????¨?????????????????????????????????\n        for x in range(0, baggage.width):\n            if(baggage.contentsdata[x][y] == checkwords):\n                up = y\n                break\n        else:\n            continue\n        break\n    for y in sorted([int(i) for i in range(0, baggage.height)], reverse=True):  # ???????????????????????¨?????????????????????????????????\n        for x in range(0, baggage.width):\n            if(baggage.contentsdata[x][y] == checkwords):\n                bottom = y\n                break\n        else:\n            continue\n        break\n    # print(checkwords + \": (left, right, up, bottom) = (\" + str(left) + \", \" + str(right) + \", \" + str(up) + \", \" + str(bottom) + \")\")\n    complite = 1\n    for x in range(left, right + 1):\n        for y in range(up, bottom + 1):\n            if(baggage.contentsdata[x][y] != checkwords):\n                complite = 0\n            if(baggage.contentsdata[x][y] == \".\"):\n                return True\n                break\n        else:\n            continue\n        break\n    if(complite == 1):\n        return 2\n    else:\n        return False\n\n\nn = int(input())\nusedwordslist = []\ncmp = False\n\nfor k in range(0, n):\n    try:\n        size = [int(i) for i in input().split(\" \")]  # size = [H, W]\n        checkingbaggage = Baggage(size[0], size[1])\n        for i in range(0, size[0]):\n            data = list(input())\n            for j in range(0, size[1]):\n                checkingbaggage.contentsdata[j][i] = data[j]\n                if(data[j] != \".\" and usedwordslist.count(data[j]) == 0):\n                    usedwordslist.append(data[j])\n        usedwordslist.sort()\n        for i in usedwordslist:\n            jdg = contentscheck(checkingbaggage, i)\n            if(jdg == True):\n                print(\"SUSPICIOUS\")\n                break\n            if(jdg == \"2\"):\n                cmp = True\n        else:\n            if(cmp == True):\n                print(\"SAFE\")\n            else:\n                print(\"SUSPICIOUS\")\n    except:\n        raise\n        exit()\n    '''???????????\\????¢??????¨\n    for i in range(0, size[0]):\n            for j in range(0, size[1]):\n                print(checkingbaggage.contentsdata[j][i])\n    print(usedwordslist)'''\n    usedwordslist.clear()"
  },
  {
    "language": "Python",
    "code": "def can_fill(image, k, v):\n    for y in range(v[1], v[3] + 1):\n        for x in range(v[0], v[2] + 1):\n            m = image[y][x]\n            if m != k and m != '*':\n                return False\n    return True\n\ndef is_safe(image, p):\n    keys = list(p.keys())\n    i = 0\n    while i < len(keys):\n        k = keys[i]\n        v = p[k]\n        if can_fill(image, k, v):\n            for y in range(v[1], v[3] + 1):\n                for x in range(v[0], v[2] + 1):\n                    image[y][x] = '*'\n            keys.remove(k)\n            i = 0\n        else:\n            i += 1\n    return len(keys) == 0\n\nn = int(input())\nfor i in range(n):\n    h, w = map(int, input().split(' '))\n    image = [list(input()) for y in range(h)]\n    p = {}\n    for y in range(h):\n        for x in range(w):\n            m = image[y][x]\n            if m != '.':\n                if m not in p:\n                    p[m] = [x, y, x, y]\n                else:\n                    p[m][0] = min(p[m][0], x)\n                    p[m][1] = min(p[m][1], y)\n                    p[m][2] = max(p[m][2], x)\n                    p[m][3] = max(p[m][3], y)\n    print('SAFE' if is_safe(image, p) else 'SUSPICIOUS')"
  },
  {
    "language": "Python",
    "code": "def is_safe(image, p):\n    count = 0\n    for k, v in p.items():\n        rect = True\n        for y in range(v[1], v[3] + 1, 1):\n            for x in range(v[0], v[2] + 1, 1):\n                m = image[y][x]\n                if m == '.':\n                    return False\n                if k != m:\n                    rect = False\n        if rect:\n            count += 1\n    return count > 0\nn = int(input())\nfor i in range(n):\n    h, w = map(int, input().split(' '))\n    image = [input() for y in range(h)]\n    p = {}\n    for y in range(h):\n        for x in range(w):\n            m = image[y][x]\n            if m == '.':\n                continue\n            if m not in p:\n                p[m] = [x, y, x, y]\n            else:\n                p[m][0] = min(p[m][0], x)\n                p[m][1] = min(p[m][1], y)\n                p[m][2] = max(p[m][2], x)\n                p[m][3] = max(p[m][3], y)\n    print('SAFE' if is_safe(image, p) else 'SUSPICIOUS')"
  },
  {
    "language": "Python",
    "code": "from itertools import permutations\nfor t in xrange(input()):\n    h, w = map(int, raw_input().split())\n    A = [list(raw_input()) for i in xrange(h)]\n    xmin = {}; xmax = {}\n    ymin = {}; ymax = {}\n    obj = set()\n    for i in xrange(h):\n        for j in xrange(w):\n            c = A[i][j]\n            if c == '.': continue\n            xmin[c] = min(xmin.get(c, 99), j)\n            xmax[c] = max(xmax.get(c, -1), j)\n            ymin[c] = min(ymin.get(c, 99), i)\n            ymax[c] = max(ymax.get(c, -1), i)\n            obj.add(c)\n    if not obj:\n        print \"SAFE\"\n        continue\n    ok = 1\n    for q in obj:\n        for i in xrange(ymin[q], ymax[q]+1):\n            for j in xrange(xmin[q], xmax[q]+1):\n                if A[i][j] == '.':\n                    ok = 0\n                    break\n            if not ok: break\n        if not ok: break\n    if not ok:\n        print \"SUSPICIOUS\"\n        continue\n    for p in permutations(obj):\n        valid = [[1]*w for i in xrange(h)]\n        ok = 1\n        for q in p:\n            for i in xrange(ymin[q], ymax[q]+1):\n                for j in xrange(xmin[q], xmax[q]+1):\n                    if A[i][j] != q and not valid[i][j]:\n                        ok = 0\n                        break\n                    elif A[i][j] == q:\n                        valid[i][j] = 0\n                if not ok: break\n            if not ok: break\n        if ok:\n            print \"SAFE\"\n            break\n    else:\n        print \"SUSPICIOUS\""
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import defaultdict\n\ndef check(i): #メモ化再帰でやります\n    if d[i] > 0:\n        return d[i]\n    d[i] = 1 #チェック状態\n    \"\"\"長方形と仮定し、矛盾があればSUSPICUOUS\"\"\"\n    for y in range(p[i][0],p[i][1]+1):\n        for x in range(p[i][2],p[i][3]+1):\n            if s[y][x] == \".\": #長方形内部に空の部分が存在\n                d[i] = 3 #SUSPICUOUS\n                return d[i]\n            elif s[y][x] != i: #長方形内部に他の物質が存在\n                if d[s[y][x]] == 1: #その物質が現在チェック状態\n                    d[i] = 3 #SUSPICUOUS(循環参照であるため。例:テストケース4)\n                    return d[i]\n                c = check(s[y][x]) #再帰でそいつの状態をみる\n                if c == 3: #SUSPICUOUS\n                    d[i] = 3 #SUSPICUOUS\n                    return d[i]\n    d[i] = 2 #SAFE\n    return 2\n\nn = int(sys.stdin.readline())\nfor _ in range(n):\n    h,w = map(int, sys.stdin.readline().split())\n    s = [sys.stdin.readline() for i in range(h)]\n    p = defaultdict(list)\n    \"\"\"p[0]:上端,p[1]:下端,p[2]:左端,p[3]:右端\"\"\"\n    for y in range(h):\n        for x in range(w):\n            if s[y][x] != \".\" and len(p[s[y][x]]) < 1:\n                p[s[y][x]].append(y)\n    for y in range(h)[::-1]:\n        for x in range(w):\n            if s[y][x] != \".\" and len(p[s[y][x]]) < 2:\n                p[s[y][x]].append(y)\n    for x in range(w):\n        for y in range(h):\n            if s[y][x] != \".\" and len(p[s[y][x]]) < 3:\n                p[s[y][x]].append(x)\n    for x in range(w)[::-1]:\n        for y in range(h):\n            if s[y][x] != \".\" and len(p[s[y][x]]) < 4:\n                p[s[y][x]].append(x)\n\n    d = defaultdict(lambda : 0) #メモ化再帰用のdict\n    for i in p.keys():\n        if check(i) == 3:\n            print(\"SUSPICIOUS\")\n            break\n    else:\n        print(\"SAFE\")\n\n"
  }
]