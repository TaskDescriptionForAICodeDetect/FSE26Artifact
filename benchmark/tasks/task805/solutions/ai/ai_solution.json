[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAX_N 20\n\nint n;\nint compatibility[MAX_N][MAX_N];\nint dp[1 << MAX_N];\n\nint countCompatiblePairings(void) {\n    memset(dp, 0, sizeof(dp));\n    dp[0] = 1;\n\n    for (int mask = 0; mask < (1 << n); mask++) {\n        int man = __builtin_popcount(mask);\n        \n        if (man >= n) continue;\n\n        for (int woman = 0; woman < n; woman++) {\n            if ((mask & (1 << woman)) == 0) {\n                if (compatibility[man][woman]) {\n                    dp[mask | (1 << woman)] = (dp[mask | (1 << woman)] + dp[mask]) % MOD;\n                }\n            }\n        }\n    }\n\n    return dp[(1 << n) - 1];\n}\n\nint main() {\n    scanf(\"%d\", &n);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &compatibility[i][j]);\n        }\n    }\n\n    printf(\"%d\\n\", countCompatiblePairings());\n    return 0;\n}",
    "timestamp": "2025-08-05 22:57:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAX_N 21\n\nint a[MAX_N][MAX_N];\nint dp[1 << MAX_N];\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            scanf(\"%d\", &a[i][j]);\n        }\n    }\n\n    memset(dp, 0, sizeof(dp));\n    dp[0] = 1;\n\n    for (int mask = 0; mask < (1 << N); ++mask) {\n        int man = __builtin_popcount(mask);\n        for (int woman = 0; woman < N; ++woman) {\n            if (!(mask & (1 << woman)) && a[man][woman]) {\n                int new_mask = mask | (1 << woman);\n                dp[new_mask] = (dp[new_mask] + dp[mask]) % MOD;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", dp[(1 << N) - 1]);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:58:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> a(N, vector<int>(N));\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            cin >> a[i][j];\n        }\n    }\n\n    vector<int> dp(1 << N, 0);\n    dp[0] = 1;\n\n    for (int mask = 0; mask < (1 << N); ++mask) {\n        int i = __builtin_popcount(mask);\n        for (int j = 0; j < N; ++j) {\n            if (!(mask & (1 << j)) && a[i][j] == 1) {\n                int new_mask = mask | (1 << j);\n                dp[new_mask] = (dp[new_mask] + dp[mask]) % MOD;\n            }\n        }\n    }\n\n    cout << dp[(1 << N) - 1] << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:58:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int[][] a = new int[N][N];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                a[i][j] = sc.nextInt();\n            }\n        }\n\n        int[] dp = new int[1 << N];\n        dp[0] = 1;\n\n        for (int mask = 0; mask < (1 << N); mask++) {\n            int men = Integer.bitCount(mask);\n            for (int woman = 0; woman < N; woman++) {\n                if ((mask & (1 << woman)) == 0 && a[men][woman] == 1) {\n                    int newMask = mask | (1 << woman);\n                    dp[newMask] = (dp[newMask] + dp[mask]) % MOD;\n                }\n            }\n        }\n\n        System.out.println(dp[(1 << N) - 1]);\n    }\n}",
    "timestamp": "2025-08-05 22:58:47"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public int countCompatiblePairings(int[][] compatibility) {\n        int N = compatibility.length;\n        int MOD = 1_000_000_007;\n        \n        // Use bitmask DP to track compatible pairings\n        int[] dp = new int[1 << N];\n        dp[0] = 1;\n        \n        for (int mask = 0; mask < (1 << N); mask++) {\n            int i = Integer.bitCount(mask);\n            if (i >= N) continue;\n            \n            for (int j = 0; j < N; j++) {\n                if ((mask & (1 << j)) == 0) {\n                    boolean canPair = true;\n                    \n                    // Check compatibility for current person\n                    for (int k = 0; k < N; k++) {\n                        if ((mask & (1 << k)) != 0 && compatibility[k][j] == 0) {\n                            canPair = false;\n                            break;\n                        }\n                    }\n                    \n                    if (canPair) {\n                        dp[mask | (1 << j)] = (dp[mask | (1 << j)] + dp[mask]) % MOD;\n                    }\n                }\n            }\n        }\n        \n        return dp[(1 << N) - 1];\n    }\n}",
    "timestamp": "2025-08-05 22:58:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "class Solution {\npublic:\n    int findCompatiblePairs(int N, vector<vector<int>>& compatibility) {\n        vector<int> dp(1 << N, 0);\n        dp[0] = 1;\n        \n        for (int mask = 0; mask < (1 << N); mask++) {\n            int i = __builtin_popcount(mask);\n            \n            for (int j = 0; j < N; j++) {\n                if ((mask & (1 << j)) == 0) {\n                    for (int k = j + 1; k < N; k++) {\n                        if ((mask & (1 << k)) == 0 && compatibility[i][j] && compatibility[i][k]) {\n                            dp[mask | (1 << j) | (1 << k)] += dp[mask];\n                            dp[mask | (1 << j) | (1 << k)] %= 1000000007;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return dp[(1 << N) - 1];\n    }\n};",
    "timestamp": "2025-08-05 22:58:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_compatible_pairings(N, compatibility_matrix):\n    MOD = 10**9 + 7\n    \n    # dp[mask] represents the number of ways to pair people with the current mask\n    dp = [0] * (1 << N)\n    dp[0] = 1\n    \n    for mask in range(1 << N):\n        x = bin(mask).count('1')  # Number of men already paired\n\n        for j in range(N):\n            if (mask & (1 << j)) == 0 and compatibility_matrix[x][j] == 1:\n                next_mask = mask | (1 << j)\n                dp[next_mask] = (dp[next_mask] + dp[mask]) % MOD\n    \n    return dp[(1 << N) - 1]\n\n# Example usage:\n# compatibility_matrix = [\n#     [1, 0, 1],\n#     [0, 1, 0],\n#     [1, 1, 1]\n# ]\n# print(count_compatible_pairings(3, compatibility_matrix))",
    "timestamp": "2025-08-13 13:11:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class CompatiblePairs {\n\n    private static final int MOD = 1_000_000_007;\n\n    public static int findCompatiblePairs(int[][] compatibility) {\n        int N = compatibility.length;\n        int[] dp = new int[1 << N];\n        dp[0] = 1;\n        \n        for (int mask = 0; mask < (1 << N); mask++) {\n            int menCount = Integer.bitCount(mask);\n            for (int woman = 0; woman < N; woman++) {\n                if ((mask & (1 << woman)) == 0 && compatibility[menCount][woman] == 1) {\n                    int newMask = mask | (1 << woman);\n                    dp[newMask] = (dp[newMask] + dp[mask]) % MOD;\n                }\n            }\n        }\n        \n        return dp[(1 << N) - 1];\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int[][] compatibility = new int[N][N];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                compatibility[i][j] = sc.nextInt();\n            }\n        }\n        System.out.println(findCompatiblePairs(compatibility));\n        sc.close();\n    }\n}",
    "timestamp": "2025-08-13 13:11:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MOD 1000000007\n\nint countCompatiblePairs(int N, int compatibilityMatrix[N][N]) {\n    int dp[1 << N]; // dp[mask] stores the number of ways for current mask\n    dp[0] = 1; // Base case: one way to pair nobody\n    \n    for (int mask = 1; mask < (1 << N); mask++) {\n        dp[mask] = 0;\n        int count = __builtin_popcount(mask); // Number of bits set in mask\n        \n        for (int j = 0; j < N; j++) {\n            if (mask & (1 << j)) { // Woman j is in current mask\n                if (compatibilityMatrix[count - 1][j]) {\n                    dp[mask] = (dp[mask] + dp[mask ^ (1 << j)]) % MOD;\n                }\n            }\n        }\n    }\n    \n    return dp[(1 << N) - 1];\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    int compatibilityMatrix[N][N];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            scanf(\"%d\", &compatibilityMatrix[i][j]);\n        }\n    }\n    \n    int result = countCompatiblePairs(N, compatibilityMatrix);\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 13:11:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nconst int MOD = 1000000007;\n\nint findCompatiblePairings(int N, const std::vector<std::vector<int>>& compatibility) {\n    std::vector<int> dp(1 << N, 0);\n    dp[0] = 1;\n\n    for (int mask = 0; mask < (1 << N); ++mask) {\n        int numMenPaired = __builtin_popcount(mask);\n        for (int woman = 0; woman < N; ++woman) {\n            if (compatibility[numMenPaired][woman] && !(mask & (1 << woman))) {\n                dp[mask | (1 << woman)] = (dp[mask | (1 << woman)] + dp[mask]) % MOD;\n            }\n        }\n    }\n\n    return dp[(1 << N) - 1];\n}\n\nint main() {\n    int N;\n    std::cin >> N;\n    std::vector<std::vector<int>> compatibility(N, std::vector<int>(N));\n\n    for (int i = 0; i < N; ++i)\n        for (int j = 0; j < N; ++j)\n            std::cin >> compatibility[i][j];\n\n    std::cout << findCompatiblePairings(N, compatibility) << std::endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:11:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_compatible_pairings(N, compatibility_matrix):\n    MOD = 10**9 + 7\n    \n    # Dynamic programming with bitmask\n    dp = [0] * (1 << N)\n    dp[0] = 1\n    \n    for mask in range(1 << N):\n        i = bin(mask).count('1')\n        \n        if i % 2 != 0:\n            continue\n        \n        for j in range(N):\n            if (mask & (1 << j)) == 0:\n                for k in range(j + 1, N):\n                    if (mask & (1 << k)) == 0 and compatibility_matrix[i // 2][j][k]:\n                        new_mask = mask | (1 << j) | (1 << k)\n                        dp[new_mask] = (dp[new_mask] + dp[mask]) % MOD\n    \n    return dp[(1 << N) - 1]",
    "timestamp": "2025-08-13 13:11:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    a = []\n    for _ in range(N):\n        row = list(map(int, data[idx:idx+N]))\n        idx += N\n        a.append(row)\n    \n    # DP table: dp[mask] = number of ways to pair first k men where mask represents the women used\n    dp = [0] * (1 << N)\n    dp[0] = 1\n    \n    for mask in range(1 << N):\n        k = bin(mask).count('1')  # current man is k-th (0-based or 1-based?)\n        for j in range(N):\n            if not (mask & (1 << j)) and a[k][j] == 1:\n                new_mask = mask | (1 << j)\n                dp[new_mask] = (dp[new_mask] + dp[mask]) % MOD\n    print(dp[(1 << N) - 1])\n\nsolve()",
    "timestamp": "2025-08-13 13:11:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countCompatiblePairings(N, compatibility) {\n    const MOD = 1000000007;\n    const dp = Array(1 << N).fill(0);\n    dp[0] = 1;\n\n    for (let mask = 0; mask < (1 << N); mask++) {\n        const man = __builtin_popcount(mask);\n\n        for (let woman = 0; woman < N; woman++) {\n            if ((mask & (1 << woman)) === 0 && compatibility[man][woman] === 1) {\n                dp[mask | (1 << woman)] = (dp[mask | (1 << woman)] + dp[mask]) % MOD;\n            }\n        }\n    }\n\n    return dp[(1 << N) - 1];\n}\n\n// Utility function to count set bits\nfunction __builtin_popcount(x) {\n    let count = 0;\n    while (x) {\n        x &= (x - 1);\n        count++;\n    }\n    return count;\n}",
    "timestamp": "2025-08-13 13:11:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countCompatiblePairings(N, compatibility) {\n    const MOD = 1e9 + 7;\n    const dp = new Array(1 << N).fill(0n);\n    dp[0] = 1n;\n\n    for (let mask = 0; mask < (1 << N); mask++) {\n        const man = countBits(mask);\n        if (man >= N) continue;\n\n        for (let woman = 0; woman < N; woman++) {\n            if ((mask & (1 << woman)) === 0) {\n                if (compatibility[man][woman] === 1) {\n                    const newMask = mask | (1 << woman);\n                    dp[newMask] = (dp[newMask] + dp[mask]) % MOD;\n                }\n            }\n        }\n    }\n\n    return Number(dp[(1 << N) - 1]);\n}\n\nfunction countBits(mask) {\n    let count = 0;\n    while (mask > 0) {\n        count += mask & 1;\n        mask >>= 1;\n    }\n    return count;\n}",
    "timestamp": "2025-08-13 13:12:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 1e9 + 7;\n\nfunction solve() {\n    const N = parseInt(readline());\n    const a = [];\n    for (let i = 0; i < N; i++) {\n        const row = readline().split(' ').map(Number);\n        a.push(row);\n    }\n    \n    const dp = new Array(1 << N).fill(0);\n    dp[0] = 1;\n    \n    for (let mask = 0; mask < (1 << N); mask++) {\n        const i = bitCount(mask);\n        for (let j = 0; j < N; j++) {\n            if (!(mask & (1 << j)) && a[i][j] === 1) {\n                const newMask = mask | (1 << j);\n                dp[newMask] = (dp[newMask] + dp[mask]) % MOD;\n            }\n        }\n    }\n    \n    console.log(dp[(1 << N) - 1]);\n}\n\nfunction bitCount(n) {\n    let count = 0;\n    while (n) {\n        count += n & 1;\n        n >>>= 1;\n    }\n    return count;\n}\n\n// Assuming input is read via readline() in a competitive programming environment\n// For example:\n// const readline = require('readline');\n// const rl = readline.createInterface({\n//     input: process.stdin,\n//     output: process.stdout\n// });\n// const input = [];\n// rl.on('line', line => input.push(line));\n// rl.on('close', () => {\n//     let ptr = 0;\n//     readline = () => input[ptr++];\n//     solve();\n// });",
    "timestamp": "2025-08-13 13:12:11"
  }
]