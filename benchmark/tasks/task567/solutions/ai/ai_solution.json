[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_USERS 10000\n\ntypedef struct Node {\n    int user;\n    struct Node* next;\n} Node;\n\nNode* graph[MAX_USERS] = {NULL};\nbool visited[MAX_USERS] = {false};\n\nvoid addEdge(int from, int to) {\n    Node* newNode = malloc(sizeof(Node));\n    newNode->user = to;\n    newNode->next = graph[from];\n    graph[from] = newNode;\n}\n\nbool dfs(int start, int end) {\n    if (start == end) return true;\n    \n    visited[start] = true;\n    \n    for (Node* curr = graph[start]; curr != NULL; curr = curr->next) {\n        if (!visited[curr->user]) {\n            if (dfs(curr->user, end)) \n                return true;\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    int n, m, q;\n    scanf(\"%d %d %d\", &n, &m, &q);\n    \n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        addEdge(u, v);\n    }\n    \n    for (int i = 0; i < q; i++) {\n        int start, end;\n        scanf(\"%d %d\", &start, &end);\n        \n        memset(visited, 0, sizeof(visited));\n        \n        printf(\"%s\\n\", dfs(start, end) ? \"Yes\" : \"No\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:09:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_USERS 1000\n\nint parent[MAX_USERS];\n\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid union_set(int x, int y) {\n    int rootX = find(x);\n    int rootY = find(y);\n    if (rootX != rootY) {\n        parent[rootY] = rootX;\n    }\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < n; i++) {\n        parent[i] = i;\n    }\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        union_set(a, b);\n    }\n\n    int q;\n    scanf(\"%d\", &q);\n    while (q--) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        if (find(a) == find(b)) {\n            printf(\"yes\\n\");\n        } else {\n            printf(\"no\\n\");\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:09:18"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nunordered_map<int, vector<int>> buildGraph(int n, const vector<pair<int, int>>& relations) {\n    unordered_map<int, vector<int>> graph;\n    for (const auto& rel : relations) {\n        graph[rel.first].push_back(rel.second);\n        graph[rel.second].push_back(rel.first);\n    }\n    return graph;\n}\n\nbool isReachable(const unordered_map<int, vector<int>>& graph, int start, int end) {\n    if (start == end) return true;\n    if (graph.find(start) == graph.end() || graph.find(end) == graph.end()) return false;\n\n    queue<int> q;\n    set<int> visited;\n    q.push(start);\n    visited.insert(start);\n\n    while (!q.empty()) {\n        int current = q.front();\n        q.pop();\n\n        for (int neighbor : graph.at(current)) {\n            if (neighbor == end) return true;\n            if (visited.find(neighbor) == visited.end()) {\n                visited.insert(neighbor);\n                q.push(neighbor);\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<pair<int, int>> relations(m);\n    for (int i = 0; i < m; ++i) {\n        cin >> relations[i].first >> relations[i].second;\n    }\n\n    auto graph = buildGraph(n, relations);\n\n    int k;\n    cin >> k;\n    for (int i = 0; i < k; ++i) {\n        int a, b;\n        cin >> a >> b;\n        cout << (isReachable(graph, a, b) ? \"yes\" : \"no\") << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:09:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SNSReachability {\n    private Map<Integer, List<Integer>> graph;\n\n    public SNSReachability() {\n        graph = new HashMap<>();\n    }\n\n    public void addRelation(int a, int b) {\n        graph.computeIfAbsent(a, k -> new ArrayList<>()).add(b);\n        graph.computeIfAbsent(b, k -> new ArrayList<>()).add(a);\n    }\n\n    public boolean isReachable(int a, int b) {\n        if (!graph.containsKey(a) || !graph.containsKey(b)) {\n            return false;\n        }\n        Set<Integer> visited = new HashSet<>();\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(a);\n        visited.add(a);\n\n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            if (current == b) {\n                return true;\n            }\n            for (int neighbor : graph.getOrDefault(current, Collections.emptyList())) {\n                if (!visited.contains(neighbor)) {\n                    visited.add(neighbor);\n                    queue.add(neighbor);\n                }\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        SNSReachability sns = new SNSReachability();\n\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        for (int i = 0; i < m; i++) {\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            sns.addRelation(a, b);\n        }\n\n        int q = scanner.nextInt();\n        for (int i = 0; i < q; i++) {\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            System.out.println(sns.isReachable(a, b) ? \"yes\" : \"no\");\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:09:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SocialNetworkReachability {\n    private Map<String, Set<String>> graph;\n\n    public SocialNetworkReachability() {\n        graph = new HashMap<>();\n    }\n\n    public void addRelation(String user1, String user2) {\n        graph.putIfAbsent(user1, new HashSet<>());\n        graph.putIfAbsent(user2, new HashSet<>());\n        graph.get(user1).add(user2);\n        graph.get(user2).add(user1);\n    }\n\n    public boolean areReachable(String start, String end) {\n        Set<String> visited = new HashSet<>();\n        return dfs(start, end, visited);\n    }\n\n    private boolean dfs(String current, String end, Set<String> visited) {\n        if (current.equals(end)) return true;\n        \n        visited.add(current);\n        \n        if (!graph.containsKey(current)) return false;\n        \n        for (String neighbor : graph.get(current)) {\n            if (!visited.contains(neighbor)) {\n                if (dfs(neighbor, end, visited)) return true;\n            }\n        }\n        \n        return false;\n    }\n\n    public static void main(String[] args) {\n        SocialNetworkReachability snr = new SocialNetworkReachability();\n        \n        // Example usage\n        snr.addRelation(\"Alice\", \"Bob\");\n        snr.addRelation(\"Bob\", \"Charlie\");\n        snr.addRelation(\"Charlie\", \"David\");\n        \n        System.out.println(snr.areReachable(\"Alice\", \"David\")); // true\n        System.out.println(snr.areReachable(\"Alice\", \"Eve\")); // false\n    }\n}",
    "timestamp": "2025-08-05 22:10:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n\nusing namespace std;\n\nclass SocialNetwork {\nprivate:\n    unordered_map<string, vector<string>> graph;\n\npublic:\n    void addRelation(string user1, string user2) {\n        graph[user1].push_back(user2);\n        graph[user2].push_back(user1);\n    }\n\n    bool areReachable(string start, string end) {\n        unordered_set<string> visited;\n        queue<string> q;\n        \n        q.push(start);\n        visited.insert(start);\n        \n        while (!q.empty()) {\n            string current = q.front();\n            q.pop();\n            \n            if (current == end) return true;\n            \n            for (string neighbor : graph[current]) {\n                if (visited.find(neighbor) == visited.end()) {\n                    q.push(neighbor);\n                    visited.insert(neighbor);\n                }\n            }\n        }\n        \n        return false;\n    }\n};\n\nint main() {\n    SocialNetwork sns;\n    int numRelations;\n    string user1, user2, startUser, endUser;\n    \n    cout << \"Enter number of relations: \";\n    cin >> numRelations;\n    \n    for (int i = 0; i < numRelations; i++) {\n        cout << \"Enter relation (user1 user2): \";\n        cin >> user1 >> user2;\n        sns.addRelation(user1, user2);\n    }\n    \n    cout << \"Enter users to check reachability (start end): \";\n    cin >> startUser >> endUser;\n    \n    bool reachable = sns.areReachable(startUser, endUser);\n    \n    if (reachable) {\n        cout << \"Users are reachable\" << endl;\n    } else {\n        cout << \"Users are not reachable\" << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:10:11"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class SocialNetwork:\n    def __init__(self, num_users):\n        self.num_users = num_users\n        self.adj_list = {i: [] for i in range(num_users)}\n\n    def add_relation(self, user1, user2):\n        self.adj_list[user1].append(user2)\n        self.adj_list[user2].append(user1)\n\n    def is_reachable(self, user1, user2):\n        visited = [False] * self.num_users\n        return self.dfs(user1, user2, visited)\n\n    def dfs(self, current, target, visited):\n        if current == target:\n            return True\n        visited[current] = True\n        for neighbor in self.adj_list[current]:\n            if not visited[neighbor]:\n                if self.dfs(neighbor, target, visited):\n                    return True\n        return False\n\n# Example usage:\nsns = SocialNetwork(5)\nsns.add_relation(0, 1)\nsns.add_relation(1, 2)\nsns.add_relation(2, 3)\nsns.add_relation(3, 4)\n\n# Test if 0 and 4 are reachable\nprint(sns.is_reachable(0, 4))  # Output: True\n\n# Test if 0 and 3 are reachable\nprint(sns.is_reachable(0, 3))  # Output: True\n\n# Test if 0 and 5 are reachable (out of bounds check)\n# print(sns.is_reachable(0, 5))  # Uncommenting this will raise an error",
    "timestamp": "2025-08-13 09:16:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class SocialNetwork {\n    private Map<String, Set<String>> network;\n\n    public SocialNetwork() {\n        network = new HashMap<>();\n    }\n\n    public void addRelation(String user1, String user2) {\n        network.computeIfAbsent(user1, k -> new HashSet<>()).add(user2);\n        network.computeIfAbsent(user2, k -> new HashSet<>()).add(user1);\n    }\n\n    public boolean areReachable(String user1, String user2) {\n        if (!network.containsKey(user1) || !network.containsKey(user2)) {\n            return false;\n        }\n        Set<String> visited = new HashSet<>();\n        Queue<String> queue = new LinkedList<>();\n        queue.add(user1);\n        visited.add(user1);\n\n        while (!queue.isEmpty()) {\n            String current = queue.poll();\n            if (current.equals(user2)) {\n                return true;\n            }\n            for (String neighbor : network.get(current)) {\n                if (visited.add(neighbor)) {\n                    queue.add(neighbor);\n                }\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        SocialNetwork sns = new SocialNetwork();\n        Scanner scanner = new Scanner(System.in);\n        int relationCount = scanner.nextInt();\n        int queryCount = scanner.nextInt();\n        scanner.nextLine();\n\n        for (int i = 0; i < relationCount; i++) {\n            String[] relation = scanner.nextLine().split(\" \");\n            sns.addRelation(relation[0], relation[1]);\n        }\n\n        for (int i = 0; i < queryCount; i++) {\n            String[] query = scanner.nextLine().split(\" \");\n            System.out.println(sns.areReachable(query[0], query[1]) ? \"YES\" : \"NO\");\n        }\n\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 09:16:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_USERS 1000\n\nint adj_matrix[MAX_USERS][MAX_USERS] = {0};\nint visited[MAX_USERS] = {0};\nint user_count = 0;\n\nvoid dfs(int user) {\n    visited[user] = 1;\n    for (int i = 0; i < user_count; i++) {\n        if (adj_matrix[user][i] && !visited[i]) {\n            dfs(i);\n        }\n    }\n}\n\nint main() {\n    int relations, queries;\n    scanf(\"%d %d\", &user_count, &relations);\n\n    for (int i = 0; i < relations; i++) {\n        int u1, u2;\n        scanf(\"%d %d\", &u1, &u2);\n        adj_matrix[u1][u2] = 1;\n        adj_matrix[u2][u1] = 1;\n    }\n\n    scanf(\"%d\", &queries);\n    for (int i = 0; i < queries; i++) {\n        int u1, u2;\n        scanf(\"%d %d\", &u1, &u2);\n\n        // Reset visited array\n        for (int j = 0; j < user_count; j++) {\n            visited[j] = 0;\n        }\n\n        dfs(u1);\n        if (visited[u2]) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 09:16:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\nclass SocialNetwork:\n    def __init__(self):\n        self.graph = defaultdict(set)\n    \n    def add_connection(self, user1, user2):\n        self.graph[user1].add(user2)\n        self.graph[user2].add(user1)\n    \n    def is_reachable(self, start, end):\n        if start not in self.graph or end not in self.graph:\n            return False\n        \n        visited = set()\n        queue = deque([start])\n        visited.add(start)\n        \n        while queue:\n            current = queue.popleft()\n            \n            if current == end:\n                return True\n            \n            for neighbor in self.graph[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n        \n        return False\n\ndef main():\n    sns = SocialNetwork()\n    \n    # Read number of connections\n    n = int(input())\n    \n    # Add connections\n    for _ in range(n):\n        user1, user2 = input().split()\n        sns.add_connection(user1, user2)\n    \n    # Read number of queries\n    q = int(input())\n    \n    # Process queries\n    for _ in range(q):\n        start, end = input().split()\n        if sns.is_reachable(start, end):\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 09:16:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def main():\n    import sys\n    from collections import defaultdict, deque\n\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    M = int(input[ptr])\n    ptr += 1\n\n    graph = defaultdict(list)\n    for _ in range(M):\n        a = int(input[ptr])\n        ptr += 1\n        b = int(input[ptr])\n        ptr += 1\n        graph[a].append(b)\n        graph[b].append(a)\n\n    Q = int(input[ptr])\n    ptr += 1\n    queries = []\n    for _ in range(Q):\n        s = int(input[ptr])\n        ptr += 1\n        t = int(input[ptr])\n        ptr += 1\n        queries.append((s, t))\n\n    results = []\n    for s, t in queries:\n        if s == t:\n            results.append(\"yes\")\n            continue\n        visited = set()\n        q = deque()\n        q.append(s)\n        visited.add(s)\n        found = False\n        while q:\n            current = q.popleft()\n            for neighbor in graph[current]:\n                if neighbor == t:\n                    found = True\n                    break\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    q.append(neighbor)\n            if found:\n                break\n        results.append(\"yes\" if found else \"no\")\n\n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 09:16:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\n// Function to perform BFS and check reachability\nbool bfs(int start, int end, const unordered_map<int, vector<int>>& graph) {\n    if (start == end) return true;\n\n    unordered_map<int, bool> visited;\n    queue<int> q;\n    q.push(start);\n    visited[start] = true;\n\n    while (!q.empty()) {\n        int current = q.front();\n        q.pop();\n\n        if (current == end) return true;\n\n        for (const int& neighbor : graph.at(current)) {\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                q.push(neighbor);\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int numUsers, numRelations, numQueries;\n    cin >> numUsers >> numRelations >> numQueries;\n\n    unordered_map<int, vector<int>> graph;\n\n    for (int i = 0; i < numRelations; ++i) {\n        int u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    for (int i = 0; i < numQueries; ++i) {\n        int start, end;\n        cin >> start >> end;\n\n        if (bfs(start, end, graph)) {\n            cout << \"Reachable\" << endl;\n        } else {\n            cout << \"Not Reachable\" << endl;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:50:29"
  }
]