[
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt,readLine}\nimport scala.collection.mutable.HashMap\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main {\n\n  def move(m:Int, d1:Int, d2:Int) = {\n    val x = m/d2 % 10\n    m-9*d1-x*d2+9*d2+x*d1\n  }\n  def end(m:Int) = m == 123456789\n\n  def main(args:Array[String]) = {\n    val hist = new ArrayBuffer[Int]\n    val phist = new ArrayBuffer[Int]\n    val map = new HashMap[Int,Int]\n    var pointer = 0\n    var found = false\n    var count = 0\n\n    val s = { for(i<-1 to 3) yield readLine.split(\" \").reduce(_+_) }.reduce(_+_)\n    val idx = 8-s.indexWhere(_=='0')\n    phist += idx\n\n    val n = s.map{ c => if(c=='0') '9' else c }.toInt\n    hist += n\n    map += (n->1)\n\n    if(end(r)) found = true\n    while(!found) {\n      val len = hist.length\n      for(i<-pointer until len if !found) {\n        val pos = phist(i)\n        val data = hist(i)\n        val p = Math.pow(10,pos).toInt\n        if((8-pos)%3 != 2) {\n          val r = move(data, p, p/10)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos-1\n          }\n        }\n        if(!found && (8-pos) % 3 != 0) {\n          val r = move(data, p, p*10)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos+1\n          }\n        }\n        if(!found && (8-pos) / 3 != 0) {\n          val r = move(data, p, p*1000)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos+3\n          }\n        }\n        if(!found && (8-pos) / 3 != 2) {\n          val r = move(data, p, p/1000)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos-3\n          }\n        }\n      }\n      pointer = (len-pointer)\n      count += 1\n    }\n    println(count)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt,readLine}\nimport scala.collection.mutable.HashMap\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main {\n\n  def move(m:Int, d1:Int, d2:Int) = {\n    val x = m/d2 % 10\n    m-9*d1-x*d2+9*d2+x*d1\n  }\n  def end(m:Int) = m == 123456789\n\n  def main(args:Array[String]) = {\n    val hist = new ArrayBuffer[Int]\n    val phist = new ArrayBuffer[Int]\n    val map = new HashMap[Int,Int]\n    var pointer = 0\n    var found = false\n    var count = 0\n\n    val s = { for(i<-1 to 3) yield readLine.split(\" \").reduce(_+_) }.reduce(_+_)\n    val idx = 8-s.indexWhere(_=='0')\n    phist += idx\n\n    val n = s.map{ c => if(c=='0') '9' else c }.toInt\n    hist += n\n    map += (n->1)\n\n    if(end(n)) found = true\n    while(!found) {\n      val len = hist.length\n      for(i<-pointer until len if !found) {\n        val pos = phist(i)\n        val data = hist(i)\n        val p = Math.pow(10,pos).toInt\n        if((8-pos)%3 != 2) {\n          val r = move(data, p, p/10)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos-1\n          }\n        }\n        if(!found && (8-pos) % 3 != 0) {\n          val r = move(data, p, p*10)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos+1\n          }\n        }\n        if(!found && (8-pos) / 3 != 0) {\n          val r = move(data, p, p*1000)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos+3\n          }\n        }\n        if(!found && (8-pos) / 3 != 2) {\n          val r = move(data, p, p/1000)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos-3\n          }\n        }\n      }\n      pointer = (len-pointer)\n      count += 1\n    }\n    println(count)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt,readLine}\nimport scala.collection.mutable.HashMap\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main {\n\n  def move(m:Int, d1:Int, d2:Int) = {\n    val x = m/d2 % 10\n    m-9*d1-x*d2+9*d2+x*d1\n  }\n  def end(m:Int) = m == 123456789\n\n  def main(args:Array[String]) = {\n    val hist = new ArrayBuffer[Int]\n    val phist = new ArrayBuffer[Int]\n    val map = new HashMap[Int,Int]\n    var pointer = 0\n    var found = false\n    var count = 0\n\n    val s = { for(i<-1 to 3) yield readLine.split(\" \").reduce(_+_) }.reduce(_+_)\n    val idx = 8-s.indexWhere(_=='0')\n    phist += idx\n\n    val n = s.map{ c => if(c=='0') '9' else c }.toInt\n    hist += n\n    map += (n->1)\n\n    if(end(n)) found = true\n    while(!found) {\n      val len = hist.length\n      for(i<-pointer until len if !found) {\n        val pos = phist(i)\n        val data = hist(i)\n        val p = Math.pow(10,pos).toInt\n        if((8-pos)%3 != 2) {\n          val r = move(data, p, p/10)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos-1\n          }\n        }\n        if(!found && (8-pos) % 3 != 0) {\n          val r = move(data, p, p*10)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos+1\n          }\n        }\n        if(!found && (8-pos) / 3 != 0) {\n          val r = move(data, p, p*1000)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos+3\n          }\n        }\n        if(!found && (8-pos) / 3 != 2) {\n          val r = move(data, p, p/1000)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos-3\n          }\n        }\n      }\n      pointer = (len-pointer)\n      count += 1\n    }\n    println(count)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt,readLine}\nimport scala.collection.mutable.HashMap\n\nobject Main {\n  def right(m:scala.collection.immutable.Map[Int,Int],i:Int):Map[Int,Int] = m.updated(i, m(i+1)).updated(i+1,0)\n  def left(m:Map[Int,Int],i:Int):Map[Int,Int] = m.updated(i, m(i-1)).updated(i-1,0)\n  def up(m:Map[Int,Int],i:Int):Map[Int,Int] = m.updated(i, m(i-3)).updated(i-3,0)\n  def down(m:Map[Int,Int],i:Int):Map[Int,Int] = m.updated(i, m(i+3)).updated(i+3,0)\n  def end(m:Map[Int,Int]) = m == Map(0->1,1->2,2->3,3->4,4->5,5->6,6->7,7->8,8->0)\n\n  def main(args:Array[String]) = {\n    val p = new HashMap[Int,Int]\n    val hist= new HashMap[scala.collection.immutable.Map[Int,Int], Int]\n    var found = false\n    var count = 0\n    var idx = 0\n    var k = 0\n    var l = 0\n    for(i<-1 to 3) {\n      readLine.split(\" \").map(_.toInt).foreach{ x=>\n        p += (k->x)\n        if(x==0) l = k\n        k+=1\n      }\n    }\n\n    hist += (p.toMap->l)\n    while(!found) {\n      val hist2 = new HashMap[scala.collection.immutable.Map[Int,Int], Int]\n      for((m,i)<-hist if !found) {\n        if(i % 3 != 2) {\n          val r = right(m, i)\n          if(end(r)) found = true\n          else if(!hist.contains(r)) hist2 += (r->(i+1))\n        }\n        if(!found && i % 3 != 0) {\n          val r = left(m, i)\n          if(end(r)) found = true\n          else if(!hist.contains(r)) hist2 += (r->(i-1))\n        }\n        if(!found && i / 3 != 0) {\n          val r = up(m, i)\n          if(end(r)) found = true\n          else if(!hist.contains(r)) hist2 += (r->(i-3))\n        }\n        if(!found && i / 3 != 2) {\n          val r = down(m, i)\n          if(end(r)) found = true\n          else if(!hist.contains(r)) hist2 += (r->(i+3))\n        }\n      }\n      if(!found) hist ++= hist2\n      count += 1\n    }\n    println(count)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt,readLine}\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main {\n\n  def move(m:Int, d1:Int, d2:Int) = {\n    val x = m/d2 % 10\n    m-9*d1-x*d2+9*d2+x*d1\n  }\n  def end(m:Int) = m == 123456789\n\n  def main(args:Array[String]) = {\n    val hist = new ArrayBuffer[Int]\n    val phist = new ArrayBuffer[Int]\n    var pointer = 0\n    var found = false\n    var count = 0\n\n    val s = { for(i<-1 to 3) yield readLine.split(\" \").reduce(_+_) }.reduce(_+_)\n    val idx = 8-s.indexWhere(_=='0')\n    phist += idx\n\n    val n = s.map{ c => if(c=='0') '9' else c }.toInt\n    hist += n\n    while(!found) {\n      val len = hist.length\n      for(i<-pointer until len if !found) {\n        val pos = phist(i)\n        val data = hist(i)\n        val p = Math.pow(10,pos).toInt\n        if((8-pos)%3 != 2) {\n          val r = move(data, p, p/10)\n          if(end(r)) found = true\n          else if(!hist.contains(r)) {\n            hist += r\n            phist += pos-1\n          }\n        }\n        if(!found && (8-pos) % 3 != 0) {\n          val r = move(data, p, p*10)\n          if(end(r)) found = true\n          else if(!hist.contains(r)) {\n            hist += r\n            phist += pos+1\n          }\n        }\n\n        if(!found && (8-pos) / 3 != 0) {\n          val r = move(data, p, p*1000)\n          if(end(r)) found = true\n          else if(!hist.contains(r)) {\n            hist += r\n            phist += pos+3\n          }\n        }\n        if(!found && (8-pos) / 3 != 2) {\n          val r = move(data, p, p/1000)\n          if(end(r)) found = true\n          else if(!hist.contains(r)) {\n            hist += r\n            phist += pos-3\n          }\n        }\n      }\n      pointer = (len-pointer)\n      count += 1\n    }\n    println(count)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import java.util\nobject Main extends App {\n  import scala.io.StdIn._\n  val goal = new Square(Array(Array(1,2,3), Array(4,5,6), Array(7,8,0)))\n  val goalHash = goal.hashCode()\n  val start = new Square((0 until 3).map{_ => readLine().trim().split(' ').map(_.toInt).toArray}.toArray)\n  println(search(start))\n  def search(start:Square):Int = {\n    val memo = Array.tabulate(362880){_ => -1}\n    var count = 0\n    val queue:util.Deque[Square] = new util.LinkedList()\n    memo(start.hashCode()) = 0\n    queue.addLast(start)\n    while (memo(goalHash) < 0){\n      count += 1\n      for (i <- 0 until queue.size()){\n        for (s <- queue.peek().nextCases){\n          if (memo(s.hashCode()) < 0){\n            memo(s.hashCode()) = count\n            queue.addLast(s)\n          }\n        }\n        queue.pop()\n      }\n    }\n    memo(goalHash)\n  }\n  class Square(private val array:Array[Array[Int]]){\n    override def hashCode(): Int = Square.factorial.foldLeft((0, (0 until 3).flatMap{a => (0 until 3).map{b => array(a)(b)}}.toList)){\n      case ((s, h::t), f) => (s + f * h, t.map{n => if (n > h) n - 1 else n})\n      case (s, f) => s\n    }._1\n    lazy val zeroPoint:Point = (0 until 3).flatMap{x => (0 until 3).map{y => Point(x, y)}}.filter{case Point(x, y) => array(x)(y) == 0}.head\n    def copy:Square = new Square(array.map(_.clone()))\n    def nextCases:List[Square] = zeroPoint.neighbors.filter(Square.isValidPoint(_)).map{\n      case Point(x, y) =>\n        val r = copy\n        r.array(zeroPoint.x)(zeroPoint.y) = array(x)(y)\n        r.array(x)(y) = 0\n        r\n    }\n  }\n  case class Point(x:Int, y:Int){\n    def neighbors:List[Point] = List(Point(x - 1, y), Point(x + 1, y), Point(x, y - 1), Point(x, y + 1))\n  }\n  object Square{\n    val factorial = List(40320, 5040, 720, 120, 24, 6, 2, 1, 1)\n    def isValidPoint(other:Point):Boolean = (0 until 3).contains(other.x) && (0 until 3).contains(other.y)\n  }\n}\n\n"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt,readLine}\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main {\n  def right(a:Array[Int],i:Int) = { val b = a.clone; b(i) = b(i+1); b(i+1) = 0;b }\n  def left(a:Array[Int],i:Int) = { val b = a.clone; b(i) = b(i-1); b(i-1) = 0;b }\n  def up(a:Array[Int],i:Int) = { val b = a.clone; b(i) = b(i-3); b(i-3) = 0;b }\n  def down(a:Array[Int],i:Int) = { val b = a.clone; b(i) = b(i+3); b(i+3) = 0;b }\n  def end(a:Array[Int], i:Int ) =\n    a(0)==1 && a(1)==2 && a(2)==3 && a(3)==4 &&\n    a(4)==5 && a(5)==6 && a(6)==7 && a(7)==8 && a(8)==0\n  def contains(list:ArrayBuffer[(Int,Array[Int])], a:Array[Int]) =\n    list.exists( _._2.sameElements(a) )\n\n  def main(args:Array[String]) = { val p = new ArrayBuffer[Int]\n    val hist= new ArrayBuffer[(Int,Array[Int])]\n    var found = false\n    var count = 0\n    var idx = 0\n    var result:Array[Int] = null\n    for(i<-1 to 3) readLine.split(\" \").map(_.toInt).foreach( p += _ )\n\n    hist += ((p.indexWhere( _ == 0 ), p.toArray))\n\n    while(!found && count<5) {\n      val len = hist.length\n      for(k<-idx until hist.length if !found) {\n        val (i,e) = hist(k)\n        if(i % 3 != 2) {\n          val r = right(e, i)\n          if(end(r,i)) { found = true; result = r }\n          else if(!contains(hist,r)) hist += ((i+1,r))\n        }\n        if(!found && i % 3 != 0) {\n          val r = left(e, i)\n          if(end(r,i)) { found = true; result = r }\n          else if(!contains(hist,r)) hist += ((i-1,r))\n        }\n        if(!found && i / 3 != 0) {\n          val r = up(e, i)\n          if(end(r,i)) { found = true; result = r }\n          else if(!contains(hist,r)) hist += ((i-3,r))\n        }\n        if(!found && i / 3 != 2) {\n          val r = down(e, i)\n          if(end(r,i)) { found = true; result = r }\n          else if(!contains(hist,r)) hist += ((i+3,r))\n        }\n      }\n      idx += (len-idx)\n      count += 1\n    }\n    println(count)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt,readLine}\nimport scala.collection.mutable.HashMap\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main {\n\n  def move(m:Int, d1:Int, d2:Int) = {\n    val x = m/d2 % 10\n    m+(9+x)(d2-d1)\n  }\n  def end(m:Int) = m == 123456789\n\n  def main(args:Array[String]) = {\n    val hist = new ArrayBuffer[Int]\n    val phist = new ArrayBuffer[Int]\n    val map = new HashMap[Int,Int]\n    var pointer = 0\n    var found = false\n    var count = 0\n\n    val s = { for(i<-1 to 3) yield readLine.split(\" \").reduce(_+_) }.reduce(_+_)\n    val idx = 8-s.indexWhere(_=='0')\n    phist += idx\n\n    val n = s.map{ c => if(c=='0') '9' else c }.toInt\n    hist += n\n    map += (n->1)\n\n    if(end(n)) found = true\n    while(!found) {\n      val len = hist.length\n      for(i<-pointer until len if !found) {\n        val pos = phist(i)\n        val data = hist(i)\n        val p = Math.pow(10,pos).toInt\n        if((8-pos)%3 != 2) {\n          val r = move(data, p, p/10)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos-1\n          }\n        }\n        if(!found && (8-pos) % 3 != 0) {\n          val r = move(data, p, p*10)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos+1\n          }\n        }\n        if(!found && (8-pos) / 3 != 0) {\n          val r = move(data, p, p*1000)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos+3\n          }\n        }\n        if(!found && (8-pos) / 3 != 2) {\n          val r = move(data, p, p/1000)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos-3\n          }\n        }\n      }\n      pointer = (len-pointer)\n      count += 1\n    }\n    println(count)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt,readLine}\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main {\n  def right(a:Array[Int],i:Int) = { val b = a.clone; b(i) = b(i+1); b(i+1) = 0;b }\n  def left(a:Array[Int],i:Int) = { val b = a.clone; b(i) = b(i-1); b(i-1) = 0;b }\n  def up(a:Array[Int],i:Int) = { val b = a.clone; b(i) = b(i-3); b(i-3) = 0;b }\n  def down(a:Array[Int],i:Int) = { val b = a.clone; b(i) = b(i+3); b(i+3) = 0;b }\n  def end(a:Array[Int], i:Int ) =\n    a(0)==1 && a(1)==2 && a(2)==3 && a(3)==4 &&\n    a(4)==5 && a(5)==6 && a(6)==7 && a(7)==8 && a(8)==0\n  def contains(list:ArrayBuffer[(Int,Array[Int])], a:Array[Int]) =\n    list.exists( _._2.sameElements(a) )\n\n  def main(args:Array[String]) = { val p = new ArrayBuffer[Int]\n    val hist= new ArrayBuffer[(Int,Array[Int])]\n    var found = false\n    var count = 0\n    var idx = 0\n    var result:Array[Int] = null\n    for(i<-1 to 3) readLine.split(\" \").map(_.toInt).foreach( p += _ )\n\n    hist += ((p.indexWhere( _ == 0 ), p.toArray))\n\n    while(!found) {\n      val len = hist.length\n      for(k<-idx until hist.length if !found) {\n        val (i,e) = hist(k)\n        if(i % 3 != 2) {\n          val r = right(e, i)\n          if(end(r,i)) { found = true; result = r }\n          else if(!contains(hist,r)) hist += ((i+1,r))\n        }\n        if(!found && i % 3 != 0) {\n          val r = left(e, i)\n          if(end(r,i)) { found = true; result = r }\n          else if(!contains(hist,r)) hist += ((i-1,r))\n        }\n        if(!found && i / 3 != 0) {\n          val r = up(e, i)\n          if(end(r,i)) { found = true; result = r }\n          else if(!contains(hist,r)) hist += ((i-3,r))\n        }\n        if(!found && i / 3 != 2) {\n          val r = down(e, i)\n          if(end(r,i)) { found = true; result = r }\n          else if(!contains(hist,r)) hist += ((i+3,r))\n        }\n      }\n      idx += (len-idx)\n      count += 1\n    }\n    println(count)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt,readLine}\nimport scala.collection.mutable.HashMap\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main {\n\n  def move(m:Int, d1:Int, d2:Int) = {\n    val x = m/d2 % 10\n    m-9*d1-x*d2+9*d2+x*d1\n  }\n  def end(m:Int) = m == 123456789\n\n  def main(args:Array[String]) = {\n    val hist = new ArrayBuffer[Int]\n    val phist = new ArrayBuffer[Int]\n    val map = new HashMap[Int,Int]\n    var pointer = 0\n    var found = false\n    var count = 0\n\n    val s = { for(i<-1 to 3) yield readLine.split(\" \").reduce(_+_) }.reduce(_+_)\n    val idx = 8-s.indexWhere(_=='0')\n    phist += idx\n\n    val n = s.map{ c => if(c=='0') '9' else c }.toInt\n    hist += n\n    map += (n->1)\n\n    while(!found) {\n      val len = hist.length\n      for(i<-pointer until len if !found) {\n        val pos = phist(i)\n        val data = hist(i)\n        val p = Math.pow(10,pos).toInt\n        if((8-pos)%3 != 2) {\n          val r = move(data, p, p/10)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos-1\n          }\n        }\n        if(!found && (8-pos) % 3 != 0) {\n          val r = move(data, p, p*10)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos+1\n          }\n        }\n        if(!found && (8-pos) / 3 != 0) {\n          val r = move(data, p, p*1000)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos+3\n          }\n        }\n        if(!found && (8-pos) / 3 != 2) {\n          val r = move(data, p, p/1000)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos-3\n          }\n        }\n      }\n      pointer = (len-pointer)\n      count += 1\n    }\n    println(count)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt,readLine}\nimport scala.collection.mutable.HashMap\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main {\n\n  def move(m:Int, d1:Int, d2:Int) = {\n    val x = m/d2 % 10\n    m + (9+x) * (d2-d1)\n  }\n  def end(m:Int) = m == 123456789\n\n  def main(args:Array[String]) = {\n    val hist = new ArrayBuffer[Int]\n    val phist = new ArrayBuffer[Int]\n    val map = new HashMap[Int,Int]\n    var pointer = 0\n    var found = false\n    var count = 0\n\n    val s = { for(i<-1 to 3) yield readLine.split(\" \").reduce(_+_) }.reduce(_+_)\n    val idx = 8-s.indexWhere(_=='0')\n    phist += idx\n\n    val n = s.map{ c => if(c=='0') '9' else c }.toInt\n    hist += n\n    map += (n->1)\n\n    if(end(n)) found = true\n    while(!found) {\n      val len = hist.length\n      for(i<-pointer until len if !found) {\n        val pos = phist(i)\n        val data = hist(i)\n        val p = Math.pow(10,pos).toInt\n        if((8-pos)%3 != 2) {\n          val r = move(data, p, p/10)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos-1\n          }\n        }\n        if(!found && (8-pos) % 3 != 0) {\n          val r = move(data, p, p*10)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos+1\n          }\n        }\n        if(!found && (8-pos) / 3 != 0) {\n          val r = move(data, p, p*1000)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos+3\n          }\n        }\n        if(!found && (8-pos) / 3 != 2) {\n          val r = move(data, p, p/1000)\n          if(end(r)) found = true\n          else if(!map.contains(r)) {\n            hist += r\n            map += (r->1)\n            phist += pos-3\n          }\n        }\n      }\n      pointer = (len-pointer)\n      count += 1\n    }\n    println(count)\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<set>\nusing namespace std;\n\n#define U 1\n#define D 2\n#define R 3 \n#define L 4\n\n\nconst int ans = 123456780;\nset<int> leaf;\n\n\nvoid print(int s){\n  int board[9];\n  for(int i=0; i<9; i++){\n    board[8-i] = s%10;\n    s /= 10;\n  }\n  for(int i=0; i<9; i++){\n    cout << board[i] << ' ';\n    if(i%3 == 2)cout << endl;\n  }\n}\n\nint  moveSpace(int state, int dir){\n  int board[9];\n\n  //int --> matrix\n  for(int i=0; i<9; i++){\n    board[8-i] = state%10;\n    state /= 10;\n  }\n\n  //find space\n  int pos = 0;\n  while(board[pos]!=0)pos++;\n  \n\n  //move space up\n  if(dir==U && pos > 2){\n    int tmp = board[pos];\n    board[pos] = board[pos-3];\n    board[pos-3] = tmp;\n  }\n  else if(dir==D && pos < 6){\n    int tmp = board[pos];\n    board[pos] = board[pos+3];\n    board[pos+3] = tmp;\n  }\n  else if(dir==R && pos != 2 && pos != 5 && pos != 8){\n    int tmp = board[pos];\n    board[pos] = board[pos+1];\n    board[pos+1] = tmp;\n  }\n  else if(dir==L && pos != 0 && pos != 3 && pos != 6){\n    int tmp = board[pos];\n    board[pos] = board[pos-1];\n    board[pos-1] = tmp;\n  }\n  else{\n    return -1;\n  }\n\n  //matrix --> int\n  state = board[0];\n  for(int i=1; i<9; i++){\n    state *= 10;\n    state += board[i];\n  }\n\n  return state;\n}\n//@end moveSpace\n\n\n\nint solve(int state, int step, int depth){\n  if(state == ans)return step;\n  if(step == depth){\n    leaf.insert(state);\n\n    //cout << \"Step:\" << step << endl;\n    //print(state); cout << endl;\n    \n    return -1;\n  }\n  //if(searched.find(state)!=searched.end())return -1;\n  \n  int next;\n  next = moveSpace(state, U);\n  if(next!=-1){\n    int res=solve(next, step+1, depth);\n    if(res != -1)return res;\n  }\n  next = moveSpace(state, D);\n  if(next!=-1){\n    int res=solve(next, step+1, depth);\n    if(res != -1)return res;\n  }\n  next = moveSpace(state, R);\n  if(next!=-1){\n    int res=solve(next, step+1, depth);\n    if(res != -1)return res;\n  }\n  next = moveSpace(state, L);\n  if(next!=-1){\n    int res=solve(next, step+1, depth);\n    if(res != -1)return res;\n  }\n\n  return -1;\n}\n\n\nint main(){\n\n  /*\n    Index of array\n    0 1 2\n    3 4 5 \n    6 7 8\n   */\n  int init_state;\n\n  //input\n  cin >> init_state;\n  for(int i=1; i<9; i++){\n    int tmp;\n    cin >> tmp;\n    init_state*=10; init_state+=tmp;\n  }\n  \n\n  int step = 0;\n \n  //solve\n  int depth = 1;\n  leaf.insert(init_state);\n  while(1){\n\n    //test\n    //cout << \"===================================\" << endl;\n    //cout << \"Depth: \" << depth << endl;\n\n    \n    set<int> next = leaf;\n    leaf.clear();\n    step = 0;\n    \n    for(int state : next){\n      step = solve(state ,depth-1, depth);\n      if(step != -1)break;\n    }\n    if(step != -1)break;\n\n    \n    depth++;\n  }\n  \n  cout << step << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n\nusing namespace std;\n\nint checkTable[362880];\n\nvoid setNUM(int table[3][3], long long x){\n    int S = 100000000;\n    for(int i=0;i<3;i++){\n        for(int k=0;k<3;k++){\n            table[i][k] = x/S;\n            x = x%S;\n            S /= 10;\n        }\n    }\n}\n\nint getNUM(int x){\n    switch(x){\n    case 0:return 1;\n    case 1:return 1;\n    case 2:return 2;\n    case 3:return 6;\n    case 4:return 24;\n    case 5:return 120;\n    case 6:return 720;\n    case 7:return 5040;\n    case 8:return 40320;\n    }\n    return -1;\n}\n\nlong long makeLong(int Table[3][3]){\n    return 100000000*Table[0][0]+10000000*Table[0][1]+1000000*Table[0][2]+\n            100000*Table[1][0]+10000*Table[1][1]+1000*Table[1][2]+ 100*Table[2][0]+\n            10*Table[2][1]+Table[2][2];\n}\n\nint translateORDER(int Table[3][3]){\n    long long x = makeLong(Table);\n    int checkTable[9] = {0};\n    long long S = 100000000;\n    int ret = 0,small_num_appear_count,limit;\n    for(int i=8; i >= 0; i--){\n        small_num_appear_count=0;\n\tlimit = x/S;\n        for(int k = 0; k < limit;k++){\n            if(checkTable[k] == 1)small_num_appear_count++;\n        }\n        ret += ((x/S)-small_num_appear_count)*getNUM(i);\n        checkTable[(x/S)]=1;\n        x %= S;\n        S /= 10;\n    }\n\n    return ret;\n}\n\n\nint zeroLoc(int table[3][3]){\n    int zero_loc;\n    for(int i=0;i<3;i++){\n        for(int k=0;k<3;k++){\n            if(table[i][k]==0){\n                zero_loc=10*i+k;\n            }\n        }\n    }\n    return zero_loc;\n}\n\nstruct Info{\n    Info(){ zero_loc=data = count = 0;}\n    Info(long long arg_data,int arg_count,short arg_loc){\n        data = arg_data;\n        count = arg_count;\n        zero_loc = arg_loc;\n    }\n    long long data;\n    int count;\n    short zero_loc;\n};\n\nclass LongQ{\npublic:\n    LongQ(){\n        Q = new Info[362880];\n        head = tail = num_of_data=0;\n    }\n\n    void enqueue(long long arg_data,int arg_count,short arg_loc){\n        Q[tail].count = arg_count;\n        Q[tail].data = arg_data;\n        Q[tail].zero_loc = arg_loc;\n        num_of_data++;\n        tail = (tail+1)%362880;\n    }\n\n    Info dequeue(){\n        Info ret = Q[head];\n        head = (head+1)%362880;\n        num_of_data--;\n        return ret;\n    }\n\n    bool isEmpty(){\n        return num_of_data == 0;\n    }\n\nprivate:\n    Info* Q;\n    int head,tail,num_of_data;\n};\n\nLongQ func(LongQ queue,int table[3][3],Info tmpInfo,short zero_loc){\n    if(checkTable[translateORDER(table)] == -1){\n        checkTable[translateORDER(table)]=tmpInfo.count;\n        queue.enqueue(makeLong(table),tmpInfo.count+1,zero_loc);\n    }\n    return queue;\n}\n\nint main(){\n\n    for(int i = 0; i < 362880;i++)checkTable[i]=-1;\n\n    int table[3][3];\n\n    for(int i=0;i<3;i++){\n        scanf(\"%d %d %d\",&table[i][0],&table[i][1],&table[i][2]);\n    }\n\n    checkTable[translateORDER(table)]=0;\n    LongQ queue;\n\n    queue.enqueue(makeLong(table),0,zeroLoc(table));\n\n    Info tmpInfo;\n\n    while(queue.isEmpty()==false){\n        tmpInfo=queue.dequeue();\n\n        int tmpTable[3][3];\n        setNUM(tmpTable,tmpInfo.data);\n        if(tmpTable[0][0]==1&&tmpTable[0][1]==2&&tmpTable[0][2]==3&&tmpTable[1][0]==4&&\n        \t\ttmpTable[1][1]==5&&tmpTable[1][2]==6&&tmpTable[2][0]==7&&tmpTable[2][1]==8){\n            printf(\"%d\\n\",tmpInfo.count);\n            break;\n        }\n\n        int next_table[4][3][3];\n\n        for(int a=0;a<4;a++){\n            for(int b=0;b<3;b++){\n                for(int c=0;c<3;c++){\n                    next_table[a][b][c] = tmpTable[b][c];\n                }\n            }\n        }\n\n        switch(tmpInfo.zero_loc){\n        case 0:\n            swap(next_table[0][0][0],next_table[0][0][1]);\n            queue = func(queue,next_table[0],tmpInfo,1);\n\n            swap(next_table[1][0][0],next_table[1][1][0]);\n            queue = func(queue,next_table[1],tmpInfo,10);\n            break;\n        case 1:\n            swap(next_table[0][0][1],next_table[0][0][0]);\n            queue = func(queue,next_table[0],tmpInfo,0);\n\n            swap(next_table[1][0][1],next_table[1][0][2]);\n            queue = func(queue,next_table[1],tmpInfo,2);\n\n            swap(next_table[2][0][1],next_table[2][1][1]);\n            queue = func(queue,next_table[2],tmpInfo,11);\n            break;\n        case 2:\n            swap(next_table[0][0][2],next_table[0][0][1]);\n            queue = func(queue,next_table[0],tmpInfo,1);\n\n            swap(next_table[1][0][2],next_table[1][1][2]);\n            queue = func(queue,next_table[1],tmpInfo,12);\n\n            break;\n        case 10:\n            swap(next_table[0][1][0],next_table[0][0][0]);\n            queue = func(queue,next_table[0],tmpInfo,0);\n\n            swap(next_table[1][1][0],next_table[1][1][1]);\n            queue = func(queue,next_table[1],tmpInfo,11);\n\n            swap(next_table[2][1][0],next_table[2][2][0]);\n            queue = func(queue,next_table[2],tmpInfo,20);\n\n            break;\n        case 11:\n            swap(next_table[0][1][1],next_table[0][0][1]);\n            queue = func(queue,next_table[0],tmpInfo,1);\n\n            swap(next_table[1][1][1],next_table[1][1][0]);\n            queue = func(queue,next_table[1],tmpInfo,10);\n\n            swap(next_table[2][1][1],next_table[2][1][2]);\n            queue = func(queue,next_table[2],tmpInfo,12);\n\n            swap(next_table[3][1][1],next_table[3][2][1]);\n            queue = func(queue,next_table[3],tmpInfo,21);\n            break;\n        case 12:\n            swap(next_table[0][1][2],next_table[0][0][2]);\n            queue = func(queue,next_table[0],tmpInfo,2);\n\n            swap(next_table[1][1][2],next_table[1][1][1]);\n            queue = func(queue,next_table[1],tmpInfo,11);\n\n            swap(next_table[2][1][2],next_table[2][2][2]);\n            queue = func(queue,next_table[2],tmpInfo,22);\n            break;\n        case 20:\n            swap(next_table[0][2][0],next_table[0][1][0]);\n            queue = func(queue,next_table[0],tmpInfo,10);\n\n            swap(next_table[1][2][0],next_table[1][2][1]);\n            queue = func(queue,next_table[1],tmpInfo,21);\n            break;\n        case 21:\n            swap(next_table[0][2][1],next_table[0][2][0]);\n            queue = func(queue,next_table[0],tmpInfo,20);\n\n            swap(next_table[1][2][1],next_table[1][1][1]);\n            queue = func(queue,next_table[1],tmpInfo,11);\n\n            swap(next_table[2][2][1],next_table[2][2][2]);\n            queue = func(queue,next_table[2],tmpInfo,22);\n            break;\n        case 22:\n            swap(next_table[0][2][2],next_table[0][1][2]);\n            queue = func(queue,next_table[0],tmpInfo,12);\n\n            swap(next_table[1][2][2],next_table[1][2][1]);\n            queue = func(queue,next_table[1],tmpInfo,21);\n            break;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n\n#define N 3\n#define N2 9\n  \nstruct Puzzle{\nint f[N2];\nint space;\nstring path;\n  \nbool operator < (const Puzzle &p) const{\nfor(int i = 0; i < N2; i++){\nif(f[i] == p.f[i]) continue;\nreturn f[i] > p.f[i];\n}\nreturn false;\n}\n};\n  \nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n  \nbool isTarget(Puzzle p){\nfor(int i = 0; i < N2; i++)\nif(p.f[i] != (i + 1)) return false;\nreturn true;\n}\n  \nstring bfs(Puzzle s){\nqueue<Puzzle> Q;\nmap<Puzzle, bool> V;\nPuzzle u, v;\ns.path = \"\";\nQ.push(s);\nV[s] = true;\n  \nwhile(!Q.empty()){\nu = Q.front(); Q.pop();\nif(isTarget(u)) return u.path;\nint sx = u.space / N;\nint sy = u.space % N;\nfor(int r = 0; r < 4; r++){\nint tx = sx + dx[r];\nint ty = sy + dy[r];\nif(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\nv = u;\nswap(v.f[u.space], v.f[tx * N + ty]);\nv.space = tx * N + ty;\nif(!V[v]){\nV[v] = true;\nv.path += dir[r];\nQ.push(v);\n}\n}\n}\nreturn \"\";\n}\n  \nint main(){\nPuzzle in;\nfor(int i = 0; i < N2; i++){\ncin >> in.f[i];\nif(in.f[i] == 0){\nin.f[i] = N2;\nin.space = i;\n}\n}\nstring ans = bfs(in);\ncout << ans.size() << endl;\n  \nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define NUM 3\n#define PRUNING 20\n\ntypedef struct STATUS{\n    int num;\n    int board[NUM][NUM];\n}STATUS;\n\ntypedef pair<int, int> cell;\n\nbool checkfinish(STATUS in){\n    \n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            if (i == NUM - 1 && j == NUM - 1) return true;\n            if(in.board[i][j] != val++) return false;\n        }\n    }\n    return true;\n}\n\n\nint backtrack(STATUS in, cell last_zero){\n\n    int x = 0, y = 0, ret = PRUNING;\n    cell zero;\n    STATUS out;\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    \n    if (in.num > ret) {\n        return ret;\n    }\n    \n    if (checkfinish(in)) {\n        return in.num;\n    }\n\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            if(in.board[i][j] == 0){\n                x = zero.first = j;\n                y = zero.second = i;\n            }\n        }\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (x + dx[i] >=0 && x+dx[i] < NUM && y+dy[i] >=0 && y+dy[i] < NUM) {\n            if (last_zero.first == x+dx[i] && last_zero.second == y+dy[i]){ continue;\n            }\n            memcpy(&out, &in, sizeof(STATUS));\n            swap(out.board[y][x], out.board[y+dy[i]][x+dx[i]]);\n            out.num++;\n            ret = min(ret, backtrack(out, zero));\n        }\n    }\n    return ret;\n}\n\n\nint main(){\n    \n    int val, ans;\n    \n    STATUS init;\n    init.num = 0;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            cin >> val;\n            init.board[i][j] = val;\n        }\n    }\n    \n    //?????????????????????????????????zero????????¨?????????????????????????????\\????????????\n    ans = backtrack(init, cell(-1,-1));\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\n\n#define NPANEL 9\n\nclass State {\npublic:\n  int panels[9];\n  int empty;\n  State(int p[]) {\n    for (int i = 0; i < NPANEL; i++) {\n      panels[i] = p[i];\n      if (p[i] == 0)\n        empty = i;\n    }\n  }\n  void print() {\n    for (int i = 0; i < NPANEL; i++) {\n      if (i != 0 && i % 3 == 0)\n        printf(\"\\n\");\n      printf(\"%d \", panels[i]);\n    }\n  }\n  bool is_completed() {\n    for (int i = 1; i < NPANEL; i++)\n      if (panels[i - 1] != i)\n        return false;\n    return true;\n  }\n  State left() { return slide(empty, empty - 1); }\n  State above() { return slide(empty, empty - 3); }\n  State right() { return slide(empty, empty + 1); }\n  State bottom() { return slide(empty, empty + 3); }\n  State slide(int x, int y) {\n    auto s = State(panels);\n    swap(s.panels[x], s.panels[y]);\n    s.empty = y;\n    return s;\n  }\n\n  vector<State> nexts() {\n    vector<State> v;\n    if (empty % 3 != 0)\n      v.push_back(left());\n    if (empty >= 3)\n      v.push_back(above());\n    if (empty % 3 != 2)\n      v.push_back(right());\n    if (empty <= 5)\n      v.push_back(bottom());\n    return v;\n  }\n};\n\nbool store(State st) {\n  return true;\n  static set<int> pool;\n  int hash = 0;\n  for (int i = 0; i < NPANEL; i++) {\n    hash *= 10;\n    hash += st.panels[i];\n  }\n  bool exists = (pool.find(hash) != pool.end());\n  if (!exists)\n    pool.insert(hash);\n  return !exists;\n}\n\nstruct Node {\n  State state;\n  int depth;\n};\n\nvoid solve(State init) {\n  queue<Node> que;\n  que.push(Node{init, 0});\n\n  while (!que.empty()) {\n    Node node = que.front();\n    for (auto s : node.state.nexts()) {\n      if (s.is_completed()) {\n        cout << node.depth + 1 << endl;\n        return;\n      }\n      if (store(s)) {\n        que.push(Node{s, node.depth + 1});\n      }\n    }\n    que.pop();\n  }\n}\n\nint main() {\n  int data[NPANEL];\n  for (int i = 0; i < NPANEL; i++)\n    cin >> data[i];\n\n  auto s = State(data);\n  solve(s);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<string>\n#include<cassert>\n#include<cmath>\n\nusing namespace std;\n\n#define N 3\n#define PN 9\n#define LIMIT 100\n\nstatic const int dx[4] = {0, -1, 0, 1};\nstatic const int dy[4] = {1, 0, -1, 0};\nstatic const char dir[4] = {'r', 'u', 'l', 'd'};\n\nint MDT[PN][PN];\n\nstruct Puzzle{\n  int f[PN], space, MD;\n};\n\nPuzzle state;\nint limit;\nint path[LIMIT];\n\nint sumMD(Puzzle pzl){\n  int sum = 0;\n  for(int i=0 ; i<PN ; ++i){\n    if(pzl.f[i] == PN) continue;\n    sum += MDT[i][pzl.f[i]-1];\n  }\n  return sum;\n}\n\nbool isSolved(){\n  for(int i=0 ; i<PN ; ++i) if(state.f[i] != i+1) return false;\n  return true;\n}\n\nbool dfs(int depth, int prev){\n  if(state.MD == 0) return true;\n  if(depth + state.MD > limit) return false;\n\n  int sx = state.space/N;\n  int sy = state.space%N;\n  Puzzle tmp;\n\n  for(int r=0 ; r<4 ; ++r){\n    int tx = sx + dx[r];\n    int ty = sy + dy[r];\n    if(tx<0 || ty<0|| tx>=N || ty >= N) continue;\n    if(max(prev, r)-min(prev, r) == 2) continue;\n    tmp = state;\n\n    state.MD -= MDT[tx*N+ty][state.f[tx*N+ty]-1];\n    state.MD += MDT[sx*N+sy][state.f[tx*N+ty]-1];\n    swap(state.f[tx*N+ty], state.f[sx*N+sy]);\n    state.space = tx*N+ty;\n    if(dfs(depth+1, r)){\n      path[depth] = r;\n      return true;\n    }\n    state = tmp;\n  }\n  return false;\n}\n\nstring iterative_deeping(Puzzle in){\n  in.MD = sumMD(in);\n\n  for(limit = in.MD ; limit<=LIMIT ; ++limit){\n    state = in;\n    if(dfs(0, -100)){\n      string ans = \"\";\n      for(int i=0 ; i<limit ; ++i) ans += dir[path[i]];\n      return ans;\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  for(int i=0 ; i<PN ; ++i){\n    for(int j=0 ; j<PN ; ++j){\n      MDT[i][j] = abs(i/N - j/N) + abs(i%N - j%N);\n    }\n  }\n  Puzzle in;\n  for(int i=0 ; i<PN ; ++i){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = PN;\n      in.space = i;\n    }\n  }\n  string ans = iterative_deeping(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\n#define SIDE 3\n#define N 9\n\ntypedef struct board {\n  int state[N];\n  int zero_pos;\n  vector<int> path;\n\n  bool operator < (const board &t) const {\n    for (int i = 0; i < N; i++) {\n      if (state[i] == t.state[i]) continue;\n      else if (state[i] < t.state[i]) return true;\n      else return false;\n    }\n    return false;\n  }\n} Board;\n\nint BOARD[N] = { -1 };\nint DX[4] = { 0, 1, 0, -1 };\nint DY[4] = { 1, 0, -1, 0 };\n\nbool is_goal(Board b) {\n  for (int i = 0; i < N-1; i ++)\n    if (b.state[i] != i+1) return false;\n\n  return true;\n}\n\nvoid solve(Board b) {\n  map<Board, bool> visited;\n  queue<Board> q;\n  q.push(b);\n\n  while (!q.empty()) {\n    Board cur_b = q.front(); q.pop();\n    visited[cur_b] = true;\n\n    if (is_goal(cur_b)) {\n      cout << cur_b.path.size() << endl;\n      return;\n    }\n\n    for (int i = 0; i < 4; i ++) {\n      Board new_b = cur_b;\n      int new_x = (cur_b.zero_pos / SIDE) + DX[i];\n      int new_y = (cur_b.zero_pos % SIDE) + DY[i];\n\n      if (new_x < 0 || new_x > 2 || new_y < 0 || new_y > 2) continue;\n\n      new_b.zero_pos = new_x * SIDE + new_y;\n      swap(new_b.state[new_b.zero_pos], new_b.state[cur_b.zero_pos]);\n\n      if (visited[new_b]) continue;\n\n      new_b.path.push_back(new_b.zero_pos);\n      q.push(new_b);\n    }\n  }\n}\n\nint main() {\n  Board b;\n\n  for (int i = 0; i < N; i++) {\n    cin >> b.state[i];\n    if (b.state[i] == 0) b.zero_pos = i;\n  }\n\n  solve(b);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n#define N 3\n#define N2 9\n\nint main()\n{\n    8puzzle in;\n    for (int i = 0; i < N2; i++)\n    {\n        cin >> in.f[i];\n        if (in.f[i] == 0)\n        {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n\n    return 0;\n}\n\nstruct 8puzzle\n{\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator<(const 8puzzle & p) const\n    {\n        for (int i = 0; i < N2; i++)\n        {\n            if (f[i] == p.f[i])\n                continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\n\nbool isTarget(8puzzle p)\n{\n    for (int i = 0; i < N2; i++)\n        if (p.f[i] != (i + 1))\n            return false;\n    return true;\n}\n\nstring bfs(8puzzle s)\n{\n    queue<8puzzle> Q;\n    map<8puzzle, bool> V;\n    8puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while (!Q.empty())\n    {\n        u = Q.front();\n        Q.pop();\n        if (isTarget(u))\n            return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; r++)\n        {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N)\n                continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if (!V[v])\n            {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 20;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i) {\n        return;\n    }\n\n    if (in.path == \"ldrd\")\n        int debug = 0;\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n    /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n    freopen(\"in.txt\", \"r\", stdin);\n    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for (int i = x; i < n; i++)\n#define OP(m) cout << m << endl\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nstruct puzzle\n{\n    int f[9];\n    int space;\n    int cnt;\n\n    bool operator<(const puzzle &p) const\n    {\n        rep(i, 9)\n        {\n            if (f[i] == p.f[i])\n                continue;\n            return f[i] > p.f[i];\n        }\n        return 0;\n    }\n};\n\npair<int, int> d[4] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};\n\nint bfs(puzzle s)\n{\n    queue<puzzle> q;\n    map<puzzle, bool> mp;\n    mp[s] = 1;\n    s.cnt = 0;\n    q.push(s);\n\n    while (!q.empty())\n    {\n        puzzle u = q.front();\n        q.pop();\n\n        auto check = [](puzzle p) -> bool {\n            rep(i, 9) if (p.f[i] != i + 1) return 0;\n            return 1;\n        };\n\n        if (check(u))\n            return u.cnt;\n\n        int x = u.space / 3, y = u.space % 3;\n        rep(i, 4)\n        {\n            int nx = x + d[i].first, ny = y + d[i].second;\n            if (!((0 <= nx && nx < 3) && (0 <= ny && ny < 3)))\n                continue;\n            puzzle u_copy = u;\n\n            swap(u_copy.f[u.space], u_copy.f[3 * nx + ny]);\n            u_copy.space = 3 * nx + ny;\n\n            if (!mp[u_copy])\n            {\n                mp[u_copy] = 1;\n                u_copy.cnt++;\n                q.push(u_copy);\n            }\n        }\n    }\n\n    return 0;\n}\n\nint main()\n{\n    puzzle in;\n    rep(i, 9)\n    {\n        cin >> in.f[i];\n        if (in.f[i] == 0)\n        {\n            in.f[i] = 9;\n            in.space = i;\n        }\n    }\n\n    OP(bfs(in));\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    for(int i = 0; i < N2; i++){\n      if(f[i] == p.f[i])continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i = 0;i < N2;i++)if(p.f[i] != (i+1))return false;\n    return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while( !Q.empty() ){\n    u = Q.front();\n    Q.pop();\n    if( isTarget(u) )return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r = 0;r < 4;r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if( tx < 0 || ty < 0 || tx >= N || ty >= N )continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx*N+ty]);\n      v.space = tx * N + ty;\n      if( !V[v] ){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0;i<N2;i++){\n    cin >> in.f[i];\n    if( in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n#define N 3\n#define LIMIT_TIME 180000\ntypedef pair<int, int> P;\n\nstruct State {\n    int g, h;\n    string state;\n    P blank;\n    string path;\n    bool operator<(const State &a) const {\n        return g + h > a.g + a.h;\n    }\n};\n\nint d[5] = {-1, 0, 1, 0, -1};\nstring r[4] = {\"D\", \"R\", \"U\", \"L\"};\nstring ans_str = \"\";\nint ans[N][N], puzzle0[N][N], puzzle1[N][N];\nset<string> s;\npriority_queue<State> next_state;\nstring path;\n\nbool range(int y, int x) {return 0 <= y && y < N && 0 <= x && x < N;}\n\nint h2() {\n    int find = -1;\n    while(next_state.size()) {\n        State state = next_state.top();\n        next_state.pop();\n        if (s.count(state.state)) continue; // already search\n        s.insert(state.state); // visited\n\n        P blank = state.blank;\n        rep(i, 4) {\n            int y = d[i] + blank.first, x = d[i + 1] + blank.second; // next blank position\n            if (range(y, x)) { // can be replaced\n                string tmp = state.state; // next state (string)\n                int p = blank.first * N + blank.second, q = y * N + x;\n                if (N < 4)  swap(tmp[p], tmp[q]);\n                else swap(tmp[2 * p], tmp[2 * q]), swap(tmp[2 * p + 1], tmp[2 * q + 1]);\n                if (s.count(tmp)) continue; // already search\n\n                int num;\n                if (N < 4) num = state.state[q] - '1';\n                else num = stoi(state.state.substr(2 * q, 2)) - 1;\n                // calcurate manhattan distance\n                int manhattan = state.h - ((abs(num / N - y) + abs(num % N - x)))\n                + (abs(num / N - blank.first) + abs(num % N - blank.second));\n\n                if (manhattan == 0) { // answer\n                    find = state.g + 1;\n                    path = state.path + r[i];\n                    break;\n                }\n\n                next_state.push(State{state.g + 1, manhattan, tmp, P(y, x), state.path + r[i]});\n            }\n        }\n        if (find != -1) break; // find an answer\n    }\n    return find;\n}\n\nint main(){\n    rep(i, N)rep(j, N) cin >> puzzle0[i][j];\n\n    string state = \"\";\n    P blank;\n    int manhattan = 0, wrong_place = 0;\n    rep(i, N)rep(j, N) {\n        cout << puzzle0[i][j] << ((j % N == N - 1) ? \"\\n\" : \"\\t\");\n\n        if (N * N - 1 > 9 && puzzle0[i][j] < 10) state += \"0\";\n        state += to_string(puzzle0[i][j]);\n        if (N * N - 1 > 9 && ans[i][j] < 10) ans_str += \"0\";\n        ans_str += to_string(ans[i][j]);\n\n        if(puzzle0[i][j] == 0) blank = P(i, j);\n        else {\n            int num = puzzle0[i][j] - 1;\n            manhattan += (abs(num / N - i) + abs(num % N - j));\n            if (puzzle0[i][j] != ans[i][j]) wrong_place++;\n        }\n    }\n\n    if (manhattan == 0) { // the answer\n        cout << 0 << endl;\n    } else {\n        s.clear();\n        next_state = priority_queue<State>();\n        next_state.push(State{0, manhattan, state, blank, \"\"});\n        int steps = h2();\n        cout << steps << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<algorithm>\n#include<stdio.h>\n#include<stdlib.h>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n    \n    bool operator < ( const Puzzle &p ) const {\n        \n        for (int i = 0 ; i<N2 ; i++) {\n            if (f[i]==p.f[i]){\n                continue;\n                \n            }\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nbool isTarget(Puzzle p){\n    \n    for (int i =0 ; i<N2 ; i++){\n        if (p.f[i]!=(i + 1)){\n            return false;\n        }\n    }\n    return true;\n}\n\nstatic const char dir[4] = {'u', 'l', 'd', 'r'\n};\nstatic const int dx[4] = {-1, 0, 1, 0\n};\nstatic const int dy[4] = {0, -1, 0, 1\n};\n\nstring bfs(Puzzle s) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n    \n    while( !Q.empty()) {\n        u = Q.front();\n        Q.pop();\n        if ( isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; r++) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if ( !V[v]) {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    \n    return \"unsolvable\";\n}\n\nint main() {\n    Puzzle in;\n    \n    for (int i =0 ; i<N2 ; i++){\n        cin >> in.f[i];\n        if (in.f[i]==0) {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    \n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n#define N 3\ntypedef pair<int, int> P;\n\nstruct State {\n    int g, h;\n    string state;\n    P blank;\n    string path;\n    bool operator<(const State &a) const {\n        return g + h > a.g + a.h;\n    }\n};\n\nint d[5] = {-1, 0, 1, 0, -1};\nstring r[4] = {\"D\", \"R\", \"U\", \"L\"};\nstring ans_str = \"\";\nint ans[N][N], puzzle0[N][N], puzzle1[N][N];\nset<string> s;\npriority_queue<State> next_state;\nstring path;\n\nbool range(int y, int x) {return 0 <= y && y < N && 0 <= x && x < N;}\n\nint h1() {\n    int find = -1;\n    while(next_state.size()) {\n        State state = next_state.top();\n        next_state.pop();\n        if (s.count(state.state)) continue; // already search\n        s.insert(state.state); // visited\n\n        P blank = state.blank;\n        rep(i, 4) {\n            int y = d[i] + blank.first, x = d[i + 1] + blank.second; // next blank position\n            if (range(y, x)) { // can be replaced\n                string tmp = state.state; // next state (string)\n                int wrong_place = state.h, p = blank.first * N + blank.second, q = y * N + x;\n                if (N < 4) {\n                    swap(tmp[p], tmp[q]);\n                    wrong_place = wrong_place - (state.state[q] != ans_str[q]) + (state.state[q] != ans_str[p]);\n                } else {\n                    swap(tmp[2 * p], tmp[2 * q]), swap(tmp[2 * p + 1], tmp[2 * q + 1]);\n                    wrong_place = wrong_place - (state.state.substr(2 * q, 2) != ans_str.substr(2 * q, 2))\n                    + (state.state.substr(2 * q, 2) != ans_str.substr(2 * p, 2));\n                }\n                if (s.count(tmp)) continue; // already search\n\n                if (wrong_place == 0) { // answer\n                    find = state.g + 1;\n                    path = state.path + r[i];\n                    break;\n                }\n\n                next_state.push(State{state.g + 1, wrong_place, tmp, P(y, x), state.path + r[i]});\n            }\n        }\n        if (find != -1) break; // find an answer\n    }\n    return find;\n}\n\nint main(){\n    // create answer's numbers\n    iota(ans[0], ans[0] + N * N, 1);\n    ans[N - 1][N - 1] = 0;\n    // create number\n    iota(puzzle0[0], puzzle0[0] + N * N, 0);\n    rep(i, N)rep(j, N) cin >> puzzle0[i][j];\n\n    string state = \"\";\n    P blank;\n    int manhattan = 0, wrong_place = 0;\n    rep(i, N)rep(j, N) {\n        state += to_string(puzzle0[i][j]);\n        ans_str += to_string(ans[i][j]);\n\n        if(puzzle0[i][j] == 0) blank = P(i, j);\n        else {\n            int num = puzzle0[i][j] - 1;\n            manhattan += (abs(num / N - i) + abs(num % N - j));\n            if (puzzle0[i][j] != ans[i][j]) wrong_place++;\n        }\n    }\n\n    if (manhattan == 0) { // the answer\n        cout << 0 << endl;\n    } else {\n        int steps;\n        next_state.push(State{0, manhattan, state, blank, \"\"});\n        steps = h1();\n        cout << steps << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n//#define ll long long\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n#define rep(i, n) REP(i, 0, n)\n#define rep_rev(i, n) for (int (i) = (int)(n) - 1 ; (i) >= 0 ; --(i))\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define all(x) (x).begin(),(x).end()\nll t1,t2,t3;\nconst ll mod = 1000000007;\nconst int INF = 1e9;\nconst ll INFLONG = 1e18;\n//ll n = 3;\n//vector<ll> vec(9),vec_init(9);\n//vector<ll> move_vec[9];\n//bool can = false;\n//\n//void init(){\n//  rep(i,9){\n//    vec[i] = vec_init[i];\n//  }\n//}\n//\n//void dfs(ll piv,ll pre, ll depth,ll maxi){\n//  if(depth > maxi){\n//    //cout << depth << endl;\n//    return;\n//  }\n//  bool eq = true;\n//  rep(i,9){\n//    if(vec[i] != (i+1) % 9){\n//      eq = false;\n//      break;\n//    }\n//  }\n//  if(eq){\n//    can = true;\n//    return;\n//  }\n//  for(auto itr:move_vec[piv]){\n//    if(itr != pre){\n//      swap(vec[piv],vec[itr]);\n//      dfs(itr,piv,depth+1,maxi);\n//      swap(vec[piv],vec[itr]);\n//    }\n//  }\n//}\n//\n//int main(){\n//  ll piv = 0;\n//  rep(i,n*n){\n//    cin >> vec_init[i];\n//    if(vec_init[i] == 0){\n//      piv = i;\n//    }\n//  }\n//  rep(i,n*n){\n//    if(i % 3 != 2){\n//      move_vec[i].push_back(i+1);\n//    }\n//    if(i % 3 != 0){\n//      move_vec[i].push_back(i-1);\n//    }\n//    if(i / 3 != 0){\n//      move_vec[i].push_back(i-3);\n//    }\n//    if(i / 3 != 2){\n//      move_vec[i].push_back(i+3);\n//    }\n//  }\n//\n//  ll ans = 0;\n//  rep(i,100){\n//    init();\n//    dfs(piv,-1,0,i);\n//    if(can){\n//      ans = i;\n//      break;\n//    }\n//  }\n//  cout << ans << endl;\n//}\n\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n    ll f[N2];\n    ll space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n      rep(i,N2){\n        if(f[i] == p.f[i])continue;\n        return f[i] > p.f[i];\n      }\n      return false;\n    }\n};\n\nstatic const ll dx[4] = {-1,0,1,0};\nstatic const ll dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  rep(i,N2){\n    if(p.f[i] != (i+1) ) return false;\n  }\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n    if(isTarget(u)) return u.path;\n    ll sx = u.space / N;\n    ll sy = u.space % N;\n    rep(r,4){\n      ll tx = sx + dx[r];\n      ll ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N){\n        continue;\n      }\n      v = u;\n      swap(v.f[u.space],v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if(!V[v]){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  rep(i,N2){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2; // set space\n      in.space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include<iostream>\n#include<functional>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<iomanip>\n#include<set>\n#include<map>\n#include<utility>\n#include<string>\n#include<vector>\n\nusing namespace std;\n\n#define LL long long\nconst int dx[4] = { 1,-1,0,0 };\nconst int dy[4] = { 0,0,1,-1 };\nbool OOA(int x, int y, int H, int W) { return (0 <= x && x<H) && (0 <= y && y<W); }\n\nint main(){\n\tstring f=\"\";\n\tfor(int i=0;i<9;i++){\n\t\tchar c;\n\t\tcin>>c;\n\t\tf+=c;\n\t}\n\n\tmap<string,int>d;\n\tstring g=\"123456780\";\n\n\tqueue<string>q;\n\tq.push(f);\n\td[f]=0;\n\t\n\twhile(!q.empty()){\n\t\tstring n=q.front();\n\t\tq.pop();\n\t\tif(n==g){\n\t\t\tcout<<d[n]<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint nd=d[n];\n\t\tfor(int i=0;i<9;i++){\n\t\t\tif((i/3)&&(n[i]=='0'||n[i-3]=='0')){\n\t\t\t\tswap(n[i],n[i-3]);\n\t\t\t\tif(!d.count(n)){\n\t\t\t\t\td[n]=nd+1;\n\t\t\t\t\tq.push(n);\n\t\t\t\t}\n\t\t\t\tswap(n[i],n[i-3]);\n\t\t\t}\n\t\t\tif((i%3)&&(n[i]=='0'||n[i-1]=='0')){\n\t\t\t\tswap(n[i],n[i-1]);\n\t\t\t\tif(!d.count(n)){\n\t\t\t\t\td[n]=nd+1;\n\t\t\t\t\tq.push(n);\n\t\t\t\t}\n\t\t\t\tswap(n[i],n[i-1]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define NUM 3\n#define PRUNING 28\n\ntypedef struct STATUS{\n    int num;\n    int board[NUM][NUM];\n}STATUS;\n\ntypedef pair<int, int> cell;\n\nbool checkfinish(STATUS in){\n    \n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            if (i == NUM - 1 && j == NUM - 1) return true;\n            if(in.board[i][j] != val++) return false;\n        }\n    }\n    return true;\n}\n\n\nint backtrack(STATUS in, cell last_zero){\n\n    int x = 0, y = 0, ret = PRUNING;\n    cell zero;\n    STATUS out;\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    \n    if (in.num > ret) {\n        return ret;\n    }\n    \n    if (checkfinish(in)) {\n        return in.num;\n    }\n\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            if(in.board[i][j] == 0){\n                x = zero.first = j;\n                y = zero.second = i;\n            }\n        }\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (x + dx[i] >=0 && x+dx[i] < NUM && y+dy[i] >=0 && y+dy[i] < NUM) {\n            if (last_zero.first == x+dx[i] && last_zero.second == y+dy[i]){ continue;\n            }\n            memcpy(&out, &in, sizeof(STATUS));\n            swap(out.board[y][x], out.board[y+dy[i]][x+dx[i]]);\n            out.num++;\n            ret = min(ret, backtrack(out, zero));\n        }\n    }\n    return ret;\n}\n\n\nint main(){\n    \n    int val, ans;\n    \n    STATUS init;\n    init.num = 0;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            cin >> val;\n            init.board[i][j] = val;\n        }\n    }\n    \n    //?????????????????????????????????zero????????¨?????????????????????????????\\????????????\n    ans = backtrack(init, cell(-1,-1));\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define NUM 3\n#define PRUNING 15\n\ntypedef struct STATUS{\n    int num;\n    int board[NUM][NUM];\n}STATUS;\n\nbool checkfinish(STATUS in){\n    \n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            if (i == NUM - 1 && j == NUM - 1) return true;\n            if(in.board[i][j] != val++) return false;\n        }\n    }\n    return true;\n}\n\n\nint backtrack(STATUS in){\n\n    int x = 0, y = 0, ret = PRUNING;\n    STATUS out;\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    \n    if (in.num > ret) {\n        return ret;\n    }\n    \n    if (checkfinish(in)) {\n        return in.num;\n    }\n\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            if(in.board[i][j] == 0){\n                x = j;\n                y = i;\n            }\n        }\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (x + dx[i] >=0 && x+dx[i] < NUM && y+dy[i] >=0 && y+dy[i] < NUM) {\n            memcpy(&out, &in, sizeof(STATUS));\n            swap(out.board[y][x], out.board[y+dy[i]][x+dx[i]]);\n            out.num++;\n            ret = min(ret, backtrack(out));\n        }\n    }\n    return ret;\n}\n\n\nint main(){\n    \n    int val, ans;\n    \n    STATUS init;\n    init.num = 0;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            cin >> val;\n            init.board[i][j] = val;\n        }\n    }\n    \n    ans = backtrack(init);\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\tbool operator <(const Puzzle &p) const {\n\t\tfor (int i = 0; i < N2; ++i) {\n\t\t\tif (f[i] != p.f[i]) {\n\t\t\t\treturn f[i] > p.f[i];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\nbool isComplete(Puzzle p) {\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif (p.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nconst int dx[4] { -1, 0, 1, 0 };\nconst int dy[4] { 0, -1, 0, 1 };\nconst char dir[4] { 'u', 'l', 'd', 'r' };\nstring bfs(Puzzle p) {\n\tp.path = \"\";\n\tmap<Puzzle, bool> M;\n\tM[p] = true;\n\tPuzzle u, v;\n\tqueue<Puzzle> Q;\n\tQ.push(p);\n\tfor (int i = 0; i < N2; ++i) {\n\t\twhile (!Q.empty()) {\n\t\t\tu = Q.front();\n\t\t\tQ.pop();\n\t\t\tif (isComplete(u))\n\t\t\t\treturn u.path;\n\t\t\tint sx = u.space / N;\n\t\t\tint sy = u.space % N;\n\t\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\t\tint tx = sx + dx[r];\n\t\t\t\tint ty = sy + dy[r];\n\t\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\t\tcontinue;\n\t\t\t\tv = u;\n\t\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\t\tv.space = tx * N + ty;\n\t\t\t\tif (!M[v]) {\n\t\t\t\t\tM[v] = true;\n\t\t\t\t\tv.path += dir[r];\n\t\t\t\t\tQ.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unresolved\";\n}\n\nint main() {\n\n\tPuzzle p;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tscanf(\"%d\", &p.f[i]);\n\t\tif (p.f[i] == 0) {\n\t\t\tp.f[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(p);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n\nusing namespace std;\n\nint minimum = -1;\n\nint calcDiffSum(int table[3][3]) {\n    int sum = 0;\n    \n    for(int row = 0; row < 3; row++) {\n        for(int col = 0; col < 3; col++) {\n            if(table[row][col] != 0) {\n                sum += abs((table[row][col] - 1) / 3 - row) + abs((table[row][col] - 1) % 3 - col);\n            }\n        }\n    }\n    return sum;\n}\n\nint zeroLoc(int table[3][3]) {\n    int zero_loc;\n    \n    for(int i = 0; i < 3; i++) {\n        for(int k = 0; k < 3; k++) {\n            if(table[i][k] == 0) {\n                zero_loc = 10 * i + k;\n            }\n        }\n    }\n    return zero_loc;\n}\n\nvoid recursive(int table[3][3], int max_depth, int count, int pre_loc, int zero_loc) {\n    int diffSum = calcDiffSum(table);\n    if(count == max_depth && diffSum == 0) {\n        minimum = max_depth;\n        return;\n    }\n    \n    if(minimum != -1) return;\n    \n    int next_table[4][3][3], tmp_row, tmp_col, pre_row, pre_col;\n    int dif1, dif2, dif3, dif4;\n    \n    switch(zero_loc) {\n        case 0:\n            for(int a = 0; a < 2; a++) {\n                for(int b = 0; b < 3; b++) {\n                    for(int c = 0;  c < 3; c++) {\n                        next_table[a][b][c] = table[b][c];\n                    }\n                }\n            }\n            if(pre_loc != 1) {\n                if((table[0][1] - 1) % 3 == 0) {\n                    dif1 = diffSum - 1;\n                }else {\n                    dif1 = diffSum + 1;\n                }\n                swap(next_table[0][0][0], next_table[0][0][1]);\n                if(count < max_depth && dif1 <= max_depth - count) {\n                    recursive(next_table[0], max_depth, count + 1, zero_loc, 1);\n                }\n            }\n            if(pre_loc != 10) {\n                if((table[1][0] - 1) / 3 == 0) {\n                    dif2 = diffSum - 1;\n                }else {\n                    dif2 = diffSum + 1;\n                }\n                swap(next_table[1][0][0], next_table[1][1][0]);\n                if(count < max_depth && dif2 <= max_depth - count) {\n                    recursive(next_table[1], max_depth, count + 1, zero_loc, 10);\n                }\n            }\n            break;\n            \n        case 1:\n            for(int a = 0; a < 3; a++) {\n                for(int b = 0; b < 3; b++) {\n                    for(int c = 0; c < 3; c++) {\n                        next_table[a][b][c] = table[b][c];\n                    }\n                }\n            }\n            \n            if(pre_loc != 0) {\n                if((table[0][0] - 1) % 3 >= 1) {\n                    dif1 = diffSum - 1;\n                }else {\n                    dif1 = diffSum + 1;\n                }\n                swap(next_table[0][0][1], next_table[0][0][0]);\n                if(count < max_depth && dif1 <= max_depth - count) {\n                    recursive(next_table[0], max_depth, count + 1, zero_loc, 0);\n                }\n            }\n            if(pre_loc != 11) {\n                if((table[1][1] - 1) / 3 == 0) {\n                    dif2 = diffSum - 1;\n                }else {\n                    dif2 = diffSum + 1;\n                }\n                swap(next_table[1][0][1], next_table[1][1][1]);\n                if(count < max_depth && dif2 <= max_depth - count) {\n                    recursive(next_table[1], max_depth, count + 1, zero_loc, 11);\n                }\n            }\n            if(pre_loc != 2) {\n                if((table[0][2] - 1) % 3 <= 1) {\n                    dif3 = diffSum - 1;\n                }else {\n                    dif3 = diffSum + 1;\n                }\n                \n                swap(next_table[2][0][1], next_table[2][0][2]);\n                if(count < max_depth && dif3 <= max_depth - count) {\n                    recursive(next_table[2], max_depth, count + 1, zero_loc, 2);\n                }\n            }\n            break;\n        \n        case 2:\n            for(int a=0;a<2;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 1){\n\t\t\tif((table[0][1]-1)%3==2){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][0][2],next_table[0][0][1]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,1);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 12){\n\t\t\tif((table[1][2]-1)/3==0){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][0][2],next_table[1][1][2]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,12);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 10:\n\t\tfor(int a=0;a<3;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 0){\n\t\t\tif((table[0][0]-1)/3>=1){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][1][0],next_table[0][0][0]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,0);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 11){\n\t\t\tif((table[1][1]-1)%3==0){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][1][0],next_table[1][1][1]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,11);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 20){\n\t\t\tif((table[2][0]-1)/3<=1){\n\t\t\t\tdif3 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif3 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[2][1][0],next_table[2][2][0]);\n\t\t\tif(count < max_depth && dif3 <= max_depth-count){\n\t\t\t\trecursive(next_table[2],max_depth,count+1,zero_loc,20);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 11:\n\t\tfor(int a=0;a<4;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 1){\n\t\t\tif((table[0][1]-1)/3>=1){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][1][1],next_table[0][0][1]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,1);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 10){\n\t\t\tif((table[1][0]-1)%3>=1){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][1][1],next_table[1][1][0]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,10);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 12){\n\t\t\tif((table[1][2]-1)%3<=1){\n\t\t\t\tdif3 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif3 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[2][1][1],next_table[2][1][2]);\n\t\t\tif(count < max_depth && dif3 <= max_depth-count){\n\t\t\t\trecursive(next_table[2],max_depth,count+1,zero_loc,12);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 21){\n\t\t\tif((table[2][1]-1)/3<=1){\n\t\t\t\tdif4 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif4 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[3][1][1],next_table[3][2][1]);\n\t\t\tif(count < max_depth && dif4 <= max_depth-count){\n\t\t\t\trecursive(next_table[3],max_depth,count+1,zero_loc,21);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 12:\n\t\tfor(int a=0;a<3;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 2){\n\t\t\tif((table[0][2]-1)/3>=1){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][1][2],next_table[0][0][2]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,2);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 11){\n\t\t\tif((table[1][1]-1)%3==2){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][1][2],next_table[1][1][1]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,11);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 22){\n\t\t\tif((table[2][2]-1)/3<=1){\n\t\t\t\tdif3 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif3 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[2][1][2],next_table[2][2][2]);\n\t\t\tif(count < max_depth && dif3 <= max_depth-count){\n\t\t\t\trecursive(next_table[2],max_depth,count+1,zero_loc,22);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 20:\n\n\t\tfor(int a=0;a<2;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 10){\n\t\t\tif((table[1][0]-1)/3==2){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][2][0],next_table[0][1][0]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,10);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 21){\n\t\t\tif((table[2][1]-1)%3==0){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][2][0],next_table[1][2][1]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,21);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase 21:\n\t\tfor(int a=0;a<3;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 20){\n\t\t\tif((table[2][0]-1)%3>=1){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][2][1],next_table[0][2][0]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,20);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 11){\n\t\t\tif((table[1][1]-1)/3==2){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][2][1],next_table[1][1][1]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,11);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 22){\n\t\t\tif((table[2][2]-1)%3<=1){\n\t\t\t\tdif3 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif3 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[2][2][1],next_table[2][2][2]);\n\t\t\tif(count < max_depth && dif3 <= max_depth-count){\n\t\t\t\trecursive(next_table[2],max_depth,count+1,zero_loc,22);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 22:\n\t\tfor(int a=0;a<2;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 12){\n\t\t\tif((table[1][2]-1)/3==2){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][2][2],next_table[0][1][2]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,12);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 21){\n\t\t\tif((table[2][1]-1)%3==2){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][2][2],next_table[1][2][1]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,21);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t}\n}\n\n\nvoid func(int table[3][3],int max_depth){\n\twhile(minimum == -1){\n\t\trecursive(table,max_depth,0,-1,zeroLoc(table));\n\t\tmax_depth += 2;\n\t}\n}\n\n\nint main(){\n\n    int table[3][3],start_count;\n\n    for(int i=0;i<3;i++){\n        scanf(\"%d %d %d\",&table[i][0],&table[i][1],&table[i][2]);\n    }\n    start_count = calcDiffSum(table);\n\n    func(table,start_count);\n\n    printf(\"%d\\n\",minimum);\n\n    return 0;\n}\n\n    \n\n"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n// AC\n// ??????????????????????????????????????????AC??????????????????\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 40;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\nint limit;\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nint getAllMD(Puzzle p)\n{\n    int dist = 0;\n    int x, y;\n    int ux, uy;\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] == N2) continue; // ??????0??????\n        x = (p.f[i] - 1) / N;\n        y = (p.f[i] - 1) % N;\n        ux = i / N;\n        uy = i % N;\n        dist += abs(x - ux) + abs(y - uy);\n    }\n    return dist;\n}\n\nbool bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return true;\n    }\n    if (ms[in] || limit < i + getAllMD(in)) {\n        return false;\n    }\n\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n        /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n//    cout << \"MD: \" << getAllMD(in) << endl;\n        if(bfs(i+1)) return true;\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n    return false;\n}\n\nstring iterative_deepening()\n{\n    limit = getAllMD(in);\n    for ( ; limit <= INF; limit++) {\n        if (bfs(0)) {\n            return in.path;\n        }\n    }\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    string ans = iterative_deepening();\n    cout << ans.size() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n \nstruct Puzzle {\n  int f[N*N];\n  int space;\n  string path;\n \n  bool operator < ( const Puzzle &p ) const {\n    for(int i=0;i < N*N; i++){\n      if(f[i]==p.f[i]) continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n \nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n \nbool isTarget(Puzzle p){\n  for(int i=0;i<N*N;i++)\n    if(p.f[i]!=(i+1)) return false;\n  return true;\n}\n \nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n \n  while(!Q.empty()){\n    u=Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N) continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n    V[v]=true;\n    v.path+=dir[r];\n    Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n \nint main()\n{\n  Puzzle in;\n \n  for(int i=0;i<N*N;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N*N;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout<<ans.size()<<endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define N 9\n\nint ans[N];\nint cur[N];\nint anspos[N];\nint movepos[4] = {-3, 1, 3, -1};\n\n// int trace[1000][N];\nint ti=0;\n\nint checkAns() {\n  for (int i = 0; i < N; i++) {\n    if (ans[i] != cur[i]) return 0;\n  }\n  return 1;\n}\n\nint calcEst() {\n  int total = 0, t;\n  for (int i = 0; i < N; i++) {\n    t = (i % 3) - (anspos[cur[i]] % 3);\n    if (t >= 0)\n      total += t;\n    else\n      total -= t;\n\n    t = (i / 3) - (anspos[cur[i]] / 3);\n    if (t >= 0)\n      total += t;\n    else\n      total -= t;\n  }\n  return total;\n}\n\nint dfs(int x, int px,int lim) {\n  int res = -1, minres = -1;\n\n  int mark[N];\n\n  if (checkAns()) return 0;\n  if (lim == 0) return -1;\n  if (calcEst() > lim) return -1;\nti++;\n  for (int i = 0; i < 4; i++) {\n    if (x + movepos[i]==px)continue;\n    if ((x%3==0&&movepos[i]==-1)||(x%3==2&&movepos[i]==1)) continue;\n    if (x + movepos[i] >= N || x +movepos[i] < 0) continue;\n    swap(cur[x], cur[x + movepos[i]]);\n    res = dfs(x + movepos[i],x, lim - 1);\n    if (res != -1) {\n      // return res+1;\n      if (minres == -1){\n\n        minres = res + 1;\n                // for (int i = 0; i < N; i++) trace[ti][i] = cur[i];\n      }\n\n      else {\n        minres = min(minres, res + 1);\n        // for (int i = 0; i < N; i++) trace[ti][i] = cur[i];\n      }\n    }\n    swap(cur[x], cur[x + movepos[i]]);\n  }\n\n\nti--;\n  return minres;\n}\n\nint main() {\n  int x, lim = 0, res;\n\n  for (int i = 0; i < N; i++) ans[i] = i + 1;\n  ans[N - 1] = 0;\n  for (int i = 0; i < N; i++) anspos[i] = i - 1;\n  anspos[0] = N - 1;\n\n  for (int i = 0; i < N; i++) {\n    cin >> cur[i];\n    if (cur[i] == 0) x = i;\n  }\n\n  while (true) {\n    res = dfs(x,x, lim);\n    if (res >= 0) break;\n    lim++;\n  }\n//           for (int i = 0; i < res+2; i++) {\n//             for (int j = 0; j < N;j++){ cout << trace[i][j]<<\" \" ;if (j%3==2)cout <<endl;}\n// cout <<\"----------\" <<endl;\n//           }\n\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n// ????????¨?????????24????????±??????????????????\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 23;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nint getAllMD(Puzzle p)\n{\n\tint dist = 0;\n\tint x, y;\n\tint ux, uy;\n\tfor (int i = 0; i < N2; i++) {\n\t\tx = p.f[i] / N;\n\t\ty = p.f[i] % N;\n\t\tux = i / N;\n\t\tuy = i % N;\n\t\tdist += abs(x - ux) + abs(y - uy);\n\t}\n\treturn dist;\n}\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i + getAllMD(in)) {\n        return;\n    }\n\n    if (in.path == \"ldrd\")\n        int debug = 0;\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n    /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < ( const Puzzle &p ) const {\n    for ( int i = 0; i < N2; i++ ) {\n      if ( f[i] == p.f[i] ) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n  for ( int i = 0; i < N2; i++ )\n    if ( p.f[i] != (i + 1) ) return false;\n  return true;\n}\n\nstring bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while ( !Q.empty() ) {\n    u = Q.front(); Q.pop();\n    if ( isTarget(u) ) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for ( int r = 0; r < 4; r++ ) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if ( !V[v] ) {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main() {\n  Puzzle in;\n\n  for ( int i = 0; i < N2; i++ ) {\n    cin >> in.f[i];\n    if ( in.f[i] == 0 ) {\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    for(int i = 0; i < N2; i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  for(int i = 0; i < N2; i++) if(p.f[i] != (i + 1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r = 0; r < 4; r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if(!V[v]){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i = 0; i < N2; i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n#define N 3\nint po[N*N+10];\nint m2i(mat m){\n  int res=0;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      res+=m[i][j]*po[i*N+j];\n  return res;\n}\nmat i2m(int x){\n  mat res(N,vec(N));;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      res[i][j]=(x%po[i*N+j+1])/po[i*N+j];\n  return res;\n}\n\nsigned main(){\n  po[0]=1;\n  for(int i=0;i<N*N;i++) po[i+1]=po[i]*10;\n  mat p(N,vec(N));\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      cin>>p[i][j];\n  mat e(p);\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      e[i][j]=i*N+j+1;\n  e[N-1][N-1]=0;\n  int ans=m2i(e);\n  //cout<<ans<<endl;\n  queue<int> q;\n  map<int,int> m;\n  q.push(m2i(p));\n  m[m2i(p)]=0;\n  int ax[]={1,0,-1,0};\n  int ay[]={0,1,0,-1};\n  while(!q.empty()){\n    int x=q.front();q.pop();\n    if(x==ans) break;\n    //cout<<x<<endl;\n    p=i2m(x);\n    int zy,zx;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n\tif(p[i][j]==0) zy=i,zx=j;\n    //cout<<zy<<\" \"<<zx<<endl;\n    for(int k=0;k<4;k++){\n      int ny=zy+ay[k],nx=zx+ax[k];\n      if(ny<0||N<=ny||nx<0||N<=nx) continue;\n      swap(p[zy][zx],p[ny][nx]);\n      int t=m2i(p);\n      //cout<<t<<endl;\n      if(!m.count(t)){\n\tm[t]=m[x]+1;\n\tq.push(t);\n      }\n      swap(p[zy][zx],p[ny][nx]);\n    }\n  }\n  cout<<m[ans]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <cmath>\n#include <cassert>\n#include <string>\nusing namespace std;\n\n#define N1 3\n#define N2 9\n#define LIMITMAX 100\n//#define false 0\n//#define true 1\n\nstruct PUZZLE\n{\n    int f[N2], kuuhaku, MD; /*マンハッタン距離*/\n                            //int cost;\n};\n\nstatic const int dx_123[4] = {0, -1, 0, 1};         //４方向\nstatic const int dy_123[4] = {1, 0, -1, 0};         //４方向\nstatic const char houkou[4] = {'r', 'u', 'l', 'd'}; //右:right,　上:up,　左:left,　下:down\n\nint ManhattanDistance[N2][N2];\nPUZZLE jyoutai;\nint limit; //深さのlimit\nint miti[LIMITMAX];\n\nint GetallManhattanDistance(PUZZLE);\nbool dfs(int, int);\n//int max(int, int);\n//int min(int, int);\nstring iterative_deepning(PUZZLE); //反復深化\n\nint main()\n{\n\n    int i, j, k;\n    PUZZLE in;\n\n    for (i = 0; i < N2; i++)\n    {\n        for (j = 0; j < N2; j++)\n        {\n            ManhattanDistance[i][j] = abs(i / N1 - j / N1) + abs(i % N1 - j % N1);\n        }\n    }\n\n    for (i = 0; i < N2; i++)\n    {\n        cin >> in.f[i];\n        if (in.f[i] == 0)\n        {\n            in.f[i] = N2;\n            in.kuuhaku = i;\n        }\n    }\n\n    string kotae = iterative_deepning(in);\n\n    cout << kotae.size();\n    cout << endl;\n\n    return 0;\n}\n\n/*\n  void  swap(int *a , int *b){\n  int *tmp;\n  \n  tmp = a;\n  a = b ;\n  b = tmp;\n  \n  }\n*/\nint GetallManhattanDistance(PUZZLE p)\n{ //全てのマンハッタン距離を取得する\n\n    int goukei = 0;\n    int i, j, k;\n\n    for (i = 0; i < N2; i++)\n    {\n        if (p.f[i] == N2)\n            continue;\n        goukei += ManhattanDistance[i][p.f[i] - 1];\n    }\n\n    return goukei;\n}\n\nbool dfs(int depth, int prev)\n{\n\n    int i, j, k;\n    int r;\n    int sx, sy;\n    PUZZLE tmp;\n    int tx, ty;\n\n    if (jyoutai.MD == 0)\n        return true;\n    //現在の深さにヒューリスティックを足して制限を超えたら枝を切る\n\n    if (depth + jyoutai.MD > limit)\n        return false;\n\n    sx = jyoutai.kuuhaku / N1;\n    sy = jyoutai.kuuhaku % N1;\n\n    for (r = 0; r < 4; r++)\n    {\n        tx = sx + dx_123[r];\n        ty = sy + dy_123[r];\n\n        if (tx < 0 || tx >= N1 || ty < 0 || ty >= N1)\n            continue;\n        if (max(prev, r) - min(prev, r) == 2)\n            continue;\n        tmp = jyoutai;\n        //マンハッタン距離の差分を計算しつつ、ピースをスワップ\n        jyoutai.MD -= ManhattanDistance[tx * N1 + ty][jyoutai.f[tx * N1 + ty] - 1];\n        jyoutai.MD += ManhattanDistance[sx * N1 + sy][jyoutai.f[tx * N1 + ty] - 1];\n        swap(jyoutai.f[tx * N1 + ty], jyoutai.f[sx * N1 + sy]);\n        jyoutai.kuuhaku = tx * N1 + ty;\n        if (dfs(depth + 1, r))\n        {\n            miti[depth] = r;\n            return true;\n        }\n        jyoutai = tmp;\n    }\n\n    return false;\n}\n/*\n  int max(int a, int b){\n  if(a<b) return b;\n  return a;\n  }\n\n  int min(int a, int b){\n  if(a<b) return a;\n  return b;\n  }\n*/\n\nstring iterative_deepning(PUZZLE in)\n{ //反復深化\n\n    int i, j, k;\n    //string  kotae = \"\";\n    //char kotae2[] = \"unsolvable\";\n\n    in.MD = GetallManhattanDistance(in); //初期のマンハッタン距離\n\n    for (limit = in.MD; limit <= LIMITMAX; limit++)\n    {\n        jyoutai = in;\n        if (dfs(0, -100))\n        {\n            string kotae = \"\";\n            for (i = 0; i < limit; i++)\n                kotae += houkou[miti[i]];\n            return kotae;\n        }\n    }\n\n    return \"できませんでした\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nset<int> dp;\n\nclass eightPuzzle {\n public:\n    int table[3][3];\n    int x, y;\n};\n\nint UP = 0, LEFT = 1, RIGHT = 2, DOWN = 3;\neightPuzzle move(eightPuzzle p, int dir) {\n    eightPuzzle newp;\n    for (int i = 0; i < 3; i++) {\n        memcpy(newp.table[i], p.table[i], sizeof(p.table[i]));\n    }\n    newp.x = p.x;\n    newp.y = p.y;\n\n    if (dir == UP && newp.y + 1 < 3) {\n        swap(newp.table[newp.y][newp.x], newp.table[newp.y + 1][newp.x]);\n        newp.y++;\n    } else if (dir == LEFT && newp.x + 1 < 3) {\n        swap(newp.table[newp.y][newp.x], newp.table[newp.y][newp.x + 1]);\n        newp.x++;\n    } else if (dir == RIGHT && newp.x - 1 >= 0) {\n        swap(newp.table[newp.y][newp.x], newp.table[newp.y][newp.x - 1]);\n        newp.x--;\n    } else if (dir == DOWN && newp.y - 1 >= 0) {\n        swap(newp.table[newp.y][newp.x], newp.table[newp.y - 1][newp.x]);\n        newp.y--;\n    }\n    return newp;\n}\n\n// 8パズルをハッシュ化する関数\nint eightHash(eightPuzzle p) {\n    int ret = 0;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            ret += p.table[i][j] * pow(10, 3 * i + j);\n        }\n    }\n    return ret;\n}\n\n// ゴールに到達したかを判定する\nbool goal(eightPuzzle p) {\n    bool flag = true;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (p.table[i][j] != (3 * i + j + 1) % 9) flag = false;\n            if (!flag) break;\n        }\n        if (!flag) break;\n    }\n    return flag;\n}\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    eightPuzzle p;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            cin >> p.table[i][j];\n            if (p.table[i][j] == 0) {\n                p.x = j;\n                p.y = i;\n            }\n        }\n    }\n    if (goal(p)) {\n        cout << 0 << endl;\n        return 0;\n    }\n    int ehash = eightHash(p);\n    dp.insert(ehash);\n    queue<pair<eightPuzzle, int>> q;\n    q.push(make_pair(p, 0));\n    while (true) {\n        int cnt;\n        eightPuzzle ep;\n        tie(ep, cnt) = q.front();\n        q.pop();\n        for (int i = 0; i < 4; i++) {\n            eightPuzzle np = move(ep, i);\n            if (goal(np)) {\n                cout << cnt + 1 << endl;\n                return 0;\n            }\n            int h = eightHash(np);\n            if (dp.find(h) == dp.end()) {\n                q.push(make_pair(np, cnt + 1));\n                dp.insert(h);\n            }\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<string>\n\nusing namespace std;\n#define N 3\n#define M 9\nint i,j;;\n//?§????????????????\nstruct Puzzle{\n  int f[M];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p)const{\n    for( i=0;i<M;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n  \n};\n////\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n///\nvoid swapp(int *p,int *q){\n  int tmp;\n  tmp=*p;\n  *p=*q;\n  *q=tmp;\n}\n///\nbool Target(Puzzle p){\n  for(i=0;i<M;i++)if(p.f[i]!=(i+1))return false;\n  return true;\n\n}\n///\n\n///\nstring bfs(Puzzle s){\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  queue<Puzzle> Q;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front();\n    Q.pop();\n    if(Target(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N)continue;\n      v=u;\n      swapp(&v.f[u.space],&v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      } \n    }\n  }\n  return \"unsolvable\";\n}\n///\n\nint main(){\n  Puzzle in;\n\n  for(i=0;i<M;i++){\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i]==0){\n      in.f[i]=M;\n      in.space=i;\n    }\n  }\n\n  string ans=bfs(in);\n  cout << ans.size() << endl;\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define PER(i,n) for(int i=n-1;i>=0;--i)\n#define REPA(i,n) for(int i=1;i<(n);++i)\n#define foreach(i, n) for(auto &i:(n))\n#define PII pair<int,int>\n#define PLI pair<long long, int>\n#define PLL pair<long long, long long>\n#define MOD ((int)1e9 + 7)\n#define INF ((int)1e9+5)\n#define INFLL ((LL)4e18)\n#define ALL(x) (x).begin(),(x).end()\n#define BIT(x) (1LL << (x))\n#define SIZE 3\nusing namespace std;\n\nclass board{\npublic:\n\tvector<vector<int>> data;\n\tint ncost;\n\tint hcost;\n\tPII zpoint;\n\n\tint culonecost(int i, int j){\n\t\tif(data[i][j]==0){\n\t\t\treturn abs(SIZE-1-i) + abs(SIZE-1-j);\n\t\t}\n\t\tint x = (data[i][j]-1)%SIZE;\n\t\tint y = (data[i][j]-1)/SIZE;\n\t\treturn abs(i-y) + abs(j-x);\n\t}\n\n\tvoid setup(){\n\t\thcost = 0;\n\t\tREP(i, SIZE){\n\t\t\tREP(j, SIZE){\n\t\t\t\thcost+=culonecost(i, j);\n\t\t\t\tif(data[i][j]==0){\n\t\t\t\t\tzpoint=PII(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tboard(vector<vector<int>> d){\n\t\tREP(i, SIZE){\n\t\t\tREP(j, SIZE){\n\t\t\t\tdata[i][j]=d[i][j];\n\t\t\t}\n\t\t}\n\t\thcost = 0;\n\t\tsetup();\n\t}\n\n\tboard(){\n\t\tdata.resize(SIZE, vector<int>(SIZE));\n\t}\n\n\tvoid swap(int i, int j, int k, int l){\n\t\thcost -= culonecost(i, j);\n\t\thcost -= culonecost(k, l);\n\t\tstd::swap(data[i][j], data[k][l]);\n\t\thcost += culonecost(i, j);\n\t\thcost += culonecost(k, l);\n\t\tif(data[i][j]==0){\n\t\t\tzpoint=PII(i, j);\n\t\t}else{\n\t\t\tzpoint=PII(k, l);\n\t\t}\n\t}\n\n\tbool onboard(int i, int j){\n\t\treturn 0<=i&&0<=j&&i<SIZE&&j<SIZE;\n\t}\n\t\n};\n\nint mx[]={1, 0, -1, 0}, my[]={0, 1, 0, -1};\n\nbool func(board &boa, int time, int lx, int ly){\n\tif(boa.hcost - boa.culonecost(boa.zpoint.first, boa.zpoint.second) > time * 1)return false;\n\tif(boa.hcost==0)return true;\n\tbool res = false;\n\tREP(i, 4){\n\t\tint y = boa.zpoint.first;\n\t\tint x = boa.zpoint.second;\n\t\tint ny = y + my[i];\n\t\tint nx = x + mx[i];\n\t\tif(lx==nx&&ly==ny)continue;\n\t\tif(!boa.onboard(ny, nx))continue;\n\t\tboa.swap(y, x, ny, nx);\n\t\tres |= func(boa, time-1, x, y);\n\t\tboa.swap(y, x, ny, nx);\n\t\tif(res)return true;\n\t}\n\treturn res;\n}\n\n\nint main(){\n\tboard boa;\n\tREP(i, SIZE)\n\t\tREP(j, SIZE)cin>>boa.data[i][j];\n\tboa.setup();\n\tREP(i, 1000){\n\t\tif(func(boa, i, -1, -1)){\n\t\t\tcout << i << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<unordered_set>\nusing namespace std;\n\nconst int D_x[4] = { 0,1,0,-1 };\nconst int D_y[4] = { 1,0,-1,0 };\nconst int ANS = 123456780;\n\nvoid setNum(int puzzle[3][3],int n) {\n\tfor (int i = 2; i >= 0; i--) {\n\t\tfor (int j = 2; j >= 0; j--) {\n\t\t\tpuzzle[i][j] = n % 10;\n\t\t\tn /= 10;\n\t\t}\n\t}\n}\n\nint getNum(int puzzle[3][3]) {\n\tint res = 0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tres *= 10;\n\t\t\tres += puzzle[i][j];\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid find_0(int puzzle[3][3], int& x, int& y) {\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tif (puzzle[i][j] == 0) {\n\t\t\t\tx = j;\n\t\t\t\ty = i;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve(int puzzle[3][3]) {\n\tqueue<int> q;\n\tunordered_set<int> table;\n\tint cnt = 1;\n\n\tq.push(getNum(puzzle));\n\tif (q.front() == ANS)return 0;\n\twhile (true) {\n\t\tint s = q.size();\n\n\t\tfor (int i = 0; i < s; i++) {\n\t\t\tint x, y;\n\t\t\tfind_0(puzzle, x, y);\n\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tint X = x + D_x[j];\n\t\t\t\tint Y = y + D_y[j];\n\t\t\t\tif (X < 0 || Y < 0 || X >= 3 || y >= 3)continue;\n\t\t\t\tsetNum(puzzle, q.front());\n\t\t\t\tswap(puzzle[y][x], puzzle[Y][X]);\n\n\t\t\t\tint n = getNum(puzzle);\n\t\t\t\tif (n == ANS) {\n\t\t\t\t\treturn cnt;\n\t\t\t\t}\n\t\t\t\tif (table.count(n) == 0) {\n\t\t\t\t\ttable.insert(n);\n\t\t\t\t\tq.push(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.pop();\n\t\t}\n\t\tcnt++;\n\t}\n}\n\nint main() {\n\tint puzzle[3][3];\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tcin >> puzzle[i][j];\n\t\t}\n\t}\n\n\tcout << solve(puzzle) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator <(const Puzzle &p) const {\n\t\tfor (int i = 0; i < N2; ++i) {\n\t\t\tif (f[i] == p.f[i])\n\t\t\t\tcontinue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nbool isComplete(Puzzle p) {\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif (p.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nconst int dx[4] = { -1, 0, 1, 0 };\nconst int dy[4] = { 0, -1, 0, 1 };\nconst char dir[4] = { 'u', 'l', 'd', 'r' };\nstring bfs(Puzzle p) {\n\tqueue<Puzzle> Q;\n\tp.path = \"\";\n\tQ.push(p);\n\tPuzzle u, v;\n\tmap<Puzzle, bool> M;\n\tM[p] = true;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isComplete(u))\n\t\t\treturn u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!M[v]) {\n\t\t\t\tM[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"unresolved\";\n}\n\nint main() {\n\n\tPuzzle p;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tscanf(\"%d\", &p.f[i]);\n\t\tif (p.f[i] == 0) {\n\t\t\tp.f[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\n\tstring ans = bfs(p);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n// ????????¨?????????24????????±??????????????????\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 30;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nint getAllMD(Puzzle p)\n{\n    int dist = 0;\n    int x, y;\n    int ux, uy;\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] == N2) continue; // ??????0??????\n        x = (p.f[i] - 1) / N;\n        y = (p.f[i] - 1) % N;\n        ux = i / N;\n        uy = i % N;\n        dist += abs(x - ux) + abs(y - uy);\n    }\n    return dist;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i + getAllMD(in)) {\n        return;\n    }\n    \n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n        /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n//    cout << \"MD: \" << getAllMD(in) << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<string>\nusing namespace std;\n\nstatic const int N = 3;\nstatic const int N2 = 9;\n\nstatic const int dx[4] = {-1, 0, 1, 0}; //??£??\\???{}\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const int dir[4] = {'u', 'l', 'd', 'r'};\n\nstruct Puzzle {\n\tint p[N2], space;\n\tstring path;\n\n\tbool operator < (const Puzzle &p1) const { //????????§?????????\n\t\tfor (int i = 0; i < N2; i++) {\n\t\t\tif (p[i] == p1.p[i]) continue;\n\t\t\treturn p[i] > p1.p[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nbool isTarget(Puzzle u) {\n\tfor (int i = 0; i < N2; i++) {\n\t\tif (u.p[i] != i + 1) return false; \n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle s) {\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V; //????????´???Puzzle??§????????????????????§ < ????????????????????¨????????????\n\n\tPuzzle u, v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isTarget(u)) return u.path; //????????????????????????????????§??????\n\t\tint sx = u.space / N; //space??????\n\t\tint sy = u.space % N; //space??????\n\t\tfor (int r = 0; r < 4; r++)\t{\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tswap(v.p[u.space], v.p[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\n\nint main() {\n\tPuzzle in;\n\tfor (int i = 0; i < N2; i++) {\n\t\tcin >> in.p[i];\n\t\tif (!in.p[i]) {\n\t\t\tin.p[i] = N2; //isTarget?????????\n\t\t\tin.space = i;\n\t\t}\n\t}\n\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <list>\n#include <vector>\n#include <string>\n#include <map>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nstruct state {\n    Board board;\n    int count;\n};\n\nlist<state> q;\nmap<Board,char> history;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    map<Board,char>::iterator it = history.find(s.board);\n    if (it != history.end()) {\n        return -1;\n    }\n    history.insert(make_pair(s.board, ' '));\n//    for (list<state>::iterator it = q.begin(); it != q.end(); ++it) {\n//        if (it->board == s.board) {\n//            return -1;\n//        }\n//    }\n    ++s.count;\n    if (s.board == GOAL) {\n        return s.count;\n    }\n    q.push_back(s);\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0; i < N; ) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            board |= static_cast<long long>((ch - '0')) << (i*4);\n            ++i;\n        }\n    }\n\n//    print(GOAL);\n//    print(board);\n\n    q.push_back({ board, 0 });\n    int count = 0;\n    while (!q.empty()) {\n        state s = q.front();\n        q.pop_front();\n        // ?????????????????????\n        int pos;\n        for (pos = 0; pos < N; ++pos) {\n            if (((s.board >> (pos*4)) & 15) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n#define N 3\nint po[N*N+10];\nint m2i(mat m){\n  int res=0;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      res+=m[i][j]*po[i*N+j];\n  return res;\n}\nmat i2m(int x){\n  mat res(N,vec(N));;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      res[i][j]=(x%po[i*N+j+1])/po[i*N+j];\n  return res;\n}\n\nsigned main(){\n  po[0]=1;\n  for(int i=0;i<N*N;i++) po[i+1]=po[i]*10;\n  mat p(N,vec(N));\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      cin>>p[i][j];\n  mat e(p);\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      e[i][j]=i*N+j+1;\n  e[N-1][N-1]=0;\n  int ans=m2i(e);\n  //cout<<ans<<endl;\n  queue<int> q;\n  map<int,int> m;\n  q.push(m2i(p));\n  m[m2i(p)]=0;\n  int ax[]={1,0,-1,0};\n  int ay[]={0,1,0,-1};\n  while(!q.empty()){\n    int x=q.front();q.pop();\n    if(x==ans) break;\n    //cout<<x<<endl;\n    p=i2m(x);\n    int zy,zx;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n\tif(p[i][j]==0) zy=i,zx=j;\n    //cout<<zy<<\" \"<<zx<<endl;\n    for(int k=0;k<4;k++){\n      int ny=zy+ay[k],nx=zx+ax[k];\n      if(ny<0||N<=ny||nx<0||N<=nx) continue;\n      swap(p[zy][zx],p[ny][nx]);\n      int t=m2i(p);\n      //cout<<t<<endl;\n      if(!m.count(t)){\n\tm[t]=m[x]+1;\n\tq.push(t);\n      }\n      swap(p[zy][zx],p[ny][nx]);\n    }\n  }\n  cout<<m[ans]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX 3\n#define MAX2 9\n\nusing namespace std;\n\nstruct Puzzle{\n  int f[MAX2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const {\n  int i;\n    for(i = 0; i < MAX2; i++){\n      if( f[i] == p.f[i] ){\n        continue;\n      }\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstring bfs(Puzzle);\nbool isTarget(Puzzle);\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\nchar dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  int i;\n  for(i = 0; i < MAX2; i++){\n    if( p.f[i] != (i+1) ){\n      return false;\n    }\n  }\n  return true;\n}//end of isTarget func\n\nint main(){\n  Puzzle in;\n  int i;\n  for(i = 0; i < MAX2; i++){\n    cin >> in.f[i];\n    if( in.f[i] == 0 ){\n      in.f[i] = MAX2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n  return 0;\n}//end of main func\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  int r,tx,ty;\n  int sx,sy;\n  int tmp;\n\n  while( !Q.empty() ){\n    u = Q.front();\n    Q.pop();\n    if( isTarget(u) ){\n      return u.path;\n    }\n    sx = u.space / MAX;\n    sy = u.space % MAX;\n    for(r = 0; r < 4; r++){\n      tx = sx + dx[r];\n      ty = sy + dy[r];\n      if( tx < 0 || ty < 0 || tx >= MAX || ty >= MAX){\n        continue;\n      }\n      v = u;\n      /*swap*/\n      tmp = v.f[u.space];\n      v.f[u.space] = v.f[tx * MAX + ty];\n      v.f[tx * MAX + ty] = tmp;\n\n      v.space = tx * MAX + ty;\n      if( !V[v] ){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n    int f[N2];\n    int space;\n    string path;\n    \n    bool operator <(const Puzzle &p) const{\n        for(int i=0;i<N2;i++){\n            if(f[i]==p.f[i]) continue;\n            return f[i]>p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n    for(int i=0;i<N2;i++){\n        if(p.f[i]!=(i+1)) return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle,bool> V;\n    Puzzle u,v;\n    s.path=\"\";\n    Q.push(s);\n    V[s]=true;\n    \n    while(!Q.empty()){\n        u=Q.front(); Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx=u.space/N;\n        int sy=u.space%N;\n        for(int r=0;r<4;r++){\n            int tx=sx+dx[r];\n            int ty=sy+dy[r];\n            if(tx<0||ty<0||tx>=N||ty>=N) continue;\n            v=u;\n            swap(v.f[u.space],v.f[tx*N+ty]);\n            v.space=tx*N+ty;\n            if(!V[v]){\n                V[v]=true;\n                v.path+=dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main(){\n    Puzzle in;\n    for(int i=0;i<N2;i++){\n        cin>>in.f[i];\n        if(in.f[i]==0){\n            in.f[i]=N2;\n            in.space=i;\n        }\n    }\n    string ans=bfs(in);\n    cout<<ans.size()<<endl;\n    return 0;\n}\n    \n    \n    \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint ans[3][3] =\n{\n    {1, 2, 3},\n    {4, 5, 6},\n    {7, 8, 0}\n};\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { -1, 0, 1, 0 };\n\nbool match(int f[3][3]) {\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            if (f[i][j] != ans[i][j])\n                return false;\n        }\n    }\n    return true;\n}\n\nint dfs(int f[3][3], int x, int y, int d, int l) {\n    if (match(f))\n        return d;\n    if (d > l)\n        return -1;\n    for (int i = 0, res; i < 4; ++i) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (nx < 0 || nx > 2 || ny < 0 || ny > 2)\n            continue;\n        f[y][x] = f[ny][nx];\n        f[ny][nx] = 0;\n        if ((res = dfs(f, nx, ny, d + 1, l)) > 0)\n            return res;\n        f[ny][nx] = f[y][x];\n        f[y][x] = 0;\n    }\n    return -1;\n}\n\nint main() {\n    int f[3][3], x, y;\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> f[i][j];\n            if (f[i][j] == 0) {\n                y = i;\n                x = j;\n            }\n        }\n    }\n\n    int res;\n    for (int i = 1; i < 100; ++i) {\n        if ((res = dfs(f, x, y, 0, i)) >= 0) {\n            break;\n        }\n    }\n    cout << res << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<set>\n#include<algorithm>\nusing namespace std;\nstruct Status{\n        int a[3][3];\n        int c,i,j;\n        bool isTarget(){\n                for(int i=0;i<8;i++){\n                        if(a[i/3][i%3]!=i+1) return false;\n                }\n                return true;\n        }\n};\n\nbool operator< (const Status &s, const Status &t){\n        for(int i=0;i<9;i++){\n                if(s.a[i/3][i%3]==t.a[i/3][i%3]) continue;\n                return s.a[i/3][i%3] < t.a[i/3][i%3];\n        }\n        return false;\n}\n\nqueue<Status> que;\nset<Status> visited;\n\n\nint solve(){\n        while(1){\n                Status s = que.front();que.pop();\n                if(visited.find(s)!=visited.end()) continue;\n                if(s.isTarget()) return s.c;\n                visited.insert(s);\n                s.c++;\n                if(s.i!=0) {\n                        swap(s.a[s.i][s.j], s.a[s.i-1][s.j]);\n                        s.i = s.i-1;\n                        que.push(s);\n                        s.i = s.i+1;\n                        swap(s.a[s.i][s.j], s.a[s.i-1][s.j]);\n                }\n                if(s.j!=0) {\n                        swap(s.a[s.i][s.j], s.a[s.i][s.j-1]);\n                        s.j = s.j-1;\n                        que.push(s);\n                        s.j = s.j+1;\n                        swap(s.a[s.i][s.j], s.a[s.i][s.j-1]);\n                }\n                if(s.i!=2) {\n                        swap(s.a[s.i][s.j], s.a[s.i+1][s.j]);\n                        s.i = s.i+1;\n                        que.push(s);\n                        s.i = s.i-1;\n                        swap(s.a[s.i][s.j], s.a[s.i+1][s.j]);\n                }\n                if(s.j!=2) {\n                        swap(s.a[s.i][s.j], s.a[s.i][s.j+1]);\n                        s.j = s.j+1;\n                        que.push(s);\n                        s.j = s.j-1;\n                        swap(s.a[s.i][s.j], s.a[s.i][s.j+1]);\n                }\n        }\n}\nint main(){\n        Status s;\n        s.c=0;\n        for(int i=0;i<9;i++) {\n                cin>>s.a[i/3][i%3];\n                if(s.a[i/3][i%3]==0){\n                        s.i=i/3;\n                        s.j=i%3;\n                }\n        }\n        que.push(s);\n\n        cout<<solve()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* \n * I used # 1687007 as a refference. Thx. \n */\n#include <iostream>\n#include <queue>\n#include <set>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\n//const int PATTERN = 181440;       // NG; 9! / 2;\nconst int PATTERN = 362880;         // OK; 9!\nconst Board GOAL = 0x123456780LL;\nconst int DX[] = { -1, 0, 1,  0 },\n          DY[] = {  0, 1, 0, -1 };\n\nint history[PATTERN];\nqueue<Board> q;\n\n// I made this function based on one by Haruhiko Okumura(Algorithm \n// Dictionary, p116) and one by M.Hiroi(Puzzle DE Programming).\ninline int change_number(long long board) {\n    static int fact_table[N] = {\n         40320, 5040, 720, 120, 24, 6, 2, 1, 0      // on N = 8\n    };\n    int value = 0;\n    for (int j = 0; j < N - 1; ++j) {\n        int J = static_cast<int>((board >> (j*4) & 0xF));\n        value += fact_table[j] * J;\n        for (int k = j + 1; k < N; ++k) {\n            int K = static_cast<int>((board >> k*4) & 0xF);\n            if (J < K) {\n                board &= ~(0xFLL << k*4);\n                board |= (static_cast<long long>(K - 1) << k*4);\n            }\n        }\n    }\n//    printf(\"[change_number] value = %d\\n\", value);\n    return value;\n}\n\ninline Board swap(int numpos, int zeropos, Board board) {\n    long long num = (board >> (numpos * 4)) & 0xF;\n    return (board | (num << zeropos * 4)) & ~(0xFLL << numpos * 4);\n}\n\ninline int check(Board newboad, Board board) {\n    int hash = change_number(newboad);\n    int direction = history[change_number(board)];\n    if (history[hash] == 0) {\n        q.push(newboad);\n        history[hash] = direction + (direction > 0 ? 1 : -1);\n    }\n    else if ((history[hash] > 0 && direction < 0)\n            || (history[hash] < 0 && direction > 0)) {\n        return abs(history[hash]) + abs(direction) - 1;\n    }\n    return 0;\n}\n\nvoid print(Board b) {\n    for (int i = N - 1; i >= 0; --i) {\n        printf(\"%2lld\", (b >> (i*4) & 0xF));\n    }\n    printf(\"\\n\");\n}\n\n// OK\nint main(void) {\n\n    Board board = 0;\n    for (int i = N - 1, num; i >= 0; --i) {\n        scanf(\"%d\", &num);\n        board |= static_cast<long long>(num) << (i * 4);\n    }\n//    print(board);\n//    print(GOAL);\n\n    int count = 0;\n    if (board == GOAL)\n        goto END;\n\n    history[change_number(board)] =  1;     // forward\n    history[change_number(GOAL)]  = -1;     // backward\n\n    q.push(board);\n    q.push(GOAL);\n    while (!q.empty()) {\n        board = q.front();\n        q.pop();\n\n        int zeropos = -1;\n        while (++zeropos < N)\n            if (((board >> (zeropos * 4)) & 0xF) == 0)\n                break;\n\n        int zx = zeropos % 3, zy = zeropos / 3;\n        for (int i = 0; i < 4; ++i) {\n            int nx = zx + DX[i], ny = zy + DY[i];\n            if (nx < 0 || nx > 2 || ny < 0 || ny > 2)\n                continue;\n            int numpos = nx + ny * 3;\n            Board newboard = swap(numpos, zeropos, board);\n            if ((count = check(newboard, board)))\n                goto END;\n        }\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n#define N 3\n#define LIMIT_TIME 180000\ntypedef pair<int, int> P;\n\nstruct State {\n    int g, h;\n    string state;\n    P blank;\n    string path;\n    bool operator<(const State &a) const {\n        return g + h > a.g + a.h;\n    }\n};\n\nint d[5] = {-1, 0, 1, 0, -1};\nstring r[4] = {\"D\", \"R\", \"U\", \"L\"};\nstring ans_str = \"\";\nint ans[N][N], puzzle0[N][N], puzzle1[N][N];\nset<string> s;\npriority_queue<State> next_state;\nstring path;\n\nbool range(int y, int x) {return 0 <= y && y < N && 0 <= x && x < N;}\n\nint h0() {\n    int find = -1;\n    while(next_state.size()) {\n        State state = next_state.top();\n        next_state.pop();\n        if (s.count(state.state)) continue; // already search\n        s.insert(state.state); // visited\n\n        P blank = state.blank;\n        rep(i, 4) {\n            int y = d[i] + blank.first, x = d[i + 1] + blank.second; // next blank position\n            if (range(y, x)) { // can be replaced\n                string tmp = state.state; // next state (string)\n                int p = blank.first * N + blank.second, q = y * N + x;\n                if (N < 4) swap(tmp[p], tmp[q]);\n                else swap(tmp[2 * p], tmp[2 * q]), swap(tmp[2 * p + 1], tmp[2 * q + 1]);\n                if (s.count(tmp)) continue; // already search\n\n                if (tmp == ans_str) { // answer\n                    find = state.g + 1;\n                    path = state.path + r[i];\n                    break;\n                }\n\n                next_state.push(State{state.g + 1, 0, tmp, P(y, x), state.path + r[i]});\n            }\n        }\n        if (find != -1) break; // find an answer\n    }\n    return find;\n}\n\nint main(){\n    rep(i, N)rep(j, N) cin >> puzzle0[i][j];\n\n    string state = \"\";\n    P blank;\n    int manhattan = 0, wrong_place = 0;\n    rep(i, N)rep(j, N) {\n        // cout << puzzle0[i][j] << ((j % N == N - 1) ? \"\\n\" : \"\\t\");\n\n        if (N * N - 1 > 9 && puzzle0[i][j] < 10) state += \"0\";\n        state += to_string(puzzle0[i][j]);\n        if (N * N - 1 > 9 && ans[i][j] < 10) ans_str += \"0\";\n        ans_str += to_string(ans[i][j]);\n\n        if(puzzle0[i][j] == 0) blank = P(i, j);\n        else {\n            int num = puzzle0[i][j] - 1;\n            manhattan += (abs(num / N - i) + abs(num % N - j));\n            if (puzzle0[i][j] != ans[i][j]) wrong_place++;\n        }\n    }\n\n    if (manhattan == 0) { // the answer\n        cout << 0 << endl;\n    } else {\n        s.clear();\n        next_state = priority_queue<State>();\n        next_state.push(State{0, manhattan, state, blank, \"\"});\n        int steps = h0();\n        cout << steps << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\nint main(){\n\t\n\tqueue<string> que;\n\t\n\tmap<string, int> m;\n\t\n\tstring fs = \"\";\n\t\n\tfor(int i = 0; i < 9; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tfs += s;\n\t}\n\t\n\tque.push(fs);\n\t\n\tfor(int loop = 0; loop < 1000; loop++){\n\t\tif(que.empty()){\n\t\t\tbreak;\n\t\t}\n\t\tint sz = que.size();\n\t\tfor(int num = 0; num < sz; num++){\n\t\t\tstring str = que.front();\n\t\t\tque.pop();\n\t\t\tif(m.find(str) != m.end()){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tm[str] = loop;\n\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\tif(str[i] == '0'){\n\t\t\t\t\tif(i >= 3){\n\t\t\t\t\t\tswap(str[i], str[i - 3]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i - 3]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i < 6){\n\t\t\t\t\t\tswap(str[i], str[i + 3]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i + 3]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i % 3 > 0){\n\t\t\t\t\t\tswap(str[i], str[i - 1]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i - 1]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i % 3 < 2){\n\t\t\t\t\t\tswap(str[i], str[i + 1]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << m[\"123456780\"] << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\nvector<int> searched[9];\n\nclass board{\nprivate:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<int> tiles;\n\npublic:\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        REP(i, 9){\n            tiles.push_back(num[i]);\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n    }\n\n    int cost() {\n        return wrongs + moves;\n    }\n\n    void board_to_int(){\n        int k;\n        REP(i, 9)\n            k += (tiles[i] * pow(10, i));\n        REP(i, searched[tiles[0]].size())\n            if(k == searched[tiles[0]][i])\n                return;\n        pq.push(board(tiles, moves+1));\n        searched[tiles[0]].push_back(k);\n        return;\n    }\n\n    void move() {\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\nbool operator< (board b1, board b2){\n    return (b1.cost() > b2.cost()) ? true : false;\n}\n\nint solve(){\n    pq.push(board(original, 0));\n    while(!pq.empty()){\n        auto target = pq.top();\n        pq.pop();\n        if(target.cost() > 100)\n            return -1;\n        if(target.get_wrongs() == 0)\n            return target.cost();\n        target.move();\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = 0;\n    move = solve();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n \n struct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n \n  bool operator < (const Puzzle &p) const {\n    for(int i=0;i<N2;i++) {\n      if(f[i]==p.f[i])continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n \nstatic const char dir[4] = {'u','l','d','r'};\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\n \nbool isTarget(Puzzle p) {\n  for(int i=0;i<N2;i++)\n  if(p.f[i] != (i+1)) return false;\n  return true;\n}\n \nstring bfs(Puzzle s ) {\nqueue<Puzzle> Q;\nmap<Puzzle,bool> V;\nPuzzle u,v;\ns.path = \"\";\nQ.push(s);\nV[s] = true;\n \nwhile(!Q.empty()) {\n  u = Q.front();Q.pop();\n  if(isTarget(u)) return u.path;\n  int sx = u.space / N;\n  int sy = u.space % N;\n  for(int r = 0;r<4 ; r++) {\n    int tx = sx + dx[r];\n    int ty = sy + dy[r];\n    if(tx < 0 || ty < 0|| tx>=N || ty >= N) continue;\n    v = u;\n    swap(v.f[u.space], v.f[tx *N+ty]);\n    v.space = tx * N + ty;\n    if(!V[v]) {\n      V[v] = true;\n      v.path  += dir[r];\n      Q.push(v);\n    }\n  }\n}\nreturn \"unsolvable\";\n}\n \nint main() {\n  Puzzle in;\n \n  for(int i=0;i<N2;i++) {\n    cin >> in.f[i];\n    if(in.f[i]==0) {\n      in.f[i]=N2;\n      in.space = i;\n    }\n  }\n \n  string ans = bfs(in);\n  cout << ans.size()<<endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include<algorithm>\nusing namespace std;\n\nint d_x[4] = { -1,0,1,0 };\nint d_y[4] = { 0,1,0,-1 };\n\nint t[3][3];\nint px, py, level=0;\n\nint countpath() {\n\tint ret=0;\n\tint tmp;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tif (t[i][j] != 0) {\n\t\t\t\ttmp = t[i][j] - 1;\n\t\t\t\tret += abs(tmp / 3 - i) + abs(tmp % 3 - j);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool check(int depth, int pre) {\n\tint w = countpath();\n\tif (w + depth > level) return false;\n\tif (w == 0)return true;\n\tint dx, dy;\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (abs(i - pre) != 2) {\n\t\t\tdx = px + d_x[i];\n\t\t\tdy = py + d_y[i];\n\t\t\tif (dx < 0 || dx == 3 || dy < 0 || dy == 3) continue;\n\t\t\tswap(t[dx][dy], t[px][py]);\n\t\t\tif (check(depth + 1, i)) return true;\n\t\t\tswap(t[dx][dy], t[px][py]);\n\t\t}\n\n\t}\n}\n\nvoid solution() {\n\tfor (level = 0;; level++) {\n\t\tif (check(0, 9)) {\n\t\t\tcout << level << endl;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main() {\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tcin >> t[i][j];\n\t\t\tif (t[i][j] == 0) {\n\t\t\t\tpx = i;\n\t\t\t\tpy = j;\n\t\t\t}\n\t\t}\n\t}\n\tsolution();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint ans[3][3] =\n{\n\t{1, 2, 3},\n\t{4, 5, 6},\n\t{7, 8, 0}\n};\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { -1, 0, 1, 0 };\n\nbool match(int f[3][3]) {\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tif (f[i][j] != ans[i][j])\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint dfs(int f[3][3], int x, int y, int v, int d, int l) {\n\tif (match(f))\n\t\treturn d;\n\tif (d > l)\n\t\treturn -1;\n\tfor (int i = 0, res; i < 4; ++i) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif (nx < 0 || nx > 2 || ny < 0 || ny > 2 || (i + 2) % 4 == v)\n\t\t\tcontinue;\n\t\tf[y][x] = f[ny][nx];\n\t\tf[ny][nx] = 0;\n\t\tif ((res = dfs(f, nx, ny, i, d + 1, l)) > 0)\n\t\t\treturn res;\n\t\tf[ny][nx] = f[y][x];\n\t\tf[y][x] = 0;\n\t}\n\treturn -1;\n}\n\nint main() {\n\tint f[3][3], x, y;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tcin >> f[i][j];\n\t\t\tif (f[i][j] == 0) {\n\t\t\t\ty = i;\n\t\t\t\tx = j;\n\t\t\t}\n\t\t}\n\t}\n\n\tint res;\n\tfor (int i = 1; i < 50; ++i) {\n\t\tif ((res = dfs(f, x, y, -1, 0, i)) >= 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << res << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <array>\n#include <set>\n#include <queue>\nusing namespace std;\n\n#define si static inline\n#define gcu getchar_unlocked\nsi int in() {\n\tint n = 0, c = gcu();\n\t// bool minus = false; if (c == '-') minus = true, c = gcu();\n\tdo {n = 10 * n + (c - '0'), c = gcu();} while (c >= '0');\n\treturn n; }\n\t// return minus ? -n : n; }\nsi void scan(char *s) {while (!isspace(*s++ = gcu()));}\n#define pcu putchar_unlocked\n#define svo si void out\ntemplate <typename T>\nsvo(T n) {\n\tstatic char buf[20];\n\tchar *p = buf;\n\t//if(n < 0) pcu('-'), n *= -1;\n\tif (!n) *p++ = '0';\n\telse while (n) *p++ = n % 10 + '0', n /= 10;\n\twhile (p != buf) pcu(*--p); }\nsvo(const char *s){while(*s)pcu(*s++);}\nsvo(char *s){while(*s)pcu(*s++);}\nsvo(char c){pcu(c);}\n//template <typename T>\n//svo(vector<T> &v){for(T &x:v)out(' '),out(x);out('\\n');}\n//svo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);out('\\n');}\ntemplate <typename head, typename... tail>\nsvo(head&& h, tail&&... t){out(h);out(move(t)...);}\n#undef svo\n#undef si\n\nstruct board {\n\tenum {size = 3};\n\tstruct pos {int r, c;};\n\ttypedef array<array<int, size>, size> arr;\n\tarr b;\n\tpos p;\n\tint max;\n\tint cnt = 0;\n\n\tint f(arr &a) {\n\t\tint l = 0;\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tint c = a[i][j];\n\t\t\t\tif (c == 0)\n\t\t\t\t\tc = size * size - 1;\n\t\t\t\telse\n\t\t\t\t\tc--;\n\t\t\t\tl += abs(i - c / 3) + abs(j - c % 3);\n\t\t\t}\n\t\treturn l;\n\t}\n\n\tvoid read() {\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tb[i][j] = in();\n\t\t\t\tif (!b[i][j])\n\t\t\t\t\tp.r = i, p.c = j;\n\t\t\t}\n\t\tmax = f(b);\n\t}\n\tvoid print() {\n\t\tfor (auto &r: b) {\n\t\t\tfor (int &c: r)\n\t\t\t\tout(&c == &r[0]?\"\":\" \", c);\n\t\t\tout('\\n');\n\t\t}\n\t\tout('\\n');\n\t}\n\n\n\tint solver() {\n\t\tset<arr> m;\n\t\tqueue<board> q;\n\t\tq.push(*this);\n\t\twhile (!q.empty()) {\n\t\t\tboard a = q.front();\n\t\t\tq.pop();\n\t\t\t//a.print();\n\t\t\tint dis = f(a.b);\n\t\t\tif (dis > max * 2.1 - a.cnt)\n\t\t\t\tcontinue;\n\t\t\t//out(dis, \"\\n\");\n\t\t\tauto it = m.find(a.b);\n\t\t\tif (it != m.end())\n\t\t\t\tcontinue;\n\t\t\tm.insert(a.b);\n\t\t\tif (!dis)\n\t\t\t\treturn a.cnt;\n\t\t\tpos to[] = {\n\t\t\t\ta.p.r + 1, a.p.c,\n\t\t\t\ta.p.r, a.p.c + 1,\n\t\t\t\ta.p.r - 1, a.p.c,\n\t\t\t\ta.p.r, a.p.c - 1\n\t\t\t};\n\t\t\tfor (pos o: to) {\n\t\t\t\tif (0 <= o.r && o.r < size && 0 <= o.c && o.c < size) {\n\t\t\t\t\tboard c = a;\n\t\t\t\t\tswap(c.b[a.p.r][a.p.c], c.b[o.r][o.c]);\n\t\t\t\t\tc.p = o;\n\t\t\t\t\tc.cnt = a.cnt + 1;\n\t\t\t\t\tq.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\nint main() {\n\tboard b;\n\tb.read();\n\tout(b.solver(), '\\n');\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1e9\ntypedef long long ll;\n\nstruct P{\n  int x,y;\n  P(int x,int y) : x(x),y(y) {}\n};\n\nll getValue(vector<int> &v){\n  ll res = 0LL;\n  for(auto x : v){\n    res *= 10LL;\n    res += x;\n  }\n  return res;\n}\n\nvector<int> getState(ll x){\n  vector<int> res;\n  while(x > 0LL){\n    res.push_back(x%10LL);\n    x /= 10LL;\n  }\n  if(res.size() == 8){ res.push_back(0); }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\nP getPos(int x){\n  x--;\n  return P(x%3,x/3);\n}\n\nint getMD(ll x){\n  vector<int> v = getState(x);\n  int res = 0;\n  for(int i = 0 ; i < 9 ; i++){\n    if(v[i] == 0){ continue; }\n    P tp = getPos(v[i]);\n    res += abs(i%3-tp.x) + abs(i/3-tp.y);\n  }\n  return res;\n}\n\nint LIMIT;\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nbool inField(int x,int y){\n  return (0 <= x && x < 3 && 0 <= y && y < 3);\n}\n\nbool solve(int sp,ll st,int step,int prev){\n  int md = getMD(st);\n  if(md == 0){ return true; }\n  if(md + step > LIMIT){\n    return false;\n  }\n  int x = sp%3,y = sp/3;\n  for(int i = 0 ; i < 4 ; i++){\n    int nx = x + dx[i],ny = y + dy[i];\n    if(abs(i-prev) == 2){ continue; }\n    if(!inField(nx,ny)){ continue; }\n    vector<int> v = getState(st);\n    int nsp = ny*3 + nx;\n    swap(v[sp],v[nsp]);\n    if(solve(nsp,getValue(v),step+1,i)){\n      return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int sp = -1;\n  vector<int> v(9);\n  for(int i = 0 ; i < 9 ; i++){\n    cin >> v[i];\n    if(v[i] == 0){ sp = i; }\n  }\n  ll st = getValue(v);\n  for(LIMIT = 0 ; LIMIT < 35 ; LIMIT++){\n    if(solve(sp,st,0,INF)){\n      cout << LIMIT << endl;\n      break;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nmap<string,int> mp;\n\nint dr[4]={-1,1,0,0},dc[4]={0,0,-1,1};\n\nvoid bfs()\n{\n    queue<string> q;\n    mp[\"123456780\"]=0;\n    q.push(\"123456780\");\n\n    while(!q.empty())\n    {\n        string s=q.front();q.pop();\n        //cout<<s<<\" \"<<mp[s]<<endl;\n        int idx;\n        for(idx=0;idx<s.length()&&s[idx]!='0';idx++);\n\n        int r=idx/3,c=idx%3;\n        for(int i=0;i<4;i++)\n        {\n            int rr=r+dr[i],cc=c+dc[i];\n\n            if(rr<0||rr>=3||cc<0||cc>=3) continue;\n\n            int idx1=rr*3+cc;\n            string s1=s;\n            swap(s1[idx],s1[idx1]);\n            if(mp.find(s1)==mp.end())\n            {\n                mp[s1]=mp[s]+1;\n                q.push(s1);\n            }\n        }\n    }\n}\n\nchar mat[3][3];\n\nint main()\n{\n    bfs();\n\n    string s;\n\n    for(int i=0;i<3;i++)\n    {\n        for(int j=0;j<3;j++)\n        {\n            char ch;\n            scanf(\"%c%c\",&mat[i][j],&ch);\n            s+=mat[i][j];\n        }\n    }\n\n    printf(\"%d\\n\",mp[s]);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <stack>\n#include <map>\n#include <string>\nusing namespace std;\n\n#define FLG  INT_MIN\n#define GOAL 0\n\n#define N 3\n\nmap<string, int> mp;\nqueue<pair<string, int> > Q;\n\nvector<int> neighbor(int pos)\n{\n    vector<int> rt;\n    if (pos % N != 0)\n        rt.push_back(pos - 1);\n    if (pos % N != N - 1)\n        rt.push_back(pos + 1);\n    if (pos - N > 0)\n        rt.push_back(pos - N);\n    if (pos + N < N * N)\n        rt.push_back(pos + N);\n    return rt;\n}\n\nint bfs()\n{\n    string st, tmp;\n    int cnt, pos;\n    while (!Q.empty()) {\n        st = Q.front().first;\n        cnt = Q.front().second;\n        pos = st.find(\"0\");\n        Q.pop();\n        vector<int> nb(neighbor(pos));\n        for (int i = 0; i < nb.size(); i++) {\n            tmp = st;\n            tmp[pos] = st[nb[i]]; tmp[nb[i]] = st[pos];\n            if (mp.count(tmp)) {\n                if (mp[tmp] == FLG) {\n                    continue;\n                } else if (mp[tmp] == GOAL) {\n                    return cnt + 1;\n                } else\n                    printf(\"ERROR: %d\\n\", __LINE__);\n            }\n            mp[tmp] = FLG;\n            Q.push(make_pair(tmp, cnt + 1));\n        }\n    }\n    return INT_MIN;\n}\n\nint main()\n{\n    string st, gl = \"123456780\";\n    for (int i = 0; i < 9; i++) {\n        int  j;\n        cin >> j;\n        st += to_string(j);\n    }\n    mp[gl] = GOAL;\n    Q.push(make_pair(st, 0));\n    cout << bfs() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <set>\n#include <queue>\n\n\nusing namespace std;\n\nconst int N = 3;\n\nstruct Puzzle {\n    array<array<int, N>, N> board;\n    array<int, 2> empty;\n    int turn;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                if (board[i][j] != p.board[i][j])\n                    return board[i][j] < p.board[i][j];\n            }\n        }\n        return false;\n    }\n};\n\n\nvector<array<int, 2>> dir = {\n    {-1, 0}, // left\n    {0, -1}, // up\n    {1, 0},  // right\n    {0, 1},  // down\n};\n\nbool solved(const Puzzle& p) {\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            int x = i == 2 && j == 2 ? 0 : i * 3 + j + 1;\n            if (p.board[i][j] != x) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    Puzzle start;\n    start.turn = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            int x;\n            cin >> x;\n            if (x == 0) {\n                start.empty = {i, j};\n            }\n            start.board[i][j] = x;\n        }\n    }\n\n    Puzzle ans;\n    set<Puzzle> visited;\n    queue<Puzzle> Q;\n    Q.push(start);\n    while (!Q.empty()) {\n        auto u = Q.front();\n        Q.pop();\n        if (solved(u)) {\n            ans = u;\n            break;\n        }\n        for (auto& d : dir) {\n            auto tx = u.empty[0] + d[0];\n            auto ty = u.empty[1] + d[1];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N) {\n                continue;\n            }\n            auto v = u;\n            swap(v.board[v.empty[0]][v.empty[1]], v.board[tx][ty]);\n            v.empty = {tx, ty};\n            if (visited.find(v) == visited.end()) {\n                ++v.turn;\n                visited.insert(v);\n                Q.push(v);\n            }\n        }\n    }\n    cout << ans.turn << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct P{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator<(const P&p) const{\n    int i;\n    for(i=0;i<N2;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1, 0, 1, 0};\nstatic const int dy[4]={0, -1, 0, 1};\nstatic const char dir[4]={'u', 'l', 'd', 'r'};\n\nbool isT(P p){\n  int i;\n  for(i=0;i<N2;i++)\n    if(p.f[i]!=(i+1))return false;\n    return true;\n}\n\nstring bfs(P s){\n  queue<P> Q;\n  map<P, bool> V;\n  P u, v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n  int sx, sy, tx, ty, r;\n\n  while(!Q.empty()){\n    u=Q.front();\n    Q.pop();\n    if(isT(u)) return u.path;\n    sx=u.space/N;\n    sy=u.space%N;\n    for(r=0;r<4;r++){\n      tx=sx+dx[r];\n      ty=sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n      v=u;\n      swap(v.f[u.space], v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n        V[v]=true;\n        v.path+=dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return\"unsolvable\";\n}\n\nint main(){\n  P in;\n  int i;\n\n  for(i=0;i<N2;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout<<ans.size()<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator <(const Puzzle p) const {\n\t\tfor (int i = 0; i < N2; ++i) {\n\t\t\tif (f[i] == p.f[i])\n\t\t\t\tcontinue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nbool isComplete(Puzzle p) {\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif (p.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nconst int dx[4] { -1, 0, 1, 0 };\nconst int dy[4] { 0, -1, 0, 1 };\nconst char dir[4] { 'u', 'l', 'd', 'r' };\n\nstring bfs(Puzzle p) {\n\tqueue<Puzzle> Q;\n\tp.path = \"\";\n\tQ.push(p);\n\tPuzzle u, v;\n\tmap<Puzzle, bool> M;\n\tM[p] = true;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isComplete(u))\n\t\t\treturn u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!M[v]) {\n\t\t\t\tM[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"unresolved\";\n}\n\nint main() {\n\tPuzzle p;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tscanf(\"%d\", &p.f[i]);\n\t\tif (p.f[i] == 0) {\n\t\t\tp.f[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(p);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define NUM 3\n#define PRUNING 35\n\ntypedef struct STATUS{\n    int num;\n    int board[NUM][NUM];\n}STATUS;\n\ntypedef pair<int, int> cell;\n\nbool checkfinish(STATUS in){\n    \n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            if (i == NUM - 1 && j == NUM - 1) return true;\n            if(in.board[i][j] != val++) return false;\n        }\n    }\n    return true;\n}\n\n\nint backtrack(STATUS in, cell last_zero){\n\n    int x = 0, y = 0, ret = PRUNING;\n    cell zero;\n    STATUS out;\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    \n    if (in.num > ret) {\n        return ret;\n    }\n    \n    if (checkfinish(in)) {\n        return in.num;\n    }\n\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            if(in.board[i][j] == 0){\n                x = zero.first = j;\n                y = zero.second = i;\n            }\n        }\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (x + dx[i] >=0 && x+dx[i] < NUM && y+dy[i] >=0 && y+dy[i] < NUM) {\n            if (last_zero.first == x+dx[i] && last_zero.second == y+dy[i]){ continue;\n            }\n            memcpy(&out, &in, sizeof(STATUS));\n            swap(out.board[y][x], out.board[y+dy[i]][x+dx[i]]);\n            out.num++;\n            ret = min(ret, backtrack(out, zero));\n        }\n    }\n    return ret;\n}\n\n\nint main(){\n    \n    int val, ans;\n    \n    STATUS init;\n    init.num = 0;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            cin >> val;\n            init.board[i][j] = val;\n        }\n    }\n    \n    //?????????????????????????????????zero????????¨?????????????????????????????\\????????????\n    ans = backtrack(init, cell(-1,-1));\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n// ????????¨?????????24????????±??????????????????\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 23;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nint getAllMD(Puzzle p)\n{\n    int dist = 0;\n    int x, y;\n    int ux, uy;\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] == N2) continue; // ??????0??????\n        x = (p.f[i] - 1) / N;\n        y = (p.f[i] - 1) % N;\n        ux = i / N;\n        uy = i % N;\n        dist += abs(x - ux) + abs(y - uy);\n    }\n    return dist;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i + getAllMD(in)) {\n        return;\n    }\n    \n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n        /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n//    cout << \"MD: \" << getAllMD(in) << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <stack>\n#include <map>\n#include <string>\nusing namespace std;\n\n#define FLG  INT_MIN\n#define GOAL 0\n\n#define N 3\n\nmap<string, int> mp;\nqueue<pair<string, int> > Q;\n\nvector<int> neighbor(int pos)\n{\n    vector<int> rt;\n    if (pos % N != 0)\n        rt.push_back(pos - 1);\n    if (pos % N != N - 1)\n        rt.push_back(pos + 1);\n    if (pos - N >= 0)\n        rt.push_back(pos - N);\n    if (pos + N < N * N)\n        rt.push_back(pos + N);\n    return rt;\n}\n\nint bfs()\n{\n    string st, tmp;\n    int cnt, pos;\n    while (!Q.empty()) {\n        st = Q.front().first;\n        cnt = Q.front().second;\n//        cout << st << \" \" << cnt << endl;\n        pos = st.find(\"0\");\n        Q.pop();\n        vector<int> nb(neighbor(pos));\n        for (int i = 0; i < nb.size(); i++) {\n            tmp = st;\n            tmp[pos] = st[nb[i]]; tmp[nb[i]] = st[pos];\n            if (mp.count(tmp)) {\n                if (mp[tmp] == FLG) {\n                    continue;\n                } else if (mp[tmp] == GOAL) {\n                    return cnt + 1;\n                } else\n                    printf(\"ERROR: %d\\n\", __LINE__);\n            }\n            mp[tmp] = FLG;\n            Q.push(make_pair(tmp, cnt + 1));\n        }\n    }\n    return INT_MIN;\n}\n\nint main()\n{\n    string st, gl = \"123456780\";\n    for (int i = 0; i < 9; i++) {\n        int  j;\n        cin >> j;\n        st += to_string(j);\n    }\n    mp[st] = FLG; mp[gl] = GOAL;\n    Q.push(make_pair(st, 0));\n    cout << bfs() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    for (int i = 0; i < N2; i++) {\n      if (f[i] == p.f[i] ) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for (int i = 0; i < N2; i++)\n  if(p.f[i] != (i + 1)) return false;\n\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while (!Q.empty()){\n    u = Q.front(); Q.pop();\n    if (isTarget(u))return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for (int r = 0; r < 4; r++) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if ( !V[v] ){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\nint main() {\n  Puzzle in;\n\n  for (int i = 0; i < N2; i++) {\n    cin >> in.f[i];\n    if (in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-12)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nstring s = \"\";\nstring ans = \"123456780\";\nint d[4] = {-1,1,-3,3};\n\nbool rec(string v,int c_index,int p_index,int step,int limit){\n  if(limit<step)return false;\n  if(v==ans)return true;\n  FOR(i,0,4){\n    if(c_index%3==0 && d[i]==-1)continue;\n    if((c_index+1)%3==0 && d[i]==1)continue;\n    if(c_index<=2 && d[i]==-3)continue;\n    if(6<=c_index && d[i]==3)continue;\n    int n_index = c_index+d[i];\n    if(n_index==p_index)continue;\n    string u = v;\n    swap(u[c_index],u[n_index]);\n    if(rec(u,n_index,c_index,step+1,limit))return true;\n  }\n  return false;  \n}\n\nint solve(){\n  int res = 0;\n  int ind = 0;\n  FOR(i,0,9)if(s[i]=='0')ind=i;\n  while(!rec(s,ind,-1,0,res))res++;\n  return res;\n}\n\nint main()\n{\n  FOR(i,0,9){\n    string a;\n    cin>>a;\n    s+=a;\n  }\n  cout<<solve()<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tbool operator <( const Puzzle p ) const\n\t{\n\t\tfor( int i = 0; i < N2; i++ ) {\n\t\t\tif( f[i] == p.f[i] ) continue;\n\t\t\treturn f[i] < p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nbool isTarget( Puzzle &u )\n{\n\tfor( int i = 0; i < N2; i++ ) {\n\t\tif( u.f[i] != i + 1 ) return false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tPuzzle s;\n\tfor( int i = 0; i < N2; i++ ) {\n\t\tcin >> s.f[i];\n\t\tif( s.f[i] == 0 ) {\n\t\t\ts.space = i;\n\t\t\ts.f[i] = N2;\n\t\t}\n\t}\n\n\tint dirh[] = { 0, 0, -1, 1 };\n\tint dirv[] = { -1, 1, 0, 0 };\n\tqueue<pair<Puzzle, int>> que;\n\tmap<Puzzle, int> m;\n\tint ans;\n\tque.push( make_pair( s, 0 ) );\n\tm[s] = 1;\n\twhile( !que.empty() ) {\n\t\tPuzzle u;\n\t\tint cnt;\n\t\ttie( u, cnt ) = que.front();\n\t\tque.pop();\n\t\tif( isTarget( u ) ) {\n\t\t\tans = cnt;\n\t\t\tbreak;\n\t\t}\n\t\tint sy = u.space / N;\n\t\tint sx = u.space % N;\n\t\tfor( int i = 0; i < 4; i++ ) {\n\t\t\tint nx = sx + dirh[i];\n\t\t\tint ny = sy + dirv[i];\n\t\t\tif( nx < 0 || N <= nx || ny < 0 || N <= ny ) continue;\n\t\t\tint ni = ny * N + nx;\n\t\t\tPuzzle v;\n\t\t\tv = u;\n\t\t\tswap( v.f[ni], v.f[v.space] );\n\t\t\tv.space = ni;\n\t\t\tif( m.find( v ) == m.end() ) {\n\t\t\t\tque.push( make_pair( v, cnt + 1 ) );\n\t\t\t\tm[v] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n \nstruct Puzzle{\n  int i,f[N2];\n  int space;\n  string path;\n \n  bool operator < (const Puzzle &p) const{\n\n    for(i = 0;i < N2;i ++)\n      {\n\tif(f[i] == p.f[i]) continue;\n\treturn f[i] > p.f[i];\n      }\n    return false;\n  }\n};\n \nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n \n \nint main(){\n\n  Puzzle in;\n\n  int i;\n\n  string ans;\n  \n  for(i = 0;i < N2;i ++)\n    {\n      cin >> in.f[i];\n      if(in.f[i] == 0)\n\t{\n\t  in.f[i] = N2;\n\t  in.space = i;\n\t}\n    }\n  ans = bfs(in);\n\n  cout << ans.size() << endl;\n \n  return 0;\n}\n\nbool isTarget(Puzzle p){\n\n  int i;\n  \n  for(i = 0;i < N2;i ++)\n    {\n      if(p.f[i] != (i + 1)) return false;\n    }\n  \n  return true;\n}\n \nstring bfs(Puzzle s){\n\n  int sx,sy,tx,ty,r;\n  \n  queue<Puzzle> Q;\n\n  map<Puzzle, bool> V;\n\n  Puzzle u, v;\n\n  s.path = \"\";\n\n  Q.push(s);\n\n  V[s] = true;\n \n  while(!Q.empty()){\n\n    u = Q.front();\n\n    Q.pop();\n\n    if(isTarget(u))return u.path;\n\n    sx = u.space / N;\n    sy = u.space % N;\n\n    for(r = 0;r < 4;r ++)\n      {\n\ttx = sx + dx[r];\n\tty = sy + dy[r];\n\n\tif(tx < 0 || ty < 0 || tx >= N || ty >= N)continue;\n       \n\tv = u;\n      \n\tswap(v.f[u.space], v.f[tx * N + ty]);\n      \n\tv.space = tx * N + ty;\n      \n\tif(!V[v]){\n\t  V[v] = true;\n\t  v.path += dir[r];\n\t  Q.push(v);\n\t}\n      }\n  }\n \n  return \"unsolvable\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\nstruct Puzzle {\nint f[N2];\n\nint space;\nstring path;\nbool operator < (const Puzzle &p) const{\nfor (int i=0; i<N2; i++ ){\nif(f[i] == p.f[i]) continue;\nreturn f[i] > p.f[i];\n}\nreturn false;\n}\n};\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nbool isTarget (Puzzle p) {\nfor (int i = 0; i< N2; i++ )\nif(p.f[i] != (i + 1)) return false;\nreturn true;\n}\nstring bfs (Puzzle s) {\nqueue<Puzzle> Q;\nmap<Puzzle, bool> V;\nPuzzle u, v;\ns.path = \"\";\nQ.push(s);\nV[s] = true;\n\nwhile (!Q.empty()){\nu = Q. front(); Q.pop();\nif (isTarget(u)) return u.path;\nint sx = u.space / N;\nint sy = u.space % N;\nfor (int r= 0; r< 4;r++ ){\nint tx = sx + dx[r];\nint ty = sy + dy[r];\nif (tx<0 || ty <0 || tx >= N || ty >= N) continue;\n\nv=u;\nswap(v.f[u.space], v.f[tx * N + ty]);\nv.space = tx * N + ty;\nif (!V[v]){\nV[v] = true;\nv.path += dir[r];\nQ.push(v);\n\n\n}\n}\n}\n\n\nreturn \"unsolvable\";\n}\nint main(){\nPuzzle in;\nfor (int i = 0; i < N2; i++ ){\ncin >> in.f[i];\nif (in.f[i] == 0){\nin.f[i] = N2; // set space\nin.space = i;\n}\n}\nstring ans = bfs(in);\ncout << ans.size() << endl;\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;\n#define MAXN 363000  //9!==326880\nstruct node\n{\n    int s[9];\n    int a;\n    int b;\n    int step;\n};\nint fac[10]= {1,1,2,6,24,120,720,5040,40320,362880};//分别存储1--9的阶乘值\nint dir[4][2]= {-1,0,1,0,0,-1,0,1};\nint aim=322561;//123456780对应的hash值\nbool vis[MAXN];\nnode str,now,next;\n\nint cantor(const int *s)\n{\n    int sum=0;\n    for(int i=0; i<9; i++)\n    {\n        int num=0;\n        for(int j=0; j<i; j++)\n            if(s[j]>s[i])\n                num++;\n        sum+=(num*fac[i]);\n    }\n    return (sum+1);\n}\nbool bfs()\n{\n    memset(vis,0,sizeof(vis));\n    queue<node>q;\n    q.push(str);\n    vis[str.b]=1;\n    while(!q.empty())\n    {\n        now=q.front();\n        q.pop();\n        int x=now.a/3;\n        int y=now.a%3;\n        for(int i=0; i<4; i++)\n        {\n            int tx=x+dir[i][0],ty=y+dir[i][1];\n            if(tx<0||tx>=3||ty<0||ty>=3)\n                continue;\n            next=now;\n            next.a=tx*3+ty;\n            next.s[now.a]=next.s[next.a];\n            next.s[next.a]=0;\n            next.b=cantor(next.s);\n            if(!vis[next.b])\n            {\n                vis[next.b]=1;\n                if(next.b==aim)\n                {\n                    return true;\n                }\n                next.step=now.step+1;\n                q.push(next);\n            }\n        }\n    }\n    return 0;\n}\nchar sss[3];\nint main()\n{\n    char q[10];\n    for(int i=0; i<9; i++)\n    {\n        scanf(\"%s\",sss);\n        q[i]=sss[0];\n    }\n    int len=strlen(q);\n    int num=0;\n    for(int i=0; i<len; i++)\n    {\n        if(q[i]>='1'&&q[i]<='9')\n        {\n            str.s[num++]=q[i]-'0';\n        }\n        else if(q[i]=='0')\n        {\n            str.s[num]=0;\n            str.a=num++;\n        }\n    }\n    str.b=cantor(str.s);\n    if(str.b==aim)\n        printf(\"%d\\n\",0);\n    else if(bfs())\n        printf(\"%d\\n\",next.step+1);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n//#include <fstream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N=3; // N x N board\n\nstruct Node{\n    unsigned long long int id;  // hash key\n    int mat[N][N];              // to save the N x N board\n    int x0, y0;                 // location of the blank square\n    int cost;                   // minimum number of movements to reach the destination Node\n    int level;                  // no. of movements so far to reach this Node\n    Node(){}                    // construction function #1\n    Node(int matrix_[N][N], int x0_, int y0_, int cost_, int level_);    // construction function #2\n};\n\nint calCostUtil(int mat[N][N], int i, int j) {\n    int cost  = 0;\n    if (mat[i][j] != 0) {\n        int x1 = (int) (mat[i][j]-1) / N;\n        int y1 = (int) (mat[i][j]-1) - N*x1;\n        cost = abs(i-x1) + abs(j-y1);\n    }\n    return cost;\n}\n\nint calCost(int mat[N][N]) {\n    int cost = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j=0; j<N; j++) {\n            if (mat[i][j] != 0) {\n                cost += calCostUtil(mat, i, j);\n            }\n        }\n    }\n    return cost;\n}\n\n//Node getInput(string fn) {\n//    ifstream infile(fn);\n//    int tmp, x0, y0;\n//    int mat[N][N];\n//    for (int i = 0; i < N; i++) {\n//        for (int j = 0; j < N; j++) {\n//            infile >> tmp;\n//            mat[i][j] = tmp;\n//            if (tmp==0) {x0=i; y0=j;}\n//        }\n//    }\n//    Node root(mat, x0, y0, calCost(mat), 0);\n//    infile.close();\n//    return root;\n//}\n\nNode getInput() {\n    int tmp, x0, y0;\n    int mat[N][N];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> tmp;\n            mat[i][j] = tmp;\n            if (tmp==0) {x0=i; y0=j;}\n        }\n    }\n    Node root(mat, x0, y0, calCost(mat), 0);\n    return root;\n}\n\nvoid printNode(Node nd) {\n    for (int i=0; i<N; i++) {\n        for (int j = 0; j < N; j++) {\n            cout << nd.mat[i][j] <<\"  \";\n        }\n        cout << \"\\n\";\n    }\n    cout << \"(\" << nd.x0 << \", \" << nd.y0 << \")\\n\";\n    cout << \"cost: \" << nd.cost << \"\\n\";\n    cout << \"level: \" << nd.level << \"\\n\";\n}\n\nunsigned long long int genHashKey(int mat[N][N]) {\n    unsigned long long int tmp = 0;\n    for (int i=0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            tmp += mat[i][j]*pow(10, i*N+j);\n        }\n    }\n    return tmp;\n}\n\nbool isMoveValid(int x0, int y0, int mrow, int mcol) {\n    if ((x0+mrow>=0) && (x0+mrow<N) && (y0+mcol>=0) && (y0+mcol<N)) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\n//              up      down    left    right\nint mrow[] = {  1,      -1,     0,      0       };\nint mcol[] = {  0,      0,      -1,     1       };\n\n// flag\nbool isSolved = false;\nset<unsigned long long int> mylist;     // save all hash keys of nodes visited\n\nbool solveUtil(Node* node, int limit) {\n    if (!isSolved) {\n        // if destination node is reached: print current node's level\n        if (node->cost==0) {\n            cout << node->level << \"\\n\";  // minimum no. of steps to reach the goal\n            isSolved = true;\n            return true;\n        }\n\n        // else: visit children nodes (depth-first search)\n        for (int imove = 0; imove < 4; imove++) {\n            if(isMoveValid(node->x0, node->y0, mrow[imove], mcol[imove])) {\n                int x0_new = node->x0 + mrow[imove];\n                int y0_new = node->y0 + mcol[imove];\n                int mat[N][N];\n                memcpy(mat, node->mat, sizeof(mat));\n                swap(mat[node->x0][node->y0], mat[x0_new][y0_new]);\n                int cost = calCost(mat);\n                // check whether depth limit is reached\n                if (node->level + cost <= limit) {\n                    //check whether the node is visited before\n                    unsigned long long int id = genHashKey(mat);\n                    if (mylist.find(id)==mylist.end()) {\n                        Node newNode(mat, x0_new, y0_new, cost, node->level+1);\n                        mylist.insert(id);\n                        solveUtil(&newNode, limit);\n                        // if cannot reach the goal -> erase the node from list for backtracking\n                        mylist.erase(id);\n                    }\n                }\n            }\n        }\n\n        // after visiting all children nodes but the goal has not reached\n        return false;\n    }\n}\n\nvoid solve(Node* root, int depth_limit) {\n    // iterative deepening DFS\n    for (int i = root->cost; i < depth_limit; i++) {\n        mylist.clear();\n        mylist.insert(genHashKey(root->mat));\n        if (solveUtil(root, i)) {return;};\n    }\n}\n\nint main() {\n    //Node root = getInput(\"in.txt\");  // root node\n    Node root = getInput();  // root node\n    solve(&root, 45);\n    return 0;\n}\n\nNode::Node(int matrix_[N][N], int x0_, int y0_, int cost_, int level_) {\n    memcpy(mat, matrix_, sizeof(mat));\n    x0 = x0_;  y0 = y0_;\n    cost = cost_;\n    level = level_;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\nusing namespace std;\n#define MAXN 363000  //9!==326880\nstruct node\n{\n    int s[9];\n    int a;\n    int b;\n    int step;\n};\nint fac[10]= {1,1,2,6,24,120,720,5040,40320,362880};//分别存储1--9的阶乘值\nint dir[4][2]= {-1,0,1,0,0,-1,0,1};\nint aim=322561;//123456780对应的hash值\nbool vis[MAXN];\nnode str,now,next;\nint cantor(const int *s)\n{\n    int sum=0;\n    for(int i=0; i<9; i++)\n    {\n        int num=0;\n        for(int j=0; j<i; j++)\n            if(s[j]>s[i])\n                num++;\n        sum+=(num*fac[i]);\n    }\n    return (sum+1);\n}\nbool bfs()\n{\n    memset(vis,0,sizeof(vis));\n    queue<node>q;\n    q.push(str);\n    vis[str.b]=1;\n    while(!q.empty())\n    {\n        now=q.front();\n        q.pop();\n        int x=now.a/3;\n        int y=now.a%3;\n        for(int i=0; i<4; i++)\n        {\n            int tx=x+dir[i][0],ty=y+dir[i][1];\n            if(tx<0||tx>=3||ty<0||ty>=3)\n                continue;\n            next=now;\n            next.a=tx*3+ty;\n            next.s[now.a]=next.s[next.a];\n            next.s[next.a]=0;\n            next.b=cantor(next.s);\n            if(!vis[next.b])\n            {\n                vis[next.b]=1;\n                if(next.b==aim)\n                {\n                    return true;\n                }\n                next.step=now.step+1;\n                q.push(next);\n            }\n        }\n    }\n    return 0;\n}\nchar sss[3];\nint main()\n{\n    char q[10];\n    for(int i=0; i<9; i++)\n    {\n        scanf(\"%s\",sss);\n        q[i]=sss[0];\n    }\n    int len=strlen(q);\n    int num=0;\n    for(int i=0; i<len; i++)\n    {\n        if(q[i]>='1'&&q[i]<='9')\n        {\n            str.s[num++]=q[i]-'0';\n        }\n        else if(q[i]=='0')\n        {\n            str.s[num]=0;\n            str.a=num++;\n        }\n    }\n    str.b=cantor(str.s);\n    if(str.b==aim)\n        printf(\"%d\\n\",0);\n    else if(bfs())\n        printf(\"%d\\n\",next.step+1);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing namespace std;\nstruct state {\n    state(vector<int> vec, int z, int c, int n) : board {vec}, zero {z}, correct {c}, num {n} {};\n    vector<int> board;\n    int zero;\n    int correct;\n    int num;\n    void print(){\n        cout << \"board\" << endl;\n        for(int i = 0; i < 9; ++i){\n            cout << board[i] << ' ';\n            if(i%3 == 2){\n                cout << endl;\n            }\n        }\n        cout << \"correct = \" << correct << \", zero = \" << zero << \", n = \" << num << endl;\n    }\n};\n\nmultiset<vector<int>> memo {};\n\nbool correct_pos(vector<int>& vec, int id){\n    return (id+1)%9 == vec[id];\n}\n\nvoid push_queue(queue<state>& states, state now, int pos){\n    if(pos >= 0 && pos < 9){\n        int nc = now.correct;\n        if(correct_pos(now.board, pos)){\n            --nc;\n        }\n        if(correct_pos(now.board, now.zero)){\n            --nc;\n        }\n        swap(now.board[pos], now.board[now.zero]);\n        if(correct_pos(now.board, pos)){\n            ++nc;\n        }\n        if(correct_pos(now.board, now.zero)){\n            ++nc;\n        }\n        bool pushed = memo.find(now.board) != memo.end();\n        if(pushed){\n        //    cout << \"already searched, pos = \" << pos << endl;\n            return;\n        } else {\n            memo.insert(now.board);\n        }\n        state next_st = state(vector<int>(now.board), pos, nc, now.num+1);\n        //cout << \"pushing\" << endl;\n        //next_st.print();\n        states.push(next_st);\n        swap(now.board[pos], now.board[now.zero]);\n    }\n}\n\nint bfs(queue<state>& states){\n    int ret = 0;\n    while(states.size()){\n        state s = states.front();\n        states.pop();\n        if(s.correct == 9){\n            ret = s.num;\n            break;\n        }\n        int up = s.zero - 3;\n        int down = s.zero + 3;\n        int left = s.zero%3 ? s.zero - 1 : -1;\n        int right = s.zero%3 != 2 ? s.zero + 1 : -1;\n        //cout << up << \" \" << down << \" \" << left << \" \" << right << endl;\n        push_queue(states, s, up);\n        push_queue(states, s, down);\n        push_queue(states, s, left);\n        push_queue(states, s, right);\n    }\n    return ret;\n}\n\nint find_minimum(vector<int>& vec){\n    int zero = 0;\n    int correct = 0;\n    for(auto it = vec.begin(); it != vec.end(); ++it){\n        int i = it - vec.begin();\n        if(*it == 0){\n            zero = i;\n        }\n        if(correct_pos(vec, i)){\n            ++correct;\n        }\n    }\n    auto st = queue<state>();\n    st.push(state(vec, zero, correct, 0));\n    return bfs(st);\n}\n\nint main(){\n    vector<int> board {};\n    for(int i = 0; i < 9; ++i){\n        int v;\n        cin >> v;\n        board.push_back(v);\n    }\n    cout << find_minimum(board) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\ntypedef long long lli;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<vector<lli> > mat;\ntypedef vector<vector<bool> > matb;\ntypedef vector<string> vst;\ntypedef pair<lli,lli> pll;\ntypedef pair<double,double> pdd;\n\nvll x(9);\nlli y;\n\nset<vll> vis;\nqueue<vll> q;\nqueue<lli> d;\n\nvll ans{1,2,3,4,5,6,7,8,0};\n\nint main(){\n    for(lli i = 0;i < 9;i++) cin >> x[i];\n    q.push(x);\n    d.push(0);\n    while(!q.empty()){\n        x = q.front();\n        y = d.front();\n        q.pop();\n        d.pop();\n        if(vis.count(x)) continue;\n        vis.insert(x);\n        if(x == ans){\n            cout << y << endl;\n            return 0;\n        }\n        for(lli i = 0;i < 9;i++){\n            if(x[i] == 0){\n                if(i+3 < 9){\n                    swap(x[i],x[i+3]);\n                    q.push(x);\n                    d.push(y+1);\n                    swap(x[i],x[i+3]);\n                }\n                if(i-3 >= 0){\n                    swap(x[i],x[i-3]);\n                    q.push(x);\n                    d.push(y+1);\n                    swap(x[i],x[i-3]);\n                }\n                if(i%3 != 0){\n                    swap(x[i],x[i-1]);\n                    q.push(x);\n                    d.push(y+1);\n                    swap(x[i],x[i-1]);\n                }\n                if(i%3 != 2){\n                    swap(x[i],x[i+1]);\n                    q.push(x);\n                    d.push(y+1);\n                    swap(x[i],x[i+1]);\n                }\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int dx[4] = { 0,-1, 0, 1};\nconst int dy[4] = {-1, 0, 1, 0};\nconst char dir[4] = {'u', 'l', 'd', 'r'};\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] < p.f[i];\n        }\n        return false;\n    }\n};\n\nbool isTarget(Puzzle p) {\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != (i+1)) return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle s) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while (!Q.empty()) {\n        u = Q.front(); Q.pop();\n        if (isTarget(u)) return u.path;\n\n        int sx = u.space % N;\n        int sy = u.space / N;\n        for (int r = 0; r < 4; r++) {\n            int nx = sx + dx[r];\n            int ny = sy + dy[r];\n            if (nx < 0 || ny < 0 || nx >= N || ny >= N) continue;\n\n            v = u;\n            swap(v.f[u.space], v.f[ny*N + nx]);\n            v.space = ny*N + nx;\n            if (!V[v]) {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n\n    return \"unsolvable\";\n}\n\nint main(void) {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    Puzzle in;\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n#define N 3\ntypedef pair<int, int> P;\n\nstruct State {\n    int g, h;\n    string state;\n    P blank;\n    string path;\n    bool operator<(const State &a) const {\n        return g + h > a.g + a.h;\n    }\n};\n\nint d[5] = {-1, 0, 1, 0, -1};\nstring r[4] = {\"D\", \"R\", \"U\", \"L\"};\nstring ans_str = \"\";\nint ans[N][N], puzzle0[N][N], puzzle1[N][N];\nset<string> s;\npriority_queue<State> next_state;\nstring path;\n\nbool range(int y, int x) {return 0 <= y && y < N && 0 <= x && x < N;}\n\nint h1_dfs(int boundary, State state, int from) {\n    int find = -1;\n    s.insert(state.state); // visited\n\n    P blank = state.blank;\n    rep(i, 4) {\n        if (from == (i + 2) % 4) continue;\n        int y = d[i] + blank.first, x = d[i + 1] + blank.second; // next blank position\n        if (range(y, x)) { // can be replaced\n            string tmp = state.state; // next state (string)\n            int wrong_place = state.h, p = blank.first * N + blank.second, q = y * N + x;\n            if (N < 4) {\n                swap(tmp[p], tmp[q]);\n                wrong_place = wrong_place - (state.state[q] != ans_str[q]) + (state.state[q] != ans_str[p]);\n            } else {\n                swap(tmp[2 * p], tmp[2 * q]), swap(tmp[2 * p + 1], tmp[2 * q + 1]);\n                wrong_place = wrong_place - (state.state.substr(2 * q, 2) != ans_str.substr(2 * q, 2))\n                + (state.state.substr(2 * q, 2) != ans_str.substr(2 * p, 2));\n            }\n\n            if (wrong_place == 0) { // answer\n                find = state.g + 1;\n                path = state.path + r[i];\n                break;\n            }\n\n            if (state.g + 1 + wrong_place > boundary) continue; // estimate value is over boundary\n            find = h1_dfs(boundary, State{state.g + 1, wrong_place, tmp, P(y, x), state.path + r[i]}, i);\n            if (find != -1) break; // find an answer\n        }\n    }\n\n    return find;\n}\n\nint ids_h1(string state, int wrong_place, P blank) {\n    int i = wrong_place, find = -1;\n    while(find == -1 && i < 81) {\n        s.clear();\n        find = h1_dfs(i, State{0, wrong_place, state, blank, \"\"}, -1);\n        i++;\n    }\n    return find;\n}\n\nint main(){\n    // create answer's numbers\n    iota(ans[0], ans[0] + N * N, 1);\n    ans[N - 1][N - 1] = 0;\n    // create number\n    iota(puzzle0[0], puzzle0[0] + N * N, 0);\n    rep(i, N)rep(j, N) cin >> puzzle0[i][j];\n\n    string state = \"\";\n    P blank;\n    int manhattan = 0, wrong_place = 0;\n    rep(i, N)rep(j, N) {\n        state += to_string(puzzle0[i][j]);\n        ans_str += to_string(ans[i][j]);\n\n        if(puzzle0[i][j] == 0) blank = P(i, j);\n        else {\n            int num = puzzle0[i][j] - 1;\n            manhattan += (abs(num / N - i) + abs(num % N - j));\n            if (puzzle0[i][j] != ans[i][j]) wrong_place++;\n        }\n    }\n\n    if (manhattan == 0) { // the answer\n        cout << 0 << endl;\n    } else {\n        int steps;\n        next_state.push(State{0, wrong_place, state, blank, \"\"});\n        steps = ids_h1(state, wrong_place, blank);\n        cout << steps << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\n\nconstexpr int N = 3, N_2D = 9;\n\nstruct Puzzle {\n    int location[N_2D];\n    int space;\n    string path;\n\n    bool operator<(const Puzzle& puzzle) const {\n        for(int i = 0; i < N_2D; ++i){\n            if(location[i] == puzzle.location[i]){\n                continue;\n            }\n            return location[i] > puzzle.location[i];\n        }\n        return false;\n    }\n};\n\n/**\n *  位置があっているかどうか判定する\n */\nbool isTarget(const Puzzle& puzzle){\n    for(int i = 0; i < N_2D; ++i){\n        if(puzzle.location[i] != i+1){\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n *  幅優先探索\n */\nstring bfs(const Puzzle& origin){\n    queue<Puzzle> que;\n    map<Puzzle, bool> mp;    // 配置を記録していく\n    que.push(origin);\n    mp[origin] = true;\n\n    constexpr int dx[] = {-1, 0, 1, 0};\n    constexpr int dy[] = {0, -1, 0, 1};\n    constexpr char direction[] = {'u', 'l', 'd', 'r'};\n                                 // up, left, down, right\n    while(!que.empty()){\n        Puzzle parent = que.front();\n        que.pop();\n        if(isTarget(parent)){    // もしパズルuがターゲットと合致していれば終わり\n            return parent.path;\n        }\n        int sx = parent.space / N;   // space x\n        int sy = parent.space % N;   // space y\n\n        for(int i = 0; i < 4; ++i){\n            int tx = sx + dx[i];    // transfer x\n            int ty = sy + dy[i];    // transfer y\n            if(tx < 0 || ty < 0 || tx >= N || ty >= N){\n                continue;    // 移動先がパズルの枠を超えてしまわないようにする\n            }\n\n            Puzzle child = parent;\n            swap(child.location[parent.space], child.location[tx * N + ty]);\n            child.space = tx * N + ty;    // spaceの位置も移動\n\n            if(!mp[child]){    // 既に同じ配置のパズルを動かし済みの場合はスルーする\n                mp[child] = true;\n                child.path += direction[i];\n                que.push(child);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\n\nint main(){\n\n    Puzzle puzzle;\n\n    for(int i = 0; i < N_2D; ++i){\n        cin >> puzzle.location[i];\n        if(puzzle.location[i] == 0){\n            // spaceの場所をセットする\n            puzzle.location[i] = N_2D;\n            puzzle.space = i;\n        }\n    }\n    puzzle.path = \"\";\n\n    string ans = bfs(puzzle);\n    if(ans != \"unsolvable\"){\n    \tcout << ans.size() << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define MAXN 10+2\nint map[MAXN][MAXN];\nint min0=1000000000;\nint t;\nint map1[3][3]={1,2,3,4,5,6,7,8,0};\nbool hx[40000009];\nbool pd(){\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tif(map[i][j]!=map1[i][j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\nvoid syf(int x,int y,int tot){\n\tif(pd()){\n\t\tif(tot<min0) min0=tot;\n\t\treturn;\n    }\n    else if(tot>26) return;\n\telse{\n\t\tint g=1;\n\t\tif(x+1<3){\n\t\t\tt=map[x][y];\n\t\t\tmap[x][y]=map[x+1][y];\n\t\t\tmap[x+1][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=40000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x+1,y,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x+1][y];\n\t\t\tmap[x+1][y]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(x-1>=0){\n\t\t\tt=map[x][y];\n\t\t\tmap[x][y]=map[x-1][y];\n\t\t\tmap[x-1][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=40000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x-1,y,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x-1][y];\n\t\t\tmap[x-1][y]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(y+1<3){\n\t\t\tt=map[x][y+1];\n\t\t\tmap[x][y+1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=40000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x,y+1,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x][y+1];\n\t\t\tmap[x][y+1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(y-1>=0){\n\t\t\tt=map[x][y-1];\n\t\t\tmap[x][y-1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=40000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x,y-1,tot+1);\n\t\t\t    hx[g]=0;\n\t\t\t}\n\t\t\tt=map[x][y-1];\n\t\t\tmap[x][y-1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t}\n}\nvoid input(){\n\tint x1,y1;\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tcin>>map[i][j];\n\t\t\tif(map[i][j]==0){\n\t\t\t\tx1=i;\n\t\t\t\ty1=j;\n\t\t\t}\n\t\t}\n\t}\n\tint g=1;\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tg=g*10+map[i][j];\n\t\t\tg%=10000007;\n\t\t}\n\t}\n\thx[g]=1;\n\tsyf(x1,y1,0);\n\tcout<<min0<<endl;\n}\nint main(){\n\tinput();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n\n/* 大文字を小文字に変換 */\nchar tolower(char c) {return (c + 0x20);}\n/* 小文字を大文字に変換 */\nchar toupr(char c) {return (c - 0x20);}\n\n// if('A'<=s[i] && s[i]<='Z') s[i] += 'a'-'A';\n\n/*\nstring s = \"abcdefg\"\ns.substr(4) \"efg\"\ns.substr(0,3) \"abc\"\ns.substr(2,4) \"cdef\"\n*/\nstatic const int N = 3, N2 = 9;\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < ( const Puzzle &p ) const {\n        rep(i, N2){\n            if(f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n    rep(i,N2){\n        if(p.f[i] != i+1) return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;    // 自作した構造体に関するmapを定義\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while(!Q.empty()){\n        u = Q.front(); Q.pop();\n        // もしパズルuがターゲットと合致していれば\n        if(isTarget(u)) return u.path;\n        int sx = u.space / N;   // space x\n        int sy = u.space % N;   // space y\n        rep(r, 4){\n            int tx = sx + dx[r];    // transfer x\n            int ty = sy + dy[r];    // transfer y\n            if(tx<0 || ty<0 || tx>=N || ty>=N) continue;    // 移動先がパズルの枠を超えてしまわないようにする\n            v = u;\n            swap(v.f[u.space], v.f[tx*N + ty]);\n            v.space = tx*N + ty;    // spaceの位置も移動\n            if( !V[v] ){    // 既に同じ配置のパズルを動かし済みの場合はスルーする\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\n\nint main()\n{\n    Puzzle in;\n\n    rep(i,N2){\n        cin >> in.f[i];\n        if(in.f[i] == 0){\n            in.f[i] = N2;   // set space\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    // cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <queue>\n/*\n1 2 3\n4 5 6\n7 0 8\n????????¶????????????????????????3???????????????\n????????????8??????????????????1?????§??????\n\n1 2 3\n4 0 6\n7 5 8\n????????¶?????????5??????????????°1?????§??????????????¢????????????\n\n*/\ntypedef long long int TBoard;\nconst static TBoard Answer = 123456780;\ntypedef std::vector<bool> TTable;\nTBoard InputBoard(std::istream& in)\n{\n    TBoard Board = 0;\n    for(int i = 8; i >= 0; --i){\n        int n;\n        std::cin >> n;\n        Board += std::pow(10, i) * n;\n    }\n    return Board;\n}\nint Encode(const TBoard& Board)\n{\n    return Board / 10;\n}\nTBoard Decode(int Code)\n{\n    int n = 0;\n    while(Code){\n        n += Code % 10;\n        Code /= 10;\n    }\n    int a = 36 - n;\n    return Code * 10 + a;\n    \n}\nstd::vector<TBoard> GetMoved(const TBoard& Board)\n{\n    std::stringstream ss;\n    ss << std::setfill('0') << std::setw(9) << Board;\n    std::string s = ss.str();\n    assert(s.length() == 9);\n    int i = s.find('0');\n    assert(i >= 0);\n    assert(i <= 9);\n    \n    std::vector<TBoard> Result;\n    if(i > 2){\n        std::string copy = s;\n        std::swap(copy[i], copy[i-3]);\n        Result.push_back(std::atoi(copy.c_str()));\n    }\n    if(i < 6){\n        std::string copy = s;\n        std::swap(copy[i], copy[i+3]);\n        Result.push_back(std::atoi(copy.c_str()));\n    }\n    if((i == 0 || i == 3 || i == 6) == false){\n        std::string copy = s;\n        std::swap(copy[i], copy[i-1]);\n        Result.push_back(std::atoi(copy.c_str()));\n    }\n    if((i == 2 || i == 5 || i == 8) == false){\n        std::string copy = s;\n        std::swap(copy[i], copy[i+1]);\n        Result.push_back(std::atoi(copy.c_str()));\n    }\n\n    return Result;\n}\nvoid Print(const TBoard& Board, char c)\n{\n    std::stringstream ss;\n    ss << std::setfill('0') << std::setw(9) << Board;\n    std::string s = ss.str();\n    std::cerr << c << s[0] << \" \" << s[1] << \" \" << s[2] << std::endl;\n    std::cerr << c << s[3] << \" \" << s[4] << \" \" << s[5] << std::endl;\n    std::cerr << c << s[6] << \" \" << s[7] << \" \" << s[8] << std::endl;\n    std::cerr << std::endl;\n}\nint Solve(const TBoard& Board)\n{\n    std::vector<bool> Table(87654321, false);\n    int Cost = 0;\n    std::queue<TBoard> q;\n    q.push(Board);\n    Table[Encode(Board)] = true;\n\n    std::queue<TBoard> temp;\n    while(!q.empty()){\n        TBoard B = q.front();\n        q.pop();\n        // Print(B, ' ');\n        if(B == Answer) return Cost;\n        std::vector<TBoard> Boards = GetMoved(B);\n        for(std::size_t i = 0; i < Boards.size(); ++i){\n            if(Table[Encode(Boards[i])]) continue;\n            temp.push(Boards[i]);\n            Table[Encode(Boards[i])] = true;\n            // Print(Boards[i], '\\t');\n        }\n        if(q.empty()){\n            std::swap(q, temp);\n            ++Cost;\n            // std::cerr << \"Cost\" << Cost << std::endl;\n        }\n    }\n    assert(false);\n}\nint main()\n{\n    TBoard Board = InputBoard(std::cin);\n    std::cout << Solve(Board) << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n#include<map>\n#include<queue>\n#define Max 9\nint gg[Max]={1,2,3,4,5,6,7,8,0}, s[Max];\n\nint ff[4][2] = {0,-1,1,0,0,1,-1,0};\nint sum;\nstruct node\n{\n\tint a[Max];\n\tint step;\n};\nmap<int ,int >m;\n\n\nint bfs()\n{\n\tnode tt;\n\tmemcpy(tt.a,s,sizeof(s));\n\ttt.step = 0;\n\tqueue<node > q;\n\tq.push(tt);\n\twhile(!q.empty())\n\t{\n\t\tnode star = q.front();\n\t\tq.pop();\n\t\tint i;\n\t\tfor(i = 0;i<9;i++)\n\t\t\tif(star.a[i]==0)\n\t\t\t\tbreak;\n\t\tint y = i/3;\n\t\tint x = i%3;\n\t\tfor(i = 0;i<4;i++)\n\t\t{\n\t\t\tint tx = x + ff[i][0];\n\t\t\tint ty = y + ff[i][1];\n\t\t\tif(tx >= 0&&ty>=0&&ty<3&&tx<3)\n\t\t\t{\n\t\t\t\tnode end;\n\t\t\t\tmemcpy(end.a,star.a,sizeof(star.a));\n\t\t\t\tint k = ty*3+tx;\n\t\t\t\tswap(end.a[k],end.a[y*3+x]);\n\t\t\t\tint sum1 = 0;\n\t\t\t\tfor(int j = 0;j<9;j++)\n\t\t\t\t\tsum1 = sum1*10+end.a[j];\n\t\t\t\tif(!m[sum1])\n\t\t\t\t{\n\t\t\t\t\tm[sum1] = sum++;\n\t\t\t\t\tend.step = star.step+1;\n\t\t\t\t\tif(memcmp(end.a,gg,sizeof(gg))==0)\n\t\t\t\t\t\treturn end.step;\n\t\t\t\t\tq.push(end);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tint i,j;\n\n\twhile(~scanf(\"%d\",&s[0]))\n\t{\n\t\tm.clear();\n\t\tint k = s[0];\n\t\tsum = 1;\n\t\tfor(i = 1;i<9;i++)\n\t\t{\n\t\t\tscanf(\"%d\",&s[i]);\n\t\t\tk = k*10+s[i];\n\t\t}\n\t\tm[k] = sum++;\n\t\tif(memcmp(s,gg,sizeof(gg))==0)\n\t\t\tprintf(\"0\\n\");\n\t\telse printf(\"%d\\n\",bfs());\n\t\t\n\t}\t\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "// 8 puzzle\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define N  3\n#define N2 9\nusing namespace std;\nstruct Puzzle{\n    int f[N2];\n    int space;\n    string path;\n    bool operator < (const Puzzle &p) const\n    {\n        for (int i = 0; i < N2; ++i)\n        {\n            if (f[i] == p.f[i]) continue;\n            return f[i] < p.f[i];            \n        }\n        return false;\n    }\n};\n \nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u','l','d','r'};\n \nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; ++i)\n    {\n        if (p.f[i] != (i+1)) return false;\n    }\n    return true;\n}\n \nstring bfs(Puzzle s)\n{\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u,v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n    while(!Q.empty())\n    {\n        u = Q.front(); Q.pop();\n        if (isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; ++r)\n        {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if( tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if (!V[v])\n            {\n \n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n \nint main()\n{\n    Puzzle in;\n    for (int i = 0; i < N2; ++i)\n    {\n        cin>>in.f[i];\n        if (in.f[i]==0) {\n            in.space = i;\n                in.f[i] = 9;\n        }\n    }\n    string ans = bfs(in);\n    cout<<ans.size()<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\nusing namespace std;\n#define MAXN 363000  //9!==326880\nstruct node\n{\n    int s[9];\n    int a;\n    int b;\n    int step;\n};\nint fac[10]= {1,1,2,6,24,120,720,5040,40320,362880};//分别存储1--9的阶乘值\nint dir[4][2]= {-1,0,1,0,0,-1,0,1};\nint aim=322561;//123456780对应的hash值\nbool vis[MAXN];\nnode str,now,next\nint cantor(const int *s)\n{\n    int sum=0;\n    for(int i=0; i<9; i++)\n    {\n        int num=0;\n        for(int j=0; j<i; j++)\n            if(s[j]>s[i])\n                num++;\n        sum+=(num*fac[i]);\n    }\n    return (sum+1);\n}\nbool bfs()\n{\n    memset(vis,0,sizeof(vis));\n    queue<node>q;\n    q.push(str);\n    vis[str.b]=1;\n    while(!q.empty())\n    {\n        now=q.front();\n        q.pop();\n        int x=now.a/3;\n        int y=now.a%3;\n        for(int i=0; i<4; i++)\n        {\n            int tx=x+dir[i][0],ty=y+dir[i][1];\n            if(tx<0||tx>=3||ty<0||ty>=3)\n                continue;\n            next=now;\n            next.a=tx*3+ty;\n            next.s[now.a]=next.s[next.a];\n            next.s[next.a]=0;\n            next.b=cantor(next.s);\n            if(!vis[next.b])\n            {\n                vis[next.b]=1;\n                if(next.b==aim)\n                {\n                    return true;\n                }\n                next.step=now.step+1;\n                q.push(next);\n            }\n        }\n    }\n    return 0;\n}\nchar sss[3];\nint main()\n{\n    char q[10];\n    for(int i=0; i<9; i++)\n    {\n        scanf(\"%s\",sss);\n        q[i]=sss[0];\n    }\n    int len=strlen(q);\n    int num=0;\n    for(int i=0; i<len; i++)\n    {\n        if(q[i]>='1'&&q[i]<='9')\n        {\n            str.s[num++]=q[i]-'0';\n        }\n        else if(q[i]=='0')\n        {\n            str.s[num]=0;\n            str.a=num++;\n        }\n    }\n    str.b=cantor(str.s);\n    if(str.b==aim)\n        printf(\"%d\\n\",0);\n    else if(bfs())\n        printf(\"%d\\n\",next.step+1);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n \nstruct Puzzle{\nint f[N2];\nint space;\nstring path;\n \nbool operator < (const Puzzle &p) const{\nfor(int i = 0; i < N2; i++){\nif(f[i] == p.f[i]) continue;\nreturn f[i] > p.f[i];\n}\nreturn false;\n}\n};\n \nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n \nbool isTarget(Puzzle p){\nfor(int i = 0; i < N2; i++)\nif(p.f[i] != (i + 1)) return false;\nreturn true;\n}\n \nstring bfs(Puzzle s){\nqueue<Puzzle> Q;\nmap<Puzzle, bool> V;\nPuzzle u, v;\ns.path = \"\";\nQ.push(s);\nV[s] = true;\n \nwhile(!Q.empty()){\nu = Q.front(); Q.pop();\nif(isTarget(u)) return u.path;\nint sx = u.space / N;\nint sy = u.space % N;\nfor(int r = 0; r < 4; r++){\nint tx = sx + dx[r];\nint ty = sy + dy[r];\nif(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\nv = u;\nswap(v.f[u.space], v.f[tx * N + ty]);\nv.space = tx * N + ty;\nif(!V[v]){\nV[v] = true;\nv.path += dir[r];\nQ.push(v);\n}\n}\n}\nreturn \"unsolvable\";\n}\n \nint main(){\nPuzzle in;\nfor(int i = 0; i < N2; i++){\ncin >> in.f[i];\nif(in.f[i] == 0){\nin.f[i] = N2;\nin.space = i;\n}\n}\nstring ans = bfs(in);\ncout << ans.size() << endl;\n \nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n#include<map>\n#include<queue>\n#define Max 9\nint gg[Max]={1,2,3,4,5,6,7,8,0}, s[Max];\n\nint ff[4][2] = {0,-1,1,0,0,1,-1,0};\nint sum;\nstruct node\n{\n\tint a[Max];\n\tint step;\n};\nmap<int ,int >m;\n\n\nint bfs()\n{\n\tnode tt;\n\tmemcpy(tt.a,s,sizeof(s));\n\ttt.step = 0;\n\tqueue<node > q;\n\tq.push(tt);\n\twhile(!q.empty())\n\t{\n\t\tnode star = q.front();\n\t\tq.pop();\n\t\tint i;\n\t\tfor(i = 0;i<9;i++)\n\t\t\tif(star.a[i]==0)\n\t\t\t\tbreak;\n\t\tint y = i/3;\n\t\tint x = i%3;\n\t\tfor(i = 0;i<4;i++)\n\t\t{\n\t\t\tint tx = x + ff[i][0];\n\t\t\tint ty = y + ff[i][1];\n\t\t\tif(tx >= 0&&ty>=0&&ty<3&&tx<3)\n\t\t\t{\n\t\t\t\tnode end;\n\t\t\t\tmemcpy(end.a,star.a,sizeof(star.a));\n\t\t\t\tint k = ty*3+tx;\n\t\t\t\tswap(end.a[k],end.a[y*3+x]);\n\t\t\t\tint sum1 = 0;\n\t\t\t\tfor(int j = 0;j<9;j++)\n\t\t\t\t\tsum1 = sum1*10+end.a[j];\n\t\t\t\tif(!m[sum1])\n\t\t\t\t{\n\t\t\t\t\tm[sum1] = sum++;\n\t\t\t\t\tend.step = star.step+1;\n\t\t\t\t\tif(memcmp(end.a,gg,sizeof(gg))==0)\n\t\t\t\t\t\treturn end.step;\n\t\t\t\t\tq.push(end);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tint i,j;\n\n\twhile(~scanf(\"%d\",&s[0]))\n\t{\n\t\tm.clear();\n\t\tint k = s[0];\n\t\tsum = 1;\n\t\tfor(i = 1;i<9;i++)\n\t\t{\n\t\t\tscanf(\"%d\",&s[i]);\n\t\t\tk = k*10+s[i];\n\t\t}\n\t\tm[k] = sum++;\n\t\tif(memcmp(s,gg,sizeof(gg))==0)\n\t\t\tprintf(\"0\\n\");\n\t\telse printf(\"%d\\n\",bfs());\n\t\t\n\t}\t\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstdlib>\n#include<math.h>\n#include<iostream>\n#include<queue>\n\n// 参考　https://qiita.com/exrd/items/8bc0be17a15ff77d3754\n//      http://www.nct9.ne.jp/m_hiroi/puzzle/eight.html\n\n#define N 9 // マス目の数\n#define INF 1000\n#define FORWARD 2\n#define BACKWARD -2\n\nint sqrtN;\n\ntypedef struct {\n    int b[N];\n    int space;\n    int path; // かかった手数\n    int prenum; // 前のボードの状態\n    int from; // 双方向探索のための値\n    int hur; // ヒューリスティック値\n}Puzzle;\n\ntypedef struct s{\n    int num;\n    struct s *left;\n    struct s *right;\n}BoardState;\n\n\nvoid t(){\n    printf(\"\\ntest\\n\");\n}\n\nvoid swap(int *x, int *y){\n    int tmp;\n    tmp = *x;\n    *x = *y;\n    *y = tmp;\n}\n\n// 盤面をプリント\nvoid printBoard(Puzzle p){\n    for(int i = 0; i < N; i++){\n        printf(\"%d\", p.b[i]);\n        if ((i+1) % sqrtN == 0) {\n            printf(\"\\n\");\n        }else{\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n}\n\nint kaijou(int x){\n    int kaijou = x;\n    for(int i = x-1; i > 0; i--){\n        kaijou *= i;\n    }\n    return kaijou;\n}\n\n// 盤面の状態を数字に変換　参考:http://www.nct9.ne.jp/m_hiroi/puzzle/eight.html\nint culcBoardNum(Puzzle p){\n    for (int i = 0; i < N-1; i++) {\n        for (int j = i+1; j < N; j++) {\n            //printf(\"%d %d\\n\", p.b[i], p.b[j]);\n            if(p.b[i] < p.b[j]){\n                p.b[j]--;\n            }\n        }\n    }\n    //printBoard(p);\n    int num = 0;\n    for(int i = 0; i < N-1; i++){\n        num += p.b[i] * kaijou(N-1-i);\n    }\n    \n    return num;\n}\n\n// 空いたスペースの上下左右があるか確かめる関数たち\nint left(Puzzle p){\n    if(p.space % sqrtN == 0){\n        return 0;\n    }else{\n        return p.b[p.space-1];\n    }\n}\n\nint right(Puzzle p){\n    if((p.space+1) % sqrtN == 0){\n        return 0;\n    }else{\n        return p.b[p.space+1];\n    }\n}\n\nint up(Puzzle p){\n    if(p.space < sqrtN){\n        return 0;\n    }else{\n        return p.b[p.space-sqrtN];\n    }\n}\n\nint down(Puzzle p){\n    if(p.space + 1 + sqrtN > N){\n        return 0;\n    }else{\n        return p.b[p.space+sqrtN];\n    }\n}\n\n// 完成した盤面ならtrueを返す\nbool isDone(Puzzle p){\n    for(int i = 1; i < N; i++){\n        if(p.b[i-1] != i){\n            return false;\n        }\n    }\n    return true;\n}\n\n//   0 1 2\n//   -----   N = 9のとき\n//0 |1 2 3\n//1 |4 5 6\n//2 |7 8 0\nint x(int i){\n    if(i == 0){\n        return sqrtN-1;\n    }else{\n        return (i-1) % sqrtN;\n    }\n}\nint y(int i){\n    if(i == 0){\n        return sqrtN-1;\n    }else{\n        return ( (i-1) - (i-1)%sqrtN ) / sqrtN;\n    }\n}\n\n// ヒューリスティック値返す xの差分+yの差分\nint h(Puzzle p){\n    int sum = 0;\n    for(int i = 1; i < N; i++){\n        sum += abs(x(i) - x(p.b[i-1])) + abs(y(i) - y(p.b[i-1]));\n    }\n    sum += abs(x(0) - x(p.b[N-1])) + abs(y(0) - y(p.b[N-1]));\n    return -1;\n}\n\n// すでにでてきた盤面ならtrueを返す\nint *allboard; // でできた盤面を数字にして格納 mainでmalloc [1]からスタート\nint *fromwhere; // どっちからきたか記録　allbaordと対応\nint *paths; // allboardと対応\nint curboardNum = 0; // 今のallboardの要素数\nBoardState bs_root;\nint isAlready(Puzzle p){\n    //printf(\"isAlready\\n\");\n    int nump = culcBoardNum(p);\n    \n    // 線形探索\n    /*\n    for(int i = 0; i < curboardNum; i++){\n        //printf(\"%d: %d to %d\\n\", i, allboard[i], nump);\n        if (nump == allboard[i]) {\n            return true;\n        }\n    }\n    allboard[curboardNum] = nump;\n    curboardNum++;\n    return false;*/\n    \n    // もう作った盤面で来た方向が違ければ一致した方のpathを返す\n    for(int i = 0; i < curboardNum; i++){\n        if (nump == allboard[i] && p.from != fromwhere[i]) {\n            //printf(\"%d番目\\n\", i);\n            return paths[i] + p.path;\n        }\n    }\n    allboard[curboardNum] = nump;\n    fromwhere[curboardNum] = p.from;\n    paths[curboardNum] = p.path;\n    /*for(int i = 0; i < curboardNum+1; i++){\n        printf(\"%d \", paths[i]);\n    }\n    printf(\"\\n\");*/\n    curboardNum++;\n    return 0;\n    \n    // 二分探索木\n    /*while (1) {\n     if(allboard[i] == -1){\n     allboard[i] = nump;\n     return false;\n     }else if(allboard[i] == nump){\n     return true;\n     }else if(allboard[i] < nump){\n     i = 2*i;\n     }else{\n     i = 2*i + 1;\n     }\n     }*/\n    // 連結リストの二分木\n    /*\n    BoardState bs, newly;\n    bs = bs_root;\n    while (1) {\n        if (bs.num == nump) {\n            return true;\n        }else if(bs.num > nump){\n            if(bs.left == NULL){\n                bs.left = &newly;\n                bs.left->num = nump;\n                return false;\n            }else{\n                bs = *(bs.left);\n            }\n        }else if(bs.num < nump){\n            if(bs.right == NULL){\n                bs.right = &newly;\n                bs.right->num = nump;\n                return false;\n            }else{\n                bs = *(bs.right);\n            }\n        }\n    }*/\n\n}\nint whilecount = 0;\n// ---- // ---- //\n// 最短手数を返す\nint bfs(Puzzle p){\n    if(isDone(p)){\n        return 0;\n    }\n    std::queue<Puzzle> Q;\n    \n    Puzzle v, goal, l, r, u, d;\n    int minpath;\n    \n    p.path = 0;\n    //p.hur = h(p);\n    p.prenum = -1;\n    p.from = FORWARD;\n    // goal初期化\n    for (int i = 1; i < N; i++) {\n        goal.b[i-1] = i;\n    }\n    goal.b[N-1] = 0;\n    goal.path = 0;\n    goal.prenum = -1;\n    goal.from = BACKWARD;\n    goal.space = N-1;\n    \n    Q.push(p);\n    Q.push(goal);\n    allboard[0] = culcBoardNum(p);\n    allboard[1] = culcBoardNum(goal);\n    fromwhere[0] = FORWARD;\n    fromwhere[1] = BACKWARD;\n    paths[0] = 0;\n    paths[1] = 0;\n    curboardNum += 2;\n    bs_root.num = culcBoardNum(p);\n    while (1) {\n        v = Q.front();\n        Q.pop();\n        int hurv = h(v);\n        int numv = culcBoardNum(v);\n        /*printf(\"dequeue %s\\n\", v.from == FORWARD ? \"FORWARD\" : \"BACKWARD\");\n        printBoard(v);*/\n        // キューの先頭に入っていた盤面から一手動かしてそれをまたキューに入れる　完成したらそこでreturn\n        if (left(v)) { // spaceとそのleftを入れ替えられるなら\n            l = v; // コピー\n            swap(&l.b[l.space], &l.b[l.space-1]); // 入れ替え\n            l.space--; // space位置変更\n            l.path = v.path + 1;\n            /*if (isDone(l)) { // 完成してたら終わり\n                return v.path + 1;\n            }else if(v.prenum != culcBoardNum(l) && h(l) <= hurv){\n                l.prenum = numv;\n                l.path = v.path + 1;\n                Q.push(l);\n            }*/\n            /*if(isAlready(l)){\n                return l.path + paths[curboardNum] +1;\n            }else if(v.prenum != culcBoardNum(l)){\n                l.prenum = numv;\n                l.from = v.from;\n                Q.push(l);\n                printf(\"left path:%d\\n\", l.path);\n                printBoard(l);\n            }*/\n            if(v.prenum != culcBoardNum(l)){\n                minpath = isAlready(l); // ０が帰って来たらまだ終了でない\n                if (minpath) {\n                    return minpath;\n                }else{\n                    l.prenum = numv;\n                    l.from = v.from;\n                    Q.push(l);\n                    /*printf(\"left path:%d\\n\", l.path);\n                    printBoard(l);*/\n                }\n            }\n        }\n        // 以下同様\n        if (right(v)) {\n            r = v;\n            swap(&r.b[r.space], &r.b[r.space+1]);\n            r.space++;\n            r.path = v.path + 1;\n            /*if (isDone(r)) {\n                return v.path + 1;\n            }else if(v.prenum != culcBoardNum(r) && h(r) <= hurv){\n                r.prenum = numv;\n                r.path = v.path + 1;\n                Q.push(r);\n            }*/\n            /*if(isAlready(r)){\n                return r.path + paths[curboardNum] +1;\n            }else if(v.prenum != culcBoardNum(r)){\n                r.prenum = numv;\n                r.from = v.from;\n                Q.push(r);\n                printf(\"right path:%d\\n\", r.path);\n                printBoard(r);\n            }*/\n            if(v.prenum != culcBoardNum(r)){\n                minpath = isAlready(r);\n                if (minpath) {\n                    return minpath;\n                }else{\n                    r.prenum = numv;\n                    r.from = v.from;\n                    Q.push(r);\n                    /*printf(\"right path:%d\\n\", r.path);\n                    printBoard(r);*/\n                }\n            }\n        }\n        if (up(v)) {\n            u = v;\n            swap(&u.b[u.space], &u.b[u.space-sqrtN]);\n            u.space -= sqrtN;\n            u.path = v.path + 1;\n            /*if (isDone(u)) {\n                return v.path + 1;\n            }else if(v.prenum != culcBoardNum(u) && h(u) <= hurv){\n                u.prenum = numv;\n                u.path = v.path + 1;\n                Q.push(u);\n            }*/\n            /*if(isAlready(u)){\n                return u.path + paths[curboardNum] +1;\n            }else if(v.prenum != culcBoardNum(u)){\n                u.prenum = numv;\n                u.from = v.from;\n                Q.push(u);\n                printf(\"up path:%d\\n\", u.path);\n                printBoard(u);\n            }*/\n            if (v.prenum != culcBoardNum(u)) {\n                minpath = isAlready(u);\n                if (minpath) {\n                    return minpath;\n                }else{\n                    u.prenum = numv;\n                    u.from = v.from;\n                    Q.push(u);\n                    /*printf(\"up path:%d\\n\", u.path);\n                    printBoard(u);*/\n                }\n            }\n        }\n        if (down(v)) {\n            d = v;\n            swap(&d.b[d.space], &d.b[d.space+sqrtN]);\n            d.space += sqrtN;\n            d.path = v.path + 1;\n            /*if (isDone(d)) {\n                return v.path + 1;\n            }else if(v.prenum != culcBoardNum(d) && h(d) <= hurv){\n                d.prenum = numv;\n                d.path = v.path + 1;\n                Q.push(d);\n            }*/\n            /*if(isAlready(d)){\n                return d.path + paths[curboardNum] +1;\n            }else if(v.prenum != culcBoardNum(d)){\n                d.prenum = numv;\n                d.from = v.from;\n                Q.push(d);\n                printf(\"down path:%d\\n\", d.path);\n                printBoard(d);\n            }*/\n            if (v.prenum != culcBoardNum(d)) {\n                minpath = isAlready(d);\n                if (minpath) {\n                    return minpath;\n                }else{\n                    d.prenum = numv;\n                    d.from = v.from;\n                    Q.push(d);\n                    /*printf(\"down path:%d\\n\", d.path);\n                    printBoard(d);*/\n                }\n            }\n        }\n        \n        whilecount++;\n    }\n    return -1;\n}\n\nint main(){\n    int board;\n    Puzzle p;\n    \n    int kaijouN = kaijou(N);\n    allboard = (int *)malloc(sizeof(int) * 30000);\n    fromwhere = (int *)malloc(sizeof(int) * 30000);\n    paths = (int *)malloc(sizeof(int) * 30000);\n    \n    bs_root.right = NULL;\n    bs_root.left = NULL;\n    \n    sqrtN = sqrt(N);\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &board);\n        if(board == 0){\n            p.space = i;\n        }\n        p.b[i] = board;\n        p.path = -1;\n    }\n    \n    //printBoard(p);\n    printf(\"%d\\n\", bfs(p));\n    \n    free(allboard);\n    free(fromwhere);\n    free(paths);\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <list>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nstruct state {\n    Board board;\n    int count;\n};\n\nlist<state> q;\n//vector<state> q;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    for (list<state>::iterator it = q.begin(); it != q.end(); ++it) {\n//    for (vector<state>::iterator it = q.begin(); it != q.end(); ++it) {\n        if (it->board == s.board) {\n            return -1;\n        }\n    }\n    ++s.count;\n    if (s.board == GOAL) {\n        return s.count;\n    }\n    q.push_back(s);\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0; i < N; ) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            board |= static_cast<long long>((ch - '0')) << (i*4);\n            ++i;\n        }\n    }\n\n//    print(GOAL);\n//    print(board);\n\n    q.push_back({ board, 0 });\n    int count = 0;\n    while (!q.empty()) {\n        state s = q.front();\n        q.pop_front();\n        // ?????????????????????\n        int pos;\n        for (pos = 0; pos < N; ++pos) {\n            if (((s.board >> (pos*4)) & 15) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N29\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator<(const Puzzle &p)const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','i','d','r'};\nbool isTarget(Pizzle p){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!=Q.empty()){\n    u=Q.front();Q.pop();\n    is(isTarget(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N)continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  for(int i=0;i<N2;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout<<ans.size()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint Y[4]={-1,0,1,0};\nint X[4]={0,1,0,-1};\n \nbool in(int a,int b){\n  if(a<0 || b<0 || 3<=a || 3<=b)return false;\n  return true;\n}\n \nint main()\n{\n  int a;\n  string start=\"\",goal=\"123456780\";\n \n  for(int i=0;i<9;i++){\n    cin>>a;\n    start+=(a+'0');\n  }\n   \n  queue<string> q;\n  map<string,int> mp;\n  mp[start]=0;\n  q.push(start);\n  while(!q.empty()){\n    string u=q.front();\n    q.pop();\n    int s=-1,cost=mp[u];\n    if(u==goal){\n      cout<<mp[u]<<endl;\n      break;\n    }\n \n    for(int i=0;i<u.length();i++){\n      if(u[i]=='0')s=i;\n    }\n \n    int y=s/3,x=s%3;\n \n    for(int i=0;i<4;i++){\n      int ny=y+Y[i],nx=x+X[i];\n      if(!in(ny,nx))continue;\n      int index=ny*3+nx;\n      string t=u;\n      swap(t[s],t[index]);\n      if(mp.find(t)==mp.end()){\n    mp[t]=cost+1;\n    q.push(t);\n      }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef pair<int,ull> P;\ntypedef pair<int,int>Pii;\n#define F first\n#define S second\n \n \nint dep=0;;\nint X[]={0,3,2,1,0,3,2,1,0,3,2,1,0,3,2,1};\nint Y[]={0,3,3,3,3,2,2,2,2,1,1,1,1,0,0,0};\nint dy[]={1,0,-1,0};\nint dx[]={0,-1,0,1};\null mask[3][3],bit[3][3];\n\nconst int MAX = 333333;\null G=4886718336 , x , s , M=((ull)1<<(4*9))-1;\n\nPii pos(ull A){\n    r(y,3)r(x,3){\n        if(!((A>>bit[y][x])&15)){\n            return Pii(y,x);\n        }\n    }\n\n}\n\nint cost(ull A,int y2,int x2){\n\tint sum=0;\n\tr(y,3){\n        r(x,3){\n            int k=((A>>bit[y][x])&15);\n            int t = abs(X[k]-x) + abs(Y[k]-y);\n    \t\tsum += t ;\n        }\n\t}\n\treturn sum;\n}\n\n\nsigned main(){\n\n    ull init = 0;\n    unordered_set<ull>st;\n\n    for(int i=2;i>=0;i--){\n        for(int j=2;j>=0;j--){\n            ull x;\n            cin>>x;\n            init|=(x<<((i*3+j)*4));\n            mask[i][j] = (ull)15<<((i*3+j)*4);\n            bit[i][j] = (i*3+j)*4;\n        }\n    }\n\n\n\n    priority_queue<P> Q[2];\n    Q[0].push(P(0,init));\n    st.insert(init);\n \n    while( !Q[dep%2].empty() ){\n        while( !Q[dep%2].empty() ){\n            P A=Q[dep%2].top(); Q[dep%2].pop();\n\n            if(A.S==G){\n                cout<<dep<<endl;\n                return 0;\n            }\n\n            Pii p=pos(A.S);\n            int x=p.S, y=p.F;\n            ull a = (A.S>>bit[y][x])&15;\n\n            r(i,4){\n            \tint ny=p.F+dy[i];\n            \tint nx=p.S+dx[i];\n            \tif( ny<0 || nx<0 || 3<=ny || 3<=nx ) continue;\n\n                ull b = ( A.S>>bit[ny][nx] )&15;\n                ull c = ( A.S & ( M - mask[y][x] - mask[ny][nx] ) );\n                ull nex = (c | ( b<<bit[y][x] ) | ( a<<bit[ny][nx] ) );\n\n                if(st.count(nex)) continue;\n                st.insert(nex);\n\n\n                Q[(dep+1)%2].push(P(cost(nex,y,x),nex));\n                if(Q[(dep+1)%2].size()>=MAX) Q[(dep+1)%2].pop();\n\n            }\n        }\n        if(dep>=90)break;\n        //cout<<(Q[(dep+1)%2].size())<<endl;\n        dep++;\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) std::cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<std::endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\n \ntemplate<typename T>\nclass Deque{\npublic:\n  T *val;\n  int sz;\n  int length;\n  int head, tail;\n   \n  Deque(){sz = 0, length = 0, val = new T[0];}\n  Deque(int size, T init = T()){\n    length = 1;\n    while(length < size) length *= 2;\n    val = new T[length];\n    sz = size;\n    head = 0;\n    tail = 0;\n    for(int i=0;i<size;i++) val[tail++] = init;\n  }\n   \n  Deque(const Deque &t){\n    sz = t.size();\n    length = 1;\n    while(length < sz) length *= 2;\n    val = new T[length];\n    head = 0;\n    tail = 0;\n    for(int i=0;i<sz;i++) val[tail++] = t[i];\n  }\n \n  ~Deque(){\n    delete [] val;\n  }\n   \n  Deque<T> operator = (const Deque<T> t){\n    delete [] val;\n    sz = t.size();\n    length = 1;\n    while(length < sz) length *= 2;\n    val = new T[length];\n    head = 0;\n    tail = 0;\n    for(int i=0;i<sz;i++) val[tail++] = t[i];\n    return t;\n  };\n   \n  T& operator [] (int i){\n    assert(0 <= i && i < sz);\n    return head+i<length? val[head+i]:val[head+i - length];\n  }\n  T& operator [] (int i)const{\n   assert(0 <= i && i < sz);\n    return head+i<length? val[head+i]:val[head+i - length];\n  }\n   \n  bool operator == (const Deque<T> &a)const{\n    if(size() != a.size()) return 0;\n    for(int i=0;i<size();i++)\n      if(!((*this)[i] == a[i])) return 0;\n    return 1;\n  }\n   \n  T& front(){return val[head];}\n  T& back(){return val[(head + sz - 1) % length];}\n   \n  int size()const{return sz;}\n  int empty()const{return sz == 0;}\n   \n  void resize(int n, T v=T()){\n    while(n < size()) pop_back();\n    while(n > size()) push_back_fast(v);\n  }\n \n \n  void increaseMemory(){\n    int length_ = length;\n    length = length * 2;\n    if(length == 0) length = 1;\n    T *val2 = new T[length];\n    for(int i=0;i<sz;i++) val2[i] = val[(head + i)%length_];\n    head = 0;\n    tail = sz;\n    delete [] val;\n    val = val2;\n  };\n   \n  void push_back(T v){\n    if(sz == length) increaseMemory();\n    sz++;\n    val[tail++] = v;\n    if(tail == length) tail = 0;\n  }\n \n  void push_back_fast(T &v){\n    if(sz == length) increaseMemory();\n    sz++;\n    val[tail++] = v;\n    if(tail == length) tail = 0;\n  }\n     \n  void push_front(int v){\n    if(sz == length) increaseMemory();\n    sz++;\n    head--;\n    if(head == -1) head = length - 1;\n    val[head] = v;\n  }\n \n  void pop_back(){\n    assert(sz > 0);\n    sz--;\n    tail--;\n    if(tail == -1) tail = length - 1;\n  }\n   \n  void pop_front(){\n    assert(sz > 0);\n    sz--;\n    head++;\n    if(head == length) head = 0;\n  }\n \n  friend std::ostream& operator << (std::ostream& os,const Deque<T> a){\n    os<<\"[\";\n    for(int i=0;i<a.size();i++){\n      if(i) os<<\" \";\n      os<<a[i];\n    }\n    os<<\"]\";\n    return os;\n  }\n};\ntemplate <typename T>\nusing vector = Deque<T>;\n \ntemplate <typename T>\nusing queue = Deque<T>;\n \ntemplate <typename T, typename D>\nclass Pair{\npublic:\n  T first;\n  D second;\n  Pair(){first = T(),second = D();}\n  Pair(const T &first, const D &second):first(first), second(second){}\n   \n  bool operator < (const Pair t)const{\n    return first != t.first? (first < t.first):(second < t.second);\n  }\n  bool operator > (const Pair t)const{\n    return first != t.first? (first > t.first):(second > t.second);\n  }\n   \n  friend std::ostream& operator << (std::ostream& os,const Pair<T, D> a){\n    os<<\"(\"<<a.first<<\", \"<<a.second<<\")\";\n    return os;\n  }\n};\n \ntemplate<class T, class D>\nclass HashTable{\npublic:\n  using ull = unsigned int;\n  ull tableSize;\n  vector<vector<T> > tableKey;\n  vector<vector<D> > tableVal;\n   \n  HashTable(ull tableSize = 500009){\n    for(int i=2;i*i<=tableSize;i++)\n      assert(tableSize % i != 0 && \"tableSize have to be prime number\");\n    this->tableSize = tableSize;\n    tableKey.resize(tableSize);\n    tableVal.resize(tableSize);\n \n  }\n \n  void push(T key, D val, ull hash){\n    hash %= tableSize;\n    tableKey[hash].push_back_fast(key);\n    tableVal[hash].push_back_fast(val);\n  }\n \n  bool count(T key, ull hash){\n    hash %= tableSize;\n    int count = 0;\n    for(int i=0;i<tableKey[hash].size();i++)\n      if(tableKey[hash][i] == key) count++;\n    return count;\n  }\n \n  D getVal(T key, ull hash){\n    hash %= tableSize;\n    for(int i=0;i<tableKey[hash].size();i++)\n      if(tableKey[hash][i] == key) return tableVal[hash][i];\n    assert(!\"key not exists\");\n  }\n};\n \ntemplate<class T>\nvoid swap(T &a, T &b){\n  T tmp = a;\n  a = b;\n  b = tmp;\n}\n \nusing D = vector<vector<int> >;\nusing P = Pair<int, D>;\nconst int N = 3;\nusing ull = unsigned int;\n \null toHash(D &mp){\n  const ull B = 1777771;\n  ull hash = 0;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++) hash = hash * B + mp[i][j];\n  return hash;\n}\n \nHashTable<D, int> bfs(D start, D goal, int limit){\n  queue <P> Q;\n  Q.push_back(P(0,start));\n  HashTable <D, int> memo(100019);\n  memo.push(start, 0, toHash(start));\n   \n  while(!Q.empty()){\n    int cost = Q.front().first;\n    D mp = Q.front().second;\n    Q.pop_front();\n    if(cost == limit) continue;\n     \n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++){\n    if(j+1<N && (mp[i][j] == 0 || mp[i][j+1] == 0)){\n      D key = mp; swap(key[i][j], key[i][j+1]);\n      int val = cost + 1;\n      ull hash = toHash(key);\n      if(!memo.count(key, hash)){ \n        memo.push(key, val, hash);\n        Q.push_back(P(val, key));\n      }\n    }\n \n    if(i+1<N && (mp[i][j] == 0 || mp[i+1][j] == 0)){\n      D key = mp; swap(key[i][j], key[i+1][j]);\n      int val = cost + 1;\n      ull hash = toHash(key);\n      if(!memo.count(key, hash)){\n        memo.push(key, val, hash);\n        Q.push_back(P(val, key));\n      }\n    }\n      }\n  }\n  return memo;\n}\n \nsigned main(){\n \n  D goal(N, vector<int>(N));\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++) goal[i][j] = i*N + j + 1;\n  goal[N-1][N-1] = 0;\n \n  D start(N, vector<int>(N));\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++) std::cin>>start[i][j];\n \n   \n  auto A = bfs(start, goal, 20);\n  auto B = bfs(goal, start, 15);\n \n  int ans = 1000000;\n  for(int i=0;i<(int)B.tableSize;i++)\n    for(int j=0;j<(int)B.tableKey[i].size();j++){\n      auto key = B.tableKey[i][j];\n      auto costB = B.tableVal[i][j];\n      int costA = 10000000;\n      if(A.count(key, i)) costA = A.getVal(key, i);\n      if(ans > costA + costB) ans = costA + costB;\n     \n \n    }\n   \n  std::cout<<ans<<std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct r{\n\tint men[3][3];\n\tint cnt;\n};\nbool used[9][9][9][9][9][9][9][9][9]={};\nint main(){\n\tint i,j,dx[4]={0,1,0,-1},dy[4]={-1,0,1,0},k,temp,menc[3][3]={{1,2,3},{4,5,6},{7,8,0}};\n\tr f,v;\n\tqueue<r> q;\n\tfor(i=0;i<3;i++){\n\t\tfor(j=0;j<3;j++){\n\t\t\tcin>>f.men[i][j];\n\t\t}\n\t}\n\tf.cnt=0;\n\tq.push(f);\n\twhile(!q.empty()){\n\t\tf=q.front();\n\t\tq.pop();\n\t\tif(used[f.men[0][0]][f.men[0][1]][f.men[0][2]][f.men[1][0]][f.men[1][1]][f.men[1][2]][f.men[2][0]][f.men[2][1]][f.men[2][2]]==false){\n\t\t\tused[f.men[0][0]][f.men[0][1]][f.men[0][2]][f.men[1][0]][f.men[1][1]][f.men[1][2]][f.men[2][0]][f.men[2][1]][f.men[2][2]]=true;\n\t\t}\n\t\telse continue;\n\t\tint o=0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tfor(j=0;j<3;j++){\n\t\t\t\tif(f.men[i][j]!=menc[i][j]){\n\t\t\t\t\to=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(o==0)break;\n\t\tint b=0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tfor(j=0;j<3;j++){\n\t\t\t\tif(f.men[i][j]==0){\n\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\tif(i+dy[k]>=0&&i+dy[k]<3&&j+dx[k]>=0&&j+dx[k]<3){\n\t\t\t\t\t\t\tv=f;\n\t\t\t\t\t\t\ttemp=v.men[i][j];\n\t\t\t\t\t\t\tv.men[i][j]=v.men[i+dy[k]][j+dx[k]];\n\t\t\t\t\t\t\tv.men[i+dy[k]][j+dx[k]]=temp;\n\t\t\t\t\t\t\tv.cnt++;\n\t\t\t\t\t\t\tq.push(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b==1)break;\n\t\t}\n\t}\n\tcout<<f.cnt<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// using A star algorithm\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <map>\nusing namespace std;\nconst int N = 9;\nconst int XY = 3;\nconst int LIMIT = 100;\n\nstruct state {\n  vector<int> board;\n  int g;\n  state(vector<int> &board) {\n    this->board = board;\n    this->g = 0;\n  }\n};\nstruct compare_state {\n  int h_func(state &s) {\n    // using Manhattan distance\n    int distance = 0;\n    vector<int> solve(N,0);\n    for(int i=0;i<N;i++) {\n      solve[i] = i+1;\n    }\n    solve[N-1] = 0;\n    vector<int> board = s.board;\n    int solve_x,solve_y;\n    int board_x,board_y;\n    for(int i=0;i<N;i++) {\n      for(int j=0;j<N;j++) {\n        if(solve[i] == board[j]) {\n          solve_x = i % XY; solve_y = i / XY;\n          board_x = j % XY; board_y = j / XY;\n          distance += abs(solve_x - board_x) + abs(solve_y - board_y);\n          break;\n        }\n      }\n    }\n    return distance;\n  }\n  bool operator() (state &a,state &b) {\n    return (a.g + h_func(a)) > (b.g + h_func(b));\n  }\n};\npriority_queue<state,vector<state>,compare_state> que;\nmap<vector<int>,bool> exist_table;\n\nbool check(state &current,state &end) {\n  for(int i=0;i<N;i++) {\n    if(current.board[i] != end.board[i])\n      return false;\n  }\n  return true;\n}\n\nbool is_infield(int x,int y) {\n  return (x < XY && y < XY && x >= 0 && y >= 0);\n}\n\nint search(state &start,state &end) {\n  // initialize process\n  que.push(start);\n  exist_table[start.board] = true;\n  while(!que.empty()) {\n    state current = que.top(); que.pop();\n    // approach goal\n    if(check(current,end)) {\n      return current.g;\n    }\n    // not find goal\n    if(current.g > LIMIT) {\n      break;\n    }\n    // find zero brocks\n    int zero_pos;\n    for(int i=0;i<N;i++)\n      if(current.board[i] == 0)\n        zero_pos = i;\n    int x = zero_pos % XY;\n    int y = zero_pos / XY;\n    // swap zero brocks and update cost tables\n    int dx[] = {0,-1,1,0};\n    int dy[] = {-1,0,0,1};\n    for(int d=0;d<4;d++) {\n      if(!is_infield(x+dx[d],y+dy[d])) continue;\n      vector<int> next_board = current.board;\n      swap(next_board[x+y*XY],next_board[(x+dx[d])+(y+dy[d])*XY]);\n      if(!exist_table.count(next_board)) {\n        exist_table[next_board] = true;\n        state next = *(new state(next_board));\n        next.g = current.g + 1;\n        que.push(next);\n      }\n    }\n  }\n  return -1;\n}\n\nint main() {\n  vector<int> start_vec(N,-1);\n  vector<int> end_vec(N,-1);\n  for(int i=0;i<N;i++) {\n    cin >> start_vec[i];\n    end_vec[i] = i+1;\n  }\n  end_vec[N-1] = 0;\n\n  state start = *(new state(start_vec));\n  state end = *(new state(end_vec));\n\n  cout << search(start,end) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <utility>\nusing namespace std;\n\nclass state{\npublic:\n  static constexpr int size = 3;\n  int sx, sy;\n  int n[size*size];\n\n  bool operator < (const state&a) const{\n    for(int i=0; i<size*size; i++){\n      if(n[i]==a.n[i]) continue;\n      return n[i] < a.n[i];\n    }\n    return false;\n  }\n};\n\nclass board : public state{\npublic:\n  int cnt;\n  int dis;\n  board(): state(){\n    cnt = 0;\n    dis = 0;\n  }\n\n  bool check(){\n    for(int i=0; i<size*size; i++){\n      if(n[i] != i) return false;\n    }\n    return true;\n  }\n\n  board sswap(int x1, int y1, int x2, int y2){\n    board next(*this);\n\n    next.sx = x2; next.sy = y2;\n    swap(next.n[y1 * size + x1], next.n[y2 * size + x2]);\n    next.cnt = cnt+1;\n\n    return next;\n  }\n\n  void print(){\n    for(int i=0; i<size*size; i++){\n      cout << n[i] << \" \";\n      if(i%size == size-1) cout << endl;\n    }\n  }\n};\n\ntypedef pair<int, board> np;\n\nint main(){\n  board s;\n\n  for(int i=0; i<board::size*board::size; i++) {\n    cin >> s.n[i];\n    if(s.n[i] == 0){\n      s.sx = i % board::size;\n      s.sy = i / board::size;\n    }\n  }\n\n  queue<board> q;\n  map<state, bool> mp;\n  mp[s] = true;\n  q.push(s);\n\n  int c=0;\n  while(!q.empty()){\n    board now = q.front();\n\n    q.pop();\n    c++;\n\n    if(now.check()){\n      cout << now.cnt << endl;\n      cout << c << endl;\n      return 0;\n    }\n\n    int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\n\n    for(int i=0; i<4; i++){\n      int nx = now.sx + dx[i], ny = now.sy + dy[i];\n\n      if(nx < 0 || nx >= board::size || ny < 0 || ny >= board::size) continue;\n      board next = now.sswap(now.sx, now.sy, nx, ny);\n\n      if(!mp[next]){\n        mp[next] = true;\n        q.push(next);\n      }\n    }\n  }\n\n  cout << \"not found\" << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nconst int INF = 1<<30;\n\nvector<int> board( 9 );\nint completeState;\nset<int> reachedState;\n\nvoid PrintBoard() {\n    for ( int row=0; row<3; ++row ) {\n\tfor ( int col=0; col<3; ++col ) cout << board[row*3+col];\n\tcout << endl;\n    }\n}\n\nbool IsReachedState( int state ) {\n    return reachedState.find( state ) != reachedState.end();\n}\n\nint TranslateIntoState( const vector<int>& b ) {\n    int state = b[8] + 1;\n    for ( int i=7; i>=0; --i ) state = state*10 + (b[i]+1);\n    return state;\n}\n\nvoid RegisterState( int state ) {\n    reachedState.insert( state );\n}\n\nbool IsCompleted( int state ) {\n    return state == completeState;\n}\n\nint Try( int x, int y, int moves ) {\n\n    return 100;\n}\n\nint main() {\n\n    const int dx[4] = { -1, 0, 1,  0 };\n    const int dy[4] = {  0, 1, 0, -1 };\n    \n    int x, y;\n    for ( int i=0; i<3; ++i ) {\n\tfor ( int j=0; j<3; ++j ) {\n\t    cin >> board[i*3+j];\n\t    if ( board[i*3+j] == 0 ) {\n\t\ty = i;\n\t\tx = j;\n\t    }\n\t}\n    }\n\n    completeState = 1;\n    for ( int i=9; i>=2; --i ) completeState = completeState*10 + i;\n\n    /*\n    vector<int> b(9);\n    b[0] = 1; b[1] = 2; b[2] = 3;\n    b[3] = 4; b[4] = 5; b[5] = 6;\n    b[6] = 7; b[7] = 8; b[8] = 0;\n    cout << completeState << \" \" << TranslateIntoState( b ) << endl;\n    */\n    \n    //    PrintBoard();\n\n    queue< pair<vector<int>,int> > stateQue;\n    stateQue.push( make_pair(board, 0) );\n\n    int minStep = INF;\n    while ( !stateQue.empty() ) {\n\n\tvector<int> state = stateQue.front().first;\n\tint step = stateQue.front().second;\n\tstateQue.pop();\n\n\tint s = TranslateIntoState( state );\n\tif ( IsCompleted( s ) ) {\n\t    cout << step << endl;\n\t    board = state;\n\t    //\t    PrintBoard();\n\t    break;\n\t}\n\n\tif ( IsReachedState( s ) ) continue;\n\tRegisterState( s );\n\n\tint x, y;\n\tfor ( int i=0; i<9; ++i ) {\n\t    if ( state[i] == 0 ) {\n\t\tx = i%3;\n\t\ty = i/3;\n\t\tbreak;\n\t    }\n\t}\n\t\n\tfor ( int i=0; i<4; ++i ) {\n\n\t    int nx = x + dx[i];\n\t    int ny = y + dy[i];\n\n\t    if ( nx < 0 || nx > 2 || ny < 0 || ny > 2 ) continue;\n\n\t    vector<int> next = state;\n\t    swap( next[3*y+x], next[3*ny+nx] );\n\t    stateQue.push( make_pair( next, step+1 ) );\n\t    \n\t}\n\t\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3\nusing namespace std;\nstruct Graph{\n\tchar r, c;\n\tstring m;\n\tint cnt;\n\tbool ok(){\n\t\tbool ans = 1;\n\t\tfor(int i=0; i<N*N; i++)\n\t\t\tans &= (m[i] == (i+1) % (N*N));\n\t\treturn ans;\n\t}\n\tvoid get(){\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++){\n\t\t\tcin >> cnt;\n\t\t\tm.push_back(cnt);\n\t\t\tif(cnt == 0) r = i, c = j;\n\t\t}\n\t\tcnt = 0;\n\t}\n\tbool go(int i, int j){\n\t\tint r1=i+r, c1=j+c;\n\t\tif(!legal(r1, c1)) return 0;\n\t\tm[r*N+c] = m[r1*N+c1];\n\t\tm[r1*N+c1] = 0;\n\t\tr = r1, c = c1;\n\t\tcnt++;\n\t\treturn 1;\n\t}\n\tbool legal(int r1, int c1){\n\t\treturn (r1>=0 && r1<N && c1>=0 && c1<N);\n\t}\n};\nqueue <Graph> Q;\nmap <string , bool> V;\nint bfs(){\n\tint cmd[4][2]={{1,0}, {-1,0}, {0,1}, {0,-1}};\n\tGraph t0,t1;\n\twhile(!Q.empty()){\n\t\tt0 = Q.front();\n\t\tQ.pop();\n\t\tif(t0.ok()) return t0.cnt;\n\t\tfor(int i=0; i<4; i++){\n\t\t\tt1 = t0;\n\t\t\tif(t1.go(cmd[i][0], cmd[i][1]))\n\t\t\t\tif(!V[t1.m])\n\t\t\t\t\tQ.push(t1), V[t1.m] = 1;\n\t\t}\n\t}\n\treturn -1;\n}\nint main()\n{\t\n\tGraph a; a.get();\n\tQ.push(a);\n\tV[a.m] = 1;\n\tcout << bfs() << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3\nusing namespace std;\n\nint path = 0;\n//goal\nint final[N][N] =\n        {\n                {1, 2, 3},\n                {4, 5, 6},\n                {7, 8, 0}\n        };\n// state space tree nodes\nstruct Node {\n    // stores parent node of current node\n    // helps in tracing path when answer is found\n    Node *parent;\n\n    // stores matrix\n    int mat[N][N];\n\n    // stores blank tile cordinates\n    int x, y;\n\n    // stores the number of misplaced tiles\n    int cost;\n\n    // stores the number of moves so far\n    int level;\n};\n\n// Function to allocate a new node\nNode *newNode(int mat[N][N], int x, int y, int newX,\n              int newY, int level, Node *parent) {\n    Node *node = new Node;\n\n    // set pointer for path to root\n    node->parent = parent;\n\n    // copy data from parent node to current node\n    memcpy(node->mat, mat, sizeof node->mat);\n\n    // move tile by 1 postion\n    swap(node->mat[x][y], node->mat[newX][newY]);\n\n    // set number of misplaced tiles\n    node->cost = INT_MAX;\n\n    // set number of moves so far\n    node->level = level;\n\n    // update new blank tile cordinates\n    node->x = newX;\n    node->y = newY;\n\n    return node;\n}\n\n// botton, left, top, right\nint row[] = {1, 0, -1, 0};\nint col[] = {0, -1, 0, 1};\n\n// Function to calculate the the number of misplaced tiles\n// ie. number of non-blank tiles not in their goal position\nint calculateCost(int initial[N][N], int final[N][N]) {\n    int count = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            if (initial[i][j] && initial[i][j] != final[i][j])\n                count++;\n    return count;\n}\n\n// Function to check if (x, y) is a valid matrix cordinate\nint isSafe(int x, int y) {\n    return (x >= 0 && x < N && y >= 0 && y < N);\n}\n\n// print path from root node to destination node\nvoid checkPath(Node *root) {\n    if (root == NULL)\n        return;\n    checkPath(root->parent);\n    path += 1;\n\n}\n\n// Comparison object to be used to order the heap\nstruct comp {\n    bool operator()(const Node *lhs, const Node *rhs) const {\n        return (lhs->cost + lhs->level) > (rhs->cost + rhs->level);\n    }\n};\n\n\nvoid solve(int initial[N][N], int x, int y,\n           int final[N][N]) {\n\n    priority_queue<Node *, std::vector<Node *>, comp> pq;\n\n    Node *root = newNode(initial, x, y, x, y, 0, NULL);\n    root->cost = calculateCost(initial, final);\n\n    // Add root to list of live nodes;\n    pq.push(root);\n\n    // Finds a live node with least cost,\n    // add its childrens to list of live nodes and\n    // finally deletes it from the list.\n    while (!pq.empty()) {\n        // Find a live node with least estimated cost\n        Node *min = pq.top();\n\n        // The found node is deleted from the list of\n        // live nodes\n        pq.pop();\n\n        // if min is an answer node\n\n        if (min->cost == 0) {\n            checkPath(min);\n            return;\n        }\n\n        // do for each child of min\n        // max 4 children for a node\n        for (int i = 0; i < 4; i++) {\n            if (isSafe(min->x + row[i], min->y + col[i])) {\n                // create a child node and calculate\n                // its cost\n                Node *child = newNode(min->mat, min->x,\n                                      min->y, min->x + row[i],\n                                      min->y + col[i],\n                                      min->level + 1, min);\n                child->cost = calculateCost(child->mat, final);\n\n                // Add child to list of live nodes\n                pq.push(child);\n            }\n        }\n    }\n}\n\n\nint main() {\n    // Initial state\n    int x = 0, y = 0;\n    int initial[N][N] = {{}};\n\n    cin >> initial[0][0] >> initial[0][1] >> initial[0][2];\n    cin >> initial[1][0] >> initial[1][1] >> initial[1][2];\n    cin >> initial[2][0] >> initial[2][1] >> initial[2][2];\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if(initial[i][j] == 0)\n            {\n                x = i;\n                y = j;\n            }\n        }\n    }\n    solve(initial, x, y, final);\n    path -= 1;\n    cout << path << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define FOR(i,n) for(int i=0; i<n; ++i)\n#define GET(type,name) type name; std::cin >> name;\n\n\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <utility>\n#include <algorithm>\n#include <queue>\n#include <numeric>\n#include <unordered_map>\n\n\n    typedef std::vector<std::vector<int>> State;\n    const int N = 3;\n\n    State int_to_state(int c){\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n      FOR(i, N) {\n        FOR(j, N) {\n          int r = c%10;\n          c = c/10;\n          state[i][j] = r;\n        }\n      }\n      return state;\n    }\n    int state_to_int(State state) {\n      int c = 0;\n      int p = 1;\n      FOR(i, N) {\n        FOR(j, N) {\n          c += state[i][j] * p;\n          p *= 10;\n        }\n      }\n      return c;\n    }\n\n\n    void show(std::vector<std::vector<int>> state){\n      FOR(i, N) {\n        FOR(j, N) {\n          std::cout << state[i][j] << \" \";\n        }\n        std::cout << std::endl;\n      }\n    }\n\n    bool is_solved(const State& state) {\n      int N = state.size();\n\n      FOR(i, N) {\n        FOR(j, N) {\n          if(state[i][j] != (1 + 3*i + j)) return false;\n        }\n      }\n      return true;\n    }\n\n    std::vector<State> next_states_of(State state){\n      std::vector<State> res;\n      FOR(i,N){\n        FOR(j,N){\n          if(state[i][j] == 9){\n            State ns;\n            if(i<N-1){\n              ns = state;\n              std::swap(ns[i][j], ns[i+1][j]);\n              res.push_back(ns);\n            }\n            if(j<N-1){\n              ns = state;\n              std::swap(ns[i][j], ns[i][j+1]);\n              res.push_back(ns);\n            }\n            if(i>0){\n              ns = state;\n              std::swap(ns[i][j], ns[i-1][j]);\n              res.push_back(ns);\n            }\n            if(j>0){\n              ns = state;\n              std::swap(ns[i][j], ns[i][j-1]);\n              res.push_back(ns);\n            }\n            return res;\n          }\n        }\n    }\n\n    int solve_puzzle(State state){\n\n      std::priority_queue<\n        std::pair<int, int>,\n        std::vector<std::pair<int, int>>,\n        std::greater<std::pair<int, int>>\n      > q;\n      std::unordered_map<int, int> h;\n\n      q.push(std::make_pair(0, state_to_int(state)));\n\n      for(;not q.empty();){\n        auto d_s = q.top(); q.pop();\n        int d = d_s.first;\n        int st_int = d_s.second;\n        State state = int_to_state(d_s.second);\n//        show(state);\n\n        if(st_int == 987654321){\n//          std::cout << \"z\"<< std::endl;\n          return d;\n        }\n\n        if(h.find(st_int) == h.end()){\n          h[st_int] = d;\n          std::vector<State> next_states = next_states_of(state);\n          for(auto ns : next_states){\n            q.push(std::make_pair(d+1, state_to_int(ns)));\n          }\n        }\n      }\n      return -1;\n    }\n\n    int main(){\n      const int N = 3;\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n\n      FOR(i, N){\n        FOR(j, N){\n          GET(int, x);\n          if(x==0) x=9;\n          state[i][j] = x;\n        }\n      }\n//      show(state);\n//      int c = state_to_int(state);\n//      std::cout << c << std::endl;\n//      std::cout << \"?\" <<std::endl;\n//      State s2 = int_to_state(c);\n//      std::cout << \"!\" <<std::endl;\n//\n//      show(s2);\n//      int min_steps = rec_min_steps_\n      std::cout << solve_puzzle(state) << std::endl;\n      return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <queue>\nusing namespace std;\nconst int N = 3;\nconst int N2 = 9;\nconst int x[4] = {0, 0, 1, -1};\nconst int y[4] = {-1, 1, 0, 0};\nconst char ch[4] = {'l', 'r', 'd', 'u'};\n\nclass node{\npublic:\n\tint f[N2];\n\tint space;\n\tstring str;\n\tbool operator< (const node& n) const\n\t{\n\t\tfor (int i = 0; i < N2; ++i)\n\t\t{\n\t\t\tif (n.f[i] == f[i])\n\t\t\t\tcontinue;\n\t\t\treturn f[i] < n.f[i];\n\t\t}\n\t\treturn true;\n\t} \n};\n\nbool Is_Return(const node& n)\n{\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tif (n.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstring bfs(node& n)\n{\n\tqueue<node> Q;\n\tmap<node, bool> ans;\n\tQ.push(n);\n\tans[n] = true;\n\twhile (!Q.empty())\n\t{\n\t\tnode u = Q.front();\n\t\tQ.pop();\n\t\tif (Is_Return(u))\n\t\t\treturn u.str;\n\t\tint tx = u.space / N;\n\t\tint ty = u.space % N;\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint sx = tx + x[i];\n\t\t\tint sy = ty + y[i];\n\t\t\tif (sx < 0 || sy < 0 || sx >= N || sy >= N)\n\t\t\t\tcontinue;\n\t\t\tnode v = u;\n\t\t\tswap(v.f[v.space], v.f[sx * N + sy]);\n\t\t\tv.space = sx * N + sy;\n\t\t\tif (!ans[v])\n\t\t\t{\n\t\t\t\tans[v] = true;\n\t\t\t\tv.str += ch[i];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main()\n{\n\tnode n;\n\tfor (int i = 0; i < N2; ++i)\n\t{  \n\t\tcin >> n.f[i];\n\t\tif (n.f[i] == 0)\n\t\t{\n\t\t\tn.space = i;\n\t\t\tn.f[i] = N2;\n\t\t}\n\t}\n\tstring s = bfs(n);\n\tcout << s.length() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map> //I'm sorry to use map\n#include<algorithm>\nusing namespace std;\n\nstruct Puz{\n  int board[3][3];\n  int zx, zy; //coodinate of zero\n  int cnt;\n\n  bool operator < (const Puz &p)const{\n    for(int i = 0;i < 3;i++){\n      for(int j = 0;j < 3;j++){\n        if(board[i][j] == p.board[i][j]) continue;\n        return board[i][j] > p.board[i][j];\n      }\n    }\n    return false;\n  }\n\n  bool operator == (const Puz &p)const{\n    for(int i = 0;i < 3;i++){\n      for(int j = 0;j < 3;j++){\n        if(board[i][j] != p.board[i][j]) return false;\n      }\n    }\n    return true;\n  }\n};\n\n\n\nint d[5] = {0, -1, 0, 1, 0}; //direction\nPuz g = {{{1, 2, 3}, {4, 5, 6}, {7, 8, 0}}}; //goal\nmap<Puz, int> mem; //memory\n\n//queue\nint head, tail;\nPuz Q[30000];\n\nvoid enqueue(Puz x){\n\n  Q[tail] = x;\n\n  if(tail + 1 == 30000) tail = 0;\n  else tail++;\n}\n\nPuz dequeue(){\n\n  Puz x = Q[head];\n\n  if(head + 1 == 30000) head = 0;\n  else head++;\n\n  return x;\n}\n\n//solve\nint bfs(Puz s){\n\n  enqueue(s);\n  mem[s] = 1;\n\n  while(head != tail){\n    Puz p = dequeue(), q;\n\n    if(p == g) return p.cnt;\n\n    for(int i = 0;i < 4;i++){\n      int x = p.zx + d[i], y = p.zy + d[i + 1];\n\n      if(0 <= x && x < 3 && 0 <= y && y < 3){\n        q = p;\n        swap(q.board[q.zy][q.zx], q.board[y][x]);\n        q.zy = y;\n        q.zx = x;\n        q.cnt++;\n        if(!mem[q]++) enqueue(q); //memorizing\n      }\n    }\n  }\n\n  return 0;\n}\n\nint main(){\n\n  Puz s;\n\n  //input\n  for(int i = 0;i < 3;i++){\n    for(int j = 0;j < 3;j++){\n      cin >> s.board[i][j];\n      if(s.board[i][j] == 0){\n        s.zy = i;\n        s.zx = j;\n      }\n    }\n  }\n  s.cnt = 0;\n\n  //output\n  cout << bfs(s) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <vector>\n\nusing namespace std;\n\nclass Board {\n    friend bool operator==(const Board &b1, const Board &b2);\n    friend bool operator!=(const Board &b1, const Board &b2);\n\nprivate:\n    uint64_t board;\n\npublic:\n    Board() {\n        board = 0;\n    }\n\n    void set(int32_t r, int32_t c, int64_t v) {\n        uint32_t shift = 4 * (r * 3 + c);\n        uint64_t mask = 0xf;\n        board = (board & ~(mask << shift)) | (v << shift);\n        return;\n    }\n\n    int32_t get(int32_t r, int32_t c) const {\n        int32_t shift = 4 * (r * 3 + c);\n        return (board >> shift) & 0xf;\n    }\n\n    void swap(int32_t r1, int32_t c1, int32_t r2, int32_t c2) {\n        int32_t temp = get(r1, c1);\n        set(r1, c1, get(r2, c2));\n        set(r2, c2, temp);\n        return;\n    }\n\n    void show() const {\n        cout << hex << board << endl;\n    }\n};\n\nbool operator==(const Board &b1, const Board &b2) {return b1.board == b2.board;};\nbool operator!=(const Board &b1, const Board &b2) {return !(b1 == b2);}\n\nint32_t manhattan(const Board &board) {\n    int32_t d = 0;\n\n    for (int32_t r = 0; r < 3; r++) {\n        for (int32_t c = 0; c < 3; c++) {\n            int32_t v = board.get(r, c);\n            if (v != 0) d += abs(r - (v-1) / 3) + abs(c - (v-1) % 3);\n        }\n    }\n\n    return d;\n}\n\nvector<Board> children(const Board &board) {\n    vector<Board> c;\n    int32_t zr, zc;\n\n    for (int32_t z = 0; z < 9; z++) {\n        if (board.get(z/3, z%3) == 0) {\n            zr = z/3;\n            zc = z%3;\n            break;\n        }\n    }\n\n    array<int32_t, 4> dr = {1, 0, -1, 0}, dc = {0, 1, 0, -1};\n\n    for (int32_t i = 0; i < 4; i++) {\n        if (0 <= zr+dr[i] && zr+dr[i] < 3 && 0 <= zc+dc[i] && zc+dc[i] < 3) {\n            Board board_new = board;\n            board_new.swap(zr, zc, zr+dr[i], zc+dc[i]);\n            c.push_back(board_new);\n        }\n    }\n\n    return c;\n}\n\nbool dfs(const Board &board, const Board &parent, int32_t depth, int32_t dist, int32_t limit) {\n    if (dist == 0) {\n        cout << depth << endl;\n        return true;\n    }\n\n    if (depth + dist > limit) return false;\n\n    bool flag = false;\n    for (Board child : children(board)) {\n        if (child != parent) {\n            if (dfs(child, board, depth + 1, manhattan(child), limit)) {\n                flag = true;\n                break;\n            }\n        }\n    }\n\n    return flag;\n}\n\n\nint main() {\n    Board board;\n\n    for (int32_t r = 0; r < 3; r++) {\n        for (int32_t c = 0; c < 3; c++) {\n            int32_t v;\n            cin >> v;\n            board.set(r, c, v);\n        }\n    }\n\n    int32_t limit = 0;\n\n    while (!dfs(board, board, 0, manhattan(board), limit)) limit++;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/////////////////////////////////////////////////////////\n//\n//  ~/Izumi_Chiharu/c/temp.cpp file\n//  Last Updated: 2018-06-17 ...Maybe\n//\n//    I hope you adding this code to the setting file\n//    alias g++='g++ -std=c++1y -DDEBUG_LOCAL'\n//\n//  My sweet heart Chiharu Izumi\n//\n/////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid print_Qbey(){cout<<\n\"           H                                           M#5J~d              \"  <<endl<<\n\"         Hm.?WMM                                   MMB^ .Z  d              \"  <<endl<<\n\"         MZS.` ?7WMM                             M#=`` (!`` d              \"  <<endl<<\n\"         HP?X,```  ?TMM                       MMY! ` .d: `` d              \"  <<endl<<\n\"         Hb;<U,`````` (TMM                 HM ^ ``` .V>_` `.W              \"  <<endl<<\n\"           ;><?n. `` ````?WHHMMHHHMMMMMM MMY```` ` (3<< `` .M              \"  <<endl<<\n\"         HN<>>>?W,`` `` ` (77!~`  ```~!?7'``` `` .d>>><``  .M              \"  <<endl<<\n\"          M2<>>>>?n.`` `` `` `` ``` `` ```` `` `.X>1++< `` (H              \"  <<endl<<\n\"          MK<>>>>+?S.``` `` ```` ``` ``` `` `` .Z``` ?4-.` jM              \"  <<endl<<\n\"           N2><+d=(Y^ `` `` ` ` ` ` `` `` `` `` T~.`````?=(dM              \"  <<endl<<\n\"           MR;JY~`~``` `` `` ``` ``` `` `` `` ``` u, `` `` 7M              \"  <<endl<<\n\"            NV!_`` `` `` ```` ``` `` `` `` ``` ``` C& ` ```` TMM           \"  <<endl<<\n\"           MY.(-`` ` `` ``  `` ` `` `` `` `` ``  `` (n ` ` ``` 7M          \"  <<endl<<\n\"         HMD-(D`` ``` `` ``` `` `` `` `` `` ` ``` ```(n ` `` `` (WM        \"  <<endl<<\n\"         M _(d```` `` ``` ``` ``` `` `` `` ``` ``` `` .b.`` `` ```?MH      \"  <<endl<<\n\"        MM!_(%` `` `` `` ` ` `` `` `` ``` `` `` ` `` ` (l`` ``````` TMH    \"  <<endl<<\n\"       H#>__d:`` .JXVS, ``` `` ` `` `` `.JXWH&.``` ```` O; `` ` ` `` -WM   \"  <<endl<<\n\"       M%.~(k ``.HXH[ dr ```` ``` `` `` dWWN- u. `` ``` ,M,``` ``` ``` ?MMM\"  <<endl<<\n\"      MF_~~($`` .WXMMWX$ ` ``` `` ``` ` dXM HHK````` `` ,HN-``````````.-=jg\"  <<endl<<\n\"MMMMHMY.~~~(R ``` 799Y!```` ``` `` `` `` ?UUUY!`` ````` (M N, `` ```.Z3J=``\"  <<endl<<\n\"gaJJdD.~~::_X|`````````````` `````` `` ` ``` ````` ``` .H  MN,``` .Yiv! ```\"  <<endl<<\n\"   MD_:~:~:~(T.`````````` ``` ` ` ````` ``` ``` ``````.M     N, .Ziv!`` ._~\"  <<endl<<\n\" MM'_:::::::~(N+.`````````` .`.(.` .` ``` ```` ```` .dM       NZ1v! .-_~~``\"  <<endl<<\n\" #:(::::::::~(HMNa..  ``````_?!`?7! `` ````  ...-(+7WMM     HM3(b _:<``..`.\"  <<endl<<\n\"=_;::::::::<(H    MMHaJ--_--........-.__~~~~(&v7<~``` ?MM   M>gM9h,_.......\"  <<endl<<\n\";;;;;;;:;::(drWM          HHmgggg&gzOtOzz<<~~~~~_`` ``` ?MMMH+ggM Mm-......\"  <<endl<<\n\"e<>>;>>;;><dMMJM                  Nc_~~~~~~~~~~_ ``  ` `` 7H&-...?THNe-_._(\"  <<endl<<\n\",4m+>>>>>>j MM(W                   N-~~~~~~~~:_`` ``` ` ``  ?7UHHqqHWHMm+__\"  <<endl<<\n\"vX+vT4k&&dMMD!+M                   MR_~~~~~:_````` ```` ````````` ````  ?We\"  <<endl<<\n\"???zTwiJ-(((JdM                    MK_~~~~:_``` ` ` ` `` ` ` ` ``` ```````?\"  <<endl<<\n\"1uukgHM                            MH_~~~_``` `` ``` `` `` `` ` `` ` `  ```\"  <<endl<<\n\"CugM                                N;~~:_ ` `` `` ``` `` ````` ``` ``` ` `\"  <<endl<<\n\"H                                   M[~~~_4, `   ` `` `` ``  ``` `` `` ``` \"  <<endl<<\n\"                                    Hb~~~~~?n  (: `` `` `` `` ` ` `` `` ```\"  <<endl<<\n\"                                    Hb~~~~~~(4,J_ `` ```  ```` ``` `` `` ` \"  <<endl<<\n\"                                     N-~~~~~~(MM_` `` ` (}  `` `` `` `` ```\"  <<endl<<\n\"                                     Mr_~~~~~(HH: `` `` j!`` `` `` `` `` ``\"  <<endl<<\n\"                                     Mb~~~~~~(WH:`` `` .Z `` `` `` ``` `` `\"  <<endl<<\n\"                                      N:~~~~~(WM{ `` ` .H+.. `` `  .``` `` \"  <<endl;}\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n//#define int long long\n\n#define _overload3(_1,_2,_3,name,...) name\n#define _REP(i,n) REAP(i,0,n)\n#define REAP(i,a,b) for(int i=int(a);i<int(b);++i)\n#define REP(...) _overload3(__VA_ARGS__,REAP,_REP,)(__VA_ARGS__)\n\n#define _REPR(i,n) REAPR(i,n,0)\n#define REAPR(i,a,b) for(int i=int(a-1);i>=int(b);--i)\n#define REPR(...) _overload3(__VA_ARGS__,REAPR,_REPR,)(__VA_ARGS__)\n\n#define ALL(a) a.begin(),a.end()\n#define rALL(a) a.rbegin(),a.rend()\n\n#define coutALL(a) {int loop_coutALL=0;for(auto e:a) cout<<(loop_coutALL++?\" \":\"\")<<e; cout<<endl;}\n#define coutYN(a) cout<<(a?\"Yes\":\"No\")<<endl;\n#define coutyn(a) cout<<(a?\"yes\":\"no\")<<endl;\n\n#define pcnt __builtin_popcount\n#define buli(x) __builtin_popcountll(x)\n\nconst int INF=1145141919;\nconst int MOD=(int)1e9+7;\nconst double EPS=1e-12;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const int dx[]={-1,-1,-1,0,1,1,1,0},dy[]={-1,0,1,1,1,0,-1,-1};\n\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\n\ntypedef pair<int,int> pii;\ntypedef pair<int,string> pis;\ntypedef pair<string,int> psi;\ntypedef pair<string,string> pss;\n\ntypedef long long ll;\n\ntemplate<class T> ll upper(T n,T m){return (n+m-1)/m;};\ntemplate<class T> ll rounding(T n){return (long double)n+0.5;};\n\ninline int qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a;a=1ll*a*a;}while(b>>=1);return ans;}\ninline int qp(int a,ll b,int mo){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}\n\nstruct Arithmetic{Arithmetic(){cin.tie(0);ios::sync_with_stdio(0);cout<<fixed<<setprecision(20);}};\n\n//#define DEBUG_LOCAL\n\n#ifdef DEBUG_LOCAL\ntemplate<typename T> void deb(T a){cerr<<\"deb: \"<<a<<\"ですねぇ！\"<<endl;}\n#define debl {cerr<<\"debug: \"<<__LINE__<<\"行目だよーんおほほ\"<<endl;}\nvoid what_cr(){cout<<__GCC_ATOMIC_CHAR16_T_LOCK_FREE<<\" ←なんだろーこの数字？\"<<endl;}\nvoid t_t(){cout\n    <<endl\n    <<\"------------------------\"<<endl\n    <<\"| Presented by         |\"<<\" Compiled \"<<__FILE__<<endl\n    <<\"| \"<<__DATE__<<\" \"<<__TIME__<<\" |\"<<endl\n    <<\"|        Chiharu Izumi |\"<<\"      to get the AC :)\"<<endl\n    <<\"------------------------\"<<endl;\n}\n#else\ntemplate<typename T>void deb(T a){}\n#define debl ;\nvoid what_cr(){}void t_t(){}\n#endif\n\nvvi pz0(3,vi(3,0));\nint ans=32;\nmap <vvi,int> tf;\n\nint find0(vvi pz){\n\n  REP(i,3) REP(j,3) if(pz[i][j]==0) return i*3+j;\n\n}\n\nvoid print(vvi pz){\n\n  REP(i,3){\n    REP(j,3){\n      if(j) cout<<\" \";\n      cout<<pz[i][j];\n    }\n    cout<<endl;\n  }\n\n}\n\nvoid dfs(vvi pz,int how){\n\n  if(tf[pz]) return;\n  tf[pz]=1;\n\n  if(how>31) return;\n  if(pz0==pz){\n\n    ans=min(ans,how);\n    return;\n\n  }\n\n  int x=find0(pz)%3;\n  int y=find0(pz)/3;\n\n  /*\n  deb(find0(pz));\n  print(pz);\n  cout<<endl;\n  */\n\n  REP(i,4){\n\n    int x0=x+dx[i];\n    int y0=y+dy[i];\n\n    if(x0<0 || x0>2) continue;\n    if(y0<0 || y0>2) continue;\n\n    swap(pz[y][x],pz[y0][x0]);\n    dfs(pz,how+1);\n    swap(pz[y][x],pz[y0][x0]);\n\n  }\n\n}\n\nsigned main(){\n\n  Arithmetic Exception;\n\n  vvi pz(3,vi(3,0));\n\n  REP(i,9) pz0[i/3][i%3]=(i+1)%9;\n  REP(i,9) cin>>pz[i/3][i%3];\n\n  dfs(pz,0);\n\n  cout<<ans<<endl;\n\n  return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<set>\n#include<queue>\nusing namespace std;\nset<long long> s;\nint map1[10][10];\nint k[10];\nint t;\nqueue<long long> x,y;\nvoid input(){\n\tint g=0;\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tcin>>map1[i][j];\n\t\t\tg=g*10+map1[i][j];\n\t\t}\n\t}\n\ts.insert(g);\n\tx.push(g);\n\ty.push(0);\n}\nvoid syf(){\n\twhile(!x.empty()){\n\t\tif(x.front()==123456780){\n\t\t\tcout<<y.front()<<endl;\n\t\t\treturn;\n\t\t}\n\t\tint g=x.front(),tot=0,kl=-1;\n\t\twhile(g!=0){\n\t\t\tif(g%10==0) kl=tot;\n\t\t\tk[tot++]=g%10;\n\t\t    g/=10;\n\t\t}\n\t\tif(kl==-1) {\n\t\t\tkl=tot;\n\t\t\tk[tot++]=0;\n\t\t}\n\t\tif(kl%3>0){\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl-1];\n\t\t\tk[kl-1]=t;\n\t\t\tlong long ss=0;\n\t\t\tfor(int i=tot-1;i>=0;--i){\n\t\t\t\tss=ss*10+k[i];\n\t\t\t}\n\t\t\tif(s.count(ss)==0){\n\t\t\t\tx.push(ss);\n\t\t\t\ty.push(y.front()+1);\n\t\t\t\ts.insert(ss);\n\t\t\t}\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl-1];\n\t\t\tk[kl-1]=t;\n\t\t}\n\t\tif(kl%3<2){\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl+1];\n\t\t\tk[kl+1]=t;\n\t\t\tlong long ss=0;\n\t\t\tfor(int i=tot-1;i>=0;--i){\n\t\t\t\tss=ss*10+k[i];\n\t\t\t}\n\t\t\tif(s.count(ss)==0){\n\t\t\t\tx.push(ss);\n\t\t\t\ty.push(y.front()+1);\n\t\t\t\ts.insert(ss);\n\t\t\t}\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl+1];\n\t\t\tk[kl+1]=t;\t\t\t\n\t\t}\n\t\tif(kl+3<=8){\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl+3];\n\t\t\tk[kl+3]=t;\n\t\t\tlong long ss=0;\n\t\t\tfor(int i=tot-1;i>=0;--i){\n\t\t\t\tss=ss*10+k[i];\n\t\t\t}\n\t\t\tif(s.count(ss)==0){\n\t\t\t\tx.push(ss);\n\t\t\t\ty.push(y.front()+1);\n\t\t\t\ts.insert(ss);\n\t\t\t}\t\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl+3];\n\t\t\tk[kl+3]=t;\t\t\n\t\t}\n\t\tif(kl-3>=0){\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl-3];\n\t\t\tk[kl-3]=t;\n\t\t\tlong long ss=0;\n\t\t\tfor(int i=tot-1;i>=0;--i){\n\t\t\t\tss=ss*10+k[i];\n\t\t\t}\n\t\t\tif(s.count(ss)==0){\n\t\t\t\tx.push(ss);\n\t\t\t\ty.push(y.front()+1);\n\t\t\t\ts.insert(ss);\n\t\t\t}\t\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl-3];\n\t\t\tk[kl-3]=t;\t\t\t\n\t\t}\n\t\tx.pop();\n\t\ty.pop();\n\t}\n}\nint main(){\n\tinput();\n\tsyf();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\n struct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const {\n    for(int i=0;i<N2;i++) {\n      if(f[i]==p.f[i])continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const char dir[4] = {'u','l','d','r'};\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\n\nbool isTarget(Puzzle p) {\n  for(int i=0;i<N2;i++)\n  if(p.f[i] != (i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s ) {\nqueue<Puzzle> Q;\nmap<Puzzle,bool> V;\nPuzzle u,v;\ns.path = \"\";\nQ.push(s);\nV[s] = true;\n\nwhile(!Q.empty()) {\n  u = Q.front();Q.pop();\n  if(isTarget(u)) return u.path;\n  int sx = u.space / N;\n  int sy = u.space % N;\n  for(int r = 0;r<4 ; r++) {\n    int tx = sx + dx[r];\n    int ty = sy + dy[r];\n    if(tx < 0 || ty < 0|| tx>=N || ty >= N) continue;\n    v = u;\n    swap(v.f[u.space], v.f[tx *N+ty]);\n    v.space = tx * N + ty;\n    if(!V[v]) {\n      V[v] = true;\n      v.path  += dir[r];\n      Q.push(v);\n    }\n  }\n}\nreturn \"unsolvable\";\n}\n\nint main() {\n  Puzzle in;\n\n  for(int i=0;i<N2;i++) {\n    cin >> in.f[i];\n    if(in.f[i]==0) {\n      in.f[i]=N2;\n      in.space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size()<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <map>\n#include <cstdio>\nusing namespace std;\n#define X 3\n#define Y 3\n#define THRESHOLD 2\nint manhattan(int x1,int y1,int x2,int y2){\n\treturn abs(x1-x2)+abs(y1-y2);\n}\nint calc(vector<int>&v){\n\tint s=0;\n\tfor(int coor=0;coor<X*Y;coor++){\n\t\tif(v[coor]!=0){\n\t\t\ts+=manhattan(coor%X,coor/X,(v[coor]-1)%X,(v[coor]-1)/X);\n\t\t}else{\n\t\t\ts+=manhattan(coor%X,coor/X,X-1,Y-1);\n\t\t}\n\t}\n\treturn s;\n}\nint main(){\n\tint i=1,start_point;\n\tvector<int>start(X*Y),goal;\n\tfor(;i<X*Y;i++)goal.push_back(i);goal.push_back(0);\n\tfor(i=0;i<X*Y;i++){\n\t\tscanf(\"%d\",&start[i]);\n\t\tif(start[i]==0)start_point=i;\n\t}\n\tif(start==goal){puts(\"0\");return 0;}\n\n\tmap<vector<int>,pair<int,int> >mstart,mgoal;\n\tqueue<pair<vector<int>,bool> >q;\n\tmstart[start]=make_pair(start_point,0);\n\tmgoal[goal]=make_pair(X*Y-1,0);\n\tq.push(make_pair(start,false));\n\tq.push(make_pair(goal,true));\n\tfor(;!q.empty();){\n\t\tvector<int> v=q.front().first;\n\t\tbool f=q.front().second;\n\t\tq.pop();\n\t\tint val=calc(v);\n\t\tmap<vector<int>,pair<int,int> >&m=f?mgoal:mstart;\n\t\tmap<vector<int>,pair<int,int> >&m2=f?mstart:mgoal;\n\t\tint coor=m[v].first,x=coor%X,y=coor/X;\n\t\tint depth=m[v].second;\n\t\tif(0<x){\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor-1,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t}\n\t\tif(x<X-1){\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor+1,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t}\n\t\tif(0<y){\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor-X,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t}\n\t\tif(y<Y-1){\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor+X,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p)const{\n    for(int i = 0; i < N2; i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i = 0; i < N2; i++)\n    if(p.f[i] != (i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r = 0; r < 4; r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if(!V[v]){\n\tV[v] = true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i = 0; i < N2; i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 3;\nconst int LIMIT = 100;\nint dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\nint limit;\nint puz[N*N];\nint zero;\nint esti;\nint MDT[N*N][N*N];\n\nint dfs(int dep, int pre) {\n\tif ( esti == 0 ) return dep;\n\tif ( dep+esti >= limit ) return LIMIT;\t\n\n\tint ret = LIMIT;\n\tfor ( int i = 0; i < 4; i++ ) {\n\t\tif ( (i+2)%4 == pre ) continue;\n\t\tint y = zero/N, x = zero%N;\n\t\tint ny = y+dy[i], nx = x+dx[i];\n\t\tif ( ny < 0 || nx < 0 || ny >= N || nx >= N ) continue;\n\t\tint tmp[N*N];\n\t\tint tmp_zero  = zero;\n\t\tint tmp_esti = esti;\t\t\n\t\tfor ( int j = 0; j < N*N; j++ ) tmp[j] = puz[j];\n\t\tint ch_id = ny*N+nx;\n\t\tint ch_dat = puz[ch_id];\t\t\n\t\testi -= MDT[zero][N*N-1];\n\t\testi -= MDT[ny*N+nx][ch_dat];\n\t\testi += MDT[zero][ch_dat];\n\t\testi += MDT[ny*N+nx][N*N-1];\n\t\tswap(puz[zero], puz[ch_id]);\n\t\tzero = ch_id;\t\t\n\t\tret = min(ret, dfs(dep+1, i));\n\t\tfor ( int j = 0; j < N*N; j++ ) puz[j] = tmp[j];\n\t\tzero = tmp_zero;\n\t\testi = tmp_esti;\t\t\n\t}\n\n\treturn ret;\n}\n\nint main() {\n\tfor ( int i = 0; i < N*N; i++ ) {\n\t\tfor ( int j = 0; j < N*N; j++ ) {\n\t\t\tMDT[i][j] = abs(i/N-j/N) + abs(i%N-j%N);            \n\t\t}\n\t}\n\n\tfor ( int i = 0; i < N*N; i++ ) {\t\t\n\t\tcin >> puz[i];\n\t\tif ( puz[i] == 0 ) {\n\t\t\tzero = i;\n\t\t\tpuz[i] = N*N-1;\t\t\t\n\t\t} else {\n\t\t\tpuz[i]--;\n\t\t}\n\t\testi += abs(i/N-puz[i]/N) + abs(i%N-puz[i]%N);        \n\t}\n\n\tfor ( int i = esti; i <= LIMIT; i++ ) {\n\t\tlimit = i;\n\t\tint ans = dfs(0, -1);\n\t\tif ( ans < 100 ) {\n\t\t\tcout << ans << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n// ????????¨?????????24????????±??????????????????\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 23;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nint getAllMD(Puzzle p)\n{\n    int dist = 0;\n    int x, y;\n    int ux, uy;\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] == N2) continue; // ??????0??????\n        x = p.f[i] / N;\n        y = p.f[i] % N;\n        ux = i / N;\n        uy = i % N;\n        dist += abs(x - ux) + abs(y - uy);\n    }\n    return dist;\n}\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i + getAllMD(in)) {\n        return;\n    }\n\n    if (in.path == \"ldrd\")\n        int debug = 0;\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n        /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nclass state{\npublic:\n  int* num;\n  int time;\n\n  state(){\n    num = new int[9];\n  }\n\n  state(int time){\n    num = new int[9];\n    this->time = time;\n  }\n\n  state(const state &st){\n    num = new int[9];\n    for(int i=0; i<9; i++) num[i]=st.num[i];\n    time = st.time;\n  }\n\n  ~state(){\n    delete[] num;\n  }\n\n  bool check(){\n    bool flag=true;\n    for(int i=0; i<8; i++){\n      if(num[i]!=i+1) flag=false;\n    }\n    return flag&&(num[8]==0);\n  }\n\n  //コード1~12を指定して、パズルを移動させる\n  state operate(int i){\n    state ns=*this;\n    assert(1<=i && i<=12);\n    switch (i) {\n      case 1: ns.swap(0, 1); break;\n      case 2: ns.swap(1, 2); break;\n      case 3: ns.swap(3, 4); break;\n      case 4: ns.swap(4, 5); break;\n      case 5: ns.swap(6, 7); break;\n      case 6: ns.swap(7, 8); break;\n      case 7: ns.swap(0, 4); break;\n      case 8: ns.swap(1, 5); break;\n      case 9: ns.swap(2, 6); break;\n      case 10: ns.swap(3, 6); break;\n      case 11: ns.swap(4, 7); break;\n      case 12: ns.swap(5, 8); break;\n    }\n    ns.time=time+1;\n    return ns;\n  }\n\nprivate:\n  //numのn1番目の要素とn2番目の要素を入れ替える\n  void swap(int n1, int n2){\n    int temp=num[n1];\n    num[n1]=num[n2];\n    num[n2]=temp;\n  }\n};\nint main(){\n  state start(0);//初期状態の生成\n  for(int i=0; i<9; i++) cin >> start.num[i];\n\n  //bfs用のqueue生成\n  queue<state> q; q.push(start);\n\n  //queueが空になるまで\n  while(!q.empty()){\n    state now=q.front(); q.pop();\n\n    //もし取り出した状態が所望の状態ならかかった回数を表示して終了\n    if(now.check()){\n      cout << now.time << endl;\n      break;\n    }\n\n    for(int i=1; i<=12; i++){\n      q.push(now.operate(i));\n    }\n\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n#if defined(_MSC_VER) || defined(ONLINE_JUDGE)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define FOR(i, m, n) for(int i=(m); i<(n); ++i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define mp make_pair\n#define pb push_back\n#define dump(x) cerr << #x << \" = \" << (x) << endl;\n\nusing namespace std;\nusing LL=long long;\nusing VI=vector<int>;      using VL=vector<LL>;\nusing VS=vector<string>;   using VD=vector<double>;\nusing VVI=vector<VI>;      using VVL=vector<VL>;\nusing PII=pair<int, int>;  using PLL=pair<LL, LL>;\nconst int inf = (int)1e9;  const double pi = acos(-1.0);\nconst LL MOD = 1000000007; const string Snum = \"0123456789\";\nconst int dx[] = { -1,0,1,0,-1,-1,1,1 }, dy[] = { 0,1,0,-1,-1,1,-1,1 };\n\ntemplate<class T>void Sort(T& a) { sort(all(a)); }\ntemplate<class T>void RSort(T& a) { sort(rall(a)); }\ntemplate<class T>void Reverse(T& a) { reverse(all(a)); }\ntemplate<class T>void Unique(T& a) { a.erase(unique(all(a)), a.end()); }\ntemplate<class T>auto Max(const T& a) { return *max_element(all(a)); }\ntemplate<class T>auto Min(const T& a) { return *min_element(all(a)); }\ntemplate<class T>int MaxPos(const T& a) { return max_element(all(a)) - a.begin(); }\ntemplate<class T>int MinPos(const T& a) { return min_element(all(a)) - a.begin(); }\ntemplate<class T, class U>int Count(const T& a, U v) { return count(all(a), v); }\ntemplate<class T, class U>int Find(const T& a, U v) { auto pos = find(all(a), v); return pos == a.end() ? -1 : pos - a.begin(); }\ntemplate<class T, class U>U Sum(const T& a, U v) { return accumulate(all(a), v); }\ntemplate<class T, class U>int Lower(const T& a, U v) { return lower_bound(all(a), v) - a.begin(); }\ntemplate<class T, class U>int Upper(const T& a, U v) { return upper_bound(all(a), v) - a.begin(); }\ntemplate<class T, class P>int CountIf(const T& a, P f) { return count_if(all(a), f); }\ntemplate<class T, class P>void RemoveIf(T& a, P f) { a.erase(remove_if(all(a), f), a.end()); }\ntemplate<class T>T Age(T n, T m) { return (n + m - 1) / m; }\ntemplate<class T>T Gcd(T n, T m) { return m == 0 ? n : Gcd(m, n % m); }\ntemplate<class T>T Lcm(T n, T m) { return n / Gcd(n, m) * m; }\ntemplate<class T>T Pow(T a, T n) { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; }return r; }\ntemplate<class T>T Powmod(T a, T n, T m = MOD) { T r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r; }\nstring operator*(string s, int n) { string ret; rep(i, n)ret += s; return ret; }\n\n/* INPUT */\ntemplate<class T>T InputF() { T o; cin >> o; return o; }\ntemplate<> char InputF() {\n\tchar ret = '\\0', c = getchar_unlocked();\n\twhile (c != '\\0' && c != '\\n' && c != '\\t' && c != ' ') { ret = c; c = getchar_unlocked(); }\n\treturn ret;\n}\ntemplate<> string InputF() {\n\tstring ret; char c = getchar_unlocked();\n\twhile (c != '\\0' && c != '\\n' && c != '\\t' && c != ' ') { ret.push_back(c); c = getchar_unlocked(); }\n\treturn ret;\n}\ntemplate<> int InputF() {\n\tint ret = 0; bool neg = false; char c = getchar_unlocked();\n\tif (c == '-') { neg = true; c = getchar_unlocked(); }\n\twhile ('0' <= c && c <= '9') { ret = ret * 10 + (c - '0'); c = getchar_unlocked(); }\n\treturn neg ? -ret : ret;\n}\ntemplate<> LL InputF() {\n\tLL ret = 0; bool neg = false; char c = getchar_unlocked();\n\tif (c == '-') { neg = true; c = getchar_unlocked(); }\n\twhile ('0' <= c && c <= '9') { ret = ret * 10LL + (LL(c) - LL('0')); c = getchar_unlocked(); }\n\treturn neg ? -ret : ret;\n}\ntemplate<> double InputF() {\n\tdouble ret = 0, dp = 1; bool neg = false, adp = false; char c = getchar_unlocked();\n\tif (c == '-') { neg = true; c = getchar_unlocked(); }\n\twhile (('0' <= c && c <= '9') || c == '.') {\n\t\tif (c == '.') { adp = true; }\n\t\telse if (adp) { dp *= 0.1; ret += (c - '0') * dp; }\n\t\telse { ret = ret * 10.0 + (c - '0'); }\n\t\tc = getchar_unlocked();\n\t}\n\treturn neg ? -ret : ret;\n}\nstring GetLine() {\n\tstring ret; char c = getchar_unlocked();\n\twhile (c != '\\0' && c != '\\n') { ret.push_back(c); c = getchar_unlocked(); }\n\treturn ret;\n}\n\ntemplate<class T>T StoT(string s) { return s; }\ntemplate<> char StoT(string s) { return s.front(); }\ntemplate<> string StoT(string s) { return s; }\ntemplate<> int StoT(string s) { return stoi(s); }\ntemplate<> LL StoT(string s) { return stoll(s); }\ntemplate<> double StoT(string s) { return stod(s); }\n\nVS InputB;\ntemplate<class T>struct InputC {\n\toperator T() { return InputF<T>(); }\n\tvector<T> operator[](int h) {\n\t\tvector<T> ret(h);\n\t\trep(i, h)ret[i] = InputF<T>();\n\t\treturn ret;\n\t}\n\tvector<vector<T>> operator[](PII p) {\n\t\tint h, w; tie(h, w) = p;\n\t\tvector<vector<T>> ret(h, vector<T>(w));\n\t\trep(i, h)rep(j, w)ret[i][j] = InputF<T>();\n\t\treturn ret;\n\t}\n\tT at(int n) {\n\t\twhile (sz(InputB) <= n)InputB.pb(InputF<string>());\n\t\treturn StoT<T>(InputB[n]);\n\t}\n\tvector<T> at(int n, int h) {\n\t\tvector<T> ret(h);\n\t\trep(i, h)ret[i] = at(i + n);\n\t\treturn ret;\n\t}\n\tvector<vector<T>> at(int n, int h, int w) {\n\t\tvector<vector<T>> ret(h, vector<T>(w));\n\t\trep(i, h)rep(j, w)ret[i][j] = at(n + i * w + j);\n\t\treturn ret;\n\t}\n};\nInputC<char> inc; InputC<string> ins; InputC<int> ini; InputC<LL> inl; InputC<double> ind;\n\n/* OUTPUT */\nclass ostreamfbuff : public basic_streambuf<char, char_traits<char>> {\nprotected:int overflow(int nCh = EOF) { putchar_unlocked(nCh); return 0; }\n};\nclass ostreamf : public basic_iostream<char, char_traits<char>> {\npublic:ostreamf(void) : basic_iostream<char, char_traits<char>>(new ostreamfbuff()) {}\n};\nostreamf coutf; ostream& operator<<(ostream& ostr, InputC<string> i) { ostr << string(i); return ostr; }\nstruct BoolStr { string t, f; BoolStr(string _t, string _f) :t(_t), f(_f) {} }yes(\"yes\", \"no\"), Yes(\"Yes\", \"No\"), YES(\"YES\", \"NO\"), Yay(\"Yay!\", \":(\");\nstruct Divizer { string s; Divizer(string _s) :s(_s) {} }spc(\" \"), nosp(\"\"), comma(\",\"), lin(\"\\n\");\nstruct Output {\n\tbool flag = false; BoolStr bs; Divizer di;\n\tOutput(bool f, BoolStr b, Divizer d) :flag(f), bs(b), di(d) {}\n\ttemplate<class T>void print(T o) { coutf << o; }\n\tvoid print(double o) { printf(\"%.20f\", o); }\n\tvoid print(bool o) { coutf << (o ? bs.t : bs.f); }\n\ttemplate<class T, class U>void print(const pair<T, U>& o) {\n\t\tprint(o.first); coutf << di.s; print(o.second);\n\t}\n\ttemplate<class T>void print(const vector<T>& o) {\n\t\tfor (int i = 0; i < (int)o.size(); ++i) { if (i != 0)coutf << di.s; print(o[i]); }\n\t}\n\ttemplate<class T>void print(const vector<vector<T>>& o) {\n\t\tfor (int i = 0; i < (int)o.size(); ++i) { if (i != 0)coutf << '\\n'; print(o[i]); }\n\t}\n\ttemplate<class T, class U>void print(const map<T, U>& o) {\n\t\tcoutf << \"Map\"; for (auto a : o) { coutf << \" {\"; print(a); coutf << \"},\"; } coutf << '\\n';\n\t}\n\ttemplate<class T>void print(const set<T>& o) {\n\t\tcoutf << \"Set {\"; for (auto a : o) { print(a); coutf << \",\"; } coutf << \"}\\n\";\n\t}\n\ttemplate<class T>Output operator ,(T o) {\n\t\tif (flag)coutf << di.s; print(o); Output t(true, bs, di); return t;\n\t}\n\tOutput operator,(Output o) { coutf << '\\n'; return o; }\n\tOutput operator,(BoolStr b) { Output t(flag, b, di); return t; }\n\tOutput operator,(Divizer d) { Output t(flag, bs, d); return t; }\n}out(false, Yes, spc);\n\n/* ANSWER */\nstruct Answer {\n\tint mini = INT_MAX, maxi = INT_MIN, sumi = 0;\n\tLL minl = LLONG_MAX, maxl = LLONG_MIN, suml = 0;\n\tdouble mind = DBL_MAX, maxd = DBL_MIN, sumd = 0; int cnt = 0;\n\tvoid operator=(int n) { mini = min(mini, n); maxi = max(maxi, n); sumi += n; cnt++; }\n\tvoid operator=(LL n) { minl = min(minl, n); maxl = max(maxl, n); suml += n; cnt++; }\n\tvoid operator=(double n) { mind = min(mind, n); maxd = max(maxd, n); sumd += n; cnt++; }\n}ans;\n\n\nstruct Point {\n\tint x, y;\n\tPoint() :x(-1), y(-1) {}\n\tPoint(int _x, int _y) :x(_x), y(_y) {}\n\tPoint operator+() { return *this; }\n\tPoint operator-() { return { -x,-y }; }\n\tPoint operator+(const Point& p) { return { x + p.x,y + p.y }; }\n\tPoint operator-(const Point& p) { return { x - p.x,y - p.y }; }\n\tPoint operator*(const Point& p) { return { x * p.x,y * p.y }; }\n\tPoint operator/(const Point& p) { return { x / p.x,y / p.y }; }\n\tPoint operator+(int d) { return { x + d,y + d }; }\n\tPoint operator-(int d) { return { x - d,y - d }; }\n\tPoint operator*(int d) { return { x * d,y * d }; }\n\tPoint operator/(int d) { return { x / d,y / d }; }\n\tPoint& operator+=(const Point& p) { x += p.x; y += p.y; return *this; }\n\tPoint& operator-=(const Point& p) { x -= p.x; y -= p.y; return *this; }\n\tPoint& operator*=(const Point& p) { x *= p.x; y *= p.y; return *this; }\n\tPoint& operator/=(const Point& p) { x /= p.x; y /= p.y; return *this; }\n\tbool operator==(const Point& p) { return x == p.x && y == p.y; }\n\tbool operator!=(const Point& p) { return x != p.x || y != p.y; }\n\tPoint& set(int _x, int _y) { x = _x; y = _y; return *this; }\n\tPoint& set(const Point& p) { return *this = p; }\n\tint Dist(const Point& p) { return abs(x - p.x) + abs(y - p.y); }\n\tbool inBound(int H, int W) { return 0 <= x && x < W && 0 <= y && y < H; }\n\tarray<Point, 4> Adjacent4() {\n\t\tarray<Point, 4> ret = { Point(x,y + 1),Point(x,y + -1),Point(x + 1,y),Point(x + -1,y) };\n\t\treturn ret;\n\t}\n\tarray<Point, 8> Adjacent8() {\n\t\tarray<Point, 8> ret = { Point(x,y + 1),Point(x,y - 1),Point(x + 1,y),Point(x - 1,y),\n\t\t\tPoint(x + 1,y + 1),Point(x + 1,y + -1),Point(x - 1,y + 1),Point(x - 1,y - 1) };\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tVVI Map = ini[{3, 3}];\n\n\tqueue<VVI> q;\n\tq.push(Map);\n\tmap<VVI, int> flag;\n\tflag[Map] = 0;\n\n\tauto Check = [](VVI v) {\n\t\tbool flag = true;\n\t\trep(i, 3)rep(j, 3) {\n\t\t\tif (i == 2 && j == 2) {\n\t\t\t\tif (v[i][j] != 0)flag = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (v[i][j] != i * 3 + j + 1)flag = false;\n\t\t\t}\n\t\t}\n\t\treturn flag;\n\t};\n\n\tint Ans;\n\n\twhile (!q.empty()) {\n\t\tauto Fro = q.front(); q.pop();\n\t\tPoint Fro0; rep(i, 3)rep(j, 3)if (Fro[i][j] == 0)Fro0.set(j, i);\n\t\tif (Check(Fro)) {\n\t\t\tAns = flag[Fro]; break;\n\t\t}\n\n\t\tfor (auto P : Fro0.Adjacent4())if (P.inBound(3, 3)) {\n\t\t\tauto Next = Fro; swap(Next[Fro0.y][Fro0.x], Next[P.y][P.x]);\n\t\t\tif (!flag.count(Next)) {\n\t\t\t\tq.push(Next);\n\t\t\t\tflag[Next] = flag[Fro] + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tout, Ans, out;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define NUM 3\n#define PRUNING 50\n\ntypedef struct STATUS{\n    int num;\n    int board[NUM][NUM];\n}STATUS;\n\nbool checkfinish(STATUS in){\n    \n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            if (i == NUM - 1 && j == NUM - 1) return true;\n            if(in.board[i][j] != val++) return false;\n        }\n    }\n    return true;\n}\n\n\nint backtrack(STATUS in){\n\n    int x = 0, y = 0, ret = PRUNING;\n    STATUS out;\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    \n    if (in.num > ret) {\n        return ret;\n    }\n    \n    if (checkfinish(in)) {\n        return in.num;\n    }\n\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            if(in.board[i][j] == 0){\n                x = j;\n                y = i;\n            }\n        }\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (x + dx[i] >=0 && x+dx[i] < NUM && y+dy[i] >=0 && y+dy[i] < NUM) {\n            memcpy(&out, &in, sizeof(STATUS));\n            swap(out.board[y][x], out.board[y+dy[i]][x+dx[i]]);\n            out.num++;\n            ret = min(ret, backtrack(out));\n        }\n    }\n    return ret;\n}\n\n\nint main(){\n    \n    int val, ans;\n    \n    STATUS init;\n    init.num = 0;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            cin >> val;\n            init.board[i][j] = val;\n        }\n    }\n    \n    ans = backtrack(init);\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n\tint f[N2];\n\tint space;\n\tstring path;\n\t\n\tbool operator < (const Puzzle &p) const{\n\t\tfor(int i=0;i<N2;i++){\n\t\t\tif(f[i]==p.f[i]) continue;\n\t\t\treturn f[i]>p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4]={-1,0,1,0};\n\nstatic const int dy[4]={0,-1,0,1};\n\nstatic const char dir[4]={'u','a','d','r'};\n\nbool isTarget(Puzzle p){\n\tfor(int i=0;i<N2;i++){\n\t\tif(p.f[i]!=(i+1)) return false;\n\t}\n\treturn true;\n}\n\n\nstring bfs(Puzzle s){\n\tqueue<Puzzle> Q;\n\tmap<Puzzle,bool> V;\n\tPuzzle u,v;\n\ts.path=\"\";\n\tQ.push(s);\n\tV[s]=true;\n\t\n\twhile(!Q.empty()){\n\t\tu=Q.front();Q.pop();\n\t\tif(isTarget(u)) return u.path;\n\t\tint sx=u.space/N;\n\t\tint sy=u.space%N;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tint tx=sx+dx[r];\n\t\t\tint ty=sy+dy[r];\n\t\t\tif(tx<0||ty<0||tx>=N||ty>=N) continue;\n\t\t\tv=u;\n\t\t\tswap(v.f[u.space],v.f[tx*N+ty]);\n\t\t\tv.space=tx*N+ty;\n\t\t\tif(!V[v]){\n\t\t\t\tV[v]=true;\n\t\t\t\tv.path+=dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn \"unsolvable\";\n}\n\n\nint main(){\n\tPuzzle in;\n\t\n\tfor(int i=0;i<N2;i++){\n\t\tcin>>in.f[i];\n\t\tif(in.f[i]==0){\n\t\t\tin.f[i]=N2;\n\t\t\tin.space=i;\n\t\t}\n\t}\n\t\n\tstring ans = bfs(in);\n\t\n\tcout<<ans.size()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator < (const Puzzle &p) const{\n\t\tfor(int i=0;i<N2;i++){\n\t\t\tif(f[i] == p.f[i]) continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n\tfor(int i=0;i<N2;i++)\n\t\tif(p.f[i] != (i+1)) return false;\n\treturn  true;\n}\n\nstring bfs(Puzzle s){\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\n\twhile(!Q.empty()){\n\t\tu = Q.front(); Q.pop();\n\t\tif(isTarget(u)) return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif(!V[v]){\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"unsolvable\";\n}\n\nint main(){\n\tPuzzle in;\n\n\tfor(int i=0;i<N2;i++){\n\t\tcin >> in.f[i];\n\t\tif(in.f[i] == 0){\n\t\t\tin.f[i] = N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct puzzle{\n    int F[N2];\n    int space;\n    string path;\n    \n    bool operator < (const puzzle &p) const{\n        for(int i=0; i<N2;i++){\n            if(F[i]==p.F[i])continue;\n            return F[i] > p.F[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool Target(puzzle p){\n    for(int i=0; i<N2; i++)\n    if(p.F[i]!=(i+1)) return false;\n    return true;\n}\n\nstring bfs(puzzle s){\n    queue<puzzle> Q;\n    map<puzzle,bool> V;\npuzzle u,v;\ns.path=\"\";\nQ.push(s);\nV[s]=true;\n\nwhile(!Q.empty()){\n    u=Q.front(); Q.pop();\n    if(Target(u))return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    \n    for(int r=0; r<4; r++){\n        int tx=sx+dx[r];\n        int ty=sy+dy[r];\n        if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n        v=u;\n        swap(v.F[u.space],v.F[tx*N+ty]);\n        v.space=tx*N+ty;\n        if(!V[v]){\n            V[v]=true;\n            v.path +=dir[r];\n            Q.push(v);\n        }\n    }\n}\n\nreturn \"unsolvable\";\n}\n\nint main(){\n    puzzle in;\n    for(int i=0;i<N2;i++){\n        cin >> in.F[i];\n        if(in.F[i]==0){\n            in.F[i]=N2;\n                in.space=i;\n            }\n        }\n        string ans = bfs(in);\n        cout << ans.size() << endl;\n        \n        return 0;\n    }\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int INF = 1000000;\nint mapp[3+2][3+2],dx[4]={0,1,0,-1},dy[4]={-1,0,1,0};\nbool used[3+2][3+2];\nint x0,y0,ans(INF);\nvoid otpt(){\n\tfor(int i=0;i<3;i++){\n\t    for(int j=0;j<3;j++)\n\t        cout<<mapp[i][j]<<' ';\n\t    cout<<endl;\n\t}\n\tcout<<endl;\n\tcin.get();\n}\nvoid init(){\n\tfor(int i=0;i<3;i++)\n\t    for(int j=0;j<3;j++){\n\t    \tcin>>mapp[i][j];\n\t    \tif(!mapp[i][j]){\n\t    \t\tx0=i;\n\t    \t\ty0=j;\n\t    \t}\n\t    }\n}\nbool ook(){\n\tint a(1);\n\tfor(int i=0;i<3;i++){\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(mapp[i][j]!=a&&mapp[i][j]) return false;\n\t\t\telse ++a;\n\t\t}\n\t}\n\t//otpt();cout<<\"!!!!!!\"<<endl;\n\treturn true;\n}\nvoid dfs(int x,int y,int bs){\n\tint bf[3+2][3+2];\n\tfor(int i=0;i<3;i++)\n\t    for(int j=0;j<3;j++)\n\t        bf[i][j]=mapp[i][j];\n\tif(bs>ans) return;\n\telse{\n\t\tif(ook()){\n\t\t\t//cout<<\"233?\"<<endl;\n\t\t\tans=min(bs,ans);\n\t\t\treturn;\n\t\t} \n\t\t//cout<<'#'<<bs<<':'<<endl;otpt();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint xx(x+dx[i]),yy(y+dy[i]);\n\t\t\tif(xx>=0&&yy>=0&&xx<3&&yy<3&&!used[xx][yy]){\n\t\t\t\tswap(mapp[x][y],mapp[xx][yy]);\n\t\t\t\tused[xx][yy]=1;\n\t\t\t\tdfs(xx,yy,bs+1);\n\t            for(int i=0;i<3;i++)\n\t                for(int j=0;j<3;j++)\n\t                    mapp[i][j]=bf[i][j];\n\t\t\t\tused[xx][yy]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid sol(){\n\tdfs(x0,y0,0);\n\tcout<<ans<<endl;\n}\nint main(){\n\tinit();\n\tsol();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n\n#define N  3\n#define N2 9\n\nstatic const int dx[4]   = {-1,0,1,0};\nstatic const int dy[4]   = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator<(const Puzzle &p)const {\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\n\n\nbool isTarget(Puzzle x){\n  for(int i=0;i<N2;i++)\n    if(x.f[i]!=(i+1))   return false;\n    return true;\n}\n\nstring bfs(Puzzle start){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  start.path = \"\";\n  Q.push(start);\n  V[start] = true;\n\n  while(!Q.empty()){\n    u = Q.front(); Q.pop();\n    if(isTarget(u))return u.path;\n    int xStart = u.space / N;\n    int yStart = u.space % N;\n\n    for(int k=0;k<4;k++){\n\t    int xTarget = xStart + dx[k];\n\t    int yTarget = yStart + dy[k];\n\t    if(xTarget<0 || yTarget<0 || xTarget >=N || yTarget>=N) continue;\n\t    v = u;\n\t    swap(v.f[u.space],v.f[xTarget*N+yTarget]);\n\t    v.space = xTarget*N+yTarget;\n\t    if(!V[v]){\n\t      V[v] = true;\n\t      v.path += dir[k];\n\t      Q.push(v);\n\t    }\n    }\n  }\n  return NULL;\n}\n  \n\nint main(){\n  Puzzle in;\n  for(int i=0;i<N2;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]  = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout<<ans.size()<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < ( const Puzzle &p ) const {\n    for ( int i = 0; i < N2; i++ ) {\n      if ( f[i] == p.f[i] ) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n  for ( int i = 0; i < N2; i++ )\n    if ( p.f[i] != (i + 1) ) return false;\n  return true;\n}\n\nstring bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while ( !Q.empty() ) {\n    u = Q.front(); Q.pop();\n    if ( isTarget(u) ) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for ( int r = 0; r < 4; r++ ) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if ( !V[v] ) {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main() {\n  Puzzle in;\n\n  for ( int i = 0; i < N2; i++ ) {\n    cin >> in.f[i];\n    if ( in.f[i] == 0 ) {\n      in.f[i] = N2;  // set space\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define N  3\n#define N2 9\nusing namespace std;\nstruct Puzzle{\n\tint f[N2];\n\tint space;\n\tstring path;\n\tbool operator < (const Puzzle &p) const \n\t{\n\t\tfor (int i = 0; i < N2; ++i)\n\t\t{\n\t\t\tif (f[i] == p.f[i]) continue;\n\t\t\treturn f[i] < p.f[i];\t\t\t\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p)\n{\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tif (p.f[i] != (i+1)) return false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle s)\n{\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u,v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\twhile(!Q.empty())\n\t{\n\t\tu = Q.front(); Q.pop();\n\t\tif (isTarget(u)) return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r)\n\t\t{\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif( tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!V[v])\n\t\t\t{\n\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main()\n{\n\tPuzzle in;\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tcin>>in.f[i];\n\t\tif (in.f[i]==0) {\n\t\t\tin.space = i;\n\t\t\tin.f[i] = N2;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout<<ans.size()<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define N 3\n#define N2 9\n  \nstruct 8puzzle{\nint f[N2];\nint space;\nstring path;\n  \nbool operator < (const 8puzzle &p) const{\nfor(int i = 0; i < N2; i++){\nif(f[i] == p.f[i]) continue;\nreturn f[i] > p.f[i];\n}\nreturn false;\n}\n};\n  \nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n  \nbool isTarget(8puzzle p){\nfor(int i = 0; i < N2; i++)\nif(p.f[i] != (i + 1)) return false;\nreturn true;\n}\n  \nstring bfs(8puzzle s){\nqueue<8puzzle> Q;\nmap<8puzzle, bool> V;\n8puzzle u, v;\ns.path = \"\";\nQ.push(s);\nV[s] = true;\n  \nwhile(!Q.empty()){\nu = Q.front(); Q.pop();\nif(isTarget(u)) return u.path;\nint sx = u.space / N;\nint sy = u.space % N;\nfor(int r = 0; r < 4; r++){\nint tx = sx + dx[r];\nint ty = sy + dy[r];\nif(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\nv = u;\nswap(v.f[u.space], v.f[tx * N + ty]);\nv.space = tx * N + ty;\nif(!V[v]){\nV[v] = true;\nv.path += dir[r];\nQ.push(v);\n}\n}\n}\nreturn \"\";\n}\n  \nint main(){\n8puzzle in;\nfor(int i = 0; i < N2; i++){\ncin >> in.f[i];\nif(in.f[i] == 0){\nin.f[i] = N2;\nin.space = i;\n}\n}\nstring ans = bfs(in);\ncout << ans.size() << endl;\n  \nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <array>\n#include <set>\n#include <queue>\nusing namespace std;\n\n#define si static inline\n#define gcu getchar_unlocked\nsi int in() {\n\tint n = 0, c = gcu();\n\t// bool minus = false; if (c == '-') minus = true, c = gcu();\n\tdo {n = 10 * n + (c - '0'), c = gcu();} while (c >= '0');\n\treturn n; }\n\t// return minus ? -n : n; }\nsi void scan(char *s) {while (!isspace(*s++ = gcu()));}\n#define pcu putchar_unlocked\n#define svo si void out\ntemplate <typename T>\nsvo(T n) {\n\tstatic char buf[20];\n\tchar *p = buf;\n\t//if(n < 0) pcu('-'), n *= -1;\n\tif (!n) *p++ = '0';\n\telse while (n) *p++ = n % 10 + '0', n /= 10;\n\twhile (p != buf) pcu(*--p); }\nsvo(const char *s){while(*s)pcu(*s++);}\nsvo(char *s){while(*s)pcu(*s++);}\nsvo(char c){pcu(c);}\n//template <typename T>\n//svo(vector<T> &v){for(T &x:v)out(' '),out(x);out('\\n');}\n//svo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);out('\\n');}\ntemplate <typename head, typename... tail>\nsvo(head&& h, tail&&... t){out(h);out(move(t)...);}\n#undef svo\n#undef si\n\nstruct board {\n\tenum {size = 3};\n\tstruct pos {int r, c;};\n\ttypedef array<array<int, size>, size> arr;\n\tarr b;\n\tpos p;\n\tint max;\n\tint cnt = 0;\n\n\tint f(arr &a) {\n\t\tint l = 0;\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tint c = a[i][j];\n\t\t\t\tif (c == 0)\n\t\t\t\t\tc = size * size - 1;\n\t\t\t\telse\n\t\t\t\t\tc--;\n\t\t\t\tl += abs(i - c / 3) + abs(j - c % 3);\n\t\t\t}\n\t\treturn l;\n\t}\n\n\tvoid read() {\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tb[i][j] = in();\n\t\t\t\tif (!b[i][j])\n\t\t\t\t\tp.r = i, p.c = j;\n\t\t\t}\n\t\tmax = f(b);\n\t}\n\tvoid print() {\n\t\tfor (auto &r: b) {\n\t\t\tfor (int &c: r)\n\t\t\t\tout(&c == &r[0]?\"\":\" \", c);\n\t\t\tout('\\n');\n\t\t}\n\t\tout('\\n');\n\t}\n\n\n\tint solver() {\n\t\tset<arr> m;\n\t\tqueue<board> q;\n\t\tq.push(*this);\n\t\twhile (!q.empty()) {\n\t\t\tboard a = q.front();\n\t\t\tq.pop();\n//\t\t\ta.print();\n\t\t\tint dis = f(a.b);\n\t\t\tif (dis > max * 2.1 - a.cnt)\n\t\t\t\tcontinue;\n//\t\t\tout(dis, \"\\n\");\n\t\t\tauto it = m.find(a.b);\n\t\t\tif (it != m.end())\n\t\t\t\tcontinue;\n\t\t\tm.insert(a.b);\n\t\t\tif (!dis)\n\t\t\t\treturn a.cnt;\n\t\t\tpos to[] = {\n\t\t\t\ta.p.r + 1, a.p.c,\n\t\t\t\ta.p.r, a.p.c + 1,\n\t\t\t\ta.p.r - 1, a.p.c,\n\t\t\t\ta.p.r, a.p.c - 1\n\t\t\t};\n\t\t\tfor (pos o: to) {\n\t\t\t\tif (0 <= o.r && o.r < size && 0 <= o.c && o.c < size) {\n\t\t\t\t\tboard c = a;\n\t\t\t\t\tswap(c.b[a.p.r][a.p.c], c.b[o.r][o.c]);\n\t\t\t\t\tc.p = o;\n\t\t\t\t\tc.cnt = a.cnt + 1;\n\t\t\t\t\tq.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\nint main() {\n\tboard b;\n\tb.read();\n\tout(b.solver(), '\\n');\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\nvector<int> searched[9];\n\nclass board{\npublic:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<int> tiles;\n\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        tiles = num;\n        REP(i, 9){\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n    }\n\n    int cost() {\n        return wrongs + moves;\n    }\n\n    void board_to_int(){\n        int k = 0;\n        REP(i, 9)\n            k += (tiles[i] * pow(10, i));\n        for(int i = searched[tiles[0]].size(); i > 0 ; i--)\n            if(k == searched[tiles[0]][i-1])\n                return;\n        pq.push(board(tiles, moves+1));\n        searched[tiles[0]].push_back(k);\n        return;\n    }\n\n    void move() {\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\nbool operator< (board b1, board b2){\n    return (b1.cost() > b2.cost()) ? true : false;\n}\n\nint solve(){\n    pq.push(board(original, 0));\n    while(1){\n        auto target = pq.top();\n        pq.pop();\n        if(target.wrongs == 0)\n            return target.cost();\n        target.move();\n    }\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = solve();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iterator>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nnamespace eight_puzzle{\n\ttypedef unsigned int uint;\n\tconst int N = 3;\n\tstruct State{\n\t\tState(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t}\n\t\tState(const uint tt,const uint tn){\n\t\t\ttable = tt;\n\t\t\tn = tn;\n\t\t}\n\n\t\tState& operator=(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t\treturn (*this);\n\t\t}\n\t\tbool isfinished(){\n\t\t\t\treturn table == 123456780;\n\t\t}\n\t\t\n\t\tuint table;\n\t\tuint n;\n\t};\n\tuint arraytovalue(int *table){\n\t\tuint t=0;\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tt*=10;\n\t\t\tt=t+table[i];\n\t\t}\n\t\treturn t;\n\t}\n\tvoid getnextstate(const State &s,std::vector<State> &states){\n\t\tint table[N*N];\n\t\tint t = s.table;\n\t\tint zi,zj;\n\t\tfor(int i=N-1;i>=0;--i){\n\t\t\tfor(int j=N-1;j>=0;--j){\n\t\t\t\tint panel = t-t/10*10;\n\t\t\t\ttable[i*N+j] = panel;\n\t\t\t\tt/=10;\n\t\t\t\tif(panel==0){\n\t\t\t\t\tzi = i;\n\t\t\t\t\tzj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=-1;i<=1;++i){\n\t\t\tfor(int j=-1;j<=1;++j){\n\t\t\t\tif((i+j)%2==0)continue;\n\t\t\t\tint ti = zi+i,tj=zj+j;\n\t\t\t\tif(0<=ti&&ti<N&&0<=tj&&tj<N){\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t\tstates.push_back(State(arraytovalue(table),s.n+1));\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tstd::vector<uint> visited;\n\t\n};\n\nint main(){\n\tusing namespace eight_puzzle;\n\tint array[N*N];\n\tfor(int i=0;i<N*N;++i){\n\t\tstd::cin>>array[i];\n\t}\n\tState init(arraytovalue(array),0);\n\n\tstd::queue<State> Q;\n\tQ.push(init);\n\twhile(!Q.empty()){\n\t\tState s = Q.front();\n\t\tQ.pop();\n\t\tstd::vector<State> states;\n\t\tgetnextstate(s,states);\n\t\tfor(uint i=0;i<states.size();++i){\n\t\t\tif(states[i].isfinished()){\n\t\t\t\tstd::cout<<states[i].n<<std::endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(std::find(visited.begin(),visited.end(),states[i].table)==visited.end()){\n\t\t\t\tQ.push(states[i]);\n\t\t\t\tvisited.push_back(states[i].table);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n  \n#define tate 3\n#define yoko 3\n#define total 9\n#define TryCnt 45\n \nextern inline void down_0(void);    \nextern inline void up_0(void);      \nextern inline void right_0(void);   \nextern inline void left_0(void);    \n \nextern int  serch(int x, int y, int MaxCnt, int pre);\n \nint num = 0;        \nint val[total] ={}; \n \n \nint main( void )\n{\n  int i = 0;\n  int x,y = 0;\n     \n    \n  for(i=0; i<total; i++)\n    {\n      scanf(\"%d\",&val[i]);\n         \n      if(val[i] == 0)\n        {\n\t  num = i;\n        }\n    }\n     \n   \n  x = tate - (num/yoko) -1;\n  y = yoko - (num%yoko) -1;\n     \n  for(i=0; i<TryCnt; i++)\n    {\n      if( serch(x,y,i,4) == 1 )\n        {\n\t  printf(\"%d\\n\",i);\n\t  break;\n        }\n    }     \n     \n  return 0;\n}\n \nint serch(int x, int y, int MaxCnt, int pre)\n{\n  int result;\n  int i=0;\n     \n  if(MaxCnt < (x + y) )\n    {\n      return 0;\n    }\n     \n   \n  if(MaxCnt==0)\n    {\n      for(i=0; i<total-1; i++)\n        {\n\t  if(val[i] != (i+1))\n            {      \n\t      return 0;\n            }\n        }\n      return 1;\n    }\n     \n     \n  \n  for(i=0; i<4; i++)\n    {\n      result = 0;\n         \n      switch(i)\n        {\n\tcase 0:\n\t  if( (x > 0) && (pre != 3) )\n\t    {\n\t      down_0();\n                     \n\t      result = serch(x-1, y, MaxCnt-1, 0);\n                     \n\t      up_0();\n\t    }\n\t  break;\n                 \n\tcase 1:\n\t  if( (y > 0) && (pre != 2) )\n\t    {\n\t      right_0();\n                     \n\t      result = serch(x, y-1, MaxCnt-1, 1);\n                     \n\t      left_0();\n\t    }\n\t  break;\n                 \n\tcase 2:\n\t  if( (y < yoko -1 ) && (pre != 1) )\n\t    {\n\t      left_0();\n                     \n\t      result = serch(x, y+1, MaxCnt-1, 2);\n                     \n\t      right_0();\n\t    }\n\t  break;\n                 \n\tcase 3:\n\t  if( (x < tate -1 ) && (pre != 0) )\n\t    {\n\t      up_0();\n                     \n\t      result = serch(x+1, y, MaxCnt-1, 3);\n                     \n\t      down_0();\n\t    }\n\t  break;\n                 \n\tdefault:\n\t  break;\n        }\n         \n      if(result)\n        {\n\t  return 1;\n        }\n    }\n     \n  return 0;\n}\n \n \ninline void down_0()\n{\n  val[num] = val[num + yoko];\n  num = num + yoko;\n}\n  \ninline void up_0()\n{\n  val[num] = val[num - yoko];\n  num = num - yoko;\n}\n  \ninline void right_0()\n{\n  val[num] = val[num +1];\n  num = num + 1;\n}\n  \ninline void left_0()\n{\n  val[num] = val[num -1];\n  num = num - 1;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\nint f[N2];\nint space;\nstring path;\n\nbool operator < (const Puzzle &p)const{\nfor(int i=0;i<N2;i++){\nif(f[i]==p.f[i])continue;\nreturn f[i]>p.f[i];\n}\nreturn false;\n}\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\nfor(int i=0;i<N2;i++)\nif(p.f[i]!=(i+1))return false;\nreturn true;\n}\nstring bfs(Puzzle s){\nqueue<Puzzle>Q;\nmap<Puzzle,bool>V;\nPuzzle u,v;\ns.path=\"\";\nQ.push(s);\nV[s]=true;\nwhile(!Q.empty()){\n  u=Q.front();\n  Q.pop();\n  if(isTarget(u))return u.path;\n  int sx=u.space/N;\n  int sy=u.space%N;\n  for(int r=0 ; r<4 ; r++){\n    int tx=sx+dx[r];\n    int ty=sy+dy[r];\n    if(tx<0 || ty<0 || tx>=N || ty>=N)continue;\n    v=u;\n    swap(v.f[u.space], v.f[tx*N+ty]);\n    v.space=tx*N+ty;\n    if(!V[v]){\n      V[v]=true;\n      v.path+=dir[r];\n      Q.push(v);\n    }\n  }\n}\nreturn \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  for(int i=0 ; i<N2 ; i++){\n    cin >> in.f[i];\n    if(in.f[i]==0){\n    in.f[i]=N2;\n    in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout << ans.size() << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst int edge[4][3] = {{0, 3, 6}, {0, 1, 2}, {6, 7, 8}, {2, 5, 8}}; /* l, t, b, r */\nconst bool direction[9][4] = {{false, false, true, true},\n                              {true, false, true, true},\n                              {true, false, true, false},\n                              {false, true, true, true},\n                              {true, true, true, true},\n                              {true, true, true, false},\n                              {false, true, false, true},\n                              {true, true, false, true},\n                              {true, true, false, false},\n                              {true, true, false, false}}\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    if(wrongs + moves > cutoff)\n        return -1;\n    int zero;\n    REP(i, 9){\n        if(tiles[i] == 0){\n            zero = i;\n            break;\n        }\n    }\n    bool dir[4] = dir[zero];\n    if(wrongs + moves >= cutoff)\n        return -1;\n    if(dir[0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-1]);\n    }\n    if(dir[1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-3]);\n    }\n    if(dir[2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+3]);\n    }\n    if(dir[3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+1]);\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n    int start = check();\n\n    REP(i, 50){\n        move = dfs(0, start + i);\n        if(move > 0){\n            break;\n        }\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nint main()\n{\n    8puzzle in;\n    for (int i = 0; i < N2; i++)\n    {\n        cin >> in.f[i];\n        if (in.f[i] == 0)\n        {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n\n    return 0;\n}\n\nstruct 8puzzle\n{\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator<(const 8puzzle & p) const\n    {\n        for (int i = 0; i < N2; i++)\n        {\n            if (f[i] == p.f[i])\n                continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(8puzzle p)\n{\n    for (int i = 0; i < N2; i++)\n        if (p.f[i] != (i + 1))\n            return false;\n    return true;\n}\n\nstring bfs(8puzzle s)\n{\n    queue<8puzzle> Q;\n    map<8puzzle, bool> V;\n    8puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while (!Q.empty())\n    {\n        u = Q.front();\n        Q.pop();\n        if (isTarget(u))\n            return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; r++)\n        {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N)\n                continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if (!V[v])\n            {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n\n#define DIVN 3\n\nvoid swap(int &a, int &b){\n\tint tmp = a;\n\ta = b;\n\tb = tmp;\n\treturn;\n}\n\nint fact(int a){\n\tint b = 1;\n\tfor (int i = 2; i <= a; i++){\n\t\tb = b * i;\n\t}\n\treturn b;\n}\n\nint PtoI(std::vector<int> p){\n\tint x, result = 0;\n\tfor (int i = 0; i < DIVN*DIVN - 1; i++){\n\t\tfor (int j = 0; j < DIVN*DIVN - i; j++){\n\t\t\tif (p[j] == i){\n\t\t\t\tx = j;\n\t\t\t\tp.erase(p.begin() + j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult += x * fact(DIVN*DIVN - i - 1);\n\t}\n\treturn result;\n}\n\nstd::vector<int> ItoP(int ii){\n\tstd::vector<int> tmp, result(DIVN*DIVN, -1);\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tint index = ii / fact(DIVN*DIVN - i - 1);\n\t\tii = ii % fact(DIVN*DIVN - i - 1);\n\t\tint curindex = -1;\n\t\tint x = -1;\n\t\tfor (int j = 0; j < DIVN*DIVN; j++){\n\t\t\tif (result[j] == -1){\n\t\t\t\tcurindex++;\n\t\t\t}\n\t\t\tif (curindex == index) {\n\t\t\t\tx = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (x == -1){\n\t\t\tresult[curindex] = -1;\n\t\t}\n\t\tresult[x] = i;\n\t}\n\treturn result;\n}\n\nint SolvePuzzle(std::vector<int> P){\n\tstd::list<int> Que;\n\tQue.push_back(PtoI(P));\n\tint answer;\n\tstd::vector<int> Puzzles(fact(DIVN*DIVN), -1);\n\tPuzzles[PtoI(P)] = 0;\n\twhile (!Que.empty()){\n\t\tstd::vector<int> Q = ItoP(Que.front());\n\t\tQue.pop_front();\n\t\tint Cursor;\n\t\tbool isAligned = true;\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] != (i + 1) % (DIVN*DIVN)){\n\t\t\t\tisAligned = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isAligned){\n\t\t\tanswer = Puzzles[PtoI(Q)];\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] == 0){\n\t\t\t\tCursor = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstd::vector<int> Qnext;\n\t\tif (Cursor >= DIVN){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] < Puzzles[PtoI(Q)] + 1 ){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tQue.push_back(PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor < DIVN * (DIVN - 1)){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] < Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tQue.push_back(PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != 0){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] < Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tQue.push_back(PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != DIVN - 1){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] < Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tQue.push_back(PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn answer;\n}\n\nint main(){\n\tint k;\n\tstd::vector<int> P;\n\tfor (int i = 0; i < DIVN * DIVN; i++){\n\t\tscanf(\"%d\", &k);\n\t\tP.push_back(k);\n\t}\n\tint n = SolvePuzzle(P);\n\n\tprintf(\"%d\\n\", n);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <sstream>\n#include <string.h>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <deque>\n#include <limits>\n#include <iomanip>\n#include <ctype.h>\n#include <unordered_map>\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <math.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, char> pic;\n#define bit(x,v) ((ll)x << v)\n\nconst ll INF = 1000000007;\nconst int MAX = 210000;\nconst int MOD = 1000000007;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit() {\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i < MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t}\n}\n\n// 二項係数計算\nlong long COM(int n, int k) {\n\tif (n < k) return 0;\n\tif (n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\nint pr[100010];\nvoid uini(int n) {\n\tfor (size_t i = 0; i <= n; i++)\n\t{\n\t\tpr[i] = i;\n\t}\n}\n\nint parent(int x) {\n\tif (x == pr[x]) return x;\n\treturn pr[x] = parent(pr[x]);\n}\n\nbool unit(int x, int y) {\n\tint px = parent(x);\n\tint py = parent(y);\n\n\tif (px == py) return false;\n\tif (px < py) {\n\t\tpr[py] = px;\n\t}\n\telse {\n\t\tpr[px] = py;\n\t}\n\treturn true;\n}\n\nll bit[200010];\nint max_n = 200000;\nint pm = 0;\nvoid add(int x) {\n\n\twhile (max_n >= x)\n\t{\n\t\tbit[x]++;\n\t\tx += x & -x;\n\t}\n}\nvoid sub(int x) {\n\twhile (max_n >= x)\n\t{\n\t\tbit[x]--;\n\t\tx += x & -x;\n\t}\n}\nll merge(ll *a, int left, int mid, int right) {\n\tll n1 = mid - left;\n\tll n2 = right - mid;\n\tvector<int> L(n1 + 1);\n\tvector<int> R(n2 + 1);\n\tfor (size_t i = 0; i < n1; i++)\n\t{\n\t\tL[i] = a[left + i];\n\t}\n\tfor (size_t i = 0; i < n2; i++)\n\t{\n\t\tR[i] = a[mid + i];\n\t}\n\n\tL[n1] = INF;\n\tR[n2] = INF;\n\tll i = 0;\n\tll j = 0;\n\tll r = 0;\n\tfor (size_t k = left; k < right; k++)\n\t{\n\t\tif (L[i] <= R[j]) {\n\t\t\ta[k] = L[i];\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\ta[k] = R[j];\n\t\t\tr += n1 - i;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn r;\n}\nll merge2(pair<int, char> *a, int left, int mid, int right) {\n\tll n1 = mid - left;\n\tll n2 = right - mid;\n\tvector<pair<int, char>> L(n1 + 1);\n\tvector<pair<int, char>> R(n2 + 1);\n\tfor (size_t i = 0; i < n1; i++)\n\t{\n\t\tL[i] = a[left + i];\n\t}\n\tfor (size_t i = 0; i < n2; i++)\n\t{\n\t\tR[i] = a[mid + i];\n\t}\n\n\tL[n1] = make_pair(INF, ' ');\n\tR[n2] = make_pair(INF, ' ');\n\tll i = 0;\n\tll j = 0;\n\tll r = 0;\n\tfor (size_t k = left; k < right; k++)\n\t{\n\t\tif (L[i].first <= R[j].first) {\n\t\t\ta[k] = L[i];\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\ta[k] = R[j];\n\t\t\tr += n1 - i;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn r;\n}\nll mergeSort2(pair<int, char> *a, int left, int right) {\n\tll res = 0;\n\tif (left + 1 < right) {\n\t\tint mid = (left + right) / 2;\n\t\tres = mergeSort2(a, left, mid);\n\t\tres += mergeSort2(a, mid, right);\n\t\tres += merge2(a, left, mid, right);\n\t}\n\treturn res;\n}\nll mergeSort(ll *a, int left, int right) {\n\tll res = 0;\n\tif (left + 1 < right) {\n\t\tint mid = (left + right) / 2;\n\t\tres = mergeSort(a, left, mid);\n\t\tres += mergeSort(a, mid, right);\n\t\tres += merge(a, left, mid, right);\n\t}\n\treturn res;\n}\nint partition(pair<int, char> *a, int p, int r) {\n\tpair<int, char> x = a[r];\n\tint i = p - 1;\n\tfor (size_t j = p; j < r; j++)\n\t{\n\t\tif (a[j].first <= x.first) {\n\t\t\ti++;\n\t\t\tswap(a[i], a[j]);\n\t\t}\n\t}\n\tswap(a[i + 1], a[r]);\n\treturn i + 1;\n}\nvoid quick(pair<int, char> *a, int p, int r) {\n\tif (p < r) {\n\t\tint q = partition(a, p, r);\n\t\tquick(a, p, q - 1);\n\t\tquick(a, q + 1, r);\n\t}\n}\n\nint n;\nvector<pii> es[100010];\nint ci = 0;\nll P[1000010];\nstruct Node {\n\tint key;\n\tint priority;\n\tNode *parent, *left, *right;\n\tNode(int key, int priority);\n\tNode() {}\n};\nNode NIL;\nNode::Node(int key, int priority) : key(key), priority(priority) {\n\tleft = &NIL;\n\tright = &NIL;\n}\nNode* root = new Node();\nvoid cenrec(Node* k) {\n\tif (k->key == NIL.key) return;\n\tcenrec(k->left);\n\tcout << \" \" << k->key;\n\tcenrec(k->right);\n}\nvoid fastrec(Node* k)\n{\n\tif (k->key == NIL.key) return;\n\tcout << \" \" << k->key;\n\tfastrec(k->left);\n\tfastrec(k->right);\n}\nvoid insert(Node* v) {\n\tNode* y = &NIL;\n\tNode* x = root;\n\twhile (x->key != NIL.key)\n\t{\n\t\ty = x;\n\t\tif (v->key < x->key) {\n\t\t\tx = x->left;\n\t\t}\n\t\telse {\n\t\t\tx = x->right;\n\t\t}\n\t}\n\tv->parent = y;\n\tif (y->key == NIL.key) {\n\t\troot = v;\n\t}\n\telse if (v->key < y->key) {\n\t\ty->left = v;\n\t}\n\telse {\n\t\ty->right = v;\n\t}\n\n}\n\nNode* find(Node* k, ll v)\n{\n\tif (k->key == NIL.key) return &NIL;\n\tif (k->key == v) return k;\n\tif (v < k->key) return find(k->left, v);\n\treturn find(k->right, v);\n}\nvoid delp12(Node* x) {\n\tif (x->key == NIL.key)  return;\n\tNode* l = x->left;\n\tNode* r = x->right;\n\tNode* pr = x->parent;\n\n\tif (l->key == NIL.key\n\t\t&& r->key == NIL.key) {\n\t\tif (pr->left == x) {\n\t\t\tpr->left = &NIL;\n\t\t}\n\t\telse pr->right = &NIL;\n\t}\n\telse if (l->key != NIL.key) {\n\t\tif (pr->left == x) {\n\t\t\tpr->left = l;\n\t\t}\n\t\telse pr->right = l;\n\t\tl->parent = pr;\n\t}\n\telse if (r->key != NIL.key) {\n\t\tif (pr->left == x) {\n\t\t\tpr->left = r;\n\t\t}\n\t\telse pr->right = r;\n\t\tr->parent = pr;\n\t}\n}\nNode* get_next(Node* k) {\n\tif (k->key == NIL.key) return &NIL;\n\tNode* res = get_next(k->left);\n\tif (res->key != NIL.key) return res;\n\treturn k;\n}\nvoid del(Node* x) {\n\n\tif (x->key == NIL.key) return;\n\tNode* l = x->left;\n\tNode* r = x->right;\n\tNode* pr = x->parent;\n\n\tif (l->key != NIL.key && r->key != NIL.key) {\n\t\tNode* nex = get_next(r);\n\t\tx->key = nex->key;\n\t\tdelp12(nex);\n\t}\n\telse {\n\t\tdelp12(x);\n\t}\n}\nNode* rightRotate(Node *t) {\n\tNode* s = t->left;\n\tt->left = s->right;\n\ts->right = t;\n\treturn s;\n}\nNode* leftRotate(Node *t) {\n\tNode* s = t->right;\n\tt->right = s->left;\n\ts->left = t;\n\treturn s;\n}\nNode* _insert(Node *t, int key, int priority) {\n\tif (t->key == NIL.key) {\n\t\treturn new Node(key, priority);\n\t}\n\tif (key == t->key) {\n\t\treturn t;\n\t}\n\n\tif (key < t->key) {\n\t\tt->left = _insert(t->left, key, priority);\n\t\tif (t->priority < t->left->priority) {\n\t\t\tt = rightRotate(t);\n\t\t}\n\t}\n\telse {\n\t\tt->right = _insert(t->right, key, priority);\n\t\tif (t->priority < t->right->priority) {\n\t\t\tt = leftRotate(t);\n\t\t}\n\t}\n\treturn t;\n}\nNode* delete1(Node* t, int key);\nNode* _delete(Node *t, int key) {\n\tif (t->left->key == NIL.key && t->right->key == NIL.key) {\n\t\treturn &NIL;\n\t}\n\telse if (t->left->key == NIL.key) {\n\t\tt = leftRotate(t);\n\t}\n\telse if (t->right->key == NIL.key) {\n\t\tt = rightRotate(t);\n\t}\n\telse\n\t{\n\t\tif (t->left->priority > t->right->priority) {\n\t\t\tt = rightRotate(t);\n\t\t}\n\t\telse\n\t\t\tt = leftRotate(t);\n\t}\n\treturn delete1(t, key);\n}\nNode* delete1(Node* t, int key) {\n\tif (t->key == NIL.key) {\n\t\treturn &NIL;\n\t}\n\tif (key < t->key) {\n\t\tt->left = delete1(t->left, key);\n\t}\n\telse if (key > t->key) {\n\t\tt->right = delete1(t->right, key);\n\t}\n\telse return _delete(t, key);\n\treturn t;\n}\nint H;\nint left(int i) {\n\treturn i * 2 + 1;\n}\nint right(int i) {\n\treturn i * 2 + 2;\n}\n\nll heap[2000010];\nvoid maxHeapify(int i) {\n\tint l = left(i);\n\tint r = right(i);\n\tint largest = 0;\n\tif (l < H && heap[l] > heap[i])\n\t\tlargest = l;\n\telse\n\t\tlargest = i;\n\tif (r < H && heap[r] > heap[largest])\n\t\tlargest = r;\n\n\tif (largest != i) {\n\t\tswap(heap[i], heap[largest]);\n\t\tmaxHeapify(largest);\n\t}\n}\nint pare(int i) {\n\treturn (i - 1) / 2;\n}\nvoid raise(int i) {\n\tint l = pare(i);\n\tif (l < 0) return;\n\n\tif (heap[l] < heap[i]){\n\t\tswap(heap[i], heap[l]);\n\t\traise(l);\n\t}\n}\nvoid minHeapify(int i) {\n\tint l = left(i);\n\tint r = right(i);\n\tint minimam = 0;\n\tif (l < H && heap[l] < heap[i])\n\t\tminimam = l;\n\telse\n\t\tminimam = i;\n\tif (r < H && heap[r] < heap[minimam])\n\t\tminimam = r;\n\n\tif (minimam != i) {\n\t\tswap(heap[i], heap[minimam]);\n\t\tminHeapify(minimam);\n\t}\n}\nvoid buildMaxHeap() {\n\tfor (int i = H/2; i >= 0; i--)\n\t{\n\t\tmaxHeapify(i);\n\t}\n}\nll lcs(string s1, string s2) {\n\tll dp[1010][1010];\n\tmemset(dp, 0, sizeof(dp));\n\tint s1l = s1.size();\n\tint s2l = s2.size();\n\tfor (size_t i = 1; i <= s1l; i++)\n\t{\n\t\tfor (size_t j = 1; j <= s2l; j++)\n\t\t{\n\t\t\tif (s1[i - 1] == s2[j - 1]) {\n\t\t\t\tdp[i][j] = dp[i - 1][j - 1] + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[s1l][s2l];\n}\nstruct edge {\n\tll to, cap, rev;\n\tedge(int to,int cap,int rev) : to(to),cap(cap),rev(rev){}\n};\nvector<edge> ed[100010];\nvoid addedge(int f, int t, int c) {\n\ted[f].push_back(edge(t, c, ed[t].size()));\n\ted[t].push_back(edge(f, 0, ed[f].size() - 1));\n}\nvector<int> es2[100010];\n\nll d[100010];\nvoid dij(int x) {\n\n\td[x] = 0;\n\tpriority_queue<pll, vector<pll>, greater<pll>> q;\n\tq.push(pll(0, x));\n\twhile (!q.empty())\n\t{\n\t\tpll p = q.top();\n\t\tq.pop();\n\t\tif (d[p.second] < p.first) continue;\n\t\tfor (auto v : ed[p.second]) {\n\t\t\tif (d[v.to] > d[p.second] + v.cap) {\n\t\t\t\td[v.to] = d[p.second] + v.cap;\n\t\t\t\tq.push(pll(d[v.to], v.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool check(vector<vector<int>> tb) {\n\tint p = 1;\n\n\tfor (size_t i = 0; i < 3; i++)\n\t{\n\t\tfor (size_t j = 0; j < 3; j++)\n\t\t{\n\t\t\tif (tb[i][j] != p) return false;\n\t\t\tp++;\n\t\t\tp %= 9;\n\t\t}\n\t}\n\treturn true;\n}\nint dx[] = { 0, -1, 0, 1 };\nint dy[] = { 1, 0, -1, 0 };\nmap<vector<vector<int>>, int> mp;\nint rec(vector<vector<int>> tb) {\n\tif (check(tb)) \n\t\treturn 0;\n\tpriority_queue<pair<int, vector<vector<int>>>, vector< pair<int, vector<vector<int>>>>, greater< pair<int, vector<vector<int>>>>> q;\n\tq.push(make_pair(0, tb));\n\tint res = INF;\n\twhile (!q.empty())\n\t{\n\t\tauto p = q.top();\n\t\tq.pop();\n\t\tif (mp.count(p.second) && mp[p.second] <= p.first) continue;\n\t\tmp[p.second] = p.first;\n\t\tauto tt = p.second;\n\t\tint x = -1, y;\n\t\tfor (size_t i = 0; i < 3; i++)\n\t\t{\n\t\t\tfor (size_t j = 0; j  < 3; j ++)\n\t\t\t{\n\t\t\t\tif (tt[i][j] == 0) {\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x != -1) break;\n\t\t}\n\n\t\tfor (size_t i = 0; i < 4; i++)\n\t\t{\n\t\t\tint tx, ty;\n\t\t\ttx = x + dx[i];\n\t\t\tty = y + dy[i];\n\t\t\tif (tx < 0 || ty < 0 || ty >= 3 || tx >= 3) continue;\n\t\t\tswap(tt[x][y], tt[tx][ty]);\n\t\t\tq.push(make_pair(p.first + 1, tt));\n\t\t\tif (check(tt)) {\n\t\t\t\treturn p.first + 1;\n\t\t\t}\n\t\t\tswap(tt[tx][ty],tt[x][y]);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvoid solv() {\n\n\tint sx, sy;\n\tauto tb = vector<vector<int>>(3, vector<int>(3, 0));\n\tfor (size_t i = 0; i < 3; i++)\n\t{\n\t\tfor (size_t j = 0; j < 3; j++)\n\t\t{\n\t\t\tcin >> tb[i][j];\n\t\t\tif (tb[i][j] == 0) {\n\t\t\t\tsx = i;\n\t\t\t\tsy = j;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << rec(tb) << endl;\n}\n\nint main() {\n\t//\tCOMinit();\n\tsolv();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator<(const Puzzle &p)const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','i','d','r'};\nbool isTarget(Pizzle p){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!=Q.empty()){\n    u=Q.front();Q.pop();\n    is(isTarget(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N)continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  for(int i=0;i<N2;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout<<ans.size()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst int edge[4][3] = {{0, 3, 6}, {0, 1, 2}, {6, 7, 8}, {2, 5, 8}}; /* l, t, b, r */\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    int zero;\n    int original[9];\n    if(wrongs + moves > cutoff)\n        return -1;\n    REP(i, 9){\n        original[i] = tiles[i];\n        if(tiles[i] == 0){\n            zero = i;\n        }\n    }\n    bool dir[4] = {true, true, true, true};\n    REP(i, 4) REP(j, 3)\n        if (zero == edge[i][j])\n            dir[i] = false;\n    if(dir[0] && wrongs + moves < cutoff){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[0])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[1] && wrongs + moves < cutoff){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[1])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[2] && wrongs + moves < cutoff){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[2])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[3] && wrongs + moves < cutoff){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[3])\n        REP(i, 9) tiles[i] = original[i];\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n    int start = check();\n\n    REP(i, 100){\n        move = dfs(0, start + i);\n        if(move > 0)\n            break;\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nconst int dx[4] { -1, 0, 1, 0 };\nconst int dy[4] { 0, -1, 0, 1 };\nconst char dir[4] { 'u', 'l', 'd', 'r' };\n\nstruct Puzzle {\n\tint f[N2], space;\n\tstring path;\n\tbool operator <(const Puzzle p) const {\n\t\tfor (int i = 0; i < N2; ++i) {\n\t\t\tif (f[i] == p.f[i])\n\t\t\t\tcontinue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nbool isResolved(Puzzle p) {\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif (p.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle p) {\n\tqueue<Puzzle> Q;\n\tp.path = \"\";\n\tQ.push(p);\n\tmap<Puzzle, bool> M;\n\tM[p] = true;\n\tPuzzle u, v;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isResolved(u))\n\t\t\treturn u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || tx >= N)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!M[v]) {\n\t\t\t\tM[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\";\n}\n\nint main() {\n\tPuzzle p;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tscanf(\"%d\", &p.f[i]);\n\t\tif (p.f[i] == 0) {\n\t\t\tp.f[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(p);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst int edge[4][3] = {{0, 3, 6}, {0, 1, 2}, {6, 7, 8}, {2, 5, 8}}; /* l, t, b, r */\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    if(wrongs + moves > cutoff)\n        return -1;\n    int zero;\n    REP(i, 9){\n        if(tiles[i] == 0){\n            zero = i;\n            break;\n        }\n    }\n    bool dir[4] = {true, true, true, true};\n    REP(i, 4) REP(j, 3)\n        if (zero == edge[i][j])\n            dir[i] = false;\n    if(wrongs + moves >= cutoff)\n        return -1;\n    if(dir[0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-1]);\n    }\n    if(dir[1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-3]);\n    }\n    if(dir[2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+3]);\n    }\n    if(dir[3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+1]);\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n    int start = check();\n\n    REP(i, 100){\n        move = dfs(0, start + i);\n        if(move > 0)\n            break;\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n#define N 3\n#define LIMIT_TIME 180000\ntypedef pair<int, int> P;\n\nstruct State {\n    int g, h;\n    string state;\n    P blank;\n    string path;\n    bool operator<(const State &a) const {\n        return g + h > a.g + a.h;\n    }\n};\n\nint d[5] = {-1, 0, 1, 0, -1};\nstring r[4] = {\"D\", \"R\", \"U\", \"L\"};\nstring ans_str = \"\";\nint ans[N][N], puzzle0[N][N], puzzle1[N][N];\nset<string> s;\npriority_queue<State> next_state;\nstring path;\n\nbool range(int y, int x) {return 0 <= y && y < N && 0 <= x && x < N;}\n\nint h2() {\n    int find = -1;\n    while(next_state.size()) {\n        State state = next_state.top();\n        next_state.pop();\n        if (s.count(state.state)) continue; // already search\n        s.insert(state.state); // visited\n\n        P blank = state.blank;\n        rep(i, 4) {\n            int y = d[i] + blank.first, x = d[i + 1] + blank.second; // next blank position\n            if (range(y, x)) { // can be replaced\n                string tmp = state.state; // next state (string)\n                int p = blank.first * N + blank.second, q = y * N + x;\n                if (N < 4)  swap(tmp[p], tmp[q]);\n                else swap(tmp[2 * p], tmp[2 * q]), swap(tmp[2 * p + 1], tmp[2 * q + 1]);\n                if (s.count(tmp)) continue; // already search\n\n                int num;\n                if (N < 4) num = state.state[q] - '1';\n                else num = stoi(state.state.substr(2 * q, 2)) - 1;\n                // calcurate manhattan distance\n                int manhattan = state.h - ((abs(num / N - y) + abs(num % N - x)))\n                + (abs(num / N - blank.first) + abs(num % N - blank.second));\n\n                if (manhattan == 0) { // answer\n                    find = state.g + 1;\n                    path = state.path + r[i];\n                    break;\n                }\n\n                next_state.push(State{state.g + 1, manhattan, tmp, P(y, x), state.path + r[i]});\n            }\n        }\n        if (find != -1) break; // find an answer\n    }\n    return find;\n}\n\nint main(){\n    rep(i, N)rep(j, N) cin >> puzzle0[i][j];\n\n    string state = \"\";\n    P blank;\n    int manhattan = 0, wrong_place = 0;\n    rep(i, N)rep(j, N) {\n        // cout << puzzle0[i][j] << ((j % N == N - 1) ? \"\\n\" : \"\\t\");\n\n        if (N * N - 1 > 9 && puzzle0[i][j] < 10) state += \"0\";\n        state += to_string(puzzle0[i][j]);\n        if (N * N - 1 > 9 && ans[i][j] < 10) ans_str += \"0\";\n        ans_str += to_string(ans[i][j]);\n\n        if(puzzle0[i][j] == 0) blank = P(i, j);\n        else {\n            int num = puzzle0[i][j] - 1;\n            manhattan += (abs(num / N - i) + abs(num % N - j));\n            if (puzzle0[i][j] != ans[i][j]) wrong_place++;\n        }\n    }\n\n    if (manhattan == 0) { // the answer\n        cout << 0 << endl;\n    } else {\n        s.clear();\n        next_state = priority_queue<State>();\n        next_state.push(State{0, manhattan, state, blank, \"\"});\n        int steps = h2();\n        cout << steps << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-12)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nstring s = \"\";\nstring ans = \"123456780\";\nint d[4] = {-1,1,-3,3};\n\nbool rec(string v,int index,int step,int limit){\n  if(limit<step)return false;\n  if(v==ans)return true;\n  FOR(i,0,4){\n    if(index%3==0 && d[i]==-1)continue;\n    if((index+1)%3==0 && d[i]==1)continue;\n    if(index<=2 && d[i]==-3)continue;\n    if(6<=index && d[i]==3)continue;\n    string u = v;\n    swap(u[index],u[index+d[i]]);\n    if(rec(u,index+d[i],step+1,limit))return true;\n  }\n  return false;  \n}\n\nint solve(){\n  int ans = 0;\n  int ind = 0;\n  FOR(i,0,9)if(s[i]=='0')ind=i;\n  while(!rec(s,ind,0,ans))ans++;\n  return ans;\n}\n\nint main()\n{\n  FOR(i,0,9){\n    string a;\n    cin>>a;\n    s+=a;\n  }\n  cout<<solve()<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const {\n    for(int i=0; i<N2; i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd','r'};\n\nbool isTarget(Puzzle p) {\n  for(int i=0; i<N2; i++)\n    if(p.f[i] != (i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r=0; r<4; r++){\n      int tx = sx+dx[r];\n      int ty = sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n      v=u;\n      swap(v.f[u.space], v.f[tx*N+ty]);\n      v.space = tx*N+ty;\n      if(!V[v]){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"usdolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0; i<N2; i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in .space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\nvector<int> searched[9];\n\nclass board{\npublic:\n    int moves;\n    int wrongs;\n    int zero_place;\n    int cost;\n    vector<int> tiles;\n\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        tiles = num;\n        REP(i, 9){\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n        cost = wrongs + moves;\n    }\n\n    void board_to_int(){\n        int k = 0;\n        REP(i, 9)\n            k += (tiles[i] * pow(10, i));\n        for(int i = searched[tiles[0]].size(); i > 0 ; i--)\n            if(k == searched[tiles[0]][i-1])\n                return;\n        pq.push(board(tiles, moves+1));\n        searched[tiles[0]].push_back(k);\n        return;\n    }\n\n    void move() {\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\nbool operator< (board b1, board b2){\n    return ((b1.cost > b2.cost) ? true : false);\n}\n\nint solve(){\n    pq.push(board(original, 0));\n    while(1){\n        auto target = pq.top();\n        pq.pop();\n        if(target.wrongs == 0)\n            return target.cost;\n        target.move();\n    }\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = solve();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define N 3\n#define M 9\n#define O 4\n\nstruct Puzzle{\n  int f[M];\n  int space;\n  string path;\n\n  bool operator < ( const Puzzle &p ) const {\n    for(int i = 0;i < M;i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[O] = {-1, 0, 1, 0};\nstatic const int dy[O] = {0, -1, 0, 1};\nstatic const int dir[O] = {'u', 'l', 'd', 'r'};\n\nbool isTarget (Puzzle p){\n  int i;\n  for(i = 0;i < M;i++)\n    if(p.f[i] != (i + 1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n    if(isTarget(u))return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r = 0;r < O;r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0 ||ty < 0 ||tx >= N ||ty >= N)continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if( !V[v]){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  int i;\n\n  for(i = 0;i < M;i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = M;\n      in.space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nbool ok(char a[3][3])\n{\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tif (a[i / 3][i % 3] != i + 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstruct puzzle\n{\n\tchar board[3][3];\n\tchar distance;\n};\n\nconst int dx[4] = { 0, -1, 1, 0 };\nconst int dy[4] = { -1, 0, 0, 1 };\n\nint main() \n{\n\tpuzzle start;\n\n\tstart.distance = 0;\n\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tfor (int j = 0; j < 3; j++)\n\t\t{\n\t\t\tcin >> start.board[i][j];\n\n\t\t\tstart.board[i][j] -= 48;\n\t\t}\n\t}\n\n\tqueue<puzzle> que; que.push(start);\n\n\tchar Ans = 0, x, y, i, j, dir;\n\n\tpuzzle p, q;\n\n\tif (ok(start.board) == false)\n\t{\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tp = que.front(); que.pop();\n\n\t\t\tfor (i = 0; i < 3; i++)\n\t\t\t{\n\t\t\t\tfor (j = 0; j < 3; j++)\n\t\t\t\t{\n\t\t\t\t\tif (p.board[i][j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (dir = 0; dir < 4; dir++)\n\t\t\t{\n\t\t\t\tif (0 <= x + dx[dir] && x + dx[dir] < 3 && 0 <= y + dy[dir] && y + dy[dir] < 3)\n\t\t\t\t{\n\t\t\t\t\tq = p;\n\n\t\t\t\t\tswap(q.board[y][x], q.board[y + dy[dir]][x + dx[dir]]);\n\n\t\t\t\t\tq.distance = p.distance + 1;\n\n\t\t\t\t\tif (ok(q.board) == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tAns = q.distance; goto Exit;\n\t\t\t\t\t}\n\n\t\t\t\t\tque.push(q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExit:;\n\n\tcout << (int)Ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <vector>\n\ntypedef std::vector<std::vector<int> > TPuzzle;\n\nvoid MakeGoal(TPuzzle& Goal)\n{\n\tGoal.resize(3);\n\tfor(int i = 0; i < 3; ++i){\n\t\tGoal[i].resize(3);\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tGoal[i][j] = (1 + 3 * i + j) % 9;\n\t\t}\n\t}\n}\n\nvoid ZeroPosition(int& Row, int& Col, const TPuzzle& Puzzle)\n{\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tif(Puzzle[i][j] == 0){\n\t\t\t\tRow = i;\n\t\t\t\tCol = j;\n\t\t\t}\n\t\t}\n\t}\n}\n\nenum TMovePattern\n{\n\tmpUp,\n\tmpDown,\n\tmpLeft,\n\tmpRight\n};\n\nbool Movable(const TPuzzle& Puzzle, const TMovePattern& Pattern)\n{\n\tint Row, Col;\n\tZeroPosition(Row, Col, Puzzle);\n\tswitch(Pattern){\n\tcase mpUp    : return Row != 0;\n\tcase mpDown  : return Row != 2;\n\tcase mpLeft  : return Col != 0;\n\tcase mpRight : return Col != 2;\n\t}\n\tassert(false);\n\treturn false;\n}\n\nTPuzzle Move(const TPuzzle& Puzzle, const TMovePattern& Pattern)\n{\n\tint Row, Col;\n\tZeroPosition(Row, Col, Puzzle);\n\tTPuzzle Result = Puzzle;\n\tswitch(Pattern){\n\tcase mpUp    : std::swap(Result[Row][Col], Result[Row - 1][Col]);break;\n\tcase mpDown  : std::swap(Result[Row][Col], Result[Row + 1][Col]);break;\n\tcase mpLeft  : std::swap(Result[Row][Col], Result[Row][Col - 1]);break;\n\tcase mpRight : std::swap(Result[Row][Col], Result[Row][Col + 1]);break;\n\tdefault : break;\n\t}\n\treturn Result;\n}\n\nint CountMove(const std::set<TPuzzle>& Before, const TPuzzle& Goal, int Count)\n{\n\tif(Before.find(Goal) != Before.end()) return Count;\n\tstd::set<TPuzzle> Next;\n\tfor(std::set<TPuzzle>::const_iterator It = Before.begin(); It != Before.end(); ++It){\n\t\tconst TPuzzle& Puzzle = *It;\n\t\tif(Movable(Puzzle, mpUp))    Next.insert(Move(Puzzle, mpUp));\n\t\tif(Movable(Puzzle, mpDown))  Next.insert(Move(Puzzle, mpDown));\n\t\tif(Movable(Puzzle, mpLeft))  Next.insert(Move(Puzzle, mpLeft));\n\t\tif(Movable(Puzzle, mpRight)) Next.insert(Move(Puzzle, mpRight));\n\t}\n\treturn CountMove(Next, Goal, 1 + Count);\n}\n\nint CountMinimumMove(const TPuzzle& Puzzle, const TPuzzle& Goal)\n{\n\tstd::set<TPuzzle> Start;\n\tStart.insert(Puzzle);\n\treturn CountMove(Start, Goal, 0);\n}\n\nint main()\n{\n\tTPuzzle Goal;\n\tMakeGoal(Goal);\n\tTPuzzle Start(3, std::vector<int>(3));\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tint Input;\n\t\t\tstd::cin >> Input;\n\t\t\tStart[i][j] = Input;\n\t\t}\n\t}\n\tstd::cout << CountMinimumMove(Start, Goal) << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<queue>\nusing namespace std;\nconst int MAXN=1000010;\nconst int MOD=1000007;\nstring st;\nstring en=\"123456780\";\nint head[MAXN],nex[MAXN];\nint f[MAXN],top;\nstring ss[MAXN];\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nqueue<string> q;\nqueue<int> qs;\nvoid input()\n{\n\tmemset(head,-1,sizeof(head));\n\tmemset(nex,-1,sizeof(nex));\n\tfor(int i=0;i<3;i++)\n\t    for(int j=0;j<3;j++){\n\t    \tchar c;\n\t        cin>>c;\n\t        st+=c;\n\t    }\n\t//cout<<st<<endl;\n}\n\nint has(string s){\n\tint sum(0);\n\tfor(int i=0;i<9;i++){\n\t\tsum*=10;\n\t\tsum+=s[i]-'0';\n\t}\n\treturn sum;\n}\n\nvoid add(string tt){\n\tint tmp=has(tt);\n\tnex[top]=head[tmp%MOD];\n\thead[tmp%MOD]=top;\n\tss[top++]=tt;\n}\n\nbool ff(string tt){\n\tint tmp=has(tt);\n\tint u=head[tmp%MOD];\n\twhile(u!=-1){\n\t\tstring ttt=ss[u];u=nex[u];\n\t\tif(ttt==tt) return true;\n\t}\n\treturn false;\n}\n\nvoid xxj()\n{\n\tq.push(st);\n\tadd(st);\n\tqs.push(0);\n\twhile(!q.empty()){\n\t\tstring tmp=q.front();q.pop();\n\t\tint ts=qs.front();qs.pop();\n\t\t//if(ts==4) cout<<tmp<<' '<<ts<<endl;\n\t\tif(tmp==en) {cout<<ts<<endl;return;}\n\t\tint pos=tmp.find('0');\n\t\tint x=pos/3,y=pos%3;\n\t\t//cout<<x<<' '<<y<<endl;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint xx=x+dx[k];\n\t\t\tint yy=y+dy[k];\n\t\t\tif(xx<0 || yy<0 || xx>=3 || yy>=3) continue;\n\t\t\tstring tt=tmp;\n\t\t\tswap(tt[xx*3+yy],tt[pos]);\n\t\t\tif(!ff(tt)){\n\t\t\t\tq.push(tt);\n\t\t\t\tqs.push(ts+1);\n\t\t\t\tadd(tt);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tinput();\n\txxj();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 9\n\nstruct data{\n  int f[N];\n  int move;\n  string path;\n\n  bool operator < (const data &p) const {\n    for(int i = 0;i < N;i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char where[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(data);\nstring bfs(data);\n\nint main(){\n  data a;\n  int i;\n  string c;\n\n  for(i = 0;i < N;i++){\n    cin >> a.f[i];\n    if(a.f[i] == 0){\n      a.f[i] = N;\n      a.move = i;\n    }\n  }\n  c = bfs(a);\n  cout << c.size() << endl;\n\n  return 0;\n}\n\nbool isTarget(data p){\n  int i;\n  \n  for(i = 0;i < N;i++){\n    if(p.f[i] != (i + 1)) return 0;\n  }\n    return 1;\n}\n\nstring bfs(data p){\n  queue<data> Q;\n  map<data,bool> V;\n  data x,y;\n  int px,py,tx,ty,i;\n  p.path = \"\";\n  Q.push(p);\n  V[p] = 1;\n\n  while(!Q.empty()){\n    x = Q.front(); Q.pop();\n    if(isTarget(x)) return x.path;\n    px = x.move / (N/3);\n    py = x.move % (N/3);\n    for(i = 0;i < 4;i++){\n      tx = px + dx[i];\n      ty = py + dy[i];\n      if(tx < 0 || ty < 0 || tx >= (N/3) || ty >= (N/3)) continue;\n      y = x;\n      swap(y.f[x.move],y.f[tx * (N/3) + ty]);\n      y.move = tx * (N/3) + ty;\n      if(!V[y]){\n\tV[y] = 1;\n\ty.path += where[i];\n\tQ.push(y);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define NN 9\n \nstruct Puzzle {\n  int f[NN];\n  int space;\n  string path;\n \n  bool operator < (const Puzzle &p) const {\n    for(int i=0; i<NN; i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n \nstatic const int x[4] = {-1, 0, 1, 0};\nstatic const int y[4] = {0, -1, 0, 1};\nstatic const char dr[4] = {'u', 'l', 'd','r'};\n \nbool isTarget(Puzzle p) {\n  for(int i=0; i<NN; i++)\n    if(p.f[i] != (i+1)) return false;\n  return true;\n}\n string bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n   while(!Q.empty()){\n    u = Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r=0; r<4; r++){\n      int tx = sx+x[r];\n      int ty = sy+y[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n      v=u;\n      swap(v.f[u.space], v.f[tx*N+ty]);\n      v.space = tx*N+ty;\n      if(!V[v]){\n        V[v] = true;\n        v.path += dr[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"usdolvable\";\n}\n \nint main(){\n  Puzzle p;\n for(int i=0; i<NN; i++){\n    cin >> p.f[i];\n    if(p.f[i] == 0){\n      p.f[i] = NN;\n      p .space = i;\n    }\n  }\n  string ans = bfs(p);\n  cout << ans.size() << endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Ref : https://book.mynavi.jp/ec/products/detail/id=35408\n\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2]; // 9マスの状態\n\tint space; // 遷移の起点となるスペース位置\n\tstring path; // スペースの移動方向を文字（dir[4]）の組み合わせで記録\n\n\t// mapによる二分探索木を使うための要素の大小関係の定義\n\tbool operator < (const Puzzle &p) const {\n\t\tfor (int i = 0; i < N2; i++) {\n\t\t\tif (f[i] == p.f[i]) continue;\n\t\t\treturn f[i] < p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\n// スペースと隣り合う位置への座標移動\nstatic const int dx[4] = { -1, 0, 1, 0 };\nstatic const int dy[4] = {  0,-1, 0, 1 };\nstatic const char dir[4] = { 'u', 'l', 'd', 'r' };\n\nbool isTarget(Puzzle p) {\n\tfor (int i = 0; i < N2; i++)\n\t\tif (p.f[i] != (i + 1)) return false;\n\treturn true;\n}\n\nstring bfs(Puzzle s) {\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\n\twhile (!Q.empty()) {\n\t\tu = Q.front(); Q.pop();\n\t\tif (isTarget(u)) return u.path;\n\t\tint sx = u.space / N; // スペースのx座標に変換\n\t\tint sy = u.space % N; // スペースのy座標に変換\n\t\tfor (int r = 0; r < 4; r++) {\n\t\t\tint tx = sx + dx[r]; // 交換対象のx座標\n\t\t\tint ty = sy + dy[r]; // 交換対象のx座標\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N) continue; // マス外の無効座標\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]); // スペースと交換対象を交換\n\t\t\tv.space = tx * N + ty; // スペースの位置を更新\n\t\t\tif ( !V[v] ) { // 交換後の状態が存在しなければ自動的にfalseで要素が新規作成される\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r]; \n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main() {\n\tPuzzle in;\n\n\tfor (int i = 0; i < N2; i++) {\n\t\tcin >> in.f[i];\n\t\tif (in.f[i] == 0) {\n\t\t\tin.f[i] = N2; // スペースは0からN2に形式変更\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl; // 移動方向の記録の文字数からスペースの交換回数を取得\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define NUM 3\n#define PRUNING 25\n\ntypedef struct STATUS{\n    int num;\n    int board[NUM][NUM];\n}STATUS;\n\ntypedef pair<int, int> cell;\n\nbool checkfinish(STATUS in){\n    \n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            if (i == NUM - 1 && j == NUM - 1) return true;\n            if(in.board[i][j] != val++) return false;\n        }\n    }\n    return true;\n}\n\n\nint backtrack(STATUS in, cell last_zero){\n\n    int x = 0, y = 0, ret = PRUNING;\n    cell zero;\n    STATUS out;\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    \n    if (in.num > ret) {\n        return ret;\n    }\n    \n    if (checkfinish(in)) {\n        return in.num;\n    }\n\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            if(in.board[i][j] == 0){\n                x = zero.first = j;\n                y = zero.second = i;\n            }\n        }\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (x + dx[i] >=0 && x+dx[i] < NUM && y+dy[i] >=0 && y+dy[i] < NUM) {\n            if (last_zero.first == x+dx[i] && last_zero.second == y+dy[i]){ continue;\n            }\n            memcpy(&out, &in, sizeof(STATUS));\n            swap(out.board[y][x], out.board[y+dy[i]][x+dx[i]]);\n            out.num++;\n            ret = min(ret, backtrack(out, zero));\n        }\n    }\n    return ret;\n}\n\n\nint main(){\n    \n    int val, ans;\n    \n    STATUS init;\n    init.num = 0;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            cin >> val;\n            init.board[i][j] = val;\n        }\n    }\n    \n    //?????????????????????????????????zero????????¨?????????????????????????????\\????????????\n    ans = backtrack(init, cell(-1,-1));\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define NUM 3\n#define PRUNING 50\n\n#define MAX 500000000\nbool passed[MAX];\n\ntypedef struct STATUS{\n    int num;\n    int board[NUM][NUM];\n}STATUS;\n\ntypedef pair<int, int> cell;\n\nbool checkfinish(STATUS in){\n    \n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            if (i == NUM - 1 && j == NUM - 1) return true;\n            if(in.board[i][j] != val++) return false;\n        }\n    }\n    return true;\n}\n\nint rtnindex(STATUS in){\n    \n    int ret = 0;\n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            ret += val*in.board[i][j];\n            val *= 9;\n        }\n    }\n    return ret;\n}\n\n\nint backtrack(STATUS in, cell last_zero){\n\n    int x = 0, y = 0, ret = PRUNING;\n    cell zero;\n    STATUS out;\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    \n    if (in.num > ret) {\n        return ret;\n    }\n    \n    if (checkfinish(in)) {\n        return in.num;\n    }\n\n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            if(in.board[i][j] == 0){\n                x = zero.first = j;\n                y = zero.second = i;\n            }\n        }\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (x + dx[i] >=0 && x+dx[i] < NUM && y+dy[i] >=0 && y+dy[i] < NUM) {\n            if (last_zero.first == x+dx[i] && last_zero.second == y+dy[i]){ continue;\n            }\n            memcpy(&out, &in, sizeof(STATUS));\n            swap(out.board[y][x], out.board[y+dy[i]][x+dx[i]]);\n            int rtn = rtnindex(out);\n            if (passed[rtn] == true) {\n                continue;\n            }\n            out.num++;\n            ret = min(ret, backtrack(out, zero));\n            passed[rtn] = true;\n        }\n    }\n    return ret;\n}\n\n\nint main(){\n    \n    int val, ans;\n    \n    STATUS init;\n    init.num = 0;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            cin >> val;\n            init.board[i][j] = val;\n        }\n    }\n    \n    for (int i = 0; i < MAX; i++) passed[i] = false;\n    \n    passed[rtnindex(init)] = true;\n    \n    //?????????????????????????????????zero????????¨?????????????????????????????\\????????????\n    ans = backtrack(init, cell(-1,-1));\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<utility>\nusing namespace std;\n#define TxT for(int i = 0; i < 3; i++)for(int j = 0; j < 3; j++)\n\ntypedef struct tep{\n\tint e[3][3];\n\tint c;\n\tbool operator  < (const tep& r) const{\n\t\tTxT if(e[i][j] > r.e[i][j]) return true;\n\t\treturn false;\n\t}\n\t// bool operator  == (const tep& r) const{\n\t\t// TxT if(e[i][j] != r.e[i][j]) return false;\n\t\t// return true;\n\t// }\n} EP;\n\nmap<int,bool> z;\nEP e;\nint dxy[] = {1,-1,0,0};\n\nint hogefuga(EP hoge){\n\tint ten = 1, re = 0;\n\tTxT re += ten*hoge.e[i][j],ten*=10;\n\treturn re;\n}\n\nint fugafuga(EP hoge){\n\tint count = 1, count2 = 0;\n\tTxT{ if(hoge.e[i][j] != (count++)%9) count2++;}\n\treturn count2;\n}\n\nvoid print(EP hoge){\t\n\tcout<<hoge.c<<\" +++++ \"<<endl;;\n\tcout<<hogefuga(hoge)<<endl;\n\tfor(int i = 0; i < 3; i++){\n\t\tfor(int j = 0; j < 3; j++) cout<<hoge.e[i][j]<<\" \";\n\t\tcout<<endl;\n\t}\n\tcout<<endl;\n\tstring hogehogehoge;\n\tcin>>hogehogehoge;\n}\n\nbool hogehoge(EP hoge){\n\tint count = 1;\n\tTxT{ if(hoge.e[i][j] != (count++)%9) return false;}\n\treturn true;\n}\n\nvoid fuga(queue<EP> &Q, EP hoge){\n\tint x, y, mi = 10, t, ti;\n\t\n\tTxT if(hoge.e[i][j] == 0)y = i, x = j;\n\t\n\tfor(int i = 0; i < 4; i++){\n\t\tint ny = y + dxy[i], nx = x + dxy[3-i];\n\t\tif(ny < 0 || ny >= 3 || nx < 0 || nx >= 3) continue;\n\t\tEP fuga = hoge;\n\t\tswap(fuga.e[y][x],fuga.e[ny][nx]);\n\t\t\n\t\tif(z[hogefuga(fuga)]) continue;\n\t\telse z[hogefuga(fuga)] = true;\n\t\tfuga.c = hoge.c+1;\n\t\tQ.push(fuga);\n\t\t\n\t\t// if((t = fugafuga(fuga)) < mi){\n\t\t\t// mi = t, ti = i;\n\t\t// }\n\t\t\n\t\t\n\t\t// fuga.c = hoge.c+1;\n\t\t// Q.push(fuga);\n\t}\n\t// if(mi != 10){\n\t\t// int ny = y + dxy[ti], nx = x + dxy[3-ti];\n\t\t// EP fuga = hoge;\n\t\t// swap(fuga.e[y][x],fuga.e[ny][nx]);\n\t\t// fuga.c = hoge.c+1;\n\t\t// Q.push(fuga);\n\t\t// z[hogefuga(fuga)] = true;\n\t// }\n}\n\nint solve(){\n\tqueue<EP> Q;\n\t\n\te.c = 0;\n\t\n\tQ.push(e);\n\t\n\twhile(!Q.empty()){\n\t\tEP hoge = Q.front(); Q.pop();//print(hoge);\n\t\tfuga(Q,hoge);\n\t\tif(hogehoge(hoge)) return hoge.c;\n\t}\n}\n\nint main(){\n\t\n\tTxT cin>>e.e[i][j];\n\t\n\t//z[hogefuga(e)] = true;\n\t\n\tcout<<solve()<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < ( const Puzzle &p ) const {\n    for ( int i = 0; i < N2; i++ ) {\n      if ( f[i] == p.f[i] ) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n  for ( int i = 0; i < N2; i++ )\n    if ( p.f[i] != (i + 1) ) return false;\n  return true;\n}\n\nstring bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while ( !Q.empty() ) {\n    u = Q.front(); Q.pop();\n    if ( isTarget(u) ) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for ( int r = 0; r < 4; r++ ) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if ( !V[v] ) {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main() {\n  Puzzle in;\n\n  for ( int i = 0; i < N2; i++ ) {\n    cin >> in.f[i];\n    if ( in.f[i] == 0 ) {\n      in.f[i] = N2;  // set space\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<map>\nusing namespace std;\nqueue<pair<string,int> > Q;\n \nvoid Sw(string st,int x)\n{\n    int i;\n    int pos,npos;\n    int d[4]={-3,3,-1,1};\n    string st1;\n     \n    for(i=0;i<=8;i++)\n    {\n        if(st[i]=='0')\n        {\n            pos=i;\n            break;\n        }\n    }\n    for(i=0;i<=3;i++)\n    {\n        st1=st;\n        if(i==2 && pos%3==0) continue;\n        if(i==3 && pos%3==2) continue;\n        npos=pos+d[i];\n        if(npos>=9 || npos<=-1) continue;\n        swap(st1[pos],st1[npos]);\n        Q.push(pair<string,int>(st1,x+1));\n    }\n}\n \nint main()\n{\n    string puzzle=\"\";\n    string goal=\"123456780\";\n    map<string,bool> M;\n    int i,x;\n    string P;\n     \n    for(i=0;i<=8;i++)\n    {\n        cin >> x;\n        puzzle+='0'+x;\n    }\n    Q.push(pair<string,int>(puzzle,0));\n    while(1)\n    {\n        pair<string,int> p=Q.front();\n        Q.pop();\n        P=p.first;\n        x=p.second;\n        if(P==goal)\n        {\n            cout << x << endl;\n            break;\n        }\n        if(M[P]) continue;\n        else M[P]=1;\n        Sw(P,x);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n  bool operator < ( const Puzzle &p ) const {\n    for( int i = 0 ; i <  N2 ; i++ ){\n      if( f[i] == p.f[i] ) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const int dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for( int i = 0 ; i < N2 ; i++ )\n    if(p.f[i] != (i + 1) ) return false;\n  return true;\n}\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while( !Q.empty() ){\n    u = Q.front(); Q.pop();\n    if( isTarget(u) ) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for( int r = 0;r < 4;r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if( tx < 0 || ty < 0 ||tx>=N ||ty>=N ) continue;\n      v=u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if( !V[v] ){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\nint main(){\n  Puzzle in;\n\n  for( int i =0 ; i < N2 ; i++ ){\n    cin >> in.f[i];\n    if( in.f[i] == 0 ){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int INF = 1000000;\nint mapp[3+2][3+2],dx[4]={0,1,0,-1},dy[4]={-1,0,1,0};\nint x0,y0,ans(INF);\nstruct edge{\n\tint xa,ya;\n}s[35];\nvoid otpt(int x,int y,int nn){\n\tfor(int i=0;i<3;i++){\n\t    for(int j=0;j<3;j++)\n\t        cout<<mapp[i][j]<<' ';\n\t    cout<<endl;\n\t}\n\tcout<<endl;\n\tfor(int i=0;i<nn;i++) cout<<s[i].xa<<' '<<s[i].ya<<endl;\n\tcin.get();\n}\nvoid init(){\n\tfor(int i=0;i<3;i++)\n\t    for(int j=0;j<3;j++){\n\t    \tcin>>mapp[i][j];\n\t    \tif(!mapp[i][j]){\n\t    \t\tx0=i;\n\t    \t\ty0=j;\n\t    \t}\n\t    }\n}\nbool ook(){\n\tint a(1);\n\tfor(int i=0;i<3;i++){\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(mapp[i][j]!=a&&mapp[i][j]) return false;\n\t\t\telse ++a;\n\t\t}\n\t}\n\t//otpt();cout<<\"!!!!!!\"<<endl;\n\treturn true;\n}\nbool f(int x,int y,int nn){\n\tfor(int i=0;i<nn;i++)\n\t\tif(x==s[i].xa&&y==s[i].ya){\n\t\t\t//cout<<\"x=\"<<x<<\" y=\"<<y<<endl;\n\t\t\treturn false;\n\t\t} \n\treturn true;\n}\nvoid dfs(int x,int y,int bs){\n\tint bf[3+2][3+2];\n\tfor(int i=0;i<3;i++)\n\t    for(int j=0;j<3;j++)\n\t        bf[i][j]=mapp[i][j];\n\tif(bs>ans) return;\n\telse{\n\t\tif(ook()){\n\t\t\t//cout<<\"233?\"<<endl;\n\t\t\tans=min(bs,ans);\n\t\t\treturn;\n\t\t} \n\t\t//cout<<'#'<<bs<<':'<<endl;otpt(x,y,bs);\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint xx(x+dx[i]),yy(y+dy[i]);\n\t\t\tif(xx>=0&&yy>=0&&xx<3&&yy<3&&f(xx,yy,bs)){\n\t\t\t\ts[bs].xa=xx;\n\t\t\t\ts[bs].ya=yy;\n\t\t\t\tswap(mapp[x][y],mapp[xx][yy]);\n\t\t\t\t//used[xx][yy]=1;\n\t\t\t\tdfs(xx,yy,bs+1);\n\t            for(int i=0;i<3;i++)\n\t                for(int j=0;j<3;j++)\n\t                    mapp[i][j]=bf[i][j];\n\t\t\t\t//used[xx][yy]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid sol(){\n\tdfs(x0,y0,0);\n\tcout<<ans<<endl;\n}\nint main(){\n\tinit();\n\tsol();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * b.cc: \n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n\nusing namespace std;\n\n/* constant */\n\nconst int N = 3;\nconst int NN = N * N;\n\nconst int dxs[] = {1, 0, -1, 0}, dys[] = {0, -1, 0, 1};\n\n/* typedef */\n\ntypedef unsigned long long ull;\ntypedef pair<int,ull> piul;\ntypedef map<ull,int> muli;\n\n/* global variables */\n\nmuli dists;\n\n/* subroutines */\n\ninline int zeropos(ull bits) {\n  for (int i = 0; i < NN; i++)\n    if (((bits >> (i * 4)) & 0xf) == 0) return i;\n  return -1;\n}\n\ninline ull move(ull u, int p0, int p1) {\n  ull x = (u >> (4 * p1)) & 0xfULL;\n  return ((u | (x << (4 * p0))) & ~(0xfULL << (4 * p1)));\n}\n\n/* main */\n\nint main() {\n  ull st = 0, gl = 0;\n\n  for (int i = 0; i < NN; i++) {\n    ull ai;\n    cin >> ai;\n    st |= (ai << (i * 4));\n  }\n\n  for (int i = 0; i < NN - 1; i++)\n    gl |= ((ull)(i + 1) << (i * 4));\n  //printf(\"st=%09llx, gl=%09llx\\n\", st, gl);\n\n  if (st == gl) {\n    puts(\"0\");\n    return 0;\n  }\n  \n  dists[st] = 1;\n  dists[gl] = -1;\n\n  queue<piul> q;\n  q.push(piul(1, st));\n  q.push(piul(-1, gl));\n\n  int mind = -1;\n\n  while (! q.empty()) {\n    piul u = q.front(); q.pop();\n    int &ud = u.first;\n    ull &ui = u.second;\n\n    int upos = zeropos(ui);\n    int ux = upos % N, uy = upos / N;\n\n    for (int di = 0; di < 4; di++) {\n      int vx = ux + dxs[di], vy = uy + dys[di];\n      if (vx >= 0 && vx < N && vy >= 0 && vy < N) {\n\tint vpos = vy * N + vx;\n\tull vi = move(ui, upos, vpos);\n\n\tint vd = ud + ((ud >= 0) ? 1 : -1);\n\tmuli::iterator mit = dists.find(vi);\n\tif (mit == dists.end()) {\n\t  dists[vi] = vd;\n\t  q.push(piul(vd, vi));\n\t}\n\telse {\n\t  if (ud * mit->second < 0) {\n\t    int d = abs(mit->second - ud) - 1;\n\t    printf(\"%d\\n\", d);\n\t    exit(0);\n\t  }\n\n\t  if ((ud > 0 && mit->second > vd) || (ud < 0 && mit->second < vd)) {\n\t    mit->second = vd;\n\t    q.push(piul(vd, vi));\n\t  }\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\nusing namespace std;\n#define H 3\n#define W 3\n#define begin 1\n#define end 4\nstruct BOARD{\n        int board[10][10],y,x,count;\n        bool operator<(const BOARD &other)const{\n                for(int i=begin ; i<end ; i++ )\n                        for(int j=begin ; j<end ; j++ )\n                                if(board[i][j]!=other.board[i][j])\n                                        return true;\n                return true;\n        }\n};\nmap <BOARD,bool> past;\nint direction[5]={-1,0,1,0,-1};\nbool check(BOARD now){\n        int s=1;\n        for(int i=begin ; i<end ; i++ ){\n                for(int j=begin ; j<end ; j++ ){\n                        if(now.board[i][j]==s){\n                                s++;\n                                s%=9;\n                        }else return false;\n                }\n        }\n}\nint main(){\n        BOARD board;\n        for(int i=0 ; i<=H+1 ; i++ ){\n                board.board[i][0]=-1;\n                board.board[0][i]=-1;\n                board.board[H+1][i]=-1;\n                board.board[i][W+1]=-1;\n        }\n        for(int i=begin ; i<end ; i++ ){\n                for(int j=begin ; j<end ; j++ ){\n                        cin >> board.board[i][j] ;\n                        if(board.board[i][j]==0){\n                                board.y=i;\n                                board.x=j;\n                        }\n                }\n        }\n        queue<BOARD> circle;\n        board.count=0;\n        circle.push(board);\n        int count=0;\n        while(circle.size()!=0){\n                board=circle.front();circle.pop();\n                if(past[board])continue;\n                past[board]=true;\n                if(board.y<1 || board.y>=4 )continue;\n                if(board.x<1 || board.x>=4 )continue;\n                if(check(board)){\n                        cout << board.count << endl;\n                        break;\n                }\n                for(int i=0 ; i<4 ; i++ ){\n                        int y=board.y+direction[i];\n                        int x=board.x+direction[i+1];\n                        swap(board.board[board.y][board.x],board.board[y][x]);\n                        swap(board.y,y);swap(board.x,x);\n                        board.count++;\n                        circle.push(board);\n                        board.count--;\n                        swap(board.board[board.y][board.x],board.board[y][x]);\n                        swap(board.y,y);swap(board.x,x);\n                }\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//lec04\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define n 3\n#define n1 9\n\n\nstruct puzz{\n  int m[n1];\n  int space;\n  string path;\n  int operator < (const puzz &p)const{\n    for(int i=0;i<n1;i++){\n      if(m[i]==p.m[i])continue;\n      return m[i] > p.m[i];\n    }\n    return false;\n  }\n};\n\n\nstatic const int x[4]={-1,0,1,0};\nstatic const int y[4]={0,-1,0,1};\nstatic const char c[4]={'u','l','d','r'};\n\nint target(puzz p){\n  for(int i=0;i<n1;i++){\n    if(p.m[i]!=(i+1))return false;\n  }\n  return true;\n}\n\nstring am(puzz p){\n  queue<puzz> Q;\n  map<puzz, int> V;\n  puzz a,b;\n  int tmp;\n  p.path=\"\";\n  Q.push(p);\n  V[p]=true;\n\n  while(!Q.empty()){\n    a=Q.front();\n    Q.pop();\n    if(target(a))return a.path;\n    int xx=a.space/n;\n    int yy=a.space%n;\n    for(int k=0;k<4;k++){\n      int xc=xx+x[k];\n      int yc=yy+y[k];\n      if(xc<0||yc<0||xc>=n||yc>=n)continue;\n      b=a;\n      tmp=b.m[a.space];\n      b.m[a.space]=b.m[xc*n+yc];\n      b.m[xc*n+yc]=tmp;\n      b.space=xc*n+yc;\n      if(!V[b]){\n\tV[b]=true;\n\tb.path+=c[k];\n\tQ.push(b);\n\t\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  puzz input;\n  for(int i=0;i<n1;i++){\n    cin>>input.m[i];\n    if(input.m[i]==0){\n      input.m[i]=n1;\n      input.space=i;\n    }\n  }\n  string ans =am(input);\n  cout<<ans.size()<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle& p) const {\n    for (int i = 0; i < N2; i++) {\n      if (f[i] == p.f[i]) {\n        continue;\n      }\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n  for (int i = 0; i < N2; i++) {\n    if (p.f[i] != (i + 1)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nstring bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while (!Q.empty()) {\n    u = Q.front(); Q.pop();\n    if (isTarget(u)) {\n      return u.path;\n    }\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for (int r = 0; r < 4; r++) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if (tx < 0 || ty < 0 || tx >= || ty >= N) {\n        continue;\n      }\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if (!V[v]) {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for (int i = 0; i < N2; i++) {\n    cin >> in.f[i];\n    if (in.f[i] == 0) {\n      in.f[i] = N2; // set space\n      in.space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <stack>\n#include <map>\n#include <string>\nusing namespace std;\n\n#define FLG  INT_MIN\n#define GOAL 0\n\n#define N 3\n\nmap<string, int> mp;\nqueue<pair<string, int> > Q;\n\nvector<int> neighbor(int pos)\n{\n    vector<int> rt;\n    if (pos % N != 0)\n        rt.push_back(pos - 1);\n    if (pos % N != N - 1)\n        rt.push_back(pos + 1);\n    if (pos - N >= 0)\n        rt.push_back(pos - N);\n    if (pos + N < N * N)\n        rt.push_back(pos + N);\n    return rt;\n}\n\nint bfs()\n{\n    string st, tmp;\n    int cnt, pos;\n    while (!Q.empty()) {\n        st = Q.front().first;\n        cnt = Q.front().second;\n        pos = st.find(\"0\");\n        Q.pop();\n        if (mp.count(st)) {\n            if (mp[st] == FLG) {\n                continue;\n            } else if (mp[st] == GOAL) {\n                return cnt;\n            } else\n                printf(\"ERROR: %d\\n\", __LINE__);\n        }\n        mp[st] = FLG;\n        vector<int> nb(neighbor(pos));\n        for (int i = 0; i < nb.size(); i++) {\n            tmp = st;\n            tmp[pos] = st[nb[i]]; tmp[nb[i]] = st[pos];\n            Q.push(make_pair(tmp, cnt + 1));\n        }\n    }\n    return INT_MIN;\n}\n\nint main()\n{\n    string st, gl = \"123456780\";\n    for (int i = 0; i < 9; i++) {\n        int  j;\n        cin >> j;\n        st += to_string(j);\n    }\n    mp[gl] = GOAL;\n    Q.push(make_pair(st, 0));\n    cout << bfs() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1e9\ntypedef long long ll;\n\nstruct P{\n  int x,y;\n  P(int x,int y) : x(x),y(y) {}\n};\n\nll getValue(vector<int> &v){\n  ll res = 0LL;\n  for(auto x : v){\n    res *= 10LL;\n    res += x;\n  }\n  return res;\n}\n\nvector<int> getState(ll x){\n  vector<int> res;\n  while(x > 0LL){\n    res.push_back(x%10LL);\n    x /= 10LL;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\nP getPos(int x){\n  x--;\n  return P(x%3,x/3);\n}\n\nint getMD(ll x){\n  vector<int> v = getState(x);\n  int res = 0;\n  for(int i = 0 ; i < 9 ; i++){\n    if(v[i] == 0){ continue; }\n    P tp = getPos(v[i]);\n    res += abs(i%3-tp.x) + abs(i/3-tp.y);\n  }\n  return res;\n}\n\nint LIMIT;\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nbool inField(int x,int y){\n  return (0 <= x && x < 3 && 0 <= y && y < 3);\n}\n\nvoid print(vector<int> &v){\n  for(int i = 0 ; i < 3 ; i++){\n    for(int j = 0 ; j < 3 ; j++){\n      cout << v[i*3+j] << \" \";\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\nbool solve(int sp,ll st,int step,int prev){\n  int md = getMD(st);\n  if(md == 0){ return true; }\n  if(md + step > LIMIT){\n    return false;\n  }\n  int x = sp%3, y = sp/3;\n  bool res = false;\n  for(int i = 0 ; i < 4 ; i++){\n    int nx = x + dx[i], ny = y + dy[i];\n    if(!inField(nx,ny)){ continue; }\n    if(abs(i-prev) == 2){ continue; }\n    vector<int> v = getState(st);\n    int nsp = ny*3 + nx;\n    swap(v[sp],v[nsp]);\n    res |= solve(nsp,getValue(v),step+1,i);\n  }\n  return res;\n}\n\nint main(){\n  int sp = -1;\n  vector<int> v(9);\n  for(int i = 0 ; i < 9 ; i++){\n    cin >> v[i];\n    if(v[i] == 0){ sp = i; }\n  }\n  ll st = getValue(v);\n  for(LIMIT = 0 ; LIMIT < 35 ; LIMIT++){\n    if(solve(sp,st,0,INF)){\n      cout << LIMIT << endl;\n      break;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<cmath>  // use \"abs\" function.\n\n// non-recursive algorithm.\n#define N 3\n#define N2 9\n\nint main()\n{\n    int MDT[N2][N2];   // Manhattan Distance Table.\n    int dx[4] = {0, -1, 0, 1};  // move.\n    int dy[4] = {1, 0, -1, 0};\n\n    int i, j;\n    for(i = 0; i < N2; i++){\n        for(j = 0; j < N2; j++){\n            MDT[i][j] = abs((i / N) - (j / N)) + abs((i % N) - (j % N));\n        }\n    }\n    int pre_f[N2], f[N2], pre_space, space, pre_MD, MD, depth;\n    for(i = 0; i < N2; i++){\n        scanf(\"%d\", &pre_f[i]);\n        if(pre_f[i] == 0) pre_space = i;\n    }\n\n    pre_MD = 0;\n    for(i = 0; i < N2; i++){\n        if(pre_f[i] != 0){\n            pre_MD += MDT[i][pre_f[i] - 1];\n        }\n    }\n\n    int level, sx, sy, tx, ty, diff, trail[101], s, r, rev_sp;\n\n    for(level = pre_MD; level < 100; level++, level++){  // DFS.\n        for(i = 0; i < N2; i++) f[i] = pre_f[i];\n        space = pre_space;\n        MD = pre_MD;\n        depth = 0;\n        trail[0] = 4;\n        s = 0;\n\n        while(depth >= 0 && MD > 0)\n        {\n            sx = space / N;\n            sy = space % N;\n            for(r = s; r < 4; r++){\n                if((trail[depth] ^ r) == 2) continue;  // go forward.\n                tx = sx + dx[r];\n                ty = sy + dy[r];\n\n                if(tx < 0 || tx >= N || ty < 0 || ty >= N) continue;\n                diff = MDT[sx * N + sy][f[tx * N + ty] - 1] - MDT[tx * N + ty][f[tx * N + ty] - 1];\n                if(depth + 1 + MD + diff > level) continue;  // branch cut.\n\n                break;\n            }\n            if(r < 4){  // next direction.\n                swap(f[sx * N + sy], f[tx * N + ty]);\n                space = tx * N + ty;\n                MD += diff;\n                depth++;\n                trail[depth] = r;\n                s = 0;\n            }else{\n                // back-track.\n                r = trail[depth] ^ 2;\n                s = trail[depth] + 1;\n                depth--;\n                if(depth >= 0){\n                    rev_sp = space + N * dx[r] + dy[r];\n                    MD += MDT[space][f[rev_sp] - 1] - MDT[rev_sp][f[rev_sp] - 1];\n                    swap(f[space], f[rev_sp]);\n                    space = rev_sp;\n                }\n            }\n        };\n        if(depth >= 0) break;\n    }\n    printf(\"%d\\n\", depth);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\nvector<int> searched[9];\n\nclass board{\npublic:\n    int moves;\n    int wrongs;\n    int zero_place;\n    int cost;\n    vector<int> tiles;\n\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        tiles = num;\n        REP(i, 9){\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n        cost = wrongs + moves;\n    }\n\n    void board_to_int(){\n        int k = 0;\n        REP(i, 9)\n            k += (tiles[i] * pow(10, i));\n        for(int i = searched[tiles[0]].size(); i > 0 ; i--)\n            if(k == searched[tiles[0]][i-1])\n                return;\n        pq.push(board(tiles, moves+1));\n        searched[tiles[0]].push_back(k);\n        return;\n    }\n\n    void move() {\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\nbool operator< (board b1, board b2){\n    return ((b1.cost > b2.cost) ? true : false;\n}\n\nint solve(){\n    pq.push(board(original, 0));\n    while(1){\n        auto target = pq.top();\n        pq.pop();\n        if(target.wrongs == 0)\n            return target.cost;\n        target.move();\n    }\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = solve();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue> \n#include <map>\n\nusing namespace std;\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n \ntypedef struct Puzzle {\n\tint M[9];\n\tint space;\n\tstring path;\n\tbool operator<(const Puzzle & p) const {\n\t\tfor (int i=0;i<9;i++) {\n\t\t\tif (M[i] == p.M[i]) continue;\n\t\t\treturn M[i] > p.M[i];\n\t\t}\n\t\treturn false;\n\t}\n} Puzzle;\n\nbool check(Puzzle & p) {\n\tfor (int i=0;i<8;i++) {\n\t\tif (p.M[i] != i+1) return false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle & p) { //广度优先搜索 \n\tqueue<Puzzle> Q;\n\tmap<Puzzle,bool> V; //标记该状态是否被访问\n\tPuzzle u,v;\n\tp.path = \"\";\n\tQ.push(p);\n\tV[p] = true;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (check(u)) return u.path;\n\t\t\n\t\tint sx = u.space / 3;\n\t\tint sy = u.space % 3;\n\t\t\n\t\tfor (int r = 0;r<4;r++) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= 3 || ty >= 3) continue;\n\t\t\t\n\t\t\tv = u;\n\t\t\tswap(v.M[u.space],v.M[tx * 3 + ty]);\n\t\t\tv.space = tx*3 + ty;\n\t\t\t\n\t\t\tif (!V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\t\n\treturn \"unsolvable\";\n}\n\nint main() {\n\tPuzzle in;\n\tfor (int i=0;i<9;i++) {\n\t\tcin >> in.M[i];\n\t\tif (in.M[i] == 0) {\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\nvector<int> searched[9];\n\nclass board{\nprivate:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<int> tiles;\n\npublic:\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        REP(i, 9){\n            tiles.push_back(num[i]);\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n    }\n\n    int cost() {\n        return wrongs + moves;\n    }\n\n    void board_to_int(){\n        int k;\n        REP(i, 9)\n            k += (tiles[i] * pow(10, i));\n        REP(i, searched[tiles[0]].size())\n            if(k == searched[tiles[0]][i])\n                return;\n        pq.push(board(tiles, moves+1));\n        searched[tiles[0]].push_back(k);\n        return;\n    }\n\n    void move() {\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\nbool operator< (board b1, board b2){\n    return (b1.cost() > b2.cost()) ? true : false;\n}\n\nint solve(){\n    pq.push(board(original, 0));\n    while(!pq.empty()){\n        auto target = pq.top();\n        pq.pop();\n        if(target.cost() > 100)\n            return -1;\n        if(target.get_wrongs() == 0)\n            return target.cost();\n        target.move();\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = 0;\n    move = solve();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define MAXN 10+2\nint map[MAXN][MAXN];\nint min0=1000000000;\nint t;\nint map1[3][3]={1,2,3,4,5,6,7,8,0};\nbool hx[40000009];\nbool pd(){\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tif(map[i][j]!=map1[i][j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\nvoid syf(int x,int y,int tot){\n\tif(pd()){\n\t\tif(tot<min0) min0=tot;\n\t\treturn;\n    }\n    else if(tot>28) return;\n\telse{\n\t\tint g=1;\n\t\tif(x+1<3){\n\t\t\tt=map[x][y];\n\t\t\tmap[x][y]=map[x+1][y];\n\t\t\tmap[x+1][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=40000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x+1,y,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x+1][y];\n\t\t\tmap[x+1][y]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(x-1>=0){\n\t\t\tt=map[x][y];\n\t\t\tmap[x][y]=map[x-1][y];\n\t\t\tmap[x-1][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=40000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x-1,y,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x-1][y];\n\t\t\tmap[x-1][y]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(y+1<3){\n\t\t\tt=map[x][y+1];\n\t\t\tmap[x][y+1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=40000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x,y+1,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x][y+1];\n\t\t\tmap[x][y+1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(y-1>=0){\n\t\t\tt=map[x][y-1];\n\t\t\tmap[x][y-1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=40000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x,y-1,tot+1);\n\t\t\t    hx[g]=0;\n\t\t\t}\n\t\t\tt=map[x][y-1];\n\t\t\tmap[x][y-1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t}\n}\nvoid input(){\n\tint x1,y1;\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tcin>>map[i][j];\n\t\t\tif(map[i][j]==0){\n\t\t\t\tx1=i;\n\t\t\t\ty1=j;\n\t\t\t}\n\t\t}\n\t}\n\tint g=1;\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tg=g*10+map[i][j];\n\t\t\tg%=10000007;\n\t\t}\n\t}\n\thx[g]=1;\n\tsyf(x1,y1,0);\n\tcout<<min0<<endl;\n}\nint main(){\n\tinput();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define INF 1e9\n#define LIMIT 16\ntypedef vector<int> Vec;\n \nconst int dx[] = {-1,0,0,1};\nconst int dy[] = {0,-1,1,0};\nint res;\nbool flg;\n \nbool inField(int y,int x){\n  return 0 <= y && y < 3 && 0 <= x && x < 3; \n}\n \nbool check(Vec &vec){\n  for(int i = 0 ; i < 8 ; i++){\n    if(vec[i] != i+1) return false;\n  }\n  return true;\n}\n \nvoid solve(Vec &start,int z,map<Vec,int> &cost){\n  queue<Vec> Q;\n  queue<int> zero;\n  Q.push(start); zero.push(z);\n  cost[start] = 0;\n   \n  while(!Q.empty()){\n    Vec now = Q.front(); Q.pop();\n    int pos = zero.front(); zero.pop();\n    int x = pos % 3, y = pos / 3;\n    if(!flg && check(now)){\n      res = cost[now];\n      return;\n    }\n    if(cost[now] == LIMIT) break;\n    for(int i = 0 ; i < 4 ; i++){\n      int nx = x + dx[i], ny = y + dy[i];\n      if(!inField(ny,nx)) continue;\n      vector<int> next = now;\n      swap(next[pos],next[ny*3+nx]);\n      if(!cost.count(next)){\n        cost[next] = cost[now] + 1;\n        Q.push(next);\n        zero.push(ny*3+nx);\n      }\n    }\n  }\n}\n \nint main(){\n  int z = -1;\n  vector<int> start(9),goal(9);\n  for(int i = 0 ; i < 9 ; i++){\n    cin >> start[i];\n    goal[i] = i+1;\n    if(start[i] == 0) z = i;\n  }\n  goal[8] = 0;\n  res = INF; flg = false;\n  map<Vec,int> s2v,g2v;\n  solve(start,z,s2v);\n  if(res == INF){\n    flg = true;\n    solve(goal,8,g2v);\n  }\n  map<Vec,int>::iterator s,g;\n  for(s = s2v.begin() ; s != s2v.end() ; ++s){\n    if(g2v[s->first]){\n      res = min(res,s->second+g2v[s->first]);\n    }\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n#define N 3\nint po[N*N+10];\nint m2i(mat m){\n  int res=0;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      res+=m[i][j]*po[i*N+j];\n  return res;\n}\nmat i2m(int x){\n  mat res(N,vec(N));;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      res[i][j]=(x%po[i*N+j+1])/po[i*N+j];\n  return res;\n}\n\nsigned main(){\n  po[0]=1;\n  for(int i=0;i<N*N;i++) po[i+1]=po[i]*10;\n  mat p(N,vec(N));\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      cin>>p[i][j];\n  mat e(p);\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      e[i][j]=i*N+j+1;\n  e[N-1][N-1]=0;\n  int ans=m2i(e);\n  //cout<<ans<<endl;\n  queue<int> q;\n  map<int,int> m;\n  q.push(m2i(p));\n  m[m2i(p)]=0;\n  int ax[]={1,0,-1,0};\n  int ay[]={0,1,0,-1};\n  while(!q.empty()){\n    int x=q.front();q.pop();\n    if(x==ans) break;\n    //cout<<x<<endl;\n    p=i2m(x);\n    int zy,zx;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n\tif(p[i][j]==0) zy=i,zx=j;\n    //cout<<zy<<\" \"<<zx<<endl;\n    for(int k=0;k<4;k++){\n      int ny=zy+ay[k],nx=zx+ax[k];\n      if(ny<0||N<=ny||nx<0||N<=nx) continue;\n      swap(p[zy][zx],p[ny][nx]);\n      int t=m2i(p);\n      //cout<<t<<endl;\n      if(!m.count(t)){\n\tm[t]=m[x]+1;\n\tq.push(t);\n      }\n      swap(p[zy][zx],p[ny][nx]);\n    }\n  }\n  cout<<m[ans]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n#define X 3\n#define Y 3\n#define THRESHOLD 2\nint manhattan(int x1,int y1,int x2,int y2){\n\treturn abs(x1-x2)+abs(y1-y2);\n}\nint calc(vector<int>&v){\n\tint s=0;\n\tfor(int coor=0;coor<X*Y;coor++){\n\t\tif(v[coor]!=0){\n\t\t\ts+=manhattan(coor%X,coor/X,(v[coor]-1)%X,(v[coor]-1)/X);\n\t\t}else{\n\t\t\ts+=manhattan(coor%X,coor/X,X-1,Y-1);\n\t\t}\n\t}\n\treturn s;\n}\nint main(){\n\tint i=1,start_point;\n\tvector<int>start(X*Y),goal;\n\tfor(;i<X*Y;i++)goal.push_back(i);goal.push_back(0);\n\tfor(i=0;i<X*Y;i++){\n\t\tscanf(\"%d\",&start[i]);\n\t\tif(start[i]==0)start_point=i;\n\t}\n\tif(start==goal){puts(\"0\");return 0;}\n\n\tmap<vector<int>,pair<int,int> >mstart,mgoal;\n\tqueue<pair<vector<int>,bool> >q;\n\tmstart[start]=make_pair(start_point,0);\n\tmgoal[goal]=make_pair(X*Y-1,0);\n\tq.push(make_pair(start,false));\n\tq.push(make_pair(goal,true));\n\tfor(;!q.empty();){\n\t\tvector<int> v=q.front().first;\n\t\tbool f=q.front().second;\n\t\tq.pop();\n\t\tint val=calc(v);\n\t\tmap<vector<int>,pair<int,int> >&m=f?mgoal:mstart;\n\t\tmap<vector<int>,pair<int,int> >&m2=f?mstart:mgoal;\n\t\tint coor=m[v].first,x=coor%X,y=coor/X;\n\t\tint depth=m[v].second;\n\t\tif(0<x){\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor-1,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t}\n\t\tif(x<X-1){\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor+1,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t}\n\t\tif(0<y){\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor-X,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t}\n\t\tif(y<Y-1){\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor+X,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < ( const Puzzle &p ) const {\n    for ( int i = 0; i < N2; i++ ) {\n      if ( f[i] == p.f[i] ) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n  for ( int i = 0; i < N2; i++ )\n    if ( p.f[i] != (i + 1) ) return false;\n  return true;\n}\n\nstring bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while ( !Q.empty() ) {\n    u = Q.front(); Q.pop();\n    if ( isTarget(u) ) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for ( int r = 0; r < 4; r++ ) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if ( !V[v] ) {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main() {\n  Puzzle in;\n\n  for ( int i = 0; i < N2; i++ ) {\n    cin >> in.f[i];\n    if ( in.f[i] == 0 ) {\n      in.f[i] = N2;  // set space\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct point{\n\tstring s;\n\tstring path;\n\tint k;\n\tint i;\n};\nstring s;\nunordered_map<string,bool>vis;\nqueue<point> q;\nint jb;\nvoid solve(){\n\tpoint p;\n\tp.s=s;p.i=jb;p.k=0;\n\tq.push(p);\n\twhile(!q.empty()){\n\t\tp=q.front();q.pop();\n\t\tstring path=p.path;\n\t\tif(vis[p.s])continue;\n\t\tif(p.s==\"123456780\"){\n\t\t\tcout<<p.k<<\"\\n\";\n//\t\t\tcout<<p.path<<\"\\n\";\n\t\t\texit(0);\n\t\t}\n//\t\tcout<<p.s<<endl;\n\t\tvis[p.s]=1;\n\t\tp.k+=1;\n\t\tif(p.k==5){\n\t\t\tp.k=p.k;\n\t\t}\n\t\tint i=p.i;\n\t\tif(i-3>=0){\n\t\t\tswap(p.s[i],p.s[i-3]);\n\t\t\tp.i=i-3;\n\t\t\tp.path=path+\"u\";\n\t\t\tq.push(p);\n\t\t\tswap(p.s[i],p.s[i-3]);\n\t\t}\n\t\tif(i-1>=0&&i%3!=0){\n\t\t\tswap(p.s[i],p.s[i-1]);\n\t\t\tp.i=i-1;\n\t\t\tp.path=path+\"l\";\n\t\t\tq.push(p);\n\t\t\tswap(p.s[i],p.s[i-1]);\n\t\t}\n\t\tif(i+3<9){\n\t\t\tswap(p.s[i],p.s[i+3]);\n\t\t\tp.i=i+3;\n\t\t\tp.path=path+\"d\";\n\t\t\tq.push(p);\n\t\t\tswap(p.s[i],p.s[i+3]);\n\t\t}\n\t\tif(i+1<9&&(i+1)%3!=0){\n\t\t\tswap(p.s[i],p.s[i+1]);\n\t\t\tp.i=i+1;\n\t\t\tp.path=path+\"r\";\n\t\t\tq.push(p);\n\t\t\tswap(p.s[i],p.s[i+1]);\n\t\t}\n\t}\t\n}\nint main(){\n//\tfreopen(\"a.txt\",\"r\",stdin);\n//\tfreopen(\"b.txt\",\"w\",stdout);\n\tchar tc;\n\tfor(int i=0;i<9;i++){\n\t\tcin>>tc;\n\t\tif(tc=='0')jb=i;\n\t\ts+=tc;\n\t}\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst static int N = 3;\nconst static int N2 = 9;\nconst static int dx[4] = {-1, 0, 1, 0};\nconst static int dy[4] = {0, -1, 0, 1};\nconst static char dir[4] = {'u', 'l', 'd', 'r'};\n\nstruct Puzzle{\n    int f[N2];\n    int space;\n    std::string path;\n\n    bool operator <(const Puzzle &p) const{\n        for(int i = 0; i < N2; i++){\n            if(f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nbool isTarget(Puzzle p){\n    for(int i = 0; i < N2; i++){\n        if(p.f[i] != i+1) return false;\n    }\n    return true;\n}\n\n\n\nstd::string bfs(Puzzle s){\n    std::queue<Puzzle> Q;\n    std::map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while(!Q.empty()){\n        u = Q.front(); Q.pop();\n        if(isTarget(u) ) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for(int r = 0; r < 4; r++){\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            std::swap(v.f[u.space], v.f[tx*N+ty]);\n            v.space = tx * N + ty;\n            if(!V[v]){\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n\n    return \"unsolvable\";\n\n}\n\nint main(void){\n    Puzzle in;\n\n    for(int i = 0; i < N2; i++){\n        std::cin >> in.f[i];\n        if(in.f[i] == 0){\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    std::string ans = bfs(in);\n    std::cout << ans.size() << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define M 9\nstruct Puzzle{\n  int f[M];\n  int space;\n  string path;\n  bool operator < (const Puzzle &p) const{\n    for(int i=0;i<M;i++){\n      if(f[i]==p.f[i]) continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\nbool kansuu(Puzzle p){\n  for(int i=0;i<M;i++){\n    if(p.f[i]!=(i+1))return false;\n  }\n  return true;\n}\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n  while(!Q.empty()){\n    u=Q.front();\n    Q.pop();\n    if(kansuu(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N)continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n    \tV[v]=true;\n    \tv.path+=dir[r];\n    \tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\nint main(){\n  Puzzle in;\n  for(int i=0;i<M;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=M;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout << ans.size() << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst vector<int> dx = {-1, 0, 1, 0};\nconst vector<int> dy = {0, -1, 0, 1};\n\nll to_id(const vector<vector<int>> &board) {\n    ll acc = 0;\n    for (int i = 0; i < 9; i++) {\n        int row = i / 3;\n        int col = i % 3;\n        acc = acc * 10 + board[row][col];\n    }\n    return acc;\n}\n\nvector<vector<int>> to_board(ll id) {\n    vector<vector<int>> board(3, vector<int>(3));\n    for (int i = 2; i >= 0; i--) {\n        for (int j = 2; j >= 0; j--) {\n            board[i][j] = id % 10;\n            id /= 10;\n        }\n    }\n    return board;\n}\n\n// {row, col}\npair<int, int> find(const int v, const vector<vector<int>> &board) {\n    int row;\n    int col;\n    for (int i = 0; i < 9; i++) {\n        row = i / 3;\n        col = i % 3;\n        if (board[row][col] == v) break;\n    }\n    return {row, col};\n}\n\nvoid print_board(const vector<vector<int>> &board) {\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            printf(\"%d \", board[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n\nset<ll> visited;\n\nint main(void) {\n    vector<vector<int>> start(3, vector<int>(3));\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            cin >> start[i][j];\n        }\n    }\n\n    const vector<vector<int>> goal = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 0}\n    };\n    const auto goal_id = to_id(goal);\n\n    // {id, dist}\n    queue<pair<ll, int>> q;\n    auto start_id = to_id(start);\n    q.push({start_id, 0});\n    visited.insert(start_id);\n\n    if (start_id == goal_id) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    int ans = -1;\n    while (!q.empty()) {\n        const auto node = q.front();\n        q.pop();\n        const auto cur_board_id = node.first;\n        const auto cur_board = to_board(cur_board_id);\n        const auto cur_dist = node.second;\n        const auto zero_pos = find(0, cur_board);\n        // print_board(cur_board);\n\n        for (int i = 0; i < 4; i++) {\n            auto b = cur_board;\n            const int next_row = zero_pos.first + dy[i];\n            const int next_col = zero_pos.second + dx[i];\n            if (next_row < 0 || next_row > 2 || next_col < 0 || next_col > 2) continue;\n\n            swap(b[zero_pos.first][zero_pos.second], b[next_row][next_col]);\n            auto id = to_id(b);\n            auto dist = cur_dist + 1;\n            if (visited.find(id) != visited.end()) continue;\n            visited.insert(id);\n            if (id == goal_id) {\n                ans = dist;\n                break;\n            }\n            q.push({id, dist});\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <clocale>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(false); cin.tie(0);\n#define FOR(i, s, n) for(int i = (s), i##_len=(n); i < i##_len; ++i)\n#define FORS(i, s, n) for(int i = (s), i##_len=(n); i <= i##_len; ++i)\n#define VFOR(i, s, n) for(int i = (s); i < (n); ++i)\n#define VFORS(i, s, n) for(int i = (s); i <= (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPS(i, n) FORS(i, 0, n)\n#define VREP(i, n) VFOR(i, 0, n)\n#define VREPS(i, n) VFORS(i, 0, n)\n#define RFOR(i, s, n) for(int i = (s), i##_len=(n); i >= i##_len; --i)\n#define RFORS(i, s, n) for(int i = (s), i##_len=(n); i > i##_len; --i)\n#define RREP(i, n) RFOR(i, n, 0)\n#define RREPS(i, n) RFORS(i, n, 0)\n#define ALL(v) (v).begin(), (v).end()\n#define SORT(v) sort(ALL(v))\n#define RSORT(v) sort(ALL(v), greater<decltype(v[0])>())\n#define SZ(x) ((int)(x).size())\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n\nusing ll = long long;\nusing Pi_i = pair<int, int>;\nusing VB = vector<bool>;\nusing VC = vector<char>;\nusing VD = vector<double>;\nusing VI = vector<int>;\nusing VLL = vector<ll>;\nusing VS = vector<string>;\nusing VSH = vector<short>;\n\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst int NIL = -1;\n\ntemplate<class T, class S>\nbool chmax(T &a, const S &b){\n    if(a < b){\n        a = b; return true;\n    }\n    return false;\n}\ntemplate<class T, class S>\nbool chmin(T &a, const S &b){\n    if(b < a){\n        a = b; return true;\n    }\n    return false;\n}\n\n\nconst int N = 3;\nconst int NN = N * N;\nstruct Puzzle{\n    int num[NN] = {};\n    int space = NIL;\n    string path;\n\n    bool operator<(const Puzzle &b) const{\n        REP(i, NN){\n            if(num[i] == b.num[i]) continue;\n            return num[i] < b.num[i];\n        }\n        return false;\n    }\n};\n\nint dx[4] = {-1, 0, 0, 1};\nint dy[4] = {0, -1, 1, 0};\nchar dir[4] = {'u', 'l', 'r', 'd'};\n\nbool isGoal(Puzzle& p){\n    REP(i, NN)\n        if(p.num[i] != i+1) return false;\n    return true;\n}\n\nstring bfs(Puzzle s){\n    queue<Puzzle> que;\n    map<Puzzle, bool> mp;\n    s.path = \"\";\n    que.push(s);\n    mp[s] = true;\n\n    while(!que.empty()){\n        Puzzle p = que.front(); que.pop();\n        if(isGoal(p)) return p.path;\n        int px = p.space / N;\n        int py = p.space % N;\n        REP(i, 4){\n            int nx = px + dx[i];\n            int ny = py + dy[i];\n            if(nx<0 || ny<0 || nx>=N || ny>=N)\n                continue;\n            Puzzle q = p;\n            swap(q.num[q.space], q.num[nx*N + ny]);\n            q.space = nx*N + ny;\n            if(!mp[q]){\n                mp[q] = true;\n                q.path += dir[i];\n                que.push(q);\n            }\n        }\n    }\n    return \"\";\n}\n\nint main(){\n    Puzzle in;\n    REP(i, NN){\n        cin >> in.num[i];\n        if(in.num[i] == 0){\n            in.num[i] = NN;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.length() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const {\n    for(int i = 0;i < N2;i++){\n      if(f[i] == p.f[i])\n\t{\n\t  continue;\n\t}\n      \n      return f[i] > p.f[i];\n    }\n    \n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p);\nstring bfs(Puzzle s);\n\nint main(void){\n  int i;\n  Puzzle in;\n  string ans;\n  \n  for(i = 0;i < N2;i++){\n    cin >> in.f[i];\n      \n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n      \n  }\n  \n  ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n\nbool isTarget(Puzzle p){\n  for(int i = 0;i < N2;i++){\n    if(p.f[i] != (i+1)){\n      return false;\n    }\n  }\n  \n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool>V;\n  Puzzle u,v;\n  \n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n      \n    if(isTarget(u)){\n      return u.path;\n    }\n    \n    int sx = u.space/N;\n    int sy = u.space%N;\n    \n    for(int r = 0;r < 4;r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      \n      if(tx < 0 || ty < 0 || tx >= N || ty >= N){\n\tcontinue;\n      }\n      v = u;\n      \n      swap(v.f[u.space] , v.f[tx*N + ty]);\n      \n      v.space = tx*N + ty;\n      \n      if(!V[v]){\n\tV[v] = true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\n\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n#define N 3\ntypedef pair<int, int> P;\n\nstruct State {\n    int g, h;\n    string state;\n    P blank;\n    string path;\n    bool operator<(const State &a) const {\n        return g + h > a.g + a.h;\n    }\n};\n\nint d[5] = {-1, 0, 1, 0, -1};\nstring r[4] = {\"D\", \"R\", \"U\", \"L\"};\nstring ans_str = \"\";\nint ans[N][N], puzzle0[N][N], puzzle1[N][N];\nset<string> s;\npriority_queue<State> next_state;\nstring path;\n\nbool range(int y, int x) {return 0 <= y && y < N && 0 <= x && x < N;}\n\nint h1() {\n    int find = -1;\n    while(next_state.size()) {\n        State state = next_state.top();\n        next_state.pop();\n        if (s.count(state.state)) continue; // already search\n        s.insert(state.state); // visited\n\n        P blank = state.blank;\n        rep(i, 4) {\n            int y = d[i] + blank.first, x = d[i + 1] + blank.second; // next blank position\n            if (range(y, x)) { // can be replaced\n                string tmp = state.state; // next state (string)\n                int wrong_place = state.h, p = blank.first * N + blank.second, q = y * N + x;\n                if (N < 4) {\n                    swap(tmp[p], tmp[q]);\n                    wrong_place = wrong_place - (state.state[q] != ans_str[q]) + (state.state[q] != ans_str[p]);\n                } else {\n                    swap(tmp[2 * p], tmp[2 * q]), swap(tmp[2 * p + 1], tmp[2 * q + 1]);\n                    wrong_place = wrong_place - (state.state.substr(2 * q, 2) != ans_str.substr(2 * q, 2))\n                    + (state.state.substr(2 * q, 2) != ans_str.substr(2 * p, 2));\n                }\n                if (s.count(tmp)) continue; // already search\n\n                if (wrong_place == 0) { // answer\n                    find = state.g + 1;\n                    path = state.path + r[i];\n                    break;\n                }\n\n                next_state.push(State{state.g + 1, wrong_place, tmp, P(y, x), state.path + r[i]});\n            }\n        }\n        if (find != -1) break; // find an answer\n    }\n    return find;\n}\n\nint main(){\n    // create answer's numbers\n    iota(ans[0], ans[0] + N * N, 1);\n    ans[N - 1][N - 1] = 0;\n    // create number\n    iota(puzzle0[0], puzzle0[0] + N * N, 0);\n    rep(i, N)rep(j, N) cin >> puzzle0[i][j];\n\n    string state = \"\";\n    P blank;\n    int manhattan = 0, wrong_place = 0;\n    rep(i, N)rep(j, N) {\n        state += to_string(puzzle0[i][j]);\n        ans_str += to_string(ans[i][j]);\n\n        if(puzzle0[i][j] == 0) blank = P(i, j);\n        else {\n            int num = puzzle0[i][j] - 1;\n            manhattan += (abs(num / N - i) + abs(num % N - j));\n            if (puzzle0[i][j] != ans[i][j]) wrong_place++;\n        }\n    }\n\n    if (manhattan == 0) { // the answer\n        cout << 0 << endl;\n    } else {\n        int steps;\n        next_state.push(State{0, wrong_place, state, blank, \"\"});\n        steps = h1();\n        cout << steps << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n    int f[N2]; int space; string path;\n    bool operator<(const Puzzle &p) const{\n    for(int i=0;i<N2;i++){\n        if(f[i]==p.f[i]) continue;\n        return f[i]>p.f[i];\n    }\n    return false;\n    }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n    for(int i=0;i<N2;i++){\n        if(p.f[i]!=(i+1)) return false;\n    }\n     return true;    \n}\n\nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle,bool> V;\n    Puzzle u,v;\n    s.path=\"\";\n    Q.push(s);\n    V[s]=true;\n\n    while (!Q.empty()){\n        u=Q.front();Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx=u.space/N;\n        int sy=u.space%N;\n        for(int r=0;r<4;r++){\n            int tx=sx+dx[r];\n            int ty=sy+dy[r];\n            if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n            v=u;\n            swap(v.f[u.space],v.f[tx*N+ty]);\n            v.space=tx*N+ty;\n            if(!V[v]){\n                V[v]=true;\n                v.path+=dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main(){\n    Puzzle in;\n\n    for(int i=0;i<N2;i++){\n        cin>>in.f[i];\n        if(in.f[i]==0){\n            in.f[i]=N2;\n            in.space=i;\n        }\n    }\n    string ans=bfs(in);\n    cout<<ans.size()<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <list>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL =     1      | 2 << (1*4)  | 3 << (2*4)\n                 | 4 << (3*4) | 5 << (4*4)  | 6 << (5*4)\n                 | 7 << (6*4) | 8LL << (7*4) | 0LL << (8*4);\n\nstruct state {\n    Board board;\n    int count;\n};\n\nlist<state> q;\n//vector<state> q;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    for (list<state>::iterator it = q.begin(); it != q.end(); ++it) {\n//    for (vector<state>::iterator it = q.begin(); it != q.end(); ++it) {\n        if (it->board == s.board) {\n            return -1;\n        }\n    }\n    ++s.count;\n    if (s.board == GOAL) {\n        return s.count;\n    }\n    q.push_back(s);\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\nint main(void) {\n\n    Board board = 0;\n    int i = 0;\n    while (i != N) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            board |= static_cast<long long>((ch - '0')) << (i*4);\n            ++i;\n        }\n    }\n\n//    print(GOAL);\n//    print(board);\n\n    q.push_back({ board, 0 });\n    int count = 0;\n    while (!q.empty()) {\n        state s = q.front();\n        q.pop_front();\n        // ?????????????????????\n        int pos;\n        for (int i = 0; i < N; ++i) {\n            if (((s.board >> (i*4)) & 15) == 0) {\n                pos = i;\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n\nusing namespace std;\n\nint checkTable[362880];\n\nvoid setNUM(int table[3][3], long long x){\n    int S = 100000000;\n    for(int i=0;i<3;i++){\n        for(int k=0;k<3;k++){\n            table[i][k] = x/S;\n            x = x%S;\n            S /= 10;\n        }\n    }\n}\n\nint getNUM(int x){\n    switch(x){\n    case 0:return 1;\n    case 1:return 1;\n    case 2:return 2;\n    case 3:return 6;\n    case 4:return 24;\n    case 5:return 120;\n    case 6:return 720;\n    case 7:return 5040;\n    case 8:return 40320;\n    }\n    return -1;\n}\n\nlong long makeLong(int Table[3][3]){\n    return 100000000*Table[0][0]+10000000*Table[0][1]+1000000*Table[0][2]+\n            100000*Table[1][0]+10000*Table[1][1]+1000*Table[1][2]+ 100*Table[2][0]+\n            10*Table[2][1]+Table[2][2];\n}\n\nint translateORDER(int Table[3][3]){\n    long long x = makeLong(Table);\n    int checkTable[9] = {0};\n    long long S = 100000000;\n    int ret = 0,small_num_appear_count;\n    for(int i=8; i >= 0; i--){\n        small_num_appear_count=0;\n        for(int k = 0; k < (x/S);k++){\n            if(checkTable[k] == 1)small_num_appear_count++;\n        }\n        ret += ((x/S)-small_num_appear_count)*getNUM(i);\n        checkTable[(x/S)]=1;\n        x %= S;\n        S /= 10;\n    }\n\n    return ret;\n}\n\n\nint zeroLoc(int table[3][3]){\n    int zero_loc;\n    for(int i=0;i<3;i++){\n        for(int k=0;k<3;k++){\n            if(table[i][k]==0){\n                zero_loc=10*i+k;\n            }\n        }\n    }\n    return zero_loc;\n}\n\nstruct Info{\n    Info(){ zero_loc=data = count = 0;}\n    Info(long long arg_data,int arg_count,short arg_loc){\n        data = arg_data;\n        count = arg_count;\n        zero_loc = arg_loc;\n    }\n    long long data;\n    int count;\n    short zero_loc;\n};\n\nclass LongQ{\npublic:\n    LongQ(){\n        Q = new Info[362880];\n        head = tail = num_of_data=0;\n    }\n\n    void enqueue(long long arg_data,int arg_count,short arg_loc){\n        Q[tail].count = arg_count;\n        Q[tail].data = arg_data;\n        Q[tail].zero_loc = arg_loc;\n        num_of_data++;\n        tail = (tail+1)%362880;\n    }\n\n    Info dequeue(){\n        Info ret = Q[head];\n        head = (head+1)%362880;\n        num_of_data--;\n        return ret;\n    }\n\n    bool isEmpty(){\n        return num_of_data == 0;\n    }\n\nprivate:\n    Info* Q;\n    int head,tail,num_of_data;\n};\n\nLongQ func(LongQ queue,int table[3][3],Info tmpInfo,short zero_loc){\n    if(checkTable[translateORDER(table)] == -1){\n        checkTable[translateORDER(table)]=tmpInfo.count;\n        queue.enqueue(makeLong(table),tmpInfo.count+1,zero_loc);\n    }\n    return queue;\n}\n\nint main(){\n\n    for(int i = 0; i < 362880;i++)checkTable[i]=-1;\n\n    int table[3][3];\n\n    for(int i=0;i<3;i++){\n        scanf(\"%d %d %d\",&table[i][0],&table[i][1],&table[i][2]);\n    }\n\n    checkTable[translateORDER(table)]=0;\n    LongQ queue;\n\n    queue.enqueue(makeLong(table),0,zeroLoc(table));\n\n    Info tmpInfo;\n\n    while(queue.isEmpty()==false){\n        tmpInfo=queue.dequeue();\n\n        int tmpTable[3][3];\n        setNUM(tmpTable,tmpInfo.data);\n        if(tmpTable[0][0]==1&&tmpTable[0][1]==2&&tmpTable[0][2]==3&&tmpTable[1][0]==4&&\n        \t\ttmpTable[1][1]==5&&tmpTable[1][2]==6&&tmpTable[2][0]==7&&tmpTable[2][1]==8){\n            printf(\"%d\\n\",tmpInfo.count);\n            break;\n        }\n\n        int next_table[4][3][3];\n\n        for(int a=0;a<4;a++){\n            for(int b=0;b<3;b++){\n                for(int c=0;c<3;c++){\n                    next_table[a][b][c] = tmpTable[b][c];\n                }\n            }\n        }\n\n        switch(tmpInfo.zero_loc){\n        case 0:\n            swap(next_table[0][0][0],next_table[0][0][1]);\n            queue = func(queue,next_table[0],tmpInfo,1);\n\n            swap(next_table[1][0][0],next_table[1][1][0]);\n            queue = func(queue,next_table[1],tmpInfo,10);\n            break;\n        case 1:\n            swap(next_table[0][0][1],next_table[0][0][0]);\n            queue = func(queue,next_table[0],tmpInfo,0);\n\n            swap(next_table[1][0][1],next_table[1][0][2]);\n            queue = func(queue,next_table[1],tmpInfo,2);\n\n            swap(next_table[2][0][1],next_table[2][1][1]);\n            queue = func(queue,next_table[2],tmpInfo,11);\n            break;\n        case 2:\n            swap(next_table[0][0][2],next_table[0][0][1]);\n            queue = func(queue,next_table[0],tmpInfo,1);\n\n            swap(next_table[1][0][2],next_table[1][1][2]);\n            queue = func(queue,next_table[1],tmpInfo,12);\n\n            break;\n        case 10:\n            swap(next_table[0][1][0],next_table[0][0][0]);\n            queue = func(queue,next_table[0],tmpInfo,0);\n\n            swap(next_table[1][1][0],next_table[1][1][1]);\n            queue = func(queue,next_table[1],tmpInfo,11);\n\n            swap(next_table[2][1][0],next_table[2][2][0]);\n            queue = func(queue,next_table[2],tmpInfo,20);\n\n            break;\n        case 11:\n            swap(next_table[0][1][1],next_table[0][0][1]);\n            queue = func(queue,next_table[0],tmpInfo,1);\n\n            swap(next_table[1][1][1],next_table[1][1][0]);\n            queue = func(queue,next_table[1],tmpInfo,10);\n\n            swap(next_table[2][1][1],next_table[2][1][2]);\n            queue = func(queue,next_table[2],tmpInfo,12);\n\n            swap(next_table[3][1][1],next_table[3][2][1]);\n            queue = func(queue,next_table[3],tmpInfo,21);\n            break;\n        case 12:\n            swap(next_table[0][1][2],next_table[0][0][2]);\n            queue = func(queue,next_table[0],tmpInfo,2);\n\n            swap(next_table[1][1][2],next_table[1][1][1]);\n            queue = func(queue,next_table[1],tmpInfo,11);\n\n            swap(next_table[2][1][2],next_table[2][2][2]);\n            queue = func(queue,next_table[2],tmpInfo,22);\n            break;\n        case 20:\n            swap(next_table[0][2][0],next_table[0][1][0]);\n            queue = func(queue,next_table[0],tmpInfo,10);\n\n            swap(next_table[1][2][0],next_table[1][2][1]);\n            queue = func(queue,next_table[1],tmpInfo,21);\n            break;\n        case 21:\n            swap(next_table[0][2][1],next_table[0][2][0]);\n            queue = func(queue,next_table[0],tmpInfo,20);\n\n            swap(next_table[1][2][1],next_table[1][1][1]);\n            queue = func(queue,next_table[1],tmpInfo,11);\n\n            swap(next_table[2][2][1],next_table[2][2][2]);\n            queue = func(queue,next_table[2],tmpInfo,22);\n            break;\n        case 22:\n            swap(next_table[0][2][2],next_table[0][1][2]);\n            queue = func(queue,next_table[0],tmpInfo,12);\n\n            swap(next_table[1][2][2],next_table[1][2][1]);\n            queue = func(queue,next_table[1],tmpInfo,21);\n            break;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define NUM 3\n#define PRUNING 20\n\ntypedef struct STATUS{\n    int num;\n    int board[NUM][NUM];\n}STATUS;\n\nbool checkfinish(STATUS in){\n    \n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            if (i == NUM - 1 && j == NUM - 1) return true;\n            if(in.board[i][j] != val++) return false;\n        }\n    }\n    return true;\n}\n\n\nint backtrack(STATUS in){\n\n    int x = 0, y = 0, ret = PRUNING;\n    STATUS out;\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    \n    if (in.num > ret) {\n        return ret;\n    }\n    \n    if (checkfinish(in)) {\n        return in.num;\n    }\n\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            if(in.board[i][j] == 0){\n                x = j;\n                y = i;\n            }\n        }\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (x + dx[i] >=0 && x+dx[i] < NUM && y+dy[i] >=0 && y+dy[i] < NUM) {\n            memcpy(&out, &in, sizeof(STATUS));\n            swap(out.board[y][x], out.board[y+dy[i]][x+dx[i]]);\n            out.num++;\n            ret = min(ret, backtrack(out));\n        }\n    }\n    return ret;\n}\n\n\nint main(){\n    \n    int val, ans;\n    \n    STATUS init;\n    init.num = 0;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            cin >> val;\n            init.board[i][j] = val;\n        }\n    }\n    \n    ans = backtrack(init);\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nbool ok(int a[3][3])\n{\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tif (a[i / 3][i % 3] != i + 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstruct puzzle\n{\n\tint board[3][3];\n\tint distance;\n};\n\nconst int dx[4] = { 0, -1, 1, 0 };\nconst int dy[4] = { -1, 0, 0, 1 };\n\nint main() \n{\n\tpuzzle start;\n\n\tstart.distance = 0;\n\n\tfor (int i = 0; i < 3; i++)\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tcin >> start.board[i][j];\n\n\tqueue<puzzle> que; que.push(start);\n\n\tint Ans = 0;\n\n\tif (ok(start.board) == false)\n\t{\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tpuzzle p = que.front(); que.pop();\n\n\t\t\tint x, y;\n\n\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t\t{\n\t\t\t\t\tif (p.board[i][j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t\t{\n\t\t\t\tif (0 <= x + dx[dir] && x + dx[dir] < 3 && 0 <= y + dy[dir] && y + dy[dir] < 3)\n\t\t\t\t{\n\t\t\t\t\tpuzzle q = p;\n\n\t\t\t\t\tswap(q.board[y][x], q.board[y + dy[dir]][x + dx[dir]]);\n\n\t\t\t\t\tq.distance = p.distance + 1;\n\n\t\t\t\t\tif (ok(q.board) == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tAns = q.distance; goto Exit;\n\t\t\t\t\t}\n\n\t\t\t\t\tque.push(q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExit:;\n\n\tcout << Ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Puzzle {\n    int f[9];\n    int space;\n    string path = \"\";\n\n    bool operator < (const Puzzle& p) const {\n        for(int i = 0; i < 9; i++) {\n            if(f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nconst int nxt[][2] = {{-1,0},{0,-1},{1,0},{0,1} };\nconst char dir[] = {'u','l','d','r'};\n\ninline bool isTarget(Puzzle p) {\n    for(int i = 0; i < 9; i++) {\n        if(p.f[i] != (i+1)) return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle s) {\n    queue<Puzzle> Q;\n    map<Puzzle,bool> V; //K-V对表示哪个迷宫(状态)是已经搜索过的了\n    Q.push(s);\n    V[s] = true;\n\n    while(!Q.empty()) {\n        Puzzle u = Q.front(); Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx = u.space / 3;\n        int sy = u.space % 3; // 得到空位所在的行列\n        for(int i = 0; i < 4; i++) {\n            int tx = sx + nxt[i][0];\n            int ty = sy + nxt[i][1]; // 空位旁边所有拼图片\n            if(tx < 0 || ty < 0 || tx >= 3 || ty >= 3) continue;\n            Puzzle v = u;\n            swap(v.f[u.space],v.f[tx*3 + ty]);\n            v.space = tx * 3 + ty;\n            if(!V[v]) {\n                V[v] = true;\n                v.path += dir[i];\n                Q.push(v);\n            }\n        }\n    }\n}\n\nint main() {\n    Puzzle in;\n    for(int i =0; i < 9; i++) {\n        cin >> in.f[i];\n        if(in.f[i] == 0) {\n            in.f[i] = 9;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n// ????????¨?????????24????????±??????????????????\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 40;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nint getAllMD(Puzzle p)\n{\n    int dist = 0;\n    int x, y;\n    int ux, uy;\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] == N2) continue; // ??????0??????\n        x = (p.f[i] - 1) / N;\n        y = (p.f[i] - 1) % N;\n        ux = i / N;\n        uy = i % N;\n        dist += abs(x - ux) + abs(y - uy);\n    }\n    return dist;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i + getAllMD(in)) {\n        return;\n    }\n    \n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n        /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n//    cout << \"MD: \" << getAllMD(in) << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 20;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i) {\n        return;\n    }\n\n    if (in.path == \"ldrd\")\n        int debug = 0;\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n    /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nconst int PATTERN = 362880;\nconst int FORWARD  = 1;\nconst int BACKWARD = 2;\nint frontier[PATTERN];\n\nstruct State {\n    Board board;\n    int count;\n};\n\nqueue<State> q;\n\n// I made this function based on one by Haruhiko Okumura(Algorithm \n// Dictionary, p116) and one by M.Hiroi(Puzzle DE Programming).\ninline int change_number(long long board) {\n    static int fact_table[N] = {\n         40320, 5040, 720, 120, 24, 6, 2, 1, 0      // on N = 8\n    };\n    int value = 0;\n    for (int j = 0; j < N - 1; ++j) {\n        int J = static_cast<int>((board >> (j*4) & 0xF));\n        value += fact_table[j] * J;\n        for (int k = j + 1; k < N; ++k) {\n            int K = static_cast<int>((board >> k*4) & 0xF);\n            if (J < K) {\n                board &= ~(0xFLL << k*4);\n                board |= (static_cast<long long>(K - 1) << k*4);\n            }\n        }\n    }\n//    printf(\"[change_number] value = %d\\n\", value);\n    return value;\n}\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 0xF;\n    board |= num << (spacepos*4);\n    board &= ~(0xFLL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, State s) {\n    int prev = change_number(s.board);\n    int direction = frontier[prev];\n    printf(\"[swap&check] direction = %d\\n\", direction);\n    swap(numpos, spacepos, s.board);\n//    if (s.board == GOAL) {\n//        return ++s.count;\n//    }\n    int pos = change_number(s.board);\n    if (!frontier[pos]) {\n        ++s.count;\n        q.push(s);\n        frontier[pos] = direction;\n        return -1;\n    }\n    else if (frontier[pos] != direction) {\n        ++s.count;\n        printf(\"[swap&check] s.count = %d\\n\", s.count);\n        return s.count * 2;\n    }\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 0xF));\n    }\n    printf(\"\\n\");\n}\n\n// OK\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0, num; i < N; ++i) {\n        scanf(\"%d\", &num);\n        board |= static_cast<long long>(num) << (i*4);\n    }\n//    print(GOAL);\n//    print(board);\n\n    int count = 0;\n    if (board == GOAL) {\n        goto END;\n    }\n\n    frontier[change_number(board)] = FORWARD;\n    frontier[change_number(GOAL)] = BACKWARD;\n\n    q.push({ board, 0 });\n    q.push({ GOAL, 0 });\n    while (!q.empty()) {\n        State s = q.front();\n        q.pop();\n\n        int pos = -1;\n        while (++pos < N) {\n            if (((s.board >> (pos*4)) & 0xF) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <time.h>\n#include <stdlib.h>\n#define N 3\n\nint map[N][N];\nint x0,y0;\nint lim;\nbool check(void){\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(i==N-1&&j==N-1) break;\n\t\t\tif(map[i][j]!=i*N+j+1) return false;\n\t\t}\n\t}\n\tif(map[N-1][N-1]!=0)return false;\n\treturn true;\n}\n\nbool swapping(int x,int y,int dep){\n\tint temp=map[x0+x][y0+y];\n\tmap[x0+x][y0+y]=map[x0][y0];\n\tmap[x0][y0]=temp;\n\tx0+=x;\n\ty0+=y;\n\tif(check()){\n\t\tprintf(\"%d\\n\",dep);\n\t\texit(0);\n\t\treturn true;\n\t}\n\tif(dep<=lim){\n\t\tif(x!=1&&x0-1!=-1) swapping(-1,0,dep+1);\n\t\tif(x!=-1&&x0+1!=N) swapping(1,0,dep+1);\n\t\tif(y!=1&&y0-1!=-1) swapping(0,-1,dep+1);\n\t\tif(y!=-1&&y0+1!=N) swapping(0,1,dep+1);\n\t}\n\ttemp=map[x0-x][y0-y];\n\tmap[x0-x][y0-y]=map[x0][y0];\n\tmap[x0][y0]=temp;\n\tx0-=x;\n\ty0-=y;\n\treturn false;\n}\nint main(void){\n\ttime_t t;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<N;j++){\n\t\t\tscanf(\"%d\",&map[i][j]);\n\t\t\tif(map[i][j]==0){\n\t\t\t\tx0=i;\n\t\t\t\ty0=j;\n\t\t\t}\n\t\t}\n\t}\n\tif(check()){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\ttime_t t0=time(NULL);\n\tfor(lim=1;lim<46;lim++){\n\t\tt=time(NULL);\n//\t\tprintf(\"lim:%d:%lld\\n\",lim,t-t0);\n\t\tt0=t;\n\t\tif(x0-1!=-1) swapping(-1,0,1);\n\t\tif(x0+1!=N) swapping(1,0,1);\n\t\tif(y0-1!=-1) swapping(0,-1,1);\n\t\tif(y0+1!=N) swapping(0,1,1);\n\t}\n//\tprintf(\"Unsolved\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n\n#define A 3\n#define AB 9\n\nstruct pazzle{\n  int f[AB];\n  int space;\n  string path;\n\n  bool operator < (const pazzle &p) const{\n    for(int i=0;i<AB;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(pazzle p){\n  for(int i=0;i<AB;i++)\n    if(p.f[i]!=(i+1))return false;\n  return true;\n}\n\nstring bfs(pazzle s){\n  queue<pazzle> Q;\n  map<pazzle,bool> V;\n  pazzle u,v;\n   s.path = \"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front();\n    Q.pop();\n\n    if(isTarget(u))return u.path;\n\n    int sx = u.space/A;\n    int sy = u.space%A;\n\n    for(int r=0;r<4;r++){\n      int tx = sx+dx[r];\n      int ty = sy+dy[r];\n\n      if(tx<0 || ty<0 || tx>=A || ty>=A)continue;\n\n      v=u;\n      swap(v.f[u.space],v.f[tx*A+ty]);\n      v.space = tx*A+ty;\n      if(!V[v]){\n        V[v]=true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  pazzle in;\n\n  for(int i=0;i<AB;i++){\n    cin >> in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=AB;\n      in.space =i;\n    }\n  }\n string ans = bfs(in);\n cout << ans.size() << endl;\n return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define loop(i,j,k) for(long long i = j;i < k;i++)\n#include <iostream>\n#include <queue>\n#include <array>\n#include <utility>\n#include <stdio.h>\n\nusing namespace std;\n\nbool cp(array<array<int,3>,3>& e) {\n\tloop(i,0,3)loop(j,0,3)if(e[i][j]!=(1+j+i*3)%9)return false;\n\treturn true;\n}\n\nint main() {\n\tarray<array<int,3>,3> pz;\n\tqueue<pair<array<array<int,3>,3> ,int>> q;\n\tloop(i,0,3)loop(j,0,3)cin>>pz[i][j];\n\tq.push(make_pair(pz,0));\n\tif(cp(pz)) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\twhile(!q.empty()) {\n\t\tauto cur = q.front().first;\n\t\tint dep = q.front().second + 1;\n\t\tq.pop();\n\t\tint r=-1,c=-1;\n\t\tloop(i,0,3)loop(j,0,3)if(cur[i][j] == 0){r=i;c=j;}\n\t\tif(r!=2) {\n\t\t\tswap(cur[r][c],cur[r+1][c]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else q.push(make_pair(cur,dep));\n\t\t\tswap(cur[r][c],cur[r+1][c]);\n\t\t}\n\t\tif(r!=0) {\n\t\t\tswap(cur[r][c],cur[r-1][c]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else q.push(make_pair(cur,dep));\n\t\t\tswap(cur[r][c],cur[r-1][c]);\n\t\t}\n\t\tif(c!=2) {\n\t\t\tswap(cur[r][c],cur[r][c+1]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else q.push(make_pair(cur,dep));\n\t\t\tswap(cur[r][c],cur[r][c+1]);\n\t\t}\n\t\tif(c!=0) {\n\t\t\tswap(cur[r][c],cur[r][c-1]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else q.push(make_pair(cur,dep));\n\t\t\tswap(cur[r][c],cur[r][c-1]);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<array>\n\nint search(int);\nint translate(std::array<int, 9>);\n\nstruct BoardStatus {\n\tstd::array<int, 9> arrange = {};\n\tint distance = 0;\n\tint zero_position = 8;\n};\n\nint main()\n{\n\tstd::array<int, 9> board;\n\tfor (int i = 0; i < 9; ++i)\n\t\tstd::cin >> board[i];\n\n\tstd::cout << search(translate(board)) << std::endl;\n\n\treturn 0;\n}\n\nint search(int dest_num)\n{\n    if (dest_num == 46233) return 0;\n\tBoardStatus board = { { 1, 2, 3, 4, 5, 6, 7, 8, 0}, 0, 8 };\n\tstd::vector<BoardStatus> queue;\n\tqueue.push_back(board);\n\tint pre_size = 0;\n\tint table[362880] = { };\n\n\tint move_direction[4] = { 1, -1, 3, -3 };\n\n\twhile (pre_size != queue.size())\n\t{\n\t\tint now_size = queue.size();\n\t\tfor (int queue_i = pre_size; queue_i < now_size; ++queue_i)\n\t\t{\n\t\t\tint zero_pos = queue[queue_i].zero_position;\n\t\t\tbool can_move[4] = {\n\t\t\t\tzero_pos % 3 != 2, zero_pos % 3 != 0,\n\t\t\t\tzero_pos / 3 != 2, zero_pos / 3 != 0\n\t\t\t};\n\t\t\tfor (int condi_i = 0; condi_i < 4; ++condi_i)\n\t\t\t{\n\t\t\t\tif (!can_move[condi_i]) continue;\n\n\t\t\t\tboard = queue[queue_i];\n\t\t\t\tint next_zero = zero_pos + move_direction[condi_i];\n\n\t\t\t\tboard.arrange[board.zero_position] = board.arrange[next_zero];\n\t\t\t\tboard.arrange[next_zero] = 0;\n\t\t\t\tboard.zero_position = next_zero;\n\t\t\t\tboard.distance++;\n\n\t\t\t\tint num_board = translate(board.arrange);\n\t\t\t\tif (!table[num_board] && num_board != 46233)\n\t\t\t\t{\n\t\t\t\t\ttable[num_board] = board.distance;\n\t\t\t\t\tqueue.push_back(board);\n\t\t\t\t}\n\t\t\t\tif (num_board == dest_num)\n\t\t\t\t\treturn board.distance;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint translate(std::array<int , 9> board)\n{\n\tbool used[9]{};\n\tint count = 0, tmp, ret = 0, fac = 362880;\n\tfor (int i = 0; i < 9; ++i)\n\t{\n\t\tcount = 0;\n\t\ttmp = board[i];\n\t\tfor (int j = 0; j < tmp; ++j)\n\t\t\tif (!used[j])\n\t\t\t\tcount++;\n\t\tused[tmp] = true;\n\t\tfac /= 9 - i;\n\t\tret += fac * count;\n\t}\n\treturn ret;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <queue>\n/*\n1 2 3\n4 5 6\n7 0 8\n????????¶????????????????????????3???????????????\n????????????8??????????????????1?????§??????\n\n1 2 3\n4 0 6\n7 5 8\n????????¶?????????5??????????????°1?????§??????????????¢????????????\n\n*/\ntypedef long long int TBoard;\nconst static TBoard Answer = 123456780;\ntypedef std::vector<bool> TTable;\nTBoard InputBoard(std::istream& in)\n{\n    TBoard Board = 0;\n    for(int i = 8; i >= 0; --i){\n        int n;\n        std::cin >> n;\n        Board += std::pow(10, i) * n;\n    }\n    return Board;\n}\nint Encode(const TBoard& Board)\n{\n    return Board / 10;\n}\nTBoard Decode(int Code)\n{\n    int n = 0;\n    while(Code){\n        n += Code % 10;\n        Code /= 10;\n    }\n    int a = 36 - n;\n    return Code * 10 + a;\n    \n}\nstd::vector<TBoard> GetMoved(const TBoard& Board)\n{\n    std::stringstream ss;\n    ss << std::setfill('0') << std::setw(9) << Board;\n    std::string s = ss.str();\n    assert(s.length() == 9);\n    int i = s.find('0');\n    assert(i >= 0);\n    assert(i <= 9);\n    \n    std::vector<TBoard> Result;\n    if(i > 2){\n        std::string copy = s;\n        std::swap(copy[i], copy[i-3]);\n        Result.push_back(std::atoi(copy.c_str()));\n    }\n    if(i < 6){\n        std::string copy = s;\n        std::swap(copy[i], copy[i+3]);\n        Result.push_back(std::atoi(copy.c_str()));\n    }\n    if((i == 0 || i == 3 || i == 6) == false){\n        std::string copy = s;\n        std::swap(copy[i], copy[i-1]);\n        Result.push_back(std::atoi(copy.c_str()));\n    }\n    if((i == 2 || i == 5 || i == 8) == false){\n        std::string copy = s;\n        std::swap(copy[i], copy[i+1]);\n        Result.push_back(std::atoi(copy.c_str()));\n    }\n\n    return Result;\n}\nvoid Print(const TBoard& Board, char c)\n{\n    std::stringstream ss;\n    ss << std::setfill('0') << std::setw(9) << Board;\n    std::string s = ss.str();\n    std::cerr << c << s[0] << \" \" << s[1] << \" \" << s[2] << std::endl;\n    std::cerr << c << s[3] << \" \" << s[4] << \" \" << s[5] << std::endl;\n    std::cerr << c << s[6] << \" \" << s[7] << \" \" << s[8] << std::endl;\n    std::cerr << std::endl;\n}\nint Solve(const TBoard& Board)\n{\n    std::vector<bool> Table(87654321, false);\n    int Cost = 0;\n    std::queue<TBoard> q;\n    q.push(Board);\n    Table[Encode(Board)] = true;\n\n    std::queue<TBoard> temp;\n    while(!q.empty()){\n        TBoard B = q.front();\n        q.pop();\n        // Print(B, ' ');\n        if(B == Answer) return Cost;\n        std::vector<TBoard> Boards = GetMoved(B);\n        for(std::size_t i = 0; i < Boards.size(); ++i){\n            if(Table[Encode(Boards[i])]) continue;\n            temp.push(Boards[i]);\n            Table[Encode(Boards[i])] = true;\n            // Print(Boards[i], '\\t');\n        }\n        if(q.empty()){\n            std::swap(q, temp);\n            ++Cost;\n            // std::cerr << \"Cost\" << Cost << std::endl;\n        }\n    }\n    assert(false);\n}\nint main()\n{\n    TBoard Board = InputBoard(std::cin);\n    std::cout << Solve(Board) << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#define MOD 1000007\n\n#include<iostream>\n#include<cstring>\n#include<cmath>\n#include<set>\n\nusing namespace std;\n\nconst int AIM=87654321;\nconst int inic[]={2,0,1,2,0,1,2,0,1};\nconst int inir[]={2,0,0,0,1,1,1,2,2};\nconst int incr[]={-1,0,1,0};\nconst int incc[]={0,-1,0,1};\n\nint gragh[3][3];\nint zeror,zeroc;\nint dis(0);\n\nset<int> hash;\n\nint maxdep(0);\n\ninline int trans()\n{\n\tint mpow(1);\n\tint data(0);\n\tfor(int i=0;i<3;++i)\n\t\tfor(int j=0;j<3;++j)\n\t\t{\n\t\t\tdata+=mpow*gragh[i][j];\n\t\t\tmpow*=10;\n\t\t}\n\treturn data;\n}\ninline int calu()\n{\n\tint ans(0);\n\tfor(int i=0;i<=2;++i)\n\t\tfor(int j=0;j<=2;++j)\n\t\t\tans+=abs(inir[gragh[i][j]]-i)+abs(inic[gragh[i][j]]-j);\n\treturn ans;\n}\ninline int swap(int &a,int &b)\n{\n\ta^=b;b^=a;a^=b;\n}\nbool dfs(int dep)\n{\n\tif(trans()==AIM)\n\t{\n\t\tcout<<maxdep<<endl;\n\t\treturn 1;\n\t}\n\tif(dep>=maxdep)\n\t\treturn false;\n\tif(dis>(maxdep-dep)*2)\n\t\treturn false;\n\tint nr,nc;\n\tfor(int i=0;i<4;++i)\n\t{\n\t\tnr=zeror+incr[i];\n\t\tnc=zeroc+incc[i];\n\t\tif(nr<0||nc<0||nr>2||nc>2)\n\t\t\tcontinue;\n\t\tint olddis=dis;\n\t\tswap(nr,zeror);swap(nc,zeroc);\n\t\tswap(gragh[nr][nc],gragh[zeror][zeroc]);\n\t\tint data=trans();dis=calu();\n\t\tif(!hash.count(data))\n\t\t{\n\t\t\thash.insert(data);\n\t\t\tif(dfs(dep+1))\n\t\t\t\treturn 1;\n\t\t\thash.erase(data);\n\t\t}\n\t\tdis=olddis;\n\t\tswap(nr,zeror);swap(nc,zeroc);\n\t\tswap(gragh[nr][nc],gragh[zeror][zeroc]);\n\t}\n\treturn false;\n}\n\t\nint main()\n{\n\tfor(int i=0;i<3;++i)\n\t\tfor(int j=0;j<3;++j)\n\t\t{\n\t\t\tcin>>gragh[i][j];\n\t\t\tif(!gragh[i][j])\n\t\t\t\tzeror=i,zeroc=j;\n\t\t}\n\tdis=calu();\n\twhile(!dfs(0))\n\t{\n\t\thash.clear();\n\t\thash.insert(trans());\n\t\t++maxdep;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for(int i=0; i<N2; i++){\n            if(f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n    for(int i=0; i<N2; i++)\n        if(p.f[i] != (i+1)) return false;\n    return true;\n}\n\nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while(!Q.empty()){\n        u = Q.front(); Q.pop();\n        if( isTarget(u) ) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for(int r=0; r<4; r++){\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx*N + ty]);\n            v.space = tx*N + ty;\n            if( !V[v] ){\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n\n    return \"unsolvable\";\n}\n\nint main(){\n    Puzzle in;\n\n    for(int i=0; i<N2; i++){\n        cin >> in.f[i];\n        if(in.f[i] == 0){\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<set>\nusing namespace std;\n\nstruct Node{\n\tvector<int> arr;\n\tint step;\n};\nconst int tx[]={1,0,-1,0};\nconst int ty[]={0,1,0,-1};\nvector<int> start,end;\nqueue<Node> sq;\nset<int> pan;\n\nvoid input()\n{\n\tint tmp;\n\tfor(int i=0;i!=3;++i)\n\t\tfor(int j=0;j!=3;++j)\n\t\t{\n\t\t\tcin>>tmp;\n\t\t\tstart.push_back(tmp);\n\t\t}\n\tfor(int i=0;i!=8;++i)\n\t\tend.push_back(i+1);\n\tend.push_back(0);\n}\n\nNode makenod(vector<int> tmp,int step)\n{\n\tNode res;\n\tres.arr=tmp;\n\tres.step=step;\n\treturn res;\n}\n\nint vton(vector<int> tmp)\n{\n\tint res=0;\n\tfor(int i=0;i!=9;++i)\n\t\tres=res*10+tmp[i];\n\treturn res;\n}\n\n/*\nvoid print(vector<int> tmp)\n{\n\tfor(int i=1;i!=10;++i)\n\t{\n\t\tcout<<tmp[i-1]<<' ';\n\t\tif(i%3==0)\tcout<<endl;\n\t}\n\tcout<<endl;\n}\n*/\nint main()\n{\n\tinput();\n\n\tsq.push(makenod(start,0));\n\tpan.insert(vton(start));\n\n\tint ans;\n\twhile(!sq.empty())\n\t{\n\t\tNode now=sq.front();\tsq.pop();\n\n\t\t//print(now.arr);\n\n\t\tif(now.arr==end)\n\t\t{\n\t\t\tans=now.step;\n\t\t\tbreak;\n\t\t}\n\n\t\tint ith;\n\t\tfor(int i=0;i!=9;++i)\n\t\t\tif(now.arr[i]==0)\n\t\t\t{\n\t\t\t\tith=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tint x=ith/3,y=ith%3;\n\n\t\tfor(int i=0;i!=4;++i)\n\t\t{\n\t\t\tint nx=x+tx[i],ny=y+ty[i];\n\t\t\tif(nx>=0 && nx<3 && ny>=0 && ny<3)\n\t\t\t{\n\t\t\t\tswap(now.arr[nx*3+ny],now.arr[ith]);\n\t\t\t\tint num=vton(now.arr);\n\t\t\t\tif(pan.count(num)==0)\n\t\t\t\t{\n\t\t\t\t\tsq.push(makenod(now.arr,now.step+1));\n\t\t\t\t\tpan.insert(num);\n\t\t\t\t}\n\t\t\t\tswap(now.arr[nx*3+ny],now.arr[ith]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout<<ans<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#define N 9\n\nusing namespace std;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nstruct Puzzle{\n  int field[N];\n  int blank;\n  int num;\n\n  bool operator < (const Puzzle& a) const{\n    for(int i = 0; i < N; i++){\n      if(a.field[i] == field[i]) continue;\n      return field[i] >  a.field[i];\n    }\n    return false;\n  }\n};\n\nbool check(Puzzle puz){\n  for(int i = 0; i < N; i++){\n    if(puz.field[i] != i+1) return false;\n  }\n  return true;\n}\n\nint bfs(Puzzle puz){\n  queue<Puzzle> que;\n  map<Puzzle, bool> mp;\n\n  que.push(puz);\n  mp[puz] = true;\n\n  while(!que.empty()){\n    Puzzle p = que.front(); que.pop();\n    if(check(p) == true) return p.num;\n    int x = p.blank % 3;\n    int y = p.blank / 3;\n    for(int i = 0; i < 4; i++){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(nx < 0 || 2 < nx || ny < 0 || 2 < ny) continue;\n      Puzzle tmp = p;\n      swap(tmp.field[p.blank], tmp.field[3 * ny + nx]);\n      tmp.blank = 3 * ny + nx;\n      if(mp[tmp] == false){\n    mp[tmp] = true;\n    tmp.num++;\n    que.push(tmp);\n      }\n    }\n  }\n  return -1;\n}\n\nsigned main(){\n  Puzzle puz;\n\n  for(int i = 0; i < N; i++){\n    cin >> puz.field[i];\n    if(puz.field[i] == 0){\n      puz.field[i] = N;\n      puz.blank = i;\n    }\n  }\n\n  puz.num = 0;\n  int b = bfs(puz);\n  cout << b << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle\n{\n  int f[N2];\n  int space;\n  string path;\n  bool operator<(const Puzzle &p) const\n  {\n    for (int i = 0; i < N2; i++)\n    {\n      if (f[i] == p.f[i])\n      {\n        continue;\n      }\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p)\n{\n  for (int i = 0; i < N2; i++)\n  {\n    if (p.f[i] != (i + 1))\n    {\n\n      return false;\n    }\n  }\n  return true;\n}\n\nstring bfs(Puzzle s)\n{\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while (!Q.empty())\n  {\n    u = Q.front();\n    Q.pop();\n    if (isTarget(u))\n    {\n      return u.path;\n    }\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for (int r = 0; r < 4; r++)\n    {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if (tx < 0 || ty < 0 || tx >= N || ty >= N)\n      {\n        continue;\n      }\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if (!V[v])\n      {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main()\n{\n  Puzzle in;\n\n  for (int i = 0; i < N2; i++)\n  {\n    cin >> in.f[i];\n    if (in.f[i] == 0)\n    {\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 30;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i) {\n        return;\n    }\n\n    if (in.path == \"ldrd\")\n        int debug = 0;\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n    /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nstatic const int LINE = 3;\nstatic const int N = 9;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\nint ans[LINE][LINE];\nint in[LINE][LINE];\n\nint check(){\n\n    for(int i=0; i<LINE; i++){\n        for(int j=0; j<LINE; j++){\n            if(in[i][j] != ans[i][j])\n                return false;\n        }\n    }\n\n    return true;\n}\n\nint dfs(int x, int y, int d,int u,int k){\n    if(check()) return d;\n    if(d > k) return -1;\n    for(int i=0; i<4; i++){\n        int vx,vy,val;\n        vx = x+dx[i];\n        vy = y+dy[i];\n\n        if(vx > 2 || vx < 0 || vy > 2 || vy < 0 || (i + 2) % 4 == u ){\n            continue;\n        }\n        in[y][x] = in[vy][vx];\n        in[vy][vx] = 0;\n        val  = dfs(vx,vy,d+1,i,k);\n        if(val > 0) return val;\n        in[vy][vx] = in[y][x];\n        in[y][x] = 0;\n    }\n    return -1;\n}\n\n\nint main(){\n    int x,y,sol,cnt=0;\n\n    for(int i=0; i<LINE; i++){\n        for(int j=0; j<LINE; j++){\n            ans[i][j] = ++cnt;\n            if(i == LINE-1 && j == LINE -1) ans[i][j] = 0;\n        }\n    }\n\n    for(int i=0; i<LINE; i++){\n        for(int j=0; j<LINE; j++){\n            cin>>in[i][j];\n            if(in[i][j] == 0){\n                y = i;\n                x = j;\n            }\n        }\n    }\n\n    cnt = 1;\n\n    while(1){\n        sol = dfs(x,y,0,-1,cnt);\n        if(sol >= 0) break;\n        cnt++;\n    }\n\n    /*for(int i=0; i<LINE; i++){\n        for(int j=0; j<LINE; j++){\n            cout<<in[i][j];\n        }\n        cout<<endl;\n    }*/ //出力確認\n\n\n    cout<<sol<<endl;\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// using A star algorithm\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <map>\nusing namespace std;\nconst int N = 9;\nconst int XY = 3;\nconst int LIMIT = 100;\n\nstruct state {\n  vector<int> board;\n  int g;\n  state(vector<int> &board) {\n    this->board = board;\n    this->g = 0;\n  }\n};\nstruct compare_state {\n  int h_func(state &s) {\n    // using Manhattan distance\n    int distance = 0;\n    vector<int> solve(N,0);\n    for(int i=0;i<N;i++) {\n      solve[i] = i+1;\n    }\n    solve[N-1] = 0;\n    vector<int> board = s.board;\n    int solve_x,solve_y;\n    int board_x,board_y;\n    for(int i=0;i<N;i++) {\n      for(int j=0;j<N;j++) {\n        if(solve[i] == board[j]) {\n          solve_x = i % XY; solve_y = i / XY;\n          board_x = j % XY; board_y = j / XY;\n          distance += abs(solve_x - board_x) + abs(solve_y - board_y);\n          break;\n        }\n      }\n    }\n    return distance;\n  }\n  bool operator() (state &a,state &b) {\n    return (a.g + h_func(a)) > (b.g + h_func(b));\n  }\n};\npriority_queue<state,vector<state>,compare_state> que;\nmap<vector<int>,int> cost_table;\n\nbool check(state &current,state &end) {\n  for(int i=0;i<N;i++) {\n    if(current.board[i] != end.board[i])\n      return false;\n  }\n  return true;\n}\n\nbool is_infield(int x,int y) {\n  return (x < XY && y < XY && x >= 0 && y >= 0);\n}\n\nint search(state &start,state &end) {\n  // initialize process\n  que.push(start);\n  cost_table[start.board] = 0;\n  while(!que.empty()) {\n    state current = que.top(); que.pop();\n    // approach goal\n    if(check(current,end)) {\n      return current.g;\n    }\n    // not find goal\n    if(current.g > LIMIT) {\n      break;\n    }\n    // find zero brocks\n    int zero_pos;\n    for(int i=0;i<N;i++)\n      if(current.board[i] == 0)\n        zero_pos = i;\n    int x = zero_pos % XY;\n    int y = zero_pos / XY;\n    // swap zero brocks and find next state\n    int dx[] = {0,-1,1,0};\n    int dy[] = {-1,0,0,1};\n    for(int d=0;d<4;d++) {\n      if(!is_infield(x+dx[d],y+dy[d])) continue;\n      vector<int> next_board = current.board;\n      swap(next_board[x+y*XY],next_board[(x+dx[d])+(y+dy[d])*XY]);\n      // make and update cost table\n      if(!cost_table.count(next_board)) {\n        cost_table[next_board] = current.g + 1;\n        state next = *(new state(next_board));\n        next.g = current.g + 1;\n        que.push(next);\n      }\n      else {\n        if((current.g+1) < cost_table[next_board]) {\n          cost_table[next_board] = current.g + 1;\n          state next = *(new state(next_board));\n          next.g = current.g + 1;\n          que.push(next);\n        }\n      }\n    }\n  }\n  return -1;\n}\n\nint main() {\n  vector<int> start_vec(N,-1);\n  vector<int> end_vec(N,-1);\n  for(int i=0;i<N;i++) {\n    cin >> start_vec[i];\n    end_vec[i] = i+1;\n  }\n  end_vec[N-1] = 0;\n\n  state start = *(new state(start_vec));\n  state end = *(new state(end_vec));\n\n  cout << search(start,end) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nconst int PATTERN = 362880;\nbool frontier[PATTERN];\n\nstruct State {\n    Board board;\n    int count;\n};\n\nqueue<State> q;\nset<Board> history;\n\n// I made this function based on one by Haruhiko Okumura(Algorithm \n// Dictionary, p116) and one by M.Hiroi(Puzzle DE Programming).\nint change_number(long long board) {\n    static int fact_table[N] = {\n         40320, 5040, 720, 120, 24, 6, 2, 1, 0      // on N = 8\n    };\n    int value = 0;\n    for (int j = 0; j < N - 1; ++j) {\n        int J = static_cast<int>((board >> (j*4) & 0xF));\n        value += fact_table[j] * J;\n        for (int k = j + 1; k < N; ++k) {\n            int K = static_cast<int>((board >> k*4) & 0xF);\n            if (J < K) {\n                board &= ~(0xFLL << k*4);\n                board |= (static_cast<long long>(K - 1) << k*4);\n            }\n        }\n    }\n//    printf(\"[change_number] value = %d\\n\", value);\n    return value;\n}\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, State s) {\n    swap(numpos, spacepos, s.board);\n    if (s.board == GOAL) {\n        return ++s.count;\n    }\n    int pos = change_number(s.board);\n    if (!frontier[pos]) {\n        ++s.count;\n        q.push(s);\n        frontier[pos] = true;\n    }\n//    if (history.insert(s.board).second) {\n//        ++s.count;\n//    }\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\n// OK\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0, num; i < N; ++i) {\n        scanf(\"%d\", &num);\n        board |= static_cast<long long>(num) << (i*4);\n    }\n//    print(GOAL);\n//    print(board);\n\n    int count = 0;\n    if (board == GOAL) {\n        goto END;\n    }\n\n    q.push({ board, 0 });\n    while (!q.empty()) {\n        State s = q.front();\n        q.pop();\n\n        int pos = -1;\n        while (++pos < N) {\n            if (((s.board >> (pos*4)) & 15) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fi       first\n#define se       second\n#define sf       scanf\n#define pf       printf\n#define mp       make_pair\n#define pb       push_back\n#define si(x)    scanf(\"%d\", &x)\n#define pi(x)    printf(\"%d\\n\", x)\n#define sl(x)    scanf(\"%lld\", &x)\n#define pl(x)    printf(\"%lld\\n\", x)\n#define all(x)   x.begin(), x.end()\n#define READ(f)  freopen(f, \"r\", stdin)\n#define WRITE(f) freopen(f, \"w\", stdout)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef map<ll, ll> mll;\ntypedef pair<ll, ll> pll;\ntypedef map<int, int> mii;\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\n\nconst ll MAX = 100005;\nconst ll MOD = 1000000007;\nconst ll INF = 1000000000000000;\nconst double PI = 2 * acos(0.0);\nconst double EPS = 0.00000000001;\n\nclass vState {\npublic:\n    int cpuz[3][3];\n};\n\nclass node {\npublic:\n    int g, h, f, steps = 0, zeroI, zeroJ, puzzle[3][3];\n    bool operator < (const node &a) const {\n        if (a.f == f) return a.steps < steps;\n        else return a.f < f;\n    }\n};\n\nint goal[3][3];\nvector<vState> visit;\n\nint calc_heuristic(int puzzle[][3]) {\n    int h = 0;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (goal[i][j] != puzzle[i][j]) h++;\n        }\n    }\n    return h;\n}\n\nvoid set_goal_state() {\n    //pf(\"- Goal State -\\n\\n\");\n    goal[0][0] = 1;\n    goal[0][1] = 2;\n    goal[0][2] = 3;\n    goal[1][0] = 4;\n    goal[1][1] = 5;\n    goal[1][2] = 6;\n    goal[2][0] = 7;\n    goal[2][1] = 8;\n    goal[2][2] = 0;\n    //pf(\"\\n\");\n}\n\nnode set_current_state() {\n    node cur;\n    //pf(\"- Current State -\\n\");\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            si(cur.puzzle[i][j]);\n            if (cur.puzzle[i][j] == 0) {\n                cur.zeroI = i;\n                cur.zeroJ = j;\n            }\n        }\n    }\n    //pf(\"\\n\");\n    cur.h = calc_heuristic(cur.puzzle);\n    cur.g = 0;\n    cur.f = cur.g + cur.h;\n    return cur;\n}\n\nvoid print_state(node x) {\n    pf(\"._______.\\n\");\n    for (int i = 0; i < 3; i++) {\n        pf(\"| \");\n        for (int j = 0; j < 3; j++) {\n            pf(\"%d \", x.puzzle[i][j]);\n        }\n        pf(\"|\\n\");\n    }\n    pf(\"---------\\n\");\n    pf(\"H(n) = %d\\n\", x.h);\n    pf(\"G(n) = %d\\n\", x.g);\n    pf(\"F(n) = %d\\n\\n\", x.f);\n}\n\nbool already_visited(int puzzle[][3]) {\n    for (int i = 0; i < visit.size(); i++) {\n        int flag = true;\n        for (int j = 0; j < 3; j++) {\n            for (int k = 0; k < 3; k++) {\n                if (puzzle[j][k] != visit[i].cpuz[j][k]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (!flag) break;\n        }\n        if (flag) return true;\n    }\n    return false;\n}\n\nbool check_if_goal(int puzzle[][3]) {\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (puzzle[i][j] != goal[i][j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nnode copy_puzzle(int puzzle[][3]) {\n    node x;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            x.puzzle[i][j] = puzzle[i][j];\n        }\n    }\n    return x;\n}\n\nvState copy_puzzle2(int puzzle[][3]) {\n    vState x;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            x.cpuz[i][j] = puzzle[i][j];\n        }\n    }\n    return x;\n}\n\nint astar(node cur) {\n    priority_queue<node> pq;\n    pq.push(cur);\n    node LAST;\n    while (!pq.empty()) {\n        node u = LAST = pq.top();\n        //print_state(u);\n        visit.pb( copy_puzzle2(u.puzzle) );\n        while (!pq.empty()) pq.pop(); // clearing queue\n        if (check_if_goal(u.puzzle)) break;\n        // check the moves that can be made from current state\n        // if any moves is already made we will not pass that in the queue, this is to avoid infinite loops\n        if (u.zeroI - 1 >= 0) {\n            /// UP\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI - 1][u.zeroJ], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.steps = u.steps + 1;\n                v.zeroI = u.zeroI - 1;\n                v.zeroJ = u.zeroJ;\n                pq.push(v);\n            }\n        }\n        if (u.zeroI + 1 < 3) {\n            /// DOWN\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI + 1][u.zeroJ], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.steps = u.steps + 1;\n                v.zeroI = u.zeroI + 1;\n                v.zeroJ = u.zeroJ;\n                pq.push(v);\n            }\n        }\n        if (u.zeroJ - 1 >= 0) {\n            /// LEFT\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI][u.zeroJ - 1], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.steps = u.steps + 1;\n                v.zeroI = u.zeroI;\n                v.zeroJ = u.zeroJ - 1;\n                pq.push(v);\n            }\n        }\n        if (u.zeroJ + 1 < 3) {\n            /// RIGHT\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI][u.zeroJ + 1], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.steps = u.steps + 1;\n                v.zeroI = u.zeroI;\n                v.zeroJ = u.zeroJ + 1;\n                pq.push(v);\n            }\n        }\n     }\n     return LAST.steps;\n}\n\nint main() {\n    set_goal_state();\n    node cur = set_current_state();\n    pf(\"%d\\n\", astar(cur));\n\n    return 0;\n}\n\n\n/*\n\nTEST 1\n------\n0 1 2\n3 4 5\n6 7 8\n\n7 2 4\n5 0 6\n8 3 1\n\nTEST 2\n------\n1 2 3\n4 5 6\n7 8 0\n\n1 2 0\n4 5 3\n7 8 6\n\nTEST 3\n------\n1 2 3\n8 0 4\n7 6 5\n\n3 6 4\n0 1 2\n8 7 5\n\nTEST 4\n------\n1 2 3\n8 0 4\n7 6 5\n\n1 3 4\n8 6 2\n0 7 5\n\nTEST 5\n------\n1 2 3\n8 0 4\n7 6 5\n\n1 3 4\n8 0 5\n7 2 6\n\nTEST 6 // WORST CASE\n------\n1 2 3\n4 5 6\n7 8 0\n\n6 4 7\n8 5 0\n3 2 1\n\n8 6 7\n2 5 4\n3 0 1\n\n*/\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define repr(i, n) for (int i = (int)(n); i >= 0; i--)\n#define REP(i, m, n) for (int i = (int)(m); i <= (int)(n); i++)\n#define REPR(i, m, n) for (int i = (int)(m); i >= (int)(n); i--)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst int INF = 1001001001;\ntypedef unsigned long long ll;\n\nstruct Puzzle{\n  int f[9];\n  int space;\n  int cnt;\n\n  bool operator < (const Puzzle &p) const {\n    rep(i, 9){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nqueue<Puzzle> Q;\nmap<Puzzle, bool> V;\n\nstatic const int dx[4] = {1, 0, -1, 0};\nstatic const int dy[4] = {0, 1, 0, -1};\n\nbool isTarget(Puzzle p){\n  rep(i, 9) if(p.f[i] != (i+1)) return false;\n  return true;\n}\n\nint main(){\n  Puzzle in;\n\n  rep(i, 9){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = 9;\n      in.space = i;\n    }\n  }\n  in.cnt = 0;\n\n  V[in] = true;\n  Q.push(in);\n  int ans;\n  while(!Q.empty()){\n    Puzzle u = Q.front(); Q.pop();\n    if(isTarget(u)){\n      ans = u.cnt;\n      break;\n    } \n    int sx = u.space / 3;\n    int sy = u.space % 3;\n    rep(i, 4){\n      int tx = sx + dx[i];\n      int ty = sy + dy[i];\n      if(tx<0 || ty<0 || 3<=tx || 3<=ty) continue;\n      Puzzle v = u;\n      v.space = tx * 3 + ty;\n      swap(v.f[u.space], v.f[v.space]);\n      v.cnt++;\n      if(!V[v]){\n        V[v] = true;\n        Q.push(v);\n      }\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<stdlib.h>\nusing namespace std;\nconst int Max = 3;\nint a[4][2]= {0,-1,1,0,0,1,-1,0};\nint last[9][2]= {{2,2},{0,0},{0,1},{0,2},{1,0},{1,1},{1,2},{2,0},{2,1}}; // 目标状态的数字所在位置\nint k[Max][Max],k2[Max*Max],flag=0,limit,Mi;   // k用来保存八数码状态，k2用来计算曼巴顿距离\nint add(int k[Max][Max])       // 曼哈顿距离为 所有的数字要走到目标状态，最少要和0换的次数；\n{\n    int i,j;\n    int sum = 0;\n    for(i=0; i<3; i++)\n        for(j=0; j<3; j++)\n        {\n            if(k[i][j]!=0)     //判断曼哈顿距离不能判断0；\n                sum += abs(i-last[k[i][j]][0])+abs(j - last[k[i][j]][1]);  //求曼哈顿距离\n        }\n    return sum;\n}\nvoid dfs(int y,int x,int len,int f)     // x,y当前0的坐标 len 为已经走了几步了，f为当上一次的搜索方向\n{\n    int s = add(k);                     // 求当前状态的曼哈顿距离\n    if(flag) return;                    // 如果找到符合的结果，不在搜索\n    if(len<=limit)\n    {\n        if(s==0)                        //曼哈顿距离为零，为目标状态\n        {\n            flag=1;\n            Mi=len;\n            return ;\n        }\n        if(len==limit) return;          //递归到了本轮终点，结束\n    }\n    for(int i=0; i<4; i++)\n    {\n        int tx = x + a[i][0];\n        int ty = y + a[i][1];\n        if(tx>=0&&ty>=0&&ty<3&&tx<3&&((f==-1)||i!=(f+2)%4))\n        {\n            swap(k[y][x],k[ty][tx]);    // 让下一个数与 0 交换位置\n            if(len+add(k)<=limit)       // IDA* 值减少，当前走的步数 加上 当前状态到达标状态的最小步数，\n            {\n                // 要小于等于当前枚举到的最小的 从起始状态到达目标状态的步数，不能超过；\n                dfs(ty,tx,len+1,i);\n                if(flag) return ;\n            }\n            swap(k[y][x],k[ty][tx]);    //还原\n        }\n    }\n}\nint main()\n{\n    int i,j;\n    while(~scanf(\"%d\",&k2[0]))\n    {\n        int y,x;\n        k[0][0] = k2[0];\n        if(k2[0]==0)    //记录 0 所在的位置\n        {\n            y = 0;\n            x = 0;\n        }\n        for(i=1; i<Max*Max; i++)\n        {\n            scanf(\"%d\",&k2[i]);\n            k[i/3][i%3] = k2[i];//把输入的数存到二维数组\n            if(k2[i]==0)        //记录 0 所在的位置\n            {\n                y = i/3;\n                x = i%3;\n            }\n        }\n        flag = 0;\n        limit = add(k);        // 当前要达到目标状态的最小步数；\n        while(!flag&&limit<=36)\n        {\n            dfs(y,x,0,-1);\n            if(!flag)          //如果本轮没有满足的条件，扩大搜索范围\n                limit ++;      // 深搜底线 +1\n        }\n        if(flag)\n            printf(\"%d\\n\",Mi);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 20;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i) {\n        return;\n    }\n\n    if (in.path == \"ldrd\")\n        int debug = 0;\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n    /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n    freopen(\"in.txt\", \"r\", stdin);\n    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "    typedef std::vector<std::vector<int>> State;\n    const int N = 3;\n\n    State int_to_state(int c){\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n      FOR(i, N) {\n        FOR(j, N) {\n          int r = c%10;\n          c = c/10;\n          state[i][j] = r;\n        }\n      }\n      return state;\n    }\n    int state_to_int(State state) {\n      int c = 0;\n      int p = 1;\n      FOR(i, N) {\n        FOR(j, N) {\n          c += state[i][j] * p;\n          p *= 10;\n        }\n      }\n      return c;\n    }\n\n\n    void show(std::vector<std::vector<int>> state){\n      FOR(i, N) {\n        FOR(j, N) {\n          std::cout << state[i][j] << \" \";\n        }\n        std::cout << std::endl;\n      }\n    }\n\n    bool is_solved(const State& state) {\n      int N = state.size();\n\n      FOR(i, N) {\n        FOR(j, N) {\n          if(state[i][j] != (1 + 3*i + j)) return false;\n        }\n      }\n      return true;\n    }\n\n    std::vector<State> next_states_of(State state){\n      std::vector<State> res;\n      auto ns = state; std::swap(ns[0][0], ns[0][1]); res.push_back(ns);\n      ns = state; std::swap(ns[0][1], ns[0][2]); res.push_back(ns);\n      ns = state; std::swap(ns[1][0], ns[1][1]); res.push_back(ns);\n      ns = state; std::swap(ns[1][1], ns[1][2]); res.push_back(ns);\n      ns = state; std::swap(ns[2][0], ns[2][1]); res.push_back(ns);\n      ns = state; std::swap(ns[2][1], ns[2][2]); res.push_back(ns);\n      ns = state; std::swap(ns[0][0], ns[1][0]); res.push_back(ns);\n      ns = state; std::swap(ns[1][0], ns[2][0]); res.push_back(ns);\n      ns = state; std::swap(ns[0][1], ns[1][1]); res.push_back(ns);\n      ns = state; std::swap(ns[1][1], ns[2][1]); res.push_back(ns);\n      ns = state; std::swap(ns[0][2], ns[1][2]); res.push_back(ns);\n      ns = state; std::swap(ns[1][2], ns[2][2]); res.push_back(ns);\n//      std::cout << res.size() <<std::endl;\n      return res;\n    }\n\n    int solve_puzzle(State state){\n\n      std::priority_queue<\n        std::pair<int, int>,\n        std::vector<std::pair<int, int>>,\n        std::greater<std::pair<int, int>>\n      > q;\n      std::unordered_map<int, int> h;\n\n      q.push(std::make_pair(0, state_to_int(state)));\n\n      for(;not q.empty();){\n        auto d_s = q.top(); q.pop();\n        int d = d_s.first;\n        int st_int = d_s.second;\n        State state = int_to_state(d_s.second);\n//        show(state);\n\n        if(st_int == 987654321){\n//          std::cout << \"z\"<< std::endl;\n          return d;\n        }\n\n        if(h.find(st_int) == h.end()){\n          h[st_int] = d;\n          std::vector<State> next_states = next_states_of(state);\n          for(auto ns : next_states){\n            q.push(std::make_pair(d+1, state_to_int(ns)));\n          }\n        }\n      }\n      return -1;\n    }\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <utility>\n#include <algorithm>\n#include <queue>\n#include <numeric>\n#include <unordered_map>\n\n    int main(){\n      const int N = 3;\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n\n      FOR(i, N){\n        FOR(j, N){\n          GET(int, x);\n          if(x==0) x=9;\n          state[i][j] = x;\n        }\n      }\n//      show(state);\n//      int c = state_to_int(state);\n//      std::cout << c << std::endl;\n//      std::cout << \"?\" <<std::endl;\n//      State s2 = int_to_state(c);\n//      std::cout << \"!\" <<std::endl;\n//\n//      show(s2);\n//      int min_steps = rec_min_steps_\n      std::cout << solve_puzzle(state) << std::endl;\n      return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nconst int dx[4] { -1, 0, 1, 0 };\nconst int dy[4] { 0, -1, 0, 1 };\nconst char dir[4] { 'u', 'l', 'd', 'r' };\n\nstruct Puzzle {\n\tint f[N2], space;\n\tstring path;\n\tbool operator <(const Puzzle p) const {\n\t\tfor (int i = 0; i < N2; ++i) {\n\t\t\tif (f[i] == p.f[i])\n\t\t\t\tcontinue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nbool isResolved(Puzzle p) {\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif (p.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle p) {\n\tqueue<Puzzle> Q;\n\tp.path = \"\";\n\tQ.push(p);\n\tmap<Puzzle, bool> M;\n\tM[p] = true;\n\tPuzzle u, v;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isResolved(u))\n\t\t\treturn u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!M[v]) {\n\t\t\t\tM[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\";\n}\n\nint main() {\n\tPuzzle p;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tscanf(\"%d\", &p.f[i]);\n\t\tif (p.f[i] == 0) {\n\t\t\tp.f[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(p);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n    int f[N2];\n    int space;\n    string path;\n    \n    bool operator < ( const Puzzle &p) const{\n        for(int i=0;i<N2;i++){\n            if(f[i]==p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n     for(int i=0;i<N2;i++)\n         if(p.f[i]!=(i+1)) return false;\n         return true;\n}\n\nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle,bool> V;\n    Puzzle u,v;\n    s.path = \"\";\n    Q.push(s);\n    V[s]=true;\n    \n    while(!Q.empty()){\n        u = Q.front();\n        Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx=u.space/N;\n        int sy=u.space%N;\n        for(int r=0;r<4;r++){\n            int tx = sx +dx[r];\n            int ty = sy +dy[r];\n            if(tx<0 || ty <0 || tx >=N || ty >=N) continue;\n            v =u;\n            swap(v.f[u.space], v.f[tx*N+ty]);\n            v.space = tx*N+ty;\n            if(!V[v]){\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    \n    return \"unsolvable\";\n}\n\nint main(){\n    Puzzle in;\n    \n    for(int i=0;i<N2;i++){\n        cin >> in.f[i];\n        if(in.f[i] == 0){\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iomanip>\n#include <iostream>\n#include <stack>\n#include <tuple>\n#include <vector>\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nconst int dr[4] = {0, 1, 0, -1};\nconst int dc[4] = {1, 0, -1, 0};\n\ntemplate <typename T> class Board {\npublic:\n  static const int L = 3;\n  static const int N = L*L;\n\n  Board() : prohibited_dir(-1) {}\n  Board(T *board) : prohibited_dir(-1) {\n    for (int i = 0; i < N; i++) {\n      this->board[i] = board[i];\n    }\n  }\n  Board(const Board &b) : prohibited_dir(b.prohibited_dir) {\n    for (int i = 0; i < N; i++) {\n      this->board[i] = b.board[i];\n    }\n  }\n\n  const T &operator[](std::size_t i) const { return board[i]; }\n  T &operator[](std::size_t i) { return board[i]; }\n\n  const T &as_plane(std::size_t r, std::size_t c) const {\n    return board[plane2line(r, c)];\n  }\n\n  bool operator==(const Board &b) const {\n    if (prohibited_dir != b.prohibited_dir)\n      return false;\n    for (int i = 0; i < N; i++) {\n      if (board[i] != b.board[i])\n        return false;\n    }\n    return true;\n  }\n\n  std::tuple<int, int> line2plane(int i) {\n    return std::make_pair(i / L, i % L);\n  }\n\n  int plane2line(int r, int c) { return r * L + c; }\n\n  int L1(int sr, int sc, int dr, int dc) {\n    int r = std::abs(sr - dr);\n    int c = std::abs(sc - dc);\n    return r + c;\n  }\n\n  bool is_goal() {\n    for (int i = 0; i < N - 1; i++) {\n      if (board[i] != i + 1)\n        return false;\n    }\n    return board[N - 1] == 0;\n  }\n\n  int h() {\n    int res = 0;\n    for (int src = 0; src < N; src++) {\n      int sr, sc;\n      std::tie(sr, sc) = line2plane(src);\n      int dr, dc;\n      std::tie(dr, dc) = line2plane(board[src] - 1);\n      res += L1(sr, sc, dr, dc);\n    }\n    return res;\n  }\n\n  bool is_in(int r, int c) { return 0 <= r && r < L && 0 <= c && c < L; }\n\n  std::vector<Board<T>> neighbor() {\n    std::vector<Board<T>> res;\n    int zero;\n    int zr, zc;\n    for (int i = 0; i < N; i++) {\n      if (board[i] == 0) {\n        std::tie(zr, zc) = line2plane(i);\n        zero = i;\n      }\n    }\n\n    for (int i = 0; i < 4; i++) {\n      if (prohibited_dir == i)\n        continue;\n      int nr = zr + dr[i], nc = zc + dc[i];\n      int nxt = plane2line(nr, nc);\n      if (!is_in(nr, nc))\n        continue;\n      Board next(*this);\n      std::swap(next.board[zero], next.board[nxt]);\n      next.prohibited_dir = (i + 2) % 4;\n      res.push_back(next);\n    }\n    return res;\n  }\n\n#ifdef EBUG\n  void print() {\n    for (int r = 0; r < L; r++) {\n      for (int c = 0; c < L; c++) {\n        int idx = plane2line(r, c);\n        cout << std::setw(3) << std::right << board[idx] << \" \";\n        ;\n      }\n      cout << endl;\n    }\n  }\n#endif\n\nprotected:\n  int prohibited_dir;\n\nprivate:\n  T board[N];\n};\n\nBoard<int> board;\nconst int FOUND = (1 << 30) + 1;\nconst int INF = (1 << 30);\n\nstd::vector<Board<int>> ida_star(Board<int> root);\nint search(std::vector<Board<int>> &path, int g, int bound);\n\nint main(void) {\n  int tmp[Board<int>::N];\n  for (int i = 0; i < Board<int>::N; i++) {\n    cin >> tmp[i];\n  }\n  board = Board<int>(tmp);\n\n  std::vector<Board<int>> path = ida_star(board);\n  cout << path.size() - 1 << endl;\n\n#ifdef EBUG\n  for (auto &p : path) {\n    p.print();\n  }\n#endif\n}\n\nstd::vector<Board<int>> ida_star(Board<int> root) {\n  int bound = root.h();\n  std::vector<Board<int>> path;\n  path.push_back(root);\n  while (1) {\n    int t = search(path, 0, bound);\n    if (t == FOUND)\n      return path;\n    if (t == INF)\n      assert(false);\n    bound = t;\n  }\n}\n\nint search(std::vector<Board<int>> &path, int g, int bound) {\n  Board<int> node = path.back();\n  int f = g + node.h();\n  if (f > bound)\n    return f;\n  if (node.is_goal())\n    return FOUND;\n  int minv = INF;\n  for (const auto &succ : node.neighbor()) {\n    if (std::find(path.begin(), path.end(), succ) == path.end()) {\n      path.push_back(succ);\n      int t = search(path, g + 1, bound);\n      if (t == FOUND)\n        return FOUND;\n      if (t < minv)\n        minv = t;\n      path.pop_back();\n    }\n  }\n  return minv;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\n#define N 3\n#define TRUE 1\n#define FALSE 0\n\nint x[4]={0,-1,0,1};\nint y[4]={1,0,-1,0};\nint l;\nint puzzle[N][N];\n\nvoid swap(int *,int *);\nint abc();\nint dfs(int,int,int,int);\nvoid Solved(int,int);\n\nint main()\n{\n  int i,j,sx,sy;\n   \n   for(i=0;i<N;i++){\n     for(j=0;j<N;j++){\n       scanf(\"%d\",&puzzle[i][j]);\n        if(puzzle[i][j]==0){\n            sy=i;sx=j;\n        }\n     }\n   }\n   Solved(sy,sx);\n   return 0;\n}\n\n\nvoid swap(int *x,int *y)\n{\n  int tmp;\n  tmp=*x;\n  *x=*y;\n  *y=tmp;\n}\n\n\nint abc()\n{\n  int i,j,s=0,r;\n  \n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n        \n        if(puzzle[i][j]==0)continue;\n        \n        r=puzzle[i][j]-1;\n        s+=abs(r/N-i)+abs(r%N-j);\n    }\n  }\n  return s;\n}\n\n\nint dfs(int d,int p,int sy,int sx)\n{\n  int i,m;\n  int tx,ty;\n\n  m=abc();\n  \n  if(m==0)return TRUE;\n  if(d+m>l)return FALSE;\n  \n  for(i=0;i<4;i++){\n    if(abs(i-p)==2)continue;\n    \n    tx=sx+x[i],ty=sy+y[i];\n    \n    if(tx<0||ty<0||tx>=N||ty>=N)continue;\n    \n    swap(&puzzle[ty][tx],&puzzle[sy][sx]);\n    \n    if(dfs(d+1,i,ty,tx))return TRUE;\n    \n    swap(&puzzle[ty][tx],&puzzle[sy][sx]);\n  }\n    return FALSE;\n}\n\n\nvoid Solved(int sy,int sx)\n{\n  for(l=0;;l++){\n    if(dfs(0,99,sy,sx)){\n      printf(\"%d\\n\",l);\n      return ;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3\nusing namespace std;\n\nint path = 0;\n//goal\nint final[N][N] =\n        {\n                {1, 2, 3},\n                {4, 5, 6},\n                {7, 8, 0}\n        };\n// state space tree nodes\nstruct Node {\n    // stores parent node of current node\n    // helps in tracing path when answer is found\n    Node *parent;\n\n    // stores matrix\n    int mat[N][N];\n\n    // stores blank tile cordinates\n    int x, y;\n\n    // stores the number of misplaced tiles\n    int cost;\n\n    // stores the number of moves so far\n    int level;\n};\n\n// Function to allocate a new node\nNode *newNode(int mat[N][N], int x, int y, int newX,\n              int newY, int level, Node *parent) {\n    Node *node = new Node;\n\n    // set pointer for path to root\n    node->parent = parent;\n\n    // copy data from parent node to current node\n    memcpy(node->mat, mat, sizeof node->mat);\n\n    // move tile by 1 postion\n    swap(node->mat[x][y], node->mat[newX][newY]);\n\n    // set number of misplaced tiles\n    node->cost = INT_MAX;\n\n    // set number of moves so far\n    node->level = level;\n\n    // update new blank tile cordinates\n    node->x = newX;\n    node->y = newY;\n\n    return node;\n}\n\n// botton, left, top, right\nint row[] = {1, 0, -1, 0};\nint col[] = {0, -1, 0, 1};\n\n// Function to calculate the the number of misplaced tiles\n// ie. number of non-blank tiles not in their goal position\nint calculateCost(int initial[N][N], int final[N][N]) {\n    int count = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            if (initial[i][j] && initial[i][j] != final[i][j])\n                count++;\n    return count;\n}\n\n// Function to check if (x, y) is a valid matrix cordinate\nint isSafe(int x, int y) {\n    return (x >= 0 && x < N && y >= 0 && y < N);\n}\n\n// print path from root node to destination node\nvoid checkPath(Node *root) {\n    if (root == NULL)\n        return;\n    checkPath(root->parent);\n    path += 1;\n\n}\n\n// Comparison object to be used to order the heap\nstruct comp {\n    bool operator()(const Node *lhs, const Node *rhs) const {\n        return (lhs->cost + lhs->level) > (rhs->cost + rhs->level);\n    }\n};\n\n\nvoid solve(int initial[N][N], int x, int y,\n           int final[N][N]) {\n\n    priority_queue<Node *, std::vector<Node *>, comp> pq;\n\n    Node *root = newNode(initial, x, y, x, y, 0, NULL);\n    root->cost = calculateCost(initial, final);\n\n    // Add root to list of live nodes;\n    pq.push(root);\n\n    // Finds a live node with least cost,\n    // add its childrens to list of live nodes and\n    // finally deletes it from the list.\n    while (!pq.empty()) {\n        // Find a live node with least estimated cost\n        Node *min = pq.top();\n\n        // The found node is deleted from the list of\n        // live nodes\n        pq.pop();\n\n        // if min is an answer node\n\n        if (min->cost == 0) {\n            checkPath(min);\n            return;\n        }\n\n        // do for each child of min\n        // max 4 children for a node\n        for (int i = 0; i < 4; i++) {\n            if (isSafe(min->x + row[i], min->y + col[i])) {\n                // create a child node and calculate\n                // its cost\n                Node *child = newNode(min->mat, min->x,\n                                      min->y, min->x + row[i],\n                                      min->y + col[i],\n                                      min->level + 1, min);\n                child->cost = calculateCost(child->mat, final);\n\n                // Add child to list of live nodes\n                pq.push(child);\n            }\n        }\n    }\n}\n\n\nint main() {\n    // Initial state\n    int x = 0, y = 0;\n    int initial[N][N] = {{}};\n\n    cin >> initial[0][0] >> initial[0][1] >> initial[0][2];\n    cin >> initial[1][0] >> initial[1][1] >> initial[1][2];\n    cin >> initial[2][0] >> initial[2][1] >> initial[2][2];\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if(initial[i][j] == 0)\n            {\n                x = i;\n                y = j;\n            }\n        }\n    }\n    solve(initial, x, y, final);\n    path -= 1;\n    cout << path;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    int i;\n\n    for( i=0; i<N2; i++){\n      if( f[i] == p.f[i] ) continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1, 0, 1, 0};\nstatic const int dy[4]={0, -1, 0, 1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  int i;\n  for( i=0; i<N2; i++)\n    if( p.f[i] != (i+1) )\n      return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  \n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while( !Q.empty() ){\n    u=Q.front();\n    Q.pop();\n    if(isTarget(u))\n      return u.path;\n    int sx=u.space / N;\n    int sy=u.space % N;\n    int r;\n\n    for( r=0; r<4; r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if( tx < 0 || ty < 0 || tx >= N || ty >= N )\n\tcontinue;\n      v=u;\n      swap( v.f[u.space], v.f[tx*N+ty] );\n      v.space = tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  int i;\n\n  for(i=0;i<N2;i++){\n    cin>>in.f[i];\n    \n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout<<ans.size()<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n// #define int long long\n #define inf  1000000007\n// #define inf  998244353\n\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int Gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return Gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn Gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                              \n                int pr[100000];\n                int inv[100000];\n                \n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=((ll)pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=(ll)inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\nusing T=array<array<int,4>,4>;\n\nusing ul=unsigned long long;\nstruct hoge{\n\tul ban;\n\tint x;\n\tint y;\n\tint ato;\n\tint ima;\n\tbool operator<(const hoge& p) const{\n\t\treturn ato+ima>p.ato+p.ima;\n\t}\n};\n\nqueue<hoge> qu[10000];\n\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\nint h=3,w=3;\n\t\n\t//cin>>h>>w;\n\tT a;\n\tint sx,sy;\n\t\n\tint dis=0;\n\tul state=0ull;\n\t\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\tcin>>a[i][j];\n\t\ta[i][j]--;\n\t\tif(a[i][j]>=0){\n\t\tdis+=abs(j-a[i][j]%w);\n\t\tdis+=abs(i-a[i][j]/w);\n\t\t}\n\t\tif(a[i][j]==-1)sx=i,sy=j,a[i][j]=8;\n\t}\n\tfor(int i=2;i>=0;i--)for(int j=2;j>=0;j--){\n\t\tstate<<=4;\n\t\tstate|=a[i][j];\n\t}\n\tif(dis==0){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\t\n\tqu[dis].push({state,sx,sy,dis,0});\n\t//set<T> se;\n\t//se.insert(a);\n\tmap<ul,int> ma;\n\tma[state]=0;\n\tint it=0;\n\tint cnt=0;\n\tul zen=0;\n\tfor(int i=0;i<9;i++){\n\t\tzen*=16ull;\n\t\tzen+=15ull;\n\t}\n\t\n\twhile(1){\n\t\twhile(qu[it].size()==0){\n\t\t\tit++;\n\t//\t\tcout<<it<<\" \"<<cnt<<endl;\n\t\t}\n\n\t\thoge Z=qu[it].front();\n\t\tqu[it].pop();\n\t\tif(ma[Z.ban]<Z.ima)continue;\n\t\tcnt++;\n\t\t\n\t\tfor(int r=0;r<4;r++){\n\t\t\tint x=Z.x+dx[r];\n\t\t\tint y=Z.y+dy[r];\n\t\t\tif(x<0 ||x>=h ||y<0 ||y>=w)continue;\n\t\t\t\n\t\t\tint t0=Z.x*3+Z.y;\n\t\t\tint t1=x*3+y;\n\t\t\tul g0=(Z.ban>>(4*t0))&15ull;\n\t\t\tul g1=(Z.ban>>(4*t1))&15ull;\n\t\t\tstate=Z.ban;\n\t\t\tstate&=(zen^(15ull<<(4*t0)));\n\t\t\tstate&=(zen^(15ull<<(4*t1)));\n\n\t\t\tstate|=g1<<(4*t0);\n\t\t\tstate|=g0<<(4*t1);\n\t\t\t\n\t\t\tint zou=abs(Z.y-(int)(g1%3))+abs(Z.x-(int)(g1/3))-abs(y-(int)(g1%3))-abs(x-(int)(g1/3));\n\t\t\t\n\t\t\t\n\t\t\t//if(Z.ima+1+Z.ato+zou>45)continue;\n\t\t\n\t\t\tif(Z.ato+zou==0){\n\t\t\t\tcout<<Z.ima+1<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\tif(!ma.count(state) || ma[state]>Z.ima+1){\n\t\t\t\tma[state]=Z.ima+1;\n\t\t\t\tqu[Z.ato+zou+Z.ima+1].push({state,x,y,Z.ato+zou,Z.ima+1});\n\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n }\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle\n{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const\n  {\n    for(int i=0;i<N2;i++)\n      {\n\tif(f[i]==p.f[i]) continue;\n\treturn f[i]>p.f[i];\n      }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const int dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p)\n{\n  for(int i=0;i<N2;i++)\n    if(p.f[i]!=(i+1))return false;\n  return true;\n}\n\nstring bfs(Puzzle s)\n{\n  queue<Puzzle>Q;\n  map<Puzzle,bool>V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty())\n    {\n      u=Q.front();Q.pop();\n      if(isTarget(u))return u.path;\n      int sx=u.space/N;\n      int sy=u.space%N;\n      for(int r=0;r<4;r++)\n\t{\n\t  int tx=sx+dx[r];\n\t  int ty=sy+dy[r];\n\t  if(tx<0||ty<0||tx>=N||ty>=N) continue;\n\t  v=u;\n\t  swap(v.f[u.space],v.f[tx*N+ty]);\n\t  v.space=tx*N+ty;\n\t  if(!V[v])\n\t    {\n\t      V[v]=true;\n\t      v.path+=dir[r];\n\t      Q.push(v);\n\t    }\n\t}\n    }\n\n  return \"unsolvable\";\n}\n\nint main()\n{\n  Puzzle in;\n\n  for(int i=0;i<N2;i++)\n    {\n      cin>>in.f[i];\n      if(in.f[i]==0)\n\t{\n\t  in.f[i]=N2;\n\t  in.space=i;\n\t}\n    }\n  string ans=bfs(in);\n  cout<<ans.size()<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_13_B\n// Heuristic Search - 8 Puzzle\n// status:\n// tag: [bfs]\n\n#define SUBMIT\n\n#include <utility>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <sstream>\n\nusing namespace std;\nusing ui64 = unsigned long long;\nusing i64 = long long;\n\nconst int N = 3;\nconst int N2 = 9;\n\nstruct puzzle {\n    int p[N2];\n    string path;\n    int space;\n\n    bool is_complete() {\n        // complete pattern is:\n        // 1 2 3\n        // 4 5 6\n        // 7 8 9\n        for (int i = 0; i < N2; ++i) {\n            if (p[i] != i + 1) return false;\n        }\n\n        return true;\n    }\n};\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst char direction[] = {'l', 'd', 'r', 'u'};\n\nint to_index(int x, int y) { return y * N + x; }\nint to_x(int index) { return index % N; }\nint to_y(int index) { return index / N; }\n\nqueue<puzzle> pq;\n\nstring bfs() {\n    while (!pq.empty()) {\n        auto curr_puzzle = pq.front();\n        pq.pop();\n\n        int curr_x = to_x(curr_puzzle.space), curr_y = to_y(curr_puzzle.space);\n        for (int r = 0; r < 4; ++r) {\n            int next_x = curr_x + dx[r], next_y = curr_y + dy[r];\n            if (next_x < 0 || N <= next_x || next_y < 0 || N <= next_y) continue;\n\n            auto next_puzzle = curr_puzzle;\n            next_puzzle.path += direction[r];\n            next_puzzle.space = to_index(next_x, next_y);\n\n            swap(next_puzzle.p[curr_puzzle.space], next_puzzle.p[next_puzzle.space]);\n\n            if (next_puzzle.is_complete()) return next_puzzle.path;\n            pq.push(next_puzzle);\n        }\n    }\n\n    // fail\n    return \"\";\n}\n\nint main() {\n#ifdef SUBMIT\n    auto& stream = cin;\n#else\n    string program_input_str = R\"(1 3 0\n4 2 5\n7 8 6\n)\";\n    stringstream stream(program_input_str);\n#endif\n    puzzle start_puzzle;\n    start_puzzle.path = \"\";\n\n    int value;\n    for (int y = 0; y < N; ++y) {\n        for (int x = 0; x < N; ++x) {\n            auto index = to_index(x, y);\n            stream >> value;\n            start_puzzle.p[index] = value;\n            if (value == 0) {\n                start_puzzle.p[index] = N2;\n                start_puzzle.space = index;\n            }\n        }\n    }\n\n    pq.push(start_puzzle);\n    auto ans = bfs();\n    cout << ans.size() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n#define DIVN 3\n\nvoid swap(int &a, int &b);\nint fact(int a);\nint dist(int x);\nint abs(int x);\nvoid insert(vector<int> &A, int v);\nint extract(vector<int> &A);\nint PtoI(vector<int> p);\nvector<int> ItoP(int ii);\nint SolvePuzzle(vector<int> P);\n\nvector<int> Puzzles(fact(DIVN*DIVN), INT_MAX);\n\n\nvoid swap(int &a, int &b){\n\tint tmp = a;\n\ta = b;\n\tb = tmp;\n\treturn;\n}\n\nint fact(int a){\n\tint b = 1;\n\tfor (int i = 2; i <= a; i++){\n\t\tb = b * i;\n\t}\n\treturn b;\n}\n\nint dist(int x){\n\tstd::vector<int> P = ItoP(x);\n\tint result = 0;\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tresult += abs(P[i] % DIVN - (i + 1) % DIVN) + abs((P[i] == 0 ? DIVN - 1 : (P[i] - 1) / DIVN) / DIVN - i / DIVN);\n\t}\n\treturn -result;\n}\n\nint abs(int x){\n\treturn x < 0 ? -x : x;\n}\n\nvoid insert(vector<int> &A, int v){\n\tint n = A.size();\n\tA.push_back(v);\n\twhile (n != 0){\n\t\tint i = (n - 1) / 2;\n\t\tif (dist(A[n]) > dist(A[i])){\n\t\t\tswap(A[n], A[i]);\n\t\t}\n\t\tn = i;\n\t}\n\treturn;\n}\n\nint extract(vector<int> &A){\n\tint n = A.size() - 1;\n\tint res = A[0];\n\tA[0] = A[n];\n\tA.pop_back();\n\n\tfor (int i = 0, j; 2 * i + 1 < n;){\n\t\tj = 2 * i + 1;\n\t\tif (j != n - 1 && dist(A[j]) < dist(A[j + 1])){\n\t\t\tj++;\n\t\t}\n\t\tif (dist(A[i]) < dist(A[j])){\n\t\t\tswap(A[i], A[j]);\n\t\t}\n\t\ti = j;\n\t}\n\treturn res;\n}\n\n\nint PtoI(vector<int> p){\n\tint x, result = 0;\n\tfor (int i = 0; i < DIVN*DIVN - 1; i++){\n\t\tfor (int j = 0; j < DIVN*DIVN - i; j++){\n\t\t\tif (p[j] == i){\n\t\t\t\tx = j;\n\t\t\t\tp.erase(p.begin() + j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult += x * fact(DIVN*DIVN - i - 1);\n\t}\n\treturn result;\n}\n\nvector<int> ItoP(int ii){\n\tvector<int> result(DIVN*DIVN, -1);\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tint index = ii / fact(DIVN*DIVN - i - 1);\n\t\tii = ii % fact(DIVN*DIVN - i - 1);\n\t\tint curindex = -1;\n\t\tint x = -1;\n\t\tfor (int j = 0; j < DIVN*DIVN; j++){\n\t\t\tif (result[j] == -1){\n\t\t\t\tcurindex++;\n\t\t\t}\n\t\t\tif (curindex == index) {\n\t\t\t\tx = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult[x] = i;\n\t}\n\treturn result;\n}\n\nint SolvePuzzle(vector<int> P){\n\tvector<int> Que;\n\tinsert(Que, PtoI(P));\n\tint answer = INT_MAX;\n\tPuzzles[PtoI(P)] = 0;\n\twhile (!Que.empty()){\n\t\tvector<int> Q = ItoP(extract(Que));\n\t\tint Cursor;\n\t\tbool isAligned = true;\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] != (i + 1) % (DIVN*DIVN)){\n\t\t\t\tisAligned = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isAligned && Puzzles[PtoI(Q)] < answer){\n\t\t\tanswer = Puzzles[PtoI(Q)];\n\t\t}\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] == 0){\n\t\t\t\tCursor = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvector<int> Qnext;\n\t\tif (Cursor >= DIVN){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1 && (answer > Puzzles[PtoI(Q)] + 1)){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor < DIVN * (DIVN - 1)){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1 && (answer > Puzzles[PtoI(Q)] + 1)){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != 0){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1 && (answer > Puzzles[PtoI(Q)] + 1)){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != DIVN - 1){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1 && (answer > Puzzles[PtoI(Q)] + 1)){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn answer;\n}\n\nint main(){\n\tint k;\n\tvector<int> P;\n\tfor (int i = 0; i < DIVN * DIVN; i++){\n\t\tscanf(\"%d\", &k);\n\t\tP.push_back(k);\n\t}\n\tint n = SolvePuzzle(P);\n\n\tprintf(\"%d\\n\", n);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nstruct paz{\n\tint in2[3][3];\n\tint cnt;\n\tpair<int, int> s;\n};\n\nint main(){\n\tint ok[3][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 0 } }; int flag = 0; int answer;\n\tpaz in;\n\tqueue<paz> pp;\n \tfor (int i = 0; i < 3; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tcin >> in.in2[i][j];\n\t\t\tif (in.in2[i][j] == 0) {\n\t\t\t\tin.s.first = i;\n\t\t\t\tin.s.second = j;\n\t\t\t}\n\t\t}\n\t}\n\tin.cnt = 0;\n\tpp.push(in);\n\twhile (1){\n\t\tflag = 0;\n\t\tpaz temp = pp.front();\n\t\tpp.pop();\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tif (temp.in2[i][j] != ok[i][j]) flag = 1;\n\t\t\t}\n\t\t}if (flag == 0) {\n\t\t\tanswer = temp.cnt;\n\t\t\tbreak;\n\t\t}\n\t\tint dx[4] = { 1, 0, -1, 0 }; int dy[4] = { 0, 1, 0, -1 };\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tif (temp.in2[temp.s.first + dy[i]][temp.s.second + dx[i]] >= 0){\n\t\t\t\tpaz a = temp;\n\t\t\t\tswap(a.in2[a.s.first][a.s.second], a.in2[a.s.first + dy[i]][a.s.second + dx[i]]);\n\t\t\t\ta.cnt++;\n\t\t\t\ta.s.first += dy[i]; a.s.second += dx[i];\n\t\t\t\tpp.push(a);\n\t\t\t}\n\t\t}\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int H=3,W=3;\nconst int SIZE=H*W;\n\nclass State\n{\n public:\n    string str;\n    int space,distFromS,distToG;\n    State(string str,int space,int dist):str(str),space(space),distFromS(dist),distToG(0){\n        for(int i=0;i<SIZE;i++) if(i!=space){\n            int y=i/W,x=i%W;\n            int gy=(str[i]-'a')/W,gx=(str[i]-'a')%W;\n            distToG+=abs(y-gy)+abs(x-gx);\n        }\n    }\n    bool operator<(const State& s) const{\n        return distFromS+distToG>s.distFromS+s.distToG;\n    }\n};\n\nint d[4]={-W,-1,1,W};\n\nint main()\n{  \n    string s(SIZE,' '),goal(SIZE,' ');\n    for(int i=0;i<SIZE;i++) goal[i]=(char)('a'+i);\n    for(int i=0;i<SIZE;i++){\n        int t; cin>>t;\n        if(t==0) s[i]=goal[SIZE-1];\n        else s[i]=goal[t-1];\n    }\n\n    State start(s,s.find(goal[SIZE-1]),0);\n    priority_queue<State> Q; Q.push(start);\n    set<string> visited; visited.insert(s);\n    while(!Q.empty()){\n        auto cur=Q.top(); Q.pop();\n        if(cur.str==goal){\n            cout<<cur.distFromS<<endl;\n            return 0;\n        }\n        for(int i=0;i<4;i++){\n            int nxtspace=cur.space+d[i];\n            if(nxtspace<0 or nxtspace>=SIZE) continue;\n            if(d[i]==1 and nxtspace%W==0) continue;\n            if(d[i]==-1 and nxtspace%W==W-1) continue;\n            string nxtstr=cur.str;\n            swap(nxtstr[cur.space],nxtstr[nxtspace]);\n            if(!visited.count(nxtstr)){\n                visited.insert(nxtstr);\n                State nxt(nxtstr,nxtspace,cur.distFromS+1);\n                Q.push(nxt);\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n// ---------------------\n// repetition\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n// debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n// ---------------------\n#define INF 922337203685477580\n#define IINF (1<<21)\ntypedef long long ll;\n\n\nclass Board {\npublic:\n  int board[3][3];\n  Board() {}\n  Board(int b[3][3]) {\n    REP(i, 3) {\n      REP(j, 3) {\n        board[i][j] = b[i][j];\n      }\n    }\n  }\n\n  int hash() {\n    int accum = 0;\n    int digit = 1;\n    REP(i, 3) {\n      REP(j, 3) {\n        accum += board[i][j] * digit;\n        digit *= 10;\n      }\n    }\n    return accum;\n  }\n  string to_str() {\n    string str = \"\";\n    REP(i, 3) {\n      REP(j, 3) {\n        str += \" \" + to_string(board[i][j]);\n      }\n      str += \"\\n\";\n    }\n    return str;\n  }\n  bool operator==( const Board& other) {\n    REP(i, 3) {\n      REP(j, 3) {\n        if (board[i][j] != other.board[i][j]) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n};\n\nclass Nully;\nstatic Board Nully;\n\nBoard swap_with_upper(const Board& b) {\n  int pos_i, pos_j;\n  REP(i, 3) {\n    REP(j, 3) {\n      if (b.board[i][j] == 0) {\n        pos_i = i;\n        pos_j = j;\n        break;\n      }\n    }\n  }\n  if (pos_i == 0) {\n    return Nully;\n  }\n\n  Board next = b;\n  swap(next.board[pos_i][pos_j], next.board[pos_i - 1][pos_j]);\n  return next;\n}\nBoard swap_with_lower(const Board& b) {\n  int pos_i, pos_j;\n  REP(i, 3) {\n    REP(j, 3) {\n      if (b.board[i][j] == 0) {\n        pos_i = i;\n        pos_j = j;\n        break;\n      }\n    }\n  }\n  if (pos_i == 2) {\n    return Nully;\n  }\n\n  Board next = b;\n  swap(next.board[pos_i][pos_j], next.board[pos_i + 1][pos_j]);\n  return next;\n}\nBoard swap_with_left(const Board& b) {\n  int pos_i, pos_j;\n  REP(i, 3) {\n    REP(j, 3) {\n      if (b.board[i][j] == 0) {\n        pos_i = i;\n        pos_j = j;\n        break;\n      }\n    }\n  }\n  if (pos_j == 0) {\n    return Nully;\n  }\n\n  Board next = b;\n  swap(next.board[pos_i][pos_j], next.board[pos_i][pos_j - 1]);\n  return next;\n}\nBoard swap_with_right(const Board& b) {\n  int pos_i, pos_j;\n  REP(i, 3) {\n    REP(j, 3) {\n      if (b.board[i][j] == 0) {\n        pos_i = i;\n        pos_j = j;\n        break;\n      }\n    }\n  }\n  if (pos_j == 2) {\n    return Nully;\n  }\n\n  Board next = b;\n  swap(next.board[pos_i][pos_j], next.board[pos_i][pos_j + 1]);\n  return next;\n}\n\nint main() {\n  // int b[3][3] = {{1, 3, 0}, {4, 2, 5}, {7, 8, 6}};\n  int b[3][3];\n  REP(i, 3) {\n    REP(j, 3) {\n      cin >> b[i][j];\n    }\n  }\n\n  int g[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};\n  Board init(b);\n  Board goal(g);\n  // cout << init.to_str() << endl;\n\n  int depth = 0;\n  queue<pair<Board, int> > Q;\n  set<int> S;\n  Q.push(make_pair(init, depth));\n  S.insert(init.hash());\n\n  while (!Q.empty()) {\n    Board current = Q.front().first;\n    Board next;\n    int dpt = Q.front().second;\n    Q.pop();\n\n    if (goal == current) {\n      cout << dpt << endl;\n      return 0;\n    }\n\n    next = swap_with_upper(current);\n    if (!(next == Nully) && S.count(next.hash()) == 0) {\n      Q.push(make_pair(next, dpt + 1));\n      S.insert(next.hash());\n    }\n    next = swap_with_lower(current);\n    if (!(next == Nully) && S.count(next.hash()) == 0) {\n      Q.push(make_pair(next, dpt + 1));\n      S.insert(next.hash());\n    }\n    next = swap_with_left(current);\n    if (!(next == Nully) && S.count(next.hash()) == 0) {\n      Q.push(make_pair(next, dpt + 1));\n      S.insert(next.hash());\n    }\n    next = swap_with_right(current);\n    if (!(next == Nully) && S.count(next.hash()) == 0) {\n      Q.push(make_pair(next, dpt + 1));\n      S.insert(next.hash());\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define N  3\n#define N2 9\nusing namespace std;\nstruct Puzzle{\n\tint f[N2];\n\tint space;\n\tstring path;\n\tbool operator < (const Puzzle &p) const \n\t{\n\t\tfor (int i = 0; i < N2; ++i)\n\t\t{\n\t\t\tif (f[i] == p.f[i]) continue;\n\t\t\treturn f[i] < p.f[i];\t\t\t\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p)\n{\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tif (p.f[i] != (i+1)) return false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle s)\n{\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u,v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\twhile(!Q.empty())\n\t{\n\t\tu = Q.front(); Q.pop();\n\t\tif (isTarget(u)) return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r)\n\t\t{\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif( tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!V[v])\n\t\t\t{\n\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main()\n{\n\tPuzzle in;\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tcin>>in.f[i];\n\t\tif (in.f[i]==0) {\n\t\t\tin.space = i;\n\t\t        //in.f[i] = N2;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout<<ans.size()<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <map>\nusing namespace std;\nconst int MAXN = 100005;\nconst int MAXE = 200005;\nconst int NIL = -1;\ntypedef long long ll;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\nconst int dx[4] = { -1, 0, 1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\nconst char dir[4] = { 'u', 'r', 'd', 'l' };\nstruct Puzzle {\n\tint Sudoku[3][3];\n\tint space;\n\tstring path;\n\tbool operator<(const Puzzle& p) const\n\t{\n\t\tfor (int i = 0; i < 3; ++i)\n\t\t\tfor (int j = 0; j < 3; ++j)\n\t\t\t\tif (Sudoku[i][j] == p.Sudoku[i][j])\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\treturn Sudoku[i][j] < p.Sudoku[i][j];\n\t\treturn false;\n\t}\n};\n\nbool ok(const Puzzle &p)\n{\n\tfor (int i = 0; i < 3; ++i)\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t\tif (p.Sudoku[i][j] != i * 3 + j + 1)\n\t\t\t\treturn false;\n\treturn true;\n}\n\nstring bfs(Puzzle s)\n{\n\tqueue<Puzzle> q;\n\tmap<Puzzle, bool> vis;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tq.push(s);\n\tvis[s] = true;\n\twhile (!q.empty())\n\t{\n\t\tu = q.front();\n\t\tq.pop();\n\t\tif (ok(u))\n\t\t\treturn u.path;\n\t\tint x = (u.space - 1) / 3;\n\t\tint y = (u.space - 1) % 3;\n\t\t//cout << \"space == \" << u.space << \" x == \" << x << \" y == \" << y << endl;\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint tx = x + dx[i];\n\t\t\tint ty = y + dy[i];\n\t\t\tif (tx < 0 || ty < 0 || tx >= 3 || ty >= 3)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\tswap(v.Sudoku[x][y], v.Sudoku[tx][ty]);\n\t\t\tv.space = tx * 3 + ty + 1;\n\t\t\tif (!vis[v])\n\t\t\t{\n\t\t\t\tvis[v] = true;\n\t\t\t\tv.path += dir[i];\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t\n\tPuzzle s;\n\tfor (int i = 0; i < 3; ++i)\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t{\n\t\t\tcin >> s.Sudoku[i][j];\n\t\t\tif (s.Sudoku[i][j] == 0)\n\t\t\t\ts.Sudoku[i][j] = 9, s.space = i * 3 + j + 1;\n\t\t}\n\tcout << s.space << endl;\n\tcout << bfs(s).size() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nconst int PATTERN = 362880;\nconst int FORWARD  = 1;\nconst int BACKWARD = 2;\nint frontier[PATTERN];\n\nstruct State {\n    Board board;\n    int count;\n};\n\nqueue<State> q;\n\n// I made this function based on one by Haruhiko Okumura(Algorithm \n// Dictionary, p116) and one by M.Hiroi(Puzzle DE Programming).\ninline int change_number(long long board) {\n    static int fact_table[N] = {\n         40320, 5040, 720, 120, 24, 6, 2, 1, 0      // on N = 8\n    };\n    int value = 0;\n    for (int j = 0; j < N - 1; ++j) {\n        int J = static_cast<int>((board >> (j*4) & 0xF));\n        value += fact_table[j] * J;\n        for (int k = j + 1; k < N; ++k) {\n            int K = static_cast<int>((board >> k*4) & 0xF);\n            if (J < K) {\n                board &= ~(0xFLL << k*4);\n                board |= (static_cast<long long>(K - 1) << k*4);\n            }\n        }\n    }\n//    printf(\"[change_number] value = %d\\n\", value);\n    return value;\n}\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 0xF;\n    board |= num << (spacepos*4);\n    board &= ~(0xFLL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, State s) {\n    int prev = change_number(s.board);\n    int direction = frontier[prev];\n//    printf(\"[swap&check] direction = %d\\n\", direction);\n    swap(numpos, spacepos, s.board);\n//    if (s.board == GOAL) {\n//        return ++s.count;\n//    }\n    int pos = change_number(s.board);\n    if (!frontier[pos]) {\n        ++s.count;\n        q.push(s);\n        frontier[pos] = direction;\n        return -1;\n    }\n    else if (frontier[pos] != direction) {\n        ++s.count;\n//        printf(\"[swap&check] s.count = %d\\n\", s.count);\n        return s.count * 2;\n    }\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 0xF));\n    }\n    printf(\"\\n\");\n}\n\n// OK\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0, num; i < N; ++i) {\n        scanf(\"%d\", &num);\n        board |= static_cast<long long>(num) << (i*4);\n    }\n//    print(GOAL);\n//    print(board);\n\n    int count = 0;\n    if (board == GOAL) {\n        goto END;\n    }\n\n    frontier[change_number(board)] = FORWARD;\n    frontier[change_number(GOAL)] = BACKWARD;\n\n    q.push({ board, 0 });\n    q.push({ GOAL, 0 });\n    while (!q.empty()) {\n        State s = q.front();\n        q.pop();\n\n        int pos = -1;\n        while (++pos < N) {\n            if (((s.board >> (pos*4)) & 0xF) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,s,n) for (int i = (int)s; i < (int)n; i++)\n#define ll long long\n#define pb push_back\n#define All(x) x.begin(), x.end()\n#define Range(x, i, j) x.begin() + i, x.begin() + j\n#define lbidx(x, y) lower_bound(x.begin(), x.end(), y) - x.begin()\n#define ubidx(x, y) upper_bound(x.begin(), x.end(), y) - x.begin()\n#define llbidx(x, y, z) lower_bound(x.begin(), x.end(), z) - lower_bound(x.begin(), x.end(), y) // 二要素間の距離\n#define deg2rad(deg) ((((double)deg)/((double)360)*2*M_PI))\n#define rad2deg(rad) ((((double)rad)/(double)2/M_PI)*(double)360)\n#define Find(set, element) set.find(element) != set.end()\n\ntypedef pair<int, int> PI;\ntypedef pair<ll, ll> PLL;\n\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n  if(a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n};\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n  if(a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n};\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n  bool operator < (const Puzzle &p) const {\n    rep(i, 0, N2) {\n      if (f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = { -1, 0, 1, 0};\nstatic const int dy[4] = { 0, -1, 0, 1};\nstatic const char dir[4] = { 'u', 'l', 'd', 'r'}; // up, left, down, right\n\nbool isTarget(Puzzle p) {\n  rep(i, 0, N2) {\n    if (p.f[i] != (i+1)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nstring bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while (!Q.empty()) {\n    u = Q.front(); Q.pop();\n    if (isTarget(u)) return u.path;\n    int sx = u.space / N; // row\n    int sy = u.space % N; // column\n\n    rep(r, 0, 4) {\n      // tx, ty 交換する先のrow, column\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if (!V[v]) {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n};\n\nint main() {\n  Puzzle in;\n  rep(i, 0, N2) {\n    cin >> in.f[i];\n\n    if (in.f[i] == 0) {\n      in.f[i] = N2; // set space\n      in.space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n};\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst int edge[4][3] = {{0, 3, 6}, {0, 1, 2}, {6, 7, 8}, {2, 5, 8}}; /* l, t, b, r */\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    if(wrongs + moves > cutoff)\n        return -1;\n    int zero;\n    REP(i, 9){\n        if(tiles[i] == 0){\n            zero = i;\n            break;\n        }\n    }\n    bool dir[4] = {true, true, true, true};\n    REP(i, 4) REP(j, 3)\n        if (zero == edge[i][j])\n            dir[i] = false;\n    if(wrongs + moves >= cutoff)\n        return -1;\n    if(dir[0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-1]);\n    }\n    if(dir[1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-3]);\n    }\n    if(dir[2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+3]);\n    }\n    if(dir[3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+1]);\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n    int start = check();\n\n    REP(i, 50){\n        move = dfs(0, start + i);\n        if(move > 0){\n            break;\n        }\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cstdlib>\n#include <string>\n#include <queue>\nusing namespace std;\nconst int N = 3;\nconst int N2 = 9;\nconst int x[4] = {0, 0, 1, -1};\nconst int y[4] = {-1, 1, 0, 0};\nconst char ch[4] = {'l', 'r', 'd', 'u'};\n\nclass node{\npublic:\n\tint f[N2];\n\tint space;\n\tstring str;\n\tbool operator< (const node& n) const\n\t{\n\t\treturn true;\n\t} \n};\n\nbool Is_Return(const node& n)\n{\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tif (n.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstring bfs(node& n)\n{\n\tqueue<node> Q;\n\tmap<node, bool> ans;\n\tQ.push(n);\n\tans[n] = true;\n\twhile (!Q.empty())\n\t{\n\t\tnode u = Q.front();\n\t\tQ.pop();\n\t\tif (Is_Return(u))\n\t\t\treturn u.str;\n\t\tint tx = u.space / N;\n\t\tint ty = u.space % N;\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint sx = tx + x[i];\n\t\t\tint sy = ty + y[i];\n\t\t\tif (sx < 0 || sy < 0 || sx >= N || sy >= N)\n\t\t\t\tcontinue;\n\t\t\tnode v = u;\n\t\t\tswap(v.f[v.space], v.f[sx * N + sy]);\n\t\t\tv.space = sx * N + sy;\n\t\t\tif (!ans[v])\n\t\t\t{\n\t\t\t\tans[v] = true;\n\t\t\t\tv.str += ch[i];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main()\n{\n\tnode n;\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tcin >> n.f[i];\n\t\tif (n.f[i] == 0)\n\t\t{\n\t\t\tn.space = i;\n\t\t\tn.f[i] = N2;\n\t\t}\n\t}\n\tstring s = bfs(n);\n\tcout << s.length() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n// AC\n// ??????????????????????????????????????????AC??????????????????\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 40;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\nint limit;\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nint getAllMD(Puzzle p)\n{\n    int dist = 0;\n    int x, y;\n    int ux, uy;\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] == N2) continue; // ??????0??????\n        x = (p.f[i] - 1) / N;\n        y = (p.f[i] - 1) % N;\n        ux = i / N;\n        uy = i % N;\n        dist += abs(x - ux) + abs(y - uy);\n    }\n    return dist;\n}\n\nbool bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return true;\n    }\n    if (ms[in] || limit < i + getAllMD(in)) {\n        return false;\n    }\n\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n        /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n//    cout << \"MD: \" << getAllMD(in) << endl;\n        if(bfs(i+1)) return true;\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n    return false;\n}\n\nstring iterative_deepening()\n{\n    limit = getAllMD(in);\n    for ( ; limit <= INF; limit++) {\n        if (bfs(0)) {\n            return in.path;\n        }\n    }\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    string ans = iterative_deepening();\n    cout << ans.size() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n  bool operator < (const Puzzle &p) const {\n    for (int i = 0; i < N2; i++) {\n      if (f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool istarget(Puzzle p){\n  for(int i=0;i<N2;i++){\n    if(p.f[i]!=(i+1)) return false;\n  }\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n  while(!Q.empty()){\n    u=Q.front(); Q.pop();\n    if(istarget(u)) return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int i=0;i<4;i++){\n      int tx=sx+dx[i];\n      int ty=sy+dy[i];\n      if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[i];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  for(int i=0;i<N2;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout<<ans.size()<<endl;\n  return 0;\n}\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nbool ok(int a[3][3])\n{\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tif (a[i / 3][i % 3] != i + 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstruct puzzle\n{\n\tint board[3][3];\n\tint distance;\n};\n\nconst int dx[4] = { 0, -1, 1, 0 };\nconst int dy[4] = { -1, 0, 0, 1 };\n\nint main() \n{\n\tpuzzle start;\n\n\tstart.distance = 0;\n\n\tfor (int i = 0; i < 3; i++)\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tcin >> start.board[i][j];\n\n\tqueue<puzzle> que; que.push(start);\n\n\tint Ans = 0;\n\n\tif (ok(start.board) == false)\n\t{\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tpuzzle p = que.front(); que.pop();\n\n\t\t\tint x, y;\n\n\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t\t{\n\t\t\t\t\tif (p.board[i][j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t\t{\n\t\t\t\tif (0 <= x + dx[dir] && x + dx[dir] < 3 && 0 <= y + dy[dir] && y + dy[dir] < 3)\n\t\t\t\t{\n\t\t\t\t\tpuzzle q = p;\n\n\t\t\t\t\tswap(q.board[y][x], q.board[y + dy[dir]][x + dx[dir]]);\n\n\t\t\t\t\tq.distance = p.distance + 1;\n\n\t\t\t\t\tif (ok(q.board) == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tAns = q.distance; goto Exit;\n\t\t\t\t\t}\n\n\t\t\t\t\tque.push(q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExit:;\n\n\tcout << Ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle& p) const {\n    for (int i = 0; i < N2; i++) {\n      if (f[i] == p.f[i]) {\n        continue;\n      }\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n  for (int i = 0; i < N2; i++) {\n    if (p.f[i] != (i + 1)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nstring bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while (!Q.empty()) {\n    u = Q.front(); Q.pop();\n    if (isTarget(u)) {\n      return u.path;\n    }\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for (int r = 0; r < 4; r++) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if (tx < 0 || ty < 0 || tx >= N || ty >= N) {\n        continue;\n      }\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if (!V[v]) {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for (int i = 0; i < N2; i++) {\n    cin >> in.f[i];\n    if (in.f[i] == 0) {\n      in.f[i] = N2; // set space\n      in.space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <map>\n#include <queue>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nint dx[5] = {0, 0, 1, -1};\nint dy[5] = {1, -1, 0, 0};\n//string dir[5] = {\"r\", \"l\", \"d\", \"u\"};//右、左、下、上\nchar dir[5] = {'r', 'l', 'd', 'u'};//右、左、下、上\nstruct Puzzle\n{\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for(int i=0; i<N2; i++)\n        {\n            if(f[i]==p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\nPuzzle P;\nbool isTarget(Puzzle s)\n{\n    for(int i=0; i<N2-1; i++)\n    {\n        if(s.f[i]!=i+1) return 0;\n    }\n    return 1;\n}\nint bfs(Puzzle P)\n{\n    map<Puzzle, bool> V;\n    queue<Puzzle> Q;\n    Q.push(P);\n    V[P] = true;\n    Puzzle u, v;\n    while(!Q.empty())\n    {\n        u = Q.front();\n        Q.pop();\n        if(isTarget(u)) return u.path.size();\n        int sx = u.space/N, sy = u.space%N;\n        //cout << 1 << endl;\n        for(int i=0; i<4; i++)\n        {\n            int tx = sx + dx[i], ty = sy + dy[i];\n            if(tx>=N || tx<0 || ty>=N || ty<0) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx*N+ty]);\n            v.space = tx*N+ty;\n            if(!V[v])\n            {\n                V[v] = true;\n                v.path += dir[i];\n                Q.push(v);\n            }\n        }\n    }\n    return -1;\n}\nint main()\n{\n    for(int i=0; i<N2; i++)\n    {\n        cin >> P.f[i];\n        if(P.f[i]==0)\n        {\n            P.space = i;\n        }\n    }\n    P.path = \"\";\n    cout << bfs(P) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iterator>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\nnamespace eight_puzzle{\n\ttypedef unsigned int uint;\n\tconst int N = 3;\n\tconst int ansval = 123456780;\n\tconst int ansarray[N*N] = {1,2,3,4,5,6,7,8,0};\n\tuint arraytovalue(int *table){\n\t\tuint t=0;\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tt*=10;\n\t\t\tt=t+table[i];\n\t\t}\n\t\treturn t;\n\t}\n\tvoid valuetoarray(uint t,int *table){\n\t\tfor(int i=N-1;i>=0;--i){\n\t\t\tfor(int j=N-1;j>=0;--j){\n\t\t\t\tint panel = t-t/10*10;\n\t\t\t\ttable[i*N+j] = panel;\n\t\t\t\tt/=10;\n\t\t\t}\n\t\t}\t\t\n\t}\n\tuint getscore(uint t){\n\t\tint table[N*N];\n\t\tuint score = 0;\n\t\tvaluetoarray(t,table);\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tfor(int j=0;j<N*N;++j){\n\t\t\t\tif(ansarray[i]==table[j]){\n\t\t\t\t\tscore += (i/N-j/N)*(i/N-j/N)+(i%N-j%N)*(i%N-j%N);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn score;\n\t}\n\tstruct State{\n\t\tState(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t\tscore = s.score;\n\t\t}\n\t\tState(const uint tt,const uint tn){\n\t\t\ttable = tt;\n\t\t\tn = tn;\n\t\t\tscore = getscore(table);\n\t\t}\n\n\t\tState& operator=(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t\tscore = s.score;\n\t\t\treturn (*this);\n\t\t}\n\t\tbool operator<(const State& s) const{\n\t\t\treturn score < s.score;\n\t\t}\n\t\tbool operator>(const State& s) const{\n\t\t\treturn score > s.score;\n\t\t}\n\t\tbool isfinished() const{\n\t\t\t\treturn table == 123456780;\n\t\t}\n\t\t\n\t\tuint table;\n\t\tuint n;\n\t\tuint score;\n\t};\n\n\tvoid getnextstate(const State &s,std::vector<State> &states){\n\t\tint table[N*N];\n\t\tint t = s.table;\n\t\tint zi,zj;\n\t\tvaluetoarray(t,table);\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tif(table[i]==0){\n\t\t\t\tzi = i/N;\n\t\t\t\tzj = i%N;\n\t\t\t}\n\t\t}\n\t\tfor(int i=-1;i<=1;++i){\n\t\t\tfor(int j=-1;j<=1;++j){\n\t\t\t\tif((i+j)%2==0)continue;\n\t\t\t\tint ti = zi+i,tj=zj+j;\n\t\t\t\tif(0<=ti&&ti<N&&0<=tj&&tj<N){\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t\tstates.push_back(State(arraytovalue(table),s.n+1));\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tstd::map<uint, bool> visited;\n};\n\nint main(){\n\tusing namespace eight_puzzle;\n\tint array[N*N];\n\tfor(int i=0;i<N*N;++i){\n\t\tstd::cin>>array[i];\n\t}\n\tState init(arraytovalue(array),0);\n\tif(init.isfinished()){\n\t\tstd::cout<<0<<std::endl;\n\t\treturn 0;\n\t}\n//\tstd::priority_queue<State,std::vector<State>,std::greater<State> > Q;\n\tstd::queue<State> Q;\n\tQ.push(init);\n\twhile(!Q.empty()){\n\t\tState s = Q.front();\n\t\tQ.pop();\n\t\tstd::vector<State> states;\n\t\tgetnextstate(s,states);\n\t\tfor(uint i=0;i<states.size();++i){\n\t\t\tif(states[i].isfinished()){\n\t\t\t\tstd::cout<<states[i].n<<std::endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(visited.find(states[i].table)==visited.end()){\n\t\t\t\tQ.push(states[i]);\n\t\t\t\tvisited[states[i].table]=true;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_13_B\n// Heuristic Search - 8 Puzzle\n// status:\n// tag: [bfs]\n\n#define SUBMIT\n\n#include <utility>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <sstream>\n#include <map>\n\nusing namespace std;\nusing ui64 = unsigned long long;\nusing i64 = long long;\n\nconst int N = 3;\nconst int N2 = 9;\n\nstruct puzzle {\n    int p[N2];\n    string path;\n    int space;\n\n    bool is_complete() {\n        // complete pattern is:\n        // 1 2 3\n        // 4 5 6\n        // 7 8 9\n        for (int i = 0; i < N2; ++i) {\n            if (p[i] != i + 1) return false;\n        }\n\n        return true;\n    }\n\n    bool operator<(const puzzle& other) const {\n        for (int i = 0; i < N2; ++i) {\n            if (p[i] == other.p[i]) continue;\n            return other.p[i] < p[i];\n        }\n\n        // equal\n        return false;\n    }\n};\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst char direction[] = {'l', 'd', 'r', 'u'};\n\nint to_index(int x, int y) { return y * N + x; }\nint to_x(int index) { return index % N; }\nint to_y(int index) { return index / N; }\n\nqueue<puzzle> pq;\n\nstring bfs() {\n    map<puzzle, bool> puzzle_memory;\n\n    while (!pq.empty()) {\n        auto curr_puzzle = pq.front();\n        pq.pop();\n\n        int curr_x = to_x(curr_puzzle.space), curr_y = to_y(curr_puzzle.space);\n        for (int r = 0; r < 4; ++r) {\n            int next_x = curr_x + dx[r], next_y = curr_y + dy[r];\n            if (next_x < 0 || N <= next_x || next_y < 0 || N <= next_y) continue;\n\n            auto next_puzzle = curr_puzzle;\n            next_puzzle.space = to_index(next_x, next_y);\n            swap(next_puzzle.p[curr_puzzle.space], next_puzzle.p[next_puzzle.space]);\n            // 既に出現した盤面ならcontinue\n            if (puzzle_memory[next_puzzle]) continue;\n\n            next_puzzle.path += direction[r];\n            if (next_puzzle.is_complete()) return next_puzzle.path;\n\n            puzzle_memory[next_puzzle] = true;\n            pq.push(next_puzzle);\n        }\n    }\n\n    // fail\n    return \"\";\n}\n\nint main() {\n#ifdef SUBMIT\n    auto& stream = cin;\n#else\n    string program_input_str = R\"(1 3 0\n4 2 5\n7 8 6\n)\";\n    stringstream stream(program_input_str);\n#endif\n    puzzle start_puzzle;\n    start_puzzle.path = \"\";\n\n    int value;\n    for (int y = 0; y < N; ++y) {\n        for (int x = 0; x < N; ++x) {\n            auto index = to_index(x, y);\n            stream >> value;\n            start_puzzle.p[index] = value;\n            if (value == 0) {\n                start_puzzle.p[index] = N2;\n                start_puzzle.space = index;\n            }\n        }\n    }\n\n    if (start_puzzle.is_complete()) {\n        cout << \"0\" << endl;\n    }\n    else {\n        pq.push(start_puzzle);\n        auto ans = bfs();\n        cout << ans.size() << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct r{\n\tint men[3][3];\n\tint cnt;\n};\nbool used[9][9][9][9][9][9][9][9][9]={};\nint main(){\n\tint i,j,dx[4]={0,1,0,-1},dy[4]={-1,0,1,0},k,temp,menc[3][3]={{1,2,3},{4,5,6},{7,8,0}};\n\tr f,v;\n\tqueue<r> q;\n\tfor(i=0;i<3;i++){\n\t\tfor(j=0;j<3;j++){\n\t\t\tcin>>f.men[i][j];\n\t\t}\n\t}\n\tf.cnt=0;\n\tq.push(f);\n\twhile(!q.empty()){\n\t\tf=q.front();\n\t\tq.pop();\n\t\tused[f.men[0][0]][f.men[0][1]][f.men[0][2]][f.men[1][0]][f.men[1][1]][f.men[1][2]][f.men[2][0]][f.men[2][1]][f.men[2][2]]=true;\n\t\tint o=0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tfor(j=0;j<3;j++){\n\t\t\t\tif(f.men[i][j]!=menc[i][j]){\n\t\t\t\t\to=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(o==0)break;\n\t\tint b=0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tfor(j=0;j<3;j++){\n\t\t\t\tif(f.men[i][j]==0){\n\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\tif(i+dy[k]>=0&&i+dy[k]<3&&j+dx[k]>=0&&j+dx[k]<3){\n\t\t\t\t\t\t\tv=f;\n\t\t\t\t\t\t\ttemp=v.men[i][j];\n\t\t\t\t\t\t\tv.men[i][j]=v.men[i+dy[k]][j+dx[k]];\n\t\t\t\t\t\t\tv.men[i+dy[k]][j+dx[k]]=temp;\n\t\t\t\t\t\t\tv.cnt++;\n\t\t\t\t\t\t\tif(used[v.men[0][0]][v.men[0][1]][v.men[0][2]][v.men[1][0]][v.men[1][1]][v.men[1][2]][v.men[2][0]][v.men[2][1]][v.men[2][2]]==false){\n\t\t\t\t\t\t\t\tq.push(v);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb=1;\n\t\t\t\t}\n\t\t\t\tif(b==1)break;\n\t\t\t}\n\t\t\tif(b==1)break;\n\t\t}\n\t}\n\tcout<<f.cnt<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define loop(i,j,k) for(long long i = j;i < k;i++)\n#include <iostream>\n#include <queue>\n#include <array>\n#include <utility>\n#include <stdio.h>\n\nusing namespace std;\n\nbool cp(array<array<int,3>,3>& e) {\n\tloop(i,0,3)loop(j,0,3)if(e[i][j]!=(1+j+i*3)%9)return false;\n\treturn true;\n}\n\nint main() {\n\tarray<array<int,3>,3> pz;\n\tqueue<pair<typeof(pz),int>> q;\n\tloop(i,0,3)loop(j,0,3)cin>>pz[i][j];\n\tq.push(make_pair(pz,0));\n\tif(cp(pz)) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\twhile(!q.empty()) {\n\t\tauto cur = q.front().first;\n\t\tint dep = q.front().second + 1;\n\t\tq.pop();\n\t\tint r=-1,c=-1;\n\t\tloop(i,0,3)loop(j,0,3)if(cur[i][j] == 0){r=i;c=j;}\n\t\tif(r!=2) {\n\t\t\tswap(cur[r][c],cur[r+1][c]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else q.push(make_pair(cur,dep));\n\t\t\tswap(cur[r][c],cur[r+1][c]);\n\t\t}\n\t\tif(r!=0) {\n\t\t\tswap(cur[r][c],cur[r-1][c]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else q.push(make_pair(cur,dep));\n\t\t\tswap(cur[r][c],cur[r-1][c]);\n\t\t}\n\t\tif(c!=2) {\n\t\t\tswap(cur[r][c],cur[r][c+1]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else q.push(make_pair(cur,dep));\n\t\t\tswap(cur[r][c],cur[r][c+1]);\n\t\t}\n\t\tif(c!=0) {\n\t\t\tswap(cur[r][c],cur[r][c-1]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else q.push(make_pair(cur,dep));\n\t\t\tswap(cur[r][c],cur[r][c-1]);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst char answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<char> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\n\nclass board{\nprivate:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<char> tiles;\n\npublic:\n    explicit board(vector<char> num, int move){\n        wrongs = 0;\n        REP(i, 9){\n            tiles.push_back(num[i]);\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n    }\n\n    int cost() {\n        return wrongs + moves;\n    }\n\n    void move() {\n        pq.pop();\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\n\n\nbool operator< (board b1, board b2){\n    return (b1.cost() > b2.cost()) ? true : false;\n}\n\nint dfs(int moves, int cutoff){\n    pq.push(board(original, 0));\n    while(!pq.empty()){\n        auto target = pq.top();\n        if(target.cost() > cutoff)\n            return -1;\n        if(target.get_wrongs() == 0)\n            return target.cost();\n        else{\n            target.move();\n        }\n    }\n    return -1;\n}\n\nint main() {\n    int ii;\n    REP(i, 9){\n        cin >> ii;\n        original[i] = ii;\n    }\n    int move = 0;\n    move = dfs(0, 100);\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<map>\n#include<vector>\n#include<cmath>\n#include<cstdlib>\n#include<list>\n#include<queue>\n#define mm(a,b) memset(a,b,sizeof(a))\n#define ACCELERATE (ios::sync_with_stdio(false),cin.tie(0))\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n#define MAXN 0x3f3f3f3f3f3f3f3f\n#define PI acos(-1.0)\n#define E exp(1.0)\nusing namespace std;\n\n//#define debug\n\nstruct Puzzle{\n    int e[10];\n    int space;\n    int ans;\n};\n\nPuzzle tmp;\n\nbool state[362880];\n\nint kangtuo(int x[])  //康拓展开进行判重\n{\n    int fac[]={1,1,2,6,24,120,720,5040,40320};\n    int i,j,t,sum;\n    sum = 0;\n    for(i=0;i<9;i++)\n    {\n        t = 0;\n        for(j=i+1;j<9;j++)\n        {\n            if(x[j]<x[i])\n                t++;\n        }\n        sum = sum+t*fac[8-i];\n    }\n    if(state[sum]==1)\n        return 0;\n    else\n    {\n        state[sum] = 1;\n        return 1;\n    }\n}\n\nbool judge(Puzzle t){\n    for(int i=0;i<=8;i++){\n        if(t.e[i]!=i+1) return false;\n    }\n    return true;\n}\n\nconst int dx[4]={0,1,0,-1};\nconst int dy[4]={1,0,-1,0};\n\nint bfs(){\n    queue<Puzzle> q;\n    q.push(tmp);\n    while(!q.empty()){\n        Puzzle t=q.front();\n        q.pop();\n        kangtuo(t.e);\n        if(judge(t)) return t.ans;\n        for(int i=0;i<4;i++){\n            int sx=t.space/3+dx[i];\n            int sy=t.space%3+dy[i];\n            if(sx>=3||sy>=3||sx<0||sy<0){\n                continue;\n            }\n            Puzzle f;\n            f.ans=t.ans+1;\n            f.space=sx*3+sy;\n//            cout<<sx<<\" \"<<sy<<endl;\n            memcpy(f.e,t.e,sizeof(t.e));\n            swap(f.e[sx*3+sy],f.e[t.space]);\n            if(!kangtuo(f.e)) continue;\n\n            q.push(f);\n        }\n    }\n}\n\nint main()\n{\n    #ifdef debug\n    freopen(\"in.txt\",\"r\",stdin);\n    freopen(\"out.txt\",\"w\",stdout);\n    #endif // debug\n\n    ACCELERATE;\n    mm(state,0);\n    for(int i=0;i<9;i++){\n        cin>>tmp.e[i];\n        if(tmp.e[i]==0){\n            tmp.e[i]=9;\n            tmp.space=i;\n            tmp.ans=0;\n        }\n    }\n    int ans=bfs();\n    cout<<ans<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint ans[3][3] =\n        {\n                {1, 2, 3},\n                {4, 5, 6},\n                {7, 8, 0}\n        };\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { -1, 0, 1, 0 };\n\nbool match(int f[3][3]){\n    for (int i = 0; i < 3; i++){\n        for (int j = 0; j < 3; j++){\n            if (f[i][j] != ans[i][j])\n                return false;\n        }\n    }\n    return true;\n}\n\nint dfs(int f[3][3], int x, int y, int v, int d, int l){\n    if (match(f))\n        return d;\n    if (d > l)\n        return -1;\n    for (int i = 0, res; i < 4; ++i){\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (nx < 0 || nx > 2 || ny < 0 || ny > 2 || (i + 2) % 4 == v)\n            continue;\n        f[y][x] = f[ny][nx];\n        f[ny][nx] = 0;\n        if ((res = dfs(f, nx, ny, i, d + 1, l)) > 0)\n            return res;\n        f[ny][nx] = f[y][x];\n        f[y][x] = 0;\n    }\n    return -1;\n}\n\nint main() {\n    int f[3][3], x, y;\n    for (int i = 0; i < 3; i++){\n        for (int j = 0; j < 3; j++){\n            cin >> f[i][j];\n            if (f[i][j] == 0){\n                y = i;\n                x = j;\n            }\n        }\n    }\n\n    int res;\n    for (int i = 1; i < 50; i++){\n        if ((res = dfs(f, x, y, -1, 0, i)) >= 0){\n            break;\n        }\n    }\n    cout << res << endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <istream>\n#include <ostream>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <random>\n#include <tuple>\n#include <functional>\n\nusing namespace std;\n\ninline int abs(int i) {return i > 0 ? i : -i;}\n\nconstexpr int W = 3;\nconstexpr int H = 3;\nconstexpr int WH = W * H;\n\nenum class Direction {Left, Right, Up, Down};\n\nstruct Position\n{\n    int row;\n    int col;\n    bool slide(Direction d);\n};\n\ninline int pos2idx(const Position & pos) {return pos.row * W + pos.col;}\n\nusing Board = vector<int>;\n\nint calc_MHD(Board & board);\n\nPosition find_blank(Board & board);\n\n\nclass Status\n{\npublic:\n    // ctor\n    Status() = default;\n    Status(Board & board_, Position & blank_): board{board_}, blank{blank_} {mhd = calc_MHD(board_);};\n    Status(Board & board_): board{board_} {blank = find_blank(board_); mhd = calc_MHD(board_);};\n    // copy, move ctor\n    Status(const Status & status) = default;\n    Status(Status && status) = default;\n    // copy, move assignment\n    Status& operator=(const Status & status) = default;\n    Status& operator=(Status && status) = default;\n    //detor\n    ~Status() = default;\n    \n    friend istream & operator>>(istream & is, Status & st);\n    \n    bool operator==(const Status & rhs) const {return board == rhs.board;};\n    bool operator<(const Status & rhs) const {return board < rhs.board;};\n    bool operator>(const Status & rhs) const {return board > rhs.board;};\n    \n    bool slide(Direction d);\n    \n    int get_mhd() const {return mhd;};\n    Board get_board() const {return board;};\n\nprivate:\n    Board board = {1, 2, 3, 4, 5, 6, 7, 8, 0};\n    Position blank = {2, 2};\n    int mhd = 0;\n    void _update();\n    void _update_after_slide(const Position & prev_blank);\n};\n\nistream & operator>>(istream & is, Board & board);\n\nint solve(Status status);\n\n////////////////////////////////////////////////\n// main function\n////////////////////////////////////////////////\nint main()\n{\n    Status status;\n    cin >> status;\n    cout << solve(status) << endl;\n    return 0;\n}\n\n\n////////////////////////////////////////////////\n\nint solve(Status status){\n    priority_queue< pair<int, Status>, vector< pair<int, Status> >, greater< pair<int, Status> > > pq;\n    map<Board, int> b2s;\n    \n    pq.emplace(0 + status.get_mhd(), status);\n    b2s[status.get_board()] = 0;\n    while (not pq.empty()){\n        int p;\n        Status st;\n        tie(p, st) = pq.top();\n        pq.pop();\n        if (st.get_mhd() == 0) return p;\n        int steps = p - st.get_mhd();\n        auto bd = st.get_board();\n        if (b2s[bd] < steps) continue;\n        for (auto d : {Direction::Left, Direction::Right, Direction::Up, Direction::Down}){\n            Status new_st{st};\n            if (new_st.slide(d)){\n                auto new_bd = new_st.get_board();\n                auto it = b2s.find(new_bd);\n                if (it == b2s.end() or it->second > steps + 1){\n                    b2s[new_bd] = steps + 1;\n                    pq.emplace(steps + 1 + new_st.get_mhd(), new_st);\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint calc_MHD(Board & board){\n    // Calculates the sum of Manhattan distances\n    // from current position to goal position \n    // for all panels except blank (=0) panel. \n    int mhdist = 0;\n    int src = 0;\n    for (auto dst : board){\n        if (dst == 0){\n            ++src;\n            continue;\n        }\n        dst = (dst + WH - 1) % WH;\n        int drow = abs(src / W - dst / W);\n        int dcol = abs(src % W - dst % W);\n        mhdist += drow + dcol;\n        ++src;\n    }\n    return mhdist;\n}\n\n\nPosition find_blank(Board & board){\n    // Find a blank (=0) panel on a board with width=W and height=H\n    // and return its position (row, col).\n    for(int i = 0; i != WH; ++i){\n        if (board[i]) continue;\n        return {i / W, i % W};\n    }\n}\n\n\nistream & operator>>(istream & is, Board & board){\n    for (int i = 0; i != WH; ++i){\n        cin >> board[i];\n    }\n    return is;\n}\n\n\nistream & operator>>(istream & is, Status & st){\n    is >> st.board;\n    st._update();\n    return is;\n}\n\nbool Position::slide(Direction d){\n    switch(d){\n        case Direction::Left:\n            if (col <= 0) return false;\n            --col;\n            break;\n        case Direction::Right:\n            if (col >= W - 1) return false;\n            ++col;\n            break;\n        case Direction::Up:\n            if (row <= 0) return false;\n            --row;\n            break;\n        case Direction::Down:\n            if (row >= H - 1) return false;\n            ++row;\n            break;\n    }\n    return true;\n}\n\nbool Status::slide(Direction d){\n    Position prev_blank = blank;\n    if (blank.slide(d)){\n        // post_process\n        _update_after_slide(prev_blank);\n        return true;\n    }else{\n        // can't slide\n        return false;\n    }\n}\n\nvoid Status::_update(){\n    blank = find_blank(board);\n    mhd = calc_MHD(board);\n}\n\nvoid Status::_update_after_slide(const Position & prev_blank){\n    auto prev_idx = pos2idx(prev_blank);\n    auto new_idx = pos2idx(blank);\n    auto panel_val = board[new_idx];\n    // update Manhattan disntance\n    // panel_val has moved from prev_blank to blank.\n    int row_final = (panel_val - 1) / W;\n    int col_final = (panel_val - 1) % W;\n    // subtract the Manhattan distance from the previous position of panel_val,\n    // which is the same as the current position of blank, to the final position of panel_val.\n    mhd -= abs(row_final - blank.row) + abs(col_final - blank.col);\n    // add the Manhattan distance from the current position of panel_val,\n    // which is the same as the previous position of blank, to the final position of panel_val.\n    mhd += abs(row_final - prev_blank.row) + abs(col_final - prev_blank.col);\n    \n    // swap 0 and panel_val\n    board[prev_idx] = panel_val;\n    board[new_idx] = 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n\nusing namespace std;\nconst int N = 3;\nconst int N2 = 9;\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\nconst char dir[4] = {'u','l','d','r'};\n\n\ntypedef struct Puzzle {\n\tint M[N2]; //状态 \n\tint space; //空格位置 \n\tstring path; //记录空格的移动路径 \n\t\n\tbool operator<(const Puzzle & p) const {\n\t\tfor (int i=0;i<N2;i++) {\n\t\t\tif (M[i] == p.M[i]) continue;\n\t\t\treturn M[i] > p.M[i]; //为了让后面生成的状态靠前 \n\t\t}\n\t\treturn false;\n\t}\n\t\n} Puzzle;\n\nbool isTarget(Puzzle & p) {\n\tfor (int i=0;i<N2-1;i++) {\n\t\tif (p.M[i] != i+1) return false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle p) { //广度优先搜索 \n\tqueue<Puzzle> Q;\n\tmap<Puzzle,bool> V;\n\tPuzzle u,v;\n\tp.path = \"\";\n\tQ.push(p);\n\tV[p] = true;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isTarget(u)) {\n\t\t\treturn u.path;\n\t\t}\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\t//搜索四个方向 \n\t\tfor (int r=0;r<4;r++) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N) continue; //不存在的情况\n\t\t\tint tspace = tx * N + ty; //新的空格位置\n\t\t\tv = u;//拷贝一份\n\t\t\tv.space = tspace; //改变数据\n\t\t\tswap(v.M[u.space],v.M[v.space]);\n\t\t\t//检查新生成的状态是否已经存在 \n\t\t\tif (!V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main() {\n\tPuzzle in;\n\tfor (int i=0;i<N2;i++) {\n\t\tcin >> in.M[i];\n\t\tif (in.M[i] == 0) {\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl; \n \treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nconst int PATTERN = 362880;\nconst int FORWARD  = 1;\nconst int BACKWARD = 2;\nint frontier[PATTERN];\n\nstruct State {\n    Board board;\n    int count;\n};\n\nqueue<State> q;\n\n// I made this function based on one by Haruhiko Okumura(Algorithm \n// Dictionary, p116) and one by M.Hiroi(Puzzle DE Programming).\ninline int change_number(long long board) {\n    static int fact_table[N] = {\n         40320, 5040, 720, 120, 24, 6, 2, 1, 0      // on N = 8\n    };\n    int value = 0;\n    for (int j = 0; j < N - 1; ++j) {\n        int J = static_cast<int>((board >> (j*4) & 0xF));\n        value += fact_table[j] * J;\n        for (int k = j + 1; k < N; ++k) {\n            int K = static_cast<int>((board >> k*4) & 0xF);\n            if (J < K) {\n                board &= ~(0xFLL << k*4);\n                board |= (static_cast<long long>(K - 1) << k*4);\n            }\n        }\n    }\n//    printf(\"[change_number] value = %d\\n\", value);\n    return value;\n}\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 0xF;\n    board |= num << (spacepos*4);\n    board &= ~(0xFLL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, State s) {\n    int prev = change_number(s.board);\n    int direction = frontier[prev];\n//    printf(\"[swap&check] direction = %d\\n\", direction);\n    swap(numpos, spacepos, s.board);\n//    if (s.board == GOAL) {\n//        return ++s.count;\n//    }\n    int pos = change_number(s.board);\n    if (!frontier[pos]) {\n        ++s.count;\n        q.push(s);\n        frontier[pos] = direction;\n        return -1;\n    }\n    else if (frontier[pos] != direction) {\n        ++s.count;\n//        printf(\"[swap&check] s.count = %d\\n\", s.count);\n        return s.count * 2 - s.count % 2;\n    }\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 0xF));\n    }\n    printf(\"\\n\");\n}\n\n// OK\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0, num; i < N; ++i) {\n        scanf(\"%d\", &num);\n        board |= static_cast<long long>(num) << (i*4);\n    }\n//    print(GOAL);\n//    print(board);\n\n    int count = 0;\n    if (board == GOAL) {\n        goto END;\n    }\n\n    frontier[change_number(board)] = FORWARD;\n    frontier[change_number(GOAL)] = BACKWARD;\n\n    q.push({ board, 0 });\n    q.push({ GOAL, 0 });\n    while (!q.empty()) {\n        State s = q.front();\n        q.pop();\n\n        int pos = -1;\n        while (++pos < N) {\n            if (((s.board >> (pos*4)) & 0xF) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<ll, ll> pll;\n\n#define FOR(i, n, m) for(ll (i)=(m);(i)<(n);++(i))\n#define REP(i, n) FOR(i,n,0)\n#define OF64 std::setprecision(10)\n\nconst ll MOD = 1000000007;\nconst ll INF = (ll) 1e15;\nconst ll MAX = 3;\nll LIMIT = 35;\n\nll A[MAX][MAX];\nll x[4] = {0, 1, 0, -1};\nll y[4] = {1, 0, -1, 0};\n\nll dfs(pll s, ll match, pll prev = pll(-1, -1), ll cnt = 0) {\n    if (match == MAX * MAX - 1) {\n        return cnt;\n    }\n    if (LIMIT <= cnt)\n        return INF;\n    if (LIMIT < cnt + (MAX - s.first - 1) + (MAX - s.second - 1))\n        return INF;\n\n    ll ret = INF;\n    REP(i, 4) {\n        ll nx = x[i] + s.first, ny = y[i] + s.second;\n        if (nx < 0 || ny < 0 || nx >= MAX || ny >= MAX)\n            continue;\n        if (prev.first == nx && prev.second == ny)\n            continue;\n        ll m = match;\n        if (A[nx][ny] == nx * MAX + ny + 1)\n            m--;\n        else if (A[nx][ny] == s.first * MAX + s.second + 1)\n            m++;\n        swap(A[s.first][s.second], A[nx][ny]);\n        ret = std::min(ret, dfs(pll(nx, ny), m, s, cnt + 1));\n        swap(A[s.first][s.second], A[nx][ny]);\n    }\n    LIMIT = std::min(LIMIT, ret);\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    pll s;\n    REP(i, MAX) {\n        REP(j, MAX) {\n            cin >> A[i][j];\n            if (A[i][j] == 0)\n                s = pll(i, j);\n        }\n    }\n\n    ll match = 0;\n    REP(i, MAX) {\n        REP(j, MAX) {\n            ll num = i * MAX + j + 1;\n            if (A[i][j] == num)\n                match++;\n        }\n    }\n\n    cout << dfs(s, match) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<string,int> P;\nqueue<P > que;\nvoid move(string st,int x){\n  int pos;\n  int look[4]={-3,3,-1,1};//up do le ri\n  for(int i=0;i<9;i++){\n    if(st[i]=='0'){\n      pos=i;\n      break;\n    }\n  }\n  for(int i=0;i<4;i++){\n    string str=st;\n    if(i==2&&pos%3==0)continue;\n    if(i==3&&pos%3==2)continue;\n    int npos=pos+look[i];\n    if(npos>8||npos<0)continue;\n    swap(str[pos],str[npos]);\n    que.push(P(str,x+1));\n  }\n}\nint main(){\n  string puzzle=\"\";\n  string goal=\"123456780\";\n  map<string,bool> ma;\n  for(int i=0;i<9;i++){\n    int x;\n    cin >> x;\n    puzzle+='0'+x;\n  }\n  que.push(P(puzzle,0));\n  while(1){\n    P p=que.front();que.pop();\n    string puz=p.first;\n    int x=p.second;\n    if(puz==goal){\n      cout << x << endl;\n      break;\n    }\n    if(ma[puz])continue;\n    else ma[puz]=1;\n    move(puz,x);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//8 Puzzle\n#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nstatic const int N = 3;\nstatic const int N2 = 9;\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nstatic const int dx[4] = {0, -1, 0, 1};\nstatic const int dy[4] = {1, 0, -1, 0};\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for(int i = 0; i < N2; i++) {\n            if(f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nbool isTarget(Puzzle p) {\n    for(int i = 0; i < N2; i++) {\n        if(p.f[i] != (i + 1)) return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle p) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    p.path = \"\";\n    Q.push(p);\n    V[p] = true;\n    while(!Q.empty()) {\n        u = Q.front();\n        Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx = u.space % N;\n        int sy = u.space / N;\n        for(int r = 0; r < 4; r++) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            v.space = tx + N * ty;\n            swap(v.f[v.space], v.f[u.space]);\n            if(!V[v]) {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main() {\n    Puzzle in;\n    for(int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if(in.f[i] == 0) {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n\n    cout << bfs(in).size() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\ntypedef pair<LL, LL> pii;\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nconst char dir[4] = { 'u','l','d','r' };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nconst int n = 3;\n\nstruct Puzzle {\n\tint f[n*n];\n\tint space;\n\tstring path;\n\n\tbool operator < (const Puzzle &p)const {\n\t\tfor (int i = 0; i < n*n; i++) {\n\t\t\tif (f[i] == p.f[i])continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t};\n};\n\nbool istarget(Puzzle p) {\n\tfor (int i = 0; i < n*n; i++) {\n\t\tif (p.f[i] != (i + 1))return false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle s) {\n\tqueue<Puzzle> q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tq.push(s);\n\tV[s] = true;\n\n\twhile (!q.empty()) {\n\t\tu = q.front();\n\t\tq.pop();\n\t\tif (istarget(u))return u.path;\n\t\tint sx = u.space / n;\n\t\tint sy = u.space % n;\n\t\tfor (int r = 0; r < 4; r++) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= n || ty >= n)continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx*n + ty]);\n\t\t\tv.space = tx*n + ty;\n\t\t\tif (!V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main() {\n\tPuzzle in;\n\n\tfor (int i = 0; i < n*n; i++) {\n\t\tcin >> in.f[i];\n\t\tif (in.f[i] == 0) {\n\t\t\tin.f[i] = n*n;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nconst static int N = 3;\nconst static int N2 = 9;\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    for(int i=0; i<N2; ++i){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nconst static int dx[4] = {-1, 0, 1, 0};\nconst static int dy[4] = {0, -1, 0, 1};\nconst static char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  for(int i=0; i<N2; ++i)\n    if(p.f[i] != (i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r=0; r<4; ++r){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if(!V[v]){\n\tV[v] = true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0; i<N2; ++i){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space =i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <list>\n#include <vector>\n#include <string>\n#include <map>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nstruct state {\n    Board board;\n    int count;\n};\n\nlist<state> q;\nmap<Board,char> history;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    map<Board,char>::iterator it = history.find(s.board);\n    if (it != history.end()) {\n        return -1;\n    }\n    history.insert(make_pair(s.board, ' '));\n//    for (list<state>::iterator it = q.begin(); it != q.end(); ++it) {\n//        if (it->board == s.board) {\n//            return -1;\n//        }\n//    }\n    ++s.count;\n    if (s.board == GOAL) {\n        return s.count;\n    }\n    q.push_back(s);\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0; i < N; ) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            board |= static_cast<long long>((ch - '0')) << (i*4);\n            ++i;\n        }\n    }\n\n    if (board == GOAL) {\n        printf(\"0\\n\");\n        return 0;\n    }\n\n//    print(GOAL);\n//    print(board);\n\n    q.push_back({ board, 0 });\n    int count = 0;\n    while (!q.empty()) {\n        state s = q.front();\n        q.pop_front();\n        // ?????????????????????\n        int pos;\n        for (pos = 0; pos < N; ++pos) {\n            if (((s.board >> (pos*4)) & 15) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 20;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i) {\n        return;\n    }\n\n    if (in.path == \"ldrd\")\n        int debug = 0;\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n    /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n    freopen(\"in.txt\", \"r\", stdin);\n    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i, n) for(int i=0;i<n;i++)\n#define N 9\n#define SQRTN 3\n#define LIMIT 100\nusing namespace std;\n\nint limit;\nint searchV[4][2] = {{0, 1},{1, 0},{0, -1},{-1, 0}};\n\nstruct Board{\n  int b[N], h;\n  int calcHeust(void){\n    h = 0;\n    for(int i = 0; i < SQRTN; i++){\n      for(int j = 0; j < SQRTN; j++){\n        if(b[i*SQRTN + j] == N-1) continue;\n        h += abs(b[i*SQRTN + j]/SQRTN-i) + abs(b[i*SQRTN + j]%SQRTN-j);\n      }\n    }\n    return h;\n  }\n};\n\nvoid printBoard(Board b){\n    rep(i, SQRTN){\n     rep(j, SQRTN){\n       cout << b.b[i*SQRTN + j];\n     }\n     cout << endl;\n    }\n}\n\n\nBoard currentState;\n\nbool dfs(int depth, int prev, int cbX, int cbY){\n  currentState.calcHeust();\n  if ( currentState.h == 0) return true;\n  if ( depth + currentState.h > limit ) return false;\n  \n  for (int d = 0 ; d < 4 ; d++ ){\n    int sx = cbX + searchV[d][0];\n    int sy = cbY + searchV[d][1];\n    if ( abs(d - prev) == 2 ) continue;\n    if ( sx < 0 || sy < 0 || sx >= SQRTN || sy >= SQRTN) continue;\n\n    swap(currentState.b[cbY*SQRTN + cbX], currentState.b[sy*SQRTN + sx]);\n    if (dfs(depth+1, d, sx, sy)) return true;\n    swap(currentState.b[cbY*SQRTN + cbX], currentState.b[sy*SQRTN + sx]);\n  }\n  \n  return false;\n}\n\nint idastar(Board in, int px, int py){\n  for (limit=0;limit < LIMIT;limit++){\n    currentState = in;\n    if (dfs(0, 100, px, py)) return limit;\n  }\n  return -1;\n}\n\nint main(void){\n  Board init;\n  int p0x, p0y;\n  rep(i, N){\n    cin >> init.b[i];\n    if (init.b[i]==0){\n      init.b[i] = N;\n      p0y = i/SQRTN;\n      p0x = i%SQRTN;\n    }\n    init.b[i]--;\n  }\n  cout << idastar(init, p0x, p0y) << endl;;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\nint f[N2];\nint space;\nstring path;\n\nbool operator < (const Puzzle &p) const{\nfor(int i = 0; i < N2; i++){\nif(f[i] == p.f[i]) continue;\nreturn f[i] > p.f[i];\n}\nreturn false;\n}\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\nfor(int i = 0; i < N2; i++)\nif(p.f[i] != (i + 1)) return false;\nreturn true;\n}\n\nstring bfs(Puzzle s){\nqueue<Puzzle> Q;\nmap<Puzzle, bool> V;\nPuzzle u, v;\ns.path = \"\";\nQ.push(s);\nV[s] = true;\n\nwhile(!Q.empty()){\nu = Q.front(); Q.pop();\nif(isTarget(u)) return u.path;\nint sx = u.space / N;\nint sy = u.space % N;\nfor(int r = 0; r < 4; r++){\nint tx = sx + dx[r];\nint ty = sy + dy[r];\nif(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\nv = u;\nswap(v.f[u.space], v.f[tx * N + ty]);\nv.space = tx * N + ty;\nif(!V[v]){\nV[v] = true;\nv.path += dir[r];\nQ.push(v);\n}\n}\n}\nreturn \"unsolvable\";\n}\n\nint main(){\nPuzzle in;\nfor(int i = 0; i < N2; i++){\ncin >> in.f[i];\nif(in.f[i] == 0){\nin.f[i] = N2;\nin.space = i;\n}\n}\nstring ans = bfs(in);\ncout << ans.sizu() << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<string>\n#include<queue>\n#include<iostream>\n#define N 3\n#define N2 9\nusing namespace std;\nstatic const char c[4] = {'u', 'd', 'l', 'r'};\nstatic const int x[4] = {-1, 1, 0, 0};\nstatic const int y[4] = {0, 0, -1, 1};\nstruct Puzzle\n{\n  int f[N2];  int space; // f[] to record number sequence, space to record the location of number '0';\n  string path;\n  bool operator < (const Puzzle &p) const\n  {\n    for(int i=0; i<N2; i++)\n    {\n      if(f[i] == p.f[i])  continue;\n      else return f[i] < p.f[i];\n    }\n    return false;\n  }\n};\n\nbool istarget(Puzzle p)\n{\n  for(int i=0; i<N2; i++)\n  {\n    if(p.f[i] == i+1)\n      continue;\n    else return false;\n  }\n  return true;\n}\n\nstring bfs(Puzzle& p)\n{\n  queue<Puzzle> PQ;\n  Puzzle u, v;\n  p.path = \"\";\n  map<Puzzle, bool> V;\n  V[p] = true;\n  PQ.push(p);\n  while(!PQ.empty())\n  {\n    u = PQ.front(); PQ.pop();\n    if(istarget(u)) {return u.path;}\n    int sx, sy, tx, ty;\n    sx = u.space/N; sy = u.space % N;\n    for(int r=0; r<4; r++)\n    {\n      tx = sx + x[r]; ty = sy + y[r];\n      if(tx>=N || tx<0 || ty>=N || ty<0) continue;\n      v = u; v.space = tx*N + ty;v.path += c[r];\n      swap(v.f[sx*N + sy], v.f[tx*N + ty]);\n\n      if(V.find(v) == V.end())\n      {\n        V[v] = true;PQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\nint main()\n{\n  Puzzle input;\n  for(int i=0; i<N2; i++)\n  {\n    scanf(\"%d\", &input.f[i]);\n    if(input.f[i] == 0)\n    {\n      input.f[i] = N2;\n      input.space = i;\n    }\n  }\n  string ans = bfs(input);\n  cout << ans.size() << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst int edge[4][3] = {{0, 3, 6}, {0, 1, 2}, {6, 7, 8}, {2, 5, 8}}; /* l, t, b, r */\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    if(check() == 0)\n        return moves;\n    int zero;\n    int original[9];\n    if(check() + moves > cutoff)\n        return -1;\n    REP(i, 9){\n        original[i] = tiles[i];\n        if(tiles[i] == 0){\n            zero = i;\n        }\n    }\n    bool dir[4] = {true, true, true, true};\n    REP(i, 4) REP(j, 3)\n        if (zero == edge[i][j])\n            dir[i] = false;\n    if(dir[0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    REP(i, 9) tiles[i] = original[i];\n    if(dir[1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    REP(i, 9) tiles[i] = original[i];\n    if(dir[2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    REP(i, 9) tiles[i] = original[i];\n    if(dir[3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    REP(i, 9) tiles[i] = original[i];\n    return dfs(moves, cutoff+1);\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = dfs(0, check());\n\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator < (const Puzzle &p)const{\n\t\tfor (int i = 0; i < N2; ++i) {\n\t\t\tif(f[i]==p.f[i])continue;\n\t\t\treturn f[i]>p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif(p.f[i]!=(i+1))return false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle s){\n\tqueue<Puzzle> Q;\n\tmap<Puzzle,bool> V;\n\tPuzzle u,v;\n\ts.path=\"\";\n\tQ.push(s);\n\tV[s]=true;\n\twhile(!Q.empty()){\n\t\tu=Q.front();Q.pop();\n\t\tif(isTarget(u))return u.path;\n\t\tint sx=u.space/N;\n\t\tint sy=u.space%N;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tint tx=sx+dx[r];\n\t\t\tint ty=sy+dy[r];\n\t\t\tif(tx<0||ty<0||tx>=N||ty>=N)continue;\n\t\t\tv=u;\n\t\t\tswap(v.f[u.space],v.f[tx*N+ty]);\n\t\t\tv.space=tx*N+ty;\n\t\t\tif(!V[v]){\n\t\t\t\tV[v]=true;\n\t\t\t\tv.path+=dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\nint main(){\n\tPuzzle in;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tcin>>in.f[i];\n\t\tif(in.f[i]==0){\n\t\t\tin.f[i]=N2;//set space\n\t\t\tin.space=i;\n\t\t}\n\t}\n\tstring ans=bfs(in);\n\tcout<<ans.size()<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <map>\nusing namespace std;\nconst int MAXN = 100005;\nconst int MAXE = 200005;\nconst int NIL = -1;\ntypedef long long ll;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\nconst int dx[4] = { -1, 0, 1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\nconst char dir[4] = { 'u', 'r', 'd', 'l' };\nstruct Puzzle {\n\tint Sudoku[3][3];\n\tint space;\n\tstring path;\n\tbool operator<(const Puzzle& p) const\n\t{\n\t\tfor (int i = 0; i < 3; ++i)\n\t\t\tfor (int j = 0; j < 3; ++j)\n\t\t\t\tif (Sudoku[i][j] == p.Sudoku[i][j])\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\treturn Sudoku[i][j] < p.Sudoku[i][j];\n\t\treturn false;\n\t}\n};\n\nbool ok(const Puzzle &p)\n{\n\tfor (int i = 0; i < 3; ++i)\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t\tif (p.Sudoku[i][j] != i * 3 + j + 1)\n\t\t\t\treturn false;\n\treturn true;\n}\n\nstring bfs(Puzzle s)\n{\n\tqueue<Puzzle> q;\n\tmap<Puzzle, bool> vis;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tq.push(s);\n\tvis[s] = true;\n\twhile (!q.empty())\n\t{\n\t\tu = q.front();\n\t\tq.pop();\n\t\tif (ok(u))\n\t\t\treturn u.path;\n\t\tint x = (u.space - 1) / 3;\n\t\tint y = (u.space - 1) % 3;\n\t\t//cout << \"space == \" << u.space << \" x == \" << x << \" y == \" << y << endl;\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint tx = x + dx[i];\n\t\t\tint ty = y + dy[i];\n\t\t\tif (tx < 0 || ty < 0 || tx >= 3 || ty >= 3)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\tswap(v.Sudoku[x][y], v.Sudoku[tx][ty]);\n\t\t\tv.space = tx * 3 + ty + 1;\n\t\t\tif (!vis[v])\n\t\t\t{\n\t\t\t\tvis[v] = true;\n\t\t\t\tv.path += dir[i];\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t\n\tPuzzle s;\n\tfor (int i = 0; i < 3; ++i)\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t{\n\t\t\tcin >> s.Sudoku[i][j];\n\t\t\tif (s.Sudoku[i][j] == 0)\n\t\t\t\ts.Sudoku[i][j] = 9, s.space = i * 3 + j + 1;\n\t\t}\n\tcout << bfs(s).size() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\nstruct Puzzle{\n    int f[N2];\n    int space;\n    string path;\n    bool operator < ( const Puzzle &p ) const {\n        for ( int i = 0; i < N2; i++ ) {\n            if ( f[i] == p.f[i] ) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n    for ( int i = 0; i < N2; i++ )\n    if ( p.f[i] != (i + 1) ) return false;\n    return true;\n}\n\nstring bfs(Puzzle s) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while(!Q.empty()){\n        u = Q.front(); Q.pop();\n        if (isTarget(u) ) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for ( int r =0; r < 4; r++ ) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if ( tx < 0 || ty < 0 || tx >=N || ty >= N ) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if ( !V[v] ) {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main(){\n    Puzzle in;\n    for ( int i = 0; i < N2; i++ ){\n        cin >> in.f[i];\n        if ( in.f[i] == 0 ){\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define fordebug int hoge;cin>>hoge;\n#define DEKAI 1000000007\n#define INF (1<<28)\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,j,n) for(int i=j;i<n;i++)\n#define floot10 cout<<fixed<<setprecision(10);\n//#define int long long\n\nint goal,ans=INF;\nset<int> s;\ndecltype(s)::iterator it;\nint fh[3][3];\n\nint tohash(){\n\tint hash=0;\n\tlp(i,3){\n\t\tlp(j,3){\n\t\t\thash*=10;\n\t\t\thash+=fh[i][j];\n\t\t}\n\t}\n\treturn hash;\n}\n\nvoid fromhash(int h){\n\tlp(i,3){\n\t\tlp(j,3){\n\t\t\tfh[2-i][2-j]=h%10;\n\t\t\th/=10;\n\t\t}\n\t}\n\treturn;\n}\n\nvoid solve(){\n\tlp(i,3)lp(j,3){\n\t\tfh[i][j]=i*3+j+1;\n\t}\n\tfh[2][2]=0;\n\tqueue<pair<int,int> > q;\n\tq.push(make_pair(tohash(),0));\n\tif(tohash()==goal){\n\t\tans=0;\n\t\treturn;\n\t}\n\tint cost;\n\tint x,y;\n\twhile(!q.empty()){\n\t\tcost=q.front().second;\n\t\tfromhash(q.front().first);\n\t\tq.pop();\n\t\tlp(i,3){\n\t\t\tlp(j,3){\n\t\t\t\tif(fh[i][j]==0){\n\t\t\t\t\tx=i;y=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(x!=0){\n\t\t\tswap(fh[x][y],fh[x-1][y]);\n\t\t\tint memo=tohash();\n\t\t\tif(memo==goal){\n\t\t\t\tans=cost+1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tit=s.find(memo);\n\t\t\tif(it==s.end()){\n\t\t\t\tq.push(make_pair(memo,cost+1));\n\t\t\t\ts.insert(memo);\n\t\t\t}\n\t\t\tswap(fh[x][y],fh[x-1][y]);\n\t\t}\n\t\tif(y!=0){\n\t\t\tswap(fh[x][y],fh[x][y-1]);\n\t\t\tint memo=tohash();\n\t\t\tif(memo==goal){\n\t\t\t\tans=cost+1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tit=s.find(memo);\n\t\t\tif(it==s.end()){\n\t\t\t\tq.push(make_pair(memo,cost+1));\n\t\t\t\ts.insert(memo);\n\t\t\t}\n\t\t\tswap(fh[x][y],fh[x][y-1]);\n\t\t}\n\t\tif(x!=2){\n\t\t\tswap(fh[x][y],fh[x+1][y]);\n\t\t\tint memo=tohash();\n\t\t\tif(memo==goal){\n\t\t\t\tans=cost+1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tit=s.find(memo);\n\t\t\tif(it==s.end()){\n\t\t\t\tq.push(make_pair(memo,cost+1));\n\t\t\t\ts.insert(memo);\n\t\t\t}\n\t\t\tswap(fh[x][y],fh[x+1][y]);\n\t\t}\n\t\tif(y!=2){\n\t\t\tswap(fh[x][y],fh[x][y+1]);\n\t\t\tint memo=tohash();\n\t\t\tif(memo==goal){\n\t\t\t\tans=cost+1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tit=s.find(memo);\n\t\t\tif(it==s.end()){\n\t\t\t\tq.push(make_pair(memo,cost+1));\n\t\t\t\ts.insert(memo);\n\t\t\t}\n\t\t\tswap(fh[x][y],fh[x][y+1]);\n\t\t}\n\t}\n}\n\nsigned main(){\n\tlp(i,3){\n\t\tlp(j,3){\n\t\t\tcin>>fh[i][j];\n\t\t}\n\t}\n\tgoal=tohash();\n\ts.insert(goal);\n\tsolve();\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define FOR(i,n) for(int i=0; i<n; ++i)\n#define GET(type,name) type name; std::cin >> name;\n\n\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <utility>\n#include <algorithm>\n#include <queue>\n#include <numeric>\n#include <unordered_map>\n\n\n    typedef std::vector<std::vector<int>> State;\n    const int N = 3;\n\n    State int_to_state(int c){\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n      FOR(i, N) {\n        FOR(j, N) {\n          int r = c%10;\n          c = c/10;\n          state[i][j] = r;\n        }\n      }\n      return state;\n    }\n    int state_to_int(State state) {\n      int c = 0;\n      int p = 1;\n      FOR(i, N) {\n        FOR(j, N) {\n          c += state[i][j] * p;\n          p *= 10;\n        }\n      }\n      return c;\n    }\n\n\n    void show(std::vector<std::vector<int>> state){\n      FOR(i, N) {\n        FOR(j, N) {\n          std::cout << state[i][j] << \" \";\n        }\n        std::cout << std::endl;\n      }\n    }\n\n    bool is_solved(const State& state) {\n      int N = state.size();\n\n      FOR(i, N) {\n        FOR(j, N) {\n          if(state[i][j] != (1 + 3*i + j)) return false;\n        }\n      }\n      return true;\n    }\n\n    std::vector<State> next_states_of(State state){\n      std::vector<State> res;\n      FOR(i,N){\n        FOR(j,N){\n          if(state[i][j] == 9){\n            State ns;\n            if(i<N-1){\n              ns = state;\n              std::swap(ns[i][j], ns[i+1][j]);\n              res.push_back(ns);\n            }\n            if(j<N-1){\n              ns = state;\n              std::swap(ns[i][j], ns[i][j+1]);\n              res.push_back(ns);\n            }\n            if(i>0){\n              ns = state;\n              std::swap(ns[i][j], ns[i-1][j]);\n              res.push_back(ns);\n            }\n            if(j>0){\n              ns = state;\n              std::swap(ns[i][j], ns[i][j-1]);\n              res.push_back(ns);\n            }\n            return res;\n          }\n        \n    }\n\n    int solve_puzzle(State state){\n\n      std::priority_queue<\n        std::pair<int, int>,\n        std::vector<std::pair<int, int>>,\n        std::greater<std::pair<int, int>>\n      > q;\n      std::unordered_map<int, int> h;\n\n      q.push(std::make_pair(0, state_to_int(state)));\n\n      for(;not q.empty();){\n        auto d_s = q.top(); q.pop();\n        int d = d_s.first;\n        int st_int = d_s.second;\n        State state = int_to_state(d_s.second);\n//        show(state);\n\n        if(st_int == 987654321){\n//          std::cout << \"z\"<< std::endl;\n          return d;\n        }\n\n        if(h.find(st_int) == h.end()){\n          h[st_int] = d;\n          std::vector<State> next_states = next_states_of(state);\n          for(auto ns : next_states){\n            q.push(std::make_pair(d+1, state_to_int(ns)));\n          }\n        }\n      }\n      return -1;\n    }\n\n    int main(){\n      const int N = 3;\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n\n      FOR(i, N){\n        FOR(j, N){\n          GET(int, x);\n          if(x==0) x=9;\n          state[i][j] = x;\n        }\n      }\n//      show(state);\n//      int c = state_to_int(state);\n//      std::cout << c << std::endl;\n//      std::cout << \"?\" <<std::endl;\n//      State s2 = int_to_state(c);\n//      std::cout << \"!\" <<std::endl;\n//\n//      show(s2);\n//      int min_steps = rec_min_steps_\n      std::cout << solve_puzzle(state) << std::endl;\n      return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nstruct state {\n    Board board;\n    int count;\n};\n\nlist<state> q;\nset<Board> history;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    if (s.board == GOAL) {\n        return ++s.count;\n    }\n    if (history.insert(s.board).second) {\n        ++s.count;\n        q.push_back(s);\n    }\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\n// OK\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0; i < N; ) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            board |= static_cast<long long>((ch - '0')) << (i*4);\n            ++i;\n        }\n    }\n//    print(GOAL);\n//    print(board);\n\n    int count = 0;\n    if (board == GOAL) {\n        goto END;\n    }\n\n    q.push_back({ board, 0 });\n    while (!q.empty()) {\n        state s = q.front();\n        q.pop_front();\n\n        int pos = -1;\n        while (++pos < N) {\n            if (((s.board >> (pos*4)) & 15) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\nusing board = vector<int>;\n \nint h, w, n;\nconstexpr int dx[4] = {0, 1, 0, -1};\nconstexpr int dy[4] = {1, 0, -1, 0};\n \nstruct state{\n    int score, dist;\n    board b;\n \n    state(int s, int d, board b): score(s), dist(d), b(b){}\n};\n \nint xy_to_id(int x, int y){\n    return x*w + y;\n}\n \npair<int, int> id_to_xy(int i){\n    return {i/w, i%w};\n}\n \npair<int, int> blank(board &b){\n    for(int i=0; i<n; ++i){\n        if(b[i] == n-1) return id_to_xy(i);\n    }\n}\n \nbool check(board &b){\n    for(int i=0; i<n; ++i){\n        if(b[i] != i) return false;\n    }\n    return true;\n}\n \nint heuristic_func(board &b){\n    int ret = 0;\n    for(int i=0; i<n; ++i)if(b[i] != n-1) ret += (b[i] != i);\n    return ret;\n}\n \nint main(){\n    h = w = 3;\n    n = h * w;\n \n    board b(n);\n    for(int i=0; i<n; ++i){\n        int c;\n        cin >> c;\n        b[i] = (c == 0 ? n-1 : c-1);\n    }\n \n    auto cmp = [](const state &s1, const state &s2){\n        if(s1.score == s2.score){\n            if(s1.dist == s2.dist) return s1.b < s2.b;\n            return s1.dist < s2.dist;\n        }\n        return s1.score < s2.score;\n    };\n    map<board, int> min_score;\n    set<state, decltype(cmp)> open_list(cmp);\n    state init_state = {heuristic_func(b), 0, b};\n    open_list.insert(init_state);\n    min_score[init_state.b] = init_state.score;\n \n    while(!open_list.empty()){\n        auto cur_state = *open_list.begin();\n        open_list.erase(cur_state);\n        if(cur_state.score > 45 ||  cur_state.score > min_score[cur_state.b]) continue;\n \n        auto bxy = blank(cur_state.b);\n        for(int i=0; i<4; ++i){\n            int nx = bxy.first + dx[i], ny = bxy.second + dy[i];\n            if(0<=nx && nx<h && 0<=ny && ny<w){\n                auto nxt_state = cur_state;\n                swap(nxt_state.b[xy_to_id(nx, ny)], nxt_state.b[xy_to_id(bxy.first, bxy.second)]);\n                nxt_state.dist = cur_state.dist + 1;\n                nxt_state.score = nxt_state.dist + heuristic_func(nxt_state.b);\n                if(nxt_state.score > 45) continue;\n                if(min_score.find(nxt_state.b) == min_score.end() || min_score[nxt_state.b] > nxt_state.score){\n                    min_score[nxt_state.b] = nxt_state.score;\n                    open_list.insert(nxt_state);\n                }\n            }\n        }\n    }\n    \n    board cur_board(n);\n    for(int i=0; i<n; ++i) cur_board[i] = i;\n    cout << min_score[cur_board] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <istream>\n#include <ostream>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <random>\n#include <tuple>\n#include <functional>\n\nusing namespace std;\n\ninline int abs(int i) {return i > 0 ? i : -i;}\n\nconstexpr int W = 3;\nconstexpr int H = 3;\nconstexpr int WH = W * H;\n\nenum class Direction {Left, Right, Up, Down};\n\nstruct Position\n{\n    int row;\n    int col;\n    bool slide(Direction d);\n};\n\ninline int pos2idx(const Position & pos) {return pos.row * W + pos.col;}\n\nusing Board = vector<int>;\n\nint calc_MHD(Board & board);\n\nPosition find_blank(Board & board);\n\n\nclass Status\n{\npublic:\n    // ctor\n    Status() = default;\n    Status(Board & board_, Position & blank_): board{board_}, blank{blank_} {mhd = calc_MHD(board_);};\n    Status(Board & board_): board{board_} {blank = find_blank(board_); mhd = calc_MHD(board_);};\n    // copy, move ctor\n    Status(const Status & status) = default;\n    Status(Status && status) = default;\n    // copy, move assignment\n    Status& operator=(const Status & status) = default;\n    Status& operator=(Status && status) = default;\n    //detor\n    ~Status() = default;\n    \n    friend istream & operator>>(istream & is, Status & st);\n    \n    bool operator==(const Status & rhs) const {return board == rhs.board;};\n    bool operator<(const Status & rhs) const {return board < rhs.board;};\n    bool operator>(const Status & rhs) const {return board > rhs.board;};\n    \n    bool slide(Direction d);\n    \n    int get_mhd() const {return mhd;};\n    Board get_board() const {return board;};\n\nprivate:\n    Board board = {1, 2, 3, 4, 5, 6, 7, 8, 0};\n    Position blank = {2, 2};\n    int mhd = 0;\n    void _update();\n    void _update_after_slide(const Position & prev_blank);\n};\n\nistream & operator>>(istream & is, Board & board);\n\nint solve(Status status);\n\n////////////////////////////////////////////////\n// main function\n////////////////////////////////////////////////\nint main()\n{\n    Status status;\n    cin >> status;\n    cout << solve(status);\n    return 0;\n}\n\n\n////////////////////////////////////////////////\n\nint solve(Status status){\n    priority_queue< pair<int, Status>, vector< pair<int, Status> >, greater< pair<int, Status> > > pq;\n    map<Board, int> b2s;\n    \n    pq.emplace(0 + status.get_mhd(), status);\n    b2s[status.get_board()] = 0;\n    while (not pq.empty()){\n        int p;\n        Status st;\n        tie(p, st) = pq.top();\n        pq.pop();\n        if (st.get_mhd() == 0) return p;\n        int steps = p - st.get_mhd();\n        auto bd = st.get_board();\n        if (b2s[bd] < steps) continue;\n        for (auto d : {Direction::Left, Direction::Right, Direction::Up, Direction::Down}){\n            Status new_st{st};\n            if (new_st.slide(d)){\n                auto new_bd = new_st.get_board();\n                auto it = b2s.find(new_bd);\n                if (it == b2s.end() or it->second > steps + 1){\n                    b2s[new_bd] = steps + 1;\n                    pq.emplace(steps + 1 + new_st.get_mhd(), new_st);\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint calc_MHD(Board & board){\n    // Calculates the sum of Manhattan distances\n    // from current position to goal position \n    // for all panels except blank (=0) panel. \n    int mhdist = 0;\n    int src = 0;\n    for (auto dst : board){\n        if (dst == 0){\n            ++src;\n            continue;\n        }\n        dst = (dst + WH - 1) % WH;\n        int drow = abs(src / W - dst / W);\n        int dcol = abs(src % W - dst % W);\n        mhdist += drow + dcol;\n        ++src;\n    }\n    return mhdist;\n}\n\n\nPosition find_blank(Board & board){\n    // Find a blank (=0) panel on a board with width=W and height=H\n    // and return its position (row, col).\n    for(int i = 0; i != WH; ++i){\n        if (board[i]) continue;\n        return {i / W, i % W};\n    }\n}\n\n\nistream & operator>>(istream & is, Board & board){\n    for (int i = 0; i != WH; ++i){\n        cin >> board[i];\n    }\n    return is;\n}\n\n\nistream & operator>>(istream & is, Status & st){\n    is >> st.board;\n    st._update();\n    return is;\n}\n\nbool Position::slide(Direction d){\n    switch(d){\n        case Direction::Left:\n            if (col <= 0) return false;\n            --col;\n            break;\n        case Direction::Right:\n            if (col >= W - 1) return false;\n            ++col;\n            break;\n        case Direction::Up:\n            if (row <= 0) return false;\n            --row;\n            break;\n        case Direction::Down:\n            if (row >= H - 1) return false;\n            ++row;\n            break;\n    }\n    return true;\n}\n\nbool Status::slide(Direction d){\n    Position prev_blank = blank;\n    if (blank.slide(d)){\n        // post_process\n        _update_after_slide(prev_blank);\n        return true;\n    }else{\n        // can't slide\n        return false;\n    }\n}\n\nvoid Status::_update(){\n    blank = find_blank(board);\n    mhd = calc_MHD(board);\n}\n\nvoid Status::_update_after_slide(const Position & prev_blank){\n    auto prev_idx = pos2idx(prev_blank);\n    auto new_idx = pos2idx(blank);\n    auto panel_val = board[new_idx];\n    // update Manhattan disntance\n    // panel_val has moved from prev_blank to blank.\n    int row_final = (panel_val - 1) / W;\n    int col_final = (panel_val - 1) % W;\n    // subtract the Manhattan distance from the previous position of panel_val,\n    // which is the same as the current position of blank, to the final position of panel_val.\n    mhd -= abs(row_final - blank.row) + abs(col_final - blank.col);\n    // add the Manhattan distance from the current position of panel_val,\n    // which is the same as the previous position of blank, to the final position of panel_val.\n    mhd += abs(row_final - prev_blank.row) + abs(col_final - prev_blank.col);\n    \n    // swap 0 and panel_val\n    board[prev_idx] = panel_val;\n    board[new_idx] = 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n \nqueue<char>Q[3][3];\nqueue<char>R[3][3];\n \nint main() {\n    int a, b, c, d, e, sum=0;\n    int x[3][3];\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            cin >> a;\n            Q[i][j].push(a);\n        }\n    }\n    while (true) {\n        while (!Q[0][0].empty()) {\n            for (int i = 0; i < 3; i++) {\n                for (int j = 0; j < 3; j++) {\n                    if (Q[i][j].front() == 0) {\n                        b = i;\n                        c = j;\n                    }\n                }\n            }\n            for (int i = 0; i < 3; i++) {\n                for (int j = 0; j < 3; j++) {\n                    x[i][j] = Q[i][j].front();\n                }\n            }\n            if (x[0][0] == 1 && x[0][1] == 2 && x[0][2] == 3 && x[1][0] == 4 && x[1][1] == 5 && x[1][2] == 6 && x[2][0] == 7 && x[2][1] == 8) {\n                goto owata;\n            }\n            if (b >= 1) {\n                d = x[b][c];\n                e = x[b - 1][c];\n                x[b][c] = e;\n                x[b - 1][c] = d;\n                for (int i = 0; i < 3; i++) {\n                    for (int j = 0; j < 3; j++) {\n                        R[i][j].push(x[i][j]);\n                    }\n                }\n            }\n            for (int i = 0; i < 3; i++) {\n                for (int j = 0; j < 3; j++) {\n                    x[i][j] = Q[i][j].front();\n                }\n            }\n            if (b <= 1) {\n                d = x[b][c];\n                e = x[b + 1][c];\n                x[b][c] = e;\n                x[b + 1][c] = d;\n                for (int i = 0; i < 3; i++) {\n                    for (int j = 0; j < 3; j++) {\n                        R[i][j].push(x[i][j]);\n                    }\n                }\n            }\n            for (int i = 0; i < 3; i++) {\n                for (int j = 0; j < 3; j++) {\n                    x[i][j] = Q[i][j].front();\n                }\n            }\n            if (c >= 1) {\n                d = x[b][c];\n                e = x[b][c - 1];\n                x[b][c] = e;\n                x[b][c - 1] = d;\n                for (int i = 0; i < 3; i++) {\n                    for (int j = 0; j < 3; j++) {\n                        R[i][j].push(x[i][j]);\n                    }\n                }\n            }\n            for (int i = 0; i < 3; i++) {\n                for (int j = 0; j < 3; j++) {\n                    x[i][j] = Q[i][j].front();\n                }\n            }\n            if (c <= 1) {\n                d = x[b][c];\n                e = x[b][c + 1];\n                x[b][c] = e;\n                x[b][c + 1] = d;\n                for (int i = 0; i < 3; i++) {\n                    for (int j = 0; j < 3; j++) {\n                        R[i][j].push(x[i][j]);\n                    }\n                }\n            }\n            for (int i = 0; i < 3; i++) {\n                for (int j = 0; j < 3; j++) {\n                    Q[i][j].pop();\n                }\n            }\n        }\n        while (!R[0][0].empty()) {\n            for (int i = 0; i < 3; i++) {\n                for (int j = 0; j < 3; j++) {\n                    Q[i][j].push(R[i][j].front());\n                    R[i][j].pop();\n                }\n            }\n        }\n        sum++;\n    }\nowata:;\n    cout << sum << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef complex<int> P;\ntypedef long long ll;\n\nP Dir[4] = {\n\tP(-1, 0),\n\tP(0, -1),\n\tP(1, 0),\n\tP(0, 1),\n};\n\nll pow17[15];\n\nvoid Init() {\n\tpow17[0] = 1;\n\tfor (int i = 1; i < 15; ++i) {\n\t\tpow17[i] = pow17[i-1]*17;\n\t}\n}\n\nclass Puzzle {\nprivate:\n\tint W, H;\n\tint holes;\n\tint board[4][4];\n\tint coe[4][4];\n\tmap<int, P> rboard;\n\tll hash, gHash;\n\npublic:\n\tPuzzle(int W, int H) : W(W), H(H) {\n\t\tinit();\n\t}\n\tvoid init() {\n\t\tholes = 0;\n\t\trboard.clear();\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tint k = y * W + x + 1;\n\t\t\t\tboard[y][x] = k;\n\t\t\t}\n\t\t}\n\t\tinitCoe();\n\t\tinitHash();\n\t}\n\tvoid setTile(int x, int y, int v) {\n\t\tint pv = board[y][x];\n\t\tif (pv < 0) --holes;\n\t\tif (v < 0) ++holes;\n\t\tboard[y][x] = v;\n\t\trboard[v] = P(x, y);\n\t\thash += ((v < 0 ? 0 : v) - (pv < 0 ? 0 : pv)) * pow17[coe[y][x]];\n\t}\n\tvoid initCoe() {\n\t\tfor (int y = 0, k = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (getTile(x, y) != 0) {\n\t\t\t\t\tcoe[y][x] = k++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcoe[y][x] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgHash = 0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tint v = getTile(x, y);\n\t\t\t\tif (v > 0) {\n\t\t\t\t\tint x = (v-1)%W, y = (v-1)/W;\n\t\t\t\t\tgHash += v * pow17[coe[y][x]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint getTile(int x, int y) {\n\t\treturn board[y][x];\n\t}\n\tbool swap(int x1, int y1, int x2, int y2) {\n\t\tint v1 = getTile(x1, y1), v2 = getTile(x2, y2);\n\t\tif (v1 == 0 || v2 == 0 || (v1 < 0 && v2 == 0)) return false;\n\t\tsetTile(x1, y1, v2);\n\t\tsetTile(x2, y2, v1);\n\t\treturn true;\n\t}\n\tbool isComplete() {\n\t\treturn hash == gHash;\n/*\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tint k = y * W + x + 1;\n\t\t\t\tint v = board[y][x];\n\t\t\t\tif (v > 0 && k != v) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n*/\n\t}\n\tbool isOut(int x, int y ) {\n\t\treturn x < 0 || x >= W || y < 0 || y >= H;\n\t}\n\tvoid move(int dir) {\n\t\tdir = (dir + 2) % 4;\n\t\tvector< pair<P, int> > v;\n\t\tfor (int i = 0; i < holes; ++i) {\n\t\t\tP& p = rboard[-(i+1)];\n\t\t\tint x = p.real(), y = p.imag();\n\t\t\tint nx = x + Dir[dir].real(), ny = y + Dir[dir].imag();\n\t\t\tif (isOut(nx, ny)) continue;\n\t\t\tif (getTile(nx, ny) < 0) continue;\n\t\t\tv.push_back( pair<P, int>(p, getTile(nx, ny)) );\n\t\t}\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\tint x = v[i].first.real(), y = v[i].first.imag();\n\t\t\tP p = rboard[v[i].second];\n\t\t\tswap(x, y, p.real(), p.imag());\n\t\t}\n\t}\n\tvoid draw() {\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (x) cout << \" \";\n\t\t\t\tprintf(\"%2d\", getTile(x, y));\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tll getHash() {\n\t\treturn hash;\n\t}\n\tvoid initHash() {\n\t\thash = 0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tint v = getTile(x, y);\n\t\t\t\tif (v != 0) {\n\t\t\t\t\thash += (v < 0 ? 0 : v) * pow17[coe[y][x]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid setHash(ll h) {\n\t\tint k = 0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (getTile(x, y) != 0) {\n\t\t\t\t\tint v = h%17; if (v == 0) v = --k;\n\t\t\t\t\tsetTile(x, y, v);\n\t\t\t\t\th /= 17;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint getH() {\n\t\tint res = 0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tint v = getTile(x, y);\n\t\t\t\tif (v > 0) {\n\t\t\t\t\tint gx = (v-1)%W, gy = (v-1)/W;\n\t\t\t\t\tres += abs(gx-x) + abs(gy-y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tint getHoles() {\n\t\treturn holes;\n\t}\n\tll getGHash() {\n\t\treturn gHash;\n\t}\n};\n\nstruct Node {\n\tll hash;\n\tint step, h;\n};\nbool operator >(const Node& n1, const Node& n2) {\n\treturn n1.h > n2.h;\n}\n\nint main() {\n\tInit();\n\n//\tint W, H; cin >> W >> H;\n\tint W = 3, H = 3;\n\tPuzzle puzzle(W, H);\n\tfor (int y = 0; y < H; ++y) {\n\t\tfor (int x = 0; x < W; ++x) {\n\t\t\tint v; cin >> v;\n\t\t\tif (v == 0) v = -1;\n\t\t\tpuzzle.setTile(x, y, v);\n\t\t}\n\t}\n\tpuzzle.initCoe();\n\tpuzzle.initHash();\n\n\tint s = 0;\n\n\tset<ll> gone;\n\tpriority_queue<Node, vector<Node>, greater<Node> > Q; Q.push((Node){puzzle.getHash(), 0, puzzle.getH()});\n\twhile ( !Q.empty() ) {\n\t\tNode node = Q.top(); Q.pop();\n\t\tll hash = node.hash;\n\t\tint step = node.step;\n\n\t\tif (step > s) {\n//\t\t\ts = step;\n//\t\t\tcout << s << endl;\n\t\t}\n\n\t\tif (gone.count(hash)) continue;\n\t\tgone.insert(hash);\n\n\t\tif (puzzle.getGHash() == hash) {\n\t\t\tcout << step << endl;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tpuzzle.setHash(hash);\n\t\t\tpuzzle.move(i);\n\t\t\tll h = puzzle.getHash();\n\t\t\tif (gone.count(h) == 0) {\n\t\t\t\tQ.push((Node){h, step+1, step*puzzle.getHoles()+puzzle.getH()});\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <queue>\nusing namespace std;\nconst int N = 3;\nconst int N2 = 9;\nconst int x[4] = {0, 0, 1, -1};\nconst int y[4] = {-1, 1, 0, 0};\nconst char ch[4] = {'l', 'r', 'd', 'u'};\n\nclass node{\npublic:\n\tint f[N2];\n\tint space;\n\tstring str;\n\tbool operator< (const node& n) const\n\t{\n\t\tfor (int i = 0; i < N2; ++i)\n\t\t{\n\t\t\tif (n.f[i] == f[i])\n\t\t\t\tcontinue;\n\t\t\treturn f[i] > n.f[i];\n\t\t}\n\t\treturn false;\n\t} \n};\n\nbool Is_Return(const node& n)\n{\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tif (n.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstring bfs(node& n)\n{\n\tqueue<node> Q;\n\tmap<node, bool> ans;\n\tQ.push(n);\n\tans[n] = true;\n\twhile (!Q.empty())\n\t{\n\t\tnode u = Q.front();\n\t\tQ.pop();\n\t\tif (Is_Return(u))\n\t\t\treturn u.str;\n\t\tint tx = u.space / N;\n\t\tint ty = u.space % N;\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint sx = tx + x[i];\n\t\t\tint sy = ty + y[i];\n\t\t\tif (sx < 0 || sy < 0 || sx >= N || sy >= N)\n\t\t\t\tcontinue;\n\t\t\tnode v = u;\n\t\t\tswap(v.f[v.space], v.f[sx * N + sy]);\n\t\t\tv.space = sx * N + sy;\n\t\t\tif (!ans[v])\n\t\t\t{\n\t\t\t\tans[v] = true;\n\t\t\t\tv.str += ch[i];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main()\n{\n\tnode n;\n\tfor (int i = 0; i < N2; ++i)\n\t{  \n\t\tcin >> n.f[i];\n\t\tif (n.f[i] == 0)\n\t\t{\n\t\t\tn.space = i;\n\t\t\tn.f[i] = N2;\n\t\t}\n\t}\n\tstring s = bfs(n);\n\tcout << s.length() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n\nusing namespace std;\n\nint checkTable[362880];\n\nvoid setNUM(int table[3][3], long long x){\n\tint S = 100000000;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int k=0;k<3;k++){\n\t\t\ttable[i][k] = x/S;\n\t\t\tx = x%S;\n\t\t\tS /= 10;\n\t\t}\n\t}\n}\n\nint getNUM(int x){\n\tswitch(x){\n\tcase 0:return 1;\n\tcase 1:return 1;\n\tcase 2:return 2;\n\tcase 3:return 6;\n\tcase 4:return 24;\n\tcase 5:return 120;\n\tcase 6:return 720;\n\tcase 7:return 5040;\n\tcase 8:return 40320;\n\t}\n\treturn -1;\n}\n\nlong long makeLong(int Table[3][3]){\n\treturn 100000000*Table[0][0]+10000000*Table[0][1]+1000000*Table[0][2]+\n            100000*Table[1][0]+10000*Table[1][1]+1000*Table[1][2]+ 100*Table[2][0]+\n            10*Table[2][1]+Table[2][2];\n}\n\nint translateORDER(int Table[3][3]){\n\tlong long x = makeLong(Table);\n\tint checkTable[9] = {0};\n\tlong long S = 100000000;\n\tint ret = 0,small_num_appear_count;\n\tfor(int i=8; i >= 0; i--){\n\t\tsmall_num_appear_count=0;\n\t\tfor(int k = 0; k < (x/S);k++){\n\t\t\tif(checkTable[k] == 1)small_num_appear_count++;\n\t\t}\n\t\tret += ((x/S)-small_num_appear_count)*getNUM(i);\n\t\tcheckTable[(x/S)]=1;\n\t\tx %= S;\n\t\tS /= 10;\n\t}\n\n\treturn ret;\n}\n\n\nint calcDiffSum(int table[3][3]){\n\tint sum = 0;\n\tfor(int row=0;row<3;row++){\n\t\tfor(int col=0;col<3;col++){\n\t\t\tif(table[row][col] != 0){\n\t\t\t\tsum += abs((table[row][col]-1)/3-row) + abs((table[row][col]-1)%3-col);\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\n\nint zeroLoc(int table[3][3]){\n\tint zero_loc;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int k=0;k<3;k++){\n\t\t\tif(table[i][k]==0){\n\t\t\t\tzero_loc=10*i+k;\n\t\t\t}\n\t\t}\n\t}\n\treturn zero_loc;\n}\n\nstruct Info{\n\tInfo(){data = count = 0;}\n\tInfo(long long arg_data,int arg_count){\n\t\tdata = arg_data;\n\t\tcount = arg_count;\n\t}\n\tlong long data;\n\tint count;\n};\n\nclass LongQ{\npublic:\n\tLongQ(){\n\t\tQ = new Info[362880];\n\t\thead = tail = num_of_data=0;\n\t}\n\n\tvoid enqueue(long long arg_data,int arg_count){\n\t\tQ[tail].count = arg_count;\n\t\tQ[tail].data = arg_data;\n\t\tnum_of_data++;\n\t\ttail = (tail+1)%362880;\n\t}\n\n\tInfo dequeue(){\n\t\tInfo ret = Q[head];\n\t\thead = (head+1)%362880;\n\t\tnum_of_data--;\n\t\treturn ret;\n\t}\n\n\tbool isEmpty(){\n\t\treturn num_of_data == 0;\n\t}\n\nprivate:\n\tInfo* Q;\n\tint head,tail,num_of_data;\n};\n\nLongQ func(LongQ queue,int table[3][3],Info tmpInfo){\n\tif(checkTable[translateORDER(table)] == -1){\n\t\tcheckTable[translateORDER(table)]=tmpInfo.count;\n\t\tqueue.enqueue(makeLong(table),tmpInfo.count+1);\n\t}\n\treturn queue;\n}\n\nint main(){\n\n\tfor(int i = 0; i < 362880;i++)checkTable[i]=-1;\n\n\tint table[3][3];\n\n\tfor(int i=0;i<3;i++){\n\t\tscanf(\"%d %d %d\",&table[i][0],&table[i][1],&table[i][2]);\n\t}\n\n\tcheckTable[translateORDER(table)]=0;\n\tLongQ queue;\n\n\tqueue.enqueue(makeLong(table),0);\n\n\tInfo tmpInfo;\n\n\twhile(queue.isEmpty()==false){\n\t\ttmpInfo=queue.dequeue();\n\n\t\tint tmpTable[3][3];\n\t\tsetNUM(tmpTable,tmpInfo.data);\n\t\tif(calcDiffSum(tmpTable)==0){\n\t\t\tprintf(\"%d\\n\",tmpInfo.count);\n\t\t\tbreak;\n\t\t}\n\n\t\tint next_table[4][3][3];\n\n\t\tfor(int a=0;a<4;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = tmpTable[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tswitch(zeroLoc(tmpTable)){\n\t\tcase 0: //??????\n\t\t\tswap(next_table[0][0][0],next_table[0][0][1]);\n\t\t\tqueue = func(queue,next_table[0],tmpInfo);\n\n\t\t\tswap(next_table[1][0][0],next_table[1][1][0]);\n\t\t\tqueue = func(queue,next_table[1],tmpInfo);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tswap(next_table[0][0][1],next_table[0][0][0]);\n\t\t\tqueue = func(queue,next_table[0],tmpInfo);\n\n\t\t\tswap(next_table[1][0][1],next_table[1][0][2]);\n\t\t\tqueue = func(queue,next_table[1],tmpInfo);\n\n\t\t\tswap(next_table[2][0][1],next_table[2][1][1]);\n\t\t\tqueue = func(queue,next_table[2],tmpInfo);\n\t\t\tbreak;\n\t\tcase 2:\t//??????\n\t\t\tswap(next_table[0][0][2],next_table[0][0][1]);\n\t\t\tqueue = func(queue,next_table[0],tmpInfo);\n\n\t\t\tswap(next_table[1][0][2],next_table[1][1][2]);\n\t\t\tqueue = func(queue,next_table[1],tmpInfo);\n\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tswap(next_table[0][1][0],next_table[0][0][0]);\n\t\t\tqueue = func(queue,next_table[0],tmpInfo);\n\n\t\t\tswap(next_table[1][1][0],next_table[1][1][1]);\n\t\t\tqueue = func(queue,next_table[1],tmpInfo);\n\n\t\t\tswap(next_table[2][1][0],next_table[2][2][0]);\n\t\t\tqueue = func(queue,next_table[2],tmpInfo);\n\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tswap(next_table[0][1][1],next_table[0][0][1]);\n\t\t\tqueue = func(queue,next_table[0],tmpInfo);\n\n\t\t\tswap(next_table[1][1][1],next_table[1][1][0]);\n\t\t\tqueue = func(queue,next_table[1],tmpInfo);\n\n\t\t\tswap(next_table[2][1][1],next_table[2][1][2]);\n\t\t\tqueue = func(queue,next_table[2],tmpInfo);\n\n\t\t\tswap(next_table[3][1][1],next_table[3][2][1]);\n\t\t\tqueue = func(queue,next_table[3],tmpInfo);\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tswap(next_table[0][1][2],next_table[0][0][2]);\n\t\t\tqueue = func(queue,next_table[0],tmpInfo);\n\n\t\t\tswap(next_table[1][1][2],next_table[1][1][1]);\n\t\t\tqueue = func(queue,next_table[1],tmpInfo);\n\n\t\t\tswap(next_table[2][1][2],next_table[2][2][2]);\n\t\t\tqueue = func(queue,next_table[2],tmpInfo);\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\tswap(next_table[0][2][0],next_table[0][1][0]);\n\t\t\tqueue = func(queue,next_table[0],tmpInfo);\n\n\t\t\tswap(next_table[1][2][0],next_table[1][2][1]);\n\t\t\tqueue = func(queue,next_table[1],tmpInfo);\n\t\t\tbreak;\n\t\tcase 21:\n\t\t\tswap(next_table[0][2][1],next_table[0][2][0]);\n\t\t\tqueue = func(queue,next_table[0],tmpInfo);\n\n\t\t\tswap(next_table[1][2][1],next_table[1][1][1]);\n\t\t\tqueue = func(queue,next_table[1],tmpInfo);\n\n\t\t\tswap(next_table[2][2][1],next_table[2][2][2]);\n\t\t\tqueue = func(queue,next_table[2],tmpInfo);\n\t\t\tbreak;\n\t\tcase 22:\n\t\t\tswap(next_table[0][2][2],next_table[0][1][2]);\n\t\t\tqueue = func(queue,next_table[0],tmpInfo);\n\n\t\t\tswap(next_table[1][2][2],next_table[1][2][1]);\n\t\t\tqueue = func(queue,next_table[1],tmpInfo);\n\t\t\tbreak;\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator<(const Puzzle &p)const {\n\t\tfor (int i = 0; i < N2; i++) {\n\t\t\tif (f[i] == p.f[i])continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4] = { -1,0,1,0 };\nstatic const int dy[4] = { 0,-1,0,1 };\nstatic const char dir[4] = { 'u','l','d','r' };\n\nbool isTarget(Puzzle p) {\n\tfor (int i = 0; i < N2; i++)\n\t\tif (p.f[i] != (i + 1))return false;\n\treturn true;\n}\n\nstring bfs(Puzzle s) {\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isTarget(u))return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space%N;\n\t\tfor (int r = 0; r < 4; r++) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx*N + ty]);\n\t\t\tv.space = tx*N + ty;\n\t\t\tif (!V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main() {\n\tPuzzle in;\n\n\tfor (int i = 0; i < N2; i++) {\n\t\tcin >> in.f[i];\n\t\tif (in.f[i] == 0) {\n\t\t\tin.f[i] == N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define MAX_D 3\n#define MAX_N 9\n#define MAX_C 362880\nint fact1[MAX_N][MAX_N][MAX_N][MAX_N][MAX_N][MAX_N][MAX_N][2];\nvector<int> fact2[MAX_C]; int MAP[MAX_D][MAX_D]; int DP[MAX_C], K;\nvoid FACT() {\n\tint a[MAX_N]; for (int i = 0; i < MAX_N; i++) { a[i] = i; }int cnt = 0;\n\tdo {\n\t\tif (a[MAX_N - 2] < a[MAX_N - 1]) { fact1[a[0]][a[1]][a[2]][a[3]][a[4]][a[5]][a[6]][0] = cnt; }\n\t\tvector<int>vec; for (int i = 0; i < MAX_N; i++) { vec.push_back(a[i]); }fact2[cnt] = vec; cnt++;\n\t} while (next_permutation(a, a + MAX_N));\n}\nint main() {\n\tfor (int i = 0; i < MAX_D; i++) {\n\t\tfor (int j = 0; j < MAX_D; j++) { cin >> MAP[i][j]; }\n\t}FACT(); for (int i = 0; i < MAX_C; i++) { DP[i] = MAX_C; }\n\tif (MAP[2][1] < MAP[2][2]) { K = fact1[MAP[0][0]][MAP[0][1]][MAP[0][2]][MAP[1][0]][MAP[1][1]][MAP[1][2]][MAP[2][0]][0]; }\n\telse { K = fact1[MAP[0][0]][MAP[0][1]][MAP[0][2]][MAP[1][0]][MAP[1][1]][MAP[1][2]][MAP[2][0]][1]; }DP[K] = 0;\n\twhile (DP[0] == MAX_C) {\n\t\tfor (int i = 0; i < MAX_C; i++) {\n\t\t\tif (DP[i] >= MAX_C) { continue; }vector<int>X = fact2[i]; int y[MAX_D][MAX_D], z[MAX_D][MAX_D], cx, cy; int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n\t\t\tfor (int j = 0; j < X.size(); j++) { y[j / 3][j % 3] = X[j]; if (X[j] == 0) { cx = j / 3; cy = j % 3; } }\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tfor (int k = 0; k < MAX_N; k++) { z[k / 3][k % 3] = y[k / 3][k % 3]; }int ex = cx + dx[j], ey = cy + dy[j];\n\t\t\t\tswap(z[cx][cy], z[ex][ey]);\n\t\t\t\tif (z[2][1] < z[2][2]) { K = fact1[z[0][0]][z[0][1]][z[0][2]][z[1][0]][z[1][1]][z[1][2]][z[2][0]][0]; }\n\t\t\t\telse { K = fact1[z[0][0]][z[0][1]][z[0][2]][z[1][0]][z[1][1]][z[1][2]][z[2][0]][1]; }DP[K] = min(DP[K], DP[i] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP[0] << endl; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\nconst ll mod2 = 998244353;\nconst int INF = 1000000005;\nconst long double EPS = 1e-10;\n\nstruct Puzzle {\n  int f[9];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const {\n    rep(i, 9) {\n      if (f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\nconst char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n  rep(i, 9) {\n    if (p.f[i] != i + 1) return false;\n  }\n  return true;\n}\n\nstring bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while (!Q.empty()) {\n    u = Q.front();\n    Q.pop();\n    if (isTarget(u)) return u.path;\n    int sx = u.space / 3;\n    int sy = u.space % 3;\n    rep(r, 4) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if (tx < 0 || ty < 0 || tx >= 3 || ty >= 3) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * 3 + ty]);\n      v.space = tx * 3 + ty;\n      if (!V[v]) {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n}\n\nint main() {\n  Puzzle in;\n\n  rep(i, 9) {\n    cin >> in.f[i];\n    if (in.f[i] == 0) {\n      in.f[i] = 9;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}};\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    if(wrongs + moves >= cutoff)\n        return -1;\n    int zero;\n    REP(i, 9){\n        if(tiles[i] == 0){\n            zero = i;\n            break;\n        }\n    }\n    if(dir[zero][0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-1]);\n    }\n    if(dir[zero][1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-3]);\n    }\n    if(dir[zero][2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+3]);\n    }\n    if(dir[zero][3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+1]);\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n\n    REP(i, 50){\n        move = dfs(0, i);\n        if(move > 0){\n            break;\n        }\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n#define N 3\n#define LIMIT_TIME 180000\ntypedef pair<int, int> P;\n\nstruct State {\n    int g, h;\n    string state;\n    P blank;\n    string path;\n    bool operator<(const State &a) const {\n        return g + h > a.g + a.h;\n    }\n};\n\nint d[5] = {-1, 0, 1, 0, -1};\nstring r[4] = {\"D\", \"R\", \"U\", \"L\"};\nstring ans_str = \"\";\nint ans[N][N], puzzle0[N][N], puzzle1[N][N];\nset<string> s;\npriority_queue<State> next_state;\nstring path;\n\nbool range(int y, int x) {return 0 <= y && y < N && 0 <= x && x < N;}\n\nint h0() {\n    int find = -1;\n    while(next_state.size()) {\n        auto end = chrono::system_clock::now();\n        auto dur = end - start;\n        auto msec = chrono::duration_cast<chrono::milliseconds>(dur).count();\n        if (msec > LIMIT_TIME) break;\n\n        State state = next_state.top();\n        next_state.pop();\n        if (s.count(state.state)) continue; // already search\n        s.insert(state.state); // visited\n\n        P blank = state.blank;\n        rep(i, 4) {\n            int y = d[i] + blank.first, x = d[i + 1] + blank.second; // next blank position\n            if (range(y, x)) { // can be replaced\n                string tmp = state.state; // next state (string)\n                int p = blank.first * N + blank.second, q = y * N + x;\n                if (N < 4) swap(tmp[p], tmp[q]);\n                else swap(tmp[2 * p], tmp[2 * q]), swap(tmp[2 * p + 1], tmp[2 * q + 1]);\n                if (s.count(tmp)) continue; // already search\n\n                if (tmp == ans_str) { // answer\n                    find = state.g + 1;\n                    path = state.path + r[i];\n                    break;\n                }\n\n                next_state.push(State{state.g + 1, 0, tmp, P(y, x), state.path + r[i]});\n            }\n        }\n        if (find != -1) break; // find an answer\n    }\n    return find;\n}\n\nint main(){\n    rep(i, N)rep(j, N) cin >> puzzle0[i][j];\n\n    string state = \"\";\n    P blank;\n    int manhattan = 0, wrong_place = 0;\n    rep(i, N)rep(j, N) {\n        // cout << puzzle0[i][j] << ((j % N == N - 1) ? \"\\n\" : \"\\t\");\n\n        if (N * N - 1 > 9 && puzzle0[i][j] < 10) state += \"0\";\n        state += to_string(puzzle0[i][j]);\n        if (N * N - 1 > 9 && ans[i][j] < 10) ans_str += \"0\";\n        ans_str += to_string(ans[i][j]);\n\n        if(puzzle0[i][j] == 0) blank = P(i, j);\n        else {\n            int num = puzzle0[i][j] - 1;\n            manhattan += (abs(num / N - i) + abs(num % N - j));\n            if (puzzle0[i][j] != ans[i][j]) wrong_place++;\n        }\n    }\n\n    if (manhattan == 0) { // the answer\n        cout << 0 << endl;\n    } else {\n        s.clear();\n        next_state = priority_queue<State>();\n        next_state.push(State{0, manhattan, state, blank, \"\"});\n        int steps = h0();\n        cout << steps << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n\nusing namespace std;\n\nint checkTable[362880];\n\nvoid setNUM(int table[3][3], long long x){\n    int S = 100000000;\n    for(int i=0;i<3;i++){\n        for(int k=0;k<3;k++){\n            table[i][k] = x/S;\n            x = x%S;\n            S /= 10;\n        }\n    }\n}\n\nint getNUM(int x){\n    switch(x){\n    case 0:return 1;\n    case 1:return 1;\n    case 2:return 2;\n    case 3:return 6;\n    case 4:return 24;\n    case 5:return 120;\n    case 6:return 720;\n    case 7:return 5040;\n    case 8:return 40320;\n    }\n    return -1;\n}\n\nlong long makeLong(int Table[3][3]){\n    return 100000000*Table[0][0]+10000000*Table[0][1]+1000000*Table[0][2]+\n            100000*Table[1][0]+10000*Table[1][1]+1000*Table[1][2]+ 100*Table[2][0]+\n            10*Table[2][1]+Table[2][2];\n}\n\nint translateORDER(int Table[3][3]){\n    long long x = makeLong(Table);\n    int checkTable[9] = {0};\n    long long S = 100000000;\n    int ret = 0,small_num_appear_count;\n    for(int i=8; i >= 0; i--){\n        small_num_appear_count=0;\n        for(int k = 0; k < (x/S);k++){\n            if(checkTable[k] == 1)small_num_appear_count++;\n        }\n        ret += ((x/S)-small_num_appear_count)*getNUM(i);\n        checkTable[(x/S)]=1;\n        x %= S;\n        S /= 10;\n    }\n\n    return ret;\n}\n\n\nint calcDiffSum(int table[3][3]){\n    int sum = 0;\n    for(int row=0;row<3;row++){\n        for(int col=0;col<3;col++){\n            if(table[row][col] != 0){\n                sum += abs((table[row][col]-1)/3-row) + abs((table[row][col]-1)%3-col);\n            }\n        }\n    }\n    return sum;\n}\n\nint zeroLoc(int table[3][3]){\n    int zero_loc;\n    for(int i=0;i<3;i++){\n        for(int k=0;k<3;k++){\n            if(table[i][k]==0){\n                zero_loc=10*i+k;\n            }\n        }\n    }\n    return zero_loc;\n}\n\nstruct Info{\n    Info(){ zero_loc=data = count = 0;}\n    Info(long long arg_data,int arg_count,short arg_loc){\n        data = arg_data;\n        count = arg_count;\n        zero_loc = arg_loc;\n    }\n    long long data;\n    int count;\n    short zero_loc;\n};\n\nclass LongQ{\npublic:\n    LongQ(){\n        Q = new Info[362880];\n        head = tail = num_of_data=0;\n    }\n\n    void enqueue(long long arg_data,int arg_count,short arg_loc){\n        Q[tail].count = arg_count;\n        Q[tail].data = arg_data;\n        Q[tail].zero_loc = arg_loc;\n        num_of_data++;\n        tail = (tail+1)%362880;\n    }\n\n    Info dequeue(){\n        Info ret = Q[head];\n        head = (head+1)%362880;\n        num_of_data--;\n        return ret;\n    }\n\n    bool isEmpty(){\n        return num_of_data == 0;\n    }\n\nprivate:\n    Info* Q;\n    int head,tail,num_of_data;\n};\n\nLongQ func(LongQ queue,int table[3][3],Info tmpInfo,short zero_loc){\n    if(checkTable[translateORDER(table)] == -1){\n        checkTable[translateORDER(table)]=tmpInfo.count;\n        queue.enqueue(makeLong(table),tmpInfo.count+1,zero_loc);\n    }\n    return queue;\n}\n\nint main(){\n\n    for(int i = 0; i < 362880;i++)checkTable[i]=-1;\n\n    int table[3][3];\n\n    for(int i=0;i<3;i++){\n        scanf(\"%d %d %d\",&table[i][0],&table[i][1],&table[i][2]);\n    }\n\n    checkTable[translateORDER(table)]=0;\n    LongQ queue;\n\n    queue.enqueue(makeLong(table),0,zeroLoc(table));\n\n    Info tmpInfo;\n\n    while(queue.isEmpty()==false){\n        tmpInfo=queue.dequeue();\n\n        int tmpTable[3][3];\n        setNUM(tmpTable,tmpInfo.data);\n        if(calcDiffSum(tmpTable)==0){\n            printf(\"%d\\n\",tmpInfo.count);\n            break;\n        }\n\n        int next_table[4][3][3];\n\n        for(int a=0;a<4;a++){\n            for(int b=0;b<3;b++){\n                for(int c=0;c<3;c++){\n                    next_table[a][b][c] = tmpTable[b][c];\n                }\n            }\n        }\n\n        switch(tmpInfo.zero_loc){\n        case 0:\n            swap(next_table[0][0][0],next_table[0][0][1]);\n            queue = func(queue,next_table[0],tmpInfo,1);\n\n            swap(next_table[1][0][0],next_table[1][1][0]);\n            queue = func(queue,next_table[1],tmpInfo,10);\n            break;\n        case 1:\n            swap(next_table[0][0][1],next_table[0][0][0]);\n            queue = func(queue,next_table[0],tmpInfo,0);\n\n            swap(next_table[1][0][1],next_table[1][0][2]);\n            queue = func(queue,next_table[1],tmpInfo,2);\n\n            swap(next_table[2][0][1],next_table[2][1][1]);\n            queue = func(queue,next_table[2],tmpInfo,11);\n            break;\n        case 2:\n            swap(next_table[0][0][2],next_table[0][0][1]);\n            queue = func(queue,next_table[0],tmpInfo,1);\n\n            swap(next_table[1][0][2],next_table[1][1][2]);\n            queue = func(queue,next_table[1],tmpInfo,12);\n\n            break;\n        case 10:\n            swap(next_table[0][1][0],next_table[0][0][0]);\n            queue = func(queue,next_table[0],tmpInfo,0);\n\n            swap(next_table[1][1][0],next_table[1][1][1]);\n            queue = func(queue,next_table[1],tmpInfo,11);\n\n            swap(next_table[2][1][0],next_table[2][2][0]);\n            queue = func(queue,next_table[2],tmpInfo,20);\n\n            break;\n        case 11:\n            swap(next_table[0][1][1],next_table[0][0][1]);\n            queue = func(queue,next_table[0],tmpInfo,1);\n\n            swap(next_table[1][1][1],next_table[1][1][0]);\n            queue = func(queue,next_table[1],tmpInfo,10);\n\n            swap(next_table[2][1][1],next_table[2][1][2]);\n            queue = func(queue,next_table[2],tmpInfo,12);\n\n            swap(next_table[3][1][1],next_table[3][2][1]);\n            queue = func(queue,next_table[3],tmpInfo,21);\n            break;\n        case 12:\n            swap(next_table[0][1][2],next_table[0][0][2]);\n            queue = func(queue,next_table[0],tmpInfo,2);\n\n            swap(next_table[1][1][2],next_table[1][1][1]);\n            queue = func(queue,next_table[1],tmpInfo,11);\n\n            swap(next_table[2][1][2],next_table[2][2][2]);\n            queue = func(queue,next_table[2],tmpInfo,22);\n            break;\n        case 20:\n            swap(next_table[0][2][0],next_table[0][1][0]);\n            queue = func(queue,next_table[0],tmpInfo,10);\n\n            swap(next_table[1][2][0],next_table[1][2][1]);\n            queue = func(queue,next_table[1],tmpInfo,21);\n            break;\n        case 21:\n            swap(next_table[0][2][1],next_table[0][2][0]);\n            queue = func(queue,next_table[0],tmpInfo,20);\n\n            swap(next_table[1][2][1],next_table[1][1][1]);\n            queue = func(queue,next_table[1],tmpInfo,11);\n\n            swap(next_table[2][2][1],next_table[2][2][2]);\n            queue = func(queue,next_table[2],tmpInfo,22);\n            break;\n        case 22:\n            swap(next_table[0][2][2],next_table[0][1][2]);\n            queue = func(queue,next_table[0],tmpInfo,12);\n\n            swap(next_table[1][2][2],next_table[1][2][1]);\n            queue = func(queue,next_table[1],tmpInfo,21);\n            break;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<iomanip>\n#include<complex>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<list>\n#include<map>\n#include<set>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef stack<int> SI;\ntypedef queue<int> QI;\ntypedef list<int> LI;\ntypedef pair<int,int> PII;\ntypedef long long LL;\n\n#define d(x)  cout<<#x<<\" = \"<<(x)<<endl;\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define EMP empty()\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define REACH(i,c) for(typeof((c).rbegin()) i=(c).rbegin(); i!=(c).rend(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c,n) sort(c,c+n)\n#define VSORT(c) sort((c).begin(),(c).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define DFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define DREP(i,n) DFOR(i,n,0)\n#define INF 1000000000\n#define PI  acos(-1.0)\n////////////////////////////////////////////////\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n\tint f[N2];\n\tint space;\n\tstring path;\n\t\n\tbool operator < (const Puzzle &p)const\n\t{\n\t\tREP(i,N2)\n\t\t{\n\t\t\tif(f[i]==p.f[i])continue;\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool istgt(Puzzle p)\n{\n\tREP(i,N2)\n\t{\n\t\tif(p.f[i]!=(i+1))return false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle s)\n{\n\tqueue<Puzzle> Q;\n\tmap<Puzzle,bool> V;\n\tPuzzle u,v;\n\ts.path=\"\";\n\tQ.push(s);\n\tV[s]=true;\n\t\n\twhile(!Q.empty())\n\t{\n\t\tu=Q.front();Q.pop();\n\t\tif(istgt(u))return u.path;\n\t\tint sx=u.space/N;\n\t\tint sy=u.space%N;\n\t\tREP(r,4)\n\t\t{\n\t\t\tint tx=sx+dx[r];\n\t\t\tint ty=sy+dy[r];\n\t\t\tif(tx<0||ty<0||tx>=N||ty>=N)continue;\n\t\t\tv=u;\n\t\t\tswap(v.f[u.space],v.f[tx*N+ty]);\n\t\t\tv.space=tx*N+ty;\n\t\t\tif(!V[v])\n\t\t\t{\n\t\t\t\tV[v]=true;\n\t\t\t\tv.path+=dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main()\n{\n\tPuzzle in;\n\tREP(i,N2)\n\t{\n\t\tcin>>in.f[i];\n\t\tif(in.f[i]==0)\n\t\t{\n\t\t\tin.f[i]=N2;\n\t\t\tin.space=i;\n\t\t}\n\t}\n\tstring ans=bfs(in);\n\tcout<<ans.size()<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 10010;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> Array;\ntypedef vector<Array> Graph;\ntypedef pair<double, double> pdd;\nconst ull mod = 1000000000 + 7;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\nconst int CODE_MAX = 362880;\nconst int SIZE = 9;\nint visited[CODE_MAX];\n\nint factorial(int n){\n    if(n==1) return 1;\n    return n*factorial(n-1);\n};\n\nstruct Board{\n    int num[SIZE];\n    void print(){\n        for(int i=0;i<SIZE;i++) cout << num[i] << \" \";\n        cout << endl;\n    }\n};\n\nint encode(Board &b){\n    int res = 0;\n    int temp_b[SIZE];\n    for(int i=0;i<SIZE;i++) temp_b[i] = b.num[i];\n    for(int i=0;i<SIZE-1;i++){\n        res += factorial(SIZE-1-i)*temp_b[i];\n        for(int j=i+1;j<SIZE-1;j++){\n            if(temp_b[i]<temp_b[j]) temp_b[j]--;\n        }\n    }\n   return res;\n}\n\nBoard decode(int encoded){\n    Board b;\n    int tmp[SIZE];\n    for(int i=0;i<SIZE-1;i++){\n        int fact = factorial(SIZE-1-i);\n        tmp[i] = encoded/fact;\n        encoded %= fact;\n    }\n    tmp[SIZE-1] = 0;\n    int tmp2[SIZE];\n    bool check[SIZE];\n    for(int i=0;i<SIZE;i++){\n        tmp2[i] = i;\n        check[i] = false;\n    }\n    for(int i=0;i<SIZE;i++){\n        int j=0;\n        while(tmp[i]!=tmp2[j] || check[j]) j++;\n        b.num[i] = j;\n        check[j] = true;\n        while(j<SIZE){\n            tmp2[j]--;\n            j++;\n        }\n    }\n\n    return b;\n}\n\nint get_adjacent(int now, int i){\n    // \"i\" represents the direction of zero movement.0 up, 1 down, 2 left, 3 right\n    Board b = decode(now);\n    int zero=0;\n    while(b.num[zero]!=0) zero++;\n    if(i==0){\n        if(zero<3) return -1;\n        swap(b.num[zero], b.num[zero-3]);\n    }\n    if(i==1){\n        if(zero>5) return -1;\n        swap(b.num[zero], b.num[zero+3]);\n    }\n    if(i==2){\n        if(zero%3<1) return -1;\n        swap(b.num[zero], b.num[zero-1]);\n    }\n    if(i==3){\n        if(zero%3>1) return -1;\n        swap(b.num[zero], b.num[zero+1]);\n    }\n    return encode(b);\n}\n\nint main(){\n    Board b;\n    for (int i=0;i<SIZE;i++){\n        cin >> b.num[i];\n    }\n    for(int i=0;i<CODE_MAX;i++){\n        visited[i] = -1;\n    }\n\n    const int start = encode(b);\n    const int goal = 46233;\n    queue<int> que;\n    que.push(start);\n    visited[start] = 0;\n    while(visited[goal]==-1){\n        int now = que.front();\n        que.pop();\n        for(int i=0;i<4;i++){\n            int adj = get_adjacent(now, i);\n            if(adj==-1 || visited[adj]!=-1) continue;\n            visited[adj] = visited[now]+1;\n            que.push(adj);\n        }\n    }\n    cout << visited[goal] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <cmath>\n#include <set>\n\nusing namespace std;\n\nusing Weight=int;\nusing Encoded=int;\n\nstruct State {\n    Weight hcost, acost;\n    Encoded encoded;\n    State() {}\n    State(Weight h, Weight a, Encoded e): hcost(h), acost(a), encoded(e) {}\n    bool operator>(const State & state2) const {\n        if (hcost+acost != state2.hcost+state2.acost) {\n            return hcost+acost > state2.hcost+state2.acost;\n        } else {\n            return acost > state2.acost;\n        }\n    }\n};\n\nconst Weight INF=1<<29;\n\ntemplate <class T>\nusing lp_queue=priority_queue<T, deque<T>, greater<T>>;\n\nEncoded encode(vector<int> d) {\n    int cur=0;\n    Encoded enc=0;\n    for (size_t i=0; i<d.size()-1; ++i) {\n        cur = d[i];\n        for (size_t j=i+1; j<d.size(); ++j)\n            if (cur < d[j])\n                --d[j];\n\n        (enc += d[i]) *= d.size()-i-1;\n    }\n\n    return enc;\n}\n\nvector<int> decode(Encoded e) {\n    vector<int> d(9);\n    for (size_t i=1; i<=9; ++i) {\n        d[9-i] = e % i;\n        e /= i;\n    }\n\n    for (size_t i=9; i--;)\n        for (size_t j=i+1; j<9; ++j)\n            if (d[i] <= d[j])\n                ++d[j];\n\n    return d;\n}\n\nWeight heucost(Encoded start, Encoded end) {\n    static const vector<int> dend=decode(end);\n    vector<int> dstart=decode(start);\n\n    Weight h=0;\n    for (size_t i=0; i<9; ++i)\n        for (size_t j=0; j<9; ++j)\n            if (dstart[i] == dend[j]) {\n                h += abs(i/3-j/3)+abs(i%3-j%3);\n                break;\n            }\n\n    return h;\n}\n\nvector<pair<Weight, Encoded>> pmoves(Encoded cur) {\n    vector<int> d=decode(cur);\n    size_t i;\n    for (i=0; d[i]; ++i);\n\n    vector<pair<Weight, Encoded>> p;\n    if (i/3 < 2) {\n        swap(d[i], d[i+3]);\n        p.push_back(make_pair(1, encode(d)));\n        swap(d[i], d[i+3]);\n    }\n    if (i/3 > 0) {\n        swap(d[i], d[i-3]);\n        p.push_back(make_pair(1, encode(d)));\n        swap(d[i], d[i-3]);\n    }\n    if (i%3 < 2) {\n        swap(d[i], d[i+1]);\n        p.push_back(make_pair(1, encode(d)));\n        swap(d[i], d[i+1]);\n    }\n    if (i%3 > 0) {\n        swap(d[i], d[i-1]);\n        p.push_back(make_pair(1, encode(d)));\n        swap(d[i], d[i-1]);\n    }\n    return p;\n}\n\nWeight astar(Encoded start, Encoded end) {\n    lp_queue<State> q;\n    q.push(State(heucost(start, end), 0, start));\n\n    Weight opt=INF;\n    set<Encoded> visited;\n    while (!q.empty()) {\n        State p=q.top(); q.pop();\n        Weight cur_cost=p.acost;\n        Encoded cur_state=p.encoded;\n        visited.insert(cur_state);\n\n        if (opt < cur_cost) continue;\n        if (cur_state == end)\n            if (opt > cur_cost)\n                opt = cur_cost;\n\n        vector<pair<Weight, Encoded>> ms=pmoves(cur_state);\n        for (pair<Weight, Encoded> m: ms) {\n            if (visited.count(m.second)) continue;\n\n            q.push(State(heucost(m.second, end), cur_cost+m.first, m.second));\n        }\n    }\n\n    return opt;\n}\n\nint main() {\n    vector<int> d(9);\n    for (size_t i=0; i<9; ++i)\n        scanf(\"%d\", &d[i]);\n\n    Encoded e=encode(d);\n\n    Weight c=astar(e, 46233);\n    printf(\"%d\\n\", c);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 13B.cpp : このファイルには 'main' 関数が含まれています。プログラム実行の開始と終了がそこで行われます。\n//\n\n#include <iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < (const Puzzle& p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i])continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n\n};\n\nstatic const int dx[4] = { -1,0,1,0 };\nstatic const int dy[4] = { 0,-1,0,1 };\nstatic const char dir[4] = { 'u','l','d','r' };\n\nbool isTarget(Puzzle p) {\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != (i + 1))return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle s) {\n\n    queue<Puzzle> Q;\n    map<Puzzle, bool>V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while (!Q.empty()) {\n        u = Q.front(); Q.pop();\n        if (isTarget(u))return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; r++) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N) {\n                continue;\n            }\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if (!V[v]) {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n\n\n\n\n    return \"unsolvable\";\n}\n\nint main()\n{\n    Puzzle in;\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n#include<cassert>\nusing namespace std;\n#define MAX 3\n#define MAX2 9\n\nstruct Puzzle{\n  int f[MAX2];\n  int space;\n  string path;\n\n  bool operator < ( const Puzzle &p ) const{\n    for ( int i = 0; i < MAX2; i++ ){\n      if ( f[i] == p.f[i] ) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\nchar dir[4] = {'u', 'l', 'd', 'r'};\n\nbool trush(Puzzle);\nstring bfs(Puzzle);\n\nint main(){\n  Puzzle in;\n  int i;\n  for (i=0;i<MAX2;i++){\n    cin >> in.f[i];\n    if ( in.f[i] == 0 ) {\n      in.f[i] = MAX2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\nbool trush(Puzzle p){\n  for ( int i = 0; i < MAX2; i++ )\n    if ( p.f[i] != (i + 1) ) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  int sx,sy,r,tx,ty;\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n  \n  while( !Q.empty() ){\n    u = Q.front(); Q.pop();\n    if ( trush(u) ) return u.path;\n    sx = u.space/MAX;\n    sy = u.space%MAX;\n    for ( r = 0; r < 4; r++ ){\n      tx = sx + dx[r];\n      ty = sy + dy[r];\n      if ( tx < 0 || ty < 0 || tx >= MAX || ty >= MAX ) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx*MAX+ty]);\n      v.space = tx*MAX+ty;\n      if ( !V[v] ){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<memory>\n#include<functional>\n\n#define rep(i,n) REP(i,0,n)\n#define REP(i,a,n) for(int i = a; i < (int)n; i++)\n\nusing namespace std;\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nstruct Puzzle{\n  int field[9];\n  int space;\n  int turn;\n\n\n  bool operator < (const Puzzle& a) const{\n    rep(i,9){\n      if(a.field[i] == field[i]) continue;\n      return field[i] > a.field[i];\n  }\n    return false;\n  }\n};\n\nbool check(Puzzle p){\n  rep(i,9){\n    if(p.field[i] != i+1) return false;\n  }\n  return true;\n}\n\nint solve(Puzzle in){\n  queue<Puzzle> q;\n  map<Puzzle, bool> mp;\n\n  q.push(in);\n  mp[in] = true;\n\n  while(!q.empty()){\n    Puzzle p = q.front(); q.pop();\n    if(check(p)) return p.turn;\n    int x = p.space % 3;\n    int y = p.space / 3;\n    rep(i, 4){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(nx < 0 || 2 < nx || ny < 0 || 2 < ny) continue;\n      Puzzle tmp = p;\n      swap(tmp.field[p.space], tmp.field[3 * ny + nx]);\n      tmp.space = 3 * ny + nx;\n      if(mp[tmp] == false){\n    mp[tmp] = true;\n    tmp.turn++;\n    q.push(tmp);\n      }\n    }\n  }\n  return -1;\n}\n\n\n\nsigned main(){\n  Puzzle in;\n\n  rep(i,9){\n    cin >> in.field[i];\n    if(in.field[i] == 0){\n      in.field[i] = 9;\n      in.space = i;\n    }\n  }\n\n  in.turn = 0;\n  cout << solve(in) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <map>\n#define N 3\n#define N2 9\n#define ANS \"123456780\"\n\nusing namespace std;\n\n// 上、左、右、下\nconst int dx[] = {-1, 0, 0, 1};\nconst int dy[] = {0, -1, 1, 0};\nstruct Puzzle {\n  string f;\n  int space;\n  int step;\n};\n\nvoid bfs (Puzzle p) {\n  Puzzle cur;\n  queue<Puzzle> Q;\n  map<string, bool> M;\n\n  Q.push(p);\n\n  while (Q.size()) {\n    cur = Q.front(); Q.pop();\n    if (cur.f == ANS) {\n      cout << cur.step << endl;\n      break;\n    }\n    int sx = cur.space / N;\n    int sy = cur.space % N;\n    for (int r = 0; r < 4; r++) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      Puzzle next;\n      next.f = cur.f;\n      swap(next.f[cur.space], next.f[tx * N + ty]);\n      next.space = tx * N + ty;\n      if (!M[next.f]) {\n        M[next.f] = true;\n        next.step = cur.step + 1;\n        Q.push(next);\n      }\n    }\n  }\n}\n\nint main () {\n  Puzzle p;\n  char c;\n  \n  p.step = 0;\n  \n  for (int i = 0; i < N2; i++) {\n    cin >> c;\n    p.f += c;\n    if (c == '0') {\n      p.space = i;\n    }\n  }\n\n  bfs(p);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<iomanip>\n#include<complex>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<list>\n#include<map>\n#include<set>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef stack<int> SI;\ntypedef queue<int> QI;\ntypedef list<int> LI;\ntypedef pair<int,int> PII;\ntypedef long long LL;\n\n#define d(x)  cout<<#x<<\" = \"<<(x)<<endl;\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define EMP empty()\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define REACH(i,c) for(typeof((c).rbegin()) i=(c).rbegin(); i!=(c).rend(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c,n) sort(c,c+n)\n#define VSORT(c) sort((c).begin(),(c).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define DFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define DREP(i,n) DFOR(i,n,0)\n#define INF 1000000000\n#define PI  acos(-1.0)\n////////////////////////////////////////////////\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n\tint f[N2];\n\tint space;\n\tstring path;\n\t\n\tbool operator < (const Puzzle &p)const\n\t{\n\t\tREP(i,N2)\n\t\t{\n\t\t\tif(f[i]==p.f[i])continue;\n\t\t\treturn f[i]>p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool istgt(Puzzle p)\n{\n\tREP(i,N2)\n\t{\n\t\tif(p.f[i]!=(i+1))return false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle s)\n{\n\tqueue<Puzzle> Q;\n\tmap<Puzzle,bool> V;\n\tPuzzle u,v;\n\ts.path=\"\";\n\tQ.push(s);\n\tV[s]=true;\n\t\n\twhile(!Q.empty())\n\t{\n\t\tu=Q.front();Q.pop();\n\t\tif(istgt(u))return u.path;\n\t\tint sx=u.space/N;\n\t\tint sy=u.space%N;\n\t\tREP(r,4)\n\t\t{\n\t\t\tint tx=sx+dx[r];\n\t\t\tint ty=sy+dy[r];\n\t\t\tif(tx<0||ty<0||tx>=N||ty>=N)continue;\n\t\t\tv=u;\n\t\t\tswap(v.f[u.space],v.f[tx*N+ty]);\n\t\t\tv.space=tx*N+ty;\n\t\t\tif(!V[v])\n\t\t\t{\n\t\t\t\tV[v]=true;\n\t\t\t\tv.path+=dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main()\n{\n\tPuzzle in;\n\tREP(i,N2)\n\t{\n\t\tcin>>in.f[i];\n\t\tif(in.f[i]==0)\n\t\t{\n\t\t\tin.f[i]=N2;\n\t\t\tin.space=i;\n\t\t}\n\t}\n\tstring ans=bfs(in);\n\tcout<<ans.size()<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iterator>\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <numeric>\n#include <cstdio>\n#include <bitset>\n#include <map>\n#include <string>\n#include <valarray>\n#include <queue>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> Coordinate;\n\nclass PuzzleStatus\n{\n    // enum Direction {up, down, left, right};    \n\n    public:\n    friend ostream & operator<<(ostream & os, PuzzleStatus & ps);\n    friend istream & operator>>(istream & is, PuzzleStatus & ps);\n    bool operator<(const PuzzleStatus &) const;\n\n    bool move_up();\n    bool move_down();\n    bool move_left();\n    bool move_right();\n\n    static const vector< vector<int> > & get_target();\n    static void set_target();\n    const vector< vector<int> > & get_position() const;\n    // PuzzleStatus() {distance = 0;}\n\n    private:\n        vector< vector<int> > position;\n        Coordinate space_pos;\n        int distance = 0;   //the fewest steps from the original status\n   \n        //require c++11\n        // static const vector< vector<int> > target;\n\n        static vector< vector<int> > target;\n};\n\n\nbool move(PuzzleStatus & u, string direction);\n\n//require c++11\n// const vector< vector<int> > PuzzleStatus::target = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};\n\nvector< vector<int> > PuzzleStatus::target;\n\n// not used\n// bool is_target(PuzzleStatus);\n// vector<PuzzleStatus (PuzzleStatus::*) ()> funcs = \n// {PuzzleStatus::move_up, PuzzleStatus::move_down, PuzzleStatus::move_left, PuzzleStatus::move_right};\n// int a[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};\n// PuzzleStatus move(PuzzleStatus, PuzzleStatus (PuzzleStatus::*) (PuzzleStatus));\n\n//the size of puzzle\nconst int SIZE = 3;\n\nint main()\n{\n    PuzzleStatus::set_target();\n    \n    PuzzleStatus origin;\n\n    cin >> origin;\n\n    queue<PuzzleStatus> Q;\n    map<PuzzleStatus, bool> visited;\n    \n    Q.push(origin);\n    visited[origin] = true;\n\n    //require c++11\n    // vector<string> directions = {\"up\", \"down\", \"left\", \"right\"};\n    \n    string d[] = {\"up\", \"down\", \"left\", \"right\"};\n    vector<string> directions(d, d+4);\n\n    while (!Q.empty())\n    {\n        if (Q.front().get_position() == PuzzleStatus::get_target())\n            break;\n\n        for (int i = 0; i < 4; i++)\n        {\n            PuzzleStatus temp = Q.front();\n            if (move(temp, directions[i]) && !visited[temp])\n            {\n                visited[temp] = true; \n                Q.push(temp);                \n            }\n        }\n        Q.pop();\n    }\n\n    cout << Q.front();\n}\n\n\nostream & operator<<(ostream & os, PuzzleStatus & ps)\n{\n    os << ps.distance << endl;\n    return os;\n}\n\nistream & operator>>(istream & is, PuzzleStatus & ps)\n{\n    ps.position.resize(SIZE);\n    for (int i = 0; i < SIZE; i++)\n    {\n        ps.position[i].resize(SIZE);\n        for (int j = 0; j < SIZE; j++)\n        {\n            is >> ps.position[i][j];\n            if (ps.position[i][j] == 0)\n            {\n                ps.space_pos.first = i; \n                ps.space_pos.second = j; \n            }\n                           \n        }\n\n    }\n    return is;\n}\n\n\nbool PuzzleStatus::move_up()\n{\n    int & i = space_pos.first, & j = space_pos.second;\n\n    if (i > 0)\n    {\n        swap(position[i-1][j], position[i][j]);\n        i--;\n        distance++;\n        return true;     \n    }  \n    return false;   \n}\n\nbool PuzzleStatus::move_down()\n{\n    int & i = space_pos.first, & j = space_pos.second;\n\n    if (i < SIZE-1)\n    {\n        swap(position[i+1][j], position[i][j]);\n        i++;\n        distance++;   \n        return true;   \n    }  \n    return false;   \n}\n\nbool PuzzleStatus::move_left()\n{\n    int & i = space_pos.first, & j = space_pos.second;\n\n    if (j > 0)\n    {\n        swap(position[i][j-1], position[i][j]);\n        j--;\n        distance++;\n        return true;     \n    }  \n    return false;      \n}\n\nbool PuzzleStatus::move_right()\n{\n    int & i = space_pos.first, & j = space_pos.second;\n\n    if (j < SIZE-1)\n    {\n        swap(position[i][j+1], position[i][j]);\n        j++;\n        distance++; \n        return true;    \n    }  \n    return false;   \n}\n\n\n// PuzzleStatus move(PuzzleStatus u, PuzzleStatus (PuzzleStatus::*func) ())\n// {\n//     return (u.*func)();\n// }\n\nbool move(PuzzleStatus & u, string direction)\n{\n    if (direction == \"up\")\n        return u.move_up();\n    else if (direction == \"down\")\n        return u.move_down();\n    else if (direction == \"left\")\n        return u.move_left();\n    else if(direction == \"right\")\n        return u.move_right();\n    else\n        return false;\n}\n\n\nconst vector< vector<int> > & PuzzleStatus::get_target()\n{\n    return target;\n}\n\nconst vector< vector<int> > & PuzzleStatus::get_position() const\n{\n    return position;\n}\n\n\nbool PuzzleStatus::operator<(const PuzzleStatus & ps) const\n{\n    return position < ps.position;\n}\n\n\nvoid PuzzleStatus::set_target()\n{\n    target.resize(SIZE);\n    for (int i = 0; i < SIZE; i++)\n    {\n        target[i].resize(SIZE);\n        for (int j = 0; j < SIZE; j++)\n            target[i][j] = i*SIZE+j+1;\n    }\n    target[SIZE-1][SIZE-1] = 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\n//?§???¨??????\nstatic const int dx[4]={0,-1,0,1};\nstatic const int dy[4]={1,0,-1,0};\nstatic const char dir[4]={'u','l','d','r'};\n\n//Puzzle{????????????????????????}\nstruct Puzzle\n{ \n\tint f[N2], space;\n\tstring path;\n\t\n\tbool operator < (const Puzzle &p) const\n\t{\n\t\tfor(int i=0;i<N2;i++)\n\t\t{\n\t\t\tif(f[i]==p.f[i])continue;\n\t\t\treturn f[i]<p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nbool isTarget(Puzzle p)\n{\n\tfor(int i=0;i<N2;i++)\n\t\tif(p.f[i]!=(i+1))return false;\n\treturn true;\n}\n\nstring bfs(Puzzle s)\n{\n\tqueue<Puzzle>Q;\n\tmap<Puzzle,bool> V;\n\tPuzzle u,v;\n\ts.path=\"\";\n\tQ.push(s);\n\tV[s]=true;\n\t\n\twhile(!Q.empty())\n\t{\n\t\tu=Q.front();Q.pop();\n\t\tif(isTarget(u))return u.path;\n\t\tint sx=u.space/N;\n\t\tint sy=u.space%N;\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint tx=sx+dx[r];\n\t\t\tint ty=sy+dy[r];\n\t\t\tif(tx<0||ty<0||tx>=N||ty>=N)continue;\n\t\t\tv=u;\n\t\t\tswap(v.f[u.space],v.f[tx*N+ty]);\n\t\t\tv.space=tx*N+ty;\n\t\t\tif(!V[v])\n\t\t\t{\n\t\t\t\tV[v]=true;\n\t\t\t\tv.path+=dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolveable\";\n}\n\nint main()\n{\n\tPuzzle in;\n\t\n\tfor(int i=0;i<N2;i++)\n\t{\n\t\tcin>>in.f[i];\n\t\tif(in.f[i]==0)\n\t\t{\n\t\t\tin.f[i]=N2;\n\t\t\tin.space=i;\n\t\t}\n\t}\n\tstring ans=bfs(in);\n\tcout<<ans.size()<<endl;\n\t//cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <map>\n#include <memory>\n#include <set>\n#include <vector>\n#include <deque>\n#include <list>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\nstruct state\n{\n  vector<vector<int>> bd;\n  int cnt;\n};\n\nclass EightPuzzle\n{\npublic:\n  queue<state> q;\n  vector<vector<int>> goal;\n  vector<int> dr,dc;\n  EightPuzzle(){}\n  EightPuzzle( state st ){ q.push(st); goal = {{1,2,3},{4,5,6},{7,8,0}}; dr = {1, -1, 0, 0}; dc = {0, 0, 1, -1}; }\n  int solve();\n  void find0( vector<vector<int>> &b, int &x, int &y );\n};\n\nvoid EightPuzzle::find0( vector<vector<int>> &b, int &r, int &c )\n{\n  for ( r = 0; r < 3; ++r )\n    for ( c = 0; c < 3; ++c )\n      if ( b[r][c] == 0 ) return;\n}\n\nint EightPuzzle::solve()\n{\n  while ( ! q.empty() )\n    {\n      state st = q.front();\n      \n      if ( st.bd == goal )\n        {\n          cout << st.cnt << endl;\n          return 0;\n        }\n\n      int r, c;\n      find0( st.bd, r, c );\n\n      for ( auto i = 0; i < 4; ++i )\n        {\n          int nr = r + dr[i];\n          int nc = c + dc[i];\n          if ( nr < 0 || nr > 2 || nc < 0 || nc > 2 ) continue;\n\n          state nst = st;\n          nst.bd[r][c] = st.bd[nr][nc];\n          nst.bd[nr][nc] = 0;\n          nst.cnt = st.cnt + 1;\n          q.push(nst);\n        }\n      q.pop();\n    }\n  \n  return 0;\n}\n\nint main()\n{\n  state st;\n  st.cnt = 0;\n  \n  for ( auto i = 0; i < 3; ++i )\n    {\n      vector<int> vl;\n      for ( auto j = 0; j < 3; ++j )\n        {\n          int v;\n          cin >> v;\n          vl.push_back(v);\n        }\n      st.bd.push_back(vl);\n    }\n\n  EightPuzzle ep( st );\n\n  ep.solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\n#define N 3\n#define MAXQ 3628800\n\nint bfs(int [N][N]);\nint check_save (int [N][N]);\n//hash\nlong long h1(long long);\nlong long  h2(long long);\n\n#define RIGHT -1\n#define LEFT -2\n#define ABOVE -3\n#define UNDER -4\n\nint Z[362880][N][N];\nint num=0;\n\nint hash[MAXQ];\n\nint main(){\n  int i,j;\n  int depth;\n  int P[N][N];\n  \n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&P[i][j]);\n    }\n  }\n  \n  for(i=0;i<MAXQ;i++) hash[i] = 0;\n\n  /* for(i=0;i<N;i++){\n     for(j=0;j<N;j++){\n     if(j) printf(\" \");\n     printf(\"%d\",P[i][j]);\n     }\n     printf(\"\\n\");\n\n     }\n  */\n\n  depth = bfs(P);\n\n  printf(\"%d\\n\",depth);\n  \n  return 0;\n}\nint Q[MAXQ][N][N];\nint Qd[MAXQ];\n\nint bfs(int A[N][N]){\n\n  int head=0,tail=0;\n  int depth;\n  int i,j,puzzle[N][N],tp[N][N];\n  int x,y;\n  int temp;\n  int direction = 0;\n  //int depth_limit = 32;\n  //int min = depth_limit;\n  int result;\n\n\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      Q[tail][i][j] = A[i][j];\n      Qd[tail]=0;\n    }\n  }\n  tail++;\n  //if(tail >= MAXQ) tail = 0;\n  \n\n  while(head != tail){\n    //printf(\"%d:%d\\n\",head,tail);\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++){\n        puzzle[i][j] = Q[head][i][j];\n        if(puzzle[i][j] == 0) {\n          x = i;\n          y = j;\n        }    \n      }\n    }\n    depth=Qd[head];\n    head++;\n    if(head >= MAXQ) head = 0;\n  \n    //finish\n    if(puzzle[0][0] == 1 &&\n       puzzle[0][1] == 2 &&\n       puzzle[0][2] == 3 &&\n       puzzle[1][0] == 4 &&\n       puzzle[1][1] == 5 &&\n       puzzle[1][2] == 6 &&\n       puzzle[2][0] == 7 &&\n       puzzle[2][1] == 8 && puzzle[2][2] == 0) return depth;\n\n    /*\n      result = check_save(puzzle);\n\n      if(result == 1) continue;\n    */\n  \n\n    //0の位置は(x,y)\n\n    //0 can swap above\n    if(y != 0){\n      for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n          tp[i][j] = puzzle[i][j];\n        }\n      }\n      //swaping pazzle\n      temp = tp[x][y-1];\n      tp[x][y-1] = tp[x][y];\n      tp[x][y] = temp;\n\n      result = check_save(tp);\n\n      if(result == 0) {\n\n\tfor(i=0;i<N;i++){\n\t  for(j=0;j<N;j++){       \n\t    Q[tail][i][j] = tp[i][j];     \n\t  }     \n\t}\n\tQd[tail] = depth + 1;\n\ttail++;\n\tif(tail >= MAXQ) tail = 0;\n      }\n    }\n\n    \n\n    //0 can swap under\n    if(y != 2) {\n      for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n          tp[i][j] = puzzle[i][j];\n        }\n      }\n\n      temp = tp[x][y+1];\n      tp[x][y+1] = tp[x][y];\n      tp[x][y] = temp;\n\n      result = check_save(tp);\n\n      if(result == 0) {\n\n\tfor(i=0;i<N;i++){\n\t  for(j=0;j<N;j++){       \n\t    Q[tail][i][j] = tp[i][j];     \n\t  }     \n\t}\n\tQd[tail] = depth + 1;\n\ttail++;\n\tif(tail >= MAXQ) tail = 0;\n      }\n\n    }\n\n    //0 can swap right\n    if(x != 2){\n      for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n          tp[i][j] = puzzle[i][j];\n        }\n      }\n\n      temp = tp[x+1][y];\n      tp[x+1][y] = tp[x][y];\n      tp[x][y] = temp;\n\n      result = check_save(tp);\n\n      if(result == 0) {\n\n\n      \n\tfor(i=0;i<N;i++){\n\t  for(j=0;j<N;j++){       \n\t    Q[tail][i][j] = tp[i][j];     \n\t  }     \n\t}\n\tQd[tail] = depth + 1;\n\ttail++;\n\tif(tail >= MAXQ) tail = 0;\n      }\n    }\n\n    //0 can swap left\n    if(x != 0){\n      for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n          tp[i][j] = puzzle[i][j];\n        }\n      }\n\n      temp = tp[x-1][y];\n      tp[x-1][y] = tp[x][y];\n      tp[x][y] = temp;\n\n      result = check_save(tp);\n\n      if(result == 0) {\n\t\n\tfor(i=0;i<N;i++){\n\t  for(j=0;j<N;j++){       \n\t    Q[tail][i][j] = tp[i][j];     \n\t  }     \n\t}\n\tQd[tail] = depth + 1;\n\ttail++;\n\tif(tail >= MAXQ) tail = 0;\n      }\n    }\n  }\n  return -1;\n}\n\n\n\n\n\nint check_save(int A[3][3]){\n  int i,j;\n  int sum=0;\n  int value;\n  \n  //存在すれば １\n  \n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      sum += A[i][j];\n      if(i != 2 || j != 2) sum *=10;\n    }\n  }\n\n  //printf(\"sum = %d\\n\",sum);\n\n\n  i = 0; \n  while(1){\n    \n    value = (h1(sum) + i * h2(sum)) % MAXQ;\n  \n    if(hash[value] != 0) {\n      if(hash[value] == sum) {\n\t//printf(\"%d already exists!!\\n\", value);\n\treturn 1;\n\n      }\n      else{\n\t//printf(\"CONFLICT!!\\n\");\n\ti++;\n      }\n    }\n  \n    else{\n      hash[value] = sum;\n      break;\n    }\n  }\n\n  return 0;\n}\n\nlong long h1(long long key){\n  return key % MAXQ;\n}\n\nlong long h2(long long key){\n  return 1 + (key % (MAXQ-1));\n}\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#define FOR(i,n) for(int i=0; i<n; ++i)\n#define GET(type,name) type name; std::cin >> name;\n\n\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <utility>\n#include <algorithm>\n#include <queue>\n#include <numeric>\n#include <unordered_map>\n\n\n    typedef std::vector<std::vector<int>> State;\n    const int N = 3;\n\n    State int_to_state(int c){\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n      FOR(i, N) {\n        FOR(j, N) {\n          int r = c%10;\n          c = c/10;\n          state[i][j] = r;\n        }\n      }\n      return state;\n    }\n    int state_to_int(State state) {\n      int c = 0;\n      int p = 1;\n      FOR(i, N) {\n        FOR(j, N) {\n          c += state[i][j] * p;\n          p *= 10;\n        }\n      }\n      return c;\n    }\n\n\n    void show(std::vector<std::vector<int>> state){\n      FOR(i, N) {\n        FOR(j, N) {\n          std::cout << state[i][j] << \" \";\n        }\n        std::cout << std::endl;\n      }\n    }\n\n    bool is_solved(const State& state) {\n      int N = state.size();\n\n      FOR(i, N) {\n        FOR(j, N) {\n          if(state[i][j] != (1 + 3*i + j)) return false;\n        }\n      }\n      return true;\n    }\n\n    std::vector<State> next_states_of(State state){\n      std::vector<State> res;\n      FOR(i,N){\n        FOR(j,N){\n          if(state[i][j] == 9){\n            State ns;\n            if(i<N-1){\n              ns = state;\n              std::swap(ns[i][j], ns[i+1][j]);\n              res.push_back(ns);\n            }\n            if(j<N-1){\n              ns = state;\n              std::swap(ns[i][j], ns[i][j+1]);\n              res.push_back(ns);\n            }\n            if(i>0){\n              ns = state;\n              std::swap(ns[i][j], ns[i-1][j]);\n              res.push_back(ns);\n            }\n            if(j>0){\n              ns = state;\n              std::swap(ns[i][j], ns[i][j-1]);\n              res.push_back(ns);\n            }\n            return res;\n          }\n        }\n      }\n\n//      auto ns = state; std::swap(ns[0][0], ns[0][1]); res.push_back(ns);\n//      ns = state; std::swap(ns[0][1], ns[0][2]); res.push_back(ns);\n//      ns = state; std::swap(ns[1][0], ns[1][1]); res.push_back(ns);\n//      ns = state; std::swap(ns[1][1], ns[1][2]); res.push_back(ns);\n//      ns = state; std::swap(ns[2][0], ns[2][1]); res.push_back(ns);\n//      ns = state; std::swap(ns[2][1], ns[2][2]); res.push_back(ns);\n//      ns = state; std::swap(ns[0][0], ns[1][0]); res.push_back(ns);\n//      ns = state; std::swap(ns[1][0], ns[2][0]); res.push_back(ns);\n//      ns = state; std::swap(ns[0][1], ns[1][1]); res.push_back(ns);\n//      ns = state; std::swap(ns[1][1], ns[2][1]); res.push_back(ns);\n//      ns = state; std::swap(ns[0][2], ns[1][2]); res.push_back(ns);\n//      ns = state; std::swap(ns[1][2], ns[2][2]); res.push_back(ns);\n//      std::cout << res.size() <<std::endl;\n\n    }\n\n\n    int solve_puzzle(State state){\n\n      std::priority_queue<\n        std::pair<int, int>,\n        std::vector<std::pair<int, int>>,\n        std::greater<std::pair<int, int>>\n      > q;\n      std::unordered_map<int, int> h;\n\n      q.push(std::make_pair(0, state_to_int(state)));\n\n      for(;not q.empty();){\n        auto d_s = q.top(); q.pop();\n        int d = d_s.first;\n        int st_int = d_s.second;\n        State state = int_to_state(d_s.second);\n//        show(state);\n\n        if(st_int == 987654321){\n//          std::cout << \"z\"<< std::endl;\n          return d;\n        }\n\n        if(h.find(st_int) == h.end()){\n          h[st_int] = d;\n          std::vector<State> next_states = next_states_of(state);\n          for(auto ns : next_states){\n            q.push(std::make_pair(d+1, state_to_int(ns)));\n          }\n        }\n      }\n      return -1;\n    }\n\n    int main(){\n      const int N = 3;\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n\n      FOR(i, N){\n        FOR(j, N){\n          GET(int, x);\n          if(x==0) x=9;\n          state[i][j] = x;\n        }\n      }\n//      show(state);\n//      int c = state_to_int(state);\n//      std::cout << c << std::endl;\n//      std::cout << \"?\" <<std::endl;\n//      State s2 = int_to_state(c);\n//      std::cout << \"!\" <<std::endl;\n//\n//      show(s2);\n//      int min_steps = rec_min_steps_\n      std::cout << solve_puzzle(state) << std::endl;\n      return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n#include<cmath>\n\nusing namespace std;\n\n\n#define N 3\n#define N2 9\n//--------------------------------------- \nstruct P{\n    int f[N2];\n    int space;\n    string path;\n\n     \n    bool operator < (const P &p) const{\n        for(int i = 0; i < N2; i++){\n            if(f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\n//-------------------------------------------- \nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n \n//--------------------------------------------\nbool isTarget(P p){\n    for(int i = 0; i < N2; i++)\n        if(p.f[i] != (i + 1)) return false;\n    return true;\n}\n//--------------------------------------------\nstring bfs(P s){\n    queue<P> Q;\n    map<P, bool> V;\n    P u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n     \n    while(!Q.empty()){\n        u = Q.front(); Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for(int r = 0; r < 4; r++){\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if(!V[v]){\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n//-----------------------------\nint main(){\n    P in;\n    for(int i = 0; i < N2; i++){\n        cin >> in.f[i];\n        if(in.f[i] == 0){\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n     \n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n#include<cassert>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < ( const Puzzle &p ) const{\n    for ( int i = 0; i < N2; i++ ){\n      if ( f[i] == p.f[i] ) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  for ( int i = 0; i < N2; i++ )\n    if ( p.f[i] != (i + 1) ) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n  \n  while( !Q.empty() ){\n    u = Q.front(); Q.pop();\n    if ( isTarget(u) ) return u.path;\n    int sx = u.space/N;\n    int sy = u.space%N;\n    for ( int r = 0; r < 4; r++ ){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx*N+ty]);\n      v.space = tx*N+ty;\n      if ( !V[v] ){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  assert(false);\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  \n  for ( int i = 0; i < N2; i++ ){\n    cin >> in.f[i];\n    if ( in.f[i] == 0 ) {\n      in.f[i] = N2; \n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep2(x,fr,to) for(int (x)=(fr);(x)<(to);(x)++)\n#define rep(x,to) for(int (x)=0;(x)<(to);(x)++)\n#define repr(x,fr,to) for(int (x)=(fr);(x)>=(to);(x)--)\n#define all(c) (c).begin(),(c).end()\n#define sz(v) (int)(v).size()\n\nusing namespace std;\ntypedef long long ll; typedef vector<int> VI; typedef pair<int,int> pii;\nvoid dbg(){ cerr << \"\\n\"; }  template <typename T,typename ...T2>\nvoid dbg(const T& fst, const T2&...rst){ cerr << fst << \": \"; dbg(rst...); }\n\nconst vector<VI> cnsw ={\n\t{1,3},  {0,2,4},  {1,5},\n\t{0,4,6},{1,3,5,7},{2,4,8},\n\t{3,7},  {4,6,8},  {5,7}\n};\n\nconst VI pps = {1,2,3,4,5,6,7,8,0};\nint main(){\n\t\n\tVI ba(9); int wi;\n\trep(i,3) rep(j,3) {cin >> wi; ba[i*3+j] = wi;}\n\n\tmap<VI, int> usd;\n\tqueue<VI> q;\n\tq.emplace(pps);\n\tusd[pps] = 0;\n\tint ct=0;\n\twhile(!q.empty()){\n\t\tauto cv = q.front(); q.pop();\n\t\tint crz, oc = usd[cv]; \n\t\trep(i,9) if(cv[i]==0){crz=i; break;}\n\t\tfor(auto p: cnsw[crz]){\n\t\t\tswap(cv[crz], cv[p]);\n\t\t\tif(!usd.count(cv) ){\n\t\t\t\tq.emplace(cv);\n\t\t\t\tusd[cv] = oc +1;\n\t\t\t}\n\t\t\tswap(cv[crz], cv[p]);\n\t\t}\n\t}\n\t\n\t\n\t\n\tcout << (usd.count(ba)? usd[ba]: -1) <<\"\\n\";\n\t\n\t/*for(auto& x: usd){\n\t\tcout << x.second <<\" :: \";\n\t\tfor(int z: x.first) cout << z <<\" \";\n\t\tcout <<\"\\n\";\n\t}*/\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<memory.h>\n#define len 362888\n#define le 9\ntypedef int state[le];\nstate st[len],goal;\nint dis[len],fact[le],head[len],vis[len],der[4][2]= {{-1,0},{1,0},{0,-1},{0,1}};\nvoid encode()\n{\n    int i;\n    for(i=fact[0]=1; i<le; i++)\n        fact[i]=fact[i-1]*i;\n}\nint decode(int s)\n{\n    int i,j,code,cnt;\n    for(i=code=0; i<le; i++)\n    {\n        for(cnt=0,j=i+1; j<le; j++)    if(st[s][i]>st[s][j])     cnt++;\n        code+=cnt*fact[8-i];\n    }\n    if(vis[code])   return 0;\n    else            return vis[code]=1;\n}\nint bfs()\n{\n    int front=1,rear=2,i,x,y,z,nx,ny,nz;\n    encode();\n    while(front<rear)\n    {\n        state& s=st[front];\n        if(memcmp(s,goal,sizeof(s))==0)\n            return front;\n        for(i=0; i<le; i++)\n            if(s[i]==0)     break;\n        x=i/3;\n        y=i%3;\n        z=i;\n        for(i=0; i<4; i++)\n        {\n\n            nx=x+der[i][0];\n            ny=y+der[i][1];\n            nz=nx*3+ny;\n            if(nx>=0&&nx<3&&ny>=0&&ny<3)\n            {\n                state& t=st[rear];\n                memcpy(&t,&s,sizeof(s));\n                t[z]=s[nz];\n                t[nz]=s[z];\n                dis[rear]=dis[front]+1;\n                if(decode(rear))\n                    rear++;\n            }\n        }\n        front++;\n    }\n    return 0;\n}\nint main(void)\n{\n    int i,oj;\n    int ppp = 1;\n    for(i=0; i<le; i++)   scanf(\"%d\",&st[1][i]);\n    for(i=0; i<le; i++){\n        goal[i] = ppp;\n        ppp++;\n    }\n    goal[8] = 0;\n\n    //for(i=0; i<le; i++)   scanf(\"%d\",&goal[i]);\n    oj=bfs();\n    if(oj)    printf(\"%d\\n\",dis[oj]);\n    else    puts(\"Impossible\");\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n    \n    bool operator < ( const Puzzle &p ) const {\n        for ( int i = 0; i < N2; i++ ) {\n            if ( f[i] == p.f[i] ) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n    for ( int i = 0; i < N2; i++ )\n      if ( p.f[i] != (i + 1) ) return false;\n    return true;\n}\n\nstring bfs(Puzzle s) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n    \n    while ( !Q.empty() ) {\n        u = Q.front(); Q.pop();\n        if ( isTarget(u) ) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for ( int r = 0; r < 4; r++ ) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if ( !V[v] ) {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    \n    return \"unsolvable\";\n}\n\nint main() {\n    Puzzle in;\n    \n    for ( int i = 0; i < N2; i++ ) {\n        cin >> in.f[i];\n        if ( in.f[i] == 0 ) {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\nvector<int> searched;\n\nbool find(int target){\n    int n = searched.size() - 1;\n    REP(i, n + 1){\n        if(searched[n-i] == target)\n            return false;\n    }\n    return true;\n}\n\nclass board{\nprivate:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<int> tiles;\n\npublic:\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        REP(i, 9){\n            tiles.push_back(num[i]);\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n    }\n\n    int cost() {\n        return wrongs + moves;\n    }\n\n    int board_to_int(){\n        int k = 0;\n        REP(i, 9)\n            k += (tiles[i] * pow(10, i));\n        return k;\n    }\n\n    void move() {\n        pq.pop();\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            if(find(board_to_int()))\n                pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            if(find(board_to_int()))\n                pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            if(find(board_to_int()))\n                pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            if(find(board_to_int()))\n                pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\n\n\nbool operator< (board b1, board b2){\n    return (b1.cost() > b2.cost()) ? true : false;\n}\n\nint dfs(){\n    pq.push(board(original, 0));\n    while(!pq.empty()){\n        auto target = pq.top();\n        if(target.cost() > 100)\n            return -1;\n        if(target.get_wrongs() == 0)\n            return target.cost();\n        else{\n            target.move();\n        }\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = 0;\n    move = dfs();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* \n * I used # 1687007 as a refference. Thx. \n */\n#include <iostream>\n#include <queue>\n#include <set>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\n//const int PATTERN = 181440;     // 9! / 2;\nconst int PATTERN = 362880;     // 9! / 2;\nconst int FORWARD  = 1;\nconst int BACKWARD = -1;\nconst Board GOAL = 0x123456780LL;\nconst int DX[] = { -1, 0, 1,  0 },\n          DY[] = {  0, 1, 0, -1 };\n\nint history[PATTERN];\nqueue<Board> q;\n\n// I made this function based on one by Haruhiko Okumura(Algorithm \n// Dictionary, p116) and one by M.Hiroi(Puzzle DE Programming).\ninline int change_number(long long board) {\n    static int fact_table[N] = {\n         40320, 5040, 720, 120, 24, 6, 2, 1, 0      // on N = 8\n    };\n    int value = 0;\n    for (int j = 0; j < N - 1; ++j) {\n        int J = static_cast<int>((board >> (j*4) & 0xF));\n        value += fact_table[j] * J;\n        for (int k = j + 1; k < N; ++k) {\n            int K = static_cast<int>((board >> k*4) & 0xF);\n            if (J < K) {\n                board &= ~(0xFLL << k*4);\n                board |= (static_cast<long long>(K - 1) << k*4);\n            }\n        }\n    }\n//    printf(\"[change_number] value = %d\\n\", value);\n    return value;\n}\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 0xF;\n    board |= num << (spacepos*4);\n    board &= ~(0xFLL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, Board board) {\n//    printf(\"change_number(board) = %d\\n\", change_number(board));\n    int direction = history[change_number(board)];\n    swap(numpos, spacepos, board);\n    int pos = change_number(board);\n    if (!history[pos]) {\n        q.push(board);\n        history[pos] = direction + (direction > 0 ? 1 : -1);\n    }\n    else if ((history[pos] > 0 && direction < 0)\n          || (history[pos] < 0 && direction > 0)) {\n        return abs(history[pos]) + abs(direction) + (direction > 0 ? 1 : -1);\n    }\n    return 0;\n}\n\nvoid print(Board b) {\n    for (int i = N - 1; i >= 0; --i) {\n        printf(\"%2lld\", (b >> (i*4) & 0xF));\n    }\n    printf(\"\\n\");\n}\n\n// OK\nint main(void) {\n\n    Board board = 0;\n    for (int i = N - 1, num; i >= 0; --i) {\n        scanf(\"%d\", &num);\n        board |= static_cast<long long>(num) << (i * 4);\n    }\n//    print(board);\n//    print(GOAL);\n\n    int count = 0;\n    if (board == GOAL) {\n        goto END;\n    }\n\n    history[change_number(board)] = FORWARD;\n    history[change_number(GOAL)]  = BACKWARD;\n\n    q.push(board);\n    q.push(GOAL);\n    while (!q.empty()) {\n        board = q.front();\n        q.pop();\n\n        int pos = -1;\n        while (++pos < N)\n            if (((board >> (pos * 4)) & 0xF) == 0)\n                break;\n\n        int zx = pos % 3, zy = pos / 3;\n        for (int i = 0; i < 4; ++i) {\n            int nx = zx + DX[i], ny = zy + DY[i];\n            if (nx < 0 || nx > 2 || ny < 0 || ny > 2)\n                continue;\n            int npos = nx + ny * 3;\n//            printf(\"npos = %d\\n\", npos);\n            assert(pos >= 0 && pos < N);\n            assert(npos >= 0 && npos < N);\n            if ((count = swap_and_check(npos, pos, board)))\n                goto END;\n        }\n//        printf(\"\\n\");\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstruct r{\n\tint x;\n\tint y;\n\tint men[3][3];\n\tint cnt;\n};\nbool used[9][9][9][9][9][9][9][9][9];\nint main(){\n\tint i,j,dx[4]={0,1,0,-1},dy[4]={-1,0,1,0},k,temp,menc[3][3]={{1,2,3},{4,5,6},{7,8,0}};\n\tr f,v;\n\tqueue<r> q;\n\tmemset(used,0,sizeof(used));\n\tfor(i=0;i<3;i++){\n\t\tfor(j=0;j<3;j++){\n\t\t\tcin>>f.men[i][j];\n\t\t\tif(f.men[i][j]==0){\n\t\t\t\tf.x=j;\n\t\t\t\tf.y=i;\n\t\t\t}\n\t\t}\n\t}\n\tf.cnt=0;\n\tq.push(f);\n\twhile(!q.empty()){\n\t\tf=q.front();\n\t\tq.pop();\n\t\tif(used[f.men[0][0]][f.men[0][1]][f.men[0][2]][f.men[1][0]][f.men[1][1]][f.men[1][2]][f.men[2][0]][f.men[2][1]][f.men[2][2]]==false){\n\t\t\tused[f.men[0][0]][f.men[0][1]][f.men[0][2]][f.men[1][0]][f.men[1][1]][f.men[1][2]][f.men[2][0]][f.men[2][1]][f.men[2][2]]=true;\n\t\t}\n\t\telse continue;\n\t\tint o=0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tfor(j=0;j<3;j++){\n\t\t\t\tif(f.men[i][j]!=menc[i][j]){\n\t\t\t\t\to=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(o==0)break;\n\t\tfor(k=0;k<4;k++){\n\t\t\tif(f.y+dy[k]>=0&&f.y+dy[k]<3&&f.x+dx[k]>=0&&f.x+dx[k]<3){\n\t\t\t\tv=f;\n\t\t\t\ttemp=v.men[f.y][f.x];\n\t\t\t\tv.men[f.y][f.x]=v.men[f.y+dy[k]][f.x+dx[k]];\n\t\t\t\tv.men[f.y+dy[k]][f.x+dx[k]]=temp;\n\t\t\t\tv.x=f.x+dx[k];\n\t\t\t\tv.y=f.y+dy[k];\n\t\t\t\tv.cnt++;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<f.cnt<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 10010;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> Array;\ntypedef vector<Array> Graph;\ntypedef pair<double, double> pdd;\nconst ull mod = 1000000000 + 7;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\nconst int CODE_MAX = 362880;\nconst int SIZE = 9;\nint visited[CODE_MAX];\n\nint factorial(int n){\n    if(n==1) return 1;\n    return n*factorial(n-1);\n};\n\nstruct Board{\n    int num[SIZE];\n    void print(){\n        for(int i=0;i<SIZE;i++) cout << num[i] << \" \";\n        cout << endl;\n    }\n};\n\nint encode(Board &b){\n    int res = 0;\n    int temp_b[SIZE];\n    for(int i=0;i<SIZE;i++) temp_b[i] = b.num[i];\n    for(int i=0;i<SIZE-1;i++){\n        res += factorial(SIZE-1-i)*temp_b[i];\n        for(int j=i+1;j<SIZE-1;j++){\n            if(temp_b[i]<temp_b[j]) temp_b[j]--;\n        }\n    }\n   return res;\n}\n\nBoard decode(int encoded){\n    Board b;\n    int tmp[SIZE];\n    for(int i=0;i<SIZE-1;i++){\n        int fact = factorial(SIZE-1-i);\n        tmp[i] = encoded/fact;\n        encoded %= fact;\n    }\n    tmp[SIZE-1] = 0;\n    int tmp2[SIZE];\n    bool check[SIZE];\n    for(int i=0;i<SIZE;i++){\n        tmp2[i] = i;\n        check[i] = false;\n    }\n    for(int i=0;i<SIZE;i++){\n        int j=0;\n        while(tmp[i]!=tmp2[j] || check[j]) j++;\n        b.num[i] = j;\n        check[j] = true;\n        while(j<SIZE){\n            tmp2[j]--;\n            j++;\n        }\n    }\n\n    return b;\n}\n\nint get_adjacent(int now, int i){\n    // \"i\" represents the direction of zero movement.0 up, 1 down, 2 left, 3 right\n    Board b = decode(now);\n    int zero=0;\n    while(b.num[zero]!=0) zero++;\n    if(i==0){\n        if(zero<3) return -1;\n        swap(b.num[zero], b.num[zero-3]);\n    }\n    if(i==1){\n        if(zero>5) return -1;\n        swap(b.num[zero], b.num[zero+3]);\n    }\n    if(i==2){\n        if(zero%3<1) return -1;\n        swap(b.num[zero], b.num[zero-1]);\n    }\n    if(i==3){\n        if(zero%3>1) return -1;\n        swap(b.num[zero], b.num[zero+1]);\n    }\n    return encode(b);\n}\n\nint heuristic_func(int enc1, int enc2){\n    Board b1 = decode(enc1);\n    int zero1 = 0;\n    while(b1.num[zero1]!=0) zero1++;\n    Board b2 = decode(enc2);\n    int zero2 = 0;\n    while(b2.num[zero2]!=0) zero2++;\n    return abs(zero1/3 - zero2/3) + abs(zero1%3 - zero2%3);\n}\n\nint heuristic_func2(int enc1, int enc2){\n    Board b1 = decode(enc1);\n    Board b2 = decode(enc2);\n    int res = 0;\n    for(int i=0;i<SIZE;i++){\n        int pos1 = 0;\n        int pos2 = 0;\n        while(b1.num[pos1]!=i) pos1++;\n        while(b2.num[pos2]!=i) pos2++;\n        res += abs(pos1/3-pos2/3) + abs(pos1%3 - pos2%3);\n    }\n    return res;\n}\n\nint main(){\n    Board b;\n    for (int i=0;i<SIZE;i++){\n        cin >> b.num[i];\n    }\n    for(int i=0;i<CODE_MAX;i++){\n        visited[i] = -1;\n    }\n\n    const int start = encode(b);\n    const int goal = 46233;\n    priority_queue<pii, vector<pii>, greater<pii> > que;\n    que.push(make_pair(heuristic_func2(start, goal), start));\n    visited[start] = 0;\n    int count = 0;\n    while(visited[goal]==-1){\n        pii x = que.top();\n        que.pop();\n        int now = x.second;\n        for(int i=0;i<4;i++){\n            int adj = get_adjacent(now, i);\n            if(adj==-1 || visited[adj]!=-1) continue;\n            count++;\n            visited[adj] = visited[now]+1;\n            que.push(make_pair(heuristic_func2(adj, goal) + visited[adj], adj));\n        }\n    }\n    cout << visited[goal] << endl;\n    //cout << count << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <vector>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\nusing board_t = array<int32_t, 9>;\nusing state_t = tuple<int32_t, int32_t, board_t, board_t>;\n\nint32_t hamming(const board_t &board) {\n    int32_t d = 0;\n\n    for (int32_t i = 0; i < 9; i++) {\n        if (board[i] != (i+1)%9) d++;\n    }\n\n    return d;\n}\n\nvector<board_t> children(const board_t &board) {\n    vector<board_t> c;\n    int32_t z = 0;\n    while (board[z] != 0) z++;\n    int32_t zr = z/3, zc = z%3;\n\n    if (zr-1 >= 0) {\n        board_t board_new = board;\n        swap(board_new[zr*3+zc], board_new[(zr-1)*3+zc]);\n        c.push_back(board_new);\n    }\n    if (zr+1 < 9) {\n        board_t board_new = board;\n        swap(board_new[zr*3+zc], board_new[(zr+1)*3+zc]);\n        c.push_back(board_new);\n    }\n    if (zc-1 >= 0) {\n        board_t board_new = board;\n        swap(board_new[zr*3+zc], board_new[zr*3+zc-1]);\n        c.push_back(board_new);\n    }\n    if (zc+1 < 9) {\n        board_t board_new = board;\n        swap(board_new[zr*3+zc], board_new[zr*3+zc+1]);\n        c.push_back(board_new);\n    }\n\n    return c;\n}\n\n\nint main() {\n    board_t board;\n\n    for (int32_t i = 0; i < 9; i++) {\n        cin >> board[i];\n    }\n\n    auto c = [](state_t l, state_t r) {return (get<0>(l) + get<1>(l)) > (get<0>(r) + get<1>(r));};\n    priority_queue<state_t, vector<state_t>, decltype(c)> tovisit(c);\n    tovisit.push(make_tuple(0, hamming(board), board, board));\n\n    while (!tovisit.empty()) {\n        int32_t moves, dist;\n        board_t board, parent;\n        tie(moves, dist, board, parent) = tovisit.top();\n        tovisit.pop();\n\n        if (dist == 0) {\n            cout << moves << endl;\n            break;\n        }\n\n        for (board_t child : children(board)) {\n            if (child != parent) {\n                tovisit.push(make_tuple(moves + 1, hamming(child), child, board));\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define LIMIT 32\n\nstruct Puzzle{\n    char cont[9];\n    int space;\n    string path;\n    bool operator < ( const Puzzle &p ) const{\n        for ( int i = 0; i < 9; i++ ){\n            if ( cont[i] == p.cont[i] ) continue;\n            return cont[i] > p.cont[i];\n        }\n        return false;\n    }\n};\n\nint limit;\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char direction[4] = {'d', 'r', 'u', 'l'};\n\nbool isTarget(Puzzle puzzle){\n    for ( int i = 0; i < 8; i++ ){\n        if ( puzzle.cont[i] != '1' + i ) return false;\n    }\n    return true;\n}\n\nvoid bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n    \n    while( !Q.empty() ){\n        u = Q.front(); Q.pop();\n        if ( isTarget(u) ){\n            cout << u.path.size() << endl;\n            return;\n        } else if ( u.path.size() > LIMIT ) break;\n        \n        int sx, sy, tx, ty;\n        sx = u.space/3;\n        sy = u.space%3;\n        \n        for ( int r = 0; r < 4; r++ ){\n            tx = sx + dx[r];\n            ty = sy + dy[r];\n            if ( tx < 0 || ty < 0 || tx >= 3 || ty >= 3 ) continue;\n            v = u;\n            v.cont[u.space] = u.cont[tx*3+ty];\n            v.cont[tx*3+ty] = '0';\n            v.space = tx*3+ty;\n            if ( !V[v] ){\n                V[v] = true;\n                v.path += direction[r];\n                Q.push(v);\n            }\n        }\n    }\n    cout << \"unsolvable\" << endl;\n}\n\nint main(){\n    Puzzle in;\n    for ( int i = 0; i < 9; i++ ){\n        cin >> in.cont[i];\n        if ( in.cont[i] == '0' ) {\n            in.space = i;\n        }\n    }\n    \n    bfs(in);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n\n#define A 3\n#define B 9\n\nstruct pazzle{\n  int f[B];\n  int space;\n  string path;\n\n  bool operator < (const pazzle &p) const{\n    for(int i=0;i<B;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(pazzle p){\n  for(int i=0;i<B;i++)\n    if(p.f[i]!=(i+1))return false;\n  return true;\n}\n\nstring bfs(pazzle s){\n  queue<pazzle> Q;\n  map<pazzle,bool> V;\n  pazzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front();\n    Q.pop();\n\n    if(isTarget(u))return u.path;\n\n    int sx = u.space/A;\n    int sy = u.space%A;\n\n    for(int r=0;r<4;r++){\n      int tx = sx+dx[r];\n      int ty = sy+dy[r];\n\n      if(tx<0 || ty<0 || tx>=A || ty>=A)continue;\n\n      v=u;\n      swap(v.f[u.space],v.f[tx*A+ty]);\n      v.space = tx*A+ty;\n      if(!V[v]){\n        V[v]=true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  pazzle in;\n\n  for(int i=0;i<B;i++){\n    cin >> in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=B;\n      in.space =i;\n    }\n  }\n string ans = bfs(in);\n cout << ans.size() << endl;\n\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <fstream>\n\nusing namespace std;\n\n//moves will be outputted to this filestream\nofstream ofs(\"PuzzleSolution.txt\");\n\n//Puzzle solver\nclass EPSolver\n{\n    using ID = uint64_t;\n    using P = pair<double, ID>;\n\npublic:\n    int h, w;\n\n    //Puzzle board\n    class Puzzle\n    {\n    public:\n        int h, w;\n        EPSolver::ID id;\n        vector<vector<int>> board;\n\n        Puzzle(int N = 3, int M = 3)\n        {\n            h = N, w = M;\n            id = 0;\n            board.resize(h, vector<int>(w));\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    board[i][j] = (i == h - 1 && j == w - 1 ? 0 : i * w + j + 1);\n                    id = id * h * w + board[i][j];\n                }\n            }\n        }\n\n        Puzzle(const vector<vector<int>> &newboard)\n        {\n            setBoard(newboard);\n        }\n\n        void setBoard(const vector<vector<int>> &newboard)\n        {\n            h = newboard.size();\n            w = newboard[0].size();\n            board = newboard;\n            id = 0;\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    board[i][j] = newboard[i][j];\n                    id = id * h * w + board[i][j];\n                }\n            }\n            if (!checkInput())\n            {\n                //cerr << \"Invalid Input\" << endl;\n                exit(0);\n            }\n        }\n\n        bool checkInput()\n        {\n            bool res = true;\n            set<int> s;\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    int v = board[i][j];\n                    res &= 0 <= v && v < h * w;\n                    res &= s.find(v) == s.end();\n                    s.insert(v);\n                }\n            }\n            res &= s.size() == (h * w);\n            return res;\n        }\n\n        //evaluation function\n        //a=1安定\n        double calcScore(double a = 1.)\n        {\n            double res = 0;\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    int k = board[i][j];\n                    if (k == 0)\n                        continue;\n                    int y = (k - 1) / w, x = (k - 1) % w;\n                    res += pow(pow(abs(y - i), a) + pow(abs(x - j), a), 1 / a);\n                }\n            }\n            return res;\n        }\n\n        double calcScore(int a = 1)\n        {\n            double res = 0;\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    int k = board[i][j];\n                    if (k == 0)\n                        continue;\n                    int y = (k - 1) / w, x = (k - 1) % w;\n                    res += abs(y - i) + abs(x - j);\n                }\n            }\n            return res;\n        }\n\n        friend ostream &operator<<(ostream &os, const Puzzle &puzzle)\n        {\n            for (int i = 0; i < puzzle.h; i++)\n            {\n                for (int j = 0; j < puzzle.w; j++)\n                {\n                    int x = puzzle.board[i][j];\n                    os << (char)(x ? x + '0' : '#') << ' ';\n                }\n                os << '\\n';\n            }\n            return os;\n        }\n    };\n\n    //ID -> Puzzle\n    Puzzle encodeBoard(ID id)\n    {\n        vector<vector<int>> b(h);\n        for (int i = 0; i < h; i++)\n        {\n            for (int j = 0; j < w; j++)\n            {\n                b[i].push_back(id % ID(h * w));\n                id /= ID(h * w);\n            }\n            reverse(b[i].begin(), b[i].end());\n        }\n        reverse(b.begin(), b.end());\n        Puzzle p(b);\n        return p;\n    }\n\n    //score and boardID\n    priority_queue<P, vector<P>, greater<P>> open, close;\n    set<ID> openId, closeId;\n\n    //child, parent\n    map<ID, ID> par;\n    map<ID, double> scoreMemoF;\n    map<ID, double> scoreMemoG;\n\n    //first state, target state\n    ID initId, targetId;\n\n    EPSolver(const vector<vector<int>> &b, const vector<vector<int>> &t)\n    {\n        h = b.size();\n        w = b[0].size();\n        Puzzle pb(b), pt(t);\n        double s = pb.calcScore(1);\n        initId = pb.id;\n        targetId = pt.id;\n        openId.insert(initId);\n        open.push(make_pair(s, initId));\n        par[initId] = -1;\n        scoreMemoF[initId] = s;\n        solve();\n    }\n\n    vector<Puzzle> nextBoard(const Puzzle &puzzle)\n    {\n        vector<Puzzle> res;\n        for (int i = 0; i < h; i++)\n            for (int j = 0; j < w; j++)\n            {\n                //find empty cell\n                if (puzzle.board[i][j])\n                    continue;\n                for (int d = 0; d < 4; d++)\n                {\n                    int ny = i + ((d & 1) ? 0 : ((d & 2) ? 1 : -1));\n                    int nx = j + ((d & 1) ? ((d & 2) ? 1 : -1) : 0);\n                    if (0 > ny || ny >= h || 0 > nx || nx >= w)\n                        continue;\n                    vector<vector<int>> copyBoard(puzzle.board);\n                    swap(copyBoard[ny][nx], copyBoard[i][j]);\n                    Puzzle newpuzzle = Puzzle(copyBoard);\n                    res.push_back(newpuzzle);\n                }\n            }\n        return res;\n    }\n\n    void solve()\n    {\n        if (initId == targetId)\n        {\n            //cerr << \"Already Solved (*-v・)\" << endl;\n            return;\n        }\n        while (!open.empty())\n        {\n            //openから一番いいものを採用\n            double score = open.top().first;\n            ID id = open.top().second;\n\n            open.pop();\n            //openから削除、closeに追加\n            openId.erase(openId.find(id));\n            closeId.insert(id);\n\n            auto newBoard = encodeBoard(id);\n            auto nextState = nextBoard(newBoard);\n\n            for (auto board : nextState)\n            {\n                ID nextId = board.id;\n                if (!scoreMemoG[nextId] || scoreMemoG[nextId] < scoreMemoG[id] + 1)\n                {\n                    scoreMemoG[nextId] = scoreMemoG[id] + 1;\n                }\n                double score = board.calcScore(1) + scoreMemoG[nextId];\n                if (nextId == targetId)\n                {\n                    //cerr << \"Solution Was Found!\" << endl;\n                    par[nextId] = id;\n                    return;\n                }\n                bool foundInOpen = openId.find(nextId) != openId.end();\n                bool foundInClose = closeId.find(nextId) != closeId.end();\n                if (not foundInOpen and not foundInClose)\n                {\n                    open.push({score, nextId});\n                    openId.insert(nextId);\n                    scoreMemoF[nextId] = score;\n                    par[nextId] = id;\n                }\n                else if (foundInClose)\n                {\n                    if (score < scoreMemoF[nextId])\n                    {\n                        scoreMemoF[nextId] = score;\n                        par[nextId] = id;\n                        openId.insert(nextId);\n                        open.push({score, nextId});\n                    }\n                }\n                else if (foundInOpen)\n                {\n                    if (score < scoreMemoF[nextId])\n                    {\n                        scoreMemoF[nextId] = score;\n                        par[nextId] = id;\n                    }\n                }\n            }\n        }\n        //cerr << \"Solution Was Not Found...\" << endl;\n        return;\n    }\n\n    void traceBack()\n    {\n        ID p = targetId;\n        vector<ID> path;\n        while (p != -1)\n        {\n            //ofs << p << ' ' << par[p] << endl;\n            path.push_back(p);\n            p = par[p];\n        }\n        cout << path.size() - 1 << endl;\n        //cerr << \"Number of moves: \" << path.size() - 1 << endl;\n        reverse(path.begin(), path.end());\n        int cnt = 0;\n        for (auto i : path)\n        {\n            ofs << \"move \" << cnt++ << '\\n'\n                << encodeBoard(i) << endl;\n        }\n    }\n};\n\nint main()\n{\n    int n = 3;\n    // vector<vector<int>> easy = {{5, 3, 4}, {1, 2, 6}, {7, 8, 0}};\n    // vector<vector<int>> hard = {{0, 6, 3}, {5, 8, 2}, {7, 4, 1}};\n    vector<vector<int>> b(n, vector<int>(n)), t(b);\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n        {\n            cin >> b[i][j];\n            t[i][j] = i * n + j + 1;\n        }\n    t.back().back() = 0;\n    EPSolver eps(b, t);\n    eps.traceBack();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <string>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define N 3\n#define N2 9\nclass puzzle{\npublic:\n\tint f[N2];\n\tint space;\n\tstring path;\n\t\n\tbool operator < (const puzzle &p) const {\n\t\tfor(int i=0;i<N2;i++){\n\t\t\tif(f[i]!=p.f[i]) return f[i]>p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n\t\n};\n\nstatic const int dx[4]={-1,+1,0,0};\nstatic const int dy[4]={0,0,-1,+1};\nstatic const char dir[4]={'u','d','l','r'};\n\nbool isTarget(puzzle u){\n\tfor(int i=0;i<N2;i++){\n\t\tif(u.f[i]!=i+1) return false;\n\t}\n\treturn true;\n}\n\nstring bfs(puzzle s){\n\tqueue<puzzle> Q;\n\tmap<puzzle,bool> V;\n\tpuzzle u,v;\n\ts.path=\"\";\n\tQ.push(s);\n\tV[s]=true;\n\twhile(!Q.empty()){\n\t\tu=Q.front();Q.pop();\n\t\tif(isTarget(u)) return u.path;\n\t\tint sx=u.space/N,sy=u.space%N;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tint tx=sx+dx[r],ty=sy+dy[r];\n\t\t\tif(tx<0 || tx>=N || ty<0 || ty>=N) continue;\n\t\t\tv=u;\n\t\t\tswap(v.f[v.space],v.f[tx*N+ty]);\n\t\t\tv.space=tx*N+ty;\n\t\t\tif(!V[v]){\n\t\t\t\tV[v]=true;\n\t\t\t\tv.path+=dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main() {\n\tpuzzle in;\n\tfor(int i=0;i<N2;i++){\n\t\t\tcin>>in.f[i];\n\t\t\tif(in.f[i]==0){\n\t\t\t\tin.f[i]=N2;\n\t\t\t\tin.space=i;\n\t\t\t}\n\t}\n\tstring ans=bfs(in);\n\tcout<<ans.size()<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint limit=0,T[3][3];\n\nint evaluate(){\n  int cx[]={2,0,1,2,0,1,2,0,1},cy[]={2,0,0,0,1,1,1,2,2};\n  int ret=0;\n  for (int i=0;i<3;i++){\n    for (int j=0;j<3;j++){\n      int ti = T[i][j];\n      if (ti==0)continue;\n      ret+=abs(cx[ti]-j);\n      ret+=abs(cy[ti]-i);\n      // if (cx[ti]!=j||cy[ti]!=i)ret++;\n    }\n  }\n  return ret;\n}\n\nbool trymove(int c,int zx,int zy,int pzx,int pzy){\n  int dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n  if (evaluate()==0)return true;\n  if (c+evaluate()>limit)return false;\n  for (int i=0;i<4;i++){\n    if (0>zx+dx[i]||zx+dx[i]>2||0>zy+dy[i]||zy+dy[i]>2)continue;\n    if (zx+dx[i]==pzx&&zy+dy[i]==pzy)continue;\n    swap(T[zy][zx],T[zy+dy[i]][zx+dx[i]]);\n    if (trymove(c+1,zx+dx[i],zy+dy[i],zx,zy)) return true;\n    swap(T[zy][zx],T[zy+dy[i]][zx+dx[i]]);\n  }\n  return false;\n}\n\nint main(){\n  int zx,zy;\n  for (int i=0;i<3;i++){\n    for (int j=0;j<3;j++){\n      cin >> T[i][j];\n      if (T[i][j]==0){\n\tzx=j;\n\tzy=i;\n      }\n    }\n  }\n  \n  while (evaluate()){\n    limit++;\n    if (trymove(0,zx,zy,zx,zy))break;\n  }\n  \n  cout << limit << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#define N 3\n#define NN 9\n\nusing namespace std;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\nchar direction[4] = {'u', 'l', 'd', 'r'};\n\ntypedef struct Puzzle{\n    int state[NN];\n    int space;\n    string result;\n\n    bool operator < (const Puzzle &p) const{\n        for(int i = 0; i < NN; i++){\n            if(state[i] == p.state[i]) continue;\n            return state[i] > p.state[i];\n        }\n        return false;\n    }\n}P;\n\nbool isfinished(P p){\n    for(int i = 0; i < NN; i++){\n        if(p.state[i] != i+1) return false;\n    }\n    return true;\n}\n\nstring bfs(P p){\n    queue<P> Q;\n    map<P, bool> V;\n    P u, v;\n    int sx, sy, tx, ty;\n\n    p.result = \"\";\n    Q.push(p);\n    V[p] = true;\n\n    while(!Q.empty()){\n        u = Q.front();\n        Q.pop();\n\n        if(isfinished(u)) return u.result;\n\n        sx = u.space / N;\n        sy = u.space % N;\n        for(int i = 0; i < 4; i++){\n            tx = sx + dx[i];\n            ty = sy + dy[i];\n            \n            if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\n            v = u;\n            int tmp = v.state[u.space];\n            v.state[u.space] = v.state[tx * N + ty];\n            v.state[tx * N + ty] = tmp;\n            v.space = tx * N + ty;\n\n            if(!V[v]){\n                V[v] = true;\n                v.result += direction[i];\n                Q.push(v);\n            }\n        }\n    }\n    return \"\";\n}\n\nint main(){\n    P p;\n\n    for(int i = 0; i < NN; i++){\n        cin >> p.state[i];\n        if(p.state[i] == 0){\n            p.state[i] = NN;\n            p.space = i;\n        }\n    }\n\n    string result = bfs(p);\n\n    cout << result.size() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Puzzle{\n\tint f[9], space;\n\tstring path;\n\tbool operator < (const Puzzle &p) const {\n\t\tfor (int i = 0; i < 9; ++i){\n\t\t\tif (f[i] == p.f[i])continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p)\n{\n\tfor (int i = 0; i < 9; ++i)if (p.f[i] != i + 1)return false;\n\treturn true;\n}\n\nstring bfs(Puzzle s)\n{\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\twhile (!Q.empty()){\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isTarget(u))return u.path;\n\t\tint sx = u.space / 3, sy = u.space % 3;\n\t\tfor (int r = 0; r < 4; ++r){\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= 3 || ty >= 3)continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * 3 + ty]);\n\t\t\tv.space = tx * 3 + ty;\n\t\t\tif (!V[v]){\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main()\n{\n\tPuzzle in;\n\tfor (int i = 0; i < 9; ++i){\n\t\tcin >> in.f[i];\n\t\tif (in.f[i] == 0){\n\t\t\tin.f[i] = 9;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define DIVN 3\n\nvoid swap(int &a, int &b);\nint fact(int a);\nint dist(int x);\nint abs(int x);\nvoid insert(vector<int> &A, int v);\nint extract(vector<int> &A);\nint PtoI(vector<int> p);\nvector<int> ItoP(int ii);\nint SolvePuzzle(vector<int> P);\n\nvector<int> Puzzles(fact(DIVN*DIVN), INT_MAX);\n\n\nvoid swap(int &a, int &b){\n\tint tmp = a;\n\ta = b;\n\tb = tmp;\n\treturn;\n}\n\nint fact(int a){\n\tint b = 1;\n\tfor (int i = 2; i <= a; i++){\n\t\tb = b * i;\n\t}\n\treturn b;\n}\n\nint dist(int x){\n\tstd::vector<int> P = ItoP(x);\n\tint result = 0;\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tresult += abs(P[i] % DIVN - (i + 1) % DIVN) + abs((P[i] == 0 ? DIVN - 1 : (P[i] - 1) / DIVN) / DIVN - i / DIVN);\n\t}\n\treturn -result;\n}\n\nint abs(int x){\n\treturn x < 0 ? -x : x;\n}\n\nvoid insert(vector<int> &A, int v){\n\tint n = A.size();\n\tA.push_back(v);\n\twhile (n != 0){\n\t\tint i = (n - 1) / 2;\n\t\tif (dist(A[n]) > dist(A[i])){\n\t\t\tswap(A[n], A[i]);\n\t\t}\n\t\tn = i;\n\t}\n\treturn;\n}\n\nint extract(vector<int> &A){\n\tint n = A.size() - 1;\n\tint res = A[0];\n\tA[0] = A[n];\n\tA.pop_back();\n\n\tfor (int i = 0, j; 2 * i + 1 < n;){\n\t\tj = 2 * i + 1;\n\t\tif (j != n - 1 && dist(A[j]) < dist(A[j + 1])){\n\t\t\tj++;\n\t\t}\n\t\tif (dist(A[i]) < dist(A[j])){\n\t\t\tswap(A[i], A[j]);\n\t\t}\n\t\ti = j;\n\t}\n\treturn res;\n}\n\n\nint PtoI(vector<int> p){\n\tint x, result = 0;\n\tfor (int i = 0; i < DIVN*DIVN - 1; i++){\n\t\tfor (int j = 0; j < DIVN*DIVN - i; j++){\n\t\t\tif (p[j] == i){\n\t\t\t\tx = j;\n\t\t\t\tp.erase(p.begin() + j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult += x * fact(DIVN*DIVN - i - 1);\n\t}\n\treturn result;\n}\n\nvector<int> ItoP(int ii){\n\tvector<int> result(DIVN*DIVN, -1);\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tint index = ii / fact(DIVN*DIVN - i - 1);\n\t\tii = ii % fact(DIVN*DIVN - i - 1);\n\t\tint curindex = -1;\n\t\tint x = -1;\n\t\tfor (int j = 0; j < DIVN*DIVN; j++){\n\t\t\tif (result[j] == -1){\n\t\t\t\tcurindex++;\n\t\t\t}\n\t\t\tif (curindex == index) {\n\t\t\t\tx = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult[x] = i;\n\t}\n\treturn result;\n}\n\nint SolvePuzzle(vector<int> P){\n\tvector<int> Que;\n\tinsert(Que, PtoI(P));\n\tint answer = INT_MAX;\n\tPuzzles[PtoI(P)] = 0;\n\twhile (!Que.empty()){\n\t\tvector<int> Q = ItoP(extract(Que));\n\t\tint Cursor;\n\t\tbool isAligned = true;\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] != (i + 1) % (DIVN*DIVN)){\n\t\t\t\tisAligned = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isAligned && Puzzles[PtoI(Q)] < answer){\n\t\t\tanswer = Puzzles[PtoI(Q)];\n\t\t}\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] == 0){\n\t\t\t\tCursor = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvector<int> Qnext;\n\t\tif (Cursor >= DIVN){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1 && (answer > Puzzles[PtoI(Q)] + 1)){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor < DIVN * (DIVN - 1)){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1 && (answer > Puzzles[PtoI(Q)] + 1)){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != 0){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1 && (answer > Puzzles[PtoI(Q)] + 1)){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != DIVN - 1){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1 && (answer > Puzzles[PtoI(Q)] + 1)){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn answer;\n}\n\nint main(){\n\tint k;\n\tvector<int> P;\n\tfor (int i = 0; i < DIVN * DIVN; i++){\n\t\tscanf(\"%d\", &k);\n\t\tP.push_back(k);\n\t}\n\tint n = SolvePuzzle(P);\n\n\tprintf(\"%d\\n\", n);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nstatic const int MAX = 10000;\nstatic const int INFTY = (1 << 20);\nstatic const int WHITE = 0;\nstatic const int GRAY = 1;\nstatic const int BLACK = 2;\n\nint n;\nvector<pair<int, int> > adj[MAX];\n\nvoid dijkstra() {\n\tpriority_queue<pair<int, int> > PQ;\n\tint color[MAX];\n\tint d[MAX];\n\tfor (int i = 0; i < n; i++) {\n\t\td[i] = INFTY;\n\t\tcolor[i] = WHITE;\n\t}\n\n\td[0] = 0;\n\tPQ.push(make_pair(0, 0));\n\tcolor[0] = GRAY;\n\n\twhile (!PQ.empty()) {\n\t\tpair<int, int> f = PQ.top();\n\t\tPQ.pop();\n\t\tint u = f.second;\n\n\t\tcolor[u] = BLACK;\n\n\t\tif (d[u] < f.first*(-1))continue;\n\n\t\tfor (unsigned int j = 0; j < adj[u].size(); j++) {\n\t\t\tint v = adj[u][j].first;\n\t\t\tif (color[v] == BLACK)continue;\n\t\t\tif (d[v] > d[v] + adj[u][j].second) {\n\t\t\t\td[v] = d[u] + adj[u][j].second;\n\t\t\t\tPQ.push(make_pair(d[v] * (-1), v));\n\t\t\t\tcolor[v] = GRAY;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << i << \" \" << (d[i] == INFTY ? -1 : d[i]) << endl;\n\t}\n}\n\nint main() {\n\tint k, u, v, c;\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> u >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tcin >> v >> c;\n\t\t\tadj[u].push_back(make_pair(v, c));\n\t\t}\n\t}\n\n\tdijkstra();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst int edge[4][3] = {{0, 3, 6}, {0, 1, 2}, {6, 7, 8}, {2, 5, 8}}; /* l, t, b, r */\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    int zero;\n    int original[9];\n    REP(i, 9){\n        original[i] = tiles[i];\n        if(tiles[i] == 0){\n            zero = i;\n        }\n    }\n    bool dir[4] = {true, true, true, true};\n    REP(i, 4) REP(j, 3)\n        if (zero == edge[i][j])\n            dir[i] = false;\n    if(wrongs + moves >= cutoff)\n        return -1;\n    if(dir[0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[0])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[1])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[2])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[3])\n        REP(i, 9) tiles[i] = original[i];\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n    int start = check();\n\n    REP(i, 100){\n        move = dfs(0, start + i);\n        if(move > 0)\n            break;\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\n\n#define NPANEL 9\n\nclass State {\npublic:\n  int panels[9];\n  int empty;\n  State(int p[]) {\n    for (int i = 0; i < NPANEL; i++) {\n      panels[i] = p[i];\n      if (p[i] == 0)\n        empty = i;\n    }\n  }\n  void print() {\n    for (int i = 0; i < NPANEL; i++) {\n      if (i != 0 && i % 3 == 0)\n        printf(\"\\n\");\n      printf(\"%d \", panels[i]);\n    }\n  }\n  bool is_completed() {\n    for (int i = 1; i < NPANEL; i++)\n      if (panels[i - 1] != i)\n        return false;\n    return true;\n  }\n  State left() { return slide(empty, empty - 1); }\n  State above() { return slide(empty, empty - 3); }\n  State right() { return slide(empty, empty + 1); }\n  State bottom() { return slide(empty, empty + 3); }\n  State slide(int x, int y) {\n    auto s = State(panels);\n    swap(s.panels[x], s.panels[y]);\n    s.empty = y;\n    return s;\n  }\n\n  vector<State> nexts() {\n    vector<State> v;\n    if (empty % 3 != 0)\n      v.push_back(left());\n    if (empty >= 3)\n      v.push_back(above());\n    if (empty % 3 != 2)\n      v.push_back(right());\n    if (empty <= 5)\n      v.push_back(bottom());\n    return v;\n  }\n};\n\nbool store(State st) {\n  static set<int> pool;\n  int hash = 0;\n  for (int i = 0; i < NPANEL; i++) {\n    hash *= 10;\n    hash += st.panels[i];\n  }\n  bool exists = (pool.find(hash) != pool.end());\n  if (!exists)\n    pool.insert(hash);\n  return !exists;\n}\n\nstruct Node {\n  State state;\n  int depth;\n};\n\nint solve(State init) {\n  if (init.is_completed())\n    return 0;\n  queue<Node> que;\n  que.push(Node{init, 0});\n\n  while (!que.empty()) {\n    Node node = que.front();\n    for (auto s : node.state.nexts()) {\n      if (s.is_completed()) {\n        return node.depth + 1;\n      }\n      if (store(s)) {\n        que.push(Node{s, node.depth + 1});\n      }\n    }\n    que.pop();\n  }\n}\n\nint main() {\n  int data[NPANEL];\n  for (int i = 0; i < NPANEL; i++)\n    cin >> data[i];\n\n  auto s = State(data);\n  cout << solve(s) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\n#define SIZE 3\n\nstruct Board {\n\tint array[SIZE][SIZE];\n\tint x0;\n\tint y0;\n};\n\nint distance(int a[][SIZE], int b[][SIZE])\n{\n\tint res = 0;\n\tfor (int i=0; i<SIZE*SIZE; i++) {\n\t\tint val = a[i/SIZE][i%SIZE];\n\t\tfor (int j=0; j<SIZE*SIZE; j++) {\n\t\t\tif (b[j/SIZE][j%SIZE] == val) {\n\t\t\t\tres += abs((i/SIZE) - (j/SIZE)) + abs((i%SIZE) - (j%SIZE));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn res/2;\n}\n\nvoid copyBoard(int A[][SIZE], int B[][SIZE])\n{\n\tfor (int i=0; i<SIZE; i++) {\n\t\tfor (int j=0; j<SIZE; j++) A[i][j] = B[i][j];\n\t}\n}\n\nvoid swap(int& x,int& y)\n{\n\tint tmp = x;\n\tx = y;\n\ty = tmp;\n}\n\nbool DFS(Board b, Board goal, int step, int max_step, int pre_x0, int pre_y0)\n{\t\t\t\n\tif (distance(b.array, goal.array) + step > max_step) return false;\n\tif (distance(b.array, goal.array) == 0) return true;\n\t\n\tint x0 = b.x0;\n\tint y0 = b.y0;\n\t\n\tBoard next;\n\t\n\tif (x0 > 0 && !(pre_x0 == x0 - 1 && pre_y0 == y0) ) {\n\t\tcopyBoard(next.array, b.array);\n\t\tswap(next.array[x0-1][y0], next.array[x0][y0]);\n\t\tnext.x0 = x0 - 1;\n\t\tnext.y0 = y0;\n\t\tif (DFS(next, goal, step+1, max_step, x0, y0)) return true;\n\t}\n\tif (x0 < SIZE-1 && !(pre_x0 == x0 + 1 && pre_y0 == y0)) {\n\t\tcopyBoard(next.array, b.array);\n\t\tswap(next.array[x0][y0], next.array[x0+1][y0]);\n\t\tnext.x0 = x0 + 1;\n\t\tnext.y0 = y0;\n\t\tif (DFS(next, goal, step+1, max_step, x0, y0)) return true;\n\t}\n\tif (y0 > 0 && !(pre_x0 == x0 && pre_y0 == y0 - 1)) {\n\t\tcopyBoard(next.array, b.array);\n\t\tswap(next.array[x0][y0], next.array[x0][y0-1]);\n\t\tnext.x0 = x0;\n\t\tnext.y0 = y0 - 1;\n\t\tif (DFS(next, goal, step+1, max_step, x0, y0)) return true;\n\t}\n\tif (y0 < SIZE-1  && !(pre_x0 == x0 && pre_y0 == y0 + 1)) {\n\t\tcopyBoard(next.array, b.array);\n\t\tswap(next.array[x0][y0], next.array[x0][y0+1]);\n\t\tnext.x0 = x0;\n\t\tnext.y0 = y0 + 1;\n\t\tif (DFS(next, goal, step+1, max_step, x0, y0)) return true;\n\t}\n\treturn false;\n}\n\nint solve(Board init, Board goal, int lb_max_step)\n{\n\tfor (int max_step = lb_max_step; ; max_step++) {\n\t\tif ( DFS(init, goal, 0, max_step, init.x0, init.y0) ) return max_step;\n\t}\n}\n\t\n\t\nint main()\n{\n\tBoard init;\n\t\n\tfor (int i=0; i<SIZE; i++) {\n\t\tfor (int j=0; j<SIZE; j++) {\n\t\t\tstd::cin >> init.array[i][j];\n\t\t\tif (init.array[i][j] == 0) {\n\t\t\t\tinit.x0 = i, init.y0 = j;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tBoard goal;\n\tfor (int i=0; i<SIZE; i++) {\n\t\tfor (int j=0; j<SIZE; j++) {\n\t\t\tgoal.array[i][j] = (SIZE*i+j+1) % (SIZE*SIZE);\n\t\t}\n\t}\n\tgoal.x0 = SIZE-1;\n\tgoal.y0 = SIZE-1;\n\t\n\tint distance_to_goal = distance(init.array, goal.array);\n\t\n\tint fewest_steps = solve(init, goal, distance_to_goal);\n\t\n\tstd::cout << fewest_steps << std::endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\nconst int N = 3;\nconst int N2 = 9;\n\nstruct Puzzle{\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const{\n        for (int i = 0; i < N2 ; ++i) {\n            if (f [i] == p.f[i])continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] ={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n    for (int i = 0; i < N2 ; ++i)\n        if (p.f[i] != (i + 1) ) return false;\n    return true;\n}\n\nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle,bool> V;\n    Puzzle u,v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while(! Q.empty()){\n        u = Q.front();Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4 ; ++r) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if( tx < 0 or ty < 0 or tx >= N or ty >= N ) continue;\n            v = u;\n            swap(v.f[u.space],v.f[tx * N + ty]);\n            v.space = tx * N +ty;\n            if (!V[v]){\n                V[v] = true ;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main(){\n    Puzzle in;\n    for (int i = 0; i < N2 ; ++i) {\n        cin >> in.f[i];\n        if (in.f[i] == 0){\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size () << endl;\n    return 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<functional>\n#include<algorithm>\n#include<set>\n#include<queue>\nusing namespace std;\nint main(void)\n{\n\tint i,j,a[9],b[9],x1,go,g[9]={1,2,3,4,5,6,7,8,0},x2,x3,y,x4;\n\tint d[9][4]={{1,3,-1,-1},{0,2,4,-1},{1,5,-1,-1},\n\t\t{0,4,6,-1},{1,3,5,7},{2,4,8,-1},\n\t{3,7,-1,-1},{4,6,8,-1},{5,7,-1,-1}};\n\tset<int> ss;\n\tset<int>::iterator it;\n\tqueue<int> q1,q2,q3;\n\tgo=0;\n\tfor(i=0;i<9;i++){\n\t\tgo*=9;\n\t\tgo+=g[i];\n\t}\n\tfor(i=0;i<9;i++)\tscanf(\"%d\",&a[i]);\n\tx1=0;\n\tfor(i=0;i<9;i++){\n\t\tx1*=9;\n\t\tx1+=a[i];\n\t\tif(a[i]==0)\tx2=i;\n\t}\t\n\tss.insert(x1);\n\tx3=0;\n\tq1.push(x1);\tq2.push(x2);\tq3.push(x3);\n\twhile(q1.size()!=0)\t{\n\t\tx1=q1.front();\tq1.pop();\n\t\tx2=q2.front();\tq2.pop();\n\t\tx3=q3.front();\tq3.pop();\n//\t\tprintf(\"x1=%d\\n\",x1);\n\t\tif(x1==go)\tbreak;\n\t\tfor(j=8;j>=0;j--)\t{\n\t\t\tb[j]=x1%9;\n\t\t\tx1/=9;\n\t\t}\t\t\n//\t\tfor(i=0;i<9;i++)\tprintf(\"%d \",b[i]);\tprintf(\"\\n\");\n\t\tfor(i=0;i<4;i++)\t{\n\t\t\ty=d[x2][i];\t\t\n//\t\t\tprintf(\"y=%d\\n\",y);\n\t\t\tif(y!=-1)\t{\n\t\t\t\tswap(b[x2],b[y]);\n\t\t\t\tx1=0;\n\t\t\t\tfor(j=0;j<9;j++){\n\t\t\t\t\tx1*=9;\n\t\t\t\t\tx1+=b[j];\n\t\t\t\t}\t\n\t\t\t\tit=ss.find(x1);\n\t\t\t\tif(it==ss.end())\t{\n\t\t\t\t\tq1.push(x1);\tq2.push(y);\tq3.push(x3+1);\n\t\t\t\t\tss.insert(x1);\n\t\t\t\t}\n\t\t\t\tswap(b[x2],b[y]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",x3);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<string>\n\nusing namespace std;\n#define N2 9\n#define N  3\nstruct Puzzle\n{\n    int f[N2];\n    int space;\n    string path;\n    bool operator < (const Puzzle &p)const {\n            for(int i=0;i<N2;i++){\n            if(f[i]==p.f[i])continue;\n            return f[i]>p.f[i];\n            }\n        return false;\n    }\n};\nconst int dx[4]={-1,0,1,0};\nconst int dy[4]={0,-1,0,1};\nconst char dir[4]={'u','l','d','r'};\nbool isTarge(Puzzle p)\n{\n    for(int i=0;i<N2;i++)if(p.f[i]!=i+1)return false ;\n    return true;\n}\nstring bfs(Puzzle s)\n{\n    queue<Puzzle> q;\n    map<Puzzle,bool>V;\n    Puzzle u,v;\n    s.path=\"\";\n    q.push(s);\n    V[s]=true;\n    while(!q.empty())\n    {\n        u=q.front();q.pop();\n        if(isTarge(u))return u.path;\n        int sx=u.space/N;\n        int sy=u.space%N;\n        for(int i=0;i<4;i++)\n        {\n            int nx=sx+dx[i];\n            int ny=sy+dy[i];\n            if(nx<0||ny<0||nx>=N||ny>=N)continue;\n            v=u;\n            swap(v.f[u.space],v.f[nx*N+ny]);\n            v.space=nx*N+ny;\n            if(!V[v])\n            {\n                V[v]=true;\n                v.path+=dir[i];\n                q.push(v);\n            }\n        }\n    }\n    return \"unsovleable\";\n}\nint main()\n{\n    Puzzle in;\n    for(int i=0;i<N2;i++)\n    {\n        cin>>in.f[i];\n        if(in.f[i]==0)\n        {\n            in.f[i]=N2;\n            in.space=i;\n        }\n    }\n    string ans=bfs(in);\n    cout<<ans.size()<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define NN 9\n\nstruct Puzzle{\n    int f[NN];\n    int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const{\n        for(int i = 0; i < NN; i++){\n            if(f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n    for(int i = 0; i < NN; i++){\n        if(p.f[i] != (i + 1)) return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while(!Q.empty()){\n        u = Q.front();\n        Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for(int r = 0; r < 4; r++){\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if(!V[v]){\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main(){\n    Puzzle in;\n\n    for(int i = 0; i < NN; i++){\n        cin >> in.f[i];\n        if(in.f[i] == 0){\n            in.f[i] = NN;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator<(const Puzzle &p)const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool func(Puzzle p){\n  for(int i=0;i<N2;i++)\n    if(p.f[i]!=(i+1))return false;\n  return true;\n}\nstring func1(Puzzle s){\n  queue<Puzzle>Q;\n  map<Puzzle,bool>V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n  while(!Q.empty()){\n    u=Q.front();Q.pop();\n    if(func(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N)continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\nint main(){\n  Puzzle in;\n  for(int i=0;i<N2;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=func1(in);\n  cout<<ans.size()<<endl;\n  return 0;\n}\n\t\t\t  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle\n{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator<(const Puzzle &p)\n    const\n  {\n    for(int i=0;i<N2;i++)\n      {\n\tif(f[i]==p.f[i])\n\t  {\n\t    continue;\n\t  }\n      \n\treturn f[i]>p.f[i];\n      }\n    \n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p)\n{\n  for(int i=0;i<N2;i++)\n    {\n      if(p.f[i]!=(i+1))\n\t{\n\t  return false;\n\t}\n    }\n  return true;\n}\n\nstring bfs(Puzzle s)\n{\n  queue<Puzzle> Q;\n  map<Puzzle, bool>V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty())\n    {\n      u=Q.front();\n      Q.pop();\n      if(isTarget(u))\n\t{\n\t  return u.path;\n\t}\n    \n      int sx=u.space/N;\n      int sy=u.space%N;\n    \n      for(int r=0;r<4;r++)\n\t{\n\t  int tx=sx+dx[r];\n\t  int ty=sy+dy[r];\n      \n\t  if(tx<0||ty<0||tx>=N||ty>=N)\n\t    {\n\t      continue;\n\t    }\n\t  v=u;\n      \n\t  swap(v.f[u.space],v.f[tx * N + ty]);\n      \n\t  v.space=tx*N+ty;\n      \n\t  if(!V[v])\n\t    {\n\t      V[v]=true;\n\t      v.path+=dir[r];\n\t      Q.push(v);\n\t    }\n\t}\n    }\n\n  return \"unsolvable\";\n}\n\nint main(void)\n{\n  Puzzle in;\n\n  for(int i=0;i<N2;i++)\n    {\n      cin>>in.f[i];\n      if(in.f[i]==0)\n\t{\n\t  in.f[i]=N2;\n\t  in.space=i;\n\t}\n    }\n  \n  string ans=bfs(in);\n  \n  cout<<ans.size()<<endl;\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// ------ Includes ------ //\n\n#include <set>\n#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\n\n// ------ Directions ------ //\n\nconst int dx[4] = { 0, 1, 0, -1 };\nconst int dy[4] = { 1, 0, -1, 0 };\n\n\n// ------ BFS ------ //\n\nint BFS(vector<vector<int> > p)\n{\n\t// ------ Initialize ------ //\n\n\tvector<vector<int> > lastboard = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 0 } };\n\n\tset<vector<vector<int> >, int> D;\n\n\tqueue<pair<vector<vector<int> >, int> > que;\n\n\tD.insert(p); que.push(make_pair(p, 0));\n\n\n\t// ------ Search ------ //\n\n\twhile (!que.empty())\n\t{\n\t\tpair<vector<vector<int> >, int> p1 = que.front(); que.pop();\n\n\n\t\t// ------ 0 Searching ------ //\n\n\t\tint tx = -1, ty = -1;\n\n\t\tfor (int i = 0; i < p1.first.size(); i++)\n\t\t{\n\t\t\tfor (int j = 0; j < p1.first[i].size(); j++)\n\t\t\t{\n\t\t\t\tif (p1.first[i][j] == 0)\n\t\t\t\t{\n\t\t\t\t\ttx = j; ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\t// ------ Moving ------ //\n\n\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t{\n\t\t\tif (0 <= tx + dx[dir] && tx + dx[dir] < p1.first[0].size() && 0 <= ty + dy[dir] && ty + dy[dir] < p1.first.size())\n\t\t\t{\n\t\t\t\tvector<vector<int> > p2 = p1.first;\n\n\t\t\t\tswap(p2[ty][tx], p2[ty + dy[dir]][tx + dx[dir]]);\n\n\t\t\t\tif (D.find(p2) == D.end())\n\t\t\t\t{\n\t\t\t\t\tif (p2 == lastboard)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn p1.second;\n\t\t\t\t\t}\n\n\t\t\t\t\tD.insert(p2);\n\n\t\t\t\t\tque.push(make_pair(p2, p1.second + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tvector<vector<int> > board(3, vector<int>(3, -1));;\n\n\tfor (int i = 0; i < board.size(); i++)\n\t{\n\t\tfor (int j = 0; j < board[i].size(); j++)\n\t\t{\n\t\t\tcin >> board[i][j];\n\t\t}\n\t}\n\n\tcout << BFS(board) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#pragma GCC optimize (\"O0\")\n#else\n#pragma GCC optimize (\"O3\")\n#endif\n\n\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\nusing ll = long long;\nconst int INF = 1e9 + 7;\nconst int MOD = INF;\nconst ll INF_LL = 1e18 + 7;\n\n#define __overload3(_1, _2, _3, name,...) name\n#define rep(...) __overload3(__VA_ARGS__, repFromUntil, repUntil, repeat)(__VA_ARGS__)\n#define repeat(times) repFromUntil(__name, 0, times)\n#define repUntil(name, times) repFromUntil(name, 0, times)\n#define repFromUntil(name, from, until) for (int name = from, name##__until = (until); name < name##__until; name++)\n#define repFromTo(name, from, to) repFromUntil(name, from, to + 1)\n#define repr(...) __overload3(__VA_ARGS__, reprFromUntil, reprUntil, repeat)(__VA_ARGS__)\n#define reprUntil(name, times) reprFromUntil(name, 0, times)\n#define reprFromUntil(name, from, until) for (int name = until - 1, name##__from = (from); name >= name##__from; name--)\n#define reprFromTo(name, from, to) reprFromUntil(name, from, to + 1)\n\n#define debugos OUT\n#ifdef LOCAL\n#define debug(v) {printf(\"L%d %s > \",__LINE__,#v);debugos<<(v)<<newl;}\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:(v)){debugos<<e<<\" \";}debugos<<newl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){debugos<<(m)[x]<<\" \";}debugos<<newl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){debugos<<(m)[y][x]<<\" \";}debugos<<newl;}}\n#else\n#define debug(v) {}\n#define debugv(v) {}\n#define debuga(m,w) {}\n#define debugaa(m,h,w) {}\n#endif\n\n#define newl \"\\n\"\n\n#define all(iter) begin(iter), end(iter)\n\n\ntemplate <class T> bool chmin(T& var, T x) {\n  if (var > x) {\n    var = x;\n    return true;\n  } else return false;\n}\ntemplate <class T> bool chmax(T& var, T x) {\n  if (var < x) {\n    var = x;\n    return true;\n  } else return false;\n}\n\nclass MyScanner {\n  public:\n    template<typename T> void input_integer(T& var) {\n        var = 0; T sign = 1;\n        int cc = getchar();\n        for (; cc<'0' || '9'<cc; cc = getchar())\n            if (cc == '-') sign = -1;\n        for (; '0' <= cc && cc <= '9'; cc = getchar())\n            var = (var << 3) + (var << 1) + cc - '0';\n        var = var * sign;\n    }\n    int c() { char c; while (c = getchar(), c == ' ' or c == '\\n'); return c; }\n    MyScanner& operator>>(char& var) { var = c(); return *this; }\n    MyScanner& operator>>(int& var) { input_integer<int>(var); return *this; }\n    MyScanner& operator>>(ll& var) { input_integer<ll>(var); return *this; }\n    MyScanner& operator>>(string& var) {\n        int cc = getchar();\n        for (; !isvisiblechar(cc); cc = getchar());\n        for (; isvisiblechar(cc); cc = getchar())\n            var.push_back(cc);\n        return *this;\n    }\n    operator int() {\n      int n;\n      *this >> n;\n      return n;\n    }\n    operator ll() {\n      ll n;\n      *this >> n;\n      return n;\n    }\n    private:\n      int isvisiblechar(int c) {\n        return 0x21 <= c && c <= 0x7E;\n      }\n};\nclass MyPrinter {\n  public:\n    template<typename T>\n    void output_integer(T var) {\n        if (var == 0) { putchar('0'); return; }\n        if (var < 0)\n            putchar('-'),\n            var = -var;\n        char stack[32]; int stack_p = 0;\n        while (var)\n            stack[stack_p++] = '0' + (var % 10),\n            var /= 10;\n        while (stack_p)\n            putchar(stack[--stack_p]);\n    }\n    MyPrinter& operator<<(char c) { putchar(c); return *this; }\n    template <typename T>\n    MyPrinter& operator<<(T var) { output_integer<T>(var); return *this; }\n    MyPrinter& operator<<(char* str_p) { while (*str_p) putchar(*(str_p++)); return *this; }\n    MyPrinter& operator<<(const char* str_p) { while (*str_p) putchar(*(str_p++)); return *this; }\n    MyPrinter& operator<<(const string& str) {\n        const char* p = str.c_str();\n        const char* l = p + str.size();\n        while (p < l) putchar(*p++);\n        return *this;\n    }\n    // MyPrinter& operator<<(const modint& var) { output_integer<ll>(var.value); return *this; }\n    template <typename T>\n    void operator()(T x) {\n        *this << x << newl;\n    }\n};\nMyScanner IN;\nMyPrinter OUT;\n\nusing T = vector<vector<int>>;\nusing P = pair<T, int>;\n\nint main() {\n  T start(3, vector<int>(3));\n  rep(r, 3) rep(c, 3) start[r][c] = IN;\n\n  T goal = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};\n\n  if (start == goal) {\n    OUT(0);\n    return 0;\n  }\n\n  set<T> done;\n  done.insert(start);\n  queue<P> q;\n  q.push({start, 0});\n\n  while (!q.empty()) {\n    P p = q.front(); q.pop();\n    T t = p.first; int e = p.second;\n    rep(r, 3) rep(c, 3) if (t[r][c] == 0) {\n      for (auto&& d : vector<vector<int>>{{-1, 0}, {1, 0}, {0, -1}, {0, 1}})\n        if (0 <= r+d[0] and r+d[0] < 3 and 0 <= c+d[1] and c+d[1] < 3) {\n          T t1 = t;\n          swap(t1[r+d[0]][c+d[1]], t1[r][c]);\n          if (t1 == goal) {\n            OUT(e + 1);\n            return 0;\n          } else if (!done.count(t1)) {\n            q.push({t1, e+1});\n            done.insert(t1);\n          }\n        }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <unordered_map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\nint main(){\n\t\n\tqueue<string> que;\n\t\n\tunordered_map<string, int> m;\n\t\n\tstring fs = \"\";\n\t\n\tfor(int i = 0; i < 9; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tfs += s;\n\t}\n\t\n\tque.push(fs);\n\t\n\tfor(int loop = 0; loop < 1000; loop++){\n\t\tif(que.empty()){\n\t\t\tbreak;\n\t\t}\n\t\tint sz = que.size();\n\t\tfor(int num = 0; num < sz; num++){\n\t\t\tstring str = que.front();\n\t\t\tque.pop();\n\t\t\tif(m.find(str) != m.end()){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tm[str] = loop;\n\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\tif(str[i] == '0'){\n\t\t\t\t\tif(i >= 3){\n\t\t\t\t\t\tswap(str[i], str[i - 3]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i - 3]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i < 6){\n\t\t\t\t\t\tswap(str[i], str[i + 3]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i + 3]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i % 3 > 0){\n\t\t\t\t\t\tswap(str[i], str[i - 1]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i - 1]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i % 3 < 2){\n\t\t\t\t\t\tswap(str[i], str[i + 1]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << m[\"123456780\"] << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<tr1/unordered_set>\n#include<cstring>\nusing namespace std;\nlong long m[10]={1};\nint f;\nlong long ans=0;\nint zon[10]={1,2,3,4,5,6,7,8,0};\nint fx[4]={1,-1,3,-3};\nint wz[10]={8,0,1,2,3,4,5,6,7};\ntr1::unordered_set<long long> s;\nvoid dfs(int use,long long sm,int tot){\n    if(use>tot || s.count(sm) || f) return;\n    if(ans==sm){\n        f=1;\n        return;\n    }\n    s.insert(sm);\n    int dt[9];\n    int p;\n    for(int i=8;i>=0;i--){\n        dt[i]=sm/m[i];\n        sm%=m[i];\n        if(dt[i]==0) p=i;\n    }\n    int u=0;\n    for(int i=1;i<9;i++){\n        u+=abs(i%3-wz[dt[i]]%3)+abs(i/3-wz[dt[i]]/3);\n    }\n    if(u+use*2>tot*2) return;\n    for(int i=0;i<4;i++){\n        if(p+fx[i]<0||p+fx[i]>8) continue;\n        dt[p]=dt[p+fx[i]];\n        dt[p+fx[i]]=0;\n        long long ssm=0;\n        for(int j=0;j<9;j++){\n            ssm+=dt[j]*m[j];\n        }\n        dfs(use+1,ssm,tot);\n        dt[p+fx[i]]=dt[p];\n        dt[p]=0;\n    }\n}\nint main(){\n    int dt[9];\n    for(int i=1;i<9;i++){\n        m[i]=m[i-1]*9;\n    }\n    long long sm=0;\n    for(int i=0;i<9;i++){\n        cin>>dt[i];\n        sm+=dt[i]*m[i];\n    }\n    for(int i=0;i<9;i++){\n        ans+=zon[i]*m[i];\n    }\n    for(int i=0;i<1000;i++){\n        s.clear();\n        dfs(0,sm,i);\n        if(f){\n            cout<<i<<\"\\n\";\n            break;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n    \n    bool operator < ( const Puzzle &p ) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {\n    -1, 0, 1, 0\n};\nstatic const int dy[4] = {\n    0, -1, 0, 1\n};\nstatic const char dir[4] = {\n    'u', 'l', 'd', 'r'\n};\n\nbool isTarget(Puzzle p) {\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != (i + 1)) return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle s) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n    \n    while( !Q.empty()) {\n        u = Q.front();\n        Q.pop();\n        if ( isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; r++) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if ( !V[v]) {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    \n    return \"unsolvable\";\n}\n\nint main() {\n    Puzzle in;\n    \n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\nconst int maxn = 10;\n\ntypedef struct Node{\n\tint a[maxn];\n\tint step;\n}Node;\n\nint arr[maxn],start[maxn];//start arr 分别是开始和目标状态 \nint cnt;//记录map的值 \nint dx[4] = {0,0,-1,1};\nint dy[4] = {-1,1,0,0};\nmap<int,int>mp;\n\nint bfs(){\n\tqueue<Node>que;\n\tNode node;\n\tmemcpy(node.a,start,sizeof(start));\n\tnode.step = 0;\n\tque.push(node);\n\twhile(!que.empty()){\n\t\t//for()...\n\t\tnode = que.front();\n\t\tque.pop();\n\t\tint index;\n\t\tfor(int i = 0; i<9; i++){\n\t\t\tif(node.a[i] == 0) index = i;\n\t\t}\n\t\tint r = index/3;\n\t\tint c = index%3;\n\t\tfor(int i = 0; i<4; i++){\n\t\t\tint nr = r + dx[i];\n\t\t\tint nc = c + dy[i];\n\t\t\tif(0<=nr && nr<3 && 0<=nc && nc<3){\n\t\t\t\tNode node_new;\n\t\t\t\tint index_new = nr*3 + nc;\n\t\t\t\tint sum = 0;\n\t\t\t\tmemcpy(node_new.a,node.a,sizeof(node.a));\t\t\t\t\n\t\t\t\tswap(node_new.a[index],node_new.a[index_new]);\n\t\t\t\tfor(int j = 0; j<9; j++){\n\t\t\t\t\tsum = sum*10 + node_new.a[j];\n\t\t\t\t}\n\t\t\t\tif(mp[sum] == 0){\n\t\t\t\t\tmp[sum] = cnt++;\n\t\t\t\t\tnode_new.step = node.step+1;\n\t\t\t\t\tif(memcmp(arr,node_new.a,sizeof(arr)) == 0){\n\t\t\t\t\t\treturn node_new.step;\n\t\t\t\t\t}\n\t\t\t\t\tque.push(node_new);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//if !vis[i] ...que.push\n\t}\n}\nint main()\n{\n\tint sum1 = 0, cnt = 0, sum = 0;\n\tfor(int i = 1; i<=8; i++){\n\t\tsum1 = sum1*10 + i;\n\t\tstart[i-1] = i; \n\t}\n\tsum1 = sum1*10;\n\tstart[8] = 0;\n\tmp[sum1] = cnt++;\n\tfor(int i = 0; i<9; i++){\n\t\tscanf(\"%d\",&arr[i]);\n\t\tsum = sum*10 + arr[i];\n\t}\n\tif(sum == sum1) printf(\"0\\n\");\n\telse{\n\t\tprintf(\"%d\\n\",bfs());\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>   \n#include<cstdio>  \n#include<algorithm>\n#include<queue>\n#include<map>\n#include<string>\nusing namespace std;\nconst int row = 3;\nconst int maxx = 9;\n\nstruct Puzzle {\n\tint f[maxx];\n\tint space;\n\tstring path;\n\tbool operator < (const Puzzle &p) const {\n\t\tfor (int i = 0; i < maxx; i++) {\n\t\t\tif (f[i] != p.f[i])\n\t\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nconst int dx[4] = { -1, 0, 1, 0 };\nconst int dy[4] = { 0, -1, 0 ,1 };\nconst char dir[4] = { 'u','l','d','r' };\n\nbool isTarget(Puzzle p) {\n\tfor (int i = 0; i < maxx; i++)\n\t\tif (p.f[i] != (i + 1))\n\t\t\treturn false;\n\treturn true;\n}\n\n\nstring bfs(Puzzle s) {\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\n\twhile (!Q.empty()) {\n\t\tu = Q.front(); Q.pop();\n\t\tif (isTarget(u))\n\t\t\treturn u.path;\n\t\tint sx = u.space / row;\n\t\tint sy = u.space % row;\n\t\tfor (int r = 0; r < 4; r++) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\n\t\t\tif (tx < 0 || ty < 0 || tx >= row || ty >= row)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * row + ty]);\n\t\t\tv.space = tx * row + ty;\n\t\t\tif (!V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolveable\";\n}\nint main()\n{\n\tPuzzle in;\n\tfor (int i = 0; i < maxx; i++) {\n\t\tcin >> in.f[i];\n\t\tif (in.f[i] == 0) {\n\t\t\tin.f[i] = maxx;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tprintf(\"%d\\n\", ans.size());\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   for(int i=0;i<(n);++i)\n#define SORT(c)    sort((c).begin(),(c).end())\n#define CLR(a)     memset((&a), 0 ,sizeof(a))//clear memory\n#define dump(x)    cerr << #x << \" = \" << (x) << endl;//debug\n#define debug(x)   cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define EPS        1e-10//sample:if((double)>=(double)+EPS)\n//cin,cout release\n//std::cin.tie(0);\n//ios::sync_with_stdio(false);\n\nusing namespace std;\n#define N 3\n#define N2 9\n#define LIMIT 100\n\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n\nint MDT[N2][N2];\n\nstruct puzzle {\n  int f[N2],space,MD;\n};\npuzzle state;\nint limit=100;\nint path[100];\n\nint getallmd(puzzle pz){\n  int sum=0;\n  rep(i,N2){\n    if(pz.f[i]==N2)continue;\n    sum+=MDT[i][pz.f[i]-1];\n  }\n  return sum;\n}\nbool isSolved(){\n  rep(i,N2)if(state.f[i]!=i+1)return 0;\n  return 1;\n}\nbool dfs(int depth,int prev){\n  if(state.MD==0){\n    return 1;\n  }\n  if(depth+state.MD>limit)return 0;\n  int sx=state.space/N;\n  int sy=state.space%N;\n  puzzle tmp;\n  rep(r,4){\n    int tx=sx+dx[r];\n    int ty=sy+dy[r];\n    if(tx<0||ty<0||tx>=N||ty>=N)continue;\n    if(max(prev,r)-min(prev,r)==2)continue;\n    tmp=state;\n    state.MD -= MDT[tx*N+ty][state.f[tx*N+ty]-1];\n    state.MD += MDT[sx*N+sy][state.f[tx*N+ty]-1];\n    swap(state.f[tx*N+ty],state.f[sx*N+sy]);\n    state.space = tx*N+ty;\n    if(dfs(depth+1,r)){\n      path[depth]=r;\n      return 1;\n    }\n    state=tmp;\n  }\n  return 0;\n}\n\nint iterative_deeping(puzzle in){\n  in.MD=getallmd(in);\n  for(limit=in.MD;limit<=LIMIT;limit++){\n    state=in;\n    if(dfs(0,-100)){\n      int ans=0;\n      rep(i,limit)ans+=1;\n      return ans;\n    }\n  }\n  return -1;\n}\n\n\n\nint main(){\n  rep(i,N2)rep(j,N2)MDT[i][j]=abs(i/N-j/N)+abs(i%N-j%N);\n  puzzle in;\n  rep(i,N2){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n   int ans = iterative_deeping(in);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nstruct state {\n    Board board;\n    int count;\n};\n\nqueue<state> q;\nset<Board> history;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    if (s.board == GOAL) {\n        return ++s.count;\n    }\n    if (history.insert(s.board).second) {\n        ++s.count;\n        q.push(s);\n    }\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\n// OK\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0; i < N; ) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            board |= static_cast<long long>((ch - '0')) << (i*4);\n            ++i;\n        }\n    }\n//    print(GOAL);\n//    print(board);\n\n    int count = 0;\n    if (board == GOAL) {\n        goto END;\n    }\n\n    q.push({ board, 0 });\n    while (!q.empty()) {\n        state s = q.front();\n        q.pop();\n\n        int pos = -1;\n        while (++pos < N) {\n            if (((s.board >> (pos*4)) & 15) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n    \n    bool operator < ( const Puzzle &p ) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {\n    -1, 0, 1, 0\n};\nstatic const int dy[4] = {\n    0, -1, 0, 1\n};\nstatic const char dir[4] = {\n    'u', 'l', 'd', 'r'\n};\n\nbool isTarget(Puzzle p) {\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != (i + 1)) return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle s) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n    \n    while( !Q.empty()) {\n        u = Q.front();\n        Q.pop();\n        if ( isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; r++) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if ( !V[v]) {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    \n    return \"unsolvable\";\n}\n\nint main() {\n    Puzzle in;\n    \n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n  bool operator < ( const Puzzle &p ) const {\n    for( int i = 0 ; i < N2 ; i++ ){\n      if( f[i] == p.f[i] ) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = { -1, 0, 1, 0};\nstatic const int dy[4] = { 0, -1, 0, 1};\nstatic const char dir[4] = { 'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  int i;\n  for( i = 0 ; i < N2 ; i++ ){\n    if( p.f[i] != ( i + 1 ) ) return false;\n  }\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  int i, a;\n  Puzzle  u ,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while( !Q.empty()){\n    u = Q.front();\n    Q.pop();\n    if( isTarget(u) ) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for( a = 0 ; a < 4 ; a++ ){\n      int tx = sx + dx[a];\n      int ty = sy + dy[a];\n      if( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n      v = u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space = tx * N + ty;\n      if( !V[v] ){\n\tV[v] = true;\n\tv.path += dir[a];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  int i;\n\n  for( i = 0 ; i < N2 ; i++ ){\n    cin >> in.f[i];\n    if( in.f[i] == 0 ){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <fstream>\n#include <queue>\n#include <vector>\n#include <time.h>\n#define PSIZE 3\n#define PPSIZE PSIZE * PSIZE\n#define NOTMOVED \"NOTMOVED\"\n#define SPACE '0'\n\nusing namespace std;\n\nstring GOAL = \"123456780\";\nint dist_table[PPSIZE][PPSIZE];\n\ntypedef enum Move {\n    UP,\n    DOWN,\n    LEFT,\n    RIGHT,\n    NOMOVE\n} Move;\n\ntypedef struct State State;\nstruct State {\n    int depth;\n    int dist;\n    string puzzle;\n    State* parent;\n};\n\nstruct comp {\n    bool operator()(const State* s1, const State* s2) {\n        return (s1->depth + s1->dist) > (s2->depth + s2->dist);\n    }\n};\n\nState* createState(int depth, int dist, string puzzle, State* parent);\nint findSpace(string puzzle);\nstring movePuzzle(string puzzle, Move move);\nint mdist(string p1);\nvoid createDistTable();\nvoid printDistTable();\nvoid printPath(State* state);\n\nint solve(string start_puzzle) {\n    int dist;\n    string moved = \"\";\n    State* curr_state = NULL;\n    State* next_state = NULL;\n\n    map<string, int> puzzle_table;\n    priority_queue<State*, vector<State*>, comp> pqueue;\n\n    curr_state = createState(0, 0, start_puzzle, NULL);\n    pqueue.push(curr_state);\n    puzzle_table[start_puzzle] = 0;\n    \n    while (!pqueue.empty()) {\n        curr_state = pqueue.top();\n        pqueue.pop();\n        \n        if (mdist(curr_state->puzzle) == 0) break;\n        \n        for (int mi = 0; mi <= NOMOVE; mi++) {\n            Move move = (Move)mi;\n            moved = movePuzzle(curr_state->puzzle, move);\n            if (moved == NOTMOVED) continue;\n            if (puzzle_table.find(moved) != puzzle_table.end() && puzzle_table[moved] < curr_state->depth+1) continue;\n            puzzle_table[moved] = curr_state->depth+1;\n            dist = mdist(moved);\n            next_state = createState(curr_state->depth+1, dist, moved, curr_state);\n            pqueue.push(next_state);\n        }\n    }\n  \n    //printPath(curr_state);\n\n    return curr_state->depth;\n\n}\n\nint main() {\n\n    createDistTable();\n    //printDistTable();\n\n\n    int out;\n    string line, puzzle;\n    for (int i = 0; i < PSIZE; i++) {\n        getline(cin, line);\n        puzzle += line[0];\n        puzzle += line[2];\n        puzzle += line[4];\n    }\n\n    out = solve(puzzle);\n\n    cout << out << endl;\n\n    return 0;\n}\n\nState* createState(int depth, int dist, string puzzle, State* parent) {\n    State* state = new State;\n    state->depth = depth;\n    state->dist = dist;\n    state->puzzle = puzzle;\n    state->parent = parent;\n    return state;\n}\n\nint mdist(string p1) {\n    int dist = 0;\n    int pi;\n    for (int i = 0; i < PPSIZE; i++) {\n        if (p1[i] == '0') continue;\n        pi = p1[i] - '1';\n        dist += dist_table[pi][i];\n    }\n    return dist;\n}\n\nint findSpace(string puzzle) {\n    size_t found = puzzle.find(SPACE);\n    if (found == string::npos) return -1;\n    return (int)found;\n}\n\nstring movePuzzle(string puzzle, Move move) {\n    int si = findSpace(puzzle);\n    if (si == -1) return NOTMOVED;\n   \n    string moved = puzzle;\n    if (move == UP) {\n        if (si < PSIZE) return NOTMOVED;\n        swap(moved[si], moved[si-3]);\n    } else if (move == DOWN) {\n        if (si >= PSIZE*(PSIZE-1)) return NOTMOVED;\n        swap(moved[si], moved[si+3]);\n    } else if (move == LEFT) {\n        if (si % PSIZE == 0) return NOTMOVED;\n        swap(moved[si], moved[si-1]);\n    } else if (move == RIGHT) {\n        if (si % PSIZE == PSIZE-1) return NOTMOVED;\n        swap(moved[si], moved[si+1]);\n    } else {\n        return NOTMOVED;\n    }\n    return moved;\n}\n\nvoid createDistTable() {\n    for (int i = 0; i < PPSIZE; i++) {\n        for (int j = 0; j < PPSIZE; j++) {\n            dist_table[i][j] = abs(i / PSIZE - j / PSIZE) + abs(i % PSIZE - j % PSIZE);\n        }\n    }\n}\n\nvoid printDistTable() {\n    for (int i = 0; i < PPSIZE; i++) {\n        for (int j = 0; j < PPSIZE; j++) {\n            cout << dist_table[i][j];\n        }\n        cout << endl;\n    }\n}\n\nvoid printPuzzle(string puzzle) {\n    cout << \"---\" << endl;\n    for (int i = 0; i < PSIZE; i++) {\n        for (int j = 0; j < PSIZE; j++) {\n            cout << puzzle[i*PSIZE+j];\n        }\n        cout << endl;\n    }\n    cout << \"---\" << endl;\n}\n\nvoid printPath(State* state) {\n    while (state != NULL) {\n        printPuzzle(state->puzzle);\n        state = state->parent;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tvector<int> ans = { 1, 2, 3, 4, 5, 6, 7, 8, 0 };\n\tvector<int> s(9);\n\tfor (int i = 0; i < 9; i++) {\n\t\tcin >> s[i];\n\t}\n\tmap<vector<int>, int> mp; mp[s] = 1;\n\tqueue<vector<int>> q; q.push(s);\n\twhile (!q.empty()) {\n\t\tauto p = q.front(); q.pop();\n\t\tif (p == ans) {\n\t\t\tcout << mp[p] - 1 << endl;\n\t\t\tbreak;\n\t\t}\n\t\tint zero;\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (p[i] == 0) {\n\t\t\t\tzero = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tauto cp = p;\n\t\tif ((zero + 1) % 3 != 0) {\n\t\t\tswap(cp[zero], cp[zero + 1]);\n\t\t\tif (mp[cp] == 0) {\n\t\t\t\tmp[cp] = mp[p] + 1;\n\t\t\t\tq.push(cp);\n\t\t\t}\n\t\t\tswap(cp[zero], cp[zero + 1]);\n\t\t}\n\t\tif (zero % 3 != 0) {\n\t\t\tswap(cp[zero], cp[zero - 1]);\n\t\t\tif (mp[cp] == 0) {\n\t\t\t\tmp[cp] = mp[p] + 1;\n\t\t\t\tq.push(cp);\n\t\t\t}\n\t\t\tswap(cp[zero], cp[zero - 1]);\n\t\t}\n\t\tif (zero < 6) {\n\t\t\tswap(cp[zero], cp[zero + 3]);\n\t\t\tif (mp[cp] == 0) {\n\t\t\t\tmp[cp] = mp[p] + 1;\n\t\t\t\tq.push(cp);\n\t\t\t}\n\t\t\tswap(cp[zero], cp[zero + 3]);\n\t\t}\n\t\tif (zero >= 3) {\n\t\t\tswap(cp[zero], cp[zero - 3]);\n\t\t\tif (mp[cp] == 0) {\n\t\t\t\tmp[cp] = mp[p] + 1;\n\t\t\t\tq.push(cp);\n\t\t\t}\n\t\t\tswap(cp[zero], cp[zero - 3]);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1e9\ntypedef long long ll;\n\nll getValue(vector<int> &v){\n  ll res = 0LL;\n  for(auto x : v){\n    res *= 10LL;\n    res += x;\n  }\n  return res;\n}\n\nvector<int> getState(ll x){\n  vector<int> res;\n  while(x > 0LL){\n    res.push_back(x%10LL);\n    x /= 10LL;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\npair<int,int> getPos(int x){\n  if(x == 0){\n    return make_pair(2,2);\n  }else{\n    x--;\n    return make_pair(x%3,x/3);\n  }\n}\n\nint getMD(ll x){\n  vector<int> v = getState(x);\n  int res = 0;\n  for(int i = 0 ; i < 9 ; i++){\n    pair<int,int> tp = getPos(v[i]);\n    res += abs(i%3-tp.first) + abs(i/3-tp.second);\n  }\n  return res;\n}\n\nint LIMIT;\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nbool inField(int x,int y){\n  return (0 <= x && x < 3 && 0 <= y && y < 3);\n}\n\nvoid print(vector<int> &v){\n  for(int i = 0 ; i < 3 ; i++){\n    for(int j = 0 ; j < 3 ; j++){\n      cout << v[i*3+j] << \" \";\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\nint ans;\n\nbool solve(int sp,ll st,int step,int prev){\n  int md = getMD(st);\n  if(md == 0){ ans = step; return true; }\n  if(md + step > LIMIT){\n    return false;\n  }\n  int x = sp%3, y = sp/3;\n  bool res = false;\n  for(int i = 0 ; i < 4 ; i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(!inField(nx,ny)){ continue; }\n    if(abs(i-prev) == 2){ continue; }\n    vector<int> v = getState(st);\n    int nsp = ny*3 + nx;\n    swap(v[sp],v[nsp]);\n    res |= solve(nsp,getValue(v),step+1,i);\n  }\n  return res;\n}\n\nint main(){\n  int sp = -1;\n  vector<int> v(9);\n  for(int i = 0 ; i < 9 ; i++){\n    cin >> v[i];\n    if(v[i] == 0){ sp = i; }\n  }\n  ll st = getValue(v);\n  ans = INF;\n  for(LIMIT = 0 ; LIMIT < 35 ; LIMIT++){\n    if(solve(sp,st,0,INF)){\n      cout << ans << endl;\n      break;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint limit=1,T[3][3];\n\nint evaluate(){\n  int cx[]={2,0,1,2,0,1,2,0,1},cy[]={2,0,0,0,1,1,1,2,2};\n  int ret=0;\n  for (int i=0;i<3;i++){\n    for (int j=0;j<3;j++){\n      int ti = T[i][j];\n      if (ti==0)continue;\n      ret+=abs(cx[ti]-j);\n      ret+=abs(cy[ti]-i);\n      // if (cx[ti]!=j||cy[ti]!=i)ret++;\n    }\n  }\n  return ret;\n}\n\nbool trymove(int c,int zx,int zy,int pzx,int pzy){\n  int dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n  if (evaluate()==0)return true;\n  if (c+evaluate()>limit)return false;\n  for (int i=0;i<4;i++){\n    if (0>zx+dx[i]||zx+dx[i]>2||0>zy+dy[i]||zy+dy[i]>2)continue;\n    if (zx+dx[i]==pzx&&zy+dy[i]==pzy)continue;\n    swap(T[zy][zx],T[zy+dy[i]][zx+dx[i]]);\n    if (trymove(c+1,zx+dx[i],zy+dy[i],zx,zy)) return true;\n    swap(T[zy][zx],T[zy+dy[i]][zx+dx[i]]);\n  }\n  return false;\n}\n\nint main(){\n  int zx,zy;\n  for (int i=0;i<3;i++){\n    for (int j=0;j<3;j++){\n      cin >> T[i][j];\n      if (T[i][j]==0){\n\tzx=j;\n\tzy=i;\n      }\n    }\n  }\n\n  while (true){\n    if (trymove(0,zx,zy,zx,zy))break;\n    limit++;\n  }\n  \n  cout << limit << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <string>\n#include <unordered_map>\n\nint main() {\n  std::unordered_map<std::string, int> ss;\n  std::queue<std::pair<std::string, int>> q;\n  q.push(std::make_pair(\"123456780\", 0));\n  ss[\"123456780\"] = 0;\n  while (q.size()) {\n    auto p = q.front();\n    q.pop();\n    auto s = p.first;\n    auto d = p.second;\n    auto z = std::find(s.begin(), s.end(), '0') - s.begin();\n    auto x = z % 3, y = z / 3;\n    int dxs[] = { 1, -1, 0, 0 }, dys[] = { 0, 0, 1, -1 };\n    for (size_t i = 0; i < 4; i++) {\n      int a = x + dxs[i], b = y + dys[i];\n      if (0 <= a && a < 3 && 0 <= b && b < 3) {\n        std::swap(s[3*y+x], s[3*b+a]);\n        if (ss.find(s) == ss.end()) {\n          ss[s] = d + 1;\n          q.push(std::make_pair(s, d + 1));\n        }\n        std::swap(s[3*y+x], s[3*b+a]);\n      }\n    }\n  }\n  std::string s;\n  for (size_t i = 0; i < 9; i++) {\n    int c;\n    scanf(\"%d\", &c);\n    s.push_back('0' + c);\n  }\n  printf(\"%d\\n\", ss[s]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i,n) for(UL i=0; i<(n); i++)\n\nUL E[9][9]={\n {0,1,0,1,0,0,0,0,0},\n {1,0,1,0,1,0,0,0,0},\n {0,1,0,0,0,1,0,0,0},\n {1,0,0,0,1,0,1,0,0},\n {0,1,0,1,0,1,0,1,0},\n {0,0,1,0,1,0,0,0,1},\n {0,0,0,1,0,0,0,1,0},\n {0,0,0,0,1,0,1,0,1},\n {0,0,0,0,0,1,0,1,0}\n};\n\nint main() {\n set<string> G;\n string S(9,' '); rep(i,9) scanf(\" %c\",&S[i]);\n queue<pair<string,UL>> Q; Q.push({S,0});\n while(Q.size()){\n  string P=move(Q.front().first);\n  UL d=Q.front().second;\n  UL p=P.find('0');\n  Q.pop();\n  if(P==\"123456780\"){cout<<d<<endl; break;}\n  if(G.count(P)) continue;\n  G.insert(P);\n  rep(j,9) {\n   if(!E[p][j]) continue;\n   swap(P[p],P[j]);\n   Q.push({P,d+1});\n   swap(P[p],P[j]);\n  }\n }\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <queue>\n\nint main() {\n    std::vector<int> pazzle(9);\n    for (int i = 0; i < 9; i++) {\n        std::cin >> pazzle[i];\n    }\n\n    std::map<std::vector<int>, int> m;\n    std::queue <std::pair<std::vector<int>, int> > q;\n\n    m[pazzle] = 0;\n    m[{1, 2, 3, 4, 5, 6, 7, 8, 0}] = 10000;\n\n    q.push({pazzle, 0});\n    while (!q.empty()) {\n        pazzle = q.front().first;\n        int num = q.front().second;\n        q.pop();\n        if (m[{1, 2, 3, 4, 5, 6, 7, 8, 0}] != 0 && m[{1, 2, 3, 4, 5, 6, 7, 8, 0}]  < num) break;\n        //if (m[pazzle] != 0 && m[pazzle] <= num) continue;\n\n        int space = std::find(pazzle.begin(), pazzle.end(), 0) - pazzle.begin();\n\n        if (space > 2) {\n            std::swap(pazzle[space], pazzle[space - 3]);\n            if (m.find(pazzle) == m.end() || m[pazzle] > num + 1) {\n                m[pazzle] = num + 1;\n                q.push({pazzle, num + 1});\n            }\n            std::swap(pazzle[space], pazzle[space - 3]);\n        }\n        if (space < 6) {\n            std::swap(pazzle[space], pazzle[space + 3]);\n            if (m.find(pazzle) == m.end() || m[pazzle] > num + 1) {\n                m[pazzle] = num + 1;\n                q.push({ pazzle, num + 1 });\n            }\n            std::swap(pazzle[space], pazzle[space + 3]);\n        }\n        if (space % 3 != 0) {\n            std::swap(pazzle[space], pazzle[space - 1]);\n            if (m.find(pazzle) == m.end() || m[pazzle] > num + 1) {\n                m[pazzle] = num + 1;\n                q.push({ pazzle, num + 1 });\n            }\n            std::swap(pazzle[space], pazzle[space - 1]);\n        }\n        if (space % 3 != 2) {\n            std::swap(pazzle[space], pazzle[space + 1]);\n            if (m.find(pazzle) == m.end() || m[pazzle] > num + 1) {\n                m[pazzle] = num + 1;\n                q.push({ pazzle, num + 1 });\n            }\n            std::swap(pazzle[space], pazzle[space + 1]);\n        }\n    }\n\n    std::cout << m[{1, 2, 3, 4, 5, 6, 7, 8, 0}] << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\n#include <queue>\nusing namespace std;\n\nstatic const int N = 3;\nstatic const char dir[4] = {'r', 'l', 'u', 'd'};\n\nclass Puzzle {\n public:\n  int v[N*N];\n  string path;\n  int space_pos;\n\n  bool operator < (const Puzzle &p) const {\n    for (int i = 0; i < N*N; i++) {\n      if (v[i] == p.v[i]) continue;\n      return v[i] < p.v[i];\n    }\n    return false;\n  }\n};\n\nbool isTarget(Puzzle& p) {\n  for (int i = 0; i < N*N; i++) {\n    if (p.v[i] != ((i+1) % (N*N))) {\n      return false;\n    }\n  }\n  return true;\n}\n\nstring bfs(Puzzle& p) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  p.path = \"\";\n  Q.push(p);\n  V[p] = true;\n  Puzzle new_u;\n  while(!Q.empty()) {\n    Puzzle u = Q.front();\n    Q.pop();\n    if (isTarget(u)) {\n      return u.path;\n    }\n    if (u.space_pos % 3 != 2) {\n      new_u = u;\n      swap(new_u.v[u.space_pos], new_u.v[u.space_pos+1]);\n      new_u.space_pos = u.space_pos+1;\n      if (!V[new_u]) {\n        V[new_u] = true;\n        new_u.path += dir[0];\n        Q.push(new_u);\n      }\n    }\n    if (u.space_pos % 3 != 0) {\n      new_u = u;\n      swap(new_u.v[u.space_pos], new_u.v[u.space_pos-1]);\n      new_u.space_pos = u.space_pos-1;\n      if (!V[new_u]) {\n        V[new_u] = true;\n        new_u.path += dir[1];\n        Q.push(new_u);\n      }\n    }\n    if (u.space_pos / 3 != 0) {\n      new_u = u;\n      swap(new_u.v[u.space_pos], new_u.v[u.space_pos-N]);\n      new_u.space_pos = u.space_pos-N;\n      if (!V[new_u]) {\n        V[new_u] = true;\n        new_u.path += dir[2];\n        Q.push(new_u);\n      }\n    }\n    if (u.space_pos / 3 != 2) {\n      new_u = u;\n      swap(new_u.v[u.space_pos], new_u.v[u.space_pos+N]);\n      new_u.space_pos = u.space_pos+N;\n      if (!V[new_u]) {\n        V[new_u] = true;\n        new_u.path += dir[3];\n        Q.push(new_u);\n      }\n    }\n  }\n}\n\n\nint main() {\n  Puzzle p;\n  for (int i = 0; i < N*N; i++) {\n    cin >> p.v[i];\n    if (!p.v[i]) p.space_pos = i;\n  }\n  cout << bfs(p).size() << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\n// 要素数\n#define N 3\n#define N2 N * N\n\n// 上,右,下,左の順でチェックする\nstatic const int dx[4] = {0,1,0,-1};\nstatic const int dy[4] = {-1,0,1,0};\nstatic const char dir[4] = {'u','r','d','l'};\n\nstruct Puzzle{\n    // 各々のタイルの状態(spaceは0だけど、9に換算する)\n    int tiles[N2];\n    // 空白の位置を管理indexで0 - 8まで\n    int space;\n    // 解法までのルートを記録\n    string path;\n    \n    // 同じ状態遷移か判定する\n    bool operator < (const Puzzle &p) const {\n        for(int i = 0;i < N2;++i){\n            if(tiles[i] == p.tiles[i]) continue;\n            // タイル数値が大きいと一致していると判定する\n            return tiles[i] < p.tiles[i];\n        }\n        return false;\n    }\n};\n\n/**\n    パズルの一致チェック\n*/\nbool isCorrect(Puzzle p){\n    // パズルが順番通り一致しているかチェック\n    for(int i = 0;i < N2;++i){\n        // 1,2,3,4,5,6,7,8の順で並ぶ\n        if(p.tiles[i] != (i + 1)){\n          return false;\n        }\n    }\n    return true;\n}\n\n// 幅優先探索を行う\nstring bfs(Puzzle p){\n    // queueを使って、パズルの状態遷移を管理する\n    queue<Puzzle> Q;\n    // 同じ遷移状態がないか判定するためにmapを定義する\n    map<Puzzle,bool> V;\n    Puzzle u,v;\n    p.path = \"\";\n    Q.push(p);\n    // 最初の状態遷移を保存\n    V[p] = true;\n    \n    // 幅優先探索\n    while(!Q.empty()){\n        u = Q.front();\n        Q.pop();\n        \n        // 正解チェック\n        if(isCorrect(u)){\n            return u.path;\n        }\n        // 空白の位置を算出する\n        int sx = u.space % N;\n        int sy = u.space / N;\n        \n        // スペースの周りの四方のタイルを動かす\n        for(int r = 0;r < 4;++r){\n            // 動かすタイルのindexを算出する(上,右,下,左の順)\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            // 範囲外チェック\n            if(tx < 0 || ty < 0 || tx >= N || ty >= N){\n                continue;\n            }\n            v = u;\n            // 入れ替え\n            swap(v.tiles[u.space],v.tiles[ty * N + tx]);\n            // 入れ替えた場所がspaceになる\n            v.space = (ty * N) + tx;\n            \n            // 同じ状態がでなかったら\n            if(!V[v]){\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main(){\n    Puzzle in;\n    \n    for(int i = 0;i < N2;++i){\n        cin >> in.tiles[i];\n        if(in.tiles[i] == 0){\n            // 空白は9として管理\n            in.tiles[i] = N2;\n            in.space = i;\n        }\n    }\n    \n    string answer = bfs(in);\n    cout << answer.size() << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n#define X 3\n#define Y 3\nint manhattan(int x1,int y1,int x2,int y2){\n\treturn abs(x1-x2)+abs(y1-y2);\n}\nint calc(vector<int>&v){\n\tint s=0;\n\tfor(int coor=0;coor<X*Y;coor++){\n\t\tif(v[coor]!=0){\n\t\t\ts+=manhattan(coor%X,coor/X,(v[coor]-1)%X,(v[coor]-1)/X);\n\t\t}else{\n\t\t\t//s+=manhattan(coor%X,coor/X,X-1,Y-1);\n\t\t}\n\t\t\t\n\t}\n\treturn s;\n}\nint main(){\n\tint i=1,start_point;\n\tvector<int>start(X*Y),goal;\n\tfor(;i<X*Y;i++)goal.push_back(i);goal.push_back(0);\n\tfor(i=0;i<X*Y;i++){\n\t\tscanf(\"%d\",&start[i]);\n\t\tif(start[i]==0)start_point=i;\n\t}\n\tif(start==goal){puts(\"0\");return 0;}\n\n\tmap<vector<int>,pair<int,int> >mstart;\n\tqueue<vector<int> >q;\n\tmstart[start]=make_pair(start_point,0);\n\tq.push(start);\n\tfor(;!q.empty();){\n\t\tvector<int> v=q.front();\n\t\tint val=calc(v);\n\t\tq.pop();\n\t\tmap<vector<int>,pair<int,int> >&m=mstart;\n\t\tint coor=m[v].first,x=coor%X,y=coor/X;\n\t\tint depth=m[v].second;\n\t\tif(0<x){\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val)m[v]=make_pair(coor-1,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t}\n\t\tif(x<X-1){\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val)m[v]=make_pair(coor+1,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t}\n\t\tif(0<y){\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val)m[v]=make_pair(coor-X,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t}\n\t\tif(y<Y-1){\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val)m[v]=make_pair(coor+X,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 25;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i) {\n        return;\n    }\n\n    if (in.path == \"ldrd\")\n        int debug = 0;\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n    /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<map>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int mx[4] = {0,-1,0,1};\nconst int my[4] = {-1,0,1,0};\nconst char itoc[10] = {'0','1','2','3','4','5','6','7','8','9'};\n\nint bfs(vector<int> p, string key) {\n    queue< pair<vector<int>,int> > q;\n    map<string,bool> m;\n    pair<vector<int>,int> a,b;\n    q.push(make_pair(p,0));\n    m[key] = true;\n\n    while(!q.empty()) {\n        a = q.front(); q.pop();\n        bool flg=true;\n        int blank;\n        for(int i=0; i<N2; i++) {\n            if(a.first[i]!=i+1) flg = false;\n            if(a.first[i]==N2) blank=i;\n        }\n        if(flg==true) return a.second;\n        int bx = blank%N, by = blank/N;\n        for(int i=0; i<4; i++) {\n            int x=bx+mx[i],y=by+my[i];\n            if(x<0 || x>=N || y<0 || y>=N) continue;\n            b = make_pair(a.first,a.second);\n            swap(b.first[y*N+x],b.first[blank]);\n            key=\"\";\n            for(int j=0; j<N2; j++) key += itoc[b.first[j]];\n            if(!m[key]) {\n                m[key] = true;\n                b.second+=1;;\n                q.push(b);\n            }\n        }\n\n\n    }\n    return 0;\n}\n\nint main() {\n    vector<int> init; int k;\n    string key=\"\";\n    for(int i=0; i<N2; i++) {\n        cin >> k; init.push_back(k);\n        if(init[i]==0) init[i]=N2;\n        key+=itoc[init[i]];\n    }\n    cout << bfs(init, key) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nconst ll R=3;\n\nll Hash(vector<vector<ll>> &A){\n    ll ret=0;\n    for(int i=0;i<R;i++){\n        for(int t=0;t<R;t++){\n            ret+=A[i][t];\n            if(i+1!=R || t+1!=R){\n                ret*=10;\n            }\n        }\n    }\n    return ret;\n}\n\nmap<ll,ll> M;\n\nvector<ll> dx={0,1,0,-1};\nvector<ll> dy={1,0,-1,0};\n\nstruct PZL{\n    ll hash;\n    vector<vector<ll>> A;\n    ll h,w;\n    ll d;\n};\n\n\nvoid bfs(vector<vector<ll>> A){\n    queue<PZL> Q;\n    Q.push({Hash(A),A,2,2,0});\n    M[Hash(A)]=0;\n    while(!Q.empty()){\n        PZL W=Q.front(); Q.pop();\n        for(int i=0;i<4;i++){\n            ll x=W.h+dx[i];\n            ll y=W.w+dy[i];\n            if(x<0 || y<0 || x>=R || y>=R){continue;}\n            PZL N=W;\n            swap(N.A[x][y],N.A[W.h][W.w]);\n            N.hash=Hash(N.A);\n            if(M.count(N.hash)){continue;}\n            N.h=x;\n            N.w=y;\n            M[N.hash]=++N.d;\n            Q.push(N);\n        }\n    }\n}\n\n\n\nint main(){\n    bfs({{1,2,3},{4,5,6},{7,8,0}});\n    vector<vector<ll>> A(3,vector<ll>(3));\n    for(int i=0;i<R;i++){\n        for(int t=0;t<R;t++){\n            cin>>A[i][t];\n        }\n    }\n    ll h=Hash(A);\n    cout<<M[h]<<endl;\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <stack>\n\nusing namespace std;\n\nint minimum=-1;\n\nvoid setNUM(int table[3][3], long long x){\n\tint S = 100000000;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int k=0;k<3;k++){\n\t\t\ttable[i][k] = x/S;\n\t\t\tx = x%S;\n\t\t\tS /= 10;\n\t\t}\n\t}\n}\n\nint getNUM(int x){\n\tswitch(x){\n\tcase 0:return 1;\n\tcase 1:return 1;\n\tcase 2:return 2;\n\tcase 3:return 6;\n\tcase 4:return 24;\n\tcase 5:return 120;\n\tcase 6:return 720;\n\tcase 7:return 5040;\n\tcase 8:return 40320;\n\t}\n\treturn -1;\n}\n\nlong long makeLong(int Table[3][3]){\n\treturn 100000000*Table[0][0]+10000000*Table[0][1]+1000000*Table[0][2]+\n            100000*Table[1][0]+10000*Table[1][1]+1000*Table[1][2]+ 100*Table[2][0]+\n            10*Table[2][1]+Table[2][2];\n}\n\n\nint calcDiffSum(int table[3][3]){\n\tint sum = 0;\n\tfor(int row=0;row<3;row++){\n\t\tfor(int col=0;col<3;col++){\n\t\t\tif(table[row][col] != 0){\n\t\t\t\tsum += abs((table[row][col]-1)/3-row) + abs((table[row][col]-1)%3-col);\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\n\nint zeroLoc(int table[3][3]){\n\tint zero_loc;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int k=0;k<3;k++){\n\t\t\tif(table[i][k]==0){\n\t\t\t\tzero_loc=10*i+k;\n\t\t\t}\n\t\t}\n\t}\n\treturn zero_loc;\n}\n\nint main(){\n\n\tint table[3][3];\n\tstack<long long>A,B;\n\n\n\tfor(int i=0;i<3;i++){\n\t\tscanf(\"%d %d %d\",&table[i][0],&table[i][1],&table[i][2]);\n\t}\n\n\tA.push(makeLong(table));\n\tlong long tmp;\n\tbool foundFLG=false;\n\n\tfor(int count=0;count < 362880;count++){\n\t\tif(count%2 == 0){\n\t\t\twhile(!A.empty()){\n\t\t\t\ttmp = A.top();\n\t\t\t\tA.pop();\n\t\t\t\tint tmpTable[3][3];\n\t\t\t\tsetNUM(tmpTable,tmp);\n\t\t\t\tif(calcDiffSum(tmpTable)==0){\n\t\t\t\t\tfoundFLG=true;\n\t\t\t\t\tprintf(\"%d\\n\",count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tint next_table[4][3][3];\n\n\t\t\t\tfor(int a=0;a<4;a++){\n\t\t\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\t\t\tnext_table[a][b][c] = tmpTable[b][c];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tswitch(zeroLoc(tmpTable)){\n\t\t\t\tcase 0:\n\t\t\t\t\tswap(next_table[0][0][0],next_table[0][0][1]);\n\t\t\t\t\tB.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][0][0],next_table[1][1][0]);\n\t\t\t\t\tB.push(makeLong(next_table[1]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tswap(next_table[0][0][1],next_table[0][0][0]);\n\t\t\t\t\tB.push(makeLong(next_table[0]));\n\t\t\t\t\tswap(next_table[1][0][1],next_table[1][0][2]);\n\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\tswap(next_table[2][0][1],next_table[2][1][1]);\n\t\t\t\t\tB.push(makeLong(next_table[2]));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tswap(next_table[0][0][2],next_table[0][0][1]);\n\t\t\t\t\tB.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][0][2],next_table[1][1][2]);\n\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:\n\t\t\t\t\tswap(next_table[0][1][0],next_table[0][0][0]);\n\t\t\t\t\tB.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][1][0],next_table[1][1][1]);\n\t\t\t\t\tB.push(makeLong(next_table[1]));\n\n\t\t\t\t\tswap(next_table[2][1][0],next_table[2][2][0]);\n\t\t\t\t\tB.push(makeLong(next_table[2]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 11:\n\t\t\t\t\tswap(next_table[0][1][1],next_table[0][0][1]);\n\t\t\t\t\tB.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][1][1],next_table[1][1][0]);\n\t\t\t\t\tB.push(makeLong(next_table[1]));\n\n\t\t\t\t\tswap(next_table[2][1][1],next_table[2][1][2]);\n\t\t\t\t\tB.push(makeLong(next_table[2]));\n\n\t\t\t\t\tswap(next_table[3][1][1],next_table[3][2][1]);\n\t\t\t\t\tB.push(makeLong(next_table[3]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 12:\n\t\t\t\t\tswap(next_table[0][1][2],next_table[0][0][2]);\n\t\t\t\t\tB.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][1][2],next_table[1][1][1]);\n\t\t\t\t\tB.push(makeLong(next_table[1]));\n\n\t\t\t\t\tswap(next_table[2][1][2],next_table[2][2][2]);\n\t\t\t\t\tB.push(makeLong(next_table[2]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 20:\n\t\t\t\t\tswap(next_table[0][2][0],next_table[0][1][0]);\n\t\t\t\t\tB.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][2][0],next_table[1][2][1]);\n\t\t\t\t\tB.push(makeLong(next_table[1]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 21:\n\t\t\t\t\tswap(next_table[0][2][1],next_table[0][2][0]);\n\t\t\t\t\tB.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][2][1],next_table[1][1][1]);\n\t\t\t\t\tB.push(makeLong(next_table[1]));\n\n\t\t\t\t\tswap(next_table[2][2][1],next_table[2][2][2]);\n\t\t\t\t\tB.push(makeLong(next_table[2]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 22:\n\t\t\t\t\tswap(next_table[0][2][2],next_table[0][1][2]);\n\t\t\t\t\tB.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][2][2],next_table[1][2][1]);\n\t\t\t\t\tB.push(makeLong(next_table[1]));\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}else{\n\t\t\twhile(!B.empty()){\n\t\t\t\ttmp = B.top();\n\t\t\t\tB.pop();\n\t\t\t\tint tmpTable[3][3];\n\t\t\t\tsetNUM(tmpTable,tmp);\n\t\t\t\tif(calcDiffSum(tmpTable)==0){\n\t\t\t\t\tfoundFLG=true;\n\t\t\t\t\tprintf(\"%d\\n\",count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\t\tint next_table[4][3][3];\n\n\t\t\t\tfor(int a=0;a<4;a++){\n\t\t\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\t\t\tnext_table[a][b][c] = tmpTable[b][c];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tswitch(zeroLoc(tmpTable)){\n\t\t\t\tcase 0: //??????\n\t\t\t\t\tswap(next_table[0][0][0],next_table[0][0][1]);\n\t\t\t\t\tA.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][0][0],next_table[1][1][0]);\n\t\t\t\t\tA.push(makeLong(next_table[1]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tswap(next_table[0][0][1],next_table[0][0][0]);\n\t\t\t\t\tA.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][0][1],next_table[1][0][2]);\n\t\t\t\t\tA.push(makeLong(next_table[1]));\n\n\t\t\t\t\tswap(next_table[2][0][1],next_table[2][1][1]);\n\t\t\t\t\tA.push(makeLong(next_table[2]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\t//??????\n\t\t\t\t\tswap(next_table[0][0][2],next_table[0][0][1]);\n\t\t\t\t\tA.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][0][2],next_table[1][1][2]);\n\t\t\t\t\tA.push(makeLong(next_table[1]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:\n\t\t\t\t\tswap(next_table[0][1][0],next_table[0][0][0]);\n\t\t\t\t\tA.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][1][0],next_table[1][1][1]);\n\t\t\t\t\tA.push(makeLong(next_table[1]));\n\n\t\t\t\t\tswap(next_table[2][1][0],next_table[2][2][0]);\n\t\t\t\t\tA.push(makeLong(next_table[2]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 11:\n\t\t\t\t\tswap(next_table[0][1][1],next_table[0][0][1]);\n\t\t\t\t\tA.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][1][1],next_table[1][1][0]);\n\t\t\t\t\tA.push(makeLong(next_table[1]));\n\n\t\t\t\t\tswap(next_table[2][1][1],next_table[2][1][2]);\n\t\t\t\t\tA.push(makeLong(next_table[2]));\n\n\t\t\t\t\tswap(next_table[3][1][1],next_table[3][2][1]);\n\t\t\t\t\tA.push(makeLong(next_table[3]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 12:\n\t\t\t\t\tswap(next_table[0][1][2],next_table[0][0][2]);\n\t\t\t\t\tA.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][1][2],next_table[1][1][1]);\n\t\t\t\t\tA.push(makeLong(next_table[1]));\n\n\t\t\t\t\tswap(next_table[2][1][2],next_table[2][2][2]);\n\t\t\t\t\tA.push(makeLong(next_table[2]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 20:\n\t\t\t\t\tswap(next_table[0][2][0],next_table[0][1][0]);\n\t\t\t\t\tA.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][2][0],next_table[1][2][1]);\n\t\t\t\t\tA.push(makeLong(next_table[1]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 21:\n\t\t\t\t\tswap(next_table[0][2][1],next_table[0][2][0]);\n\t\t\t\t\tA.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][2][1],next_table[1][1][1]);\n\t\t\t\t\tA.push(makeLong(next_table[1]));\n\n\t\t\t\t\tswap(next_table[2][2][1],next_table[2][2][2]);\n\t\t\t\t\tA.push(makeLong(next_table[2]));\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 22:\n\t\t\t\t\tswap(next_table[0][2][2],next_table[0][1][2]);\n\t\t\t\t\tA.push(makeLong(next_table[0]));\n\n\t\t\t\t\tswap(next_table[1][2][2],next_table[1][2][1]);\n\t\t\t\t\tA.push(makeLong(next_table[1]));\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(foundFLG)break;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nconst int N = 3;\nconst int dx[4] = {0,1,0,-1},dy[4] = {1,0,-1,0};\n\nint mat[N][N];\nint lim;\n\nint getMD(){\n  int sum = 0;\n  for(int i = 0; i < N; i++){\n    for(int j = 0; j < N; j++){\n      if(mat[i][j] == N*N-1) continue;\n      sum += abs(mat[i][j]/N-i) + abs(mat[i][j]%N-j);\n    }\n  }\n  return sum;\n}\n\nbool IDAstar(int depth,int prev,int py,int px){\n  int MD = getMD();\n  if(MD == 0) return true;\n  if(depth + MD > lim) return false;\n\n  for(int k = 0; k < 4; k++){\n    int ny = py + dy[k];\n    int nx = px + dx[k];\n    if(ny < 0 || N <= ny || nx < 0 || N <= nx) continue;\n    if(abs(k - prev) == 2) continue;\n    swap(mat[ny][nx],mat[py][px]);\n    if(IDAstar(depth+1,k,ny,nx)) return true;\n    swap(mat[ny][nx],mat[py][px]);\n  }\n  return false;\n}\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int py,px;\n  for(int i = 0; i < N; i++){\n    for(int j = 0; j < N; j++){\n      cin >> mat[i][j];\n      if(mat[i][j] == 0){\n        mat[i][j] = N*N;\n        py = i;\n        px = j;\n      }\n      mat[i][j]--;\n    }\n  }\n\n  for(lim = 0; lim < 100; lim++){\n    if(IDAstar(0,100,py,px)){\n      cout << lim << endl;\n      return 0;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Data = pair < string , int >;\n\nint main()\n{\n        string S = \"         \";\n        queue < Data > que;\n        set < string > used;\n        int d[4] = {-3, -1, 1, 3};\n\n        for ( int i = 0; i < 9; i++ ) cin >> S[i];\n        \n        que.emplace(S, 0);\n\n        while ( !que.empty() ) {\n                Data q = que.front(); que.pop();\n                string T;\n                if ( q.first == \"123456780\" ) {\n                        cout << q.second << endl;\n                        return ( 0 );\n                }\n                int pos = q.first.find('0');\n                for ( int i = 0; i < 4; i++ ) {\n                        int npos = pos + d[i];\n                        string T = q.first;\n                        if ( i == 1 && pos % 3 == 0 ) continue;\n                        if ( i == 2 && pos % 3 == 2 ) continue;\n                        if ( npos < 0 || 8 < npos ) continue;\n                        swap(T[pos], T[npos]);\n                        if ( used.find(T) == used.end() ) {\n                                used.insert(T);\n                                que.emplace(T, q.second + 1);\n                        }\n                }\n        }\n\n        return ( 0 );\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n\nstatic int board[9], goal[9] = { 1, 2, 3, 4, 5, 6, 7, 8, 0 };\n\nstatic bool rec(int n, int x, int y) {\n  if (n == 0)\n    return std::mismatch(board, board + 9, goal).first == board + 9;\n  int dxs[] = { 1, -1, 0, 0 }, dys[] = { 0, 0, 1, -1 };\n  for (size_t i = 0; i < 4; i++) {\n    int p = x + dxs[i], q = y + dys[i];\n    if (0 <= p && p < 3 && 0 <= q && q < 3) {\n      std::swap(board[3*y+x], board[3*q+p]);\n      if (rec(n - 1, p, q))\n        return true;\n      std::swap(board[3*y+x], board[3*q+p]);\n    }\n  }\n  return false;\n}\n\nint main() {\n  for (size_t i = 0; i < 9; i++)\n    scanf(\"%d\", board + i);\n  int z = std::find(board, board + 9, 0) - board;\n  int x = z % 3, y = z / 3;\n  for (int n = 0;; n++)\n    if (rec(n, x, y)) {\n      printf(\"%d\\n\", n);\n      break;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <algorithm>\nusing namespace std;\nconst int N = 3;\nconst int INF = 50;\nvector<vector<int> > cell(N, vector<int>(N));\nvector<vector<int> > ans = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};\nint q = 0;\nunordered_set<int> ms;\nint zero_x = 0;\nint zero_y = 0;\nint ministep = INF;\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\nint key(vector<vector<int> > cell)\n{\n\tint res = 0;\n\tint p = 1;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tres += cell[i][j] * p;\n\t\t\tp *= 10;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid solve(int i)\n{\n\tint p = key(cell);\n\tif (ms.find(p) != ms.end() || ministep < i) {\n\t\treturn;\n\t}\n\tif (p == q) {\n\t\tministep = min(ministep, i);\n\t\treturn;\n\t}\n\t\n\tms.insert(p);\n\tif (zero_x > 0) {\n\t\tswap(cell[zero_x][zero_y], cell[zero_x - 1][zero_y]);\n        zero_x--;\n\t\tsolve(i + 1);\n\t\tswap(cell[zero_x][zero_y], cell[zero_x + 1][zero_y]);\n        zero_x++;\n\t}\n\tif (zero_x < N - 1) {\n\t\tswap(cell[zero_x][zero_y], cell[zero_x + 1][zero_y]);\n        zero_x++;\n\t\tsolve(i + 1);\n\t\tswap(cell[zero_x][zero_y], cell[zero_x - 1][zero_y]);\n        zero_x--;\n\t}\n\tif (zero_y > 0) {\n\t\tswap(cell[zero_x][zero_y], cell[zero_x][zero_y - 1]);\n        zero_y--;\n\t\tsolve(i + 1);\n\t\tswap(cell[zero_x][zero_y], cell[zero_x][zero_y + 1]);\n        zero_y++;\n\t}\n\tif (zero_y < N - 1) {\n\t\tswap(cell[zero_x][zero_y], cell[zero_x][zero_y + 1]);\n        zero_y++;\n\t\tsolve(i + 1);\n\t\tswap(cell[zero_x][zero_y], cell[zero_x][zero_y - 1]);\n        zero_y--;\n\t}\n\tms.erase(p);\n}\n\nint main()\n{\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tcin >> cell[i][j];\n            if (cell[i][j] == 0) {\n                zero_x = i;\n                zero_y = j;\n            }\n\t\t}\n\t}\n\n\tq = key(ans);\n\tsolve(0);\n\tcout << ministep << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator < ( const Puzzle &p ) const {\n\t\tfor ( int i = 0; i < N2; i++ ) {\n\t\t\tif ( f[i] == p.f[i] ) continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\treturn false;\n\t}\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n\tfor ( int i = 0; i < N2; i++ )\n\t\tif (p.f[i] != (i + 1)) return false;\n\treturn true;\n}\n\nstring bfs(Puzzle s) {\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\nwhile ( !Q.empty()) {\n\tu = Q.front(); Q.pop();\n\tif ( isTarget(u) ) return u.path;\n\tint sx = u.space / N;\n\tint sy = u.space % N;\n\tfor ( int r = 0; r < 4; r++ ) {\n\t\tint tx = sx + dx[r];\n\t\tint ty = sy + dy[r];\n\t\tif ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n\t\tv = u;\n\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif ( !V[v] ) {\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"unsolvable\";\n}\n\nint main() {\n\tPuzzle in;\n\n\tfor (int i = 0; i < N2; i++ ) {\n\t\tcin >> in.f[i];\n\t\tif ( in.f[i] == 0 ) {\n\t\t\tin.f[i] = N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\nusing namespace std;\n\nstruct pz{\n\tint a[9];\n\tint t;\n\n\tbool operator < (const pz &p) const {\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (a[i] == p.a[i])\n\t\t\t\tcontinue;\n\t\t\treturn a[i] > p.a[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nint main()\n{\n\tpz p;\n\tint n = -1;\n\tmap<pz, bool> v;\n\n\tfor (int i = 0; i < 9; i++)\n\t\tcin >> p.a[i];\n\n\tp.t = 0;\n\n\tqueue<pz> que;\n\tque.push(p);\n\tv[p] = true;\n\n\twhile (!que.empty()) {\n\t\tpz g = que.front();\n\t\tque.pop();\n\n\t\tbool f = 1;\n\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tif (g.a[i] != (i + 1)) {\n\t\t\t\tf = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (f == 1) {\n\t\t\tn = g.t;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (g.a[i] == 0) {\n\t\t\t\tif(i % 3 != 0){\n\t\t\t\t\tg.t++;\n\t\t\t\t\tswap(g.a[i], g.a[i - 1]);\n\t\t\t\t\tif (!v[g]) {\n\t\t\t\t\t\tv[g] = true;\n\t\t\t\t\t\tque.push(g);\n\t\t\t\t\t}\n\t\t\t\t\tswap(g.a[i], g.a[i - 1]);\n\t\t\t\t\tg.t--;\n\t\t\t\t}\n\t\t\t\tif (i % 3 != 2) {\n\t\t\t\t\tg.t++;\n\t\t\t\t\tswap(g.a[i], g.a[i + 1]);\n\t\t\t\t\tif (!v[g]) {\n\t\t\t\t\t\tv[g] = true;\n\t\t\t\t\t\tque.push(g);\n\t\t\t\t\t}\n\t\t\t\t\tswap(g.a[i], g.a[i + 1]);\n\t\t\t\t\tg.t--;\n\t\t\t\t}\n\t\t\t\tif (i / 3 != 0) {\n\t\t\t\t\tg.t++;\n\t\t\t\t\tswap(g.a[i], g.a[i - 3]);\n\t\t\t\t\tif (!v[g]) {\n\t\t\t\t\t\tv[g] = true;\n\t\t\t\t\t\tque.push(g);\n\t\t\t\t\t}\n\t\t\t\t\tswap(g.a[i], g.a[i - 3]);\n\t\t\t\t\tg.t--;\n\t\t\t\t}\n\t\t\t\tif (i / 3 != 2) {\n\t\t\t\t\tg.t++;\n\t\t\t\t\tswap(g.a[i], g.a[i + 3]);\n\t\t\t\t\tif (!v[g]) {\n\t\t\t\t\t\tv[g] = true;\n\t\t\t\t\t\tque.push(g);\n\t\t\t\t\t}\n\t\t\t\t\tswap(g.a[i], g.a[i + 3]);\n\t\t\t\t\tg.t--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << n << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nconst int PATTERN = 362880;\nconst int FORWARD  = 1;\nconst int BACKWARD = 2;\nint frontier[PATTERN];\n\nstruct State {\n    Board board;\n    int count;\n};\n\nqueue<State> q;\n\n// I made this function based on one by Haruhiko Okumura(Algorithm \n// Dictionary, p116) and one by M.Hiroi(Puzzle DE Programming).\ninline int change_number(long long board) {\n    static int fact_table[N] = {\n         40320, 5040, 720, 120, 24, 6, 2, 1, 0      // on N = 8\n    };\n    int value = 0;\n    for (int j = 0; j < N - 1; ++j) {\n        int J = static_cast<int>((board >> (j*4) & 0xF));\n        value += fact_table[j] * J;\n        for (int k = j + 1; k < N; ++k) {\n            int K = static_cast<int>((board >> k*4) & 0xF);\n            if (J < K) {\n                board &= ~(0xFLL << k*4);\n                board |= (static_cast<long long>(K - 1) << k*4);\n            }\n        }\n    }\n//    printf(\"[change_number] value = %d\\n\", value);\n    return value;\n}\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 0xF;\n    board |= num << (spacepos*4);\n    board &= ~(0xFLL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, State s) {\n    int prev = change_number(s.board);\n    int direction = frontier[prev];\n//    printf(\"[swap&check] direction = %d\\n\", direction);\n    swap(numpos, spacepos, s.board);\n//    if (s.board == GOAL) {\n//        return ++s.count;\n//    }\n    int pos = change_number(s.board);\n    if (!frontier[pos]) {\n        ++s.count;\n        q.push(s);\n        frontier[pos] = direction;\n        return -1;\n    }\n    else if (frontier[pos] != direction) {\n        ++s.count;\n//        printf(\"[swap&check] s.count = %d\\n\", s.count);\n//        return s.count * 2 + direction - 1;\n        return s.count * 2;\n    }\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 0xF));\n    }\n    printf(\"\\n\");\n}\n\n// OK\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0, num; i < N; ++i) {\n        scanf(\"%d\", &num);\n        board |= static_cast<long long>(num) << (i*4);\n    }\n//    print(GOAL);\n//    print(board);\n\n    int count = 0;\n    if (board == GOAL) {\n        goto END;\n    }\n\n    frontier[change_number(board)] = FORWARD;\n    frontier[change_number(GOAL)] = BACKWARD;\n\n    q.push({ board, 0 });\n    q.push({ GOAL, 0 });\n    while (!q.empty()) {\n        State s = q.front();\n        q.pop();\n\n        int pos = -1;\n        while (++pos < N) {\n            if (((s.board >> (pos*4)) & 0xF) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvoid decodeboard(int board, vector<int>& brd) {\n\tfor(int i=0; i<9; ++i) {\n\t\tbrd[8-i]=board%10;\n\t\tboard/=10;\n\t}\n\treturn;\n}\n\nvoid encodeboard(int& board, vector<int>& brd) {\n\tboard=0;\n\tfor(int i=0; i<9; ++i) {\n\t\tboard*=10;\n\t\tboard+=brd[i];\n\t}\n\treturn;\n}\n\nint searchzero(vector<int> brd) {\n    for(int i=0; i<9; ++i){\n        if(brd[i]==0) return i;\n    }\n    return -1;\n}\n\nint main() {\n\tint board=0;\n\tint goal=123456780;\n\n\tvector<int> brd(9,0);\n\n\tfor(int i=0; i<9; ++i) {\n\t\tint temp;\n\t\tcin >> temp;\n\t\tboard*=10;\n\t\tboard+=temp;\n\t\tbrd[i]=temp;\n\t}\n\n\t// BFS\n\tqueue<P> q;\n\tunordered_set<int> checked;\n\tint cnt=0;\n\n\tq.push(P(board,0));\n\n\twhile(!q.empty()) {\n\t\tP p=q.front(); q.pop();\n\t\tboard=p.first; cnt=p.second;\n\t\tcnt=p.second;\n\t\tif(checked.count(board)!=0) continue;\n        if(board==goal) break;\n\t\tdecodeboard(board,brd); // board--->brd[]\n        ++cnt;\n        int zp=searchzero(brd);\n        switch(zp/3) {\n        case 0:\n            brd[zp]=brd[zp+3];\n            brd[zp+3]=0;\n            encodeboard(board,brd);\n            if(checked.count(board)==0) q.push(P(board,cnt));\n            brd[zp+3]=brd[zp];\n            brd[zp]=0;\n            break;\n        case 1:\n            brd[zp]=brd[zp-3];\n            brd[zp-3]=0;\n            encodeboard(board,brd);\n            if(checked.count(board)==0) q.push(P(board,cnt));\n            brd[zp-3]=brd[zp];\n            brd[zp]=0;\n\n            brd[zp]=brd[zp+3];\n            brd[zp+3]=0;\n            encodeboard(board,brd);\n            if(checked.count(board)==0) q.push(P(board,cnt));\n            brd[zp+3]=brd[zp];\n            brd[zp]=0;\n            break;\n        case 2:\n            brd[zp]=brd[zp-3];\n            brd[zp-3]=0;\n            encodeboard(board,brd);\n            if(checked.count(board)==0) q.push(P(board,cnt));\n            brd[zp-3]=brd[zp];\n            brd[zp]=0;\n            break;\n        }\n\n        switch(zp%3) {\n        case 0:\n            brd[zp]=brd[zp+1];\n            brd[zp+1]=0;\n            encodeboard(board,brd);\n            if(checked.count(board)==0) q.push(P(board,cnt));\n            brd[zp+1]=brd[zp];\n            brd[zp]=0;\n            break;\n        case 1:\n            brd[zp]=brd[zp+1];\n            brd[zp+1]=0;\n            encodeboard(board,brd);\n            if(checked.count(board)==0) q.push(P(board,cnt));\n            brd[zp+1]=brd[zp];\n            brd[zp]=0;\n\n            brd[zp]=brd[zp-1];\n            brd[zp-1]=0;\n            encodeboard(board,brd);\n            if(checked.count(board)==0) q.push(P(board,cnt));\n            brd[zp-1]=brd[zp];\n            brd[zp]=0;\n            break;\n        case 2:\n            brd[zp]=brd[zp-1];\n            brd[zp-1]=0;\n            encodeboard(board,brd);\n            if(checked.count(board)==0) q.push(P(board,cnt));\n            brd[zp-1]=brd[zp];\n            brd[zp]=0;\n            break;\n        }\n\t}\n\n\tcout << cnt << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    for(int i = 0 ; i < N2 ; i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] ={-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  for(int i = 0 ; i < N2 ; i++)\n    if(p.f[i] != (i + 1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle>Q;\n  map<Puzzle, bool>V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r = 0 ; r < 4 ; r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if(!V[v]){\n\tV[v] = true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i = 0 ; i < N2 ; i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout<< ans.size()<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n#define N 3\n#define N2 9\n\nstruct 8puzzle\n{\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator<(const 8puzzle & p) const\n    {\n        for (int i = 0; i < N2; i++)\n        {\n            if (f[i] == p.f[i])\n                continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\n\nbool isTarget(8puzzle p)\n{\n    for (int i = 0; i < N2; i++)\n        if (p.f[i] != (i + 1))\n            return false;\n    return true;\n}\n\nstring bfs(8puzzle s)\n{\n    queue<8puzzle> Q;\n    map<8puzzle, bool> V;\n    8puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while (!Q.empty())\n    {\n        u = Q.front();\n        Q.pop();\n        if (isTarget(u))\n            return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; r++)\n        {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N)\n                continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if (!V[v])\n            {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"\";\n}\n\nint main()\n{\n    8puzzle in;\n    for (int i = 0; i < N2; i++)\n    {\n        cin >> in.f[i];\n        if (in.f[i] == 0)\n        {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator <(const Puzzle &p) const {\n\t\tfor (int i = 0; i < N2; ++i) {\n\t\t\tif (f[i] == p.f[i])\n\t\t\t\tcontinue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nbool isTarget(Puzzle p) {\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif (p.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nconst int dx[4] { -1, 0, 1, 0 };\nconst int dy[4] { 0, -1, 0, 1 };\nconst char dir[4] { 'u', 'l', 'd', 'r' };\n\nstring bfs(Puzzle p) {\n\tqueue<Puzzle> Q;\n\tp.path = \"\";\n\tQ.push(p);\n\tmap<Puzzle, bool> M;\n\tM[p] = true;\n\tPuzzle u, v;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isTarget(u))\n\t\t\treturn u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!M[v]) {\n\t\t\t\tM[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unresolved\";\n}\n\nint main() {\n\tPuzzle p;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tcin >> p.f[i];\n\t\tif (p.f[i] == 0) {\n\t\t\tp.f[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(p);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<map>\nusing namespace std;\nqueue<pair<string,int> > Q;\n\nvoid Sw(string st,int x)\n{\n\tint i;\n\tint pos,npos;\n\tint d[4]={-3,3,-1,1};\n\tstring st1;\n\t\n\tfor(i=0;i<=8;i++)\n\t{\n\t\tif(st[i]=='0')\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(i=0;i<=3;i++)\n\t{\n\t\tst1=st;\n\t\tif(i==2 && pos%3==0) continue;\n\t\tif(i==3 && pos%3==0) continue;\n\t\tnpos=pos+d[i];\n\t\tif(npos>=9 || npos<=-1) continue;\n\t\tswap(st1[pos],st1[npos]);\n\t\tQ.push(pair<string,int>(st1,x+1));\n\t}\n}\n\nint main()\n{\n\tstring puzzle=\"\";\n\tstring goal=\"123456780\";\n\tmap<string,bool> M;\n\tint i,x;\n\tstring P;\n\t\n\tfor(i=0;i<=8;i++)\n\t{\n\t\tcin >> x;\n\t\tpuzzle+='0'+x;\n\t}\n\tQ.push(pair<string,int>(puzzle,0));\n\twhile(1)\n\t{\n\t\tpair<string,int> p=Q.front();\n\t\tQ.pop();\n\t\tP=p.first;\n\t\tx=p.second;\n\t\tif(P==goal)\n\t\t{\n\t\t\tcout << x << endl;\n\t\t\tbreak;\n\t\t}\n\t\tif(M[P]) continue;\n\t\telse M[P]=1;\n\t\tSw(P,x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\n#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define sz(x) ll(x.size())\n//typedef long long ll;\ntypedef long long ll;\n//typedef pair<int, int> P;\n//typedef pair<ll, ll> P;\n//const double INF = 1e10;\nconst ll INF = 10e15;\nconst ll MINF = -10e10;\n//const int INF = INT_MAX / 100;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n\n\n//ifstream myfile(\"~/Downloads/02.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\n\n//typedef priority_queue<P, vector<P>, greater<P> > PQ_ASK;\nconst int mod = 1000000007;\nconst double PI = 3.14159265358979323846;\n\ntypedef pair<ll, ll> P;\n\n\nstring to_upper(string str) {\n    int diff = 'a' - 'A';\n    for (int i = 0; i < str.size(); i++) {\n        char c = str[i];\n        if ('A' <= c && c <= 'Z') {\n            c += diff;\n            str[i] = c;\n        }\n    }\n    return str;\n}\n\nvector<int> up(vector<int> &board) {\n    auto it = find(board.begin(), board.end(), 0);\n    int id = distance(board.begin(), it);\n    if (id == 0 || id == 1 || id == 2) {\n        return vector<int>(0);\n    }\n    vector<int> res = board;\n    swap(res[id], res[id - 3]);\n    return res;\n}\n\nvector<int> down(vector<int> &board) {\n    auto it = find(board.begin(), board.end(), 0);\n    int id = distance(board.begin(), it);\n    if (id == 6 || id == 7 || id == 8) {\n        return vector<int>(0);\n    }\n    vector<int> res = board;\n    swap(res[id], res[id + 3]);\n    return res;\n}\n\nvector<int> right(vector<int> &board) {\n    auto it = find(board.begin(), board.end(), 0);\n    int id = distance(board.begin(), it);\n    if (id == 2 || id == 5 || id == 8) {\n        return vector<int>(0);\n    }\n    vector<int> res = board;\n    swap(res[id], res[id + 1]);\n    return res;\n}\n\nvector<int> left(vector<int> &board) {\n    auto it = find(board.begin(), board.end(), 0);\n    int id = distance(board.begin(), it);\n    if (id == 0 || id == 3 || id == 6) {\n        return vector<int>(0);\n    }\n    vector<int> res = board;\n    swap(res[id], res[id - 1]);\n    return res;\n}\n\nstruct Board {\n    vector<int> board;\n    int depth;\n};\n\nint bfs(vector<int> &board) {\n\n    vector<int> clear = {1, 2, 3, 4, 5, 6, 7, 8, 0};\n    set<vector<int> > used;\n\n    queue<Board> q;\n    q.push({board, 0});\n\n    while (!q.empty()) {\n        Board top = q.front();\n        q.pop();\n        if (top.board == clear) {\n            return top.depth;\n        }\n        if (used.find(top.board) != used.end()) {\n            continue;\n        }\n        used.insert(top.board);\n\n        vector<int> u = up(top.board),\n                d = down(top.board),\n                r = right(top.board),\n                l = left(top.board);\n\n        if (!u.empty()) {\n            q.push({u, top.depth + 1});\n        }\n        if (!d.empty()) {\n            q.push({d, top.depth + 1});\n        }\n        if (!r.empty()) {\n            q.push({r, top.depth + 1});\n        }\n        if (!l.empty()) {\n            q.push({l, top.depth + 1});\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    vector<int> board(9, 0);\n    rep(i, 9) cin >> board[i];\n\n    int ans = bfs(board);\n\n    cout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<queue>\n#define maxn 3\nusing namespace std;\n\nstruct Node\n{\n    int x,y;\n    int data[maxn][maxn];\n    int step;\n    friend bool operator ==(Node a,Node b)\n    {\n        bool flag=true;\n        for(int i=0;i<3;i++)\n            for(int j=0;j<3;j++)\n                if(a.data[i][j]!=b.data[i][j])\n                    {\n                        flag=false;\n                        break;\n                    }\n        return flag;\n    }\n\n    string covert_string()\n    {\n        string st=\"\";\n        for(int i=0;i<3;i++)\n            for(int j=0;j<3;j++)\n                st+=(data[i][j]-0+'0');\n        return st;\n    }\n};\nqueue<Node> q;\nmap<string,int> mp;\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\n\nvoid read(int &x){//读入正整数优化\n\tchar ch = getchar();x = 0;\n\tfor (; ch < '0' || ch > '9'; ch = getchar());\n\tfor (; ch >='0' && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n}\n\nint main()\n{\n    int i,j,k,t,x;\n    Node p,p_,aim;\n    for(i=0;i<maxn;i++)\n        for(j=0;j<maxn;j++)\n        {\n            read(x);\n            p.data[i][j]=x;\n            if(x==0)\n                p.x=i,p.y=j;\n        }\n    for(i=0;i<3;i++)\n        for(j=0;j<3;j++)\n            aim.data[i][j]=(i*3)+j+1;\n    aim.data[2][2]=0;\n    if(p==aim)\n    {\n        printf(\"0\\n\");\n        return 0;\n    }\n    p.step=0;\n    q.push(p);\n    mp[p.covert_string()]=1;\n    while(!q.empty())\n    {\n        p=q.front();\n        q.pop();\n        for(i=0;i<4;i++)\n        {\n            int xx=p.x+dx[i];\n            int yy=p.y+dy[i];\n            if(xx>=0&&xx<3&&yy>=0&&yy<3)\n            {\n                for(j=0;j<3;j++)\n                    for(k=0;k<3;k++)\n                        p_.data[j][k]=p.data[j][k];\n                swap(p_.data[xx][yy],p_.data[p.x][p.y]);\n                string st=p_.covert_string();\n                if(mp.count(st)==0)\n                {\n                    p_.x=xx,p_.y=yy,p_.step=p.step+1;\n                    if(p_==aim)\n                    {\n                        printf(\"%d\\n\",p_.step);\n                        return 0;\n                    }\n                    q.push(p_);\n                    mp[st]=1;\n                }\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <utility>\n#include <algorithm>\n#include <queue>\n#include <numeric>\n#include <unordered_map>\n\n\n    typedef std::vector<std::vector<int>> State;\n    const int N = 3;\n\n    State int_to_state(int c){\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n      FOR(i, N) {\n        FOR(j, N) {\n          int r = c%10;\n          c = c/10;\n          state[i][j] = r;\n        }\n      }\n      return state;\n    }\n    int state_to_int(State state) {\n      int c = 0;\n      int p = 1;\n      FOR(i, N) {\n        FOR(j, N) {\n          c += state[i][j] * p;\n          p *= 10;\n        }\n      }\n      return c;\n    }\n\n\n    void show(std::vector<std::vector<int>> state){\n      FOR(i, N) {\n        FOR(j, N) {\n          std::cout << state[i][j] << \" \";\n        }\n        std::cout << std::endl;\n      }\n    }\n\n    bool is_solved(const State& state) {\n      int N = state.size();\n\n      FOR(i, N) {\n        FOR(j, N) {\n          if(state[i][j] != (1 + 3*i + j)) return false;\n        }\n      }\n      return true;\n    }\n\n    std::vector<State> next_states_of(State state){\n      std::vector<State> res;\n      auto ns = state; std::swap(ns[0][0], ns[0][1]); res.push_back(ns);\n      ns = state; std::swap(ns[0][1], ns[0][2]); res.push_back(ns);\n      ns = state; std::swap(ns[1][0], ns[1][1]); res.push_back(ns);\n      ns = state; std::swap(ns[1][1], ns[1][2]); res.push_back(ns);\n      ns = state; std::swap(ns[2][0], ns[2][1]); res.push_back(ns);\n      ns = state; std::swap(ns[2][1], ns[2][2]); res.push_back(ns);\n      ns = state; std::swap(ns[0][0], ns[1][0]); res.push_back(ns);\n      ns = state; std::swap(ns[1][0], ns[2][0]); res.push_back(ns);\n      ns = state; std::swap(ns[0][1], ns[1][1]); res.push_back(ns);\n      ns = state; std::swap(ns[1][1], ns[2][1]); res.push_back(ns);\n      ns = state; std::swap(ns[0][2], ns[1][2]); res.push_back(ns);\n      ns = state; std::swap(ns[1][2], ns[2][2]); res.push_back(ns);\n//      std::cout << res.size() <<std::endl;\n      return res;\n    }\n\n    int solve_puzzle(State state){\n\n      std::priority_queue<\n        std::pair<int, int>,\n        std::vector<std::pair<int, int>>,\n        std::greater<std::pair<int, int>>\n      > q;\n      std::unordered_map<int, int> h;\n\n      q.push(std::make_pair(0, state_to_int(state)));\n\n      for(;not q.empty();){\n        auto d_s = q.top(); q.pop();\n        int d = d_s.first;\n        int st_int = d_s.second;\n        State state = int_to_state(d_s.second);\n//        show(state);\n\n        if(st_int == 987654321){\n//          std::cout << \"z\"<< std::endl;\n          return d;\n        }\n\n        if(h.find(st_int) == h.end()){\n          h[st_int] = d;\n          std::vector<State> next_states = next_states_of(state);\n          for(auto ns : next_states){\n            q.push(std::make_pair(d+1, state_to_int(ns)));\n          }\n        }\n      }\n      return -1;\n    }\n\n    int main(){\n      const int N = 3;\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n\n      FOR(i, N){\n        FOR(j, N){\n          GET(int, x);\n          if(x==0) x=9;\n          state[i][j] = x;\n        }\n      }\n//      show(state);\n//      int c = state_to_int(state);\n//      std::cout << c << std::endl;\n//      std::cout << \"?\" <<std::endl;\n//      State s2 = int_to_state(c);\n//      std::cout << \"!\" <<std::endl;\n//\n//      show(s2);\n//      int min_steps = rec_min_steps_\n      std::cout << solve_puzzle(state) << std::endl;\n      return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <algorithm>\nusing namespace std;\nconst int n = 3;\nstruct no{\n    int a[n][n];//棋盘\n    int x, y;//0所在的位置\n    string path;\n    bool operator < (const no &p) const {\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                if(a[i][j] == p.a[i][j]) continue;\n                return a[i][j] > p.a[i][j];\n            }\n        }\n        return false;\n    }\n};\nno s, g;\nint isEqual(no x, no y){\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if(x.a[i][j] != y.a[i][j]) return 0;\n        }\n    }\n    return 1;\n}\nvoid bfs(){\n    int dy[] = {-1, 0, 1, 0};//左，上，右，下\n    int dx[] = {0, -1, 0, 1};\n    string dr[] = {\"l\", \"u\", \"r\", \"d\"};\n    queue<no> q;\n    map<no, bool> used;\n    s.path = \"\";\n    q.push(s);\n    while(!q.empty()){\n        no t = q.front(); q.pop();\n        used[t] = true;\n        if(isEqual(t, g)){\n            cout<<t.path.length()<<endl;\n            break;\n        }\n        for(int i = 0; i < 4; i++){\n            int nx = t.x + dx[i];\n            int ny = t.y + dy[i];\n            if(0 <= nx && nx < n && 0 <= ny && ny < n){\n                no u;\n                u.x = nx; u.y = ny;\n                for(int k = 0; k < n; k++){\n                    for(int j = 0; j < n; j++){\n                        u.a[k][j] = t.a[k][j];\n                    }\n                }\n                u.a[t.x][t.y] = u.a[nx][ny]; u.a[nx][ny] = 0;\n                u.path = t.path;\n                if(!used[u]){\n                    u.path += dr[i];\n                    q.push(u);\n                }\n            }\n        }\n    }\n}\nint main(){\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            scanf(\"%d\", &s.a[i][j]);\n            if(s.a[i][j] == 0) {s.x = i; s.y = j; }\n            g.a[i][j] = n*i + (j+1);\n        }\n    }\n    g.a[n-1][n-1] = 0;\n    g.x = g.y = 2;\n    bfs();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n#define MAX 3\n#define MAX2 9\n\nstruct Puzzle{\n  int f[MAX2];\n  int space;\n  string path;\n  \n  bool operator < (const Puzzle &p) const{\n    for(int i=0;i<MAX2;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<MAX2;i++)if(p.f[i]!=(i+1))return false;\n  return true;\n}\nstring BFS(Puzzle s){\n  queue<Puzzle>Q;\n  map<Puzzle,bool>V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front();\n    Q.pop();\n    if(isTarget(u))return u.path;\n    int sx=u.space/MAX;\n    int sy=u.space%MAX;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0 || ty<0 || tx>=MAX || ty>=MAX)continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*MAX+ty]);\n      v.space=tx*MAX+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"umsolvable\";\n}\n\nint main() {\n  Puzzle in;\n  for(int i=0;i<MAX2;i++){\n    cin >> in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=MAX2;\n      in.space=i;\n    }\n  }\n  string ans=BFS(in);\n  cout << ans.size() << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<cmath>\n#include<cassert>\nusing namespace std;\nint inf = 1000000000;\n\nint dx[4] = {0,0,1,-1};\nint dy[4] = {1,-1,0,0};\n\nmap<string, int> mp;\n\nstring trans(vector< vector<int> > a){\n  string t = \"\";\n  for(int i=0; i<3; i++) for(int j=0; j<3; j++) t += to_string(a[i][j]);\n  return t;\n}\n\nvoid dfs(vector< vector<int> > a, int turn){\n  string t = trans(a);\n  if( mp[t] != 0 && turn > mp[t] ) return;\n  if( t == \"123456780\" ){\n    // cout << t << \" \" << turn << \" \" << mp[t] << endl;\n    mp[t] = turn;\n    return;\n  }\n  if( turn > 15 ) return;\n  mp[t] = turn;\n  // cerr << t << \" \" << mp[t] << endl;\n\n  for(int y=0; y<3; y++){\n    for(int x=0; x<3; x++){\n      if( a[y][x] == 0 ){\n        for(int d=0; d<4; d++){\n          int nx = x + dx[d]; int ny = y + dy[d];\n          if( nx < 0 || ny < 0 || nx >= 3 || ny >= 3 ) continue;\n          vector< vector<int> > b = a;\n          swap(b[ny][nx], b[y][x]);\n          string tt = trans(b);\n          dfs(b, turn + 1);\n        }\n      }\n    }\n  }\n  return;\n}\n\nint main(){\n\n  vector< vector<int> > a(3, vector<int>(3));\n  for(int i=0; i<3; i++) for(int j=0; j<3; j++) cin >> a[i][j];\n  mp[trans(a)] = 0;\n  mp[\"123456780\"] = inf;\n  dfs(a, 1);\n  cout << mp[\"123456780\"] - 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<string>\n\nusing namespace std;\n#define N 3\n#define M 9\n int i,j;\n//?§????????????????\nstruct Puzzle{\n  int f[M];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p)const{\n    for( i=0;i<M;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n  \n};\n////\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n///\nvoid swapp(int *p,int *q){\n  int tmp;\n  tmp=*p;\n  *p=*q;\n  *q=tmp;\n}\n///\nbool Target(Puzzle p){\n  for(i=0;i<M;i++)if(p.f[i]!=(i+1))return false;\n  return true;\n\n}\n///\n\n///\nstring bfs(Puzzle s){\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  queue<Puzzle> Q;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front();\n    Q.pop();\n    if(Target(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N)continue;\n      v=u;\n      swapp(&v.f[u.space],&v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      } \n    }\n  }\n  return \"unsolvable\";\n}\n///\n\nint main(){\n  Puzzle in;\n\n  for(i=0;i<M;i++){\n    cin >>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=M;\n      in.space=i;\n    }\n  }\n\n  string ans=bfs(in);\n  cout << ans.size() << endl;\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <list>\n#include <string>\n#include <map>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nstruct state {\n    Board board;\n    int count;\n};\n\nlist<state> q;\nmap<Board,char> history;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    map<Board,char>::iterator it = history.find(s.board);\n    if (it != history.end()) {\n        return -1;\n    }\n    history.insert(make_pair(s.board, ' '));\n    ++s.count;\n    if (s.board == GOAL) {\n        return s.count;\n    }\n    q.push_back(s);\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0; i < N; ) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            board |= static_cast<long long>((ch - '0')) << (i*4);\n            ++i;\n        }\n    }\n\n    if (board == GOAL) {\n        printf(\"0\\n\");\n        return 0;\n    }\n\n//    print(GOAL);\n//    print(board);\n\n    q.push_back({ board, 0 });\n    int count = 0;\n    while (!q.empty()) {\n        state s = q.front();\n        q.pop_front();\n        // ?????????????????????\n        int pos = -1;\n        while (++pos < N) {\n            if (((s.board >> (pos*4)) & 15) == 0) {\n                break;\n            }\n        }\n//        for (pos = 0; pos < N; ++pos) {\n//            if (((s.board >> (pos*4)) & 15) == 0) {\n//                break;\n//            }\n//        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fi       first\n#define se       second\n#define sf       scanf\n#define pf       printf\n#define mp       make_pair\n#define pb       push_back\n#define si(x)    scanf(\"%d\", &x)\n#define pi(x)    printf(\"%d\\n\", x)\n#define sl(x)    scanf(\"%lld\", &x)\n#define pl(x)    printf(\"%lld\\n\", x)\n#define all(x)   x.begin(), x.end()\n#define READ(f)  freopen(f, \"r\", stdin)\n#define WRITE(f) freopen(f, \"w\", stdout)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef map<ll, ll> mll;\ntypedef pair<ll, ll> pll;\ntypedef map<int, int> mii;\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\n\nconst ll MAX = 100005;\nconst ll MOD = 1000000007;\nconst ll INF = 1000000000000000;\nconst double PI = 2 * acos(0.0);\nconst double EPS = 0.00000000001;\n\nclass vState {\npublic:\n    int cpuz[3][3];\n};\n\nclass node {\npublic:\n    int g, h, f, zeroI, zeroJ, puzzle[3][3];\n    bool operator < (const node &a) const {\n        return a.f < f;\n    }\n};\n\nint goal[3][3];\nvector<vState> visit;\n\nint calc_heuristic(int puzzle[][3]) {\n    int h = 0;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (goal[i][j] != puzzle[i][j]) h++;\n        }\n    }\n    return h;\n}\n\nvoid set_goal_state() {\n    //pf(\"- Goal State -\\n\\n\");\n    goal[0][0] = 1;\n    goal[0][1] = 2;\n    goal[0][2] = 3;\n    goal[1][0] = 4;\n    goal[1][1] = 5;\n    goal[1][2] = 6;\n    goal[2][0] = 7;\n    goal[2][1] = 8;\n    goal[2][2] = 0;\n    //pf(\"\\n\");\n}\n\nnode set_current_state() {\n    node cur;\n    //pf(\"- Current State -\\n\");\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            si(cur.puzzle[i][j]);\n            if (cur.puzzle[i][j] == 0) {\n                cur.zeroI = i;\n                cur.zeroJ = j;\n            }\n        }\n    }\n    //pf(\"\\n\");\n    cur.h = calc_heuristic(cur.puzzle);\n    cur.g = 0;\n    cur.f = cur.g + cur.h;\n    return cur;\n}\n\nvoid print_state(node x) {\n    pf(\"._______.\\n\");\n    for (int i = 0; i < 3; i++) {\n        pf(\"| \");\n        for (int j = 0; j < 3; j++) {\n            pf(\"%d \", x.puzzle[i][j]);\n        }\n        pf(\"|\\n\");\n    }\n    pf(\"---------\\n\");\n    pf(\"H(n) = %d\\n\", x.h);\n    pf(\"G(n) = %d\\n\", x.g);\n    pf(\"F(n) = %d\\n\\n\", x.f);\n}\n\nbool already_visited(int puzzle[][3]) {\n    for (int i = 0; i < visit.size(); i++) {\n        int flag = true;\n        for (int j = 0; j < 3; j++) {\n            for (int k = 0; k < 3; k++) {\n                if (puzzle[j][k] != visit[i].cpuz[j][k]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (!flag) break;\n        }\n        if (flag) return true;\n    }\n    return false;\n}\n\nbool check_if_goal(int puzzle[][3]) {\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (puzzle[i][j] != goal[i][j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nnode copy_puzzle(int puzzle[][3]) {\n    node x;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            x.puzzle[i][j] = puzzle[i][j];\n        }\n    }\n    return x;\n}\n\nvState copy_puzzle2(int puzzle[][3]) {\n    vState x;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            x.cpuz[i][j] = puzzle[i][j];\n        }\n    }\n    return x;\n}\n\nint astar(node cur) {\n    priority_queue<node> pq;\n    pq.push(cur);\n    int steps = 0;\n    while (!pq.empty()) {\n        steps++;\n        node u = pq.top();\n        //print_state(u);\n        visit.pb( copy_puzzle2(u.puzzle) );\n        while (!pq.empty()) pq.pop(); // clearing queue\n        if (check_if_goal(u.puzzle)) break;\n        // check the moves that can be made from current state\n        // if any moves is already made we will not pass that in the queue, this is to avoid infinite loops\n        if (u.zeroI - 1 >= 0 && goal[u.zeroI - 1][u.zeroJ] != u.puzzle[u.zeroI - 1][u.zeroJ]) {\n            /// UP\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI - 1][u.zeroJ], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.zeroI = u.zeroI - 1;\n                v.zeroJ = u.zeroJ;\n                pq.push(v);\n            }\n        }\n        if (u.zeroI + 1 < 3 && goal[u.zeroI + 1][u.zeroJ] != u.puzzle[u.zeroI + 1][u.zeroJ]) {\n            /// DOWN\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI + 1][u.zeroJ], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.zeroI = u.zeroI + 1;\n                v.zeroJ = u.zeroJ;\n                pq.push(v);\n            }\n        }\n        if (u.zeroJ - 1 >= 0 && goal[u.zeroI][u.zeroJ - 1] != u.puzzle[u.zeroI][u.zeroJ - 1]) {\n            /// LEFT\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI][u.zeroJ - 1], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.zeroI = u.zeroI;\n                v.zeroJ = u.zeroJ - 1;\n                pq.push(v);\n            }\n        }\n        if (u.zeroJ + 1 < 3 && goal[u.zeroI][u.zeroJ + 1] != u.puzzle[u.zeroI][u.zeroJ + 1]) {\n            /// RIGHT\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI][u.zeroJ + 1], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.zeroI = u.zeroI;\n                v.zeroJ = u.zeroJ + 1;\n                pq.push(v);\n            }\n        }\n     }\n     return steps;\n}\n\nint main() {\n    set_goal_state();\n    node cur = set_current_state();\n    pf(\"%d\\n\", astar(cur) - 1);\n\n    return 0;\n}\n\n\n/*\n\nTEST 1\n------\n0 1 2\n3 4 5\n6 7 8\n\n7 2 4\n5 0 6\n8 3 1\n\nTEST 2\n------\n1 2 3\n4 5 6\n7 8 0\n\n1 2 0\n4 5 3\n7 8 6\n\nTEST 3\n------\n1 2 3\n8 0 4\n7 6 5\n\n3 6 4\n0 1 2\n8 7 5\n\nTEST 4\n------\n1 2 3\n8 0 4\n7 6 5\n\n1 3 4\n8 6 2\n0 7 5\n\nTEST 5\n------\n1 2 3\n8 0 4\n7 6 5\n\n1 3 4\n8 0 5\n7 2 6\n\nTEST 6 // WORST CASE\n------\n1 2 3\n4 5 6\n7 8 0\n\n6 4 7\n8 5 0\n3 2 1\n\n8 6 7\n2 5 4\n3 0 1\n\n*/\n\n\n"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 20;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n        return;\n    }\n    if (ms[in] || ministep < i) {\n        return;\n    }\n\n    if (in.path == \"ldrd\")\n        int debug = 0;\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n        /* test */\n//        cout << \"(i = \" << i << \") \" << in.path << endl;\n//        for (int j = 0; j < N2; j++)\n//            cout << \" \" << in.f[j];\n//        cout << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n//    ms[in] = true;\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n#define N 3\n\nint po[N*N+10];\nint m2i(mat m){\n  int res=0;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      res+=m[i][j]*po[i*N+j];\n  return res;\n}\nmat i2m(int x){\n  mat res(N,vec(N));;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      res[i][j]=(x%po[i*N+j+1])/po[i*N+j];\n  return res;\n}\n\nsigned main(){\n  po[0]=1;\n  for(int i=0;i<N*N;i++) po[i+1]=po[i]*10;\n  mat p(N,vec(N));\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      cin>>p[i][j];\n  mat e(p);\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      e[i][j]=i*N+j+1;\n  e[N-1][N-1]=0;\n  int ans=m2i(e);\n  queue<int> q;\n  map<int,int> m;\n  q.push(m2i(p));\n  m[m2i(p)]=0;\n  int ax[]={1,0,-1,0};\n  int ay[]={0,1,0,-1};\n  while(!q.empty()){\n    int x=q.front();q.pop();\n    if(x==ans) break;\n    p=i2m(x);\n    int zy,zx;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n        if(p[i][j]==0) zy=i,zx=j;\n    for(int k=0;k<4;k++){\n      int ny=zy+ay[k],nx=zx+ax[k];\n      if(ny<0||N<=ny||nx<0||N<=nx) continue;\n      swap(p[zy][zx],p[ny][nx]);\n      int t=m2i(p);\n      if(!m.count(t)){\n        m[t]=m[x]+1;\n        q.push(t);\n      }\n      swap(p[zy][zx],p[ny][nx]);\n    }\n  }\n  cout<<m[ans]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include \"puzzle.h\"\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> Vector;\ntypedef vector<vector<ll>> DVector;\n\n#define fi          first\n#define se          second\n#define pb          push_back\n#define INF         INT_MAX/3\n#define bcnt        __builtin_popcount\n#define all(x)      (x).begin(),(x).end()\n#define dbg(x)      cout<<#x\"=\"<<x<<endl\n#define ub(x,y)     upper_bound(all(x),y)-x.begin()\n#define lb(x,y)     lower_bound(all(x),y)-x.begin()\n#define uni(x)      x.erase(unique(all(x)),x.end())\n#define rep(i,n)    repl(i,0,n-1)\n#define repl(i,a,b) for(ll i=(ll)(a);i<=(ll)(b);i++)\n#define mmax(x,y)   (x>y?x:y)\n#define mmin(x,y)   (x<y?x:y)\n#define maxch(x,y)  x=mmax(x,y)\n#define minch(x,y)  x=mmin(x,y)\n#define exist(x,y)  (find(all(x),y)!=x.end())\n#define each(itr,v) for(auto itr:v)\n#define usort(x)    sort(all(x))\n#define dsort(x)    sort(all(x),greater<int>())\n#define mkp(x,y)    make_pair(x,y)\n#define N 3\n\n\nll seach_count = 0;\n\nint h0(DVector tmp){\n  return 0;\n}\n\nint h1(DVector &tmp){\n  int ct = 0;\n  rep(i,N)rep(j,N)if(amp[i][j] != tmp[i][j] && tmp[i][j] != 0 )ct++;\n  return ct;\n}\n\nint h2(int n){\n\n}\n\nbool as(){\n\n}\n\n\nint main(){\n  cin.sync_with_stdio(false);\n  int mp[N][N];\n  create_puzzle(mp);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<cstdlib>\n#include<utility>\nusing namespace std;\n\nclass State{\npublic:\n    vector<vector<int>> puzzle;\n    int zero_col, zero_row, prev_zero_col, prev_zero_row;\n    int edge_len, heuristic;\n    State(vector<vector<int>>& arr, const int& zc, const int& zr, const int& pzc, const int& pzr, const int& h): puzzle(arr), zero_col(zc), zero_row(zr), prev_zero_col(pzc), prev_zero_row(pzr), heuristic(h) {\n        edge_len = arr.size();\n    }\n    int get_manhattan_diff(const int& new_zero_col, const int& new_zero_row){\n        int diff = 0;\n        diff += abs((puzzle[new_zero_row][new_zero_col]-1)/edge_len - zero_row) + abs((puzzle[new_zero_row][new_zero_col]-1)%edge_len - zero_col) - abs((puzzle[new_zero_row][new_zero_col]-1)/edge_len - new_zero_row) - abs((puzzle[new_zero_row][new_zero_col]-1)%edge_len - new_zero_col);\n        return diff;\n    }\n    vector<State> get_next_states(){\n        vector<State> res;    \n        vector<vector<int>> tmp;\n        int diff;\n        if(zero_col+1 < edge_len && prev_zero_col != zero_col+1){\n            diff = get_manhattan_diff(zero_col+1, zero_row);\n            tmp = puzzle;\n            swap(tmp[zero_row][zero_col], tmp[zero_row][zero_col+1]);\n            res.push_back(State(tmp, zero_col+1, zero_row, zero_col, zero_row, heuristic + diff));\n        }\n        if(zero_col-1 >= 0 && prev_zero_col != zero_col-1){\n            diff = get_manhattan_diff(zero_col-1, zero_row);\n            tmp = puzzle;\n            swap(tmp[zero_row][zero_col], tmp[zero_row][zero_col-1]);\n            res.push_back(State(tmp, zero_col-1, zero_row, zero_col, zero_row, heuristic + diff));\n        }\n        if(zero_row+1 < edge_len && prev_zero_row != zero_row+1){\n            diff = get_manhattan_diff(zero_col, zero_row+1);\n            tmp = puzzle;\n            swap(tmp[zero_row][zero_col], tmp[zero_row+1][zero_col]);\n            res.push_back(State(tmp, zero_col, zero_row+1, zero_col, zero_row, heuristic + diff));\n        }\n        if(zero_row-1 >= 0 && prev_zero_row != zero_row-1){\n            diff = get_manhattan_diff(zero_col, zero_row-1);\n            tmp = puzzle;\n            swap(tmp[zero_row][zero_col], tmp[zero_row-1][zero_col]);\n            res.push_back(State(tmp, zero_col, zero_row-1, zero_col, zero_row, heuristic + diff));\n        }\n        return res;\n    }\n};\n\nint get_sum_manhattan(vector<vector<int>>& state){\n    int edge_len = state.size(), res = 0;\n    for(int i = 0; i < edge_len; i++){\n        for(int j = 0; j < edge_len; j++){\n            if(state[i][j] != 0)\n                res += abs((state[i][j]-1)/edge_len - i) + abs((state[i][j]-1)%edge_len -j); \n        }\n    }\n    return res;\n}\n\nbool DLS(State& state, const int& limit, const int& depth){\n    if(depth + state.heuristic > limit) return false;\n    if(state.heuristic == 0) return true;\n    vector<State> next_states = state.get_next_states();\n    for(State s : next_states){\n        if(DLS(s, limit, depth+1)) return true;\n    }\n    return false;\n}\n\nint IDA(State& initial_state, const int& max_step){\n    for(int l = 0; l <= max_step; l++){\n        if(DLS(initial_state, l, 0))\n            return l;\n    }\n    return -1;\n}\n\nint main(){\n    int max_step = 45;\n    int edge_len = 3;\n    int x, zr, zc;\n    vector<vector<int>> puzzle(edge_len, vector<int>(edge_len));\n    for(int i = 0; i < edge_len; i++){\n        for(int j = 0; j < edge_len; j++){\n            scanf(\"%d\", &x);\n            if(x == 0){\n                zr = i; zc = j;\n            }\n            puzzle[i][j] = x;\n        }\n    }\n    State initial_state = State(puzzle, zc, zr, zc, zr, get_sum_manhattan(puzzle));\n    printf(\"%d\\n\", IDA(initial_state, max_step));\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstruct r{\n\tint men[3][3];\n\tint cnt;\n};\nbool used[9][9][9][9][9][9][9][9][9];\nint main(){\n\tint i,j,dx[4]={0,1,0,-1},dy[4]={-1,0,1,0},k,temp,menc[3][3]={{1,2,3},{4,5,6},{7,8,0}};\n\tr f,v;\n\tqueue<r> q;\n\tmemset(used,0,sizeof(used));\n\tfor(i=0;i<3;i++){\n\t\tfor(j=0;j<3;j++){\n\t\t\tcin>>f.men[i][j];\n\t\t}\n\t}\n\tf.cnt=0;\n\tq.push(f);\n\twhile(!q.empty()){\n\t\tf=q.front();\n\t\tq.pop();\n\t\tused[f.men[0][0]][f.men[0][1]][f.men[0][2]][f.men[1][0]][f.men[1][1]][f.men[1][2]][f.men[2][0]][f.men[2][1]][f.men[2][2]]=true;\n\t\tint o=0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tfor(j=0;j<3;j++){\n\t\t\t\tif(f.men[i][j]!=menc[i][j]){\n\t\t\t\t\to=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(o==0)break;\n\t\tint b=0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tfor(j=0;j<3;j++){\n\t\t\t\tif(f.men[i][j]==0){\n\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\tif(i+dy[k]>=0&&i+dy[k]<3&&j+dx[k]>=0&&j+dx[k]<3){\n\t\t\t\t\t\t\tv=f;\n\t\t\t\t\t\t\ttemp=v.men[i][j];\n\t\t\t\t\t\t\tv.men[i][j]=v.men[i+dy[k]][j+dx[k]];\n\t\t\t\t\t\t\tv.men[i+dy[k]][j+dx[k]]=temp;\n\t\t\t\t\t\t\tv.cnt++;\n\t\t\t\t\t\t\tif(used[v.men[0][0]][v.men[0][1]][v.men[0][2]][v.men[1][0]][v.men[1][1]][v.men[1][2]][v.men[2][0]][v.men[2][1]][v.men[2][2]]==false){\n\t\t\t\t\t\t\t\tq.push(v);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb=1;\n\t\t\t\t}\n\t\t\t\tif(b==1)break;\n\t\t\t}\n\t\t\tif(b==1)break;\n\t\t}\n\t}\n\tcout<<f.cnt<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<assert.h>\n\ntemplate<typename T>\nvoid swap(T &a,T &b){\n  T x=a;\n  a=b;\n  b=x;\n}\n\nint dif(int x,int y){return x-y>=0?x-y:y-x;}\n\nconst int N = 3;\nint st[N*N];\n\nint calc(int i,int j){ \n  if(st[i*N+j]<0) return 0;\n  int res=0; \n  res+=dif(i,st[i*N+j]/N);\n  res+=dif(j,st[i*N+j]%N);\n  return res;\n}\n\nint dist=0,ans=31;\n\nint check(int cur){\n  if(dist==0&&ans>cur) ans=cur;\n  int val=cur+dist;\n  return val<ans;  \n}\n\nint dy[]={0,0,1,-1};\nint dx[]={1,-1,0,0};\nint in(int y,int x){return 0<=y&&y<N&&0<=x&&x<N;};\n\nvoid dfs(int di,int y,int x,int p){\n  for(int k=0;k<4;k++){\n    if((p>=0)&&((p^1)==k)) continue;\n    int ny=y+dy[k],nx=x+dx[k];\n    if(!in(ny,nx)) continue;\n    dist-=calc(ny,nx);\n    swap(st[y*N+x],st[ny*N+nx]);\n    dist+=calc(y,x);\n    if(check(di+1)) dfs(di+1,ny,nx,k);    \n    dist-=calc(y,x);\n    swap(st[y*N+x],st[ny*N+nx]);\n    dist+=calc(ny,nx);\n  }\n}\n\nint main(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      std::cin>>st[i*N+j],st[i*N+j]--;\n  \n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      dist+=calc(i,j);\n  \n  int y=-1,x=-1;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      if(st[i*N+j]<0) y=i,x=j;\n\n  check(0);\n  dfs(0,y,x,-1);\n  \n  std::cout<<ans<<std::endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <cmath>\n#include <set>\n\nusing namespace std;\n\nusing Weight=int;\nusing Encoded=int;\n\nstruct State {\n    Weight hcost, acost;\n    Encoded encoded;\n    State() {}\n    State(Weight h, Weight a, Encoded e): hcost(h), acost(a), encoded(e) {}\n    bool operator>(const State & state2) const {\n        if (hcost+acost != state2.hcost+state2.acost) {\n            return hcost+acost > state2.hcost+state2.acost;\n        } else {\n            return acost > state2.acost;\n        }\n    }\n};\n\nconst Weight INF=1<<29;\n\ntemplate <class T>\nusing lp_queue=priority_queue<T, deque<T>, greater<T>>;\n\nEncoded encode(vector<int> d) {\n    int cur=0;\n    Encoded enc=0;\n    for (size_t i=0; i<d.size()-1; ++i) {\n        cur = d[i];\n        for (size_t j=i+1; j<d.size(); ++j)\n            if (cur < d[j])\n                --d[j];\n\n        (enc += d[i]) *= d.size()-i-1;\n    }\n\n    return enc;\n}\n\nvector<int> decode(Encoded e) {\n    vector<int> d(9);\n    for (size_t i=1; i<=9; ++i) {\n        d[9-i] = e % i;\n        e /= i;\n    }\n\n    for (size_t i=9; i--;)\n        for (size_t j=i+1; j<9; ++j)\n            if (d[i] <= d[j])\n                ++d[j];\n\n    return d;\n}\n\nWeight heucost(Encoded start, Encoded end) {\n    static const vector<int> dend=decode(end);\n    vector<int> dstart=decode(start);\n\n    Weight h=0;\n    for (size_t i=0; i<9; ++i)\n        for (size_t j=0; j<9; ++j)\n            if (dstart[i] == dend[j]) {\n                h += abs(int(i/3-j/3))+abs(int(i%3-j%3));\n                break;\n            }\n\n    return h;\n}\n\nvector<pair<Weight, Encoded>> pmoves(Encoded cur) {\n    vector<int> d=decode(cur);\n    size_t i;\n    for (i=0; d[i]; ++i);\n\n    vector<pair<Weight, Encoded>> p;\n    if (i/3 < 2) {\n        swap(d[i], d[i+3]);\n        p.push_back(make_pair(1, encode(d)));\n        swap(d[i], d[i+3]);\n    }\n    if (i/3 > 0) {\n        swap(d[i], d[i-3]);\n        p.push_back(make_pair(1, encode(d)));\n        swap(d[i], d[i-3]);\n    }\n    if (i%3 < 2) {\n        swap(d[i], d[i+1]);\n        p.push_back(make_pair(1, encode(d)));\n        swap(d[i], d[i+1]);\n    }\n    if (i%3 > 0) {\n        swap(d[i], d[i-1]);\n        p.push_back(make_pair(1, encode(d)));\n        swap(d[i], d[i-1]);\n    }\n    return p;\n}\n\nWeight astar(Encoded start, Encoded end) {\n    lp_queue<State> q;\n    q.push(State(heucost(start, end), 0, start));\n\n    Weight opt=INF;\n    set<Encoded> visited;\n    while (!q.empty()) {\n        State p=q.top(); q.pop();\n        Weight cur_cost=p.acost;\n        Encoded cur_state=p.encoded;\n        visited.insert(cur_state);\n\n        if (opt < cur_cost) continue;\n        if (cur_state == end)\n            if (opt > cur_cost)\n                opt = cur_cost;\n\n        vector<pair<Weight, Encoded>> ms=pmoves(cur_state);\n        for (pair<Weight, Encoded> m: ms) {\n            if (visited.count(m.second)) continue;\n            if (cur_cost+m.first >= opt) continue;\n\n            q.push(State(heucost(m.second, end), cur_cost+m.first, m.second));\n        }\n    }\n\n    return opt;\n}\n\nint main() {\n    vector<int> d(9);\n    for (size_t i=0; i<9; ++i)\n        scanf(\"%d\", &d[i]);\n\n    Encoded e=encode(d);\n\n    Weight c=astar(e, 46233);\n    printf(\"%d\\n\", c);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define LIMIT 30\n\nstruct Puzzle{\n    char cont[9];\n    int space;\n    string path;\n    bool operator < ( const Puzzle &p ) const{\n        for ( int i = 0; i < 9; i++ ){\n            if ( cont[i] == p.cont[i] ) continue;\n            return cont[i] > p.cont[i];\n        }\n        return false;\n    }\n};\n\nint limit;\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char direction[4] = {'d', 'r', 'u', 'l'};\n\nbool isTarget(Puzzle puzzle){\n    for ( int i = 0; i < 8; i++ ){\n        if ( puzzle.cont[i] != '1' + i ) return false;\n    }\n    return true;\n}\n\nvoid bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n    \n    while( !Q.empty() ){\n        u = Q.front(); Q.pop();\n        if ( isTarget(u) ){\n            cout << u.path.size() << endl;\n            return;\n        } else if ( u.path.size() > LIMIT ) break;\n        \n        int sx, sy, tx, ty;\n        sx = u.space/3;\n        sy = u.space%3;\n        \n        for ( int r = 0; r < 4; r++ ){\n            tx = sx + dx[r];\n            ty = sy + dy[r];\n            if ( tx < 0 || ty < 0 || tx >= 3 || ty >= 3 ) continue;\n            v = u;\n            v.cont[u.space] = u.cont[tx*3+ty];\n            v.cont[tx*3+ty] = '0';\n            v.space = tx*3+ty;\n            if ( !V[v] ){\n                V[v] = true;\n                v.path += direction[r];\n                Q.push(v);\n            }\n        }\n    }\n    cout << \"unsolvable\" << endl;\n}\n\nint main(){\n    Puzzle in;\n    for ( int i = 0; i < 9; i++ ){\n        cin >> in.cont[i];\n        if ( in.cont[i] == '0' ) {\n            in.space = i;\n        }\n    }\n    \n    bfs(in);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 23;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i) {\n        return;\n    }\n\n    if (in.path == \"ldrd\")\n        int debug = 0;\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n    /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint Y[4]={-1,0,1,0};\nint X[4]={0,1,0,-1};\nbool in(int a,int b){\n  if(a<0||b<0||3<=a||3<=b)return false;\n  return true;\n}\nint main(){\n  int a;\n  string start=\"\",goal=\"123456780\";\n  for(int i=0;i<9;i++){\n    cin>>a;\n    start+=(a+'0');\n  }\n  queue<string> q;\n  map<string,int> m;\n  m[start]=0;\n  q.push(start);\n  while(!q.empty()){\n    string u=q.front();\n    q.pop();\n    if(u==goal){\n      cout<<m[u]<<endl;\n      break;\n    }\n    int s=-1;\n    for(int i=0;i<u.length();i++)if(u[i]=='0')s=i;\n    int y=s/3,x=s%3;\n    for(int i=0;i<4;i++){\n      int ny=y+Y[i],nx=x+X[i];\n      if(!in(ny,nx))continue;\n      int g=ny*3+nx;\n      string t=u;\n      swap(t[s],t[g]);\n      if(m.find(t)==m.end()){\n        m[t]=m[u]+1;\n        q.push(t);\n      }\n    }\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int dx[4]={0,0,-1,1},dy[4]={-1,1,0,0};\nconst char rd[4]={'u','d','l','r'};\nstruct gg{\n\tint mp[9];\n\tint space;\n\tstring path;\n\tbool operator<(const gg &tmp)const\n\t{\n\t\tfor(int i=0;i<=8;i++)\n\t\t   {\n\t\t   \tif(mp[i]!=tmp.mp[i])return mp[i]>tmp.mp[i];\n\t\t   }\n\t\treturn false;   \n\t}\n};\nbool ifok(gg a)\n{\n\tfor(int i=0;i<8;i++)\n\t  if(a.mp[i]!=i+1)return false;\n\treturn true;  \n}\ngg bfs(gg bg)\n{\n\tqueue<gg> q;gg now,tmp;int x,y;\n\tmap<gg,bool>vis;\n\tvis[bg]=1;\n\tq.push(bg);\n\twhile(!q.empty())\n\t{   \n\t\tnow=q.front();q.pop();\n\t\tif(ifok(now))return now;\n\t\tx=now.space%3;y=now.space/3;\n\t\tfor(int i=0;i<=3;i++)\n\t\t   {\n\t\t     tmp=now;\n\t\t     if(x+dx[i]<0||x+dx[i]>2||y+dy[i]<0||y+dy[i]>2)continue;\n\t\t     tmp.space=x+dx[i]+(y+dy[i])*3;\n\t\t     swap(tmp.mp[x+y*3],tmp.mp[x+dx[i]+(y+dy[i])*3]);\n\t\t     tmp.path+=rd[i];\n\t\t     if(vis[tmp])continue;\n\t\t     vis[tmp]=1;q.push(tmp);\n\t\t   }\n\t}\t\n}\nint main()\n{\n\tgg bg,ans;\n\tfor(int i=0;i<=8;i++)\n\t   {\n\t   \tscanf(\"%d\",&bg.mp[i]);\n\t   \tif(bg.mp[i]==0)bg.space=i;\n\t   }   \n\tbg.path=\"\";\n\tans=bfs(bg);\n\tcout<<ans.path.length()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,vector<int>> P;\n\nint main(){\n\tmap<vector<int>,int> dist;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\t\n\tvector<int> start(9),end = {1,2,3,4,5,6,7,8,0};\n\tfor(int i=0; i<9; i++) cin>>start[i];\n\t\n\tdist[start] = 0;\n\tq.push(P(0,start));\n\t\n\tfor(;q.size();){\n\t\tint cost = q.top().first;\n\t\tvector<int> now = q.top().second;\n\t\tq.pop();\n\t\t\n\t\tif(now==end){\n\t\t\tcout<<cost<<endl;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tvector<vector<int>> next;\n\t\tint z = find(now.begin(), now.end(), 0) - now.begin();\n\t\tif(z > 2){\n\t\t\tvector<int> nx = now;\n\t\t\tswap(nx[z], nx[z-3]);\n\t\t\tnext.push_back(nx);\n\t\t}\n\t\tif(z < 6){\n\t\t\tvector<int> nx = now;\n\t\t\tswap(nx[z], nx[z+3]);\n\t\t\tnext.push_back(nx);\n\t\t}\n\t\tif(z % 3 > 0){\n\t\t\tvector<int> nx = now;\n\t\t\tswap(nx[z], nx[z-1]);\n\t\t\tnext.push_back(nx);\n\t\t}\n\t\tif(z % 3 < 2){\n\t\t\tvector<int> nx = now;\n\t\t\tswap(nx[z], nx[z+1]);\n\t\t\tnext.push_back(nx);\n\t\t}\n\t\t\n\t\tfor(auto n : next){\n\t\t\tif(dist.find(n) == dist.end() || 1+cost < dist[n]){\n\t\t\t\tq.push(P(dist[n]=1+cost, n));\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/* \n * I used # 1687007 as a refference. Thx. \n */\n#include <iostream>\n#include <queue>\n#include <set>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\n//const int PATTERN = 181440;     // 9! / 2;\nconst int PATTERN = 362880;     // 9! / 2;\nconst int FORWARD  = 1;\nconst int BACKWARD = -1;\nconst Board GOAL = 0x123456780LL;\nconst int DX[] = { -1, 0, 1,  0 },\n          DY[] = {  0, 1, 0, -1 };\n\nint history[PATTERN];\nqueue<Board> q;\n\n// I made this function based on one by Haruhiko Okumura(Algorithm \n// Dictionary, p116) and one by M.Hiroi(Puzzle DE Programming).\ninline int change_number(long long board) {\n    static int fact_table[N] = {\n         40320, 5040, 720, 120, 24, 6, 2, 1, 0      // on N = 8\n    };\n    int value = 0;\n    for (int j = 0; j < N - 1; ++j) {\n        int J = static_cast<int>((board >> (j*4) & 0xF));\n        value += fact_table[j] * J;\n        for (int k = j + 1; k < N; ++k) {\n            int K = static_cast<int>((board >> k*4) & 0xF);\n            if (J < K) {\n                board &= ~(0xFLL << k*4);\n                board |= (static_cast<long long>(K - 1) << k*4);\n            }\n        }\n    }\n//    printf(\"[change_number] value = %d\\n\", value);\n    return value;\n}\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 0xF;\n    board |= num << (spacepos*4);\n    board &= ~(0xFLL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, Board board) {\n//    printf(\"change_number(board) = %d\\n\", change_number(board));\n    int direction = history[change_number(board)];\n    swap(numpos, spacepos, board);\n    int pos = change_number(board);\n    if (history[pos] == 0) {\n        q.push(board);\n        history[pos] = direction + (direction > 0 ? 1 : -1);\n    }\n    else if ((history[pos] > 0 && direction < 0)\n          || (history[pos] < 0 && direction > 0)) {\n        return abs(history[pos]) + abs(direction) - 1;\n    }\n    return 0;\n}\n\nvoid print(Board b) {\n    for (int i = N - 1; i >= 0; --i) {\n        printf(\"%2lld\", (b >> (i*4) & 0xF));\n    }\n    printf(\"\\n\");\n}\n\n// OK\nint main(void) {\n\n    Board board = 0;\n    for (int i = N - 1, num; i >= 0; --i) {\n        scanf(\"%d\", &num);\n        board |= static_cast<long long>(num) << (i * 4);\n    }\n//    print(board);\n//    print(GOAL);\n\n    int count = 0;\n    if (board == GOAL) {\n        goto END;\n    }\n\n    history[change_number(board)] = FORWARD;\n    history[change_number(GOAL)]  = BACKWARD;\n\n    q.push(board);\n    q.push(GOAL);\n    while (!q.empty()) {\n        board = q.front();\n        q.pop();\n\n        int pos = -1;\n        while (++pos < N)\n            if (((board >> (pos * 4)) & 0xF) == 0)\n                break;\n\n        int zx = pos % 3, zy = pos / 3;\n        for (int i = 0; i < 4; ++i) {\n            int nx = zx + DX[i], ny = zy + DY[i];\n            if (nx < 0 || nx > 2 || ny < 0 || ny > 2)\n                continue;\n            int npos = nx + ny * 3;\n//            printf(\"npos = %d\\n\", npos);\n            assert(pos >= 0 && pos < N);\n            assert(npos >= 0 && npos < N);\n            if ((count = swap_and_check(npos, pos, board)))\n                goto END;\n        }\n//        printf(\"\\n\");\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    for(int i = 0; i < N2; ++i){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  for(int i = 0; i < N2; i++)\n    if(p.f[i] != (i + 1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n\n    for(int r = 0; r < 4; ++r){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if(!V[v]){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main() {\n  Puzzle in;\n\n  for(int i = 0; i < N2; ++i){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Problem Description: 8 Puzzle\n * Category: Heuristic Search\n * Author: Khan\n * Date: 22th October, 2017\n */\n\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle\n{\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const\n    {\n        for (int i = 0; i < N2; ++i)\n        {\n            if(f[i] == p.f[i])\n                continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; ++i)\n        if(p.f[i] != (i + 1))\n            return false;\n    return true;\n}\n\nstring bfs(Puzzle s)\n{\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while(!Q.empty())\n    {\n        u = Q.front(); Q.pop();\n        if(isTarget(u))\n            return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; ++r)\n        {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if(tx < 0 || ty < 0 || tx >= N || ty >= N)\n                continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if(!V[v])\n            {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main(int argc, char const *argv[])\n{\n    //freopen(\"sample.txt\", \"r\", stdin);\n    Puzzle in;\n\n    for (int i = 0; i < N2; ++i)\n    {\n        cin >> in.f[i];\n        if(in.f[i] == 0)\n        {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3\nusing namespace std;\n\nint path = 0;\n// state space tree nodes\nstruct Node {\n    // stores parent node of current node\n    // helps in tracing path when answer is found\n    Node *parent;\n\n    // stores matrix\n    int mat[N][N];\n\n    // stores blank tile cordinates\n    int x, y;\n\n    // stores the number of misplaced tiles\n    int cost;\n\n    // stores the number of moves so far\n    int level;\n};\n\n// Function to allocate a new node\nNode *newNode(int mat[N][N], int x, int y, int newX,\n              int newY, int level, Node *parent) {\n    Node *node = new Node;\n\n    // set pointer for path to root\n    node->parent = parent;\n\n    // copy data from parent node to current node\n    memcpy(node->mat, mat, sizeof node->mat);\n\n    // move tile by 1 postion\n    swap(node->mat[x][y], node->mat[newX][newY]);\n\n    // set number of misplaced tiles\n    node->cost = INT_MAX;\n\n    // set number of moves so far\n    node->level = level;\n\n    // update new blank tile cordinates\n    node->x = newX;\n    node->y = newY;\n\n    return node;\n}\n\n// botton, left, top, right\nint row[] = {1, 0, -1, 0};\nint col[] = {0, -1, 0, 1};\n\n// Function to calculate the the number of misplaced tiles\n// ie. number of non-blank tiles not in their goal position\nint calculateCost(int initial[N][N], int final[N][N]) {\n    int count = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            if (initial[i][j] && initial[i][j] != final[i][j])\n                count++;\n    return count;\n}\n\n// Function to check if (x, y) is a valid matrix cordinate\nint isSafe(int x, int y) {\n    return (x >= 0 && x < N && y >= 0 && y < N);\n}\n\n// print path from root node to destination node\nvoid checkPath(Node *root) {\n    if (root == NULL)\n        return;\n    checkPath(root->parent);\n    path += 1;\n\n}\n\n// Comparison object to be used to order the heap\nstruct comp {\n    bool operator()(const Node *lhs, const Node *rhs) const {\n        return (lhs->cost + lhs->level) > (rhs->cost + rhs->level);\n    }\n};\n\n\nvoid solve(int initial[N][N], int x, int y,\n           int final[N][N]) {\n\n    priority_queue<Node *, std::vector<Node *>, comp> pq;\n\n    Node *root = newNode(initial, x, y, x, y, 0, NULL);\n    root->cost = calculateCost(initial, final);\n\n    // Add root to list of live nodes;\n    pq.push(root);\n\n    // Finds a live node with least cost,\n    // add its childrens to list of live nodes and\n    // finally deletes it from the list.\n    while (!pq.empty()) {\n        // Find a live node with least estimated cost\n        Node *min = pq.top();\n\n        // The found node is deleted from the list of\n        // live nodes\n        pq.pop();\n\n        // if min is an answer node\n\n        if (min->cost == 0) {\n            checkPath(min);\n            return;\n        }\n\n        // do for each child of min\n        // max 4 children for a node\n        for (int i = 0; i < 4; i++) {\n            if (isSafe(min->x + row[i], min->y + col[i])) {\n                // create a child node and calculate\n                // its cost\n                Node *child = newNode(min->mat, min->x,\n                                      min->y, min->x + row[i],\n                                      min->y + col[i],\n                                      min->level + 1, min);\n                child->cost = calculateCost(child->mat, final);\n\n                // Add child to list of live nodes\n                pq.push(child);\n            }\n        }\n    }\n}\n\n\nint main() {\n    // Initial state\n\n    int x = 0, y = 0;\n    int initial[N][N] = {{}};\n\n\n    cin >> initial[0][0] >> initial[0][1] >> initial[0][2];\n    cin >> initial[1][0] >> initial[1][1] >> initial[1][2];\n    cin >> initial[2][0] >> initial[2][1] >> initial[2][2];\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if(initial[i][j] == 0)\n            {\n                x = i;\n                y = j;\n            }\n        }\n    }\n\n    // goal\n    int final[N][N] =\n            {\n                    {1, 2, 3},\n                    {4, 5, 6},\n                    {7, 8, 0}\n            };\n\n    solve(initial, x, y, final);\n    cout << path - 1;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<string>\n\nusing namespace std;\n#define N 3\n#define M 9\nint i,j;\n//?§????????????????\nstruct Puzzle{\n  int f[M];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p)const{\n    for( i=0;i<M;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n  \n};\n////\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n///\nvoid swapp(int *p,int *q){\n  int tmp;\n  tmp=*p;\n  *p=*q;\n  *q=tmp;\n}\n///\nbool Target(Puzzle p){\n  for(i=0;i<M;i++)if(p.f[i]!=(i+1))return false;\n  return true;\n\n}\n///\n\n///\nstring bfs(Puzzle s){\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  queue<Puzzle> Q;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front();\n    Q.pop();\n    if(Target(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N)continue;\n      v=u;\n      swapp(&v.f[u.space],&v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      } \n    }\n  }\n  return \"unsolvable\";\n}\n///\n\nint main(){\n  Puzzle in;\n\n  for(i=0;i<M;i++){\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i]==0){\n      in.f[i]=M;\n      in.space=i;\n    }\n  }\n\n  string ans=bfs(in);\n  cout << ans.size() << endl;\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h>\n#include<string.h>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nmap<int, int> book;\n\nint a[5][5];\nint nx[4][2] = { 0,1,1,0,0,-1,-1,0 };\n\nstruct node\n{\n\tint x, y, step;\n\tint aa[5][5];\n};\n\nnode getnode(int x, int y, int step, int aa[5][5])\n{\n\tnode q;\n\tq.x = x;\n\tq.y = y;\n\tq.step = step;\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tfor (int j = 0; j < 3; j++)\n\t\t{\n\t\t\tq.aa[i][j] = aa[i][j];\n\t\t}\n\t}\n\treturn q;\n}\n\nvoid bfs(int x, int y, int step, int aa[5][5])\n{\n\tqueue<node> q;\n\tnode p;\n\tq.push(getnode(x, y, step, aa));\n\twhile (!q.empty())\n\t{\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tint tx = q.front().x + nx[i][0];\n\t\t\tint ty = q.front().y + nx[i][1];\n\t\t\tif (tx >= 0 && tx < 3 && ty >= 0 && ty < 3)\n\t\t\t{\n\t\t\t\t//memcpy(p.aa,q.front().aa,sizeof(q.front().aa));\n\t\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tp.aa[i][j] = q.front().aa[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//\t\t\t\tprintf(\"******\\n\");\n\t\t\t\t//\t\t\t\tfor(int i=0;i<3;i++)\n\t\t\t\t//\t\t\t\t{\n\t\t\t\t//\t\t\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\t//\t\t\t\t\t{\n\t\t\t\t//\t\t\t\t\t\tprintf(\"%d \",p.aa[i][j]);\n\t\t\t\t//\t\t\t\t\t}\n\t\t\t\t//\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t//\t\t\t\t}\n\t\t\t\tswap(p.aa[q.front().x][q.front().y], p.aa[tx][ty]);\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tsum = sum * 10 + p.aa[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//\t\t\t\tprintf(\"sum===%d\\n\",sum);\n\n\n\t\t\t\tif (sum == 123456780)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d\\n\", q.front().step + 1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\n\n\t\t\t\tif (!book[sum])\n\t\t\t\t{\n\t\t\t\t\tbook[sum] = 1;\n\t\t\t\t\tq.push(getnode(tx, ty, q.front().step + 1, p.aa));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tq.pop();\n\t}\n}\n\nint main()\n{\n\twhile (~scanf(\"%d%d%d\", &a[0][0], &a[0][1], &a[0][2]))\n\t{\n\t\tfor (int i = 1; i < 3; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tint sum = 0, x1, y1;\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t{\n\t\t\t\tsum = sum * 10 + a[i][j];\n\t\t\t\tif (a[i][j] == 0)\n\t\t\t\t{\n\t\t\t\t\tx1 = i;\n\t\t\t\t\ty1 = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (sum == 123456780)\n\t\t{\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tbook.clear();\n\t\tbook[sum] = 1;\n\t\tbfs(x1, y1, 0, a);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\n#define N 3\n#define N1 9\n\nstruct P{\n    int f[N1];\n    int space;\n    string path;\n\n    bool operator < (const P &p) const{\n        for(int i = 0; i < N1; i++){\n            if(f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n    return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\n\nint isT(P p){\n    for(int i = 0; i < N1; i++){\n        if(p.f[i] != (i + 1)) return 0;\n    }\n    return 1;\n}\n\nstring bfs(P s){\n    queue<P> Q;\n    map<P, bool> V;\n    P u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while(!Q.empty()){\n        u = Q.front();\n        Q.pop();\n        if(isT(u) == 1) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for(int r = 0; r < 4; r++){\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if(!V[v]){\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main(){\n    P in;\n\n    for(int i = 0; i < N1; i++){\n        cin >> in.f[i];\n        if(in.f[i] == 0){\n            in.f[i] = N1;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define rep(i, n) for (ll i = 0; i < (ll)n; ++i)\nll dx[4] = { 0, 1, 0, -1 };\nll dy[4] = { 1, 0, -1, 0 };\nstatic const int N = 3;\nstatic const int N2 = 9;\nstatic const char dir[4] = { 'u', 'r', 'd', 'l' };\n\nstruct Puzzle {\n    int f[N2]; // f[i] = i+1となっているときに答え\n    int space; // 0がある場所の添字\n    string path; // 移動を文字列で管理している\n    bool operator<(const Puzzle& p) const\n    {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) {\n                continue;\n            }\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\n// このパズルが答えであるとき\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != (i + 1)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nstring bfs(Puzzle s)\n{\n    queue<Puzzle> Q; // パズルをキューに入れる(深さ幅優先なので)\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true; // 入力の写像をtrue(探索済み)にする\n\n    while (!Q.empty()) {\n        u = Q.front(); // 一番最初に入れたキューの中身をセット\n        Q.pop();\n        if (isTarget(u)) { //もしターゲットなら移動の順序を返す\n            return u.path;\n        }\n        // スペースのある位置は(sx, sy)\n        int sx = u.space / N;\n        int sy = u.space % N;\n\n        rep(r, 4)\n        {\n            // スペースの移動先の場所を(tx, ty)\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            // もし枠の外に移動していたら無視\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N) {\n                continue;\n            }\n            // u: 移動前の盤, v: 移動後の盤\n            v = u;\n            // コマを交換\n            v.space = tx * N + ty; // 新しいスペースの置き場所\n            swap(v.f[u.space], v.f[v.space]);\n            if (!V[v]) {\n                V[v] = true; // vを探索済みにする\n                v.path += dir[r]; // 経路を追加する\n                Q.push(v); // 探索済みの経路をQに追加する\n            }\n        }\n    }\n\n    return \"unsolvable\";\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    Puzzle in;\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            in.f[i] = N2; // スペースを9として扱う\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\nvector<int> searched[9];\n\nclass board{\npublic:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<int> tiles;\n\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        tiles = num;\n        REP(i, 9){\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n    }\n\n    int cost() {\n        return wrongs + moves;\n    }\n\n    void board_to_int(){\n        int k = 0;\n        REP(i, 9)\n            k += (tiles[i] * pow(10, i));\n        for(int i = searched[tiles[0]].size(); i > 0 ; i--)\n            if(k == searched[tiles[0]][i-1])\n                return;\n        pq.push(board(tiles, moves+1));\n        searched[tiles[0]].push_back(k);\n        return;\n    }\n\n    void move() {\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\nbool operator< (board b1, board b2){\n    return (b1.cost() > b2.cost()) ? true : false;\n}\n\nint solve(){\n    pq.push(board(original, 0));\n    while(1){\n        auto target = pq.top();\n        pq.pop();\n        if(target.wrongs == 0)\n            return target.cost();\n        target.move();\n    }\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = solve();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator<(const Puzzle &p) const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i]) continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++)\n    if(p.f[i]!=(i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0 || ty<0 ||tx>=N || ty>=N) continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0;i<N2;i++){\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  printf(\"%d\\n\",ans.size());\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n \n struct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n \n  bool operator < (const Puzzle &p) const {\n    for(int i=0;i<N2;i++) {\n      if(f[i]==p.f[i])continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p) {\n  for(int i=0;i<N2;i++)\n  if(p.f[i] != (i+1)) return false;\n  return true;\n}\n \nstring bfs(Puzzle s ) {\nqueue<Puzzle> Q;\nmap<Puzzle,bool> V;\nPuzzle u,v;\ns.path = \"\";\nQ.push(s);\nV[s] = true;\n \nwhile(!Q.empty()) {\n  u = Q.front();Q.pop();\n  if(isTarget(u)) return u.path;\n  int sx = u.space / N;\n  int sy = u.space % N;\n  for(int r = 0;r<4 ; r++) {\n    int tx = sx + dx[r];\n    int ty = sy + dy[r];\n    if(tx < 0 || ty < 0|| tx>=N || ty >= N) continue;\n    v = u;\n    swap(v.f[u.space], v.f[tx *N+ty]);\n    v.space = tx * N + ty;\n    if(!V[v]) {\n      V[v] = true;\n      v.path  += dir[r];\n      Q.push(v);\n    }\n  }\n}\nreturn \"unsolvable\";\n}\n \nint main() {\n  Puzzle in;\n \n  for(int i=0;i<N2;i++) {\n    cin >> in.f[i];\n    if(in.f[i]==0) {\n      in.f[i]=N2;\n      in.space = i;\n    }\n  }\n \n  string ans = bfs(in);\n  cout << ans.size()<<endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i]) continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isT(Puzzle p){\n  for(int i=0;i<N2;i++)\n    if(p.f[i]!=(i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front(); Q.pop();\n    if(isT(u)) return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n       int ty=sy+dy[r];\n       if(tx<0||ty<0||tx>=N||ty>=N) continue;\n       v=u;\n       swap(v.f[u.space],v.f[tx*N+ty]);\n       v.space=tx*N+ty;\n       if(!V[v]){\n         V[v]=true;\n         v.path+=dir[r];\n         Q.push(v);\n\n       }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\n\nint main(){\n  Puzzle in;\n\n  for(int i=0;i<N2;i++){\n    cin >> in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nvector<int> board( 9 );\nset< vector<int> > reachedState;\n\nvoid PrintBoard() {\n    for ( int row=0; row<3; ++row ) {\n\tfor ( int col=0; col<3; ++col ) cout << board[row*3+col];\n\tcout << endl;\n    }\n}\n\nbool IsReachedState( const vector<int>& b ) {\n    return reachedState.find( b ) != reachedState.end();\n}\n\nvoid RegisterState( const vector<int>& b ) {\n    reachedState.insert( b );\n}\n\nbool IsCompleted( const vector<int>& b ) {\n    for ( int i=0; i<8; ++i ) {\n\tif ( b[i] != i+1 ) return false;\n    }\n    return b[8] == 0;\n}\n\nint main() {\n\n    const int dx[4] = { -1, 0, 1,  0 };\n    const int dy[4] = {  0, 1, 0, -1 };\n    \n    int x, y;\n    for ( int i=0; i<3; ++i ) {\n\tfor ( int j=0; j<3; ++j ) {\n\t    cin >> board[i*3+j];\n\t    if ( board[i*3+j] == 0 ) {\n\t\ty = i;\n\t\tx = j;\n\t    }\n\t}\n    }\n\n    //    PrintBoard();\n\n    queue< pair<vector<int>,int> > stateQue;\n    stateQue.push( make_pair(board, 0) );\n\n    while ( !stateQue.empty() ) {\n\n\tvector<int> state = stateQue.front().first;\n\tint step = stateQue.front().second;\n\tstateQue.pop();\n\n\tif ( IsCompleted( state ) ) {\n\t    cout << step << endl;\n\t    board = state;\n\t    //\t    PrintBoard();\n\t    break;\n\t}\n\n\tif ( IsReachedState( state ) ) continue;\n\tRegisterState( state );\n\n\tint x, y;\n\tfor ( int i=0; i<9; ++i ) {\n\t    if ( state[i] == 0 ) {\n\t\tx = i%3;\n\t\ty = i/3;\n\t\tbreak;\n\t    }\n\t}\n\t\n\tfor ( int i=0; i<4; ++i ) {\n\n\t    int nx = x + dx[i];\n\t    int ny = y + dy[i];\n\n\t    if ( nx < 0 || nx > 2 || ny < 0 || ny > 2 ) continue;\n\n\t    vector<int> next = state;\n\t    swap( next[3*y+x], next[3*ny+nx] );\n\t    stateQue.push( make_pair( next, step+1 ) );\n\t    \n\t}\n\t\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n  \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n  \nusing namespace std;\n  \ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n  \nconst int INF=1<<29;\nconst double EPS=1e-9;\n  \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nconst int boardw = 3;\n\nstruct BOARD {\n    int map[boardw][boardw];\n};\n \nstd::queue<BOARD> q;\nstd::map<BOARD,int> m;\n \nbool check(BOARD b) {\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            if (b.map[i][j] == 0) continue;\n            int tgt = i * boardw + j + 1;\n            if (b.map[i][j] != tgt) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint dfs(BOARD &b, int depth, int dir) {\n    if (depth == 0) {\n        if (check(b)) {\n            return 1;\n        } else {\n            return -1;\n        }\n    }\n\n    int px, py;\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            if (b.map[i][j] == 0) {\n                px = j;\n                py = i;\n            }\n        }\n    }\n    int dx[] = {0, 1, 0, -1};\n    int dy[] = {1, 0, -1, 0};\n    for (int k = 0; k < 4; k++) {\n        if (dir != -1 && k == (dir + 2) % 4) {\n            continue;\n        }\n        int tx = px + dx[k];\n        int ty = py + dy[k];\n        if (tx < 0 || tx >= boardw || ty < 0 || ty >= boardw) continue;\n        int temp = b.map[py][px];\n        b.map[py][px] = b.map[ty][tx];\n        b.map[ty][tx] = temp;\n        \n        int ret = dfs(b, depth - 1, k);\n        \n        temp = b.map[py][px];\n        b.map[py][px] = b.map[ty][tx];\n        b.map[ty][tx] = temp;\n        if (ret != -1) return ret;\n    }\n    return -1;\n}\n \nint main(int argc, char const *argv[]) {\n    BOARD b;\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            cin >> b.map[i][j];\n        }\n    }\n    if (check(b)) {\n        cout << 0 << endl;\n        return 0;\n    }\n    for (int i = 1; i <= 45; i++) {\n        int ret = dfs(b, i, -1);\n        if (ret == 1) {\n            cout << i << endl;\n            return 0;\n        }\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int dx[4]={0,0,-1,1},dy[4]={-1,1,0,0};\nconst char rd[4]={'u','d','l','r'};\nstruct gg{\n\tint mp[9];\n\tint space;\n\tstring path;\n\tbool operator<(const gg &tmp)const\n\t{\n\t\tfor(int i=0;i<=8;i++)\n\t\t   {\n\t\t   \tif(mp[i]!=tmp.mp[i])return mp[i]>tmp.mp[i];\n\t\t   }\n\t\treturn false;   \n\t}\n};\nbool ifok(gg a)\n{\n\tfor(int i=0;i<8;i++)\n\t  if(a.mp[i]!=i+1)return false;\n\treturn true;  \n}\ngg bfs(gg bg)\n{\n\tqueue<gg> q;gg now,tmp;int x,y;\n\tmap<gg,bool>vis;\n\tvis[bg]=1;\n\tq.push(bg);\n\twhile(!q.empty())\n\t{   \n\t\tnow=q.front();q.pop();\n\t\tif(ifok(now))return now;\n\t\tx=now.space%3;y=now.space/3;\n\t\tfor(int i=0;i<=3;i++)\n\t\t   {\n\t\t     tmp=now;\n\t\t     if(x+dx[i]<0||x+dx[i]>2||y+dy[i]<0||y+dy[i]>2)continue;\n\t\t     tmp.space=x+dx[i]+(y+dy[i])*3;\n\t\t     swap(tmp.mp[x+y*3],tmp.mp[x+dx[i]+(y+dy[i])*3]);\n\t\t     tmp.path+=rd[i];\n\t\t     if(vis[tmp])continue;\n\t\t     vis[tmp]=1;q.push(tmp);\n\t\t   }\n\t}\t\n}\nint main()\n{\n\tgg bg,ans;\n\tfor(int i=0;i<=8;i++)\n\t   {\n\t   \tscanf(\"%d\",&bg.mp[i]);\n\t   \tif(bg.mp[i]==0)bg.space=i;\n\t   }   \n\tbg.path=\"\";\n\tans=bfs(bg);\n\tcout<<ans.path.length();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n// ---------------------\n// repetition\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n// debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n// ---------------------\n#define INF 922337203685477580\n#define IINF (1<<21)\ntypedef long long ll;\n\n\nclass Board {\npublic:\n  int board[3][3];\n  Board() {}\n  Board(int b[3][3]) {\n    REP(i, 3) {\n      REP(j, 3) {\n        board[i][j] = b[i][j];\n      }\n    }\n  }\n\n  int hash() {\n    int accum = 0;\n    int digit = 1;\n    REP(i, 3) {\n      REP(j, 3) {\n        accum += board[i][j] * digit;\n        digit *= 10;\n      }\n    }\n    return accum;\n  }\n  string to_str() {\n    string str = \"\";\n    REP(i, 3) {\n      REP(j, 3) {\n        str += \" \" + to_string(board[i][j]);\n      }\n      str += \"\\n\";\n    }\n    return str;\n  }\n  bool operator==( const Board& other) {\n    REP(i, 3) {\n      REP(j, 3) {\n        if (board[i][j] != other.board[i][j]) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n};\n\nclass Nully;\nstatic Board Nully;\n\nBoard swap_with_upper(const Board& b) {\n  int pos_i, pos_j;\n  REP(i, 3) {\n    REP(j, 3) {\n      if (b.board[i][j] == 0) {\n        pos_i = i;\n        pos_j = j;\n        break;\n      }\n    }\n  }\n  if (pos_i == 0) {\n    return Nully;\n  }\n\n  Board next = b;\n  swap(next.board[pos_i][pos_j], next.board[pos_i - 1][pos_j]);\n  return next;\n}\nBoard swap_with_lower(const Board& b) {\n  int pos_i, pos_j;\n  REP(i, 3) {\n    REP(j, 3) {\n      if (b.board[i][j] == 0) {\n        pos_i = i;\n        pos_j = j;\n        break;\n      }\n    }\n  }\n  if (pos_i == 2) {\n    return Nully;\n  }\n\n  Board next = b;\n  swap(next.board[pos_i][pos_j], next.board[pos_i + 1][pos_j]);\n  return next;\n}\nBoard swap_with_left(const Board& b) {\n  int pos_i, pos_j;\n  REP(i, 3) {\n    REP(j, 3) {\n      if (b.board[i][j] == 0) {\n        pos_i = i;\n        pos_j = j;\n        break;\n      }\n    }\n  }\n  if (pos_j == 0) {\n    return Nully;\n  }\n\n  Board next = b;\n  swap(next.board[pos_i][pos_j], next.board[pos_i][pos_j - 1]);\n  return next;\n}\nBoard swap_with_right(const Board& b) {\n  int pos_i, pos_j;\n  REP(i, 3) {\n    REP(j, 3) {\n      if (b.board[i][j] == 0) {\n        pos_i = i;\n        pos_j = j;\n        break;\n      }\n    }\n  }\n  if (pos_j == 2) {\n    return Nully;\n  }\n\n  Board next = b;\n  swap(next.board[pos_i][pos_j], next.board[pos_i][pos_j + 1]);\n  return next;\n}\n\nint main() {\n  // int b[3][3] = {{1, 3, 0}, {4, 2, 5}, {7, 8, 6}};\n  int b[3][3];\n  REP(i, 3) {\n    REP(j, 3) {\n      cin >> b[i][j];\n    }\n  }\n\n  int g[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};\n  Board init(b);\n  Board goal(g);\n  // cout << init.to_str() << endl;\n\n  int depth = 0;\n  queue<pair<Board, int> > Q;\n  Q.push(make_pair(init, depth));\n\n  while (!Q.empty()) {\n    Board current = Q.front().first;\n    Board next;\n    int dpt = Q.front().second;\n    Q.pop();\n\n    if (goal == current) {\n      cout << dpt << endl;\n      return 0;\n    }\n\n    next = swap_with_upper(current);\n    if (!(next == Nully)) {\n      Q.push(make_pair(next, dpt + 1));\n    }\n    next = swap_with_lower(current);\n    if (!(next == Nully)) {\n      Q.push(make_pair(next, dpt + 1));\n    }\n    next = swap_with_left(current);\n    if (!(next == Nully)) {\n      Q.push(make_pair(next, dpt + 1));\n    }\n    next = swap_with_right(current);\n    if (!(next == Nully)) {\n      Q.push(make_pair(next, dpt + 1));\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < ( const Puzzle &p ) const {\n    for (int i = 0; i < N2; i++) {\n      if (f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n  for (int i = 0; i < N2; i++) {\n    if (p.f[i] != (i + 1)) return false;\n  }\n  return true;\n}\n\nstring bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while ( !Q.empty() ) {\n    u = Q.front();\n    Q.pop();\n    if ( isTarget(u) ) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for (int r = 0; r < 4; r++) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if ( !V[v] ) {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main() {\n  Puzzle in;\n\n  for (int i = 0; i < N2; i++) {\n    cin >> in.f[i];\n    if (in.f[i] == 0) {\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define MAX_D 3\n#define MAX_N 9\n#define MAX_C 362880\nint fact1[MAX_N][MAX_N][MAX_N][MAX_N][MAX_N][MAX_N][MAX_N][2];\nvector<int> fact2[MAX_C]; int MAP[MAX_D][MAX_D]; int DP[MAX_C], K;\nvoid FACT() {\n\tint a[MAX_N]; for (int i = 0; i < MAX_N; i++) { a[i] = i; }int cnt = 0;\n\tdo {\n\t\tif (a[MAX_N - 2] < a[MAX_N - 1]) { fact1[a[0]][a[1]][a[2]][a[3]][a[4]][a[5]][a[6]][0] = cnt; }\n\t\telse { fact1[a[0]][a[1]][a[2]][a[3]][a[4]][a[5]][a[6]][1] = cnt; }\n\t\tvector<int>vec; for (int i = 0; i < MAX_N; i++) { vec.push_back(a[i]); }fact2[cnt] = vec; cnt++;\n\t} while (next_permutation(a, a + MAX_N));\n}\nint main() {\n\tfor (int i = 0; i < MAX_D; i++) {\n\t\tfor (int j = 0; j < MAX_D; j++) { cin >> MAP[i][j]; }\n\t}FACT(); for (int i = 0; i < MAX_C; i++) { DP[i] = MAX_C; }\n\tint T = fact1[1][2][3][4][5][6][7][1];\n\tif (MAP[2][1] < MAP[2][2]) { K = fact1[MAP[0][0]][MAP[0][1]][MAP[0][2]][MAP[1][0]][MAP[1][1]][MAP[1][2]][MAP[2][0]][0]; }\n\telse { K = fact1[MAP[0][0]][MAP[0][1]][MAP[0][2]][MAP[1][0]][MAP[1][1]][MAP[1][2]][MAP[2][0]][1]; }DP[K] = 0;\n\twhile (DP[T] == MAX_C) {\n\t\tfor (int i = 0; i < MAX_C; i++) {\n\t\t\tif (DP[i] >= MAX_C) { continue; }vector<int>X = fact2[i]; int y[MAX_D][MAX_D], z[MAX_D][MAX_D], cx, cy; int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n\t\t\tfor (int j = 0; j < X.size(); j++) { y[j / 3][j % 3] = X[j]; if (X[j] == 0) { cx = j / 3; cy = j % 3; } }\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tfor (int k = 0; k < MAX_N; k++) { z[k / 3][k % 3] = y[k / 3][k % 3]; }int ex = cx + dx[j], ey = cy + dy[j];\n\t\t\t\tif (ex >= 3 || ex <= -1 || ey >= 3 || ey <= -1) { continue; } swap(z[cx][cy], z[ex][ey]);\n\t\t\t\tif (z[2][1] < z[2][2]) { K = fact1[z[0][0]][z[0][1]][z[0][2]][z[1][0]][z[1][1]][z[1][2]][z[2][0]][0]; }\n\t\t\t\telse { K = fact1[z[0][0]][z[0][1]][z[0][2]][z[1][0]][z[1][1]][z[1][2]][z[2][0]][1]; }DP[K] = min(DP[K], DP[i] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP[T] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <queue>\n#define N 9\n#define n 3\n#define Blank 0\n#define up -N/n\n#define down N/n\n#define left -1\n#define right 1\n#define limit 34\nusing namespace std;\nstruct p{\n  int v[N];\n  int blankPlace;\n  int g=0;\n  int h=0;\n  bool operator < (const p& pazzle) const {\n    for(int i=0;i<N;i++){\n      if(v[i] == pazzle.v[i]) continue;\n      return v[i]<pazzle.v[i];\n    }\n    return false;\n  }\n};\npriority_queue <p, vector<p>, greater<p> > pazzle;\nmap <p,bool> existPazzle;\nbool operator > (const p a,const p b){return a.h+a.g>b.h+b.g;};\n\nint calculate_h(p this_pazzle,int i){\n  if(i == this_pazzle.blankPlace ) return abs(i/n-(N-1)/n)+abs(i%n-(N-1)/n);\n  else return abs(i/n-(this_pazzle.v[i]-1)/n)+abs(i%n-(this_pazzle.v[i]-1)%n);\n}\n\np checkPazzle(p thisPazzle){\n  thisPazzle.h = 0;\n    for(int i=0;i<N;i++)\n      thisPazzle.h += calculate_h(thisPazzle,i);\n  return thisPazzle;\n}\n\nvoid moveBlank(p thisPazzle,int move){\n  int moved = thisPazzle.blankPlace + move;\n  thisPazzle.g++;\n  //cout<<\"g: \"<<thisPazzle.g<<\" moved: \"<<moved<<endl;\n  swap(thisPazzle.v[thisPazzle.blankPlace],thisPazzle.v[moved]);\n  if(existPazzle[thisPazzle])return;\n  thisPazzle.blankPlace = moved;\n  thisPazzle = checkPazzle(thisPazzle);\n  if(thisPazzle.g+thisPazzle.h>limit)return;\n  pazzle.push(thisPazzle);\n}\n\nvoid movePazzle(p thisPazzle){\n  if(thisPazzle.blankPlace+up>=0)\n    moveBlank(thisPazzle,up);\n  if(thisPazzle.blankPlace+down<9)\n    moveBlank(thisPazzle,down);\n  if(thisPazzle.blankPlace + left >= 0&&thisPazzle.blankPlace/3 == (thisPazzle.blankPlace+left)/3)\n    moveBlank(thisPazzle,left);\n  if(thisPazzle.blankPlace/3 == (thisPazzle.blankPlace+right)/3)\n    moveBlank(thisPazzle,right);\n}\n\np dfs(){\n  p tmp,thisPazzle;\n  tmp.g = -1;\n  while(!pazzle.empty()){\n    thisPazzle = pazzle.top();\n    pazzle.pop();\n    existPazzle[thisPazzle]=true;\n    if(!thisPazzle.h)return thisPazzle;\n    movePazzle(thisPazzle);\n  }\n  return tmp;\n}\n\nint main(){\n  p thisPazzle;\n  for(int i=0;i<N;i++){\n    cin>>thisPazzle.v[i];\n    if(thisPazzle.v[i]==Blank)thisPazzle.blankPlace=i;\n  }\n  thisPazzle = checkPazzle(thisPazzle);\n  pazzle.push(thisPazzle);\n  thisPazzle = dfs();\n  cout<<thisPazzle.g<<endl;\n  return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair< int, vector<int> > Q;\n\n#define MAX 100005\n#define INF 1001001001\n\nint main(int, char**)\n{\n    vector<int> b(9);\n    rep(i,9) { cin >> b[i]; b[i]--; }\n\n    map< vector<int>, bool > close;\n    map< vector<int>, int > h;\n    priority_queue< Q, vector<Q>, greater<Q> > q;\n\n    auto heu = [&](vector<int> v) -> int {\n        if (h.count(v)) return h[v];\n        int dif = 0;\n        rep(i,9) {\n            if (v[i] == -1) continue;\n            dif += abs(v[i]/3 - i/3) + abs(v[i]%3 - i%3); // 各パネルの目的地までのマンハッタン距離の総和\n        }\n        h[v] = dif;\n        return dif;\n    };\n\n    q.push({heu(b), b});\n    int ans;\n    while (!q.empty()) {\n        vector<int> b;\n        int f;\n        tie(f,b) = q.top(); q.pop();\n        if (h[b]==0) {\n            ans = f;\n            break;\n        }\n        close[b] = true;\n \n        int g = f - h[b];\n\n        int r, c;\n        rep(i,9) {\n            if (b[i] == -1) {\n                r = i/3;\n                c = i%3;\n                break;\n            }\n        }\n        int dr[4] = { -1,  0,  1,  0};\n        int dc[4] = {  0, -1,  0,  1};\n        rep(i,4) {\n            int nr = r + dr[i];\n            int nc = c + dc[i];\n            if (nr < 0 || nr >= 3 || nc < 0 || nc >= 3) continue;\n            vector<int> nb = b;\n            swap(nb[nr*3+nc], nb[r*3+c]);\n            if (!close[nb]) {\n                q.push({g+1+heu(nb), nb});\n            }\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 8パズル\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n\n#include<vector>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n//const int PUZZLE_NUM = 9;\n\n// パネルの移動方向の定義\nconst int LOW = 1;\nconst int UP = 2;\nconst int LEFT = 3;\nconst int RIGHT = 4;\n\n// 目標の状態 ( 0x12345678 を 10 進数に変換した値 )\nint Target = 305419896;\n\nconst int PANEL_NUM = 8;\n// 1 〜 8 までの和\nconst int ALL_SUM = 36;\n\n// 並び替えの状態を格納するキュー\n// 第1要素 : 検索する数値, 第2要素 : 並び替えた回数\nqueue<pair<int, int>> q_P;\n// 探索済みのパネルの状態を格納しておくマップ\nmap<int, bool> Map_V;\n\n// -------------------------------\n// パズルのパネルを操作するためのクラス\n// -------------------------------\nclass PuzzleOperation\n{\n\n    public:\n\n        // パネルの並びを16進数に変換して格納する変数\n        int panel;\n        // パネル内のゼロの位置\n        int zeroPos;\n        // panel を分解した状態を保持する配列\n        //int ary_panel[PANEL_NUM];\n        // 8 個のパネルに入っていない数\n        int remainNum;\n        // 並び替えの回数\n        int sortNum;\n\n    // コンストラクタ\n    PuzzleOperation()\n    {\n        panel = 0;\n        zeroPos = 0;\n        remainNum = 0;\n        sortNum = 0;\n    }\n\n    // コピーコンストラクタ\n    PuzzleOperation(const PuzzleOperation& p)\n    {\n        panel = p.panel;\n        zeroPos = p.zeroPos;\n        remainNum = p.remainNum;\n        sortNum = p.sortNum;\n\n        //cout << \"コピーコンストラクタが呼ばれました\" << endl;\n    }\n\n    // デストラクタ\n    ~PuzzleOperation()\n    {\n        //cout << \"デストラクタが呼ばれました\" << endl;\n    }\n\n    // --------------------------------------------------\n    // map のキーである PuzzleOperation クラスをキー順に並べるための定義\n    // --------------------------------------------------\n    bool operator < (const PuzzleOperation &p ) const\n    {\n\n        if( panel > p.panel )\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n\n    }\n\n    // ゴールに到達したかを判定する関数\n    bool reachGoal(int p)\n    {\n        if( p != Target )\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    // panel に設定された数値から正解を求める\n    // 計算値 : num の中で 4bit がゼロとなっている位置 ( zeroPos )\n    //       : 8個の配列要素に含まれていない数 ( remainNum )\n    // 戻り値 : 並び替えの回数\n    bool panelMove()\n    {\n        int x, y;\n        bool retX = false, retY = false;\n\n        int tmp = panel;\n        int bitNum;\n\n        // 最初に 1 〜 8 までの和を入れておいて, 不足している数を求める\n        remainNum = ALL_SUM;\n        // 配列の 9 番目にゼロが存在することを考慮しておく\n        // ( 要素数としては, 8 番目 )\n        zeroPos = 8;\n\n        for(int i = PANEL_NUM - 1; i >= 0; i--)\n        {\n            bitNum = tmp & 0xF;\n            // 配列の 8 要素に入ってない値を求める\n            remainNum -= bitNum;\n\n            if( bitNum == 0 )\n            {\n                // ゼロ位置の設定\n                zeroPos = i;\n            }\n\n            tmp = tmp >> 4;\n        }\n\n        // ゼロの位置から x, y 座標に変換する\n        x = zeroPos / 3;\n        y = zeroPos % 3;\n\n        // -----------------\n        // パネルを移動させる\n        // -----------------\n        retX = moveX(x, y);\n        retY = moveY(x, y);\n\n        if( retX == true || retY == true )\n        {\n            // パネルが目標の状態に到達した\n            return true;\n        }\n\n        return false;\n    }\n\n    // 指定位置のパネルとゼロ位置のパネルの入れ替え操作をする処理\n    bool panelReplacement(int movePos)\n    {\n\n        bool ret = false;\n        int movePanel, moveNum, sortCount;\n\n        // 移動操作はコピーしたもので実施する\n        movePanel = panel;\n        sortCount = sortNum;\n        moveNum = 0;\n\n        if( movePos < PANEL_NUM )\n        {\n            // -------------------------\n            // 8 以内ならそのまま入れ替える\n            // -------------------------\n\n            // 移動する値まで, 4ビット単位でビットシフトする\n            moveNum = movePanel >> ( 4 * ( ( PANEL_NUM - 1 ) - movePos ) );\n            // 移動する値を抜き出す\n            moveNum = moveNum & 0xF;\n        }\n        else\n        {\n            // 9 個目の要素なら, remainNum を入れておく\n            moveNum = remainNum;\n        }\n\n        // -----▼▼▼ ゼロの位置に移動する値を入れる処理　▼▼▼-----\n\n        if( zeroPos != 8 )\n        {\n            // 配列要素の 8 番目にゼロがあった場合は配列の圏外になるので何もしない\n\n            // 移動する値を, 移動する位置まで, 4ビット単位でビットシフトする\n            moveNum = moveNum << ( 4 * ( ( PANEL_NUM - 1 ) - zeroPos ) );\n            // 移動する値をゼロの位置に入れる\n            movePanel = movePanel | moveNum;\n        }\n\n        // -----▲▲▲ ゼロの位置に移動する値を入れる処理　▲▲▲-----\n\n        // -----▼▼▼ 移動させた箇所をゼロに落とす処理　▼▼▼-----\n\n        if( movePos < PANEL_NUM )\n        {\n            int zeroNum = 0xF;\n\n            // ゼロの入る位置まで, 4ビット単位でビットシフトする\n            zeroNum = zeroNum << ( 4 * ( ( PANEL_NUM - 1 ) - movePos ) );\n            // ビット反転する\n            zeroNum = ~zeroNum;\n            // ゼロを設定する\n            movePanel = movePanel & zeroNum;\n        }\n\n        // -----▲▲▲ 移動させた箇所をゼロに落とす処理　▲▲▲-----\n\n        // 配列から数値へ統合する\n        //copy.numIntegration();\n\n        // 入れ替え回数をインクリメントする\n        sortCount++;\n\n        if( reachGoal(movePanel) == false )\n        {\n            // 並び替えたものをキューに入れ直す\n            if( searchPanelStatus(movePanel) == true )\n            {\n                // 未検索の数値のみキューにプッシュする\n                q_P.push(make_pair(movePanel, sortCount));\n            }\n        }\n        else\n        {\n            ret = true;\n        }\n\n        return ret;\n    }\n\n    // ------------------\n    // x 方向のパネルを移動\n    // ------------------\n    // x : パネル位置の x 座標\n    // y : パネル位置の y 座標\n    // 戻り値 : true - 目標到達, false : 目標に到達していない\n    bool moveX(int x, int y)\n    {\n        bool ret = false;\n\n        // 関数コール後の x は値が変わるので元の値を覚えておく\n        int nowX = x;\n\n        switch (x)\n        {\n            case 0:\n                // 下のパネルと交換\n                panelShift_X(LOW, x);\n                ret = panelSwap(x, y);\n                break;\n\n            case 1:\n\n                // 上のパネルと交換\n                panelShift_X(UP, x);\n                ret = panelSwap(x, y);\n\n                if( ret == false )\n                {\n                    x = nowX;\n\n                    // 下のパネルと交換\n                    panelShift_X(LOW, x);\n                    ret = panelSwap(x, y);\n                }\n\n                break;\n\n            case 2:\n                // 上のパネルと交換\n                panelShift_X(UP, x);\n                ret = panelSwap(x, y);\n\n                break;\n        }\n\n        return ret;\n    }\n\n    // ------------------\n    // y 方向のパネルを移動\n    // ------------------\n    // puz : パネルの状態を保持する配列\n    // x : パネル位置の x 座標\n    // y : パネル位置の y 座標\n    // 戻り値 : true - 目標到達, false : 目標に到達していない\n    bool moveY(int x, int y)\n    {\n        bool ret = false;\n\n        // 関数コール後の y は値が変わるので元の値を覚えておく\n        int nowY = y;\n\n        switch (y)\n        {\n            case 0:\n                // 右のパネルと交換\n                panelShift_Y(RIGHT, y);\n                ret = panelSwap(x, y);\n                break;\n\n            case 1:\n\n                // 左のパネルと交換\n                panelShift_Y(LEFT, y);\n                ret = panelSwap(x, y);\n\n                if( ret == false )\n                {\n                    y = nowY;\n\n                    // 右のパネルと交換\n                    panelShift_Y(RIGHT, y);\n                    ret = panelSwap(x, y);\n                }\n\n                break;\n\n            case 2:\n                // 左のパネルと交換\n                panelShift_Y(LEFT, y);\n                ret = panelSwap(x, y);\n\n                break;\n        }\n\n        return ret;\n    }\n\n    // -------------------------------------\n    // 移動後のパネルが目標に到達しているかを確認\n    // -------------------------------------\n    // puz : パネルの状態を保持する配列\n    // x : パネル位置の x 座標\n    // y : パネル位置の y 座標\n    // 戻り値 : true - 目標到達, false : 目標に到達していない\n    bool panelSwap(int x, int y)\n    {\n        bool ret = false;\n        int movePos;\n\n        // 移動させる前に複製を作っておく\n        //PuzzleOperation copy = puz;\n\n        // 座標から配列の要素No.へ変換する\n        movePos = calcArrayNum(x, y);\n        // 数値を入れ替える\n        ret = panelReplacement(movePos);\n\n        return ret;\n    }\n\n    // x, y 座標から配列の要素数へ変換する関数\n    int calcArrayNum(int x, int y)\n    {\n        return 3 * x + y;\n    }\n\n    // パネルの移動後の X 座標を計算する関数\n    void panelShift_X(int moveNum, int &x)\n    {\n        switch ( moveNum )\n        {\n            case UP:\n                x = x - 1;\n                break;\n\n            case LOW:\n                x = x + 1;\n                break;\n\n            default:\n                // x をそのまま返す\n                break;\n        }\n    }\n\n    // パネルの移動後の Y 座標を計算する関数\n    void panelShift_Y(int moveNum, int &y)\n    {\n        switch ( moveNum )\n        {\n            case LEFT:\n                y = y - 1;\n                break;\n\n            case RIGHT:\n                y = y + 1;\n                break;\n\n            default:\n            // y をそのまま返す\n                break;\n        }\n    }\n\n    // 検索したパネルの並びを記憶して、過去のパネル状態との比較もする\n    // puz   : 整数値に置き換えるパネルの状態\n    // 戻り値 : true - 新しいパターン, false : 検索済みのパターン\n    bool searchPanelStatus(int p)\n    {\n        int ret = false;\n\n        if( !Map_V[p] )\n        {\n            // --- 指定値が未検索の時 ---\n\n            // 検索済みであることを記憶する\n            Map_V[p] = true;\n            ret = true;\n        }\n\n        return ret;\n\n    }\n\n};\n\n// ----------------\n// 8パズルを解く関数\n// ----------------\n// 戻り値 : パネルの移動回数\nint solveEightPuzzle()\n{\n    int count = 0;\n\n    while( !q_P.empty() )\n    {\n        pair<int, int> q_element;\n        PuzzleOperation puz;\n\n        q_element = q_P.front();\n        q_P.pop();\n\n        // キューから取り出した値を設定する\n        puz.panel = q_element.first;\n        puz.sortNum = q_element.second;\n\n        // 整数値からパネルの並びへと分割する\n        if( puz.panelMove() == true )\n        {\n            // puz の状態は正解の一つ前の状態なので, 最終的な回数として1を足しておく\n            count = puz.sortNum + 1;\n            break;\n        }\n    }\n\n    return count;\n}\n\nint main(void)\n{\n\n    int count = 0;\n    int panelCond = 0;\n\n    PuzzleOperation puz;\n\n    int ary_panel[PANEL_NUM];\n\n    // 初期状態を設定する\n    for(int i = 0; i < PANEL_NUM; i++)\n    {\n        cin >> ary_panel[i];\n    }\n\n    // 数値に変換する\n    // 8個の配列要素から, panel に数値を設定する\n    for(int i = 0; i < PANEL_NUM; i++)\n    {\n        // 4bit 左にシフトする\n        panelCond = panelCond << 4;\n        // 数値に変換する\n        panelCond += ary_panel[i] & 0xF;\n    }\n\n    // 初期状態の設定\n    puz.panel = panelCond;\n    puz.sortNum = 0;\n\n    q_P.push(make_pair(puz.panel, 0));\n    puz.searchPanelStatus(puz.panel);\n\n    if( puz.reachGoal(panelCond) == false )\n    {\n        // 最初の入力が正解で無ければ, 探索を開始する\n        count = solveEightPuzzle();\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define NUM 3\n#define PRUNING 10\n\ntypedef struct STATUS{\n    int num;\n    int board[NUM][NUM];\n}STATUS;\n\nbool checkfinish(STATUS in){\n    \n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            if (i == NUM - 1 && j == NUM - 1) return true;\n            if(in.board[i][j] != val++) return false;\n        }\n    }\n    return true;\n}\n\n\nint backtrack(STATUS in){\n\n    int x = 0, y = 0, ret = PRUNING;\n    STATUS out;\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    \n    if (in.num > ret) {\n        return ret;\n    }\n    \n    if (checkfinish(in)) {\n        return in.num;\n    }\n\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            if(in.board[i][j] == 0){\n                x = j;\n                y = i;\n            }\n        }\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (x + dx[i] >=0 && x+dx[i] < NUM && y+dy[i] >=0 && y+dy[i] < NUM) {\n            memcpy(&out, &in, sizeof(STATUS));\n            swap(out.board[y][x], out.board[y+dy[i]][x+dx[i]]);\n            out.num++;\n            ret = min(ret, backtrack(out));\n        }\n    }\n    return ret;\n}\n\n\nint main(){\n    \n    int val, ans;\n    \n    STATUS init;\n    init.num = 0;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            cin >> val;\n            init.board[i][j] = val;\n        }\n    }\n    \n    ans = backtrack(init);\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle\n{\nint f[N2];\nint space;\nstring path;\nbool operator < (const Puzzle &p) const\n{\nfor(int i=0;i<N2;i++)\n{\nif(f[i]==p.f[i]) continue;\nreturn f[i]>p.f[i];\n}\nreturn false;\n}\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p)\n{\nfor(int i=0;i<N2;i++)\nif(p.f[i]!=(i+1)) return false;\nreturn true;\n}\n\nstring bfs(Puzzle s)\n{\nqueue<Puzzle> Q;\nmap<Puzzle,bool> V;\nPuzzle u,v;\ns.path= \"\";\nQ.push(s);\nV[s]=true;\n\nwhile(!Q.empty())\n{\nu=Q.front(); Q.pop();\nif(isTarget(u)) return u.path;\nint sx=u.space/N;\nint sy=u.space%N;\nfor(int r=0;r<4;r++)\n{\nint tx=sx+dx[r];\nint ty=sy+dy[r];\nif(tx<0||ty<0||tx>=N||ty>=N) continue;\nv=u;\nswap(v.f[u.space],v.f[tx*N+ty]);\nv.space=tx*N+ty;\nif(!V[v])\n{\nV[v]=true;\nv.path+=dir[r];\nQ.push(v);\n\n}\n}\n}\nreturn \"unsolvable\";\n}\n\nint main()\n{\nPuzzle in;\n\nfor(int i=0;i<N2;i++)\n{\ncin >>in.f[i];\nif(in.f[i]==0)\n{\nin.f[i]=N2;\nin.space=i;\n}\n}\nstring ans=bfs(in);\ncout << ans.size()<<endl;\n\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <array>\n#include <unordered_set>\n#include <queue>\nusing namespace std;\n\n#define si static inline\n#define gcu getchar_unlocked\nsi int in() {\n\tint n = 0, c = gcu();\n\t// bool minus = false; if (c == '-') minus = true, c = gcu();\n\tdo {n = 10 * n + (c - '0'), c = gcu();} while (c >= '0');\n\treturn n; }\n\t// return minus ? -n : n; }\nsi void scan(char *s) {while (!isspace(*s++ = gcu()));}\n#define pcu putchar_unlocked\n#define svo si void out\ntemplate <typename T>\nsvo(T n) {\n\tstatic char buf[20];\n\tchar *p = buf;\n\t//if(n < 0) pcu('-'), n *= -1;\n\tif (!n) *p++ = '0';\n\telse while (n) *p++ = n % 10 + '0', n /= 10;\n\twhile (p != buf) pcu(*--p); }\nsvo(const char *s){while(*s)pcu(*s++);}\nsvo(char *s){while(*s)pcu(*s++);}\nsvo(char c){pcu(c);}\n//template <typename T>\n//svo(vector<T> &v){for(T &x:v)out(' '),out(x);out('\\n');}\n//svo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);out('\\n');}\ntemplate <typename head, typename... tail>\nsvo(head&& h, tail&&... t){out(h);out(move(t)...);}\n#undef svo\n#undef si\n\nstruct board {\n\tenum {size = 3};\n\tstruct pos {int r, c;};\n\ttypedef array<array<int, size>, size> arr;\n\n\tarr b;\n\tpos p;\n\tint f, g, h;\n\n\tvoid read() {\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tb[i][j] = in();\n\t\t\t\tif (!b[i][j])\n\t\t\t\t\tp.r = i, p.c = j;\n\t\t\t}\n\t\tg = 0;\n\t\tf = h = hn(b);\n\t}\n\n\tvoid print() {\n\t\tfor (auto &r: b) {\n\t\t\tfor (int &c: r)\n\t\t\t\tout(&c == &r[0]?\"\":\" \", c);\n\t\t\tout('\\n');\n\t\t}\n\t\tout('\\n');\n\t}\n\n\tstatic int hn(const arr &a) {\n\t\tint l = 0;\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tif (!a[i][j])\n\t\t\t\t\tcontinue;\n\t\t\t\tint k = a[i][j] - 1;\n\t\t\t\tl += abs(i - k / size) + abs(j - k % size);\n\t\t\t}\n\t\treturn l;\n\t}\n\n\tstatic int key(const arr &a) {\n\t\tint k = 0;\n\t\tfor (auto &r: a)\n\t\t\tfor (int c: r)\n\t\t\t\tk = (k * 10) + c;\n\t\treturn k;\n\t}\n\n\tint solver() {\n\t\tstatic const pos to[] = {-1, 0, 0, -1, 1, 0, 0, 1};\n\t\tunordered_set<int> m;\n\t\tpriority_queue<board> q;\n\t\tq.push(*this);\n\t\twhile (!q.empty()) {\n\t\t\tboard a = q.top();\n\t\t\tq.pop();\n\t\t\tint k = key(a.b);\n\t\t\tif (m.count(k))\n\t\t\t\tcontinue;\n\t\t\tm.insert(k);\n\t\t\tif (!a.h)\n\t\t\t\treturn a.g;\n\t\t\tfor (pos o: to) {\n\t\t\t\to.r += a.p.r, o.c += a.p.c;\n\t\t\t\tif (0 <= o.r && o.r < size && 0 <= o.c && o.c < size) {\n\t\t\t\t\tboard c = a;\n\t\t\t\t\tswap(c.b[a.p.r][a.p.c], c.b[o.r][o.c]);\n\t\t\t\t\tc.g += 1;\n\t\t\t\t\tc.h = hn(c.b);\n\t\t\t\t\tc.f = c.g + c.h;\n\t\t\t\t\tc.p = o;\n\t\t\t\t\tq.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\nbool operator < (const board &a, const board &b) {\n\treturn a.f > b.f;\n}\n\nint main() {\n\tboard b;\n\tb.read();\n\tout(b.solver(), '\\n');\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n    \n    bool operator < ( const Puzzle &p ) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {\n    -1, 0, 1, 0\n};\nstatic const int dy[4] = {\n    0, -1, 0, 1\n};\nstatic const char dir[4] = {\n    'u', 'l', 'd', 'r'\n};\n\nbool isTarget(Puzzle p) {\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != (i + 1)) return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle s) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n    \n    while( !Q.empty()) {\n        u = Q.front();\n        Q.pop();\n        if ( isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; r++) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if ( !V[v]) {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    \n    return \"unsolvable\";\n}\n\nint main() {\n    Puzzle in;\n    \n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nnamespace eight_puzzle{\n\ttypedef unsigned int uint;\n\tconst int N = 3;\n\tstruct State{\n\t\tState(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t}\n\t\tState(const uint tt,const uint tn){\n\t\t\ttable = tt;\n\t\t\tn = tn;\n\t\t}\n\n\t\tState& operator=(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t\treturn (*this);\n\t\t}\n\t\tbool isfinished(){\n\t\t\t\treturn table == 123456780;\n\t\t}\n\t\t\n\t\tuint table;\n\t\tuint n;\n\t};\n\tuint arraytovalue(int *table){\n\t\tuint t=0;\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tt*=10;\n\t\t\tt=t+table[i];\n\t\t}\n\t\treturn t;\n\t}\n\tvoid getnextstate(const State &s,std::vector<State> &states){\n\t\tint table[N*N];\n\t\tint t = s.table;\n\t\tint zi,zj;\n\t\tfor(int i=N-1;i>=0;--i){\n\t\t\tfor(int j=N-1;j>=0;--j){\n\t\t\t\tint panel = t-t/10*10;\n\t\t\t\ttable[i*N+j] = panel;\n\t\t\t\tt/=10;\n\t\t\t\tif(panel==0){\n\t\t\t\t\tzi = i;\n\t\t\t\t\tzj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=-1;i<=1;++i){\n\t\t\tfor(int j=-1;j<=1;++j){\n\t\t\t\tif((i+j)%2==0)continue;\n\t\t\t\tint ti = zi+i,tj=zj+j;\n\t\t\t\tif(0<=ti&&ti<N&&0<=tj&&tj<N){\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t\tstates.push_back(State(arraytovalue(table),s.n+1));\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tconst int MAX_N = 900000000;\n\tstd::vector<bool> visited(MAX_N);\n\t\n};\n\nint main(){\n\tusing namespace eight_puzzle;\n\tint array[N*N];\n\tfor(int i=0;i<N*N;++i){\n\t\tstd::cin>>array[i];\n\t}\n\tState init(arraytovalue(array),0);\n\n\tstd::queue<State> Q;\n\tQ.push(init);\n\twhile(!Q.empty()){\n\t\tState s = Q.front();\n\t\tQ.pop();\n\t\tstd::vector<State> states;\n\t\tgetnextstate(s,states);\n\t\tfor(uint i=0;i<states.size();++i){\n\t\t\tif(states[i].isfinished()){\n\t\t\t\tstd::cout<<states[i].n<<std::endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(!eight_puzzle::visited[states[i].table]){\n\t\t\t\tQ.push(states[i]);\n\t\t\t\teight_puzzle::visited[states[i].table]=true;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define EPS (1e-10)\n#define rep(i, a, b) for (int i = a; i < (int)(b); ++i)\n#define rrep(i, a, b) for (int i = b - 1; i >= (int)(a); --i)\n\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vd = vector<double>;\nusing vvi = vector<vi>;\n\nconstexpr int N = 3;\nconstexpr int N2 = 9;\nconstexpr int dx[4] = {0, -1, 0, 1};\nconstexpr int dy[4] = {1, 0, -1, 0};\n\nstruct Puzzle {\n    int f[N2], z_pos, MD;\n    int depth;\n    bool operator<(const Puzzle& pz) const {\n        rep(i, 0, N2) {\n            if (f[i] == pz.f[i]) { continue; }\n            return f[i] < pz.f[i];\n        }\n        return false;\n    }\n};\n\nstruct State {\n    Puzzle pz;\n    int estimate;\n    bool operator<(const State& st) const { return estimate > st.estimate; }\n};\n\nvoid init_MD(vvi& MDT) {\n    rep(i, 0, N2) {\n        rep(j, 0, N2) { MDT[i][j] = abs(i / N - j / N) + abs(i % N - j % N); }\n    }\n}\n\nint get_md(const Puzzle& pz, const vvi& MDT) {\n    int sum = 0;\n    rep(i, 0, N2) {\n        if (pz.f[i] == N2) { continue; }\n        sum += MDT[i][pz.f[i] - 1];\n    }\n    return sum;\n}\n\nint astar(const Puzzle& pz, const vvi& MDT) {\n    State init;\n    init.pz = pz;\n    init.pz.depth = 0;\n    init.pz.MD = get_md(init.pz, MDT);\n    init.estimate = init.pz.MD;\n\n    priority_queue<State> PQ;\n    PQ.push(init);\n\n    map<Puzzle, bool> seen;\n\n    while (!PQ.empty()) {\n        State st = PQ.top();\n        PQ.pop();\n\n        if (st.pz.MD == 0) { return st.pz.depth; }\n        seen[st.pz] = true;\n\n        int sx = st.pz.z_pos % N;\n        int sy = st.pz.z_pos / N;\n\n        rep(i, 0, 4) {\n            int tx = sx + dx[i];\n            int ty = sy + dy[i];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N) { continue; }\n\n            State next = st;\n            next.pz.MD -= MDT[ty * N + tx][next.pz.f[ty * N + tx] - 1];\n            next.pz.MD += MDT[sy * N + sx][next.pz.f[ty * N + tx] - 1];\n\n            swap(next.pz.f[sy * N + sx], next.pz.f[ty * N + tx]);\n            next.pz.z_pos = ty * N + tx;\n\n            if (!seen[next.pz]) {\n                ++next.pz.depth;\n                next.estimate = next.pz.depth + next.pz.MD;\n                PQ.push(next);\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    Puzzle pz;\n    rep(i, 0, N2) {\n        cin >> pz.f[i];\n        if (pz.f[i] == 0) {\n            pz.f[i] = N2;\n            pz.z_pos = i;\n        }\n    }\n\n    vvi MDT(N2, vi(N2));\n    init_MD(MDT);\n\n    cout << astar(pz, MDT) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 10010;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> Array;\ntypedef vector<Array> Graph;\ntypedef pair<double, double> pdd;\nconst ull mod = 1000000000 + 7;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\nconst int CODE_MAX = 362880;\nconst int SIZE = 9;\nint visited[CODE_MAX];\n\nint factorial(int n){\n    if(n==1) return 1;\n    return n*factorial(n-1);\n};\n\nstruct Board{\n    int num[SIZE];\n    void print(){\n        for(int i=0;i<SIZE;i++) cout << num[i] << \" \";\n        cout << endl;\n    }\n};\n\nint encode(Board &b){\n    int res = 0;\n    int temp_b[SIZE];\n    for(int i=0;i<SIZE;i++) temp_b[i] = b.num[i];\n    for(int i=0;i<SIZE-1;i++){\n        res += factorial(SIZE-1-i)*temp_b[i];\n        for(int j=i+1;j<SIZE-1;j++){\n            if(temp_b[i]<temp_b[j]) temp_b[j]--;\n        }\n    }\n   return res;\n}\n\nBoard decode(int encoded){\n    Board b;\n    int tmp[SIZE];\n    for(int i=0;i<SIZE-1;i++){\n        int fact = factorial(SIZE-1-i);\n        tmp[i] = encoded/fact;\n        encoded %= fact;\n    }\n    tmp[SIZE-1] = 0;\n    int tmp2[SIZE];\n    bool check[SIZE];\n    for(int i=0;i<SIZE;i++){\n        tmp2[i] = i;\n        check[i] = false;\n    }\n    for(int i=0;i<SIZE;i++){\n        int j=0;\n        while(tmp[i]!=tmp2[j] || check[j]) j++;\n        b.num[i] = j;\n        check[j] = true;\n        while(j<SIZE){\n            tmp2[j]--;\n            j++;\n        }\n    }\n\n    return b;\n}\n\nint get_adjacent(int now, int i){\n    // \"i\" represents the direction of zero movement.0 up, 1 down, 2 left, 3 right\n    Board b = decode(now);\n    int zero=0;\n    while(b.num[zero]!=0) zero++;\n    if(i==0){\n        if(zero<3) return -1;\n        swap(b.num[zero], b.num[zero-3]);\n    }\n    if(i==1){\n        if(zero>5) return -1;\n        swap(b.num[zero], b.num[zero+3]);\n    }\n    if(i==2){\n        if(zero%3<1) return -1;\n        swap(b.num[zero], b.num[zero-1]);\n    }\n    if(i==3){\n        if(zero%3>1) return -1;\n        swap(b.num[zero], b.num[zero+1]);\n    }\n    return encode(b);\n}\n\nint heuristic_func(int enc1, int enc2){\n    Board b1 = decode(enc1);\n    int zero1 = 0;\n    while(b1.num[zero1]!=0) zero1++;\n    Board b2 = decode(enc2);\n    int zero2 = 0;\n    while(b2.num[zero2]!=0) zero2++;\n    return abs(zero1/3 - zero2/3) + abs(zero1%3 - zero2%3);\n}\n/*\nint heuristic_func2(int enc1, int enc2){\n    Board b1 = decode(enc1);\n    Board b2 = decode(enc2);\n    for(int i=0;i<SIZE;i++){\n        int pos1 = 0;\n        int pos2 = 0;\n        while(zero1!=i)\n    }\n}\n*/\n\nint main(){\n    Board b;\n    for (int i=0;i<SIZE;i++){\n        cin >> b.num[i];\n    }\n    for(int i=0;i<CODE_MAX;i++){\n        visited[i] = -1;\n    }\n\n    const int start = encode(b);\n    const int goal = 46233;\n    priority_queue<pii, vector<pii>, greater<pii> > que;\n    que.push(make_pair(heuristic_func(start, goal), start));\n    visited[start] = 0;\n    int count = 0;\n    while(visited[goal]==-1){\n        pii x = que.top();\n        que.pop();\n        int now = x.second;\n        for(int i=0;i<4;i++){\n            int adj = get_adjacent(now, i);\n            if(adj==-1 || visited[adj]!=-1) continue;\n            count++;\n            visited[adj] = visited[now]+1;\n            que.push(make_pair(heuristic_func(adj, goal) + visited[adj], adj));\n        }\n    }\n    cout << visited[goal] << endl;\n    //cout << count << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 5;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n        return;\n    }\n    if (ms[in] || ministep < i) {\n        return;\n    }\n\n    if (in.path == \"ldrd\")\n        int debug = 0;\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n        cout << \"(i = \" << i << \") \" << in.path << endl;\n        for (int j = 0; j < N2; j++)\n            cout << \" \" << in.f[j];\n        cout << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n//    ms[in] = true;\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<unordered_set>\nusing namespace std;\n\nconst int D_x[4] = { 0,1,0,-1 };\nconst int D_y[4] = { 1,0,-1,0 };\nconst int ANS = 123456780;\n\nvoid setNum(int puzzle[3][3],int n) {\n\tfor (int i = 2; i >= 0; i--) {\n\t\tfor (int j = 2; j >= 0; j--) {\n\t\t\tpuzzle[i][j] = n % 10;\n\t\t\tn /= 10;\n\t\t}\n\t}\n}\n\nint getNum(int puzzle[3][3]) {\n\tint res = 0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tres *= 10;\n\t\t\tres += puzzle[i][j];\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid find_0(int puzzle[3][3], int& x, int& y) {\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tif (puzzle[i][j] == 0) {\n\t\t\t\tx = j;\n\t\t\t\ty = i;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve(int puzzle[3][3]) {\n\tqueue<int> q;\n\tunordered_set<int> table;\n\tint cnt = 1;\n\n\tq.push(getNum(puzzle));\n\tif (q.front() == ANS)return 0;\n\twhile (true) {\n\t\tint s = q.size();\n\n\t\tfor (int i = 0; i < s; i++) {\n\t\t\tint x, y;\n\t\t\tsetNum(puzzle, q.front());\n\t\t\tfind_0(puzzle, x, y);\n\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tint X = x + D_x[j];\n\t\t\t\tint Y = y + D_y[j];\n\t\t\t\tif (X < 0 || Y < 0 || X >= 3 || Y >= 3)continue;\n\t\t\t\tsetNum(puzzle, q.front());\n\t\t\t\tswap(puzzle[y][x], puzzle[Y][X]);\n\n\t\t\t\tint n = getNum(puzzle);\n\t\t\t\tif (n == ANS) {\n\t\t\t\t\treturn cnt;\n\t\t\t\t}\n\t\t\t\tif (table.count(n) == 0) {\n\t\t\t\t\ttable.insert(n);\n\t\t\t\t\tq.push(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.pop();\n\t\t}\n\t\tcnt++;\n\t}\n}\n\nint main() {\n\tint puzzle[3][3];\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tcin >> puzzle[i][j];\n\t\t}\n\t}\n\n\tcout << solve(puzzle) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\nusing namespace std;\nconst int N = 3;\nconst int N2 = 9;\nvector<int> in(N2);\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\nconst char dir[4] = {'u', 'l', 'd', 'r'};\nstruct Puzzle\n{\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle p)\n{\n    map<Puzzle, bool> mp;\n    queue<Puzzle> mq;\n    Puzzle u, v;\n    mp[p] = true;\n    mq.push(p);\n    while(!mq.empty()) {\n        u = mq.front();\n        mq.pop();\n        if (isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n\n        for (int r = 0; r < 4; r++) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N)\n                continue;\n            v = u;\n            swap(v.f[tx * N + ty], v.f[sx * N + sy]);\n            v.space = tx * N + ty;\n\n            if (!mp[v]) {\n                mp[v] = true;\n                v.path += dir[r];\n                mq.push(v);\n            }\n        }\n    }\n    return \"unsolveable\";\n}\n\nint main()\n{\n    Puzzle in;\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            in.space = i;\n            in.f[i] = N2;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cassert>\n#include <map>\nusing namespace std;\n\nclass state{\npublic:\n  int* num;\n  int time;\n  int space;\n\n  state(){\n    num = new int[9];\n  }\n\n  state(int time){\n    num = new int[9];\n    this->time = time;\n  }\n\n  state(const state &st){\n    num = new int[9];\n    for(int i=0; i<9; i++) num[i]=st.num[i];\n    time = st.time;\n    space = st.space;\n  }\n\n  ~state(){\n    delete[] num;\n  }\n\n  bool operator < (const state&a) const{\n    for(int i=0; i<9; i++){\n      if(num[i]==a.num[i]) continue;\n      return num[i] < a.num[i];\n    }\n    return false;\n  }\n\n  bool check_ans(){\n    bool flag=true;\n    for(int i=0; i<9; i++){\n      if(num[i]!=i+1) flag=false;\n    }\n    return flag;\n  }\n\n  //コード1~4を指定して、パズルを移動させる\n  state operate(int i){\n    int dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};//移動方向\n    int nx = space%3+dx[i], ny = space/3+dy[i];\n    state ns=*this;\n    ns.swap(ny*3+nx, space);\n\n    ns.time=time+1;\n    ns.space=ny*3+nx;\n\n    return ns;\n  }\n\n  bool direction_check(int i){\n    int dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};//移動方向\n    int nx = space%3+dx[i], ny = space/3+dy[i];\n    if(nx<0 || 2<nx || ny<0 || 2<ny) return false;\n    return true;\n  }\nprivate:\n  //numのn1番目の要素とn2番目の要素を入れ替える\n  void swap(int n1, int n2){\n    int temp=num[n1];\n    num[n1]=num[n2];\n    num[n2]=temp;\n  }\n};\nint main(){\n  state start(0);//初期状態の生成\n  for(int i=0; i<9; i++) {\n    cin >> start.num[i];\n    if(start.num[i]==0){\n      start.num[i]=9;\n      start.space=i;\n    }\n  }\n\n  //重複を避けるためのmap\n  map<state, bool> mp;\n  mp[start]=true;\n\n  //bfs用のqueue生成\n  queue<state> q; q.push(start);\n\n  //queueが空になるまで\n  while(!q.empty()){\n    state now=q.front(); q.pop();\n\n    //もし取り出した状態が所望の状態なら、かかった回数を表示して終了\n    if(now.check_ans()){\n      cout << now.time << endl;\n      break;\n    }\n\n    for(int i=0; i<4; i++){\n      if(!now.direction_check(i)) continue;\n      state ns=now.operate(i);\n      if(!mp[ns]){\n        mp[ns]=true;\n        q.push(ns);\n      }\n    }\n\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <map>\n#include <memory>\n#include <set>\n#include <vector>\n#include <deque>\n#include <list>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\nstruct state\n{\n  vector<vector<int>> bd;\n  int cnt;\n};\n\nclass EightPuzzle\n{\npublic:\n  queue<state> q;\n  map<vector<vector<int>>,bool> m;\n  vector<vector<int>> goal;\n  vector<int> dr,dc;\n  EightPuzzle(){}\n  EightPuzzle( state st ){ q.push(st); goal = {{1,2,3},{4,5,6},{7,8,0}}; dr = {1, -1, 0, 0}; dc = {0, 0, 1, -1}; }\n  int solve();\n  void find0( vector<vector<int>> &b, int &x, int &y );\n};\n\nvoid EightPuzzle::find0( vector<vector<int>> &b, int &r, int &c )\n{\n  for ( r = 0; r < 3; ++r )\n    for ( c = 0; c < 3; ++c )\n      if ( b[r][c] == 0 ) return;\n}\n\nint EightPuzzle::solve()\n{\n  while ( ! q.empty() )\n    {\n      state st = q.front();\n      \n      if ( st.bd == goal )\n        {\n          cout << st.cnt << endl;\n          return 0;\n        }\n\n      int r, c;\n      find0( st.bd, r, c );\n\n      for ( auto i = 0; i < 4; ++i )\n        {\n          int nr = r + dr[i];\n          int nc = c + dc[i];\n          if ( nr < 0 || nr > 2 || nc < 0 || nc > 2 ) continue;\n\n          state nst = st;\n          nst.bd[r][c] = st.bd[nr][nc];\n          nst.bd[nr][nc] = 0;\n          nst.cnt = st.cnt + 1;\n\n          if ( m.count(nst.bd) == 0 )\n            {\n              q.push(nst);\n              m[nst.bd] = true;\n            }\n        }\n      q.pop();\n    }\n  \n  return 0;\n}\n\nint main()\n{\n  state st;\n  st.cnt = 0;\n  \n  for ( auto i = 0; i < 3; ++i )\n    {\n      vector<int> vl;\n      for ( auto j = 0; j < 3; ++j )\n        {\n          int v;\n          cin >> v;\n          vl.push_back(v);\n        }\n      st.bd.push_back(vl);\n    }\n\n  EightPuzzle ep( st );\n\n  ep.solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define ll long long\n#define endl '\\n'\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator<(const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'}; // dir:direction\n\nbool isTarget(Puzzle p) {\n    for (int i = 0; i < N2; i++)\n        if (p.f[i] != (i + 1)) return false;\n    return true;\n}\n\nstring bfs(Puzzle s) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while (!Q.empty()) {\n        u = Q.front();\n        Q.pop();\n        if (isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; r++) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if (!V[v]) {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n\n    return \"unsolvable\";\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Puzzle in;\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            in.f[i] = N2;  // set space\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\nvector<int> searched[9];\n\nclass board{\nprivate:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<int> tiles;\n\npublic:\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        REP(i, 9){\n            tiles.push_back(num[i]);\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n    }\n\n    int cost() {\n        return wrongs + moves;\n    }\n\n    void board_to_int(){\n        int k;\n        REP(i, 9)\n            k += (tiles[i] * pow(10, i));\n        REP(i, searched[tiles[0]].size())\n            if(k == searched[tiles[0]][i]){\n                pq.pop();\n                return;\n            }\n        searched[tiles[0]].push_back(k);\n        return;\n    }\n\n    void move() {\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            pq.push(board(tiles, moves+1));\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            pq.push(board(tiles, moves+1));\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            pq.push(board(tiles, moves+1));\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            pq.push(board(tiles, moves+1));\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\nbool operator< (board b1, board b2){\n    return (b1.cost() > b2.cost()) ? true : false;\n}\n\nint solve(){\n    pq.push(board(original, 0));\n    while(!pq.empty()){\n        auto target = pq.top();\n        pq.pop();\n        if(target.cost() > 100)\n            return -1;\n        if(target.get_wrongs() == 0)\n            return target.cost();\n        target.move();\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = 0;\n    move = solve();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n#define N 3\n#define N2 9\nusing namespace std;\n \nstruct Puz{\n  int f[N2];\n  int space;\n  string path;\n  \n  bool operator < (const Puz &p) const{\n    for(int i = 0; i < N2; i++){\n      if(f[i]==p.f[i]) continue;\n      \n      return f[i]>p.f[i];\n      \n    }\n    \n    return false;\n    \n  }\n};\n \nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\nchar dir[4]={'u','l','d','r'};\n \nbool check(Puz p){\n  for(int i = 0; i < N2; i++){\n    if(p.f[i] != (i+1)) return false;\n  }\n  \n  return true;\n\n}\n \nstring bfs(Puz s){\n  queue<Puz> Q;\n  map<Puz,bool> V;\n  Puz u, v;\n  \n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n   \n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n    \n    if(check(u)) return u.path;\n    \n    int sx = u.space / N;\n    int sy = u.space % N;\n    \n    for(int i = 0; i < 4; i++){\n      int tx = sx + dx[i];\n      int ty = sy + dy[i];\n      \n      if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      \n      v=u;\n      swap(v.f[u.space], v.f[tx*N+ty]);\n      \n      v.space = tx * N + ty;\n      \n      if(!V[v]){\n\tV[v] = true;\n\tv.path += dir[i];\n\tQ.push(v);\n      }\n    }\n  }\n  \n  return \"unsolvable\";\n  \n}\n \nint main(){\n  Puz in;\n  for(int i = 0; i < N2; i++){\n    cin >> in.f[i];\n    \n    if(in.f[i] == 0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  \n  string ans = bfs(in);\n  \n  cout << ans.size() << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}};\nvector<int> tiles(9);\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    if(wrongs + moves >= cutoff)\n        return -1;\n    int zero;\n    REP(i, 9){\n        if(tiles[i] == 0){\n            zero = i;\n            break;\n        }\n    }\n    if(dir[zero][0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-1]);\n    }\n    if(dir[zero][1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-3]);\n    }\n    if(dir[zero][2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+3]);\n    }\n    if(dir[zero][3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+1]);\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n\n    REP(i, 50){\n        move = dfs(0, i);\n        if(move > 0){\n            break;\n        }\n        i += 5;\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const {\n    for(int i=0; i<N2; i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1);\nstatic const char dir[4] = {'u', 'l', 'd','r'};\n\nbool isTarget(Puzzle p) {\n  for(int i=0; i<N2; i++)\n    if(p.f[o] != (i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space/N;\n    int sy u.space%N;\n    for(int r=0; r<4; r++){\n      int tx = sx+dx[r];\n      int ty = sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n      v=u;\n      swap(v.f[u.space], v.f[tx*N+ty]);\n      v.space = tx*N+ty;\n      if(!V[v]){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"usdolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0; i<N2; i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in .space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<set>\nusing namespace std;\n\nstruct Node{\n\tvector<int> arr;\n\tint step;\n};\nconst int tx[]={1,0,-1,0};\nconst int ty[]={0,1,0,-1};\nvector<int> start,end;\nqueue<Node> sq;\nset<int> pan;\n\nvoid input()\n{\n\tint tmp;\n\tfor(int i=0;i!=3;++i)\n\t\tfor(int j=0;j!=3;++j)\n\t\t{\n\t\t\tcin>>tmp;\n\t\t\tstart.push_back(tmp);\n\t\t}\n\tfor(int i=0;i!=8;++i)\n\t\tend.push_back(i+1);\n\tend.push_back(0);\n}\n\nNode makenod(vector<int> tmp,int step)\n{\n\tNode res;\n\tres.arr=tmp;\n\tres.step=step;\n\treturn res;\n}\n\nint vton(vector<int> tmp)\n{\n\tint res=0;\n\tfor(int i=0;i!=9;++i)\n\t\tres=res*10+tmp[i];\n\treturn res;\n}\n\n/*\nvoid print(vector<int> tmp)\n{\n\tfor(int i=1;i!=10;++i)\n\t{\n\t\tcout<<tmp[i-1]<<' ';\n\t\tif(i%3==0)\tcout<<endl;\n\t}\n\tcout<<endl;\n}\n*/\nint main()\n{\n\tinput();\n\n\tsq.push(makenod(start,0));\n\tpan.insert(vton(start));\n\t\n\tint ans;\n\twhile(!sq.empty())\n\t{\n\t\tNode now=sq.front();\tsq.pop();\n\n\t\tprint(now.arr);\n\n\t\tif(now.arr==end)\n\t\t{\n\t\t\tans=now.step;\n\t\t\tbreak;\n\t\t}\n\n\t\tint ith;\n\t\tfor(int i=0;i!=9;++i)\n\t\t\tif(now.arr[i]==0)\n\t\t\t{\n\t\t\t\tith=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tint x=ith/3,y=ith%3;\n\t\t\n\t\tfor(int i=0;i!=4;++i)\n\t\t{\n\t\t\tint nx=x+tx[i],ny=y+ty[i];\n\t\t\tif(nx>=0 && nx<3 && ny>=0 && ny<3)\n\t\t\t{\n\t\t\t\tswap(now.arr[nx*3+ny],now.arr[ith]);\n\t\t\t\tint num=vton(now.arr);\n\t\t\t\tif(pan.count(num)==0)\n\t\t\t\t{\n\t\t\t\t\tsq.push(makenod(now.arr,now.step+1));\n\t\t\t\t\tpan.insert(num);\t\t\n\t\t\t\t}\n\t\t\t\tswap(now.arr[nx*3+ny],now.arr[ith]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<ans<<endl;\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<string>\nusing namespace std;\n\nstatic const int N = 3;\nstatic const int N2 = 9;\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const int dir[4] = {'u', 'l', 'd', 'r'};\n\nstruct Puzzle {\n  int pas[N2], ss;\n  string path;\n\n  bool operator < (const Puzzle &p1) const {\n\n    for (int i = 0; i < N2; i++) {\n      if (pas[i] == p1.pas[i]) continue;\n      return pas[i] > p1.pas[i];\n    }\n    return false;\n  }\n};\n\nbool isTarget(Puzzle u) {\n  for (int i = 0; i < N2; i++) {\n    if (u.pas[i] != i + 1) return false;\n  }\n  return true;\n}\n\nstring bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map <Puzzle, bool> V;\n\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n  while (!Q.empty()) {\n    u = Q.front();\n    Q.pop();\n    if (isTarget(u)) return u.path;\n    int sx = u.ss / N;\n    int sy = u.ss % N;\n    for (int r = 0; r < 4; r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      v = u;\n      swap(v.pas[u.ss], v.pas[tx * N + ty]);\n      v.ss = tx * N + ty;\n      if (!V[v]) {\n\tV[v] = true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\n\nint main() {\n  Puzzle in;\n  for (int i = 0; i < N2; i++) {\n    cin >> in.pas[i];\n    if (!in.pas[i]) {\n      in.pas[i] = N2;\n      in.ss = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <stack>\n\nusing namespace std;\n\nint minimum=-1;\n\nint checkTable[362880];\t//????????¶????????????????????£??????????????????????????????????????????????????????????????????\n\nvoid setNUM(int table[3][3], long long x){\n\tint S = 100000000;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int k=0;k<3;k++){\n\t\t\ttable[i][k] = x/S;\n\t\t\tx = x%S;\n\t\t\tS /= 10;\n\t\t}\n\t}\n}\n\nint getNUM(int x){\n\tswitch(x){\n\tcase 0:return 1;\n\tcase 1:return 1;\n\tcase 2:return 2;\n\tcase 3:return 6;\n\tcase 4:return 24;\n\tcase 5:return 120;\n\tcase 6:return 720;\n\tcase 7:return 5040;\n\tcase 8:return 40320;\n\t}\n\treturn -1;\n}\n\nlong long makeLong(int Table[3][3]){\n\treturn 100000000*Table[0][0]+10000000*Table[0][1]+1000000*Table[0][2]+\n            100000*Table[1][0]+10000*Table[1][1]+1000*Table[1][2]+ 100*Table[2][0]+\n            10*Table[2][1]+Table[2][2];\n}\n\nint translateORDER(int Table[3][3]){\n\tlong long x = makeLong(Table);\n\tint checkTable[9] = {0};\n\tlong long S = 100000000;\n\tint ret = 0,small_num_appear_count;\n\tfor(int i=8; i >= 0; i--){\n\t\tsmall_num_appear_count=0;\n\t\tfor(int k = 0; k < (x/S);k++){\n\t\t\tif(checkTable[k] == 1)small_num_appear_count++;\n\t\t}\n\t\tret += ((x/S)-small_num_appear_count)*getNUM(i);\n\t\tcheckTable[(x/S)]=1;\n\t\tx %= S;\n\t\tS /= 10;\n\t}\n\n\treturn ret;\n}\n\n\nint calcDiffSum(int table[3][3]){\n\tint sum = 0;\n\tfor(int row=0;row<3;row++){\t//(table[row][col]-1)/3:??¬??\\???????????????(0???2)\n\t\tfor(int col=0;col<3;col++){ //(table[row][col]-1)%3:??¬??\\???????????????(0???2)\n\t\t\tif(table[row][col] != 0){\t//0?????\\??±???\n\t\t\t\tsum += abs((table[row][col]-1)/3-row) + abs((table[row][col]-1)%3-col);\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\n\nint zeroLoc(int table[3][3]){\n\tint zero_loc;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int k=0;k<3;k++){\n\t\t\tif(table[i][k]==0){\n\t\t\t\tzero_loc=10*i+k;\n\t\t\t}\n\t\t}\n\t}\n\treturn zero_loc;\n}\n\nint main(){\n\n\tfor(int i = 0; i < 362880;i++)checkTable[i]=-1;\n\n\tint table[3][3];\n\tstack<long long>A,B;\n\n\n\tfor(int i=0;i<3;i++){\n\t\tscanf(\"%d %d %d\",&table[i][0],&table[i][1],&table[i][2]);\n\t}\n\n\tcheckTable[translateORDER(table)]=0;\n\tA.push(makeLong(table));\n\tlong long tmp;\n\tbool foundFLG=false;\n\tint zero_loc;\n\n\tfor(int count=0;count < 362880;count++){\n\t\tif(count%2 == 0){\n\t\t\twhile(!A.empty()){\n\t\t\t\ttmp = A.top();\n\t\t\t\tA.pop();\n\t\t\t\tint tmpTable[3][3];\n\t\t\t\tsetNUM(tmpTable,tmp);\n\t\t\t\tif(calcDiffSum(tmpTable)==0){\n\t\t\t\t\tfoundFLG=true;\n\t\t\t\t\tprintf(\"%d\\n\",count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tint next_table[4][3][3];\n\n\t\t\t\tfor(int a=0;a<4;a++){\n\t\t\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\t\t\tnext_table[a][b][c] = tmpTable[b][c];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tzero_loc = zeroLoc(tmpTable);\n\t\t\t\tswitch(zero_loc){\n\t\t\t\tcase 0:\t//?§?\n\t\t\t\tcase 2:\n\t\t\t\tcase 20:\n\t\t\t\tcase 22:\n\t\t\t\t\tswap(next_table[0][zero_loc/10][zero_loc%10],next_table[0][zero_loc/10][abs(zero_loc%10-1)]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\n\t\t\t\t\tswap(next_table[1][zero_loc/10][zero_loc%10],next_table[1][abs(zero_loc/10-1)][zero_loc%10]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1://???\n\t\t\t\tcase 10:\n\t\t\t\tcase 12:\n\t\t\t\tcase 21:\n\t\t\t\t\tswap(next_table[0][zero_loc/10][zero_loc%10],next_table[0][abs(zero_loc/10-1)][zero_loc%10]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\n\t\t\t\t\tswap(next_table[1][zero_loc/10][zero_loc%10],next_table[1][zero_loc/10][abs(zero_loc%10-1)]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch(zero_loc){\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tswap(next_table[2][0][1],next_table[2][0][2]);\n\t\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\t\tB.push(makeLong(next_table[2]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 10:\n\t\t\t\t\t\tswap(next_table[2][1][0],next_table[2][2][0]);\n\t\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\t\tB.push(makeLong(next_table[2]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 12:\n\t\t\t\t\t\tswap(next_table[2][1][2],next_table[2][2][2]);\n\t\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\t\tB.push(makeLong(next_table[2]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 21:\n\t\t\t\t\t\tswap(next_table[2][1][2],next_table[2][2][2]);\n\t\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\t\tB.push(makeLong(next_table[2]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 11:\n\t\t\t\t\tswap(next_table[0][1][1],next_table[0][0][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][1][1],next_table[1][1][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[2][1][1],next_table[2][1][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[2]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[3][1][1],next_table[3][2][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[3])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[3])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[3]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}else{\n\t\t\twhile(!B.empty()){\n\t\t\t\ttmp = B.top();\n\t\t\t\tB.pop();\n\t\t\t\tint tmpTable[3][3];\n\t\t\t\tsetNUM(tmpTable,tmp);\n\t\t\t\tif(calcDiffSum(tmpTable)==0){\n\t\t\t\t\tfoundFLG=true;\n\t\t\t\t\tprintf(\"%d\\n\",count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\t\tint next_table[4][3][3];\n\n\t\t\t\tfor(int a=0;a<4;a++){\n\t\t\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\t\t\tnext_table[a][b][c] = tmpTable[b][c];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tzero_loc = zeroLoc(tmpTable);\n\t\t\t\tswitch(zero_loc){\n\t\t\t\tcase 0:\t//?§?\n\t\t\t\tcase 2:\n\t\t\t\tcase 20:\n\t\t\t\tcase 22:\n\t\t\t\t\tswap(next_table[0][zero_loc/10][zero_loc%10],next_table[0][zero_loc/10][abs(zero_loc%10-1)]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\n\t\t\t\t\tswap(next_table[1][zero_loc/10][zero_loc%10],next_table[1][abs(zero_loc/10-1)][zero_loc%10]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1://???\n\t\t\t\tcase 10:\n\t\t\t\tcase 12:\n\t\t\t\tcase 21:\n\t\t\t\t\tswap(next_table[0][zero_loc/10][zero_loc%10],next_table[0][abs(zero_loc/10-1)][zero_loc%10]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\n\t\t\t\t\tswap(next_table[1][zero_loc/10][zero_loc%10],next_table[1][zero_loc/10][abs(zero_loc%10-1)]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch(zero_loc){\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tswap(next_table[2][0][1],next_table[2][0][2]);\n\t\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\t\tA.push(makeLong(next_table[2]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 10:\n\t\t\t\t\t\tswap(next_table[2][1][0],next_table[2][2][0]);\n\t\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\t\tA.push(makeLong(next_table[2]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 12:\n\t\t\t\t\t\tswap(next_table[2][1][2],next_table[2][2][2]);\n\t\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\t\tA.push(makeLong(next_table[2]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 21:\n\t\t\t\t\t\tswap(next_table[2][1][2],next_table[2][2][2]);\n\t\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\t\tA.push(makeLong(next_table[2]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 11:\n\t\t\t\t\tswap(next_table[0][1][1],next_table[0][0][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][1][1],next_table[1][1][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[2][1][1],next_table[2][1][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[2]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[3][1][1],next_table[3][2][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[3])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[3])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[3]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(foundFLG)break;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator < (const Puzzle &p ) const{\n\t\tfor(int i=0;i<N2;i++){\n\t\t\tif(f[i] == p.f[i]) continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const int dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n\tfor(int i = 0;i<N2;i++)\n\tif(p.f[i] != (i+1) ) return false;\n\treturn true;\n}\n\nstring bfs(Puzzle s) {\n\tqueue<Puzzle> Q;\n\tmap<Puzzle,bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\t\n\twhile( !Q.empty() ){\n\t\tu = Q.front();Q.pop();\n\t\tif( isTarget(u) )return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor(int r = 0; r < 4 ; r++){\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space],v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif( !V[v] ){\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn \"unsolvable\";\n}\n\nint main(){\n\tPuzzle in;\n\t\n\tfor(int i = 0;i < N2; i++){\n\t\tcin >> in.f[i];\n\t\tif(in.f[i] == 0 ){\n\t\t\tin.f[i] = N2; // set space\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() <<  endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <cmath>\n#include <cassert>\n#include <string>\nusing namespace std;\n\n#define N1 3\n#define N2 9  \n#define LIMITMAX 100\n//#define false 0\n//#define true 1\n\nstruct PUZZLE{\n  int f[N2], kuuhaku ,MD;/*マンハッタン距離*/\n  //int cost;\n};\n\nstatic const int dx_123[4] = {0, -1, 0, 1};//４方向\nstatic const int dy_123[4] = {1, 0, -1, 0};//４方向\nstatic const char houkou[4] ={'r', 'u', 'l', 'd'};//右:right,　上:up,　左:left,　下:down\n\nint ManhattanDistance[N2][N2];\nPUZZLE jyoutai;\nint limit;//深さのlimit\nint miti[LIMITMAX];\n\nint GetallManhattanDistance(PUZZLE);\nbool dfs(int, int);\n//int max(int, int);\n//int min(int, int);\nstring  iterative_deepning(PUZZLE); //反復深化\n\n\nint main(){\n\n  int i,j,k;\n  PUZZLE in;\n  \n  for(i=0;i<N2;i++){\n    for(j=0;j<N2;j++){\n      ManhattanDistance[i][j] = abs( i/N1 - j/N1 ) + abs(i%N1 -j%N1); \n    }\n  }\n\n   \n  for(i=0;i<N2;i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] =  N2;\n      in.kuuhaku = i;\n    }\n  }\n\n  string kotae = iterative_deepning(in);\n\n  cout << kotae.size();\n  cout << endl;\n \n  return 0;\n}\n\n/*\n  void  swap(int *a , int *b){\n  int *tmp;\n  \n  tmp = a;\n  a = b ;\n  b = tmp;\n  \n  }\n*/\nint GetallManhattanDistance(PUZZLE p){//全てのマンハッタン距離を取得する\n\n  int goukei = 0;\n  int i,j,k;\n\n  for(i=0;i<N2;i++){\n    if(p.f[i] == N2)continue;\n    goukei += ManhattanDistance[i][p.f[i]-1];\n  }\n\n  return goukei;\n}\n\nbool dfs(int depth, int prev){\n\n  int i,j,k;\n  int r;\n  int sx,sy;\n  PUZZLE tmp;\n  int tx,ty;\n  \n  if(jyoutai.MD == 0) return true ;\n  //現在の深さにヒューリスティックを足して制限を超えたら枝を切る\n\n  if( depth + jyoutai.MD > limit ) return false;\n\n  sx = jyoutai.kuuhaku / N1;\n  sy = jyoutai.kuuhaku % N1;\n\n  for(r=0;r<4;r++){\n    tx = sx + dx_123[r];\n    ty = sy + dy_123[r];\n\n    if(tx < 0 || tx >= N1 || ty < 0 || ty >= N1 ) continue;\n    if(max(prev, r) - min(prev, r) == 2 ) continue;\n    tmp = jyoutai;\n    //マンハッタン距離の差分を計算しつつ、ピースをスワップ\n    jyoutai.MD -= ManhattanDistance[tx * N1 + ty][jyoutai.f[tx * N1 + ty]-1];\n    jyoutai.MD += ManhattanDistance[sx * N1 + sy][jyoutai.f[tx * N1 + ty]-1];\n    swap(jyoutai.f[tx * N1 + ty], jyoutai.f[sx * N1 + sy]);\n    jyoutai.kuuhaku = tx * N1 + ty;\n    if( dfs(depth + 1, r) ){\n      miti[depth] = r;\n      return true;\n    }\n    jyoutai = tmp;\n  }\n  \n  return false;\n}\n/*\n  int max(int a, int b){\n  if(a<b) return b;\n  return a;\n  }\n\n  int min(int a, int b){\n  if(a<b) return a;\n  return b;\n  }\n*/\n\n\n\n\nstring  iterative_deepning(PUZZLE in){//反復深化\n\n  int i,j,k;\n  //string  kotae = \"\";\n  //char kotae2[] = \"unsolvable\";\n  \n  in.MD = GetallManhattanDistance(in);//初期のマンハッタン距離\n\n  for(limit = in.MD; limit <= LIMITMAX; limit++ ){\n    jyoutai = in;\n    if( dfs(0, -100) ){\n      string kotae = \"\";\n      for(i = 0; i < limit; i++) kotae += houkou[miti[i]];\n      return kotae;\n    } \n  }\n  \n  return \"できませんでした\";\n  \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst char answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<char> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\n\nclass board{\npublic:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<char> tiles;\n    explicit board(vector<char> num, int move){\n        wrongs = 0;\n        REP(i, 9){\n            tiles.push_back(num[i]);\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n    }\n\n    void move() {\n        pq.pop();\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n};\n\n\n\nbool operator< (board b1, board b2){\n    return ((b1.moves + b1.wrongs) > (b2.moves + b2.wrongs)) ? true : false;\n}\n\nint dfs(){\n    pq.push(board(original, 0));\n    while(!pq.empty()){\n        auto target = pq.top();\n        if((target.moves + target.wrongs) > 100)\n            return -1;\n        if(target.wrongs == 0)\n            return target.moves;\n        else{\n            target.move();\n        }\n    }\n    return -1;\n}\n\nint main() {\n    short ii;\n    REP(i, 9){\n        cin >> ii;\n        original[i] = ii;\n    }\n    int move = dfs();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <map>\n#include <cstdio>\nusing namespace std;\n#define X 3\n#define Y 3\nint main(){\n\tint i=1,start_point;\n\tvector<int>start(X*Y),goal;\n\tfor(;i<X*Y;i++)goal.push_back(i);goal.push_back(0);\n\tfor(i=0;i<X*Y;i++){\n\t\tscanf(\"%d\",&start[i]);\n\t\tif(start[i]==0)start_point=i;\n\t}\n\tif(start==goal){puts(\"0\");return 0;}\n\n\tmap<vector<int>,pair<int,int> >mstart,mgoal;\n\tqueue<pair<vector<int>,bool> >q;\n\tmstart[start]=make_pair(start_point,0);\n\tmgoal[goal]=make_pair(X*Y-1,0);\n\tq.push(make_pair(start,false));\n\tq.push(make_pair(goal,true));\n\tfor(;!q.empty();){\n\t\tvector<int> v=q.front().first;\n\t\tbool f=q.front().second;\n\t\tq.pop();\n\t\tmap<vector<int>,pair<int,int> >&m=f?mgoal:mstart;\n\t\tmap<vector<int>,pair<int,int> >&m2=f?mstart:mgoal;\n\t\tint coor=m[v].first,x=coor%X,y=coor/X;\n\t\tint depth=m[v].second;\n\t\tif(0<x){\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t\tif(m.find(v)==m.end())m[v]=make_pair(coor-1,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t}\n\t\tif(x<X-1){\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t\tif(m.find(v)==m.end())m[v]=make_pair(coor+1,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t}\n\t\tif(0<y){\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t\tif(m.find(v)==m.end())m[v]=make_pair(coor-X,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t}\n\t\tif(y<Y-1){\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t\tif(m.find(v)==m.end())m[v]=make_pair(coor+X,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nbool isTarget(Puzzle );\nstring bfs(Puzzle );\n\nstruct Puzzle{\n  int i,f[N2];\n  int space;\n  string path;\n \n  bool operator < (const Puzzle &p) const{\n\n    for(i = 0;i < N2;i ++)\n      {\n\tif(f[i] == p.f[i]) continue;\n\treturn f[i] > p.f[i];\n      }\n    return false;\n  }\n};\n \nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n \n \nint main(){\n\n  Puzzle in;\n\n  int i;\n\n \n  for(i = 0;i < N2;i ++)\n    {\n      cin >> in.f[i];\n      if(in.f[i] == 0)\n\t{\n\t  in.f[i] = N2;\n\t  in.space = i;\n\t}\n    }\n string ans = bfs(in);\n\n  cout << ans.size() << endl;\n \n  return 0;\n}\n\nbool isTarget(Puzzle p){\n\n  int i;\n  \n  for(i = 0;i < N2;i ++)\n    {\n      if(p.f[i] != (i + 1)) return false;\n    }\n  \n  return true;\n}\n \nstring bfs(Puzzle s){\n\n  int sx,sy,tx,ty,r;\n  \n  queue<Puzzle> Q;\n\n  map<Puzzle, bool> V;\n\n  Puzzle u, v;\n\n  s.path = \"\";\n\n  Q.push(s);\n\n  V[s] = true;\n \n  while(!Q.empty()){\n\n    u = Q.front();\n\n    Q.pop();\n\n    if(isTarget(u))return u.path;\n\n    sx = u.space / N;\n    sy = u.space % N;\n\n    for(r = 0;r < 4;r ++)\n      {\n\ttx = sx + dx[r];\n\tty = sy + dy[r];\n\n\tif(tx < 0 || ty < 0 || tx >= N || ty >= N)continue;\n       \n\tv = u;\n      \n\tswap(v.f[u.space], v.f[tx * N + ty]);\n      \n\tv.space = tx * N + ty;\n      \n\tif(!V[v]){\n\t  V[v] = true;\n\t  v.path += dir[r];\n\t  Q.push(v);\n\t}\n      }\n  }\n \n  return \"unsolvable\";\n}"
  },
  {
    "language": "C++",
    "code": "// ------ Includes ------ //\n\n#include <map>\n#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\n\n// ------ Directions ------ //\n\nconst int dx[4] = { 0, 1, 0, -1 };\nconst int dy[4] = { 1, 0, -1, 0 };\n\n\n// ------ BFS ------ //\n\nint BFS(vector<vector<int> > p)\n{\n\t// ------ Initialize ------ //\n\n\tvector<vector<int> > lastboard = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 0 } };\n\n\tmap<vector<vector<int> >, int> D;\n\n\tqueue<pair<vector<vector<int> >, int> > que;\n\n\tD[p] = 1; que.push(make_pair(p, 1));\n\n\n\t// ------ Search ------ //\n\n\twhile (!que.empty())\n\t{\n\t\tpair<vector<vector<int> >, int> p1 = que.front(); que.pop();\n\n\n\t\t// ------ 0 Searching ------ //\n\n\t\tint tx = -1, ty = -1;\n\n\t\tfor (int i = 0; i < p1.first.size(); i++)\n\t\t{\n\t\t\tfor (int j = 0; j < p1.first[i].size(); j++)\n\t\t\t{\n\t\t\t\tif (p1.first[i][j] == 0)\n\t\t\t\t{\n\t\t\t\t\ttx = j; ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\t// ------ Moving ------ //\n\n\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t{\n\t\t\tif (0 <= tx + dx[dir] && tx + dx[dir] < p1.first[0].size() && 0 <= ty + dy[dir] && ty + dy[dir] < p1.first.size())\n\t\t\t{\n\t\t\t\tvector<vector<int> > p2 = p1.first;\n\n\t\t\t\tswap(p2[ty][tx], p2[ty + dy[dir]][tx + dx[dir]]);\n\n\t\t\t\tif (D[p2] == 0)\n\t\t\t\t{\n\t\t\t\t\tif (p2 == lastboard)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn p1.second;\n\t\t\t\t\t}\n\n\t\t\t\t\tD[p2] = p1.second + 1;\n\n\t\t\t\t\tque.push(make_pair(p2, p1.second + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tvector<vector<int> > board(3, vector<int>(3, -1));;\n\n\tfor (int i = 0; i < board.size(); i++)\n\t{\n\t\tfor (int j = 0; j < board[i].size(); j++)\n\t\t{\n\t\t\tcin >> board[i][j];\n\t\t}\n\t}\n\n\tcout << BFS(board) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>           // printf(), scanf()\n#include <string>\n#include <queue>\n#include <map>\n#include <algorithm>        // swap()\n\nusing namespace std;\nstatic const int N = 3;\nstatic const int N2 = 9;\n\nstruct puzzle\n{\n\tint f[N2];\n\tint space;\n\tstring path;\n\tbool operator < (const puzzle &p) const\n\t{\n\t\tfor (int i = 0; i < N2; ++i)\n\t\t{\n\t\t\tif (f[i] != p.f[i])\n\t\t\t\treturn f[i] > p.f[i];\n\t\t}\n\n\t\treturn false;\n\t}\n};\n\nbool\nis_target(puzzle p)\n{\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tif (p.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nstring\nbfs(puzzle s)\n{\n\tqueue<puzzle> Q;\n\tmap<puzzle, bool> V;\n\tpuzzle u, v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\n\twhile (!Q.empty())\n\t{\n\t\tu = Q.front(); Q.pop();\n\t\tif (is_target(u))\n\t\t\treturn u.path;\n\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r)\n\t\t{\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\tcontinue;\n\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!V[v])\n\t\t\t{\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"unsolvable\";\n}\n\nint\nmain(int argc, char** argv)\n{\n\tpuzzle in;\n\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tscanf(\"%d\", &in.f[i]);\n\t\tif (in.f[i] == 0)\n\t\t{\n\t\t\tin.f[i] = N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\n\tstring ans = bfs(in);\n\tprintf(\"%lu\\n\", ans.size());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i) \n#define PI acos(-1)\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing LP = pair<ll, ll>;\nusing PZL = vector<vector<int>>;\n\nint potential(PZL p) {\n    int res = 0;\n    rep(i, 3) {\n        rep(j, 3) {\n            int x = (p[i][j] - 1) % 3;\n            int y = (p[i][j] - 1) / 3;\n            if (p[i][j] == 0) {\n                x = 2;\n                y = 2;\n            }\n            res += abs(j - x) + abs(i - y);\n        }\n    }\n    return res;\n}\n\nll hashing(PZL p) {\n    ll res = 0;\n    ll base = 1;\n    rep(i, 3) {\n        rep(j, 3) {\n            res += p[i][j] * base;\n            base *= 9;\n        }\n    }\n    return res;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    PZL pazzle(3, vector<int>(3)); \n    rep(i, 3) {\n        rep(j, 3) cin>>pazzle[i][j];\n    }\n\n    PZL ans {\n        vector<int> {1, 2, 3},\n        vector<int> {4, 5, 6},\n        vector<int> {7, 8, 0},\n    };\n    vector<P> direc {P(1, 0), P(-1, 0), P(0, 1), P(0, -1)};\n    priority_queue<pair<P, PZL>, vector<pair<P, PZL>>, greater<pair<P, PZL>>> q;\n    set<ll> visited;\n    q.push(pair<P, PZL>(P(potential(pazzle), 0), pazzle));\n\n    int res = 0;\n    while (!q.empty()) {\n        pair<P, PZL> p = q.top(); q.pop();\n        PZL pzl = p.second;\n        int w = p.first.second;\n        \n        if (pzl == ans) {\n            res = w;\n            break;\n        }\n\n        ll hash = hashing(pzl);\n        if (visited.find(hash) != visited.end()) continue;\n        visited.insert(hash);\n\n        P z;\n        rep(i, 3) {\n            rep(j, 3) {\n                if (pzl[i][j] == 0) z = P(i, j);\n            }\n        }\n        for (auto d : direc) {\n            int ni = z.first + d.first;\n            int nj = z.second + d.second;\n            if (ni < 0 || ni >= 3 || nj < 0 || nj >= 3) continue;\n            swap(pzl[z.first][z.second], pzl[ni][nj]);\n            q.push(pair<P, PZL>(P(w + 1 + potential(pzl), w + 1), pzl));\n            swap(pzl[z.first][z.second], pzl[ni][nj]);\n        }\n    }\n    cout<<res<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator <(const Puzzle p) const {\n//\t\tfor (int i = 0; i < N2; ++i) {\n//\t\t\tif (f[i] == p.f[i])\n//\t\t\t\tcontinue;\n//\t\t\treturn f[i] > p.f[i];\n//\t\t}\n\t\treturn false;\n\t}\n};\n\nbool isComplete(Puzzle p) {\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif (p.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nconst int dx[4] { -1, 0, 1, 0 };\nconst int dy[4] { 0, -1, 0, 1 };\nconst char dir[4] { 'u', 'l', 'd', 'r' };\n\nstring bfs(Puzzle p) {\n\tqueue<Puzzle> Q;\n\tp.path = \"\";\n\tQ.push(p);\n\tPuzzle u, v;\n\tmap<Puzzle, bool> M;\n\tM[p] = true;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isComplete(u))\n\t\t\treturn u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!M[v]) {\n\t\t\t\tM[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"unresolved\";\n}\n\nint main() {\n\tPuzzle p;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tscanf(\"%d\", &p.f[i]);\n\t\tif (p.f[i] == 0) {\n\t\t\tp.f[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(p);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <stack>\n#include <map>\n#include <string>\nusing namespace std;\n\n#define FLG  INT_MIN\n#define GOAL 0\n\n#define N 3\n\nmap<string, int> mp;\nqueue<pair<string, int> > Q;\n\nvector<int> neighbor(int pos)\n{\n    vector<int> rt;\n    if (pos % N != 0)\n        rt.push_back(pos - 1);\n    if (pos % N != N - 1)\n        rt.push_back(pos + 1);\n    if (pos - N >= 0)\n        rt.push_back(pos - N);\n    if (pos + N < N * N)\n        rt.push_back(pos + N);\n    return rt;\n}\n\nint bfs()\n{\n    string st, tmp;\n    int cnt, pos;\n    while (!Q.empty()) {\n        st = Q.front().first;\n        cnt = Q.front().second;\n        pos = st.find(\"0\");\n        Q.pop();\n        if (mp.count(st)) {\n            if (mp[st] == FLG) {\n                continue;\n            } else if (mp[st] == GOAL) {\n                return cnt;\n            } else\n                printf(\"ERROR: %d\\n\", __LINE__);\n        }\n        mp[st] = FLG;\n        vector<int> nb(neighbor(pos));\n        for (int i = 0; i < nb.size(); i++) {\n            tmp = st;\n            tmp[pos] = st[nb[i]]; tmp[nb[i]] = st[pos];\n            Q.push(make_pair(tmp, cnt + 1));\n        }\n    }\n    return INT_MIN;\n}\n\nint main()\n{\n    string st, gl = \"123456780\";\n    for (int i = 0; i < 9; i++) {\n        int  j;\n        cin >> j;\n        st += to_string(j);\n    }\n    mp[gl] = GOAL;\n    Q.push(make_pair(st, 0));\n    cout << bfs() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n\nusing namespace std;\n#define N 3\n#define N2 9\n\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n\n  \nbool operator < (const Puzzle &p)const{\n  for(int i=0;i<N2;i++){\n    if(f[i] == p.f[i])continue;\n    return f[i] > p.f[i];\n  }\n  return false;\n}\n};  \n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\n\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++)\n    if(p.f[i] != (i + 1))return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n\n  \n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n    if(isTarget(u))return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r = 0;r<4;r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0||ty<0||tx>=N||ty>=N)continue;\n      v = u;\n      swap(v.f[u.space],v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if(!V[v]){\n\tV[v] = true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0;i<N2;i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n\n  \n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <map>\n#include <cstdio>\nusing namespace std;\n#define X 3\n#define Y 3\nint main(){\n\tint i=1,start_point;\n\tvector<int>start(X*Y),goal;\n\tfor(;i<X*Y;i++)goal.push_back(i);goal.push_back(0);\n\tfor(i=0;i<X*Y;i++){\n\t\tscanf(\"%d\",&start[i]);\n\t\tif(start[i]==0)start_point=i;\n\t}\n\tif(start==goal){puts(\"0\");return 0;}\n\n\tmap<vector<int>,pair<int,int> >mstart,mgoal;\n\tqueue<pair<vector<int>,bool> >q;\n\tmstart[start]=make_pair(start_point,0);\n\tmgoal[goal]=make_pair(X*Y-1,0);\n\tq.push(make_pair(start,false));\n\tq.push(make_pair(goal,true));\n\tfor(;!q.empty();){\n\t\tvector<int> v=q.front().first;\n\t\tbool f=q.front().second;\n\t\tq.pop();\n\t\tmap<vector<int>,pair<int,int> >&m=f?mgoal:mstart;\n\t\tmap<vector<int>,pair<int,int> >&m2=f?mstart:mgoal;\n\t\tint coor=m[v].first,x=coor%X,y=coor/X;\n\t\tint depth=m[v].second;\n\t\tif(0<x){\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t\tif(m.find(v)==m.end())m[v]=make_pair(coor-1,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t}\n\t\tif(x<X-1){\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t\tif(m.find(v)==m.end())m[v]=make_pair(coor+1,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t}\n\t\tif(0<y){\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t\tif(m.find(v)==m.end())m[v]=make_pair(coor-X,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t}\n\t\tif(y<Y-1){\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t\tif(m.find(v)==m.end())m[v]=make_pair(coor+X,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nqueue<int>Q[3][3];\nqueue<int>R[3][3];\n\nint main() {\n\tint a, b, c, d, e, sum=0;\n\tint x[3][3];\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tcin >> a;\n\t\t\tQ[i][j].push(a);\n\t\t}\n\t}\n\twhile (true) {\n\t\twhile (!Q[0][0].empty()) {\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (Q[i][j].front() == 0) {\n\t\t\t\t\t\tb = i;\n\t\t\t\t\t\tc = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tx[i][j] = Q[i][j].front();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[0][0] == 1 && x[0][1] == 2 && x[0][2] == 3 && x[1][0] == 4 && x[1][1] == 5 && x[1][2] == 6 && x[2][0] == 7 && x[2][1] == 8) {\n\t\t\t\tgoto owata;\n\t\t\t}\n\t\t\tif (b >= 1) {\n\t\t\t\td = x[b][c];\n\t\t\t\te = x[b - 1][c];\n\t\t\t\tx[b][c] = e;\n\t\t\t\tx[b - 1][c] = d;\n\t\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tR[i][j].push(x[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tx[i][j] = Q[i][j].front();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (b <= 1) {\n\t\t\t\td = x[b][c];\n\t\t\t\te = x[b + 1][c];\n\t\t\t\tx[b][c] = e;\n\t\t\t\tx[b + 1][c] = d;\n\t\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tR[i][j].push(x[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tx[i][j] = Q[i][j].front();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c >= 1) {\n\t\t\t\td = x[b][c];\n\t\t\t\te = x[b][c - 1];\n\t\t\t\tx[b][c] = e;\n\t\t\t\tx[b][c - 1] = d;\n\t\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tR[i][j].push(x[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tx[i][j] = Q[i][j].front();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c <= 1) {\n\t\t\t\td = x[b][c];\n\t\t\t\te = x[b][c + 1];\n\t\t\t\tx[b][c] = e;\n\t\t\t\tx[b][c + 1] = d;\n\t\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tR[i][j].push(x[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tQ[i][j].pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!R[0][0].empty()) {\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tQ[i][j].push(R[i][j].front());\n\t\t\t\t\tR[i][j].pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsum++;\n\t}\nowata:;\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<string>\nusing namespace std;\n#define maxn 10\nstruct my\n{\n    int tu[10];\n    int space;\n    int  ans;\n    bool operator <(const my &p)const{\n    for (int i=0;i<9;i++)\n        {\n            if(tu[i]==p.tu[i]) continue;\n        return tu[i]>p.tu[i];\n        }\n        return false ;\n    }\n};\nbool is(my s)\n{\n    for (int i=0;i<9;i++)\n        if(s.tu[i]!=(i+1)) return false;\n    return true;\n}\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n//char dir[]={'u','l','d','r'};\nint bfs(my s)\n{\n    queue<my>Q;\n    map<my,bool>V;\n    s.ans=0;\n    Q.push(s);\n    V[s]=true;\n    my u,v;\n\n    while(!Q.empty())\n    {\n        u=Q.front();\n        Q.pop();\n        if(is(u)) return u.ans;\n        int sx=u.space/3;\n        int sy=u.space%3;\n        for (int i=0;i<4;i++)\n        {\n            int tx=sx+dx[i];\n            int ty=sy+dy[i];\n            if(tx<0||ty<0||tx>=3||ty>=3) continue;\n            v=u;\n            swap(v.tu[u.space],v.tu[tx*3+ty]);\n            v.space=tx*3+ty;\n            if(!V[v])\n            {\n                V[v]=true;\n                v.ans++;\n                Q.push(v);\n            }\n        }\n    }\n}\nint main()\n{\n    my in;\n    for (int i=0;i<9;i++)\n    {\n        scanf(\"%d\",&in.tu[i]);\n        if(in.tu[i]==0){\n            in.space=i;\n            in.tu[i]=9;\n        }\n    }\n    int sum=bfs(in);\n    printf(\"%d\\n\",sum);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int,mat> P;\n\nbool check(mat A){\n  \n  string ans = \"123456780\";\n  string s;\n  \n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++) s += (char)( A[i][j] + '0' );\n  }\n  \n  return ans == s;  \n}\n\nint bfs(mat s){\n  \n  queue<P> Q;\n  map<mat,int> memo;\n  \n  Q.push( P( 0, s ) );\n  memo[ s ] = 0;\n  \n  while( !Q.empty() ){\n    \n    P t = Q.front(); Q.pop();\n    \n    int cost = t.first;\n    mat A = t.second;\n    \n    if( check( A ) == true ) return cost;\n    \n    int y, x;\n    \n    for(int i=0;i<3;i++){\n      \n      for(int j=0;j<3;j++){\n\t\n\tif( A[i][j] == 0 ) y = i, x = j;\n\t\n      }\n      \n    }\n    \n    int dy[4] = {-1,0,1,0};\n    int dx[4] = {0,1,0,-1};\n    \n    for(int i=0;i<4;i++){\n      \n      int ny = y + dy[i], nx = x + dx[i];\n      \n      if( ny < 0 || nx < 0 || 3 <= ny || 3 <= nx ) continue;\n      \n      mat nA = A;\n      int ncost = cost + 1;\n      \n      swap( nA[y][x], nA[ny][nx] );\n      \n      if( memo.count( nA ) ) continue;\n      \n      memo[nA] = ncost;\n      Q.push( P( ncost, nA ) );\n      \n    }\n    \n  }\n  \n  return 0; \n}\n\nsigned main(){\n  \n  mat s = mat( 3, vec( 3 ) );\n  \n  for(int i=0;i<3;i++){\n    \n    for(int j=0;j<3;j++){\n      \n      cin>>s[i][j];\n      \n    }\n    \n  }\n  \n  cout<<bfs(s)<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n#define DIVN 3\n\nvoid swap(int &a, int &b);\nint fact(int a);\nint dist(int x);\nint abs(int x);\nvoid insert(vector<int> &A, int v);\nint extract(vector<int> &A);\nint PtoI(vector<int> p);\nvector<int> ItoP(int ii);\nint SolvePuzzle(vector<int> P);\n\nvector<int> Puzzles(fact(DIVN*DIVN), INT_MAX);\n\n\nvoid swap(int &a, int &b){\n\tint tmp = a;\n\ta = b;\n\tb = tmp;\n\treturn;\n}\n\nint fact(int a){\n\tint b = 1;\n\tfor (int i = 2; i <= a; i++){\n\t\tb = b * i;\n\t}\n\treturn b;\n}\n\nint dist(int x){\n\tstd::vector<int> P = ItoP(x);\n\tint result = 0;\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tresult += abs(P[i] % DIVN - (i + 1) % DIVN) + abs(((P[i] == 0 ? DIVN - 1 : (P[i] - 1) / DIVN)) - i / DIVN);\n\t}\n\treturn -result;\n}\n\nint abs(int x){\n\treturn x < 0 ? -x : x;\n}\n\nvoid insert(vector<int> &A, int v){\n\tint n = A.size();\n\tA.push_back(v);\n\twhile (n != 0){\n\t\tint i = (n - 1) / 2;\n\t\tif (dist(A[n]) > dist(A[i])){\n\t\t\tswap(A[n], A[i]);\n\t\t}\n\t\tn = i;\n\t}\n\treturn;\n}\n\nint extract(vector<int> &A){\n\tint n = A.size() - 1;\n\tint res = A[0];\n\tA[0] = A[n];\n\tA.pop_back();\n\n\tfor (int i = 0, j; 2 * i + 1 < n;){\n\t\tj = 2 * i + 1;\n\t\tif (j != n - 1 && dist(A[j]) < dist(A[j + 1])){\n\t\t\tj++;\n\t\t}\n\t\tif (dist(A[i]) < dist(A[j])){\n\t\t\tswap(A[i], A[j]);\n\t\t}\n\t\ti = j;\n\t}\n\treturn res;\n}\n\n\nint PtoI(vector<int> p){\n\tint x, result = 0;\n\tfor (int i = 0; i < DIVN*DIVN - 1; i++){\n\t\tfor (int j = 0; j < DIVN*DIVN - i; j++){\n\t\t\tif (p[j] == i){\n\t\t\t\tx = j;\n\t\t\t\tp.erase(p.begin() + j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult += x * fact(DIVN*DIVN - i - 1);\n\t}\n\treturn result;\n}\n\nvector<int> ItoP(int ii){\n\tvector<int> result(DIVN*DIVN, -1);\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tint index = ii / fact(DIVN*DIVN - i - 1);\n\t\tii = ii % fact(DIVN*DIVN - i - 1);\n\t\tint curindex = -1;\n\t\tint x = -1;\n\t\tfor (int j = 0; j < DIVN*DIVN; j++){\n\t\t\tif (result[j] == -1){\n\t\t\t\tcurindex++;\n\t\t\t}\n\t\t\tif (curindex == index) {\n\t\t\t\tx = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult[x] = i;\n\t}\n\treturn result;\n}\n\nint SolvePuzzle(vector<int> P){\n\tvector<int> Que;\n\tinsert(Que, PtoI(P));\n\tint answer = INT_MAX;\n\tPuzzles[PtoI(P)] = 0;\n\twhile (!Que.empty()){\n\t\tvector<int> Q = ItoP(extract(Que));\n\t\tint Cursor;\n\t\tbool isAligned = true;\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] != (i + 1) % (DIVN*DIVN)){\n\t\t\t\tisAligned = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isAligned && Puzzles[PtoI(Q)] < answer){\n\t\t\tanswer = Puzzles[PtoI(Q)];\n\t\t}\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] == 0){\n\t\t\t\tCursor = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvector<int> Qnext;\n\t\tif (Cursor >= DIVN){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1 && (answer > Puzzles[PtoI(Q)] + 1)){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor < DIVN * (DIVN - 1)){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1 && (answer > Puzzles[PtoI(Q)] + 1)){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != 0){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1 && (answer > Puzzles[PtoI(Q)] + 1)){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != DIVN - 1){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1 && (answer > Puzzles[PtoI(Q)] + 1)){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn answer;\n}\n\nint main(){\n\tint k;\n\tvector<int> P;\n\tfor (int i = 0; i < DIVN * DIVN; i++){\n\t\tscanf(\"%d\", &k);\n\t\tP.push_back(k);\n\t}\n\tint n = SolvePuzzle(P);\n\n\tprintf(\"%d\\n\", n);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n#define N 3\n#define LIMIT_TIME 180000\ntypedef pair<int, int> P;\n\nstruct State {\n    int g, h;\n    string state;\n    P blank;\n    string path;\n    bool operator<(const State &a) const {\n        return g + h > a.g + a.h;\n    }\n};\n\nint d[5] = {-1, 0, 1, 0, -1};\nstring r[4] = {\"D\", \"R\", \"U\", \"L\"};\nstring ans_str = \"\";\nint ans[N][N], puzzle0[N][N], puzzle1[N][N];\nset<string> s;\npriority_queue<State> next_state;\nstring path;\n\nbool range(int y, int x) {return 0 <= y && y < N && 0 <= x && x < N;}\n\nint h2() {\n    int find = -1;\n    while(next_state.size()) {\n        State state = next_state.top();\n        next_state.pop();\n        if (s.count(state.state)) continue; // already search\n        s.insert(state.state); // visited\n\n        P blank = state.blank;\n        rep(i, 4) {\n            int y = d[i] + blank.first, x = d[i + 1] + blank.second; // next blank position\n            if (range(y, x)) { // can be replaced\n                string tmp = state.state; // next state (string)\n                int p = blank.first * N + blank.second, q = y * N + x;\n                if (N < 4)  swap(tmp[p], tmp[q]);\n                else swap(tmp[2 * p], tmp[2 * q]), swap(tmp[2 * p + 1], tmp[2 * q + 1]);\n                if (s.count(tmp)) continue; // already search\n\n                int num;\n                if (N < 4) num = state.state[q] - '1';\n                else num = stoi(state.state.substr(2 * q, 2)) - 1;\n                // calcurate manhattan distance\n                int manhattan = state.h - ((abs(num / N - y) + abs(num % N - x)))\n                + (abs(num / N - blank.first) + abs(num % N - blank.second));\n\n                if (manhattan == 0) { // answer\n                    find = state.g + 1;\n                    path = state.path + r[i];\n                    break;\n                }\n\n                next_state.push(State{state.g + 1, manhattan, tmp, P(y, x), state.path + r[i]});\n            }\n        }\n        if (find != -1) break; // find an answer\n    }\n    return find;\n}\n\nint main(){\n    \n\n    string state = \"\";\n    P blank;\n    int manhattan = 0, wrong_place = 0;\n    rep(i, N)rep(j, N) {\n        cout << puzzle0[i][j] << ((j % N == N - 1) ? \"\\n\" : \"\\t\");\n\n        if (N * N - 1 > 9 && puzzle0[i][j] < 10) state += \"0\";\n        state += to_string(puzzle0[i][j]);\n        if (N * N - 1 > 9 && ans[i][j] < 10) ans_str += \"0\";\n        ans_str += to_string(ans[i][j]);\n\n        if(puzzle0[i][j] == 0) blank = P(i, j);\n        else {\n            int num = puzzle0[i][j] - 1;\n            manhattan += (abs(num / N - i) + abs(num % N - j));\n            if (puzzle0[i][j] != ans[i][j]) wrong_place++;\n        }\n    }\n\n    if (manhattan == 0) { // the answer\n        cout << 0 << endl;\n    } else {\n        s.clear();\n        next_state = priority_queue<State>();\n        next_state.push(State{0, manhattan, state, blank, \"\"});\n        int steps = h2();\n        cout << steps << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <vector>\n\ntypedef std::vector<std::vector<int> > TPuzzle;\n\nvoid MakeGoal(TPuzzle& Goal)\n{\n\tGoal.resize(3);\n\tfor(int i = 0; i < 3; ++i){\n\t\tGoal[i].resize(3);\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tGoal[i][j] = (1 + 3 * i + j) % 9;\n\t\t}\n\t}\n}\n\nvoid ZeroPosition(int& Row, int& Col, const TPuzzle& Puzzle)\n{\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tif(Puzzle[i][j] == 0){\n\t\t\t\tRow = i;\n\t\t\t\tCol = j;\n\t\t\t}\n\t\t}\n\t}\n}\n\nenum TMovePattern\n{\n\tmpUp,\n\tmpDown,\n\tmpLeft,\n\tmpRight\n};\n\nbool Movable(const TPuzzle& Puzzle, const TMovePattern& Pattern)\n{\n\tint Row, Col;\n\tZeroPosition(Row, Col, Puzzle);\n\tswitch(Pattern){\n\tcase mpUp    : return Row != 0;\n\tcase mpDown  : return Row != 2;\n\tcase mpLeft  : return Col != 0;\n\tcase mpRight : return Col != 2;\n\t}\n\tassert(false);\n\treturn false;\n}\n\nTPuzzle Move(TPuzzle Puzzle, const TMovePattern& Pattern)\n{\n\tint Row, Col;\n\tZeroPosition(Row, Col, Puzzle);\n\tswitch(Pattern){\n\tcase mpUp    : std::swap(Puzzle[Row][Col], Puzzle[Row - 1][Col]);break;\n\tcase mpDown  : std::swap(Puzzle[Row][Col], Puzzle[Row + 1][Col]);break;\n\tcase mpLeft  : std::swap(Puzzle[Row][Col], Puzzle[Row][Col - 1]);break;\n\tcase mpRight : std::swap(Puzzle[Row][Col], Puzzle[Row][Col + 1]);break;\n\t}\n\treturn Puzzle;\n}\n\nvoid RenewTargets(\n\tconst TPuzzle& Puzzle,\n\tconst TMovePattern& Pattern,\n\tstd::vector<TPuzzle>& Targets,\n\tstd::set<TPuzzle>& History)\n{\n\tif(!Movable(Puzzle, Pattern)) return;\n\tTPuzzle Moved = Move(Puzzle, Pattern);\n\tif(History.find(Moved) != History.end()) return;\n\tTargets.push_back(Moved);\n\tHistory.insert(Moved);\n}\n//?¬??????????????????????????????¶???????????????\n\n//????¬??????????????????????????¨?????????£???????????°?????????\n//?¬?????????????????????????????????§?????????????????????????????????\n//???????????§????±\\??´????????£????????????\n//?¬???????????????????????????????????????????????????????\n//?±\\??´????????????\n//????????????\nbool CountMove(std::vector<TPuzzle>& NextTargets,\n\t          const TPuzzle& Goal,\n\t          std::set<TPuzzle>& History)\n{\n\tif(std::find(NextTargets.begin(), NextTargets.end(), Goal) != NextTargets.end()) return true;\n\tstd::vector<TPuzzle> NewTargets;\n\tfor(std::vector<TPuzzle>::const_iterator It = NextTargets.begin(); It != NextTargets.end(); ++It){\n\t\tRenewTargets(*It, mpUp,    NewTargets, History);\n\t\tRenewTargets(*It, mpDown,  NewTargets, History);\n\t\tRenewTargets(*It, mpLeft,  NewTargets, History);\n\t\tRenewTargets(*It, mpRight, NewTargets, History);\n\t}\n\tNextTargets = NewTargets;\n\treturn false;\n}\n\nint CountMinimumMove(const TPuzzle& Puzzle, const TPuzzle& Goal)\n{\n\tstd::vector<TPuzzle> Targets(1, Puzzle);\n\tstd::set<TPuzzle> History;\n\tint Count = 0;\n\twhile(!CountMove(Targets, Goal, History)) ++Count;\n\treturn Count;\n}\n\nint main()\n{\n\tTPuzzle Goal;\n\tMakeGoal(Goal);\n\tTPuzzle Start(3, std::vector<int>(3));\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tint Input;\n\t\t\tstd::cin >> Input;\n\t\t\tStart[i][j] = Input;\n\t\t}\n\t}\n\tstd::cout << CountMinimumMove(Start, Goal) << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <functional>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <ctime>\n#include <queue>\ntypedef std::vector<std::vector<int>> vvi;\n\nint n;\nvvi a(4,std::vector<int>(4));\nstd::map<vvi, int> mp;\n/*ゴール状態をそれぞれ\n0 1 2\n3 4 5\n6 7 *\n\n0 1 2 3\n4 5 6 7\n8 9 10 11\n12 13 14 *\nとする\n */\n\nvoid init(){\n\tint N = n*n;\n\tstd::vector<bool> use(N,false);\n\tint now = 0;\n\twhile(now < N){\n\t\tint x = rand() % N;\n\t\tif(!use[x]){\n\t\t\ta[now/n][now%n] = x;\n\t\t\tuse[x] = true;\n\t\t\tnow++;\n\t\t}\n\t}\n}\n\nbool goal(){\n\tbool res = true;\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(a[i][j] != i*n+j) res = false;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid print(){\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++) std::cout << a[i][j] << \" \";\n\t\tstd::cout << \"\\n\";\n\t}\n}\n\nint h(int mode){\n\tif(mode == 0) return 0;\n\tint res = 0;\n\tif(mode == 1){\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(a[i][j] != i*n+j) res++;\n\t\t\t}\n\t\t}\n\t}else if(mode == 2){\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tint y = a[i][j]/n;\n\t\t\t\tint x = a[i][j]%n;\n\t\t\t\tres += abs(y-i) + abs(x-j);\n\t\t\t}\n\t\t}\n\t}else{\n\t\treturn 1<<30;\n\t}\n\treturn res;\n}\n\nint f(int mode, int g){\n\treturn h(mode) + g;\n}\n\n\nbool in(int y, int x){\n\treturn 0 <= y && y < n && 0 <= x && x < n;\n}\n\nint dy[4] = {1,0,-1,0};\nint dx[4] = {0,1,0,-1};\n\nstruct dat{\n\tint f,g;\n\tvvi vec;\n\tbool operator< (const dat &d) const {\n\t\treturn f > d.f;\n\t}\n};\n\nint search(int mode){\n\tstd::priority_queue<dat> pq;\n\tpq.push({f(mode,0),0,a});\n\t//std::cout << f(mode,0) << \" \" << ss << \"\\n\";\n\tmp[a] = f(mode,0);\n\twhile(!pq.empty()){\n\t\tauto p = pq.top(); pq.pop();\n\t\ta = p.vec;\n\t\tif(goal()) return p.g;\n\t\tint y,x;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(a[i][j] == n*n-1){\n\t\t\t\t\ty = i; x = j; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<4; i++){\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tif(!in(ny,nx)) continue;\n\t\t\tstd::swap(a[ny][nx], a[y][x]);\n\t\t\tif(mp.find(a) != mp.end()){\n\t\t\t\tstd::swap(a[ny][nx], a[y][x]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint cost = f(mode, p.g + 1);\n\t\t\tmp[a] = cost;\n\t\t\tpq.push({cost, p.g + 1, a});\n\t\t\tstd::swap(a[ny][nx], a[y][x]);\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nint main(){\n\t//srand(unsigned(time(NULL)));\n\tint mode = 1;\n\tn = 3;\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tint c; std::cin >> c;\n\t\t\ta[i][j] = c - 1;\n\t\t\tif(a[i][j] < 0) a[i][j] += 9;\n\t\t}\n\t}\n\t//std::cin >> n >> mode;\n\t//cin >> n;\n\t//init();\n\tstd::cout << search(mode) << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<map>\n#include<queue>\n\nusing namespace std;\n#define N 3\n#define N2 9\n\nstatic const int dx[4] = {0, -1, 0, 1};\nstatic const int dy[4] = {1, 0, -1, 0};\nstatic const char dir[4] = {'r','u','l','d'};\nint MDT[N2][N2];\n\nstruct Puzzle {\n    int f[N2], space, MD;\n    int cost;\n\n    bool operator < (const Puzzle &p) const{\n        for(int i=0; i<N2; i++){\n            if(f[i]==p.f[i]) continue;\n            return f[i] < p.f[i];\n        }\n        return false;\n    }\n};\n\nstruct State{\n    Puzzle puzzle;\n    int estimated;\n    bool operator < (const State &s) const{\n        return estimated > s.estimated;\n    }\n};\n\nint getAllMD(Puzzle pz){\n    int sum=0;\n    for(int i=0; i<N2; i++){\n        if(pz.f[i] == N2) continue;\n        sum += MDT[i][pz.f[i]-1];\n    }\n    return sum;\n}\n\nint astar(Puzzle s){\n    priority_queue<State> PQ;//優先順位付きキュー\n    s.MD = getAllMD(s);//マンハッタン距離の初期値を計算\n    s.cost = 0;//コスト値は最初は0\n    //mapとはC++標準ライブラリに用意された平衡二分木.\n    //要素の要素数に対する対数オーダーでの高速な検索が可能。内部で要素がソート状態で保持される\n    //辞書みたいな使い方が多い\n    //Puzzleがkey,boolがvalue\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    State initial;//State構造体はパズルの情報とヒューリスティック値を計算\n    initial.puzzle = s; //Stateのインスタンスを生成\n    initial.estimated = getAllMD(s);//sのマンハッタン距離を計算して格納\n    PQ.push(initial);//initialをキューにプッシュ\n\n    while(!PQ.empty()){//PQが空でない間はループ 全てのキューに入っている要素を見る\n        State st = PQ.top(); PQ.pop();//キューの要素をstに代入して削除\n        u = st.puzzle; //stのメンバである盤面情報puzzleをuに代入\n\n        if(u.MD == 0) return u.cost;//マンハッタン距離が0 -->解けた\n        V[u] = true;//Vはmapで、Puzzleのインスタンスとtrue,falseを対応させる。\n\n        int sx = u.space / N;//x座標計算\n        int sy = u.space % N;//y座標計算\n\n        for(int r=0; r<4; r++){ //4方向すべてを試す。\n            int tx = sx + dx[r]; //x方向の遷移\n            int ty = sy + dy[r]; //y方向の遷移\n            if(tx<0 || ty<0 || tx>=N || ty>=N) continue;//移動後マスからはみ出した場合\n            v = u;\n            \n            /*マンハッタン距離の差分を計算しつつ、ピースをスワップ*/\n            //tx * N + tyは空白の位置。f配列はパズルのマスの値。v.f[tx * N + ty]はパズルの値\n            //空白が移動する先(tx*N+ty)がもともとの数字があった場所なので、移動前のマンハッタン距離を引く\n            v.MD -= MDT[tx * N + ty][v.f[tx * N + ty] - 1];\n            //もともとの数字は空白があった場所に移動する。これによって増えるマンハッタン距離を足す。\n            v.MD += MDT[sx * N + sy][v.f[tx * N + ty] - 1];\n\n            swap(v.f[sx * N + sy], v.f[tx * N + ty]);//空白の位置をswap\n            v.space = tx * N + ty;//swapしたので空白の位置を更新\n            if(!V[v]){\n                v.cost++;//swapしたので木の下に行ってコストが1増える\n                State news;\n                news.puzzle = v;\n                news.estimated = v.cost + v.MD;//木の深さとマンハッタン距離を足してヒューリスティック値にする。\n                PQ.push(news);\n            }\n        }\n    }\n    return -1;\n}\n\nint main(){\n    //マンハッタン距離の計算\n    for(int i=0; i<N2; i++){\n        for(int j=0;j<N2;j++){\n            //MDT[i][j] := 「1次元配列上の」位置iから位置jに移動させるとした時、\n            //2次元配列上ではマンハッタン距離でどれくらい移動してるかを前計算\n            //abs(i/N - j/N)は縦方向の距離の絶対値\n            //abs(i%N - j%N)は横方向の距離の絶対値\n            MDT[i][j] = abs(i/N-j/N) + abs(i%N-j%N);//マンハッタン距離\n        }\n    }\n    Puzzle in;\n\n    for(int i=0;i<N2;i++){\n        cin >> in.f[i];\n        if(in.f[i]==0){\n            in.f[i] = N2;//空白の部分はN2(16)を代入\n            in.space = i;//空白の位置を格納\n        }\n    }\n    cout << astar(in) << endl;\n\n    return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <set>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<vector<int>, int> P;\n\nint zeroPosition( vector<int> a ) {\n    for ( int i = 0; i < 9; i++ ) {\n\tif ( a[i] == 0 ) return i;\n    }\n\n    return -1;\n}\n\nvector<int> swapDigit( vector<int> v, int a, int b ) {\n    vector<int> ret = v;\n    int x = v[a];\n    int y = v[b];\n    ret[a] = y;\n    ret[b] = x;\n\n    return ret;\n}\n\nbool isSame( vector<int> a, vector<int> b ) {\n    for ( int i = 0; i < 9; i++ ) {\n\tif ( a[i] != b[i] ) return false;\n    }\n\n    return true;\n}\n\nint convert( vector<int> a ) {\n    int ret = 0;\n    for ( int i = 0; i < 9; i++ ) {\n\tret *= 10;\n\tret += a[i];\n    }\n\n    return ret;\n}\n\nint main()\n{\n    set<int> S;\n    queue<P> Q;\n    vector<int> start;\n    vector<int> goal;\t\t// 123456780\n    for ( int i = 0; i < 9; i++ ) {\n\tgoal.push_back( (i + 1) % 9 );\n    }\n\n    for ( int i = 0; i < 9; i++ ) {\n\tint d;\n\tscanf(\"%d\", &d);\n\tstart.push_back( d );\n    }\n\n    S.insert( convert(start) );\n    Q.push( make_pair( start, 0 ) );\n    int ans = 0;\n\n    while ( !Q.empty() ) {\n\tP p = Q.front(); Q.pop();\n\tif ( isSame( p.first, goal) ) {\n\t    ans = p.second;\n\t    break;\n\t}\n\tint pos = zeroPosition( p.first );\n\t\n\tif ( ( pos % 3 ) != 0 ) { // ???????§???????\n\t    vector<int> v = swapDigit( p.first, pos, pos - 1 );\n\t    if ( S.find( convert(v) ) == S.end() ) {\n\t\tQ.push( make_pair( v, p.second + 1 ) );\n\t    }\n\t}\n\n\tif ( ( pos % 3 ) != 2 ) { // ???????§???????\n\t    vector<int> v = swapDigit( p.first, pos, pos + 1 );\t    \n\t    if ( S.find( convert(v) ) == S.end() ) {\n\t\tQ.push( make_pair( v, p.second + 1 ) );\n\t    }\n\t}\n\n\tif ( pos > 2 ) { // ???????§???????\n\t    vector<int> v = swapDigit( p.first, pos, pos - 3 );\t    \t    \n\t    if ( S.find( convert(v) ) == S.end() ) {\n\t\tQ.push( make_pair( v, p.second + 1 ) );\n\t    }\n\t}\n\n\tif ( pos < 6 ) { // ???????§???????\n\t    vector<int> v = swapDigit( p.first, pos, pos + 3 );\t    \t    \n\t    if ( S.find( convert(v) ) == S.end() ) {\n\t\tQ.push( make_pair( v, p.second + 1 ) );\n\t    }\n\t}\n    }\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n  \nint t[3][3];\nint limit;\n  \nint Puzzle_1(){\n  int res=0,a;\n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n      if(t[i][j]==0)continue;\n      a=t[i][j]-1;\n      res+=abs(a/3-i)+abs(a%3-j);\n    }\n  }\n  return res;\n}\n  \nbool confirm(int depth,int prev,int py,int px){\n  int heuri=Puzzle_1();\n  if(heuri+depth>limit)return false;\n  if(heuri==0)return true;\n  for(int i=0;i<4;i++){\n    if(abs(i-prev)==2)continue;\n    int ny=py+dy[i],nx=px+dx[i];\n    if(ny<0||nx<0)continue;\n    if(ny>=3||nx>=3)continue;\n    swap(t[ny][nx],t[py][px]);\n    if(confirm(depth+1,i,ny,nx)) return true;\n    swap(t[ny][nx],t[py][px]);\n  }\n  return false;\n}\n  \nvoid solve(int py,int px){\n  for(limit=0;;limit++){\n    if(confirm(0,99,py,px)){\n      cout<<limit<<endl;\n      return;\n    }\n  }\n}\nint main(){\n  int py,px;\n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n      cin>>t[i][j];\n      if(t[i][j]==0){\n    py=i;\n    px=j;\n      }\n    }\n  }\n  solve(py,px);\n  return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const {\n    for(int i = 0 ; i < N2 ; i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const int dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  for(int i = 0 ; i < N2 ; i++)\n    if(p.f[i] != (i + 1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n\n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r = 0 ; r < 4 ; r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if(!V[v]){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i = 0 ; i < N2 ; i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <map>\n#include <cstdio>\nusing namespace std;\n#define X 3\n#define Y 3\nint main(){\n\tint i=1,start_point;\n\tvector<int>start(X*Y),goal;\n\tfor(;i<X*Y;i++)goal.push_back(i);goal.push_back(0);\n\tfor(i=0;i<X*Y;i++){\n\t\tscanf(\"%d\",&start[i]);\n\t\tif(start[i]==0)start_point=i;\n\t}\n\tif(start==goal){puts(\"0\");return 0;}\n\n\tmap<vector<int>,pair<int,int> >mstart;\n\tqueue<vector<int> >q;\n\tmstart[start]=make_pair(start_point,0);\n\tq.push(start);\n\tfor(;!q.empty();){\n\t\tvector<int> v=q.front();\n\t\tq.pop();\n\t\tmap<vector<int>,pair<int,int> >&m=mstart;\n\t\tint coor=m[v].first,x=coor%X,y=coor/X;\n\t\tint depth=m[v].second;\n\t\tif(0<x){\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t\tif(m.find(v)==m.end())m[v]=make_pair(coor-1,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t}\n\t\tif(x<X-1){\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t\tif(m.find(v)==m.end())m[v]=make_pair(coor+1,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t}\n\t\tif(0<y){\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t\tif(m.find(v)==m.end())m[v]=make_pair(coor-X,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t}\n\t\tif(y<Y-1){\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t\tif(m.find(v)==m.end())m[v]=make_pair(coor+X,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\n#define P(x) cout << (x) << \"\\n\"\n#define p(x) cout << (x)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define vv(type, c, m, n, i) vector<vector<type>> c(m, vector<type>(n, i));\n#define rep(i,a,n) for(int i=(a), i##_len=(n); i<i##_len; ++i)\n#define rrep(i,a,n) for(int i=(a), i##_len=(n); i>i##_len; --i)\n#define len(x) ((int)(x).size())\n#define mp make_pair\n#define eb emplace_back\n#define fi first\n#define se second\n#define chmax(a,b) if(a<b)a=b;\n#define chmin(a,b) if(b<a)a=b;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef pair<int, int> pii;\nconstexpr int dx[] = {1, 0, -1,  0};\nconstexpr int dy[] = {0, 1,  0, -1};\n#define N 3\n#define N2 9\nconstexpr char dir[4] = {'u', 'l', 'd', 'r'};\nstruct Puzzle {\n\tvi f;\n\tint space;\n\tstring path;\n\tPuzzle(): space(0), path(\"\") {\n\t\tvi b(N2, 0);\n\t\tf = b;\n\t}\n\tbool operator < (const Puzzle &p) const {\n\t\trep(i, 0, N2) {\n\t\t\tif(f[i] == p.f[i]) continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\nbool isTarget(Puzzle p) {\n\trep(i, 0, N2)\n\t\tif(p.f[i] != (i + 1)) return false;\n\treturn true;\n}\nstring bfs(Puzzle s) {\n\tdeque<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tQ.eb(s);\n\tV[s] = true;\n\tint sx, sy, tx, ty;\n\twhile(!Q.empty()) {\n\t\tu = Q.front(); Q.pop_front();\n\t\tif(isTarget(u)) return u.path;\n\t\tsx = u.space / N;\n\t\tsy = u.space % N;\n\t\trep(r, 0, 4) {\n\t\t\ttx = sx + dx[r];\n\t\t\tty = sy + dy[r];\n\t\t\tif(tx < 0 || tx >= N || ty < 0 || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif(!V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.eb(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsoIvable\";\n}\nint main() {\n\tPuzzle in;\n\trep(i, 0, N2) {\n\t\tcin >> in.f[i];\n\t\tif(in.f[i] == 0) {\n\t\t\tin.f[i] = N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tP(len(ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nbool ok(int a[3][3])\n{\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tif (a[i / 3][i % 3] != i + 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstruct puzzle\n{\n\tint board[3][3];\n\tint distance;\n};\n\nconst int dx[4] = { 0, -1, 1, 0 };\nconst int dy[4] = { -1, 0, 0, 1 };\n\nint main() \n{\n\tpuzzle start;\n\n\tstart.distance = 0;\n\n\tfor (int i = 0; i < 3; i++)\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tcin >> start.board[i][j];\n\n\tqueue<puzzle> que; que.push(start);\n\n\tint Ans = 0;\n\n\tif (ok(start.board) == false)\n\t{\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tpuzzle p = que.front(); que.pop();\n\n\t\t\tint x, y;\n\n\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t\t{\n\t\t\t\t\tif (p.board[i][j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t\t{\n\t\t\t\tif (0 <= x + dx[dir] && x + dx[dir] < 3 && 0 <= y + dy[dir] && y + dy[dir] < 3)\n\t\t\t\t{\n\t\t\t\t\tpuzzle q = p;\n\n\t\t\t\t\tswap(q.board[y][x], q.board[y + dy[dir]][x + dx[dir]]);\n\n\t\t\t\t\tq.distance = p.distance + 1;\n\n\t\t\t\t\tif (ok(q.board) == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tAns = q.distance; goto Exit;\n\t\t\t\t\t}\n\n\t\t\t\t\tque.push(q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExit:;\n\n\tcout << Ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\n//template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n \n/* attention\n    long longのシフト演算には気をつけよう\n    タイポした時のデバッグが死ぬほどきつくなるので変数名は最低3字くらい使った方がいいかも\n*/\n\nconst int N = 3;\nconst int N2 = 9;\n\nstruct Puzzle{\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for(int i=0; i<N2; i++){\n            if(f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n    for(int i=0; i<N2; i++){\n        if(p.f[i] != (i+1)) return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while(!Q.empty()){\n        u = Q.front(); Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx = u.space/N;\n        int sy = u.space%N;\n        for(int r=0; r<4; r++){\n            int tx = sx+dx[r];\n            int ty = sy+dy[r];\n            if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx*N + ty]);\n            v.space = tx*N + ty;\n            if(!V[v]){\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n\n    return \"unsolvable\";\n}\n\nint main(){\n    Puzzle in;\n    for(int i=0; i<N2; i++){\n        cin >> in.f[i];\n        if(in.f[i] == 0){\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, s, n) for (int i = s; i < n; i++)\n#define rep(i, n) REP(i, 0, n)\n\nusing namespace std;\n\n// data\nint P[3][3];\n\nvoid solve();\nint main(){\n    rep(i, 3){\n        rep(j, 3){\n            cin >> P[i][j];\n        }\n    }\n\n    solve();\n}\n\nint manhattan(int (*P)[3]){\n    int dst = 0;\n    rep(i, 3){\n        rep(j, 3){\n            if(P[i][j] == 0) continue;\n\n            int ti = (P[i][j] - 1) / 3,\n                tj = (P[i][j] - 1) % 3; // target location\n            dst += abs(ti - i) + abs(tj - j);\n        }\n    }\n\n    return dst;\n}\n\ntypedef pair<int, int> Pi;\n\nstruct State{\n    State(int (*P0)[3], int move0, Pi blankBef, Pi blankNow){\n        rep(i, 3)\n            rep(j, 3)\n                P[i][j] = P0[i][j];\n        move = move0;\n        dst = manhattan(P) + move;\n        blank = blankNow;\n        _blank = blankBef;\n    }\n    friend bool operator>(State s0, State s1){\n        return s0.dst > s1.dst;\n    }\n    int dst;\n    int move;\n    int P[3][3];\n    pair<int, int> blank, _blank;\n};\n\nconst int di[4] = {-1, 1, 0 ,0},\n    dj[4] = {0,0,-1, 1};\nvoid solve(){\n    // find blank\n    int bi, bj;\n    rep(i, 3)\n        rep(j, 3) if (P[i][j] == 0) bi = i,\n                                    bj = j;\n\n    State s0(P, 0, Pi(bi, bj), Pi(bi, bj));\n    priority_queue<State, vector<State>, greater<State>> pq;\n    pq.push(s0);\n\n    while(!pq.empty()){\n        State s = pq.top(); pq.pop();\n\n        // check final\n        if(manhattan(s.P) == 0){\n            cout << s.move << endl;\n            break;\n        }\n        \n        rep(i, 4){\n            int ii, jj;\n            ii = s.blank.first + di[i];\n            jj = s.blank.second + dj[i];\n\n            if(ii>=0&&ii<3 && jj>=0&&jj<3 && Pi(ii, jj)!= s._blank){\n                swap(s.P[s.blank.first][s.blank.second], \n                    s.P[ii][jj]);\n\n                pq.push(State(s.P, s.move+1, s.blank, Pi(ii, jj)));\n\n                swap(s.P[s.blank.first][s.blank.second],\n                     s.P[ii][jj]);\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL =     1      | 2 << (1*4)  | 3 << (2*4)\n                 | 4 << (3*4) | 5 << (4*4)  | 6 << (5*4)\n                 | 7 << (6*4) | 8LL << (7*4) | 0LL << (8*4);\n\nstruct state {\n    Board board;\n    int count;\n};\n\nqueue<state> q;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n//    board |= static_cast<long long>(num) << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    ++s.count;\n    if (s.board == GOAL) {\n        return s.count;\n    }\n    q.push(s);\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\nint main(void) {\n\n    Board board = 0;\n    int i = 0;\n    while (i != N) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            board |= static_cast<long long>((ch - '0')) << (i*4);\n            ++i;\n        }\n    }\n\n//    print(GOAL);\n//    print(board);\n\n    q.push({ board, 0 });\n    int count = 0;\n    while (!q.empty()) {\n        state s = q.front();\n        q.pop();\n        // ?????????????????????\n        int pos;\n        for (int i = 0; i < N; ++i) {\n            if (((s.board >> (i*4)) & 15) == 0) {\n                pos = i;\n                break;\n            }\n        }\n\n        if (pos < 3) {\n            if (pos < 2) {\n                if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if (pos > 0) {\n                if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        else if (pos < 6) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n            if (pos < 5) {\n                if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if (pos > 3) {\n                if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        else {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n            if (pos < 8) {\n                if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if (pos > 6) {\n                if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <set>\n#include <queue>\n\n\nusing namespace std;\n\nconst int N = 3;\n\nstruct Puzzle {\n    array<array<int, N>, N> board;\n    array<int, 2> empty;\n    int turn;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                if (board[i][j] != p.board[i][j])\n                    return board[i][j] < p.board[i][j];\n            }\n        }\n        return false;\n    }\n};\n\n\nvector<array<int, 2>> dir = {\n    {-1, 0}, // left\n    {0, -1}, // up\n    {1, 0},  // right\n    {0, 1},  // down\n};\n\nbool solved(const Puzzle& p) {\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            int x = i == 2 && j == 2 ? 0 : i * 3 + j + 1;\n            if (p.board[i][j] != x) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    Puzzle start;\n    start.turn = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            int x;\n            cin >> x;\n            if (x == 0) {\n                start.empty = {i, j};\n            }\n            start.board[i][j] = x;\n        }\n    }\n\n    Puzzle ans;\n    set<Puzzle> visited;\n    queue<Puzzle> Q;\n    Q.push(start);\n    while (!Q.empty()) {\n        auto u = Q.front();\n        Q.pop();\n        if (solved(u)) {\n            ans = u;\n            break;\n        }\n        for (auto& d : dir) {\n            auto tx = u.empty[0] + d[0];\n            auto ty = u.empty[1] + d[1];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N) {\n                continue;\n            }\n            auto v = u;\n            swap(v.board[v.empty[0]][v.empty[1]], v.board[tx][ty]);\n            v.empty = {tx, ty};\n            if (visited.find(v) == visited.end()) {\n                ++v.turn;\n                visited.insert(v);\n                Q.push(v);\n            }\n        }\n    }\n    cout << ans.turn << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define A 3\n#define B 9\n\nstruct puzzle{\n    int f[B];\n    int space;\n    string path;\n    \n    bool operator<(const puzzle &p) const{\n        int i;\n        for(i=0;i<B;i++){\n            if(f[i]==p.f[i]) continue;\n            return f[i]>p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool Target(puzzle p){\n    int i;\n    for(i=0;i<B;i++)\n        if(p.f[i] != (i+1)) return false;\n    return true;\n}\n\nstring bfs(puzzle s){\n    queue<puzzle> Q;\n    map<puzzle,bool>V;\n    puzzle u,v;\n    s.path= \"\";\n    Q.push(s);\n    V[s]=true;\n    \n    while(!Q.empty()){\n        u=Q.front();\n        Q.pop();\n        if(Target(u)) return u.path;\n        int sx=u.space/A;\n        int sy=u.space%A;\n        int r;\n        for(r=0;r<4;r++){\n            int tx=sx+dx[r];\n            int ty=sy+dy[r];\n            if(tx<0||ty<0||tx>=A||ty>=A) continue;\n            v=u;\n            swap(v.f[u.space], v.f[tx*A+ty]);\n            v.space=tx*A+ty;\n            if(!V[v]){\n                V[v]=true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main(){\n    puzzle in;\n    int i;\n    \n    for(i=0;i<B;i++){\n        cin >> in.f[i];\n        if(in.f[i]==0){\n            in.f[i]=B;\n            in.space=i;\n        }\n    }\n    string ans=bfs(in);\n    cout << ans.size() << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iterator>\n#include <vector>\n#include <queue>\n\nnamespace eight_puzzle{\n\ttypedef unsigned int uint;\n\tconst int N = 3;\n\tstruct State{\n\t\tState(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t}\n\t\tState(const uint tt,const uint tn){\n\t\t\ttable = tt;\n\t\t\tn = tn;\n\t\t}\n\n\t\tState& operator=(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t\treturn (*this);\n\t\t}\n\t\tbool isfinished(){\n\t\t\t\treturn table == 123456780;\n\t\t}\n\t\t\n\t\tuint table;\n\t\tuint n;\n\t};\n\tuint arraytovalue(int *table){\n\t\tuint t=0;\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tt*=10;\n\t\t\tt=t+table[i];\n\t\t}\n\t\treturn t;\n\t}\n\tvoid getnextstate(const State &s,std::vector<State> &states){\n\t\tint table[N*N];\n\t\tint t = s.table;\n\t\tint zi,zj;\n\t\tfor(int i=N-1;i>=0;--i){\n\t\t\tfor(int j=N-1;j>=0;--j){\n\t\t\t\tint panel = t-t/10*10;\n\t\t\t\ttable[i*N+j] = panel;\n\t\t\t\tt/=10;\n\t\t\t\tif(panel==0){\n\t\t\t\t\tzi = i;\n\t\t\t\t\tzj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=-1;i<=1;++i){\n\t\t\tfor(int j=-1;j<=1;++j){\n\t\t\t\tif((i+j)%2==0)continue;\n\t\t\t\tint ti = zi+i,tj=zj+j;\n\t\t\t\tif(0<=ti&&ti<N&&0<=tj&&tj<N){\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t\tstates.push_back(State(arraytovalue(table),s.n+1));\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tstd::vector<uint> visited;\n\t\n};\n\nint main(){\n\tusing namespace eight_puzzle;\n\tint array[N*N];\n\tfor(int i=0;i<N*N;++i){\n\t\tstd::cin>>array[i];\n\t}\n\tState init(arraytovalue(array),0);\n\n\tstd::queue<State> Q;\n\tQ.push(init);\n\twhile(!Q.empty()){\n\t\tState s = Q.front();\n\t\tQ.pop();\n\t\tstd::vector<State> states;\n\t\tgetnextstate(s,states);\n\t\tfor(uint i=0;i<states.size();++i){\n\t\t\tif(states[i].isfinished()){\n\t\t\t\tstd::cout<<states[i].n<<std::endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(std::find(visited.begin(),visited.end(),states[i].table)==visited.end()){\n\t\t\t\tQ.push(states[i]);\n\t\t\t\tvisited.push_back(states[i].table);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n#define N 3\n#define N2 9\nusing namespace std;\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n  bool operator < (const Puzzle &p)const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++)\n    if(p.f[i]!=(i+1))return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle>Q;\n  map<Puzzle,bool>V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n  \n  while(!Q.empty()){\n    u=Q.front();\n    Q.pop();\n    if(isTarget(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N)continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  for(int i=0;i<N2;i++){\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  printf(\"%lu\\n\",ans.size());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <map>\n#include <queue>\n\ntemplate <class T, class U>\nT ipow(T b, U n) {\n    T ret = 1;\n    while (n > 0) {\n        if (n & 1) ret *= b;\n        n >>= 1;\n        b *= b;\n    }\n    return ret;\n}\n\nconst int dx[4] = {-1, 0, 0, 1};\nconst int dy[4] = {0, -1, 1, 0};\n\nconst std::array<std::array<int, 3>, 3> goal({std::array<int, 3>({1, 2, 3}),\n                                              std::array<int, 3>({4, 5, 6}),\n                                              std::array<int, 3>({7, 8, 0})});\n\nint encode(const std::array<std::array<int, 3>, 3>& brd) {\n    int ret = 0;\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            ret += ipow(9, i * 3 + j) * brd[i][j];\n        }\n    }\n    return ret;\n}\n\nint main() {\n    std::array<std::array<int, 3>, 3> brd;\n    for (auto& v : brd) {\n        for (auto& e : v) std::cin >> e;\n    }\n\n    std::map<int, int> dp;\n    std::queue<std::array<std::array<int, 3>, 3>> que;\n    que.push(brd);\n    dp[encode(brd)] = 0;\n\n    while (!que.empty()) {\n        auto b = que.front();\n        que.pop();\n        int ope = dp[encode(b)];\n\n        int zx, zy;\n        {\n            bool flag = false;\n            for (zx = 0; zx < 3; ++zx) {\n                for (zy = 0; zy < 3; ++zy) {\n                    if (b[zx][zy] == 0) {\n                        flag = true;\n                        break;\n                    }\n                }\n                if (flag) break;\n            }\n        }\n\n        for (int i = 0; i < 4; ++i) {\n            int nx = zx + dx[i], ny = zy + dy[i];\n            if (nx < 0 || 3 <= nx || ny < 0 || 3 <= ny) continue;\n            std::swap(b[zx][zy], b[nx][ny]);\n            int id = encode(b);\n            if (!dp.count(id)) {\n                dp[id] = ope + 1;\n                que.push(b);\n            }\n            std::swap(b[zx][zy], b[nx][ny]);\n        }\n    }\n\n    std::cout << dp[encode(goal)] << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief 8パズル問題を扱う\n *\n * @date 2016/02/29\n */\n\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <string>\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing array1D = std::vector<int>;\n\n\n//****************************************\n// 大域変数の定義\n//****************************************\n\nstatic const int N  = 3;                           /**< 3x3の盤面を考える */\nstatic const int NN = 9;                           /**< 3x3 = 9 */\nstatic const array1D dx = { -1,  0,  1,  0 };      /**< 方向ベクトルのx成分 */\nstatic const array1D dy = {  0, -1,  0,  1 };      /**< 方向ベクトルのy成分 */\nstatic const char dir[] = { 'l', 'u', 'r', 'd' };  /**< 方向ベクトルのキー */\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct puzzle {\n    array1D state;\n    int space;\n    std::string path;\n\n    puzzle() : state(NN) { }\n\n    /**< @brief <演算子オーバーロード */\n    bool operator < (const puzzle& p) const\n    {\n        for (int i = 0; i < NN; i++) {\n            if (state[i] == p.state[i]) { continue; }\n            return state[i] > p.state[i];\n        }\n        return false;\n    }\n\n    /**< @brief []演算子オーバーロード */\n    int& operator [] (std::size_t i)\n    {\n        return state[i];\n    }\n\n     /**< @brief パズルの状態が解決済みか否か返す  */\n    bool resolved()\n    {\n        for (int i = 0; i < NN; i++) {\n            if (state[i] != (i + 1)) { return false; }\n        }\n        return true;\n    }\n};\n\n\n\n/**< @brief 幅優先探索を行い8パズルを解く */\nstd::string bfs(puzzle s)\n{\n    std::queue<puzzle> Q;      // パズルを格納するキュー\n    std::map<puzzle, bool> V;  // パズルをキーとした連想配列\n    puzzle u, v;\n\n    auto init  = [&]() -> void      { s.path = \"\"; Q.push(s); V[s] = true; };                     // 手続きと同時に始点sを発見\n    auto visit = [&](int i) -> void { if (!V[v]) { V[v] = true; v.path += dir[i]; Q.push(v);} };  // 訪問済みの印を刻む\n\n    init();\n    while (!Q.empty()) {\n        u = Q.front(); Q.pop();\n        if (u.resolved()) { return u.path; }  // パズルが解決済みならそれまでの手を返す\n        // 現在の空いているマスの座標を取得\n        int spaceX = u.space % N;\n        int spaceY = u.space / N;\n        for (int i = 0; i <= N; i++) {  // 左、上、右、下方向の順にループする\n            // ターゲットとなる座標を取得\n            int targetX = spaceX + dx[i];\n            int targetY = spaceY + dy[i];\n            // パズルの範囲外なら隣接していないとみなす\n            if (targetX < 0 || targetX >= N || targetY < 0 || targetY >= N) { continue; }\n            // 以下、uの隣接リストに属するパズルの状態vを考える\n            v = u;\n            std::swap(v[u.space], v[targetY * N + targetX]);    // パズルの手を進める\n            v.space = targetY * N + targetX;                    // 空いたマスを記憶\n            visit(i);                                           // 未訪問ならば、訪問する\n        }\n    }\n    return \"unresovable\";\n}\n\n\nint main()\n{\n    using namespace std;\n    puzzle p;\n\n    for (int i = 0; i < NN; i++) {\n        cin >> p[i];\n        if (p[i] == 0) {\n            p[i] = NN;\n            p.space = i;\n        }\n    }\n\n    string ans = bfs(p);\n    cout << ans.size() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint x,sx,sy,g[3][3],dir[4][2]={{-1,0},{0,-1},{0,1},{1,0}};\nstruct node{\n\tint v[3][3],x,y,step;\n};\nmap<string,int> ht;\nint judge(node a){\n\tstring s=\"\";\n\tfor(int i=0;i<3;i++){\n\t\tfor(int j=0;j<3;j++){\n\t\t\tx=a.v[i][j];\n\t\t\ts+=x+'0';\n\t\t}\n\t}\n\tif(!ht[s]){\n\t\tht[s]=1;\n\t\treturn 1;\n\t}\n\telse return 0;\n}\nint check(node a){\n\tint cnt=1,f=1;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(a.v[i][j]==cnt){\n\t\t\t\tcnt++;\n\t\t\t\tif(cnt==9) cnt=0;\n\t\t\t}\n\t\t\telse f=0;\n\t\t}\n\t}\n\treturn f;\n}\nvoid bfs(){\n\tqueue<node> q;\n\tnode tmp,tt;\n\ttmp.x=sx,tmp.y=sy,tmp.step=0;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int j=0;j<3;j++){\n\t\t\ttmp.v[i][j]=g[i][j];\n\t\t}\n\t}\n\tjudge(tmp);\n\tq.push(tmp);\n\twhile(!q.empty()){\n\t\ttt=q.front();\n\t\tq.pop();\n\t\tif(check(tt)) {\n\t\t\tprintf(\"%d\\n\",tt.step);\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint tx=tt.x+dir[i][0];\n\t\t\tint ty=tt.y+dir[i][1];\n\t\t\tif(tx>=0&&tx<3&&ty>=0&&ty<3){\n\t\t\t\ttmp.x=tx,tmp.y=ty,tmp.step=tt.step+1;\n\t\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\t\ttmp.v[i][j]=tt.v[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp.v[tt.x][tt.y]=tt.v[tx][ty];\n\t\t\t\ttmp.v[tx][ty]=0;\n\t\t\t\tif(judge(tmp)){\n\t\t\t\t\tq.push(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} \n}\nint main()\n{\n\tfor(int i=0;i<3;i++){\n\t\tfor(int j=0;j<3;j++){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tif(x==0) {\n\t\t\t\tsx=i,sy=j;\n\t\t\t}\n\t\t\tg[i][j]=x;\n\t\t}\n\t}\n\tbfs();\n } \n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <unordered_map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\nint main(){\n\t\n\tqueue<string> que;\n\t\n\tunordered_map<string, int> m;\n\t\n\tstring fs = \"\";\n\t\n\tfor(int i = 0; i < 9; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tfs += s;\n\t}\n\t\n\tque.push(fs);\n\t\n\tfor(int loop = 0; loop < 1000; loop++){\n\t\tif(que.empty()){\n\t\t\tbreak;\n\t\t}\n\t\tint sz = que.size();\n\t\tfor(int num = 0; num < sz; num++){\n\t\t\tstring str = que.front();\n\t\t\tque.pop();\n\t\t\tif(m.find(str) != m.end()){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tm[str] = loop;\n\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\tif(str[i] == '0'){\n\t\t\t\t\tif(i >= 3){\n\t\t\t\t\t\tswap(str[i], str[i - 3]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i - 3]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i < 6){\n\t\t\t\t\t\tswap(str[i], str[i + 3]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i + 3]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i % 3 > 0){\n\t\t\t\t\t\tswap(str[i], str[i - 1]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i - 1]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i % 3 < 2){\n\t\t\t\t\t\tswap(str[i], str[i + 1]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << m[\"123456780\"] << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < ( const Puzzle &p ) const {\n    for ( int i = 0; i < N2; i++ ) {\n      if ( f[i] == p.f[i] ) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n  for ( int i = 0; i < N2; i++ )\n    if ( p.f[i] != (i + 1) ) return false;\n  return true;\n}\n\nstring bfs(Puzzle p) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while ( !Q.empty() ) {\n    u = Q.front(); Q.pop();\n    if ( isTarget(u) ) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for ( int r = 0; r < 4; r++ ) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if ( !V[v] ) {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main() {\n  Puzzle in;\n\n  for ( int i = 0; i < N2; i++ ) {\n    cin >> in.f[i];\n    if ( in.f[i] == 0 ) {\n      in.f[i] = N2;  // set space\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\n\nclass board{\nprivate:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<int> tiles;\n\npublic:\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        REP(i, 9){\n            tiles.push_back(num[i]);\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n    }\n\n    int cost() {\n        return wrongs + moves;\n    }\n\n    void move() {\n        pq.pop();\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\n\n\nbool operator< (board b1, board b2){\n    return (b1.cost() > b2.cost()) ? true : false;\n}\n\nint dfs(int moves, int cutoff){\n    pq.push(board(original, 0));\n    while(!pq.empty()){\n        auto target = pq.top();\n        if(target.cost() > cutoff)\n            return -1;\n        if(target.get_wrongs() == 0)\n            return target.cost();\n        else{\n            target.move();\n        }\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = 0;\n\n    REP(i, 100){\n        move = dfs(0, i);\n        if(move > 0){\n            break;\n        }\n        pq = priority_queue <board>();\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define rep(i,n) FOR(i,0,n)\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define vint vector<int>\n#define vdouble vector<double>\n#define vstring vector<string>\nusing namespace std;\n\n#include<map>\n#include<set>\n#include<queue>\n#include <sstream>\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int MAX_N = 1000000;\nconst int INFTY = (1 << 21); // 2097152\n// const ll INFTY = (1LL << 60);\nconst ll MD = 1000000007LL;\n\nstruct Board{\n\tvector<vint> v;\n    ll _hash;\n\n\tBoard(vector<vint> v){\n\t\tthis->v = v;\n        _hash = hash();\n\t}\n\n\tvector<Board> transition(){\n\t\tvector<Board> ret;\n\n\t\tvint dx{1, 0, -1, 0};\n\t\tvint dy{0, 1, 0, -1};\n\n\t\tint x0 = 0, y0 = 0;\n\t\trep(y, 3) rep(x, 3){\n\t\t\tif(v[y][x] == 0) {x0 = x; y0 = y;}\n\t\t}\n\n\t\trep(d, 4){\n\t\t\tint xn = x0 + dx[d];\n\t\t\tint yn = y0 + dy[d];\n\t\t\tif(xn >= 0 && xn < 3 && yn >= 0 && yn < 3){\n\t\t\t\tvector<vint> vv = v;\n\t\t\t\tvv[yn][xn] = v[y0][x0];\n\t\t\t\tvv[y0][x0] = v[yn][xn];\n\t\t\t\tret.push_back(Board(vv));\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tll hash() const{\n\t\tll ret = 0;\n\t\tll m = 1;\n\t\trep(y, 3) rep(x, 3){\n\t\t\tret += v[y][x] * m;\n\t\t\tm *= 10;\n\t\t}\n        return ret;\n\t}\n\n\tbool operator < (const Board &p) const {\n        ll h1 = _hash;\n        ll h2 = p._hash;\n\t\treturn h1 < h2;\n\t}\n\n\tbool operator == (const Board &p) const{\n        ll h1 = _hash;\n        ll h2 = p._hash;\n        return h1 == h2;\n\t}\n};\n\nint main() {\n\tvector<vint> v0;\n\trep(y, 3){\n\t\tvint v;\n\t\trep(x, 3) { int n; cin >> n; v.push_back(n);}\n\t\tv0.push_back(v);\n\t}\n\tBoard b0 = Board(v0);\n\n\tvector<vint> ve;\n\tvint ve1{1, 2, 3}; ve.push_back(ve1);\n\tvint ve2{4, 5, 6}; ve.push_back(ve2);\n\tvint ve3{7, 8, 0}; ve.push_back(ve3);\n\tBoard be = Board(ve);\n\n\tset<Board> S;\n\tqueue<pair<Board, int>> q;\n\n\tq.push(make_pair(b0, 0));\n    // fprintf(stderr, \"%09lld\\n\", b0.hash());\n    // fprintf(stderr, \"%09lld\\n\", be.hash());\n\n\twhile(true){\n\t\tauto p = q.front(); q.pop();\n\t\tBoard b = p.first;\n\t\tint t = p.second;\n\n        S.find(b);\n        S.end();\n\t\tif(S.find(b) != S.end()) continue;\n        S.insert(b);\n        // fprintf(stderr, \"%09lld %d\\n\", b.hash(), t);\n\n\t\tif(b == be) {cout << t << endl; return 0;}\n\n\t\tvector<Board> trans = b.transition();\n\t\tfor(Board bb: trans){\n\t\t\tq.push(make_pair(bb, t+1));\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n#define N 3\n#define LIMIT_TIME 180000\ntypedef pair<int, int> P;\n\nstruct State {\n    int g, h;\n    string state;\n    P blank;\n    string path;\n    bool operator<(const State &a) const {\n        return g + h > a.g + a.h;\n    }\n};\n\nint d[5] = {-1, 0, 1, 0, -1};\nstring r[4] = {\"D\", \"R\", \"U\", \"L\"};\nstring ans_str = \"\";\nint ans[N][N], puzzle0[N][N], puzzle1[N][N];\nset<string> s;\npriority_queue<State> next_state;\nstring path;\n\nbool range(int y, int x) {return 0 <= y && y < N && 0 <= x && x < N;}\n\nint h2() {\n    int find = -1;\n    while(next_state.size()) {\n        State state = next_state.top();\n        next_state.pop();\n        if (s.count(state.state)) continue; // already search\n        s.insert(state.state); // visited\n\n        P blank = state.blank;\n        rep(i, 4) {\n            int y = d[i] + blank.first, x = d[i + 1] + blank.second; // next blank position\n            if (range(y, x)) { // can be replaced\n                string tmp = state.state; // next state (string)\n                int p = blank.first * N + blank.second, q = y * N + x;\n                if (N < 4)  swap(tmp[p], tmp[q]);\n                else swap(tmp[2 * p], tmp[2 * q]), swap(tmp[2 * p + 1], tmp[2 * q + 1]);\n                if (s.count(tmp)) continue; // already search\n\n                int num;\n                if (N < 4) num = state.state[q] - '1';\n                else num = stoi(state.state.substr(2 * q, 2)) - 1;\n                // calcurate manhattan distance\n                int manhattan = state.h - ((abs(num / N - y) + abs(num % N - x)))\n                + (abs(num / N - blank.first) + abs(num % N - blank.second));\n\n                if (manhattan == 0) { // answer\n                    find = state.g + 1;\n                    path = state.path + r[i];\n                    break;\n                }\n\n                next_state.push(State{state.g + 1, manhattan, tmp, P(y, x), state.path + r[i]});\n            }\n        }\n        if (find != -1) break; // find an answer\n    }\n    return find;\n}\n\nint main(){\n    rep(i, N)rep(j, N) cin >> puzzle0[i][j];\n\n    string state = \"\";\n    P blank;\n    int manhattan = 0, wrong_place = 0;\n    rep(i, N)rep(j, N) {\n        // cout << puzzle0[i][j] << ((j % N == N - 1) ? \"\\n\" : \"\\t\");\n\n        if (N * N - 1 > 9 && puzzle0[i][j] < 10) state += \"0\";\n        state += to_string(puzzle0[i][j]);\n        if (N * N - 1 > 9 && ans[i][j] < 10) ans_str += \"0\";\n        ans_str += to_string(ans[i][j]);\n\n        if(puzzle0[i][j] == 0) blank = P(i, j);\n        else {\n            int num = puzzle0[i][j] - 1;\n            manhattan += (abs(num / N - i) + abs(num % N - j));\n            if (puzzle0[i][j] != ans[i][j]) wrong_place++;\n        }\n    }\n\n    if (manhattan == 0) { // the answer\n        cout << 0 << endl;\n    } else {\n        s.clear();\n        next_state = priority_queue<State>();\n        next_state.push(State{0, manhattan, state, blank, \"\"});\n        int steps = h2();\n        cout << steps << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define BOARD_N 3\n\nint board[BOARD_N][BOARD_N];\n\nconst int dx[4] = { 0, -1, 1, 0 };\nconst int dy[4] = { -1, 0, 0, 1 };\n\nint min_depth;\n\nvoid dfs(int a[BOARD_N][BOARD_N], int maxdepth, int depth)\n{\n\tif (maxdepth == depth)\n\t{\n\t\tbool ok = true;\n\n\t\tfor (int i = 0; i < BOARD_N * BOARD_N - 1; i++)\n\t\t{\n\t\t\tif (a[i / BOARD_N][i % BOARD_N] != i + 1)\n\t\t\t{\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\n\t\tif (ok == true)\n\t\t{\n\t\t\tmin_depth = maxdepth;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tint x, y;\n\n\tfor (int i = 0; i < BOARD_N; i++)\n\t{\n\t\tfor (int j = 0; j < BOARD_N; j++)\n\t\t{\n\t\t\tif (a[i][j] == 0)\n\t\t\t{\n\t\t\t\tx = j;\n\t\t\t\ty = i;\n\t\t\t}\n\t\t}\n\t}\n\n\tint b[BOARD_N][BOARD_N];\n\n\tfor (int dir = 0; dir < 4; dir++)\n\t{\n\t\tif (0 <= x + dx[dir] && dx[dir] < BOARD_N && 0 <= y + dy[dir] && y + dy[dir] < BOARD_N)\n\t\t{\n\t\t\tfor (int i = 0; i < BOARD_N; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < BOARD_N; j++)\n\t\t\t\t{\n\t\t\t\t\tb[i][j] = a[i][j];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswap(b[y][x], b[y + dy[dir]][x + dx[dir]]);\n\n\t\t\tdfs(b, maxdepth, depth + 1);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tmin_depth = 100;\n\n\tfor (int i = 0; i < 3; i++)\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tcin >> board[i][j];\n\n\tfor (int i = 0; i < 45; i++)\n\t{\n\t\tdfs(board, i, 0);\n\n\t\tif (min_depth != 100) { break; }\n\t}\n\n\tcout << min_depth << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Puzzle{\n    int f[9];\n    int space;\n    string path;\n\n    bool operator<(const Puzzle &p)const{\n        for(int i=0;i<9;i++){\n            if(f[i]==p.f[i]) continue;\n            return f[i]<p.f[i];\n        }\n        return false;\n    }\n};\n\nbool isTarget(Puzzle &p){\n    for(int i=0;i<9;i++){\n        if(p.f[i]!=i+1) return false;\n    }\n    return true;\n}\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nstring bfs(Puzzle &s){\n    queue<Puzzle> Q;\n    map<Puzzle,bool> V;\n    Puzzle u,v;\n    s.path=\"\";\n    Q.push(s);\n    V[s]=true;\n    while(!Q.empty()){\n        u=Q.front();\n        Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx=u.space/3;\n        int sy=u.space%3;\n        for(int r=0;r<4;r++){\n            int tx=sx+dx[r];\n            int ty=sy+dy[r];\n            if(tx<0||ty<0||tx>2||ty>2){\n                continue;\n            }\n            v=u;\n            swap(v.f[u.space],v.f[tx*3+ty]);\n            v.space=tx*3+ty;\n            if(!V[v]){\n                V[v]=true;\n                v.path+=dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main(){\n    Puzzle x;\n    for(int i=0;i<9;i++){\n        cin>>x.f[i];\n        if(x.f[i]==0){\n            x.f[i]=9;\n            x.space=i;\n        }\n    }\n\n    cout<<(bfs(x)).size()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<map>\nusing namespace std;\nconst int dx[4]={0,0,-1,1},dy[4]={-1,1,0,0};\nconst char rd[4]={'d','u','r','l'};\nstruct gg{\n\tint mp[9];\n\tint space;\n\tstring path;\n\tbool operator<(const gg &tmp)const\n\t{\n\t\tfor(register int i=0;i<=8;i++)\n\t\t   {\n\t\t   \tif(mp[i]!=tmp.mp[i])return mp[i]>tmp.mp[i];\n\t\t   }\n\t\treturn false;   \n\t}\n};map<gg,bool>vis;\ninline void bfs(gg bg)\n{   queue<gg> q;\n\tgg now,tmp;register int x,y;\n\tvis[bg]=1;\n\tq.push(bg);\n\twhile(!q.empty())\n\t{   \n\t\tnow=q.front();q.pop();\n\t\ty=now.space/3;x=now.space-y-y-y;\n\t\tfor(register int i=0;i<=3;i++)\n\t\t   {\n\t\t     tmp=now;\n\t\t     if(x+dx[i]<0||x+dx[i]>2||y+dy[i]<0||y+dy[i]>2)continue;\n\t\t     tmp.space=x+dx[i]+y+dy[i]+y+dy[i]+y+dy[i];\n\t\t     swap(tmp.mp[x+y*3],tmp.mp[x+dx[i]+y+dy[i]+y+dy[i]+y+dy[i]]);\n\t\t     tmp.path+=rd[i];\n\t\t     if(!vis[tmp])vis[tmp]=1,q.push(tmp);\n\t\t   }\n\t}\t\t \n}\nint main()\n{ \n\tgg bg,ans;char c;string s;\n\tbg.mp[0]=1;bg.mp[1]=2;bg.mp[2]=3;bg.mp[3]=4;bg.mp[4]=5;bg.mp[5]=6;bg.mp[6]=7;bg.mp[7]=8;bg.mp[8]=0;bg.space=8;bg.path=\"\";bfs(bg);  \n\t for(register int i=0;i<=8;i++)\n\t   {scanf(\" %c\",&c);\n\t   \tif(c=='x')bg.space=i,bg.mp[i]=0;\n\t   \telse bg.mp[i]=c-48;}   \n\tbg.path=\"\";\n\tmap<gg,bool>::iterator pos=vis.find(bg);\n\tif(pos!=vis.end())\n \t  {s=pos->first.path;printf(\"%d\",s.length());}//or(int i=s.length()-1;i!=-1;i--)printf(\"%c\",s[i]);}\n    else cout<<\"unsolvable\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define M 500009\n#define int long long\nusing namespace std;\nstruct st {\n  int puzzle[3][3],cnt,x0,y0;\n};\nint dx[] = { -1,0,1,0 }, dy[] = { 0,-1,0,1 };\nint used[M];\nint fhash(int x) {\n  for (int i = 1;; ++i) \n    if (used[i*x%M] == 0 || used[i * x % M] == x) return i;\n}\nsigned main() {\n  struct st p;\n  p.cnt = 0;\n  for (int i = 0; i < 3; ++i)\n    for (int j = 0; j < 3; ++j) {\n      cin >> p.puzzle[i][j];\n      if (p.puzzle[i][j] == 0) { p.x0 = j; p.y0 = i; }\n    }\n  int head = 0, tail = 0;\n  struct st que[M];\n  que[tail++] = p;\n  while (head != tail) {\n    p = que[head%M]; ++head;\n    int flag = 1;\n    for (int i = 0; i < 3; ++i)\n      for (int j = 0; j < 3; ++j)\n\tif (p.puzzle[i][j] != (3 * i + j + 1) % 9) flag = 0;\n    if (flag) {\n      cout << p.cnt << endl;\n      return 0;\n    }\n    int x = 0, k = 1;\n    for (int i = 2; i >= 0; --i)\n      for (int j = 2; j >= 0; --j, k *= 10) x += p.puzzle[i][j] * k;\n    int y = fhash(x);\n    if (used[y*x%M] == x) continue;\n    used[y*x%M] = x;\n    for (int i = 0; i < 4; ++i) {\n      if (p.x0 + dx[i] >= 0 && p.x0 + dx[i] < 3 && p.y0 + dy[i] >= 0 && p.y0 + dy[i] < 3) {\n\tstruct st q;\n\tfor (int i = 0; i < 3; ++i)\n\t  for (int j = 0; j < 3; ++j) q.puzzle[i][j] = p.puzzle[i][j];\n\tint tmp;\n\ttmp = q.puzzle[p.y0][p.x0];\n\tq.puzzle[p.y0][p.x0] = q.puzzle[p.y0+dy[i]][p.x0+dx[i]];\n\tq.puzzle[p.y0 + dy[i]][p.x0 + dx[i]] = tmp;\n\tq.cnt = p.cnt + 1; q.x0 = p.x0 + dx[i]; q.y0 = p.y0 + dy[i];\n\tque[tail%M] = q; ++tail;\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int field[N2];\n  int blank;\n  int count;\n\n  bool operator < (const Puzzle &p) const {\n    int i;\n    \n    for (i = 0; i < N2; i++) {\n      if (field[i] == p.field[i]) continue;\n      return field[i] > p.field[i];\n    }\n    return false;\n  }\n};\n\nbool isTrue(Puzzle p);\nint bfs(Puzzle s);\n\nint x[4] = {-1, 0, 1, 0};\nint y[4] = {0, -1, 0, 1};\n\nint main() {\n  Puzzle input;\n  int i;\n\n  for (i = 0; i < N2; i++) {\n    cin >> input.field[i];\n    if (input.field[i] == 0) {\n      input.field[i] = N2;\n      input.blank = i;\n    }\n  }\n\n  cout << bfs(input) << endl;\n\n  return 0;\n}\n\nbool isTrue(Puzzle p) {\n  int i;\n  \n  for (i = 0; i < N2; i++) {\n    if (p.field[i] != i + 1) return false;\n  }\n  return true;\n}\n\nint bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  int x1, y1, x2, y2, i;\n  s.count = 0;\n  Q.push(s);\n  V[s] = true;\n\n  while (!Q.empty()) {\n    u = Q.front();\n    Q.pop();\n    if (isTrue(u)) return u.count;\n    x1 = u.blank / N;\n    y1 = u.blank % N;\n    for (i = 0; i < 4; i++) {\n      x2 = x1 + x[i];\n      y2 = y1 + y[i];\n      if (!(x2 >= 0 && y2 >= 0 && x2 < N && y2 < N)) continue;\n      v = u;\n      swap(v.field[u.blank], v.field[x2 * N + y2]);\n      v.blank = x2 * N + y2;\n      if (!V[v]) {\n\tV[v] = true;\n\tv.count++;\n\tQ.push(v);\n\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n//\n////////////////////////////////////////\n\n#include <iostream>\n#include <algorithm> // next_permutation\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cstring> //memcpy\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <list>\n#include <numeric> //accumulate\n//#include <unordered_map> //hash func.\n#include <fstream> //ifstream, ofstream\n\n//#define NDEBUG //If NDEBUG is defined before #include <cassert>, assert will be ignored. You had better define NDEBUG when u submit the code.\n#include <cassert> //assert\n\n\nusing namespace std;\n\n#define TEST //*******************************************************************************************************************************************\n//?????????????????¨??§?????\\????????????????????????????????°?????????????¨???????????????????dout???????????????????????§???????????¬??????????????????????????????????????????\n//??????????????????????????????????????????????????????????§?CPU???????£??????????????????§???TLE?????????????????????????????????????????§????????¨???                           ????????????????????????cerr????????£????????????????????????????????????\n#ifdef TEST\n#define dout cout\n#define din cin\n#else\nstringstream dummy; //???????????°??????dout?????????????????????????????????\n#define dout dummy.str(\"\"); dummy.clear(stringstream::goodbit); dummy //dummy?????????????????????????????????????????¨?????¢?????¢???????????????\n//???????????¨??????????????????goodbit?????????????????????????????¨???????????´????????????????????????????????¨?????°?????????????????§???????????????????????????????????? http://d.hatena.ne.jp/linden/20060427/p1\n#endif\n\n//If u wanna output to a text file instead of standard output, plz define OUTPUTFILE.\n//#define OUTPUTFILE \"output.txt\" //*******************************************************************************************************************************************\n#ifdef OUTPUTFILE\n#define dout outputfile //??¨????????????TLE????????§?????????dout?????¨??¨??????????????¢????????????????????????????????????????????§????¨????????????´??????????????£??????????????????????¨?????????????????????????????????????????????§?????????????????????\nofstream outputfile(OUTPUTFILE);\n#define OutputFilePath \"/Users/Nag/Documents/Prgm/Test/DerivedData/Test/Build/Products/Debug/output.txt\"\n#endif\n\n//If u wanna input from a text file instead of standard input, plz define INPUTFROMTEXTFILE???.\n//#define INPUTFILE \"input.txt\" //*******************************************************************************************************************************************\n#ifdef INPUTFILE\n#define din inputfile\nifstream inputfile(INPUTFILE);\n#endif\n\n\n#define disp(A) dout << #A << \" = \" << setw(3) << (A) << endl\n#define disP(A) dout << setw(3) << (A) << \" \"\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define dispAll(A,n) dout << #A << \" = \"; rep(j, 0, (n)) {disP(A[j]);} dout << endl\n\n#define p(i) (i)/2\n#define l(i) (i)*2\n#define r(i) (i)*2+1\n\nstruct d {int n, m, r, l;}; //for Binary Search Tree\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\nconst int INF = 2e9+10;\nconst ll INF_LL = 1e18; //Be careful for overflow.\nconst int NONE = -1;\nconst int SUCCESSFUL = -2;\n\n#define GOAL 123456780\n//int numOfMove = -1; //?????°\nll numOfSearch = 0;\n\n#define N_MAX 100000//876543210 //num of vertex or element\n#define M_MAX 10000 //num of edge\n\nint N;\n\nstruct d T[N_MAX+1]; //Binary Search Tree\nint H = 0; //num of data in T[]. next new data will be placed on T[H]\n\nqueue<pii> Q; // <puzzle, numOfMove>\n\n\nvoid printInorder(int i) {\n    if(i==NONE) return;\n    \n    printInorder(T[i].l);\n    dout << \" \" << T[i].n;\n    printInorder(T[i].r);\n}\nvoid printPreorder(int i) {\n    if(i==NONE) return;\n    \n    dout << \" \" << T[i].n;\n    printInorder(T[i].l);\n    printInorder(T[i].r);\n}\nvoid print() {\n    printInorder(0);\n    dout << endl;\n    printPreorder(0);\n    dout << endl;\n}\n\nbool find(int x, int i=0) {\n    \n    if(i==NONE) return 0;\n    if(T[i].n==x) return 1;\n    \n    if(x < T[i].n) return find(x, T[i].l);\n    else return find(x, T[i].r);\n    \n}\n\n\nvoid insert(int x, int i=0) { //insert x at T[i]\n\n    if(T[i].n==INF) {\n        T[i].n = x;\n//        T[i].m = numOfMove; //Binary Search Tree?????°????????¶????????????????????¨?????????????????????????????¶????????????????????¨???????????°????¨????????????????\n        H++;\n        return;\n    }\n    \n    if(x < T[i].n) {\n        if(T[i].l==NONE) T[i].l=H;\n        insert(x, T[i].l);\n    }\n    else {\n        if(T[i].r==NONE) T[i].r=H;\n        insert(x, T[i].r);\n    }\n    \n}\n\nvoid puzzle_int2array(int puzzle, int p[]) {\n    int digit = 1e8;\n    rep(i,0,9) {\n        p[i] = puzzle/digit;\n        puzzle %= digit;\n        digit /= 10;\n    }\n}\n\nint puzzle_array2int(int p[]) {\n    int puzzle = 0;\n    int digit = 1e8;\n    rep(i,0,9) {\n        puzzle += p[i]*digit;\n        digit /= 10;\n    }\n    \n    return puzzle;\n}\n\n\n\n\n\nvoid display(int puzzle) {\n    int digit = 1e8;\n    \n    for(int i=8; i>=0; i--) {\n        dout << puzzle/digit << \" \";\n        if(i%3==0) dout << endl;\n        \n        puzzle %= digit;\n        digit /= 10;\n    }\n}\n\n\n\nvoid solve(int puzzle, int numOfMove=0) {\n    \n    Q.push(make_pair(puzzle, numOfMove));\n    \n    while( !Q.empty() ) {\n        \n        puzzle = Q.front().first;\n        numOfMove = Q.front().second;\n        Q.pop();\n        \n        if( find(puzzle) ) continue; //??¢??\\?????¶?????§????????°????????????\n        \n        insert(puzzle);\n\n        \n//        dout << \"-----------------\\n\";\n//        disp(++numOfSearch);\n//        disp(numOfMove);\n//        display(puzzle);\n        \n        if(puzzle == GOAL) {\n            dout << numOfMove << endl;\n            return;\n        }\n        \n        int p[9];\n        puzzle_int2array(puzzle,p);\n        \n        \n        //find 0\n        int zero=NONE;\n        rep(i,0,9) {\n            if( p[i] == 0 ) {\n                zero = i;\n                break;\n            }\n        }\n        assert(zero!=NONE); //0 must be found\n        \n        \n        //move 0 to 4 direction\n        numOfMove++;\n        \n        int alt;\n        \n        alt = zero - 3;\n        if(0<=alt && alt<=8) {\n//            disp(-3);\n            swap(p[zero], p[alt]);\n            \n            puzzle = puzzle_array2int(p);\n            if( find(puzzle)==0 ) { //???????????????\n                Q.push(make_pair(puzzle, numOfMove));\n//                dout << \"push to Q\\n\";\n            }\n            else {\n//                dout << \"already found\\n\";\n            }\n            swap(p[zero], p[alt]);\n        }\n        \n        alt = zero - 1;\n        if(0<=alt && alt<=8 && zero%3!=0) { //0??????????????´?????????????????????\n//            disp(-1);\n            swap(p[zero], p[alt]);\n            \n            puzzle = puzzle_array2int(p);\n            if( find(puzzle)==0 ) { //???????????????\n                Q.push(make_pair(puzzle, numOfMove));\n//                dout << \"push to Q\\n\";\n            }\n            else {\n//                dout << \"already found\\n\";\n            }\n            swap(p[zero], p[alt]);\n        }\n        \n        \n        alt = zero + 1;\n        if(0<=alt && alt<=8 && zero%3!=2) { //0??????????????´?????????????????????\n//            disp(1);\n            swap(p[zero], p[alt]);\n            \n            puzzle = puzzle_array2int(p);\n            if( find(puzzle)==0 ) { //???????????????\n                Q.push(make_pair(puzzle, numOfMove));\n//                dout << \"push to Q\\n\";\n            }\n            else {\n//                dout << \"already found\\n\";\n            }\n            swap(p[zero], p[alt]);\n        }\n        \n        alt = zero + 3;\n        if(0<=alt && alt<=8 ) {\n//            disp(3);\n            swap(p[zero], p[alt]);\n            \n            puzzle = puzzle_array2int(p);\n            if( find(puzzle)==0 ) { //???????????????\n                Q.push(make_pair(puzzle, numOfMove));\n//                dout << \"push to Q\\n\";\n            }\n            else {\n//                dout << \"already found\\n\";\n            }\n            swap(p[zero], p[alt]);\n        }\n        \n    } //end of while-loop\n    \n}\n\n\n\n\nint main() {\n    \n    //initialize\n    rep(i,0,N_MAX+1) {\n        T[i].n = INF;\n        T[i].l = T[i].r = NONE;\n    }\n    \n    int puzzle = 0;\n    int digit = 1e8;\n\n    int p;\n    rep(i,0,9) {\n            din >> p;\n            puzzle += digit * p;\n            digit /= 10;\n    }\n    \n    \n//    display(puzzle);\n    \n    solve(puzzle, 0);\n\n    \n\n    \n    \n    \n    \n#ifdef INPUTFILE\n    inputfile.close();\n#endif\n    \n#ifdef OUTPUTFILE\n    outputfile.close();\n    cout << \"\\\"\" << OutputFilePath << \"\\\"\" << endl;\n#endif\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <stdlib.h>\n#include <limits.h>\n#include <unordered_map>\n#include <string>\n#include <map>\n#include <sstream>\n#include <cstdlib> \nusing namespace std;\n\n#define INF     INT_MAX\n#define SIZE  9\n#define WIDTH 3\n\n#define LEFT  0\n#define RIGHT 1\n#define UP    2\n#define DOWN  3\n\ntypedef struct{\n  int            dist;        // accumulated distance fromt start board \n  int            evaluation;\n  bool           visited;     // default: false\n} v_t;\n\nmap< string, v_t >  Node; // Key: cell hash, Value: node\nvoid assert(vector<int> v);\n\nbool Move[SIZE][4];\nvoid initMove(){\n  // Can Move Right?\n  Move[0][RIGHT]=Move[1][RIGHT]=Move[3][RIGHT]=Move[4][RIGHT]=Move[6][RIGHT]=Move[7][RIGHT]=true;\n  Move[2][RIGHT]=Move[5][RIGHT]=Move[8][RIGHT]=false;\n  // Can Move Left?\n  Move[1][LEFT]=Move[2][LEFT]=Move[4][LEFT]=Move[5][LEFT]=Move[7][LEFT]=Move[8][LEFT]=true;\n  Move[0][LEFT]=Move[3][LEFT]=Move[6][LEFT]=false;\n  // Can Move Up?\n  Move[3][UP]=Move[4][UP]=Move[5][UP]=Move[6][UP]=Move[7][UP]=Move[8][UP]=true;\n  Move[0][UP]=Move[1][UP]=Move[2][UP]=false;\n  // Can Move Down?\n  Move[0][DOWN]=Move[1][DOWN]=Move[2][DOWN]=Move[3][DOWN]=Move[4][DOWN]=Move[5][DOWN]=true;\n  Move[6][DOWN]=Move[7][DOWN]=Move[8][DOWN]=false;\n}\n\nmultimap< int, string > Q;   // Key: dist + evaluation , Value: cell hash\nstring hashkey(vector<int> cell){\n  string hash;\n  for(const auto& e: cell){\n    hash += to_string(e) + \",\";\n  }\n  return hash;\n}\n\nvector<string> split(const string &str, char sep)\n{\n  vector<string> v;\n  stringstream ss(str);\n  string buffer;\n  while( getline(ss, buffer, sep) ) {\n      v.push_back(buffer);\n  }\n  return v;\n}\nvector<int> dehash(string hash){\n  vector<int> cell;\n  vector<string> board = split(hash, ',');\n  for(const auto& e : board){\n    cell.push_back(stoi(e));\n  }\n  return cell;\n}\n\nint estimateH(vector<int> cell){\n  int hr = 0; // heuristic\n  for(int i = 0 ; i < SIZE ; i++){\n    if(cell[i] == 0){\n      cell[i] = SIZE;\n    }\n    hr += abs( (cell[i]-1)%WIDTH - i%WIDTH );\n    hr += abs( (cell[i]-1)/WIDTH - i/WIDTH );\n  }\n\treturn hr;\n}\n\nvector<int> updateGQ(vector<int> curCell,int space, int dir){\n  const string curHash = hashkey(curCell);\n  vector<int> nextCell(curCell);\n  int moveto = space + dir; // move to = space(0) + direction\n  nextCell[space] = nextCell[moveto];\n  nextCell[moveto] = 0;\n  const string nextHash = hashkey(nextCell); \n  if( !Node[nextHash].visited ){\n    Node[nextHash].visited = true;\n  \tNode[nextHash].dist = Node[curHash].dist + 1;\n   \tNode[nextHash].evaluation = estimateH(nextCell);\n    int dist_ev = 1 + Node[curHash].dist + Node[curHash].evaluation;\n\t\tQ.insert(make_pair(dist_ev, nextHash));\n  }\n  return nextCell;\n}\n\nvoid move(vector<int> curCell){\n  for(int i = 0 ; i < SIZE ; i++ ){\n    vector<int> resultCell;\n    if(curCell[i] == 0){\n      if(Move[i][LEFT]){\n        resultCell = updateGQ(curCell, i, -1); \n      }\n      if(Move[i][RIGHT]){\n        resultCell = updateGQ(curCell, i, 1 ); \n      }\n      if(Move[i][UP]){\n        resultCell = updateGQ(curCell, i, -3); \n      }\n      if(Move[i][DOWN]){\n        resultCell = updateGQ(curCell, i, 3); \n      }\n    }\n  }\n  return;\n}\n\nvoid assert(vector<int> v){ // for debug\n  int i = 0;\n\tfor(auto itr = v.begin() ; itr != v.end(); ++itr){\n    fprintf(stderr, \"%d \"  ,*itr);\n    i++;\n    if(i==3){\n      i = 0;\n      fprintf(stderr, \"\\n\");\n    }\n  }\n}\n\nint main(){ // Dijkstra P.254\n  vector<int> cell(SIZE); // current cell\n  const vector<int> goalCell = {1,2,3,4,5,6,7,8,0};\n  const string goalHash = hashkey(goalCell);\n  initMove();\n \n  //  insert First node\n  for(int i = 0 ; i < SIZE ; i++){\n    int num;\n    scanf(\"%d\" ,&num);\n    cell[i] = num;\n  }\n  v_t firstNode = {0, 0, true};\n  Node[hashkey(cell)] = firstNode;\n\tQ.insert( make_pair(0, hashkey(cell)) );\n  move(cell);\n  auto itr = Q.begin();\n  Q.erase(itr);\n\n  while(!Q.empty()){\n    if( Node[goalHash].visited ){\n      break;\n    }\n    auto itr = Q.begin();\n    string curHash = itr->second;\n    Q.erase(itr);\n    cell = dehash(curHash);\n    move(cell);\n  }\n\n  printf(\"%d\\n\" ,Node[goalHash].dist );\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n#define X 3\n#define Y 3\n#define THRESHOLD 2\n\nnamespace std{\n\ttemplate<typename T>\n\tinline void hash_combine(size_t& seed, T const& v){\n\t\tseed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n\t}\n    template<typename It>\n    inline size_t hash_range(It first, It last){\n\t\tsize_t seed=0;\n\t\thash_range(seed,first,last);\n\t\treturn seed;\n\t}\n\ttemplate<typename It>\n\tinline void hash_range(size_t& seed, It first, It last){\n\t\tfor(;first!=last;++first)hash_combine(seed, *first);\n\t}\n\ttemplate<typename A,typename B>\n\tclass hash<pair<A,B>>{\n\t\tpublic:\n\t\tsize_t operator()(pair<A,B> const &p) const{\n\t\t\tsize_t seed=0;\n\t\t\thash_combine(seed,p.first);\n\t\t\thash_combine(seed,p.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\ttemplate<typename T,size_t N>\n\tclass hash<array<T,N>>{\n\t\tpublic:\n\t\tsize_t operator()(array<T,N> const &container) const{\n\t\t\treturn hash_range(container.begin(),container.end());\n\t\t}\n\t};\n\ttemplate<typename T,typename A>\n\tclass hash<vector<T,A>>{\n\t\tpublic:\n\t\tsize_t operator()(vector<T,A> const &container) const{\n\t\t\treturn hash_range(container.begin(),container.end());\n\t\t}\n\t};\n}\n\nint manhattan(int x1,int y1,int x2,int y2){\n\treturn abs(x1-x2)+abs(y1-y2);\n}\nint calc(vector<int>&v){\n\tint s=0;\n\tfor(int coor=0;coor<X*Y;coor++){\n\t\tif(v[coor]!=0){\n\t\t\ts+=manhattan(coor%X,coor/X,(v[coor]-1)%X,(v[coor]-1)/X);\n\t\t}else{\n\t\t\ts+=manhattan(coor%X,coor/X,X-1,Y-1);\n\t\t}\n\t}\n\treturn s;\n}\nint main(){\n\tint i=1,start_point;\n\tvector<int>start(X*Y),goal;\n\tfor(;i<X*Y;i++)goal.push_back(i);goal.push_back(0);\n\tfor(i=0;i<X*Y;i++){\n\t\tscanf(\"%d\",&start[i]);\n\t\tif(start[i]==0)start_point=i;\n\t}\n\tif(start==goal){puts(\"0\");return 0;}\n\n\tunordered_map<vector<int>,pair<int,int> >mstart,mgoal;\n\tqueue<pair<vector<int>,bool> >q;\n\tmstart[start]=make_pair(start_point,0);\n\tmgoal[goal]=make_pair(X*Y-1,0);\n\tq.push(make_pair(start,false));\n\tq.push(make_pair(goal,true));\n\tfor(;!q.empty();){\n\t\tvector<int> v=q.front().first;\n\t\tbool f=q.front().second;\n\t\tq.pop();\n\t\tint val=calc(v);\n\t\tunordered_map<vector<int>,pair<int,int> >&m=f?mgoal:mstart;\n\t\tunordered_map<vector<int>,pair<int,int> >&m2=f?mstart:mgoal;\n\t\tint coor=m[v].first,x=coor%X,y=coor/X;\n\t\tint depth=m[v].second;\n\t\tif(0<x){\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor-1,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t}\n\t\tif(x<X-1){\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor+1,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t}\n\t\tif(0<y){\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor-X,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t}\n\t\tif(y<Y-1){\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor+X,depth+1),q.push(make_pair(v,f));\n\t\t\tif(m2.find(v)!=m2.end()){printf(\"%d\\n\",m2[v].second+depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX 3\n#define MAX2 9\n\nusing namespace std;\n\nstruct Puzzle{\n  int f[MAX2];\n  int space;\n  string path;\n\n  bool operator < (Puzzle &p){\n  int i;\n    for(i = 0; i < MAX2; i++){\n      if( f[i] == p.f[i] ){\n        continue;\n      }\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstring bfs(Puzzle);\nbool isTarget(Puzzle);\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\nchar dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  int i;\n  for(i = 0; i < MAX2; i++){\n    if( p.f[i] != (i+1) ){\n      return false;\n    }\n  }\n  return true;\n}//end of isTarget func\n\nint main(){\n  Puzzle in;\n  int i;\n  for(i = 0; i < MAX2; i++){\n    cin >> in.f[i];\n    if( in.f[i] == 0 ){\n      in.f[i] == MAX2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n  return 0;\n}//end of main func\n\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n  \n  int r,tx,ty;\n  int sx,sy;\n  int tmp;\n\n  while( !Q.empty() ){\n    u = Q.front();\n    Q.pop();\n    if( isTarget(u) ){\n      return u.path;\n    }\n    sx = u.space / MAX;\n    sy = u.space % MAX;\n    for(r = 0; r < 4; r++){\n      tx = sx + dx[r];\n      ty = sy + dy[r];\n      if( tx < 0 || ty < 0 || tx >= MAX || ty >= MAX){\n        continue;\n      }\n      v = u;\n      /*swap*/\n      tmp = v.f[u.space];\n      v.f[u.space] = v.f[tx * MAX + ty];\n      v.f[tx * MAX + ty] = tmp;\n\n      v.space = tx * MAX + ty;\n      if( !V[v] ){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n#include <stdio.h>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator < (const Puzzle &p) const {\n\t\tfor(int i=0;i<N2;i++){\n\t\t\tif(f[i] == p.f[i]) continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n\tfor(int i=0;i<N2;i++){\n\t\tif(p.f[i] != (i+1)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n\nstring bfs(Puzzle s){\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u,v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\n\twhile(!Q.empty()){\n\t\tu = Q.front(); Q.pop();\n\t\tif(isTarget(u)) return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif(tx<0 || ty<0 || tx >=N || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space],v.f[tx*N+ty]);\n\t\t\tv.space = tx * N +ty;\n\t\t\tif(!V[v]){\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn \"unsolvable\";\n}\n\n\t\t\n\nint main(void){\n\t\n\tint i;\n\tPuzzle in;\n\tstring ans;\n\n\tfor(i=0;i<N2;i++){\n\t\tscanf(\"%d\",&in.f[i]);\n\t\tif(in.f[i] == 0){\n\t\t\tin.f[i] = N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\n\tans = bfs(in);\n\tprintf(\"%lu\\n\",ans.size());\n\n\treturn 0;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<array>\n\nint search(int);\nint translate(std::array<int, 9>);\n\nstruct BoardStatus {\n\tstd::array<int, 9> arrange = {};\n\tint distance = 0;\n\tint zero_position = 8;\n};\n\nint main()\n{\n\tstd::array<int, 9> board;\n\tfor (int i = 0; i < 9; ++i)\n\t\tstd::cin >> board[i];\n\n\tstd::cout << search(translate(board)) << std::endl;\n\n\treturn 0;\n}\n\nint search(int dest_num)\n{\n    if (dest_num == 46233) return 0;\n    \n\tBoardStatus board;\n\tboard.arrange = { 1, 2, 3, 4, 5, 6, 7, 8, 0};\n\tboard.distance = 0;\n\tboard.zero_position = 8;\n\t\n\tstd::vector<BoardStatus> queue;\n\tqueue.push_back(board);\n\tint pre_size = 0;\n\tint table[362880] = { };\n\n\tint move_direction[4] = { 1, -1, 3, -3 };\n\n\twhile (pre_size != queue.size())\n\t{\n\t\tint now_size = queue.size();\n\t\tfor (int queue_i = pre_size; queue_i < now_size; ++queue_i)\n\t\t{\n\t\t\tint zero_pos = queue[queue_i].zero_position;\n\t\t\tbool can_move[4] = {\n\t\t\t\tzero_pos % 3 != 2, zero_pos % 3 != 0,\n\t\t\t\tzero_pos / 3 != 2, zero_pos / 3 != 0\n\t\t\t};\n\t\t\tfor (int condi_i = 0; condi_i < 4; ++condi_i)\n\t\t\t{\n\t\t\t\tif (!can_move[condi_i]) continue;\n\n\t\t\t\tboard = queue[queue_i];\n\t\t\t\tint next_zero = zero_pos + move_direction[condi_i];\n\n\t\t\t\tboard.arrange[board.zero_position] = board.arrange[next_zero];\n\t\t\t\tboard.arrange[next_zero] = 0;\n\t\t\t\tboard.zero_position = next_zero;\n\t\t\t\tboard.distance++;\n\n\t\t\t\tint num_board = translate(board.arrange);\n\t\t\t\tif (!table[num_board] && num_board != 46233)\n\t\t\t\t{\n\t\t\t\t\ttable[num_board] = board.distance;\n\t\t\t\t\tqueue.push_back(board);\n\t\t\t\t}\n\t\t\t\tif (num_board == dest_num)\n\t\t\t\t\treturn board.distance;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint translate(std::array<int , 9> board)\n{\n\tbool used[9]{};\n\tint count = 0, tmp, ret = 0, fac = 362880;\n\tfor (int i = 0; i < 9; ++i)\n\t{\n\t\tcount = 0;\n\t\ttmp = board[i];\n\t\tfor (int j = 0; j < tmp; ++j)\n\t\t\tif (!used[j])\n\t\t\t\tcount++;\n\t\tused[tmp] = true;\n\t\tfac /= 9 - i;\n\t\tret += fac * count;\n\t}\n\treturn ret;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator<(const Puzzle& p) const {\n\t\tfor (int i = 0; i < N2; i++) {\n\t\t\tif (f[i] == p.f[i]) continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\nstatic const int dx[4] = { -1,0,1,0 };\nstatic const int dy[4] = { 0,-1,0,1 };\nstatic char dir[4] = { 'u','l','d','r' };\nbool isTarget(Puzzle p) {\n\tfor (int i = 0; i < N2; i++) {\n\t\tif (p.f[i] != (i + 1)) return false;\n\t}\n\treturn true;\n}\nstring bfs(Puzzle s) {\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isTarget(u)) return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; r++) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\nint main() {\n\tPuzzle in;\n\n\tfor (int i = 0; i < N2; i++) {\n\t\tcin >> in.f[i];\n\t\tif (in.f[i] == 0) {\n\t\t\tin.f[i] = N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n#define N 3\ntypedef pair<int, int> P;\n\nstruct State {\n    int g, h;\n    string state;\n    P blank;\n    string path;\n    bool operator<(const State &a) const {\n        return g + h > a.g + a.h;\n    }\n};\n\nint d[5] = {-1, 0, 1, 0, -1};\nstring r[4] = {\"D\", \"R\", \"U\", \"L\"};\nstring ans_str = \"\";\nint ans[N][N], puzzle0[N][N], puzzle1[N][N];\nset<string> s;\npriority_queue<State> next_state;\nstring path;\n\nbool range(int y, int x) {return 0 <= y && y < N && 0 <= x && x < N;}\n\nint h2_dfs(int boundary, State state, int from) {\n    int find = -1;\n    s.insert(state.state); // visited\n\n    P blank = state.blank;\n    rep(i, 4) {\n        if (from == (i + 2) % 4) continue;\n        int y = d[i] + blank.first, x = d[i + 1] + blank.second; // next blank position\n        if (range(y, x)) { // can be replaced\n            string tmp = state.state; // next state (string)\n            int p = blank.first * N + blank.second, q = y * N + x;\n            if (N < 4) swap(tmp[p], tmp[q]);\n            else swap(tmp[2 * p], tmp[2 * q]), swap(tmp[2 * p + 1], tmp[2 * q + 1]);\n\n            int num;\n            if (N < 4) num = state.state[q] - '1';\n            else num = stoi(state.state.substr(2 * q, 2)) - 1;\n            // calcurate manhattan distance\n            int manhattan = state.h - ((abs(num / N - y) + abs(num % N - x)))\n            + (abs(num / N - blank.first) + abs(num % N - blank.second));\n\n            if (manhattan == 0) { // answer\n                find = state.g + 1;\n                path = state.path + r[i];\n                break;\n            }\n\n            if (state.g + 1 + manhattan > boundary) continue; // estimate value is over boundary\n            find = h2_dfs(boundary, State{state.g + 1, manhattan, tmp, P(y, x), state.path + r[i]}, i);\n            if (find != -1) break;\n        }\n    }\n    return find;\n}\n\nint ids_h2(string state, int manhattan, P blank) {\n    int i = manhattan, find = -1;\n    while(find == -1 && i < 81) {\n        s.clear();\n        find = h2_dfs(i, State{0, manhattan, state, blank, \"\"}, -1);\n        i++;\n    }\n    return find;\n}\n\nint main(){\n    // create answer's numbers\n    iota(ans[0], ans[0] + N * N, 1);\n    ans[N - 1][N - 1] = 0;\n    // create number\n    iota(puzzle0[0], puzzle0[0] + N * N, 0);\n    rep(i, N)rep(j, N) cin >> puzzle0[i][j];\n\n    string state = \"\";\n    P blank;\n    int manhattan = 0, wrong_place = 0;\n    rep(i, N)rep(j, N) {\n        state += to_string(puzzle0[i][j]);\n        ans_str += to_string(ans[i][j]);\n\n        if(puzzle0[i][j] == 0) blank = P(i, j);\n        else {\n            int num = puzzle0[i][j] - 1;\n            manhattan += (abs(num / N - i) + abs(num % N - j));\n            if (puzzle0[i][j] != ans[i][j]) wrong_place++;\n        }\n    }\n\n    if (manhattan == 0) { // the answer\n        cout << 0 << endl;\n    } else {\n        int steps;\n        next_state.push(State{0, wrong_place, state, blank, \"\"});\n        steps = ids_h2(state, manhattan, blank);\n        cout << steps << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\nvector<int> searched[9];\n\nclass board{\npublic:\n    int moves;\n    int wrongs;\n    int zero_place;\n    int cost;\n    vector<int> tiles;\n\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        tiles = num;\n        REP(i, 9){\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n        cost = wrongs + moves;\n    }\n\n    void board_to_int(){\n        int k = 0;\n        REP(i, 9)\n            k += (tiles[i] * pow(10, i));\n        for(int i = searched[tiles[0]].size(); i > 0 ; i--)\n            if(k == searched[tiles[0]][i-1])\n                return;\n        pq.push(board(tiles, moves+1));\n        searched[tiles[0]].push_back(k);\n        return;\n    }\n\n    void move() {\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n};\n\nbool operator< (board b1, board b2){\n    return ((b1.cost > b2.cost) ? true : false);\n}\n\nint solve(){\n    pq.push(board(original, 0));\n    while(1){\n        auto target = pq.top();\n        pq.pop();\n        if(target.wrongs == 0)\n            return target.cost;\n        target.move();\n    }\n}\n\nint main() {\n    REP(i, 9) scanf(\"%d\", &original[i]);\n    int move = solve();\n    printf(\"%d\\n\", move);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <vector>\n \nusing namespace std;\n \n#define RY 3\n#define N 9\n \ntypedef struct board {\n  int hira[N];\n  int maru;\n  vector<int> path;\n \n  bool operator < (const board &t) const {\n    for (int i = 0; i < N; i++) {\n      if (hira[i] == t.hira[i]) continue;\n      else if (hira[i] < t.hira[i]) return true;\n      else return false;\n    }\n    return false;\n  }\n} cubic;\n\nint xx[4] = { 0, 1, 0, -1 };\nint yy[4] = { 1, 0, -1, 0 };\n \nbool fingoal(cubic b) {\n  for (int i = 0; i < N-1; i ++)\n    if (b.hira[i] != i+1) return false;\n \n  return true;\n}\n \nvoid meltd(cubic b) {\n  map<cubic, bool> visited;\n  queue<cubic> q;\n  q.push(b);\n \n  while (!q.empty()) {\n    cubic bcur = q.front(); q.pop();\n    visited[bcur] = true;\n \n    if (fingoal(bcur)) {\n      cout << bcur.path.size() << endl;\n      return;\n    }\n \n    for (int i = 0; i < 4; i ++) {\n      cubic b = bcur;\n      int nx = (bcur.maru / RY) + xx[i];\n      int ny = (bcur.maru % RY) + yy[i];\n \n      if (nx < 0 || nx > 2 || ny < 0 || ny > 2) continue;\n \n      b.maru = nx * RY + ny;\n      swap(b.hira[b.maru], b.hira[bcur.maru]);\n \n      if (visited[b]) continue;\n \n      b.path.push_back(b.maru);\n      q.push(b);\n    }\n  }\n}\n \nint main() {\n  cubic b;\n \n  for (int i = 0; i < N; i++) {\n    cin >> b.hira[i];\n    if (b.hira[i] == 0) b.maru = i;\n  }\n \n  meltd(b);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nnamespace eight_puzzle{\n\ttypedef unsigned int uint;\n\tconst int N = 3;\n\tstruct State{\n\t\tState(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t}\n\t\tState(const uint tt,const uint tn){\n\t\t\ttable = tt;\n\t\t\tn = tn;\n\t\t}\n\n\t\tState& operator=(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t\treturn (*this);\n\t\t}\n\t\tbool isfinished(){\n\t\t\t\treturn table == 123456780;\n\t\t}\n\t\t\n\t\tuint table;\n\t\tuint n;\n\t};\n\tuint arraytovalue(int *table){\n\t\tuint t=0;\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tt*=10;\n\t\t\tt=t+table[i];\n\t\t}\n\t\treturn t;\n\t}\n\tvoid getnextstate(const State &s,std::vector<State> &states){\n\t\tint table[N*N];\n\t\tint t = s.table;\n\t\tint zi,zj;\n\t\tfor(int i=N-1;i>=0;--i){\n\t\t\tfor(int j=N-1;j>=0;--j){\n\t\t\t\tint panel = t-t/10*10;\n\t\t\t\ttable[i*N+j] = panel;\n\t\t\t\tt/=10;\n\t\t\t\tif(panel==0){\n\t\t\t\t\tzi = i;\n\t\t\t\t\tzj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=-1;i<=1;++i){\n\t\t\tfor(int j=-1;j<=1;++j){\n\t\t\t\tif((i+j)%2==0)continue;\n\t\t\t\tint ti = zi+i,tj=zj+j;\n\t\t\t\tif(0<=ti&&ti<N&&0<=tj&&tj<N){\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t\tstates.push_back(State(arraytovalue(table),s.n+1));\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tstd::vector<uint> visited;\n\t\n};\n\nint main(){\n\tusing namespace eight_puzzle;\n\tint array[N*N];\n\tfor(int i=0;i<N*N;++i){\n\t\tstd::cin>>array[i];\n\t}\n\tState init(arraytovalue(array),0);\n\n\tstd::queue<State> Q;\n\tQ.push(init);\n\twhile(!Q.empty()){\n\t\tState s = Q.front();\n\t\tQ.pop();\n\t\tstd::vector<State> states;\n\t\tgetnextstate(s,states);\n\t\tfor(uint i=0;i<states.size();++i){\n\t\t\tif(states[i].isfinished()){\n\t\t\t\tstd::cout<<states[i].n<<std::endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(std::find(visited.begin(),visited.end(),states[i].table)==visited.end()){\n\t\t\t\tQ.push(states[i]);\n\t\t\t\tvisited.push_back(states[i].table);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <string>\n#include <cassert>\nusing namespace std;\nconst int num = 9, ud[] = { -1, 0, 1, 0 }, lr[] = { 0, -1, 0, 1 }, nd = 3;\nconst char wa[] = { 'u', 'l', 'd', 'r' };\nstruct puzzle {\n\tint sp, p[num];\n\tstring way;\n\tbool operator < (const puzzle &pu) const {\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tif (p[i] == pu.p[i]) continue;\n\t\t\treturn p[i] < pu.p[i];\n\t\t}\n\t\treturn false;\n\t}\n};\ninline bool fin(puzzle pu) {\n\tfor (int i = 0; i < num; i++)\n\t\tif (pu.p[i] != i + 1) return false;\n\treturn true;\n}\ninline string bfs(puzzle pu) {\n\tqueue<puzzle> q;\n\tmap <puzzle, bool> m;\n\tq.push(pu);\n\tm[pu] = true;\n\tpuzzle x, y;\n\tint row, col, ns, ro, co;\n\twhile (!q.empty()) {\n\t\tx = q.front(); q.pop();\n\t\tif (fin(x)) return x.way;\n\t\tro = x.sp / nd;\n\t\tco = x.sp % nd;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\trow = ro + ud[i];\n\t\t\tcol = co + lr[i];\n\t\t\tif (row >= nd || row < 0 || col >= nd || col < 0) continue;\n\t\t\ty = x;\n\t\t\tns = row*nd + col;\n\t\t\tswap(y.p[x.sp], y.p[ns]);\n\t\t\ty.sp = ns;\n\t\t\tif (!m[y]) {\n\t\t\t\tm[y] = true;\n\t\t\t\ty.way += wa[i];\n\t\t\t\tq.push(y);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tpuzzle fi;\n\tfor (int i = 0; i < num; i++) {\n\t\tcin >> fi.p[i];\n\t\tif (!fi.p[i]) { \n\t\t\tfi.sp = i; \n\t\t\tfi.p[i] = num;\n\t\t}\n\t}\n\tcout << bfs(fi).size() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n \nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<VVI> VVVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\ntypedef long long LL;\ntypedef priority_queue<int> PQ_DESC;\ntypedef priority_queue<int, vector<int>, greater<int>> PQ_ASC;\ntypedef priority_queue<PII> PQ_DESC_PII;\ntypedef priority_queue<PII, vector<PII>, greater<PII>> PQ_ASC_PII;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVLL> VVVLL;\n\n#define SORT_ASC(c) sort((c).begin(), (c).end())\n#define SORT_DESC(c) sort((c).begin(), (c).end(), greater<typeof((c).begin())>())\n \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define FORL(i,a,b) for(LL i=(a);i<(b);++i)\n#define REPL(i,n)  FORL(i,0,n)\n#define ALL(a) (a).begin(),(a).end()\n \nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n //debug func\ntemplate<typename T>\nvoid vprint(vector<T> v) {\n    for(auto x : v) {\n        cerr << x << \" \";\n    }\n    cerr << endl;\n}\n \ntemplate<typename T>\nvoid vvprint(vector<vector<T>> vv) {\n    REP(i, vv.size()) {\n        REP(j, vv[i].size()) {\n            cerr << vv[i][j] << \" \";\n        }\n        cerr << endl;\n    }\n}\n\ntemplate <typename Iterator>\ninline bool next_combination(const Iterator first, Iterator k, const Iterator last)\n{\n   /* Credits: Thomas Draper */\n   if ((first == last) || (first == k) || (last == k))\n      return false;\n   Iterator itr1 = first;\n   Iterator itr2 = last;\n   ++itr1;\n   if (last == itr1)\n      return false;\n   itr1 = last;\n   --itr1;\n   itr1 = k;\n   --itr2;\n   while (first != itr1)\n   {\n      if (*--itr1 < *itr2)\n      {\n         Iterator j = k;\n         while (!(*itr1 < *j)) ++j;\n         iter_swap(itr1,j);\n         ++itr1;\n         ++j;\n         itr2 = k;\n         rotate(itr1,j,last);\n         while (last != j)\n         {\n            ++j;\n            ++itr2;\n         }\n         rotate(k,itr2,last);\n         return true;\n      }\n   }\n   rotate(first,k,last);\n   return false;\n}\n\ninline double get_time_sec(void){\n    return static_cast<double>(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count())/1000000000;\n}\n\ntemplate<typename T>\nT lcm(T a, T b) {\n    return (a / __gcd(a, b)) * b;\n}\n\ntemplate<typename T>\nmap<T, T> prime_list(T n) {\n    map<T, T> ret;\n    for(T i = 2; i*i <= n; i++) {\n        if(n % i == 0) {\n            ret[i] = 0;\n            while(n % i == 0) {\n                n /= i;\n                ret[i]++;\n            }\n        }\n    }\n    if(n != 1) ret[n]++;\n    return ret;\n}\n\n#define MOD 1000000007\n\nLL mypow(LL a, LL n) {\n    if(n == 0) return 1;\n    if(n == 1) return a % MOD;\n    if(n % 2 == 1) return (a * mypow(a, n-1)) % MOD;\n    LL t = mypow(a, n/2);\n    return (t * t) % MOD; \n}\n\nLL mycomb(LL n, LL k) {\n    if(n == 0 || n == k) return 1;\n    LL x = 1, y = 1;\n    REP(i, k) {\n        x = x * (n-i) % MOD;\n        y = y * (i+1) % MOD;\n    }\n    return x * mypow(y, MOD - 2) % MOD;\n}\n\n#define INF 1e8\n\nstruct edge {int u, v, cost;};\n\nvector<edge> g;\nVI par, rnk;\n\nint root(int x) {\n    if(par[x] == x) return x;\n    else return par[x] = root(par[x]);\n}\n\nint same(int x, int y) {\n    x = root(x);\n    y = root(y);\n    return x == y;\n}\n\nvoid unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if(rnk[x] > rnk[y]) {\n        par[y] = x;\n    } else {\n        par[x] = y;\n        if(rnk[x] == rnk[y]) rnk[y]++;\n    }\n}\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    VVI b(3, VI(3));\n    REP(i, 3) REP(j, 3) cin >> b[i][j];\n    VVI c = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};\n    if(b == c) {cout << 0 << endl; return 0;}\n    map<VVI, int> mb;\n    queue<VVI> q;\n    q.push(b);\n    while(!q.empty()) {\n        auto p = q.front();\n        q.pop();\n        int i, j;\n        REP(_i, 3) REP(_j, 3) if(p[_i][_j] == 0) {\n            i = _i;\n            j = _j;\n        }\n        if(i > 0) {\n            VVI c(p);\n            swap(c[i-1][j], c[i][j]);\n            if(!mb[c]) {\n                mb[c] = mb[p] + 1;\n                q.push(c);\n            } \n        }\n        if(i < 2) {\n            VVI c(p);\n            swap(c[i][j], c[i+1][j]);\n            if(!mb[c]) {\n                mb[c] = mb[p] + 1;\n                q.push(c);\n            } \n        }\n        if(j > 0) {\n            VVI c(p);\n            swap(c[i][j-1], c[i][j]);\n            if(!mb[c]) {\n                mb[c] = mb[p] + 1;\n                q.push(c);\n            } \n        }\n        if(j < 2) {\n            VVI c(p);\n            swap(c[i][j], c[i][j+1]);\n            if(!mb[c]) {\n                mb[c] = mb[p] + 1;\n                q.push(c);\n            } \n        }\n        if(mb[{{1, 2, 3}, {4, 5, 6}, {7, 8, 0}}]) {\n            cout << mb[{{1, 2, 3}, {4, 5, 6}, {7, 8, 0}}] << endl;\n            return 0;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <list>\n#include <string>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL =     1      | 2 << (1*4)  | 3 << (2*4)\n                 | 4 << (3*4) | 5 << (4*4)  | 6 << (5*4)\n                 | 7 << (6*4) | 8LL << (7*4) | 0LL << (8*4);\n\nstruct state {\n    Board board;\n    int count;\n};\n\n//queue<state> q;\n//vector<state> q;\nlist<state> q;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n//    board |= static_cast<long long>(num) << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    for (list<state>::iterator it = q.begin(); it != q.end(); ++it) {\n        if (it->board == s.board) {\n            return -1;\n        }\n    }\n//    for (queue<state>::iterator it = q.begin(); it != q.end(); ++it) {\n//        if (it->board == s.board) {\n//            return -1;\n//        }\n//    }\n    ++s.count;\n    if (s.board == GOAL) {\n        return s.count;\n    }\n//    q.push(s);\n    q.push_back(s);\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\nint main(void) {\n\n    Board board = 0;\n    int i = 0;\n    while (i != N) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            board |= static_cast<long long>((ch - '0')) << (i*4);\n            ++i;\n        }\n    }\n\n//    print(GOAL);\n//    print(board);\n\n//    q.push({ board, 0 });\n    q.push_back({ board, 0 });\n    int count = 0;\n    while (!q.empty()) {\n        state s = q.front();\n//        q.pop();\n        q.pop_front();\n        // ?????????????????????\n        int pos;\n        for (int i = 0; i < N; ++i) {\n            if (((s.board >> (i*4)) & 15) == 0) {\n                pos = i;\n                break;\n            }\n        }\n\n        if (pos < 3) {\n            if (pos < 2) {\n                if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if (pos > 0) {\n                if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        else if (pos < 6) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n            if (pos < 5) {\n                if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if (pos > 3) {\n                if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        else {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n            if (pos < 8) {\n                if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if (pos > 6) {\n                if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <array>\n#include <set>\n#include <queue>\nusing namespace std;\n\n#define si static inline\n#define gcu getchar_unlocked\nsi int in() {\n\tint n = 0, c = gcu();\n\t// bool minus = false; if (c == '-') minus = true, c = gcu();\n\tdo {n = 10 * n + (c - '0'), c = gcu();} while (c >= '0');\n\treturn n; }\n\t// return minus ? -n : n; }\nsi void scan(char *s) {while (!isspace(*s++ = gcu()));}\n#define pcu putchar_unlocked\n#define svo si void out\ntemplate <typename T>\nsvo(T n) {\n\tstatic char buf[20];\n\tchar *p = buf;\n\t//if(n < 0) pcu('-'), n *= -1;\n\tif (!n) *p++ = '0';\n\telse while (n) *p++ = n % 10 + '0', n /= 10;\n\twhile (p != buf) pcu(*--p); }\nsvo(const char *s){while(*s)pcu(*s++);}\nsvo(char *s){while(*s)pcu(*s++);}\nsvo(char c){pcu(c);}\n//template <typename T>\n//svo(vector<T> &v){for(T &x:v)out(' '),out(x);out('\\n');}\n//svo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);out('\\n');}\ntemplate <typename head, typename... tail>\nsvo(head&& h, tail&&... t){out(h);out(move(t)...);}\n#undef svo\n#undef si\n\nstruct board {\n\tenum {size = 3};\n\tstruct pos {int r, c;};\n\ttypedef array<array<int, size>, size> arr;\n\tarr b;\n\tpos p;\n\tint cnt = 0;\n\n\tvoid read() {\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tb[i][j] = in();\n\t\t\t\tif (!b[i][j])\n\t\t\t\t\tp.r = i, p.c = j;\n\t\t\t}\n\t}\n\tvoid print() {\n\t\tfor (auto &r: b) {\n\t\t\tfor (int &c: r)\n\t\t\t\tout(&c == &r[0]?\"\":\" \", c);\n\t\t\tout('\\n');\n\t\t}\n\t\tout('\\n');\n\t}\n\n\tint solver() {\n\t\tconst arr end = {1, 2, 3, 4, 5, 6, 7, 8, 0};\n\t\tset<arr> m;\n\t\tqueue<board> q;\n\t\tq.push(*this);\n\t\twhile (!q.empty()) {\n\t\t\tboard a = q.front();\n\t\t\tq.pop();\n\t\t\tif (a.b == end)\n\t\t\t\treturn a.cnt;\n\t\t\tauto it = m.find(a.b);\n\t\t\tif (it != m.end())\n\t\t\t\tcontinue;\n\t\t\tm.insert(a.b);\n\t\t\tpos to[] = {\n\t\t\t\ta.p.r + 1, a.p.c,\n\t\t\t\ta.p.r, a.p.c + 1,\n\t\t\t\ta.p.r - 1, a.p.c,\n\t\t\t\ta.p.r, a.p.c - 1\n\t\t\t};\n\t\t\tfor (pos o: to) {\n\t\t\t\tif (0 <= o.r && o.r < size && 0 <= o.c && o.c < size) {\n\t\t\t\t\tboard c = a;\n\t\t\t\t\tswap(c.b[a.p.r][a.p.c], c.b[o.r][o.c]);\n\t\t\t\t\tc.p = o;\n\t\t\t\t\tc.cnt = a.cnt + 1;\n\t\t\t\t\tq.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\nint main() {\n\tboard b;\n\tb.read();\n\tout(b.solver(), '\\n');\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator<(const Puzzle &p)const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++)\n  if(p.f[i]!=(i+1))return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle>Q;\n  map<Puzzle,bool>V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front();Q.pop();\n    if(isTarget(u))return u.path;\n    int sx =u.space/N;\n    int sy =u.space%N;\n    for(int r=0;r<4;r++){\n      int tx =sx+dx[r];\n      int ty =sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N)continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n        V[v]=true;\n        v.path+=dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0;i<N2;i++){\n    cin >> in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans =bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle\n{\n    int f[N2];\n    int space;\n    string path;\n    int i;\n\n    bool operator < (const Puzzle &p) const\n    {\n        int i;\n        for(i=0;i<N2;i++)\n        {\n            if(f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p)\n{\n    int i;\n\n    for(i=0;i<N2;i++)\n    {\n       if(p.f[i] != (i+1)) return false;\n    }\n       return true; \n}\n\nstring bfs(Puzzle s)\n{\n    queue<Puzzle> Q;\n    map<Puzzle,bool> V;\n    Puzzle u,v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while(!Q.empty())\n    {\n        u = Q.front();Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for(int r=0;r<4;r++)\n        {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space],v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if(!V[v])\n            {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n\n    return \"unsolvable\";\n\n}\n\nint main()\n{\n    Puzzle in;\n\n    for(int i=0;i<N2;i++)\n    {\n        cin >> in.f[i];\n        if(in.f[i] == 0)\n        {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n  bool operator < (const Puzzle &p) const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i]) continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++)\n    if(p.f[i] != (i+1)) return false;\n  return true;\n}\nstring bfs(Puzzle s){\n  queue<Puzzle>Q;\n  map<Puzzle,bool>V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n  while(!Q.empty() ){\n    u=Q.front();Q.pop();\n    if(isTarget(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N) continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n\tv.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\nint main(){\n  Puzzle in;\n  for(int i=0;i<N2;i++){\n    cin >> in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout << ans.size() << endl;\n  return 0;\n}\n\t \t\t  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <array>\n#include <unordered_set>\n#include <queue>\nusing namespace std;\n\n#define si static inline\n#define gcu getchar_unlocked\nsi int in() {\n\tint n = 0, c = gcu();\n\t// bool minus = false; if (c == '-') minus = true, c = gcu();\n\tdo {n = 10 * n + (c - '0'), c = gcu();} while (c >= '0');\n\treturn n; }\n\t// return minus ? -n : n; }\nsi void scan(char *s) {while (!isspace(*s++ = gcu()));}\n#define pcu putchar_unlocked\n#define svo si void out\ntemplate <typename T>\nsvo(T n) {\n\tstatic char buf[20];\n\tchar *p = buf;\n\t//if(n < 0) pcu('-'), n *= -1;\n\tif (!n) *p++ = '0';\n\telse while (n) *p++ = n % 10 + '0', n /= 10;\n\twhile (p != buf) pcu(*--p); }\nsvo(const char *s){while(*s)pcu(*s++);}\nsvo(char *s){while(*s)pcu(*s++);}\nsvo(char c){pcu(c);}\n//template <typename T>\n//svo(vector<T> &v){for(T &x:v)out(' '),out(x);out('\\n');}\n//svo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);out('\\n');}\ntemplate <typename head, typename... tail>\nsvo(head&& h, tail&&... t){out(h);out(move(t)...);}\n#undef svo\n#undef si\n\nstruct board {\n\tenum {size = 3};\n\tstruct pos {int r, c;};\n\ttypedef array<array<int, size>, size> arr;\n\n\tarr b;\n\tpos p;\n\tint f, g, h;\n\n\tvoid read() {\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tb[i][j] = in();\n\t\t\t\tif (!b[i][j])\n\t\t\t\t\tp.r = i, p.c = j;\n\t\t\t}\n\t\tg = 0;\n\t\tf = h = hn(b);\n\t}\n\n\tvoid print() {\n\t\tfor (auto &r: b) {\n\t\t\tfor (int &c: r)\n\t\t\t\tout(&c == &r[0]?\"\":\" \", c);\n\t\t\tout('\\n');\n\t\t}\n\t\tout('\\n');\n\t}\n\n\tstatic int hn(const arr &a) {\n\t\tint l = 0;\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tint k = a[i][j] ? a[i][j] - 1 : size * size - 1;\n\t\t\t\tl += abs(i - k / size) + abs(j - k % size);\n\t\t\t}\n\t\treturn l;\n\t}\n\n\tstatic int key(const arr &a) {\n\t\tint k = 0;\n\t\tfor (auto &r: a)\n\t\t\tfor (int c: r)\n\t\t\t\tk = (k * 10) + c;\n\t\treturn k;\n\t}\n\n\tint solver() {\n\t\tstatic const pos to[] = {-1, 0, 0, -1, 1, 0, 0, 1};\n\t\tunordered_set<int> m;\n\t\tpriority_queue<board> q;\n\t\tq.push(*this);\n\t\twhile (!q.empty()) {\n\t\t\tboard a = q.top();\n\t\t\tq.pop();\n\t\t\tint k = key(a.b);\n\t\t\tif (m.count(k))\n\t\t\t\tcontinue;\n\t\t\tm.insert(k);\n\t\t\tif (!a.h)\n\t\t\t\treturn a.g / 2;\n\t\t\tfor (pos o: to) {\n\t\t\t\to.r += a.p.r, o.c += a.p.c;\n\t\t\t\tif (0 <= o.r && o.r < size && 0 <= o.c && o.c < size) {\n\t\t\t\t\tboard c = a;\n\t\t\t\t\tswap(c.b[a.p.r][a.p.c], c.b[o.r][o.c]);\n\t\t\t\t\tc.g += 2;\n\t\t\t\t\tc.h = hn(c.b);\n\t\t\t\t\tc.f = c.g + c.h;\n\t\t\t\t\tc.p = o;\n\t\t\t\t\tq.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\nbool operator < (const board &a, const board &b) {\n\treturn a.f > b.f;\n}\n\nint main() {\n\tboard b;\n\tb.read();\n\tout(b.solver(), '\\n');\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// #include {{{\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <forward_list>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <regex>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#ifdef DEBUG\n#include <fmt/format.h>\n#include <fmt/ostream.h>\n#endif\n\nusing namespace std;\n// }}}\n\n// type {{{\nusing  s8 =   int8_t;\nusing  u8 =  uint8_t;\nusing s16 =  int16_t;\nusing u16 = uint16_t;\nusing s32 =  int32_t;\nusing u32 = uint32_t;\nusing s64 =  int64_t;\nusing u64 = uint64_t;\n\ntemplate<typename T>\nusing max_heap = priority_queue<T, vector<T>, less<T>>;\ntemplate<typename T>\nusing min_heap = priority_queue<T, vector<T>, greater<T>>;\n// }}}\n\n// hide {{{\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-const-variable\"\n#endif\n// }}}\n\n// 適宜調整\n//#define int s64\n//#define double long double\n\nconstexpr bool AUTOFLUSH = false;\n\nconstexpr bool STDIO_ENABLE = false;\n\nconstexpr int IOS_PREC = 10;\n\nconstexpr int INF_S32 =             1'010'000'000;\nconstexpr s64 INF_S64 = 1'010'000'000'000'000'000LL;\n\nconstexpr auto   INF = INF_S64;\nconstexpr double EPS = 1e-9;\n\nconstexpr s64 MOD = 1'000'000'007;\n\n// hide {{{\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n// }}}\n\n// util {{{\ntemplate<typename T, size_t N, size_t... NS>\nstruct ArrayStruct {\n    using type = array<typename ArrayStruct<T,NS...>::type,N>;\n};\n\ntemplate<typename T, size_t N>\nstruct ArrayStruct<T,N> {\n    using type = array<T,N>;\n};\n\ntemplate<typename T, size_t N, size_t... NS>\nusing Array = typename ArrayStruct<T,N,NS...>::type;\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    static_assert(is_signed<T>::value, \"ABS(): argument must be signed\");\n    return x < 0 ? -x : x;\n}\n\ntemplate<typename T>\nconstexpr T abs_diff(T x, T y) {\n    return x < y ? y-x : x-y;\n}\n\ntemplate<typename T>\nconstexpr bool is_odd(T x) {\n    return x % 2 != 0;\n}\n\ntemplate<typename T>\nconstexpr bool is_even(T x) {\n    return x % 2 == 0;\n}\n\ntemplate<typename T>\nconstexpr int cmp(T x, T y) {\n    return (x > y) - (x < y);\n}\n\ntemplate<typename T>\nconstexpr int sgn(T x) {\n    return cmp(x, T(0));\n}\n\ntemplate<typename T>\nconstexpr T ipow(T a, T b) {\n    assert(b >= 0);\n    T res(1);\n    for(T i = 0; i < b; ++i)\n        res *= a;\n    return res;\n}\n\ntemplate<\n    typename T,\n    std::enable_if_t<\n        std::is_integral<T>::value &&\n        std::is_signed<T>::value, std::nullptr_t> = nullptr>\nconstexpr T div_ceil(T a, T b) {\n    return a/b + (((a<0)^(b>0)) && (a%b));\n}\n\ntemplate<\n    typename T,\n    std::enable_if_t<\n        std::is_integral<T>::value &&\n        std::is_unsigned<T>::value, std::nullptr_t> = nullptr>\nconstexpr T div_ceil(T a, T b) {\n    return a/b + !!(a%b);\n}\n\ntemplate<\n    typename T,\n    std::enable_if_t<\n        std::is_integral<T>::value &&\n        std::is_signed<T>::value, std::nullptr_t> = nullptr>\nconstexpr T div_floor(T a, T b) {\n    return a/b - (((a>0)^(b>0)) && (a%b));\n}\n\ntemplate<\n    typename T,\n    std::enable_if_t<\n        std::is_integral<T>::value &&\n        std::is_unsigned<T>::value, std::nullptr_t> = nullptr>\nconstexpr T div_floor(T a, T b) {\n    return a/b;\n}\n\ntemplate<typename T, typename U>\nconstexpr auto modulo(T a, U b) {\n    using R = common_type_t<T,U>;\n    assert(b > 0);\n    R r = a % b;\n    return r >= 0 ? r : r+b;\n}\n\ntemplate<typename T>\nconstexpr T clamp(T x, T lo, T hi) {\n    assert(lo <= hi);\n    if(x < lo)\n        return lo;\n    else if(x > hi)\n        return hi;\n    else\n        return x;\n}\n\ntemplate<typename T>\nT isqrt(T x) {\n    assert(x >= 0);\n    return static_cast<T>(sqrt(static_cast<long double>(x)));\n}\n\ntemplate<typename T, typename U>\nbool chmax(T& xmax, const U& x) {\n    if(x > xmax) {\n        xmax = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T, typename U>\nbool chmin(T& xmin, const U& x) {\n    if(x < xmin) {\n        xmin = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T>\nconstexpr int SIZE(const T& c) {\n    return static_cast<int>(c.size());\n}\n\ntemplate<typename T, size_t N>\nconstexpr int SIZE(const T (&)[N]) {\n    return static_cast<int>(N);\n}\n\ntemplate<typename InputIt, typename T>\nint argfind(InputIt first, InputIt last, const T& x) {\n    auto it = find(first, last, x);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nint argmax(InputIt first, InputIt last) {\n    auto it = max_element(first, last);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nint argmin(InputIt first, InputIt last) {\n    auto it = min_element(first, last);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nbool alltrue(InputIt first, InputIt last) {\n    return all_of(first, last, [](bool b) { return b; });\n}\n\ntemplate<typename InputIt>\nbool anytrue(InputIt first, InputIt last) {\n    return any_of(first, last, [](bool b) { return b; });\n}\n\ntemplate<typename InputIt>\nbool allfalse(InputIt first, InputIt last) {\n    return !anytrue(first, last);\n}\n\ntemplate<typename InputIt>\nbool anyfalse(InputIt first, InputIt last) {\n    return !alltrue(first, last);\n}\n\ntemplate<typename T>\narray<pair<T,T>,4> neighbor4(const T& x, const T& y) {\n    return array<pair<T,T>,4> {{\n                    { x, y-1 },\n        { x-1, y },             { x+1, y },\n                    { x, y+1 },\n    }};\n}\n\ntemplate<typename T>\narray<pair<T,T>,8> neighbor8(const T& x, const T& y) {\n    return array<pair<T,T>,8> {{\n        { x-1, y-1 }, { x, y-1 }, { x+1, y-1 },\n        { x-1, y   },             { x+1, y   },\n        { x-1, y+1 }, { x, y+1 }, { x+1, y+1 },\n    }};\n}\n\ntemplate<typename T>\nbool in_bounds(const T& x, const T& minx, const T& maxx) {\n    return !(x < minx) && !(maxx < x);\n}\n\ntemplate<typename T>\nbool in_bounds_2(\n    const T& x,    const T& y,\n    const T& minx, const T& miny,\n    const T& maxx, const T& maxy) {\n    return in_bounds(x, minx, maxx) && in_bounds(y, miny, maxy);\n}\n\ntemplate<typename T>\nbool in_bounds_wh(const T& x, const T& y, const T& w, const T& h) {\n    return in_bounds_2(x, y, 0, 0, w-1, h-1);\n}\n\nstruct pairhash {\n    template<typename T1, typename T2>\n    size_t operator()(const pair<T1,T2>& p) const {\n        size_t res = 17;\n        res = 31*res + hash<T1>()(p.first);\n        res = 31*res + hash<T2>()(p.second);\n        return res;\n    }\n};\n\nstruct vectorhash {\n    template<typename T>\n    size_t operator()(const vector<T>& v) const {\n        size_t res = 17;\n        res = 31*res + hash<size_t>()(v.size());\n        for(const auto& e : v) {\n            res = 31*res + hash<T>()(e);\n        }\n        return res;\n    }\n};\n\ntemplate<typename K, typename V>\npair<typename map<K,V>::iterator, bool> insert_or_assign(map<K,V>& m, const K& k, const V& v) {\n    auto it = m.lower_bound(k);\n    if(it != end(m) && !m.key_comp()(k,it->first)) {\n        it->second = v;\n        return make_pair(it, false);\n    }\n    else {\n        auto it_ins = m.insert(it, make_pair(k,v));\n        return make_pair(it_ins, true);\n    }\n}\n\ntemplate<typename K, typename V>\npair<typename unordered_map<K,V>::iterator, bool>\ninsert_or_assign(unordered_map<K,V>& m, const K& k, const V& v) {\n    auto it = m.find(k);\n    if(it != end(m)) {\n        it->second = v;\n        return make_pair(it, false);\n    }\n    else {\n        auto it_ins = m.insert(it, make_pair(k,v));\n        return make_pair(it_ins, true);\n    }\n}\n\ntemplate<typename T>\nstring TO_STRING(const T& x) {\n    ostringstream out;\n    out << x;\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring JOIN(InputIt first, InputIt last, const string& sep) {\n    ostringstream out;\n    while(first != last) {\n        out << *first++;\n        if(first != last)\n            out << sep;\n    }\n    return out.str();\n}\n\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n    using T = typename iterator_traits<InputIt>::value_type;\n    return accumulate(first, last, T());\n}\n\ntemplate<typename T>\nvoid UNIQ(T& c) {\n    c.erase(unique(begin(c), end(c)), end(c));\n}\n\ntemplate<typename T, typename F>\nenable_if_t<rank<T>::value==0> ARRAY_FOREACH(T& e, F f) {\n    f(e);\n}\n\ntemplate<typename Array, typename F>\nenable_if_t<rank<Array>::value!=0> ARRAY_FOREACH(Array& ary, F f) {\n    for(auto& e : ary)\n        ARRAY_FOREACH(e, f);\n}\n\ntemplate<typename Array, typename U>\nenable_if_t<rank<Array>::value!=0> ARRAY_FILL(Array& ary, const U& v) {\n    ARRAY_FOREACH(ary, [&v](auto& elem) { elem = v; });\n}\n\ntemplate<typename T>\nT POP_BACK(vector<T>& que) {\n    T x = que.back(); que.pop_back();\n    return x;\n}\n\ntemplate<typename T>\nT POP_BACK(deque<T>& que) {\n    T x = que.back(); que.pop_back();\n    return x;\n}\n\ntemplate<typename T>\nT POP_FRONT(deque<T>& que) {\n    T x = que.front(); que.pop_front();\n    return x;\n}\n\ntemplate<typename T, typename C>\nT POP(stack<T,C>& stk) {\n    T x = stk.top(); stk.pop();\n    return x;\n}\n\ntemplate<typename T, typename C>\nT POP(queue<T,C>& que) {\n    T x = que.front(); que.pop();\n    return x;\n}\n\ntemplate<typename T, typename Cont, typename Cmp>\nT POP(priority_queue<T,Cont,Cmp>& que) {\n    T x = que.top(); que.pop();\n    return x;\n}\n\ntemplate<typename T>\nvoid RD(T& x) {\n    cin >> x;\n#ifdef DEBUG\n    if(!cin) assert(false);\n#endif\n}\n\ntemplate<typename T>\nvoid RD(vector<T>& v, int n) {\n    v.reserve(n);\n    for(int i = 0; i < n; ++i) {\n        T e; RD(e);\n        v.emplace_back(e);\n    }\n}\n\n// 出力 {{{\n// FPRINTSEQ {{{\ntemplate<typename InputIt>\nostream& FPRINTSEQ(ostream& out, InputIt first, InputIt last) {\n    for(InputIt it = first; it != last; ++it) {\n        if(it != first) out << ' ';\n        out << *it;\n    }\n    return out;\n}\ntemplate<typename InputIt>\nostream& PRINTSEQ(InputIt first, InputIt last) {\n    return FPRINTSEQ(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTSEQ(InputIt first, InputIt last) {\n#ifdef DEBUG\n    FPRINTSEQ(cerr, first, last);\n#endif\n    return cerr;\n}\n// }}}\n\n// 1次元生配列 {{{\ntemplate<typename T, size_t N>\nostream& FPRINTARRAY1(ostream& out, const T (&c)[N]) {\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\ntemplate<typename T, size_t N>\nostream& PRINTARRAY1(const T (&c)[N]) {\n    return FPRINTARRAY1(cout, c);\n}\ntemplate<typename T, size_t N>\nostream& DPRINTARRAY1(const T (&c)[N]) {\n#ifdef DEBUG\n    FPRINTARRAY1(cerr, c);\n#endif\n    return cerr;\n}\n// }}}\n\n// 2次元生配列 {{{\ntemplate<typename T, size_t N1, size_t N2>\nostream& FPRINTARRAY2(ostream& out, const T (&c)[N1][N2]) {\n    out << '\\n';\n    for(const auto& e : c) {\n        FPRINTARRAY1(out, e) << '\\n';\n    }\n    return out;\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& PRINTARRAY2(const T (&c)[N1][N2]) {\n    return FPRINTARRAY2(cout, c);\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& DPRINTARRAY2(const T (&c)[N1][N2]) {\n#ifdef DEBUG\n    FPRINTARRAY2(cerr, c);\n#endif\n    return cerr;\n}\n// }}}\n\n// 非mapコンテナ {{{\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& c) {\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\n// 特別扱い\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T>>& c) {\n    out << '\\n';\n    for(const auto& e : c) {\n        out << e << '\\n';\n    }\n    return out;\n}\n\n// 特別扱い\nostream& operator<<(ostream& out, const vector<string>& c) {\n    out << '\\n';\n    for(const string& e : c) {\n        out << e << '\\n';\n    }\n    return out;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const deque<T>& c) {\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const list<T>& c) {\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const forward_list<T>& c) {\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const set<T>& c) {\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const unordered_set<T>& c) {\n    return out << set<T>(cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const multiset<T>& c) {\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const unordered_multiset<T>& c) {\n    return out << multiset<T>(cbegin(c), cend(c));\n}\n\ntemplate<typename T, size_t N>\nostream& operator<<(ostream& out, const array<T,N>& c) {\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n// }}}\n\n// mapコンテナ {{{\ntemplate<typename InputIt>\nostream& FPRINTMAP(ostream& out, InputIt first, InputIt last) {\n    out << \"{\\n\";\n    for(auto it = first; it != last; ++it) {\n        out << \"  \" << it->first << \" : \" << it->second << '\\n';\n    }\n    out << \"}\\n\";\n    return out;\n}\ntemplate<typename InputIt>\nostream& PRINTMAP(InputIt first, InputIt last) {\n    return FPRINTMAP(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTMAP(InputIt first, InputIt last) {\n#ifdef DEBUG\n    FPRINTMAP(cerr, first, last);\n#endif\n    return cerr;\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const map<K,V>& c) {\n    return FPRINTMAP(out, cbegin(c), cend(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const unordered_map<K,V>& c) {\n    return out << map<K,V>(cbegin(c), cend(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const multimap<K,V>& c) {\n    return FPRINTMAP(out, cbegin(c), cend(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const unordered_multimap<K,V>& c) {\n    return out << multimap<K,V>(cbegin(c), cend(c));\n}\n// }}}\n\n// stack/queue/priority_queue {{{\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, stack<T,C> c) {\n    while(!c.empty()) {\n        out << c.top();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, queue<T,C> c) {\n    while(!c.empty()) {\n        out << c.front();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n\ntemplate<typename T, typename Cont, typename Cmp>\nostream& operator<<(ostream& out, priority_queue<T,Cont,Cmp> c) {\n    while(!c.empty()) {\n        out << c.top();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n// }}}\n\n// pair/tuple {{{\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& out, const pair<T1,T2>& p) {\n    return out << '(' << p.first << ',' << p.second << ')';\n}\n\ntemplate<typename Tuple, size_t Pos>\nostream& FPRINTTUPLE(ostream& out, const Tuple&) {\n    return out;\n}\n\ntemplate<typename Tuple, size_t Pos, typename T, typename... TS>\nostream& FPRINTTUPLE(ostream& out, const Tuple& t) {\n    if(Pos != 0)\n        out << ',';\n    out << get<Pos>(t);\n    return FPRINTTUPLE<Tuple,Pos+1,TS...>(out, t);\n}\n\ntemplate<typename... TS>\nostream& operator<<(ostream& out, const tuple<TS...>& t) {\n    out << '(';\n    FPRINTTUPLE<tuple<TS...>,0,TS...>(out, t);\n    out << ')';\n    return out;\n}\n// }}}\n\n// PRINT {{{\nostream& FPRINT(ostream& out) { return out; }\n\ntemplate<typename T, typename... TS>\nostream& FPRINT(ostream& out, const T& x, const TS& ...args) {\n    out << x;\n    if(sizeof...(args))\n        out << ' ';\n    return FPRINT(out, args...);\n}\n\ntemplate<typename... TS>\nostream& FPRINTLN(ostream& out, const TS& ...args) {\n    FPRINT(out, args...);\n    return out << '\\n';\n}\n\ntemplate<typename... TS>\nostream& PRINT(const TS& ...args) {\n    return FPRINT(cout, args...);\n}\n\ntemplate<typename... TS>\nostream& PRINTLN(const TS& ...args) {\n    return FPRINTLN(cout, args...);\n}\n\ntemplate<typename... TS>\nostream& DPRINT(const TS& ...args) {\n#ifdef DEBUG\n    FPRINT(cerr, args...);\n#endif\n    return cerr;\n}\n\ntemplate<typename... TS>\nostream& DPRINTLN(const TS& ...args) {\n#ifdef DEBUG\n    FPRINTLN(cerr, args...);\n#endif\n    return cerr;\n}\n// }}}\n// }}}\n\nvoid FLUSH() {\n    if(STDIO_ENABLE)\n        fflush(stdout);\n    else\n        cout.flush();\n}\n\n[[noreturn]] void EXIT() {\n#ifdef DEBUG\n    fflush(stdout);\n    fflush(stderr);\n    cout.flush();\n    cerr.flush();\n#else\n    FLUSH();\n#endif\n    //quick_exit(0); // does not work on codeforces\n    _Exit(0);\n}\n\nstruct IoInit {\n    IoInit() {\n#ifndef DEBUG\n        cin.tie(nullptr);\n        if(!STDIO_ENABLE)\n            ios::sync_with_stdio(false);\n#endif\n        cout << fixed << setprecision(IOS_PREC);\n\n        if(AUTOFLUSH) {\n            if(STDIO_ENABLE)\n                setvbuf(stdout, nullptr, _IONBF, 0);\n            cout << unitbuf;\n        }\n    }\n} IOINIT;\n\n#define FOR(i, start, end) for(s64 i = (start); i < (end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cc) { return (f)(begin(cc), end(cc), ## __VA_ARGS__); })(c))\n\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(forward<decltype(args)>(args)...); })\n\n#define MEMSET(a,v) memset((a), (v), sizeof(a))\n\n#define DBG(x) DPRINTLN('L', __LINE__, ':', #x, ':', (x))\n// }}}\n\nusing Board = vector<int>;\n\nunordered_map<Board,bool,vectorhash> M;\n\nBoard INI;\n\nbool is_ok(const Board& board) {\n    static constexpr int OK[9] = {\n        1, 2, 3,\n        4, 5, 6,\n        7, 8, 0,\n    };\n\n    return ALL(equal, board, begin(OK));\n}\n\nvector<Board> neighbor(const Board& board) {\n    vector<Board> res;\n\n    int pos = ALL(argfind, board, 0);\n    int pos_x = pos % 3;\n    int pos_y = pos / 3;\n    for(const auto& p : neighbor4(pos_x, pos_y)) {\n        int x,y; tie(x,y) = p;\n        if(x < 0 || 3 <= x || y < 0 || 3 <= y) continue;\n        Board b(board);\n        int pos2 = 3*y + x;\n        swap(b[pos], b[pos2]);\n        res.emplace_back(b);\n    }\n\n    return res;\n}\n\nint bfs() {\n    queue<pair<Board,int>> que;\n    M[INI] = true;\n    que.emplace(make_pair(INI,0));\n\n    while(!que.empty()) {\n        Board board;\n        int turn;\n        tie(board,turn) = POP(que);\n\n        if(is_ok(board)) return turn;\n\n        for(const auto& b : neighbor(board)) {\n            if(M[b]) continue;\n            M[b] = true;\n            que.emplace(make_pair(b,turn+1));\n        }\n    }\n\n    return -1;\n}\n\nvoid solve() {\n    int ans = bfs();\n    PRINTLN(ans);\n}\n\nsigned main(signed /*argc*/, char** /*argv*/) {\n    INI.resize(9);\n    REP(i, 9) {\n        int a; RD(a);\n        INI[i] = a;\n    }\n\n    \n\n    solve();\n\n    EXIT();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n#define DIVN 3\n\nvoid swap(int &a, int &b);\nint fact(int a);\nint dist(int x);\nint abs(int x);\nvoid insert(vector<int> &A, int v);\nint extract(vector<int> &A);\nint PtoI(vector<int> p);\nvector<int> ItoP(int ii);\nint SolvePuzzle(vector<int> P);\n\nvector<int> Puzzles(fact(DIVN*DIVN), INT_MAX);\n\n\nvoid swap(int &a, int &b){\n\tint tmp = a;\n\ta = b;\n\tb = tmp;\n\treturn;\n}\n\nint fact(int a){\n\tint b = 1;\n\tfor (int i = 2; i <= a; i++){\n\t\tb = b * i;\n\t}\n\treturn b;\n}\n\nint dist(int x){\n\tstd::vector<int> P = ItoP(x);\n\tint result = 0;\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tresult += abs(P[i] % DIVN - (i + 1) % DIVN) + abs(((P[i] == 0 ? DIVN - 1 : (P[i] - 1) / DIVN)) - i / DIVN);\n\t}\n\treturn -result;\n}\n\nint abs(int x){\n\treturn x < 0 ? -x : x;\n}\n\nvoid insert(vector<int> &A, int v){\n\tint n = A.size();\n\tA.push_back(v);\n\twhile (n != 0){\n\t\tint i = (n - 1) / 2;\n\t\tif (dist(A[n]) > dist(A[i])){\n\t\t\tswap(A[n], A[i]);\n\t\t}\n\t\tn = i;\n\t}\n\treturn;\n}\n\nint extract(vector<int> &A){\n\tint n = A.size() - 1;\n\tint res = A[0];\n\tA[0] = A[n];\n\tA.pop_back();\n\n\tfor (int i = 0, j; 2 * i + 1 < n;){\n\t\tj = 2 * i + 1;\n\t\tif (j != n - 1 && dist(A[j]) < dist(A[j + 1])){\n\t\t\tj++;\n\t\t}\n\t\tif (dist(A[i]) < dist(A[j])){\n\t\t\tswap(A[i], A[j]);\n\t\t}\n\t\ti = j;\n\t}\n\treturn res;\n}\n\n\nint PtoI(vector<int> p){\n\tint x, result = 0;\n\tfor (int i = 0; i < DIVN*DIVN - 1; i++){\n\t\tfor (int j = 0; j < DIVN*DIVN - i; j++){\n\t\t\tif (p[j] == i){\n\t\t\t\tx = j;\n\t\t\t\tp.erase(p.begin() + j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult += x * fact(DIVN*DIVN - i - 1);\n\t}\n\treturn result;\n}\n\nvector<int> ItoP(int ii){\n\tvector<int> result(DIVN*DIVN, -1);\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tint index = ii / fact(DIVN*DIVN - i - 1);\n\t\tii = ii % fact(DIVN*DIVN - i - 1);\n\t\tint curindex = -1;\n\t\tint x = -1;\n\t\tfor (int j = 0; j < DIVN*DIVN; j++){\n\t\t\tif (result[j] == -1){\n\t\t\t\tcurindex++;\n\t\t\t}\n\t\t\tif (curindex == index) {\n\t\t\t\tx = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult[x] = i;\n\t}\n\treturn result;\n}\n\nint SolvePuzzle(vector<int> P){\n\tvector<int> Que;\n\tinsert(Que, PtoI(P));\n\tint answer = INT_MAX;\n\tPuzzles[PtoI(P)] = 0;\n\twhile (!Que.empty()){\n\t\tvector<int> Q = ItoP(extract(Que));\n\t\tint Cursor;\n\t\tbool isAligned = true;\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] != (i + 1) % (DIVN*DIVN)){\n\t\t\t\tisAligned = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isAligned){\n\t\t\tanswer = Puzzles[PtoI(Q)];\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] == 0){\n\t\t\t\tCursor = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvector<int> Qnext;\n\t\tif (Cursor >= DIVN){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor < DIVN * (DIVN - 1)){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != 0){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != DIVN - 1){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn answer;\n}\n\nint main(){\n\tint k;\n\tvector<int> P;\n\tfor (int i = 0; i < DIVN * DIVN; i++){\n\t\tscanf(\"%d\", &k);\n\t\tP.push_back(k);\n\t}\n\tint n = SolvePuzzle(P);\n\n\tprintf(\"%d\\n\", n);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator<(const Puzzle &p)const {\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool itarget(Puzzle x){\n  for(int i=0;i<N2;i++)\n    if(x.f[i]!=(i+1))return false;\n    return true;\n  }\n\n  string bfs(Puzzle a){\n    queue<Puzzle>Q;\n    map<Puzzle, bool>V;\n    Puzzle u, v;\n    a.path=\"\";\n    Q.push(a);\n    V[a]=true;\n\n    while(!Q.empty()){\n      u=Q.front(); Q.pop();\n      if(itarget(u))return u.path;\n      int xx=u.space/N;\n      int xy=u.space%N;\n\n      for(int k=0;k<4;k++){\n\tint yx=xx+dx[k];\n\tint yy=xy+dy[k];\n\tif(yx<0 || yy<0 || yx >=N || yy>=N)continue;\n\tv=u;\n\tswap(v.f[u.space],v.f[yx*N+yy]);\n\tv.space=yx*N+yy;\n\tif(!V[v])\n\t  {\n\t    V[v]=true;\n\t    v.path+=dir[k];\n\t    Q.push(v);\n\t  }\n      }\n    }\n    return \"unsolvable\";\n  }\n  \n\nint main(){\n  Puzzle n;\n  for(int i=0;i<N2;i++){\n    cin>>n.f[i];\n    if(n.f[i]==0){\n      n.f[i]=N2;\n      n.space=i;\n    }\n  }\n  string ans=bfs(n);\n  cout<<ans.size()<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define MAXN 10+2\nint map[MAXN][MAXN];\nint min0=1000000000;\nint t;\nint map1[3][3]={1,2,3,4,5,6,7,8,0};\nbool hx[40000009];\nbool pd(){\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tif(map[i][j]!=map1[i][j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\nvoid syf(int x,int y,int tot){\n\tif(pd()){\n\t\tif(tot<min0) min0=tot;\n\t\treturn;\n    }\n    else if(tot>27) return;\n\telse{\n\t\tint g=1;\n\t\tif(x+1<3){\n\t\t\tt=map[x][y];\n\t\t\tmap[x][y]=map[x+1][y];\n\t\t\tmap[x+1][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=40000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x+1,y,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x+1][y];\n\t\t\tmap[x+1][y]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(x-1>=0){\n\t\t\tt=map[x][y];\n\t\t\tmap[x][y]=map[x-1][y];\n\t\t\tmap[x-1][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=40000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x-1,y,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x-1][y];\n\t\t\tmap[x-1][y]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(y+1<3){\n\t\t\tt=map[x][y+1];\n\t\t\tmap[x][y+1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=40000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x,y+1,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x][y+1];\n\t\t\tmap[x][y+1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(y-1>=0){\n\t\t\tt=map[x][y-1];\n\t\t\tmap[x][y-1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=40000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x,y-1,tot+1);\n\t\t\t    hx[g]=0;\n\t\t\t}\n\t\t\tt=map[x][y-1];\n\t\t\tmap[x][y-1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t}\n}\nvoid input(){\n\tint x1,y1;\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tcin>>map[i][j];\n\t\t\tif(map[i][j]==0){\n\t\t\t\tx1=i;\n\t\t\t\ty1=j;\n\t\t\t}\n\t\t}\n\t}\n\tint g=1;\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tg=g*10+map[i][j];\n\t\t\tg%=10000007;\n\t\t}\n\t}\n\thx[g]=1;\n\tsyf(x1,y1,0);\n\tcout<<min0<<endl;\n}\nint main(){\n\tinput();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator<(const Puzzle &p)const {\n\t\tfor (int i = 0; i < N2; i++) {\n\t\t\tif (f[i] == p.f[i])continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4] = { -1,0,1,0 };\nstatic const int dy[4] = { 0,-1,0,1 };\nstatic const char dir[4] = { 'u','l','d','r' };\n\nbool isTarget(Puzzle p) {\n\tfor (int i = 0; i < N2; i++)\n\t\tif (p.f[i] != (i + 1))return false;\n\treturn true;\n}\n\nstring bfs(Puzzle s) {\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isTarget(u))return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space%N;\n\t\tfor (int r = 0; r < 4; r++) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx*N + ty]);\n\t\t\tv.space = tx*N + ty;\n\t\t\tif (!V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main() {\n\tPuzzle in;\n\n\tfor (int i = 0; i < N2; i++) {\n\t\tcin >> in.f[i];\n\t\tif (in.f[i] == 0) {\n\t\t\tin.f[i] = N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define FOR(i,n) for(int i=0; i<n; ++i)\n#define GET(type,name) type name; std::cin >> name;\n\n\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <utility>\n#include <algorithm>\n#include <queue>\n#include <numeric>\n#include <unordered_map>\n\n\n    typedef std::vector<std::vector<int>> State;\n    const int N = 3;\n\n    State int_to_state(int c){\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n      FOR(i, N) {\n        FOR(j, N) {\n          int r = c%10;\n          c = c/10;\n          state[i][j] = r;\n        }\n      }\n      return state;\n    }\n    int state_to_int(State state) {\n      int c = 0;\n      int p = 1;\n      FOR(i, N) {\n        FOR(j, N) {\n          c += state[i][j] * p;\n          p *= 10;\n        }\n      }\n      return c;\n    }\n\n\n    void show(std::vector<std::vector<int>> state){\n      FOR(i, N) {\n        FOR(j, N) {\n          std::cout << state[i][j] << \" \";\n        }\n        std::cout << std::endl;\n      }\n    }\n\n    bool is_solved(const State& state) {\n      int N = state.size();\n\n      FOR(i, N) {\n        FOR(j, N) {\n          if(state[i][j] != (1 + 3*i + j)) return false;\n        }\n      }\n      return true;\n    }\n\n    std::vector<State> next_states_of(State state){\n      std::vector<State> res;\n      auto ns = state; std::swap(ns[0][0], ns[0][1]); res.push_back(ns);\n      ns = state; std::swap(ns[0][1], ns[0][2]); res.push_back(ns);\n      ns = state; std::swap(ns[1][0], ns[1][1]); res.push_back(ns);\n      ns = state; std::swap(ns[1][1], ns[1][2]); res.push_back(ns);\n      ns = state; std::swap(ns[2][0], ns[2][1]); res.push_back(ns);\n      ns = state; std::swap(ns[2][1], ns[2][2]); res.push_back(ns);\n      ns = state; std::swap(ns[0][0], ns[1][0]); res.push_back(ns);\n      ns = state; std::swap(ns[1][0], ns[2][0]); res.push_back(ns);\n      ns = state; std::swap(ns[0][1], ns[1][1]); res.push_back(ns);\n      ns = state; std::swap(ns[1][1], ns[2][1]); res.push_back(ns);\n      ns = state; std::swap(ns[0][2], ns[1][2]); res.push_back(ns);\n      ns = state; std::swap(ns[1][2], ns[2][2]); res.push_back(ns);\n//      std::cout << res.size() <<std::endl;\n      return res;\n    }\n\n    int solve_puzzle(State state){\n\n      std::priority_queue<\n        std::pair<int, int>,\n        std::vector<std::pair<int, int>>,\n        std::greater<std::pair<int, int>>\n      > q;\n      std::unordered_map<int, int> h;\n\n      q.push(std::make_pair(0, state_to_int(state)));\n\n      for(;not q.empty();){\n        auto d_s = q.top(); q.pop();\n        int d = d_s.first;\n        int st_int = d_s.second;\n        State state = int_to_state(d_s.second);\n//        show(state);\n\n        if(st_int == 987654321){\n//          std::cout << \"z\"<< std::endl;\n          return d;\n        }\n\n        if(h.find(st_int) == h.end()){\n          h[st_int] = d;\n          std::vector<State> next_states = next_states_of(state);\n          for(auto ns : next_states){\n            q.push(std::make_pair(d+1, state_to_int(ns)));\n          }\n        }\n      }\n      return -1;\n    }\n\n    int main(){\n      const int N = 3;\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n\n      FOR(i, N){\n        FOR(j, N){\n          GET(int, x);\n          if(x==0) x=9;\n          state[i][j] = x;\n        }\n      }\n//      show(state);\n//      int c = state_to_int(state);\n//      std::cout << c << std::endl;\n//      std::cout << \"?\" <<std::endl;\n//      State s2 = int_to_state(c);\n//      std::cout << \"!\" <<std::endl;\n//\n//      show(s2);\n//      int min_steps = rec_min_steps_\n      std::cout << solve_puzzle(state) << std::endl;\n      return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nint limit;\nint cost;\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\n\n\nstruct state {\n    int puzzle[9];\n    int space;\n    int cost;\n    int evaluation;\n\n    bool operator < (const state &s) const {\n        return evaluation > s.evaluation;\n    }\n};\n\n\nint goal[9] = {1, 2, 3,\n               4, 5, 6,\n               7, 8, 0};\n\n\nbool IsGoal(state s) {\n    for (int i = 0; i < 9; i++) {\n        if (s.puzzle[i] != goal[i]) return false;\n    }\n    return true;\n}\n\n\nvector<state> closed;\n\nbool IsSamePuzzle(state s1, state s2){\n    for (int i = 0; i < 9; i++) {\n        if (s1.puzzle[i] != s2.puzzle[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool InClosed(state s){\n    for (int i = 0; i < closed.size(); i++) {\n        if (IsSamePuzzle(s, closed[i])) return true;\n    }\n    return false;\n}\n\n\nint h2(state s) {\n    int res = 0;\n    for (int i = 0; i < 9; i++) {\n        if (s.puzzle[i] == 0) continue;\n\n        int px = (s.puzzle[i] - 1) / 3;\n        int py = (s.puzzle[i] - 1) % 3;\n\n        int x = i / 3;\n        int y = i % 3;\n\n        res += abs(x - px) + abs(y - py);\n    }\n    return res;\n}\n\n\nint astar(state s) {\n    priority_queue<state> pq;\n    pq.push(s);\n\n    while (!pq.empty()) {\n        state st = pq.top(); pq.pop();\n\n        if (IsGoal(st)) {\n            return st.cost;\n        }\n\n        closed.push_back(st);\n\n        int px = st.space / 3;\n        int py = st.space % 3;\n\n        for (int i = 0; i < 4; i++) {\n            int x = px + dx[i];\n            int y = py + dy[i];\n\n            if (x < 0 || y < 0 || x >= 3 || y >= 3) continue;\n\n            state next = st;\n            swap(next.puzzle[st.space], next.puzzle[x * 3 + y]);\n            next.space = x * 3 + y;\n\n            if (!InClosed(next)) {\n                next.cost++;\n                next.evaluation = next.cost + h2(next);\n                pq.push(next);\n            }\n        }\n    }\n\n    return -1;\n}\n\n\nint main() {\n    state init;\n\n    for (int i = 0; i < 9; i++) {\n        cin >> init.puzzle[i]; \n        if (init.puzzle[i] == 0) init.space = i;\n    }\n    init.cost = 0;\n    init.evaluation = init.cost + h2(init);\n\n    cout << astar(init) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <string>\n#include <utility>\n\nusing namespace std;\n\n#define N (3)\n#define N2 (N*N)\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < ( const Puzzle &p ) const {\n\tfor ( int i = 0; i < N2; i++ ) {\n\t    if ( f[i] == p.f[i] ) continue;\n\t    return ( f[i] < p.f[i] );\n\t}\n\t//return false;\t\t// ????????????????????´???????????\\????????????\n        return true;\n    }\n};\n\n// x, y?????????????????£??????\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget( Puzzle p ) {\n    for ( int i = 0; i < N2; i++ ) {\n\tif ( p.f[i] != ( i + 1 ) ) return false;\n    }\n    return true;\n}\n\nstring bfs( Puzzle s ) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push( s );\n    V[s] = true;\n    \n    while ( !Q.empty() ) {\n\tu = Q.front(); Q.pop();\n\tif ( isTarget( u ) ) return u.path;\n\tint sx = u.space / N;\n\tint sy = u.space % N;\n\t\n\tfor ( int r = 0; r < 4; r++ ) {\n\t    int tx = sx + dx[r];\n\t    int ty = sy + dy[r];\n\n\t    if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n\t    v = u;\n\t    swap( v.f[u.space], v.f[tx * N + ty] );\n\t    v.space = tx * N + ty;\n\t    if ( !V[v] ) {\n\t\tV[v] = true;\n\t\tv.path += dir[r];\n\t\tQ.push( v );\n\t    }\n\t}\n    }\n\n    return \"unsolvable\";\n}\n\nint main()\n{\n    Puzzle in;\n    \n    for ( int i = 0; i < N2; i++ ) {\n\tscanf(\"%d\", &in.f[i]);\n\tif ( in.f[i] == 0 ) {\n\t    in.f[i] = N2;\n\t    in.space = i;\n\t}\n    }\n    string ans = bfs( in );\n\n    printf(\"%d\\n\", (int)ans.size());\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n     int f[N2];\n     int space;\n     string path;\n     bool operator < ( const Puzzle &p ) const {\n         for ( int i = 0; i < N2; i++ ) {\n        if ( f[i] == p.f[i] ) continue;\n        return f[i] > p.f[i];\n             \n         }\n        return false;\n         \n     }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nbool isTarget(Puzzle p) {\n    for ( int i = 0; i < N2; i++ )\n        if ( p.f[i] != (i + 1) ) return false;\n    return true;\n}\n\nstring bfs(Puzzle s) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n    \n    while ( !Q.empty() ) {\n        u = Q.front(); Q.pop();\n        if ( isTarget(u) ) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for ( int r = 0; r < 4; r++ ) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if ( !V[v] ) {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n    \n}\nint main() {\n    Puzzle in;\n    for ( int i = 0; i < N2; i++ ) {\n        cin >> in.f[i];\n        if ( in.f[i] == 0 ) {\n            in.f[i] = N2; // set space\n            in.space = i;\n            \n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ------ Includes ------ //\n\n#include <map>\n#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\n\n// ------ Directions ------ //\n\nconst int dx[4] = { 0, 1, 0, -1 };\nconst int dy[4] = { 1, 0, -1, 0 };\n\n\n// ------ BFS ------ //\n\nint BFS(vector<vector<int> > p)\n{\n\t// ------ Initialize ------ //\n\n\tvector<vector<int> > lastboard = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 0 } };\n\n\tmap<vector<vector<int> >, int> D;\n\n\tqueue<pair<vector<vector<int> >, int> > que;\n\n\tD[p] = 1; que.push(make_pair(p, 1));\n\n\n\t// ------ Search ------ //\n\n\twhile (!que.empty())\n\t{\n\t\tpair<vector<vector<int> >, int> p1 = que.front(); que.pop();\n\n\n\t\t// ------ 0 Searching ------ //\n\n\t\tint tx = -1, ty = -1;\n\n\t\tfor (int i = 0; i < p1.first.size(); i++)\n\t\t{\n\t\t\tfor (int j = 0; j < p1.first[i].size(); j++)\n\t\t\t{\n\t\t\t\tif (p1.first[i][j] == 0)\n\t\t\t\t{\n\t\t\t\t\ttx = j; ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\t// ------ Moving ------ //\n\n\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t{\n\t\t\tif (0 <= tx + dx[dir] && tx + dx[dir] < p1.first[0].size() && 0 <= ty + dy[dir] && ty + dy[dir] < p1.first.size())\n\t\t\t{\n\t\t\t\tvector<vector<int> > p2 = p1.first;\n\n\t\t\t\tswap(p2[ty][tx], p2[ty + dy[dir]][tx + dx[dir]]);\n\n\t\t\t\tif (p2 == lastboard)\n\t\t\t\t{\n\t\t\t\t\treturn p1.second;\n\t\t\t\t}\n\n\t\t\t\tD[p2] = p1.second + 1;\n\n\t\t\t\tque.push(make_pair(p2, p1.second + 1));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tvector<vector<int> > board(3, vector<int>(3, -1));;\n\n\tfor (int i = 0; i < board.size(); i++)\n\t{\n\t\tfor (int j = 0; j < board[i].size(); j++)\n\t\t{\n\t\t\tcin >> board[i][j];\n\t\t}\n\t}\n\n\tcout << BFS(board) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<tr1/unordered_set>\n#include<cstring>\nusing namespace std;\nbool done[40000000];\nint m[10]={1};\nint f;\nlong long ans=0;\nint zon[10]={1,2,3,4,5,6,7,8,0};\nint fx[4]={1,-1,3,-3};\nint wz[10]={8,0,1,2,3,4,5,6,7};\ntr1::unordered_set<long long> s;\nvoid dfs(int use,long long sm,int tot){\n    if(use>tot || s.count(sm) || f) return;\n    if(ans==sm){\n        f=1;\n        return;\n    }\n    s.insert(sm);\n    long long dt[9],p,ssm;\n    for(int i=8;i>=0;i--){\n        dt[i]=sm/m[i];\n        sm-=m[i]*dt[i];\n        if(dt[i]==0) p=i;\n    }\n    int u=0;\n    for(int i=1;i<9;i++){\n        u+=abs(i%3-wz[dt[i]]%3)+abs(i/3-wz[dt[i]]/3);\n    }\n    if(u+use*2>tot*2) return;\n    for(int i=0;i<4;i++){\n        if(p+fx[i]<0||p+fx[i]>15) continue;\n        dt[p]=dt[p+fx[i]];\n        dt[p+fx[i]]=0;\n        ssm=0;\n        for(int i=0;i<9;i++) ssm+=dt[i]*m[i];\n        dfs(use+1,ssm,tot);\n        dt[p+fx[i]]=dt[p];\n        dt[p]=0;\n    }\n}\nint main(){\n    int dt[9];\n    for(int i=1;i<9;i++){\n        m[i]=m[i-1]*9;\n    }\n    long long sm=0;\n    for(int i=0;i<9;i++){\n        cin>>dt[i];\n        sm+=dt[i]*m[i];\n    }\n    for(int i=0;i<9;i++){\n        ans+=zon[i]*m[i];\n    }\n    for(int i=0;i<1000;i++){\n        s.clear();\n        dfs(0,sm,i);\n        if(f){\n            cout<<i<<\"\\n\";\n            break;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct P{\n  int f[9];\n  int t;\n  int st;\n  bool operator < (const P &p) const{\n    for(int i=0;i<9;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nint main(){\n  P in;\n  map<P,bool> V;\n  queue<P> Q;\n  for(int i=0;i<9;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0)in.st=i;\n  }\n  in.t=0;\n  Q.push(in);\n  while(!Q.empty()){\n    P top=Q.front();\n    Q.pop();\n    if(!V[top]){\n      V[top]=true;\n      int flag=0;\n      for(int i=0;i<9;i++)if((i+1)%9!=top.f[i])flag=1;\n      if(!flag){\n\tcout<<top.t<<endl;\n\tbreak;\n      }\n      int st=top.st;\n      top.t++;\n      P tmp;\n      if(st-3>=0){\n\ttmp=top;\n\tswap(tmp.f[st],tmp.f[st-3]);\n\ttmp.st-=3;\n\tQ.push(tmp);\n      }\n      if(st+3<9){\n\ttmp=top;\n\tswap(tmp.f[st],tmp.f[st+3]);\n\ttmp.st+=3;\n\tQ.push(tmp);\n      }\n      if(st%3!=2){\n\ttmp=top;\n\tswap(tmp.f[st],tmp.f[st+1]);\n\ttmp.st++;\n\tQ.push(tmp);\n      }\n      if(st%3!=0){\n\ttmp=top;\n\tswap(tmp.f[st],tmp.f[st-1]);\n\ttmp.st--;\n\tQ.push(tmp);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst int edge[4][3] = {{0, 3, 6}, {0, 1, 2}, {6, 7, 8}, {2, 5, 8}}; /* l, t, b, r */\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}};\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    if(wrongs + moves > cutoff)\n        return -1;\n    int zero;\n    REP(i, 9){\n        if(tiles[i] == 0){\n            zero = i;\n            break;\n        }\n    }\n    if(wrongs + moves >= cutoff)\n        return -1;\n    if(dir[zero][0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-1]);\n    }\n    if(dir[zero][1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-3]);\n    }\n    if(dir[zero][2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+3]);\n    }\n    if(dir[zero][3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+1]);\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n    int start = check();\n\n    REP(i, 50){\n        move = dfs(0, start + i);\n        if(move > 0){\n            break;\n        }\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ****************************************************************************\n// C header\n// ****************************************************************************\n#include <cmath>\n// ****************************************************************************\n// C++ header\n// ****************************************************************************\n#include <iostream>\n// ****************************************************************************\n// STL library\n// ****************************************************************************\n#include <queue>\n#include <set>\n// ****************************************************************************\n// MACRO\n// ****************************************************************************\n#define N       3\n#define FINITE  123456780\n// ****************************************************************************\n// STRUCT\n// ****************************************************************************\ntypedef struct _State {\n    int v[N][N];\n    int cnt;\n    int x, y;\n} State;\n// ****************************************************************************\n// PROTOTYPE\n// ****************************************************************************\nint hash ( int state[][N] );\nint solve( int state[][N] );\n// ****************************************************************************\n// GLOBAL VARIABLE\n// ****************************************************************************\nstd::set< int > hset;\n// ****************************************************************************\n// FUNCTIONS\n// ****************************************************************************\nint hash( int state[][N] ) {\n    int res=0, k=8;\n    for (int i=0; i<N; ++i) {\n        for (int j=0;j<N; ++j) {\n            res += state[i][j] * pow(10, k);\n            --k;\n        }\n    }\n    return res;\n}\n\nint solve( int state[][N] ) {\n    int dx[] = {-1,  0,  1,  0},\n        dy[] = { 0, -1,  0,  1};\n    std::queue< State > que;\n    while ( !que.empty() ) que.pop();\n    State s;\n    for (int i=0; i<N; ++i) {\n        for (int j=0; j<N; ++j) {\n            s.v[i][j] = state[i][j];\n            if (state[i][j] == 0) {\n                s.x = i;\n                s.y = j;\n            }\n        }\n    }\n    s.cnt = 0;\n    que.push( s );\n\n    while ( !que.empty() ) {\n        s = que.front();\n        int h = hash( s.v );\n\n        if ( h == FINITE ) break;\n\n        if (hset.find( h ) == hset.end()) {\n            hset.insert( h );\n\n            for (int i=0; i<4; ++i) {\n                int x=s.x+dx[i], y=s.y+dy[i];\n                if (0<=x && x<N && 0<=y && y<N) {\n                    State tmp = s;\n                    std::swap( tmp.v[s.x][s.y], tmp.v[x][y] );\n                    tmp.x = x;\n                    tmp.y = y;\n                    ++tmp.cnt;\n                    que.push( tmp );\n                }\n            }\n        }\n        que.pop();\n    }\n    return que.front().cnt;\n}\n// ****************************************************************************\n// MAIN FUNCTION\n// ****************************************************************************\nint main() {\n    int state[N][N];\n    for (int i=0; i<N; ++i) {\n        for (int j=0; j<N; ++j) {\n            std::cin >> state[i][j];\n        }\n    }\n    std::cout << solve( state ) << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nconst int dx[4] { -1, 0, 1, 0 };\nconst int dy[4] { 0, -1, 0, 1 };\nconst char dir[4] { 'u', 'l', 'd', 'r' };\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator <(const Puzzle &p) const {\n\t\tfor (int i = 0; i < N2; ++i) {\n\t\t\tif (f[i] == p.f[i])\n\t\t\t\tcontinue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nbool isResolved(Puzzle p) {\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif (p.f[i] != i + 1) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle p) {\n\tqueue<Puzzle> Q;\n\tp.path = \"\";\n\tQ.push(p);\n\tmap<Puzzle, bool> M;\n\tM[p] = true;\n\tPuzzle u, v;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isResolved(u))\n\t\t\treturn u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!M[v]) {\n\t\t\t\tM[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\";\n}\n\nint main() {\n\tPuzzle p;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tscanf(\"%d\", &p.f[i]);\n\t\tif (p.f[i] == 0) {\n\t\t\tp.f[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(p);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <list>\n#include <string>\n#include <map>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nstruct state {\n    Board board;\n    int count;\n};\n\nlist<state> q;\nmap<Board,char> history;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    ++s.count;\n    if (s.board == GOAL) {\n        return s.count;\n    }\n    map<Board,char>::iterator it = history.find(s.board);\n    if (it == history.end()) {\n        history.insert(make_pair(s.board, ' '));\n        q.push_back(s);\n    }\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0; i < N; ) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            board |= static_cast<long long>((ch - '0')) << (i*4);\n            ++i;\n        }\n    }\n\n    if (board == GOAL) {\n        printf(\"0\\n\");\n        return 0;\n    }\n\n//    print(GOAL);\n//    print(board);\n\n    q.push_back({ board, 0 });\n    int count = 0;\n    while (!q.empty()) {\n        state s = q.front();\n        q.pop_front();\n\n        int pos = -1;\n        while (++pos < N) {\n            if (((s.board >> (pos*4)) & 15) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <cmath>\n\nusing namespace std;\n\nusing Weight=int;\nusing Encoded=int;\n\nstruct State {\n    Weight hcost, acost;\n    Encoded encoded;\n    State() {}\n    State(Weight h, Weight a, Encoded e): hcost(h), acost(a), encoded(e) {}\n    bool operator>(const State & state2) const {\n        if (hcost+acost != state2.hcost+state2.acost) {\n            return hcost+acost > state2.hcost+state2.acost;\n        } else {\n            return acost > state2.acost;\n        }\n    }\n};\n\nconst Weight INF=1<<29;\n\ntemplate <class T>\nusing lp_queue=priority_queue<T, deque<T>, greater<T>>;\n\nEncoded encode(vector<int> d) {\n    int cur=0;\n    Encoded enc=0;\n    for (size_t i=0; i<d.size()-1; ++i) {\n        cur = d[i];\n        for (size_t j=i+1; j<d.size(); ++j)\n            if (cur < d[j])\n                --d[j];\n\n        (enc += d[i]) *= d.size()-i-1;\n    }\n\n    return enc;\n}\n\nvector<int> decode(Encoded e) {\n    vector<int> d(9);\n    for (size_t i=1; i<=9; ++i) {\n        d[9-i] = e % i;\n        e /= i;\n    }\n\n    for (size_t i=9; i--;)\n        for (size_t j=i+1; j<9; ++j)\n            if (d[i] <= d[j])\n                ++d[j];\n\n    return d;\n}\n\nWeight heucost(Encoded start, Encoded end) {\n    static const vector<int> dend=decode(end);\n    vector<int> dstart=decode(start);\n\n    Weight h=0;\n    for (size_t i=0; i<9; ++i)\n        for (size_t j=0; j<9; ++j)\n            if (dstart[i] == dend[j]) {\n                h += abs(i/3-j/3)+abs(i%3-j%3);\n                break;\n            }\n\n    return h;\n}\n\nvector<pair<Weight, Encoded>> pmoves(Encoded cur) {\n    vector<int> d=decode(cur);\n    size_t i;\n    for (i=0; d[i]; ++i);\n\n    vector<pair<Weight, Encoded>> p;\n    if (i/3 < 2) {\n        swap(d[i], d[i+3]);\n        p.push_back(make_pair(1, encode(d)));\n        swap(d[i], d[i+3]);\n    }\n    if (i/3 > 0) {\n        swap(d[i], d[i-3]);\n        p.push_back(make_pair(1, encode(d)));\n        swap(d[i], d[i-3]);\n    }\n    if (i%3 < 2) {\n        swap(d[i], d[i+1]);\n        p.push_back(make_pair(1, encode(d)));\n        swap(d[i], d[i+1]);\n    }\n    if (i%3 > 0) {\n        swap(d[i], d[i-1]);\n        p.push_back(make_pair(1, encode(d)));\n        swap(d[i], d[i-1]);\n    }\n    return p;\n}\n\nWeight astar(Encoded start, Encoded end) {\n    lp_queue<State> q;\n    q.push(State(heucost(start, end), 0, start));\n\n    Weight opt=INF;\n    vector<bool> visited(362881);\n    while (!q.empty()) {\n        State p=q.top(); q.pop();\n        Weight cur_cost=p.acost;\n        Encoded cur_state=p.encoded;\n        visited[cur_state] = true;\n\n        if (opt < cur_cost) continue;\n        if (cur_state == end)\n            if (opt > cur_cost)\n                opt = cur_cost;\n\n        vector<pair<Weight, Encoded>> ms=pmoves(cur_state);\n        for (pair<Weight, Encoded> m: ms) {\n            if (visited[m.second]) continue;\n\n            q.push(State(heucost(m.second, end), cur_cost+m.first, m.second));\n        }\n    }\n\n    return opt;\n}\n\nint main() {\n    vector<int> d(9);\n    for (size_t i=0; i<9; ++i)\n        scanf(\"%d\", &d[i]);\n\n    Encoded e=encode(d);\n\n    Weight c=astar(e, 46233);\n    printf(\"%d\\n\", c);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\n#define NUM 3\n\ntypedef struct STATUS{\n    int num;                    //????????????????????????????????°\n    int board[NUM * NUM];       //?????¢?????¶???\n    int x,y;                    //?????¢???0???????????????????????§?¨?\n}STATUS;\n\nbool checked[9*8*7*6*5*4*3*2*1];\n\n/* ?????¢?????¶????????????????????? */\nint change_number( int *board )\n{\n    int work[NUM*NUM];\n    static int fact_table[NUM*NUM] = {\n        40320, 5040, 720, 120, 24, 6, 2, 1, 0,\n    };\n    int j, k, value = 0;\n    memcpy( work, board, sizeof(int)*NUM*NUM );\n    for( j = 0; j < NUM*NUM - 1; j++ ){\n        value += fact_table[j] * work[j];\n        for( k = j + 1; k < NUM*NUM; k++ ){\n            if( work[j] < work[k] ) work[k]--;\n        }\n    }\n    return value;\n}\n\n\nint search(STATUS in){\n    \n    int x = 0, y = 0;\n    int chk_num,goal_num;\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    \n    int goal[9] = {1,2,3,4,5,6,7,8,0};\n    STATUS out;\n    goal_num = change_number(goal);\n    \n    //?????¢?????¶????????????????????????????????\\???\n    queue<STATUS> qu;\n    qu.push(in);\n    \n    //?????\\???????????????????????§?¶???????\n    while (!qu.empty()) {\n        \n        in = qu.front();\n        qu.pop();\n        chk_num = change_number(in.board);\n        if (goal_num == chk_num){\n            return in.num;\n        }\n        else{\n            checked[chk_num] = true;\n        }\n        for (int i = 0; i < 4; i++) {\n            //?????¢???0???????????????????????§?¨????x,y???????????????\n            x = in.x;\n            y = in.y;\n            if (x + dx[i] >=0 && x+dx[i] < NUM && y+dy[i] >=0 && y+dy[i] < NUM) {\n                memcpy(&out, &in, sizeof(STATUS));\n                swap(out.board[NUM*y + x], out.board[NUM*(y+dy[i]) + x + dx[i]] );\n                \n                chk_num = change_number(out.board);\n                if (checked[chk_num] == true){\n                    continue;\n                }\n                else{\n                    out.num++;\n                    out.x = x + dx[i];\n                    out.y = y + dy[i];\n                    qu.push(out);\n                }\n            }\n        }\n    }\n    \n    //?????¢???goal?????°??????????????£?????´??????-1?????????\n    return -1;\n}\n\n\nint main(){\n    \n    int val, ans;\n    \n    STATUS init;\n    init.num = 0;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            cin >> val;\n            init.board[i*NUM +j] = val;\n            if (val == 0){\n                init.x = j;\n                init.y = i;\n            }\n        }\n    }\n    \n    ans = search(init);\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\nvector<int> searched[9][9];\n\nclass board{\npublic:\n    int moves;\n    int wrongs;\n    int zero_place;\n    int cost;\n    vector<int> tiles;\n\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        tiles = num;\n        REP(i, 9){\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n        cost = wrongs + moves;\n    }\n\n    void board_to_int(){\n        int k = 0;\n        REP(i, 7)\n            k += (tiles[i+2] * pow(10, i));\n        for(int i = searched[tiles[0]][tiles[1]].size(); i > 0 ; i--)\n            if(k == searched[tiles[0]][tiles[1]][i-1])\n                return;\n        pq.push(board(tiles, moves+1));\n        searched[tiles[0]][tiles[1]].push_back(k);\n        return;\n    }\n\n    void move() {\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n};\n\nbool operator< (board b1, board b2){\n    return ((b1.cost > b2.cost) ? true : false);\n}\n\nint solve(){\n    pq.push(board(original, 0));\n    while(1){\n        auto target = pq.top();\n        if(target.wrongs == 0)\n            return target.cost;\n        pq.pop();\n        target.move();\n    }\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = solve();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n#include<map>\n#include<queue>\n#define Max 9\nint gg[Max]={1,2,3,4,5,6,7,8,0}, s[Max];\n\nint ff[4][2] = {0,-1,1,0,0,1,-1,0};\nint sum;\nstruct node\n{\n\tint a[Max];\n\tint step;\n};\nmap<int ,int >m;\n\n\nint bfs()\n{\n\tnode tt;\n\tmemcpy(tt.a,s,sizeof(s));\n\ttt.step = 0;\n\tqueue<node > q;\n\tq.push(tt);\n\twhile(!q.empty())\n\t{\n\t\tnode star = q.front();\n\t\tq.pop();\n\t\tint i;\n\t\tfor(i = 0;i<9;i++)\n\t\t\tif(star.a[i]==0)\n\t\t\t\tbreak;\n\t\tint y = i/3;\n\t\tint x = i%3;\n\t\tfor(i = 0;i<4;i++)\n\t\t{\n\t\t\tint tx = x + ff[i][0];\n\t\t\tint ty = y + ff[i][1];\n\t\t\tif(tx >= 0&&ty>=0&&ty<3&&tx<3)\n\t\t\t{\n\t\t\t\tnode end;\n\t\t\t\tmemcpy(end.a,star.a,sizeof(star.a));\n\t\t\t\tint k = ty*3+tx;\n\t\t\t\tswap(end.a[k],end.a[y*3+x]);\n\t\t\t\tint sum1 = 0;\n\t\t\t\tfor(int j = 0;j<9;j++)\n\t\t\t\t\tsum1 = sum1*10+end.a[j];\n\t\t\t\tif(!m[sum1])\n\t\t\t\t{\n\t\t\t\t\tm[sum1] = sum++;\n\t\t\t\t\tend.step = star.step+1;\n\t\t\t\t\tif(memcmp(end.a,gg,sizeof(gg))==0)\n\t\t\t\t\t\treturn end.step;\n\t\t\t\t\tq.push(end);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tint i,j;\n\n\twhile(~scanf(\"%d\",&s[0]))\n\t{\n\t\tm.clear();\n\t\tint k = s[0];\n\t\tsum = 1;\n\t\tfor(i = 1;i<9;i++)\n\t\t{\n\t\t\tscanf(\"%d\",&s[i]);\n\t\t\tk = k*10+s[i];\n\t\t}\n\t\tm[k] = sum++;\n\t\tif(memcmp(s,gg,sizeof(gg)==0))\n\t\t\tprintf(\"0\\n\");\n\t\telse printf(\"%d\\n\",bfs());\n\t\t\n\t}\t\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    for(int i = 0;i < N2;i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i = 0;i < N2;i++){\n    if(p.f[i] != (i + 1))return false;\n  }\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front();Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r = 0;r < 4;r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      v = u;\n      swap(v.f[u.space],v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if(!V[v]){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i = 0;i < N2;i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <cmath>\n#include <cstdlib>\nusing namespace std;\n\nstatic const int N = 3;\nstatic const int N2 = 9;\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n    for (int i = 0; i < N2; i++) \n        if (p.f[i] != (i + 1)) return false;\n    return true;\n}\n\nstring bfs(Puzzle s) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while (!Q.empty()) {\n        u = Q.front(); Q.pop();\n        if (isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; r++) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if (!V[v]) {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main() {\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n    Puzzle in;\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint getcost(int i, int j, int tmp)\n{\n    return abs(i - (tmp - 1) / 3) + abs(j - (tmp - 1) % 3);\n}\n\nbool solve(vector<vector<int> > puzzle, int cutoff, int cost)\n{\n    priority_queue<pair<int, vector<vector<int> > > > qu;\n    qu.push(make_pair(-cost, puzzle));\n    while(!qu.empty()){\n        vector<vector<int> > now = (qu.top()).second;\n        int nowcost = (qu.top()).first;\n        qu.pop();\n        int h = 0;\n        for(int i = 0; i < 3; i++){\n            for(int j = 0; j < 3; j++){\n                int tmp = now[i][j];\n                if(tmp != 0) h += getcost(i, j, tmp); \n            }\n        }\n        // cout << nowcost << endl;\n        if(h == 0){\n            return true;\n        }\n        for(int i = 0; i < 4; i++){\n            for(int j = 0; j < 4; j++){\n                // cout << now[i][j] << \" \";\n                if(now[i][j] == 0){\n                    int dx[4] = {0, 1, 0, -1};\n                    int dy[4] = {1, 0, -1, 0};\n                    for(int k = 0; k < 4; k++){\n                        int nx = i + dx[k];\n                        int ny = j + dy[k];\n                        if(nx < 0 || ny < 0 || nx >= 3 || ny >= 3) continue;\n                        int nowc = getcost(nx, ny, now[nx][ny]);\n                        int nextc = getcost(i, j, now[nx][ny]);\n                        // cout << now[nx][ny] << \" \" << nextc - nowc << endl;\n                        nowcost -= nextc - nowc + 1;\n                        swap(now[i][j], now[nx][ny]);\n                        if(-nowcost <= cutoff) qu.push(make_pair(nowcost, now));\n                        swap(now[i][j], now[nx][ny]);\n                        nowcost += nextc - nowc + 1;\n                    }\n                    i = 5;\n                    break;\n                }\n            }\n            // cout << endl;\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    vector<vector<int> > puzzle(3);\n    int cost = 0;\n    for(int i = 0; i < 3; i++){\n        for(int j = 0; j < 3; j++){\n            int tmp;\n            cin >> tmp;\n            puzzle[i].push_back(tmp);\n            if(tmp != 0) cost += getcost(i, j, tmp);\n        }\n    }\n    // cout << cost << endl;\n    for(int i = cost; ; i++){\n        if(solve(puzzle, i, cost)){\n            cout << i << endl;\n            break;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define b 3\n#define n2 9\n\nconst int dx[4]={-1,0,1,0};\nconst int dy[4]={0,-1,0,1};\nconst char dir[4]={'u','l','d','r'};\n\nstruct puzzle{\n    int f[n2];\n    int space;\n    string path;\n    bool operator < (const puzzle &p)const {\n        for(int i=0;i<n2;i++){\n            if(f[i]==p.f[i]){\n                continue;\n            }\n            return f[i]>p.f[i];\n        }\n        return false;\n    }\n};\n\nbool istarget(puzzle p)\n{\n    for(int i=0;i<n2;i++){\n        if(p.f[i]!=(i+1)){\n            return false;\n        }\n    }\n    return true;\n}\n\nstring bfs(puzzle s)\n{\n    queue<puzzle>q;\n    map<puzzle,bool>V;\n    puzzle u,v;\n    s.path=\"\";\n    q.push(s);\n    V[s]=true;\n    while(!q.empty()){\n        u=q.front();\n//        for(int i=0;i<n2;i++){\n//            cout<<u.f[i]<<\" \";\n//        }\n//        cout<<endl;\n        q.pop();\n        if(istarget(u)){\n            return u.path;\n        }\n        int sx=u.space/b;\n        int sy=u.space%b;\n//        cout<<sx<<\" \"<<sy<<endl;\n        for(int r=0;r<4;r++){\n            int tx=sx+dx[r];\n            int ty=sy+dy[r];\n            if(tx<0||ty<0||tx>=b||ty>=b){\n                continue;\n            }\n            v=u;\n            v.space=tx*b+ty;\n            swap(v.f[v.space],v.f[u.space]);\n            if(!V[v]){\n                V[v]=true;\n                v.path+=dir[r];\n                q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main()\n{\n    puzzle in;\n    for(int i=0;i<n2;i++){\n        scanf(\"%d\",&in.f[i]);\n        if(in.f[i]==0){\n            in.f[i]=n2;\n            in.space=i;\n        }\n    }\n    string ans=bfs(in);\n    cout<<ans.size()<<endl;\n    return 0;\n}\n/*\n1 3 0\n4 2 5\n7 8 6\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\nint f[N2];\nint space;\nstring path;\n\nbool operator < (const Puzzle &p)const{\nfor(int i=0;i<N2;i++){\nif(f[i]==p.f[i])continue;\nreturn f[i]>p.f[i];\n}\nreturn false;\n}\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\nfor(int i=0;i<N2;i++)\nif(p.f[i]!=(i+1))return false;\nreturn true;\n}\nstring bfs(Puzzle s){\nqueue<Puzzle>Q;\nmap<Puzzle,bool>V;\nPuzzle u,v;\ns.path=\"\";\nQ.push(s);\nV[s]=true;\nwhile(!Q.empty()){\n  u=Q.front();\n  Q.pop();\n  if(isTarget(u))return u.path;\n  int sx=u.space/N;\n  int sy=u.space%N;\n  for(int r=0 ; r<4 ; r++){\n    int tx=sx+dx[r];\n    int ty=sy+dy[r];\n    if(tx<0 || ty<0 || tx>=N || ty>=N)continue;\n    v=u;\n    swap(v.f[u.space], v.f[tx*N+ty]);\n    v.space=tx*N+ty;\n    if(!V[v]){\n      V[v]=true;\n      v.path+=dir[r];\n      Q.push(v);\n    }\n  }\n}\nreturn \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  for(int i=0 ; i<N2 ; i++){\n    cin >> in.f[i];\n    if(in.f[i]==0){\n    in.f[i]=N2;\n    in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout << ans.size() << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define NUM 3\n#define PRUNING 50\n\n#define MAX 500000000\nchar passed[MAX];\n\ntypedef struct STATUS{\n    int num;\n    int board[NUM][NUM];\n}STATUS;\n\ntypedef pair<int, int> cell;\n\nbool checkfinish(STATUS in){\n    \n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            if (i == NUM - 1 && j == NUM - 1) return true;\n            if(in.board[i][j] != val++) return false;\n        }\n    }\n    return true;\n}\n\nint rtnindex(STATUS in){\n    \n    int ret = 0;\n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            ret += val*in.board[i][j];\n            val *= 9;\n        }\n    }\n    return ret;\n}\n\n\nint backtrack(STATUS in, cell last_zero){\n\n    int x = 0, y = 0, ret = PRUNING;\n    cell zero;\n    STATUS out;\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    \n    if (in.num > ret) {\n        return ret;\n    }\n    \n    if (checkfinish(in)) {\n        return in.num;\n    }\n\n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            if(in.board[i][j] == 0){\n                x = zero.first = j;\n                y = zero.second = i;\n            }\n        }\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (x + dx[i] >=0 && x+dx[i] < NUM && y+dy[i] >=0 && y+dy[i] < NUM) {\n            if (last_zero.first == x+dx[i] && last_zero.second == y+dy[i]){ continue;\n            }\n            memcpy(&out, &in, sizeof(STATUS));\n            swap(out.board[y][x], out.board[y+dy[i]][x+dx[i]]);\n            int rtn = rtnindex(out);\n            if (passed[rtn] == 1) {\n                continue;\n            }\n            out.num++;\n            ret = min(ret, backtrack(out, zero));\n            passed[rtn] = 1;\n        }\n    }\n    return ret;\n}\n\n\nint main(){\n    \n    int val, ans;\n    \n    STATUS init;\n    init.num = 0;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            cin >> val;\n            init.board[i][j] = val;\n        }\n    }\n    \n    for (int i = 0; i < MAX; i++) passed[i] = 0;\n    \n    passed[rtnindex(init)] = 1;\n    \n    //?????????????????????????????????zero????????¨?????????????????????????????\\????????????\n    ans = backtrack(init, cell(-1,-1));\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n#define X 3\n#define Y 3\nint manhattan(int x1,int y1,int x2,int y2){\n\treturn abs(x1-x2)+abs(y1-y2);\n}\nint calc(vector<int>&v){\n\tint s=0;\n\tfor(int coor=0;coor<X*Y;coor++){\n\t\tif(v[coor]!=0){\n\t\t\ts+=manhattan(coor%X,coor/X,(v[coor]-1)%X,(v[coor]-1)/X);\n\t\t}else{\n\t\t\ts+=manhattan(coor%X,coor/X,X-1,Y-1);\n\t\t}\n\t\t\t\n\t}\n\treturn s;\n}\nint main(){\n\tint i=1,start_point;\n\tvector<int>start(X*Y),goal;\n\tfor(;i<X*Y;i++)goal.push_back(i);goal.push_back(0);\n\tfor(i=0;i<X*Y;i++){\n\t\tscanf(\"%d\",&start[i]);\n\t\tif(start[i]==0)start_point=i;\n\t}\n\tif(start==goal){puts(\"0\");return 0;}\n\n\tmap<vector<int>,pair<int,int> >mstart;\n\tqueue<vector<int> >q;\n\tmstart[start]=make_pair(start_point,0);\n\tq.push(start);\n\tfor(;!q.empty();){\n\t\tvector<int> v=q.front();\n\t\tint val=calc(v);\n\t\tq.pop();\n\t\tmap<vector<int>,pair<int,int> >&m=mstart;\n\t\tint coor=m[v].first,x=coor%X,y=coor/X;\n\t\tint depth=m[v].second;\n\t\tif(0<x){\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val)m[v]=make_pair(coor-1,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t}\n\t\tif(x<X-1){\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val)m[v]=make_pair(coor+1,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t}\n\t\tif(0<y){\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val)m[v]=make_pair(coor-X,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t}\n\t\tif(y<Y-1){\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val)m[v]=make_pair(coor+X,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//By Vlgd\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=3,NN=9;\nconst int dx[4]={0,1,-1,0};\nconst int dy[4]={1,0,0,-1};\nstruct Puz{\n\tint mp[NN],space,path;\n\tbool operator<(const Puz &p)const{\n\t\tfor(int i=0;i<NN;i++){\n\t\t\tif(mp[i]==p.mp[i]) continue;\n\t\t\treturn mp[i]>p.mp[i];\n\t\t}\n\t\treturn false;\n\t}\t\n};\nbool solved(Puz p){\n\tfor(int i=0;i<NN;i++) if(p.mp[i]!=(i+1)) return false;\n\treturn true;\n}\nint bfs(Puz s){\n\tmap<Puz,bool>tab;\n\tqueue<Puz>Q;\n\tPuz u,v;\n\ts.path=0;\n\ttab[s]=true;\n\tQ.push(s);\n\twhile(!Q.empty()){\n\t\tu=Q.front();Q.pop();\n\t\tif(solved(u)) return u.path;\n\t\tint sx=u.space/N,sy=u.space%N;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint tx=sx+dx[i],ty=sy+dy[i];\n\t\t\tv=u;\n\t\t\tif(tx<0||ty<0||tx>=N||ty>=N) continue;\n\t\t\tswap(v.mp[u.space],v.mp[tx*N+ty]);\n\t\t\tv.space=tx*N+ty;\n\t\t\tif(!tab[v]){\n\t\t\t\tv.path++;\n\t\t\t\ttab[v]=true;\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tPuz src;\n\tfor(int i=0;i<NN;i++){\n\t\tscanf(\"%d\",&src.mp[i]);\n\t\tif(src.mp[i]==0){\n\t\t\tsrc.mp[i]=NN;\n\t\t\tsrc.space=i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",bfs(src));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n#define N 3\ntypedef pair<int, int> P;\n\nstruct State {\n    int g, h;\n    string state;\n    P blank;\n    string path;\n    bool operator<(const State &a) const {\n        return g + h > a.g + a.h;\n    }\n};\n\nint d[5] = {-1, 0, 1, 0, -1};\nstring r[4] = {\"D\", \"R\", \"U\", \"L\"};\nstring ans_str = \"\";\nint ans[N][N], puzzle0[N][N], puzzle1[N][N];\nset<string> s;\npriority_queue<State> next_state;\nstring path;\n\nbool range(int y, int x) {return 0 <= y && y < N && 0 <= x && x < N;}\n\nint h0_dfs(int boundary, State state, int from) {\n    int find = -1;\n    s.insert(state.state); // visited\n\n    P blank = state.blank;\n    rep(i, 4) {\n        if (from == (i + 2) % 4) continue;\n        int y = d[i] + blank.first, x = d[i + 1] + blank.second; // next blank position\n        if (range(y, x)) { // can be replaced\n            string tmp = state.state; // next state (string)\n            int p = blank.first * N + blank.second, q = y * N + x;\n            if (N < 4) swap(tmp[p], tmp[q]);\n            else swap(tmp[2 * p], tmp[2 * q]), swap(tmp[2 * p + 1], tmp[2 * q + 1]);\n\n            if (tmp == ans_str) { // answer\n                find = state.g + 1;\n                path = state.path + r[i];\n                break;\n            }\n\n            if (state.g + 1 > boundary) continue; // estimate value is over boundary\n            find = h0_dfs(boundary, State{state.g + 1, 0, tmp, P(y, x), state.path + r[i]}, i);\n            if (find != -1) break; // find an answer\n        }\n    }\n    return find;\n}\n\nint ids_h0(string state, P blank) {\n    int i = 1, find = -1;\n    while(find == -1 && i < 81) {\n        s.clear();\n        find = h0_dfs(i, State{0, 0, state, blank, \"\"}, -1);\n        i++;\n    }\n    return find;\n}\n\nint main(){\n    // create answer's numbers\n    iota(ans[0], ans[0] + N * N, 1);\n    ans[N - 1][N - 1] = 0;\n    // create number\n    iota(puzzle0[0], puzzle0[0] + N * N, 0);\n    rep(i, N)rep(j, N) cin >> puzzle0[i][j];\n\n    string state = \"\";\n    P blank;\n    int manhattan = 0, wrong_place = 0;\n    rep(i, N)rep(j, N) {\n        state += to_string(puzzle0[i][j]);\n        ans_str += to_string(ans[i][j]);\n\n        if(puzzle0[i][j] == 0) blank = P(i, j);\n        else {\n            int num = puzzle0[i][j] - 1;\n            manhattan += (abs(num / N - i) + abs(num % N - j));\n            if (puzzle0[i][j] != ans[i][j]) wrong_place++;\n        }\n    }\n\n    if (manhattan == 0) { // the answer\n        cout << 0 << endl;\n    } else {\n        int steps;\n        next_state.push(State{0, wrong_place, state, blank, \"\"});\n        steps = ids_h0(state, blank);\n        cout << steps << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n\n\n  bool operator < (const Puzzle &p) const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i]) continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++)\n    if(p.f[i]!=(i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N) continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0;i<N2;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout << ans.size() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint H=3,W=3;\nset<vector<vector<short>>> memo;\n\nstruct STATE {\n    int f;\n    int g;\n    vector<vector<short>> b;\n\n    bool operator < (const STATE& tgt) const {\n\treturn f > tgt.f; // ?¨????\n    }\n};\ninline bool is_searched(const STATE& s) {\n    return (memo.find(s.b) != memo.end());\n}\ninline void searched(const STATE& s) {\n    memo.insert(s.b);\n}\ninline bool is_goal(const STATE& s) {\n    for(int i=0; i<H; i++) {\n\tfor(int j=0; j<W; j++) {\n\t    if( i == H-1 and j == W-1 )  return true;\n\t    if( s.b[i][j] != (i*W)+j+1 ) return false;\n\t}\n    }\n}\n\ninline void where0(const STATE& s, int& h, int& w) {\n    for(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t    if( s.b[i][j] == 0 ) {\n\t\th = i;\n\t\tw = j;\n\t    }\n}\n\ninline int manhattan_dis(const int tgt, const int h, const int w) {\n    if(tgt == 0 ) return 0;\n    int tgt_h = (tgt-1)/W;\n    int tgt_w = (tgt-1)%W;\n    return abs(tgt_h - h) + abs(tgt_w - w);\n}\n\ninline int heuristic(const vector<vector<short>>& b) {\n    int ans = 0;\n    for(int i=0; i<H; i++) {\n\tfor(int j=0; j<W; j++) {\n\t    ans += manhattan_dis(b[i][j],i,j);\n\t}\n    }\n    return ans;\n}\n\nconst int dx[] = { 1, 0,-1, 0}; \nconst int dy[] = { 0, 1, 0,-1};\ninline vector<STATE> adjcency(const STATE& cur) {\n    int h,w;   where0(cur,h,w);\n    vector<STATE> ans;\n    vector<vector<short>> b = cur.b;\n    \n    for(int i=0; i<4; i++) { // 4??????\n\tint nh = h+dy[i], nw = w+dx[i];\n\tif( nh >= 0 and nh < H and nw >= 0 and nw < W ) {\n\t    swap(b[nh][nw], b[h][w]);\n\t    int heu = heuristic(b);\n//\t    if( cur.g+1+heu <= 24 )\n\t\tans.push_back( STATE{cur.g+1+heu, cur.g+1, b} );\n\t    swap(b[nh][nw], b[h][w]);\n\t}\n    }\n    return ans;\n}\n    \nSTATE astar(const STATE& init) {\n    \n    priority_queue<STATE> pq;              // ?????????????°?????????????????????????????????????\n    pq.push(init);                         // ????????? STATE ????????£??????\n    \n    while( pq.size() ) {                   // ?????\\???????????????????????§????????§???\n\tSTATE cur = pq.top(); pq.pop();    // ?????£??¨????????????????????¶??????????????§???\n\tif( is_searched(cur) ) continue;   // ??????????????¢?´¢????????§...\n\tif( is_goal(cur) ) return cur;     // ??´??????????????´????????????\n\n\tsearched(cur);                     // cur ?????¢?´¢???????????¨????????????????????????\n\t\n\tfor(STATE& next : adjcency(cur)) { // ?????????????????¨?????????????????§???\n\t    if( is_searched(next) ) continue;\n\t    pq.push(next);\n\t}\n    }\n    // ???????????\\?????£??????????????¨??????...????????????????????£?????£????????¨???...\n    return init;\n}\n\nint main() {\n\n//    cin >> H >> W;\n    vector<vector<short>> b(H,vector<short>(W));\n    for(int i=0; i<H; i++) for(int j=0; j<W; j++) cin >> b[i][j];\n\n    int h = heuristic(b);\n    STATE init{h,0,b};\n    \n    STATE lst = astar(init);\n    cout << lst.g << endl;\n\n//    cout << memo.size() << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n\nusing namespace std;\n\nint checkTable[362880];\n\nvoid setNUM(int table[3][3], long long x){\n\tint S = 100000000;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int k=0;k<3;k++){\n\t\t\ttable[i][k] = x/S;\n\t\t\tx = x%S;\n\t\t\tS /= 10;\n\t\t}\n\t}\n}\n\nint getNUM(int x){\n\tswitch(x){\n\tcase 0:return 1;\n\tcase 1:return 1;\n\tcase 2:return 2;\n\tcase 3:return 6;\n\tcase 4:return 24;\n\tcase 5:return 120;\n\tcase 6:return 720;\n\tcase 7:return 5040;\n\tcase 8:return 40320;\n\t}\n\treturn -1;\n}\n\nlong long makeLong(int Table[3][3]){\n\treturn 100000000*Table[0][0]+10000000*Table[0][1]+1000000*Table[0][2]+\n            100000*Table[1][0]+10000*Table[1][1]+1000*Table[1][2]+ 100*Table[2][0]+\n            10*Table[2][1]+Table[2][2];\n}\n\nint translateORDER(int Table[3][3]){\n\tlong long x = makeLong(Table);\n\tint checkTable[9] = {0};\n\tlong long S = 100000000;\n\tint ret = 0,small_num_appear_count;\n\tfor(int i=8; i >= 0; i--){\n\t\tsmall_num_appear_count=0;\n\t\tfor(int k = 0; k < (x/S);k++){\n\t\t\tif(checkTable[k] == 1)small_num_appear_count++;\n\t\t}\n\t\tret += ((x/S)-small_num_appear_count)*getNUM(i);\n\t\tcheckTable[(x/S)]=1;\n\t\tx %= S;\n\t\tS /= 10;\n\t}\n\n\treturn ret;\n}\n\n\nint calcDiffSum(int table[3][3]){\n\tint sum = 0;\n\tfor(int row=0;row<3;row++){\n\t\tfor(int col=0;col<3;col++){\n\t\t\tif(table[row][col] != 0){\n\t\t\t\tsum += abs((table[row][col]-1)/3-row) + abs((table[row][col]-1)%3-col);\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\n\nint zeroLoc(int table[3][3]){\n\tint zero_loc;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int k=0;k<3;k++){\n\t\t\tif(table[i][k]==0){\n\t\t\t\tzero_loc=10*i+k;\n\t\t\t}\n\t\t}\n\t}\n\treturn zero_loc;\n}\n\nstruct Info{\n\tInfo(){data = count = 0;}\n\tInfo(long long arg_data,int arg_count){\n\t\tdata = arg_data;\n\t\tcount = arg_count;\n\t}\n\tlong long data;\n\tint count;\n};\n\nclass LongQ{\npublic:\n\tLongQ(){\n\t\tQ = new Info[362880];\n\t\thead = tail = num_of_data=0;\n\t}\n\n\tvoid enqueue(long long arg_data,int arg_count){\n\t\tQ[tail].count = arg_count;\n\t\tQ[tail].data = arg_data;\n\t\tnum_of_data++;\n\t\ttail = (tail+1)%362880;\n\t}\n\n\tInfo dequeue(){\n\t\tInfo ret = Q[head];\n\t\thead = (head+1)%362880;\n\t\tnum_of_data--;\n\t\treturn ret;\n\t}\n\n\tbool isEmpty(){\n\t\treturn num_of_data == 0;\n\t}\n\nprivate:\n\tInfo* Q;\n\tint head,tail,num_of_data;\n};\n\nint main(){\n\n\tfor(int i = 0; i < 362880;i++)checkTable[i]=-1;\n\n\tint table[3][3];\n\n\tfor(int i=0;i<3;i++){\n\t\tscanf(\"%d %d %d\",&table[i][0],&table[i][1],&table[i][2]);\n\t}\n\n\tcheckTable[translateORDER(table)]=0;\n\tLongQ queue;\n\n\tqueue.enqueue(makeLong(table),0);\n\n\tInfo tmpInfo;\n\n\twhile(true){\n\t\ttmpInfo=queue.dequeue();\n\n\t\tint tmpTable[3][3];\n\t\tsetNUM(tmpTable,tmpInfo.data);\n\t\tif(calcDiffSum(tmpTable)==0){\n\t\t\tprintf(\"%d\\n\",tmpInfo.count);\n\t\t\tbreak;\n\t\t}\n\n\t\tint next_table[4][3][3];\n\n\t\tfor(int a=0;a<4;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = tmpTable[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tswitch(zeroLoc(tmpTable)){\n\t\tcase 0: //??????\n\t\t\tswap(next_table[0][0][0],next_table[0][0][1]);\n\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[0])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[0]),tmpInfo.count+1);\n\t\t\t}\n\n\t\t\tswap(next_table[1][0][0],next_table[1][1][0]);\n\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[1])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[1]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tswap(next_table[0][0][1],next_table[0][0][0]);\n\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[0])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[0]),tmpInfo.count+1);\n\t\t\t}\n\n\t\t\tswap(next_table[1][0][1],next_table[1][0][2]);\n\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[1])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[1]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tswap(next_table[2][0][1],next_table[2][1][1]);\n\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[2])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[2]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\t//??????\n\t\t\tswap(next_table[0][0][2],next_table[0][0][1]);\n\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[0])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[0]),tmpInfo.count+1);\n\t\t\t}\n\n\t\t\tswap(next_table[1][0][2],next_table[1][1][2]);\n\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[1])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[1]),tmpInfo.count+1);\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tswap(next_table[0][1][0],next_table[0][0][0]);\n\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[0])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[0]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tswap(next_table[1][1][0],next_table[1][1][1]);\n\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[1])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[1]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tswap(next_table[2][1][0],next_table[2][2][0]);\n\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[2])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[2]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tswap(next_table[0][1][1],next_table[0][0][1]);\n\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[0])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[0]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tswap(next_table[1][1][1],next_table[1][1][0]);\n\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[1])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[1]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tswap(next_table[2][1][1],next_table[2][1][2]);\n\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[2])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[2]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tswap(next_table[3][1][1],next_table[3][2][1]);\n\t\t\tif(checkTable[translateORDER(next_table[3])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[3])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[3]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tswap(next_table[0][1][2],next_table[0][0][2]);\n\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[0])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[0]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tswap(next_table[1][1][2],next_table[1][1][1]);\n\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[1])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[1]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tswap(next_table[2][1][2],next_table[2][2][2]);\n\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[2])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[2]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\tswap(next_table[0][2][0],next_table[0][1][0]);\n\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[0])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[0]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tswap(next_table[1][2][0],next_table[1][2][1]);\n\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[1])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[1]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 21:\n\t\t\tswap(next_table[0][2][1],next_table[0][2][0]);\n\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[0])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[0]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tswap(next_table[1][2][1],next_table[1][1][1]);\n\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[1])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[1]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tswap(next_table[2][2][1],next_table[2][2][2]);\n\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[2])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[2]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 22:\n\t\t\tswap(next_table[0][2][2],next_table[0][1][2]);\n\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[0])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[0]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tswap(next_table[1][2][2],next_table[1][2][1]);\n\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\tcheckTable[translateORDER(next_table[1])]=tmpInfo.count;\n\t\t\t\tqueue.enqueue(makeLong(next_table[1]),tmpInfo.count+1);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<unordered_set>\nusing namespace std;\n\nconst int D_x[4] = { 0,1,0,-1 };\nconst int D_y[4] = { 1,0,-1,0 };\nconst int ANS = 123456780;\n\nvoid setNum(int puzzle[3][3],int n) {\n\tfor (int i = 2; i >= 0; i--) {\n\t\tfor (int j = 2; j >= 0; j--) {\n\t\t\tpuzzle[i][j] = n % 10;\n\t\t\tn /= 10;\n\t\t}\n\t}\n}\n\nint getNum(int puzzle[3][3]) {\n\tint res = 0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tres *= 10;\n\t\t\tres += puzzle[i][j];\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid find_0(int puzzle[3][3], int& x, int& y) {\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tif (puzzle[i][j] == 0) {\n\t\t\t\tx = j;\n\t\t\t\ty = i;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve(int puzzle[3][3]) {\n\tqueue<int> q;\n\tunordered_set<int> table;\n\tint cnt = 1;\n\n\tq.push(getNum(puzzle));\n\tif (q.front() == ANS)return 0;\n\twhile (true) {\n\t\tint s = q.size();\n\n\t\tfor (int i = 0; i < s; i++) {\n\t\t\tint x, y;\n\t\t\tfind_0(puzzle, x, y);\n\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tint X = x + D_x[j];\n\t\t\t\tint Y = y + D_y[j];\n\t\t\t\tif (X < 0 || Y < 0 || X >= 3 || y >= 3)continue;\n\t\t\t\tsetNum(puzzle, q.front());\n\t\t\t\tswap(puzzle[y][x], puzzle[Y][X]);\n\n\t\t\t\tint n = getNum(puzzle);\n\t\t\t\tif (n == ANS) {\n\t\t\t\t\treturn cnt;\n\t\t\t\t}\n\t\t\t\tif (table.count(n) == 0) {\n\t\t\t\t\ttable.insert(n);\n\t\t\t\t\tq.push(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.pop();\n\t\t}\n\t\tcnt++;\n\t}\n}\n\nint main() {\n\tint puzzle[3][3];\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tcin >> puzzle[i][j];\n\t\t}\n\t}\n\n\tcout << solve(puzzle) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <queue>\n#include <unistd.h>\n#include <set>\nusing namespace std;\n\nclass puzzle{\npublic:\n  int num;\n  pair<int, int> zid;\n  int v[3][3];\n  bool operator<(const puzzle& another) const{\n    for(int i = 0; i < 3; i++){\n      for(int j = 0; j < 3; j++){\n        if(v[i][j] < another.v[i][j]) return false;\n        else if(v[i][j] > another.v[i][j]) return true;\n      }\n    }\n    return false;\n  }\n  void print(){\n    for(int i = 0; i < 3; i++){\n      for(int j = 0; j < 3; j++){\n        cout << v[i][j] << \" \";\n      }\n      cout << endl;\n    }\n  }\n};\n\nbool istarget(puzzle p){\n  for(int i = 0; i < 3; i++){\n    for(int j = 0; j < 3; j++){\n      if(p.v[i][j] != (i * 3 + j  + 1) % 9) return false;\n    }\n  }\n  return true;\n}\n\nvoid solve(){\n  puzzle p, ans;\n  for(int i = 0; i < 3; i++){\n    for(int j = 0; j < 3; j++){\n      cin >> p.v[i][j];\n      if(p.v[i][j] == 0) p.zid = make_pair(i, j);\n    }\n  }\n  p.num = 0;\n  map<puzzle, bool> mp;\n  mp[p] = true;\n  queue<puzzle> q;\n  q.push(p);\n  while(q.size() > 0){\n    puzzle c = q.front(), n; q.pop();\n    //cout << c.num << endl;\n    //c.print();\n    if(istarget(c)){\n      cout << c.num << endl;\n      break;\n    }\n    int x = c.zid.first, y = c.zid.second;\n    n = c;\n    n.num++;\n    if(x >= 1){\n      swap(n.v[x][y], n.v[x - 1][y]);\n      n.zid.first--;\n      if(mp[n] == false){\n        q.push(n);\n        mp[n] = true;\n      }\n    }\n    n = c;\n    n.num++;\n    if(x <= 1){\n      swap(n.v[x][y], n.v[x + 1][y]);\n      n.zid.first++;\n      if(mp[n] == false){\n        q.push(n);\n        mp[n] = true;\n      }\n    }\n    n = c;\n    n.num++;\n    if(y >= 1){\n      swap(n.v[x][y], n.v[x][y - 1]);\n      n.zid.second--;\n      if(mp[n] == false){\n        q.push(n);\n        mp[n] = true;\n      }\n    }\n    n = c;\n    n.num++;\n    if(y <= 1){\n      swap(n.v[x][y], n.v[x][y + 1]);\n      n.zid.second++;\n      if(mp[n] == false){\n        q.push(n);\n        mp[n] = true;\n      }\n    }\n  }\n  return;\n}\nint main(){\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nbitset<362880> ht;\ntypedef pair<int[9],int> state;\nqueue<state> q;\nconst int goal=46233;\n\nint hash(const int *board)\n{\n    const static int fact[]={40320,5040,720,120,24,6,2,1};\n    int h=0;\n    int work;\n    for(int i=0; i<8; i++) {\n        work=board[i];\n        for(int j=0; j<i; j++) {\n            if(board[j]<board[i]) --work;\n        }\n        h+=work*fact[i];\n    }\n    return h;\n}\n\nint search()\n{\n    while(!q.empty()) {\n        state now=q.front();\n        if(hash(now.first)==goal) return now.second;\n        q.pop();\n        int f;\n        for(f=0; now.first[f]; f++);\n        if(f%3!=0) {\n            state next=now;\n            next.second++;\n            swap(next.first[f], next.first[f-1]);\n            int h=hash(next.first);\n            if(!ht.test(h)) {\n                ht.set(h);\n                q.push(next);\n            }\n        }\n        if((f+1)%3!=0) {\n            state next=now;\n            next.second++;\n            swap(next.first[f], next.first[f+1]);\n            int h=hash(next.first);\n            if(!ht.test(h)) {\n                ht.set(h);\n                q.push(next);\n            }\n        } \n        if(f>=3) {\n            state next=now;\n            next.second++;\n            swap(next.first[f], next.first[f-3]);\n            int h=hash(next.first);\n            if(!ht.test(h)) {\n                ht.set(h);\n                q.push(next);\n            }\n        } \n        if(f<6) {\n            state next=now;\n            next.second++;\n            swap(next.first[f], next.first[f+3]);\n            int h=hash(next.first);\n            if(!ht.test(h)) {\n                ht.set(h);\n                q.push(next);\n            }\n        } \n    }\n    return -1;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    state board;\n    board.second=0;\n    for(int i=0; i<9; i++) cin>>board.first[i];\n    ht.set(hash(board.first));\n    q.push(board);\n    cout<<search()<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\ntypedef struct {\n  int f[N2];\n  int space:\n  string path;\n\n  bool operator < (const puzzle &p) const {\n    for(int i=0; i<N2; i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n} Puzzle;\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1);\nstatic const char dir[4] = {'u', 'l', 'd','r'};\n\nbool isTarget(Puzzle p) {\n  for(int i=0; i<N2; i++)\n    if(p.f[o] != (i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space/N;\n    int sy u.space%N;\n    for(int r=0; r<4; r++){\n      int tx = sx+dx[r];\n      int ty = sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n      v=u;\n      swap(v.f[u.space], v.f[tx*N+ty]);\n      v.space = tx*N+ty;\n      if(!V[v]){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"usdolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0; i<N2; i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in .space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef complex<int> P;\ntypedef long long ll;\n\nP Dir[4] = {\n\tP(-1, 0),\n\tP(0, -1),\n\tP(1, 0),\n\tP(0, 1),\n};\n\nll pow17[15];\n\nvoid Init() {\n\tpow17[0] = 1;\n\tfor (int i = 1; i < 15; ++i) {\n\t\tpow17[i] = pow17[i-1]*17;\n\t}\n}\n\nclass Puzzle {\nprivate:\n\tint W, H;\n\tint holes;\n\tint board[4][4];\n\tint coe[4][4];\n\tmap<int, P> rboard;\n\tll hash, gHash;\n\tvector< pair<P, P> > psl;\n\npublic:\n\tPuzzle(int W, int H) : W(W), H(H) {\n\t\tinit();\n\t}\n\tvoid init() {\n\t\tholes = 0;\n\t\trboard.clear();\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tint k = y * W + x + 1;\n\t\t\t\tboard[y][x] = k;\n\t\t\t}\n\t\t}\n\t\tinitCoe();\n\t\tinitHash();\n\t}\n\tvoid setTile(int x, int y, int v) {\n\t\tint pv = board[y][x];\n\t\tif (pv < 0) --holes;\n\t\tif (v < 0) ++holes;\n\t\tboard[y][x] = v;\n\t\trboard[v] = P(x, y);\n\t\thash += ((v < 0 ? 0 : v) - (pv < 0 ? 0 : pv)) * pow17[coe[y][x]];\n\t}\n\tvoid initCoe() {\n\t\tfor (int y = 0, k = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (getTile(x, y) != 0) {\n\t\t\t\t\tcoe[y][x] = k++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcoe[y][x] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgHash = 0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tint v = getTile(x, y);\n\t\t\t\tif (v > 0) {\n\t\t\t\t\tint x = (v-1)%W, y = (v-1)/W;\n\t\t\t\t\tgHash += v * pow17[coe[y][x]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint getTile(int x, int y) {\n\t\treturn board[y][x];\n\t}\n\tbool swap(int x1, int y1, int x2, int y2) {\n\t\tint v1 = getTile(x1, y1), v2 = getTile(x2, y2);\n\t\tif (v1 == 0 || v2 == 0 || (v1 < 0 && v2 == 0)) return false;\n\t\tsetTile(x1, y1, v2);\n\t\tsetTile(x2, y2, v1);\n\t\treturn true;\n\t}\n\tbool isComplete() {\n\t\treturn hash == gHash;\n/*\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tint k = y * W + x + 1;\n\t\t\t\tint v = board[y][x];\n\t\t\t\tif (v > 0 && k != v) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n*/\n\t}\n\tbool isOut(int x, int y ) {\n\t\treturn x < 0 || x >= W || y < 0 || y >= H;\n\t}\n\tvoid move(int dir) {\n\t\tdir = (dir + 2) % 4;\n\t\tvector< pair<P, int> > v;\n\t\tfor (int i = 0; i < holes; ++i) {\n\t\t\tP& p = rboard[-(i+1)];\n\t\t\tint x = p.real(), y = p.imag();\n\t\t\tint nx = x + Dir[dir].real(), ny = y + Dir[dir].imag();\n\t\t\tif (isOut(nx, ny)) continue;\n\t\t\tif (getTile(nx, ny) < 0) continue;\n\t\t\tv.push_back( pair<P, int>(p, getTile(nx, ny)) );\n\t\t}\n\t\tpsl.clear();\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\tint x = v[i].first.real(), y = v[i].first.imag();\n\t\t\tP p = rboard[v[i].second];\n\t\t\tif ( swap(x, y, p.real(), p.imag()) ) {\n\t\t\t\tpsl.push_back( pair<P, P>(P(x, y), p) );\n\t\t\t}\n\t\t}\n\t}\n\tvoid prev() {\n\t\tfor (int i = psl.size()-1; i >= 0; --i) {\n\t\t\tP &p1 = psl[i].first, &p2 = psl[i].second;\n\t\t\tswap(p1.real(), p1.imag(), p2.real(), p2.imag());\n\t\t}\n\t}\n\tvoid draw() {\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (x) cout << \" \";\n\t\t\t\tprintf(\"%2d\", getTile(x, y));\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tll getHash() {\n\t\treturn hash;\n\t}\n\tvoid initHash() {\n\t\thash = 0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tint v = getTile(x, y);\n\t\t\t\tif (v != 0) {\n\t\t\t\t\thash += (v < 0 ? 0 : v) * pow17[coe[y][x]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid setHash(ll h) {\n\t\tint k = 0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (getTile(x, y) != 0) {\n\t\t\t\t\tint v = h%17; if (v == 0) v = --k;\n\t\t\t\t\tsetTile(x, y, v);\n\t\t\t\t\th /= 17;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint getH() {\n\t\tint res = 0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tint v = getTile(x, y);\n\t\t\t\tif (v > 0) {\n\t\t\t\t\tint gx = (v-1)%W, gy = (v-1)/W;\n\t\t\t\t\tres += abs(gx-x) + abs(gy-y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tint getHoles() {\n\t\treturn holes;\n\t}\n\tll getGHash() {\n\t\treturn gHash;\n\t}\n};\n\nstruct Node {\n\tll hash;\n\tint step, h;\n};\nbool operator >(const Node& n1, const Node& n2) {\n\treturn n1.h > n2.h;\n}\n\nint main() {\n\tInit();\n\n//\tint W, H; cin >> W >> H;\n\tint W = 3, H = 3;\n\tPuzzle puzzle(W, H);\n\tfor (int y = 0; y < H; ++y) {\n\t\tfor (int x = 0; x < W; ++x) {\n\t\t\tint v; cin >> v;\n\t\t\tif (v == 0) v = -1;\n\t\t\tpuzzle.setTile(x, y, v);\n\t\t}\n\t}\n\tpuzzle.initCoe();\n\tpuzzle.initHash();\n\n\tint s = 0;\n\n\tset<ll> gone;\n\tpriority_queue<Node, vector<Node>, greater<Node> > Q; Q.push((Node){puzzle.getHash(), 0, puzzle.getH()});\n\twhile ( !Q.empty() ) {\n\t\tNode node = Q.top(); Q.pop();\n\t\tll hash = node.hash;\n\t\tint step = node.step;\n\n\t\tif (step > s) {\n//\t\t\ts = step;\n//\t\t\tcout << s << endl;\n\t\t}\n\n\t\tif (gone.count(hash)) continue;\n\t\tgone.insert(hash);\n\n\t\tif (puzzle.getGHash() == hash) {\n\t\t\tcout << step << endl;\n\t\t\tbreak;\n\t\t}\n\n\t\tpuzzle.setHash(hash);\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tif (i) puzzle.prev();\n\t\t\tpuzzle.move(i);\n\t\t\tll h = puzzle.getHash();\n\t\t\tif (gone.count(h) == 0) {\n\t\t\t\tQ.push((Node){h, step+1, step*puzzle.getHoles()+puzzle.getH()});\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// ------ Includes ------ //\n\n#include <map>\n#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\n\n// ------ Directions ------ //\n\nconst int dx[4] = { 0, 1, 0, -1 };\nconst int dy[4] = { 1, 0, -1, 0 };\n\n\n// ------ BFS ------ //\n\nint BFS(vector<vector<int> > p)\n{\n\t// ------ Initialize ------ //\n\n\tmap<vector<vector<int> >, int> D;\n\n\tqueue<pair<vector<vector<int> >, int> > que;\n\n\tD[p] = 1; que.push(make_pair(p, 1));\n\n\n\t// ------ Search ------ //\n\n\twhile (!que.empty())\n\t{\n\t\tpair<vector<vector<int> >, int> p1 = que.front(); que.pop();\n\n\n\t\t// ------ 0 Searching ------ //\n\n\t\tint tx = -1, ty = -1;\n\n\t\tfor (int i = 0; i < p1.first.size(); i++)\n\t\t{\n\t\t\tfor (int j = 0; j < p1.first[i].size(); j++)\n\t\t\t{\n\t\t\t\tif (p1.first[i][j] == 0)\n\t\t\t\t{\n\t\t\t\t\ttx = j; ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\t// ------ Moving ------ //\n\n\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t{\n\t\t\tif (0 <= tx + dx[dir] && tx + dx[dir] < p1.first[0].size() && 0 <= ty + dy[dir] && ty + dy[dir] < p1.first.size())\n\t\t\t{\n\t\t\t\tvector<vector<int> > p2 = p1.first;\n\n\t\t\t\tswap(p2[ty][tx], p2[ty + dy[dir]][tx + dx[dir]]);\n\n\t\t\t\tD[p2] = p1.second + 1;\n\n\t\t\t\tque.push(make_pair(p2, p1.second + 1));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn D[{ { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 0 } }];\n}\n\nint main()\n{\n\tvector<vector<int> > board(3, vector<int>(3, -1));;\n\n\tfor (int i = 0; i < board.size(); i++)\n\t{\n\t\tfor (int j = 0; j < board[i].size(); j++)\n\t\t{\n\t\t\tcin >> board[i][j];\n\t\t}\n\t}\n\n\tcout << BFS(board) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <string>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i != N2; ++i) {\n            if ( f[i] == p.f[i] ) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle s) {\n    for (int i = 0; i != N2; ++i) {\n        if ( s.f[i] == i + 1 ) continue;\n        return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle s) {\n    queue<Puzzle> Q;\n    Puzzle u, v;\n    map<Puzzle, bool> V;\n    V[s] = true;\n    s.path = \"\";\n    Q.push(s);\n    \n    while ( !Q.empty() ) {\n        u = Q.front(); Q.pop();\n        if ( isTarget(u) ) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r != 4; ++r) {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if ( !V[v] ) {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main()\n{\n    Puzzle in;\n    \n    for (int i = 0; i != N2; ++i) {\n        cin >> in.f[i];\n        if ( in.f[i] == 0 ) {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <queue>\n\nint main() {\n    std::vector<int> pazzle(9);\n    for (int i = 0; i < 9; i++) {\n        std::cin >> pazzle[i];\n    }\n\n    std::map<std::vector<int>, int> m;\n    std::queue <std::pair<std::vector<int>, int> > q;\n\n    m[pazzle] = 0;\n    m[{1, 2, 3, 4, 5, 6, 7, 8, 0}] = 10000;\n\n    q.push({pazzle, 0});\n    while (!q.empty()) {\n        pazzle = q.front().first;\n        int num = q.front().second;\n        q.pop();\n        if (m[{1, 2, 3, 4, 5, 6, 7, 8, 0}] != 0 && m[{1, 2, 3, 4, 5, 6, 7, 8, 0}]  < num) break;\n        //if (m[pazzle] != 0 && m[pazzle] <= num) continue;\n\n        int space = std::find(pazzle.begin(), pazzle.end(), 0) - pazzle.begin();\n\n        if (space > 2) {\n            std::swap(pazzle[space], pazzle[space - 3]);\n            if (m.find(pazzle) == m.end() || m[pazzle] > num + 1) {\n                m[pazzle] = num + 1;\n                q.push({pazzle, num + 1});\n            }\n            std::swap(pazzle[space], pazzle[space - 3]);\n        }\n        if (space < 6) {\n            std::swap(pazzle[space], pazzle[space + 3]);\n            if (m.find(pazzle) == m.end() || m[pazzle] > num + 1) {\n                m[pazzle] = num + 1;\n                q.push({ pazzle, num + 1 });\n            }\n            std::swap(pazzle[space], pazzle[space + 3]);\n        }\n        if (space % 3 != 0) {\n            std::swap(pazzle[space], pazzle[space - 1]);\n            if (m.find(pazzle) == m.end() || m[pazzle] > num + 1) {\n                m[pazzle] = num + 1;\n                q.push({ pazzle, num + 1 });\n            }\n            std::swap(pazzle[space], pazzle[space - 1]);\n        }\n        if (space % 3 != 2) {\n            std::swap(pazzle[space], pazzle[space + 1]);\n            if (m.find(pazzle) == m.end() || m[pazzle] > num + 1) {\n                m[pazzle] = num + 1;\n                q.push({ pazzle, num + 1 });\n            }\n            std::swap(pazzle[space], pazzle[space + 1]);\n        }\n    }\n\n    std::cout << m[{1, 2, 3, 4, 5, 6, 7, 8, 0}] << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\nconst double PI = acos(-1);\nconst ll MOD = 1000000007;\nusing Graph = vector<vector<int>>;\n\nint main() {\n  Graph board(3, vector<int>(3)),last(3, vector<int>(3));\n  rep(i,3) {\n    rep(j,3) cin >> board[i][j];\n  }\n\n  last = {\n    {1,2,3},\n    {4,5,6},\n    {7,8,0}\n  };\n\n  map<Graph, int> m;\n  m[board] = 0;\n  queue <Graph> que;\n  que.push(board);\n\n  const vector<int> dy = {-1,0,0,1};\n  const vector<int> dx = {0,-1,1,0};\n\n  while(!que.empty()) {\n    Graph v = que.front();\n    int count = m[v];\n    que.pop();\n    int y,x;\n    rep(i,3) {\n      rep(j,3) {\n        if (v[i][j] == 0) {\n          y = i;\n          x = j;\n        }\n      }\n    }\n\n    rep(i,4) {\n      int yy = y + dy[i];\n      int xx = x + dx[i];\n      if (yy < 0 || yy >= 3 || xx < 0 || xx >= 3) continue;\n      swap(v[y][x],v[yy][xx]);\n      if (!m.count(v)) {\n        que.push(v);\n        m[v] = count + 1;\n        if (m.count(last)) goto OUT;\n      }\n      swap(v[y][x],v[yy][xx]);\n    }\n  }\n\n  OUT:\n\n  cout << m[last] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n  \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n  \nusing namespace std;\n  \ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n  \nconst int INF=1<<29;\nconst double EPS=1e-9;\n  \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nconst int boardw = 3;\n\nstruct BOARD {\n    int map[boardw][boardw];\n};\n \nstd::queue<BOARD> q;\nstd::map<BOARD,int> m;\n \nbool check(BOARD b) {\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            if (b.map[i][j] == 0) continue;\n            int tgt = i * boardw + j + 1;\n            if (b.map[i][j] != tgt) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint dfs(BOARD &b, int depth) {\n    if (depth == 0) {\n        if (check(b)) {\n            return 1;\n        } else {\n            return -1;\n        }\n    }\n\n    int px, py;\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            if (b.map[i][j] == 0) {\n                px = j;\n                py = i;\n            }\n        }\n    }\n    int dx[] = {0, 1, 0, -1};\n    int dy[] = {1, 0, -1, 0};\n    for (int k = 0; k < 4; k++) {\n        int tx = px + dx[k];\n        int ty = py + dy[k];\n        if (tx < 0 || tx >= boardw || ty < 0 || ty >= boardw) continue;\n        int temp = b.map[py][px];\n        b.map[py][px] = b.map[ty][tx];\n        b.map[ty][tx] = temp;\n        \n        int ret = dfs(b, depth - 1);\n        \n        temp = b.map[py][px];\n        b.map[py][px] = b.map[ty][tx];\n        b.map[ty][tx] = temp;\n        if (ret != -1) return ret;\n    }\n    return -1;\n}\n \nint main(int argc, char const *argv[]) {\n    BOARD b;\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            cin >> b.map[i][j];\n        }\n    }\n    for (int i = 1; i <= 45; i++) {\n        int ret = dfs(b, i);\n        if (ret == 1) {\n            cout << i << endl;\n            return 0;\n        }\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n#define N 3\n#define NN 9\nusing namespace std;\n\nstruct Puzzle{\n  int f[NN];\n  int space;\n  string path;\n  bool operator < (const Puzzle &p)const{\n    for(int i=0;i<NN;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic int dx[4]={1,0,-1,0};\nstatic int dy[4]={0,1,0,-1};\nstatic char dir[4]={'r','d','l','u'};\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<NN;i++)\n    if(p.f[i]!=(i+1))return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle>Q;\n  map<Puzzle,bool>V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n  \n  while(!Q.empty()){\n    u=Q.front();\n    Q.pop();\n    if(isTarget(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N)continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  for(int i=0;i<NN;i++){\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i]==0){\n      in.f[i]=NN;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  printf(\"%lu\\n\",ans.size());\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n\tint f[N2];\n\tint space;\n\tstring path;\n\t\n\tbool operator < (const Puzzle &p)const {\n\t\tfor(int i=0;i < N2;++i){\n\t\t\tif(f[i] == p.f[i]) continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n\tfor(int i=0;i < N2;++i)\n\t\tif(p.f[i] != (i+1)) return false;\n\treturn true;\n}\n\nstring bfs(Puzzle s){\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\t\n\twhile(!Q.empty()){\n\t\tu = Q.front(), Q.pop();\n\t\tif(isTarget(u)) return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor(int r=0;r < 4;++r){\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx*N+ty]);\n\t\t\tv.space = tx*N + ty;\n\t\t\tif(!V[v]){\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main(){\n\tPuzzle in;\n\t\n\tfor(int i=0;i < N2;++i){\n\t\tcin >> in.f[i];\n\t\tif(in.f[i] == 0){\n\t\t\tin.f[i] = N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nstatic const int N = 3;\nstatic const int N2 = 9;\n\nclass Puzzle {\npublic:\n    int piece[N2];\n    int space;\n    string path;\n\n    Puzzle() {}\n\n    Puzzle(int space, string path) : space(space), path(path) {}\n\n    bool operator<(const Puzzle &p) const {\n        for(int i = 0; i < N2; i++)\n        {\n            if(piece[i] == p.piece[i])\n                continue;\n            return piece[i] < p.piece[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++)\n        if (p.piece[i] != (i + 1)) // 不正解\n            return false;\n\n    return true;\n}\n\nstring bfs(Puzzle start)\n{\n    queue<Puzzle> Q;\n    map<Puzzle, bool> is_visit;\n    Puzzle u, v;\n    start.path = \"\";\n    Q.push(start);\n    is_visit[start] = true;\n\n    while (!Q.empty())\n    {\n        u = Q.front();\n        Q.pop();\n\n        if (isTarget(u))\n            return u.path;\n\n        int sx = u.space / N; // 空きマスのx座標\n        int sy = u.space % N; // 空きマスのy座標\n        for (int direct = 0; direct < 4; direct++)\n        {\n            int tx = sx + dx[direct]; // 遷移先の空きマスのx座標\n            int ty = sy + dy[direct]; // 遷移先の空きマスのy座標\n            if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n                continue; // 枠外にでたら無視\n            v = u;\n            swap(v.piece[u.space], v.piece[tx * N + ty]); // ピースを移動\n            v.space = tx * N + ty;\n            if(!is_visit[v])\n            {\n                is_visit[v] = true;\n                v.path += dir[direct];\n                Q.push(v);\n            }\n        }\n    }\n\n    return \"unsolvable\";\n}\n\nint main()\n{\n    Puzzle input;\n\n    for(int i = 0; i < N2; i++)\n    {\n        cin >> input.piece[i];\n        if(input.piece[i] == 0)\n        {\n            input.piece[i] = N2;\n            input.space = i;\n        }\n    }\n\n    string answer = bfs(input);\n    cout << answer.size() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,s,e) for((i)=(s);(i)<(int)(e);(i)++)\n#define REP(i,e) FOR(i,0,e)\n\n#define all(o) (o).begin(), (o).end()\n#define psb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nconst double EPS = 1e-10;\n\nconst int N = 3;\nconst int M = 9;\nconst int dx[] = {1, 0, -1,  0};\nconst int dy[] = {0, 1,  0, -1};\nconst char dir[] = {'r', 'u', 'l', 'd'};\n\ntypedef struct puzzle_def {\n  int f[M];\n  int space;\n  string path;\n\n  bool operator < (const puzzle_def &p) const {\n    for (int i=0; i<M; i++) \n      if (f[i] < p.f[i])\n        return true;\n      else if (f[i] > p.f[i])\n        return false;\n    return false;\n  }\n\n/*\n  bool operator < (const puzzle_def &l, const puzzle_def &r) {\n    for (int i=0; i<M; i++) \n      if (l.f[i] < r.f[i])\n        return true;\n      else if (l.f[i] > r.f[i])\n        return false;\n    return false; \n  }\n*/\n\n} pzl;\n\nbool is_target(pzl p) {\n  for (int i=0; i<M; i++)\n    if (p.f[i] != (i+1)) return false;\n  return true;\n}\n\nstring bfs(pzl s) {\n  queue<pzl> q;\n  map<pzl, bool> past;\n  s.path = \"\";\n  q.push(s);\n  past[s] = true;\n\n  while (q.size()) {\n    pzl u = q.front(); q.pop(); \n    if (is_target(u)) return u.path;\n    int x = u.space / N, y = u.space % N;\n    for (int i=0; i<4; i++) {\n      int nx = x + dx[i]; \n      int ny = y + dy[i]; \n      if (nx<0 || nx>=N || ny<0 || ny>=N) continue;\n      pzl v = u;\n      swap(v.f[v.space], v.f[nx * N + ny]);\n      v.space = nx * N + ny;\n      if (!past[v]) {\n        past[v] = true;\n        v.path += dir[i];\n        q.push(v);\n      }\n    }\n  }\n  return \"failed.\";\n}\n\nint main() {\n  pzl ini;\n  for (int i=0; i<M; i++) {\n    scanf(\"%d \", &(ini.f[i])); \n    if (!ini.f[i]) {\n      ini.f[i] = M;\n      ini.space = i;\n    }\n  }\n\n  string res = bfs(ini);\n  cout << res.size() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cstddef>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <utility>\n\nstatic const int N = 3;\nstatic const int N2 = N * N;\n\nstatic std::array<int, 4> dx{0, -1, 0, 1};\nstatic std::array<int, 4> dy{1, 0, -1, 0};\nstatic std::array<char, 4> dchar{'u', 'l', 'd', 'r'};\n\nstruct Puzzle\n{\n    std::array<int, N2> state;\n    int space;\n    std::string path = \"\";\n\n    // For map comparison\n    bool operator<(const Puzzle &p) const\n    {\n        for (size_t i = 0; i < state.size(); ++i)\n        {\n            if (state[i] != p.state[i])\n            {\n                return state[i] < p.state[i];\n            }\n        }\n\n        return false;\n    }\n};\n\nbool isTarget(Puzzle &p)\n{\n    for (int i = 0; i < p.state.size(); ++i)\n    {\n        if (p.state.at(i) != (i + 1))\n            return false;\n    }\n    return true;\n}\n\nstd::string bfs(Puzzle &p)\n{\n    std::queue<Puzzle> q;\n    std::map<Puzzle, bool> visited;\n\n    q.push(p);\n    visited[p] = true;\n\n    while (!q.empty())\n    {\n        auto u = q.front();\n        q.pop();\n\n        if (isTarget(u))\n        {\n            return u.path;\n        }\n\n        int u_space_x = u.space % 3;\n        int u_space_y = u.space / 3;\n\n        for (size_t i = 0; i < 4; ++i)\n        {\n            auto nx = u_space_x + dx[i];\n            auto ny = u_space_y + dy[i];\n\n            if (0 <= nx && nx < N && 0 <= ny && ny < N)\n            {\n                auto v = u;\n                auto next_space = ny * 3 + nx;\n\n                std::swap(v.state[u.space], v.state[next_space]);\n                v.space = next_space;\n                v.path += dchar[i];\n\n                if (!visited[v])\n                {\n                    q.push(v);\n                    visited[v] = true;\n                }\n            }\n        }\n    }\n\n    return \"Unsolvable\\n\";\n}\n\nint main()\n{\n    Puzzle in;\n    for (size_t i = 0; i < N2; ++i)\n    {\n        std::cin >> in.state[i];\n        if (in.state[i] == 0)\n        {\n            in.state[i] = 9;\n            in.space = i;\n        }\n    }\n\n    auto ans = bfs(in);\n    std::cout << ans.length() << std::endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<string>\n#include<cassert>\n#include<cmath>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n#define LIMIT 100\n\nstatic const int dx[4] = {0, -1, 0, 1};\nstatic const int dy[4] = {1, 0, -1, 0};\nstatic const char dir[4] = {'r', 'u', 'l', 'd'};\n\nint MDT[N2][N2];\n\nstruct Puzzle{\n  int f[N2], space, MD;\n};\n\nPuzzle state;\nint limit;\nint path[LIMIT];\n\nint getAllMD(Puzzle pz){\n  int sum = 0;\n  for(int i=0 ; i<N2 ; ++i){\n    if(pz.f[i] == N2) continue;\n    sum += MDT[i][pz.f[i]-1];\n  }\n  return sum;\n}\n\nbool isSolved(){\n  for(int i=0 ; i<N2 ; ++i) if(state.f[i] != i+1) return false;\n  return true;\n}\n\nbool dfs(int depth, int prev){\n  if(state.MD == 0) return true;\n  if(depth + state.MD > limit) return false;\n\n  int sx = state.space/N;\n  int sy = state.space%N;\n  Puzzle tmp;\n\n  for(int r=0 ; r<4 ; ++r){\n    int tx = sx + dx[r];\n    int ty = sy + dy[r];\n    if(tx<0 || ty<0|| tx>=N || ty >= N) continue;\n    if(max(prev, r)-min(prev, r) == 2) continue;\n    tmp = state;\n\n    state.MD -= MDT[tx*N+ty][state.f[tx*N+ty]-1];\n    state.MD += MDT[sx*N+sy][state.f[tx*N+ty]-1];\n    swap(state.f[tx*N+ty], state.f[sx*N+sy]);\n    state.space = tx*N+ty;\n    if(dfs(depth+1, r)){\n      path[depth] = r;\n      return true;\n    }\n    state = tmp;\n  }\n  return false;\n}\n\nstring iterative_deeping(Puzzle in){\n  in.MD = getAllMD(in);\n\n  for(limit = in.MD ; limit<=LIMIT ; ++limit){\n    state = in;\n    if(dfs(0, -100)){\n      string ans = \"\";\n      for(int i=0 ; i<limit ; ++i) ans += dir[path[i]];\n      return ans;\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  for(int i=0 ; i<N2 ; ++i){\n    for(int j=0 ; j<N2 ; ++j){\n      MDT[i][j] = abs(i/N - j/N) + abs(i%N - j%N);\n    }\n  }\n  Puzzle in;\n  for(int i=0 ; i<N2 ; ++i){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = iterative_deeping(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<queue>\n#include<map>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle\n{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const\n  {\n    for(int i=0;i<N2;i++)\n      {\n\tif(f[i]==p.f[i]) continue;\n\treturn f[i] > p.f[i];\n      }\n    return false;\n  }\n};\n\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p)\n{\n  for(int i=0;i<N2;i++)\n  \n    if(p.f[i]!=(i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s)\n{\n  queue<Puzzle>Q;\n  map<Puzzle, bool>V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty())\n    {\n      u=Q.front();Q.pop();\n      if(isTarget(u)) return u.path;\n      int sx=u.space/N;\n      int sy=u.space%N;\n      for(int r=0;r<4;r++)\n\t{\n\t  int tx=sx+dx[r];\n\t  int ty=sy+dy[r];\n\t  if(tx<0||ty<0||tx>=N||ty>=N) continue;\n\t  v=u;\n\t  swap(v.f[u.space],v.f[tx*N+ty]);\n\t  v.space=tx*N+ty;\n\t  if(!V[v])\n\t    {\n\t      V[v]=true;\n\t      v.path += dir[r];\n\t      Q.push(v);\n\t    }\n\t}\n    }\n  return \"unsolvable\";\n}\n\nint main()\n{\n  Puzzle in;\n\n  for(int i=0;i<N2;i++)\n    {\n      cin>>in.f[i];\n      if(in.f[i]==0)\n\t{\n\t  in.f[i]=N2;\n\t  in.space=i;\n\t}\n    }\n  string ans=bfs(in);\n  cout<<ans.size()<<endl;\n\n  return 0;\n}\n\t    \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}};\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    if(wrongs + moves >= cutoff)\n        return -1;\n    int zero;\n    REP(i, 9){\n        if(tiles[i] == 0){\n            zero = i;\n            break;\n        }\n    }\n    if(dir[zero][0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-1]);\n    }\n    if(dir[zero][1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-3]);\n    }\n    if(dir[zero][2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+3]);\n    }\n    if(dir[zero][3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+1]);\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n    int start = check();\n\n    REP(i, 50){\n        move = dfs(0, start + i);\n        if(move > 0){\n            break;\n        }\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define FOR(I,A,B) for(ll I = ll(A); I < ll(B); ++I)\n\n\nll get(ll now,ll tc,ll tn){\n\tll res = now;\n\tll c = now/tc;\n\tc = c%10LL;\n\tres -= c*tc;\n\tres += c*tn;\n\treturn res;\n}\n\n\nint main(){\n\n\tqueue<ll> p,dep,zero;\n\tll now=0,k;\n\tll f = 123456780;\n\tll ten = 100000000LL;\n\tFOR(i,0,9){\n\t\tcin >> k;\n\t\tnow += k*ten;\n\t\tif(k==0){\n\t\t\tzero.push(ten);\n\t\t}\n\t\tten /= 10LL;\n\t}\n\n\t//cout << now << endl;\n\tll minten = 1LL;\n\tll maxten = 100000000LL;\n\n\tp.push(now);\n\tdep.push(0);\n\tset<ll> se;\n\tse.insert(now);\n\n\twhile(p.size()){\n\t\tnow = p.front(); p.pop();\n\t\tll d = dep.front(); dep.pop();\n\t\tll t = zero.front(); zero.pop();\n\t\tif(now==f){\n\t\t\tcout << d << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(t*1000<=maxten && !se.count(get(now,t*1000,t))){\n\t\t\tse.insert(get(now,t*1000,t));\n\t\t\tp.push(get(now,t*1000,t));\n\t\t\tdep.push(d+1);\n\t\t\tzero.push(t*1000);\n\t\t}\n\t\tif(t/1000>=minten && !se.count(get(now,t/1000,t))){\n\t\t\tse.insert(get(now,t/1000,t));\n\t\t\tp.push(get(now,t/1000,t));\n\t\t\tdep.push(d+1);\n\t\t\tzero.push(t/1000);\n\t\t}\n\t\tif(t*10<=maxten && t!=100 && t!=100000 && !se.count(get(now,t*10,t))){\n\t\t\tse.insert(get(now,t*10,t));\n\t\t\tp.push(get(now,t*10,t));\n\t\t\tdep.push(d+1);\n\t\t\tzero.push(t*10);\n\t\t}\n\t\tif(t/10>=minten && t!=1000 && t!=1000000&& !se.count(get(now,t/10,t))){\n\t\t\tse.insert(get(now,t/10,t));\n\t\t\tp.push(get(now,t/10,t));\n\t\t\tdep.push(d+1);\n\t\t\tzero.push(t/10);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <vector>\n\ntypedef std::vector<std::vector<int> > TPuzzle;\n\nvoid MakeGoal(TPuzzle& Goal)\n{\n\tGoal.resize(3);\n\tfor(int i = 0; i < 3; ++i){\n\t\tGoal[i].resize(3);\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tGoal[i][j] = (1 + 3 * i + j) % 9;\n\t\t}\n\t}\n}\n\nvoid ZeroPosition(int& Row, int& Col, const TPuzzle& Puzzle)\n{\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tif(Puzzle[i][j] == 0){\n\t\t\t\tRow = i;\n\t\t\t\tCol = j;\n\t\t\t}\n\t\t}\n\t}\n}\n\nenum TMovePattern\n{\n\tmpUp,\n\tmpDown,\n\tmpLeft,\n\tmpRight\n};\n\nbool Movable(const TPuzzle& Puzzle, const TMovePattern& Pattern)\n{\n\tint Row, Col;\n\tZeroPosition(Row, Col, Puzzle);\n\tswitch(Pattern){\n\tcase mpUp    : return Row != 0;\n\tcase mpDown  : return Row != 2;\n\tcase mpLeft  : return Col != 0;\n\tcase mpRight : return Col != 2;\n\t}\n\tassert(false);\n\treturn false;\n}\n\nTPuzzle Move(TPuzzle Puzzle, const TMovePattern& Pattern)\n{\n\tint Row, Col;\n\tZeroPosition(Row, Col, Puzzle);\n\tswitch(Pattern){\n\tcase mpUp    : std::swap(Puzzle[Row][Col], Puzzle[Row - 1][Col]);break;\n\tcase mpDown  : std::swap(Puzzle[Row][Col], Puzzle[Row + 1][Col]);break;\n\tcase mpLeft  : std::swap(Puzzle[Row][Col], Puzzle[Row][Col - 1]);break;\n\tcase mpRight : std::swap(Puzzle[Row][Col], Puzzle[Row][Col + 1]);break;\n\t}\n\treturn Puzzle;\n}\n\nvoid RenewTargets(\n\tconst TPuzzle& Puzzle,\n\tconst TMovePattern& Pattern,\n\tstd::vector<TPuzzle>* Targets,\n\tstd::set<TPuzzle>& History)\n{\n\tif(!Movable(Puzzle, Pattern)) return;\n\tTPuzzle Moved = Move(Puzzle, Pattern);\n\tif(History.find(Moved) != History.end()) return;\n\tTargets->push_back(Moved);\n\tHistory.insert(Moved);\n}\n//?¬??????????????????????????????¶???????????????\n\n//????¬??????????????????????????¨?????????£???????????°?????????\n//?¬?????????????????????????????????§?????????????????????????????????\n//???????????§????±\\??´????????£????????????\n//?¬???????????????????????????????????????????????????????\n//?±\\??´????????????\n//????????????\nint CountMove(std::vector<TPuzzle>* NextTargets,\n\t          const TPuzzle& Goal,\n\t          int Count,\n\t          std::set<TPuzzle>& History)\n{\n\tif(std::find(NextTargets->begin(), NextTargets->end(), Goal) != NextTargets->end()) return Count;\n\tstd::vector<TPuzzle>* NewTargets = new std::vector<TPuzzle>();\n\tfor(std::vector<TPuzzle>::const_iterator It = NextTargets->begin(); It != NextTargets->end(); ++It){\n\t\tRenewTargets(*It, mpUp,    NewTargets, History);\n\t\tRenewTargets(*It, mpDown,  NewTargets, History);\n\t\tRenewTargets(*It, mpLeft,  NewTargets, History);\n\t\tRenewTargets(*It, mpRight, NewTargets, History);\n\t}\n\tdelete NextTargets;\n\treturn CountMove(NewTargets, Goal, 1 + Count, History);\n}\n\nint CountMinimumMove(const TPuzzle& Puzzle, const TPuzzle& Goal)\n{\n\tstd::set<TPuzzle> History;\n\treturn CountMove(new std::vector<TPuzzle>(1, Puzzle), Goal, 0, History);\n}\n\nint main()\n{\n\tTPuzzle Goal;\n\tMakeGoal(Goal);\n\tTPuzzle Start(3, std::vector<int>(3));\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tint Input;\n\t\t\tstd::cin >> Input;\n\t\t\tStart[i][j] = Input;\n\t\t}\n\t}\n\tstd::cout << CountMinimumMove(Start, Goal) << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle\n{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p)const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++)\n    if(p.f[i]!=(i+1))return false;\n    return true;\n}\n\nstring bfs(Puzzle s)\n{\n  queue<Puzzle>Q;\n  map<Puzzle,bool>V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty())\n  {\n    u=Q.front();Q.pop();\n    if(isTarget(u))return u.path;\n    int sx = u.space/N;\n    int sy = u.space%N;\n    for(int r=0;r<4;r++)\n    {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N)continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx * N + ty;\n      if(!V[v])\n      {\n        V[v]=true;\n        v.path+=dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main()\n{\n  Puzzle in;\n\n  for(int i=0;i<N2;i++)\n  {\n    cin >> in.f[i];\n    if(in.f[i]==0)\n    {\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint start_x,start_y;//起始位置x,y；\nint Map[5][5];//起始状态数组；\nint max1,min1;//起始哈曼顿距离和实际最小步数；\nint goal[5][5];//目标状态数组；\nint c[4][2]={1,0,0,1,0,-1,-1,0};//方向数组；\nint flag;//标记变量；\n\nvoid start_xyz()//求起始位置；\n{\n    int i,j;\n    for(i=0; i<4; i++)\n        for(j=0; j<4; j++)\n            if(Map[i][j]==0)\n            {\n                start_x=i;\n                start_y=j;\n                return ;\n            }\n}\n\nint MHT()//哈曼顿距离；\n{\n    int i,j,num=0;\n    for(i=0;i<4;i++)\n        for(j=0;j<4;j++)\n            if(Map[i][j]==0)continue;\n            else num+=(fabs((Map[i][j]-1)/4-i)+fabs((Map[i][j]-1)%4-j));\n    return num;\n}\n\nvoid swap(int *a,int *b)//交换位置；\n{\n    int t;\n    t=*a;\n    *a=*b;\n    *b=t;\n}\n\nvoid dfs(int x,int y,int s,int last_dis)//深搜过程；\n{\n    if(flag)\n        return ;\n    if(s==max1)//当步数与最小值相等时；\n    {\n        int len=MHT();\n        if(len==0)//且此时的哈曼顿距离为零，也就是此时的图和目标图相同；\n        {\n            flag=1;\n            min1=s;\n        }\n        return ;\n    }\n    for(int i=0;i<4;i++)//四个方向；\n    {\n        if(i+last_dis==3&&s>0)continue;//此时的方向和上一步的相反，也就是又回到了上一步，此时应该continue;\n        int dx=x+c[i][0];\n        int dy=y+c[i][1];\n        if(dx<0||dy<0||dx>=4||dy>=4)continue;//是否越界；\n        swap(&Map[dx][dy],&Map[x][y]);//先交换位置再判断是否符合情况；\n        if(MHT()+s<=max1&&!flag)//当前位置的哈曼顿距离+当前深度<=初始哈曼顿距离；\n        {\n            dfs(dx,dy,s+1,i);\n            if(flag)\n                return ;\n        }\n        swap(&Map[dx][dy],&Map[x][y]);//不符合条件再交换回来；\n    }\n}\n\nint main()\n{\n    int i,j;\n    for(i=0; i<4; i++)\n        for(j=0; j<4; j++)\n            scanf(\"%d\",&Map[i][j]);\n    int k=1;\n    for(i=0;i<4;i++)//目标数组；\n        for(j=0;j<4;j++)\n            if(i==3&&j==3)goal[i][j]=0;\n            else goal[i][j]=k++;\n    start_xyz();//找起始位置；\n    flag=0;\n    max1=MHT();//初始哈曼顿距离；\n    while(!flag)\n    {\n        dfs(start_x,start_y,0,0);\n        if(!flag)\n            max1++;//增加初始哈曼顿距离；\n    }\n    if(flag)\n        printf(\"%d\\n\",min1);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n\nusing namespace std;\n#define ROW 3\n#define COL 3\n\nstatic const int dx[4] = {0, -1, 0, 1};\nstatic const int dy[4] = {1, 0, -1, 0};\n\nstruct Puzzle{\n\tint puzzle[ROW][COL];\n\tint space_x, space_y;\n\n\tbool operator < (const Puzzle &p) const {\n\t\tfor(int i = 0; i < ROW; i++){\n\t\t\tfor(int j = 0; j < COL; j++){\n\t\t\t\tif(puzzle[i][j] == p.puzzle[i][j]) continue;\n\t\t\t\treturn puzzle[i][j] < p.puzzle[i][j];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstruct Node{\n\tPuzzle state;\n\tint level;\n\tint cost;\n\n\tbool operator < (const Node &n) const {\n\t\treturn cost > n.cost;\n\t}\n};\n\nint goal[ROW][COL] = {\n\t\t1, 2, 3,\n\t\t4, 5, 6,\n\t\t7, 8, 0\n\t};\nmap<int, pair<int, int>> heuristicMap;\n\nint isGoal(Puzzle p){\n\tfor(int i = 0; i < ROW; i++){\n\t\tfor(int j = 0; j < COL; j++){\n\t\t\tif(goal[i][j] != p.puzzle[i][j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint Heuristuc0(Puzzle p){\n\treturn 0;\n}\n\nint g(int level){\n\treturn level;\n}\n\nint CaliculateCost(Node node){\n\treturn Heuristuc0(node.state) + g(node.level);\n}\n\nint ASearch(Node start){\n\tpriority_queue<Node> openList;\n\tmap<Puzzle, pair<bool, int>> closedList;\n\n\topenList.push(start);\n\n\twhile(!openList.empty()){\n\t\tNode now = openList.top(); openList.pop();\n\t\t\n\t\tif(isGoal(now.state)) return now.level;\n\n\t\tclosedList[now.state] = make_pair(true, now.cost);\n\t\t\n\t\tfor(int k = 0; k < 4; k++){\n\t\t\tint tx = now.state.space_x + dx[k];\n\t\t\tint ty = now.state.space_y + dy[k];\n\t\t\tif(tx < 0 || ty < 0 || tx >= ROW || ty >= COL) continue;\n\n\t\t\tNode child;\n\t\t\tchild.state = now.state;\n\t\t\tswap(child.state.puzzle[now.state.space_x][now.state.space_y], child.state.puzzle[tx][ty]);\n\t\t\tchild.state.space_x = tx;\n\t\t\tchild.state.space_y = ty;\n\t\t\tchild.level = now.level + 1;\n\t\t\tchild.cost = CaliculateCost(child);\n\n\t\t\tif(!closedList[child.state].first){\n\t\t\t\topenList.push(child);\n\t\t\t}else if(child.cost < closedList[child.state].second){\n\t\t\t\tclosedList.erase(child.state);\n\t\t\t\topenList.push(child);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main(){\n\tfor(int i = 0; i < ROW; i++){\n\t\tfor(int j = 0; j < COL; j++){\n\t\t\theuristicMap[goal[i][j]] = make_pair(i, j);\n\t\t}\n\t}\n\n\tNode start;\n\tfor(int i = 0; i < ROW; i++){\n\t\tfor(int j = 0; j < COL; j++){\n\t\t\tcin >> start.state.puzzle[i][j];\n\t\t\tif(start.state.puzzle[i][j] == 0){\n\t\t\t\tstart.state.space_x = i;\n\t\t\t\tstart.state.space_y = j;\n\t\t\t}\n\t\t}\n\t}\n\tstart.level = 0;\n\tstart.cost = CaliculateCost(start);\n\n\tcout << ASearch(start) << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const {\n    for(int i = 0;i < N2;i++) {\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p) {\n  for (int i = 0;i < N2;i++)\n    if(p.f[i] != (i + 1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()) {\n    u = Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r = 0;r < 4;r++) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >=N || ty >= N) continue;\n      v = u;\n      swap(v.f[u.space],v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if(!V[v]) {\n\tV[v] = true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main() {\n  Puzzle in;\n  \n  for(int i = 0;i < N2;i++) {\n    cin >> in.f[i];\n    if(in.f[i] == 0) {\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct r{\n\tint men[3][3];\n\tint cnt;\n};\nbool used[9][9][9][9][9][9][9][9][9]={};\nint main(){\n\tint i,j,dx[4]={0,1,0,-1},dy[4]={-1,0,1,0},k,temp,menc[3][3]={{1,2,3},{4,5,6},{7,8,0}};\n\tr f,v;\n\tqueue<r> q;\n\tfor(i=0;i<3;i++){\n\t\tfor(j=0;j<3;j++){\n\t\t\tcin>>f.men[i][j];\n\t\t}\n\t}\n\tf.cnt=0;\n\tq.push(f);\n\twhile(!q.empty()){\n\t\tf=q.front();\n\t\tq.pop();\n\t\tif(used[f.men[0][0]][f.men[0][1]][f.men[0][2]][f.men[1][0]][f.men[1][1]][f.men[1][2]][f.men[2][0]][f.men[2][1]][f.men[2][2]]==false){\n\t\t\tused[f.men[0][0]][f.men[0][1]][f.men[0][2]][f.men[1][0]][f.men[1][1]][f.men[1][2]][f.men[2][0]][f.men[2][1]][f.men[2][2]]=true;\n\t\t}\n\t\telse continue;\n\t\tint o=0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tfor(j=0;j<3;j++){\n\t\t\t\tif(f.men[i][j]!=menc[i][j]){\n\t\t\t\t\to=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(o==0)break;\n\t\tint b=0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tfor(j=0;j<3;j++){\n\t\t\t\tif(f.men[i][j]==0){\n\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\tif(i+dy[k]>=0&&i+dy[k]<3&&j+dx[k]>=0&&j+dx[k]<3){\n\t\t\t\t\t\t\tv=f;\n\t\t\t\t\t\t\ttemp=v.men[i][j];\n\t\t\t\t\t\t\tv.men[i][j]=v.men[i+dy[k]][j+dx[k]];\n\t\t\t\t\t\t\tv.men[i+dy[k]][j+dx[k]]=temp;\n\t\t\t\t\t\t\tv.cnt++;\n\t\t\t\t\t\t\tq.push(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b==1)break;\n\t\t}\n\t}\n\tcout<<f.cnt<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n  \nint t[3][3];\nint limit;\n  \nint getHeuri(){\n  int res=0,a;\n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n      if(t[i][j]==0)continue;\n      a=t[i][j]-1;\n      res+=abs(a/3-i)+abs(a%3-j);\n    }\n  }\n  return res;\n}\n  \nbool check(int depth,int prev,int py,int px){\n  int heuri=getHeuri();\n  if(heuri+depth>limit)return false;\n  if(heuri==0)return true;\n  for(int i=0;i<4;i++){\n    if(abs(i-prev)==2)continue;\n    int ny=py+dy[i],nx=px+dx[i];\n    if(ny<0||nx<0)continue;\n    if(ny>=3||nx>=3)continue;\n    swap(t[ny][nx],t[py][px]);\n    if(check(depth+1,i,ny,nx)) return true;\n    swap(t[ny][nx],t[py][px]);\n  }\n  return false;\n}\n  \nvoid solve(int py,int px){\n  for(limit=0;;limit++){\n    if(check(0,99,py,px)){\n      cout<<limit<<endl;\n      return;\n    }\n  }\n}\nint main(){\n  int py,px;\n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n      cin>>t[i][j];\n      if(t[i][j]==0){\n    py=i;\n    px=j;\n      }\n    }\n  }\n  solve(py,px);\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstruct r{\n\tint x;\n\tint y;\n\tint men[3][3];\n\tint cnt;\n};\nbool used[9][9][9][9][9][9][9][9][9];\nint main(){\n\tint i,j,dx[4]={0,1,0,-1},dy[4]={-1,0,1,0},k,temp,menc[3][3]={{1,2,3},{4,5,6},{7,8,0}};\n\tr f,v;\n\tqueue<r> q;\n\tmemset(used,0,sizeof(used));\n\tfor(i=0;i<3;i++){\n\t\tfor(j=0;j<3;j++){\n\t\t\tcin>>f.men[i][j];\n\t\t\tif(f.men[i][j]==0){\n\t\t\t\tf.x=j;\n\t\t\t\tf.y=i;\n\t\t\t}\n\t\t}\n\t}\n\tf.cnt=0;\n\tq.push(f);\n\twhile(!q.empty()){\n\t\tf=q.front();\n\t\tq.pop();\n\t\tif(used[f.men[0][0]][f.men[0][1]][f.men[0][2]][f.men[1][0]][f.men[1][1]][f.men[1][2]][f.men[2][0]][f.men[2][1]][f.men[2][2]]==false){\n\t\t\tused[f.men[0][0]][f.men[0][1]][f.men[0][2]][f.men[1][0]][f.men[1][1]][f.men[1][2]][f.men[2][0]][f.men[2][1]][f.men[2][2]]=true;\n\t\t}\n\t\telse continue;\n\t\tint o=0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tfor(j=0;j<3;j++){\n\t\t\t\tif(f.men[i][j]!=menc[i][j]){\n\t\t\t\t\to=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(o==0)break;\n\t\tfor(k=0;k<4;k++){\n\t\t\tif(f.y+dy[k]>=0&&f.y+dy[k]<3&&f.x+dx[k]>=0&&f.x+dx[k]<3){\n\t\t\t\tv=f;\n\t\t\t\ttemp=v.men[f.y][f.x];\n\t\t\t\tv.men[f.y][f.x]=v.men[f.y+dy[k]][f.x+dx[k]];\n\t\t\t\tv.men[f.y+dy[k]][f.x+dx[k]]=temp;\n\t\t\t\tv.x=f.x+dx[k];\n\t\t\t\tv.y=f.y+dy[k];\n\t\t\t\tv.cnt++;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<f.cnt<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nconst int PATTERN = 362880;\nconst int FORWARD  = 1;\nconst int BACKWARD = 2;\nint frontier[PATTERN];\n\nstruct State {\n    Board board;\n    int count;\n};\n\nqueue<State> q;\n\n// I made this function based on one by Haruhiko Okumura(Algorithm \n// Dictionary, p116) and one by M.Hiroi(Puzzle DE Programming).\ninline int change_number(long long board) {\n    static int fact_table[N] = {\n         40320, 5040, 720, 120, 24, 6, 2, 1, 0      // on N = 8\n    };\n    int value = 0;\n    for (int j = 0; j < N - 1; ++j) {\n        int J = static_cast<int>((board >> (j*4) & 0xF));\n        value += fact_table[j] * J;\n        for (int k = j + 1; k < N; ++k) {\n            int K = static_cast<int>((board >> k*4) & 0xF);\n            if (J < K) {\n                board &= ~(0xFLL << k*4);\n                board |= (static_cast<long long>(K - 1) << k*4);\n            }\n        }\n    }\n//    printf(\"[change_number] value = %d\\n\", value);\n    return value;\n}\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 0xF;\n    board |= num << (spacepos*4);\n    board &= ~(0xFLL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, State s) {\n    int prev = change_number(s.board);\n    int direction = frontier[prev];\n//    printf(\"[swap&check] direction = %d\\n\", direction);\n    swap(numpos, spacepos, s.board);\n//    if (s.board == GOAL) {\n//        return ++s.count;\n//    }\n    int pos = change_number(s.board);\n    if (!frontier[pos]) {\n        ++s.count;\n        q.push(s);\n        frontier[pos] = direction;\n        return -1;\n    }\n    else if (frontier[pos] != direction) {\n        ++s.count;\n//        printf(\"[swap&check] s.count = %d\\n\", s.count);\n//        return s.count * 2 + direction - 1;\n//        return s.count * 2;\n        return s.count * 2 - (frontier[pos] - 1);\n    }\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 0xF));\n    }\n    printf(\"\\n\");\n}\n\n// OK\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0, num; i < N; ++i) {\n        scanf(\"%d\", &num);\n        board |= static_cast<long long>(num) << (i*4);\n    }\n//    print(GOAL);\n//    print(board);\n\n    int count = 0;\n    if (board == GOAL) {\n        goto END;\n    }\n\n    frontier[change_number(board)] = FORWARD;\n    frontier[change_number(GOAL)] = BACKWARD;\n\n    q.push({ board, 0 });\n    q.push({ GOAL, 0 });\n    while (!q.empty()) {\n        State s = q.front();\n        q.pop();\n\n        int pos = -1;\n        while (++pos < N) {\n            if (((s.board >> (pos*4)) & 0xF) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst int edge[4][3] = {{0, 3, 6}, {0, 1, 2}, {6, 7, 8}, {2, 5, 8}}; /* l, t, b, r */\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    int zero;\n    int original[9];\n    if(wrongs + moves > cutoff)\n        return -1;\n    REP(i, 9){\n        original[i] = tiles[i];\n        if(tiles[i] == 0){\n            zero = i;\n        }\n    }\n    bool dir[4] = {true, true, true, true};\n    REP(i, 4) REP(j, 3)\n        if (zero == edge[i][j])\n            dir[i] = false;\n    if(dir[0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    REP(i, 9) tiles[i] = original[i];\n    if(dir[1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    REP(i, 9) tiles[i] = original[i];\n    if(dir[2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    REP(i, 9) tiles[i] = original[i];\n    if(dir[3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    REP(i, 9) tiles[i] = original[i];\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n    int start = check();\n\n    REP(i, 100){\n        move = dfs(0, start + i);\n        if(move > 0)\n            break;\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\nusing namespace std;\n\nint main(){\n    map<string,int> dp;\n    string g = \"123456780\";\n    string t = \"\";\n    for(int i = 0; i < 9; i++){\n        char c; cin >> c;\n        t += c;\n    }\n    dp[t] = 0;\n    queue<string> q;\n    q.push(t);\n    while(!q.empty()){\n        string s = q.front();   q.pop();\n        int now = dp[s];\n        if(s == g){\n            cout << dp[s] << endl;\n            return 0;\n        }\n        for(int i = 0; i < 9; i++){\n            if(i%3==2)  continue;\n            if(s[i] != '0' && s[i+1] != '0')    continue;\n            swap(s[i], s[i+1]);\n            if(dp.count(s) == 0){\n                dp[s] = now+1;\n                q.push(s);\n            }\n            swap(s[i], s[i+1]);\n        }\n        for(int i = 0; i < 6; i++){\n            if(s[i] != '0' && s[i+3] != '0')    continue;\n            swap(s[i], s[i+3]);\n            if(dp.count(s) == 0){\n                dp[s] = now+1;\n                q.push(s);\n            }\n            swap(s[i], s[i+3]);   \n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nvector<int> board( 9 );\nset< vector<int> > reachedState;\n\nvoid PrintBoard() {\n    for ( int row=0; row<3; ++row ) {\n\tfor ( int col=0; col<3; ++col ) cout << board[row*3+col];\n\tcout << endl;\n    }\n}\n\nbool IsReachedState( const vector<int>& b ) {\n    return reachedState.find( b ) != reachedState.end();\n}\n\nvoid RegisterState( const vector<int>& b ) {\n    reachedState.insert( b );\n}\n\nbool IsCompleted( const vector<int>& b ) {\n    for ( int i=0; i<8; ++i ) {\n\tif ( b[i] != i+1 ) return false;\n    }\n    return b[8] == 0;\n}\n\nint main() {\n\n    const int dx[4] = { -1, 0, 1,  0 };\n    const int dy[4] = {  0, 1, 0, -1 };\n    \n    for ( int i=0; i<3; ++i ) {\n\tfor ( int j=0; j<3; ++j ) {\n\t    cin >> board[i*3+j];\n\t}\n    }\n\n    //    PrintBoard();\n\n    queue< pair<vector<int>,int> > stateQue;\n    stateQue.push( make_pair(board, 0) );\n\n    while ( !stateQue.empty() ) {\n\n\tvector<int> state = stateQue.front().first;\n\tint step = stateQue.front().second;\n\tstateQue.pop();\n\n\tif ( IsCompleted( state ) ) {\n\t    cout << step << endl;\n\t    board = state;\n\t    //\t    PrintBoard();\n\t    break;\n\t}\n\n\t//\tif ( IsReachedState( state ) ) continue;\n\t//\tRegisterState( state );\n\n\tint x, y;\n\tfor ( int i=0; i<9; ++i ) {\n\t    if ( state[i] == 0 ) {\n\t\tx = i%3;\n\t\ty = i/3;\n\t\tbreak;\n\t    }\n\t}\n\t\n\tfor ( int i=0; i<4; ++i ) {\n\n\t    int nx = x + dx[i];\n\t    int ny = y + dy[i];\n\n\t    if ( nx < 0 || nx > 2 || ny < 0 || ny > 2 ) continue;\n\n\t    vector<int> next = state;\n\t    swap( next[3*y+x], next[3*ny+nx] );\n\t    stateQue.push( make_pair( next, step+1 ) );\n\t    \n\t}\n\t\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<queue>\n#include<cmath>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nconst int dx[4] = {0, -1, 0, 1};\nconst int dy[4] = {1, 0, -1, 0};\n\nint MDT[N2][N2];\n\nstruct Puzzle\n{\n\tint f[N2], space, MD;\n\tint cost;\n\tbool operator < (const Puzzle &p) const\n\t{\n\t\tfor(int i = 0; i < N2; i++){\n\t\t\tif(f[i] == p.f[i]) continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nint getallMD(const Puzzle &p)\n{\n\tint h = 0;\n\tfor(int i = 0; i < N2; i++){\n\tif(i == p.space) continue;\n\t\th += MDT[i][p.f[i] - 1];\n\t}\n\treturn h;\n}\n\nstruct State\n{\n\tPuzzle pz;\n\tint estimated;\n\tbool operator < (const State &s) const\n\t{\n\t\treturn estimated > s.estimated;\n\t}\n};\n\nint astar(Puzzle p)\n{\n\tpriority_queue<State> A;\n\tmap<Puzzle, bool> USED;\n\n\tState initial;\n\tinitial.pz = p;\n\tinitial.estimated = p.MD;\n\tA.push(initial);\n\tUSED[p] = true;\n\n\tPuzzle u, v;\n\tint sx, sy, tx, ty, r;\n\n\twhile(!A.empty())\n\t{\n\t\tu = A.top().pz; A.pop();\n\t\tif(u.MD == 0) return u.cost;\n\n\t\tsx = u.space / N;\n\t\tsy = u.space % N;\n\t\tfor(r = 0; r < 4; r++){\n\t\t\ttx = sx + dx[r];\n\t\t\tty = sy + dy[r];\n\t\t\tif(tx < 0 || tx >= N || ty < 0 || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tv.MD -= MDT[tx * N + ty][u.f[tx * N + ty] - 1];\n\t\t\tv.MD += MDT[sx * N + sy][u.f[tx * N + ty] - 1];\n\t\t\tswap(v.f[sx * N + sy], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\t\n\t\t\tif(!USED[v]){\n\t\t\t\tv.cost++;\n\t\t\t\tUSED[v] = true;\n\t\t\t\tState new_s;\n\t\t\t\tnew_s.pz = v;\n\t\t\t\tnew_s.estimated = v.cost + v.MD;\n\t\t\t\tA.push(new_s);\n\t\t\t}\n\t\t}\n\t};\n\treturn -1;\n}\n\nint main()\n{\n\t\n\tfor(int i = 0; i < N2; i++){\n\t\tfor(int j = 0; j < N2; j++){\n\t\t\tMDT[i][j] = abs((i / N) - (j / N)) + abs((i % N) - (j % N));\n\t\t}\n\t}\n\n\tPuzzle in;\n\n\tfor(int i = 0; i < N2; i++){\n\t\tscanf(\"%d\", &in.f[i]);\n\t\tif(in.f[i] == 0) in.space = i;\n\t}\n\tin.cost = 0;\n\tin.MD = getallMD(in);\n\n\tcout << astar(in) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define INF 1e9\n#define LIMIT 16\ntypedef vector<int> Vec;\n  \nconst int dx[] = {-1,0,0,1};\nconst int dy[] = {0,-1,1,0};\nint res;\nbool flg;\n  \nbool inField(int y,int x){\n  return 0 <= y && y < 3 && 0 <= x && x < 3; \n}\n  \nbool check(Vec &vec){\n  for(int i = 0 ; i < 8 ; i++){\n    if(vec[i] != i+1) return false;\n  }\n  return true;\n}\n  \nvoid solve(Vec &start,int z,map<Vec,int> &cost){\n  queue<Vec> Q;\n  queue<int> zero;\n  Q.push(start); zero.push(z);\n  cost[start] = 0;\n    \n  while(!Q.empty()){\n    Vec now = Q.front(); Q.pop();\n    int pos = zero.front(); zero.pop();\n    int x = pos % 3, y = pos / 3;\n    if(!flg && check(now)){\n      res = cost[now];\n      return;\n    }\n    if(cost[now] == LIMIT) break;\n    for(int i = 0 ; i < 4 ; i++){\n      int nx = x + dx[i], ny = y + dy[i];\n      if(!inField(ny,nx)) continue;\n      vector<int> next = now;\n      swap(next[pos],next[ny*3+nx]);\n      if(!cost.count(next)){\n        cost[next] = cost[now] + 1;\n        Q.push(next);\n        zero.push(ny*3+nx);\n      }\n    }\n  }\n}\n  \nint main(){\n  int z = -1;\n  vector<int> start(9),goal(9);\n  for(int i = 0 ; i < 9 ; i++){\n    cin >> start[i];\n    goal[i] = i+1;\n    if(start[i] == 0) z = i;\n  }\n  goal[8] = 0;\n  res = INF; flg = false;\n  map<Vec,int> s2v,g2v;\n  solve(start,z,s2v);\n  if(res == INF){\n    flg = true;\n    solve(goal,8,g2v);\n  }\n  map<Vec,int>::iterator s,g;\n  for(s = s2v.begin() ; s != s2v.end() ; ++s){\n    if(g2v[s->first]){\n      res = min(res,s->second+g2v[s->first]);\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//  Created by conan1024hao in 2019.\n//  Copyright © 2019 conan1024hao. All rights reserved.\n//  専用ライブラリです、自由にコピーして構いません。\n//  感谢看我的代码！Wechat:conan1024hao QQ:810396815\n#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\n#define INF 10e16\n#define MOD 1000000007\n#define rep(i, a, n) for (ll i = a; i < (ll)(n); i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define siz(x) (ll)(x).size()\n#define PI acos(-1.0)\nusing namespace std;\n//using Int=int_fast64_t;\ntypedef long long int ll;\ntypedef pair<ll,ll>Pll;\ntypedef pair<int,int>Pin;\nlong long GCD(long long a, long long b) { return b ? GCD(b, a%b) : a; }\nlong long LCM(long long a, long long b)  {return a/GCD(a,b)*b;}\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\nll cmp1(pair<ll,string>a,pair<ll,string> b){\n        if(a.fi!=b.fi)\n        return a.fi<b.fi;\n        else\n        return a.se<b.se;\n}\n\n//---------------------------------------------------------------------------\n#define n 3\n#define n2 9\n\nstruct puzzle{\n    int f[n2];\n    int space;\n    string path;\n    \n    bool operator < (const puzzle &p)const{\n        for(int i=0;i<n2;i++){\n            if(f[i]==p.f[i])continue;\n            return f[i]>p.f[i];\n        }\n        return false;\n    }\n};\n\nbool istarget(puzzle p){\n    for(int i=0;i<n2;i++){\n        if(p.f[i]!=(i+1))return false;\n    }\n    return true;\n}\n\nstring bfs(puzzle s){\n    queue<puzzle>q;\n    map<puzzle,bool>V;\n    puzzle u,v;\n    s.path=\"\";\n    q.push(s);\n    V[s]=1;\n    while(!q.empty()){\n        u=q.front();q.pop();\n        if(istarget(u))return u.path;\n        int sx=u.space/n;\n        int sy=u.space%n;\n        for(int r=0;r<4;r++){\n            int tx=sx+dx[r];\n            int ty=sy+dy[r];\n            if(tx<0||ty<0||tx>=n||ty>=n)continue;\n            v=u;\n            swap(v.f[u.space],v.f[tx*n+ty]);\n            v.space=tx*n+ty;\n            if(!V[v]){\n                V[v]=1;\n                v.path+=dir[r];\n                q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n//---------------------------------------------------------------------------\nint main(){//問題をちゃんと見ろ!!!!!!!!!!!!!!!!!      llか??????????\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------\n    puzzle in;\n    for(int i=0;i<n2;i++){\n        cin>>in.f[i];\n        if(in.f[i]==0){\n            in.f[i]=n2;\n            in.space=i;\n        }\n    }\n    string ans=bfs(in);\n    cout<<ans.size()<<endl;\n    //-------------------------------\n    return 0;\n}\n//---------------------------------------------------------------------------\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid debug() { cerr << \"\\n\"; }\ntemplate <class T> void debug(const T &x) { cerr << x << \"\\n\"; }\ntemplate <class T, class... Args> void debug(const T &x, const Args &... args) {\n    cerr << x << \" \";\n    debug(args...);\n}\ntemplate <class T> void debugVector(const vector<T> &v) {\n    for(const T &x : v) {\n        cerr << x << \" \";\n    }\n    cerr << \"\\n\";\n}\n\n//----------------------------------------------\n\nconst int N = 3;\narray<array<int, N * N>, N * N> MHTdist;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nstruct State {\n    array<char, N * N> data;\n    int space_id;\n    int d;\n    State() {}\n    void init() {\n        for(int i = 0; i < N * N; i++) {\n            if(data[i] == 0) {\n                data[i] = N * N;\n                space_id = i;\n                break;\n            }\n        }\n        d = 0;\n    }\n    bool operator<(const State &s) const {\n        for(int i = 0; i < N * N; i++) {\n            if(data[i] != s.data[i]) {\n                return (data[i] < s.data[i]);\n            }\n        }\n        return false;\n    }\n    int h() {\n        int res = 0;\n        for(int i = 0; i < N * N; i++) {\n            if(data[i] == N * N) {\n                continue;\n            }\n            res += MHTdist[i][data[i] - 1];\n        }\n        return res;\n    }\n};\n\nstruct Data {\n    State state;\n    int cost;\n    bool operator<(const Data &d) const { return (cost > d.cost); }\n};\n\nvoid debugState(const State &s) {\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n            cerr << s.data[i * N + j] << \" \";\n        }\n        cerr << \"\\n\";\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    State start;\n    {\n        for(int i = 0; i < N * N; i++) {\n            int hoge;\n            cin >> hoge;\n            start.data[i] = hoge;\n        }\n        start.init();\n        for(int i = 0; i < N * N; i++) {\n            for(int j = 0; j < N * N; j++) {\n                MHTdist[i][j] = abs(i / N - j / N) + abs(i % N - j % N);\n            }\n        }\n    }\n\n    map<State, int> dp;\n    priority_queue<Data> que;\n    que.emplace(Data{start, start.h()});\n    dp[start] = 0;\n\n    while(que.size()) {\n        auto nowState = que.top().state;\n        int nowCost = que.top().cost;\n        que.pop();\n        // debugState(nowState);\n        if(!nowState.h()) {\n            cout << nowState.d << \"\\n\";\n            return 0;\n        }\n        int i = nowState.space_id / N;\n        int j = nowState.space_id % N;\n        for(int k = 0; k < 4; k++) {\n            int ni = i + dy[k], nj = j + dx[k];\n            if(ni < 0 || ni >= N || nj < 0 || nj >= N) {\n                continue;\n            }\n            State nextState = nowState;\n            swap(nextState.data[nowState.space_id],\n                 nextState.data[ni * N + nj]);\n            nextState.space_id = ni * N + nj;\n            if(!dp.count(nextState)) {\n                nextState.d++;\n                dp[nextState] = nextState.d;\n                que.emplace(Data{nextState, nextState.d + nextState.h()});\n            } else if(dp[nextState] > nowState.d + 1) {\n                dp[nextState] = nowState.d + 1;\n                nextState.d = nowState.d + 1;\n                que.emplace(Data{nextState, nextState.d + nextState.h()});\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n#define N 3\ntypedef pair<int, int> P;\n\nstruct State {\n    int g, h;\n    string state;\n    P blank;\n    string path;\n    bool operator<(const State &a) const {\n        return g + h > a.g + a.h;\n    }\n};\n\nint d[5] = {-1, 0, 1, 0, -1};\nstring r[4] = {\"D\", \"R\", \"U\", \"L\"};\nstring ans_str = \"\";\nint ans[N][N], puzzle0[N][N], puzzle1[N][N];\nset<string> s;\npriority_queue<State> next_state;\nstring path;\n\nbool range(int y, int x) {return 0 <= y && y < N && 0 <= x && x < N;}\n\nint h0() {\n    int find = -1;\n    while(next_state.size()) {\n        State state = next_state.top();\n        next_state.pop();\n        if (s.count(state.state)) continue; // already search\n        s.insert(state.state); // visited\n\n        P blank = state.blank;\n        rep(i, 4) {\n            int y = d[i] + blank.first, x = d[i + 1] + blank.second; // next blank position\n            if (range(y, x)) { // can be replaced\n                string tmp = state.state; // next state (string)\n                int p = blank.first * N + blank.second, q = y * N + x;\n                if (N < 4) swap(tmp[p], tmp[q]);\n                else swap(tmp[2 * p], tmp[2 * q]), swap(tmp[2 * p + 1], tmp[2 * q + 1]);\n                if (s.count(tmp)) continue; // already search\n\n                if (tmp == ans_str) { // answer\n                    find = state.g + 1;\n                    path = state.path + r[i];\n                    break;\n                }\n\n                next_state.push(State{state.g + 1, 0, tmp, P(y, x), state.path + r[i]});\n            }\n        }\n        if (find != -1) break; // find an answer\n    }\n    return find;\n}\n\nint main(){\n    // create answer's numbers\n    iota(ans[0], ans[0] + N * N, 1);\n    ans[N - 1][N - 1] = 0;\n    // create number\n    iota(puzzle0[0], puzzle0[0] + N * N, 0);\n    rep(i, N)rep(j, N) cin >> puzzle0[i][j];\n\n    string state = \"\";\n    P blank;\n    int manhattan = 0, wrong_place = 0;\n    rep(i, N)rep(j, N) {\n        state += to_string(puzzle0[i][j]);\n        ans_str += to_string(ans[i][j]);\n\n        if(puzzle0[i][j] == 0) blank = P(i, j);\n        else {\n            int num = puzzle0[i][j] - 1;\n            manhattan += (abs(num / N - i) + abs(num % N - j));\n            if (puzzle0[i][j] != ans[i][j]) wrong_place++;\n        }\n    }\n\n    if (manhattan == 0) { // the answer\n        cout << 0 << endl;\n    } else {\n        int steps;\n        next_state.push(State{0, manhattan, state, blank, \"\"});\n        steps = h0();\n        cout << steps << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nbool ok(char a[3][3])\n{\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tif (a[i / 3][i % 3] != i + 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstruct puzzle\n{\n\tchar board[3][3];\n\tchar distance;\n};\n\nconst int dx[4] = { 0, -1, 1, 0 };\nconst int dy[4] = { -1, 0, 0, 1 };\n\nint main() \n{\n\tpuzzle start;\n\n\tstart.distance = 0;\n\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tfor (int j = 0; j < 3; j++)\n\t\t{\n\t\t\tcin >> start.board[i][j];\n\n\t\t\tstart.board[i][j] -= 48;\n\t\t}\n\t}\n\n\tqueue<puzzle> que; que.push(start);\n\n\tint Ans = 0;\n\n\tif (ok(start.board) == false)\n\t{\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tpuzzle p = que.front(); que.pop();\n\n\t\t\tint x, y;\n\n\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t\t{\n\t\t\t\t\tif (p.board[i][j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t\t{\n\t\t\t\tif (0 <= x + dx[dir] && x + dx[dir] < 3 && 0 <= y + dy[dir] && y + dy[dir] < 3)\n\t\t\t\t{\n\t\t\t\t\tpuzzle q = p;\n\n\t\t\t\t\tswap(q.board[y][x], q.board[y + dy[dir]][x + dx[dir]]);\n\n\t\t\t\t\tq.distance = p.distance + 1;\n\n\t\t\t\t\tif (ok(q.board) == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tAns = q.distance; goto Exit;\n\t\t\t\t\t}\n\n\t\t\t\t\tque.push(q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExit:;\n\n\tcout << (int)Ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n#define X 3\n#define Y 3\n#define THRESHOLD 2\nint manhattan(int x1,int y1,int x2,int y2){\n\treturn abs(x1-x2)+abs(y1-y2);\n}\nint calc(vector<int>&v){\n\tint s=0;\n\tfor(int coor=0;coor<X*Y;coor++){\n\t\tif(v[coor]!=0){\n\t\t\ts+=manhattan(coor%X,coor/X,(v[coor]-1)%X,(v[coor]-1)/X);\n\t\t}else{\n\t\t\ts+=manhattan(coor%X,coor/X,X-1,Y-1);\n\t\t}\n\t\t\t\n\t}\n\treturn s;\n}\nint main(){\n\tint i=1,start_point;\n\tvector<int>start(X*Y),goal;\n\tfor(;i<X*Y;i++)goal.push_back(i);goal.push_back(0);\n\tfor(i=0;i<X*Y;i++){\n\t\tscanf(\"%d\",&start[i]);\n\t\tif(start[i]==0)start_point=i;\n\t}\n\tif(start==goal){puts(\"0\");return 0;}\n\n\tmap<vector<int>,pair<int,int> >mstart;\n\tqueue<vector<int> >q;\n\tmstart[start]=make_pair(start_point,0);\n\tq.push(start);\n\tfor(;!q.empty();){\n\t\tvector<int> v=q.front();\n\t\tint val=calc(v);//,nxtval;\n\t\t//printf(\"[+] %d\\n\",val);\n\t\tq.pop();\n\t\tmap<vector<int>,pair<int,int> >&m=mstart;\n\t\tint coor=m[v].first,x=coor%X,y=coor/X;\n\t\tint depth=m[v].second;\n\t\tif(0<x){\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor-1,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-1]);\n\t\t}\n\t\tif(x<X-1){\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor+1,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+1]);\n\t\t}\n\t\tif(0<y){\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor-X,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor-X]);\n\t\t}\n\t\tif(y<Y-1){\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t\tif(m.find(v)==m.end() && calc(v)<=val+THRESHOLD)m[v]=make_pair(coor+X,depth+1),q.push(v);\n\t\t\tif(v==goal){printf(\"%d\\n\",depth+1);return 0;}\n\t\t\tswap(v[coor],v[coor+X]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <list>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL =     1      | 2 << (1*4)  | 3 << (2*4)\n                 | 4 << (3*4) | 5 << (4*4)  | 6 << (5*4)\n                 | 7 << (6*4) | 8LL << (7*4) | 0LL << (8*4);\n\nstruct state {\n    Board board;\n    int count;\n};\n\nlist<state> q;\n//vector<state> q;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    for (list<state>::iterator it = q.begin(); it != q.end(); ++it) {\n//    for (vector<state>::iterator it = q.begin(); it != q.end(); ++it) {\n        if (it->board == s.board) {\n            return -1;\n        }\n    }\n    ++s.count;\n    if (s.board == GOAL) {\n        return s.count;\n    }\n    q.push_back(s);\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\nint main(void) {\n\n    Board board = 0;\n    int i = 0;\n    while (i != N) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            board |= static_cast<long long>((ch - '0')) << (i*4);\n            ++i;\n        }\n    }\n\n//    print(GOAL);\n//    print(board);\n\n    q.push_back({ board, 0 });\n    int count = 0;\n    while (!q.empty()) {\n        state s = q.front();\n        q.pop_front();\n        // ?????????????????????\n        int pos;\n        for (int i = 0; i < N; ++i) {\n            if (((s.board >> (i*4)) & 15) == 0) {\n                pos = i;\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<set>\nusing namespace std;\n\nstruct Node{\n\tvector<int> arr;\n\tint step;\n};\nconst int tx[]={1,0,-1,0};\nconst int ty[]={0,1,0,-1};\nvector<int> start,end;\nqueue<Node> sq;\nset<int> pan;\n\nvoid input()\n{\n\tint tmp;\n\tfor(int i=0;i!=3;++i)\n\t\tfor(int j=0;j!=3;++j)\n\t\t{\n\t\t\tcin>>tmp;\n\t\t\tstart.push_back(tmp);\n\t\t}\n\tfor(int i=0;i!=8;++i)\n\t\tend.push_back(i+1);\n\tend.push_back(0);\n}\n\nNode makenod(vector<int> tmp,int step)\n{\n\tNode res;\n\tres.arr=tmp;\n\tres.step=step;\n\treturn res;\n}\n\nint vton(vector<int> tmp)\n{\n\tint res=0;\n\tfor(int i=0;i!=9;++i)\n\t\tres=res*10+tmp[i];\n\treturn res;\n}\n\nint main()\n{\n\tinput();\n\n\tsq.push(makenod(start,0));\n\tpan.insert(vton(start));\n\t\n\tint ans;\n\twhile(!sq.empty())\n\t{\n\t\tNode now=sq.front();\tsq.pop();\n\n\t\tif(now.arr==end)\n\t\t{\n\t\t\tans=now.step;\n\t\t\tbreak;\n\t\t}\n\n\t\tint ith;\n\t\tfor(int i=0;i!=9;++i)\n\t\t\tif(now.arr[i]==0)\n\t\t\t{\n\t\t\t\tith=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tint x=ith/3,y=ith%3;\n\t\t\n\t\tfor(int i=0;i!=4;++i)\n\t\t{\n\t\t\tint nx=x+tx[i],ny=y+ty[i];\t\n\t\t\tswap(now.arr[nx*3+ny],now.arr[ith]);\n\t\t\tint num=vton(now.arr);\n\t\t\tif(nx>=0 && nx<3 && ny>=0 && ny<3 && pan.count(num)==0)\n\t\t\t{\n\t\t\t\tsq.push(makenod(now.arr,now.step+1));\n\t\t\t\tpan.insert(num);\t\t\n\t\t\t}\n\t\t\tswap(now.arr[nx*3+ny],now.arr[ith]);\n\t\t}\n\t}\n\t\n\tcout<<ans<<endl;\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\tbool operator <(const Puzzle &p) const {\n\t\tfor (int i = 0; i < N2; ++i) {\n\t\t\tif (f[i] == p.f[i])\n\t\t\t\tcontinue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\nbool isTarget(Puzzle p) {\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif (p.f[i] != i + 1) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nconst int dx[4] { -1, 0, 1, 0 };\nconst int dy[4] { 0, -1, 0, 1 };\nconst char dir[4] { 'u', 'l', 'd', 'r' };\n\nstring bfs(Puzzle p) {\n\tqueue<Puzzle> Q;\n\tp.path = \"\";\n\tQ.push(p);\n\tPuzzle u, v;\n\tmap<Puzzle, bool> M;\n\tM[p] = true;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isTarget(u))\n\t\t\treturn u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!M[v]) {\n\t\t\t\tM[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"not solved\";\n}\n\nint main() {\n\n\tPuzzle p;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tcin >> p.f[i];\n\t\tif (p.f[i] == 0) {\n\t\t\tp.f[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(p);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nnamespace eight_puzzle{\n\ttypedef unsigned int uint;\n\tconst int N = 3;\n\tstruct State{\n\t\tState(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t}\n\t\tState(const uint tt,const uint tn){\n\t\t\ttable = tt;\n\t\t\tn = tn;\n\t\t}\n\n\t\tState& operator=(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t\treturn (*this);\n\t\t}\n\t\tbool isfinished(){\n\t\t\t\treturn table == 123456780;\n\t\t}\n\t\t\n\t\tuint table;\n\t\tuint n;\n\t};\n\tuint arraytovalue(int *table){\n\t\tuint t=0;\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tt*=10;\n\t\t\tt=t+table[i];\n\t\t}\n\t\treturn t;\n\t}\n\tvoid getnextstate(const State &s,std::vector<State> &states){\n\t\tint table[N*N];\n\t\tint t = s.table;\n\t\tint zi,zj;\n\t\tfor(int i=N-1;i>=0;--i){\n\t\t\tfor(int j=N-1;j>=0;--j){\n\t\t\t\tint panel = t-t/10*10;\n\t\t\t\ttable[i*N+j] = panel;\n\t\t\t\tt/=10;\n\t\t\t\tif(panel==0){\n\t\t\t\t\tzi = i;\n\t\t\t\t\tzj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=-1;i<=1;++i){\n\t\t\tfor(int j=-1;j<=1;++j){\n\t\t\t\tif((i+j)%2==0)continue;\n\t\t\t\tint ti = zi+i,tj=zj+j;\n\t\t\t\tif(0<=ti&&ti<N&&0<=tj&&tj<N){\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t\tstates.push_back(State(arraytovalue(table),s.n+1));\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tconst int MAX_N = 876543211;\n\tstd::vector<bool> visited(MAX_N);\n\t\n};\n\nint main(){\n\tusing namespace eight_puzzle;\n\tint array[N*N];\n\tfor(int i=0;i<N*N;++i){\n\t\tstd::cin>>array[i];\n\t}\n\tState init(arraytovalue(array),0);\n\n\tstd::queue<State> Q;\n\tQ.push(init);\n\twhile(!Q.empty()){\n\t\tState s = Q.front();\n\t\tQ.pop();\n\t\tstd::vector<State> states;\n\t\tgetnextstate(s,states);\n\t\tfor(uint i=0;i<states.size();++i){\n\t\t\tif(states[i].isfinished()){\n\t\t\t\tstd::cout<<states[i].n<<std::endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(!eight_puzzle::visited[states[i].table]){\n\t\t\t\tQ.push(states[i]);\n\t\t\t\teight_puzzle::visited[states[i].table]=true;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\n#include <map>\n#define NN 9\nusing namespace std;\ntypedef long long ll;\ntypedef pair<vector<int>, int> P;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nvector<int> start(NN);\nvector<int> goal(NN);\nint bfs()\n{\n    queue<P> que;\n    map<vector<int>, int> mp;\n    que.push(P(start, 0));\n    mp[start] = 0;\n    while(que.size())\n    {\n        P p = que.front();\n        que.pop();\n        vector<int> now = p.first;\n        int res = p.second;\n        if(now == goal) return res;\n        int y, x, pos;\n        for(int i = 0; i < NN; i++)\n        {\n            if(now[i] != 0) continue;\n            x = i % 3;\n            y = i / 3;\n            pos = i;\n        }\n        res++;\n        for(int i = 0; i < 4; i++)\n        {\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(ny < 0 || nx < 0 || ny >= 3 || nx >= 3) continue;\n            int idx = 3 * ny + nx;\n            vector<int> next = now;\n            swap(next[pos], next[idx]);\n            if(mp.count(next) == 0 || mp[next] > res)\n            {\n                mp[next] = res;\n                que.push(P(next, res));\n            }\n        }\n    }\n    return -1;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    for(int i = 0; i < NN; i++) \n    {\n        cin >> start[i];\n        goal[i] = (i + 1) % NN;\n    }\n    cout << bfs() << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n #define LIMIT 30\n\nstruct Puzzle{\n  int cont[9];\n  int space;\n  string path;\n  bool operator < ( const Puzzle &p ) const{\n    for ( int i = 0; i < 8; i++ ){\n      if ( cont[i] == p.cont[i] ) continue;\n      return cont[i] > p.cont[i];\n    }\n    return false;\n  }\n};\n\nint limit;\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char direction[4] = {'d', 'r', 'u', 'l'};\n\nbool isTarget(Puzzle puzzle){\n  for ( int i = 0; i < 9; i++ ){\n    if ( puzzle.cont[i] != 1 + i ) return false;\n  }\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while( !Q.empty() ){\n    u = Q.front(); Q.pop();\n    if ( isTarget(u) ){\n      return u.path;\n    }\n\n    int sx, sy, tx, ty;\n    sx = u.space/3;\n    sy = u.space%3;\n\n    for ( int r = 0; r < 4; r++ ){\n      tx = sx + dx[r];\n      ty = sy + dy[r];\n      if ( tx < 0 || ty < 0 || tx >= 3 || ty >= 3 ) continue;\n      v = u;\n      swap(v.cont[u.space],v.cont[tx*3+ty]);\n      v.space = tx*3+ty;\n      if ( !V[v] ){\n\tV[v] = true;\n\tv.path += direction[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nmain(){\n  Puzzle in;\n  for ( int i = 0; i < 9; i++ ){\n    cin >> in.cont[i];\n    if ( in.cont[i] == 0 ) {\n      in.cont[i]=9;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macro\n#pragma region Basic\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define FOR(i, a, b) for (int i = (a), i##_len = (b); i < i##_len; i++)\n#define FORD(i, a, b) for (int i = (a), i##_len = (b); i > i##_len; i--)\n#define FORR(t, a) for (auto t : a)\n#define ALL(x) (x).begin(), (x).end()  // sortなどの引数を省略したい\n#define GET(i, j) get<j>(i)\n#define MT(x, ...) make_tuple(x, __VA_ARGS__)\n#define SZ(x) ((int)(x).size())\n#define ZERO(x) memset(x, 0, sizeof(x))\n#define FILL(x, y) memset(x, y, sizeof(x))\n#define PB push_back\n#ifdef _DEBUG\n#define PRE_COMMAND             \\\n    std::cin.rdbuf(in.rdbuf()); \\\n    cout << fixed << setprecision(15);\n#else\n#define PRE_COMMAND cout << fixed << setprecision(15);\n#endif\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\ntemplate <class T>\nauto MAX(T& seq) {\n    return *max_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto MIN(T& seq) {\n    return *min_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto SUM(T& seq) {\n    T temp{0};\n    auto& temp2 = temp[0];\n    return accumulate(seq.begin(), seq.end(), temp2);\n}\ntemplate <class T>\nvoid SORT(T& seq) {\n    sort(seq.begin(), seq.end());\n}\ntemplate <class T, class S>\nvoid SORT(T& seq, S& sort_order) {\n    sort(seq.begin(), seq.end(), sort_order);\n}\ntemplate <class T>\nvoid SORTR(vector<T>& seq) {\n    sort(seq.begin(), seq.end(), greater<T>());\n}\ntemplate <class T>\nvoid CHMAX(T& a, const T& b) {\n    if (a < b) { a = b; }\n}\ntemplate <class T>\nvoid CHMIN(T& a, const T& b) {\n    if (b < a) { a = b; }\n}\ntemplate <class T>\nset<T> VECTOR_2_SET(vector<T>& v) {\n    set<T> s;\n    for (auto ele : v) { s.insert(ele); }\n    return s;\n}\ntemplate <class T>\nvector<T> SET_2_VECTOR(set<T>& s) {\n    vector<T> v;\n    for (auto ele : s) { v.push_back(ele); }\n    return v;\n}\n#pragma endregion Basic\n#pragma region overload\ntemplate <class T, class S>\nvoid operator+=(vector<T>& l, S& r) {\n    for (auto i : r) { l.push_back(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(set<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(multiset<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvector<T> operator+(vector<T>& l, S& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T>\nvector<T> operator+(const vector<T> l, const vector<T>& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nset<T> operator+(set<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nset<T> operator+(const set<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nmultiset<T> operator+(multiset<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nmultiset<T> operator+(const multiset<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\nstring operator+(const string l, const string& r) {\n    string str = l;\n    str += r;\n    return str;\n}\nstring operator*(const string l, const size_t& r) {\n    string str = l;\n    for (size_t i = 0; i < r; i++) { str += l; }\n    return str;\n}\n#pragma endregion overload\n#pragma region Input\ntemplate <class Head>\nvoid INPUT(vector<Head>& head);\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head);\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t);\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t);\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t);\ntemplate <class Head>\nvoid INPUT(Head& head);\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail);\n//本体\ntemplate <class Head>\nvoid INPUT(vector<Head>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t) {\n    cin >> get<0>(t);\n}\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t) {\n    cin >> get<0>(t) >> get<1>(t);\n}\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t);\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t);\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);\n}\ntemplate <class Head>\nvoid INPUT(Head& head) {\n    cin >> head;\n}\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail) {\n    INPUT(head);\n    INPUT((tail)...);\n}\n#pragma endregion Input\n#pragma region Print\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t);\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t);\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t);\ntemplate <class Head>\nvoid PRINT2(vector<Head> head);\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head);\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head);\ntemplate <class Head>\nvoid PRINT2(Head head);\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail);\ntemplate <class Head>\nvoid PRINT(Head head);\ntemplate <class... Head>\nvoid PRINT(Head... head);\ntemplate <int N, class Head>\nvoid PRINT(Head head);\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t) {\n    PRINT2(get<0>(t));\n}\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t) {\n    PRINT2(get<0>(t), get<1>(t));\n}\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t));\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t));\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t), get<4>(t));\n}\ntemplate <class Head>\nvoid PRINT2(vector<Head> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(Head head) {\n    cout << head;\n}\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail) {\n    PRINT2(head);\n    cout << \" \";\n    PRINT2((tail)...);\n}\ntemplate <class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\ntemplate <class... Head>\nvoid PRINT(Head... head) {\n    PRINT2((head)...);\n    cout << endl;\n}\ntemplate <int N, class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\n#pragma endregion Print\n#pragma endregion Macro\n\nint main() {\n    PRE_COMMAND\n    array<int, 9> root;\n    INPUT(root);\n    map<array<int, 9>, int> d;  // 根からの距離\n    d[root] = 0;\n    vector<array<int, 9>> q = {root};\n    int cnt = 0;\n    while (q.size()) {  // BFS\n        cnt++;\n        vector<array<int, 9>> qq;\n        while (q.size()) {\n            array<int, 9> i = q.back();\n            q.pop_back();\n            vector<array<int, 9>> g;\n            int zero = (int)(find(i.begin(), i.end(), 0) - i.begin());\n\n            array<int, 9> temp;\n            temp = i;\n            if (zero % 3 != 0) {\n                swap(temp[zero - 1], temp[zero]);\n                g.push_back(temp);\n            }\n            temp = i;\n            if (zero % 3 != 2) {\n                swap(temp[zero + 1], temp[zero]);\n                g.push_back(temp);\n            }\n            temp = i;\n            if (zero / 3 != 0) {\n                swap(temp[zero - 3], temp[zero]);\n                g.push_back(temp);\n            }\n            temp = i;\n            if (zero / 3 != 2) {\n                swap(temp[zero + 3], temp[zero]);\n                g.push_back(temp);\n            }\n\n            for (auto j : g) {\n                if (d.find(j) == d.end()) {\n                    d[j] = cnt;\n                    qq.push_back(j);\n                }\n            }\n        }\n        q = qq;\n    }\n    PRINT(d[{1, 2, 3, 4, 5, 6, 7, 8, 0}]);\n}\n"
  },
  {
    "language": "C++",
    "code": "//13_B ８パズル問題  8 Puzzle\n\n#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i]) continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++)\n    if(p.f[i] != (i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front();\n    Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space/N;\n    int sy = u.space%N;\n    for(int r=0;r<4;r++){\n      int tx = sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty >=N ) continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space = tx *N +ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0;i<N2;i++){\n    cin >> in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans =bfs(in);\n  cout << ans.size() << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nlong long int N = 9;\nlong long int finish_key;\nstd::map<int, int> keys;\n\nlong long int calc_key(const std::vector<long long int> & puzzle) {\n    long long int scale = 1;\n    long long int key = 0;\n    for (int i = 0; i < N; i++) {\n        key += scale * puzzle[i];\n        scale *= N;\n    }\n    return key;\n}\n\n\nstd::vector<long long int> move_up(std::vector<long long int> puzzle, int white_idx) {\n    if (white_idx + 3 < N) {\n        std::swap(puzzle[white_idx], puzzle[white_idx + 3]);\n    }\n    return puzzle;\n}\n\nstd::vector<long long int> move_down(std::vector<long long int> puzzle, int white_idx) {\n    if (0 <= white_idx - 3) {\n        std::swap(puzzle[white_idx], puzzle[white_idx - 3]);\n    }\n    return puzzle;\n}\n\nstd::vector<long long int> move_left(std::vector<long long int> puzzle, int white_idx) {\n    if (white_idx % 3 != 2) {\n        std::swap(puzzle[white_idx], puzzle[white_idx + 1]);\n    }\n    return puzzle;\n}\n\nstd::vector<long long int> move_right(std::vector<long long int> puzzle, int white_idx) {\n    if (white_idx % 3 != 0) {\n        std::swap(puzzle[white_idx], puzzle[white_idx - 1]);\n    }\n    return puzzle;\n}\n\nvoid search(int cnt, std::vector<long long int> puzzle) {\n    std::cout << cnt << std::endl;\n    if (keys.find(finish_key) != keys.end() && cnt >= keys[finish_key]) {\n        return;\n    }\n    long long int key = calc_key(puzzle);\n    if (key == finish_key) {\n        if (keys.find(key) == keys.end() || cnt < keys[key]){\n            keys[key] = cnt;\n        }\n        return;\n    }\n    if (keys.find(key) != keys.end()) {\n        if (cnt < keys[key]) {\n            keys[key] = cnt;\n        } else {\n            return;\n        }\n    } else {\n        keys[key] = cnt;\n    }\n    auto iter = std::find(puzzle.begin(), puzzle.end(), 0);\n    int white_idx = std::distance(puzzle.begin(), iter);\n    search(cnt + 1, move_up(puzzle, white_idx));\n    search(cnt + 1, move_down(puzzle, white_idx));\n    search(cnt + 1, move_left(puzzle, white_idx));\n    search(cnt + 1, move_right(puzzle, white_idx));\n}\n\n\nint main() {\n    std::vector<long long int> puzzle(N);\n    for (int i = 0; i < N; i++) {\n        std::cin >> puzzle[i];\n    }\n    finish_key = calc_key({1, 2, 3, 4, 5, 6, 7, 8, 0});\n    // search(0, puzzle);\n\n    long long int key = calc_key(puzzle);\n    int cnt = 0;\n    std::queue<std::pair<int, std::vector<long long int>>> queues;\n    while (key != finish_key) {\n        keys[key] = cnt;\n\n        auto iter = std::find(puzzle.begin(), puzzle.end(), 0);\n        int white_idx = std::distance(puzzle.begin(), iter);\n        {\n            auto next = move_up(puzzle, white_idx);\n            if (keys.find(calc_key(next)) == keys.end()) {\n                queues.push(std::pair<int, std::vector<long long int>>(cnt + 1, next));\n            }\n        }\n        {\n            auto next = move_down(puzzle, white_idx);\n            if (keys.find(calc_key(next)) == keys.end()) {\n                queues.push(std::pair<int, std::vector<long long int>>(cnt + 1, next));\n            }\n        }\n        {\n            auto next = move_left(puzzle, white_idx);\n            if (keys.find(calc_key(next)) == keys.end()) {\n                queues.push(std::pair<int, std::vector<long long int>>(cnt + 1, next));\n            }\n        }\n        {\n            auto next = move_right(puzzle, white_idx);\n            if (keys.find(calc_key(next)) == keys.end()) {\n                queues.push(std::pair<int, std::vector<long long int>>(cnt + 1, next));\n            }\n        }\n\n        auto que = queues.front();\n        queues.pop();\n        cnt = que.first;\n        puzzle = que.second;\n        key = calc_key(puzzle);\n    }\n    std::cout << cnt << std::endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <limits>\n#include <fstream>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\ntypedef pair<vector<int>, int> P;\nmap<vector<int>, int> checked;\nqueue<P> que;\nint dy[4] = {1, 0, -1, 0};\nint dx[4] = {0, 1, 0, -1};\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  vector<int> v;\n  FOR(i,0,9){\n    int n;\n    cin>>n;\n    v.push_back(n);\n  }\n  vector<int> goal = {1,2,3,4,5,6,7,8,0};\n  que.push(P(v, 0));\n  checked[v] = 0;\n  while(!que.empty()){\n    P p = que.front();\n    que.pop();\n    vector<int> now = p.first;\n    int dist = p.second;\n    bool ok = true;\n    FOR(i,0,9){\n      if(now[i]!=goal[i]){\n        ok = false;\n        break;\n      }\n    }\n    if(ok){\n      cout << dist << endl;\n      return 0;\n    }\n    int x, y, zero;\n    FOR(i,0,9){\n      if(now[i]==0){\n        x = i % 3;\n        y = i / 3;\n        zero = i;\n        break;\n      }\n    }\n    FOR(i,0,4){\n      int ny = y + dy[i];\n      int nx = x + dx[i];\n      if(ny<0||ny>=3||nx<0||nx>=3) continue;\n      int j = 3 * ny + nx;\n      vector<int> nxt = now;\n      swap(nxt[zero], nxt[j]);\n      if(checked.count(nxt)==0||checked[nxt] > dist + 1) {\n        checked[nxt] = dist + 1;\n        que.push(P(nxt, dist+1));\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define FOR(i,n) for(int i=0; i<n; ++i)\n#define GET(type,name) type name; std::cin >> name;\n\n\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <utility>\n#include <algorithm>\n#include <queue>\n#include <numeric>\n#include <unordered_map>\n\n\n    typedef std::vector<std::vector<int>> State;\n    const int N = 3;\n\n    State int_to_state(int c){\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n      FOR(i, N) {\n        FOR(j, N) {\n          int r = c%10;\n          c = c/10;\n          state[i][j] = r;\n        }\n      }\n      return state;\n    }\n    int state_to_int(State state) {\n      int c = 0;\n      int p = 1;\n      FOR(i, N) {\n        FOR(j, N) {\n          c += state[i][j] * p;\n          p *= 10;\n        }\n      }\n      return c;\n    }\n\n\n    void show(std::vector<std::vector<int>> state){\n      FOR(i, N) {\n        FOR(j, N) {\n          std::cout << state[i][j] << \" \";\n        }\n        std::cout << std::endl;\n      }\n    }\n\n    bool is_solved(const State& state) {\n      int N = state.size();\n\n      FOR(i, N) {\n        FOR(j, N) {\n          if(state[i][j] != (1 + 3*i + j)) return false;\n        }\n      }\n      return true;\n    }\n\n    std::vector<State> next_states_of(State state){\n      std::vector<State> res;\n      FOR(i,N){\n        FOR(j,N){\n          if(state[i][j] == 9){\n            State ns;\n            if(i<N-1){\n              ns = state;\n              std::swap(ns[i][j], ns[i+1][j]);\n              res.push_back(ns);\n            }\n            if(j<N-1){\n              ns = state;\n              std::swap(ns[i][j], ns[i][j+1]);\n              res.push_back(ns);\n            }\n            if(i>0){\n              ns = state;\n              std::swap(ns[i][j], ns[i-1][j]);\n              res.push_back(ns);\n            }\n            if(j>0){\n              ns = state;\n              std::swap(ns[i][j], ns[i][j-1]);\n              res.push_back(ns);\n            }\n            return res;\n          }\n        }\n    }\n\n    int solve_puzzle(State state){\n\n      std::priority_queue<\n        std::pair<int, int>,\n        std::vector<std::pair<int, int>>,\n        std::greater<std::pair<int, int>>\n      > q;\n      std::unordered_map<int, int> h;\n\n      q.push(std::make_pair(0, state_to_int(state)));\n\n      for(;not q.empty();){\n        auto d_s = q.top(); q.pop();\n        int d = d_s.first;\n        int st_int = d_s.second;\n        State state = int_to_state(d_s.second);\n//        show(state);\n\n        if(st_int == 987654321){\n//          std::cout << \"z\"<< std::endl;\n          return d;\n        }\n\n        if(h.find(st_int) == h.end()){\n          h[st_int] = d;\n          std::vector<State> next_states = next_states_of(state);\n          for(auto ns : next_states){\n            q.push(std::make_pair(d+1, state_to_int(ns)));\n          }\n        }\n      }\n      return -1;\n    }\n\n    int main(){\n      const int N = 3;\n      std::vector<std::vector<int>> state(N, std::vector<int>(N));\n\n      FOR(i, N){\n        FOR(j, N){\n          GET(int, x);\n          if(x==0) x=9;\n          state[i][j] = x;\n        }\n      }\n//      show(state);\n//      int c = state_to_int(state);\n//      std::cout << c << std::endl;\n//      std::cout << \"?\" <<std::endl;\n//      State s2 = int_to_state(c);\n//      std::cout << \"!\" <<std::endl;\n//\n//      show(s2);\n//      int min_steps = rec_min_steps_\n      std::cout << solve_puzzle(state) << std::endl;\n      return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\nstruct Puzzle {\n\tint st[9];\n\tint space, len;\n\tbool operator < (const Puzzle& rhs) const {\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (st[i] == rhs.st[i]) continue;\n\t\t\treturn st[i] < rhs.st[i];\n\t\t}\n\t\treturn false;\n\t}\n} in;\nbool isTarget(Puzzle p) {\n\tfor (int i = 0; i < 9; i++) {\n\t\tif (p.st[i] != i + 1) return false;\n\t}\n\treturn true;\n}\nint bfs() {\n\tqueue<Puzzle> q;\n\tset<Puzzle> s;\n\tq.push(in);\n\ts.insert(in);\n\twhile (!q.empty()) {\n\t\tPuzzle u = q.front(), v;\n\t\tq.pop();\n\t\tif (isTarget(u)) return u.len;\n\t\tint sx = u.space / 3, sy = u.space % 3;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint tx = sx + dx[i], ty = sy + dy[i];\n\t\t\tif (tx < 0 || ty < 0 || tx >= 3 || ty >= 3) continue;\n\t\t\tv = u;\n\t\t\tv.space = tx * 3 + ty;\n\t\t\tv.len++;\n\t\t\tswap(v.st[u.space], v.st[v.space]);\n\t\t\tif (!s.count(v)) {\n\t\t\t\ts.insert(v);\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n    for (int i = 0; i < 9; i++) {\n    \tscanf(\"%d\", &in.st[i]);\n    \tif (in.st[i] == 0) {\n    \t\tin.space = i;\n    \t\tin.st[i] = 9;\n\t\t}\n\t}\n\tin.len = 0;\n\tprintf(\"%d\\n\", bfs());\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nconst int N = 3;\nconst int NN = N*N;\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,-1,0,1 };\nconst char dir[4] = { 'u','l','d','r' };\n\n\n//n puzzle\nstruct Puzzle {\n\tint f[NN];\n\tint space;\n\tstring path;\n\tPuzzle() :path(\"\") {};\n\n\tbool operator<(const Puzzle &p)const {\n\t\tfor (int i = 0; i < NN; i++) {\n\t\t\tif (f[i] == p.f[i])continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n\tvoid input() {\n\t\tfor (int i = 0; i < NN; i++) {\n\t\t\tcin >> f[i];\n\t\t\tif (f[i] == 0) {\n\t\t\t\tf[i] = NN;\n\t\t\t\tspace = i;\n\t\t\t}\n\t\t}\n\t}\n\tvoid slide(int t) {\n\t\tswap(f[space], f[t]);\n\t\tspace = t;\n\t}\n};\n\nbool is_target(const Puzzle &p) {\n\tfor (int i = 0; i < NN; i++)\n\t\tif (p.f[i] != (i + 1))\n\t\t\treturn false;\n\treturn true;\n}\n\nstring bfs(Puzzle s) {\n\tqueue<Puzzle> q;\n\tmap<Puzzle, bool> mp;\n\tPuzzle u, v;\n\tq.emplace(s);\n\tmp[s] = true;\n\twhile (q.size()) {\n\t\tu = q.front(); q.pop();\n\t\tif (is_target(u))return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space%N;\n\t\tfor (int r = 0; r < 4; r++) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)continue;\n\t\t\tv = u;\n\t\t\tv.slide(tx*N + ty);\n\t\t\tif (mp[v])continue;\n\t\t\tmp[v] = true;\n\t\t\tv.path += dir[r];\n\t\t\tq.emplace(v);\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tPuzzle p;\n\tp.input();\n\tstring ans = bfs(p);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n\nusing namespace std;\n\nint minimum = -1;\n\n\nint calcDiffSum(int table[3][3]){\n    int sum = 0;\n    for(int row=0;row<3;row++){\n        for(int col=0;col<3;col++){\n            if(table[row][col] != 0){\n                sum += abs((table[row][col]-1)/3-row) + abs((table[row][col]-1)%3-col);\n            }\n        }\n    }\n    return sum;\n}\n\nint zeroLoc(int table[3][3]){\n    int zero_loc;\n    for(int i=0;i<3;i++){\n        for(int k=0;k<3;k++){\n            if(table[i][k]==0){\n                zero_loc=10*i+k;\n            }\n        }\n    }\n    return zero_loc;\n}\n\nvoid recursive(int table[3][3],int max_depth,int count,int pre_loc,int zero_loc){\n\tint diffSum = calcDiffSum(table);\n\tif(count == max_depth && diffSum == 0){\n\t\tminimum = max_depth;\n\t\treturn;\n\t}\n\n\tif(minimum != -1)return;\n\n\tint next_table[4][3][3],tmp_row,tmp_col,pre_row,pre_col;\n\tint dif1,dif2,dif3,dif4;\n\n\n\tswitch(zero_loc){\n\tcase 0:\n\t\tfor(int a=0;a<2;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 1){\n\t\t\tif((table[0][1]-1)%3==0){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][0][0],next_table[0][0][1]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,1);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 10){\n\t\t\tif((table[1][0]-1)/3==0){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][0][0],next_table[1][1][0]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,10);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 1:\n\n\t\tfor(int a=0;a<3;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 0){\n\t\t\tif((table[0][0]-1)%3>=1){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][0][1],next_table[0][0][0]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,0);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 11){\n\t\t\tif((table[1][1]-1)/3==0){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][0][1],next_table[1][1][1]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,11);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 2){\n\t\t\tif((table[0][2]-1)%3<=1){\n\t\t\t\tdif3 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif3 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[2][0][1],next_table[2][0][2]);\n\t\t\tif(count < max_depth && dif3 <= max_depth-count){\n\t\t\t\trecursive(next_table[2],max_depth,count+1,zero_loc,2);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tfor(int a=0;a<2;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 1){\n\t\t\tif((table[0][1]-1)%3==2){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][0][2],next_table[0][0][1]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,1);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 12){\n\t\t\tif((table[1][2]-1)/3==0){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][0][2],next_table[1][1][2]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,12);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 10:\n\t\tfor(int a=0;a<3;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 0){\n\t\t\tif((table[0][0]-1)/3>=1){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][1][0],next_table[0][0][0]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,0);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 11){\n\t\t\tif((table[1][1]-1)%3==0){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][1][0],next_table[1][1][1]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,11);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 20){\n\t\t\tif((table[2][0]-1)/3<=1){\n\t\t\t\tdif3 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif3 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[2][1][0],next_table[2][2][0]);\n\t\t\tif(count < max_depth && dif3 <= max_depth-count){\n\t\t\t\trecursive(next_table[2],max_depth,count+1,zero_loc,20);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 11:\n\t\tfor(int a=0;a<4;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 1){\n\t\t\tif((table[0][1]-1)/3>=1){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][1][1],next_table[0][0][1]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,1);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 10){\n\t\t\tif((table[1][0]-1)%3>=1){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][1][1],next_table[1][1][0]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,10);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 12){\n\t\t\tif((table[1][2]-1)%3<=1){\n\t\t\t\tdif3 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif3 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[2][1][1],next_table[2][1][2]);\n\t\t\tif(count < max_depth && dif3 <= max_depth-count){\n\t\t\t\trecursive(next_table[2],max_depth,count+1,zero_loc,12);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 21){\n\t\t\tif((table[2][1]-1)/3<=1){\n\t\t\t\tdif4 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif4 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[3][1][1],next_table[3][2][1]);\n\t\t\tif(count < max_depth && dif4 <= max_depth-count){\n\t\t\t\trecursive(next_table[3],max_depth,count+1,zero_loc,21);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 12:\n\t\tfor(int a=0;a<3;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 2){\n\t\t\tif((table[0][2]-1)/3>=1){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][1][2],next_table[0][0][2]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,2);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 11){\n\t\t\tif((table[1][1]-1)%3==2){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][1][2],next_table[1][1][1]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,11);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 22){\n\t\t\tif((table[2][2]-1)/3<=1){\n\t\t\t\tdif3 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif3 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[2][1][2],next_table[2][2][2]);\n\t\t\tif(count < max_depth && dif3 <= max_depth-count){\n\t\t\t\trecursive(next_table[2],max_depth,count+1,zero_loc,22);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 20:\n\n\t\tfor(int a=0;a<2;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 10){\n\t\t\tif((table[1][0]-1)/3==2){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][2][0],next_table[0][1][0]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,10);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 21){\n\t\t\tif((table[2][1]-1)%3==0){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][2][0],next_table[1][2][1]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,21);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase 21:\n\t\tfor(int a=0;a<3;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 20){\n\t\t\tif((table[2][0]-1)%3>=1){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][2][1],next_table[0][2][0]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,20);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 11){\n\t\t\tif((table[1][1]-1)/3==2){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][2][1],next_table[1][1][1]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,11);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 22){\n\t\t\tif((table[2][2]-1)%3<=1){\n\t\t\t\tdif3 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif3 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[2][2][1],next_table[2][2][2]);\n\t\t\tif(count < max_depth && dif3 <= max_depth-count){\n\t\t\t\trecursive(next_table[2],max_depth,count+1,zero_loc,22);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 22:\n\t\tfor(int a=0;a<2;a++){\n\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\tnext_table[a][b][c] = table[b][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pre_loc != 12){\n\t\t\tif((table[1][2]-1)/3==2){\n\t\t\t\tdif1 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif1 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[0][2][2],next_table[0][1][2]);\n\t\t\tif(count < max_depth && dif1 <= max_depth-count){\n\t\t\t\trecursive(next_table[0],max_depth,count+1,zero_loc,12);\n\t\t\t}\n\t\t}\n\t\tif(pre_loc != 21){\n\t\t\tif((table[2][1]-1)%3==2){\n\t\t\t\tdif2 = diffSum - 1;\n\t\t\t}else{\n\t\t\t\tdif2 = diffSum + 1;\n\t\t\t}\n\t\t\tswap(next_table[1][2][2],next_table[1][2][1]);\n\t\t\tif(count < max_depth && dif2 <= max_depth-count){\n\t\t\t\trecursive(next_table[1],max_depth,count+1,zero_loc,21);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t}\n}\n\n\nvoid func(int table[3][3],int max_depth){\n\twhile(minimum == -1){\n\t\trecursive(table,max_depth,0,-1,zeroLoc(table));\n\t\tmax_depth += 2;\n\t}\n}\n\n\nint main(){\n\n    int table[3][3],start_count;\n\n    for(int i=0;i<3;i++){\n        scanf(\"%d %d %d\",&table[i][0],&table[i][1],&table[i][2]);\n    }\n    start_count = calcDiffSum(table);\n\n    func(table,start_count);\n\n    printf(\"%d\\n\",minimum);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fi       first\n#define se       second\n#define sf       scanf\n#define pf       printf\n#define mp       make_pair\n#define pb       push_back\n#define si(x)    scanf(\"%d\", &x)\n#define pi(x)    printf(\"%d\\n\", x)\n#define sl(x)    scanf(\"%lld\", &x)\n#define pl(x)    printf(\"%lld\\n\", x)\n#define all(x)   x.begin(), x.end()\n#define READ(f)  freopen(f, \"r\", stdin)\n#define WRITE(f) freopen(f, \"w\", stdout)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef map<ll, ll> mll;\ntypedef pair<ll, ll> pll;\ntypedef map<int, int> mii;\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\n\nconst ll MAX = 100005;\nconst ll MOD = 1000000007;\nconst ll INF = 1000000000000000;\nconst double PI = 2 * acos(0.0);\nconst double EPS = 0.00000000001;\n\nclass vState {\npublic:\n    int cpuz[3][3];\n};\n\nclass node {\npublic:\n    int g, h, f, zeroI, zeroJ, puzzle[3][3];\n    bool operator < (const node &a) const {\n        return a.f < f;\n    }\n};\n\nint goal[3][3];\nvector<vState> visit;\n\nint calc_heuristic(int puzzle[][3]) {\n    int h = 0;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (goal[i][j] != puzzle[i][j]) h++;\n        }\n    }\n    return h;\n}\n\nvoid set_goal_state() {\n    //pf(\"- Goal State -\\n\\n\");\n    goal[0][0] = 1;\n    goal[0][1] = 2;\n    goal[0][2] = 3;\n    goal[1][0] = 4;\n    goal[1][1] = 5;\n    goal[1][2] = 6;\n    goal[2][0] = 7;\n    goal[2][1] = 8;\n    goal[2][2] = 0;\n    //pf(\"\\n\");\n}\n\nnode set_current_state() {\n    node cur;\n    //pf(\"- Current State -\\n\");\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            si(cur.puzzle[i][j]);\n            if (cur.puzzle[i][j] == 0) {\n                cur.zeroI = i;\n                cur.zeroJ = j;\n            }\n        }\n    }\n    //pf(\"\\n\");\n    cur.h = calc_heuristic(cur.puzzle);\n    cur.g = 0;\n    cur.f = cur.g + cur.h;\n    return cur;\n}\n\nvoid print_state(node x) {\n    pf(\"._______.\\n\");\n    for (int i = 0; i < 3; i++) {\n        pf(\"| \");\n        for (int j = 0; j < 3; j++) {\n            pf(\"%d \", x.puzzle[i][j]);\n        }\n        pf(\"|\\n\");\n    }\n    pf(\"---------\\n\");\n    pf(\"H(n) = %d\\n\", x.h);\n    pf(\"G(n) = %d\\n\", x.g);\n    pf(\"F(n) = %d\\n\\n\", x.f);\n}\n\nbool already_visited(int puzzle[][3]) {\n    for (int i = 0; i < visit.size(); i++) {\n        int flag = true;\n        for (int j = 0; j < 3; j++) {\n            for (int k = 0; k < 3; k++) {\n                if (puzzle[j][k] != visit[i].cpuz[j][k]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (!flag) break;\n        }\n        if (flag) return true;\n    }\n    return false;\n}\n\nbool check_if_goal(int puzzle[][3]) {\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (puzzle[i][j] != goal[i][j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nnode copy_puzzle(int puzzle[][3]) {\n    node x;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            x.puzzle[i][j] = puzzle[i][j];\n        }\n    }\n    return x;\n}\n\nvState copy_puzzle2(int puzzle[][3]) {\n    vState x;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            x.cpuz[i][j] = puzzle[i][j];\n        }\n    }\n    return x;\n}\n\nint astar(node cur) {\n    priority_queue<node> pq;\n    pq.push(cur);\n    int steps = 0;\n    while (!pq.empty()) {\n        steps++;\n        node u = pq.top();\n        //print_state(u);\n        visit.pb( copy_puzzle2(u.puzzle) );\n        while (!pq.empty()) pq.pop(); // clearing queue\n        if (check_if_goal(u.puzzle)) break;\n        // check the moves that can be made from current state\n        // if any moves is already made we will not pass that in the queue, this is to avoid infinite loops\n        if (u.zeroI - 1 >= 0) {\n            /// UP\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI - 1][u.zeroJ], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.zeroI = u.zeroI - 1;\n                v.zeroJ = u.zeroJ;\n                pq.push(v);\n            }\n        }\n        if (u.zeroI + 1 < 3) {\n            /// DOWN\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI + 1][u.zeroJ], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.zeroI = u.zeroI + 1;\n                v.zeroJ = u.zeroJ;\n                pq.push(v);\n            }\n        }\n        if (u.zeroJ - 1 >= 0) {\n            /// LEFT\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI][u.zeroJ - 1], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.zeroI = u.zeroI;\n                v.zeroJ = u.zeroJ - 1;\n                pq.push(v);\n            }\n        }\n        if (u.zeroJ + 1 < 3) {\n            /// RIGHT\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI][u.zeroJ + 1], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.zeroI = u.zeroI;\n                v.zeroJ = u.zeroJ + 1;\n                pq.push(v);\n            }\n        }\n     }\n     return steps;\n}\n\nint main() {\n    set_goal_state();\n    node cur = set_current_state();\n    pf(\"%d\\n\", astar(cur) - 1);\n\n    return 0;\n}\n\n\n/*\n\nTEST 1\n------\n0 1 2\n3 4 5\n6 7 8\n\n7 2 4\n5 0 6\n8 3 1\n\nTEST 2\n------\n1 2 3\n4 5 6\n7 8 0\n\n1 2 0\n4 5 3\n7 8 6\n\nTEST 3\n------\n1 2 3\n8 0 4\n7 6 5\n\n3 6 4\n0 1 2\n8 7 5\n\nTEST 4\n------\n1 2 3\n8 0 4\n7 6 5\n\n1 3 4\n8 6 2\n0 7 5\n\nTEST 5\n------\n1 2 3\n8 0 4\n7 6 5\n\n1 3 4\n8 0 5\n7 2 6\n\nTEST 6 // WORST CASE\n------\n1 2 3\n4 5 6\n7 8 0\n\n6 4 7\n8 5 0\n3 2 1\n\n8 6 7\n2 5 4\n3 0 1\n\n*/\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<queue>\n#include<map>\n\nusing namespace std;\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nclass puzzle{\npublic :\n  int f[9],space;\n  string path;\n\n  bool operator < (const puzzle &p) const{\n    for(int i=0;i<9;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nbool isTarget(puzzle p){\n  for(int i=0;i<9;i++){\n    if(p.f[i] !=(i+1))return false;\n  }\n  return true;\n}\n\nstring bfs(puzzle s){\n  queue<puzzle> Q;\n  map<puzzle,bool> V;\n  puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n\n    if(isTarget(u))return u.path;\n    int sx=u.space/3;\n    int sy=u.space%3;\n\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=3||ty>=3)continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*3+ty]);\n      v.space = tx*3+ty;\n\n      if(!V[v]){\n\tV[v] =true;\n\tv.path +=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  puzzle in;\n  for(int i=0;i<9;i++){\n    cin >> in.f[i];\n    if(in.f[i] ==0){\n      in.f[i] = 9;\n      in.space=i;\n    }\n  }\n  string ans =bfs(in);\n  cout << ans.size()<<endl;\n\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    for(int i = 0; i < N2; i++){\n      if(f[i] == p.f[i]){\n\tcontinue;\n      }\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  for(int i = 0; i < N2; i++){\n    if(p.f[i] != (i + 1)) return false;\n  }\n    return true;\n}\n\nstring bfs(Puzzle s){\n  \n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  \n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n    if(isTarget(u)) return u.path;\n\n    int sx = u.space / N;\n    int sy = u.space % N;\n\n    for(int r = 0; r < 4; r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N){\n\tcontinue;\n      }\n\n      v = u;\n\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n\n      if(!V[v]){\n\tV[v] = true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i = 0; i < N2; i++){\n    cin >> in.f[i];\n    \n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n  \n\t  \n      \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\nvector<int> searched[9];\n\nclass board{\nprivate:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<int> tiles;\n\npublic:\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        REP(i, 9){\n            tiles.push_back(num[i]);\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n    }\n\n    int cost() {\n        return wrongs + moves;\n    }\n\n    void board_to_int(){\n        int k = 0;\n        REP(i, 9)\n            k += (tiles[i] * pow(10, i));\n        for(int i = searched[tiles[0]].size(); i > 0 ; i--)\n            if(k == searched[tiles[0]][i-1])\n                return;\n        pq.push(board(tiles, moves+1));\n        searched[tiles[0]].push_back(k);\n        return;\n    }\n\n    void move() {\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\nbool operator< (board b1, board b2){\n    return (b1.cost() > b2.cost()) ? true : false;\n}\n\nint solve(){\n    pq.push(board(original, 0));\n    while(!pq.empty()){\n        auto target = pq.top();\n        pq.pop();\n        if(target.cost() > 100)\n            return -1;\n        if(target.get_wrongs() == 0)\n            return target.cost();\n        target.move();\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = 0;\n    move = solve();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\tbool operator <(const Puzzle &p) const {\n\t\tfor (int i = 0; i < N2; ++i) {\n\t\t\tif (f[i] != p.f[i]) {\n\t\t\t\treturn f[i] < p.f[i];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\nbool isComplete(Puzzle p) {\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif (p.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nconst int dx[4] { -1, 0, 1, 0 };\nconst int dy[4] { 0, -1, 0, 1 };\nconst char dir[4] { 'u', 'l', 'd', 'r' };\nstring bfs(Puzzle p) {\n\tp.path = \"\";\n\tmap<Puzzle, bool> M;\n\tM[p] = true;\n\tPuzzle u, v;\n\tqueue<Puzzle> Q;\n\tQ.push(p);\n\tfor (int i = 0; i < N2; ++i) {\n\t\twhile (!Q.empty()) {\n\t\t\tu = Q.front();\n\t\t\tQ.pop();\n\t\t\tif (isComplete(u))\n\t\t\t\treturn u.path;\n\t\t\tint sx = u.space / N;\n\t\t\tint sy = u.space % N;\n\t\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\t\tint tx = sx + dx[r];\n\t\t\t\tint ty = sy + dy[r];\n\t\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\t\tcontinue;\n\t\t\t\tv = u;\n\t\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\t\tv.space = tx * N + ty;\n\t\t\t\tif (!M[v]) {\n\t\t\t\t\tM[v] = true;\n\t\t\t\t\tv.path += dir[r];\n\t\t\t\t\tQ.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unresolved\";\n}\n\nint main() {\n\n\tPuzzle p;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tscanf(\"%d\", &p.f[i]);\n\t\tif (p.f[i] == 0) {\n\t\t\tp.f[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(p);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <queue>\n#define N 9\n#define n 3\n#define Blank 0\n#define up -N/n\n#define down N/n\n#define left -1\n#define right 1\n#define limit 34\nusing namespace std;\nstruct p{\n  int v[N];\n  int blankPlace;\n  int g=0;\n  int h=0;\n  bool operator < (const p& pazzle) const {\n    for(int i=0;i<N;i++){\n      if(v[i] == pazzle.v[i]) continue;\n      return v[i]<pazzle.v[i];\n    }\n    return false;\n  }\n};\npriority_queue <p, vector<p>, greater<p> > pazzle;\nmap <p,bool> existPazzle;\nbool operator > (const p a,const p b){return a.h+a.g>b.h+b.g;};\n\nint calculate_h(p this_pazzle,int i){\n  if(i == this_pazzle.blankPlace ) return abs(i/n-(N-1)/n)+abs(i%n-(N-1)/n);\n  else return abs(i/n-(this_pazzle.v[i]-1)/n)+abs(i%n-(this_pazzle.v[i]-1)%n);\n}\n\np checkPazzle(p thisPazzle){\n  thisPazzle.h = 0;\n    for(int i=0;i<N;i++)\n      thisPazzle.h += calculate_h(thisPazzle,i);\n  return thisPazzle;\n}\n\nvoid moveBlank(p thisPazzle,int move){\n  int moved = thisPazzle.blankPlace + move;\n  thisPazzle.g++;\n  //cout<<\"g: \"<<thisPazzle.g<<\" moved: \"<<moved<<endl;\n  swap(thisPazzle.v[thisPazzle.blankPlace],thisPazzle.v[moved]);\n  if(existPazzle[thisPazzle])return;\n  thisPazzle.blankPlace = moved;\n  thisPazzle = checkPazzle(thisPazzle);\n  if(thisPazzle.g+thisPazzle.h>limit)return;\n  pazzle.push(thisPazzle);\n}\n\nvoid movePazzle(p thisPazzle){\n  if(thisPazzle.blankPlace+up>=0)\n    moveBlank(thisPazzle,up);\n  if(thisPazzle.blankPlace+down<9)\n    moveBlank(thisPazzle,down);\n  if(thisPazzle.blankPlace + left >= 0&&thisPazzle.blankPlace/3 == (thisPazzle.blankPlace+left)/3)\n    moveBlank(thisPazzle,left);\n  if(thisPazzle.blankPlace/3 == (thisPazzle.blankPlace+right)/3)\n    moveBlank(thisPazzle,right);\n}\n\np dfs(){\n  p tmp,thisPazzle;\n  tmp.g = -1;\n  while(!pazzle.empty()){\n    thisPazzle = pazzle.top();\n    pazzle.pop();\n    existPazzle[thisPazzle]=true;\n    if(!thisPazzle.h)return thisPazzle;\n    movePazzle(thisPazzle);\n  }\n  return tmp;\n}\n\nint main(){\n  p thisPazzle;\n  for(int i=0;i<N;i++){\n    cin>>thisPazzle.v[i];\n    if(thisPazzle.v[i]==Blank)thisPazzle.blankPlace=i;\n  }\n  thisPazzle = checkPazzle(thisPazzle);\n  pazzle.push(thisPazzle);\n  thisPazzle = dfs();\n  cout<<thisPazzle.g<<endl;\n  return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#define R 3\n#define L 3\n#define total 9\n#define TryCnt 45\nusing namespace std;\n\nextern inline void down_0(void);\nextern inline void up_0(void);\nextern inline void right_0(void);\nextern inline void left_0(void);\n\nextern int  serch(int x, int y, int MaxCnt, int pre);\n\nint num = 0;\nint val[total] ={};\n\n\nint main( void )\n{\n  int i = 0;\n  int x,y = 0;\n\n  for(i=0; i<total; i++)\n    {\n      cin>>val[i];\n      if(val[i] == 0)\n        {\n      num = i;\n        }\n    }\n\n  x = R - (num/L) -1;\n  y = L - (num%L) -1;\n\n  for(i=0; i<TryCnt; i++)\n    {\n      if( serch(x,y,i,4) == 1 )\n        {\n          cout<<i<<endl;\n      break;\n        }\n    }\n  return 0;\n}\nint serch(int x, int y, int MaxCnt, int pre)\n{\n  int result;\n  int i=0;\n\n  if(MaxCnt < (x + y) )\n    {\n      return 0;\n    }\n\n  if(MaxCnt==0)\n    {\n      for(i=0; i<total-1; i++)\n        if(val[i] != (i+1)) return 0;\n      return 1;\n    }\n\n for(i=0; i<4; i++)\n    {\n      result = 0;\n      switch(i)\n        {\n    case 0:\n      if( (x > 0) && (pre != 3) )\n        {\n          down_0();\n          result = serch(x-1, y, MaxCnt-1, 0);\n          up_0();\n        }\n      break;\n    case 1:\n      if( (y > 0) && (pre != 2) )\n        {\n          right_0();\n\n          result = serch(x, y-1, MaxCnt-1, 1);\n\n          left_0();\n        }\n      break;\n    case 2:\n      if( (y < L -1 ) && (pre != 1) )\n        {\n          left_0();\n          result = serch(x, y+1, MaxCnt-1, 2);\n          right_0();\n        }\n      break;\n    case 3:\n      if( (x < R -1 ) && (pre != 0) )\n        {\n          up_0();\n          result = serch(x+1, y, MaxCnt-1, 3);\n          down_0();\n        }\n      break;\n    default:\n      break;\n        }\n      if(result)\n        {\n      return 1;\n        }\n    }\n\n  return 0;\n}\n\ninline void down_0()\n{\n  val[num] = val[num + L];\n  num = num + L;\n}\n\ninline void up_0()\n{\n  val[num] = val[num - L];\n  num = num - L;\n}\n\ninline void right_0()\n{\n  val[num] = val[num +1];\n  num = num + 1;\n}\n\ninline void left_0()\n{\n  val[num] = val[num -1];\n  num = num - 1;\n}\n// 入力例                                                                       \n\n// 1 3 0                                                                        \n// 4 2 5                                                                        \n// 7 8 6                                                                        \n\n// 出力例                                                                       \n\n// 4                                                                            \n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nbitset<362880> ht;\ntypedef pair<int[9],int> state;\nqueue<state> q;\nconst int goal=46233;\n\nint hash(const int *board)\n{\n    const static int fact[]={40320,5040,720,120,24,6,2,1};\n    int h=0;\n    int work;\n    for(int i=0; i<8; i++) {\n        work=board[i];\n        for(int j=i-0; j>=0; j--) {\n            if(board[j]<work) --work;\n        }\n        h+=work*fact[i];\n    }\n    return h;\n}\n\nint search()\n{\n    while(!q.empty()) {\n        state now=q.front();\n        if(hash(now.first)==goal) return now.second;\n        q.pop();\n        int f;\n        for(f=0; now.first[f]; f++);\n        if(f%3!=0) {\n            state next=now;\n            next.second++;\n            swap(next.first[f], next.first[f-1]);\n            int h=hash(next.first);\n            if(!ht.test(h)) {\n                ht.set(h);\n                q.push(next);\n            }\n        }\n        if((f+1)%3!=0) {\n            state next=now;\n            next.second++;\n            swap(next.first[f], next.first[f+1]);\n            int h=hash(next.first);\n            if(!ht.test(h)) {\n                ht.set(h);\n                q.push(next);\n            }\n        } \n        if(f>=3) {\n            state next=now;\n            next.second++;\n            swap(next.first[f], next.first[f-3]);\n            int h=hash(next.first);\n            if(!ht.test(h)) {\n                ht.set(h);\n                q.push(next);\n            }\n        } \n        if(f<6) {\n            state next=now;\n            next.second++;\n            swap(next.first[f], next.first[f+3]);\n            int h=hash(next.first);\n            if(!ht.test(h)) {\n                ht.set(h);\n                q.push(next);\n            }\n        } \n    }\n    return -1;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    state board;\n    board.second=0;\n    for(int i=0; i<9; i++) cin>>board.first[i];\n    ht.set(hash(board.first));\n    q.push(board);\n    cout<<search()<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// include\n//------------------------------------------\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// conversion\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\ntemplate <class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\n// math\n//-------------------------------------------\ntemplate <class T>\ninline T sqr(T x) {\n    return x * x;\n}\n\n// typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n// container util\n//------------------------------------------\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i, c) \\\n    for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort((c).begin(), (c).end())\n\n// repetition\n//------------------------------------------\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(itr, ds) for (auto itr = ds.begin(); itr != ds.end(); itr++)\n\n// constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF_INT = 2147483647;\nconst LL INF_LL = 9223372036854775807;\nconst int MOD = 1000000007;\n\n// clear memory\n//--------------------------------------------\n#define CLR(a) memset((a), 0, sizeof(a))\n\n// vector\n//--------------------------------------------\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n\n// pair\n//--------------------------------------------\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, pair<T, U> &pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\n// vector\n//--------------------------------------------\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"{\";\n    for (int i = 0; i < vec.size(); i++) {\n        os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");\n    }\n    os << \"}\";\n    return os;\n}\n\n// list\n//--------------------------------------------\ntemplate <typename T>\nostream &operator<<(ostream &os, const list<T> &lst) {\n    os << \"{\";\n    REPI(itr, lst) {\n        os << *itr;\n        itr++;\n        if (itr != lst.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n// map\n//--------------------------------------------\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, map<T, U> &map_var) {\n    os << \"{\";\n    REPI(itr, map_var) {\n        os << *itr;\n        itr++;\n        if (itr != map_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n// set\n//--------------------------------------------\ntemplate <typename T>\nostream &operator<<(ostream &os, set<T> &set_var) {\n    os << \"{\";\n    REPI(itr, set_var) {\n        os << *itr;\n        itr++;\n        if (itr != set_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n// dump\n//--------------------------------------------\n#define DUMPOUT cerr\n\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail>\nvoid dump_func(Head &&head, Tail &&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) > 0) {\n        DUMPOUT << \", \";\n    }\n    dump_func(std::move(tail)...);\n}\n#ifdef DEBUG_\n#define DEB\n#define dump(...)                                                       \\\n    DUMPOUT << \"  \" << string(#__VA_ARGS__) << \": \"                     \\\n            << \"[\" << to_string(__LINE__) << \":\" << __FUNCTION__ << \"]\" \\\n            << endl                                                     \\\n            << \"    \",                                                  \\\n        dump_func(__VA_ARGS__)\n#else\n#define DEB if (false)\n#define dump(...)\n#endif\n\nstatic const int N = 3;\nstatic const int T = 9;\n\nstruct Puzzle {\n    int f[T];\n    int space;\n    string path;\n\n    bool operator<(const Puzzle &p) const {\n        REP(i, T) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] < p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n    REP(i, T) if (p.f[i] != (i + 1)) return false;\n    return true;\n}\n\nstring bfs(Puzzle p) {\n    queue<Puzzle> q;\n    map<Puzzle, bool> m;\n    p.path = \"\";\n    q.push(p);\n    m[p] = true;\n    while (!q.empty()) {\n        Puzzle u = q.front();\n        q.pop();\n        if (isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        REP(i, 4) {\n            int tx = sx + dx[i];\n            int ty = sy + dy[i];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            Puzzle v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if (!m[v]) {\n                m[v] = true;\n                v.path += dir[i];\n                q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main(void) {\n    Puzzle in;\n    REP(i, T) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            in.f[i] = T;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define ALL(v) (v).begin(), (v).end()\n#define p(s) cout<<(s)<<endl\n#define p2(s, t) cout << (s) << \" \" << (t) << endl\n#define br() p(\"\")\n#define pn(s) cout << (#s) << \" \" << (s) << endl\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nconst int W = 3;\n\nstruct Point{\n    ll x;\n    ll y;\n    Point(ll x, ll y): x(x), y(y) {}\n    Point(){}\n};\n\nstruct Puzzle{\n    ll A[W][W];\n    vector<ll> path;\n\n    Point get_space(){\n        Point p;\n        FOR(y, 0, 3){\n            FOR(x, 0, 3){\n                if(A[y][x]==0){\n                    p.x = x;\n                    p.y = y;\n                    return p;\n                }\n            }\n        }\n        return p;\n    }\n\n    bool operator<(const Puzzle &b)const\n    {\n        FOR(y, 0, 3){\n            FOR(x, 0, 3){\n                if(A[y][x] != b.A[y][x]){\n                    return A[y][x] < b.A[y][x];\n                }\n            }\n        }\n        return false;\n    }\n\n    bool is_solved(){\n        FOR(y, 0, W){\n            FOR(x, 0, W){\n                ll target = W*y + x + 1;\n                if(y==W-1 && x==W-1) target = 0;\n                if(A[y][x]!=target) return false;\n            }\n        }\n        return true;\n    }\n\n    void print(){\n        FOR(y, 0, W){\n            FOR(x, 0, W){\n                cout << A[y][x] << ' ';\n            }\n            cout << endl;\n        }\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    // 初期状態\n    auto p = Puzzle();\n    FOR(y, 0, 3){\n        FOR(x, 0, 3){\n            cin >> p.A[y][x];\n        }\n    }\n\n    map<Puzzle, bool> mp;\n    mp[p] = true;\n\n    queue<Puzzle> que;\n    que.push(p);\n\n    while(!que.empty()){\n        auto pu = que.front();\n        que.pop();\n\n        if(pu.is_solved()){\n            p(pu.path.size());\n            return 0;\n        }\n\n        FOR(i, 0, 4){\n            auto sp = pu.get_space();\n            ll x = sp.x;\n            ll y = sp.y;\n            \n            // target position\n            ll tx = x + dx[i];\n            ll ty = y + dy[i];\n\n            auto cp = pu;\n\n            // in range\n            if(0<=tx && tx<W && 0<=ty && ty<W){\n                swap(cp.A[y][x], cp.A[ty][tx]);\n\n                // まだその状態になったことがないなら入れる\n                if(mp[cp]!=true){\n                    mp[cp] = true;\n                    cp.path.push_back(i);\n                    que.push(cp);\n                }   \n            }\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define N  3\n#define N2 9\nusing namespace std;\nstruct Puzzle{\n\tint f[N2];\n\tint space;\n\tstring path;\n\tbool operator < (const Puzzle &p) const \n\t{\n\t\tfor (int i = 0; i < N2; ++i)\n\t\t{\n\t\t\tif (f[i] == p.f[i]) continue;\n\t\t\treturn f[i] < p.f[i];\t\t\t\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p)\n{\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tif (p.f[i] != (i+1)) return false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle s)\n{\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u,v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\twhile(!Q.empty())\n\t{\n\t\tu = Q.front(); Q.pop();\n\t\tif (isTarget(u)) return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r)\n\t\t{\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif( tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!V[v])\n\t\t\t{\n\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main()\n{\n\tPuzzle in;\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tcin>>in.f[i];\n\t\tif (in.f[i]==0) {\n\t\t\tin.space = i;\n\t\t        in.f[i] = 10;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout<<ans.size()<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <algorithm>\n\nconst int N = 4e5 + 1;\n\nbool vis[N];\nint fac[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320};\nstd::queue<std::pair<std::vector<int>, int>> q;\n\nint get_rank(std::vector<int> &cur) {\n  int rank = 0;\n  for (int i = 0; i < 9; ++i) {\n    int cnt = 0;\n    for (int j = i + 1; j < 9; ++j) {\n      if (cur[j] < cur[i]) cnt ++;\n    }\n    rank += cnt * fac[8 - i];\n  }\n  return rank;\n}\n\nvoid extend(std::vector<int> &cur, int pos, int step, int opr, int opc) {\n  auto nxt = cur;\n  int r = pos / 3;\n  int c = pos % 3;\n  int nr = r + opr;\n  int nc = c + opc;\n  if (nr >= 0 && nr < 3 && nc >= 0 && nc < 3) {\n    int np = nr * 3 + nc;\n    std::swap(nxt[pos], nxt[np]);\n    int rank = get_rank(nxt);\n    if (!vis[rank]) {\n      q.push({nxt,  step + 1});\n      vis[rank] = 1;\n    }\n\n  }\n}\n\nint main() {\n  while (!q.empty()) q.pop();\n  memset(vis, 0, sizeof(vis));\n  std::vector<int> goal = {1, 2, 3, 4, 5, 6, 7, 8, 0};\n  int target = get_rank(goal);\n  std::vector<int> st(9);\n  for (int i = 0; i < 9; ++i) std::cin >> st[i];\n  q.push({st, 0});\n  vis[get_rank(st)] = 1;\n  while (!q.empty()) {\n    auto cur = q.front();\n    q.pop();\n    auto p = cur.first;\n    int step = cur.second;\n    if (get_rank(p) == target) {\n      std::cout << step << std::endl;\n      return 0;\n    }\n    if (step + 1 > 45) continue;\n    int pos;\n    for (int i = 0; i < 9; ++i) {\n      if (p[i] == 0) pos = i;\n    }\n    extend(p, pos, step, 0, 1);\n    extend(p, pos, step, 0, -1);\n    extend(p, pos, step, 1, 0);\n    extend(p, pos, step, -1, 0);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n// ---------------------\n// repetition\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n// debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n// ---------------------\n#define INF 922337203685477580\n#define IINF (1<<21)\ntypedef long long ll;\n\n\nclass Board {\npublic:\n  int board[3][3];\n  Board() {}\n  Board(int b[3][3]) {\n    REP(i, 3) {\n      REP(j, 3) {\n        board[i][j] = b[i][j];\n      }\n    }\n  }\n\n  int hash() {\n    int accum = 0;\n    int digit = 1;\n    REP(i, 3) {\n      REP(j, 3) {\n        accum += board[i][j] * digit;\n        digit *= 10;\n      }\n    }\n    return accum;\n  }\n  string to_str() {\n    string str = \"\";\n    REP(i, 3) {\n      REP(j, 3) {\n        str += \" \" + to_string(board[i][j]);\n      }\n      str += \"\\n\";\n    }\n    return str;\n  }\n  bool operator==( const Board& other) {\n    REP(i, 3) {\n      REP(j, 3) {\n        if (board[i][j] != other.board[i][j]) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n};\n\nclass Nully;\nstatic Board Nully;\n\nBoard swap_with_upper(const Board& b) {\n  int pos_i, pos_j;\n  REP(i, 3) {\n    REP(j, 3) {\n      if (b.board[i][j] == 0) {\n        pos_i = i;\n        pos_j = j;\n        break;\n      }\n    }\n  }\n  if (pos_i == 0) {\n    return Nully;\n  }\n\n  Board next = b;\n  swap(next.board[pos_i][pos_j], next.board[pos_i - 1][pos_j]);\n  return next;\n}\nBoard swap_with_lower(const Board& b) {\n  int pos_i, pos_j;\n  REP(i, 3) {\n    REP(j, 3) {\n      if (b.board[i][j] == 0) {\n        pos_i = i;\n        pos_j = j;\n        break;\n      }\n    }\n  }\n  if (pos_i == 2) {\n    return Nully;\n  }\n\n  Board next = b;\n  swap(next.board[pos_i][pos_j], next.board[pos_i + 1][pos_j]);\n  return next;\n}\nBoard swap_with_left(const Board& b) {\n  int pos_i, pos_j;\n  REP(i, 3) {\n    REP(j, 3) {\n      if (b.board[i][j] == 0) {\n        pos_i = i;\n        pos_j = j;\n        break;\n      }\n    }\n  }\n  if (pos_j == 0) {\n    return Nully;\n  }\n\n  Board next = b;\n  swap(next.board[pos_i][pos_j], next.board[pos_i][pos_j - 1]);\n  return next;\n}\nBoard swap_with_right(const Board& b) {\n  int pos_i, pos_j;\n  REP(i, 3) {\n    REP(j, 3) {\n      if (b.board[i][j] == 0) {\n        pos_i = i;\n        pos_j = j;\n        break;\n      }\n    }\n  }\n  if (pos_j == 2) {\n    return Nully;\n  }\n\n  Board next = b;\n  swap(next.board[pos_i][pos_j], next.board[pos_i][pos_j + 1]);\n  return next;\n}\n\nint main() {\n  // int b[3][3] = {{1, 3, 0}, {4, 2, 5}, {7, 8, 6}};\n  int b[3][3];\n  REP(i, 3) {\n    REP(j, 3) {\n      cin >> b[i][j];\n    }\n  }\n\n  int g[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};\n  Board init(b);\n  Board goal(g);\n  // cout << init.to_str() << endl;\n\n  int depth = 0;\n  queue<pair<Board, int> > Q;\n  Q.push(make_pair(init, depth));\n\n  while (!Q.empty()) {\n    Board current = Q.front().first;\n    Board next;\n    int dpt = Q.front().second;\n    Q.pop();\n\n    if (goal == current) {\n      cout << dpt << endl;\n      return 0;\n    }\n\n    next = swap_with_upper(current);\n    if (!(next == Nully)) {\n      Q.push(make_pair(next, dpt + 1));\n    }\n    next = swap_with_lower(current);\n    if (!(next == Nully)) {\n      Q.push(make_pair(next, dpt + 1));\n    }\n    next = swap_with_left(current);\n    if (!(next == Nully)) {\n      Q.push(make_pair(next, dpt + 1));\n    }\n    next = swap_with_right(current);\n    if (!(next == Nully)) {\n      Q.push(make_pair(next, dpt + 1));\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < ( const Puzzle &p ) const {\n    for(int i=0;i<N2;i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++)\n    if(p.f[i] != (i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u=Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space = tx * N + ty;\n      if(!V[v]){\n\tV[v] = true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0;i<N2;i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define loop(i,j,k) for(long long i = j;i < k;i++)\n#include <iostream>\n#include <queue>\n#include <array>\n#include <utility>\n#include <set>\n\nusing namespace std;\n\nlong mhash(array<array<int,3>,3>& e) {\n\tlong res = 0;\n\tlong cb = 1;\n\tloop(i,0,9) {\n\t\tres += cb * e[i/3][i%3];\n\t\tcb = cb * 9;\n\t}\n\treturn res;\n}\n\nbool cp(array<array<int,3>,3>& e) {\n\tloop(i,0,3)loop(j,0,3)if(e[i][j]!=(1+j+i*3)%9)return false;\n\treturn true;\n}\n\n\nint main() {\n\tset<long> ald; \n\tarray<array<int,3>,3> pz;\n\tqueue<pair<array<array<int,3>,3> ,int>> q;\n\tloop(i,0,3)loop(j,0,3)cin>>pz[i][j];\n\tq.push(make_pair(pz,0));\n\tif(cp(pz)) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\twhile(!q.empty()) {\n\t\tauto cur = q.front().first;\n\t\tint dep = q.front().second + 1;\n\t\tq.pop();\n\t\tint r=-1,c=-1;\n\t\tloop(i,0,3)loop(j,0,3)if(cur[i][j] == 0){r=i;c=j;}\n\t\tif(r!=2) {\n\t\t\tswap(cur[r][c],cur[r+1][c]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tlong hs = mhash(cur);\n\t\t\t\tif(ald.find(hs) == ald.end()){\n\t\t\t\t\tq.push(make_pair(cur,dep));\n\t\t\t\t\tald.insert(hs);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(cur[r][c],cur[r+1][c]);\n\t\t}\n\t\tif(r!=0) {\n\t\t\tswap(cur[r][c],cur[r-1][c]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tlong hs = mhash(cur);\n\t\t\t\tif(ald.find(hs) == ald.end()){\n\t\t\t\t\tq.push(make_pair(cur,dep));\n\t\t\t\t\tald.insert(hs);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(cur[r][c],cur[r-1][c]);\n\t\t}\n\t\tif(c!=2) {\n\t\t\tswap(cur[r][c],cur[r][c+1]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tlong hs = mhash(cur);\n\t\t\t\tif(ald.find(hs) == ald.end()){\n\t\t\t\t\tq.push(make_pair(cur,dep));\n\t\t\t\t\tald.insert(hs);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(cur[r][c],cur[r][c+1]);\n\t\t}\n\t\tif(c!=0) {\n\t\t\tswap(cur[r][c],cur[r][c-1]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tlong hs = mhash(cur);\n\t\t\t\tif(ald.find(hs) == ald.end()){\n\t\t\t\t\tq.push(make_pair(cur,dep));\n\t\t\t\t\tald.insert(hs);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(cur[r][c],cur[r][c-1]);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <stack>\n\nusing namespace std;\n\nint minimum=-1;\n\nint checkTable[362880];\n\nvoid setNUM(int table[3][3], long long x){\n\tint S = 100000000;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int k=0;k<3;k++){\n\t\t\ttable[i][k] = x/S;\n\t\t\tx = x%S;\n\t\t\tS /= 10;\n\t\t}\n\t}\n}\n\nint getNUM(int x){\n\tswitch(x){\n\tcase 0:return 1;\n\tcase 1:return 1;\n\tcase 2:return 2;\n\tcase 3:return 6;\n\tcase 4:return 24;\n\tcase 5:return 120;\n\tcase 6:return 720;\n\tcase 7:return 5040;\n\tcase 8:return 40320;\n\t}\n\treturn -1;\n}\n\nlong long makeLong(int Table[3][3]){\n\treturn 100000000*Table[0][0]+10000000*Table[0][1]+1000000*Table[0][2]+\n            100000*Table[1][0]+10000*Table[1][1]+1000*Table[1][2]+ 100*Table[2][0]+\n            10*Table[2][1]+Table[2][2];\n}\n\nint translateORDER(int Table[3][3]){\n\tlong long x = makeLong(Table);\n\tint checkTable[9] = {0};\n\tlong long S = 100000000;\n\tint ret = 0,small_num_appear_count;\n\tfor(int i=8; i >= 0; i--){\n\t\tsmall_num_appear_count=0;\n\t\tfor(int k = 0; k < (x/S);k++){\n\t\t\tif(checkTable[k] == 1)small_num_appear_count++;\n\t\t}\n\t\tret += ((x/S)-small_num_appear_count)*getNUM(i);\n\t\tcheckTable[(x/S)]=1;\n\t\tx %= S;\n\t\tS /= 10;\n\t}\n\n\treturn ret;\n}\n\n\nint calcDiffSum(int table[3][3]){\n\tint sum = 0;\n\tfor(int row=0;row<3;row++){\n\t\tfor(int col=0;col<3;col++){\n\t\t\tif(table[row][col] != 0){\n\t\t\t\tsum += abs((table[row][col]-1)/3-row) + abs((table[row][col]-1)%3-col);\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\n\nint zeroLoc(int table[3][3]){\n\tint zero_loc;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int k=0;k<3;k++){\n\t\t\tif(table[i][k]==0){\n\t\t\t\tzero_loc=10*i+k;\n\t\t\t}\n\t\t}\n\t}\n\treturn zero_loc;\n}\n\nint main(){\n\n\tfor(int i = 0; i < 362880;i++)checkTable[i]=-1;\n\n\tint table[3][3];\n\tstack<long long>A,B;\n\n\n\tfor(int i=0;i<3;i++){\n\t\tscanf(\"%d %d %d\",&table[i][0],&table[i][1],&table[i][2]);\n\t}\n\n\tcheckTable[translateORDER(table)]=0;\n\tA.push(makeLong(table));\n\tlong long tmp;\n\tbool foundFLG=false;\n\n\tfor(int count=0;count < 362880;count++){\n\t\tif(count%2 == 0){\n\t\t\twhile(!A.empty()){\n\t\t\t\ttmp = A.top();\n\t\t\t\tA.pop();\n\t\t\t\tint tmpTable[3][3];\n\t\t\t\tsetNUM(tmpTable,tmp);\n\t\t\t\tif(calcDiffSum(tmpTable)==0){\n\t\t\t\t\tfoundFLG=true;\n\t\t\t\t\tprintf(\"%d\\n\",count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tint next_table[4][3][3];\n\n\t\t\t\tfor(int a=0;a<4;a++){\n\t\t\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\t\t\tnext_table[a][b][c] = tmpTable[b][c];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tswitch(zeroLoc(tmpTable)){\n\t\t\t\tcase 0:\n\t\t\t\t\tswap(next_table[0][0][0],next_table[0][0][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\n\t\t\t\t\tswap(next_table[1][0][0],next_table[1][1][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tswap(next_table[0][0][1],next_table[0][0][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\n\t\t\t\t\tswap(next_table[1][0][1],next_table[1][0][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[2][0][1],next_table[2][1][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[2]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tswap(next_table[0][0][2],next_table[0][0][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\n\t\t\t\t\tswap(next_table[1][0][2],next_table[1][1][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:\n\t\t\t\t\tswap(next_table[0][1][0],next_table[0][0][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][1][0],next_table[1][1][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[2][1][0],next_table[2][2][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[2]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 11:\n\t\t\t\t\tswap(next_table[0][1][1],next_table[0][0][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][1][1],next_table[1][1][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[2][1][1],next_table[2][1][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[2]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[3][1][1],next_table[3][2][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[3])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[3])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[3]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 12:\n\t\t\t\t\tswap(next_table[0][1][2],next_table[0][0][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][1][2],next_table[1][1][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[2][1][2],next_table[2][2][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[2]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 20:\n\t\t\t\t\tswap(next_table[0][2][0],next_table[0][1][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][2][0],next_table[1][2][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 21:\n\t\t\t\t\tswap(next_table[0][2][1],next_table[0][2][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][2][1],next_table[1][1][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[2][2][1],next_table[2][2][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[2]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 22:\n\t\t\t\t\tswap(next_table[0][2][2],next_table[0][1][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][2][2],next_table[1][2][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tB.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}else{\n\t\t\twhile(!B.empty()){\n\t\t\t\ttmp = B.top();\n\t\t\t\tB.pop();\n\t\t\t\tint tmpTable[3][3];\n\t\t\t\tsetNUM(tmpTable,tmp);\n\t\t\t\tif(calcDiffSum(tmpTable)==0){\n\t\t\t\t\tfoundFLG=true;\n\t\t\t\t\tprintf(\"%d\\n\",count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\t\tint next_table[4][3][3];\n\n\t\t\t\tfor(int a=0;a<4;a++){\n\t\t\t\t\tfor(int b=0;b<3;b++){\n\t\t\t\t\t\tfor(int c=0;c<3;c++){\n\t\t\t\t\t\t\tnext_table[a][b][c] = tmpTable[b][c];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tswitch(zeroLoc(tmpTable)){\n\t\t\t\tcase 0: //??????\n\t\t\t\t\tswap(next_table[0][0][0],next_table[0][0][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\n\t\t\t\t\tswap(next_table[1][0][0],next_table[1][1][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tswap(next_table[0][0][1],next_table[0][0][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\n\t\t\t\t\tswap(next_table[1][0][1],next_table[1][0][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[2][0][1],next_table[2][1][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[2]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\t//??????\n\t\t\t\t\tswap(next_table[0][0][2],next_table[0][0][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\n\t\t\t\t\tswap(next_table[1][0][2],next_table[1][1][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:\n\t\t\t\t\tswap(next_table[0][1][0],next_table[0][0][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][1][0],next_table[1][1][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[2][1][0],next_table[2][2][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[2]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 11:\n\t\t\t\t\tswap(next_table[0][1][1],next_table[0][0][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][1][1],next_table[1][1][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[2][1][1],next_table[2][1][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[2]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[3][1][1],next_table[3][2][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[3])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[3])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[3]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 12:\n\t\t\t\t\tswap(next_table[0][1][2],next_table[0][0][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][1][2],next_table[1][1][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[2][1][2],next_table[2][2][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[2]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 20:\n\t\t\t\t\tswap(next_table[0][2][0],next_table[0][1][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][2][0],next_table[1][2][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 21:\n\t\t\t\t\tswap(next_table[0][2][1],next_table[0][2][0]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][2][1],next_table[1][1][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[2][2][1],next_table[2][2][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[2])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[2])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[2]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 22:\n\t\t\t\t\tswap(next_table[0][2][2],next_table[0][1][2]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[0])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[0])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[0]));\n\t\t\t\t\t}\n\t\t\t\t\tswap(next_table[1][2][2],next_table[1][2][1]);\n\t\t\t\t\tif(checkTable[translateORDER(next_table[1])] == -1){\n\t\t\t\t\t\tcheckTable[translateORDER(next_table[1])]=count;\n\t\t\t\t\t\tA.push(makeLong(next_table[1]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(foundFLG)break;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, s, n) for (int i = s; i < n; i++)\n#define rep(i, n) REP(i, 0, n)\n\nusing namespace std;\n\n// data\nint P[3][3];\n\nvoid solve();\nint main(){\n    rep(i, 3){\n        rep(j, 3){\n            cin >> P[i][j];\n        }\n    }\n\n    solve();\n}\n\nint manhattan(int (*P)[3]){\n    int dst = 0;\n    rep(i, 3){\n        rep(j, 3){\n            if(P[i][j] == 0) continue;\n\n            int ti = (P[i][j] - 1) / 3,\n                tj = (P[i][j] - 1) % 3; // target location\n            dst += abs(ti - i) + abs(tj - j);\n        }\n    }\n\n    return dst;\n}\n\ntypedef pair<int, int> Pi;\n\nstruct State{\n    State(int (*P0)[3], int move0, Pi blankBef, Pi blankNow){\n        rep(i, 3)\n            rep(j, 3)\n                P[i][j] = P0[i][j];\n        move = move0;\n        dst = manhattan(P) + move;\n        blank = blankNow;\n        _blank = blankBef;\n    }\n    friend bool operator>(State s0, State s1){\n        return s0.dst > s1.dst;\n    }\n    int dst;\n    int move;\n    int P[3][3];\n    pair<int, int> blank, _blank;\n};\n\nconst int di[4] = {-1, 1, 0 ,0},\n    dj[4] = {0,0,-1, 1};\nvoid solve(){\n    // find blank\n    int bi, bj;\n    rep(i, 3)\n        rep(j, 3) if (P[i][j] == 0) bi = i,\n                                    bj = j;\n\n    State s0(P, 0, Pi(bi, bj), Pi(bi, bj));\n    priority_queue<State, vector<State>, greater<State> > pq;\n    pq.push(s0);\n\n    while(!pq.empty()){\n        State s = pq.top(); pq.pop();\n\n        // check final\n        if(manhattan(s.P) == 0){\n            cout << s.move << endl;\n            break;\n        }\n        \n        rep(i, 4){\n            int ii, jj;\n            ii = s.blank.first + di[i];\n            jj = s.blank.second + dj[i];\n\n            if(ii>=0&&ii<3 && jj>=0&&jj<3 && Pi(ii, jj)!= s._blank){\n                swap(s.P[s.blank.first][s.blank.second], \n                    s.P[ii][jj]);\n\n                pq.push(State(s.P, s.move+1, s.blank, Pi(ii, jj)));\n\n                swap(s.P[s.blank.first][s.blank.second],\n                     s.P[ii][jj]);\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define ALL(v) (v).begin(), (v).end()\n#define p(s) cout<<(s)<<endl\n#define p2(s, t) cout << (s) << \" \" << (t) << endl\n#define br() p(\"\")\n#define pn(s) cout << (#s) << \" \" << (s) << endl\n#define p_yes() p(\"Yes\")\n#define p_no() p(\"No\")\n\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e18;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, 1, 0, -1};\n\ntemplate < typename T >\nvoid vprint(T &V){\n\tfor(auto v : V){\n    \tcout << v << \" \";\n\t}\n\tcout << endl;\n}\n\nconst int W = 3;\n\nstruct Point{\n    ll x;\n    ll y;\n    Point(ll x, ll y): x(x), y(y) {}\n    Point(){}\n};\n\nstruct Puzzle{\n    ll A[W][W];\n    vector<ll> path;\n\n    Point get_space(){\n        Point p;\n        FOR(y, 0, 3){\n            FOR(x, 0, 3){\n                if(A[y][x]==0){\n                    p.x = x;\n                    p.y = y;\n                    return p;\n                }\n            }\n        }\n        return p;\n    }\n\n    bool operator<(const Puzzle &b)const\n    {\n        FOR(y, 0, 3){\n            FOR(x, 0, 3){\n                if(A[y][x] != b.A[y][x]){\n                    return A[y][x] < b.A[y][x];\n                }\n            }\n        }\n        return false;\n    }\n\n    bool is_solved(){\n        FOR(y, 0, W){\n            FOR(x, 0, W){\n                ll target = W*y + x + 1;\n                if(y==W-1 && x==W-1) target = 0;\n                if(A[y][x]!=target) return false;\n            }\n        }\n        return true;\n    }\n\n    void print(){\n        FOR(y, 0, W){\n            FOR(x, 0, W){\n                cout << A[y][x] << ' ';\n            }\n            cout << endl;\n        }\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    // 初期状態\n    auto p = Puzzle();\n    FOR(y, 0, 3){\n        FOR(x, 0, 3){\n            cin >> p.A[y][x];\n        }\n    }\n\n    // p.print();\n\n    // p.A[0][0] = 1;\n    // p.A[0][1] = 2;\n    // p.A[0][2] = 3;\n    \n    // p.A[1][0] = 4;\n    // p.A[1][1] = 5;\n    // p.A[1][2] = 6;\n    \n    // p.A[2][0] = 7;\n    // p.A[2][1] = 8;\n    // p.A[3][2] = 0;\n\n    // pn(p.is_solved());\n    // return 0;\n    \n\n    map<Puzzle, bool> mp;\n    mp[p] = true;\n\n    queue<Puzzle> que;\n    que.push(p);\n\n    while(!que.empty()){\n        auto pu = que.front();\n        que.pop();\n\n        // pu.print();\n        // br();\n\n        if(pu.is_solved()){\n            p(pu.path.size());\n            return 0;\n        }\n\n        FOR(i, 0, 4){\n            auto sp = pu.get_space();\n            ll x = sp.x;\n            ll y = sp.y;\n            \n            // target position\n            ll tx = x + dx[i];\n            ll ty = y + dy[i];\n\n            auto cp = pu;\n\n            // in range\n            if(0<=tx && tx<W && 0<=ty && ty<W){\n                swap(cp.A[y][x], cp.A[ty][tx]);\n\n                // まだその状態になったことがない\n                if(mp[cp]!=true){\n                    mp[cp] = true;\n                    cp.path.push_back(i);\n                    que.push(cp);\n                }   \n            }\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ------ Includes ------ //\n\n#include <map>\n#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\n\n// ------ Directions ------ //\n\nconst int dx[4] = { 0, 1, 0, -1 };\nconst int dy[4] = { 1, 0, -1, 0 };\n\n\n// ------ BFS ------ //\n\nint BFS(vector<vector<int> > p)\n{\n\t// ------ Initialize ------ //\n\n\tvector<vector<int> > lastboard = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 0 } };\n\n\tmap<vector<vector<int> >, int> D;\n\n\tqueue<pair<vector<vector<int> >, int> > que;\n\n\tD[p] = 1; que.push(make_pair(p, 1));\n\n\n\t// ------ Search ------ //\n\n\tif (p == lastboard)\n\t{\n\t\treturn 0;\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tpair<vector<vector<int> >, int> p1 = que.front(); que.pop();\n\n\n\t\t// ------ 0 Searching ------ //\n\n\t\tint tx = -1, ty = -1;\n\n\t\tfor (int i = 0; i < p1.first.size(); i++)\n\t\t{\n\t\t\tfor (int j = 0; j < p1.first[i].size(); j++)\n\t\t\t{\n\t\t\t\tif (p1.first[i][j] == 0)\n\t\t\t\t{\n\t\t\t\t\ttx = j; ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\t// ------ Moving ------ //\n\n\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t{\n\t\t\tif (0 <= tx + dx[dir] && tx + dx[dir] < p1.first[0].size() && 0 <= ty + dy[dir] && ty + dy[dir] < p1.first.size())\n\t\t\t{\n\t\t\t\tvector<vector<int> > p2 = p1.first;\n\n\t\t\t\tswap(p2[ty][tx], p2[ty + dy[dir]][tx + dx[dir]]);\n\n\t\t\t\tif (D[p2] == 0)\n\t\t\t\t{\n\t\t\t\t\tif (p2 == lastboard)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn p1.second;\n\t\t\t\t\t}\n\n\t\t\t\t\tD[p2] = p1.second + 1;\n\n\t\t\t\t\tque.push(make_pair(p2, p1.second + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tvector<vector<int> > board(3, vector<int>(3, -1));;\n\n\tfor (int i = 0; i < board.size(); i++)\n\t{\n\t\tfor (int j = 0; j < board[i].size(); j++)\n\t\t{\n\t\t\tcin >> board[i][j];\n\t\t}\n\t}\n\n\tcout << BFS(board) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\n/*permutation-id <-> sequence*/\n\n#define MAX_DATASIZE 9\n\nint encode(const int *data, int size){\n  bool used[MAX_DATASIZE] = {};\n  int num = 0;\n  int t = 1;\n  \n  for(int i=1; i<=size; i++) t *= i;\n  \n  for(int i=size; i>=1; i--){\n    t /= i;\n    \n    int s = 0;\n    for(int j=0; j<data[size-i]; j++){\n      if(!used[j]) s++;\n    }\n    \n    used[data[size-i]] = true;\n    num += s * t;\n  }\n  \n  return num;\n}\n\nvoid decode(int num, int *data, int size){\n  bool used[MAX_DATASIZE] = {};\n  int t = 1;\n  \n  for(int i=1; i<=size; i++) t *= i;\n  for(int i=size; i>=1; i--){\n    t /= i;\n    \n    int s = num / t;\n    for(int j=0;;j++){\n      if(!used[j]){\n        if(s == 0){\n          data[size-i] = j;\n          used[j] = true;\n          break;\n        }\n        s--;\n      }\n    }\n    num %= t;\n  }\n}\n\n\n\nbool visited[9*8*7*6*5*4*3*2*1];\n\nint bfs(const int pazzle[9]){\n  queue<int> que;\n  que.push(encode(pazzle, 9));\n\n  int goal[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\n  int goalId = encode(goal, 9);\n  \n  for(int i=0;que.size();i++){\n    queue<int> que2;\n    while(que.size()){\n      int id = que.front(); que.pop();\n      if(visited[id]) continue;\n      visited[id] = true;\n      \n      if(id == goalId) return i;\n\n      int next[9];\n      decode(id, next, 9);  \n\n      for(int i=0;i<9;i++){  \n        if(next[i] == 0){\n          if(i/3 != 0){\n            swap(next[i], next[i-3]);\n            que2.push(encode(next, 9));\n            swap(next[i], next[i-3]);\n          }\n          if(i/3 != 2){\n            swap(next[i], next[i+3]);\n            que2.push(encode(next, 9));\n            swap(next[i], next[i+3]);\n          }\n          if(i%3 != 0){\n            swap(next[i], next[i-1]);\n            que2.push(encode(next, 9));\n            swap(next[i], next[i-1]);\n          }\n          if(i%3 != 2){\n            swap(next[i], next[i+1]);\n            que2.push(encode(next, 9));\n            swap(next[i], next[i+1]);\n          }\n          break;\n        }\n      }\n    }\n    que = que2;\n  }\n\n  return INF;\n}\n\nint main(){\n  int pazzle[9];\n\n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n      scanf(\"%d\", pazzle+(i*3+j));\n    }\n  }\n\n  cout << bfs(pazzle) << endl;\n\n  \n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <sstream>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n#define rrep(i, a) RREP(i, a, 0)\n#define RREP(i, a, b) for(int i = a; i >= b; --i)\n#define repll(i, a) REPLL(i, 0, a)\n#define REPLL(i, a, b) for(ll i = a; i < b; ++i)\n#define rrepll(i, a) RREPLL(i, a, 0)\n#define RREPLL(i, a, b) for(ll i = a; i >= b; --i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<int, P> PP;\nconst double PI = 3.14159265358979323846;\nconst double esp = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+18 + 10;\n\nstruct Panel{\n\tint dat[3][3];\n\tint nx, ny;\n\n\tbool operator < (const Panel &p) const{\n\t\trep(i, 3)rep(j, 3)if (dat[i][j] != p.dat[i][j])return dat[i][j] < p.dat[i][j];\n\t\treturn false;\n\t}\n};\n\nPanel up(Panel p){\n\tif (p.ny != 0)std::swap(p.dat[p.ny][p.nx], p.dat[p.ny - 1][p.nx]), --p.ny;\n\treturn p;\n}\n\nPanel down(Panel p){\n\tif (p.ny != 2)std::swap(p.dat[p.ny][p.nx], p.dat[p.ny + 1][p.nx]), ++p.ny;\n\treturn p;\n}\n\nPanel left(Panel p){\n\tif (p.nx != 0)std::swap(p.dat[p.ny][p.nx], p.dat[p.ny][p.nx - 1]), --p.nx;\n\treturn p;\n}\n\nPanel right(Panel p){\n\tif (p.nx != 2)std::swap(p.dat[p.ny][p.nx], p.dat[p.ny][p.nx + 1]), ++p.nx;\n\treturn p;\n}\n\nbool check(Panel p){\n\trep(i, 3){\n\t\trep(j, 3){\n\t\t\tif (p.dat[i][j] != ((j + 1) + i * 3) % 9)return false;\n\t\t}\n\t}\n\treturn true;\n}\n\ntypedef std::pair<Panel, int> MP;\n\nint main(){\n\tPanel p;\n\trep(i, 3){\n\t\trep(j, 3){\n\t\t\tstd::cin >> p.dat[i][j];\n\t\t\tif (p.dat[i][j] == 0)p.nx = j, p.ny = i;\n\t\t}\n\t}\n\n\tstd::queue<MP> que;\n\tstd::set<Panel> s;\n\tque.push(MP(p, 0));\n\n\twhile (!que.empty()){\n\t\tMP p = que.front();\n\t\tque.pop();\n\n\t\tif (s.find(p.first) != s.end())continue;\n\t\telse s.insert(p.first);\n\n\t\tif (check(p.first)){\n\t\t\tstd::cout << p.second << std::endl;\n\t\t\tbreak;\n\t\t}\n\n\t\tque.push(MP(up(p.first), p.second + 1));\n\t\tque.push(MP(down(p.first), p.second + 1));\n\t\tque.push(MP(left(p.first), p.second + 1));\n\t\tque.push(MP(right(p.first), p.second + 1));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint ans[3][3] =\n{\n    {1, 2, 3},\n    {4, 5, 6},\n    {7, 8, 0}\n};\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { -1, 0, 1, 0 };\n\nbool match(int f[3][3]) {\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            if (f[i][j] != ans[i][j])\n                return false;\n        }\n    }\n    return true;\n}\n\nint dfs(int f[3][3], int x, int y, int v, int d, int l) {\n    if (match(f))\n        return d;\n    if (d > l)\n        return -1;\n    for (int i = 0, res; i < 4; ++i) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (nx < 0 || nx > 2 || ny < 0 || ny > 2 || (i + 2) % 4 == v)\n            continue;\n        f[y][x] = f[ny][nx];\n        f[ny][nx] = 0;\n        if ((res = dfs(f, nx, ny, i, d + 1, l)) > 0)\n            return res;\n        f[ny][nx] = f[y][x];\n        f[y][x] = 0;\n    }\n    return -1;\n}\n\nint main() {\n    int f[3][3], x, y;\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> f[i][j];\n            if (f[i][j] == 0) {\n                y = i;\n                x = j;\n            }\n        }\n    }\n\n    int res;\n    for (int i = 1; i < 50; ++i) {\n        if ((res = dfs(f, x, y, -1, 0, i)) >= 0) {\n            break;\n        }\n    }\n    cout << res << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// File name: 8 Puzzle\n// Written by: by_sknight\n// Date: 2019/5/21\n#include <bits/stdc++.h>\nusing namespace std;\n#define size 3\n\n\nstruct Board {\n\tint P[size][size];\n\tint space_x, space_y;\n\tbool up() {\n\t\tif (space_y == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tswap(P[space_x][space_y], P[space_x][space_y - 1]);\n\t\tspace_y--;\n\t\treturn true;\n\t}\n\tbool down() {\n\t\tif (space_y == size - 1) {\n\t\t\treturn false;\n\t\t}\n\t\tswap(P[space_x][space_y], P[space_x][space_y + 1]);\n\t\tspace_y++;\n\t\treturn true;\n\t}\n\tbool left() {\n\t\tif (space_x == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tswap(P[space_x][space_y], P[space_x - 1][space_y]);\n\t\tspace_x--;\n\t\treturn true;\n\t}\n\tbool right() {\n\t\tif (space_x == size - 1) {\n\t\t\treturn false;\n\t\t}\n\t\tswap(P[space_x][space_y], P[space_x + 1][space_y]);\n\t\tspace_x++;\n\t\treturn true;\n\t}\n\tbool isOver() {\n\t\tint i, j, v;\n\t\tv = 1;\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tfor (j = 0; j < size; j++) {\n\t\t\t\tif (i == size - 1 && j == size - 1) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (P[i][j] != v)\n\t\t\t\t\treturn false;\n\t\t\t\tv++;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tvoid operator=(const Board& obj) {\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tP[i][j] = obj.P[i][j];\n\t\t\t}\n\t\t}\n\t\tspace_x = obj.space_x;\n\t\tspace_y = obj.space_y;\n\t}\n\tbool operator<(const Board& obj) const{\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tif (P[i][j] < obj.P[i][j])\n\t\t\t\t\treturn true;\n\t\t\t\telse if (P[i][j] > obj.P[i][j])\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\nset<Board> status;\nBoard bo;\n\nvoid solution() {\n\tqueue<pair<Board, int> > Q;\n\tBoard now_board;\n\tint now_step;\n\tQ.push(make_pair(bo, 0));\n\twhile (1) {\n\t\tnow_board = Q.front().first;\n\t\tnow_step = Q.front().second;\n\t\tQ.pop();\n\t\t// 如果满足最终条件, 退出循环\n\t\tif (now_board.isOver()) {\n\t\t\tbreak;\n\t\t}\n\t\t// 如果当前棋盘状态已经出现过, 则直接跳过, 处理下一个\n\t\tif (status.insert(now_board).second == false) { \n\t\t\tcontinue;\n\t\t}\n\t\t// 如果可以向上移动空格, 则将向上移动之后的状态与步数存入队列\n\t\tif (now_board.up()) {\n\t\t\tQ.push(make_pair(now_board, now_step + 1));\n\t\t\t// 之后恢复之前的状态\n\t\t\tnow_board.down();\n\t\t}\n\t\t// 以下三个同上\n\t\tif (now_board.down()) {\n\t\t\tQ.push(make_pair(now_board, now_step + 1));\n\t\t\tnow_board.up();\n\t\t}\n\t\tif (now_board.left()) {\n\t\t\tQ.push(make_pair(now_board, now_step + 1));\n\t\t\tnow_board.right();\n\t\t}\n\t\tif (now_board.right()) {\n\t\t\tQ.push(make_pair(now_board, now_step + 1));\n\t\t\tnow_board.left();\n\t\t}\n\t}\n\twhile (!Q.empty()) {\n\t\tQ.pop();\n\t}\n\tcout << now_step << endl;\n\treturn;\n}\n\nint main(void) {\n\tfor (int i = 0; i < size; i++) {\n\t\tfor (int j = 0; j < size; j++) {\n\t\t\tcin >> bo.P[i][j];\n\t\t\tif (bo.P[i][j] == 0) {\n\t\t\t\tbo.space_x = i;\n\t\t\t\tbo.space_y = j;\n\t\t\t}\n\t\t}\n\t}\n\tsolution();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3\nusing namespace std;\n\nint path = 0;\n//goal\nint final[N][N] =\n        {\n                {1, 2, 3},\n                {4, 5, 6},\n                {7, 8, 0}\n        };\n// state space tree nodes\nstruct Node {\n    // stores parent node of current node\n    // helps in tracing path when answer is found\n    Node *parent;\n\n    // stores matrix\n    int mat[N][N];\n\n    // stores blank tile cordinates\n    int x, y;\n\n    // stores the number of misplaced tiles\n    int cost;\n\n    // stores the number of moves so far\n    int level;\n};\n\n// Function to allocate a new node\nNode *newNode(int mat[N][N], int x, int y, int newX,\n              int newY, int level, Node *parent) {\n    Node *node = new Node;\n\n    // set pointer for path to root\n    node->parent = parent;\n\n    // copy data from parent node to current node\n    memcpy(node->mat, mat, sizeof node->mat);\n\n    // move tile by 1 postion\n    swap(node->mat[x][y], node->mat[newX][newY]);\n\n    // set number of misplaced tiles\n    node->cost = INT_MAX;\n\n    // set number of moves so far\n    node->level = level;\n\n    // update new blank tile cordinates\n    node->x = newX;\n    node->y = newY;\n\n    return node;\n}\n\n// botton, left, top, right\nint row[] = {1, 0, -1, 0};\nint col[] = {0, -1, 0, 1};\n\n// Function to calculate the the number of misplaced tiles\n// ie. number of non-blank tiles not in their goal position\nint calculateCost(int initial[N][N], int final[N][N]) {\n    int count = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            if (initial[i][j] && initial[i][j] != final[i][j])\n                count++;\n    return count;\n}\n\n// Function to check if (x, y) is a valid matrix cordinate\nint isSafe(int x, int y) {\n    return (x >= 0 && x < N && y >= 0 && y < N);\n}\n\n// print path from root node to destination node\nvoid checkPath(Node *root) {\n    if (root == NULL)\n        return;\n    checkPath(root->parent);\n    path += 1;\n\n}\n\n// Comparison object to be used to order the heap\nstruct comp {\n    bool operator()(const Node *lhs, const Node *rhs) const {\n        return (lhs->cost + lhs->level) > (rhs->cost + rhs->level);\n    }\n};\n\n\nvoid solve(int initial[N][N], int x, int y,\n           int final[N][N]) {\n\n    priority_queue<Node *, std::vector<Node *>, comp> pq;\n\n    Node *root = newNode(initial, x, y, x, y, 0, NULL);\n    root->cost = calculateCost(initial, final);\n\n    // Add root to list of live nodes;\n    pq.push(root);\n\n    // Finds a live node with least cost,\n    // add its childrens to list of live nodes and\n    // finally deletes it from the list.\n    while (!pq.empty()) {\n        // Find a live node with least estimated cost\n        Node *min = pq.top();\n\n        // The found node is deleted from the list of\n        // live nodes\n        pq.pop();\n\n        // if min is an answer node\n\n        if (min->cost == 0) {\n            checkPath(min);\n            return;\n        }\n\n        // do for each child of min\n        // max 4 children for a node\n        for (int i = 0; i < 4; i++) {\n            if (isSafe(min->x + row[i], min->y + col[i])) {\n                // create a child node and calculate\n                // its cost\n                Node *child = newNode(min->mat, min->x,\n                                      min->y, min->x + row[i],\n                                      min->y + col[i],\n                                      min->level + 1, min);\n                child->cost = calculateCost(child->mat, final);\n\n                // Add child to list of live nodes\n                pq.push(child);\n            }\n        }\n    }\n}\n\n\nint main() {\n    // Initial state\n    int x = 0, y = 0;\n    int initial[N][N] = {{}};\n\n    cin >> initial[0][0] >> initial[0][1] >> initial[0][2];\n    cin >> initial[1][0] >> initial[1][1] >> initial[1][2];\n    cin >> initial[2][0] >> initial[2][1] >> initial[2][2];\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if(initial[i][j] == 0)\n            {\n                x = i;\n                y = j;\n            }\n        }\n    }\n    solve(initial, x, y, final);\n    path -= 1;\n    cout << path << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) (a)>(b)?(b):(a)\n#define max(a,b) (a)>(b)?(a):(b)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nstruct State\n{\n\tint puzzle[9];\n\tint depth;\n\tint evaluation;\n\n\tbool operator<(const State& s)const\n\t{\n\t\treturn evaluation < s.evaluation;\n\t}\n\n\tbool operator>(const State& s)const\n\t{\n\t\treturn evaluation > s.evaluation;\n\t}\n\n\tbool operator==(const State& s)const\n\t{\n\t\tfor (int i = 0; i < 9; i++)\n\t\t{\n\t\t\tif (puzzle[i] != s.puzzle[i])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n};\n\nState goal;\nvector<State> checkedState;\n\nint heuristic(State s)\n{\n\tint eva = 0;\n\tint pos1[9], pos2[9];\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tpos1[s.puzzle[i]] = i;\n\t\tpos2[goal.puzzle[i]] = i;\n\t}\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tint manhattan = 0;\n\t\tmanhattan += abs(pos1[i] / 3 - pos2[i] / 3);\n\t\tmanhattan += abs(pos1[i] % 3 - pos2[i] % 3);\n\t\teva += manhattan;\n\t}\n\treturn eva;\n}\n\nint solve(State start)\n{\n\tpriority_queue<State, vector<State>, greater<State>> pq;\n\n\tpq.push(start);\n\n\twhile (!pq.empty())\n\t{\n\t\tState ts = pq.top();\n\t\tpq.pop();\n\n\t\tcheckedState.push_back(ts);\n\n\t\tif (ts == goal)\n\t\t{\n\t\t\treturn ts.depth;\n\t\t}\n\n\t\tint zeroi = -1;\n\t\tfor (int i = 0; i < 9; i++)\n\t\t{\n\t\t\tif (ts.puzzle[i] == 0)\n\t\t\t{\n\t\t\t\tzeroi = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (zeroi <= 5)\n\t\t{\n\t\t\tState tts = ts;\n\t\t\tint t = tts.puzzle[zeroi];\n\t\t\ttts.puzzle[zeroi] = tts.puzzle[zeroi + 3];\n\t\t\ttts.puzzle[zeroi + 3] = t;\n\t\t\ttts.depth++;\n\t\t\ttts.evaluation = heuristic(tts) + tts.depth;\n\t\t\tif (find(checkedState.begin(), checkedState.end(), tts) == checkedState.end())\n\t\t\t{\n\t\t\t\tpq.push(tts);\n\t\t\t}\n\t\t}\n\t\tif (zeroi % 3 != 2)\n\t\t{\n\t\t\tState tts = ts;\n\t\t\tint t = tts.puzzle[zeroi];\n\t\t\ttts.puzzle[zeroi] = tts.puzzle[zeroi + 1];\n\t\t\ttts.puzzle[zeroi + 1] = t;\n\t\t\ttts.depth++;\n\t\t\ttts.evaluation = heuristic(tts) + tts.depth;\n\t\t\tif (find(checkedState.begin(), checkedState.end(), tts) == checkedState.end())\n\t\t\t{\n\t\t\t\tpq.push(tts);\n\t\t\t}\n\t\t}\n\t\tif (zeroi % 3 != 0)\n\t\t{\n\t\t\tState tts = ts;\n\t\t\tint t = tts.puzzle[zeroi];\n\t\t\ttts.puzzle[zeroi] = tts.puzzle[zeroi - 1];\n\t\t\ttts.puzzle[zeroi - 1] = t;\n\t\t\ttts.depth++;\n\t\t\ttts.evaluation = heuristic(tts) + tts.depth;\n\t\t\tif (find(checkedState.begin(), checkedState.end(), tts) == checkedState.end())\n\t\t\t{\n\t\t\t\tpq.push(tts);\n\t\t\t}\n\t\t}\n\t\tif (3 <= zeroi)\n\t\t{\n\t\t\tState tts = ts;\n\t\t\tint t = tts.puzzle[zeroi];\n\t\t\ttts.puzzle[zeroi] = tts.puzzle[zeroi - 3];\n\t\t\ttts.puzzle[zeroi - 3] = t;\n\t\t\ttts.depth++;\n\t\t\ttts.evaluation = heuristic(tts) + tts.depth;\n\t\t\tif (find(checkedState.begin(), checkedState.end(), tts) == checkedState.end())\n\t\t\t{\n\t\t\t\tpq.push(tts);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tState start;\n\n\tgoal.depth = 0;\n\tgoal.evaluation = 0;\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tgoal.puzzle[i] = (i + 1) % 9;\n\t}\n\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\n\t\tstart.puzzle[i] = n;\n\t}\n\n\tstart.depth = 0;\n\tstart.evaluation = 0;\n\n\tprintf(\"%d\\n\", solve(start));\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fi       first\n#define se       second\n#define sf       scanf\n#define pf       printf\n#define mp       make_pair\n#define pb       push_back\n#define si(x)    scanf(\"%d\", &x)\n#define pi(x)    printf(\"%d\\n\", x)\n#define sl(x)    scanf(\"%lld\", &x)\n#define pl(x)    printf(\"%lld\\n\", x)\n#define all(x)   x.begin(), x.end()\n#define READ(f)  freopen(f, \"r\", stdin)\n#define WRITE(f) freopen(f, \"w\", stdout)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef map<ll, ll> mll;\ntypedef pair<ll, ll> pll;\ntypedef map<int, int> mii;\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\n\nconst ll MAX = 100005;\nconst ll MOD = 1000000007;\nconst ll INF = 1000000000000000;\nconst double PI = 2 * acos(0.0);\nconst double EPS = 0.00000000001;\n\nclass vState {\npublic:\n    int cpuz[3][3];\n};\n\nclass node {\npublic:\n    int g, h, f, zeroI, zeroJ, puzzle[3][3];\n    bool operator < (const node &a) const {\n        return a.f < f;\n    }\n};\n\nint goal[3][3];\nvector<vState> visit;\n\nint calc_heuristic(int puzzle[][3]) {\n    int h = 0;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (goal[i][j] != puzzle[i][j]) h++;\n        }\n    }\n    return h;\n}\n\nvoid set_goal_state() {\n    //pf(\"- Goal State -\\n\\n\");\n    goal[0][0] = 1;\n    goal[0][1] = 2;\n    goal[0][2] = 3;\n    goal[1][0] = 4;\n    goal[1][1] = 5;\n    goal[1][2] = 6;\n    goal[2][0] = 7;\n    goal[2][1] = 8;\n    goal[2][2] = 0;\n    //pf(\"\\n\");\n}\n\nnode set_current_state() {\n    node cur;\n    //pf(\"- Current State -\\n\");\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            si(cur.puzzle[i][j]);\n            if (cur.puzzle[i][j] == 0) {\n                cur.zeroI = i;\n                cur.zeroJ = j;\n            }\n        }\n    }\n    //pf(\"\\n\");\n    cur.h = calc_heuristic(cur.puzzle);\n    cur.g = 0;\n    cur.f = cur.g + cur.h;\n    return cur;\n}\n\nvoid print_state(node x) {\n    pf(\"._______.\\n\");\n    for (int i = 0; i < 3; i++) {\n        pf(\"| \");\n        for (int j = 0; j < 3; j++) {\n            pf(\"%d \", x.puzzle[i][j]);\n        }\n        pf(\"|\\n\");\n    }\n    pf(\"---------\\n\");\n    pf(\"H(n) = %d\\n\", x.h);\n    pf(\"G(n) = %d\\n\", x.g);\n    pf(\"F(n) = %d\\n\\n\", x.f);\n}\n\nbool already_visited(int puzzle[][3]) {\n    for (int i = 0; i < visit.size(); i++) {\n        int flag = true;\n        for (int j = 0; j < 3; j++) {\n            for (int k = 0; k < 3; k++) {\n                if (puzzle[j][k] != visit[i].cpuz[j][k]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (!flag) break;\n        }\n        if (flag) return true;\n    }\n    return false;\n}\n\nbool check_if_goal(int puzzle[][3]) {\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (puzzle[i][j] != goal[i][j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nnode copy_puzzle(int puzzle[][3]) {\n    node x;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            x.puzzle[i][j] = puzzle[i][j];\n        }\n    }\n    return x;\n}\n\nvState copy_puzzle2(int puzzle[][3]) {\n    vState x;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            x.cpuz[i][j] = puzzle[i][j];\n        }\n    }\n    return x;\n}\n\nint astar(node cur) {\n    priority_queue<node> pq;\n    pq.push(cur);\n    int steps = 0;\n    while (!pq.empty()) {\n        steps++;\n        node u = pq.top();\n        //print_state(u);\n        visit.pb( copy_puzzle2(u.puzzle) );\n        while (!pq.empty()) pq.pop(); // clearing queue\n        if (check_if_goal(u.puzzle)) break;\n        // check the moves that can be made from current state\n        // if any moves is already made we will not pass that in the queue, this is to avoid infinite loops\n        if (u.zeroI - 1 >= 0 && goal[u.zeroI - 1][u.zeroJ] != u.puzzle[u.zeroI - 1][u.zeroJ]) {\n            /// UP\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI - 1][u.zeroJ], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.zeroI = u.zeroI - 1;\n                v.zeroJ = u.zeroJ;\n                pq.push(v);\n            }\n        }\n        if (u.zeroI + 1 < 3 && goal[u.zeroI + 1][u.zeroJ] != u.puzzle[u.zeroI + 1][u.zeroJ]) {\n            /// DOWN\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI + 1][u.zeroJ], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.zeroI = u.zeroI + 1;\n                v.zeroJ = u.zeroJ;\n                pq.push(v);\n            }\n        }\n        if (u.zeroJ - 1 >= 0 && goal[u.zeroI][u.zeroJ - 1] != u.puzzle[u.zeroI][u.zeroJ - 1]) {\n            /// LEFT\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI][u.zeroJ - 1], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.zeroI = u.zeroI;\n                v.zeroJ = u.zeroJ - 1;\n                pq.push(v);\n            }\n        }\n        if (u.zeroJ + 1 < 3 && goal[u.zeroI][u.zeroJ + 1] != u.puzzle[u.zeroI][u.zeroJ + 1]) {\n            /// RIGHT\n            node v = copy_puzzle(u.puzzle);\n            swap(v.puzzle[u.zeroI][u.zeroJ + 1], v.puzzle[u.zeroI][u.zeroJ]);\n            if (!already_visited(v.puzzle)) {\n                v.h = calc_heuristic(v.puzzle);\n                v.g = u.g + 1;\n                v.f = v.g + v.h;\n                v.zeroI = u.zeroI;\n                v.zeroJ = u.zeroJ + 1;\n                pq.push(v);\n            }\n        }\n     }\n     return steps;\n}\n\nint main() {\n    set_goal_state();\n    node cur = set_current_state();\n    pf(\"%d\\n\", astar(cur) - 1);\n\n    return 0;\n}\n\n\n/*\n\nTEST 1\n------\n0 1 2\n3 4 5\n6 7 8\n\n7 2 4\n5 0 6\n8 3 1\n\nTEST 2\n------\n1 2 3\n4 5 6\n7 8 0\n\n1 2 0\n4 5 3\n7 8 6\n\nTEST 3\n------\n1 2 3\n8 0 4\n7 6 5\n\n3 6 4\n0 1 2\n8 7 5\n\nTEST 4\n------\n1 2 3\n8 0 4\n7 6 5\n\n1 3 4\n8 6 2\n0 7 5\n\nTEST 5\n------\n1 2 3\n8 0 4\n7 6 5\n\n1 3 4\n8 0 5\n7 2 6\n\nTEST 6 // WORST CASE\n------\n1 2 3\n4 5 6\n7 8 0\n\n6 4 7\n8 5 0\n3 2 1\n\n8 6 7\n2 5 4\n3 0 1\n\n*/\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator<(const Puzzle &p)const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','i','d','r'};\nbool isTarget(Puzzle p){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!=Q.empty()){\n    u=Q.front();Q.pop();\n    is(isTarget(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N)continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  for(int i=0;i<N2;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout<<ans.size()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n#define N 3\n#define N2 9\n  \nstruct 8puzzle{\nint f[N2];\nint space;\nstring path;\n  \nbool operator < (const 8puzzle &p) const{\nfor(int i = 0; i < N2; i++){\nif(f[i] == p.f[i]) continue;\nreturn f[i] > p.f[i];\n}\nreturn false;\n}\n};\n  \nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n  \nbool isTarget(8puzzle p){\nfor(int i = 0; i < N2; i++)\nif(p.f[i] != (i + 1)) return false;\nreturn true;\n}\n  \nstring bfs(8puzzle s){\nqueue<8puzzle> Q;\nmap<8puzzle, bool> V;\n8puzzle u, v;\ns.path = \"\";\nQ.push(s);\nV[s] = true;\n  \nwhile(!Q.empty()){\nu = Q.front(); Q.pop();\nif(isTarget(u)) return u.path;\nint sx = u.space / N;\nint sy = u.space % N;\nfor(int r = 0; r < 4; r++){\nint tx = sx + dx[r];\nint ty = sy + dy[r];\nif(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\nv = u;\nswap(v.f[u.space], v.f[tx * N + ty]);\nv.space = tx * N + ty;\nif(!V[v]){\nV[v] = true;\nv.path += dir[r];\nQ.push(v);\n}\n}\n}\nreturn \"\";\n}\n  \nint main(){\n8puzzle in;\nfor(int i = 0; i < N2; i++){\ncin >> in.f[i];\nif(in.f[i] == 0){\nin.f[i] = N2;\nin.space = i;\n}\n}\nstring ans = bfs(in);\ncout << ans.size() << endl;\n  \nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue> \nusing namespace std;\nint map[5][5];\nint dx[5]={0,0,1,-1},dy[5]={1,-1,0,0};\nqueue<int> a1,a2,a3,a4,a5,a6,a7,a8,a9,jx,jy;\nqueue<int> a;\nbool pd[45000000];\nint main(){\n\tfor(int i=1;i<=3;i++){\n\t\tfor(int j=1;j<=3;j++) {\n\t\t    cin>>map[i][j];\n\t\t    if(i==1 && j==1) a1.push(map[i][j]);\n\t\t    else if(i==1 && j==2) a2.push(map[i][j]);\n\t\t    else if(i==1 && j==3) a3.push(map[i][j]);\n\t\t    else if(i==2 && j==1) a4.push(map[i][j]);\n\t\t    else if(i==2 && j==2) a5.push(map[i][j]);\n\t\t    else if(i==2 && j==3) a6.push(map[i][j]);\n\t\t    else if(i==3 && j==1) a7.push(map[i][j]);\n\t\t    else if(i==3 && j==2) a8.push(map[i][j]);\n\t\t    else if(i==3 && j==3) a9.push(map[i][j]);\n\t\t    if(map[i][j]==0){\n\t\t    \tjx.push(i);\n\t\t    \tjy.push(j);\n\t\t    \ta.push(0);\n\t\t    }\n\t\t}\n\t}\n\tint jishu=0;\n\tjishu=a1.front();\n\tjishu=jishu*9+a2.front();\n\tjishu=jishu*9+a3.front();\n\tjishu=jishu*9+a4.front();\n\tjishu=jishu*9+a5.front();\n\tjishu=jishu*9+a6.front();\n\tjishu=jishu*9+a7.front();\n\tjishu=jishu*9+a8.front();\n\tpd[jishu]=1;\n\tjishu=0;\n\twhile(a1.front()!=1  || a2.front()!=2 || a3.front()!=3 || a4.front()!=4 || a5.front()!=5 || a6.front()!=6 || a7.front()!=7 || a8.front()!=8 || a9.front()!=0){\n\t\tfor(int i=0;i<=3;i++){\n\t\t\tif(jx.front()+dx[i]>=1 && jx.front()+dx[i]<=3 && jy.front()+dy[i]>=1 && jy.front()+dy[i]<=3){\n\t\t\t\tmap[1][1]=a1.front();\n\t\t        map[1][2]=a2.front();\n\t\t        map[1][3]=a3.front();\n\t\t        map[2][1]=a4.front();\n\t\t        map[2][2]=a5.front();\n\t\t        map[2][3]=a6.front();\n\t\t        map[3][1]=a7.front();\n\t\t        map[3][2]=a8.front();\n\t\t        map[3][3]=a9.front();\n\t\t\t\t\n\t\t\t\tmap[jx.front()][jy.front()]=map[jx.front()+dx[i]][jy.front()+dy[i]];\n\t\t\t\tmap[jx.front()+dx[i]][jy.front()+dy[i]]=0;\n\t\t\t\t\n\t\t\t\tjishu=map[1][1];\n\t            jishu=jishu*9+map[1][2];\n\t            jishu=jishu*9+map[1][3];\n\t            jishu=jishu*9+map[2][1];\n\t            jishu=jishu*9+map[2][2];\n\t            jishu=jishu*9+map[2][3];\n\t            jishu=jishu*9+map[3][1];\n\t            jishu=jishu*9+map[3][2];\n\t            \n\t\t\t\tif(pd[jishu]==1) continue;\n\t            else pd[jishu]=1;\n\t\t\t    \n\t\t\t\tfor(int i1=1;i1<=3;i1++){\n\t\t\t    \tfor(int i2=1;i2<=3;i2++){\n\t\t\t    \t\tif(i1==1 && i2==1) a1.push(map[i1][i2]);\n\t\t                else if(i1==1 && i2==2) a2.push(map[i1][i2]);\n\t\t                else if(i1==1 && i2==3) a3.push(map[i1][i2]);\n\t\t                else if(i1==2 && i2==1) a4.push(map[i1][i2]);\n\t\t                else if(i1==2 && i2==2) a5.push(map[i1][i2]);\n\t\t                else if(i1==2 && i2==3) a6.push(map[i1][i2]);\n\t\t                else if(i1==3 && i2==1) a7.push(map[i1][i2]);\n\t\t                else if(i1==3 && i2==2) a8.push(map[i1][i2]);\n\t\t                else a9.push(map[i1][i2]);\n\t\t\t    \t}\n\t\t\t    }\n\t\t\t    jx.push(jx.front()+dx[i]);\n\t\t\t    jy.push(jy.front()+dy[i]);\n\t\t\t    a.push(a.front()+1);\n\t\t\t}\n\t\t\n\t\t}\n\t\ta1.pop(); \n\t\ta2.pop(); \n\t\ta3.pop(); \n\t\ta4.pop(); \n\t\ta5.pop(); \n\t\ta6.pop(); \n\t\ta7.pop(); \n\t\ta8.pop(); \n\t\ta9.pop(); \n\t\tjx.pop();\n\t\tjy.pop();\n\t\ta.pop();\n\t} \n\tcout<<a.front()<<endl;\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cstdlib>\n#include <string>\n#include <queue>\nusing namespace std;\nconst int N = 3;\nconst int N2 = 9;\nconst int x[4] = {0, 0, 1, -1};\nconst int y[4] = {-1, 1, 0, 0};\nconst char ch[4] = {'l', 'r', 'd', 'u'};\n\nclass node{\npublic:\n\tint f[N2];\n\tint space;\n\tstring str;\n\tbool operator< (const node& n) const\n\t{\n\t\tfor (int i = 0; i < N2; ++i)\n\t\t{\n\t\t\tif (f[i] == n.f[i])\n\t\t\t\tcontinue;\n\t\t\treturn f[i] < n.f[i];\n\t\t}\n\t\treturn false;\n\t} \n};\n\nbool Is_Return(const node& n)\n{\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tif (n.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstring bfs(node& n)\n{\n\tqueue<node> Q;\n\tmap<node, bool> ans;\n\tQ.push(n);\n\tans[n] = true;\n\twhile (!Q.empty())\n\t{\n\t\tnode u = Q.front();\n\t\tQ.pop();\n\t\tif (Is_Return(u))\n\t\t\treturn u.str;\n\t\tint tx = u.space / N;\n\t\tint ty = u.space % N;\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint sx = tx + x[i];\n\t\t\tint sy = ty + y[i];\n\t\t\tif (sx < 0 || sy < 0 || sx >= N || sy >= N)\n\t\t\t\tcontinue;\n\t\t\tnode v = u;\n\t\t\tswap(v.f[v.space], v.f[sx * N + sy]);\n\t\t\tv.space = sx * N + sy;\n\t\t\tif (!ans[v])\n\t\t\t{\n\t\t\t\tans[v] = true;\n\t\t\t\tv.str += ch[i];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main()\n{\n\tnode n;\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tcin >> n.f[i];\n\t\tif (n.f[i] == 0)\n\t\t{\n\t\t\tn.space = i;\n\t\t\tn.f[i] = N2;\n\t\t}\n\t}\n\tstring s = bfs(n);\n\tcout << s.length() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n    int f[N2];\n    int space;\n    string path;\n    \n    bool operator < (const Puzzle &p) const{\n        for(int i = 0;i<N2;i++){\n            if(f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const int dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n    for(int i = 0;i<N2;i++)\n    if(p.f[i] != (i+1)) return false;\n    return true;\n}\n\nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n    \n    while(!Q.empty()){\n        u = Q.front(); Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for(int r = 0;r<4;r++){\n            int tx = sx+dx[r];\n            int ty = sy+dy[r];\n            if(tx<0 || ty<0 || tx >=N || ty >=N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx*N+ty]);\n            v.space = tx*N+ty;\n            if(!V[v]){\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    \n    return \"unsolvable\";\n}\n\nint main(){\n    Puzzle in;\n    \n    for(int i = 0;i<N2;i++){\n        cin >> in.f[i];\n        if(in.f[i] == 0 ){\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nbool ok(int a[3][3])\n{\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tif (a[i / 3][i % 3] != i + 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstruct puzzle\n{\n\tint board[3][3];\n\tint distance;\n};\n\nconst int dx[4] = { 0, -1, 1, 0 };\nconst int dy[4] = { -1, 0, 0, 1 };\n\nint main() \n{\n\tpuzzle start;\n\n\tstart.distance = 0;\n\n\tfor (int i = 0; i < 3; i++)\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tcin >> start.board[i][j];\n\n\tqueue<puzzle> que; que.push(start);\n\n\tint Ans = 0;\n\n\tif (ok(start.board) == false)\n\t{\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tpuzzle p = que.front(); que.pop();\n\n\t\t\tint x, y;\n\n\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t\t{\n\t\t\t\t\tif (p.board[i][j] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t\t{\n\t\t\t\tif (0 <= x + dx[dir] && x + dx[dir] < 3 && 0 <= y + dy[dir] && y + dy[dir] < 3)\n\t\t\t\t{\n\t\t\t\t\tpuzzle q = p;\n\n\t\t\t\t\tswap(q.board[y][x], q.board[y + dy[dir]][x + dx[dir]]);\n\n\t\t\t\t\tq.distance = p.distance + 1;\n\n\t\t\t\t\tif (ok(q.board) == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tAns = q.distance; goto Exit;\n\t\t\t\t\t}\n\n\t\t\t\t\tque.push(q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExit:;\n\n\tcout << Ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n  \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n  \nusing namespace std;\n  \ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n  \nconst int INF=1<<29;\nconst double EPS=1e-9;\n  \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nconst int boardw = 3;\n\nstruct BOARD {\n    int map[boardw][boardw];\n};\n \nbool check(BOARD &b) {\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            if (b.map[i][j] == 0) continue;\n            int tgt = i * boardw + j + 1;\n            if (b.map[i][j] != tgt) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint dfs(BOARD &b, int depth, int dir) {\n    if (depth == 0) {\n        if (check(b)) {\n            return 1;\n        } else {\n            return -1;\n        }\n    }\n\n    int px, py;\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            if (b.map[i][j] == 0) {\n                px = j;\n                py = i;\n            }\n        }\n    }\n    int est = 0;\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            if (i * j == boardw * boardw) continue;\n            for (int k = 0; k < boardw; ++k) {\n                for (int l = 0; l < boardw; ++l) {\n                    if (i * boardw + j + 1 == b.map[k][l]) {\n                        est += std::abs(k - i) + std::abs(l - j);\n                    }\n                }\n            }\n        }\n    }\n    if (est > depth) {\n        return -1;\n    }\n    int dx[] = {0, 1, 0, -1};\n    int dy[] = {1, 0, -1, 0};\n    for (int k = 0; k < 4; k++) {\n        if (dir != -1 && k == (dir + 2) % 4) {\n            continue;\n        }\n        int tx = px + dx[k];\n        int ty = py + dy[k];\n        if (tx < 0 || tx >= boardw || ty < 0 || ty >= boardw) continue;\n        int temp = b.map[py][px];\n        b.map[py][px] = b.map[ty][tx];\n        b.map[ty][tx] = temp;\n        \n        int ret = dfs(b, depth - 1, k);\n        \n        temp = b.map[py][px];\n        b.map[py][px] = b.map[ty][tx];\n        b.map[ty][tx] = temp;\n        if (ret != -1) return ret;\n    }\n    return -1;\n}\n \nint main(int argc, char const *argv[]) {\n    BOARD b;\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            cin >> b.map[i][j];\n        }\n    }\n    if (check(b)) {\n        cout << 0 << endl;\n        return 0;\n    }\n    int i = 0;\n    while(++i) {\n        int ret = dfs(b, i, -1);\n        if (ret == 1) {\n            cout << i << endl;\n            return 0;\n        }\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 3\n#define N2 9\nstruct puzzle{\n    int f[N2];\n    int space;\n    string path;\n\n    /*bool operator == (const puzzle &t1) const {\n        for(int i=0;i<N2;++i){\n            if(f[i] != t1.f[i]) return false;\n        }\n        return true;\n    }*/\n    bool operator < (const puzzle &t1) const {\n        for(int i=0;i<N2;++i){\n            if(f[i] == t1.f[i]) continue;\n            return f[i] > t1.f[i];\n        }\n        return false;\n    }\n};\n\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\nconst char dstr[4] = {'d','l','u','r'};\n\nbool target(puzzle u){\n    for(int i=0;i<N2;++i){\n        if(u.f[i] != i+1) return false;\n    }\n    return true;\n}\n\nstring bfs(puzzle init){\n    map<puzzle,bool> m;\n    m[init] = true;\n    queue<puzzle> q;\n    q.push(init);\n    puzzle u, v;\n    int sx, sy, tx, ty;\n    while(!q.empty()){\n        u = q.front();\n        q.pop();\n        if(target(u)) return u.path;\n        tx = u.space/N;\n        ty = u.space%N;\n        for(int i=0;i<4;++i){\n            sx = tx + dx[i];\n            sy = ty + dy[i];\n            if(sx<0 || sy<0 || sx>=N || sy>=N) continue;\n            v = u;\n            v.space = sx*N+sy;\n            swap(v.f[u.space],v.f[v.space]);\n            if(!m[v]){\n                m[v] = true;\n                v.path += dstr[i];\n                q.push(v);\n            }\n        }\n    }\n}\n\n\nint main(){\n    puzzle init;\n    init.path = \"\";\n    for(int i=0;i<N2;++i){\n        cin>>init.f[i];\n        if(init.f[i]==0){\n            init.f[i] = N2;\n            init.space = i;\n        }\n    }\n    string res = bfs(init);\n    cout<<res.size()<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\nvector<int> searched[9];\n\nclass board{\nprivate:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<int> tiles;\n\npublic:\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        REP(i, 9){\n            tiles.push_back(num[i]);\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n    }\n\n    int cost() {\n        return wrongs + moves;\n    }\n\n    void board_to_int(){\n        int k = 0;\n        REP(i, 9)\n            k += (tiles[i] * pow(10, i));\n        REP(i, searched[tiles[0]].size())\n            if(k == searched[tiles[0]][i])\n                return;\n        pq.push(board(tiles, moves+1));\n        searched[tiles[0]].push_back(k);\n        return;\n    }\n\n    void move() {\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\nbool operator< (board b1, board b2){\n    return (b1.cost() > b2.cost()) ? true : false;\n}\n\nint solve(){\n    pq.push(board(original, 0));\n    while(!pq.empty()){\n        auto target = pq.top();\n        pq.pop();\n        if(target.cost() > 100)\n            return -1;\n        if(target.get_wrongs() == 0)\n            return target.cost();\n        target.move();\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = 0;\n    move = solve();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\nusing namespace std;\n#define H 3\n#define W 3\n#define begin 1\n#define end 4\nstruct BOARD{\n        int board[5][5],y,x,count;\n        bool operator<(const BOARD &other)const{\n                for(int i=begin ; i<end ; i++ )\n                        for(int j=begin ; j<end ; j++ ){\n                                if(board[i][j]==other.board[i][j])\n                                        continue;\n                                return board[i][j]>other.board[i][j];\n                        }\n                return false;\n        }\n};\nbool check(BOARD now){\n        int s=1;\n        for(int i=begin ; i<end ; i++ ){\n                for(int j=begin ; j<end ; j++ ){\n                        if(now.board[i][j]==s){\n                                s++;\n                                s%=9;\n                        }else return false;\n                }\n        }\n}\nint main(){\n        int direction[5]={-1,0,1,0,-1};\n        map <BOARD,bool> past;\n        BOARD board;\n        board.count=0;\n        for(int i=begin ; i<end ; i++ ){\n                for(int j=begin ; j<end ; j++ ){\n                        cin >> board.board[i][j] ;\n                        if(board.board[i][j]==0){\n                                board.y=i;\n                                board.x=j;\n                        }\n                }\n        }\n        queue<BOARD> circle;\n        circle.push(board);\n        int count=0;\n        while(circle.size()!=0){\n                board=circle.front();circle.pop();\n                if(board.y<1 || board.y>=4 )continue;\n                if(board.x<1 || board.x>=4 )continue;\n                past[board]=true;\n                if(check(board)){\n                        cout << board.count << endl;\n                        break;\n                }\n                for(int i=0 ; i<4 ; i++ ){\n                        int y=board.y+direction[i];\n                        int x=board.x+direction[i+1];\n                        swap(board.board[board.y][board.x],board.board[y][x]);\n                        swap(board.y,y);swap(board.x,x);\n                        board.count++;\n                        circle.push(board);\n                        board.count--;\n                        swap(board.board[board.y][board.x],board.board[y][x]);\n                        swap(board.y,y);swap(board.x,x);\n                }\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <queue>\n\nint main() {\n    std::vector<int> pazzle(9);\n    for (int i = 0; i < 9; i++) {\n        std::cin >> pazzle[i];\n    }\n\n    \n\n    std::map<std::vector<int>, int> m;\n    std::queue <std::pair<std::vector<int>, int> > q;\n\n    m[pazzle] = 0;\n\n    std::vector<int> ans(9);\n    for (int i = 0; i < 9; i++) {\n        ans[i] = (i + 1) % 9;\n    }\n\n    if (pazzle == ans) {\n        std::cout << 0 << std::endl;\n        return 0;\n    }\n    m[{1, 2, 3, 4, 5, 6, 7, 8, 0}] = 10000;\n\n    q.push({pazzle, 0});\n    while (!q.empty()) {\n        pazzle = q.front().first;\n        int num = q.front().second;\n        q.pop();\n        if (m[{1, 2, 3, 4, 5, 6, 7, 8, 0}] != 0 && m[{1, 2, 3, 4, 5, 6, 7, 8, 0}]  < num) break;\n        //if (m[pazzle] != 0 && m[pazzle] <= num) continue;\n\n        int space = std::find(pazzle.begin(), pazzle.end(), 0) - pazzle.begin();\n\n        if (space > 2) {\n            std::swap(pazzle[space], pazzle[space - 3]);\n            if (m.find(pazzle) == m.end() || m[pazzle] > num + 1) {\n                m[pazzle] = num + 1;\n                q.push({pazzle, num + 1});\n            }\n            std::swap(pazzle[space], pazzle[space - 3]);\n        }\n        if (space < 6) {\n            std::swap(pazzle[space], pazzle[space + 3]);\n            if (m.find(pazzle) == m.end() || m[pazzle] > num + 1) {\n                m[pazzle] = num + 1;\n                q.push({ pazzle, num + 1 });\n            }\n            std::swap(pazzle[space], pazzle[space + 3]);\n        }\n        if (space % 3 != 0) {\n            std::swap(pazzle[space], pazzle[space - 1]);\n            if (m.find(pazzle) == m.end() || m[pazzle] > num + 1) {\n                m[pazzle] = num + 1;\n                q.push({ pazzle, num + 1 });\n            }\n            std::swap(pazzle[space], pazzle[space - 1]);\n        }\n        if (space % 3 != 2) {\n            std::swap(pazzle[space], pazzle[space + 1]);\n            if (m.find(pazzle) == m.end() || m[pazzle] > num + 1) {\n                m[pazzle] = num + 1;\n                q.push({ pazzle, num + 1 });\n            }\n            std::swap(pazzle[space], pazzle[space + 1]);\n        }\n    }\n\n    std::cout << m[{1, 2, 3, 4, 5, 6, 7, 8, 0}] << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <list>\n#include <vector>\n#include <string>\n#include <map>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nstruct state {\n    Board board;\n    int count;\n};\n\nlist<state> q;\nmap<Board,char> history;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    map<Board,char>::iterator it = history.find(s.board);\n    if (it != history.end()) {\n        return -1;\n    }\n    history.insert(make_pair(s.board, ' '));\n//    for (list<state>::iterator it = q.begin(); it != q.end(); ++it) {\n//        if (it->board == s.board) {\n//            return -1;\n//        }\n//    }\n    ++s.count;\n    if (s.board == GOAL) {\n        return s.count;\n    }\n    q.push_back(s);\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0; i < N; ) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            board |= static_cast<long long>((ch - '0')) << (i*4);\n            ++i;\n        }\n    }\n\n    if (board == GOAL) {\n        goto END;\n    }\n\n//    print(GOAL);\n//    print(board);\n\n    q.push_back({ board, 0 });\n    int count = 0;\n    while (!q.empty()) {\n        state s = q.front();\n        q.pop_front();\n        // ?????????????????????\n        int pos;\n        for (pos = 0; pos < N; ++pos) {\n            if (((s.board >> (pos*4)) & 15) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 8パズル\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<string>\n#include<map>\n\n#include<queue>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle\n{\n    int f[N2];\n    int space;\n    string path;\n\n    // --------------------------------------------------\n    // map のキーである Puzzle クラスをキー順に並べるための定義\n    // --------------------------------------------------\n    bool operator < (const Puzzle &p ) const\n    {\n        for(int i = 0; i < N2; i++)\n        {\n            if( f[i] == p.f[i] )\n            {\n                continue;\n            }\n\n            return f[i] > p.f[i];\n        }\n\n        return false;\n    }\n};\n\n// パネルの x 軸方向への移動\nstatic const int dx[4] = {-1, 0 , 1, 0};\n// パネルの y 軸方向への移動\nstatic const int dy[4] = {0, -1, 0, 1};\n// パネルの交換操作を表す文字列 ( 上, 左, 下, 右 )\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\n// 並び替えた結果が目標に到達しているかを検索する\nbool isTarget(Puzzle p)\n{\n    for(int i = 0; i < N2; i++)\n    {\n        if( p.f[i] != ( i + 1 ) )\n        {\n            // 1 〜 9 の順番で並んでいたら目標到達\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// 並び替えを実施するクラス\nstring bfs(Puzzle s)\n{\n    queue<Puzzle> Q;\n    map<Puzzle, bool> Map_V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    Map_V[s] = true;\n\n    while( !Q.empty() )\n    {\n        u = Q.front();\n        Q.pop();\n\n        if( isTarget(u) )\n        {\n            // 目標に到達した\n            return u.path;\n        }\n\n        // ゼロの位置を配列の要素No.に変換する\n        // x : 縦方向, y : 横方向\n        int sx = u.space / N;\n        int sy = u.space % N;\n\n        for(int r = 0; r < 4; r++)\n        {\n            // 無条件に全方向に移動させる\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n\n            if( tx < 0 || ty < 0 || tx >= N || ty >= N )\n            {\n                // 移動した結果, 範囲外なら処理をスキップする\n                continue;\n            }\n\n            // u は元データで並び替えの前の状態を保持する必要があるので, 並び替えはコピーした変数で行う\n            v = u;\n\n            // パネルを入れ替える\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            // ゼロの位置も入れ替える\n            v.space = tx * N + ty;\n\n            // 既に検索済みの状態かを調べる\n            if( !Map_V[v] )\n            {\n                // 検索済みであることを記憶する\n                Map_V[v] = true;\n                // パネルの移動方向を記憶しておく\n                v.path += dir[r];\n                // キューに再度プッシュする\n                Q.push(v);\n            }\n        }\n    }\n\n    return \"unsolvable\";\n\n}\n\nint main(void)\n{\n    Puzzle in;\n\n    for(int i = 0; i < N2; i++)\n    {\n        cin >> in.f[i];\n\n        if( in.f[i] == 0 )\n        {\n            // パネルのゼロの位置を設定する\n            in.f[i] = N2; // set space\n            in.space = i;\n        }\n    }\n\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "///IDA*\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint Map[4][4];\nint max1,min1;\nint start_x,start_y;\nint flag;\nint c[4][2]= {0,1,-1,0,1,0,0,-1};///右（0），上（1），下（2），左（3）；\n\nint HMD()///曼哈顿距离；\n{\n    int i,j,num=0;\n    for(i=0; i<3; i++)\n        for(j=0; j<3; j++)\n            if(Map[i][j]==0)\n                continue;\n            else\n                num+=fabs((Map[i][j]-1)/3-i)+fabs((Map[i][j]-1)%3-j);\n    return num;\n}\n\nvoid start_xyz()///0的起始位置；\n{\n    int i,j;\n    for(i=0; i<3; i++)\n        for(j=0; j<3; j++)\n            if(Map[i][j]==0)\n            {\n                start_x=i;\n                start_y=j;\n                return ;\n            }\n}\n\nvoid swap(int *a,int *b)///交换函数;\n{\n    int t;\n    t=*a;\n    *a=*b;\n    *b=t;\n}\n\nvoid dfs(int x,int y,int s,int last_step)\n{\n    if(flag)\n        return ;\n    if(s==max1)///当结果等于当前假定最优解；\n    {\n        int l=HMD();\n        if(l==0)///与目标状态相同；\n        {\n            min1=s;///记录结果；\n            flag=1;\n        }\n        return ;\n    }\n    for(int i=0; i<4; i++)\n    {\n        if(last_step+i==3&&s>0)///和上次方向不能相反；\n            continue;\n        int dx=x+c[i][0];\n        int dy=y+c[i][1];\n        if(dx<0||dy<0||dx>=3||dy>=3)///是否越界；\n            continue;\n        swap(&Map[dx][dy],&Map[x][y]);///先交换0和要交换数的值；\n        if(HMD()+s<=max1&&!flag)///IDA*剪枝。核心：当前曼哈顿距离+当前深度<=假定最优解；\n        {\n            dfs(dx,dy,s+1,i);\n            if(flag)\n                return ;\n        }\n        swap(&Map[dx][dy],&Map[x][y]);///回溯；\n    }\n}\nint main()\n{\n    char a[10];\n    int i,j;\n    for(i=0;i<3;i++)\n        for(j=0;j<3;j++)\n            scanf(\"%d\",&Map[i][j]);\n    start_xyz();///找到0的起始位置；\n    max1=HMD();///初始假定最优解；\n    flag=0;\n    while(!flag)\n    {\n        dfs(start_x,start_y,0,0);\n        if(!flag)\n            max1++;///增加假定最优解；\n    }\n    printf(\"%d\\n\",min1);\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint Y[4]={-1,0,1,0};\nint X[4]={0,1,0,-1};\nbool in(int a,int b){\n  if(a<0||b<0||3<=a||3<=b)return false;\n  return true;\n}\nint main(){\n  int a;\n  string start=\"\",goal=\"123456780\";\n  for(int i=0;i<9;i++){\n    cin>>a;\n    start+=(a+'0');\n  }\n  queue<string> q;\n  map<string,int> m;\n  m[start]=0;\n  q.push(start);\n  while(!q.empty()){\n    string u=q.front();\n    q.pop();\n    if(u==goal){\n      cout<<m[u]<<endl;\n      break;\n    }\n    int s=-1;\n    for(int i=0;i<u.length();i++)if(u[i]=='0')s=i;\n    int y=s/3,x=s%3;\n    for(int i=0;i<4;i++){\n      int ny=y+Y[i],nx=x+X[i];\n      if(!in(ny,nx))continue;\n      int g=ny*3+nx;\n      string t=u;\n      swap(t[s],t[g]);\n      if(m.find(t)==m.end()){\n        m[t]=m[u]+1;\n        q.push(t);\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\n\n#define NPANEL 9\n\nclass State {\npublic:\n  int panels[9];\n  int empty;\n  State(int p[]) {\n    for (int i = 0; i < NPANEL; i++) {\n      panels[i] = p[i];\n      if (p[i] == 0)\n        empty = i;\n    }\n  }\n  void print() {\n    for (int i = 0; i < NPANEL; i++) {\n      if (i != 0 && i % 3 == 0)\n        printf(\"\\n\");\n      printf(\"%d \", panels[i]);\n    }\n  }\n  bool is_completed() {\n    for (int i = 1; i < NPANEL; i++)\n      if (panels[i - 1] != i)\n        return false;\n    return true;\n  }\n  State left() { return slide(empty, empty - 1); }\n  State above() { return slide(empty, empty - 3); }\n  State right() { return slide(empty, empty + 1); }\n  State bottom() { return slide(empty, empty + 3); }\n  State slide(int x, int y) {\n    auto s = State(panels);\n    swap(s.panels[x], s.panels[y]);\n    s.empty = y;\n    return s;\n  }\n\n  vector<State> nexts() {\n    vector<State> v;\n    if (empty % 3 != 0)\n      v.push_back(left());\n    if (empty >= 3)\n      v.push_back(above());\n    if (empty % 3 != 2)\n      v.push_back(right());\n    if (empty <= 5)\n      v.push_back(bottom());\n    return v;\n  }\n};\n\nbool store(State st) {\n  static set<int> pool;\n  int hash = 0;\n  for (int i = 0; i < NPANEL; i++) {\n    hash *= 10;\n    hash += st.panels[i];\n  }\n  bool exists = (pool.find(hash) != pool.end());\n  if (!exists)\n    pool.insert(hash);\n  return !exists;\n}\n\nstruct Node {\n  State state;\n  int depth;\n};\n\nint solve(State init) {\n  queue<Node> que;\n  que.push(Node{init, 0});\n\n  while (!que.empty()) {\n    Node node = que.front();\n    for (auto s : node.state.nexts()) {\n      if (s.is_completed()) {\n        return node.depth + 1;\n      }\n      if (store(s)) {\n        que.push(Node{s, node.depth + 1});\n      }\n    }\n    que.pop();\n  }\n}\n\nint main() {\n  int data[NPANEL];\n  for (int i = 0; i < NPANEL; i++)\n    cin >> data[i];\n\n  auto s = State(data);\n  cout << solve(s) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\nbool operator < (const Puzzle &p)const{\n  for(int i=0;i<N2;i++){\n    if(f[i] == p.f[i])continue;\n    return f[i] > p.f[i];\n  }\n  return false;\n}\n};  \n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++)\n    if(p.f[i] != (i + 1))return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n    if(isTarget(u))return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r = 0;r<4;r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0||ty<0||tx>=N||ty>=N)continue;\n      v = u;\n      swap(v.f[u.space],v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if(!V[v]){\n\tV[v] = true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0;i<N2;i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < ( const Puzzle &p ) const {\n    for( int i = 0; i < N2; i++){\n      if( f[i] == p.f[i] ) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  for( int i = 0; i < N2; i++ )\n    if( p.f[i] != (i + 1) )return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while( !Q.empty() ){\n    u = Q.front(); Q.pop();\n    if( isTarget(u) )return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for( int r = 0; r < 4; r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if( !V[v] ){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for( int i = 0; i < N2; i++){\n    cin >> in.f[i];\n    if( in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n/*\n  Topic13 ProblemB 8Puzzle\n  8 パズルは１つの空白を含む 3×3 のマス上に 8 枚のパネルが配置され、\n  空白を使ってパネルを上下左右にスライドさせ、絵柄を揃えるパズルです。\n\n  入力\n  入力はパネルの数字あるいは空白を表す 3×3　個の整数です。\n  空白で区切られた 3 つの整数が 3 行で与えられます。\n\n  出力\n  最短手数を１行に出力してください。\n\n  use C++\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n\tint f[N2]; //??????????????????????????°???\n\tint space; //0?????\\??£???????????????\n\tstring path; //???????????§?????????????????????\n\n\tbool operator < (const Puzzle &p) const {\n\t\tfor (int i = 0; i < N2; i++){\n\t\t\tif (f[i] == p.f[i]) continue; //?????£??¨?????????????´???§?????????\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false; //??????????????????\n\t}\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n\tfor (int i = 0; i < N2; i++){\n\t\tif (p.f[i] != (i + 1)) return false; //0???????????£??????????????????????????£???\n\t}\n\treturn true; //???????????????\n}\n\nstring bfs(Puzzle s){\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\"; //???????????????????¨????\n\tQ.push(s);\n\tV[s] = true;\n\n\twhile (!Q.empty()){\n\t\tu = Q.front(); Q.pop();\n\t\tif (isTarget(u)) return u.path;\n\t\tint sx = u.space / N; //space????????§?¨?\n\t\tint sy = u.space % N; //space????¨???§?¨?\n\t\tfor (int r = 0; r < 4; r++){\n\t\t\tint tx = sx + dx[r]; //?????§?¨?\n\t\t\tint ty = sy + dy[r]; //?¨???§?¨?\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N) continue; //???????????????\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!V[v]){\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"unsolvable\";\n}\n\nint main(){\n\tPuzzle in;\n\n\tfor (int i = 0; i < N2; i++){\n\t\tcin >> in.f[i];\n\t\tif (in.f[i] == 0){\n\t\t\tin.f[i] = N2; //0?????´???9???????????????\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl; //unsolvable?????´??????10????????????????????????????????¶???????????????????????????\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define ALL(a) (a).begin(),(a).end()\n#define SORT(c) sort((c).begin(),(c).end())\n#define DESCSORT(c) sort(c.begin(), c.end(), greater<int>())\n\nusing namespace std;\n\nusing LL = long long int;\nusing LD = long double;\n\nusing pii = pair<int, int>;\nusing pll = pair<LL, LL>;\nusing pdd = pair<double, double>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing vl = vector<LL>;\nusing vvl = vector<vl>;\nusing vvvl = vector<vvl>;\nusing vd = vector<double>;\nusing vvd = vector<vd>;\nusing vs = vector<string>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\n\nconst int INF = (1 << 30) - 1;\nconst LL INF64 = ((LL)1 << 62) - 1;\nconst double PI = 3.1415926535897932384626433832795;\n\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\nconst char dir[4] = { 'u', 'l', 'd', 'r' };\n\nint gcd(int x, int y) { return y ? gcd(y, x % y) : x; }\nLL gcd(LL x, LL y) { return y ? gcd(y, x % y) : x; }\n\nconst int N = 3, N2 = 9;\n\nstruct Puzzle {\n\tint board[N2];\n\tint space;\n\tstring path;\n\n\tbool operator < (const Puzzle &p) const {\n\t\tfor (int i = 0; i < N2; i++) {\n\t\t\tif (board[i] == p.board[i]) continue;\n\t\t\treturn board[i] > p.board[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nbool isTarget(Puzzle p) {\n\tfor (int i = 0; i < N2; i++) {\n\t\tif (p.board[i] != i + 1) return false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle p) {\n\tqueue<Puzzle> que;\n\tmap<Puzzle, bool> mp;\n\tp.path = \"\";\n\tque.push(p);\n\tmp[p] = true;\n\n\twhile (!que.empty()) {\n\t\tPuzzle u = que.front(); que.pop();\n\t\tif (isTarget(u)) return u.path;\n\t\tconst int sx = u.space / N;\n\t\tconst int sy = u.space % N;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tconst int nx = sx + dx[i];\n\t\t\tconst int ny = sy + dy[i];\n\t\t\tif (nx < 0 || ny < 0 || nx >= N || ny >= N) continue;\n\t\t\tPuzzle v = u;\n\t\t\tswap(v.board[v.space], v.board[nx * N + ny]);\n\t\t\tv.space = nx * N + ny;\n\t\t\tif (!mp[v]) {\n\t\t\t\tmp[v] = true;\n\t\t\t\tv.path += dir[i];\n\t\t\t\tque.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tPuzzle puzzle;\n\tfor (int i = 0; i < N2; i++) {\n\t\tcin >> puzzle.board[i];\n\t\tif (puzzle.board[i] == 0) {\n\t\t\tpuzzle.board[i] = 9;\n\t\t\tpuzzle.space = i;\n\t\t}\n\t}\n\n\tstring res = bfs(puzzle);\n\tcout << res.size() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<string>\nusing namespace std;\nint c[4][2]={1,0,0,1,-1,0,0,-1};\nint puzzle[10];\n\nmap<string,int> book;\nstruct yun\n{\n    int s;\n    int state[9];\n};\n\nint bfs()\n{\n    int i,j,k,l;\n    yun st,en;\n    queue<yun> Q;\n    st.s=0;\n    for(i=0;i<9;i++)\n        st.state[i]=puzzle[i];\n    Q.push(st);\n    while(Q.size())\n    {\n        st=Q.front();\n        Q.pop();\n        for(k=0;k<9;k++)\n            if(!st.state[k])break;\n        int x=k/3,y=k%3;\n        for(j=0;j<4;j++)\n        {\n            int dx=x+c[j][0];\n            int dy=y+c[j][1];\n            int dz=dx*3+dy;\n            if(dx<0||dy<0||dx>=3||dy>=3)continue;\n            string ss=\"\";\n            for(l=0;l<9;l++)\n                en.state[l]=st.state[l];\n            en.state[k]=en.state[dz];\n            en.state[dz]=0;\n            int f=0;\n            for(l=0;l<8;l++)\n            {\n                ss+=en.state[l]+'0';\n                if(en.state[l]!=l+1)\n                    f=1;\n            }\n          //  cout<<ss<<endl;\n            if(!f)return st.s+1;\n            if(book[ss])continue;\n            book[ss]=1;\n            en.s=st.s+1;\n            Q.push(en);\n        }\n    }\n}\n\nint main()\n{\n    int i;\n    for(i=0;i<9;i++)\n        scanf(\"%d\",&puzzle[i]);\n    int g=0;\n    for(i=0;i<8;i++)\n    {\n        if(puzzle[i]!=i+1)\n            g=1;\n    }\n    int max1;\n    if(!g)\n        max1=0;\n    else max1=bfs();\n    printf(\"%d\\n\",max1);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 22;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i) {\n        return;\n    }\n\n    if (in.path == \"ldrd\")\n        int debug = 0;\n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n    /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\n\nclass board{\nprivate:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<int> tiles;\n\npublic:\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        REP(i, 9){\n            tiles.push_back(num[i]);\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n    }\n\n    int cost() {\n        return wrongs + moves;\n    }\n\n    void move() {\n        pq.pop();\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            pq.push(board(tiles, moves+1));\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\n\n\nbool operator< (board b1, board b2){\n    return (b1.cost() > b2.cost()) ? true : false;\n}\n\nint dfs(int moves, int cutoff){\n    pq.push(board(original, 0));\n    while(!pq.empty()){\n        auto target = pq.top();\n        if(target.cost() > cutoff)\n            return -1;\n        if(target.get_wrongs() == 0)\n            return target.cost();\n        else{\n            target.move();\n        }\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = 0;\n    move = dfs(0, 100);\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const {\n    for(int i=0;i<N2;i++) {\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle);\nstring bfs(Puzzle);\n\nbool isTarget(Puzzle p) {\n  for(int i=0;i<N2;i++) \n    if(p.f[i] != (i+1) ) return false;\n    return true;\n}\n\nint main() {\n\n  Puzzle in;\n  for(int i=0;i<N2;i++) {\n    cin >> in.f[i];\n    if(in.f[i] == 0) {\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}    \n\nstring bfs(Puzzle s) {\n\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while( !Q.empty() ) {\n    u = Q.front(); Q.pop();\n    if(isTarget(u) ) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r=0;r<4;r++) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx<0 || ty<0 || tx >=N || ty >= N ) continue;\n      v = u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space = tx*N+ty;\n      if( !V[v] ) {\n\tV[v] = true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\n     \n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nstruct pz{\n\tint a[9];\n\tint t;\n};\n\nint main()\n{\n\tpz p;\n\tint n = -1;\n\n\tfor (int i = 0; i < 9; i++)\n\t\tcin >> p.a[i];\n\n\tp.t = 0;\n\n\tqueue<pz> que;\n\tque.push(p);\n\n\twhile (!que.empty()) {\n\t\tpz g = que.front();\n\t\tque.pop();\n\n\t\tbool f = 1;\n\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tif (g.a[i] != (i + 1)) {\n\t\t\t\tf = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (f == 1) {\n\t\t\tn = g.t;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (g.a[i] == 0) {\n\t\t\t\tif(i % 3 != 0){\n\t\t\t\t\tg.t++;\n\t\t\t\t\tswap(g.a[i], g.a[i - 1]);\n\t\t\t\t\tque.push(g);\n\t\t\t\t\tswap(g.a[i], g.a[i - 1]);\n\t\t\t\t\tg.t--;\n\t\t\t\t}\n\t\t\t\tif (i % 3 != 2) {\n\t\t\t\t\tg.t++;\n\t\t\t\t\tswap(g.a[i], g.a[i + 1]);\n\t\t\t\t\tque.push(g);\n\t\t\t\t\tswap(g.a[i], g.a[i + 1]);\n\t\t\t\t\tg.t--;\n\t\t\t\t}\n\t\t\t\tif (i / 3 != 0) {\n\t\t\t\t\tg.t++;\n\t\t\t\t\tswap(g.a[i], g.a[i - 3]);\n\t\t\t\t\tque.push(g);\n\t\t\t\t\tswap(g.a[i], g.a[i - 3]);\n\t\t\t\t\tg.t--;\n\t\t\t\t}\n\t\t\t\tif (i / 3 != 2) {\n\t\t\t\t\tg.t++;\n\t\t\t\t\tswap(g.a[i], g.a[i + 3]);\n\t\t\t\t\tque.push(g);\n\t\t\t\t\tswap(g.a[i], g.a[i + 3]);\n\t\t\t\t\tg.t--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << n << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <map>\n\n#define MAX 10000\n#define INFTY 1<<30 // 2^30\n#define N 3\n#define N2 9  // N * N\n#define REP(i,n) for(int i=0;i<n;i++)\n\n/*\npriority_queue<> pq\n push()  pop() size()  top()\nmap<>\n find() begin() end() insert(map<>::value_type())\npair<>\nsort(.begin(), .end())\nsort(arr, arr+N)\nsort(a, a+N, greater<int>())\nbinary_search(vc.begin(), vc.end(), x)  //binary_search???true, false?????????\nvector<int>::iterator lit = lower_bound(vc.begin(), vc.end(), x);\n  lower_bound?????????????????????\"??\\???\"????????????????????????????????????????????¬???????????????\nvector<int>::iterator uit = upper_bound(vc.begin(), vc.end(), x);\n  upper_bound????????????????????????\"?¶???????\"?????????????????????????????????????????¬???????????????\n*/\n\n\nusing namespace std;\n\ntypedef long long llong;\n\nstruct Puzzle\n{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const\n  {\n    for(int i = 0; i < N2; i++)\n    {\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n/*\n  1 3 2       1 2 3\n  4 5 6   <   4 5 6\n  7 8 9       7 8 9\n  : true\n  1 2 3       1 3 2\n  4 5 6   <   4 5 6\n  7 8 9       7 8 9\n  : false\n  ??¨??¨??????\n  : false\n*/\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p)\n{\n  for(int i = 0; i< N2; i++)\n    if(p.f[i] != (i + 1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s)\n{\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty())\n  {\n    u = Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r = 0; r < 4; r++)\n    {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx*N+ty]);\n      v.space = tx*N+ty;\n      if(!V[v])\n      {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  // FROM HERE\n  Puzzle in;\n  for(int i = 0; i < N2; i++)\n  {\n    cin >> in.f[i];\n    if(in.f[i] == 0)\n    {\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl; \n  //cerr << bfs(in) << endl;\n  // END\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n//\n////////////////////////////////////////\n\n#include <iostream>\n#include <algorithm> // next_permutation\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cstring> //memcpy\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <list>\n#include <numeric> //accumulate\n//#include <unordered_map> //hash func.\n#include <fstream> //ifstream, ofstream\n\n//#define NDEBUG //If NDEBUG is defined before #include <cassert>, assert will be ignored. You had better define NDEBUG when u submit the code.\n#include <cassert> //assert\n\n\nusing namespace std;\n\n#define TEST //*******************************************************************************************************************************************\n//?????????????????¨??§?????\\????????????????????????????????°?????????????¨???????????????????dout???????????????????????§???????????¬??????????????????????????????????????????\n//??????????????????????????????????????????????????????????§?CPU???????£??????????????????§???TLE?????????????????????????????????????????§????????¨???                           ????????????????????????cerr????????£????????????????????????????????????\n#ifdef TEST\n#define dout cout\n#define din cin\n#else\nstringstream dummy; //???????????°??????dout?????????????????????????????????\n#define dout dummy.str(\"\"); dummy.clear(stringstream::goodbit); dummy //dummy?????????????????????????????????????????¨?????¢?????¢???????????????\n//???????????¨??????????????????goodbit?????????????????????????????¨???????????´????????????????????????????????¨?????°?????????????????§???????????????????????????????????? http://d.hatena.ne.jp/linden/20060427/p1\n#endif\n\n//If u wanna output to a text file instead of standard output, plz define OUTPUTFILE.\n//#define OUTPUTFILE \"output.txt\" //*******************************************************************************************************************************************\n#ifdef OUTPUTFILE\n#define dout outputfile //??¨????????????TLE????????§?????????dout?????¨??¨??????????????¢????????????????????????????????????????????§????¨????????????´??????????????£??????????????????????¨?????????????????????????????????????????????§?????????????????????\nofstream outputfile(OUTPUTFILE);\n#define OutputFilePath \"/Users/Nag/Documents/Prgm/Test/DerivedData/Test/Build/Products/Debug/output.txt\"\n#endif\n\n//If u wanna input from a text file instead of standard input, plz define INPUTFROMTEXTFILE???.\n//#define INPUTFILE \"input.txt\" //*******************************************************************************************************************************************\n#ifdef INPUTFILE\n#define din inputfile\nifstream inputfile(INPUTFILE);\n#endif\n\n\n#define disp(A) dout << #A << \" = \" << setw(3) << (A) << endl\n#define disP(A) dout << setw(3) << (A) << \" \"\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define dispAll(A,n) dout << #A << \" = \"; rep(j, 0, (n)) {disP(A[j]);} dout << endl\n\n#define p(i) (i)/2\n#define l(i) (i)*2\n#define r(i) (i)*2+1\n\nstruct d {int n, m, r, l;}; //for Binary Search Tree\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\nconst int INF = 2e9+10;\nconst ll INF_LL = 1e18; //Be careful for overflow.\nconst int NONE = -1;\nconst int SUCCESSFUL = -2;\n\n#define GOAL 123456780\n//int numOfMove = -1; //?????°\nll numOfSearch = 0;\n\n#define N_MAX 181440 //num of vertex or element\n#define M_MAX 10000 //num of edge\n\nint N;\n\nstruct d T[N_MAX+1]; //Binary Search Tree\nint H = 0; //num of data in T[]. next new data will be placed on T[H]\n\nqueue<pii> Q; // <puzzle, sign>\n\nvoid printInorder(int i) {\n    if(i==NONE) return;\n    \n    printInorder(T[i].l);\n    dout << \" \" << T[i].n;\n    printInorder(T[i].r);\n}\nvoid printPreorder(int i) {\n    if(i==NONE) return;\n    \n    dout << \" \" << T[i].n;\n    printInorder(T[i].l);\n    printInorder(T[i].r);\n}\nvoid print() {\n    printInorder(0);\n    dout << endl;\n    printPreorder(0);\n    dout << endl;\n}\n\nint find(int x, int i=0) {\n    \n    if(i==NONE) return NONE;\n    if(T[i].n==x) return i;\n    \n    if(x < T[i].n) return find(x, T[i].l);\n    else return find(x, T[i].r);\n    \n}\n\n\nvoid insert(int x, int m, int i=0) { //insert x at T[i]\n\n    if(T[i].n==INF) {\n        T[i].n = x;\n        T[i].m = m; //Binary Search Tree?????°????????¶????????????????????¨?????????????????????????????¶????????????????????¨???????????°????¨?????????????????????????????????¢?´¢?????´????????°???????????°??§????????????\n        H++;\n        return;\n    }\n    \n    if(x < T[i].n) {\n        if(T[i].l==NONE) T[i].l=H;\n        insert(x, m, T[i].l);\n    }\n    else {\n        if(T[i].r==NONE) T[i].r=H;\n        insert(x, m, T[i].r);\n    }\n    \n}\n\nvoid puzzle_int2array(int puzzle, int p[]) {\n    int digit = 1e8;\n    rep(i,0,9) {\n        p[i] = puzzle/digit;\n        puzzle %= digit;\n        digit /= 10;\n    }\n}\n\nint puzzle_array2int(int p[]) {\n    int puzzle = 0;\n    int digit = 1e8;\n    rep(i,0,9) {\n        puzzle += p[i]*digit;\n        digit /= 10;\n    }\n    \n    return puzzle;\n}\n\n\n\n\n\nvoid display(int puzzle) {\n    int digit = 1e8;\n    \n    for(int i=8; i>=0; i--) {\n        dout << puzzle/digit << \" \";\n        if(i%3==0) dout << endl;\n        \n        puzzle %= digit;\n        digit /= 10;\n    }\n}\n\n\n\nvoid solve(int puzzle, int numOfMove=1) {\n    \n//    Q.push(make_pair(puzzle, numOfMove));\n    Q.push(make_pair(puzzle, 1)); //??£????????°?????????????????¢?´¢??????????????°?????????????????¢?´¢\n    Q.push(make_pair(GOAL, -1)); //???????????¢?´¢?????????GOAL????????\\????????????\n    \n    while( !Q.empty() ) {\n        \n        puzzle = Q.front().first;\n        numOfMove = Q.front().second; //??????????????¢?´¢?????´?????????????????°\n        Q.pop();\n        \n        //??£?§£??????\n        int index = find(puzzle);\n        if( index!=NONE ) { //?????§???????????????\n            if(numOfMove*T[index].m < 0) { //numOfMove ??¨ T[index].m ?????°?¬??????§????????°\n                dout << abs(numOfMove) + abs(T[index].m) -2 << endl;\n                return;\n            }\n            else { //????¬??????§????????°\n                continue; //????????????\n            }\n        }\n        \n        insert(puzzle, numOfMove);\n\n        \n//        dout << \"-----------------\\n\";\n//        disp(++numOfSearch);\n//        disp(numOfMove);\n//        display(puzzle);\n        \n\n//??£?§£?????????????¨???§????????????????????£????????§?????????????????????\n//        if(puzzle == GOAL) {\n//            dout << numOfMove << endl;\n//            return;\n//        }\n        \n        int p[9];\n        puzzle_int2array(puzzle,p);\n        \n        \n        //find 0\n        int zero=NONE;\n        rep(i,0,9) {\n            if( p[i] == 0 ) {\n                zero = i;\n                break;\n            }\n        }\n        assert(zero!=NONE); //0 must be found\n        \n        \n        //move 0 to 4 direction\n        \n        //?????°???????????????????????????1????????????\n        if( numOfMove > 0) numOfMove++;\n        else numOfMove--;\n        \n        int alt;\n        \n        alt = zero - 3;\n        if(0<=alt && alt<=8) {\n//            disp(-3);\n            swap(p[zero], p[alt]);\n            \n            puzzle = puzzle_array2int(p);\n            \n            index = find(puzzle);\n            if( index==NONE ) { //???????????????\n                Q.push(make_pair(puzzle, numOfMove));\n//                dout << \"push to Q\\n\";\n            }\n            else if(numOfMove*T[index].m < 0) { //?????????????????£?????¨??????????????°?¬??????§????????°\n                Q.push(make_pair(puzzle, numOfMove));\n            }\n            else { //????¬????????????????????????£????????????????????????\n//                dout << \"already found\\n\";\n            }\n            swap(p[zero], p[alt]);\n        }\n        \n        alt = zero - 1;\n        if(0<=alt && alt<=8 && zero%3!=0) { //0??????????????´?????????????????????\n            //            disp(-1);\n            swap(p[zero], p[alt]);\n            \n            puzzle = puzzle_array2int(p);\n            \n            index = find(puzzle);\n            if( index==NONE ) { //???????????????\n                Q.push(make_pair(puzzle, numOfMove));\n                //                dout << \"push to Q\\n\";\n            }\n            else if(numOfMove*T[index].m < 0) { //?????????????????£?????¨??????????????°?¬??????§????????°\n                Q.push(make_pair(puzzle, numOfMove));\n            }\n            else { //????¬????????????????????????£????????????????????????\n                //                dout << \"already found\\n\";\n            }\n            swap(p[zero], p[alt]);\n        }\n        \n        \n        alt = zero + 1;\n        if(0<=alt && alt<=8 && zero%3!=2) { //0??????????????´?????????????????????\n            //            disp(1);\n            swap(p[zero], p[alt]);\n            \n            puzzle = puzzle_array2int(p);\n            \n            index = find(puzzle);\n            if( index==NONE ) { //???????????????\n                Q.push(make_pair(puzzle, numOfMove));\n                //                dout << \"push to Q\\n\";\n            }\n            else if(numOfMove*T[index].m < 0) { //?????????????????£?????¨??????????????°?¬??????§????????°\n                Q.push(make_pair(puzzle, numOfMove));\n            }\n            else { //????¬????????????????????????£????????????????????????\n                //                dout << \"already found\\n\";\n            }\n            swap(p[zero], p[alt]);\n        }\n        \n        alt = zero + 3;\n        if(0<=alt && alt<=8 ) {\n            //            disp(3);\n            swap(p[zero], p[alt]);\n            \n            puzzle = puzzle_array2int(p);\n            \n            index = find(puzzle);\n            if( index==NONE ) { //???????????????\n                Q.push(make_pair(puzzle, numOfMove));\n                //                dout << \"push to Q\\n\";\n            }\n            else if(numOfMove*T[index].m < 0) { //?????????????????£?????¨??????????????°?¬??????§????????°\n                Q.push(make_pair(puzzle, numOfMove));\n            }\n            else { //????¬????????????????????????£????????????????????????\n                //                dout << \"already found\\n\";\n            }\n            swap(p[zero], p[alt]);\n        }\n        \n    } //end of while-loop\n    \n}\n\n\n\n\nint main() {\n    \n    //initialize\n    rep(i,0,N_MAX+1) {\n        T[i].n = INF;\n        T[i].l = T[i].r = NONE;\n    }\n    \n    int puzzle = 0;\n    int digit = 1e8;\n\n    int p;\n    rep(i,0,9) {\n            din >> p;\n            puzzle += digit * p;\n            digit /= 10;\n    }\n    \n    \n//    display(puzzle);\n    \n    solve(puzzle, 0);\n\n    \n\n    \n    \n    \n    \n#ifdef INPUTFILE\n    inputfile.close();\n#endif\n    \n#ifdef OUTPUTFILE\n    outputfile.close();\n    cout << \"\\\"\" << OutputFilePath << \"\\\"\" << endl;\n#endif\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<cmath>\n#include<queue>\nusing namespace std;\nint inf = 1000000000;\n\nint dx[4] = {0,0,1,-1};\nint dy[4] = {1,-1,0,0};\n\nmap<string, int> mp;\n\nstring trans(vector< vector<int> > a){\n  string t = \"\";\n  for(int i=0; i<3; i++) for(int j=0; j<3; j++) t += to_string(a[i][j]);\n  return t;\n}\n\nvoid dfs(vector< vector<int> > a, int turn){\n  string t = trans(a);\n  if( mp[t] != 0 && turn > mp[t] ) return;\n  if( t == \"123456780\" ){\n    // cout << t << \" \" << turn << \" \" << mp[t] << endl;\n    mp[t] = turn;\n    return;\n  }\n  if( turn > 15 ) return;\n  mp[t] = turn;\n  // cerr << t << \" \" << mp[t] << endl;\n\n  for(int y=0; y<3; y++){\n    for(int x=0; x<3; x++){\n      if( a[y][x] == 0 ){\n        for(int d=0; d<4; d++){\n          int nx = x + dx[d]; int ny = y + dy[d];\n          if( nx < 0 || ny < 0 || nx >= 3 || ny >= 3 ) continue;\n          vector< vector<int> > b = a;\n          swap(b[ny][nx], b[y][x]);\n          string tt = trans(b);\n          dfs(b, turn + 1);\n        }\n      }\n    }\n  }\n  return;\n}\n\nvoid bfs(string sss){\n  queue< pair<int, string> > q;\n  q.push(make_pair(0, sss));\n  map<string, int> mpb;\n  while( !q.empty() ){\n    pair<int, string> p = q.front();\n    q.pop();\n\n    string s = p.second;\n    mpb[s] = p.first;\n    // cerr << p.first << \" \" << p.second << endl;\n    if( s == \"123456780\" ){\n      cout << p.first << endl;\n      return;\n    }\n\n    for(int i=0; i<9; i++){\n      if( s[i] == '0' ){\n        int y = i / 3;\n        int x = i % 3;\n        for(int d=0; d<4; d++){\n          int nx = x + dx[d]; int ny = y + dy[d];\n          // cerr << x << \" \" << y << \" -> \" << nx << \" \" << ny << endl;\n          if( nx < 0 || ny < 0 || nx >= 3 || ny >= 3 ) continue;\n          string t = s;\n          swap(t[i], t[ny*3 + nx]);\n          // cerr << t << endl;\n          if( mpb[t] == 0 ) q.push( make_pair(p.first + 1, t) );\n        }\n      }\n    }\n\n  }\n}\n\nint main(){\n\n  vector< vector<int> > a(3, vector<int>(3));\n  for(int i=0; i<3; i++) for(int j=0; j<3; j++) cin >> a[i][j];\n  // mp[trans(a)] = 0;\n  // mp[\"123456780\"] = inf;\n  // dfs(a, 1);\n  bfs(trans(a));\n  // cout << mp[\"123456780\"] - 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\nconst int N = 9;\nconst string GOAL = \"123456780\";\n\nstruct state {\n    string board;\n    int count;\n};\n\nqueue<state> q;\n\ninline void swap(int numpos, int spacepos, string& board) {\n    char tmp = board[numpos];\n    board[numpos] = board[spacepos];\n    board[spacepos] = tmp;\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    ++s.count;\n    if (s.board == GOAL) {\n        return s.count;\n    }\n    q.push(s);\n    return -1;\n}\n\nint main(void) {\n\n    string board;\n    int i = N;\n    while (i != 0) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            --i;\n            board += ch;\n        }\n    }\n\n//    cout << \"[main] board = \" << board << \"\\n\";\n//    printf(\"[main] board = %s\\n\", board.c_str());\n\n    q.push({ board, 0 });\n    int count = 0;\n    while (!q.empty()) {\n        state s = q.front();\n        q.pop();\n        // ?????????????????????\n\n        int pos;\n        for (int i = 0; i < N; ++i) {\n            if (s.board[i] == '0') {\n                pos = i; break;\n            }\n        }\n\n        if (pos < 3) {\n            if (pos < 2) {\n                if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if (pos > 0) {\n                if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        else if (pos < 6) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n            if (pos < 5) {\n                if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if (pos > 3) {\n                if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        else {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n            if (pos < 8) {\n                if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n            if (pos > 6) {\n                if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                    break;\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <unordered_set>\n#include <queue>\nusing namespace std;\nstruct board{\n    int val[3][3];\n    int now;\n    void in(){\n        for(int i=0;i<3;i++)for(int j=0;j<3;j++)scanf(\"%d\",&val[i][j]);\n        return ;\n    }\n};\nvoid swap(int &a,int &b){\n    int temp=a;\n    a=b;\n    b=temp;\n    return ;\n}\nint btoi(board a){\n    int ans=0;\n    for(int i=0;i<3;i++)for(int j=0;j<3;j++){\n        ans*=9;\n        ans+=a.val[i][j];\n    }\n    return ans;\n}\nint main(){\n    unordered_set<int> s;\n    queue<board> q;\n    board a;\n    int temp;\n    bool f;\n    a.in();\n    a.now=0;\n    q.push(a);\n    s.insert(btoi(a));\n    while(!q.empty()){\n        a=q.front();\n        q.pop();\n        f=true;\n        for(int i=0;i<3&&f;i++)for(int j=0;j<3&&f;j++)f=a.val[i][j]==(i*3+j+1)%9;\n        if(f){\n            printf(\"%d\\n\",a.now);\n            return 0;\n        }\n        a.now++;\n        for(int i=0;i<3;i++)for(int j=0;j<3;j++)if(a.val[i][j]==0){\n            if(i!=0){\n                swap(a.val[i][j],a.val[i-1][j]);\n                temp=btoi(a);\n                if(s.find(temp)==s.end()){\n                    q.push(a);\n                    s.insert(temp);\n                }\n                swap(a.val[i][j],a.val[i-1][j]);\n            }\n            if(i!=2){\n                swap(a.val[i][j],a.val[i+1][j]);\n                temp=btoi(a);\n                if(s.find(temp)==s.end()){\n                    q.push(a);\n                    s.insert(temp);\n                }\n                swap(a.val[i][j],a.val[i+1][j]);\n            }\n            if(j!=0){\n                swap(a.val[i][j],a.val[i][j-1]);\n                temp=btoi(a);\n                if(s.find(temp)==s.end()){\n                    q.push(a);\n                    s.insert(temp);\n                }\n                swap(a.val[i][j],a.val[i][j-1]);\n            }\n            if(j!=2){\n                swap(a.val[i][j],a.val[i][j+1]);\n                temp=btoi(a);\n                if(s.find(temp)==s.end()){\n                    q.push(a);\n                    s.insert(temp);\n                }\n                swap(a.val[i][j],a.val[i][j+1]);\n            }\n            break;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tvector<vector<int>> a(3, vector<int>(3)), b{ { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 0 } };\n\tfor (vector<int>& i : a) {\n\t\tfor (int& j : i) cin >> j;\n\t}\n\tqueue<pair<int, vector<vector<int>>>> c;\n\tc.emplace(0, a);\n\tset<vector<vector<int>>> d;\n\td.insert(a);\n\twhile (true) {\n\t\tqueue<pair<int, vector<vector<int>>>> e;\n\t\twhile (!c.empty()) {\n\t\t\tif (b == c.front().second) break;\n\t\t\tpair<int, int> f;\n\t\t\tfor (int i = 0; i < 9; ++i) {\n\t\t\t\tif (!c.front().second[i / 3][i % 3]) {\n\t\t\t\t\tf.first = i / 3;\n\t\t\t\t\tf.second = i % 3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (2 != f.first) {\n\t\t\t\tswap(c.front().second[1 + f.first][f.second], c.front().second[f.first][f.second]);\n\t\t\t\tif (!d.count(c.front().second)) {\n\t\t\t\t\te.emplace(1 + c.front().first, c.front().second);\n\t\t\t\t\td.insert(c.front().second);\n\t\t\t\t}\n\t\t\t\tswap(c.front().second[1 + f.first][f.second], c.front().second[f.first][f.second]);\n\t\t\t}\n\t\t\tif (2 != f.second) {\n\t\t\t\tswap(c.front().second[f.first][1 + f.second], c.front().second[f.first][f.second]);\n\t\t\t\tif (!d.count(c.front().second)) {\n\t\t\t\t\te.emplace(1 + c.front().first, c.front().second);\n\t\t\t\t\td.insert(c.front().second);\n\t\t\t\t}\n\t\t\t\tswap(c.front().second[f.first][1 + f.second], c.front().second[f.first][f.second]);\n\t\t\t}\n\t\t\tif (f.first) {\n\t\t\t\tswap(c.front().second[f.first - 1][f.second], c.front().second[f.first][f.second]);\n\t\t\t\tif (!d.count(c.front().second)) {\n\t\t\t\t\te.emplace(1 + c.front().first, c.front().second);\n\t\t\t\t\td.insert(c.front().second);\n\t\t\t\t}\n\t\t\t\tswap(c.front().second[f.first - 1][f.second], c.front().second[f.first][f.second]);\n\t\t\t}\n\t\t\tif (f.second) {\n\t\t\t\tswap(c.front().second[f.first][f.second - 1], c.front().second[f.first][f.second]);\n\t\t\t\tif (!d.count(c.front().second)) {\n\t\t\t\t\te.emplace(1 + c.front().first, c.front().second);\n\t\t\t\t\td.insert(c.front().second);\n\t\t\t\t}\n\t\t\t\tswap(c.front().second[f.first][f.second - 1], c.front().second[f.first][f.second]);\n\t\t\t}\n\t\t\tc.pop();\n\t\t}\n\t\tif (!c.empty()) break;\n\t\tswap(c, e);\n\t}\n\tcout << c.front().first << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator < (const Puzzle &p) const {\n\t\tfor (int i = 0; i < N2; i++){\n\t\t\tif (f[i] == p.f[i]) continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n\tfor (int i = 0; i < N2; i++){\n\t\tif (p.f[i] != (i + 1)) return false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle s){\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\n\twhile (!Q.empty()){\n\t\tu = Q.front(); Q.pop();\n\t\tif (isTarget(u)) return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; r++){\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx + N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!V[v]){\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"unsolvable\";\n}\n\nint main(){\n\tPuzzle in;\n\n\tfor (int i = 0; i < N2; i++){\n\t\tcin >> in.f[i];\n\t\tif (in.f[i] == 0){\n\t\t\tin.f[i] = N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\n#define N 9\n#define SIZE 3\n\nusing namespace std;\n\nclass Puzzle{\nprivate:\n    vector<int> table;\n    vector<int> goal;\n    vector<int> checks;\n    const int STATE_NUM;\n    \n    int Factrial(int n){\n        if(n <= 1)\n            return 1;\n        return n * Factrial(n - 1);\n    }\n    \n    int GetSpace(const vector<int> &v){\n        for(int i = 0; i < N; i++)\n            if(v[i] == 0)\n                return i;\n        return -1;\n    }\n    \n    int state_number(vector<int> v){\n        int n = 0;\n        \n        for(int i = 0; i < N - 1 ; i++){\n            n += v[i] * Factrial(N - i - 1);\n            for(int j = i + 1; j < N; j++){\n                if(v[i] < v[j])\n                    v[j]--;\n            }\n        }\n        \n        return n;\n    }\n    \n    queue<int> next_q(vector<int> &v){\n        queue<int> q;\n        int space = GetSpace(v);\n        \n        if(space % SIZE != 2)\n            q.push(space + 1);\n        if(space % SIZE != 0)\n            q.push(space - 1);\n        if(0 <= space + SIZE && space + SIZE < N)\n            q.push(space + SIZE);\n        if(0 <= space - SIZE && space - SIZE < N)\n            q.push(space - SIZE);\n        \n        return q;\n    }\n    \n    int search(int step, vector<vector<int> > &state){\n        std::queue<int> q;\n        int target;\n        int state_num;\n        int q_num = 0;\n        vector<vector<int> > new_state;\n        \n        if(step == 1 && state[0] == goal)\n            return 0;\n        \n        for(vector<vector<int> >::size_type i = 0; i < state.size(); i++){\n            state_num = state_number(state[i]);\n            \n            if(checks[state_num] == 0){\n                checks[state_num] = 1;\n                q = next_q(state[i]);\n                \n                new_state.resize(q.size() + q_num);\n                while(!q.empty()){\n                    new_state[q_num] = state[i];\n                    target = q.front();\n                    q.pop();\n                    \n                    swap(new_state[q_num][target], new_state[q_num][GetSpace(new_state[q_num])]);\n                    if(new_state[q_num] == goal)\n                        return step;\n                    \n                    q_num++;\n                }\n            }\n        }\n        \n        return search(step + 1, new_state);\n    }\n    \npublic:\n    Puzzle() : STATE_NUM(Factrial(N)), table(N){\n        checks.resize(STATE_NUM);\n        \n        for(int i = 0; i < N; i++){\n            cin >> table[i];\n            goal.push_back(i == N - 1 ? 0 : i + 1);\n        }\n    }\n    \n    int GetMinStep(){\n        vector<vector<int> > state(1);\n        state[0] = table;\n        return search(1, state);\n    }\n};\n\nint main(){\n    Puzzle pz;\n    cout << pz.GetMinStep() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\n//\tbool operator <(const Puzzle p) const {\n//\t\tfor (int i = 0; i < N2; ++i) {\n//\t\t\tif (f[i] == p.f[i])\n//\t\t\t\tcontinue;\n//\t\t\treturn f[i] > p.f[i];\n//\t\t}\n//\t\treturn false;\n//\t}\n};\n\nbool isComplete(Puzzle p) {\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif (p.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nconst int dx[4] { -1, 0, 1, 0 };\nconst int dy[4] { 0, -1, 0, 1 };\nconst char dir[4] { 'u', 'l', 'd', 'r' };\n\nstring bfs(Puzzle p) {\n\tqueue<Puzzle> Q;\n\tp.path = \"\";\n\tQ.push(p);\n\tPuzzle u, v;\n\tmap<Puzzle, bool> M;\n//\tM[p] = true;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isComplete(u))\n\t\t\treturn u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n//\t\t\tif (!M[v]) {\n//\t\t\t\tM[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n//\t\t\t}\n\t\t}\n\t}\n\n\treturn \"unresolved\";\n}\n\nint main() {\n\tPuzzle p;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tscanf(\"%d\", &p.f[i]);\n\t\tif (p.f[i] == 0) {\n\t\t\tp.f[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(p);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle\n{\n    int f[N2];\n    int space;\n    string path;\n    bool operator < (const Puzzle &p) const\n    {\n        for(int i=0; i<N2; i++)\n        {\n            if(f[i]==p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p)\n{\n    for(int i=0; i<N2; i++)\n    {\n        if(p.f[i] != (i+1)) return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle s)\n{\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while(!Q.empty())\n    {\n        u = Q.front(); Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for(int r=0; r<4; r++)\n        {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx*N+ty]);\n            v.space = tx*N + ty;\n            if(!V[v])\n            {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main()\n{\n    Puzzle in;\n\n    for(int i=0; i<N2; i++)\n    {\n        cin >> in.f[i];\n        if(in.f[i] == 0)\n        {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstddef>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <array>\n#include <list>\n#include <unordered_map>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <valarray>\n#include <utility>\n#include <tuple>\n#include <cmath>\n#include <memory>\n#include <random>\n#include <fstream>\n#include <locale>\n#include <regex>\n#include <complex>\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\n//vector\ntemplate <class T>\nusing vec = std::vector<T>;\n\ntemplate <class T>\nusing vvec = vec<vec<T>>;\n\nconstexpr std::size_t operator\"\"_sz(ull n) { return std::size_t(n); }\n\nconstexpr int N = 8;\n\nstd::pair<int, vvec<bool>> solve(vvec<bool> map, int y, int x, int queenCount, vec<bool> h, vec<bool> w, vec<bool> tr, vec<bool> br)\n{\n    ++queenCount;\n\n    map[y][x] = true;\n    h[y] = true;\n    w[x] = true;\n    tr[y + x] = true;\n    br[7 - y + x] = true;\n\n    if (queenCount == N)\n    {\n        return make_pair(queenCount, map);\n    }\n\n    for (int i = 0; i < N; ++i)\n        for (int j = 0; j < N; ++j)\n        {\n            if (!h[i] && !w[j] && !tr[i + j] && !br[7 - i + j])\n            {\n\n                auto m = solve(map, i, j, queenCount, h, w, tr, br);\n\n                if (m.first == N)\n                {\n                    queenCount = N;\n                    map = m.second;\n                    goto LOOP_END;\n                }\n            }\n        }\n\n    LOOP_END:\n\n    return make_pair(queenCount, map);\n}\n\nint main()\n{\n    using namespace std;\n    // cerr.rdbuf(nullptr);\n\n    string s;\n    for (int i = 0; i < 3; ++i)\n    {\n        string line;\n        getline(cin, line);\n        s += line;\n    }\n\n    string r;\n    remove_copy(s.cbegin(), s.cend(), back_inserter(r), ' ');\n\n    set<ll> used;\n\n    queue<pair<int, string>> q;\n    q.push(make_pair(0, r));\n\n    const string target = \"123456780\";\n\n    while (!q.empty())\n    {\n        auto current = q.front();\n        q.pop();\n        //cout << current.second << endl;\n\n        if (used.count(stoll(current.second)) == 1)\n            continue;\n        used.emplace(stoll(current.second));\n\n        if (current.second == target)\n        {\n            cout << current.first << endl;\n            break;\n        }\n\n        for (int i = 0; i < 9; ++i)\n            if (current.second[i] == '0')\n            {\n                auto r = i / 3;\n                auto c = i % 3;\n                for (int y = -1; y <= 1; ++y)\n                    for (int x = -1; x <= 1; ++x)\n                    {\n                        if (abs(x) + abs(y) != 1)\n                            continue;\n                        if (r + y < 0 || r + y > 2 || c + x < 0 || c + x > 2)\n                            continue;\n                        auto next = current.second;\n                        swap(next[i], next[(r + y) * 3 + c + x]);\n                        q.push(make_pair(current.first + 1, next));\n                    }\n            }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define NUM 3\n#define PRUNING 100\n\ntypedef struct STATUS{\n    int num;\n    int board[NUM][NUM];\n}STATUS;\n\ntypedef pair<int, int> cell;\n\nbool checkfinish(STATUS in){\n    \n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            if (i == NUM - 1 && j == NUM - 1) return true;\n            if(in.board[i][j] != val++) return false;\n        }\n    }\n    return true;\n}\n\n\nint backtrack(STATUS in, cell last_zero){\n\n    int x = 0, y = 0, ret = PRUNING;\n    cell zero;\n    STATUS out;\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    \n    if (in.num > ret) {\n        return ret;\n    }\n    \n    if (checkfinish(in)) {\n        return in.num;\n    }\n\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            if(in.board[i][j] == 0){\n                x = zero.first = j;\n                y = zero.second = i;\n            }\n        }\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (x + dx[i] >=0 && x+dx[i] < NUM && y+dy[i] >=0 && y+dy[i] < NUM) {\n            if (last_zero.first == x+dx[i] && last_zero.second == y+dy[i]){ continue;\n            }\n            memcpy(&out, &in, sizeof(STATUS));\n            swap(out.board[y][x], out.board[y+dy[i]][x+dx[i]]);\n            out.num++;\n            ret = min(ret, backtrack(out, zero));\n        }\n    }\n    return ret;\n}\n\n\nint main(){\n    \n    int val, ans;\n    \n    STATUS init;\n    init.num = 0;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            cin >> val;\n            init.board[i][j] = val;\n        }\n    }\n    \n    //?????????????????????????????????zero????????¨?????????????????????????????\\????????????\n    ans = backtrack(init, cell(-1,-1));\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define n 3\n#define n1 9\n\n\nstruct puzz{\n  int m[n1];\n  int space;\n  string path;\n  int operator < (const puzz &p)const{\n    for(int i=0;i<n1;i++){\n      if(m[i]==p.m[i])continue;\n      return m[i] > p.m[i];\n    }\n    return false;\n  }\n};\n\n\nstatic const int x[4]={-1,0,1,0};\nstatic const int y[4]={0,-1,0,1};\nstatic const char c[4]={'u','l','d','r'};\n\nint target(puzz p){\n  for(int i=0;i<n1;i++){\n    if(p.m[i]!=(i+1))return false;\n  }\n  return true;\n}\n\nstring am(puzz p){\n  queue<puzz> Q;\n  map<puzz, int> V;\n  puzz a,b;\n  int tmp;\n  p.path=\"\";\n  Q.push(p);\n  V[p]=true;\n\n  while(!Q.empty()){\n    a=Q.front();\n    Q.pop();\n    if(target(a))return a.path;\n    int xx=a.space/n;\n    int yy=a.space%n;\n    for(int k=0;k<4;k++){\n      int xc=xx+x[k];\n      int yc=yy+y[k];\n      if(xc<0||yc<0||xc>=n||yc>=n)continue;\n      b=a;\n      tmp=b.m[a.space];\n      b.m[a.space]=b.m[xc*n+yc];\n      b.m[xc*n+yc]=tmp;\n      b.space=xc*n+yc;\n      if(!V[b]){\n\tV[b]=true;\n\tb.path+=c[k];\n\tQ.push(b);\n\t\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  puzz input;\n  for(int i=0;i<n1;i++){\n    cin>>input.m[i];\n    if(input.m[i]==0){\n      input.m[i]=n1;\n      input.space=i;\n    }\n  }\n  string ans =am(input);\n  cout<<ans.size()<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\n#define MAX_V 200000\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\n\n\nint main(){\n\t\n\tqueue<string> que;\n\t\n\tmap<string, int> m;\n\t\n\tstring fs = \"\";\n\t\n\tfor(int i = 0; i < 9; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tfs += s;\n\t}\n\t\n\tque.push(fs);\n\t\n\tfor(int loop = 0; loop < 1000; loop++){\n\t\tif(que.empty()){\n\t\t\tbreak;\n\t\t}\n\t\tint sz = que.size();\n\t\tfor(int num = 0; num < sz; num++){\n\t\t\tstring str = que.front();\n\t\t\tque.pop();\n\t\t\tif(m.find(str) != m.end()){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tm[str] = loop;\n\t\t\tfor(int i = 0; i < 9; i++){\n\t\t\t\tif(str[i] == '0'){\n\t\t\t\t\tif(i >= 3){\n\t\t\t\t\t\tswap(str[i], str[i - 3]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i - 3]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i < 6){\n\t\t\t\t\t\tswap(str[i], str[i + 3]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i + 3]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i % 3 > 0){\n\t\t\t\t\t\tswap(str[i], str[i - 1]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i - 1]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i % 3 < 2){\n\t\t\t\t\t\tswap(str[i], str[i + 1]);\n\t\t\t\t\t\tque.push(str);\n\t\t\t\t\t\tswap(str[i], str[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << m[\"123456780\"] << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space:\n  string path;\n\n  bool operator < (const puzzle &p) const {\n    for(int i=0; i<N2; i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1);\nstatic const char dir[4] = {'u', 'l', 'd','r'};\n\nbool isTarget(Puzzle p) {\n  for(int i=0; i<N2; i++)\n    if(p.f[o] != (i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space/N;\n    int sy u.space%N;\n    for(int r=0; r<4; r++){\n      int tx = sx+dx[r];\n      int ty = sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n      v=u;\n      swap(v.f[u.space], v.f[tx*N+ty]);\n      v.space = tx*N+ty;\n      if(!V[v]){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"usdolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0; i<N2; i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in .space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\nconst int INF=INT_MAX/3;\nconst int M = 362880; // =9!\nconst int G = 46233; //??´????????????????????£?????°\nvector<int> check(M,0);\nvector<int> preve(M,-1);\nvector<int> d(M,INF);\n\ntypedef vector<int> Board;\n\nint factorial(int n){\n\tif(n==0){\n\t\treturn 0;\n\t}\n\tif(n==1){\n\t\treturn 1;\n\t}\n\treturn n*factorial(n-1);\n}\n\nint translate(Board &b){\n\tBoard bb(9);\n\tbb=b;\n\tint S = 0 ;\n\tfor(int i=0;i<9;i++){\n\t\tS+=factorial(8-i)*bb[i];\n\t\tfor(int j=i+1;j<9;j++){\n\t\t\tif(bb[j]>bb[i]){\n\t\t\t\tbb[j]--;\n\t\t\t}\n\t\t}\n\t}\n\treturn S;\n}\n\nvoid Adj(Board u, vector< Board> &adj){\n\tint zero;\n\tfor(int i=0;i<9;i++){\n\t\tif(u[i]==0){zero=i;}\n\t}\n\n\tif(zero<6){\n\t\tBoard v(9);\n\t\tv=u;\n\t\tswap(v[zero],v[zero+3]);\n\t\tadj.push_back(v);\n\t}\n\tif(zero>2){\n\t\tBoard v(9);\n\t\tv=u;\n\t\tswap(v[zero],v[zero-3]);\n\t\tadj.push_back(v);\n\t}\n\tif(zero%3 == 0 || zero%3 == 1){\n\t\tBoard  v(9);\n\t\tv=u;\n\t\tswap(v[zero],v[zero+1]);\n\t\tadj.push_back(v);\n\t}\n\tif(zero%3 == 1 || zero%3 == 2){\n\t\tBoard v(9);\n\t\tv=u;\n\t\tswap(v[zero],v[zero-1]);\n\t\tadj.push_back(v);\n\t}\n}\n\nint solve(Board &init){\n\tBoard u(9),v(9);\n\tint u_code, v_code;\n\tint init_code = translate(init);\n\n\tqueue<Board> q;\n\tq.push(init);\n\tcheck[init_code]=1;\n\td[init_code]=0;\n\tpreve[init_code]=-1;\n\n\tif(init_code==G){\n\treturn d[init_code];\n\t}\n\n\twhile(!q.empty()){\n\t\tu = q.front();\n\t\tq.pop();\n\t\tu_code = translate(u);\n\t\tvector<Board> adj(0);\n\t\tAdj(u, adj);\n\t\tfor(int i=0;i<adj.size();i++){\n\t\t\tv = adj[i];\n\t\t\tv_code = translate(v);\n\t\t\tif(check[v_code]==0){\n\t\t\t\tcheck[v_code]=1;\n\t\t\t\td[v_code]=d[u_code]+1;\n\t\t\t\tpreve[v_code]=u_code;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t\tif(v_code==G){\n\t\t\t\treturn d[v_code];\n\t\t\t}\n\t\t}\n\t\tcheck[u_code] = 2;\n\t}\n}\n\nint main(){\n\tBoard init(9);\n\tfor(int i=0;i<9;i++){\n\t\tcin >> init[i]; \n\t} \n\n\t//cout << translate(init) << endl;\n\t/*\n\tvector<Board> b(0);\n\tAdj(init,b);\n\tfor(int i=0;i<b.size();i++){\n\t\tfor (int j=0;j<9;j++){\n\t\t\tcout << b[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl ;\n\t*/ \n\tcout << solve(init) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n#define _all(arg) begin(arg),end(arg)\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0; }\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0; }\n\nusing namespace std;\nusing vi=vector<int>;\nusing vii=vector<vi>;\n\nmap<vii, int> memo;\n\nbool check(vii m) {\n\trep(i, 8) {\n\t\tif(m[i/3][i%3] != i+1) return false;\n\t}\n\tif(m[2][2] != 0) return false;\n\treturn true;\n}\n\nint bfs(vii m) {\n\tqueue<vii> Q;\n\tQ.push(m);\n\tmemo[m] = 0;\n\twhile(Q.size()) {\n\t\tvii cur = Q.front();\n\t\tQ.pop();\n\n\t\tif(check(cur)) return memo[cur];\n\n\t\tconst int dr[4] = {1, 0, -1, 0};\n\t\tconst int dc[4] = {0, 1, 0, -1};\n\n\t\tint zero_r, zero_c;\n\n\t\trep(i, 3) rep(j, 3) if(cur[i][j] == 0) zero_r = i, zero_c = j;\n\t\trep(i, 4) {\n\t\t\tvii next = cur;\n\t\t\tint nr = zero_r + dr[i];\n\t\t\tint nc = zero_c + dc[i];\n\t\t\tif(nr<0 || 3<=nr || nc<0 || 3<=nc) continue;\n\t\t\tswap(next[zero_r][zero_c], next[nr][nc]);\n\t\t\tif(memo.find(next) != memo.end()) continue;\n\t\t\tmemo[next] = memo[cur]+1;\n\t\t\tQ.push(next);\n\t\t}\n\t}\n} \n\nint main(void){\n\tvii m(3, vi(3, 0));\n\trep(i, 9) cin >> m[i/3][i%3];\n\n\tcout << bfs(m) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define NUM 3\n#define PRUNING 30\n\ntypedef struct STATUS{\n    int num;\n    int board[NUM][NUM];\n}STATUS;\n\ntypedef pair<int, int> cell;\n\nbool checkfinish(STATUS in){\n    \n    int val = 1;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j= 0; j < NUM; j++) {\n            if (i == NUM - 1 && j == NUM - 1) return true;\n            if(in.board[i][j] != val++) return false;\n        }\n    }\n    return true;\n}\n\n\nint backtrack(STATUS in, cell last_zero){\n\n    int x = 0, y = 0, ret = PRUNING;\n    cell zero;\n    STATUS out;\n    \n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    \n    if (in.num > ret) {\n        return ret;\n    }\n    \n    if (checkfinish(in)) {\n        return in.num;\n    }\n\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            if(in.board[i][j] == 0){\n                x = zero.first = j;\n                y = zero.second = i;\n            }\n        }\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (x + dx[i] >=0 && x+dx[i] < NUM && y+dy[i] >=0 && y+dy[i] < NUM) {\n            if (last_zero.first == x+dx[i] && last_zero.second == y+dy[i]){ continue;\n            }\n            memcpy(&out, &in, sizeof(STATUS));\n            swap(out.board[y][x], out.board[y+dy[i]][x+dx[i]]);\n            out.num++;\n            ret = min(ret, backtrack(out, zero));\n        }\n    }\n    return ret;\n}\n\n\nint main(){\n    \n    int val, ans;\n    \n    STATUS init;\n    init.num = 0;\n    \n    for (int i = 0; i < NUM; i++) {\n        for (int j = 0; j < NUM; j++) {\n            cin >> val;\n            init.board[i][j] = val;\n        }\n    }\n    \n    //?????????????????????????????????zero????????¨?????????????????????????????\\????????????\n    ans = backtrack(init, cell(-1,-1));\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<set>\n#include<queue>\nusing namespace std;\nset<long long> s;\nint map1[10][10];\nint k[10];\nint t;\nqueue<long long> x,y;\nvoid input(){\n\tint g=0;\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tcin>>map1[i][j];\n\t\t\tg=g*10+map1[i][j];\n\t\t}\n\t}\n\ts.insert(g);\n\tx.push(g);\n\ty.push(0);\n}\nvoid syf(){\n\twhile(!x.empty()){\n\t\tif(x.front()==123456780){\n\t\t\tcout<<y.front()<<endl;\n\t\t\treturn;\n\t\t}\n\t\tint g=x.front(),tot=0,kl=-1;\n\t\twhile(g!=0){\n\t\t\tif(g%10==0) kl=tot;\n\t\t\tk[tot++]=g%10;\n\t\t    g/=10;\n\t\t}\n\t\tif(kl==-1) {\n\t\t\tkl=tot;\n\t\t\ttot++;\n\t\t}\n\t\tif(kl%3>0){\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl-1];\n\t\t\tk[kl-1]=t;\n\t\t\tlong long ss=0;\n\t\t\tfor(int i=tot-1;i>=0;--i){\n\t\t\t\tss=ss*10+k[i];\n\t\t\t}\n\t\t\tif(s.count(ss)==0){\n\t\t\t\tx.push(ss);\n\t\t\t\ty.push(y.front()+1);\n\t\t\t\ts.insert(ss);\n\t\t\t}\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl-1];\n\t\t\tk[kl-1]=t;\n\t\t}\n\t\tif(kl%3<2){\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl+1];\n\t\t\tk[kl+1]=t;\n\t\t\tlong long ss=0;\n\t\t\tfor(int i=tot-1;i>=0;--i){\n\t\t\t\tss=ss*10+k[i];\n\t\t\t}\n\t\t\tif(s.count(ss)==0){\n\t\t\t\tx.push(ss);\n\t\t\t\ty.push(y.front()+1);\n\t\t\t\ts.insert(ss);\n\t\t\t}\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl+1];\n\t\t\tk[kl+1]=t;\t\t\t\n\t\t}\n\t\tif(kl+3<=8){\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl+3];\n\t\t\tk[kl+3]=t;\n\t\t\tlong long ss=0;\n\t\t\tfor(int i=tot-1;i>=0;--i){\n\t\t\t\tss=ss*10+k[i];\n\t\t\t}\n\t\t\tif(s.count(ss)==0){\n\t\t\t\tx.push(ss);\n\t\t\t\ty.push(y.front()+1);\n\t\t\t\ts.insert(ss);\n\t\t\t}\t\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl+3];\n\t\t\tk[kl+3]=t;\t\t\n\t\t}\n\t\tif(kl-3>=0){\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl-3];\n\t\t\tk[kl-3]=t;\n\t\t\tlong long ss=0;\n\t\t\tfor(int i=tot-1;i>=0;--i){\n\t\t\t\tss=ss*10+k[i];\n\t\t\t}\n\t\t\tif(s.count(ss)==0){\n\t\t\t\tx.push(ss);\n\t\t\t\ty.push(y.front()+1);\n\t\t\t\ts.insert(ss);\n\t\t\t}\t\n\t\t\tt=k[kl];\n\t\t\tk[kl]=k[kl-3];\n\t\t\tk[kl-3]=t;\t\t\t\n\t\t}\n\t\tx.pop();\n\t\ty.pop();\n\t}\n}\nint main(){\n\tinput();\n\tsyf();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n  \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n  \nusing namespace std;\n  \ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n  \nconst int INF=1<<29;\nconst double EPS=1e-9;\n  \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nconst int boardw = 3;\n\nstruct BOARD {\n    int map[boardw][boardw];\n};\n \nstd::queue<BOARD> q;\nstd::map<BOARD,int> m;\n \nbool check(BOARD b) {\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            if (b.map[i][j] == 0) continue;\n            int tgt = i * boardw + j + 1;\n            if (b.map[i][j] != tgt) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint dfs(BOARD &b, int depth, int dir) {\n    if (depth == 0) {\n        if (check(b)) {\n            return 1;\n        } else {\n            return -1;\n        }\n    }\n\n    int px, py;\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            if (b.map[i][j] == 0) {\n                px = j;\n                py = i;\n            }\n        }\n    }\n    int dx[] = {0, 1, 0, -1};\n    int dy[] = {1, 0, -1, 0};\n    for (int k = 0; k < 4; k++) {\n        if (dir != -1 && k == (dir + 2) % 4) {\n            continue;\n        }\n        int tx = px + dx[k];\n        int ty = py + dy[k];\n        if (tx < 0 || tx >= boardw || ty < 0 || ty >= boardw) continue;\n        int temp = b.map[py][px];\n        b.map[py][px] = b.map[ty][tx];\n        b.map[ty][tx] = temp;\n        \n        int ret = dfs(b, depth - 1, k);\n        \n        temp = b.map[py][px];\n        b.map[py][px] = b.map[ty][tx];\n        b.map[ty][tx] = temp;\n        if (ret != -1) return ret;\n    }\n    return -1;\n}\n \nint main(int argc, char const *argv[]) {\n    BOARD b;\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            cin >> b.map[i][j];\n        }\n    }\n    for (int i = 1; i <= 45; i++) {\n        int ret = dfs(b, i, -1);\n        if (ret == 1) {\n            cout << i << endl;\n            return 0;\n        }\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <list>\n#include <string>\n#include <map>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nstruct state {\n    Board board;\n    int count;\n};\n\nlist<state> q;\nmap<Board,char> history;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, state s) {\n    swap(numpos, spacepos, s.board);\n    if (s.board == GOAL) {\n        return s.count;\n    }\n    map<Board,char>::iterator it = history.find(s.board);\n    if (it == history.end()) {\n        history.insert(make_pair(s.board, ' '));\n        ++s.count;\n        q.push_back(s);\n    }\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0; i < N; ) {\n        char ch;\n        scanf(\"%c\", &ch);\n        if (isdigit(ch)) {\n            board |= static_cast<long long>((ch - '0')) << (i*4);\n            ++i;\n        }\n    }\n\n    if (board == GOAL) {\n        printf(\"0\\n\");\n        return 0;\n    }\n\n//    print(GOAL);\n//    print(board);\n\n    q.push_back({ board, 0 });\n    int count = 0;\n    while (!q.empty()) {\n        state s = q.front();\n        q.pop_front();\n\n        int pos = -1;\n        while (++pos < N) {\n            if (((s.board >> (pos*4)) & 15) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nconst int PATTERN = 362880;\nbool frontier[PATTERN];\n\nstruct State {\n    Board board;\n    int count;\n};\n\nqueue<State> q;\n\n// I made this function based on one by Haruhiko Okumura(Algorithm \n// Dictionary, p116) and one by M.Hiroi(Puzzle DE Programming).\ninline int change_number(long long board) {\n    static int fact_table[N] = {\n         40320, 5040, 720, 120, 24, 6, 2, 1, 0      // on N = 8\n    };\n    int value = 0;\n    for (int j = 0; j < N - 1; ++j) {\n        int J = static_cast<int>((board >> (j*4) & 0xF));\n        value += fact_table[j] * J;\n        for (int k = j + 1; k < N; ++k) {\n            int K = static_cast<int>((board >> k*4) & 0xF);\n            if (J < K) {\n                board &= ~(0xFLL << k*4);\n                board |= (static_cast<long long>(K - 1) << k*4);\n            }\n        }\n    }\n//    printf(\"[change_number] value = %d\\n\", value);\n    return value;\n}\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, State s) {\n    swap(numpos, spacepos, s.board);\n    if (s.board == GOAL) {\n        return ++s.count;\n    }\n    int pos = change_number(s.board);\n    if (!frontier[pos]) {\n        ++s.count;\n        q.push(s);\n        frontier[pos] = true;\n    }\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\n// OK\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0, num; i < N; ++i) {\n        scanf(\"%d\", &num);\n        board |= static_cast<long long>(num) << (i*4);\n    }\n//    print(GOAL);\n//    print(board);\n\n    int count = 0;\n    if (board == GOAL) {\n        goto END;\n    }\n\n    q.push({ board, 0 });\n    while (!q.empty()) {\n        State s = q.front();\n        q.pop();\n\n        int pos = -1;\n        while (++pos < N) {\n            if (((s.board >> (pos*4)) & 15) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n \nstruct Puzzle {\n  int f[N*N];\n  int space;\n  string path;\n \n  bool operator < ( const Puzzle &p ) const {\n    for(int i=0;i < N*N; i++){\n      if(f[i]==p.f[i]) continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n \nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n \nbool isTarget(Puzzle p){\n  for(int i=0;i<N*N;i++)\n    if(p.f[i]!=(i+1)) return false;\n  return true;\n}\n \nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n \n  while(!Q.empty()){\n    u=Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N) continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n    V[v]=true;\n    v.path+=dir[r];\n    Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n \nint main()\n{\n  Puzzle in;\n \n  for(int i=0;i<N*N;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N*N;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout<<ans.size()<<endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX 3\n#define MAX2 9\n\nusing namespace std;\n\nstruct Puzzle{\n  int f[MAX2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const {\n    int i;\n    for(i = 0; i < MAX2; i++){\n      if( f[i] == p.f[i] ){\n        continue;\n      }\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstring bfs(Puzzle);\nbool isTarget(Puzzle);\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\nchar dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  int i;\n  for(i = 0; i < MAX2; i++){\n    if( p.f[i] != (i+1) ){\n      return false;\n    }\n  }\n  return true;\n}//end of isTarget func\n\nint main(){\n  Puzzle in;\n  int i;\n  for(i = 0; i < MAX2; i++){\n    cin >> in.f[i];\n    if( in.f[i] == 0 ){\n      in.f[i] = MAX2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n  return 0;\n}//end of main func\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  int r,tx,ty;\n  int sx,sy;\n  int tmp;\n\n  while( !Q.empty() ){\n    u = Q.front();\n    Q.pop();\n    if( isTarget(u) ){\n      return u.path;\n    }\n    sx = u.space / MAX;\n    sy = u.space % MAX;\n    for(r = 0; r < 4; r++){\n      tx = sx + dx[r];\n      ty = sy + dy[r];\n      if( tx < 0 || ty < 0 || tx >= MAX || ty >= MAX){\n        continue;\n      }\n      v = u;\n      /*swap*/\n      tmp = v.f[u.space];\n      v.f[u.space] = v.f[tx * MAX + ty];\n      v.f[tx * MAX + ty] = tmp;\n\n      v.space = tx * MAX + ty;\n      if( !V[v] ){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <cmath>\nusing namespace std;\n#define N 3 \n#define PN 9\n#define LIMIT 50\n\nint MDT[PN][PN];\nint dx[4] = {0,-1,0,1};\nint dy[4] = {1,0,-1,0};\nint limit;\n\nstruct Puzzle{ int f[PN], space, MD;};\nPuzzle state;\n\nint sumMD(Puzzle p){\n    int sum = 0;\n    for(int i = 0; i < PN; i++){\n        if(p.f[i] == PN) continue;\n        sum += MDT[i][p.f[i]-1];\n    }\n    return sum;\n}\n\nbool dfs(int depth, int prev){\n    if(state.MD == 0) return true;\n    if(depth+state.MD > limit) return false;\n\n    int sx = state.space/N;\n    int sy = state.space%N;\n    Puzzle tmp = state;\n\n    for(int r = 0; r < 4; r++){\n        int tx = sx + dx[r];\n        int ty = sy + dy[r];\n        if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n        if((r+2)%4 == prev) continue;\n        tmp = state;\n        state.MD -= MDT[tx*N+ty][state.f[tx*N+ty]-1];\n        state.MD += MDT[sx*N+sy][state.f[tx*N+ty]-1];\n        swap(state.f[tx*N+ty],state.f[sx*N+sy]);\n        state.space = tx*N+ty;\n        if(dfs(depth+1,r)) return true;\n        //if(dfs(depth+1,r)){path[depth] = r; return true;}\n        state = tmp;\n    }\n\n    return false;\n}\n\nint main(){\n    Puzzle p;\n\n    for(int i = 0; i < PN; i++){\n        cin >> p.f[i];\n        if(p.f[i] == 0){\n            p.f[i] = PN;\n            p.space = i;\n        }\n    }\n\n    for(int i = 0; i < PN; i++){\n        for(int j = 0; j < PN; j++){\n            MDT[i][j] = abs(i/N - j/N) + abs(i%N - j%N);\n        }\n    }\n\n    p.MD = sumMD(p);\n\n    for(limit = 0; limit < LIMIT; limit++){\n        state = p;\n        if(dfs(0,-1)){\n            cout << limit << endl;\n            return 0;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct puzzle{\n  int x[N2];\n  int space;\n  string path;\n  bool operator < (const puzzle &p)const{\n    for(int i=0;i<N2;i++){\n      if(x[i]==p.x[i]) continue;\n      return x[i]>p.x[i];\n    }\n    return false;\n  }\n};\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\nchar dir[4] = {'u','l','d','r'};\n\nbool target(puzzle);\nstring bfs(puzzle);\n\nint main(){\n  int i;\n  string answer;\n  puzzle in;\n\n  for(i=0;i<N2;i++){\n    cin >> in.x[i];\n    if(in.x[i] == 0){\n      in.x[i] = N2;\n      in.space = i;\n    }\n  }\n  answer = bfs(in);\n  cout << answer.size() << endl;\n\n  return 0;\n}\n\nbool target(puzzle p){\n  int i;\n  for(i=0;i<N2;i++)\n    if(p.x[i] != (i+1)) return false;\n  return true;\n}\n\nstring bfs(puzzle p){\n  int px,py,tx,ty,r;\n  queue<puzzle> Que;\n  map<puzzle,bool> V;\n  puzzle m,k;\n  p.path=\"\";\n  Que.push(p);\n  V[p]=true;\n\n  while(!Que.empty()){\n    m=Que.front(); Que.pop();\n    if(target(m)==true) return m.path;\n    px=m.space/N;\n    py=m.space%N;\n    for(r=0;r<4;r++){\n      tx=px+dx[r];\n      ty=py+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n      k=m;\n      swap(k.x[m.space],k.x[tx*N+ty]);\n      k.space=tx*N+ty;\n      if(!V[k]){\n\tV[k]=true;\n\tk.path += dir[r];\n\tQue.push(k);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle& p) const {\n    for (int i = 0; i < N2; i++) {\n      if (f[i] == p.f[i]) {\n        continue;\n      }\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n  for (int i = 0; i < N2; i++) {\n    if (p.f[i] != (i + 1)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nstring bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while (!Q.empty()) {\n    u = Q.front(); Q.pop();\n    if (isTarget(u)) {\n      return u.path;\n    }\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for (int r = 0; r < 4; r++) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if (tx < 0 || ty < 0 || tx >= || ty >= N) {\n        continue;\n      }\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if (!V[v]) {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for (int i = 0; i < N2; i++) {\n    cin >> in.f[i];\n    if (in.f[i] == 0) {\n      in.f[i] = N2; // set space\n      in.space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << and.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <vector>\n#define N 3\n#define N2 9\nusing namespace std;\n\nstruct game{\n  int b[N2];\n  bool operator < (const game &other) const{\n    for(int i=0;i<N2;i++){\n      if(b[i]<other.b[i]){\n        return true;\n      }else if(b[i]>other.b[i]){\n        return false;\n      }\n    }\n    return false;\n  }\n};\ngame g;\nmap<game,int> checked;\nqueue<game> q;\n\nvoid print(game _g){\n  for(int i=0;i<N2;i++)\n    printf(\"%d \",_g.b[i]);\n  printf(\"\\n\");\n}\n\nbool clear(game _g){\n  for(int i=0;i<N2;i++){\n    if(_g.b[i]!=i+1) return false;\n  }\n  return true;\n}\n\nint solve(){\n  q.push(g);\n  checked.insert(make_pair(g,0));\n  int depth;\n  while(!q.empty()){\n    g=q.front();q.pop();\n    depth=checked[g];\n    if(clear(g)){ return depth; }\n    int w;\n    for(int i=0;i<N2;i++){\n      if(g.b[i]==N2) {\n        w=i;\n        break;\n      }\n    }\n    vector<int> v;\n    if(w%N<N-1) v.push_back(1);\n    if(w%N>0  ) v.push_back(-1);\n    if(w/N<N-1) v.push_back(N);\n    if(w/N>0  ) v.push_back(-N);\n    for(int i:v){\n      game gt=g;\n      swap(gt.b[w],gt.b[w+i]);\n      if(checked.find(gt)==checked.end()){\n        q.push(gt);\n        checked.insert(make_pair(gt,depth+1));\n      }\n    }\n  }\n  return -1;\n}\n\n\nint main(){\n  for(int i=0;i<N2;i++) {\n    int tmp; cin>>tmp;\n    if(tmp==0) tmp=N2;\n    g.b[i]=tmp;\n  }\n\n  cout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <algorithm>\nusing namespace std;\nconst int N = 3;\nconst int INF = 50;\nvector<vector<int> > cell(N, vector<int>(N));\nvector<vector<int> > ans = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};\nint q = 0;\nunordered_set<int> ms;\nint zero_x = 0;\nint zero_y = 0;\nint ministep = INF;\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\nint key(vector<vector<int> > cell)\n{\n\tint res = 0;\n\tint p = 1;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tres += cell[i][j] * p;\n\t\t\tp *= 10;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid solve(int i)\n{\n\tint p = key(cell);\n\tif (ms.find(p) != ms.end() || ministep < i) {\n\t\treturn;\n\t}\n\tif (p == q) {\n\t\tministep = min(ministep, i);\n\t\treturn;\n\t}\n\t\n\tms.insert(p);\n\tif (zero_x > 0) {\n\t\tswap(cell[zero_x][zero_y], cell[zero_x - 1][zero_y]);\n        zero_x--;\n\t\tsolve(i + 1);\n\t\tswap(cell[zero_x][zero_y], cell[zero_x + 1][zero_y]);\n        zero_x++;\n\t}\n\tif (zero_x < N - 1) {\n\t\tswap(cell[zero_x][zero_y], cell[zero_x + 1][zero_y]);\n        zero_x++;\n\t\tsolve(i + 1);\n\t\tswap(cell[zero_x][zero_y], cell[zero_x - 1][zero_y]);\n        zero_x--;\n\t}\n\tif (zero_y > 0) {\n\t\tswap(cell[zero_x][zero_y], cell[zero_x][zero_y - 1]);\n        zero_y--;\n\t\tsolve(i + 1);\n\t\tswap(cell[zero_x][zero_y], cell[zero_x][zero_y + 1]);\n        zero_y++;\n\t}\n\tif (zero_y < N - 1) {\n\t\tswap(cell[zero_x][zero_y], cell[zero_x][zero_y + 1]);\n        zero_y++;\n\t\tsolve(i + 1);\n\t\tswap(cell[zero_x][zero_y], cell[zero_x][zero_y - 1]);\n        zero_y--;\n\t}\n\tms.erase(p);\n}\n\nint main()\n{\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tcin >> cell[i][j];\n            if (cell[i][j] == 0) {\n                zero_x = i;\n                zero_y = j;\n            }\n\t\t}\n\t}\n\n\tq = key(ans);\n\tsolve(0);\n\tcout << ministep << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iterator>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\nnamespace eight_puzzle{\n\ttypedef unsigned int uint;\n\tconst int N = 3;\n\tconst int ansval = 123456780;\n\tconst int ansarray[N*N] = {1,2,3,4,5,6,7,8,0};\n\tuint arraytovalue(int *table){\n\t\tuint t=0;\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tt*=10;\n\t\t\tt=t+table[i];\n\t\t}\n\t\treturn t;\n\t}\n\tvoid valuetoarray(uint t,int *table){\n\t\tfor(int i=N-1;i>=0;--i){\n\t\t\tfor(int j=N-1;j>=0;--j){\n\t\t\t\tint panel = t-t/10*10;\n\t\t\t\ttable[i*N+j] = panel;\n\t\t\t\tt/=10;\n\t\t\t}\n\t\t}\t\t\n\t}\n\tuint getscore(uint t){\n\t\tint table[N*N];\n\t\tuint score = 0;\n\t\tvaluetoarray(t,table);\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tfor(int j=0;j<N*N;++j){\n\t\t\t\tif(ansarray[i]==table[j]){\n\t\t\t\t\tscore += (i/N-j/N)*(i/N-j/N)+(i%N-j%N)*(i%N-j%N);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn score;\n\t}\n\tstruct State{\n\t\tState(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t\tscore = s.score;\n\t\t}\n\t\tState(const uint tt,const uint tn){\n\t\t\ttable = tt;\n\t\t\tn = tn;\n\t\t\tscore = getscore(table);\n\t\t}\n\n\t\tState& operator=(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t\tscore = s.score;\n\t\t\treturn (*this);\n\t\t}\n\t\tbool operator<(const State& s) const{\n\t\t\treturn score < s.score;\n\t\t}\n\t\tbool operator>(const State& s) const{\n\t\t\treturn score > s.score;\n\t\t}\n\t\tbool isfinished() const{\n\t\t\t\treturn table == 123456780;\n\t\t}\n\t\t\n\t\tuint table;\n\t\tuint n;\n\t\tuint score;\n\t};\n\n\tvoid getnextstate(const State &s,std::vector<State> &states){\n\t\tint table[N*N];\n\t\tint t = s.table;\n\t\tint zi,zj;\n\t\tvaluetoarray(t,table);\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tif(table[i]==0){\n\t\t\t\tzi = i/N;\n\t\t\t\tzj = i%N;\n\t\t\t}\n\t\t}\n\t\tfor(int i=-1;i<=1;++i){\n\t\t\tfor(int j=-1;j<=1;++j){\n\t\t\t\tif((i+j)%2==0)continue;\n\t\t\t\tint ti = zi+i,tj=zj+j;\n\t\t\t\tif(0<=ti&&ti<N&&0<=tj&&tj<N){\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t\tstates.push_back(State(arraytovalue(table),s.n+1));\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tstd::map<uint, bool> visited;\n};\n\nint main(){\n\tusing namespace eight_puzzle;\n\tint array[N*N];\n\tfor(int i=0;i<N*N;++i){\n\t\tstd::cin>>array[i];\n\t}\n\tState init(arraytovalue(array),0);\n//\tstd::priority_queue<State,std::vector<State>,std::greater<State> > Q;\n\tstd::queue<State> Q;\n\tQ.push(init);\n\twhile(!Q.empty()){\n\t\tState s = Q.front();\n\t\tQ.pop();\n\t\tstd::vector<State> states;\n\t\tgetnextstate(s,states);\n\t\tfor(uint i=0;i<states.size();++i){\n\t\t\tif(states[i].isfinished()){\n\t\t\t\tstd::cout<<states[i].n<<std::endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(visited.find(states[i].table)==visited.end()){\n\t\t\t\tQ.push(states[i]);\n\t\t\t\tvisited[states[i].table]=true;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<cmath>\n#include<string>\n#include<cassert>\n\n#define N 3\n#define N2 8\n#define LIMIT 100\n\nusing namespace std;\n\nstatic const int dx[4] = {0, -1, 0, 1};\nstatic const int dy[4] = {1, 0, -1, 0};\nstatic const char dir[4] = {'r', 'u', 'l', 'd'};\nint MDT[N2][N2];\n\nstruct Puzzle {\n  int f[N2], space, MD;\n};\n\nPuzzle state;\nint limit;\nint path[LIMIT];\n\nint getAllMD(Puzzle pz){\n  int sum = 0;\n  for(int i=0; i<N2; i++){\n    if(pz.f[i] == N2) continue;\n    sum += MDT[i][pz.f[i]-1];\n  }\n  return sum;\n}\n\nbool isSolved(){\n  for(int i=0; i<N2; i++)\n    if(state.f[i] != i+1) return false;\n  return true;\n}\n\nbool dfs(int depth, int prev){\n  if(state.MD == 0) return true;\n\n  if(depth+state.MD > limit) return false;\n\n  int sx = state.space / N;\n  int sy = state.space % N;\n  Puzzle tmp;\n\n  for(int r=0; r<4; r++){\n    int tx = sx + dx[r];\n    int ty = sy + dy[r];\n    \n    if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n       if(max(prev, r)-min(prev, r) == 2) continue;\n       tmp = state;\n\n       state.MD -= MDT[tx*N+ty][state.f[tx*N+ty]-1];\n       state.MD += MDT[sx*N+sy][state.f[tx*N+ty]-1];\n       swap(state.f[tx*N+ty], state.f[sx*N+sy]);\n       state.space = tx*N+ty;\n       if(dfs(depth+1,r) ) {path[depth] = r; return true; }\n       state = tmp;\n  }       \n       \n    return false;\n  \n}    \n\n\nstring iterative_deepening(Puzzle in){\n  in.MD = getAllMD(in);\n\n  for(limit = in.MD; limit <= LIMIT; limit++){\n    state = in;\n    if(dfs(0, -100) ){\n      string ans = \"\";\n      for(int i = 0; i<limit; i++) ans += dir[path[i]];\n      return ans;\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  for(int i=0; i<N2; i++)\n    for(int j=0; j<N2; j++)\n      MDT[i][j] = abs(i/N - j/N) + abs(i%N - j%N);\n\n  Puzzle in;\n\n  for(int i=0; i<N2; i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = iterative_deepening(in);\n  cout << ans.size() << endl;\n\n  return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <vector>\n\ntypedef std::vector<std::vector<int> > TPuzzle;\n\nvoid MakeGoal(TPuzzle& Goal)\n{\n\tGoal.resize(3);\n\tfor(int i = 0; i < 3; ++i){\n\t\tGoal[i].resize(3);\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tGoal[i][j] = (1 + 3 * i + j) % 9;\n\t\t}\n\t}\n}\n\nvoid ZeroPosition(int& Row, int& Col, const TPuzzle& Puzzle)\n{\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tif(Puzzle[i][j] == 0){\n\t\t\t\tRow = i;\n\t\t\t\tCol = j;\n\t\t\t}\n\t\t}\n\t}\n}\n\nenum TMovePattern\n{\n\tmpUp,\n\tmpDown,\n\tmpLeft,\n\tmpRight\n};\n\nbool Movable(const TPuzzle& Puzzle, const TMovePattern& Pattern)\n{\n\tint Row, Col;\n\tZeroPosition(Row, Col, Puzzle);\n\tswitch(Pattern){\n\tcase mpUp    : return Row != 0;\n\tcase mpDown  : return Row != 2;\n\tcase mpLeft  : return Col != 0;\n\tcase mpRight : return Col != 2;\n\t}\n\tassert(false);\n\treturn false;\n}\n\nTPuzzle Move(TPuzzle Puzzle, const TMovePattern& Pattern)\n{\n\tint Row, Col;\n\tZeroPosition(Row, Col, Puzzle);\n\tswitch(Pattern){\n\tcase mpUp    : std::swap(Puzzle[Row][Col], Puzzle[Row - 1][Col]);break;\n\tcase mpDown  : std::swap(Puzzle[Row][Col], Puzzle[Row + 1][Col]);break;\n\tcase mpLeft  : std::swap(Puzzle[Row][Col], Puzzle[Row][Col - 1]);break;\n\tcase mpRight : std::swap(Puzzle[Row][Col], Puzzle[Row][Col + 1]);break;\n\t}\n\treturn Puzzle;\n}\n\nvoid RenewTargets(\n\tconst TPuzzle& Puzzle,\n\tconst TMovePattern& Pattern,\n\tstd::vector<TPuzzle>& Targets,\n\tstd::set<TPuzzle>& History)\n{\n\tif(!Movable(Puzzle, Pattern)) return;\n\tTPuzzle Moved = Move(Puzzle, Pattern);\n\tif(History.find(Moved) != History.end()) return;\n\tTargets.push_back(Moved);\n\tHistory.insert(Moved);\n}\n//?¬??????????????????????????????¶???????????????\n\n//????¬??????????????????????????¨?????????£???????????°?????????\n//?¬?????????????????????????????????§?????????????????????????????????\n//???????????§????±\\??´????????£????????????\n//?¬???????????????????????????????????????????????????????\n//?±\\??´????????????\n//????????????\nint CountMove(const std::vector<TPuzzle>& NextTargets,\n\t          const TPuzzle& Goal,\n\t          int Count,\n\t          std::set<TPuzzle>& History)\n{\n\tif(std::find(NextTargets.begin(), NextTargets.end(), Goal) != NextTargets.end()) return Count;\n\tstd::vector<TPuzzle> NewTargets;\n\tfor(std::vector<TPuzzle>::const_iterator It = NextTargets.begin(); It != NextTargets.end(); ++It){\n\t\tRenewTargets(*It, mpUp,    NewTargets, History);\n\t\tRenewTargets(*It, mpDown,  NewTargets, History);\n\t\tRenewTargets(*It, mpLeft,  NewTargets, History);\n\t\tRenewTargets(*It, mpRight, NewTargets, History);\n\t}\n\treturn CountMove(NewTargets, Goal, 1 + Count, History);\n}\n\nint CountMinimumMove(const TPuzzle& Puzzle, const TPuzzle& Goal)\n{\n\tstd::set<TPuzzle> History;\n\treturn CountMove(std::vector<TPuzzle>(1, Puzzle), Goal, 0, History);\n}\n\nint main()\n{\n\tTPuzzle Goal;\n\tMakeGoal(Goal);\n\tTPuzzle Start(3, std::vector<int>(3));\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tint Input;\n\t\t\tstd::cin >> Input;\n\t\t\tStart[i][j] = Input;\n\t\t}\n\t}\n\tstd::cout << CountMinimumMove(Start, Goal) << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ALDS1_13_B.cpp\n// Heuristic Search - 8 Puzzle\n// ????????¨?????????24????????±??????????????????\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 3;\nconst int N2 = 9;\nconst int INF = 23;\nstruct Puzzle {\n    int f[N2];\n    //int space;\n    string path;\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\nmap<Puzzle, bool> ms;\nPuzzle in;\nint ministep = INF;\nint sx = 0;\nint sy = 0;\n\nvoid swap(int& a, int& b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != i + 1)\n            return false;\n    }\n    return true;\n}\n\nint getAllMD(Puzzle p)\n{\n    int dist = 0;\n    int x, y;\n    int ux, uy;\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] == N2) continue; // ??????0??????\n        x = (p.f[i] - 1) / N;\n        y = (p.f[i] - 1) % N;\n        ux = i / N;\n        uy = i % N;\n        dist += abs(x - ux) + abs(y - uy);\n    }\n    return dist;\n}\n\nvoid bfs(int i)\n{\n    if (isTarget(in)) {\n        ministep = min(ministep, i);\n//        cout << \"ministep = \" << ministep << endl;\n        return;\n    }\n    if (ms[in] || ministep < i + getAllMD(in)) {\n        return;\n    }\n    \n    ms[in] = true;\n    for (int u = 0; u < 4; u++) {\n        int tx = sx + dx[u];\n        int ty = sy + dy[u];\n        if (tx < 0 || tx >= N || ty < 0 || ty >= N)\n            continue;\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        sx = tx;\n        sy = ty;\n        in.path += dir[u];\n        /* test */\n//    cout << \"(i = \" << i << \") \" << in.path << endl;\n//    for (int j = 0; j < N2; j++)\n//        cout << \" \" << in.f[j];\n//    cout << endl;\n//    cout << \"MD: \" << getAllMD(in) << endl;\n        bfs(i+1);\n        sx = sx - dx[u];\n        sy = sy - dy[u];\n        swap(in.f[sx * N + sy], in.f[tx * N + ty]);\n        in.path.pop_back();\n    }\n    ms[in] = false;\n}\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    for (int i = 0; i < N2; i++) {\n        cin >> in.f[i];\n        if (in.f[i] == 0) {\n            sx = i / N;\n            sy = i % N;\n            in.f[i] = 9; // ??????isTarget?????????\n        }\n    }\n    bfs(0);\n    cout << ministep << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator<(const Puzzle &p)const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','i','d','r'};\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++)if(p.f[i]!=(i+1))return false;\n  return true;\n}\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front();Q.pop();\n    if(isTarget(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N)continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  for(int i=0;i<N2;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout<<ans.size()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define MAXN 10+2\nint map[MAXN][MAXN];\nint min0=1000000000;\nint t;\nint map1[3][3]={1,2,3,4,5,6,7,8,0};\nbool hx[20000009];\nbool pd(){\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tif(map[i][j]!=map1[i][j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\nvoid syf(int x,int y,int tot){\n\tif(pd()){\n\t\tif(tot<min0) min0=tot;\n\t\treturn;\n    }\n    else if(tot>25) return;\n\telse{\n\t\tint g=1;\n\t\tif(x+1<3){\n\t\t\tt=map[x][y];\n\t\t\tmap[x][y]=map[x+1][y];\n\t\t\tmap[x+1][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=20000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x+1,y,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x+1][y];\n\t\t\tmap[x+1][y]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(x-1>=0){\n\t\t\tt=map[x][y];\n\t\t\tmap[x][y]=map[x-1][y];\n\t\t\tmap[x-1][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=20000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x-1,y,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x-1][y];\n\t\t\tmap[x-1][y]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(y+1<3){\n\t\t\tt=map[x][y+1];\n\t\t\tmap[x][y+1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=20000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x,y+1,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x][y+1];\n\t\t\tmap[x][y+1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(y-1>=0){\n\t\t\tt=map[x][y-1];\n\t\t\tmap[x][y-1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=20000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x,y-1,tot+1);\n\t\t\t    hx[g]=0;\n\t\t\t}\n\t\t\tt=map[x][y-1];\n\t\t\tmap[x][y-1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t}\n}\nvoid input(){\n\tint x1,y1;\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tcin>>map[i][j];\n\t\t\tif(map[i][j]==0){\n\t\t\t\tx1=i;\n\t\t\t\ty1=j;\n\t\t\t}\n\t\t}\n\t}\n\tint g=1;\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tg=g*10+map[i][j];\n\t\t\tg%=10000007;\n\t\t}\n\t}\n\thx[g]=1;\n\tsyf(x1,y1,0);\n\tcout<<min0<<endl;\n}\nint main(){\n\tinput();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cmath>\n\nusing namespace std;\n\nconst int N = 9;\nint board[N];\n\n// OK\nint main(void) {\n\n    int count = 0;\n    for (int y = 0, pos; y < 3; ++y) {\n        for (int x = 0; x < 3; ++x) {\n            pos = y * 3 + x;\n            scanf(\"%d\", &board[pos]);\n            if (board[pos] == 0) { continue; }\n            int x1 = (board[pos] - 1) % 3, y1 = (board[pos] - 1) / 3;\n            count += abs(x1 - x) + abs(y1 - y);\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint Y[4]={-1,0,1,0};\nint X[4]={0,1,0,-1};\n\nbool in(int a,int b){\n  if(a<0 || b<0 || 3<=a || 3<=b)return false;\n  return true;\n}\n\nint main()\n{\n  int a;\n  string start=\"\",goal=\"123456780\";\n\n  for(int i=0;i<9;i++){\n    cin>>a;\n    start+=(a+'0');\n  }\n  \n  queue<string> q;\n  map<string,int> mp;\n  mp[start]=0;\n  q.push(start);\n  while(!q.empty()){\n    string u=q.front();\n    q.pop();\n    int s=-1,cost=mp[u];\n    if(u==goal){\n      cout<<mp[u]<<endl;\n      break;\n    }\n\n    for(int i=0;i<u.length();i++){\n      if(u[i]=='0')s=i;\n    }\n\n    int y=s/3,x=s%3;\n\n    for(int i=0;i<4;i++){\n      int ny=y+Y[i],nx=x+X[i];\n      if(!in(ny,nx))continue;\n      int index=ny*3+nx;\n      string t=u;\n      swap(t[s],t[index]);\n      if(mp.find(t)==mp.end()){\n\tmp[t]=cost+1;\n\tq.push(t);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <utility>\n#include <vector>\n\ntypedef std::vector<std::vector<int> > TPuzzle;\n\nvoid MakeGoal(TPuzzle& Goal)\n{\n\tGoal.resize(3);\n\tfor(int i = 0; i < 3; ++i){\n\t\tGoal[i].resize(3);\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tGoal[i][j] = (1 + 3 * i + j) % 9;\n\t\t}\n\t}\n}\n\nvoid ZeroPosition(int& Row, int& Col, const TPuzzle& Puzzle)\n{\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tif(Puzzle[i][j] == 0){\n\t\t\t\tRow = i;\n\t\t\t\tCol = j;\n\t\t\t}\n\t\t}\n\t}\n}\n\nenum TMovePattern\n{\n\tmpUp,\n\tmpDown,\n\tmpLeft,\n\tmpRight\n};\n\nbool Movable(const TPuzzle& Puzzle, const TMovePattern& Pattern)\n{\n\tint Row, Col;\n\tZeroPosition(Row, Col, Puzzle);\n\tswitch(Pattern){\n\tcase mpUp    : return Row != 0;\n\tcase mpDown  : return Row != 2;\n\tcase mpLeft  : return Col != 0;\n\tcase mpRight : return Col != 2;\n\t}\n\tassert(false);\n\treturn false;\n}\n\nTPuzzle Move(const TPuzzle& Puzzle, const TMovePattern& Pattern)\n{\n\tint Row, Col;\n\tZeroPosition(Row, Col, Puzzle);\n\tTPuzzle Result = Puzzle;\n\tswitch(Pattern){\n\tcase mpUp    : std::swap(Result[Row][Col], Result[Row - 1][Col]);break;\n\tcase mpDown  : std::swap(Result[Row][Col], Result[Row + 1][Col]);break;\n\tcase mpLeft  : std::swap(Result[Row][Col], Result[Row][Col - 1]);break;\n\tcase mpRight : std::swap(Result[Row][Col], Result[Row][Col + 1]);break;\n\tdefault : break;\n\t}\n\treturn Result;\n}\n\nint CountMove(const std::vector<TPuzzle>& Before, const TPuzzle& Goal, int Count)\n{\n\tif(std::find(Before.begin(), Before.end(), Goal) != Before.end()) return Count;\n\tstd::vector<TPuzzle> Next;\n\tfor(std::vector<TPuzzle>::const_iterator It = Before.begin(); It != Before.end(); ++It){\n\t\tconst TPuzzle& Puzzle = *It;\n\t\tif(Movable(Puzzle, mpUp))    Next.push_back(Move(Puzzle, mpUp));\n\t\tif(Movable(Puzzle, mpDown))  Next.push_back(Move(Puzzle, mpDown));\n\t\tif(Movable(Puzzle, mpLeft))  Next.push_back(Move(Puzzle, mpLeft));\n\t\tif(Movable(Puzzle, mpRight)) Next.push_back(Move(Puzzle, mpRight));\n\t}\n\treturn CountMove(Next, Goal, 1 + Count);\n}\n\nint CountMinimumMove(const TPuzzle& Puzzle, const TPuzzle& Goal)\n{\n\tstd::vector<TPuzzle> Start(1, Puzzle);\n\treturn CountMove(Start, Goal, 0);\n}\n\nint main()\n{\n\tTPuzzle Goal;\n\tMakeGoal(Goal);\n\tTPuzzle Start(3, std::vector<int>(3));\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tint Input;\n\t\t\tstd::cin >> Input;\n\t\t\tStart[i][j] = Input;\n\t\t}\n\t}\n\tstd::cout << CountMinimumMove(Start, Goal) << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<tr1/unordered_set>\n#include<cstring>\nusing namespace std;\nbool done[40000000];\nint m[10]={1};\nint f;\nint ans=0;\nint zon[10]={1,2,3,4,5,6,7,8,0};\nint fx[4]={1,-1,3,-3};\nint wz[10]={8,0,1,2,3,4,5,6,7};\ntr1::unordered_set<int> s;\nvoid dfs(int use,int sm,int tot){\n    if(use>tot || s.count(sm) || f) return;\n    if(ans==sm){\n        f=1;\n        return;\n    }\n    s.insert(sm);\n    int dt[9],p,ssm;\n    for(int i=8;i>=0;i--){\n        dt[i]=sm/m[i];\n        sm-=m[i]*dt[i];\n        if(dt[i]==0) p=i;\n    }\n    int u=0;\n    for(int i=1;i<9;i++){\n        u+=abs(i%3-wz[dt[i]]%3)+abs(i/3-wz[dt[i]]/3);\n    }\n    if(u+use*2>tot*2) return;\n    for(int i=0;i<4;i++){\n        if(p+fx[i]<0||p+fx[i]>15) continue;\n        dt[p]=dt[p+fx[i]];\n        dt[p+fx[i]]=0;\n        ssm=0;\n        for(int i=0;i<9;i++) ssm+=dt[i]*m[i];\n        dfs(use+1,ssm,tot);\n        dt[p+fx[i]]=dt[p];\n        dt[p]=0;\n    }\n}\nint main(){\n    int dt[9];\n    for(int i=1;i<9;i++){\n        m[i]=m[i-1]*9;\n    }\n    int sm=0;\n    for(int i=0;i<9;i++){\n        cin>>dt[i];\n        sm+=dt[i]*m[i];\n    }\n    for(int i=0;i<9;i++){\n        ans+=zon[i]*m[i];\n    }\n    for(int i=0;i<1000;i++){\n        s.clear();\n        dfs(0,sm,i);\n        if(f){\n            cout<<i<<\"\\n\";\n            break;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n\n    for(int i=0; i<N2; i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n\n  for(int i=0; i<N2; i++)\n    if(p.f[i] != (i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n\n    u = Q.front();\n    Q.pop();\n\n    if(isTarget(u)) return u.path;\n    int sx = u.space/N;\n    int sy = u.space%N;\n    for(int r=0; r<4; r++){\n      int tx = sx+dx[r];\n      int ty = sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n      v = u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n\n}\n\nint main(){\n\n  Puzzle in;\n\n  for(int i=0; i<N2; i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "// C++ 14\n#include <iostream>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <map>\n#include <unordered_map>\n#include <math.h>\n\n#define ll long ilong\n#define Int int\n#define loop(x, start, end) for(Int x = start; x < end; x++)\n#define loopdown(x, start, end) for(int x = start; x > end; x--)\n#define span(a,x,y) a.begin()+x,a.begin()+y\n#define span_all(a) a.begin(),a.end()\n#define len(x) (x.size())\n#define last(x) (*(x.end()-1))\n\nusing namespace std;\n\n#define N 3\n#define NN (N*N)\n\nvector<Int> dx = {0, 0, -1, 1};\nvector<Int> dy = {-1, 1, 0, 0};\nvector<char> dirs = {'u', 'd', 'l', 'r'};\n\n\nstruct Puzzle {\n  vector<Int> vec;\n  Int blank;\n  string path;\n  \n  Puzzle(): vec(NN, -1), blank(-1), path(\"\") {\n  }\n  \n  Puzzle(vector<Int> &vec, Int blank, string path) {\n    this->vec = vec;\n    this->blank = blank;\n    this->path = path;\n  }\n  \n  bool operator == (const Puzzle &other) const { \n    loop(n,0,NN) {\n      if (vec[n] != other.vec[n]) return false;\n    }\n    \n    return true;\n  }\n  \n  Puzzle move(Int dir) {\n    // i = h * N + w\n    Int sx = blank % N;\n    Int sy = blank / N;\n    Int tx, ty;\n    \n    switch (dir) {\n      case 0: \n      case 1:\n      case 2:\n      case 3:\n        tx = sx + dx[dir];\n        ty = sy + dy[dir];\n        break;\n      default:\n        cout << \"Invalid dir: \" << dir << endl;\n        exit(1);\n        break;\n    }\n    \n    Puzzle p;\n    if (tx < 0 || N <= tx || ty < 0 || N <= ty) {\n      return p;\n    }\n    \n    p = *this;\n    swap(p.vec[sy * N + sx], p.vec[ty * N + tx]);\n    p.blank = ty * N + tx;\n    p.path += dirs[dir];\n    return p;\n  }\n  \n  void dump() {\n    loop(n,0,NN) cout << vec[n] << ' '; cout << endl;\n  }\n  \n  void dump2() {\n    loop(h,0,N) {\n      loop(w,0,N) {\n        cout << vec[h * N + w] << ' ';\n      }\n      cout << endl;\n    }\n  }\n};\n\nnamespace std {\n\n  template <>\n  struct hash<Puzzle>\n  {\n    std::size_t operator()(const Puzzle& p) const\n    {\n      std::size_t seed = p.vec.size();\n      for(auto& i : p.vec) {\n        seed ^= i + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n      }\n      return seed;\n    }\n  };\n}\n\n\nvector<Int> targetVec = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nPuzzle target(targetVec, 8, \"\");\nPuzzle source;\n\n\nInt bfs() {\n  queue<Puzzle> Q;\n  unordered_map<Puzzle, bool> DONE;\n  \n  Q.push(source);\n  DONE[source] = true;\n  \n  while (!Q.empty()) {\n    Puzzle top = Q.front(); Q.pop();\n    if (top == target) return top.path.length();\n    \n    loop(dir,0,dirs.size()) {\n      Puzzle p = top.move(dir);\n      if (p.blank== -1) continue; // Invalid board\n      if (DONE[p]) continue;\n      Q.push(p);\n      DONE[p] = true;\n    }\n  }\n  \n  cout << \"No solution\" << endl;\n  return -1;\n}\n\nvoid input() {\n  vector<Int> vec(NN, -1);\n  Int blank = -1;\n  loop(h,0,N) {\n    loop(w,0,N) {\n      cin >> vec[h*N + w];\n      if (vec[h*N + w] == 0) blank = h * N + w;\n    }\n  }\n  source.vec = vec;\n  source.blank = blank;\n}\n\nvoid solve() {\n  cout << bfs() << endl;\n}\n\n\nint main() {\n  input();\n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long Board;\n\nconst int N = 9;\nconst Board GOAL = 0x087654321;\n\nstruct State {\n    Board board;\n    int count;\n};\n\nqueue<State> q;\nset<Board> history;\n\ninline void swap(int numpos, int spacepos, Board& board) {\n    long long num = (board >> (numpos*4)) & 15;\n    board |= num << (spacepos*4);\n    board &= ~(15LL << (numpos*4));\n}\n\ninline int swap_and_check(int numpos, int spacepos, State s) {\n    swap(numpos, spacepos, s.board);\n    if (s.board == GOAL) {\n        return ++s.count;\n    }\n    if (history.insert(s.board).second) {\n        ++s.count;\n        q.push(s);\n    }\n    return -1;\n}\n\nvoid print(Board b) {\n    for (int i = 0; i < N; ++i) {\n        printf(\"%2lld\", (b >> (i*4) & 15));\n    }\n    printf(\"\\n\");\n}\n\n// OK\nint main(void) {\n\n    Board board = 0;\n    for (int i = 0, num; i < N; ++i) {\n        scanf(\"%d\", &num);\n        board |= static_cast<long long>(num) << (i*4);\n    }\n//    print(GOAL);\n//    print(board);\n\n    int count = 0;\n    if (board == GOAL) {\n        goto END;\n    }\n\n    q.push({ board, 0 });\n    while (!q.empty()) {\n        State s = q.front();\n        q.pop();\n\n        int pos = -1;\n        while (++pos < N) {\n            if (((s.board >> (pos*4)) & 15) == 0) {\n                break;\n            }\n        }\n\n        if (pos < 6) {\n            if ((count = swap_and_check(pos + 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos > 2) {\n            if ((count = swap_and_check(pos - 3, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 < 2) {\n            if ((count = swap_and_check(pos + 1, pos, s)) > 0) {\n                break;\n            }\n        }\n        if (pos % 3 > 0) {\n            if ((count = swap_and_check(pos - 1, pos, s)) > 0) {\n                break;\n            }\n        }\n    }\n\nEND:\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\nusing namespace std;\n\nconst int N = 3;\n\nclass Puzzle {\npublic:\n\n\tint p[N][N];\n\tpair<int, int> space;\n\tint count;\n\n\tbool operator < (const Puzzle &a) const {\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (p[i][j] == a.p[i][j])\n\t\t\t\t\tcontinue;\n\t\t\t\treturn p[i][j] < a.p[i][j];\n\t\t\t}\n\n\t\t}\n\t\treturn false;\n\t}\n};\n\n\nvoid printPuzzle(const Puzzle &a) {\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcout << a.p[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\n\tint x;\n\tcin >> x;\n}\n\n\nbool isSolve(const Puzzle &p) {\n\n\tint count = 1;\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (p.p[i][j] != count)\n\t\t\t\treturn false;\n\t\t\tcount++;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint bfs(Puzzle &p) {\n\n\tint dx[4] = { 1, 0, -1, 0 };\n\tint dy[4] = { 0, 1, 0, -1 };\n\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> M;\n\tQ.push(p);\n\tint count = 0;\n\tM[p] = true;\n\n\twhile (!Q.empty()) {\n\t\tPuzzle nowPuzzle = Q.front();\n\t\tQ.pop();\n\n\t\tif (isSolve(nowPuzzle))\n\t\t\treturn nowPuzzle.count;\n\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tint nextX = nowPuzzle.space.first + dx[i];\n\t\t\tint nextY = nowPuzzle.space.second + dy[i];\n\n\t\t\tif (nextX < 0 || N <= nextX || nextY < 0 || N <= nextY)\n\t\t\t\tcontinue;\n\n\t\t\tPuzzle nextPuzzle = nowPuzzle;\n\t\t\tnextPuzzle.space = make_pair(nextX, nextY);\n\t\t\tswap(nextPuzzle.p[nextX][nextY], nextPuzzle.p[nowPuzzle.space.first][nowPuzzle.space.second]);\n\t\t\tif (!M[nextPuzzle]) {\n\t\t\t\tM[nextPuzzle] = true;\n\t\t\t\tnextPuzzle.count++;\n\t\t\t\tQ.push(nextPuzzle);\n\t\t\t\t// cout << nextPuzzle.count << endl;\n\t\t\t\t// printPuzzle(nextPuzzle);\n\t\t\t}\n\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\n\tPuzzle puzzle;\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> puzzle.p[i][j];\n\n\t\t\tif (puzzle.p[i][j] == 0) {\n\t\t\t\tpuzzle.p[i][j] = 9;\n\t\t\t\tpuzzle.space = make_pair(i, j);\n\t\t\t\tpuzzle.count = 0;\n\t\t\t}\n\n\t\t}\n\t}\n\n\tcout << bfs(puzzle) << endl;\n\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#define inf 0x3f3f3f3f\nint map[8][8];\nint vis[8][8];\nint minn;\nint dir[4][2]={0,1,1,0,0,-1,-1,0};\nint s[8][8]={{1,2,3},{4,5,6},{7,8,0}};\nint judge(int a[8][8])\n{\n      for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n      if(a[i][j]!=s[i][j])return 0;\n    return 1;\n}\nvoid dfs(int x,int y,int step)\n{\n    if(judge(map))\n    {\n        if(step<minn)minn=step;\n    }\n    for(int i=0;i<4;i++)\n    {\n        int tx=x+dir[i][0];\n        int ty=y+dir[i][1];\n        if(tx<0||ty<0||tx>=3||ty>=3)continue;\n        if(vis[tx][ty]==0)\n        {\n            vis[tx][ty]=1;\n            map[x][y]=map[tx][ty];\n            map[tx][ty]=0;\n            dfs(tx,ty,step+1);\n            vis[tx][ty]=0;\n            map[tx][ty]=map[x][y];\n            map[x][y]=0;\n        }\n    }\n    return ;\n}\nint main()\n{\n    minn=inf;\n    memset(vis,0,sizeof(vis));\n    int a,b;\n    for(int i=0;i<3;i++)\n        for(int j=0;j<3;j++)\n        {\n            scanf(\"%d\",&map[i][j]);\n            if(map[i][j]==0)\n            {\n                a=i;b=j;\n            }\n        }\n    dfs(a,b,0);\n    printf(\"%d\\n\",minn);\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<string>\n#define N  3\n#define N2 9\nusing namespace std;\nconst int dx[4]={-1,0,1,0};\nconst int dy[4]={0,-1,0,1};\nconst char toward[4]={'l','u','r','d'};\n\nclass Block{\npublic:\n    int A[N2];\n    string trace;\n    int loc;\n\n    bool operator < (const Block & b) const {\n        for(int i=0;i<N2;i++){\n            if(this->A[i]>b.A[i]) return false;\n            if(this->A[i]<b.A[i]) return true;\n        }\n        return false;\n    }\n};\nbool right(const Block &b){\n    for(int i=0;i<N2;i++){\n        if(b.A[i]!=i+1) return false;\n    }\n    return true;\n}\nvoid show(Block b){\n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n            cout<<b.A[i*N+j]<<' ';\n        }\n        cout<<endl;\n    }\n}\nstring bfs(Block b){\n    queue<Block> Q;\n    map<Block,bool> M;\n    Block temp;\n    int i,j,k;\n    Q.push(b);\n    M[b]=true;\n    while(!Q.empty()){\n        temp=Q.front();\n        Block tt=temp;\n        Q.pop();\n        if(right(temp)){\n            return temp.trace;\n        }\n        for(i=0;i<4;i++){\n            temp=tt;\n            int temploc=temp.loc;\n            int sx=temp.loc%N;\n            int sy=temp.loc/N;\n            int ex=sx+dx[i];\n            int ey=sy+dy[i];\n            int eloc=ey*N+ex;\n            if(ex<0 || ey<0 || ex>=N || ey>=N) continue;\n            swap(temp.A[temploc],temp.A[eloc]);\n            temp.loc=eloc;\n            if(right(temp)){\n                temp.trace+=toward[i];\n                return temp.trace;\n            }else\n            if(!M[temp]){\n                temp.trace+=toward[i];\n                M[temp]=true;\n                Q.push(temp);\n                //show(temp);\n                //cout<<endl;\n            }\n\n        }\n    }\n    cout<<\"???\"<<endl;\n    return \"WTF!\";\n}\nint main(){\n    int i;\n    Block b;\n    for(int i=0;i<N2;i++){\n        cin>>b.A[i];\n        if(b.A[i]==0){\n            b.loc=i;\n            b.A[i]=N2;\n        }\n    }\n    b.trace=\"\";\n    string s=bfs(b);\n    if(s==\"WTF!\") cout<<\"unsolvable\"<<endl;\n    else cout<<s.length()<<endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst vector<int> answer = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\nqueue<board> pq;\nvector<int> searched[9];\n\nclass board{\npublic:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<int> tiles;\n\n    explicit board(vector<int> num, int move, int zp){\n        wrongs = 0;\n        tiles = num;\n        zero_place = zp;\n        moves = move;\n    }\n\n    void board_to_int(int m){\n        int k = 0;\n        REP(i, 9)\n            k += (tiles[i] * pow(10, i));\n        for(int i = searched[tiles[0]].size(); i > 0 ; i--)\n            if(k == searched[tiles[0]][i-1])\n                return;\n        pq.push(board(tiles, moves+1, zero_place+m));\n        searched[tiles[0]].push_back(k);\n        return;\n    }\n\n    void move() {\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            board_to_int(-1);\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            board_to_int(-3);\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            board_to_int(3);\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            board_to_int(1);\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\nint solve(){\n    int z;\n    REP(i, 9) if(original[i] == 0) {z=i; break;}\n    pq.push(board(original, 0, z));\n    while(1){\n        auto target = pq.front();\n        pq.pop();\n        if(target.tiles == answer)\n            return target.moves;\n        target.move();\n    }\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = solve();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<memory>\n#include<functional>\n\n#define rep(i, n) REP(i, 0, n)\n#define REP(i, a, n) for(int i = a ; i < (int)n ; i++)\n\nusing namespace std;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nstruct Puzzle{\n  int field[9];\n  int space;\n  int turn;\n\n  bool operator < (const Puzzle& a) const{\n    rep(i, 9){\n      if(a.field[i] == field[i]) continue;\n      return field[i] >  a.field[i];\n    }\n    return false;\n  }\n};\n\nbool check(Puzzle p){\n  rep(i, 9){\n    if(p.field[i] != i+1) return false;\n  }\n  return true;\n}\n\nint solve(Puzzle in){\n  queue<Puzzle> q;  \n  map<Puzzle, bool> mp;\n\n  q.push(in);\n  mp[in] = true;\n  \n  // bfs\n  while(!q.empty()){\n    Puzzle p = q.front(); q.pop();\n    if(check(p)) return p.turn;\n    int x = p.space % 3;\n    int y = p.space / 3;\n    rep(i, 4){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(nx < 0 || 2 < nx || ny < 0 || 2 < ny) continue;\n      Puzzle tmp = p;\n      swap(tmp.field[p.space], tmp.field[3 * ny + nx]);\n      tmp.space = 3 * ny + nx;\n      if(mp[tmp] == false){\n    mp[tmp] = true;\n    tmp.turn++;\n    q.push(tmp);\n      }\n    }\n  }\n  return -1;\n}\n\nsigned main(){\n  Puzzle in;\n  \n  rep(i, 9){\n    cin >> in.field[i];\n    if(in.field[i] == 0){\n      in.field[i] = 9;\n      in.space = i;\n    }    \n  }\n\n  in.turn = 0;\n  cout << solve(in) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define N  3\n#define N2 9\nusing namespace std;\nstruct Puzzle{\n\tint f[N2];\n\tint space;\n\tstring path;\n\tbool operator < (const Puzzle &p) const \n\t{\n\t\tfor (int i = 0; i < N2; ++i)\n\t\t{\n\t\t\tif (f[i] == p.f[i]) continue;\n\t\t\treturn f[i] < p.f[i];\t\t\t\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p)\n{\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tif (p.f[i] != (i+1)) return false;\n\t}\n\treturn true;\n}\n\nstring bfs(Puzzle s)\n{\n\tqueue<Puzzle> Q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u,v;\n\ts.path = \"\";\n\tQ.push(s);\n\tV[s] = true;\n\twhile(!Q.empty())\n\t{\n\t\tu = Q.front(); Q.pop();\n\t\tif (isTarget(u)) return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r)\n\t\t{\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif( tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!V[v])\n\t\t\t{\n\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main()\n{\n\tPuzzle in;\n\tfor (int i = 0; i < N2; ++i)\n\t{\n\t\tcin>>in.f[i];\n\t\tif (in.f[i]==0) {\n\t\t\tin.space = i;\n\t\t        in.f[i] = 9;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout<<ans.size()<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nclass Puzzle {\npublic:\n    Puzzle(int *pzl) {\n        for (int i=0;i<9;i++) {\n            board[i]=pzl[i];\n            if (board[i] == 0)\n                zero = i;\n        }\n        moves_so_far = 0;\n    };\n\n    int moves_made() const {\n        return moves_so_far;\n    }\n\n    // for std::priority_queue\n    bool operator< (const Puzzle& p) const {\n        return hamm_dist() > p.hamm_dist();\n    }\n\n    bool operator== (const Puzzle& p) const {\n        for (int i = 0; i < 9; i++)\n            if (board[i] != p.board[i])\n                return false;\n        return true;\n    }\n\n    bool operator!= (const Puzzle& p) const {\n        return !(*this == p);\n    }\n\n    Puzzle& operator= (const Puzzle& p) {\n        zero = p.blank();\n        moves_so_far = p.moves_made();\n        for (int i = 0; i < 9; i++)\n            board[i] = p.board[i];\n\n        return *this;\n    }\n\n    int hamm_dist() const {\n        int cnt = 0;\n        for (int i = 0; i < 9; i++)\n            if (board[i] != i + 1)\n                cnt++;\n        return cnt + moves_so_far;\n    }\n\n    void move(int from, int to) {\n        swap(board[from], board[to]);\n        moves_so_far++;\n        zero = to;\n    }\n\n    int blank() const {\n        return this->zero;\n    }\n\n    bool solved() {\n        for (int i = 0; i < 8; i++)\n            if (this->board[i] != i + 1)\n                return false;\n        return true;\n    }\n    \nprivate:\n    int board[9];\n    int moves_so_far;\n    int zero;\n};\n\nint main(void)\n{\n    int puzzle[9];\n    for (int i = 0; i < 9; i++)\n        cin >> puzzle[i];\n    priority_queue<Puzzle> pqueue;\n    pqueue.push(Puzzle(puzzle));\n\n    Puzzle prev(puzzle);\n    while (true) {\n        Puzzle cur = pqueue.top();\n        pqueue.pop();\n        if (cur.solved()) {\n            cout << cur.moves_made() << endl;\n            break;\n        }\n\n        int zero = cur.blank();\n        vector<int> moves;\n        if (zero > 2)\n            moves.push_back(-3);\n        if (zero < 6)\n            moves.push_back(3);\n        if ((zero + 1) % 3 != 0)\n            moves.push_back(1);\n        if (zero % 3 != 0)\n            moves.push_back(-1);\n        for (auto d : moves) {\n            Puzzle newp = cur;\n            newp.move(zero, zero + d);\n            if (prev != newp)\n                pqueue.push(newp);\n        }\n        prev = cur;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <array>\n#include <set>\n#include <queue>\nusing namespace std;\n\n#define si static inline\n#define gcu getchar_unlocked\nsi int in() {\n\tint n = 0, c = gcu();\n\t// bool minus = false; if (c == '-') minus = true, c = gcu();\n\tdo {n = 10 * n + (c - '0'), c = gcu();} while (c >= '0');\n\treturn n; }\n\t// return minus ? -n : n; }\nsi void scan(char *s) {while (!isspace(*s++ = gcu()));}\n#define pcu putchar_unlocked\n#define svo si void out\ntemplate <typename T>\nsvo(T n) {\n\tstatic char buf[20];\n\tchar *p = buf;\n\t//if(n < 0) pcu('-'), n *= -1;\n\tif (!n) *p++ = '0';\n\telse while (n) *p++ = n % 10 + '0', n /= 10;\n\twhile (p != buf) pcu(*--p); }\nsvo(const char *s){while(*s)pcu(*s++);}\nsvo(char *s){while(*s)pcu(*s++);}\nsvo(char c){pcu(c);}\n//template <typename T>\n//svo(vector<T> &v){for(T &x:v)out(' '),out(x);out('\\n');}\n//svo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);out('\\n');}\ntemplate <typename head, typename... tail>\nsvo(head&& h, tail&&... t){out(h);out(move(t)...);}\n#undef svo\n#undef si\n\nstruct board {\n\tenum {size = 3};\n\tstruct pos {int r, c;};\n\ttypedef array<array<int, size>, size> arr;\n\tarr b;\n\tpos p;\n\tint f, g, h;\n\n\tvoid read() {\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tb[i][j] = in();\n\t\t\t\tif (!b[i][j])\n\t\t\t\t\tp.r = i, p.c = j;\n\t\t\t}\n\t\tg = 0;\n\t\tf = h = hn(b);\n\t}\n\tvoid print() {\n\t\tfor (auto &r: b) {\n\t\t\tfor (int &c: r)\n\t\t\t\tout(&c == &r[0]?\"\":\" \", c);\n\t\t\tout('\\n');\n\t\t}\n\t\tout('\\n');\n\t}\n\n\tint hn(arr &a) {\n\t\tint l = 0;\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tint k = a[i][j] ? a[i][j] - 1 : size * size - 1;\n\t\t\t\tl += abs(i - k / 3) + abs(j - k % 3);\n\t\t\t}\n\t\treturn l;\n\t}\n\n\tint solver() {\n\t\tstatic const pos to[] = {-1, 0, 0, -1, 1, 0, 0, 1};\n\t\tset<arr> m;\n\t\tpriority_queue<board> q;\n\t\tq.push(*this);\n\t\twhile (!q.empty()) {\n\t\t\tboard a = q.top();\n\t\t\tq.pop();\n//\t\t\tout(a.f,  '\\n');\n//\t\t\ta.print();\n\t\t\tauto it = m.find(a.b);\n\t\t\tif (it != m.end())\n\t\t\t\tcontinue;\n\t\t\tm.insert(a.b);\n\t\t\tif (!a.h)\n\t\t\t\treturn a.g / 2;\n\t\t\tfor (pos o: to) {\n\t\t\t\to.r += a.p.r, o.c += a.p.c;\n\t\t\t\tif (0 <= o.r && o.r < size && 0 <= o.c && o.c < size) {\n\t\t\t\t\tboard c = a;\n\t\t\t\t\tswap(c.b[a.p.r][a.p.c], c.b[o.r][o.c]);\n\t\t\t\t\tc.g += 2;\n\t\t\t\t\tc.h = hn(c.b);\n\t\t\t\t\tc.f = c.g + c.h;\n\t\t\t\t\tc.p = o;\n\t\t\t\t\tq.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\nbool operator < (const board &a, const board &b) {\n\treturn a.f > b.f;\n}\n\nint main() {\n\tboard b;\n\tb.read();\n\tout(b.solver(), '\\n');\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n  bool operator<(const Puzzle &p)const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r',};\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++)\n    if(p.f[i]!=(i+1))return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle>Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front();\n    Q.pop();\n    if(isTarget(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N)continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i=0;i<N2;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout<<ans.size()<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n\nstruct Puzzle {\n  int f[N*N];\n  int space;\n  string path;\n\n  bool operator < ( const Puzzle &p ) const {\n    for(int i=0;i < N*N; i++){\n      if(f[i]==p.f[i]) continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<N*N;i++)\n    if(p.f[i]!=(i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N) continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main()\n{\n  Puzzle in;\n\n  for(int i=0;i<N*N;i++){\n    cin>>in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N*N;\n      in.space=i;\n    }\n  }\n  string ans=bfs(in);\n  cout<<ans.size()<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n \nstruct Puzzle{\n    int f[N2];\n    int space;\n    string path;\n     \n    bool operator < (const Puzzle &p) const{\n        for(int i = 0; i < N2; i++){\n            if(f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n \nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n \nbool isTarget(Puzzle p){\n    for(int i = 0; i < N2; i++)\n        if(p.f[i] != (i + 1)) return false;\n    return true;\n}\n \nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n     \n    while(!Q.empty()){\n        u = Q.front(); Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for(int r = 0; r < 4; r++){\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if(!V[v]){\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n \nint main(){\n    Puzzle in;\n    for(int i = 0; i < N2; i++){\n        cin >> in.f[i];\n        if(in.f[i] == 0){\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n     \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<queue>\n\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    for(int i = 0; i<N2;i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i = 0; i<N2;i++){\n    if(p.f[i] != (i+1)) return false;\n  }\n    return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while(!Q.empty()){\n    u = Q.front();\n    Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r = 0; r<4;r++){\n      int tx = sx+dx[r];\n      int ty = sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N) continue;\n      v = u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space = tx*N+ty;\n      if(!V[v]){\n\tV[v] = true;\n\tv.path += dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i = 0; i<N2;i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout<<ans.size()<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 10010;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> Array;\ntypedef vector<Array> Graph;\ntypedef pair<double, double> pdd;\nconst ull mod = 1000000000 + 7;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\nconst int CODE_MAX = 362880;\nconst int SIZE = 9;\nint visited[CODE_MAX];\n\nint factorial(int n){\n    if(n==1) return 1;\n    return n*factorial(n-1);\n};\n\nstruct Board{\n    int num[SIZE];\n    void print(){\n        for(int i=0;i<SIZE;i++) cout << num[i] << \" \";\n        cout << endl;\n    }\n};\n\nint encode(Board &b){\n    int res = 0;\n    int temp_b[SIZE];\n    for(int i=0;i<SIZE;i++) temp_b[i] = b.num[i];\n    for(int i=0;i<SIZE-1;i++){\n        res += factorial(SIZE-1-i)*temp_b[i];\n        for(int j=i+1;j<SIZE-1;j++){\n            if(temp_b[i]<temp_b[j]) temp_b[j]--;\n        }\n    }\n   return res;\n}\n\nBoard decode(int encoded){\n    Board b;\n    int tmp[SIZE];\n    for(int i=0;i<SIZE-1;i++){\n        int fact = factorial(SIZE-1-i);\n        tmp[i] = encoded/fact;\n        encoded %= fact;\n    }\n    tmp[SIZE-1] = 0;\n    int tmp2[SIZE];\n    bool check[SIZE];\n    for(int i=0;i<SIZE;i++){\n        tmp2[i] = i;\n        check[i] = false;\n    }\n    for(int i=0;i<SIZE;i++){\n        int j=0;\n        while(tmp[i]!=tmp2[j] || check[j]) j++;\n        b.num[i] = j;\n        check[j] = true;\n        while(j<SIZE){\n            tmp2[j]--;\n            j++;\n        }\n    }\n\n    return b;\n}\n\nint get_adjacent(int now, int i){\n    // \"i\" represents the direction of zero movement.0 up, 1 down, 2 left, 3 right\n    Board b = decode(now);\n    int zero=0;\n    while(b.num[zero]!=0) zero++;\n    if(i==0){\n        if(zero<3) return -1;\n        swap(b.num[zero], b.num[zero-3]);\n    }\n    if(i==1){\n        if(zero>5) return -1;\n        swap(b.num[zero], b.num[zero+3]);\n    }\n    if(i==2){\n        if(zero%3<1) return -1;\n        swap(b.num[zero], b.num[zero-1]);\n    }\n    if(i==3){\n        if(zero%3>1) return -1;\n        swap(b.num[zero], b.num[zero+1]);\n    }\n    return encode(b);\n}\n\nint heuristic_func(int enc1, int enc2){\n    Board b1 = decode(enc1);\n    int zero1 = 0;\n    while(b1.num[zero1]!=0) zero1++;\n    Board b2 = decode(enc2);\n    int zero2 = 0;\n    while(b2.num[zero2]!=0) zero2++;\n    return abs(zero1/3 - zero2/3) + abs(zero1%3 - zero2%3);\n}\n\nint heuristic_func2(int enc1, int enc2){\n    Board b1 = decode(enc1);\n    Board b2 = decode(enc2);\n    int res = 0;\n    for(int i=1;i<SIZE;i++){\n        int pos1 = 0;\n        int pos2 = 0;\n        while(b1.num[pos1]!=i) pos1++;\n        while(b2.num[pos2]!=i) pos2++;\n        res += abs(pos1/3-pos2/3) + abs(pos1%3 - pos2%3);\n    }\n    return res;\n}\n\nint main(){\n    Board b;\n    for (int i=0;i<SIZE;i++){\n        cin >> b.num[i];\n    }\n    for(int i=0;i<CODE_MAX;i++){\n        visited[i] = -1;\n    }\n\n    const int start = encode(b);\n    const int goal = 46233;\n    priority_queue<pii, vector<pii>, greater<pii> > que;\n    que.push(make_pair(heuristic_func2(start, goal), start));\n    visited[start] = 0;\n    int count = 0;\n    while(visited[goal]==-1){\n        pii x = que.top();\n        que.pop();\n        int now = x.second;\n        for(int i=0;i<4;i++){\n            int adj = get_adjacent(now, i);\n            if(adj==-1 || visited[adj]!=-1) continue;\n            count++;\n            visited[adj] = visited[now]+1;\n            que.push(make_pair(heuristic_func2(adj, goal) + visited[adj], adj));\n        }\n    }\n    cout << visited[goal] << endl;\n    //cout << count << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<string>\n\nusing namespace std;\n#define N 3\n#define M 9\nint i,j;;\n//?§????????????????\nstruct Puzzle{\n  int f[M];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p)const{\n    for( i=0;i<M;i++){\n      if(f[i]==p.f[i])continue;\n      return f[i]>p.f[i];\n    }\n    return false;\n  }\n  \n};\n////\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n///\nvoid swapp(int *p,int *q){\n  int tmp;\n  tmp=*p;\n  *p=*q;\n  *q=tmp;\n}\n///\nbool Target(Puzzle p){\n  for(i=0;i<M;i++)if(p.f[i]!=(i+1))return false;\n  return true;\n\n}\n///\n\n///\nstring bfs(Puzzle s){\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  queue<Puzzle> Q;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front();\n    Q.pop();\n    if(Target(u))return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N)continue;\n      v=u;\n      swapp(&v.f[u.space],&v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      } \n    }\n  }\n  return \"unsolvable\";\n}\n///\n\nint main(){\n  Puzzle in;\n\n  for(i=0;i<M;i++){\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i]==0){\n      in.f[i]=M;\n      in.space=i;\n    }\n  }\n\n  string ans=bfs(in);\n  cout << ans.size() << endl;\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-12)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nstring s = \"\";\nstring ans = \"123456780\";\nint d[4] = {-1,1,-3,3};\n\ntypedef pair<string,pair<int,int> > state;\n\nint solve(){\n  int ind = 0;\n  FOR(i,0,9)if(s[i]=='0')ind=i;\n  queue<state> q;\n  set<string> st;\n  st.insert(s);\n  q.push(mp(s,mp(0,ind)));\n  while(!q.empty()){\n    state u = q.front();\n    q.pop();\n    if(u.f==ans)return u.s.f;\n    FOR(i,0,4){\n      int index = u.s.s;\n      if(index%3==0 && d[i]==-1)continue;\n      if((index+1)%3==0 && d[i]==1)continue;\n      if(index<=2 && d[i]==-3)continue;\n      if(6<=index && d[i]==3)continue;\n      string v = u.f;\n      swap(v[index],v[index+d[i]]);\n      if(st.count(v)==0){\n        q.push(state(v,mp(u.s.f+1,index+d[i])));\n        st.insert(v);\n      }\n    }\n  }\n  return inf;\n}\n\nint main()\n{\n  FOR(i,0,9){\n    string a;\n    cin>>a;\n    s+=a;\n  }\n  cout<<solve()<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iterator>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nnamespace eight_puzzle{\n\ttypedef unsigned int uint;\n\tconst int N = 3;\n\tconst int ansval = 123456780;\n\tconst int ansarray[N*N] = {1,2,3,4,5,6,7,8,0};\n\tuint arraytovalue(int *table){\n\t\tuint t=0;\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tt*=10;\n\t\t\tt=t+table[i];\n\t\t}\n\t\treturn t;\n\t}\n\tvoid valuetoarray(uint t,int *table){\n\t\tfor(int i=N-1;i>=0;--i){\n\t\t\tfor(int j=N-1;j>=0;--j){\n\t\t\t\tint panel = t-t/10*10;\n\t\t\t\ttable[i*N+j] = panel;\n\t\t\t\tt/=10;\n\t\t\t}\n\t\t}\t\t\n\t}\n\tuint getscore(uint t){\n\t\tint table[N*N];\n\t\tuint score = 0;\n\t\tvaluetoarray(t,table);\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tfor(int j=0;j<N*N;++j){\n\t\t\t\tif(ansarray[i]==table[j]){\n\t\t\t\t\tscore += (i/N-j/N)*(i/N-j/N)+(i%N-j%N)*(i%N-j%N);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn score;\n\t}\n\tstruct State{\n\t\tState(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t\tscore = s.score;\n\t\t}\n\t\tState(const uint tt,const uint tn){\n\t\t\ttable = tt;\n\t\t\tn = tn;\n\t\t\tscore = getscore(table);\n\t\t}\n\n\t\tState& operator=(const State &s){\n\t\t\ttable = s.table;\n\t\t\tn = s.n;\n\t\t\tscore = s.score;\n\t\t\treturn (*this);\n\t\t}\n\t\tbool operator<(const State& s) const{\n\t\t\treturn score < s.score;\n\t\t}\n\t\tbool operator>(const State& s) const{\n\t\t\treturn score > s.score;\n\t\t}\n\t\tbool isfinished() const{\n\t\t\t\treturn table == 123456780;\n\t\t}\n\t\t\n\t\tuint table;\n\t\tuint n;\n\t\tuint score;\n\t};\n\n\tvoid getnextstate(const State &s,std::vector<State> &states){\n\t\tint table[N*N];\n\t\tint t = s.table;\n\t\tint zi,zj;\n\t\tvaluetoarray(t,table);\n\t\tfor(int i=0;i<N*N;++i){\n\t\t\tif(table[i]==0){\n\t\t\t\tzi = i/N;\n\t\t\t\tzj = i%N;\n\t\t\t}\n\t\t}\n\t\tfor(int i=-1;i<=1;++i){\n\t\t\tfor(int j=-1;j<=1;++j){\n\t\t\t\tif((i+j)%2==0)continue;\n\t\t\t\tint ti = zi+i,tj=zj+j;\n\t\t\t\tif(0<=ti&&ti<N&&0<=tj&&tj<N){\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t\tstates.push_back(State(arraytovalue(table),s.n+1));\n\t\t\t\t\tstd::swap(table[ti*N+tj],table[zi*N+zj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tstd::vector<uint> visited;\n\t\n};\n\nint main(){\n\tusing namespace eight_puzzle;\n\tint array[N*N];\n\tfor(int i=0;i<N*N;++i){\n\t\tstd::cin>>array[i];\n\t}\n\tState init(arraytovalue(array),0);\n\tstd::priority_queue<State,std::vector<State>,std::greater<State> > Q;\n\tQ.push(init);\n\twhile(!Q.empty()){\n\t\tState s = Q.top();\n\t\tQ.pop();\n\t\tstd::vector<State> states;\n\t\tgetnextstate(s,states);\n\t\tfor(uint i=0;i<states.size();++i){\n\t\t\tif(states[i].isfinished()){\n\t\t\t\tstd::cout<<states[i].n<<std::endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(std::find(visited.begin(),visited.end(),states[i].table)==visited.end()){\n\t\t\t\tQ.push(states[i]);\n\t\t\t\tvisited.push_back(states[i].table);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<queue>\n#include<cmath>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nconst int dx[4] = {0, -1, 0, 1};\nconst int dy[4] = {1, 0, -1, 0};\n\nint MDT[N2][N2];\n\nstruct Puzzle\n{\n\tint f[N2], space, MD;\n\tint cost;\n\tbool operator < (const Puzzle &p) const\n\t{\n\t\tfor(int i = 0; i < N2; i++){\n\t\t\tif(f[i] == p.f[i]) continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nint getallMD(const Puzzle &p)\n{\n\tint h = 0;\n\tfor(int i = 0; i < N2; i++){\n\tif(i == p.space) continue;\n\t\th += MDT[i][p.f[i] - 1];\n\t}\n\treturn h;\n}\n\nstruct State\n{\n\tPuzzle pz;\n\tint estimated;\n\tbool operator < (const State &s) const\n\t{\n\t\tif(estimated != s.estimated){\n\t\t\treturn estimated > s.estimated;\n\t\t}else{\n\t\t\treturn pz.MD > s.pz.MD;\n\t\t}\n\t}\n};\n\nint astar(Puzzle p)\n{\n\tpriority_queue<State> A;\n\tmap<Puzzle, bool> USED;\n\n\tState initial;\n\tinitial.pz = p;\n\tinitial.estimated = p.MD;\n\tA.push(initial);\n\tUSED[p] = true;\n\n\tPuzzle u, v;\n\tint sx, sy, tx, ty, r;\n\n\twhile(!A.empty())\n\t{\n\t\tu = A.top().pz; A.pop();\n\t\tif(u.MD == 0) return u.cost;\n\n\t\tsx = u.space / N;\n\t\tsy = u.space % N;\n\t\tfor(r = 0; r < 4; r++){\n\t\t\ttx = sx + dx[r];\n\t\t\tty = sy + dy[r];\n\t\t\tif(tx < 0 || tx >= N || ty < 0 || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tv.MD -= MDT[tx * N + ty][u.f[tx * N + ty] - 1];\n\t\t\tv.MD += MDT[sx * N + sy][u.f[tx * N + ty] - 1];\n\t\t\tswap(v.f[sx * N + sy], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\t\n\t\t\tif(!USED[v]){\n\t\t\t\tv.cost++;\n\t\t\t\tUSED[v] = true;\n\t\t\t\tState new_s;\n\t\t\t\tnew_s.pz = v;\n\t\t\t\tnew_s.estimated = v.cost + v.MD;\n\t\t\t\tA.push(new_s);\n\t\t\t}\n\t\t}\n\t};\n\treturn -1;\n}\n\nint main()\n{\n\t\n\tfor(int i = 0; i < N2; i++){\n\t\tfor(int j = 0; j < N2; j++){\n\t\t\tMDT[i][j] = abs((i / N) - (j / N)) + abs((i % N) - (j % N));\n\t\t}\n\t}\n\tPuzzle in;\n\n\tfor(int i = 0; i < N2; i++){\n\t\tscanf(\"%d\", &in.f[i]);\n\t\tif(in.f[i] == 0) in.space = i;\n\t}\n\tin.cost = 0;\n\tin.MD = getallMD(in);\n\n\tcout << astar(in) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdlib>\n#define _USE_MATH_DEFINES // M_PI????????????????????????\n#include<math.h>\n#include<queue>\n#include<map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator < ( const Puzzle &p ) const {\n\t\tfor(int i=0; i<N2; i++){\n\t\t\tif( f[i]==p.f[i] ) continue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const int dx[4]={-1, 0, 1, 0};\nstatic const int dy[4]={0, -1, 0, 1};\nstatic const char dir[4]={'u', 'l', 'd', 'r'}\n\nbool isTarget(Puzzle p){\n\tfor(int i=0; i<N2; i++)\n\t\tif( p.f[i]!=(i+1) ) return false;\n\treturn true;\n}\n\nstring bfs(Puzzle s){\n\tqueue<Puzzle> Q;\n\tmap<Puzzle,bool> V;\n\tPuzzle u,v;\n\ts.puth = \"\";\n\tQ.psuh(s);\n\tV[s] = true;\n\n\twhile( !Q.empty() ){\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif( isTarget(u) ) return u.push;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor(int r=0; r<4; r++){\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif( tx<0 || ty<0 || tx>=N || ty>=N ) continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx*N+ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif( !V[v] ){\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main(){\n\tPuzzle in;\n\n\tfor(int i=0; i<N2; i++){\n\t\tcin >> in.f[i];\n\t\tif( in.f[i]==0 ){\n\t\t\tin.f[i] = N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst int edge[4][3] = {{0, 3, 6}, {0, 1, 2}, {6, 7, 8}, {2, 5, 8}}; /* l, t, b, r */\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    int zero;\n    int original[9];\n    REP(i, 9){\n        original[i] = tiles[i];\n        if(tiles[i] == 0){\n            zero = i;\n        }\n    }\n    bool dir[4] = {true, true, true, true};\n    REP(i, 4) REP(j, 3)\n        if (zero == edge[i][j])\n            dir[i] = false;\n    if(wrongs + moves >= cutoff)\n        return -1;\n    if(dir[0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[0])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[1])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[2])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[3])\n        REP(i, 9) tiles[i] = original[i];\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n    int start = check();\n\n    REP(i, 50){\n        move = dfs(0, start + i);\n        if(move > 0)\n            break;\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nstruct Puz{\n  int board[3][3];\n  int zx, zy;\n  int cnt;\n  \n  bool operator < (const Puz &p)const{\n    for(int i = 0;i < 3;i++){\n      for(int j = 0;j < 3;j++){\n        if(board[i][j] == p.board[i][j]) continue;\n        return board[i][j] > p.board[i][j];\n      }\n    }\n    return false;\n  }\n  \n  bool operator == (const Puz &p)const{\n    for(int i = 0;i < 3;i++){\n      for(int j = 0;j < 3;j++){\n        if(board[i][j] != p.board[i][j]) return false;\n      }\n    }\n    return true;\n  }\n};\n\nint d[5] = {0, -1, 0, 1, 0};\nPuz g = {{{1, 2, 3}, {4, 5, 6}, {7, 8, 0}}};\nmap<Puz, int> mem;\n\nint bfs(Puz s){\n  \n  queue<Puz> Q;\n  \n  Q.push(s);\n  mem[s] = 1;\n  \n  while(Q.size()){\n    Puz p = Q.front(), q;\n    Q.pop();\n    \n    if(p == g) return p.cnt;\n    \n    for(int i = 0;i < 4;i++){\n      int x = p.zx + d[i], y = p.zy + d[i + 1];\n      \n      if(0 <= x && x < 3 && 0 <= y && y < 3){\n        q = p;\n        swap(q.board[q.zy][q.zx], q.board[y][x]);\n        q.zy = y;\n        q.zx = x;\n        q.cnt++;\n        if(!mem[q]++) Q.push(q);\n      }\n    }\n  }\n  \n  return 0;\n}\n\nint main(){\n  \n  Puz s;\n  \n  for(int i = 0;i < 3;i++){\n    for(int j = 0;j < 3;j++){\n      cin >> s.board[i][j];\n      if(s.board[i][j] == 0){\n        s.zy = i;\n        s.zx = j;\n      }\n    }\n  }\n  s.cnt = 0;\n  \n  cout << bfs(s) << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <string>\n#include <utility>\n\nusing namespace std;\n\n#define N (3)\n#define N2 (N*N)\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < ( const Puzzle &p ) const {\n\tfor ( int i = 0; i < N2; i++ ) {\n\t    if ( f[i] == p.f[i] ) continue;\n\t    return ( f[i] < p.f[i] );\n\t}\n\treturn false;\t\t// ????????????????????´???????????\\????????????\n        //return true;\n    }\n};\n\n// x, y?????????????????£??????\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget( Puzzle p ) {\n    for ( int i = 0; i < N2; i++ ) {\n\tif ( p.f[i] != ( i + 1 ) ) return false;\n    }\n    return true;\n}\n\nstring bfs( Puzzle s ) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push( s );\n    V[s] = true;\n    \n    while ( !Q.empty() ) {\n\tu = Q.front(); Q.pop();\n\tif ( isTarget( u ) ) return u.path;\n\tint sx = u.space / N;\n\tint sy = u.space % N;\n\t\n\tfor ( int r = 0; r < 4; r++ ) {\n\t    int tx = sx + dx[r];\n\t    int ty = sy + dy[r];\n\n\t    if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n\t    v = u;\n\t    swap( v.f[u.space], v.f[tx * N + ty] );\n\t    v.space = tx * N + ty;\n\t    if ( !V[v] ) {\n\t\tV[v] = true;\n\t\tv.path += dir[r];\n\t\tQ.push( v );\n\t    }\n\t}\n    }\n\n    return \"unsolvable\";\n}\n\nint main()\n{\n    Puzzle in;\n    \n    for ( int i = 0; i < N2; i++ ) {\n\tscanf(\"%d\", &in.f[i]);\n\tif ( in.f[i] == 0 ) {\n\t    in.f[i] = N2;\n\t    in.space = i;\n\t}\n    }\n    string ans = bfs( in );\n\n    printf(\"%d\\n\", (int)ans.size());\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\nconst int N=3;\nconst int N2=9;\n\nclass puzzle\n{\npublic:\n\tint f[N2];\n\tint space;\n\tstring path;\n\t\n\tbool operator<(const puzzle &p)const\n\t{\n\t\tfor(int i=0;i<N2;i++)\n\t\t{\n\t\t\tif(f[i]==p.f[i])continue;\n\t\t\treturn f[i]>p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nconst int dx[4]={-1,0,1,0};\nconst int dy[4]={0,-1,0,1};\nconst char dir[4]={'u','l','d','r'};\n\nbool istarget(puzzle p)\n{\n\tfor(int i=0;i<N2;i++)if(p.f[i]!=i+1)return false;\n\treturn true;\n}\n\nstring bfs(puzzle s)\n{\n\tqueue<puzzle>Q;\n\tmap<puzzle,bool>V;\n\tpuzzle u,v;\n\ts.path=\"\";\n\tQ.push(s);\n\tV[s]=true;\n\t\n\twhile(!Q.empty())\n\t{\n\t\tu=Q.front();Q.pop();\n\t\tif(istarget(u))return u.path;\n\t\tint sx=u.space/N;\n\t\tint sy=u.space%N;\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tint tx=sx+dx[r];\n\t\t\tint ty=sy+dy[r];\n\t\t\tif(tx<0||tx>=N||ty<0||ty>=N)continue;\n\t\t\tv=u;\n\t\t\tswap(v.f[u.space],v.f[tx*N+ty]);\n\t\t\tv.space=tx*N+ty;\n\t\t\tif(!V[v])\n\t\t\t{\n\t\t\t\tV[v]=true;\n\t\t\t\tv.path+=dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn \"unsolvable\";\n}\n\nint main()\n{\n\tpuzzle in;\n\tfor(int i=0;i<N2;i++)\n\t{\n\t\tcin>>in.f[i];\n\t\tif(in.f[i]==0)\n\t\t{\n\t\t\tin.f[i]=N2;\n\t\t\tin.space=i;\n\t\t}\n\t}\n\t\n\tstring ans=bfs(in);\n\t\n\tif(ans!=\"unsolvable\")cout<<ans.length()<<endl;\n\telse cout<<ans<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <array>\n#include <set>\n#include <queue>\nusing namespace std;\n\n#define si static inline\n#define gcu getchar_unlocked\nsi int in() {\n\tint n = 0, c = gcu();\n\t// bool minus = false; if (c == '-') minus = true, c = gcu();\n\tdo {n = 10 * n + (c - '0'), c = gcu();} while (c >= '0');\n\treturn n; }\n\t// return minus ? -n : n; }\nsi void scan(char *s) {while (!isspace(*s++ = gcu()));}\n#define pcu putchar_unlocked\n#define svo si void out\ntemplate <typename T>\nsvo(T n) {\n\tstatic char buf[20];\n\tchar *p = buf;\n\t//if(n < 0) pcu('-'), n *= -1;\n\tif (!n) *p++ = '0';\n\telse while (n) *p++ = n % 10 + '0', n /= 10;\n\twhile (p != buf) pcu(*--p); }\nsvo(const char *s){while(*s)pcu(*s++);}\nsvo(char *s){while(*s)pcu(*s++);}\nsvo(char c){pcu(c);}\n//template <typename T>\n//svo(vector<T> &v){for(T &x:v)out(' '),out(x);out('\\n');}\n//svo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);out('\\n');}\ntemplate <typename head, typename... tail>\nsvo(head&& h, tail&&... t){out(h);out(move(t)...);}\n#undef svo\n#undef si\n\nstruct board {\n\tenum {size = 3};\n\tstruct pos {int r, c;};\n\ttypedef array<array<int, size>, size> arr;\n\tarr b;\n\tpos p;\n\tint cnt = 0;\n\n\tvoid read() {\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tb[i][j] = in();\n\t\t\t\tif (!b[i][j])\n\t\t\t\t\tp.r = i, p.c = j;\n\t\t\t}\n\t}\n\tvoid print() {\n\t\tfor (auto &r: b) {\n\t\t\tfor (int &c: r)\n\t\t\t\tout(&c == &r[0]?\"\":\" \", c);\n\t\t\tout('\\n');\n\t\t}\n\t\tout('\\n');\n\t}\n\n\tint solver() {\n\t\tconst arr end = {1, 2, 3, 4, 5, 6, 7, 8, 0};\n\t\tset<arr> m;\n\t\tqueue<board> q;\n\t\tq.push(*this);\n\t\twhile (!q.empty()) {\n\t\t\tboard a = q.front();\n\t\t\tq.pop();\n\t\t\tif (a.b == end)\n\t\t\t\treturn a.cnt;\n\t\t\tpos to[] = {\n\t\t\t\ta.p.r + 1, a.p.c,\n\t\t\t\ta.p.r, a.p.c + 1,\n\t\t\t\ta.p.r - 1, a.p.c,\n\t\t\t\ta.p.r, a.p.c - 1\n\t\t\t};\n\t\t\tfor (pos o: to) {\n\t\t\t\tif (0 <= o.r && o.r < size && 0 <= o.c && o.c < size) {\n\t\t\t\t\tboard c = a;\n\t\t\t\t\tswap(c.b[a.p.r][a.p.c], c.b[o.r][o.c]);\n\t\t\t\t\tc.p = o;\n\t\t\t\t\tc.cnt = a.cnt + 1;\n\t\t\t\t\tq.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\nint main() {\n\tboard b;\n\tb.read();\n\tout(b.solver(), '\\n');\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct r{\n\tint men[3][3];\n\tint cnt;\n};\nbool used[9][9][9][9][9][9][9][9][9]={};\nint main(){\n\tint i,j,dx[4]={0,1,0,-1},dy[4]={-1,0,1,0},k,temp,menc[3][3]={{1,2,3},{4,5,6},{7,8,0}};\n\tr f,v;\n\tqueue<r> q;\n\tfor(i=0;i<3;i++){\n\t\tfor(j=0;j<3;j++){\n\t\t\tcin>>f.men[i][j];\n\t\t}\n\t}\n\tf.cnt=0;\n\tq.push(f);\n\twhile(!q.empty()){\n\t\tf=q.front();\n\t\tq.pop();\n\t\tif(used[f.men[0][0]][f.men[0][1]][f.men[0][2]][f.men[1][0]][f.men[1][1]][f.men[1][2]][f.men[2][0]][f.men[2][1]][f.men[2][2]]==false){\n\t\t\tused[f.men[0][0]][f.men[0][1]][f.men[0][2]][f.men[1][0]][f.men[1][1]][f.men[1][2]][f.men[2][0]][f.men[2][1]][f.men[2][2]]=true;\n\t\t}\n\t\telse continue;\n\t\tint o=0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tfor(j=0;j<3;j++){\n\t\t\t\tif(f.men[i][j]!=menc[i][j]){\n\t\t\t\t\to=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(o==0)break;\n\t\tint b=0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tfor(j=0;j<3;j++){\n\t\t\t\tif(f.men[i][j]==0){\n\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\tif(i+dy[k]>=0&&i+dy[k]<3&&j+dx[k]>=0&&j+dx[k]<3){\n\t\t\t\t\t\t\tv=f;\n\t\t\t\t\t\t\ttemp=v.men[i][j];\n\t\t\t\t\t\t\tv.men[i][j]=v.men[i+dy[k]][j+dx[k]];\n\t\t\t\t\t\t\tv.men[i+dy[k]][j+dx[k]]=temp;\n\t\t\t\t\t\t\tv.cnt++;\n\t\t\t\t\t\t\tq.push(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b==1)break;\n\t\t}\n\t}\n\tcout<<f.cnt<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <set>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<vector<int>, int> P;\n\nint zeroPosition( vector<int> a ) {\n    for ( int i = 0; i < 9; i++ ) {\n\tif ( a[i] == 0 ) return i;\n    }\n\n    return -1;\n}\n\nvector<int> swapDigit( vector<int> v, int a, int b ) {\n    vector<int> ret = v;\n    int x = v[a];\n    int y = v[b];\n    ret[a] = y;\n    ret[b] = x;\n\n    return ret;\n}\n\nbool isSame( vector<int> a, vector<int> b ) {\n    for ( int i = 0; i < 9; i++ ) {\n\tif ( a[i] != b[i] ) return false;\n    }\n\n    return true;\n}\n\nint convert( vector<int> a ) {\n    int ret = 0;\n    for ( int i = 0; i < 9; i++ ) {\n\tret *= 10;\n\tret += a[i];\n    }\n\n    return ret;\n}\n\nint main()\n{\n    set<int> S;\n    queue<P> Q;\n    vector<int> start;\n    vector<int> goal;\t\t// 123456780\n    for ( int i = 0; i < 9; i++ ) {\n\tgoal.push_back( (i + 1) % 9 );\n    }\n\n    for ( int i = 0; i < 9; i++ ) {\n\tint d;\n\tscanf(\"%d\", &d);\n\tstart.push_back( d );\n    }\n\n    S.insert( convert(start) );\n    Q.push( make_pair( start, 0 ) );\n    int ans = 0;\n\n    while ( !Q.empty() ) {\n\tP p = Q.front(); Q.pop();\n\tif ( isSame( p.first, goal) ) {\n\t    ans = p.second;\n\t    break;\n\t}\n\tint pos = zeroPosition( p.first );\n\t\n\tif ( ( pos % 3 ) != 0 ) { // ???????§???????\n\t    vector<int> v = swapDigit( p.first, pos, pos - 1 );\n\t    if ( S.find( convert(v) ) == S.end() ) {\n\t\tQ.push( make_pair( v, p.second + 1 ) );\n\t\tS.insert( convert(v) );\n\t    }\n\t}\n\n\tif ( ( pos % 3 ) != 2 ) { // ???????§???????\n\t    vector<int> v = swapDigit( p.first, pos, pos + 1 );\t    \n\t    if ( S.find( convert(v) ) == S.end() ) {\n\t\tQ.push( make_pair( v, p.second + 1 ) );\n\t\tS.insert( convert(v) );\n\t    }\n\t}\n\n\tif ( pos > 2 ) { // ???????§???????\n\t    vector<int> v = swapDigit( p.first, pos, pos - 3 );\t    \t    \n\t    if ( S.find( convert(v) ) == S.end() ) {\n\t\tQ.push( make_pair( v, p.second + 1 ) );\n\t\tS.insert( convert(v) );\n\t    }\n\t}\n\n\tif ( pos < 6 ) { // ???????§???????\n\t    vector<int> v = swapDigit( p.first, pos, pos + 3 );\t    \t    \n\t    if ( S.find( convert(v) ) == S.end() ) {\n\t\tQ.push( make_pair( v, p.second + 1 ) );\n\t\tS.insert( convert(v) );\n\t    }\n\t}\n    }\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator<(const Puzzle &p) const{\n    for(int i=0;i<N2;i++){\n      if(f[i]==p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\n\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++){\n    if(p.f[i] != (i+1)) return false;\n  }\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n    u=Q.front(); Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx=u.space/N;\n    int sy=u.space%N;\n\n    for(int r=0;r<4;r++){\n      int tx=sx+dx[r];\n      int ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=N||ty>=N) continue;\n      v=u;\n      swap(v.f[u.space],v.f[tx*N+ty]);\n      v.space=tx*N+ty;\n      if(!V[v]){\n\tV[v]=true;\n\tv.path+=dir[r];\n\tQ.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n  \n}\n\nint main(){\n  \n  Puzzle in;\n\n  for(int i=0;i<N2;i++){\n    cin >> in.f[i];\n    if(in.f[i]==0){\n      in.f[i]=N2;//set space\n      in.space=i;\n    }\n  }\n\n  string ans=bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n  \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define loop(i,j,k) for(long long i = j;i < k;i++)\n#include <iostream>\n#include <queue>\n#include <array>\n#include <utility>\n#include <stdio.h>\n\nusing namespace std;\n\nbool cp(array<array<int,3>,3>& e) {\n\tloop(i,0,3)loop(j,0,3)if(e[i][j]!=(1+j+i*3)%9)return false;\n\treturn true;\n}\n\nint main() {\n\tarray<array<int,3>,3> pz;\n\tqueue<pair<typeof(pz),int>> q;\n\tloop(i,0,3)loop(j,0,3)cin>>pz[i][j];\n\tq.push(make_pair(pz,0));\n\tif(cp(pz)) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\twhile(!q.empty()) {\n\t\tauto cur = q.front().first;\n\t\tint dep = q.front().second + 1;\n\t\tq.pop();\n\t\tint r=-1,c=-1;\n\t\tloop(i,0,3)loop(j,0,3)if(cur[i][j] == 0){r=i;c=j;}\n\t\tif(r!=2) {\n\t\t\tswap(cur[r][c],cur[r+1][c]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else q.push(make_pair(cur,dep));\n\t\t\tswap(cur[r][c],cur[r+1][c]);\n\t\t}\n\t\tif(r!=0) {\n\t\t\tswap(cur[r][c],cur[r-1][c]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else q.push(make_pair(cur,dep));\n\t\t\tswap(cur[r][c],cur[r-1][c]);\n\t\t}\n\t\tif(c!=2) {\n\t\t\tswap(cur[r][c],cur[r][c+1]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else q.push(make_pair(cur,dep));\n\t\t\tswap(cur[r][c],cur[r][c+1]);\n\t\t}\n\t\tif(c!=0) {\n\t\t\tswap(cur[r][c],cur[r][c-1]);\n\t\t\tif(cp(cur)) {\n\t\t\t\tcout << dep << endl;\n\t\t\t\treturn 0;\n\t\t\t} else q.push(make_pair(cur,dep));\n\t\t\tswap(cur[r][c],cur[r][c-1]);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\tbool operator <(const Puzzle &p) const {\n\t\tfor (int i = 0; i < N2; ++i) {\n\t\t\tif (f[i] == p.f[i])\n\t\t\t\tcontinue;\n\t\t\treturn f[i] > p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nbool isResolved(Puzzle p) {\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif (p.f[i] != i + 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nconst int dx[4] { -1, 0, 1, 0 };\nconst int dy[4] { 0, -1, 0, 1 };\nconst char dir[4] { 'u', 'l', 'd', 'r' };\n\nstring bfs(Puzzle p) {\n\tqueue<Puzzle> Q;\n\tp.path = \"\";\n\tQ.push(p);\n\tmap<Puzzle, bool> M;\n\tM[p] = true;\n\tPuzzle u, v;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tif (isResolved(u))\n\t\t\treturn u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!M[v]) {\n\t\t\t\tM[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unresolved\";\n}\n\nint main() {\n\tPuzzle p;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tscanf(\"%d\", &p.f[i]);\n\t\tif (p.f[i] == 0) {\n\t\t\tp.f[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(p);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<cmath>\n#include<cassert>\nusing namespace std;\nint inf = 1000000000;\n\nint dx[4] = {0,0,1,-1};\nint dy[4] = {1,-1,0,0};\n\nmap<string, int> mp;\n\nstring trans(vector< vector<int> > a){\n  string t = \"\";\n  for(int i=0; i<3; i++) for(int j=0; j<3; j++) t += to_string(a[i][j]);\n  return t;\n}\n\nvoid dfs(vector< vector<int> > a, int turn){\n  string t = trans(a);\n  if( mp[t] != 0 && turn > mp[t] ) return;\n  if( t == \"123456780\" ){\n    // cout << t << \" \" << turn << \" \" << mp[t] << endl;\n    mp[t] = turn;\n    return;\n  }\n  if( turn > 20 ) return;\n  mp[t] = turn;\n  // cerr << t << \" \" << mp[t] << endl;\n\n  for(int y=0; y<3; y++){\n    for(int x=0; x<3; x++){\n      if( a[y][x] == 0 ){\n        for(int d=0; d<4; d++){\n          int nx = x + dx[d]; int ny = y + dy[d];\n          if( nx < 0 || ny < 0 || nx >= 3 || ny >= 3 ) continue;\n          vector< vector<int> > b = a;\n          swap(b[ny][nx], b[y][x]);\n          string tt = trans(b);\n          dfs(b, turn + 1);\n        }\n      }\n    }\n  }\n  return;\n}\n\nint main(){\n\n  vector< vector<int> > a(3, vector<int>(3));\n  for(int i=0; i<3; i++) for(int j=0; j<3; j++) cin >> a[i][j];\n  mp[trans(a)] = 0;\n  mp[\"123456780\"] = inf;\n  dfs(a, 1);\n  cout << mp[\"123456780\"] - 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\nusing namespace std;\nint str[5][5],v[5][5];\nlong long int book[5][5][100010];\nstruct Han\n{\n    int x,y,n;\n    int s[5][5];\n};\nvoid bfs(int x,int y)\n{\n    int i,j,k=0,next[4][2]={0,1,1,0,0,-1,-1,0};\n    long long l=0;\n    queue<Han>Q;\n    Han q,now;\n    for(i=0;i<3;i++)\n    {\n        for(j=0;j<3;j++)\n        {\n            l=l*10+str[i][j];\n            q.s[i][j]=str[i][j];\n        }\n    }\n    book[x][y][0]=l;\n    v[x][y]++;\n    q.x=x;\n    q.y=y;\n    q.n=0;\n    Q.push(q);\n    while(!Q.empty())\n    {\n        now=Q.front();\n        Q.pop();\n        for(i=0;i<4;i++)\n        {\n            int xx=now.x+next[i][0];\n            int yy=now.y+next[i][1];\n            if(xx<0||yy<0||xx>=3||yy>=3)continue;\n            q.x=xx;\n            q.y=yy;\n            q.n=now.n+1;\n\n            for(k=0;k<3;k++)\n            {\n                for(j=0;j<3;j++)\n                {\n                    q.s[k][j]=now.s[k][j];\n                }\n            }\n            k=q.s[now.x][now.y];\n            q.s[now.x][now.y]=q.s[xx][yy];\n            q.s[xx][yy]=k;\n\n            l=0;\n            for(k=0;k<3;k++)\n            {\n                for(j=0;j<3;j++)\n                {\n                    l=l*10+q.s[k][j];\n                }\n            }\n            if(l==123456780){printf(\"%d\\n\",q.n);return;}\n            int flag=0,a=v[xx][yy];\n            for(k=0;k<a;k++)\n            {\n                if(book[xx][yy][k]==l)\n                {\n                    flag=1;\n                    break;\n                }\n            }\n            if(flag==0)\n            {\n                book[xx][yy][a]=l;\n                v[xx][yy]++;\n                Q.push(q);\n            }\n        }\n    }\n}\nint main()\n{\n    int i,j,a,ex,ey;\n    memset(book,0,sizeof(book));\n    memset(v,0,sizeof(v));\n    for(i=0;i<3;i++)\n    {\n        for(j=0;j<3;j++)\n        {\n            scanf(\"%d\",&a);\n            str[i][j]=a;\n            if(a==0)\n            {\n                ex=i;\n                ey=j;\n            }\n        }\n    }\n    bfs(ex,ey);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n  \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n  \nusing namespace std;\n  \ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n  \nconst int INF=1<<29;\nconst double EPS=1e-9;\n  \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nconst int boardw = 3;\n\nstruct BOARD {\n    int turn;\n    int map[boardw][boardw];\n    bool operator<(const BOARD &rhs) const {\n        for(int i = 0; i < boardw; i++) {\n            for (int j = 0; j < boardw; ++j) {\n                if (this->map[i][j] < rhs.map[i][j]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n};\n \nstd::queue<BOARD> q;\nstd::map<BOARD,int> m;\n \nbool check(BOARD b) {\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            if (b.map[i][j] == 0) continue;\n            int tgt = i * boardw + j + 1;\n            if (b.map[i][j] != tgt) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n \n \nint main(int argc, char const *argv[]) {\n    BOARD b;\n    for (int i = 0; i < boardw; ++i) {\n        for (int j = 0; j < boardw; ++j) {\n            cin >> b.map[i][j];\n        }\n    }\n    b.turn = 0;\n    q.push(b);\n    while(!q.empty()) {\n        BOARD nowB;\n        nowB = q.front(); q.pop();\n \n        if (check(nowB)) {\n            cout << nowB.turn << endl;\n            return 0;\n        }\n \n        int px, py;\n \n        for (int i = 0; i < boardw; ++i) {\n            for (int j = 0; j < boardw; ++j) {\n                if (nowB.map[i][j] == 0) {\n                    px = j;\n                    py = i;\n                }\n            }\n        }\n        /*\n        int est = 0;\n        for (int i = 0; i < boardw; ++i) {\n            for (int j = 0; j < boardw; ++j) {\n                int tgt = i * boardw + j + 1;\n                if (tgt == 16) tgt = 0;\n                for (int k = 0; k < boardw; k++) {\n                    for (int l = 0; l < boardw; l++) {\n                        if (nowB.map[k][l] == tgt) {\n                            est += std::abs(k - i) + std::abs(l - j);\n                        }\n                    }\n                }\n            }\n        }\n        if (nowB.turn + est / 2 - 1 > 45) continue;\n        */\n\n        int dx[] = {0, 1, 0, -1};\n        int dy[] = {1, 0, -1, 0};\n        for (int k = 0; k < 4; ++k) {\n            int tx = px + dx[k];\n            int ty = py + dy[k];\n            if (tx < 0 || tx >= boardw || ty < 0 || ty >= boardw) continue;\n             \n            BOARD newB;\n            for (int i = 0; i < boardw; ++i) {\n                for (int j = 0; j < boardw; ++j) {\n                    newB.map[i][j] = nowB.map[i][j];\n                }\n            }\n            newB.turn = nowB.turn + 1;\n \n            int temp = newB.map[py][px];\n            newB.map[py][px] = newB.map[ty][tx];\n            newB.map[ty][tx] = temp;\n            if (m.find(newB) == m.end()) {\n                m[newB] = 1;\n                q.push(newB);\n                \n            } \n        }\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n \nusing namespace std;\n \n#define N 3\n#define N2 9\n \nstruct Puzzle{\n    int f[N2];\n    int space;\n    string path;\n     \n    bool operator < (const Puzzle &p) const{\n        for(int i=0;i<N2;i++){\n            if(f[i]==p.f[i]) continue;\n            return f[i]>p.f[i];\n        }\n        return false;\n    }\n};\n \nstatic const int dx[4]={-1,0,1,0};\n \nstatic const int dy[4]={0,-1,0,1};\n \nstatic const char dir[4]={'u','a','d','r'};\n \nbool isTarget(Puzzle p){\n    for(int i=0;i<N2;i++){\n        if(p.f[i]!=(i+1)) return false;\n    }\n    return true;\n}\n \n \nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle,bool> V;\n    Puzzle u,v;\n    s.path=\"\";\n    Q.push(s);\n    V[s]=true;\n     \n    while(!Q.empty()){\n        u=Q.front();Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx=u.space/N;\n        int sy=u.space%N;\n        for(int r=0;r<4;r++){\n            int tx=sx+dx[r];\n            int ty=sy+dy[r];\n            if(tx<0||ty<0||tx>=N||ty>=N) continue;\n            v=u;\n            swap(v.f[u.space],v.f[tx*N+ty]);\n            v.space=tx*N+ty;\n            if(!V[v]){\n                V[v]=true;\n                v.path+=dir[r];\n                Q.push(v);\n            }\n        }\n    }\n     \n    return \"unsolvable\";\n}\n \n \nint main(){\n    Puzzle in;\n     \n    for(int i=0;i<N2;i++){\n        cin>>in.f[i];\n        if(in.f[i]==0){\n            in.f[i]=N2;\n            in.space=i;\n        }\n    }\n     \n    string ans = bfs(in);\n     \n    cout<<ans.size()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <vector>\n\ntypedef std::vector<std::vector<int> > TPuzzle;\n\nvoid MakeGoal(TPuzzle& Goal)\n{\n\tGoal.resize(3);\n\tfor(int i = 0; i < 3; ++i){\n\t\tGoal[i].resize(3);\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tGoal[i][j] = (1 + 3 * i + j) % 9;\n\t\t}\n\t}\n}\n\nvoid ZeroPosition(int& Row, int& Col, const TPuzzle& Puzzle)\n{\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tif(Puzzle[i][j] == 0){\n\t\t\t\tRow = i;\n\t\t\t\tCol = j;\n\t\t\t}\n\t\t}\n\t}\n}\n\nenum TMovePattern\n{\n\tmpUp,\n\tmpDown,\n\tmpLeft,\n\tmpRight\n};\n\nbool Movable(const TPuzzle& Puzzle, const TMovePattern& Pattern)\n{\n\tint Row, Col;\n\tZeroPosition(Row, Col, Puzzle);\n\tswitch(Pattern){\n\tcase mpUp    : return Row != 0;\n\tcase mpDown  : return Row != 2;\n\tcase mpLeft  : return Col != 0;\n\tcase mpRight : return Col != 2;\n\t}\n\tassert(false);\n\treturn false;\n}\n\nTPuzzle Move(TPuzzle Puzzle, const TMovePattern& Pattern)\n{\n\tint Row, Col;\n\tZeroPosition(Row, Col, Puzzle);\n\tswitch(Pattern){\n\tcase mpUp    : std::swap(Puzzle[Row][Col], Puzzle[Row - 1][Col]);break;\n\tcase mpDown  : std::swap(Puzzle[Row][Col], Puzzle[Row + 1][Col]);break;\n\tcase mpLeft  : std::swap(Puzzle[Row][Col], Puzzle[Row][Col - 1]);break;\n\tcase mpRight : std::swap(Puzzle[Row][Col], Puzzle[Row][Col + 1]);break;\n\t}\n\treturn Puzzle;\n}\n\nint CountMove(const std::set<TPuzzle>& Before, const TPuzzle& Goal, int Count)\n{\n\tif(Before.find(Goal) != Before.end()) return Count;\n\tstd::set<TPuzzle> Next;\n\tfor(std::set<TPuzzle>::const_iterator It = Before.begin(); It != Before.end(); ++It){\n\t\tconst TPuzzle& Puzzle = *It;\n\t\tif(Movable(Puzzle, mpUp))    Next.insert(Move(Puzzle, mpUp));\n\t\tif(Movable(Puzzle, mpDown))  Next.insert(Move(Puzzle, mpDown));\n\t\tif(Movable(Puzzle, mpLeft))  Next.insert(Move(Puzzle, mpLeft));\n\t\tif(Movable(Puzzle, mpRight)) Next.insert(Move(Puzzle, mpRight));\n\t}\n\treturn CountMove(Next, Goal, 1 + Count);\n}\n\nint CountMinimumMove(const TPuzzle& Puzzle, const TPuzzle& Goal)\n{\n\tstd::set<TPuzzle> Start;\n\tStart.insert(Puzzle);\n\treturn CountMove(Start, Goal, 0);\n}\n\nint main()\n{\n\tTPuzzle Goal;\n\tMakeGoal(Goal);\n\tTPuzzle Start(3, std::vector<int>(3));\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 0; j < 3; ++j){\n\t\t\tint Input;\n\t\t\tstd::cin >> Input;\n\t\t\tStart[i][j] = Input;\n\t\t}\n\t}\n\tstd::cout << CountMinimumMove(Start, Goal) << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Pazzle {\n    string field;\n    int space;\n};\n\nmap<string, bool> mp;\nqueue<Pazzle> que;\n\nint main() {\n    Pazzle p;\n    int num, depth = 0;\n    for (int i = 0; i < 9; i++) {\n        cin >> num;\n        p.field += num + '0';\n\n        if (num == 0) {\n            p.space = i;\n        }\n    }\n\n    que.push(p);\n    while (!que.empty()) {\n        int size = que.size();\n        for (int i = 0; i < size; i++) {\n            p = que.front();\n            que.pop();\n\n            if (p.field == \"123456780\") {\n                cout << depth << endl;\n                return 0;\n            }\n            if (mp[p.field] == true) {\n                continue;\n            }\n            else {\n                mp[p.field] = true;\n            }\n\n            if ((p.space + 1) % 3 != 0) {\n                swap(p.field[p.space], p.field[p.space + 1]);\n                p.space++;\n                que.push(p);\n                p.space--;\n                swap(p.field[p.space], p.field[p.space + 1]);\n            }\n            if (p.space % 3 != 0) {\n                swap(p.field[p.space], p.field[p.space - 1]);\n                p.space--;\n                que.push(p);\n                p.space++;\n                swap(p.field[p.space], p.field[p.space - 1]);\n            }\n            if (2 < p.space) {\n                swap(p.field[p.space], p.field[p.space - 3]);\n                p.space -= 3;\n                que.push(p);\n                p.space += 3;\n                swap(p.field[p.space], p.field[p.space - 3]);\n            }\n            if (p.space < 6) {\n                swap(p.field[p.space], p.field[p.space + 3]);\n                p.space += 3;\n                que.push(p);\n                p.space -= 3;\n                swap(p.field[p.space], p.field[p.space + 3]);\n            }\n        }\n        depth++;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-12)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nstring s = \"\";\nstring ans = \"123456780\";\nint d[4] = {-1,1,-3,3};\n\nbool rec(string v,int index,int step,int limit){\n  if(limit<step)return false;\n  if(v==ans)return true;\n  FOR(i,0,4){\n    if(index%3==0 && d[i]==-1)continue;\n    if((index+1)%3==0 && d[i]==1)continue;\n    if(index<=2 && d[i]==-3)continue;\n    if(6<=index && d[i]==3)continue;\n    string u = v;\n    swap(u[index],u[index+d[i]]);\n    if(rec(u,index+d[i],step+1,limit))return true;\n  }\n  return false;  \n}\n\nint solve(){\n  int res = 0;\n  int ind = 0;\n  FOR(i,0,9)if(s[i]=='0')ind=i;\n  while(!rec(s,ind,0,res))res++;\n  return res;\n}\n\nint main()\n{\n  FOR(i,0,9){\n    string a;\n    cin>>a;\n    s+=a;\n  }\n  cout<<solve()<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle\n{\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator<(const Puzzle &p) const\n    {\n        for (int i = 0; i < N2; i++)\n        {\n            if (f[i] == p.f[i])\n                continue;\n            return f[i] > p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p)\n{\n    for (int i = 0; i < N2; i++)\n        if (p.f[i] != (i + 1))\n            return false;\n    return true;\n}\n\nstring bfs(Puzzle s)\n{\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while (!Q.empty())\n    {\n        u = Q.front();\n        Q.pop();\n        if (isTarget(u))\n            return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; r++)\n        {\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N)\n                continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if (!V[v])\n            {\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main()\n{\n    Puzzle in;\n\n    for (int i = 0; i < N2; i++)\n    {\n        cin >> in.f[i];\n        if (in.f[i] == 0)\n        {\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define Ntw 3\n#define N2tw 9\n\nstruct Puzzletw{\n    int f[N2tw];\n    int space;\n    string path;\n\n    bool operator < (const Puzzletw &p)const{\n        for(int i=0;i<N2tw;i++){\n            if(f[i]==p.f[i])continue;\n            return f[i]>p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzletw p){\n    for(int i=0;i<N2tw;i++)\n    if(p.f[i] != (i+1))return false;\n    return true;\n}\n\nstring bfs(Puzzletw s){\n    queue<Puzzletw> Q;\n    map<Puzzletw,bool>V;\n    Puzzletw u, v;\n    s.path=\"\";\n    Q.push(s);\n    V[s]=true;\n\n    while(!Q.empty()){\n        u=Q.front();Q.pop();\n        if(isTarget(u))return u.path;\n        int sx = u.space/Ntw;\n        int sy = u.space%Ntw;\n        for(int r=0;r<4;r++){\n            int tx=sx+dx[r];\n            int ty=sy+dy[r];\n            if(tx<0||ty<0||tx>=Ntw||ty>=Ntw)continue;\n            v=u;\n            swap(v.f[u.space],v.f[tx*Ntw+ty]);\n            v.space=tx*Ntw+ty;\n            if(!V[v]){\n                V[v]=true;\n                v.path+=dir[r];\n                Q.push(v);\n            }\n        }\n    }\n\n    return \"unsolvable\";\n}\n\nint main(){\n    Puzzletw in;\n\n    for(int i=0;i<N2tw;i++){\n        cin >> in.f[i];\n        if(in.f[i]==0){\n            in.f[i]=N2tw;\n            in.space=i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size()<<endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#define Size 9\n\nusing namespace std; \n\nint find_zero(string state) {\n\tfor (int i = 0; i < Size; ++i) {\n\t\tif (state[i] == '0') {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstring move(string str, int p1, int p2) {\n\tstring res = str;\n\tres[p1] = str[p2];\n\tres[p2] = str[p1];\n\treturn res;\n}\n\nint main(void) {\n\tstring state = \"012345678\";\n\tfor (int i = 0; i < Size; ++i) {\n\t\tcin >> state[i];\n\t}\n\n\tint zi;\n\tmap<string,int> memo;\n\tmemo[state] = 1;\n\tpair<string,int> now;\n\tqueue< pair<string,int> > q;\n\tq.push({state,1});\n\twhile (!q.empty()) {\n\t\tnow = q.front();\n\t\tq.pop();\n\t\tif (now.first == \"123456780\") {\n\t\t\tcout << now.second-1 << endl;\n\t\t\tbreak;\n\t\t}\n\t\tzi = find_zero(now.first);\n\t\tif (zi%3 != 2) {\n\t\t\tstate = move(now.first,zi,zi+1);\n\t\t\tif (memo[state] == 0) {\n\t\t\t\tmemo[state] = now.second+1;\n\t\t\t\tq.push({state,now.second+1});\n\t\t\t}\n\t\t}\n\t\tif (zi%3 != 0) {\n\t\t\tstate = move(now.first,zi,zi-1);\n\t\t\tif (memo[state] == 0) {\n\t\t\t\tmemo[state] = now.second+1;\n\t\t\t\tq.push({state,now.second+1});\n\t\t\t}\n\t\t}\n\t\tif (zi/3 > 0) {\n\t\t\tstate = move(now.first,zi,zi-3);\n\t\t\tif (memo[state] == 0) {\n\t\t\t\tmemo[state] = now.second+1;\n\t\t\t\tq.push({state,now.second+1});\n\t\t\t}\n\t\t}\n\t\tif (zi/3 < 2) {\n\t\t\tstate = move(now.first,zi,zi+3);\n\t\t\tif (memo[state] == 0) {\n\t\t\t\tmemo[state] = now.second+1;\n\t\t\t\tq.push({state,now.second+1});\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 10010;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> Array;\ntypedef vector<Array> Graph;\ntypedef pair<double, double> pdd;\nconst ull mod = 1000000000 + 7;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\nconst int CODE_MAX = 362880;\nconst int SIZE = 9;\nint visited[CODE_MAX];\n\nint factorial(int n){\n    if(n==1) return 1;\n    return n*factorial(n-1);\n};\n\nstruct Board{\n    int num[SIZE];\n    void print(){\n        for(int i=0;i<SIZE;i++) cout << num[i] << \" \";\n        cout << endl;\n    }\n};\n\nint encode(Board &b){\n    int res = 0;\n    int temp_b[SIZE];\n    for(int i=0;i<SIZE;i++) temp_b[i] = b.num[i];\n    for(int i=0;i<SIZE-1;i++){\n        res += factorial(SIZE-1-i)*temp_b[i];\n        for(int j=i+1;j<SIZE-1;j++){\n            if(temp_b[i]<temp_b[j]) temp_b[j]--;\n        }\n    }\n   return res;\n}\n\nBoard decode(int encoded){\n    Board b;\n    int tmp[SIZE];\n    for(int i=0;i<SIZE-1;i++){\n        int fact = factorial(SIZE-1-i);\n        tmp[i] = encoded/fact;\n        encoded %= fact;\n    }\n    tmp[SIZE-1] = 0;\n    int tmp2[SIZE];\n    bool check[SIZE];\n    for(int i=0;i<SIZE;i++){\n        tmp2[i] = i;\n        check[i] = false;\n    }\n    for(int i=0;i<SIZE;i++){\n        int j=0;\n        while(tmp[i]!=tmp2[j] || check[j]) j++;\n        b.num[i] = j;\n        check[j] = true;\n        while(j<SIZE){\n            tmp2[j]--;\n            j++;\n        }\n    }\n\n    return b;\n}\n\nint get_adjacent(int now, int i){\n    // \"i\" represents the direction of zero movement.0 up, 1 down, 2 left, 3 right\n    Board b = decode(now);\n    int zero=0;\n    while(b.num[zero]!=0) zero++;\n    if(i==0){\n        if(zero<3) return -1;\n        swap(b.num[zero], b.num[zero-3]);\n    }\n    if(i==1){\n        if(zero>5) return -1;\n        swap(b.num[zero], b.num[zero+3]);\n    }\n    if(i==2){\n        if(zero%3<1) return -1;\n        swap(b.num[zero], b.num[zero-1]);\n    }\n    if(i==3){\n        if(zero%3>1) return -1;\n        swap(b.num[zero], b.num[zero+1]);\n    }\n    return encode(b);\n}\n\nint heuristic_func(int enc1, int enc2){\n    Board b1 = decode(enc1);\n    int zero1 = 0;\n    while(zero1!=0) zero1++;\n    Board b2 = decode(enc2);\n    int zero2 = 0;\n    while(zero2!=0) zero2++;\n    return abs(zero1/3 - zero2/3) + abs(zero1%3 - zero2%3);\n}\n\nint main(){\n    Board b;\n    for (int i=0;i<SIZE;i++){\n        cin >> b.num[i];\n    }\n    for(int i=0;i<CODE_MAX;i++){\n        visited[i] = -1;\n    }\n\n    const int start = encode(b);\n    const int goal = 46233;\n    priority_queue<pii, vector<pii>, greater<pii> > que;\n    que.push(make_pair(heuristic_func(start, goal), start));\n    visited[start] = 0;\n    while(visited[goal]==-1){\n        pii x = que.top();\n        que.pop();\n        int now = x.second;\n        for(int i=0;i<4;i++){\n            int adj = get_adjacent(now, i);\n            if(adj==-1 || visited[adj]!=-1) continue;\n            visited[adj] = visited[now]+1;\n            que.push(make_pair(heuristic_func(adj, goal) + visited[adj], adj));\n        }\n    }\n    cout << visited[goal] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\n\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint calc(const vec& v){\n  int res=0;\n  for(int i=0;i<9;i++){\n    if(v[i]==0)continue;\n    int id=v[i]-1;\n    res+= abs(id/3 - i/3) + abs(id%3 - i%3);\n  }\n  return res;\n}\n\nint main(){\n  vec A(9);\n  for(int i=0;i<9;i++)cin>>A[i];\n\n  queue< vec > Q;\n  map< vec , int > d;\n  d[A]=0;\n  Q.push(A);\n  while(!Q.empty()){\n    vec p=Q.front();\n    Q.pop();\n    \n    if( calc(p)==0){\n      cout<<d[p]<<endl;\n      break;\n    }\n    \n    int py=0,px=0;\n    for(int i=0;i<9;i++){\n      if(p[i]==0){\n        py=i/3;\n        px=i%3;\n        break;\n      }\n    }\n\n    for(int i=0;i<4;i++){\n      int ny=py+dy[i];\n      int nx=px+dx[i];\n      if(ny<0 || ny>=3 || nx<0 || nx>=3)continue;\n      vec np=p;\n      swap( np[ny*3+nx] , np[py*3+px] );\n      if( d.count(np) == 0 ){\n        Q.push(np);\n        d[np]=d[p]+1;\n      }\n    }\n    \n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst int edge[4][3] = {{0, 3, 6}, {0, 1, 2}, {6, 7, 8}, {2, 5, 8}}; /* l, t, b, r */\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    int zero;\n    int original[9];\n    if(wrongs + moves > cutoff)\n        return -1;\n    REP(i, 9){\n        original[i] = tiles[i];\n        if(tiles[i] == 0){\n            zero = i;\n        }\n    }\n    bool dir[4] = {true, true, true, true};\n    REP(i, 4) REP(j, 3)\n        if (zero == edge[i][j])\n            dir[i] = false;\n    if(wrongs + moves >= cutoff)\n        return -1;\n    if(dir[0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[0])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[1])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[2])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[3])\n        REP(i, 9) tiles[i] = original[i];\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n    int start = check();\n\n    REP(i, 100){\n        move = dfs(0, start + i);\n        if(move > 0)\n            break;\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/////////////////////////////////////////////////////////\n//\n//  ~/Izumi_Chiharu/c/temp.cpp file\n//  Last Updated: 2018-06-17 ...Maybe\n//\n//    I hope you adding this code to the setting file\n//    alias g++='g++ -std=c++1y -DDEBUG_LOCAL'\n//\n//  My sweet heart Chiharu Izumi\n//\n/////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid print_Qbey(){cout<<\n\"           H                                           M#5J~d              \"  <<endl<<\n\"         Hm.?WMM                                   MMB^ .Z  d              \"  <<endl<<\n\"         MZS.` ?7WMM                             M#=`` (!`` d              \"  <<endl<<\n\"         HP?X,```  ?TMM                       MMY! ` .d: `` d              \"  <<endl<<\n\"         Hb;<U,`````` (TMM                 HM ^ ``` .V>_` `.W              \"  <<endl<<\n\"           ;><?n. `` ````?WHHMMHHHMMMMMM MMY```` ` (3<< `` .M              \"  <<endl<<\n\"         HN<>>>?W,`` `` ` (77!~`  ```~!?7'``` `` .d>>><``  .M              \"  <<endl<<\n\"          M2<>>>>?n.`` `` `` `` ``` `` ```` `` `.X>1++< `` (H              \"  <<endl<<\n\"          MK<>>>>+?S.``` `` ```` ``` ``` `` `` .Z``` ?4-.` jM              \"  <<endl<<\n\"           N2><+d=(Y^ `` `` ` ` ` ` `` `` `` `` T~.`````?=(dM              \"  <<endl<<\n\"           MR;JY~`~``` `` `` ``` ``` `` `` `` ``` u, `` `` 7M              \"  <<endl<<\n\"            NV!_`` `` `` ```` ``` `` `` `` ``` ``` C& ` ```` TMM           \"  <<endl<<\n\"           MY.(-`` ` `` ``  `` ` `` `` `` `` ``  `` (n ` ` ``` 7M          \"  <<endl<<\n\"         HMD-(D`` ``` `` ``` `` `` `` `` `` ` ``` ```(n ` `` `` (WM        \"  <<endl<<\n\"         M _(d```` `` ``` ``` ``` `` `` `` ``` ``` `` .b.`` `` ```?MH      \"  <<endl<<\n\"        MM!_(%` `` `` `` ` ` `` `` `` ``` `` `` ` `` ` (l`` ``````` TMH    \"  <<endl<<\n\"       H#>__d:`` .JXVS, ``` `` ` `` `` `.JXWH&.``` ```` O; `` ` ` `` -WM   \"  <<endl<<\n\"       M%.~(k ``.HXH[ dr ```` ``` `` `` dWWN- u. `` ``` ,M,``` ``` ``` ?MMM\"  <<endl<<\n\"      MF_~~($`` .WXMMWX$ ` ``` `` ``` ` dXM HHK````` `` ,HN-``````````.-=jg\"  <<endl<<\n\"MMMMHMY.~~~(R ``` 799Y!```` ``` `` `` `` ?UUUY!`` ````` (M N, `` ```.Z3J=``\"  <<endl<<\n\"gaJJdD.~~::_X|`````````````` `````` `` ` ``` ````` ``` .H  MN,``` .Yiv! ```\"  <<endl<<\n\"   MD_:~:~:~(T.`````````` ``` ` ` ````` ``` ``` ``````.M     N, .Ziv!`` ._~\"  <<endl<<\n\" MM'_:::::::~(N+.`````````` .`.(.` .` ``` ```` ```` .dM       NZ1v! .-_~~``\"  <<endl<<\n\" #:(::::::::~(HMNa..  ``````_?!`?7! `` ````  ...-(+7WMM     HM3(b _:<``..`.\"  <<endl<<\n\"=_;::::::::<(H    MMHaJ--_--........-.__~~~~(&v7<~``` ?MM   M>gM9h,_.......\"  <<endl<<\n\";;;;;;;:;::(drWM          HHmgggg&gzOtOzz<<~~~~~_`` ``` ?MMMH+ggM Mm-......\"  <<endl<<\n\"e<>>;>>;;><dMMJM                  Nc_~~~~~~~~~~_ ``  ` `` 7H&-...?THNe-_._(\"  <<endl<<\n\",4m+>>>>>>j MM(W                   N-~~~~~~~~:_`` ``` ` ``  ?7UHHqqHWHMm+__\"  <<endl<<\n\"vX+vT4k&&dMMD!+M                   MR_~~~~~:_````` ```` ````````` ````  ?We\"  <<endl<<\n\"???zTwiJ-(((JdM                    MK_~~~~:_``` ` ` ` `` ` ` ` ``` ```````?\"  <<endl<<\n\"1uukgHM                            MH_~~~_``` `` ``` `` `` `` ` `` ` `  ```\"  <<endl<<\n\"CugM                                N;~~:_ ` `` `` ``` `` ````` ``` ``` ` `\"  <<endl<<\n\"H                                   M[~~~_4, `   ` `` `` ``  ``` `` `` ``` \"  <<endl<<\n\"                                    Hb~~~~~?n  (: `` `` `` `` ` ` `` `` ```\"  <<endl<<\n\"                                    Hb~~~~~~(4,J_ `` ```  ```` ``` `` `` ` \"  <<endl<<\n\"                                     N-~~~~~~(MM_` `` ` (}  `` `` `` `` ```\"  <<endl<<\n\"                                     Mr_~~~~~(HH: `` `` j!`` `` `` `` `` ``\"  <<endl<<\n\"                                     Mb~~~~~~(WH:`` `` .Z `` `` `` ``` `` `\"  <<endl<<\n\"                                      N:~~~~~(WM{ `` ` .H+.. `` `  .``` `` \"  <<endl;}\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n//#define int long long\n\n#define _overload3(_1,_2,_3,name,...) name\n#define _REP(i,n) REAP(i,0,n)\n#define REAP(i,a,b) for(int i=int(a);i<int(b);++i)\n#define REP(...) _overload3(__VA_ARGS__,REAP,_REP,)(__VA_ARGS__)\n\n#define _REPR(i,n) REAPR(i,n,0)\n#define REAPR(i,a,b) for(int i=int(a-1);i>=int(b);--i)\n#define REPR(...) _overload3(__VA_ARGS__,REAPR,_REPR,)(__VA_ARGS__)\n\n#define ALL(a) a.begin(),a.end()\n#define rALL(a) a.rbegin(),a.rend()\n\n#define coutALL(a) {int loop_coutALL=0;for(auto e:a) cout<<(loop_coutALL++?\" \":\"\")<<e; cout<<endl;}\n#define coutYN(a) cout<<(a?\"Yes\":\"No\")<<endl;\n#define coutyn(a) cout<<(a?\"yes\":\"no\")<<endl;\n\n#define pcnt __builtin_popcount\n#define buli(x) __builtin_popcountll(x)\n\nconst int INF=1145141919;\nconst int MOD=(int)1e9+7;\nconst double EPS=1e-12;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const int dx[]={-1,-1,-1,0,1,1,1,0},dy[]={-1,0,1,1,1,0,-1,-1};\n\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\n\ntypedef pair<int,int> pii;\ntypedef pair<int,string> pis;\ntypedef pair<string,int> psi;\ntypedef pair<string,string> pss;\n\ntypedef long long ll;\n\ntemplate<class T> ll upper(T n,T m){return (n+m-1)/m;};\ntemplate<class T> ll rounding(T n){return (long double)n+0.5;};\n\ninline int qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a;a=1ll*a*a;}while(b>>=1);return ans;}\ninline int qp(int a,ll b,int mo){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}\n\nstruct Arithmetic{Arithmetic(){cin.tie(0);ios::sync_with_stdio(0);cout<<fixed<<setprecision(20);}};\n\n//#define DEBUG_LOCAL\n\n#ifdef DEBUG_LOCAL\ntemplate<typename T> void deb(T a){cerr<<\"deb: \"<<a<<\"ですねぇ！\"<<endl;}\n#define debl {cerr<<\"debug: \"<<__LINE__<<\"行目だよーんおほほ\"<<endl;}\nvoid what_cr(){cout<<__GCC_ATOMIC_CHAR16_T_LOCK_FREE<<\" ←なんだろーこの数字？\"<<endl;}\nvoid t_t(){cout\n    <<endl\n    <<\"------------------------\"<<endl\n    <<\"| Presented by         |\"<<\" Compiled \"<<__FILE__<<endl\n    <<\"| \"<<__DATE__<<\" \"<<__TIME__<<\" |\"<<endl\n    <<\"|        Chiharu Izumi |\"<<\"      to get the AC :)\"<<endl\n    <<\"------------------------\"<<endl;\n}\n#else\ntemplate<typename T>void deb(T a){}\n#define debl ;\nvoid what_cr(){}void t_t(){}\n#endif\n\nvvi pz0(3,vi(3,0));\nint ans=32;\nmap <vvi,int> tf;\n\nint find0(vvi pz){\n\n  REP(i,3) REP(j,3) if(pz[i][j]==0) return i*3+j;\n\n}\n\nvoid print(vvi pz){\n\n  REP(i,3){\n    REP(j,3){\n      if(j) cout<<\" \";\n      cout<<pz[i][j];\n    }\n    cout<<endl;\n  }\n\n}\n\nvoid bfs(vvi pz){\n\n  queue <pair<vvi,int>> pzq;\n  pzq.push(mp(pz,0));\n\n  for(;!pzq.empty();){\n\n    vvi now=pzq.front().fi;\n    int how=pzq.front().se;\n    pzq.pop();\n\n    if(how>31) continue;\n\n    if(tf[now]) continue;\n    tf[now]=1;\n\n    if(now==pz0){\n\n      ans=how;\n      return;\n\n    }\n\n    int x=find0(now)%3;\n    int y=find0(now)/3;\n\n    REP(i,4){\n\n    int x0=x+dx[i];\n    int y0=y+dy[i];\n\n    if(x0<0 || x0>2) continue;\n    if(y0<0 || y0>2) continue;\n\n    swap(now[y][x],now[y0][x0]);\n    pzq.push(mp(now,how+1));\n    swap(now[y][x],now[y0][x0]);\n\n    }\n\n  }\n\n}\n\nvoid dfs(vvi pz,int how){\n\n  if(tf[pz]) return;\n  tf[pz]=1;\n\n  if(how>31) return;\n  if(pz0==pz){\n\n    ans=min(ans,how);\n    return;\n\n  }\n\n  int x=find0(pz)%3;\n  int y=find0(pz)/3;\n\n  REP(i,4){\n\n    int x0=x+dx[i];\n    int y0=y+dy[i];\n\n    if(x0<0 || x0>2) continue;\n    if(y0<0 || y0>2) continue;\n\n    swap(pz[y][x],pz[y0][x0]);\n    dfs(pz,how+1);\n    swap(pz[y][x],pz[y0][x0]);\n\n  }\n\n}\n\nsigned main(){\n\n  Arithmetic Exception;\n\n  vvi pz(3,vi(3,0));\n\n  REP(i,9) pz0[i/3][i%3]=(i+1)%9;\n  REP(i,9) cin>>pz[i/3][i%3];\n\n  bfs(pz);\n\n  cout<<ans<<endl;\n\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nqueue<int>Q[3][3];\nqueue<int>R[3][3];\n\nint main() {\n\tint a, b, c, d, e, sum=0;\n\tint x[3][3];\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tcin >> a;\n\t\t\tQ[i][j].push(a);\n\t\t}\n\t}\n\twhile (true) {\n\t\twhile (!Q[0][0].empty()) {\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (Q[i][j].front() == 0) {\n\t\t\t\t\t\tb = i;\n\t\t\t\t\t\tc = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tx[i][j] = Q[i][j].front();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[0][0] == 1 && x[0][1] == 2 && x[0][2] == 3 && x[1][0] == 4 && x[1][1] == 5 && x[1][2] == 6 && x[2][0] == 7 && x[2][1] == 8) {\n\t\t\t\tgoto owata;\n\t\t\t}\n\t\t\tif (b >= 1) {\n\t\t\t\td = x[b][c];\n\t\t\t\te = x[b - 1][c];\n\t\t\t\tx[b][c] = e;\n\t\t\t\tx[b - 1][c] = d;\n\t\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tR[i][j].push(x[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (b <= 1) {\n\t\t\t\td = x[b][c];\n\t\t\t\te = x[b + 1][c];\n\t\t\t\tx[b][c] = e;\n\t\t\t\tx[b + 1][c] = d;\n\t\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tR[i][j].push(x[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c >= 1) {\n\t\t\t\td = x[b][c];\n\t\t\t\te = x[b][c - 1];\n\t\t\t\tx[b][c] = e;\n\t\t\t\tx[b][c - 1] = d;\n\t\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tR[i][j].push(x[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c <= 1) {\n\t\t\t\td = x[b][c];\n\t\t\t\te = x[b][c + 1];\n\t\t\t\tx[b][c] = e;\n\t\t\t\tx[b][c + 1] = d;\n\t\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tR[i][j].push(x[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tQ[i][j].pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!R[0][0].empty()) {\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tQ[i][j].push(R[i][j].front());\n\t\t\t\t\tR[i][j].pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsum++;\n\t}\nowata:;\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nclass puzzle8 {\npublic:\n\tint** field;\n\tint cost;\n\tint guess;\n\tint row_0, column_0;\n\tpuzzle8();\n\tpuzzle8(puzzle8*);\n\tvoid calc_guess();\n\tvoid slide_up();\n\tvoid slide_down();\n\tvoid slide_left();\n\tvoid slide_right();\n};\n\n\n\npuzzle8::puzzle8() {\n\tfield = new int* [3];\n\tfor (int i = 0;i < 3;i++) {\n\t\tfield[i] = new int[3];\n\t}\n\tcolumn_0 = row_0 = 0;\n\tcost = guess = 0;\n}\npuzzle8::puzzle8(puzzle8* a) {\n\tfield = new int* [3];\n\tfor (int i = 0;i < 3;i++) {\n\t\tfield[i] = new int[3];\n\t\tfor (int j = 0;j < 3;j++) {\n\t\t\tfield[i][j] = a->field[i][j];\n\n\t\t}\n\t}\n\tcost = a->cost;\n\tguess = a->guess;\n\trow_0 = a->row_0;\n\tcolumn_0 = a->column_0;\n}\nvoid puzzle8::calc_guess() {\n\tguess = 0;\n\tfor (int i = 0;i < 3;i++) {\n\t\tfor (int j = 0;j < 3;j++) {\n\t\t\tif (field[i][j] != 8) {\n\t\t\t\tguess += abs(i - field[i][j] / 3) + abs(j - field[i][j] % 3);\n\t\t\t}\t\n\t\t}\n\t}\n}\nvoid puzzle8::slide_up() {\n\tswap(field[row_0][column_0], field[row_0 - 1][column_0]);\n\tguess += abs(field[row_0][column_0] / 3 - row_0) - abs(field[row_0][column_0] / 3 - row_0 + 1);\n\trow_0--;\n\tcost++;\n}\nvoid puzzle8::slide_down() {\n\tswap(field[row_0][column_0], field[row_0 + 1][column_0]);\n\tguess += abs(field[row_0][column_0] / 3 - row_0) - abs(field[row_0][column_0] / 3 - row_0 - 1);\n\trow_0++;\n\tcost++;\n}\nvoid puzzle8::slide_left() {\n\tswap(field[row_0][column_0], field[row_0][column_0 - 1]);\n\tguess += abs(field[row_0][column_0] % 3 - column_0) - abs(field[row_0][column_0] % 3 - column_0 + 1);\n\tcolumn_0--;\n\tcost++;\n}\nvoid puzzle8::slide_right() {\n\tswap(field[row_0][column_0], field[row_0][column_0 + 1]);\n\tguess += abs(field[row_0][column_0] % 3 - column_0) - abs(field[row_0][column_0] % 3 - column_0 - 1);\n\tcolumn_0++;\n\tcost++;\n}\n\nint btoi(puzzle8* a) {\n\tint sum = 0;\n\tfor (int i = 0;i < 9;i++) {\n\t\tsum += pow(9, i) * a->field[i / 3][i % 3];\n\t}\n\treturn sum;\n}\n\ninline bool operator>(puzzle8 a, puzzle8 b) {\n\treturn a.cost + a.guess > b.cost + b.guess;\n}\ninline bool operator>=(puzzle8 a, puzzle8 b) {\n\treturn a.cost + a.guess >= b.cost + b.guess;\n}\ninline bool operator<(puzzle8 a, puzzle8 b) {\n\treturn a.cost + a.guess < b.cost + b.guess;\n}\ninline bool operator<=(puzzle8 a, puzzle8 b) {\n\treturn a.cost + a.guess <= b.cost + b.guess;\n}\n\nint main() {\n\tpuzzle8 p,new_puzzle;\n\t\n\tpriority_queue<puzzle8,vector<puzzle8>,greater<puzzle8>> pq;\n\tvector<int> appeared;\n\tint tmp;\n\tfor (int i = 0;i < 3;i++) {\n\t\tfor (int j = 0;j < 3;j++) {\n\t\t\tcin >> p.field[i][j];\n\t\t\tif (p.field[i][j] == 0) {\n\t\t\t\tp.field[i][j] = 8;\n\t\t\t\tp.row_0 = i;\n\t\t\t\tp.column_0 = j;\n\t\t\t}\n\t\t\telse p.field[i][j]--;\n\t\t}\n\t}\n\tp.cost = 0;\n\tp.calc_guess();\n\tappeared.push_back(btoi(&p));\n\twhile (p.guess != 0) {\n\t\tif (p.row_0 != 0) {\n\t\t\tnew_puzzle = new puzzle8(&p);\n\t\t\tnew_puzzle.slide_up();\n\t\t\ttmp = btoi(&new_puzzle);\n\t\t\tif (find(appeared.begin(), appeared.end(), tmp) == appeared.end()) {\n\t\t\t\tpq.push(new_puzzle);\n\t\t\t\tappeared.push_back(tmp);\n\t\t\t}\t\n\t\t}\n\t\tif (p.row_0 != 2) {\n\t\t\tnew_puzzle = new puzzle8(&p);\n\t\t\tnew_puzzle.slide_down();\n\t\t\ttmp = btoi(&new_puzzle);\n\t\t\tif (find(appeared.begin(), appeared.end(), tmp) == appeared.end()) {\n\t\t\t\tpq.push(new_puzzle);\n\t\t\t\tappeared.push_back(tmp);\n\t\t\t}\n\t\t}\n\t\tif (p.column_0 != 0) {\n\t\t\tnew_puzzle = new puzzle8(&p);\n\t\t\tnew_puzzle.slide_left();\n\t\t\ttmp = btoi(&new_puzzle);\n\t\t\tif (find(appeared.begin(), appeared.end(), tmp) == appeared.end()) {\n\t\t\t\tpq.push(new_puzzle);\n\t\t\t\tappeared.push_back(tmp);\n\t\t\t}\n\t\t}\n\t\tif (p.column_0 != 2) {\n\t\t\tnew_puzzle = new puzzle8(&p);\n\t\t\tnew_puzzle.slide_right();\n\t\t\ttmp = btoi(&new_puzzle);\n\t\t\tif (find(appeared.begin(), appeared.end(), tmp) == appeared.end()) {\n\t\t\t\tpq.push(new_puzzle);\n\t\t\t\tappeared.push_back(tmp);\n\t\t\t}\n\t\t}\n\t\tp = pq.top();\n\t\tpq.pop();\n\t}\n\tcout << p.cost << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <string>\n#include <utility>\n\nusing namespace std;\n\n#define N (3)\n#define N2 (N*N)\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator < ( const Puzzle &p ) const {\n\tfor ( int i = 0; i < N2; i++ ) {\n\t    if ( f[i] == p.f[i] ) continue;\n\t    return ( f[i] < p.f[i] );\n\t}\n\treturn false;\t\t// ????????????????????´???????????\\????????????\n    }\n};\n\n// x, y?????????????????£??????\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget( Puzzle p ) {\n    for ( int i = 0; i < N2; i++ ) {\n\tif ( p.f[i] != ( i + 1 ) ) return false;\n    }\n    return true;\n}\n\nstring bfs( Puzzle s ) {\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push( s );\n    V[s] = true;\n    \n    while ( !Q.empty() ) {\n\tu = Q.front(); Q.pop();\n\tif ( isTarget( u ) ) return u.path;\n\tint sx = u.space / N;\n\tint sy = u.space % N;\n\t\n\tfor ( int r = 0; r < 4; r++ ) {\n\t    int tx = sx + dx[r];\n\t    int ty = sy + dy[r];\n\n\t    if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n\t    v = u;\n\t    swap( v.f[u.space], v.f[tx * N + ty] );\n\t    v.space = tx * N + ty;\n\t    if ( !V[v] ) {\n\t\tV[v] = true;\n\t\tv.path += dir[r];\n\t\tQ.push( v );\n\t    }\n\t}\n    }\n\n    return \"unsolvable\";\n}\n\nint main()\n{\n    Puzzle in;\n    \n    for ( int i = 0; i < N2; i++ ) {\n\tscanf(\"%d\", &in.f[i]);\n\tif ( in.f[i] == 0 ) {\n\t    in.f[i] = N2;\n\t    in.space = i;\n\t}\n    }\n    string ans = bfs( in );\n\n    printf(\"%d\\n\", (int)ans.size());\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_13_B\n// Heuristic Search - 8 Puzzle\n// status:\n// tag: [bfs]\n\n#define SUBMIT\n\n#include <utility>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <sstream>\n#include <map>\n\nusing namespace std;\nusing ui64 = unsigned long long;\nusing i64 = long long;\n\nconst int N = 3;\nconst int N2 = 9;\n\nstruct puzzle {\n    int p[N2];\n    string path;\n    int space;\n\n    bool is_complete() {\n        // complete pattern is:\n        // 1 2 3\n        // 4 5 6\n        // 7 8 9\n        for (int i = 0; i < N2; ++i) {\n            if (p[i] != i + 1) return false;\n        }\n\n        return true;\n    }\n\n    bool operator<(const puzzle& other) const {\n        for (int i = 0; i < N2; ++i) {\n            if (p[i] == other.p[i]) continue;\n            return other.p[i] < p[i];\n        }\n\n        // equal\n        return false;\n    }\n};\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst char direction[] = {'l', 'd', 'r', 'u'};\n\nint to_index(int x, int y) { return y * N + x; }\nint to_x(int index) { return index % N; }\nint to_y(int index) { return index / N; }\n\nqueue<puzzle> pq;\n\nstring bfs() {\n    map<puzzle, bool> puzzle_memory;\n\n    while (!pq.empty()) {\n        auto curr_puzzle = pq.front();\n        pq.pop();\n\n        int curr_x = to_x(curr_puzzle.space), curr_y = to_y(curr_puzzle.space);\n        for (int r = 0; r < 4; ++r) {\n            int next_x = curr_x + dx[r], next_y = curr_y + dy[r];\n            if (next_x < 0 || N <= next_x || next_y < 0 || N <= next_y) continue;\n\n            auto next_puzzle = curr_puzzle;\n            next_puzzle.space = to_index(next_x, next_y);\n            swap(next_puzzle.p[curr_puzzle.space], next_puzzle.p[next_puzzle.space]);\n            // 既に出現した盤面ならcontinue\n            if (puzzle_memory[next_puzzle]) continue;\n\n            next_puzzle.path += direction[r];\n            if (next_puzzle.is_complete()) return next_puzzle.path;\n\n            puzzle_memory[next_puzzle] = true;\n            pq.push(next_puzzle);\n        }\n    }\n\n    // fail\n    return \"\";\n}\n\nint main() {\n#ifdef SUBMIT\n    auto& stream = cin;\n#else\n    string program_input_str = R\"(1 3 0\n4 2 5\n7 8 6\n)\";\n    stringstream stream(program_input_str);\n#endif\n    puzzle start_puzzle;\n    start_puzzle.path = \"\";\n\n    int value;\n    for (int y = 0; y < N; ++y) {\n        for (int x = 0; x < N; ++x) {\n            auto index = to_index(x, y);\n            stream >> value;\n            start_puzzle.p[index] = value;\n            if (value == 0) {\n                start_puzzle.p[index] = N2;\n                start_puzzle.space = index;\n            }\n        }\n    }\n\n    pq.push(start_puzzle);\n    auto ans = bfs();\n    cout << ans.size() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\nint factorial[9];\nint state[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}}, target, ans;\nqueue<int> id_que, layer_que;\nbool inque[362900];\n\nint cantor(int *map){\n    int rank = 0;\n    for(int i=0; i<9; i++){\n        int n_smaller = 0;\n        for(int j=i+1; j<9; j++)\n            if(map[i]>map[j])\n                n_smaller += 1;\n        rank += n_smaller * factorial[8-i];\n    }\n    return rank;\n}\n\nvoid inv_cantor(int rank, int *map){\n    bool used[9];\n    memset(used, 0, sizeof(used));\n    for(int i=0; i<9; i++){\n        int n_smaller = rank / factorial[8-i], cnt=0;\n        rank -= n_smaller*factorial[8-i];\n        for(int j=0; j<9; j++){\n            if(used[j]) continue;\n            if(cnt==n_smaller){\n                *(map+i) = j;\n                used[j] = true;\n                break;\n            }else \n                ++cnt;\n        }\n    }\n}\n\nbool check(int pos){\n    return pos >= 0 && pos < 3;\n}\n\nint main(){\n    factorial[0] = 1;\n    for(int i=1; i<9; i++)\n        factorial[i] = i * factorial[i-1];\n    target = cantor(state[0]);\n\n    \n    for(int i=0; i<9; i++)\n        scanf(\"%d\", state[0]+i);\n    memset(inque, 0, sizeof(inque));\n    id_que.push(cantor(state[0]));\n    layer_que.push(0);\n    inque[id_que.front()] == true;\n\n    if(id_que.front()==target)\n        printf(\"0\\n\");\n    else{\n        int head, tail, layer, zx, zy, nx, ny;\n        bool found=false;\n        while(!id_que.empty()){\n            head = id_que.front();\n            layer = layer_que.front();\n            id_que.pop();\n            layer_que.pop();\n            inv_cantor(head, state[0]);\n\n            //find the position of zero\n            for(int i=0; i<9; i++){\n                if(*(state[0]+i)==0){\n                    zx = i / 3;\n                    zy = i % 3;\n                    break;\n                }\n            }\n\n            //iterator the posible positions\n            for(int dir=0; dir<4; dir++){\n                nx = zx + dx[dir];\n                ny = zy + dy[dir];\n                if(check(nx) && check(ny)){\n                    state[zx][zy] = state[nx][ny];\n                    state[nx][ny] = 0;\n                    tail = cantor(state[0]);\n                    //printf(\"%d\\n\", tail);\n                    if(tail==target){\n                        found = true;\n                        ans = layer + 1;\n                        break;\n                    }else if(!inque[tail]){\n                        inque[tail] = true;;\n                        id_que.push(tail);\n                        layer_que.push(layer + 1);\n                    }\n                    state[nx][ny] = state[zx][zy];\n                    state[zx][zy] = 0;\n                }\n            }\n\n            if(found){\n                printf(\"%d\\n\", ans);\n                break;\n            }\n        }\n    }\n    \n    return 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<map>\n#include<string.h>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint n;\nint mp[10][10];\nint nextt[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\ntypedef struct note\n{\n    int a[5][5];\n    int x,y,s;\n}eight;\nqueue<eight>Q;\nint hash(eight x)\n{\n    int sum=0;\n    for(int i=0;i<3;i++)\n    {\n        for(int j=0;j<3;j++)\n        {\n            sum=sum*10+x.a[i][j];\n        }\n    }\n    return sum;\n}\nvoid bfs()\n{\n    map<int,bool>flag;\n    eight now,temp;\n    now=Q.front();\n    now.s=0;\n    int index=hash(now);\n    flag[index]=1;\n    while(!Q.empty())\n    {\n        now=Q.front();\n        //printf(\"%d\\n\",hash(now));\n        if(hash(now)==123456780)\n        {\n            printf(\"%d\\n\",now.s);\n            return ;\n        }\n        Q.pop();\n        for(int i=0;i<4;i++)\n        {\n            int tx=now.x+nextt[i][0];\n            int ty=now.y+nextt[i][1];\n            temp=now;\n            if(tx<0||ty<0||tx>=3||ty>=3)continue;\n            temp.a[now.x][now.y]=temp.a[tx][ty];\n            temp.a[tx][ty]=0;\n            index=hash(temp);\n            if(flag[index]==0)\n            {\n                flag[index]=1;\n                temp.x=tx;\n                temp.y=ty;\n                temp.s=now.s+1;\n                Q.push(temp);\n            }\n        }\n    }\n}\nint main()\n{\n    eight now;\n    while(!Q.empty())\n        Q.pop();\n    for(int i=0;i<3;i++)\n    {\n        for(int j=0;j<3;j++)\n        {\n            scanf(\"%d\",&mp[i][j]);\n            if(mp[i][j]==0)\n            {\n                now.x=i;\n                now.y=j;\n                now.a[i][j]=0;\n                now.s=0;\n            }\n            else\n                now.a[i][j]=mp[i][j];\n        }\n    }\n    Q.push(now);\n    bfs();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) (a)>(b)?(b):(a)\n#define max(a,b) (a)>(b)?(a):(b)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nstruct State\n{\n\tint puzzle[9];\n\tint depth;\n\tint evaluation;\n\n\tbool operator<(const State& s)const\n\t{\n\t\treturn evaluation < s.evaluation;\n\t}\n\n\tbool operator>(const State& s)const\n\t{\n\t\treturn evaluation > s.evaluation;\n\t}\n\n\tbool operator==(const State& s)const\n\t{\n\t\tfor (int i = 0; i < 9; i++)\n\t\t{\n\t\t\tif (puzzle[i] != s.puzzle[i])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n};\n\nState goal;\n//vector<State> checkedState;\n\nint heuristic(State s)\n{\n\tint eva = 0;\n\tint pos1[9], pos2[9];\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tpos1[s.puzzle[i]] = i;\n\t\tpos2[goal.puzzle[i]] = i;\n\t}\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tint manhattan = 0;\n\t\tmanhattan += abs(pos1[i] / 3 - pos2[i] / 3);\n\t\tmanhattan += abs(pos1[i] % 3 - pos2[i] % 3);\n\t\teva += manhattan;\n\t}\n\treturn eva;\n}\n\nint solve(State start)\n{\n\tpriority_queue<State, vector<State>, greater<State>> pq;\n\n\tpq.push(start);\n\n\twhile (!pq.empty())\n\t{\n\t\tState ts = pq.top();\n\t\tpq.pop();\n\n\t\t//checkedState.push_back(ts);\n\n\t\tif (ts == goal)\n\t\t{\n\t\t\treturn ts.depth;\n\t\t}\n\n\t\tint zeroi = -1;\n\t\tfor (int i = 0; i < 9; i++)\n\t\t{\n\t\t\tif (ts.puzzle[i] == 0)\n\t\t\t{\n\t\t\t\tzeroi = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (zeroi <= 5)\n\t\t{\n\t\t\tState tts = ts;\n\t\t\tint t = tts.puzzle[zeroi];\n\t\t\ttts.puzzle[zeroi] = tts.puzzle[zeroi + 3];\n\t\t\ttts.puzzle[zeroi + 3] = t;\n\t\t\ttts.depth++;\n\t\t\ttts.evaluation = heuristic(tts) + tts.depth;\n\t\t\tpq.push(tts);\n\t\t}\n\t\tif (zeroi % 3 != 2)\n\t\t{\n\t\t\tState tts = ts;\n\t\t\tint t = tts.puzzle[zeroi];\n\t\t\ttts.puzzle[zeroi] = tts.puzzle[zeroi + 1];\n\t\t\ttts.puzzle[zeroi + 1] = t;\n\t\t\ttts.depth++;\n\t\t\ttts.evaluation = heuristic(tts) + tts.depth;\n\t\t\tpq.push(tts);\n\t\t}\n\t\tif (zeroi % 3 != 0)\n\t\t{\n\t\t\tState tts = ts;\n\t\t\tint t = tts.puzzle[zeroi];\n\t\t\ttts.puzzle[zeroi] = tts.puzzle[zeroi - 1];\n\t\t\ttts.puzzle[zeroi - 1] = t;\n\t\t\ttts.depth++;\n\t\t\ttts.evaluation = heuristic(tts) + tts.depth;\n\t\t\tpq.push(tts);\n\t\t}\n\t\tif (3 <= zeroi)\n\t\t{\n\t\t\tState tts = ts;\n\t\t\tint t = tts.puzzle[zeroi];\n\t\t\ttts.puzzle[zeroi] = tts.puzzle[zeroi - 3];\n\t\t\ttts.puzzle[zeroi - 3] = t;\n\t\t\ttts.depth++;\n\t\t\ttts.evaluation = heuristic(tts) + tts.depth;\n\t\t\tpq.push(tts);\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tState start;\n\n\tgoal.depth = 0;\n\tgoal.evaluation = 0;\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tgoal.puzzle[i] = (i + 1) % 9;\n\t}\n\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\n\t\tstart.puzzle[i] = n;\n\t}\n\n\tstart.depth = 0;\n\tstart.evaluation = 0;\n\n\tprintf(\"%d\\n\", solve(start));\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define N 3\n#define M 9\n\nstruct Puzz{\n  int f[M];\n  int space;\n  string path;\n\n  bool operator < (const Puzz &p) const {\n    for(int i=0;i<M;i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1 ,0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dirc[4] = {'u','l','d','t'};\n\nbool Tage(Puzz p){\n  for(int i=0;i<M;i++)\n  if(p.f[i] != (i+1)) return false;\n  return true;\n}\n\nstring afs(Puzz m){\n  queue<Puzz> Q;\n  map<Puzz, bool> V;\n  Puzz u,v;\n  m.path=\"\";\n  Q.push(m);\n  V[m]=true;\n\n\n  while(!Q.empty()){\n    u=Q.front(); Q.pop();\n\n    if(Tage(u)) return u.path;\n    int mx=u.space/N;\n    int my=u.space%N;\n\n    for(int i=0;i<4;i++){\n      int px=mx+dx[i];\n      int py=my+dy[i];\n      if(px<0 || py<0 || px>=N || py>=N) continue;\n      v=u;\n      swap(v.f[u.space],v.f[px*N+py]);\n      v.space=px*N+py;\n\n      if(!V[v]){\n        V[v]=true;\n        v.path+=dirc[i];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzz ln;\n\n  for(int i=0;i<M;i++){\n    cin >> ln.f[i];\n    if(ln.f[i] ==0){\n      ln.f[i]=M;\n      ln.space =i;\n    }\n  }\n  string answer = afs(ln);\n  cout << answer.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst int edge[4][3] = {{0, 3, 6}, {0, 1, 2}, {6, 7, 8}, {2, 5, 8}}; /* l, t, b, r */\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    if(check() == 0)\n        return moves;\n    int zero;\n    int original[9];\n    if(check() + moves > cutoff)\n        return -1;\n    REP(i, 9){\n        original[i] = tiles[i];\n        if(tiles[i] == 0){\n            zero = i;\n        }\n    }\n    bool dir[4] = {true, true, true, true};\n    REP(i, 4) REP(j, 3)\n        if (zero == edge[i][j])\n            dir[i] = false;\n    if(dir[0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    REP(i, 9) tiles[i] = original[i];\n    if(dir[1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    REP(i, 9) tiles[i] = original[i];\n    if(dir[2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    REP(i, 9) tiles[i] = original[i];\n    if(dir[3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    REP(i, 9) tiles[i] = original[i];\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n\n    REP(i, 100){\n        move = dfs(0, check() + i);\n        if(move > 0)\n            break;\n    }\n\n\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}};\nvector<int> tiles(9);\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    if(wrongs + moves >= cutoff)\n        return -1;\n    int zero;\n    REP(i, 9){\n        if(tiles[i] == 0){\n            zero = i;\n            break;\n        }\n    }\n    if(dir[zero][0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-1]);\n    }\n    if(dir[zero][1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero-3]);\n    }\n    if(dir[zero][2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+3]);\n    }\n    if(dir[zero][3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n        swap(tiles[zero], tiles[zero+1]);\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n\n    REP(i, 50){\n        move = dfs(0, i);\n        if(move > 0){\n            break;\n        }\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <array>\n#include <set>\n#include <queue>\nusing namespace std;\n\n#define si static inline\n#define gcu getchar_unlocked\nsi int in() {\n\tint n = 0, c = gcu();\n\t// bool minus = false; if (c == '-') minus = true, c = gcu();\n\tdo {n = 10 * n + (c - '0'), c = gcu();} while (c >= '0');\n\treturn n; }\n\t// return minus ? -n : n; }\nsi void scan(char *s) {while (!isspace(*s++ = gcu()));}\n#define pcu putchar_unlocked\n#define svo si void out\ntemplate <typename T>\nsvo(T n) {\n\tstatic char buf[20];\n\tchar *p = buf;\n\t//if(n < 0) pcu('-'), n *= -1;\n\tif (!n) *p++ = '0';\n\telse while (n) *p++ = n % 10 + '0', n /= 10;\n\twhile (p != buf) pcu(*--p); }\nsvo(const char *s){while(*s)pcu(*s++);}\nsvo(char *s){while(*s)pcu(*s++);}\nsvo(char c){pcu(c);}\n//template <typename T>\n//svo(vector<T> &v){for(T &x:v)out(' '),out(x);out('\\n');}\n//svo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);out('\\n');}\ntemplate <typename head, typename... tail>\nsvo(head&& h, tail&&... t){out(h);out(move(t)...);}\n#undef svo\n#undef si\n\nstruct board {\n\tenum {size = 3};\n\tstruct pos {int r, c;};\n\ttypedef array<array<int, size>, size> arr;\n\tarr b;\n\tpos p;\n\tint max;\n\tint cnt = 0;\n\n\tint f(arr &a) {\n\t\tint l = 0;\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tint c = a[i][j];\n\t\t\t\tif (c == 0)\n\t\t\t\t\tc = size * size - 1;\n\t\t\t\telse\n\t\t\t\t\tc--;\n\t\t\t\tl += abs(i - c / 3) + abs(j - c % 3);\n\t\t\t}\n\t\treturn l;\n\t}\n\n\tvoid read() {\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tb[i][j] = in();\n\t\t\t\tif (!b[i][j])\n\t\t\t\t\tp.r = i, p.c = j;\n\t\t\t}\n\t\tmax = f(b);\n\t}\n\tvoid print() {\n\t\tfor (auto &r: b) {\n\t\t\tfor (int &c: r)\n\t\t\t\tout(&c == &r[0]?\"\":\" \", c);\n\t\t\tout('\\n');\n\t\t}\n\t\tout('\\n');\n\t}\n\n\n\tint solver() {\n\t\tset<arr> m;\n\t\tqueue<board> q;\n\t\tq.push(*this);\n\t\twhile (!q.empty()) {\n\t\t\tboard a = q.front();\n\t\t\tq.pop();\n//\t\t\ta.print();\n\t\t\tint dis = f(a.b);\n\t\t\tif (dis > max + 10 - a.cnt / 1.5)\n\t\t\t\tcontinue;\n//\t\t\tout(dis, \"\\n\");\n\t\t\tauto it = m.find(a.b);\n\t\t\tif (it != m.end())\n\t\t\t\tcontinue;\n\t\t\tm.insert(a.b);\n\t\t\tif (!dis)\n\t\t\t\treturn a.cnt;\n\t\t\tpos to[] = {\n\t\t\t\ta.p.r + 1, a.p.c,\n\t\t\t\ta.p.r, a.p.c + 1,\n\t\t\t\ta.p.r - 1, a.p.c,\n\t\t\t\ta.p.r, a.p.c - 1\n\t\t\t};\n\t\t\tfor (pos o: to) {\n\t\t\t\tif (0 <= o.r && o.r < size && 0 <= o.c && o.c < size) {\n\t\t\t\t\tboard c = a;\n\t\t\t\t\tswap(c.b[a.p.r][a.p.c], c.b[o.r][o.c]);\n\t\t\t\t\tc.p = o;\n\t\t\t\t\tc.cnt = a.cnt + 1;\n\t\t\t\t\tq.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\nint main() {\n\tboard b;\n\tb.read();\n\tout(b.solver(), '\\n');\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <vector>\n  \nusing namespace std;\n  \n#define RY 3\n#define N 9\n  \ntypedef struct board {\n  int O[N];\n  int ling;\n  vector<int> path;\n  \n  bool operator < (const board &t) const {\n    for (int i = 0; i < N; i++) {\n      if (O[i] == t.O[i]) continue;\n      else if (O[i] < t.O[i]) return true;\n      else return false;\n    }\n    return false;\n  }\n} cubic;\n \nint xx[4] = { 0, 1, 0, -1 };\nint yy[4] = { 1, 0, -1, 0 };\n  \nbool fingoal(cubic b) {\n  for (int i = 0; i < N-1; i ++)\n    if (b.O[i] != i+1) return false;\n  \n  return true;\n}\n  \nvoid meltd(cubic b) {\n  map<cubic, bool> visited;\n  queue<cubic> q;\n  q.push(b);\n  \n  while (!q.empty()) {\n    cubic bcur = q.front(); q.pop();\n    visited[bcur] = true;\n  \n    if (fingoal(bcur)) {\n      cout << bcur.path.size() << endl;\n      return;\n    }\n  \n    for (int i = 0; i < 4; i ++) {\n      cubic b = bcur;\n      int nx = (bcur.ling / RY) + xx[i];\n      int ny = (bcur.ling % RY) + yy[i];\n  \n      if (nx < 0 || nx > 2 || ny < 0 || ny > 2) continue;\n  \n      b.ling = nx * RY + ny;\n      swap(b.O[b.ling], b.O[bcur.ling]);\n  \n      if (visited[b]) continue;\n  \n      b.path.push_back(b.ling);\n      q.push(b);\n    }\n  }\n}\n  \nint main() {\n  cubic b;\n  \n  for (int i = 0; i < N; i++) {\n    cin >> b.O[i];\n    if (b.O[i] == 0) b.ling = i;\n  }\n  \n  meltd(b);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\n struct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const {\n    int i;\n    for(i=0;i<N2;i++) {\n      if(f[i]==p.f[i])continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const char dir[4] = {'u','l','d','r'};\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\n\nbool isTarget(Puzzle p) {\n  int i;\n  for(i=0;i<N2;i++)\n  if(p.f[i] != (i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s ) {\nqueue<Puzzle> Q;\nmap<Puzzle,bool> V;\nPuzzle u,v;\ns.path = \"\";\nQ.push(s);\nV[s] = true;\n\nwhile(!Q.empty()) {\n  u = Q.front();Q.pop();\n  if(isTarget(u)) return u.path;\n  int sx = u.space / N;\n  int sy = u.space % N;\n  for(int r = 0;r<4 ; r++) {\n    int tx = sx + dx[r];\n    int ty = sy + dy[r];\n    if(tx < 0 || ty < 0|| tx>=N || ty >= N) continue;\n    v = u;\n    swap(v.f[u.space], v.f[tx *N+ty]);\n    v.space = tx * N + ty;\n    if(!V[v]) {\n      V[v] = true;\n      v.path  += dir[r];\n      Q.push(v);\n    }\n  }\n}\nreturn \"unsolvable\";\n}\n\nint main() {\n  Puzzle in;\n\n  for(int i=0;i<N2;i++) {\n    cin >> in.f[i];\n    if(in.f[i]==0) {\n      in.space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size()<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#pragma warning(disable:4996)\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\tbool operator <(const Puzzle &p) const {\n\t\tfor (int i = 0; i < N2; ++i) {\n\t\t\tif (f[i] != p.f[i]) return f[i] < p.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nbool isComplete(Puzzle p) {\n\tfor (int i = 0; i < N2; ++i) {\n\t\tif (p.f[i] != i + 1) return false;\n\t}\n\treturn true;\n}\n\nconst int dx[4]{ -1, 0, 1, 0 };\nconst int dy[4]{ 0, -1, 0, 1 };\nconst char dir[4]{ 'u', 'l', 'd', 'r' };\n\nstring bfs(Puzzle p) {\n\tp.path = \"\";\n\tmap<Puzzle, bool> M;\n\tM[p] = true;\n\tPuzzle u, v;\n\tqueue<Puzzle> Q;\n\tQ.push(p);\n\tfor (int i = 0; i < N2; ++i) {\n\t\twhile (!Q.empty()) {\n\t\t\tu = Q.front();\n\t\t\tQ.pop();\n\t\t\tif (isComplete(u))\n\t\t\t\treturn u.path;\n\t\t\tint sx = u.space / N;\n\t\t\tint sy = u.space % N;\n\t\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\t\tint tx = sx + dx[r];\n\t\t\t\tint ty = sy + dy[r];\n\t\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\t\t\t\tv = u;\n\t\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\t\tv.space = tx * N + ty;\n\t\t\t\tif (!M[v]) {\n\t\t\t\t\tM[v] = true;\n\t\t\t\t\tv.path += dir[r];\n\t\t\t\t\tQ.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unresolved\";\n}\n\nint main() {\n\tPuzzle p;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tscanf(\"%d\", &p.f[i]);\n\t\tif (p.f[i] == 0) {\n\t\t\tp.f[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(p);\n\tcout << ans.size() << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define DIVN 3\n\nvoid swap(int &a, int &b);\nint fact(int a);\nint dist(int x);\nint abs(int x);\nvoid insert(vector<int> &A, int v);\nint extract(vector<int> &A);\nint PtoI(vector<int> p);\nvector<int> ItoP(int ii);\nint SolvePuzzle(vector<int> P);\n\nvector<int> Puzzles(fact(DIVN*DIVN), -1);\n\n\nvoid swap(int &a, int &b){\n\tint tmp = a;\n\ta = b;\n\tb = tmp;\n\treturn;\n}\n\nint fact(int a){\n\tint b = 1;\n\tfor (int i = 2; i <= a; i++){\n\t\tb = b * i;\n\t}\n\treturn b;\n}\n\nint dist(int x){\n\tstd::vector<int> P = ItoP(x);\n\tint result = 0;\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tresult += abs(P[i] % DIVN - (i + 1) % DIVN) + abs((P[i] == 0 ? DIVN - 1 : (P[i] - 1) / DIVN) / DIVN - i / DIVN);\n\t}\n\treturn -result - Puzzles[x] * 32768;\n}\n\nint abs(int x){\n\treturn x < 0 ? -x : x;\n}\n\nvoid insert(vector<int> &A, int v){\n\tint n = A.size();\n\tA.push_back(v);\n\twhile (n != 0){\n\t\tint i = (n - 1) / 2;\n\t\tif (dist(A[n]) > dist(A[i])){\n\t\t\tswap(A[n], A[i]);\n\t\t}\n\t\tn = i;\n\t}\n\treturn;\n}\n\nint extract(vector<int> &A){\n\tint n = A.size() - 1;\n\tint res = A[0];\n\tA[0] = A[n];\n\tA.pop_back();\n\n\tfor (int i = 0, j; 2 * i + 1 < n;){\n\t\tj = 2 * i + 1;\n\t\tif (j != n - 1 && dist(A[j]) < dist(A[j + 1])){\n\t\t\tj++;\n\t\t}\n\t\tif (dist(A[i]) < dist(A[j])){\n\t\t\tswap(A[i], A[j]);\n\t\t}\n\t\ti = j;\n\t}\n\treturn res;\n}\n\n\nint PtoI(vector<int> p){\n\tint x, result = 0;\n\tfor (int i = 0; i < DIVN*DIVN - 1; i++){\n\t\tfor (int j = 0; j < DIVN*DIVN - i; j++){\n\t\t\tif (p[j] == i){\n\t\t\t\tx = j;\n\t\t\t\tp.erase(p.begin() + j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult += x * fact(DIVN*DIVN - i - 1);\n\t}\n\treturn result;\n}\n\nvector<int> ItoP(int ii){\n\tvector<int> tmp, result(DIVN*DIVN, -1);\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tint index = ii / fact(DIVN*DIVN - i - 1);\n\t\tii = ii % fact(DIVN*DIVN - i - 1);\n\t\tint curindex = -1;\n\t\tint x = -1;\n\t\tfor (int j = 0; j < DIVN*DIVN; j++){\n\t\t\tif (result[j] == -1){\n\t\t\t\tcurindex++;\n\t\t\t}\n\t\t\tif (curindex == index) {\n\t\t\t\tx = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult[x] = i;\n\t}\n\treturn result;\n}\n\nint SolvePuzzle(vector<int> P){\n\tvector<int> Que;\n\tinsert(Que, PtoI(P));\n\tint answer;\n\tPuzzles[PtoI(P)] = 0;\n\twhile (!Que.empty()){\n\t\tvector<int> Q = ItoP(extract(Que));\n\t\tint Cursor;\n\t\tbool isAligned = true;\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] != (i + 1) % (DIVN*DIVN)){\n\t\t\t\tisAligned = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isAligned){\n\t\t\tanswer = Puzzles[PtoI(Q)];\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] == 0){\n\t\t\t\tCursor = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvector<int> Qnext;\n\t\tif (Cursor >= DIVN){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] < Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor < DIVN * (DIVN - 1)){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] < Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != 0){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] < Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != DIVN - 1){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] < Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn answer;\n}\n\nint main(){\n\tint k;\n\tvector<int> P;\n\tfor (int i = 0; i < DIVN * DIVN; i++){\n\t\tscanf(\"%d\", &k);\n\t\tP.push_back(k);\n\t}\n\tint n = SolvePuzzle(P);\n\n\tprintf(\"%d\\n\", n);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>]\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N (3)\n#define N2 (9)\n\nstruct Puzzle{\n    int f[N2];\n    int space;\n    string path;\n    \n    bool operator<(const Puzzle &p)const{\n        for(int i=0;i<N2;i++){\n            if(f[i]==p.f[i])continue;\n            return f[i]>p.f[i];\n        }\n        return false;\n    }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n    for(int i=0;i<N2;i++){\n        if(p.f[i]!=(i+1))return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u,v;\n    s.path=\"\";\n    Q.push(s);\n    V[s]=true;\n    \n    while(!Q.empty()){\n        u=Q.front();Q.pop();\n        if(isTarget(u))return u.path;\n        int sx=u.space/N;\n        int sy=u.space%N;\n        for(int r=0;r<4;r++){\n            int tx=sx+dx[r];\n            int ty=sy+dy[r];\n            if(tx<0||ty<0||tx>=N||ty>=N)continue;\n            v=u;\n            swap(v.f[u.space],v.f[tx*N+ty]);\n            v.space=tx*N+ty;\n            if(!V[v]){\n                V[v]=true;\n                v.path+=dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main(void){\n    Puzzle in;\n    for(int i=0;i<N2;i++){\n        cin>>in.f[i];\n        if(in.f[i]==0){\n            in.f[i]=N2;\n            in.space=i;\n        }\n    }\n    string ans=bfs(in);\n    cout<<ans.size()<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}};\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    if(wrongs + moves >= cutoff)\n        return -1;\n    int zero;\n    REP(i, 9){\n        if(tiles[i] == 0){\n            zero = i;\n            break;\n        }\n    }\n    if(dir[zero][0]){\n        swap(tiles[zero], tiles[zero-1]);\n        if(check() < wrongs){\n            int m = dfs(moves+1, cutoff);\n            if(m > 0)\n                return m;\n        }\n        swap(tiles[zero], tiles[zero-1]);\n    }\n    if(dir[zero][1]){\n        swap(tiles[zero], tiles[zero-3]);\n        if(check() < wrongs){\n            int m = dfs(moves+1, cutoff);\n            if(m > 0)\n                return m;\n        }\n        swap(tiles[zero], tiles[zero-3]);\n    }\n    if(dir[zero][2]){\n        swap(tiles[zero], tiles[zero+3]);\n        if(check() < wrongs){\n            int m = dfs(moves+1, cutoff);\n            if(m > 0)\n                return m;\n        }\n        swap(tiles[zero], tiles[zero+3]);\n    }\n    if(dir[zero][3]){\n        swap(tiles[zero], tiles[zero+1]);\n        if(check() < wrongs){\n            int m = dfs(moves+1, cutoff);\n            if(m > 0)\n                return m;\n        }\n        swap(tiles[zero], tiles[zero+1]);\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n    int start = check();\n\n    REP(i, 50){\n        move = dfs(0, start + i);\n        if(move > 0){\n            break;\n        }\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<cmath>\n#include<string>\n#include<cassert>\n\n#define N 3\n#define N2 9\n#define LIMIT 100\n\nusing namespace std;\n\nstatic const int dx[4] = {0, -1, 0, 1};\nstatic const int dy[4] = {1, 0, -1, 0};\nstatic const char dir[4] = {'r', 'u', 'l', 'd'};\nint MDT[N2][N2];\n\nstruct Puzzle {\n  int f[N2], space, MD;\n};\n\nPuzzle state;\nint limit;\nint path[LIMIT];\n\nint getAllMD(Puzzle pz){\n  int sum = 0;\n  for(int i=0; i<N2; i++){\n    if(pz.f[i] == N2) continue;\n    sum += MDT[i][pz.f[i]-1];\n  }\n  return sum;\n}\n\nbool isSolved(){\n  for(int i=0; i<N2; i++)\n    if(state.f[i] != i+1) return false;\n  return true;\n}\n\nbool dfs(int depth, int prev){\n  if(state.MD == 0) return true;\n\n  if(depth+state.MD > limit) return false;\n\n  int sx = state.space / N;\n  int sy = state.space % N;\n  Puzzle tmp;\n\n  for(int r=0; r<4; r++){\n    int tx = sx + dx[r];\n    int ty = sy + dy[r];\n    \n    if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n       if(max(prev, r)-min(prev, r) == 2) continue;\n       tmp = state;\n\n       state.MD -= MDT[tx*N+ty][state.f[tx*N+ty]-1];\n       state.MD += MDT[sx*N+sy][state.f[tx*N+ty]-1];\n       swap(state.f[tx*N+ty], state.f[sx*N+sy]);\n       state.space = tx*N+ty;\n       if(dfs(depth+1,r) ) {path[depth] = r; return true; }\n       state = tmp;\n  }       \n       \n    return false;\n  \n}    \n\n\nstring iterative_deepening(Puzzle in){\n  in.MD = getAllMD(in);\n\n  for(limit = in.MD; limit <= LIMIT; limit++){\n    state = in;\n    if(dfs(0, -100) ){\n      string ans = \"\";\n      for(int i = 0; i<limit; i++) ans += dir[path[i]];\n      return ans;\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main(){\n  for(int i=0; i<N2; i++)\n    for(int j=0; j<N2; j++)\n      MDT[i][j] = abs(i/N - j/N) + abs(i%N - j%N);\n\n  Puzzle in;\n\n  for(int i=0; i<N2; i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = iterative_deepening(in);\n  cout << ans.size() << endl;\n\n  return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n  bool operator<(const Puzzle &p) const{\n\tfor(int i=0;i<N2;i++){\n\t  if(f[i]==p.f[i]) continue;\n\t  return f[i]>p.f[i];\n\t}\n\treturn false;\n  }\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int i=0;i<N2;i++)\n\tif(p.f[i]!=(i+1)) return false;\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle,bool> V;\n  Puzzle u,v;\n  s.path=\"\";\n  Q.push(s);\n  V[s]=true;\n\n  while(!Q.empty()){\n\tu=Q.front(); Q.pop();\n\tif(isTarget(u)) return u.path;\n\tint sx = u.space /N;\n\tint sy =u.space %N;\n\tfor(int r=0;r<4;r++){\n\t  int tx=sx+dx[r];\n\t  int ty = sy+dy[r];\n\t  if(tx<0||ty<0||tx>=N||ty>=N) continue;\n\t  v=u;\n\t  swap(v.f[u.space],v.f[tx*N+ty]);\n\t  v.space=tx*N+ty;\n\t  if(!V[v]){\n\t\tV[v]=true;\n\t\tv.path+=dir[r];\n\t\tQ.push(v);\n\t  }\n\t}\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n  for(int i=0;i<N2;i++){\n\tcin>>in.f[i];\n\tif(in.f[i]==0){\n\t  in.f[i]=N2;\n\t  in.space=i;\n\t}\n  }\n  string ans = bfs(in);\n  cout <<ans.size()<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint getcost(int i, int j, int tmp)\n{\n    return abs(i - (tmp - 1) / 3) + abs(j - (tmp - 1) % 3);\n}\n\nbool solve(vector<vector<int> > puzzle, int cutoff, int cost)\n{\n    priority_queue<pair<int, vector<vector<int> > > > qu;\n    qu.push(make_pair(-cost, puzzle));\n    while(!qu.empty()){\n        vector<vector<int> > now = (qu.top()).second;\n        int nowcost = (qu.top()).first;\n        qu.pop();\n        int h = 0;\n        for(int i = 0; i < 3; i++){\n            for(int j = 0; j < 3; j++){\n                int tmp = now[i][j];\n                if(tmp != 0) h += getcost(i, j, tmp); \n            }\n        }\n        // cout << nowcost << endl;\n        if(h == 0){\n            return true;\n        }\n        for(int i = 0; i < 4; i++){\n            for(int j = 0; j < 4; j++){\n                // cout << now[i][j] << \" \";\n                if(now[i][j] == 0){\n                    int dx[4] = {0, 1, 0, -1};\n                    int dy[4] = {1, 0, -1, 0};\n                    for(int k = 0; k < 4; k++){\n                        int nx = i + dx[k];\n                        int ny = j + dy[k];\n                        if(nx < 0 || ny < 0 || nx >= 3 || ny >= 3) continue;\n                        int nowc = getcost(nx, ny, now[nx][ny]);\n                        int nextc = getcost(i, j, now[nx][ny]);\n                        // cout << now[nx][ny] << \" \" << nextc - nowc << endl;\n                        nowcost -= nextc - nowc + 1;\n                        swap(now[i][j], now[nx][ny]);\n                        if(-nowcost <= cutoff) qu.push(make_pair(nowcost, now));\n                        swap(now[i][j], now[nx][ny]);\n                        nowcost += nextc - nowc + 1;\n                    }\n                    i = 5;\n                    break;\n                }\n            }\n            // cout << endl;\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    vector<vector<int> > puzzle(3);\n    int cost = 0;\n    for(int i = 0; i < 3; i++){\n        for(int j = 0; j < 3; j++){\n            int tmp;\n            cin >> tmp;\n            puzzle[i].push_back(tmp);\n            if(tmp != 0) cost += getcost(i, j, tmp);\n        }\n    }\n    // cout << cost << endl;\n    for(int i = cost; ; i++){\n        if(solve(puzzle, i, cost)){\n            cout << i << endl;\n            break;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define rep(i,n) FOR(i,0,n)\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define vint vector<int>\n#define vdouble vector<double>\n#define vstring vector<string>\nusing namespace std;\n\n#include<map>\n#include<set>\n#include<queue>\n#include <sstream>\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int MAX_N = 1000000;\nconst int INFTY = (1 << 21); // 2097152\n// const ll INFTY = (1LL << 60);\nconst ll MD = 1000000007LL;\n\nstruct Board{\n\tvector<vint> v;\n\n\tBoard(vector<vint> v){\n\t\tthis->v = v;\n\t}\n\n\tvector<Board> transition(){\n\t\tvector<Board> ret;\n\n\t\tvint dx{1, 0, -1, 0};\n\t\tvint dy{0, 1, 0, -1};\n\n\t\tint x0 = 0, y0 = 0;\n\t\trep(y, 3) rep(x, 3){\n\t\t\tif(v[y][x] == 0) {x0 = x; y0 = y;}\n\t\t}\n\n\t\trep(d, 4){\n\t\t\tint xn = x0 + dx[d];\n\t\t\tint yn = y0 + dy[d];\n\t\t\tif(xn >= 0 && xn < 3 && yn >= 0 && yn < 3){\n\t\t\t\tvector<vint> vv = v;\n\t\t\t\tvv[yn][xn] = v[y0][x0];\n\t\t\t\tvv[y0][x0] = v[yn][xn];\n\t\t\t\tret.push_back(Board(vv));\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tll hash() const{\n\t\tll ret = 0;\n\t\tll m = 1;\n\t\trep(y, 3) rep(x, 3){\n\t\t\tret += v[y][x] * m;\n\t\t\tm *= 10;\n\t\t}\n        return ret;\n\t}\n\n\tbool operator < (const Board &p) const {\n        ll h1 = hash();\n        ll h2 = p.hash();\n\t\treturn h1 < h2;\n\t}\n\n\tbool operator == (const Board &p) const{\n        ll h1 = hash();\n        ll h2 = p.hash();\n        return h1 == h2;\n\t}\n};\n\nint main() {\n\tvector<vint> v0;\n\trep(y, 3){\n\t\tvint v;\n\t\trep(x, 3) { int n; cin >> n; v.push_back(n);}\n\t\tv0.push_back(v);\n\t}\n\tBoard b0 = Board(v0);\n\n\tvector<vint> ve;\n\tvint ve1{1, 2, 3}; ve.push_back(ve1);\n\tvint ve2{4, 5, 6}; ve.push_back(ve2);\n\tvint ve3{7, 8, 0}; ve.push_back(ve3);\n\tBoard be = Board(ve);\n\n\tset<Board> S;\n\tqueue<pair<Board, int>> q;\n\n\tq.push(make_pair(b0, 0));\n    // fprintf(stderr, \"%09lld\\n\", b0.hash());\n    // fprintf(stderr, \"%09lld\\n\", be.hash());\n\n\twhile(true){\n\t\tauto p = q.front(); q.pop();\n\t\tBoard b = p.first;\n\t\tint t = p.second;\n\n        S.find(b);\n        S.end();\n\t\tif(S.find(b) != S.end()) continue;\n        S.insert(b);\n        // fprintf(stderr, \"%09lld %d\\n\", b.hash(), t);\n\n\t\tif(b == be) {cout << t << endl; return 0;}\n\n\t\tvector<Board> trans = b.transition();\n\t\tfor(Board bb: trans){\n\t\t\tq.push(make_pair(bb, t+1));\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    for(int i = 0;i<N2;i++){\n      if(f[i] == p.f[i])continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\n  for(int  i = 0; i < N2; i++)\n    if(p.f[i] != (i+1))return false;\n    return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u,v;\n  s.path  = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while (!Q.empty()){\n    u = Q.front();\n    Q.pop();\n    if(isTarget(u))return u.path;\n    int sx = u.space/N;\n    int sy = u.space%N;\n    for(int r = 0; r <4;r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0||ty<0||tx>=N||ty >= N)continue;\n      v =u;\n      swap(v.f[u.space],v.f[tx * N +ty]);\n      v.space = tx * N + ty;\n      if(!V[v]){\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i =0;i<N2;i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\nint f[N2];\nint space;\nstring path;\n\nbool operator < (const Puzzle &p)const{\nfor(int i=0;i<N2;i++){\nif(f[i]==p.f[i])continue;\nreturn f[i]>p.f[i];\n}\nreturn false;\n}\n};\n\nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\nstatic const char dir[4]={'u','l','d','r'};\n\nbool isTarget(Puzzle p){\nfor(int i=0;i<N2;i++)\nif(p.f[i]!=(i+1))return false;\nreturn true;\n}\n\nstring bfs(Puzzle s){\nqueue<Puzzle>Q;\nmap<Puzzle,bool>V;\nPuzzle u,v;\ns.path=\"\";\nQ.push(s);\nV[s]=true;\nwhile(!Q.empty()){\n  u=Q.front();\n  Q.pop();\n  if(isTarget(u))return u.path;\n  int sx=u.space/N;\n  int sy=u.space%N;\n  for(int r=0 ; r<4 ; r++){\n    int tx=sx+dx[r];\n    int ty=sy+dy[r];\n    if(tx<0 || ty<0 || tx>=N || ty>=N)continue;\n    v=u;\n    swap(v.f[u.space], v.f[tx*N+ty]);\n    v.space=tx*N+ty;\n    if(!V[v]){\n      V[v]=true;\n      v.path+=dir[r];\n      Q.push(v);\n    }\n  }\n}\n\nreturn \"unsolvable\";\n\n}\n\nint main(){\n  Puzzle in;\n  for(int i=0 ; i<N2 ; i++){\n    cin >> in.f[i];\n    if(in.f[i]==0){\n    in.f[i]=N2;\n    in.space=i;\n    }\n  }\n  \n  string ans=bfs(in);\n  cout << ans.size() << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n#define DIVN 3\n\nvoid swap(int &a, int &b);\nint fact(int a);\nint dist(int x);\nint abs(int x);\nvoid insert(vector<int> &A, int v);\nint extract(vector<int> &A);\nint PtoI(vector<int> p);\nvector<int> ItoP(int ii);\nint SolvePuzzle(vector<int> P);\n\nvector<int> Puzzles(fact(DIVN*DIVN), INT_MAX);\n\n\nvoid swap(int &a, int &b){\n\tint tmp = a;\n\ta = b;\n\tb = tmp;\n\treturn;\n}\n\nint fact(int a){\n\tint b = 1;\n\tfor (int i = 2; i <= a; i++){\n\t\tb = b * i;\n\t}\n\treturn b;\n}\n\nint dist(int x){\n\tstd::vector<int> P = ItoP(x);\n\tint result = 0;\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tif (P[i] == 0) continue;\n\t\tresult += abs(P[i] % DIVN - (i + 1) % DIVN) + abs((P[i] - 1) / DIVN - i / DIVN);\n\t}\n\treturn -result-Puzzles[x];\n}\n\nint abs(int x){\n\treturn x < 0 ? -x : x;\n}\n\nvoid insert(vector<int> &A, int v){\n\tint n = A.size();\n\tA.push_back(v);\n\twhile (n != 0){\n\t\tint i = (n - 1) / 2;\n\t\tif (dist(A[n]) > dist(A[i])){\n\t\t\tswap(A[n], A[i]);\n\t\t}\n\t\tn = i;\n\t}\n\treturn;\n}\n\nint extract(vector<int> &A){\n\tint n = A.size() - 1;\n\tint res = A[0];\n\tA[0] = A[n];\n\tA.pop_back();\n\n\tfor (int i = 0, j; 2 * i + 1 < n;){\n\t\tj = 2 * i + 1;\n\t\tif (j != n - 1 && dist(A[j]) < dist(A[j + 1])){\n\t\t\tj++;\n\t\t}\n\t\tif (dist(A[i]) < dist(A[j])){\n\t\t\tswap(A[i], A[j]);\n\t\t}\n\t\ti = j;\n\t}\n\treturn res;\n}\n\n\nint PtoI(vector<int> p){\n\tint x, result = 0;\n\tfor (int i = 0; i < DIVN*DIVN - 1; i++){\n\t\tfor (int j = 0; j < DIVN*DIVN - i; j++){\n\t\t\tif (p[j] == i){\n\t\t\t\tx = j;\n\t\t\t\tp.erase(p.begin() + j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult += x * fact(DIVN*DIVN - i - 1);\n\t}\n\treturn result;\n}\n\nvector<int> ItoP(int ii){\n\tvector<int> result(DIVN*DIVN, -1);\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tint index = ii / fact(DIVN*DIVN - i - 1);\n\t\tii = ii % fact(DIVN*DIVN - i - 1);\n\t\tint curindex = -1;\n\t\tint x = -1;\n\t\tfor (int j = 0; j < DIVN*DIVN; j++){\n\t\t\tif (result[j] == -1){\n\t\t\t\tcurindex++;\n\t\t\t}\n\t\t\tif (curindex == index) {\n\t\t\t\tx = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult[x] = i;\n\t}\n\treturn result;\n}\n\nint SolvePuzzle(vector<int> P){\n\tvector<int> Que;\n\tinsert(Que, PtoI(P));\n\tint answer = INT_MAX;\n\tPuzzles[PtoI(P)] = 0;\n\twhile (!Que.empty()){\n\t\tvector<int> Q = ItoP(extract(Que));\n\t\tint Cursor;\n\t\tbool isAligned = true;\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] != (i + 1) % (DIVN*DIVN)){\n\t\t\t\tisAligned = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isAligned){\n\t\t\tanswer = Puzzles[PtoI(Q)];\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] == 0){\n\t\t\t\tCursor = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvector<int> Qnext;\n\t\tif (Cursor >= DIVN){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor < DIVN * (DIVN - 1)){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != 0){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != DIVN - 1){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn answer;\n}\n\nint main(){\n\tint k;\n\tvector<int> P;\n\tfor (int i = 0; i < DIVN * DIVN; i++){\n\t\tscanf(\"%d\", &k);\n\t\tP.push_back(k);\n\t}\n\tint n = SolvePuzzle(P);\n\n\tprintf(\"%d\\n\", n);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n\nconstexpr int NX = 3, NY = 3;\nconstexpr int SIZE = NX*NY;\n\nusing namespace std;\n\ntypedef pair< int, vector<int> > PuzzleState;\n\nset< vector<int> > visited;\n\nbool IsSolved( const vector<int>& s ) {\n    int cnt = s[SIZE-1] == 0 ? 1 : 0;\n    for ( int i=0; i<SIZE; ++i ) {\n\tif ( s[i] == i+1 ) ++cnt;\n    }\n    return cnt == SIZE;\n}\n\nbool IsVisited( const vector<int>& s ) {\n    return visited.find( s ) != visited.end();\n}\n\nint Solve( const vector<int>& init_s ) {\n\n    const int dx[4] = { -1,  0, 1, 0 };\n    const int dy[4] = {  0, -1, 0, 1 };\n\n    queue< PuzzleState > state;\n    state.push( make_pair(0, init_s) );\n    visited.insert( init_s );\n\n    while ( !state.empty() ) {\n\n\tPuzzleState curr = state.front();\n\n\tif ( IsSolved( curr.second ) ) return curr.first;\n\tstate.pop();\n\t\n\tint x, y;\n\tfor ( int i=0; i<SIZE; ++i ) {\n\t    if ( curr.second[i] == 0 ) {\n\t\tx = i%NX;\n\t\ty = i/NY;\n\t\tbreak;\n\t    }\n\t}\n\n\tfor ( int i=0; i<4; ++i ) {\n\t    int nx = x + dx[i];\n\t    int ny = y + dy[i];\n\t    if ( nx >= 0 && nx < NX && ny >= 0 && ny < NY ) {\n\n\t\tswap( curr.second[NX*y+x], curr.second[NX*ny+nx] );\n\t\tcurr.first += 1;\n\t\t\n\t\tif ( !IsVisited( curr.second ) ) {\n\t\t    state.push( curr );\n\t\t    visited.insert( curr.second );\n\t\t}\n\t\t\n\t\tcurr.first -= 1;\n\t\tswap( curr.second[NX*y+x], curr.second[NX*ny+nx] );\n\t    }\n\t}\n    }\n    return 1000000;\n}\n\nint main() {\n\n    vector<int> s(SIZE);\n    for ( int i=0; i<SIZE; ++i ) cin >> s[i];\n\n    cout << Solve( s ) << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, b) for (int i = (a), i##_max = (b); i < i##_max; ++i)\n#define RFOR(i, a, b) for (int i = (b)-1, i##_min = (a); i >= i##_min; --i)\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define RREP(i, n) for (int i = (n)-1; i >= 0; --i)\n#define ALL(obj) (obj).begin(), (obj).end()\n\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\n\nusing namespace std;\nusing i64 = int64_t;\nusing u64 = uint64_t;\nusing vb = vector<bool>;\nusing vi = vector<int>;\nusing vl = vector<i64>;\nusing vd = vector<double>;\nusing pi = pair<int, int>;\nusing pl = pair<i64, i64>;\nusing pd = pair<double, double>;\n\nconstexpr int INF = 1 << 30;\nconstexpr int MOD = 1000000007;\n\ntemplate <typename T>\ninline void chmin(T &a, T b) {\n  a = min(a, b);\n}\ntemplate <typename T>\ninline void chmax(T &a, T b) {\n  a = max(a, b);\n}\ntemplate <typename T>\nvoid print(T &v) {\n  for (auto it = v.begin(); it != v.end(); ++it) {\n    if (it != v.begin()) cout << \" \";\n    cout << *it;\n  }\n  cout << endl;\n}\n\nconstexpr int N = 3;\nconstexpr int N2 = N * N;\nconstexpr array<int, 4> dx{-1, 0, 1, 0}, dy{0, -1, 0, 1};\nconstexpr array<char, 4> dir{'u', 'l', 'd', 'r'};\n\nstruct Puzzle {\n  std::array<int, N2> f;\n  int space;\n  string path;\n\n  bool operator<(const Puzzle &p) const {\n    REP(i, N2) {\n      if (f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nbool is_target(Puzzle &p) {\n  REP(i, N2) {\n    if (p.f[i] != i + 1) return false;\n  }\n  return true;\n}\n\nstring bfs(Puzzle &s) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while (!Q.empty()) {\n    auto u = Q.front();\n    Q.pop();\n    if (is_target(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    REP(r, 4) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      auto v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if (!V[v]) {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n}\n\nint main() {\n  Puzzle in;\n  REP(i, N2) {\n    cin >> in.f[i];\n    if (in.f[i] == 0) {\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  auto ans = bfs(in);\n  cout << ans.size() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<map>\n#include<queue>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < (const Puzzle &p) const{\n    for(int i = 0; i < N2; i++){\n      if(f[i] == p.f[i]) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  for(int i = 0; i < N2; i++){\n    if(p.f[i] != (i + 1)) return false;\n  }\n  return true;\n}\n\nstring bfs(Puzzle s){\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while( !Q.empty()){\n    u = Q.front();\n    Q.pop();\n    if(isTarget(u)) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int i = 0; i < 4; i++){\n      int tx = sx + dx[i];\n      int ty = sy + dy[i];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if(!V[v]){\n\tV[v] = true;\n\tv.path += dir[i];\n\tQ.push(v);\n      }\n    }\n  }\n  return \"unsolvable\";\n}\n\nint main(){\n  Puzzle in;\n\n  for(int i = 0; i < N2; i++){\n    cin >> in.f[i];\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n    int f[N2];\n    int space;\n    string path;\n\n    bool operator = (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] != p.f[i]) return false;\n        }\n\n        return true;\n    }\n\n    bool operator < (const Puzzle &p) const {\n        for (int i = 0; i < N2; i++) {\n            if (f[i] == p.f[i]) continue;\n            return f[i] > p.f[i];\n        }\n\n        return false;\n    }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n    for (int i = 0; i < N2; i++) {\n        if (p.f[i] != (i + 1)) return false;\n    }\n    return true;\n}\n\nstring bfs(Puzzle start) {\n    map<Puzzle, bool> m;\n    m[start] = true;\n    queue<Puzzle> Q;\n    Q.push(start);\n\n    while (!Q.empty()) {\n        Puzzle x = Q.front();\n        Q.pop();\n        if (isTarget(x)) {\n            return x.path;\n        }\n        int spaceX = x.space / N;\n        int spaceY = x.space % N;\n        for (int i = 0; i < 4; i++) {\n            int nextX = spaceX + dx[i];\n            int nextY = spaceY + dy[i];\n            if (nextX < 0 || nextX >= N || nextY < 0 || nextY >= N) {\n                continue;\n            }\n\n            Puzzle nextP = x;\n            nextP.space = nextX * N + nextY;\n            nextP.path += dir[i];\n            swap(nextP.f[x.space], nextP.f[nextX * N + nextY]);\n            if (!m[nextP]) {\n                m[nextP] = true;\n                Q.push(nextP);\n            }\n        }\n    }\n\n    return \"\";\n}\n\nint main() {\n    Puzzle p;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> p.f[N * i + j];\n            if (p.f[N * i + j] == 0) {\n                p.f[N * i + j] = N2;\n                p.space = N * i + j;\n            }\n        }\n    }\n    p.path = \"\";\n\n    string ans = bfs(p);\n\n    cout << ans.length() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint H=3,W=3;\nset<vector<vector<short>>> memo;\n\nstruct STATE {\n    int f;\n    int g;\n    vector<vector<short>> b;\n\n    bool operator < (const STATE& tgt) const {\n\treturn f > tgt.f; // ?¨????\n    }\n};\ninline bool is_searched(const STATE& s) {\n    return (memo.find(s.b) != memo.end());\n}\ninline void searched(const STATE& s) {\n    memo.insert(s.b);\n}\ninline bool is_goal(const STATE& s) {\n    for(int i=0; i<H; i++) {\n\tfor(int j=0; j<W; j++) {\n\t    if( i == H-1 and j == W-1 )  return true;\n\t    if( s.b[i][j] != (i*W)+j+1 ) return false;\n\t}\n    }\n}\n\ninline void where0(const STATE& s, int& h, int& w) {\n    for(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t    if( s.b[i][j] == 0 ) {\n\t\th = i;\n\t\tw = j;\n\t    }\n}\n\ninline int manhattan_dis(const int tgt, const int h, const int w) {\n    if(tgt == 0 ) return 0;\n    int tgt_h = (tgt-1)/W;\n    int tgt_w = (tgt-1)%W;\n    return abs(tgt_h - h) + abs(tgt_w - w);\n}\n\ninline int heuristic(const vector<vector<short>>& b) {\n    int ans = 0;\n    for(int i=0; i<H; i++) {\n\tfor(int j=0; j<W; j++) {\n\t    ans += manhattan_dis(b[i][j],i,j);\n\t}\n    }\n    return ans;\n}\n\nconst int dx[] = { 1, 0,-1, 0}; \nconst int dy[] = { 0, 1, 0,-1};\ninline vector<STATE> adjcency(const STATE& cur) {\n    int h,w;   where0(cur,h,w);\n    vector<STATE> ans;\n    vector<vector<short>> b = cur.b;\n    \n    for(int i=0; i<4; i++) { // 4??????\n\tint nh = h+dy[i], nw = w+dx[i];\n\tif( nh >= 0 and nh < H and nw >= 0 and nw < W ) {\n\t    swap(b[nh][nw], b[h][w]);\n\t    int heu = heuristic(b);\n\t    if( cur.g+1+heu <= 24 )\n\t\tans.push_back( STATE{cur.g+1+heu, cur.g+1, b} );\n\t    swap(b[nh][nw], b[h][w]);\n\t}\n    }\n    return ans;\n}\n    \nSTATE astar(const STATE& init) {\n    \n    priority_queue<STATE> pq;              // ?????????????°?????????????????????????????????????\n    pq.push(init);                         // ????????? STATE ????????£??????\n    \n    while( pq.size() ) {                   // ?????\\???????????????????????§????????§???\n\tSTATE cur = pq.top(); pq.pop();    // ?????£??¨????????????????????¶??????????????§???\n\tif( is_searched(cur) ) continue;   // ??????????????¢?´¢????????§...\n\tif( is_goal(cur) ) return cur;     // ??´??????????????´????????????\n\n\tsearched(cur);                     // cur ?????¢?´¢???????????¨????????????????????????\n\t\n\tfor(STATE& next : adjcency(cur)) { // ?????????????????¨?????????????????§???\n\t    if( is_searched(next) ) continue;\n\t    pq.push(next);\n\t}\n    }\n    // ???????????\\?????£??????????????¨??????...????????????????????£?????£????????¨???...\n    return init;\n}\n\nint main() {\n\n//    cin >> H >> W;\n    vector<vector<short>> b(H,vector<short>(W));\n    for(int i=0; i<H; i++) for(int j=0; j<W; j++) cin >> b[i][j];\n\n    int h = heuristic(b);\n    STATE init{h,0,b};\n    \n    STATE lst = astar(init);\n    cout << lst.g << endl;\n\n//    cout << memo.size() << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "/////////////////////////////////////////////////////////\n//\n//  ~/Izumi_Chiharu/c/temp.cpp file\n//  Last Updated: 2018-06-17 ...Maybe\n//\n//    I hope you adding this code to the setting file\n//    alias g++='g++ -std=c++1y -DDEBUG_LOCAL'\n//\n//  My sweet heart Chiharu Izumi\n//\n/////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid print_Qbey(){cout<<\n\"           H                                           M#5J~d              \"  <<endl<<\n\"         Hm.?WMM                                   MMB^ .Z  d              \"  <<endl<<\n\"         MZS.` ?7WMM                             M#=`` (!`` d              \"  <<endl<<\n\"         HP?X,```  ?TMM                       MMY! ` .d: `` d              \"  <<endl<<\n\"         Hb;<U,`````` (TMM                 HM ^ ``` .V>_` `.W              \"  <<endl<<\n\"           ;><?n. `` ````?WHHMMHHHMMMMMM MMY```` ` (3<< `` .M              \"  <<endl<<\n\"         HN<>>>?W,`` `` ` (77!~`  ```~!?7'``` `` .d>>><``  .M              \"  <<endl<<\n\"          M2<>>>>?n.`` `` `` `` ``` `` ```` `` `.X>1++< `` (H              \"  <<endl<<\n\"          MK<>>>>+?S.``` `` ```` ``` ``` `` `` .Z``` ?4-.` jM              \"  <<endl<<\n\"           N2><+d=(Y^ `` `` ` ` ` ` `` `` `` `` T~.`````?=(dM              \"  <<endl<<\n\"           MR;JY~`~``` `` `` ``` ``` `` `` `` ``` u, `` `` 7M              \"  <<endl<<\n\"            NV!_`` `` `` ```` ``` `` `` `` ``` ``` C& ` ```` TMM           \"  <<endl<<\n\"           MY.(-`` ` `` ``  `` ` `` `` `` `` ``  `` (n ` ` ``` 7M          \"  <<endl<<\n\"         HMD-(D`` ``` `` ``` `` `` `` `` `` ` ``` ```(n ` `` `` (WM        \"  <<endl<<\n\"         M _(d```` `` ``` ``` ``` `` `` `` ``` ``` `` .b.`` `` ```?MH      \"  <<endl<<\n\"        MM!_(%` `` `` `` ` ` `` `` `` ``` `` `` ` `` ` (l`` ``````` TMH    \"  <<endl<<\n\"       H#>__d:`` .JXVS, ``` `` ` `` `` `.JXWH&.``` ```` O; `` ` ` `` -WM   \"  <<endl<<\n\"       M%.~(k ``.HXH[ dr ```` ``` `` `` dWWN- u. `` ``` ,M,``` ``` ``` ?MMM\"  <<endl<<\n\"      MF_~~($`` .WXMMWX$ ` ``` `` ``` ` dXM HHK````` `` ,HN-``````````.-=jg\"  <<endl<<\n\"MMMMHMY.~~~(R ``` 799Y!```` ``` `` `` `` ?UUUY!`` ````` (M N, `` ```.Z3J=``\"  <<endl<<\n\"gaJJdD.~~::_X|`````````````` `````` `` ` ``` ````` ``` .H  MN,``` .Yiv! ```\"  <<endl<<\n\"   MD_:~:~:~(T.`````````` ``` ` ` ````` ``` ``` ``````.M     N, .Ziv!`` ._~\"  <<endl<<\n\" MM'_:::::::~(N+.`````````` .`.(.` .` ``` ```` ```` .dM       NZ1v! .-_~~``\"  <<endl<<\n\" #:(::::::::~(HMNa..  ``````_?!`?7! `` ````  ...-(+7WMM     HM3(b _:<``..`.\"  <<endl<<\n\"=_;::::::::<(H    MMHaJ--_--........-.__~~~~(&v7<~``` ?MM   M>gM9h,_.......\"  <<endl<<\n\";;;;;;;:;::(drWM          HHmgggg&gzOtOzz<<~~~~~_`` ``` ?MMMH+ggM Mm-......\"  <<endl<<\n\"e<>>;>>;;><dMMJM                  Nc_~~~~~~~~~~_ ``  ` `` 7H&-...?THNe-_._(\"  <<endl<<\n\",4m+>>>>>>j MM(W                   N-~~~~~~~~:_`` ``` ` ``  ?7UHHqqHWHMm+__\"  <<endl<<\n\"vX+vT4k&&dMMD!+M                   MR_~~~~~:_````` ```` ````````` ````  ?We\"  <<endl<<\n\"???zTwiJ-(((JdM                    MK_~~~~:_``` ` ` ` `` ` ` ` ``` ```````?\"  <<endl<<\n\"1uukgHM                            MH_~~~_``` `` ``` `` `` `` ` `` ` `  ```\"  <<endl<<\n\"CugM                                N;~~:_ ` `` `` ``` `` ````` ``` ``` ` `\"  <<endl<<\n\"H                                   M[~~~_4, `   ` `` `` ``  ``` `` `` ``` \"  <<endl<<\n\"                                    Hb~~~~~?n  (: `` `` `` `` ` ` `` `` ```\"  <<endl<<\n\"                                    Hb~~~~~~(4,J_ `` ```  ```` ``` `` `` ` \"  <<endl<<\n\"                                     N-~~~~~~(MM_` `` ` (}  `` `` `` `` ```\"  <<endl<<\n\"                                     Mr_~~~~~(HH: `` `` j!`` `` `` `` `` ``\"  <<endl<<\n\"                                     Mb~~~~~~(WH:`` `` .Z `` `` `` ``` `` `\"  <<endl<<\n\"                                      N:~~~~~(WM{ `` ` .H+.. `` `  .``` `` \"  <<endl;}\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n//#define int long long\n\n#define _overload3(_1,_2,_3,name,...) name\n#define _REP(i,n) REAP(i,0,n)\n#define REAP(i,a,b) for(int i=int(a);i<int(b);++i)\n#define REP(...) _overload3(__VA_ARGS__,REAP,_REP,)(__VA_ARGS__)\n\n#define _REPR(i,n) REAPR(i,n,0)\n#define REAPR(i,a,b) for(int i=int(a-1);i>=int(b);--i)\n#define REPR(...) _overload3(__VA_ARGS__,REAPR,_REPR,)(__VA_ARGS__)\n\n#define ALL(a) a.begin(),a.end()\n#define rALL(a) a.rbegin(),a.rend()\n\n#define coutALL(a) {int loop_coutALL=0;for(auto e:a) cout<<(loop_coutALL++?\" \":\"\")<<e; cout<<endl;}\n#define coutYN(a) cout<<(a?\"Yes\":\"No\")<<endl;\n#define coutyn(a) cout<<(a?\"yes\":\"no\")<<endl;\n\n#define pcnt __builtin_popcount\n#define buli(x) __builtin_popcountll(x)\n\nconst int INF=1145141919;\nconst int MOD=(int)1e9+7;\nconst double EPS=1e-12;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const int dx[]={-1,-1,-1,0,1,1,1,0},dy[]={-1,0,1,1,1,0,-1,-1};\n\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\n\ntypedef pair<int,int> pii;\ntypedef pair<int,string> pis;\ntypedef pair<string,int> psi;\ntypedef pair<string,string> pss;\n\ntypedef long long ll;\n\ntemplate<class T> ll upper(T n,T m){return (n+m-1)/m;};\ntemplate<class T> ll rounding(T n){return (long double)n+0.5;};\n\ninline int qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a;a=1ll*a*a;}while(b>>=1);return ans;}\ninline int qp(int a,ll b,int mo){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}\n\nstruct Arithmetic{Arithmetic(){cin.tie(0);ios::sync_with_stdio(0);cout<<fixed<<setprecision(20);}};\n\n//#define DEBUG_LOCAL\n\n#ifdef DEBUG_LOCAL\ntemplate<typename T> void deb(T a){cerr<<\"deb: \"<<a<<\"ですねぇ！\"<<endl;}\n#define debl {cerr<<\"debug: \"<<__LINE__<<\"行目だよーんおほほ\"<<endl;}\nvoid what_cr(){cout<<__GCC_ATOMIC_CHAR16_T_LOCK_FREE<<\" ←なんだろーこの数字？\"<<endl;}\nvoid t_t(){cout\n    <<endl\n    <<\"------------------------\"<<endl\n    <<\"| Presented by         |\"<<\" Compiled \"<<__FILE__<<endl\n    <<\"| \"<<__DATE__<<\" \"<<__TIME__<<\" |\"<<endl\n    <<\"|        Chiharu Izumi |\"<<\"      to get the AC :)\"<<endl\n    <<\"------------------------\"<<endl;\n}\n#else\ntemplate<typename T>void deb(T a){}\n#define debl ;\nvoid what_cr(){}void t_t(){}\n#endif\n\nvvi pz0(3,vi(3,0));\nint ans=32;\nmap <vvi,int> tf;\n\nint find0(vvi pz){\n\n  REP(i,3) REP(j,3) if(pz[i][j]==0) return i*3+j;\n\n}\n\nvoid print(vvi pz){\n\n  REP(i,3){\n    REP(j,3){\n      if(j) cout<<\" \";\n      cout<<pz[i][j];\n    }\n    cout<<endl;\n  }\n\n}\n\nvoid bfs(vvi pz){\n\n  queue <pair<vvi,int>> pzq;\n  pzq.push(mp(pz,0));\n\n  for(;!pzq.empty();){\n\n    vvi now=pzq.front().fi;\n    int how=pzq.front().se;\n    pzq.pop();\n\n    if(how>31) continue;\n\n    if(tf[now]) continue;\n    tf[now]=1;\n\n    if(now==pz0){\n\n      ans=how;\n      return;\n\n    }\n\n    int x=find0(now)%3;\n    int y=find0(now)/3;\n\n    REP(i,4){\n\n    int x0=x+dx[i];\n    int y0=y+dy[i];\n\n    if(x0<0 || x0>2) continue;\n    if(y0<0 || y0>2) continue;\n\n    swap(now[y][x],now[y0][x0]);\n    pzq.push(mp(now,how+1));\n    swap(now[y][x],now[y0][x0]);\n\n    }\n\n  }\n\n}\n\nvoid dfs(vvi pz,int how){\n\n  if(tf[pz]) return;\n  tf[pz]=1;\n\n  if(how>31) return;\n  if(pz0==pz){\n\n    ans=min(ans,how);\n    return;\n\n  }\n\n  int x=find0(pz)%3;\n  int y=find0(pz)/3;\n\n  REP(i,4){\n\n    int x0=x+dx[i];\n    int y0=y+dy[i];\n\n    if(x0<0 || x0>2) continue;\n    if(y0<0 || y0>2) continue;\n\n    swap(pz[y][x],pz[y0][x0]);\n    dfs(pz,how+1);\n    swap(pz[y][x],pz[y0][x0]);\n\n  }\n\n}\n\nsigned main(){\n\n  Arithmetic Exception;\n\n  vvi pz(3,vi(3,0));\n\n  REP(i,9) pz0[i/3][i%3]=(i+1)%9;\n  REP(i,9) cin>>pz[i/3][i%3];\n\n  bfs(pz);\n\n  cout<<ans<<endl;\n\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n\nint d_x[4] = { -1,0,1,0 };\nint d_y[4] = { 0,1,0,-1 };\n\nint t[3][3];\nint level=0;\n\nint countpath() {\n\tint ret=0;\n\tint tmp;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tif (t[i][j] != 0) {\n\t\t\t\ttmp = t[i][j] - 1;\n\t\t\t\tret += abs(tmp / 3 - i) + abs(tmp % 3 - j);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool check(int depth, int pre, int px, int py) {\n\tint w = countpath();\n\tif (w + depth > level) return false;\n\tif (w == 0)return true;\n\tint dx, dy;\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (abs(i - pre) != 2) {\n\t\t\tdx = px + d_x[i];\n\t\t\tdy = py + d_y[i];\n\t\t\tif (dx < 0 || dx == 3 || dy < 0 || dy == 3) continue;\n\t\t\tswap(t[dx][dy], t[px][py]);\n\t\t\tif (check(depth + 1, i, dx, dy)) return true;\n\t\t\tswap(t[dx][dy], t[px][py]);\n\t\t}\n\t\t\n\t}\n\treturn false;\n}\n\nvoid solution(int px, int py) {\n\tfor (level = 0;; level++) {\n\t\tif (check(0, 9, px, py)) {\n\t\t\tcout << level << endl;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main() {\n\tint px, py;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tcin >> t[i][j];\n\t\t\tif (t[i][j] == 0) {\n\t\t\t\tpx = i;\n\t\t\t\tpy = j;\n\t\t\t}\n\t\t}\n\t}\n\tsolution(px,py);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n \nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n \nint t[3][3];\nint limit;\n \nint getHeuri(){\n  int res=0,a;\n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n      if(t[i][j]==0)continue;\n      a=t[i][j]-1;\n      res+=abs(a/3-i)+abs(a%3-j);\n    }\n  }\n  return res;\n}\n \nbool check(int depth,int prev,int py,int px){\n  int heuri=getHeuri();\n  if(heuri+depth>limit)return false;\n  if(heuri==0)return true;\n  for(int i=0;i<4;i++){\n    if(abs(i-prev)==2)continue;\n    int ny=py+dy[i],nx=px+dx[i];\n    if(ny<0||nx<0)continue;\n    if(ny>=3||nx>=3)continue;\n    swap(t[ny][nx],t[py][px]);\n    if(check(depth+1,i,ny,nx)) return true;\n    swap(t[ny][nx],t[py][px]);\n  }\n  return false;\n}\n \nvoid solve(int py,int px){\n  for(limit=0;;limit++){\n    if(check(0,99,py,px)){\n      cout<<limit<<endl;\n      return;\n    }\n  }\n}\n \nint main(){\n  int py,px;\n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n      cin>>t[i][j];\n      if(t[i][j]==0){\n    py=i;\n    px=j;\n      }\n    }\n  }\n  solve(py,px);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator < ( const Puzzle &p ) const {\n    for ( int i = 0; i < N2; i++ ) {\n      if ( f[i] == p.f[i] ) continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p) {\n  for ( int i = 0; i < N2; i++ )\n    if ( p.f[i] != (i + 1) ) return false;\n  return true;\n}\n\nstring bfs(Puzzle s) {\n  queue<Puzzle> Q;\n  map<Puzzle, bool> V;\n  Puzzle u, v;\n  s.path = \"\";\n  Q.push(s);\n  V[s] = true;\n\n  while ( !Q.empty() ) {\n    u = Q.front(); Q.pop();\n    if ( isTarget(u) ) return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for ( int r = 0; r < 4; r++ ) {\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n      v = u;\n      swap(v.f[u.space], v.f[tx * N + ty]);\n      v.space = tx * N + ty;\n      if ( !V[v] ) {\n        V[v] = true;\n        v.path += dir[r];\n        Q.push(v);\n      }\n    }\n  }\n\n  return \"unsolvable\";\n}\n\nint main() {\n  Puzzle in;\n\n  for ( int i = 0; i < N2; i++ ) {\n    cin >> in.f[i];\n    if ( in.f[i] == 0 ) {\n      in.f[i] = N2;  // set space\n      in.space = i;\n    }\n  }\n  string ans = bfs(in);\n  cout << ans.size() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define MAXN 10+2\nint map[MAXN][MAXN];\nint min0=1000000000;\nint t;\nint map1[3][3]={1,2,3,4,5,6,7,8,0};\nbool hx[10000008];\nbool pd(){\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tif(map[i][j]!=map1[i][j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\nvoid syf(int x,int y,int tot){\n\tif(pd()){\n\t\tif(tot<min0) min0=tot;\n\t\treturn;\n    }\n    else if(tot>26) return;\n\telse{\n\t\tint g=1;\n\t\tif(x+1<3){\n\t\t\tt=map[x][y];\n\t\t\tmap[x][y]=map[x+1][y];\n\t\t\tmap[x+1][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=10000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x+1,y,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x+1][y];\n\t\t\tmap[x+1][y]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(x-1>=0){\n\t\t\tt=map[x][y];\n\t\t\tmap[x][y]=map[x-1][y];\n\t\t\tmap[x-1][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=10000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x-1,y,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x-1][y];\n\t\t\tmap[x-1][y]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(y+1<3){\n\t\t\tt=map[x][y+1];\n\t\t\tmap[x][y+1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=10000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x,y+1,tot+1);\n\t\t\t\thx[g]=0;\n\t\t\t}\n\t\t\tt=map[x][y+1];\n\t\t\tmap[x][y+1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t\tg=1;\n\t\tif(y-1>=0){\n\t\t\tt=map[x][y-1];\n\t\t\tmap[x][y-1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\tfor(int j=0;j<3;++j){\n\t\t\t\t\tg=g*10+map[i][j];\n\t\t\t\t\tg%=10000007;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!hx[g]){\n\t\t\t\thx[g]=1;\n\t\t\t\tsyf(x,y-1,tot+1);\n\t\t\t    hx[g]=0;\n\t\t\t}\n\t\t\tt=map[x][y-1];\n\t\t\tmap[x][y-1]=map[x][y];\n\t\t\tmap[x][y]=t;\n\t\t}\n\t}\n}\nvoid input(){\n\tint x1,y1;\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tcin>>map[i][j];\n\t\t\tif(map[i][j]==0){\n\t\t\t\tx1=i;\n\t\t\t\ty1=j;\n\t\t\t}\n\t\t}\n\t}\n\tint g=1;\n\tfor(int i=0;i<3;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tg=g*10+map[i][j];\n\t\t\tg%=10000007;\n\t\t}\n\t}\n\thx[g]=1;\n\tsyf(x1,y1,0);\n\tcout<<min0<<endl;\n}\nint main(){\n\tinput();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include<algorithm>\nusing namespace std;\n\nint d_x[4] = { -1,0,1,0 };\nint d_y[4] = { 0,1,0,-1 };\n\nint t[3][3];\nint px, py, level=0;\n\nint countpath() {\n\tint ret=0;\n\tint tmp;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tif (t[i][j] != 0) {\n\t\t\t\ttmp = t[i][j] - 1;\n\t\t\t\tret += abs(tmp / 3 - i) + abs(tmp % 3 - j);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool check(int depth, int pre) {\n\tint w = countpath();\n\tif (w + depth > level) return false;\n\tif (w == 0)return true;\n\tint dx, dy;\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (abs(i - pre) != 2) {\n\t\t\tdx = px + d_x[i];\n\t\t\tdy = py + d_y[i];\n\t\t\tif (dx < 0 || dx == 3 || dy < 0 || dy == 3) continue;\n\t\t\tswap(t[dx][dy], t[px][py]);\n\t\t\tif (check(depth + 1, i)) return true;\n\t\t\tswap(t[dx][dy], t[px][py]);\n\t\t}\n\n\t}\nreturn false;\n}\n\nvoid solution() {\n\tfor (level = 0;; level++) {\n\t\tif (check(0, 9)) {\n\t\t\tcout << level << endl;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main() {\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tcin >> t[i][j];\n\t\t\tif (t[i][j] == 0) {\n\t\t\t\tpx = i;\n\t\t\t\tpy = j;\n\t\t\t}\n\t\t}\n\t}\n\tsolution();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n#define DIVN 3\n\nvoid swap(int &a, int &b);\nint fact(int a);\nint dist(int x);\nint abs(int x);\nvoid insert(vector<int> &A, int v);\nint extract(vector<int> &A);\nint PtoI(vector<int> p);\nvector<int> ItoP(int ii);\nint SolvePuzzle(vector<int> P);\n\nvector<int> Puzzles(fact(DIVN*DIVN), INT_MAX);\n\n\nvoid swap(int &a, int &b){\n\tint tmp = a;\n\ta = b;\n\tb = tmp;\n\treturn;\n}\n\nint fact(int a){\n\tint b = 1;\n\tfor (int i = 2; i <= a; i++){\n\t\tb = b * i;\n\t}\n\treturn b;\n}\n\nint dist(int x){\n\tstd::vector<int> P = ItoP(x);\n\tint result = 0;\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tresult += abs(P[i] % DIVN - (i + 1) % DIVN) + abs(((P[i] == 0 ? DIVN - 1 : (P[i] - 1) / DIVN)) - i / DIVN);\n\t}\n\treturn -result;\n}\n\nint abs(int x){\n\treturn x < 0 ? -x : x;\n}\n\nvoid insert(vector<int> &A, int v){\n\tint n = A.size();\n\tA.push_back(v);\n\twhile (n != 0){\n\t\tint i = (n - 1) / 2;\n\t\tif (dist(A[n]) > dist(A[i])){\n\t\t\tswap(A[n], A[i]);\n\t\t}\n\t\tn = i;\n\t}\n\treturn;\n}\n\nint extract(vector<int> &A){\n\tint n = A.size() - 1;\n\tint res = A[0];\n\tA[0] = A[n];\n\tA.pop_back();\n\n\tfor (int i = 0, j; 2 * i + 1 < n;){\n\t\tj = 2 * i + 1;\n\t\tif (j != n - 1 && dist(A[j]) < dist(A[j + 1])){\n\t\t\tj++;\n\t\t}\n\t\tif (dist(A[i]) < dist(A[j])){\n\t\t\tswap(A[i], A[j]);\n\t\t}\n\t\ti = j;\n\t}\n\treturn res;\n}\n\n\nint PtoI(vector<int> p){\n\tint x, result = 0;\n\tfor (int i = 0; i < DIVN*DIVN - 1; i++){\n\t\tfor (int j = 0; j < DIVN*DIVN - i; j++){\n\t\t\tif (p[j] == i){\n\t\t\t\tx = j;\n\t\t\t\tp.erase(p.begin() + j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult += x * fact(DIVN*DIVN - i - 1);\n\t}\n\treturn result;\n}\n\nvector<int> ItoP(int ii){\n\tvector<int> result(DIVN*DIVN, -1);\n\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\tint index = ii / fact(DIVN*DIVN - i - 1);\n\t\tii = ii % fact(DIVN*DIVN - i - 1);\n\t\tint curindex = -1;\n\t\tint x = -1;\n\t\tfor (int j = 0; j < DIVN*DIVN; j++){\n\t\t\tif (result[j] == -1){\n\t\t\t\tcurindex++;\n\t\t\t}\n\t\t\tif (curindex == index) {\n\t\t\t\tx = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult[x] = i;\n\t}\n\treturn result;\n}\n\nint SolvePuzzle(vector<int> P){\n\tvector<int> Que;\n\tinsert(Que, PtoI(P));\n\tint answer = INT_MAX;\n\tPuzzles[PtoI(P)] = 0;\n\twhile (!Que.empty()){\n\t\tvector<int> Q = ItoP(extract(Que));\n\t\tint Cursor;\n\t\tbool isAligned = true;\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] != (i + 1) % (DIVN*DIVN)){\n\t\t\t\tisAligned = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isAligned){\n\t\t\tanswer = Puzzles[PtoI(Q)];\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < DIVN*DIVN; i++){\n\t\t\tif (Q[i] == 0){\n\t\t\t\tCursor = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvector<int> Qnext;\n\t\tif (Cursor >= DIVN){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor < DIVN * (DIVN - 1)){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + DIVN]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != 0){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor - 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t\tif (Cursor % DIVN != DIVN - 1){\n\t\t\tQnext = Q;\n\t\t\tswap(Qnext[Cursor], Qnext[Cursor + 1]);\n\t\t\tif (Puzzles[PtoI(Qnext)] > Puzzles[PtoI(Q)] + 1){\n\t\t\t\tPuzzles[PtoI(Qnext)] = Puzzles[PtoI(Q)] + 1;\n\t\t\t\tinsert(Que, PtoI(Qnext));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn answer;\n}\n\nint main(){\n\tint k;\n\tvector<int> P;\n\tfor (int i = 0; i < DIVN * DIVN; i++){\n\t\tscanf(\"%d\", &k);\n\t\tP.push_back(k);\n\t}\n\tint n = SolvePuzzle(P);\n\n\tprintf(\"%d\\n\", n);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst int edge[4][3] = {{0, 3, 6}, {0, 1, 2}, {6, 7, 8}, {2, 5, 8}}; /* l, t, b, r */\nint tiles[9];\n\nint check(){\n    int wrongs = 0;\n    REP(i, 9)\n        if(tiles[i] != answer[i])\n            wrongs++;\n    return wrongs;\n}\n\nint dfs(int moves, int cutoff){\n    int wrongs = check();\n    if(wrongs == 0)\n        return moves;\n    int zero;\n    int original[9];\n    REP(i, 9){\n        original[i] = tiles[i];\n        if(tiles[i] == 0){\n            zero = i;\n        }\n    }\n    bool dir[4] = {true, true, true, true};\n    REP(i, 4) REP(j, 3)\n        if (zero == edge[i][j])\n            dir[i] = false;\n    if(wrongs + moves >= cutoff)\n        return -1;\n    if(dir[0]){\n        swap(tiles[zero], tiles[zero-1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[0])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[1]){\n        swap(tiles[zero], tiles[zero-3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[1])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[2]){\n        swap(tiles[zero], tiles[zero+3]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[2])\n        REP(i, 9) tiles[i] = original[i];\n    if(dir[3]){\n        swap(tiles[zero], tiles[zero+1]);\n        int m = dfs(moves+1, cutoff);\n        if(m > 0)\n            return m;\n    }\n    if(dir[3])\n        REP(i, 9) tiles[i] = original[i];\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> tiles[i];\n    int move = 0;\n    int start = check();\n\n    REP(i, 10){\n        move = dfs(0, start + i);\n        if(move > 0)\n            break;\n    }\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\nint f[N2];\nint space;\nstring path;\n\nbool operator < (const Puzzle &p) const{\nfor(int i = 0; i < N2; i++){\nif(f[i] == p.f[i]) continue;\nreturn f[i] > p.f[i];\n}\nreturn false;\n}\n};\n\nstatic const int dx[4] = {-1,0,1,0};\nstatic const int dy[4] = {0,-1,0,1};\nstatic const char dir[4] = {'u','l','d','r'};\n\nbool isTarget(Puzzle p){\nfor(int i = 0; i < N2; i++)\nif(p.f[i] != (i + 1)) return false;\nreturn true;\n}\n\nstring bfs(Puzzle s){\nqueue<Puzzle> Q;\nmap<Puzzle, bool> V;\nPuzzle u, v;\ns.path = \"\";\nQ.push(s);\nV[s] = true;\n\nwhile(!Q.empty()){\nu = Q.front(); Q.pop();\nif(isTarget(u)) return u.path;\nint sx = u.space / N;\nint sy = u.space % N;\nfor(int r = 0; r < 4; r++){\nint tx = sx + dx[r];\nint ty = sy + dy[r];\nif(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\nv = u;\nswap(v.f[u.space], v.f[tx * N + ty]);\nv.space = tx * N + ty;\nif(!V[v]){\nV[v] = true;\nv.path += dir[r];\nQ.push(v);\n}\n}\n}\nreturn \"unsolvable\";\n}\n\nint main(){\nPuzzle in;\nfor(int i = 0; i < N2; i++){\ncin >> in.f[i];\nif(in.f[i] == 0){\nin.f[i] = N2;\nin.space = i;\n}\n}\nstring ans = bfs(in);\ncout << ans.size() << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define N 3\n#define LIM 32\n#define HN 362897\n\nstruct dep{\n  int depth,key;\n};\n\nint ans[N][N]={\n  {1,2,3},\n  {4,5,6},\n  {7,8,0}\n};\n\nint mins = LIM;\nstruct dep h[HN];\n\nint hash1(int k){\n    return k%HN;\n}\nint hash2(int k){\n  return 1+k%(HN-1);\n}\nint hashs(int k, int i){\n  return (hash1(k)+i*hash2(k))%HN;\n}\n\n\nvoid dfs(int X[N][N], int n){\n  int i,j,in,jn,a=0,b=1;\n  int f=0;\n  int tmp[N][N];\n  for(i=0;i<N;i++)\n  {\n    for(j=0;j<N;j++)\n    {\n      if(ans[i][j]!=X[i][j])f++;\n      if(X[i][j]==0){\n        in=i;\n        jn=j;\n      }\n      a+=X[i][j]*b;\n      b*=10;\n    }\n  }\n\n  if(f==0){\n    if(mins>=n)mins=n;\n    return;\n  }\n  if(n>mins)return;\n  i=0;\n  while(1){\n    b=hashs(a, i);\n    if(h[b].key == 0){\n      h[b].key=a;\n      h[b].depth=n;\n      break;\n    }else if(h[b].key == a){\n      if(h[b].depth>n){\n        h[b].depth=n;\n        break;\n      }else return;\n    }\n    i++;\n  }\n\n  if(in>0 && in<N){\n    memcpy(tmp,X,sizeof(int)*N*N);\n    swap(tmp[in][jn],tmp[in-1][jn]);\n    dfs(tmp, n+1);\n  }\n  if(jn>0 && jn<N){\n    memcpy(tmp,X,sizeof(int)*N*N);\n    swap(tmp[in][jn],tmp[in][jn-1]);\n    dfs(tmp, n+1);\n  }\n\n  if(in>=0 && in<N-1){\n    memcpy(tmp,X,sizeof(int)*N*N);\n    swap(tmp[in][jn],tmp[in+1][jn]);\n    dfs(tmp, n+1);\n  }\n  if(jn>=0 && jn<N-1){\n    memcpy(tmp,X,sizeof(int)*N*N);\n    swap(tmp[in][jn],tmp[in][jn+1]);\n    dfs(tmp, n+1);\n  }\n\n}\n\nint main(){\n  int i,j;\n  int X[N][N]={};\n  for(i=0;i<N;i++)for(j=0;j<N;j++)cin>>X[i][j];\n  dfs(X,0);\n  cout<<mins<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define INF 9223372036854775807\n#define NN 9\n#define N 3\n\ntypedef struct Pazzle\n{\n    int frame[N][N];\n    int space[2];\n    int level;\n\n    bool operator<(const Pazzle &p) const\n    {\n        for (int i = 0; i < N; i++)\n        {\n            for (int j = 0; j < N; j++)\n            {\n                if (frame[i][j] == p.frame[i][j])\n                    continue;\n                return frame[i][j] > p.frame[i][j];\n            }\n        }\n        return false;\n    };\n} Pazzle;\n\nint dx[4] = {0, 0, 1, -1};\nint dy[4] = {1, -1, 0, 0};\n\nbool equal(Pazzle a, Pazzle b)\n{\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            if (a.frame[i][j] != b.frame[i][j])\n                return false;\n    return true;\n}\n\nint solve(Pazzle start)\n{\n    Pazzle goal;\n    queue<Pazzle> q;\n    map<Pazzle, bool> V;\n\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            goal.frame[i][j] = (j + i * 3 + 1) % 9;\n    goal.space[0] = 2;\n    goal.space[1] = 2;\n\n    if (equal(start, goal))\n        return 0;\n    V[start] = true;\n    q.push(start);\n\n    while (1)\n    {\n        Pazzle u = q.front();\n        q.pop();\n\n        for (int i = 0; i < 4; i++)\n        {\n            Pazzle v = u;\n            int x = v.space[0] + dx[i];\n            int y = v.space[1] + dy[i];\n\n            if (x >= 0 && x < N && y >= 0 && y < N)\n            {\n                swap(v.frame[v.space[1]][v.space[0]], v.frame[y][x]);\n                v.space[1] = y;\n                v.space[0] = x;\n                v.level = u.level + 1;\n                if (equal(v, goal))\n                    return v.level;\n                if (!V[v])\n                {\n                    V[v] = true;\n                    q.push(v);\n                }\n            }\n        }\n    }\n}\n\nsigned main()\n{\n    Pazzle start;\n    start.level = 0;\n\n    for (int i = 0; i < N; i++)\n    {\n        for (int j = 0; j < N; j++)\n        {\n            int n;\n            cin >> n;\n            if (n == 0)\n            {\n                start.space[0] = j;\n                start.space[1] = i;\n            }\n            start.frame[i][j] = n;\n        }\n    }\n\n    cout << solve(start) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<map>\nusing namespace std;\nqueue<pair<string,int> > Q;\n\nvoid Sw(string st,int x)\n{\n\tint i;\n\tint pos,npos;\n\tint d[4]={-3,3,-1,1};\n\tstring st1;\n\t\n\tfor(i=0;i<=8;i++)\n\t{\n\t\tif(st[i]=='0')\n\t\t{\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(i=0;i<=3;i++)\n\t{\n\t\tst1=st;\n\t\tif(i==2 && pos%3==0) continue;\n\t\tif(i==3 && pos%3==2) continue;\n\t\tnpos=pos+d[i];\n\t\tif(npos>=9 || npos<=-1) continue;\n\t\tswap(st1[pos],st1[npos]);\n\t\tQ.push(pair<string,int>(st1,x+1));\n\t}\n}\n\nint main()\n{\n\tstring puzzle=\"\";\n\tstring goal=\"123456780\";\n\tmap<string,bool> M;\n\tint i,x;\n\tstring P;\n\t\n\tfor(i=0;i<=8;i++)\n\t{\n\t\tcin >> x;\n\t\tpuzzle+='0'+x;\n\t}\n\tQ.push(pair<string,int>(puzzle,0));\n\twhile(1)\n\t{\n\t\tpair<string,int> p=Q.front();\n\t\tQ.pop();\n\t\tP=p.first;\n\t\tx=p.second;\n\t\tif(P==goal)\n\t\t{\n\t\t\tcout << x << endl;\n\t\t\tbreak;\n\t\t}\n\t\tif(M[P]) continue;\n\t\telse M[P]=1;\n\t\tSw(P,x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\n#define N 3\n#define N2 9\n\nstruct Puzzle {\n\tint f[N2], space;\n\tstring path;\n\tbool operator<(const Puzzle& a) const {\n\t\tfor (int i = 0; i < N2; ++i) {\n\t\t\tif (f[i] == a.f[i]) continue;\n\t\t\treturn f[i] > a.f[i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nint dx[] = { -1,0,0,1 }, dy[] = { 0,-1,1,0 };\nchar dir[] = { 'u','l','r','d' };\n\nbool ok(Puzzle& p) {\n\tfor (int i = 0; i < N2; ++i)\n\t\tif (p.f[i] != i + 1) return false;\n\treturn true;\n}\n\nstring bfs(Puzzle s) {\n\tqueue<Puzzle> q;\n\tmap<Puzzle, bool> V;\n\tPuzzle u, v;\n\ts.path = \"\";\n\tq.push(s);\n\tV[s] = true;\n\twhile (!q.empty()) {\n\t\tu = q.front(); q.pop();\n\t\tif (ok(u)) return u.path;\n\t\tint sx = u.space / N, sy = u.space % N;\n\t\tfor (int r = 0; r < 4; ++r) {\n\t\t\tint tx = sx + dx[r], ty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\t\t\tv = u;\n\t\t\tswap(v.f[u.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"unsolvable\";\n}\n\nint main() {\n\tPuzzle in;\n\tfor (int i = 0; i < N2; ++i) {\n\t\tcin >> in.f[i];\n\t\tif (in.f[i] == 0) {\n\t\t\tin.f[i] = N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\tstring ans = bfs(in);\n\tcout << ans.size() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define N 3\n#define N2 9\n\nstruct Puzzle{\n  int f[N2];\n  int space;\n  string path;\n\n  bool operator<(const Puzzle &p) const{\n    for (int i = 0; i < N2; i++){\n      if (f[i] == p.f[i])\n        continue;\n      return f[i] > p.f[i];\n    }\n    return false;\n  }\n};\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nbool isTarget(Puzzle p){\n  for (int i = 0; i < N2; i++){\n    if (p.f[i] != (i + 1)){\n      return false;\n    }\n  }\n  return true;\n}\n\nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle, bool> V;\n    Puzzle u, v;\n    s.path = \"\";\n    Q.push(s);\n    V[s] = true;\n\n    while (!Q.empty()){\n      u = Q.front();\n      Q.pop();\n        if (isTarget(u))\n            return u.path;\n        int sx = u.space / N;\n        int sy = u.space % N;\n        for (int r = 0; r < 4; r++){\n            int tx = sx + dx[r];\n            int ty = sy + dy[r];\n            if (tx < 0 || ty < 0 || tx >= N || ty >= N)\n                continue;\n            v = u;\n            swap(v.f[u.space], v.f[tx * N + ty]);\n            v.space = tx * N + ty;\n            if (!V[v]){\n                V[v] = true;\n                v.path += dir[r];\n                Q.push(v);\n            }\n        }\n    }\n    return \"unsolvable\";\n}\n\nint main(){\n    Puzzle in;\n\n    for (int i=0; i < N2; i++){\n        cin >> in.f[i];\n        if (in.f[i] == 0){\n            in.f[i] = N2;\n            in.space = i;\n        }\n    }\n    string ans = bfs(in);\n    cout << ans.size() << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n#define N 3\ntypedef pair<int, int> P;\n\nstruct State {\n    int g, h;\n    string state;\n    P blank;\n    string path;\n    bool operator<(const State &a) const {\n        return g + h > a.g + a.h;\n    }\n};\n\nint d[5] = {-1, 0, 1, 0, -1};\nstring r[4] = {\"D\", \"R\", \"U\", \"L\"};\nstring ans_str = \"\";\nint ans[N][N], puzzle0[N][N], puzzle1[N][N];\nset<string> s;\npriority_queue<State> next_state;\nstring path;\n\nbool range(int y, int x) {return 0 <= y && y < N && 0 <= x && x < N;}\n\nint h1_dfs(int boundary, State state, int from) {\n    int find = -1;\n    s.insert(state.state); // visited\n\n    P blank = state.blank;\n    rep(i, 4) {\n        if (from == (i + 2) % 4) continue;\n        int y = d[i] + blank.first, x = d[i + 1] + blank.second; // next blank position\n        if (range(y, x)) { // can be replaced\n            string tmp = state.state; // next state (string)\n            int wrong_place = state.h, p = blank.first * N + blank.second, q = y * N + x;\n            if (N < 4) {\n                swap(tmp[p], tmp[q]);\n                wrong_place = wrong_place - (state.state[q] != ans_str[q]) + (state.state[q] != ans_str[p]);\n            } else {\n                swap(tmp[2 * p], tmp[2 * q]), swap(tmp[2 * p + 1], tmp[2 * q + 1]);\n                wrong_place = wrong_place - (state.state.substr(2 * q, 2) != ans_str.substr(2 * q, 2))\n                + (state.state.substr(2 * q, 2) != ans_str.substr(2 * p, 2));\n            }\n\n            if (wrong_place == 0) { // answer\n                find = state.g + 1;\n                path = state.path + r[i];\n                break;\n            }\n\n            if (state.g + 1 + wrong_place > boundary) continue; // estimate value is over boundary\n            find = h1_dfs(boundary, State{state.g + 1, wrong_place, tmp, P(y, x), state.path + r[i]}, i);\n            if (find != -1) break; // find an answer\n        }\n    }\n\n    return find;\n}\n\nint ids_h1(string state, int wrong_place, P blank) {\n    int i = wrong_place, find = -1;\n    while(find == -1 && i < 81) {\n        s.clear();\n        find = h1_dfs(i, State{0, wrong_place, state, blank, \"\"}, -1);\n        i++;\n    }\n    return find;\n}\n\nint main(){\n    // create answer's numbers\n    iota(ans[0], ans[0] + N * N, 1);\n    ans[N - 1][N - 1] = 0;\n    // create number\n    iota(puzzle0[0], puzzle0[0] + N * N, 0);\n    rep(i, N)rep(j, N) cin >> puzzle0[i][j];\n\n    string state = \"\";\n    P blank;\n    int manhattan = 0, wrong_place = 0;\n    rep(i, N)rep(j, N) {\n        state += to_string(puzzle0[i][j]);\n        ans_str += to_string(ans[i][j]);\n\n        if(puzzle0[i][j] == 0) blank = P(i, j);\n        else {\n            int num = puzzle0[i][j] - 1;\n            manhattan += (abs(num / N - i) + abs(num % N - j));\n            if (puzzle0[i][j] != ans[i][j]) wrong_place++;\n        }\n    }\n\n    if (manhattan == 0) { // the answer\n        cout << 0 << endl;\n    } else {\n        int steps;\n        next_state.push(State{0, wrong_place, state, blank, \"\"});\n        steps = ids_h1(state, wrong_place, blank);\n        cout << steps << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nstruct puzzle\n{\n\tint board[3][3];\n\tint distance;\n};\n\nconst int dx[4] = { 0, -1, 1, 0 };\nconst int dy[4] = { -1, 0, 0, 1 };\n\nint main() \n{\n\tpuzzle start;\n\n\tstart.distance = 0;\n\n\tfor (int i = 0; i < 3; i++)\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tcin >> start.board[i][j];\n\n\tqueue<puzzle> que; que.push(start);\n\n\tint Ans;\n\n\twhile (!que.empty())\n\t{\n\t\tpuzzle p = que.front(); que.pop();\n\n\t\tint x, y;\n\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t{\n\t\t\t\tif (p.board[i][j] == 0) \n\t\t\t\t{ \n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t{\n\t\t\tif (0 <= x + dx[dir] && x + dx[dir] < 3 && 0 <= y + dy[dir] && y + dy[dir] < 3)\n\t\t\t{\n\t\t\t\tpuzzle q = p;\n\n\t\t\t\tswap(q.board[y][x], q.board[y + dy[dir]][x + dx[dir]]);\n\n\t\t\t\tq.distance = p.distance + 1;\n\n\t\t\t\tbool found = true;\n\n\t\t\t\tfor (int i = 0; i < 8; i++)\n\t\t\t\t\tif (p.board[i / 3][i % 3] != i + 1) { found = false; }\n\n\t\t\t\tif (found == true)\n\t\t\t\t{\n\t\t\t\t\tAns = p.distance; goto Exit;\n\t\t\t\t}\n\n\t\t\t\tque.push(q);\n\t\t\t}\n\t\t}\n\t}\n\nExit:;\n\n\tcout << Ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\nconst int INF = 1e9;\n\nusing namespace std;\nconst int answer[9] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\nconst bool dir[9][4] = {{false, false, true, true},\n                        {true, false, true, true},\n                        {true, false, true, false},\n                        {false, true, true, true},\n                        {true, true, true, true},\n                        {true, true, true, false},\n                        {false, true, false, true},\n                        {true, true, false, true},\n                        {true, true, false, false}}; /* left, up, down, right */\nvector<int> original(9, 0);\n\nclass board;\n\npriority_queue<board> pq;\nvector<int> searched[9];\n\nclass board{\nprivate:\n    int moves;\n    int wrongs;\n    int zero_place;\n    vector<int> tiles;\n\npublic:\n    explicit board(vector<int> num, int move){\n        wrongs = 0;\n        REP(i, 9){\n            tiles.push_back(num[i]);\n            if(num[i] == 0)\n                zero_place = i;\n            if(num[i] != answer[i])\n                wrongs++;\n        }\n        moves = move;\n    }\n\n    int cost() {\n        return wrongs + moves;\n    }\n\n    void board_to_int(){\n        int k = 0;\n        REP(i, 9)\n            k += (tiles[i] * pow(10, i));\n        for(int i = searched[tiles[0]].size(); i > 0 ; i--)\n            if(k == searched[tiles[0]][i-1])\n                return;\n        pq.push(board(tiles, moves+1));\n        searched[tiles[0]].push_back(k);\n        return;\n    }\n\n    void move() {\n        if(dir[zero_place][0]){\n            swap(tiles[zero_place], tiles[zero_place-1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-1]);\n        }\n        if(dir[zero_place][1]){\n            swap(tiles[zero_place], tiles[zero_place-3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place-3]);\n        }\n        if(dir[zero_place][2]){\n            swap(tiles[zero_place], tiles[zero_place+3]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+3]);\n        }\n        if(dir[zero_place][3]){\n            swap(tiles[zero_place], tiles[zero_place+1]);\n            board_to_int();\n            swap(tiles[zero_place], tiles[zero_place+1]);\n        }\n    }\n\n    int get_wrongs(){\n        return wrongs;\n    }\n};\n\nbool operator< (board b1, board b2){\n    return (b1.cost() > b2.cost()) ? true : false;\n}\n\nint solve(){\n    pq.push(board(original, 0));\n    while(!pq.empty()){\n        auto target = pq.top();\n        pq.pop();\n        if(target.get_wrongs() == 0)\n            return target.cost();\n        target.move();\n    }\n    return -1;\n}\n\nint main() {\n    REP(i, 9) cin >> original[i];\n    int move = 0;\n    move = solve();\n    cout << move << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#define N 3\n#define true 1\n#define false 0\n\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\nint limit;\nint t[N][N];\n\nvoid swap(int *x,int *y){\n  int tmp=*x;\n  *x=*y;\n  *y=tmp;\n  return ;\n}\n\nint getHeuristic(){\n  int i,j,sum=0,x;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n    if(t[i][j]==0)continue;\n    x=t[i][j]-1;\n    sum+=abs(x/N-i)+abs(x%N-j);\n    }\n  }\n  return sum;\n}\n\nint dfs(int depth,int prev,int py,int px){\n  int h=getHeuristic();\n  if(h==0)return true;\n  if(depth+h>limit)return false;\n  int i;\n  for(i=0;i<4;i++){\n    if(abs(i-prev)==2)continue;\n    int tx=px+dx[i],ty=py+dy[i];\n    if(tx<0||ty<0||tx>=N||ty>=N)continue;\n    swap(&t[ty][tx],&t[py][px]);\n    if(dfs(depth+1,i,ty,tx))return true;\n    swap(&t[ty][tx],&t[py][px]);\n  }\n  return false;\n}\n\nvoid isSolved(int py,int px){\n  for(limit=0;;limit++){\n    if(dfs(0,99,py,px)){\n      printf(\"%d\\n\",limit);\n      return ;\n    }\n  }\n}\n\nint main(){\n  int i,j,px,py;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&t[i][j]);\n      if(t[i][j]==0){\n        py=i;\n        px=j;\n      }\n    }\n  }\n  isSolved(py,px);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<deque>\n#include<queue>\n#include<map>\n#include<set>\n#define ll long long\n#define str string\n#define ld long double\n#define vec vector\n#define vll vec<ll>\n#define rep(i,a,b) for(ll i=a;i<b;i++)\n#define rrep(i,b,a) for(ll i=b;i>=a;i--)\n#define ALL(a) a.begin(),a.end()\n#define rALL(a) a.rbegin(),a.rend()\n#define kai \"\\n\"\n#define yuque priority_queue\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define mie min_element\n#define mae max_element\n#define tos to_string\n#define sep setprecision\n#define lob lower_bound\n#define upb upper_bound\n#define nep next_permutation\n#define MOD 1000000007ll\n#define MIN (1e-10)\n#define equal(a,b) (abs((a)-(b))<MIN)\n#define v2 ten\n#define chokusen senbun\n#define tenten senbun\n#define takaku vec<ten>\nusing namespace std;\nvoid solve();\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed;\n\tsolve();\n}\nstruct pea{\n\tll f,s;\n\tbool operator<(const pea &p)const{\n\t\treturn f!=p.f?f<p.f:s<p.s;\n\t};\n};\nstruct tri{\n\tll f,s,t;\n\tbool operator<(const tri &p)const{\n\t\tif(f!=p.f)return f<p.f;\n\t\tif(s!=p.s)return s<p.s;\n\t\treturn t<p.t;\n\t};\n};\nclass ten{\npublic:\n\tld x,y;\n\tten operator+(ten p){return{x+p.x,y+p.y};}\n\tten operator-(ten p){return{x-p.x,y-p.y};}\n\tten operator*(ld k){return{k*x,k*y};}\n\tten operator/(ld k){return{x/k,y/k};}\n\tld abs(){return sqrt(abs2());}\n\tld abs2(){return x*x+y*y;};\n\tbool operator<(const ten &p)const{return x!=p.x?x<p.x:y<p.y;};\n\tbool operator==(const ten &p)const{return (-MIN<x-p.x)&&(x-p.x<MIN)&&(-MIN<y-p.y)&&(y-p.y<MIN);};\n\tld naiseki(v2 b){return x*b.x+y*b.y;}\n\tld gaiseki(v2 b){return x*b.y-y*b.x;}\n};\nstruct senbun{ten p1,p2;};\nstruct en{ten o;ld r;};\n//幅優先探索(8パズル)\nll bfs(vll hajime){\n\tstruct pazzle{vll id;ll depth;};\n\tvll goal={1,2,3,4,5,6,7,8,0};\n\tmap<vll,bool> hantei;\n\tdeque<pazzle> p;\n\tp.pub({hajime,0});\n\twhile(!p.empty()){\n\t\tif(p[0].id==goal)return p[0].depth;\n\t\tll pos=find(ALL(p[0].id),0)-p[0].id.begin();\n\t\tif(pos%3!=2){\n\t\t\tswap(p[0].id[pos],p[0].id[pos+1]);\n\t\t\tif(!hantei[p[0].id]){\n\t\t\t\tp.pub({p[0].id,p[0].depth+1});\n\t\t\t\thantei[p[0].id]=true;\n\t\t\t}\n\t\t\tswap(p[0].id[pos],p[0].id[pos+1]);\n\t\t}\n\t\tif(pos%3!=0){\n\t\t\tswap(p[0].id[pos],p[0].id[pos-1]);\n\t\t\tif(!hantei[p[0].id]){\n\t\t\t\tp.pub({p[0].id,p[0].depth+1});\n\t\t\t\thantei[p[0].id]=true;\n\t\t\t}\n\t\t\tswap(p[0].id[pos],p[0].id[pos-1]);\n\t\t}\n\t\tif(pos>=3){\n\t\t\tswap(p[0].id[pos],p[0].id[pos-3]);\n\t\t\tif(!hantei[p[0].id]){\n\t\t\t\tp.pub({p[0].id,p[0].depth+1});\n\t\t\t\thantei[p[0].id]=true;\n\t\t\t}\n\t\t\tswap(p[0].id[pos],p[0].id[pos-3]);\n\t\t}\n\t\tif(pos<=5){\n\t\t\tswap(p[0].id[pos],p[0].id[pos+3]);\n\t\t\tif(!hantei[p[0].id]){\n\t\t\t\tp.pub({p[0].id,p[0].depth+1});\n\t\t\t\thantei[p[0].id]=true;\n\t\t\t}\n\t\t\tswap(p[0].id[pos],p[0].id[pos+3]);\n\t\t}\n\t\tp.pof();\n\t}\n}\nvoid solve(){\n\tvll a(9);\n\trep(i,0,9)cin>>a[i];\n\tcout<<bfs(a)<<kai;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\nusing namespace std;\n#define H 3\n#define W 3\n#define begin 1\n#define end 4\nstruct BOARD{\n        int board[10][10],y,x,count;\n        bool operator<(const BOARD &other)const{\n                for(int i=begin ; i<end ; i++ )\n                        for(int j=begin ; j<end ; j++ ){\n                                if(board[i][j]==other.board[i][j])\n                                        continue;\n                                return board[i][j]>other.board[i][j];\n                        }\n                return false;\n        }\n};\nmap <BOARD,bool> past;\nint direction[5]={-1,0,1,0,-1};\nbool check(BOARD now){\n        int s=1;\n        for(int i=begin ; i<end ; i++ ){\n                for(int j=begin ; j<end ; j++ ){\n                        if(now.board[i][j]==s){\n                                s++;\n                                s%=9;\n                        }else return false;\n                }\n        }\n}\nint main(){\n        BOARD board;\n        board.count=0;\n        for(int i=begin ; i<end ; i++ ){\n                for(int j=begin ; j<end ; j++ ){\n                        cin >> board.board[i][j] ;\n                        if(board.board[i][j]==0){\n                                board.y=i;\n                                board.x=j;\n                        }\n                }\n        }\n        queue<BOARD> circle;\n        circle.push(board);\n        int count=0;\n        while(circle.size()!=0){\n                board=circle.front();circle.pop();\n                if(board.y<1 || board.y>=4 )continue;\n                if(board.x<1 || board.x>=4 )continue;\n                past[board]=true;\n                if(check(board)){\n                        cout << board.count << endl;\n                        break;\n                }\n                for(int i=0 ; i<4 ; i++ ){\n                        int y=board.y+direction[i];\n                        int x=board.x+direction[i+1];\n                        swap(board.board[board.y][board.x],board.board[y][x]);\n                        swap(board.y,y);swap(board.x,x);\n                        board.count++;\n                        circle.push(board);\n                        board.count--;\n                        swap(board.board[board.y][board.x],board.board[y][x]);\n                        swap(board.y,y);swap(board.x,x);\n                }\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <regex>\n#include <cstdio>\n#include <cmath>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include  <cassert>\n#include <fstream>\n#include <codecvt>\n\nusing namespace std;\nusing ll = long long int;\nusing ullong = unsigned long long;\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define FOR(i, a, b)  for(int i = (a); i < (b) ; i++)\n#define pb push_back\n#define SORT(v,n) sort(v, v+n)\n#define ALL(x) (x).begin(),(x).end()\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define elif else if\n#define int ll\nconst int INF = (1LL << 32);\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nint dx[8] = { 1, 0, -1, 0, 1, -1, -1, 1 };\nint dy[8] = { 0, 1, 0, -1, 1, 1, -1, -1 };\n\n\nstatic const int N = 3;\nstatic const int N2 = 9;\n\nstruct Puzzle {\n\tint f[N2];\n\tint space;\n\tstring path;\n\n\tbool operator <(const Puzzle& p) const {\n\t\trep(i, N2) {\n\t\t\tif (p.f[i] == f[i]) continue;\n\t\t\treturn f[i] > p.f [i];\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstatic const char dir[4] = { 'u','l','d','r' };\n\n\nbool isTarget(Puzzle p) {\n\tfor (int i = 0; i < N2; i++) \n\t\tif (p.f[i] != i+1) return false;\n\n\treturn true;\n}\n\nstring bfs(Puzzle s) {\n\n\tstring path = \"\";\n\tqueue<Puzzle> Q;\n\tQ.push(s);\n\tmap<Puzzle, bool> V; \n\tV[s] = true;\n\n\twhile (!Q.empty()) {\n\t\tauto p = Q.front();\n\t\tQ.pop();\n\n\t\tif (isTarget(p)) return p.path;\n\t\t\n\t\tint sx = p.space / N;\n\t\tint sy = p.space % N;\n\n\t\trep(r, 4) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif (tx < 0 or ty < 0 or tx >= N or ty >= N) continue;\n\t\t\tauto v = p;\n\t\t\tswap(v.f[p.space], v.f[tx * N + ty]);\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (V[v] == false) {\n\t\t\t\tV[v] = true;\n\t\t\t\tv.path += dir[r];\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\";\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(true);\n\n\tPuzzle in;\n\n\trep(i, N2) {\n\t\tcin >> in.f[i];\n\t\tif (in.f[i] == 0) {\n\t\t\tin.space = i;\n\t\t\tin.f[i] = N2;\n\t\t}\n\t}\n\n\tcout << bfs(in).size() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE FlexibleContexts #-}\n\nmodule Main where\n\n-- import Debug.Trace\nimport Data.List\nimport qualified Data.Set as Set\nimport qualified Data.Sequence as Seq\nimport qualified Data.ByteString.Char8 as B\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Bits\nimport Data.Array\n-- import Data.Array.Unboxed\n-- import Data.Array.IO\nimport Data.Maybe\n-- import qualified Data.Map as M\nimport qualified Data.IntMap as M\n-- import Control.Monad.ST\n-- import Data.STRef\nimport Data.Ord\nimport Data.Functor\nimport Control.Applicative\nimport Control.Monad\nimport Text.Printf\n\nsize = 3\nmaxAdr = size*size -1\n\nsolver :: [[Int]] -> Int\nsolver lst = bfs start goalID where\n    bfs start goalID = iter ((Seq.singleton (start, generateID start, 0)), M.empty) where\n        iter (que, visited) = case Seq.viewr que of\n            Seq.EmptyR -> error \"No path found.\"\n            que Seq.:> path@(b, bId, d)\n                | bId == goalID -> d\n                | otherwise -> iter (insertPaths que visited (nextPaths path)) where\n                    insertPaths q v [] = (q, v)\n                    insertPaths q v (p@(_,x,_):ps) = insertPaths (p Seq.<| q) (M.insert x () visited) ps\n                    nextPaths path@(b, bId, d) = [(x, xId, d+1)| (x, xId) <- nextBoards, notVisited xId] where        \n                        notVisited x = M.notMember x visited\n                        boards = [swapAt (b !! q) b | q <- dest!p]\n                        nextBoards = [(x, generateID x)| x <- boards]\n                        p = fromJust $ elemIndex 0 b\n    goalID= 123456780\n    start = concat lst\n    dest  = listArray (0, maxAdr) [[1,3],[0,2,4],[1,5],[0,4,6],[1,3,5,7],[2,4,8],[3,7],[4,6,8],[5,7]] \n    generateID board = foldl' (\\b a-> 10*b+a) 0 board\n\nswapAt v = iter where\n    iter [] = []\n    iter (x:xs)\n        | x == 0 = v:iter xs\n        | x == v = 0:iter xs\n        | otherwise = x:iter xs\n\nreadIntLn:: IO Int\nreadIntLn = (fst . fromJust . B.readInt) <$> B.getLine\n\nreadIntList:: IO [Int]\nreadIntList = map (fst . fromJust . B.readInt) . B.words <$> B.getLine\n\nmain :: IO() \nmain = do\n    l <- replicateM size readIntList\n    print $ solver l\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE FlexibleContexts #-}\n\nmodule Main where\n\nimport Debug.Trace\nimport Data.List\nimport qualified Data.Set as Set\nimport qualified Data.Sequence as Seq\nimport qualified Data.ByteString.Char8 as B\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Bits\nimport Data.Array\n-- import Data.Array.Unboxed\n-- import Data.Array.IO\nimport Data.Maybe\n-- import qualified Data.Map as M\nimport qualified Data.IntMap as M\n-- import Control.Monad.ST\n-- import Data.STRef\nimport Data.Ord\nimport Data.Functor\nimport Control.Applicative\nimport Control.Monad\nimport Text.Printf\n\nsize = 3 \nsqSize = size*size\nmaxAdr = sqSize -1\nmask = 0xF\nshiftSize = 4\nshiftTimes= 16\n\nsolver :: [[Int]] -> Int\nsolver lst\n    | start == goal = 0\n    | otherwise = iter (initialQueue, initialVisited) where\n        iter (que, visited) = case Seq.viewr que of\n            Seq.EmptyR -> error \"No path found.\"\n            que Seq.:> path@(board, distance, forward) -> case next path visited of\n                (_, Just d)  -> distance + d +1\n                (nextPaths, Nothing) -> iter (insertPaths que visited nextPaths) where\n                    insertPaths q v [] = (q, v)\n                    insertPaths q v (p@(x, d, f):ps) = insertPaths insertQue insertVisited ps where\n                        insertQue = p Seq.<| q\n                        insertVisited = M.insert x (d, f) v\n        next path@(board, distance, forward) visited = iter [] Nothing nextBoards where\n            iter ac af [] = (ac, af)\n            iter ac af (x:xs) = case M.lookup x visited of\n                Nothing -> iter ((x, distance+1, forward):ac) af xs\n                Just (d', f') -> if forward == f' then iter ac af xs else (ac, Just d')\n            boards = [swapWith (valueAt p board) board | p <- dest!(searchZero board)]\n            nextBoards = [x| x <- boards]\n\n        initialQueue = (goal, 0, False) Seq.<| (Seq.singleton (start, 0, True))\n        initialVisited = M.insert goal (0, False) $ M.singleton start (0, True)\n        goal    = toBits [1,2,3,4,5,6,7,8,0]\n        start   = toBits $ concat lst\n        dest    = listArray (0, maxAdr) [[1,3],[0,2,4],[1,5],[0,4,6],[1,3,5,7],[2,4,8],[3,7],[4,6,8],[5,7]]\n        toBits = foldl' (\\b a-> shiftL b shiftSize .|. a) 0\n        valueAt i w = mask .&. shiftR w (shiftSize*i)\n\nsearchZero :: Int -> Int\nsearchZero = iter 0 where\n    iter c w = case mask .&. w of \n        hb  | hb == 0 -> c\n            | otherwise -> iter (c+1) (rotateR w shiftSize)\n\nswapWith :: Int -> Int -> Int\nswapWith v = iter sqSize where\n    iter 0 w = rotateR w (shiftSize*(shiftTimes-sqSize))\n    iter c w = iter (c-1) $ rotateR (case mask .&. w of\n        hb  | hb == 0 -> w .|. v\n            | hb == v -> w `xor` v\n            | otherwise -> w) shiftSize\n\nreadIntLn:: IO Int\nreadIntLn = (fst . fromJust . B.readInt) <$> B.getLine\n\nreadIntList:: IO [Int]\nreadIntList = map (fst . fromJust . B.readInt) . B.words <$> B.getLine\n\nmain :: IO() \nmain = do\n    l <- replicateM size readIntList\n    print $ solver l\n\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Arrow\nimport Data.Array.Unboxed as U\nimport Data.List\nimport Data.Maybe (fromJust)\nimport Control.Monad\n\nsize = 3 :: Int\n\ntype Field = U.UArray Loc Int\ntype Loc = (Int,Int)\n\ndata Dir = Up | Rt | Dw | Lf deriving (Show, Enum, Eq)\ntoVect :: Dir -> (Int,Int)\ntoVect Up = (-1,0)\ntoVect Rt = (0,1)\ntoVect Dw = (1,0)\ntoVect Lf = (0,-1)\n\ndata Puzzle = Puzzle {\n            _field :: Field,\n            _zloc :: Loc\n}\n\nfromList :: [Int] -> Puzzle\nfromList xs = let\n    f = listArray ((0,0),(size-1,size-1)) xs\n    in\n        Puzzle {\n               _field = f,\n               _zloc = (`divMod` size) .  head  $ 0 `elemIndices` xs\n               }\n\n\ninstance Show Puzzle where\n    show = showTable . _field\n\nshowTable :: Field -> String\nshowTable = unlines . map (tail . concatMap ('|':)) . cutEvery size\n    . map show . elems\n\ncutEvery :: Int -> [a] -> [[a]]\ncutEvery _ [] = []\ncutEvery n xs = let (pre,post) = splitAt n xs\n                    in pre : cutEvery n post\n\nmovableDirs :: Puzzle -> [Dir]\nmovableDirs p = let\n    (y,x) = _zloc p\n    in\n        filter (\n               case x of\n                   0 -> (/= Lf)\n                   2 -> (/= Rt)\n                   _ -> const True\n              )\n        . filter (\n                 case y of\n                    0 -> (/= Up)\n                    2 -> (/= Dw)\n                    _ -> const True\n                ) $ enumFrom Up\n\nmove :: Puzzle -> Dir -> Puzzle\nmove p d = let\n    next = toVect d `tupAdd` _zloc p\n    nexp = _field p // [(next,0), (_zloc p, _field p ! next)]\n    in\n        p {\n          _field = nexp,\n          _zloc = next\n        }\n\ntupAdd :: (Num a, Num b) => (a,b) -> (a,b) -> (a,b)\ntupAdd (x,y) = (+x) *** (+y)\n\nnextPossibles :: Puzzle -> [Puzzle]\nnextPossibles p = map (move p) (movableDirs p)\n\nisComplete :: Puzzle -> Bool\nisComplete = (== [1,2,3,4,5,6,7,8,0]) . elems . _field\n\ndata Phase = Phase {_puz :: Puzzle, _actualCost :: Int}\ninstance Show Phase where\n    show p = unlines [\"Phase :\", show (_puz p), \"cost\" ++ show (_actualCost p)]\nnextPhases :: Phase -> [Phase]\nnextPhases ph = let\n    p = _puz ph\n    c = _actualCost ph in\n        map (\\pz -> Phase pz (c+1)) . nextPossibles $ p\n\nmanHattan :: Puzzle -> Int\nmanHattan = sum . map (\\((x0,y0),e) -> let (x1,y1) = (e-1) `divMod` 3\n                                   in\n                                      abs (x1-x0) + abs (y1-y0))\n                                      . filter ((/=0) . snd) . assocs . _field\n\ntype Estimator = Puzzle -> Int\n\n\nidaStar :: Estimator -> Puzzle -> Maybe (Phase, Int)\nidaStar f p = let\n    iter :: Int -> Int -> [Phase] -> Maybe (Phase,Int)\n    iter steps depth [] = iter steps (depth+1) [Phase p 0]\n    iter steps depth ss =\n        case find (isComplete . _puz) next of\n            Just pu -> Just (pu,steps)\n            Nothing -> iter (steps+1) depth next\n        where\n            next = filter ((<= depth) . cost f) . concatMap nextPhases $ ss\n    in\n        iter 0 1 [Phase p 0]\n\ncost :: Estimator -> Phase -> Int\ncost f p = _actualCost p + f (_puz p)\n\nmain = replicateM 3 getLine >>=\n        print . _actualCost . fst . fromJust . idaStar manHattan . fromList\n            . map read . words . unlines"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE FlexibleContexts #-}\n\nmodule Main where\n\n-- import Debug.Trace\nimport Data.List\nimport qualified Data.Set as Set\nimport qualified Data.Sequence as Seq\nimport qualified Data.ByteString.Char8 as B\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Bits\nimport Data.Array\n-- import Data.Array.Unboxed\n-- import Data.Array.IO\nimport Data.Maybe\n-- import qualified Data.Map as M\nimport qualified Data.IntMap as M\n-- import Control.Monad.ST\n-- import Data.STRef\nimport Data.Ord\nimport Data.Functor\nimport Control.Applicative\nimport Control.Monad\nimport Text.Printf\n\nsize = 3\nmaxAdr = size*size -1\n\nsolver :: [[Int]] -> Int\nsolver lst = bfs start goalID where\n    bfs start goalID = iter ((Seq.singleton (start, generateID start, 0)), M.empty) where\n        iter (que, visited) = case Seq.viewr que of\n            Seq.EmptyR -> error \"No path found.\"\n            que Seq.:> path@(b, bId, d)\n                | bId == goalID -> d\n                | otherwise -> iter (insertPaths que visited (nextPaths path)) where\n                    insertPaths q v [] = (q, v)\n                    insertPaths q v (p@(_,x,_):ps) = insertPaths (p Seq.<| q) (M.insert x () visited) ps\n                    nextPaths path@(b, bId, d) = [(x, xId, d+1)| (x, xId) <- nextBoards, notVisited xId] where        \n                        notVisited x = M.notMember x visited\n                        boards = [swapAt (b !! q) b | q <- dest!p]\n                        nextBoards = [(x, generateID x)| x <- boards]\n                        p = fromJust $ elemIndex 0 b\n    goalID= generateID [1,2,3,4,5,6,7,8,0]\n    start = concat lst\n    dest  = listArray (0, maxAdr) [[1,3],[0,2,4],[1,5],[0,4,6],[1,3,5,7],[2,4,8],[3,7],[4,6,8],[5,7]] \n    generateID board = foldl' (\\b a-> shiftL b 4 .|. a) 0 board\n\nswapAt :: Int -> [Int] -> [Int]\nswapAt v = foldr (\\a b -> case a of\n    _   | a == 0 -> v:b\n        | a == v -> 0:b\n        | otherwise -> a:b\n     ) [] \n\nreadIntLn:: IO Int\nreadIntLn = (fst . fromJust . B.readInt) <$> B.getLine\n\nreadIntList:: IO [Int]\nreadIntList = map (fst . fromJust . B.readInt) . B.words <$> B.getLine\n\nmain :: IO() \nmain = do\n    l <- replicateM size readIntList\n    print $ solver l\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE FlexibleContexts #-}\n\nmodule Main where\n\nimport Debug.Trace\nimport Data.List\nimport qualified Data.Set as Set\nimport qualified Data.Sequence as Seq\nimport qualified Data.ByteString.Char8 as B\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Bits\nimport Data.Array\n-- import Data.Array.Unboxed\n-- import Data.Array.IO\nimport Data.Maybe\n-- import qualified Data.Map as M\nimport qualified Data.IntMap as M\n-- import Control.Monad.ST\n-- import Data.STRef\nimport Data.Ord\nimport Data.Functor\nimport Control.Applicative\nimport Control.Monad\nimport Text.Printf\n\nsize = 3 \nsqSize = size*size\nmaxAdr = sqSize -1\nmask = 0xF\nshiftSize = 4\nshiftTimes= 16\n\nsolver :: [[Int]] -> Int\nsolver lst = bfs start goal where\n    bfs start goal = iter (initialQueue, initialVisited) where\n        iter (que, visited) = case Seq.viewr que of\n            Seq.EmptyR -> error \"No path found.\"\n            que Seq.:> path@(board, distance, forward) -> case next path visited of\n                (_, Just d)  -> distance + d +1\n                (nextPaths, Nothing) -> iter (insertPaths que visited nextPaths) where\n                    insertPaths q v [] = (q, v)\n                    insertPaths q v (p@(x, d, f):ps) = insertPaths insertQue insertVisited ps where\n                        insertQue = p Seq.<| q\n                        insertVisited = M.insert x (d, f) v\n        next path@(board, distance, forward) visited = iter [] Nothing nextBoards where\n            iter ac af [] = (ac, af)\n            iter ac af (x:xs) = case M.lookup x visited of\n                Nothing -> iter ((x, distance+1, forward):ac) af xs\n                Just (d', f') -> if forward == f' then iter ac af xs else (ac, Just d')\n            boards = [swapWith (valueAt p board) board | p <- dest!(searchZero board)]\n            nextBoards = [x| x <- boards]\n\n    initialQueue = (goal, 0, False) Seq.<| (Seq.singleton (start, 0, True))\n    initialVisited = M.insert goal (0, False) $ M.singleton start (0, True)\n    goal    = toBits [1,2,3,4,5,6,7,8,0]\n    start   = toBits $ concat lst\n    dest    = listArray (0, maxAdr) [[1,3],[0,2,4],[1,5],[0,4,6],[1,3,5,7],[2,4,8],[3,7],[4,6,8],[5,7]]\n    toBits = foldl' (\\b a-> shiftL b shiftSize .|. a) 0\n    valueAt i w = mask .&. shiftR w (shiftSize*i)\n\nsearchZero :: Int -> Int\nsearchZero = iter 0 where\n    iter c w = case mask .&. w of \n        hb  | hb == 0 -> c\n            | otherwise -> iter (c+1) (rotateR w shiftSize)\n\nswapWith :: Int -> Int -> Int\nswapWith v = iter sqSize where\n    iter 0 w = rotateR w (shiftSize*(shiftTimes-sqSize))\n    iter c w = iter (c-1) $ rotateR (case mask .&. w of\n        hb  | hb == 0 -> w .|. v\n            | hb == v -> w `xor` v\n            | otherwise -> w) shiftSize\n\nreadIntLn:: IO Int\nreadIntLn = (fst . fromJust . B.readInt) <$> B.getLine\n\nreadIntList:: IO [Int]\nreadIntList = map (fst . fromJust . B.readInt) . B.words <$> B.getLine\n\nmain :: IO() \nmain = do\n    l <- replicateM size readIntList\n    print $ solver l\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE FlexibleContexts #-}\n \nmodule Main where\n \nimport Debug.Trace\nimport Data.List\nimport qualified Data.Set as Set\nimport qualified Data.Sequence as Seq\nimport qualified Data.ByteString.Char8 as B\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Bits\nimport Data.Array\n-- import Data.Array.Unboxed\n-- import Data.Array.IO\nimport Data.Maybe\n-- import qualified Data.Map as M\nimport qualified Data.IntMap as M\n-- import Control.Monad.ST\n-- import Data.STRef\nimport Data.Ord\nimport Data.Functor\nimport Control.Applicative\nimport Control.Monad\nimport Text.Printf\n \nsize = 3 \nsqSize = size*size\nmaxAdr = sqSize -1\nmask = 0xF\nshiftSize = 4\nshiftTimes= 16\n \nsolver :: [[Int]] -> Int\nsolver lst\n    | start == goal = 0\n    | otherwise = iter (initialQueue, initialVisited) where\n        iter (que, visited) = case Seq.viewr que of\n            Seq.EmptyR -> error \"No path found.\"\n            que Seq.:> path@(board, distance, forward) -> case next path visited of\n                (_, Just d)  -> distance + d +1\n                (nextPaths, Nothing) -> iter (insertPaths que visited nextPaths) where\n                    insertPaths q v [] = (q, v)\n                    insertPaths q v (p@(x, d, f):ps) = insertPaths insertQue insertVisited ps where\n                        insertQue = p Seq.<| q\n                        insertVisited = M.insert x (d, f) v\n        next path@(board, distance, forward) visited = iter [] Nothing nextBoards where\n            iter ac af [] = (ac, af)\n            iter ac af (x:xs) = case M.lookup x visited of\n                Nothing -> iter ((x, distance+1, forward):ac) af xs\n                Just (d', f') -> if forward == f' then iter ac af xs else (ac, Just d')\n            nextBoards = [swapWith (valueAt p board) board | p <- dest!(searchZero board)]\n \n        initialQueue = (goal, 0, False) Seq.<| (Seq.singleton (start, 0, True))\n        initialVisited = M.insert goal (0, False) $ M.singleton start (0, True)\n        goal    = toBits [1,2,3,4,5,6,7,8,0]\n        start   = toBits $ concat lst\n        dest    = listArray (0, maxAdr) [[1,3],[0,2,4],[1,5],[0,4,6],[1,3,5,7],[2,4,8],[3,7],[4,6,8],[5,7]]\n        toBits = foldl' (\\b a-> shiftL b shiftSize .|. a) 0\n        valueAt i w = mask .&. shiftR w (shiftSize*i)\n \nsearchZero :: Int -> Int\nsearchZero = iter 0 where\n    iter c w = case mask .&. w of \n        hb  | hb == 0 -> c\n            | otherwise -> iter (c+1) (rotateR w shiftSize)\n \nswapWith :: Int -> Int -> Int\nswapWith v = iter sqSize where\n    iter 0 w = rotateR w (shiftSize*(shiftTimes-sqSize))\n    iter c w = iter (c-1) $ rotateR (case mask .&. w of\n        hb  | hb == 0 -> w .|. v\n            | hb == v -> w `xor` v\n            | otherwise -> w) shiftSize\n \nreadIntLn:: IO Int\nreadIntLn = (fst . fromJust . B.readInt) <$> B.getLine\n \nreadIntList:: IO [Int]\nreadIntList = map (fst . fromJust . B.readInt) . B.words <$> B.getLine\n \nmain :: IO() \nmain = do\n    l <- replicateM size readIntList\n    print $ solver l\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n\nextern void down_0(void);\nextern void up_0(void);\nextern void right_0(void);\nextern void left_0(void);\n\nint cnt,num = 0;\nint val[Total] ={};\n\nint main( void )\n{\n\n    int kai[Total] ={};\n    \n    int i,j = 0;\n    int finish = 0;\n    int num_0,num_1 = 0;\n    int target=0;\n    \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n    \n    while(finish==0)\n    {\n        for(i=j; i<j; i++)\n        {\n            if(val[i]=target)\n            {\n                num_1=i;\n            }\n        }\n        \n        \n        left_0();\n        \n        down_0();\n        \n        right_0();\n        \n        down_0();\n        \n        finish=1;\n        for(i=0; i<(Total-1); i++)\n        {\n            if(val[i] != (i+1))\n            {\n                finish = 0;\n                break;\n            }\n            \n        }\n    }\n    \n    printf(\"%d\\n\",cnt);\n\n    return 0;\n}\n\nvoid down_0()\n{\n    val[num] = val[num+3];\n    val[num +3] = 0;\n    num = num + 3;\n    cnt = cnt + 1;\n}\n\nvoid up_0()\n{\n    val[num] = val[num-3];\n    val[num -3] = 0;\n    num = num - 3;\n    cnt = cnt + 1;\n}\n\nvoid right_0()\n{\n    val[num] = val[num +1];\n    val[num +1] = 0;\n    num = num + 1;\n    cnt = cnt + 1;\n}\n\nvoid left_0()\n{\n//    printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);\n    \n    val[num] = val[num -1];\n    val[num -1] = 0;\n    num = num - 1;\n    cnt = cnt + 1;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#define Size 9\n#define Queue_size 102400\n#define Hash_size 102400\n#define queue_next(i) (((i) + 1) % Queue_size)\nstruct hash_table {\n  long data;\n  struct hash_table *next;\n};\nstruct hash_table *hash[Hash_size];\nint swap_upper(int*, int*);\nint swap_lower(int*, int*);\nint swap_left(int*, int*);\nint swap_right(int*, int*);\nlong board_val(int*);\nvoid val_board(long, int*);\nvoid hash_insert(long);\nint hash_search(long);\nint Bfs(int*, int*);\nint main(void)\n{\n  int i, result, init[Size], goal[Size] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\n  for (i = 0; i < Size; i++) scanf(\"%d\", &init[i]);\n  for (i = 0; i < Hash_size; i++) hash[i] = NULL;\n  printf(\"%d\\n\", Bfs(init, goal));\n}\nint swap_upper(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if (!(pos / e)) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos - e];\n    next[pos - e] = board[pos];\n  }\n  return 1;\n}\nint swap_lower(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if ((pos / e) == e - 1) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos + e];\n    next[pos + e] = board[pos];\n  }\n  return 1;\n}\nint swap_left(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if (!(pos % e)) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos - 1];\n    next[pos - 1] = board[pos];\n  }\n  return 1;\n}\nint swap_right(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if ((pos % e) == e - 1) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos + 1];\n    next[pos + 1] = board[pos];\n  }\n  return 1;\n}\nlong board_val(int *board)\n{\n  int i, digit = 1;\n  long val = 0;\n  for (i = 0; i < Size; i++) {\n    val += board[Size - 1 - i] * digit;\n    digit *= 10;\n  }\n  return val;\n}\nvoid val_board(long val, int *board)\n{\n  int i, digit = 1;\n  for (i = 0; i < Size; i++) {\n    board[Size - 1 - i] = (val / digit) % 10;\n    digit *= 10;\n  }\n}\nvoid hash_insert(long val)\n{\n  struct hash_table *p = (struct hash_table*)malloc(sizeof(struct hash_table));\n  p->data = val;\n  p->next = hash[val % Hash_size];\n  hash[val % Hash_size] = p;\n}\nint hash_search(long val)\n{\n  struct hash_table *n;\n  for (n = hash[val % Hash_size]; n != NULL; n = n->next) {\n      if (val == n->data) return 1;\n  }\n  return 0;\n}\nint Bfs(int *init, int *goal)\n{\n  int depth = 0, ptr_front = 0, ptr_back = 0;\n  long queue[Queue_size][2];\n  queue[ptr_back][0] = board_val(init);\n  queue[ptr_back][1] = depth;\n  ptr_back = queue_next(ptr_back);\n  if (!memcmp(init, goal, sizeof(int) * Size)) return depth;\n  while (ptr_front != ptr_back) {\n    int curr[Size], next[Size];\n    long val;\n    val = queue[ptr_front][0];\n    val_board(val, curr);\n    depth = queue[ptr_front][1];\n    ptr_front = queue_next(ptr_front);\n    depth++;\n    hash_insert(val);\n    if (swap_upper(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n    if (swap_lower(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n    if (swap_left(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n    if (swap_right(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n  \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n#define TryCnt 45\n \nextern inline void down_0(void);    // 0 を下に移動\nextern inline void up_0(void);      // 0 を上に移動\nextern inline void right_0(void);   // 0 を右に移動\nextern inline void left_0(void);    // 0 を左に移動\n \nextern unsigned char serch(unsigned char x, unsigned char y, unsigned char MaxCnt, unsigned char pre);\n\nint num = 0;            // 0 の位置を示す\nint val[Total] = {};    // 入力数値を格納\n \n \nint main( void )\n{\n    unsigned int i = 0;\n    unsigned int x,y = 0;\n     \n    // 数値の取り込み\n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        \n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n     \n    // 0 が右下に行くために 動かさないといけない回数\n    x = tate - (num / yoko) -1;\n    y = yoko - (num % yoko) -1;\n    \n    // 解を探す\n    for(i=0; i<TryCnt; i++)\n    {\n        if(serch(x,y,i,4) == 1)\n        {\n            // 解答を表示\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n     \n    return 0;\n}\n \nunsigned char serch(unsigned char x, unsigned char y, unsigned char MaxCnt, unsigned char pre)\n{\n    unsigned char result;\n    unsigned char i=0;\n    \n    // 右下に戻れないので打ち切り\n    if(MaxCnt < (x + y))\n    {\n        return 0;\n    }\n     \n    // 最大数でゴールと一致しているか確認\n    if(0 == MaxCnt)\n    {\n        for(i=0; i<Total-1; i++)\n        {\n            if(val[i] != (i+1))\n            {\n                // ゴールと不一致\n                return 0;\n            }\n        }\n        // ゴールと一致！！\n        return 1;\n    }\n    \n    // 0 の移動\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n         \n        switch(i)\n        {\n            // 上に移動\n            case 0:\n                if( (x > 0) && (pre != 3) )\n                {\n                    down_0();\n                     \n                    result = serch(x-1, y, MaxCnt-1, 0);\n                     \n                    up_0();\n                }\n                break;\n                 \n            // 右に移動\n            case 1:\n                if( (y > 0) && (pre != 2) )\n                {\n                    right_0();\n                     \n                    result = serch(x, y-1, MaxCnt-1, 1);\n                     \n                    left_0();\n                }\n                break;\n                \n            // 左に移動\n            case 2:\n                if( (y < yoko -1 ) && (pre != 1) )\n                {\n                    left_0();\n                     \n                    result = serch(x, y+1, MaxCnt-1, 2);\n                     \n                    right_0();\n                }\n                break;\n                \n            // 下に移動\n            case 3:\n                if( (x < tate -1 ) && (pre != 0) )\n                {\n                    up_0();\n                     \n                    result = serch(x+1, y, MaxCnt-1, 3);\n                     \n                    down_0();\n                }\n                break;\n                 \n            default:\n                // 何もしない。\n                break;\n        }\n         \n        if(result)\n        {\n            return 1;\n        }\n    }\n     \n    return 0;\n}\n \n \ninline void down_0()\n{\n    val[num] = val[num + yoko];\n    num = num + yoko;\n}\n  \ninline void up_0()\n{\n    val[num] = val[num - yoko];\n    num = num - yoko;\n}\n  \ninline void right_0()\n{\n    val[num] = val[num +1];\n    num = num + 1;\n}\n  \ninline void left_0()\n{\n    val[num] = val[num -1];\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint kei(int,int,int,int);\nint c[9];\n\nint main(){\n\tint i,a;\n\tfor(i=0;i<9;i++){\n\t\tscanf(\"%d\",&c[i]);\n\t\tif(c[i]==0)a=i;\n\t}\n\tprintf(\"%d\\n\",kei(a,0,10,1));\n\treturn 0;\n}\n\nint kei(int a,int co,int b,int e){\n\tint min=999,sum=0,i,m;\n\tif((e==co || b==10) && a==8){\t\n\t\tfor(i=0;i<8;i++){\n\t\t\tif(c[i]!=i+1){\n\t\t\t\tsum++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(sum==0)return co;\n\t}\n\twhile(co<e){\n\t\n\t\tif((a+1)%3!=0 && b!=a+1){\n\t\t\tm=c[a+1];\n\t\t\tc[a+1]=c[a];\n\t\t\tc[a]=m;\n\t\t\tm=kei(a+1,co+1,a,e);\n\t\t\tif(min>m){\n\t\t\t\tmin=m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm=c[a];\n\t\t\tc[a]=c[a+1];\n\t\t\tc[a+1]=m;\n\t\t}\n\t\tif((a-1)%3!=2 && a!=0 && b!=a-1){\n\t\t\tm=c[a];\n\t\t\tc[a]=c[a-1];\n\t\t\tc[a-1]=m;\n\t\t\tm=kei(a-1,co+1,a,e);\n\t\t\tif(min>m){\n\t\t\t\tmin=m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm=c[a];\n\t\t\tc[a]=c[a-1];\n\t\t\tc[a-1]=m;\n\t\t}\n\t\tif(a-3>=0 && b!=a-3){\n\t\t\tm=c[a];\n\t\t\tc[a]=c[a-3];\n\t\t\tc[a-3]=m;\n\t\t\tm=kei(a-3,co+1,a,e);\n\t\t\tif(min>m){\n\t\t\t\tmin=m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm=c[a];\n\t\t\tc[a]=c[a-3];\n\t\t\tc[a-3]=m;\n\t\t}\n\t\tif(a+3<9 && b!=a+3){\n\t\t\tm=c[a];\n\t\t\tc[a]=c[a+3];\n\t\t\tc[a+3]=m;\n\t\t\tm=kei(a+3,co+1,a,e);\n\t\t\tif(min>m){\n\t\t\t\tmin=m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm=c[a];\n\t\t\tc[a]=c[a+3];\n\t\t\tc[a+3]=m;\n\t\t}\n\t\tif(b==10)e++;\t\t\n\t\telse return min;\n\t}\n\treturn min;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint puzz[3][3];\nint copy[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n \nvoid empty(int *,int *);\nint dfs(int,int,int,int,const int);\nint cal();\nvoid swap(int *,int *);\n\nint main(){\n  int i,j,ans,x,y,l;\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++)\n      scanf(\"%d\", &puzz[i][j]);\n\n\n  empty(&x,&y);\n    for(l=0; l<100; l++) {\n        //copy\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) copy[i][j] = puzz[i][j];\n        }\n         \n        //dfs\n        ans = dfs(x,y,-1,0,l);\n        if(ans!=-1) {\n            printf(\"%d\\n\",ans);\n            break;\n        }\n         \n        //copy\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) puzz[i][j] = copy[i][j];\n        }\n         \n        //error\n        ans = -1;\n        if(l==99) printf(\"%d\\n\",ans);\n    }\n\n\n  return 0;\n} \n \nvoid empty(int *x,int *y) {\n    int i,j;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) {\n            if(!puzz[i][j]) {\n                *x = j;\n                *y = i;\n                return;\n            }\n        }\n    }\n}\n \n \nvoid swap(int *a,int *b) {\n    int tmp;\n     \n    tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n \n \nint cal() {\n    int i,a,sum=0;\n     \n    for(i=0; i<9; i++) {\n        a = puzz[i/3][i%3];\n        if(a) {\n            a--;\n            sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n        }\n    }\n     \n    return sum;\n}\n \n \nint dfs(int x,int y,int p,int dep,const int lim) {\n    int i,h,nx,ny,res;\n     \n    h = cal();\n    if(h==0) return dep;\n    if(dep+h>lim) return -1;\n     \n    for(i=0; i<4; i++) {\n        nx = x+dx[i];\n        ny = y+dy[i];\n         \n        if(~p && i==(p+2)%4) continue;\n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n         \n        swap(&puzz[y][x],&puzz[ny][nx]);\n        res = dfs(nx,ny,i,dep+1,lim);\n        if(~res) return res;\n         \n        swap(&puzz[y][x],&puzz[ny][nx]);\n    }\n     \n    return -1;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define N 3\n#define N2 9\n#define NMAX 500001\n\nint head = 0,tail = 0;\nint V[NMAX];\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nstruct Puzz{\n  int f[N2];\n  int space;\n  int path;\n};\n\nstruct Puzz Q[NMAX];\n\nvoid enqueue(struct Puzz x){\n  \n  int next = (tail + 1) % NMAX;\n  Q[tail] = x;\n  tail = next;\n}\n\nstruct Puzz dequeue(void){\n  struct Puzz temp;\n  temp = Q[head];\n  head = (head + 1) % NMAX;\n  return temp;\n}\nint _Sort(struct Puzz x){\n  int i,j,key,cnt,n = 0;\n\n  for(i = 0,key = 1;i < N2;key *= ++i){\n    for(j = 0,cnt = 0;j < i;j++){\n      if(x.f[j] < x.f[i]){\n\tcnt++;\n      }\n    }\n    n += cnt * key;\n  }\n  return n;\n}\n\nint isTarget(struct Puzz x){\n  int i;\n\n  for(i = 0;i < N2;i++){\n    if(x.f[i] != (i + 1)){\n      return 0;\n    }\n  }\n  return 1;\n}\n\nint bfs(struct Puzz s){\n  int r,sx,sy,tx,ty,temp;\n  struct Puzz u,v;\n\n  s.path = 0;\n  enqueue(s);\n  V[_Sort(s)] = 1;\n\n  while(head != tail){\n    u = dequeue();\n    if(isTarget(u) == 1){\n      return u.path;\n    }\n    sx = u.space / N;\n    sy = u.space % N;\n    for(r = 0;r < 4;r++){\n      tx = sx + dx[r];\n      ty = sy + dy[r];\n      if(tx < 0 || ty < 0|| tx >= N || ty >= N){\n\tcontinue;\n      }\n      v = u;\n      temp = v.f[u.space];\n      v.f[u.space] = v.f[tx * N + ty];\n      v.f[tx * N + ty] = temp;\n      v.space = tx * N + ty;\n      if(V[_Sort(v)] != 1){\n\tV[_Sort(v)] = 1;\n\tv.path++;\n\tenqueue(v);\n      }\n    }\n  }\n\n  return -1;\n}\n\nint main(void){\n\n  int i,ans;\n  struct Puzz in;\n\n  for(i = 0;i < N2;i++){\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n\n  ans = bfs(in);\n  printf(\"%d\\n\",ans);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n  #include <stdlib.h>\n  int puzle[3][3];\n  int tmp[3][3];\n  int d1[4]={0,1,0,-1};\n  int d2[4]={1,0,-1,0};\n \n  void empty(int *x,int *y){\n    int i,j;\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n        if(!puzle[i][j]){\n    *x=j;\n    *y=i;\n    return;\n        }\n      }\n    }\n  }\n \n  void swap(int *a,int *b){\n    int tmp=*a;\n    *a=*b;\n    *b=tmp;\n  }\n \n  int cal(){\n    int a,i,sum=0;\n    for(i=0;i<9;i++){\n      a=puzle[i/3][i%3];\n      if(a){\n        a--;\n        sum += abs(i/3-a/3) + abs(i%3-a%3);\n      }\n    }\n    return sum;\n  }\n \n  int dfs(int x,int y,int p,int dep,const int lim){\n    int i,h,n1,n2,res;\n    h=cal();\n    if(h==0){\n      return dep;\n    }\n    if(dep+h > lim){\n      return -1;\n    }\n    for(i=0;i<4;++i){\n      n1=x+d1[i];\n      n2=y+d2[i];\n \n      if(~p && i==(p+2)%4)\n        continue;\n      if(!(0 <= n1 && n1 < 3 && 0 <= n2 && n2 < 3))\n        continue;\n      swap(&puzle[y][x],&puzle[n2][n1]);\n      res=dfs(n1,n2,i,dep+1,lim);\n \n      if(~res){\n        return res;\n      }\n      swap(&puzle[y][x],&puzle[n2][n1]);\n    }\n    return -1;\n  }\n \n  int main(){\n    int ans,x,y,l,i,j;\n \n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n        scanf(\"%d\",&puzle[i][j]);\n      }\n    }\n    empty(&x,&y);\n    for(l=0;l<100;l++){\n      for(i=0;i<3;i++){\n        for(j=0;j<3;j++){\n    tmp[i][j]=puzle[i][j];\n      }\n    }\n      ans=dfs(x,y,-1,0,l);\n      if(ans!=-1){\n        printf(\"%d\\n\",ans);\n        break;\n      }\n      for(i=0;i<3;i++){\n        for(j=0;j<3;j++){\n    puzle[i][j]=tmp[i][j];\n      }\n      }\n      ans=-1;\n      if(l==99){\n        printf(\"%d\\n\",ans);\n    }\n    }\n    return 0;\n  }\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n  char b[10];\n  int step;\n} Board;\n\nint qlen=400000;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nconst Motion motion[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\n\nint main()\n{\n  int i, k, n;\n  int qhead=0;\n  int qtail=0;\n  Board board;\n  fscanf(stdin, \"%c %c %c\\n\", &board.b[0], &board.b[1], &board.b[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board.b[3], &board.b[4], &board.b[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board.b[6], &board.b[7], &board.b[8]);\n  board.b[9]=0;\n  short int *used = (short int*)malloc(sizeof(short int)*87654321);\n  for (i=0; i<87654321; i++) used[i]=0;\n  Board *Q = (Board*)malloc(sizeof(Board)*qlen);\n  board.step=0;\n  Q[qhead++] = board;\n  \n  while (qhead>qtail) {\n    board = Q[qtail++ %qlen];\n    \n    if (strncmp(board.b, \"123456780\", 8)==0)   break;\n\n    k=board.b[7];\n    n=10;\n    for (i=1; i<8; i++) {\n      k += (board.b[7-i]-'0')*n;\n      n*=10;\n    }\n    \n    if ((used[k] & (1<<(board.b[8]-'0')))==(1<<(board.b[8]-'0'))) continue;\n    used[k] |= (1<<(board.b[8]-'0'));\n    \n    int space = (int)(strchr(board.b, '0')-board.b);    \n    for (i=0; motion[space][i].pos>=0; i++) {\n      Board b = board;\n      Motion m = motion[space][i];\n      if (m.pos==0 && b.b[0]=='1') continue;\n      if ((m.pos==1||m.pos==2) && b.b[0]=='1'&&b.b[1]=='2'&&b.b[2]=='3') continue;\n      b.b[space] = b.b[m.pos];\n      b.b[m.pos] = '0';\n      b.step=board.step+1;\n      Q[qhead++ %qlen] = b;\n    }\n  }\n  printf(\"%d\\n\", board.step);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint puz[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nvoid empty(int *,int *);\nint dfs(int,int,int,int,const int);\nint cal();\nvoid swap(int *,int *);\n\n\nint main() {\n    int i,j,ans,x,y,l;\n    \n    //puzzle input\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) scanf(\"%d\",&puz[i][j]);\n    }\n    \n    \n    empty(&x,&y);\n    for(l=0; l<100; l++) {\n        //copy\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) tmp[i][j] = puz[i][j];\n        }\n        \n        //dfs\n        ans = dfs(x,y,-1,0,l);\n        if(ans!=-1) {\n            printf(\"%d\\n\",ans);\n            break;\n        }\n        \n        //copy\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) puz[i][j] = tmp[i][j];\n        }\n        \n        //error\n        ans = -1;\n        if(l==99) printf(\"%d\\n\",ans);\n    }\n    \n    //ans output\n    //printf(\"%d\\n\",ans);\n    \n    return 0;\n}\n\n\nvoid empty(int *x,int *y) {\n    int i,j;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) {\n            if(!puz[i][j]) {\n                *x = j;\n                *y = i;\n                return;\n            }\n        }\n    }\n}\n\n\nvoid swap(int *a,int *b) {\n    int tmp;\n    \n    tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n\n\nint cal() {\n    int i,a,sum=0;\n    \n    for(i=0; i<9; i++) {\n        a = puz[i/3][i%3];\n        if(a) {\n            a--;\n            sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n        }\n    }\n    \n    return sum;\n}\n\n\nint dfs(int x,int y,int p,int dep,const int lim) {\n    int i,h,nx,ny,res;\n    \n    h = cal();\n    if(h==0) return dep;\n    if(dep+h>lim) return -1;\n    \n    for(i=0; i<4; i++) {\n        nx = x+dx[i];\n        ny = y+dy[i];\n        \n        if(~p && i==(p+2)%4) continue;\n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n        \n        swap(&puz[y][x],&puz[ny][nx]);\n        res = dfs(nx,ny,i,dep+1,lim);\n        if(~res) return res;\n        \n        swap(&puz[y][x],&puz[ny][nx]);\n    }\n    \n    return -1;\n}"
  },
  {
    "language": "C",
    "code": "#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n// I/O\nint get_uint() {\n    int n = 0;\n    int c = getchar_unlocked();\n    if(c < 48 || 57 < c) return c;\n    while(47 < c && c < 58) n = 10 * n + (c & 0xf), c = getchar_unlocked();\n    return n;\n}\nvoid put_uint(int n) {\n    if(!n) {\n        putchar_unlocked('0');\n        return;\n    }\n    char buf[11];\n    int i = 0;\n    while(n) buf[i++] = (char)(n % 10 + '0'), n /= 10;\n    while(i--)putchar_unlocked(buf[i]);\n}\n\n\n#define likely(x)   __builtin_expect(!!(x), 1)\n#define unlikely(x) __builtin_expect(!!(x), 0)\n#define container_of(ptr, type, member) ({  \\\n    void *__mptr = (void *)(ptr);           \\\n    ((type *)(__mptr - offsetof(type, member))); })\n\n\nstruct rb_node {\n    unsigned long __rb_parent_color;\n    struct rb_node *rb_right;\n    struct rb_node *rb_left;\n} __attribute__((aligned(sizeof(long))));\n\nstruct rb_root {\n    struct rb_node *rb_node;\n};\n\n#define rb_parent(r) ((struct rb_node *)((r)->__rb_parent_color & ~3))\n#define RB_ROOT (struct rb_root) { NULL, }\n#define RB_EMPTY_NODE(node)  \\\n   ((node)->__rb_parent_color == (unsigned long)(node))\n\nstatic inline void rb_link_node(struct rb_node *node, struct rb_node *parent, struct rb_node **rb_link) {\n    node->__rb_parent_color = (unsigned long)parent;\n    node->rb_left = node->rb_right = NULL;\n    *rb_link = node;\n}\n\n#define RB_RED      0\n#define RB_BLACK    1\n\n#define __rb_color(pc)      ((pc) & 1)\n#define __rb_is_red(pc)     (!__rb_color(pc))\n#define __rb_is_black(pc)   __rb_color(pc)\n#define rb_color(rb)        __rb_color((rb)->__rb_parent_color)\n#define rb_is_red(rb)       __rb_is_red((rb)->__rb_parent_color)\n#define rb_is_black(rb)     __rb_is_black((rb)->__rb_parent_color)\n\nstatic inline void rb_set_parent(struct rb_node *rb, struct rb_node *p) {\n    rb->__rb_parent_color = rb_color(rb) | (unsigned long)p;\n}\n\nstatic inline void rb_set_parent_color(struct rb_node *rb, struct rb_node *p, int color) {\n    rb->__rb_parent_color = (unsigned long)p | color;\n}\n\nstatic inline void __rb_change_child(struct rb_node *old, struct rb_node *new, struct rb_node *parent, struct rb_root *root) {\n    if(parent) {\n        if(parent->rb_left == old) parent->rb_left = new;\n        else parent->rb_right = new;\n    } else root->rb_node = new;\n}\n\nstatic inline void rb_set_black(struct rb_node *rb) {\n    rb->__rb_parent_color |= RB_BLACK;\n}\n\nstatic inline struct rb_node *rb_red_parent(struct rb_node *red) {\n    return (struct rb_node *)red->__rb_parent_color;\n}\n\nstatic inline void __rb_rotate_set_parents(struct rb_node *old, struct rb_node *new, struct rb_root *root, int color) {\n    struct rb_node *parent = rb_parent(old);\n    new->__rb_parent_color = old->__rb_parent_color;\n    rb_set_parent_color(old, new, color);\n    __rb_change_child(old, new, parent, root);\n}\n\nstatic inline void rb_insert(struct rb_node *node, struct rb_root *root) {\n    struct rb_node *parent = rb_red_parent(node), *gparent, *tmp;\n\n    while(1) {\n        // Loop invariant: node is red.\n        if(unlikely(!parent)) {\n            rb_set_parent_color(node, NULL, RB_BLACK);\n            break;\n        }\n        if(rb_is_black(parent)) break;\n\n        gparent = rb_red_parent(parent);\n\n        tmp = gparent->rb_right;\n        if(parent != tmp) {\n            if(tmp && rb_is_red(tmp)) {\n                rb_set_parent_color(tmp, gparent, RB_BLACK);\n                rb_set_parent_color(parent, gparent, RB_BLACK);\n                node = gparent;\n                parent = rb_parent(node);\n                rb_set_parent_color(node, parent, RB_RED);\n                continue;\n            }\n\n            tmp = parent->rb_right;\n            if(node == tmp) {\n                tmp = node->rb_left;\n                parent->rb_right = tmp;\n                node->rb_left = parent;\n                if(tmp) rb_set_parent_color(tmp, parent, RB_BLACK);\n                rb_set_parent_color(parent, node, RB_RED);\n                parent = node;\n                tmp = node->rb_right;\n            }\n\n            gparent->rb_left = tmp;\n            parent->rb_right = gparent;\n            if(tmp) rb_set_parent_color(tmp, gparent, RB_BLACK);\n            __rb_rotate_set_parents(gparent, parent, root, RB_RED);\n            break;\n        } else {\n            tmp = gparent->rb_left;\n            if(tmp && rb_is_red(tmp)) {\n                rb_set_parent_color(tmp, gparent, RB_BLACK);\n                rb_set_parent_color(parent, gparent, RB_BLACK);\n                node = gparent;\n                parent = rb_parent(node);\n                rb_set_parent_color(node, parent, RB_RED);\n                continue;\n            }\n\n            tmp = parent->rb_left;\n            if(node == tmp) {\n                tmp = node->rb_right;\n                parent->rb_left = tmp;\n                node->rb_right = parent;\n                if(tmp) rb_set_parent_color(tmp, parent, RB_BLACK);\n                rb_set_parent_color(parent, node, RB_RED);\n                parent = node;\n                tmp = node->rb_left;\n            }\n            gparent->rb_right = tmp;\n            parent->rb_left = gparent;\n            if(tmp) rb_set_parent_color(tmp, gparent, RB_BLACK);\n            __rb_rotate_set_parents(gparent, parent, root, RB_RED);\n            break;\n        }\n    }\n}\n\nstruct rb_node *rb_first(const struct rb_root *root) {\n    struct rb_node *n;\n    n = root->rb_node;\n    if(!n) return NULL;\n    while(n->rb_left) n = n->rb_left;\n    return n;\n}\n\nstruct rb_node *rb_next(const struct rb_node *node) {\n    struct rb_node *parent;\n    if(RB_EMPTY_NODE(node)) return NULL;\n\n    if(node->rb_right) {\n        node = node->rb_right;\n        while(node->rb_left) node = node->rb_left;\n        return (struct rb_node *)node;\n    }\n\n    while((parent = rb_parent(node)) && node == parent->rb_right) node = parent;\n\n    return parent;\n}\n\nstruct mykey {\n    int board[9];\n    int space;\n    int cnt;\n};\n\nint cmp_mykey(const struct mykey *l, const struct mykey *r) {\n    for(int i = 0; i < 9; ++i) {\n        if(l->board[i] == r->board[i]) continue;\n        if(l->board[i] < r->board[i]) return -1;\n        else return 1;\n    }\n    return 0;\n}\n\nstruct mynode {\n    struct rb_node node;\n    struct mykey key;\n};\n\nstruct mynode *my_search(struct rb_root *root, struct mykey key) {\n    struct rb_node *node = root->rb_node;\n\n    while(node) {\n        struct mynode *data = container_of(node, struct mynode, node);\n        int result = cmp_mykey(&key, &data->key);\n\n        if(result < 0) node = node->rb_left;\n        else if(result > 0) node = node->rb_right;\n        else return data;\n    }\n    return NULL;\n}\n\nint my_insert(struct rb_root *root, struct mynode *data) {\n    struct rb_node **new = &(root->rb_node), *parent = NULL;\n\n    while(*new) {\n        struct mynode *this = container_of(*new, struct mynode, node);\n        int result = cmp_mykey(&data->key, &this->key);\n\n        parent = *new;\n        if(result < 0) new = &((*new)->rb_left);\n        else if(result > 0) new = &((*new)->rb_right);\n        else return -1;\n    }\n    rb_link_node(&data->node, parent, new);\n    rb_insert(&data->node, root);\n    return 0;\n}\n\n/*\nvoid my_print_inorder(struct rb_root *root) {\n    struct rb_node *node;\n    for(node = rb_first(root); node; node = rb_next(node)) {\n        putchar_unlocked(' ');\n        put_int(container_of(node, struct mynode, node)->key);\n    }\n}\n*/\n\n// Queue\n#define QueueKey struct mykey\ntypedef struct QueueDat {\n    QueueKey key;\n    struct QueueDat *next;\n} QueueDat;\ntypedef struct Queue {\n    size_t len;\n    QueueDat *head;\n    QueueDat *tail;\n} Queue;\n#define queue_init(q) ((q) ? ((q)->len = 0, (q)->head = (q)->tail = NULL) : 0)\n#define queue_len(q) ((q) ? (q)->len : 0)\nvoid queue_push(Queue *q, QueueKey x) {\n    QueueDat *new_dat = malloc(sizeof(QueueDat));\n    *new_dat = (QueueDat){x, NULL};\n    if(q->len) {\n        q->tail->next = new_dat;\n        q->tail = new_dat;\n    } else {\n        q->head = q->tail = new_dat;\n    }\n    q->len++;\n}\nQueueKey queue_pop(Queue *q) {\n    QueueDat *old_head = q->head;\n    q->head = old_head->next;\n    QueueKey key = old_head->key;\n    free(old_head);\n    q->len--;\n    return key;\n}\n\n// end condition\nint is_solved(const int board[9]) {\n    for(int i = 0; i < 8; ++i)\n        if(board[i] != i + 1) return 0;\n    return 1;\n}\n\n\nstruct mynode node[200000];\n// solve\nint bfs(struct mykey s) {\n    const int N = 3;\n    const int dx[4] = {-1, 0, 1, 0};\n    const int dy[4] = {0, -1, 0, 1};\n    static int num = 0;\n    node[0].key = s;\n    struct rb_root mytree = RB_ROOT;\n\n    my_insert(&mytree, node + num++);\n    Queue Q;\n    queue_init(&Q);\n    queue_push(&Q, s);\n    while(queue_len(&Q)) {\n        struct mykey key = queue_pop(&Q);\n        if(is_solved(key.board)) return key.cnt;\n        int x = key.space % N;\n        int y = key.space / N;\n        for(int i = 0; i < 4; ++i) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(nx < 0 || N <= nx || ny < 0 || N <= ny) continue;\n\n            int next_space = nx + ny * N;\n            struct mykey next_key = key;\n            next_key.board[key.space] = next_key.board[next_space];\n            next_key.board[next_space] = 0;\n            next_key.space = next_space;\n            if(my_search(&mytree, next_key)) continue;\n\n            next_key.cnt++;\n            node[num].key = next_key;\n            if(my_insert(&mytree, node + num) == 0) num++;\n            queue_push(&Q, next_key);\n        }\n    }\n}\n\n\nint main(int argc, char **argv) {\n    struct mykey initial = {.cnt = 0};\n    for(int i = 0; i < 9; ++i) {\n        int x = get_uint();\n        initial.board[i] = x;\n        if(x == 0) initial.space = i;\n    }\n    //clock_t start, end;\n    //start = clock();\n\n    put_uint(bfs(initial));\n    putchar_unlocked('\\n');\n\n    //end = clock();\n    //printf(\"%lf\\n\", (double)(end-start)/CLOCKS_PER_SEC);\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define Ni 3\n\nint pzl[Ni][Ni],tmp[Ni][Ni];\nint Dx[4]={0,1,0,-1},Dy[4]={1,0,-1,0};\n\nvoid emblem(int *a,int *b){\n  int i,j;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(!pzl[i][j]){\n\t*a = j;\n\t*b=i;\n      }\n    }\n  }\n}\n\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp =*a;\n  *a = *b;\n  *b = tmp;\n}\n\nint check(){\n  int i,A,S=0;\n  for(i=0;i<9;i++){\n    A = pzl[i/3][i%3];\n    if(A){\n      A--;\n      S += abs(i/3-A/3) + abs(i%3 - A%3);\n    }\n  }\n  \n  return S;\n}\n\nint defain(int a,int b,int P,int D,const int shin){\n  int i,hi,A,B,result;\n  hi = check();\n  if(hi==0){\n    return D;\n  }\n  \n  if(D+hi>shin){\n    return -1;\n  }\n\n  for(i=0;i<4;i++){\n    A = a+Dx[i];\n    B = b+Dy[i];\n    if(~P && i==(P+2)%4) {\n      continue;\n    }\n    if(!(0<=A && A<3 && 0<=B && B<3)){\n      continue;\n    }\n    swap(&pzl[b][a],&pzl[B][A]);\n    result = defain(A,B,i,D+1,shin);\n    if(~result){\n      return result;\n    }\n    swap(&pzl[b][a],&pzl[B][A]);\n  }\n  \n  return -1;\n  \n}\n\nint main(){\n  int i,j,li,TA,a,b;\n\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&pzl[i][j]);\n    }\n  }\n\n  emblem(&a,&b);\n  for(li=0;li<100;li++){\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n\ttmp[i][j]=pzl[i][j];\n      }\n    }\n    \n    TA = defain(a,b,-1,0,li);\n    if(TA!=-1){\n      printf(\"%d\\n\",TA);\n      break;\n    }\n\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n\tpzl[i][j]=tmp[i][j];\n      }\n    }\n\n    TA = -1;\n    if(li==99){\n      printf(\"%d\\n\",TA);\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nconst int N = 8;\nint length;\n\nstruct Node {\n  int *board;\n  int h;\n  struct Node *parent;\n};\n\n\n// apparently most linkers don't auto include math.h even if you include the header file,\n// so I'm making bad sqrt for ints and ceiling functions\nint sqrt(int n) {\n  if (n == 0 || n == 1)\n    return n;\n\n  int i = 1, out = 1;\n  while (out <= n) {\n    i++;\n    out = i*i;\n  }\n\n  return i - 1;\n}\n\nint ceil(double n) {\n  if (n - (int) n > 0)\n    return (int) n + 1;\n  else\n    return (int) n;\n}\n\n\nint heuristic(int *board) {\n  int i, j, curx, counter = 0, dist = 0;\n\n  for (i = 0; i < length; i++) {\n    for (j = 0; j < length; j++) {\n      if (board[counter] % 3 == 0)\n        curx = 3;\n      else\n        curx = board[counter] % 3;\n\n      if (board[counter] != 0)\n        dist += abs(curx -(j + 1)) + abs(ceil((double) board[counter] / 3.0) - (i + 1));\n      counter++;\n    }\n  }\n\n  //printf(\"manhattan distance is: %d\\n\", dist);\n  return dist;\n}\n\nint main() {\n  int i, j;\n  length = sqrt(N + 1);\n  int *board = malloc(length * length * sizeof(int));\n\n  //printf(\"printing input board:\\n\");\n\n  for (i = 0; i < length * length; i++) {\n    scanf(\"%d\", &board[i]);\n    /*\n    if ((i + 1) % 3 == 0)\n      printf(\"%d\\n\", board[i]);\n    else\n      printf(\"%d \", board[i]);\n    */\n  }\n\n  printf(\"%d\\n\", heuristic(board));\n  return 0;\n\n  /*\n  struct Node root;\n  root.board = board;\n  root.h = heuristic(board);\n  root.parent = NULL;\n  */\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n\n\nextern void down_0(void);\nextern void up_0(void);\nextern void right_0(void);\nextern void left_0(void);\n\nextern int  serch(int x, int y, int MaxCnt);\nextern int  check(void);\n\nint cnt,num = 0;\nint val[Total] ={};\n\n\nint main( void )\n{\n    int i = 0;\n    int x,y = 0;\n    \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        \n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n    \n    x = tate - (num/yoko) -1;\n    y = yoko - (num%yoko) -1;\n    \n//    printf(\"%d,%d\\n\",x,y);\n    \n    for(i=1; i<10; i++)\n    {\n        if( serch(x,y,i) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt)\n{\n    int result;\n    int i=0;\n    \n    // 最大数で打ち切り\n    if(MaxCnt==0)\n    {\n        return check();\n    }\n    \n    //\n    if(x==0 && y==0)\n    {\n        if( check() )\n        {\n            return 1;\n        }\n    }\n    \n    // 上下左右で4回回す\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if(x > 0)\n                {\n                    down_0();\n                    \n                    result = serch(x-1, y, MaxCnt-1);\n                    \n                    up_0();\n                }\n                break;\n            case 1:\n                if(y > 0)\n                {\n                    right_0();\n                    \n                    result = serch(x, y-1, MaxCnt-1);\n                    \n                    left_0();\n                }\n                break;\n            case 2:\n                if(y < yoko)\n                {\n                    left_0();\n                    \n                    result = serch(x, y+1, MaxCnt-1);\n                    \n                    right_0();\n                }\n                break;\n            case 3:\n                if(x < tate)\n                {\n                    up_0();\n                    \n                    result = serch(x+1, y, MaxCnt-1);\n                    \n                    down_0();\n                }\n                break;\n            default:\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n        \n    }\n\n    return 0;\n}\n\n// TRUE : 完成\n// FALSE : 失敗\nint check()\n{\n    int i=0;\n    \n//    printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);\n    \n    for(i=0; i<Total-1; i++)\n    {\n        if(val[i] != (i+1))\n        {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid down_0()\n{\n    val[num] = val[num + yoko];\n//    val[num + yoko] = 0;\n    num = num + yoko;\n}\n \nvoid up_0()\n{\n    val[num] = val[num - yoko];\n//    val[num - yoko] = 0;\n    num = num - yoko;\n}\n \nvoid right_0()\n{\n    val[num] = val[num +1];\n//    val[num +1] = 0;\n    num = num + 1;\n}\n \nvoid left_0()\n{\n    val[num] = val[num -1];\n//    val[num -1] = 0;\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nint puz[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\nvoid empty(int *x,int *y) {\n  int i,j;\n  for(i=0; i<3; i++) {\n    for(j=0; j<3; j++) {\n      if(!puz[i][j]) {\n    *x = j;\n    *y = i;\n    return;\n      }\n    }\n  }\n}\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}   \nint cal(){\n  int i,a,sum=0; \n  for(i=0; i<9; i++){\n    a = puz[i/3][i%3];\n    if(a){\n      a--;\n      sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n    }\n  }    \n  return sum;\n}\nint dfs(int x,int y,int p,int dep,const int lim){\n    int i,h,nx,ny,res;   \n    h = cal();\n    if(h==0) return dep;\n    if(dep+h>lim) return -1; \n    for(i=0; i<4; i++){\n        nx = x+dx[i];\n        ny = y+dy[i];      \n        if(~p && i==(p+2)%4) continue;\n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;    \n        swap(&puz[y][x],&puz[ny][nx]);\n        res = dfs(nx,ny,i,dep+1,lim);\n        if(~res) return res;       \n        swap(&puz[y][x],&puz[ny][nx]);\n    }   \n    return -1;\n}    \nint main() {\n    int i,j,ans,x,y,l;\n       \n    for(i=0; i<3; i++){\n        for(j=0; j<3; j++) scanf(\"%d\",&puz[i][j]);\n    }\n        \n    empty(&x,&y);\n    for(l=0; l<100; l++){\n        for(i=0; i<3; i++){\n            for(j=0; j<3; j++) tmp[i][j] = puz[i][j];\n        }\n           \n        ans = dfs(x,y,-1,0,l);\n        if(ans!=-1){\n            printf(\"%d\\n\",ans);\n            break;\n        }\n           \n        for(i=0; i<3; i++){\n            for(j=0; j<3; j++) puz[i][j] = tmp[i][j];\n        }\n           \n        ans = -1;\n        if(l==99) printf(\"%d\\n\",ans);\n    }\n       \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#define Size 9\n#define Queue_size 10240\n#define Hash_size 1024\n#define queue_next(i) (((i) + 1) % Queue_size)\nstruct hash_table {\n  long data;\n  struct hash_table *next;\n};\nstruct hash_table *hash[Hash_size];\nint swap_upper(int*, int*);\nint swap_lower(int*, int*);\nint swap_left(int*, int*);\nint swap_right(int*, int*);\nlong board_val(int*);\nvoid val_board(long, int*);\nvoid hash_insert(long);\nint hash_search(long);\nint Bfs(int*, int*);\nint main(void)\n{\n  int i, result, init[Size], goal[Size] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\n  for (i = 0; i < Size; i++) scanf(\"%d\", &init[i]);\n  for (i = 0; i < Hash_size; i++) hash[i] = NULL;\n  printf(\"%d\\n\", Bfs(init, goal));\n}\nint swap_upper(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if (!(pos / e)) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos - e];\n    next[pos - e] = board[pos];\n  }\n  return 1;\n}\nint swap_lower(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if ((pos / e) == e - 1) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos + e];\n    next[pos + e] = board[pos];\n  }\n  return 1;\n}\nint swap_left(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if (!(pos % e)) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos - 1];\n    next[pos - 1] = board[pos];\n  }\n  return 1;\n}\nint swap_right(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if ((pos % e) == e - 1) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos + 1];\n    next[pos + 1] = board[pos];\n  }\n  return 1;\n}\nlong board_val(int *board)\n{\n  int i, digit = 1;\n  long val = 0;\n  for (i = 0; i < Size; i++) {\n    val += board[Size - 1 - i] * digit;\n    digit *= 10;\n  }\n  return val;\n}\nvoid val_board(long val, int *board)\n{\n  int i, digit = 1;\n  for (i = 0; i < Size; i++) {\n    board[Size - 1 - i] = (val / digit) % 10;\n    digit *= 10;\n  }\n}\nvoid hash_insert(long val)\n{\n  struct hash_table *p = (struct hash_table*)malloc(sizeof(struct hash_table));\n  p->data = val;\n  p->next = hash[val % Hash_size];\n  hash[val % Hash_size] = p;\n}\nint hash_search(long val)\n{\n  struct hash_table *n;\n  for (n = hash[val % Hash_size]; n != NULL; n = n->next) {\n      if (val == n->data) return 1;\n  }\n  return 0;\n}\nint Bfs(int *init, int *goal)\n{\n  int depth = 0, ptr_front = 0, ptr_back = 0;\n  long queue[Queue_size][2];\n  queue[ptr_back][0] = board_val(init);\n  queue[ptr_back][1] = depth;\n  ptr_back = queue_next(ptr_back);\n  if (!memcmp(init, goal, sizeof(int) * Size)) return depth;\n  while (ptr_front != ptr_back) {\n    int curr[Size], next[Size];\n    long val;\n    val = queue[ptr_front][0];\n    val_board(val, curr);\n    depth = queue[ptr_front][1];\n    ptr_front = queue_next(ptr_front);\n    depth++;\n    hash_insert(val);\n    if (swap_upper(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n    if (swap_lower(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n    if (swap_left(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n    if (swap_right(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n \nint board[9];\nint rows = 3, cols = 3, zeroIndex, current;\n \n// for previousMove: 0 is down, 1 is up, 2 is left, 3 is right\nint blindSearch(int x, int y, int moves, int previousMove) {\n  int i, foundAnswer;\n \n  // answer is less than manhattan distance, not possible\n  if (moves < (x + y))\n    return 0;\n \n  if (!moves) {\n    for (i = 0; i < 8; i++) {\n      if (board[i] != i + 1)\n        return 0;\n    }\n \n    return 1;\n  }\n \n  if (x > 0 && previousMove != 1) {\n    // can expand down\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n \n    foundAnswer = blindSearch(x - 1, y, moves - 1, 0);\n    if (foundAnswer)\n      return 1;\n \n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n  }\n \n  if (y > 0 && previousMove != 3) {\n    // right\n    board[zeroIndex] = board[++zeroIndex];\n \n    foundAnswer = blindSearch(x, y - 1, moves - 1, 2);\n    if (foundAnswer)\n      return 1;\n \n    board[zeroIndex] = board[--zeroIndex];\n  }\n if (y < rows - 1 && previousMove != 2) {\n    // left\n    board[zeroIndex] = board[--zeroIndex];\n \n    foundAnswer = blindSearch(x, y + 1, moves - 1, 3);\n    if (foundAnswer)\n      return 1;\n \n    board[zeroIndex] = board[++zeroIndex];\n  }\n \n  if (x < cols - 1 && previousMove != 0) {\n    // up\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n \n    foundAnswer = blindSearch(x + 1, y, moves - 1, 1);\n    if (foundAnswer)\n      return 1;\n \n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n  }\n \n  return 0;\n}\n \nint main() {\n  int i, x, y;\n  current = 0;\n \n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &board[i]);\n    if (!board[i])\n      zeroIndex = i;\n  }\n \n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n \n  while (current < 50) {\n    if (blindSearch(x, y, current, -1)) {\n      printf(\"%d\\n\", current);\n      break;\n    }\n    current++;\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n\n\nextern void down_0(void);\nextern void up_0(void);\nextern void right_0(void);\nextern void left_0(void);\nextern int  serch(int x, int y, int MaxCnt);\nextern int  check(void);\n\nint cnt,num = 0;\nint val[Total] ={};\n\n\nint main( void )\n{\n    int i = 0;\n    int x,y = 0;\n    \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        \n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n    \n    x = tate - (num/yoko) -1;\n    y = yoko - (num%yoko) -1;\n    \n//    printf(\"%d,%d\\n\",x,y);\n    \n    for(i=1; i<5; i++)\n    {\n        if( serch(x,y,i) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt)\n{\n    int result;\n    int i=0;\n    \n    // 最大数で打ち切り\n    if(MaxCnt==0)\n    {\n        return check();\n    }\n    \n    //\n    if(x==0 && y==0)\n    {\n        if( check() )\n        {\n            return 1;\n        }\n    }\n    \n    // 上下左右で4回回す\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if(x > 0)\n                {\n                    down_0();\n                    \n                    result = serch(x-1, y, MaxCnt-1);\n                    \n                    up_0();\n                }\n                break;\n            case 1:\n                if(y > 0)\n                {\n                    right_0();\n                    \n                    result = serch(x, y-1, MaxCnt-1);\n                    \n                    left_0();\n                }\n                break;\n            case 2:\n                if(y < yoko)\n                {\n                    left_0();\n                    \n                    result = serch(x, y+1, MaxCnt-1);\n                    \n                    right_0();\n                }\n                break;\n            case 3:\n                if(x < tate)\n                {\n                    up_0();\n                    \n                    result = serch(x+1, y, MaxCnt-1);\n                    \n                    down_0();\n                }\n                break;\n            default:\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n        \n    }\n\n    return 0;\n}\n\n// TRUE : 完成\n// FALSE : 失敗\nint check()\n{\n    int i=0;\n    \n//    printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);\n    \n    for(i=0; i<Total-1; i++)\n    {\n        if(val[i] != (i+1))\n        {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid down_0()\n{\n    val[num] = val[num + yoko];\n    val[num + yoko] = 0;\n    num = num + yoko;\n}\n \nvoid up_0()\n{\n    val[num] = val[num - yoko];\n    val[num - yoko] = 0;\n    num = num - yoko;\n}\n \nvoid right_0()\n{\n    val[num] = val[num +1];\n    val[num +1] = 0;\n    num = num + 1;\n}\n \nvoid left_0()\n{\n    val[num] = val[num -1];\n    val[num -1] = 0;\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint puzzle[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nvoid empty(int *,int *);\nint dfs(int,int,int,int,const int);\nint cal();\nvoid swap(int *,int *);\n\nint main() {\n    int i,j,a,x,y,l;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) scanf(\"%d\",&puzzle[i][j]);\n    }\n\n    empty(&x,&y);\n    for(l=0; l<100; l++) {\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) tmp[i][j] = puzzle[i][j];\n        }\n\n        ans = dfs(x,y,-1,0,l);\n        if(a!=-1) {\n            printf(\"%d\\n\",a);\n            break;\n        }\n\n        for(i=0 ; i<3 ; i++) {\n            for(j=0 ; j<3 ; j++) puzzle[i][j] = tmp[i][j];\n        }\n        a = -1;\n        if(l==99) printf(\"%d\\n\",a);\n    } \n    return 0;\n}\n\nvoid empty(int *x,int *y) {\n    int i,j;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) {\n            if(!puzzle[i][j]) {\n                *x = j;\n                *y = i;\n                return;\n            }\n        }\n    }\n}\n\nvoid swap(int *a,int *b) {\n    int tmp;\n    tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n\nint cal() {\n    int i,a,sum=0;\n    for(i=0; i<9; i++) {\n        a = puzzle[i/3][i%3];\n        if(a) {\n            a--;\n            sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n        }\n    }\n    return sum;\n}\n\nint dfs(int x,int y,int p,int dep,const int lim) {\n    int i,h,nx,ny,res;\n\n    h = cal();\n    if(h==0) return dep;\n    if(dep+h>lim) return -1;\n\n    for(i=0; i<4; i++) {\n        nx = x+dx[i];\n        ny = y+dy[i];\n \n        if(~p && i==(p+2)%4) continue;\n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n \n        swap(&puzzle[y][x],&puzzle[ny][nx]);\n        res = dfs(nx,ny,i,dep+1,lim);\n        if(~res) return res;\n \n        swap(&puzzle[y][x],&puzzle[ny][nx]);\n    }\n\n    return -1;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \nint puz[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n \nvoid empty(int *x,int *y) {\n\n  int i,j;\n\n  for(i = 0;i < 3;i ++)\n    {\n      for(j = 0;j < 3;j ++)\n\t{\n\t  if(!puz[i][j])\n\t    {\n\t      *x = j;\n\t      *y = i;\n\n\t      return;\n            }\n        }\n    }\n}\n \n \nvoid swap(int *a,int *b) {\n\n  int tmp;\n     \n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n \n \nint cal() {\n\n  int i,a;\n  int sum = 0;\n     \n  for(i = 0;i < 9;i ++)\n    {\n      a = puz[i/3][i%3];\n\n      if(a){\n\ta--;\n\n\tsum += abs(i/3 - a/3) + abs(i%3 - a%3);\n\n      }\n    }\n     \n  return sum;\n}\n \n \nint dfs(int x,int y,int p,int dep,const int lim) {\n\n  int i,h,nx,ny,res;\n     \n  h = cal();\n\n  if(h == 0){\n    return dep;\n  }\n    \n  if(dep+h > lim){\n    return -1;\n  }\n    \n  for(i = 0;i < 4;i ++)\n    {\n      nx = x+dx[i];\n      ny = y+dy[i];\n         \n      if(~p && i==(p+2)%4) continue;\n      if(!(0 <= nx && nx < 3 && 0 <= ny && ny<3)) continue;\n         \n      swap(&puz[y][x],&puz[ny][nx]);\n\n      res = dfs(nx,ny,i,dep+1,lim);\n\n      if(~res){\n\treturn res;\n      }\n\t\n      swap(&puz[y][x],&puz[ny][nx]);\n    }\n     \n  return -1;\n}\n\n \n \nint main() {\n\n  int i,j,ans,x,y,l;\n     \n   \n  for(i = 0;i < 3;i ++)\n    {\n      for(j = 0;j < 3;j ++)\n\t{\n\t  scanf(\"%d\",&puz[i][j]);\n\t}\n    }\n     \n     \n  empty(&x,&y);\n\n  for(l = 0;l < 100;l ++)\n    {\n      for(i = 0;i < 3;i ++)\n\t{\n\t  for(j = 0;j < 3;j ++)\n\t    {\n\t      tmp[i][j] = puz[i][j];\n\t    }\n        }\n         \n      ans = dfs(x,y,-1,0,l);\n\n      if(ans != -1)\n\t{\n\t  printf(\"%d\\n\",ans);\n\t  break;\n        }\n         \n      for(i = 0;i < 3;i ++)\n\t{\n\t  for(j = 0;j < 3;j ++)\n\t    {\n\t      puz[i][j] = tmp[i][j];\n\t    }\n        }\n         \n      ans = -1;\n\n      if(l == 99){\n\tprintf(\"%d\\n\",ans);\n      }\n    }     \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX_LENGTH 101\nint ini[4][4];\nint changed[4][4];\nint dxn[4] = {0, 1, 0, -1};\nint dyn[4] = {1, 0, -1, 0};\nvoid Empty(int *row, int *column)\n{\n    for(int i=0;i<3;i++)\n    {\n        for(int j=0;j<3;j++)\n        {\n            if(!ini[i][j]){*column = i;*row = j;}\n        }\n\n\tfor(int j=0;j<3;j++)\n        {\n            if(!ini[i][j]){*column = i;*row = j;}\n        }\n    }\n}\nint calculate()\n{\n    int countSum = 0;\n    for(int i=0;i<9;i++)\n    {\n        int temp = ini[i/3][i%3];\n        if(temp)\n        {\n            temp--;\n            countSum += abs(i/3-temp/3)+abs(i%3-temp%3);\n        }\n    }\n    return countSum;\n}\nint depthF(int x, int y, int k, int depth, const int limit)\n{\n    int length;\n    length = calculate();\n    if (length == 0)return depth;\n    if (depth + length > limit)return -1;\n    for (int i = 0; i < 4; i++)\n    {\n        int a = x + dxn[i];\n        int b = y + dyn[i];\n        if (~k && i == (k + 2) % 4)continue;\n        if (!(0 <= a && a < 3 && 0 <= b && b < 3))continue;\n        int tem = ini[y][x];\n        ini[y][x]=ini[b][a];\n        ini[b][a]=tem;\n        int res = depthF(a, b, i, depth + 1, limit);\n        if (~res)return res;\n        int te = ini[y][x];\n        ini[y][x]=ini[b][a];\n        ini[b][a]=te;\n    }\n    return -1;\n}\nint main() {\n    int row, column=0;\n    int step;\n    for(int i=0;i<3;i++)\n    {\n        for(int j=0;j<3;j++){scanf(\"%d\", &ini[i][j]);}\n\n\t\n    }\n    Empty(&row, &column);\n    for(int l=0;l<MAX_LENGTH;l++)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++){changed[i][j]=ini[i][j];}\n        }\n        if((step = depthF(row, column, -1, 0, l))!=-1)\n        {\n            printf(\"%d\\n\", step);\n            break;\n        }\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++){ini[i][j]=changed[i][j];}\n        }\n        step = -1;\n        if(l==MAX_LENGTH-1){printf(\"%d\\n\", step);}\n    }\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define true 1\n#define false 0\n#define LEN 500001\n#define N 3\n#define N2 9\n\ntypedef struct puzzle {\n\tint f[N2];\n\tint space;\n\tint path;\n} Puzzle;\n\nvoid enqueue(Puzzle);\nPuzzle dequeue();\n\nPuzzle Q[LEN];\nint head = 0, tail = 0;\nint V[LEN];\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\n\nint hash(Puzzle p) {\n\tint i, j;\n\tint key, count;\n\tint sum = 0;\n\n\tfor ( i = 0, key = 1; i < N2; key *= ++i) {\n\t\tfor ( j = 0, count = 0; j < i; j++) {\n\t\t\tif ( p.f[j] < p.f[i] ) count++;\n\t\t}\n\t\tsum += count * key;\n\t}\n\treturn sum;\n}\n\nint isTarget(Puzzle p) {\n\tint i;\n\tfor ( i = 0; i < N2; i++)\n\t\tif ( p.f[i] != ( i + 1 ) ) return false;\n\treturn true;\n}\n\nint bfs(Puzzle s) {\n\tPuzzle u, v;\n\tint r;\n\ts.path = 0;\n\tenqueue(s);\n\tV[hash(s)] = true;\n\n\twhile ( head != tail ){\n\t\tu = Q[head];\n\t\tdequeue();\n\t\tif ( isTarget(u) == true ) return u.path;\n\t\tint sx = u.space / N;\n\t\tint sy = u.space % N;\n\t\tfor ( r = 0; r < 4; r++) {\n\t\t\tint tx = sx + dx[r];\n\t\t\tint ty = sy + dy[r];\n\t\t\tif ( tx < 0 || ty < 0 || tx >= N || ty >= N ) continue;\n\t\t\tv = u;\n\t\t\tint temp = v.f[u.space];\n\t\t\tv.f[u.space] = v.f[tx * N + ty];\n\t\t\tv.f[tx * N + ty] = temp;\n\t\t\tv.space = tx * N + ty;\n\t\t\tif ( V[hash(v)] != true ) {\n\t\t\t\tV[hash(v)] = true;\n\t\t\t\tv.path++;\n\t\t\t\tenqueue(v);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tPuzzle in;\n\tint i;\n\n\tfor ( i = 0; i < N2; i++) {\n\t\tscanf(\"%d\",&in.f[i]);\n\t\tif (in.f[i] == 0) {\n\t\t\tin.f[i] = N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\n\tint ans = bfs(in);\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\nvoid enqueue(Puzzle x) {\n\tQ[tail] = x;\n\ttail = (tail + 1) % LEN;\n}\n\nPuzzle dequeue() {\n\tPuzzle x = Q[head];\n\thead = (head + 1) % LEN; \n\treturn x;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 9\n\nint board[N];\nint rows = 3, cols = 3, zeroIndex;\n\n// for previousMove: 0 is down, 1 is up, 2 is left, 3 is right\nint blindSearch(int x, int y, int moves, int previousMove) {\n  int i, foundAnswer;\n\n  // answer is less than manhattan distance, not possible\n  if (moves < (x + y))\n    return 0;\n\n  if (!moves) {\n    for (i = 0; i < N - 1; i++) {\n      if (board[i] != i + 1)\n        return 0;\n    }\n\n    return 1;\n  }\n\n  if (x > 0 && previousMove != 1) {\n    // can expand down\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n\n    foundAnswer = blindSearch(x - 1, y, moves - 1, 0);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n  }\n\n  if (y > 0 && previousMove != 3) {\n    // right\n    board[zeroIndex] = board[++zeroIndex];\n\n    foundAnswer = blindSearch(x, y - 1, moves - 1, 2);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[--zeroIndex];\n  }\n\n  if (y < rows - 1 && previousMove != 2) {\n    // left\n    board[zeroIndex] = board[--zeroIndex];\n\n    foundAnswer = blindSearch(x, y + 1, moves - 1, 3);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[++zeroIndex];\n  }\n\n  if (x < cols - 1 && previousMove != 0) {\n    // up\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n\n    foundAnswer = blindSearch(x + 1, y, moves - 1, 1);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n  }\n\n  return 0;\n}\n\nint main() {\n  int i, x, y, current;\n\n  for (i = 0; i < N; i++) {\n    scanf(\"%d\", &board[i]);\n    if (!board[i])\n      zeroIndex = i;\n  }\n\n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n\n  for (current = 0; current < 50; current++) {\n    if (blindSearch(x, y, current, -1)) {\n      printf(\"%d\\n\", current);\n      return;\n    }\n  }\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint puz[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nvoid empty(int *,int *);\nint dfs(int,int,int,int,const int);\nint catch();\nvoid swap(int *,int *);\n\n\nint main() {\n    int i,j,ans,x,y,V;\n    \n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) scanf(\"%d\",&puz[i][j]);\n    }\n    \n    \n    empty(&x,&y);\n    for(V=0; V<100; V++) {\n       \n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) tmp[i][j] = puz[i][j];\n        }\n        \n        ans = dfs(x,y,-1,0,V);\n        if(ans!=-1) {\n            printf(\"%d\\n\",ans);\n            break;\n        }\n        \n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) puz[i][j] = tmp[i][j];\n        }\n        \n         ans = -1;\n        if(V==99) printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n\nvoid empty(int *x,int *y) {\n    int i,j;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) {\n            if(!puz[i][j]) {\n                *x = j;\n                *y = i;\n                return;\n            }\n        }\n    }\n}\n\n\nvoid swap(int *a,int *b) {\n    int tmp;\n    \n    tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n\n\nint catch() {\n    int i,a,sum=0;\n    \n    for(i=0; i<9; i++) {\n        a = puz[i/3][i%3];\n        if(a) {\n            a--;\n            sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n        }\n    }\n    \n    return sum;\n}\n\n\nint dfs(int x,int y,int p,int dep,const int lim) {\n    int i,h,nx,ny,res;\n    \n    h = catch();\n    if(h==0) return dep;\n    if(dep+h>lim) return -1;\n    \n    for(i=0; i<4; i++) {\n        nx = x+dx[i];\n        ny = y+dy[i];\n        \n        if(~p && i==(p+2)%4) continue;\n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n        \n        swap(&puz[y][x],&puz[ny][nx]);\n        res = dfs(nx,ny,i,dep+1,lim);\n        if(~res) return res;\n        \n        swap(&puz[y][x],&puz[ny][nx]);\n    }\n    \n    return -1;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint panel[3][3];\nint temp[3][3];\nint XX[4] = {0,1,0,-1};\nint YY[4] = {1,0,-1,0};\n\nint DFS(int,int,int,int,const int);\nint Calc();\nvoid empty(int *,int *);\nvoid swap(int *,int *);\n\nint main()\n{\n\tint i,j;\n\tint x,y;\n\tint A,l;\n\tfor(i=0; i<3; i++)\n\t{\n\t\tfor(j=0; j<3; j++) scanf(\"%d\",&panel[i][j]);\n\t}\n\n\tempty(&x,&y);\n\tfor(l=0; l<100; l++)\n\t{\n\t\tfor(i=0; i<3; i++)\n\t\t{\n\t\t\tfor(j=0; j<3; j++) temp[i][j] = panel[i][j];\n\t\t}\n\n\t\tA = DFS(x,y,-1,0,l);\n\n\t\tif(A != -1)\n\t\t{\n\t\t\tprintf(\"%d\\n\",A);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(i=0 ; i<3 ; i++)\n\t\t{\n\t\t\tfor(j=0 ; j<3 ; j++) panel[i][j] = temp[i][j];\n\t\t}\n\t\tA = -1;\n\t\tif(l == 99) printf(\"%d\\n\",A);\n\t}\n\treturn 0;\n}\n\nvoid empty(int *x,int *y)\n{\n\tint i,j;\n\tfor(i=0; i<3; i++)\n\t{\n\t\tfor(j=0; j<3; j++)\n\t\t{\n\t\t\tif(!panel[i][j])\n\t\t\t{\n\t\t\t\t*x = j;\n\t\t\t\t*y = i;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid swap(int *a,int *b)\n{\n\tint temp;\n\ttemp = *a;\n\t*a = *b;\n\t*b = temp;\n}\n\nint Calc()\n{\n\tint i,x,sum=0;\n\tfor(i=0; i<9; i++)\n\t{\n\t\tx = panel[i/3][i%3];\n\t\tif(x)\n\t\t{\n\t\t\tx--;\n\t\t\tsum += abs(i/3 - x/3) + abs(i%3 - x%3);\n\t\t}\n\t}\n\treturn sum;\n}\n\nint DFS(int x,int y,int p,int Depth,const int Limit)\n{\n\tint i;\n\tint h,res;\n\tint X,Y;\n\n\th = Calc();\n\tif(h == 0) return Depth;\n\tif(Depth+h>Limit) return -1;\n\n\tfor(i = 0; i < 4; i++)\n\t{\n\t\tX = x + XX[i];\n\t\tY = y + YY[i];\n\n\t\tif(~p && i == (p+2)%4) continue;\n\t\tif(!(0 <= X && X<3 && 0 <= Y && Y<3)) continue;\n\n\t\tswap(&panel[y][x],&panel[Y][X]);\n\t\tres = DFS(X,Y,i,Depth+1,Limit);\n\t\tif(~res) return res;\n\n\t\tswap(&panel[y][x],&panel[Y][X]);\n\t}\n\n\treturn -1;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n#define TryCnt 45\n\nextern inline void down_0(void);\nextern inline void up_0(void);\nextern inline void right_0(void);\nextern inline void left_0(void);\n\nextern int  serch(int x, int y, int MaxCnt, int pre);\n\nint num = 0;\nint val[Total] ={};\n\nint main( void )\n{\n    int i = 0;\n    int x,y = 0;\n\n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n\n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n\n    x = tate - (num/yoko) -1;\n    y = yoko - (num%yoko) -1;\n\n    for(i=0; i<TryCnt; i++)\n    {\n        if( serch(x,y,i,4) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }\n\n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt, int pre)\n{\n    int result;\n    int i=0;\n\n    if(MaxCnt < (x + y) )\n    {\n        return 0;\n    }\n\n    if(MaxCnt==0)\n    {\n        for(i=0; i<Total-1; i++)\n        {\n            if(val[i] != (i+1))\n            {\n                // ゴールと不一致\n                return 0;\n            }\n        }\n        // ゴールと一致！！\n        return 1;\n    }\n\n\n    // 0 の移動\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n\n        switch(i)\n        {\n            case 0:\n                if( (x > 0) && (pre != 3) )\n                {\n                    down_0();\n\n                    result = serch(x-1, y, MaxCnt-1, 0);\n\n                    up_0();\n                }\n                break;\n\n            case 1:\n                if( (y > 0) && (pre != 2) )\n                {\n                    right_0();\n\n                    result = serch(x, y-1, MaxCnt-1, 1);\n\n                    left_0();\n                }\n                break;\n\n            case 2:\n                if( (y < yoko -1 ) && (pre != 1) )\n                {\n                    left_0();\n\n                    result = serch(x, y+1, MaxCnt-1, 2);\n\n                    right_0();\n                }\n                break;\n\n            case 3:\n                if( (x < tate -1 ) && (pre != 0) )\n                {\n                    up_0();\n\n                    result = serch(x+1, y, MaxCnt-1, 3);\n\n                    down_0();\n                }\n                break;\n\n            default:\n                // 何もしない。\n                break;\n        }\n\n        if(result)\n        {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\n\ninline void down_0()\n{\n    val[num] = val[num + yoko];\n    num = num + yoko;\n}\n\ninline void up_0()\n{\n    val[num] = val[num - yoko];\n    num = num - yoko;\n}\n\ninline void right_0()\n{\n    val[num] = val[num +1];\n    num = num + 1;\n}\n\ninline void left_0()\n{\n    val[num] = val[num -1];\n    num = num - 1;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#define N 3\n#define T 1\n#define F 0\n\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\nint limit;\nint t[N][N];\n\nvoid swap(int *x,int *y){\n  int tmp;\n  tmp = *x;\n  *x = *y;\n  *y = tmp;\n  return ;\n}\n\nint GetHeuristic(){\n  int i,j,sum = 0,x;\n  for(i = 0 ; i < N ; i++){\n    for(j = 0 ; j < N ; j++){\n    if(t[i][j] == 0)continue;\n    x = t[i][j]-1;\n    sum += abs(x/N - i) + abs(x%N - j);\n    }\n  }\n  return sum;\n}\n\nint dfs(int depth,int prev,int py,int px){\n  int h = GetHeuristic();\n  if(h == 0)return T;\n  if(depth+h > limit)return F;\n  int i;\n  for(i = 0 ; i < 4 ; i++){\n    if(abs(i-prev) == 2)continue;\n    int tx = px + dx[i],ty = py + dy[i];\n    if(tx < 0 || ty < 0 || tx >= N || ty >= N)continue;\n    swap(&t[ty][tx],&t[py][px]);\n    if(dfs(depth + 1,i,ty,tx))return T;\n    swap(&t[ty][tx],&t[py][px]);\n  }\n  return F;\n}\n\nvoid isSolved(int py,int px){\n  for(limit = 0 ; ; limit++){\n    if(dfs(0,99,py,px)){\n      printf(\"%d\\n\",limit);\n      return ;\n    }\n  }\n}\n\nint main(){\n  int i,j,px,py;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&t[i][j]);\n      if(t[i][j]==0){\n        py=i;\n        px=j;\n      }\n    }\n  }\n  isSolved(py,px);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define N 3\n\nint P[N][N],G[N][N];\nint X[4]={0,1,0,-1};\nint Y[4]={1,0,-1,0};\n\nvoid Empty(int *,int *);\nvoid Swap(int *,int *);\nint DFS(int ,int ,int ,int ,const int );\nint cal();\n\nint main()\n{\n  int i,j;\n  int h,ans,row,col;\n\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&P[i][j]);\n    }\n  }\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++){\n\tG[i][j] = -1;\n      }\n    }\n\n  Empty(&row,&col);\n\n  for(h=0;h<100;h++){\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++){\n        G[i][j] = P[i][j];\n      }\n    }\n    \n    ans = DFS(row,col,-1,0,h);\n\n    for(i=0;i<N;i++){\n      \n    }\n\n    if(ans != -1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++){\n        P[i][j] = G[i][j];\n      }\n    }\n    \n    ans = -1;\n\n    if(h == 99)\n      printf(\"%d\\n\\n\",ans);\n  }\n  return 0;\n}\n\nvoid Empty(int *row,int *col)\n{\n  int i,j;\n\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      if(!P[i][j]){\n        *row = j;\n        *col = i;\n        return;\n      }\n    }\n  }\n}\n\nvoid Swap(int *a,int *b) //交換\n{\n  int tmp;\n  \n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nint DFS(int x,int y,int p,int deep,const int lim)\n{\n  int i,len,emc;\n  int x2,y2;\n\n  len = cal();\n\n  if(len == 0)\n    return deep;\n  if(deep + len > lim)\n    return -1;\n\n  for(i=0; i<N+1; i++){\n    x2 = x+X[i];\n    y2 = y+Y[i];\n    if(p != -1 && i == (p + 2) % 4) \n      continue;\n    if(!(0<=x2 && x2<3 && 0<=y2 && y2<3))\n      continue;\n\n    Swap(&P[y][x],&P[y2][x2]);\n\n    emc = DFS(x2,y2,i,deep+1,lim);\n\n    if (emc != -1) \n      return emc;\n\n    Swap(&P[y][x],&P[y2][x2]);\n  }\n\n  return -1;\n}\n\nint cal()\n{\n  int i,e,C = 0;\n\n  for(i=0;i<9;i++){\n    e = P[i/3][i%3];\n    if(e){\n      e--;\n      C += abs(i/3-e/3) + abs(i%3-e%3);\n    }\n  }\n  return C;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#define N 3\n\nint X[4]={0,-1,0,1};\nint Y[4]={1,0,-1,0};\nint limit;\nint t[N][N];\n\nvoid swap(int *x,int *y){\n  int tmp=*x;\n  *x=*y;\n  *y=tmp;\n  return ;\n}\n\nint Heuristic(){\n  int i,j,sum=0,x;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n    if(t[i][j]==0)continue;\n    x=t[i][j]-1;\n    sum+=abs(x/N-i)+abs(x%N-j);\n    }\n  }\n  return sum;\n}\n\nint dfs(int depth,int prev,int y,int x){\n  int h=Heuristic();\n  if(h == 0) return 1;\n  if(depth + h > limit) return 0;\n  int i;\n  for(i = 0 ; i < 4 ; i++){\n    if(abs(i - prev) == 2) continue;\n    int tx=x+X[i],ty=y+Y[i];\n    if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n    swap(&t[ty][tx],&t[y][x]);\n    if(dfs(depth+1,i,ty,tx))return 1;\n    swap(&t[ty][tx],&t[y][x]);\n  }\n  return 0;\n}\n\nvoid solve(int y,int x){\n  for(limit = 0 ;; limit++){\n    if(dfs(0 ,99 ,y ,x)){\n      printf(\"%d\\n\",limit);\n      return ;\n    }\n  }\n}\n\nint main(){\n  int i,j,x,y;\n  for(i = 0 ; i < N ; i++){\n    for(j = 0 ; j < N ; j++){\n      scanf(\"%d\",&t[i][j]);\n      if(t[i][j]==0){\n        y=i;\n        x=j;\n      }\n    }\n  }\n  solve(y,x);\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define N   3\n#define LIM 32\n#define HN  362897\n\nstruct dep{\n    int depth;\n    int key;\n};\n\nint puz[N][N]={\n    {1,2,3},\n    {4,5,6},\n    {7,8,0}};\n\nint min = LIM;\nstruct dep h[HN];\n\nint Hash1(int x){\n    return x % HN;\n}\n\nint Hash2(int x){\n    return 1 + x % (HN-1);\n}\n\nint Hash3(int x, int y){\n    return (Hash1(x) + y * Hash2(x)) % HN;\n}\n\nvoid Dfs(int x[N][N], int n){\n    int i,j,l,m,a=0,b=1;\n    int f=0;\n    int tmp[N][N];\n\n    for(i = 0 ; i < N ; i++){\n        for(j = 0 ; j < N ; j++){\n            if(puz[i][j] != x[i][j]){\n              f++;\n            }\n            if(x[i][j] == 0){\n                l = i;\n                m = j;\n            }\n            a += x[i][j] * b;\n            b *= 10;\n        }\n    }\n\n    if(f == 0){\n        if(min >= n){\n            min = n;\n        }\n        return;\n    }\n    if(n > min){\n      return;\n    }\n    i = 0;\n    while(1){\n        b = Hash3(a, i);\n        if(h[b].key == 0){\n          h[b].key = a;\n          h[b].depth = n;\n          break;\n        }\n        else if(h[b].key == a){\n            if(h[b].depth > n){\n              h[b].depth = n;\n              break;\n            }\n            else{\n              return;\n            }\n        }\n        i++;\n    }\n\n    if(l > 0 && l < N){\n        memcpy(tmp, x, sizeof(int)*N*N);\n        f = tmp[l][m];\n        tmp[l][m] = tmp[l-1][m];\n        tmp[l-1][m] = f;\n        Dfs(tmp, n+1);\n    }\n\n    if(m > 0 && m < N){\n        memcpy(tmp, x, sizeof(int)*N*N);\n        f = tmp[l][m];\n        tmp[l][m] = tmp[l][m-1];\n        tmp[l][m-1] = f;\n        Dfs(tmp, n+1);\n    }\n\n    if(l >= 0 && l < N-1){\n        memcpy(tmp, x, sizeof(int)*N*N);\n        f = tmp[l][m];\n        tmp[l][m] = tmp[l+1][m];\n        tmp[l+1][m] = f;\n        Dfs(tmp, n+1);\n    }\n\n    if(m >= 0 && m < N-1){\n        memcpy(tmp, x, sizeof(int)*N*N);\n        f = tmp[l][m];\n        tmp[l][m] = tmp[l][m+1];\n        tmp[l][m+1] = f;\n        Dfs(tmp, n+1);\n    }\n}\n\nint main(){\n    int i,j;\n    int puz[N][N];\n\n    for(i = 0 ; i < N ; i++){\n        for(j = 0 ; j < N ; j++){\n            scanf(\"%d\",&puz[i][j]);\n        }\n    }\n    Dfs(puz,0);\n\n    printf(\"%d\\n\",min);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define N 3\n\nint pane[N][N], temp[N][N];\nint dx[4]={0,1,0,-1}, dy[4]={1,0,-1,0};\n\n\nvoid empty(int *,int *);\nvoid swap(int *,int *);\nint cal();\nint dfs(int ,int ,int ,int ,const int );\n\nint main() {\n  int i,j,h,ans,row,col;\n      \n  for(i=0; i<3; i++){\n    for(j=0; j<3; j++)\n      scanf(\"%d\",&pane[i][j]);\n  }  \n  empty(&row,&col);  \n  for(h=0; h<100; h++){\n    for(i=0; i<3; i++){\n      for(j=0; j<3; j++)\n\ttemp[i][j] = pane[i][j];\n    }    \n    ans = dfs(row,col,-1,0,h);    \n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }    \n    for(i=0; i<3; i++){\n      for(j=0; j<3; j++)\n\tpane[i][j] = temp[i][j];\n    }    \n    ans = -1;\n    if(h==99) printf(\"%d\\n\",ans);\n  }      \n  return 0;\n}\n\nvoid empty(int *row,int *col){\n  int i,j;\n  for(i=0; i<3; i++)\n    for(j=0; j<3; j++)\n      if(!pane[i][j]){\n\t*row = j;\n\t*col = i;\n\treturn;\n      }  \n}\n   \nvoid swap(int *a,int *b){\n  int temp;\n  temp = *a;*a = *b;*b = temp;\n}\n  \nint cal(){\n  int i,e,count=0; \n  for(i=0; i<9; i++){\n    e = pane[i/3][i%3];\n    if(e){\n      e--;\n      count += abs(i/3 - e/3) + abs(i%3 - e%3);\n    }\n  }    \n  return count;\n}\n  \nint dfs(int x,int y,int p,int deep,const int limt){\n  int i,l,x2,y2,emc;   \n  l = cal();\n  if(l==0) return deep;\n  if(deep+l > limt) return -1; \n  for(i=0; i<4; i++){\n    x2 = x+dx[i];\n    y2 = y+dy[i];      \n    if(~p && i==(p+2)%4) continue;\n    if(!(0<=x2 && x2<3 && 0<=y2 && y2<3)) continue;    \n    swap(&pane[y][x],&pane[y2][x2]);\n    emc = dfs(x2,y2,i,deep+1,limt);\n    if(~emc) return emc;       \n    swap(&pane[y][x],&pane[y2][x2]);\n  }   \n  return -1;\n}  \n  \n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nconst int N = 8;\nint length;\n\nstruct Node {\n  int *board;\n  int h;\n  struct Node *parent;\n};\n\n\nint heuristic(int *board) {\n  int i, j, curx, counter = 0, dist = 0;\n\n  for (i = 0; i < length; i++) {\n    for (j = 0; j < length; j++) {\n      if (board[counter] % 3 == 0)\n        curx = 3;\n      else\n        curx = board[counter] % 3;\n\n      if (board[counter] != 0)\n        dist += abs(curx -(j + 1)) + abs((int) ceil((float) board[counter] / 3.0) - (i + 1));\n      counter++;\n    }\n  }\n\n  //printf(\"manhattan distance is: %d\\n\", dist);\n  return dist;\n}\n\n\nint main() {\n  int i, j;\n  length = (int) sqrt((double) N + 1);\n  int *board = malloc(length * length * sizeof(int));\n\n  //printf(\"printing input board:\\n\");\n\n  for (i = 0; i < length * length; i++) {\n    scanf(\"%d\", &board[i]);\n    /*\n    if ((i + 1) % 3 == 0)\n      printf(\"%d\\n\", board[i]);\n    else\n      printf(\"%d \", board[i]);\n    */\n  }\n\n  printf(\"%d\\n\", heuristic(board));\n  return;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define N 3\n#define LIM 32\n#define HN 362897\n\nstruct dep{\n  int depth,key;\n};\n\nint ans[N][N]={\n  {1,2,3},\n  {4,5,6},\n  {7,8,0}\n};\n\nint min = LIM;\nstruct dep h[HN];\n\nint hash1(int k)\n{\n  return k % HN;\n}\nint hash2(int k)\n{\n  return 1 + k%(HN-1);\n}\nint hash(int k, int i)\n{\n  return (hash1(k) + i*hash2(k))%HN;\n}\n\n\nvoid dfs(int p[N][N], int n)\n{\n  int i,j,i0,j0,a=0,b=1;\n  int f=0;\n  int tmp[N][N];\n  for(i=0;i<N;i++)\n  {\n    for(j=0;j<N;j++)\n    {\n      if(ans[i][j]!=p[i][j])f++;\n      if(p[i][j]==0)\n      {\n        i0=i;\n        j0=j;\n      }\n      a+=p[i][j]*b;\n      b*=10;\n    }\n  }\n\n  if(f==0)\n  {\n    if(min>=n)\n    {\n      min=n;\n    }\n    return;\n  }\n  if(n>min) return;\n  i=0;\n  while(1)\n  {\n    b=hash(a, i);\n    if(h[b].key == 0)\n    {\n      h[b].key=a;\n      h[b].depth=n;\n      break;\n    }\n    else if(h[b].key == a)\n    {\n      if(h[b].depth>n)\n      {\n        h[b].depth=n;\n        break;\n      }\n      else return;\n    }\n    i++;\n  }\n\n  if(i0>0 && i0<N)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0-1][j0];\n    tmp[i0-1][j0]=f;\n    dfs(tmp, n+1);\n  }\n  if(j0>0 && j0<N)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0][j0-1];\n    tmp[i0][j0-1]=f;\n    dfs(tmp, n+1);\n  }\n\n  if(i0>=0 && i0<N-1)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0+1][j0];\n    tmp[i0+1][j0]=f;\n    dfs(tmp, n+1);\n  }\n  if(j0>=0 && j0<N-1)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0][j0+1];\n    tmp[i0][j0+1]=f;\n    dfs(tmp, n+1);\n  }\n\n}\n\nint main()\n{\n  int i,j;\n  int A[N][N];\n\n  for(i=0;i<N;i++)\n  {\n    for(j=0;j<N;j++)\n    {\n      scanf(\"%d\",&A[i][j]);\n    }\n  }\n  dfs(A,0);\n\n  printf(\"%d\\n\",min);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef unsigned char uchar;\n\n#define HASHSIZ 543217\ntypedef struct { unsigned s; char x, v; } HASH;\nHASH hash[HASHSIZ+3], *hashend = hash+HASHSIZ;\n\nint lookup(unsigned s, int x)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) return hp->v;\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\treturn 0;\n}\n\nvoid insert(unsigned s, int x, char v)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) { hp->v = v; break; }\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\thp->s = s, hp->x = x, hp->v = v;\n}\n\n#define QMAX 50000\ntypedef struct { unsigned s; char x, v; } T;\nT s[QMAX+3]; int top, end;\nint hi[9] = {2,3,2,3,4,3,2,3,2};\nint to[9][4] = {{1,3},{0,2,4},{1,5},{0,4,6},{1,3,5,7},{2,4,8},{3,7},{4,6,8},{5,7}};\n\nvoid toArray(char *nine, unsigned s, int x)\n{\n\tint i;\n\t\n\tfor (i = 8; i >= 0; i--) {\n\t\tif (i == x) nine[i] = 0;\n\t\telse nine[i] = s & 0xf, s >>= 4;\n\t}\n}\n\nunsigned swap(char *nine, int zero, int nx)\n{\n\tint i;\n\tunsigned res;\n\t\n\tres = 0;\n\tfor (i = 0; i < 9; i++) {\n\t\tif      (i == zero) res <<= 4, res |= nine[nx];\n\t\telse if (i != nx)   res <<= 4, res |= nine[i];\n\t}\n\treturn res;\n}\n\n#define MAGIC 20\n\nint main()\n{\n\tint i, x, nx, v, nv, t;\n\tunsigned a, na;\n\tunsigned gs; int gx;\t// goal\n\tchar nine[9];\n\t\n\tgs = 0; for (i = 0; i < 9; i++) {\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 0) gx = i;\n\t\telse gs <<= 4, gs |= t;\n\t}\n\ts[0].s = 0x12345678, s[0].x = 8;\n\ts[1].x = -1;\n\ttop = 0, end = 2;\n\tinsert(s[0].s, s[0].x, 0);\n\tv = 0;\n\twhile (top != end) {\n\t\ta = s[top].s, x = s[top].x;\n\t\tif (++top == QMAX) top = 0; \n\t\tif (x < 0) {\n\t\t\tif (v == MAGIC) break;\n\t\t\tv++;\n\t\t\ts[end].x = -1; if (++end == QMAX) end = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (x == gx && a == gs) goto done;\n\t\tif (lookup(a, x) < v) continue;\n\n\t\ttoArray(nine, a, x);\n\t\tfor (i = 0; i < hi[x]; i++) {\n\t\t\tnx = to[x][i];\n\t\t\tna = swap(nine, x, nx), nv = v+1;\n\t\t\tt = lookup(na, nx);\n\t\t\tif (!t || nv < t) {\n\t\t\t\ts[end].s = na, s[end].x = nx;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t\tinsert(na, nx, nv);\n\t\t\t}\n\t\t}\n\t}\n\n\ts[0].s = gs, s[0].x = gx, s[1].x = -1;\n\ttop = 0, end = 2;\n\tv = 0;\n\twhile (top != end) {\n\t\ta = s[top].s, x = s[top].x;\n\t\tif (++top == QMAX) top = 0; \n\t\tif (x < 0) {\n\t\t\tv++;\n\t\t\ts[end].x = -1; if (++end == QMAX) end = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((t = lookup(a, x)) > 0) { v += t; break; }\n\n\t\ttoArray(nine, a, x);\n\t\tfor (i = 0; i < hi[x]; i++) {\n\t\t\tnx = to[x][i];\n\t\t\tna = swap(nine, x, nx), nv = v+1;\n\t\t\tt = lookup(na, nx);\n\t\t\tif (!t || nv < t) {\n\t\t\t\ts[end].s = na, s[end].x = nx;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tprintf(\"%d\\n\", v);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nint puz[3][3];\nint temp[3][3];\n\nint dx[4]={0,1,0,-1}; \nint dy[4]={1,0,-1,0}; \n// for changing position up,down,left,right\nvoid empty(int x[],int y[])\n{\n  int i,j;\n  for(i=0;i<3;i++) \n  {\n    for(j=0;j<3;j++) \n    {\n      if(puz[i][j]==0) \n      {\n        *x = j;\n        *y = i;\n        return;\n      }\n    }\n  }\n}\nvoid swap(int a[],int b[])\n{\n  int temp;\n  temp=*a;\n  *a=*b;\n  *b=temp;\n}\nint calcum(){\n  int a;\n  int N=0;\n  for(int i=0; i<9; i++){\n    a = puz[i/3][i%3];\n    if(a!=0)\n    {\n      a=a-1;\n      N =N + abs((i/3)-(a/3))+abs((i%3)-(a%3));\n    }\n  }\n  return N;\n}\nint dfs(int x,int y,int p,int dep, int lim) \n{\n  int i,h,x2,y2,res;\n  h=calcum();\n  \n  if(h==0) return dep;\n  if(dep+h>lim) return -1;\n  for(i=0;i<4;i++)\n  {\n    x2=x+dx[i];  \n    y2=y+dy[i];\n    if(~p && i==(p+2)%9) //////\n        continue;\n    if(!(0<=x2 && x2<3 && 0<=y2 && y2<3)) \n        continue;\n    swap(&puz[y][x],&puz[y2][x2]);\n    res = dfs(x2,y2,i,dep+1,lim);\n    if(~res) \n        return res;\n    swap(&puz[y][x],&puz[y2][x2]);\n  }\n  return -1;\n}\nint main() {\n  int def,x,y;\n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++)\n    {\n        scanf(\"%d\",&puz[i][j]);\n        temp[i][j]= puz[i][j];\n    }  \n  }\n  empty(&x,&y);\n  \n  for(int i=0;i<100;i++)\n  {\n    def=dfs(x,y,-1,0,i);\n    if(def!=-1)\n    {\n      printf(\"%d\\n\",def);\n      break;\n    }\n  \n    def = -1;  \n    if(i==99) \n        printf(\"%d\\n\",def);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "/* \n * File:   main.c\n * Author: s1252007\n *\n * Created on August 2, 2018, 11:10 PM\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define Axiom 1\n#define Flaw 0\n#define Void 0\n#define Bi_Force 2\n#define Tri_Force 3\n#define Quad_Force 4\n\n/*\n * \n */\n\nint ow[] = {-1, 0, 1, 0};\nint oh[] = {0, 1, 0, -1};\nint round_table[Tri_Force][Tri_Force], lancelot;\n\nvoid swap(int *apple, int *pen);\nint getYourFatAssHereHeuriChan();\nint check(int intensity, int quondam, int loki, int odin);\nvoid solve(int loki, int odin);\n\nint main()\n{\n    int loki, odin;\n    for(int i = Void; i < Tri_Force; ++i)\n    {\n        for(int j = Void; j < Tri_Force; ++j)\n        {\n            scanf(\"%d\", &round_table[i][j]);\n            if(round_table[i][j] == Void )\n            {\n                loki = i;\n                odin = j;\n            }\n        }\n    }\n    \n    solve(loki, odin);\n    \n    return EXIT_SUCCESS;\n}\n\nvoid swap(int *apple, int *pen)\n{\n    int apple_pen = *apple;\n    *apple = *pen;\n    *pen = apple_pen;\n}\n\nint getYourFatAssHereHeuriChan()\n{\n    int heuri_chan = Void, arthur;\n    for(int i = Void; i < Tri_Force; ++i)\n    {\n        for(int j = Void; j < Tri_Force; ++j)\n        {\n            if(round_table[i][j] == Void) continue;\n            arthur = round_table[i][j] - 1;\n            heuri_chan = abs((arthur / Tri_Force) - i) + abs((arthur % Tri_Force) - j) + heuri_chan;\n        }\n    }\n    return heuri_chan;\n}\n \nint check(int intensity, int quondam, int loki, int odin)\n{\n    int heuri_chan;\n    heuri_chan = getYourFatAssHereHeuriChan();\n    if(heuri_chan + intensity > lancelot) return Flaw;\n    if(heuri_chan == Void) return Axiom;\n    for(int i = Void; i < Quad_Force; ++i)\n    {\n        if(abs(i - quondam) == Bi_Force) continue;\n        \n        int hel = loki + ow[i],gungnir = odin + oh[i];\n        if(hel < Void || gungnir < Void || hel >= Tri_Force || gungnir >= Tri_Force) continue;\n        \n        swap(&round_table[hel][gungnir], &round_table[loki][odin]);\n        if(check(intensity+1, i, hel, gungnir)) return Axiom;\n        \n        swap(&round_table[hel][gungnir], &round_table[loki][odin]);\n    }\n    return Flaw;\n}\n \nvoid solve(int loki, int odin)\n{\n    for(;;)\n    {\n        if(check(0, 1000, loki, odin))\n        {\n            printf(\"%d\\n\", lancelot);\n            return;\n        }\n        lancelot++;\n    }\n}\n \n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define Ni 3\n\nint pzl[Ni][Ni],tmp[Ni][Ni];\nint Dx[4]={0,1,0,-1},Dy[4]={1,0,-1,0};\n\nvoid emblem(int *a,int *b){\n  int i,j;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(!pzl[i][j]){\n\t*a = j;\n\t*b=i;\n      }\n    }\n  }\n}\n\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp =*a;\n  *a = *b;\n  *b = tmp;\n}\n\nint check(){\n  int i,A,S=0;\n  for(i=0;i<9;i++){\n    A = pzl[i/3][i%3];\n    if(A){\n      A--;\n      S += abs(i/3-A/3) + abs(i%3 - A%3);\n    }\n  }\n  \n  return S;\n}\n\nint defain(int a,int b,int P,int D,const int shin){\n  int i,hi,A,B,result;\n  hi = check();\n  if(hi==0){\n    return D;\n  }\n  \n  if(D+hi>shin){\n    return -1;\n  }\n\n  for(i=0;i<4;i++){\n    A = a+Dx[i];\n    B = b+Dy[i];\n    if(~P && i==(P+2)%4) {\n      continue;\n    }\n    if(!(0<=A && A<3 && 0<=B && B<3)){\n      continue;\n    }\n    swap(&pzl[b][a],&pzl[B][A]);\n    result = defain(A,B,i,D+1,shin);\n    if(~result){\n      return result;\n    }\n    swap(&pzl[b][a],&pzl[B][A]);\n  }\n  \n  return -1;\n  \n}\n\nint main(){\n  int i,j,li,TA,a,b;\n\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&pzl[i][j]);\n    }\n  }\n\n  emblem(&a,&b);\n  for(li=0;li<100;li++){\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n\ttmp[i][j]=pzl[i][j];\n      }\n    }\n    \n    TA = defain(a,b,-1,0,li);\n    if(TA!=-1){\n      printf(\"%d\\n\",TA);\n      break;\n    }\n\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n\tpzl[i][j]=tmp[i][j];\n      }\n    }\n\n    TA = -1;\n    if(li==99){\n      printf(\"%d\\n\",TA);\n    }\n  }\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define Size 9\n#define Edge 3\n#define Heap_size 102400\n#define Hash_size 102400\n#define Goal_val 0x123456780LL\nstruct heap_table {\n  long long data;\n  int space;\n  int depth;\n  int score;\n};\nstruct hash_table {\n  long long data;\n  struct hash_table *next;\n};\nint goal_score, heapsize, dir[Size], to[Size][4];\nstruct heap_table heap[Heap_size];\nstruct hash_table *hash[Hash_size];\n\nlong long swap(int*, int, int);\nlong long board_val(int*);\nvoid val_board(long long, int*);\nint fair_evaluate(int*, int *);\nvoid downheap(int);\nvoid upheap(int);\nvoid hash_insert(long long);\nint hash_search(long long);\nint Bfs(int*, int*, int);\nint main(void)\n{\n  int i, j, result, space, init[Size], goal[Size];\n  for (i = 0; i < Hash_size; i++) hash[i] = NULL;\n  for (i = 0; i < Size; i++) {\n    int dcount = 0;\n    scanf(\"%d\", &init[i]);\n    if (!init[i]) space = i;\n    goal[i] = (i + 1) % Size;\n    if (i > Edge - 1) to[i][dcount++] = i - Edge;\n    if (i % Edge) to[i][dcount++] = i - 1;\n    if ((i + 1) % Edge) to[i][dcount++] = i + 1;\n    if (i < Size - Edge) to[i][dcount++] = i + Edge;\n    dir[i] = dcount;\n  }\n  for (i = 0; i < Size / 2; i++) goal_score += goal[Size - 1 - i] - goal[i];\n  printf(\"%d\\n\", Bfs(init, goal, space));\n}\nlong long swap(int *board, int space, int next)\n{\n  int i;\n  long long res = 0;\n  for (i = 0; i < Size; i++) {\n    res <<= 4;\n    if (i == space) res |= board[next];\n    if (i == next) res |= board[space];\n    else res |= board[i];\n  }\n  return res;\n}\nlong long board_val(int *board)\n{\n  int i;\n  long long val = 0;\n  for (i = 0; i < Size; i++) {\n    val <<= 4;\n    val |= board[i];\n  }\n  return val;\n}\nvoid val_board(long long val, int *board)\n{\n  int i;\n  for (i = 0; i < Size; i++) {\n    board[Size - 1 - i] = val & 0xf;\n    val >>= 4;\n  }\n}\nint fair_evaluate(int *board, int *goal) {\n  int i, j, score = 0;\n  for (i = 1; i < Size; i++) {\n    int x1, y1, x2, y2;\n    for (j = 0; j < Size; j++) {\n      if (board[j] == i) {\n        x1 = j % Edge;\n        y1 = j / Edge;\n      }\n      if (goal[j] == i) {\n        x2 = j % Edge;\n        y2 = j / Edge;\n      }\n    }\n    score += abs(x1 - x2) + abs(y1 - y2);\n  }\n  return score;\n}\nvoid downheap(int k) {\n  int j;\n  struct heap_table v = heap[k];\n  while (k < heapsize / 2) {\n    j = 2 * k + 1;\n    if (j < heapsize - 1 && heap[j].score > heap[j + 1].score) j++;\n    if (v.score <= heap[j].score) break;\n    heap[k] = heap[j];\n    k = j;\n  }\n  heap[k] = v;\n}\nvoid upheap(int j)\n{\n  int k;\n  struct heap_table v = heap[j];\n  while (j > 0) {\n    k = (j + 1) / 2 - 1;\n    if (v.score >= heap[k].score) break;\n    heap[j] = heap[k];\n    j = k;\n  }\n  heap[j] = v;\n}\nvoid hash_insert(long long val)\n{\n  struct hash_table *p = (struct hash_table*)malloc(sizeof(struct hash_table));\n  p->data = val;\n  p->next = hash[val % Hash_size];\n  hash[val % Hash_size] = p;\n}\nint hash_search(long long val)\n{\n  struct hash_table *n;\n  for (n = hash[val % Hash_size]; n != NULL; n = n->next) {\n      if (val == n->data) return 1;\n  }\n  return 0;\n}\nint Bfs(int *init, int *goal, int spa)\n{\n  struct heap_table theap;\n  int i, board[Size];\n  theap.data = board_val(init);\n  heap[heapsize].data = theap.data;\n  heap[heapsize].space = spa;\n  heap[heapsize].depth = 0;\n  heap[heapsize++].score = fair_evaluate(init, goal);\n  if (theap.data == Goal_val) return 0;\n  hash_insert(theap.data);\n  while (heapsize > 0) {\n    theap.data = heap[0].data;\n    val_board(theap.data, board);\n    theap.space = heap[0].space;\n    theap.depth = heap[0].depth;\n    heap[0] = heap[--heapsize];\n    downheap(0);\n    for (i = 0; i < dir[theap.space]; i++) {\n      int next = to[theap.space][i], nboard[Size];\n      long long nval = swap(board, theap.space, next);\n      if (!hash_search(nval)) {\n        if (nval == Goal_val) return theap.depth + 1;\n        hash_insert(nval);\n        heap[heapsize].data = nval;\n        heap[heapsize].space = next;\n        heap[heapsize].depth = theap.depth + 1;\n        val_board(nval, nboard);\n        heap[heapsize++].score = fair_evaluate(nboard, goal) + theap.depth + 1;\n        upheap(heapsize - 1);\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint puz[3][3];\nint tmp[3][3];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n\nvoid empty(int *x,int *y) {\n  int i,j;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(!puz[i][j]){\n        *x=j;\n        *y=i;\n        return;\n      }\n    }\n  }\n}\n\nvoid swap(int *a, int *b) {\n  int tmp;\n  tmp= *a;\n  *a= *b;\n  *b=tmp;\n}\n\nint cal() {\n  int i,a;\n  int sum=0;\n  for(i=0;i<9;i ++){\n    a=puz[i/3][i%3];\n    if(a){\n      a--;\n      sum+=abs(i/3-a/3)+abs(i%3-a%3);\n    }\n  }\n  return sum;\n}\n\nint dfs(int x, int y, int p, int dep, const int lim) {\n  int i,h,nx,ny,res;\n  h=cal();\n  if(h==0){\n    return dep;\n  }\n  if(dep+h>lim){\n    return -1;\n  }\n  for(i=0;i<4;i++){\n    nx=x+dx[i];\n    ny=y+dy[i];\n    if(~p&&i==(p+2)%4) continue;\n    if(!(0<=nx&&nx<3&&0<=ny&&ny<3)) continue;\n    swap(&puz[y][x],&puz[ny][nx]);\n    res=dfs(nx,ny,i,dep+1,lim);\n    if(~res){\n      return res;\n    }\n    swap(&puz[y][x],&puz[ny][nx]);\n    }\n  return -1;\n}\n\nint main() {\n  int i,j,ans,x,y,l;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&puz[i][j]);\n    }\n  }\n  empty(&x,&y);\n  for(l=0;l<100;l++){\n    for(i=0;i<3;i++){\n      for(j =0;j<3;j++){\n        tmp[i][j] = puz[i][j];\n      }\n    }\n    ans=dfs(x,y,-1,0,l);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n        puz[i][j]=tmp[i][j];\n      }\n    }\n    ans= -1;\n    if(l==99){\n      printf(\"%d\\n\",ans);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n#define Last (Total - 1)\n\n\nextern void down_0(void);\nextern void up_0(void);\nextern void right_0(void);\nextern void left_0(void);\n\n\nint cnt,num = 0;\nint val[Total] ={};\n\n\nint main( void )\n{\n \n    int ori[Total] ={};\n    \n    \n    int i = 0;\n    int finish = 0;\n    int num_0,num_1 = 0;\n    int x,y = 0;\n     \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        ori[i]=val[i];\n        \n        if(val[i] == 0)\n        {\n            num_0 = i;\n        }\n    }\n    \n    x = tate - (num_0/yoko);\n    y = yoko - (num_0%yoko);\n    \n    while(finish==0)\n    {\n        // 初期化\n        for(i=0; i<Total; i++)\n        {\n            val[i]=ori[i];\n        }\n        num = num_0;\n        cnt = 0;\n        \n        \n        left_0();\n        down_0();\n        right_0();\n        down_0();\n        \n//  printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);        \n        \n        finish = 1;\n        for(i=0; i<Total-1; i++)\n        {\n            if(val[i] != (i+1))\n            {\n                finish = 0;\n                break;\n            }\n        }\n    }\n     \n    printf(\"%d\\n\",cnt);\n \n    return 0;\n}\n \nvoid down_0()\n{\n    val[num] = val[num + yoko];\n    val[num + yoko] = 0;\n    num = num + yoko;\n    cnt = cnt + 1;\n}\n \nvoid up_0()\n{\n    val[num] = val[num - yoko];\n    val[num - yoko] = 0;\n    num = num - yoko;\n    cnt = cnt + 1;\n}\n \nvoid right_0()\n{\n    val[num] = val[num +1];\n    val[num +1] = 0;\n    num = num + 1;\n    cnt = cnt + 1;\n}\n \nvoid left_0()\n{\n\n    val[num] = val[num -1];\n    val[num -1] = 0;\n    num = num - 1;\n    cnt = cnt + 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n\n#define MAX 362880\n#define N 3\n#define N2 9\n\n\ntypedef struct puzzle{\n  int f[N2];\n  int space;\n  int path;\n}PUZZLE;\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\n\nint V[MAX];\n\nPUZZLE Q[MAX];\nint head, tail;\n\nvoid push(PUZZLE x){\n  Q[tail] = x;\n  tail = (tail+1)%MAX;\n}\n\nPUZZLE pop(){\n  PUZZLE x;\n  x = Q[head];\n  head = (head+1)%MAX;\n  return x;\n}\n\nint check(PUZZLE p){\n  int i, j, fac, count, res = 0;\n  for(i = 0, fac = 1; i < N2; fac*= ++i){\n    for(j = 0, count = 0; j < i; j++){\n      if(p.f[j] < p.f[i]) count++;\n    }\n    res += count*fac;\n  }\n  return res;\n}\n\nint isTarget(PUZZLE p){\n  int i;\n  for(i = 0; i < N2; i++ )\n    if(p.f[i] != (i + 1) )\n      return 0;\n  return 1;\n}\n\nint bfs(PUZZLE s){\n  int sx, sy, tx, ty, r, temp;\n  PUZZLE u, v;\n\n  s.path = 0;\n  push(s);\n  V[check(s)] = 1;\n\n  while(head != tail){\n    u = pop();\n\n    if( isTarget(u))\n      return u.path;\n\n    sx = u.space / N;\n    sy = u.space % N;\n\n    for ( r = 0; r < 4; r++ ) {\n      tx = sx + dx[r];\n      ty = sy + dy[r];\n\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N)\n\tcontinue;\n      \n      v = u;\n      temp = v.f[u.space];\n      v.f[u.space] = v.f[tx * N + ty];\n      v.f[tx * N + ty] = temp;\n\n      v.space = tx * N + ty;\n\n      if( !V[check(v)] ){\n\tV[check(v)] = 1;\n\tv.path++;\n\tpush(v);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int i, ans;\n  PUZZLE in;\n\n  for( i = 0; i < N2; i++ ) {\n    scanf(\" %d\", &in.f[i]);\n    if( in.f[i] == 0) {\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n\n  ans = bfs(in);\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint m[3][3];\nint copy[3][3];\n\nvoid input(void){\n    int i,j;\n    for(i=0;i<3;i++){\n        for(j=0;j<3;j++){\n            scanf(\"%d\",&m[i][j]);\n        }\n    }\n}\nvoid output(void){\n    int i,j;\n    for(i=0;i<3;i++){\n        for(j=0;j<3;j++){\n            printf(\"%3d\",m[i][j]);\n            puts(\"\");\n        }\n    }\n}\nvoid cp(int a[3][3],int b[3][3]){\n    int i,j;\n    for(i=0;i<3;i++){\n        for(j=0;j<3;j++){\n            a[i][j] = b[i][j];\n        }\n    }\n}\nint calc(void){\n    int i,sum = 0;\n    for(i=0;i<9;i++){\n        int a = m[i/3][i%3];\n        if(a){\n            a--;\n            sum += abs(i/3 - a/3)+abs(i%3 - a%3);\n        }\n    }\n    return sum;\n}\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nvoid swap(int *a, int *b){\n    int tmp;\n    tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\nint in(int a,int b){\n    return 0<=a&&a<3&&0<=b&&b<3;\n}\nint df(int a,int b,int p,int d,const int lim){\n    int i , h=calc();\n    if(h == 0)return d;\n    if(d+h > lim)return -1;\n    \n    for(i=0;i<4;i++){\n        int x= a+dx[i],y=b+dy[i];\n        int res;\n        if(~p && i == (p+2)%4)continue;\n        if(!in(x,y))continue;\n        swap(&m[b][a],&m[y][x]);\n        res = df(x,y,i,d+1,lim);\n        if(~res)return res;\n        swap(&m[b][a],&m[y][x]);\n    }\n    return -1;\n}\n\nvoid empty(int *a, int *b){\n    int i,j;\n    for(i=0;i<3;i++){\n        for(j=0;j<3;j++){\n            if(!m[i][j]){\n                *a = j;\n                *b = i;\n                return;\n            }\n        }\n    }\n}\nint s(void){\n    int a,b,lim,x;\n    empty(&a,&b);\n    for(lim = 0;lim < 50;lim++){\n        cp(copy,m);\n        if((x = df(a,b,-1,0,lim)) != -1)return x;\n        cp(m,copy);\n    }\n    return -1;\n}\nint main(){\n    input();\n    printf(\"%d\\n\",s());\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n????\nint mas[3][3];\nint cpy[3][3];\n????\nvoid input() {\n????int i, j;\n????for(i = 0; i < 3; i++)\n????????for(j = 0; j < 3; j++)\n????????????scanf(\"%d\", &mas[i][j]);\n}\n????\nvoid output() {\n????int i, j;\n????for(i = 0; i < 3; i++) {\n????????for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n????????puts(\"\");\n????}\n}\n????\nvoid copy(int m[3][3], int t[3][3]) {\n????int i, j;\n????\n????for(i = 0; i < 3; i++)\n????????for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n????\nint calc() {\n????int i, sum = 0;\n????for(i = 0; i < 9; i++) {\n????????int v = mas[i/3][i%3];\n????????if(v) {\n????????????v--;\n????????????sum += abs(i/3-v/3)+abs(i%3-v%3);\n????????}\n????}\n????return sum;\n}\n????\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n????\nvoid swap(int *a, int *b) {\n????int tmp = *a;\n????*a = *b;\n????*b = tmp;\n}\n????\nint is_in(int x, int y) {\n????return 0<=x&&x<3&&0<=y&&y<3;\n}\n????\nint dfs(int x, int y, int p, int dep, const int lim) {\n????int i, h = calc();\n????//output();\n????if(h == 0) return dep;\n????//printf(\"%d %d %d\\n\", h, lim, p);\n????if(dep+h > lim) return -1;\n????\n????for(i = 0; i < 4; i++) {\n????????int nx = x+dx[i], ny = y+dy[i], res;\n????????if(~p && i == (p+2)%4) continue;\n????????if(!is_in(nx, ny)) continue;\n????????swap(&mas[y][x], &mas[ny][nx]);\n????????res = dfs(nx, ny, i, dep+1, lim);\n????????if(~res) return res;\n????????swap(&mas[y][x], &mas[ny][nx]);\n????}\n????\n????return -1;\n}\n????\nvoid get_empty(int *x, int *y) {\n????int i, j;\n????for(i = 0; i < 3; i++) {\n????????for(j = 0; j < 3; j++) {\n????????????if(!mas[i][j]) {\n????????*x = j;\n????????*y = i;\n????????return;\n????????????}\n????????}\n????}\n}\n????\nint solve() {\n????int x, y, lim, ans;\n????get_empty(&x, &y);\n????for(lim = 0; lim < 50; lim++) {\n????????copy(cpy, mas);\n????????if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n????????copy(mas, cpy);\n????}\n????return -1;\n}\n????\nint main() {\n????input();\n????printf(\"%d\\n\", solve());\n????return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define PUZZLE_SIZE 3\n#define DIRECTION_SIZE 4\n#define RESOLVED_PUZZLE_KEY 123456780\n#define DEFAULT_QUEUE_SIZE 16\n\ntypedef enum { UP, DOWN, RIGHT, LEFT } direction_t;\ntypedef struct { int row, col; } cell_t;\ntypedef struct { int cnt, size, key, **p; cell_t zero; } state_t;\ntypedef struct { int head, tail, size, max; state_t **arr; } queue_t;\ntypedef struct Node { int bf, x; struct Node *p, *l, *r; } node_t;\n\nstatic queue_t *new_queue(int);\nstatic void free_queue(queue_t *);\nstatic void enqueue(queue_t *, state_t *);\nstatic state_t *dequeue(queue_t *);\n\nstatic node_t *new_node(int);\nstatic void free_node(node_t *);\nstatic void insert_node(node_t *, node_t *);\nstatic node_t *find_node(node_t *, int);\nstatic node_t *rotate_left(node_t *);\nstatic node_t *rotate_right(node_t *);\nstatic node_t *rebalance(node_t *);\n\nstatic state_t *new_state(int);\nstatic state_t *copy_state(const state_t *);\nstatic void free_state(state_t *);\nstatic int advance_state(state_t *, direction_t);\nstatic void update_state_key(state_t *);\n\nstatic queue_t *new_queue(int size) {\n  queue_t *q;\n  int i;\n\n  q = (queue_t *) malloc(sizeof(queue_t));\n  q->head = q->tail = q->size = 0;\n  q->max = size;\n  q->arr = (state_t **) malloc(sizeof(state_t *) * q->max);\n  for (i = 0; i < q->max; ++i) q->arr[i] = NULL;\n  return q;\n}\n\nstatic void free_queue(queue_t *q) {\n  while (q->head < q->tail) {\n    free_state(q->arr[q->head]);\n    q->head = (q->head + 1) % q->max;\n  }\n  free(q->arr);\n  free(q);\n}\n\nstatic void enqueue(queue_t *q, state_t *s) {\n  int i, range, expanded;\n\n  q->size++;\n  if (q->size == q->max) {\n    range = q->max - q->head;\n    expanded = q->max;\n    q->max *= 2;\n    q->arr = (state_t **) realloc(q->arr, sizeof(state_t *) * q->max);\n    if (q->head > q->tail) {\n      for (i = q->max - 1; i >= q->tail; --i) q->arr[i] = (i >= q->max - range) ? q->arr[i - expanded] : NULL;\n      q->head = q->max - range;\n    }\n  }\n  q->arr[q->tail] = s;\n  q->tail = (q->tail + 1) % q->max;\n}\n\nstatic state_t *dequeue(queue_t *q) {\n  state_t *s;\n\n  if (q->size == 0) return NULL;\n  s = q->arr[q->head];\n  q->arr[q->head] = NULL;\n  q->head = (q->head + 1) % q->max;\n  q->size--;\n  return s;\n}\n\nstatic node_t *new_node(int x) {\n  node_t *n;\n\n  n = (node_t *) malloc(sizeof(node_t));\n  n->p = n->l = n->r = NULL;\n  n->x = x;\n  n->bf = 1;\n  return n;\n}\n\nstatic void free_node(node_t *n) {\n  if (n == NULL) return;\n  free_node(n->l);\n  free_node(n->r);\n  free(n);\n}\n\nstatic void insert_node(node_t *r, node_t *n) {\n  if (n->x < r->x) {\n    if (r->l == NULL) {\n      r->l = n;\n      n->p = r;\n    } else {\n      insert_node(r->l, n);\n    }\n  } else if (n->x > r->x) {\n    if (r->r == NULL) {\n      r->r = n;\n      n->p = r;\n    } else {\n      insert_node(r->r, n);\n    }\n  }\n}\n\nstatic node_t *find_node(node_t *n, int x) {\n  node_t *ret;\n\n  if (n == NULL) {\n    ret = NULL;\n  } else if (x == n->x) {\n    ret = n;\n  } else if (x < n->x) {\n    ret = find_node(n->l, x);\n  } else if (x > n->x) {\n    ret = find_node(n->r, x);\n  } else {\n    ret = NULL;\n  }\n  return ret;\n}\n\nstatic node_t *rotate_left(node_t *n) {\n  node_t *p, *r;\n\n  if (n == NULL) return n;\n\n  p = n->p;\n  r = n->r;\n\n  if (p != NULL) {\n    if (p->x > r->x) {\n      p->l = r;\n    } else {\n      p->r = r;\n    }\n  }\n\n  n->p = r;\n  n->r = r->l;\n  n->bf = r->bf - 1;\n\n  r->p = p;\n  r->l = n;\n\n  return r;\n}\n\nstatic node_t *rotate_right(node_t *n) {\n  node_t *p, *l;\n\n  if (n == NULL) return n;\n\n  p = n->p;\n  l = n->l;\n\n  if (p != NULL) {\n    if (p->x > l->x) {\n      p->l = l;\n    } else {\n      p->r = l;\n    }\n  }\n\n  n->p = l;\n  n->l = l->r;\n  n->bf = l->bf - 1;\n\n  l->p = p;\n  l->r = n;\n\n  return l;\n}\n\nstatic node_t *rebalance(node_t *n) {\n  int l, r;\n\n  if (n == NULL) return n;\n  l = n->l == NULL ? 0 : n->l->bf;\n  r = n->r == NULL ? 0 : n->r->bf;\n  n->bf = (l > r ? l : r) + 1;\n  if ((l - r < 0 ? (l - r) * -1 : l - r) > 1) {\n    if (l < r) {\n      n = rotate_left(n);\n    } else {\n      n = rotate_right(n);\n    }\n  }\n  return n->p ? rebalance(n->p) : n;\n}\n\nstatic state_t *new_state(int size) {\n  state_t *s;\n  int i;\n\n  s = (state_t *) malloc(sizeof(state_t));\n  s->size = size;\n  s->cnt = s->zero.row = s->zero.col = s->key = 0;\n  s->p = (int **) malloc(sizeof(int *) * s->size);\n  for (i = 0; i < s->size; ++i) s->p[i] = (int *) malloc(sizeof(int) * s->size);\n  return s;\n}\n\nstatic state_t *copy_state(const state_t *src) {\n  state_t *dest;\n  int i, j;\n\n  dest = new_state(src->size);\n  dest->cnt = src->cnt;\n  dest->zero = src->zero;\n  dest->key = src->key;\n  for (i = 0; i < dest->size; ++i) {\n    for (j = 0; j < dest->size; ++j) dest->p[i][j] = src->p[i][j];\n  }\n  return dest;\n}\n\nstatic void free_state(state_t *s) {\n  int i;\n\n  for (i = 0; i < s->size; ++i) free(s->p[i]);\n  free(s->p);\n  free(s);\n}\n\nstatic int advance_state(state_t *s, direction_t d) {\n  switch (d) {\n    case UP:\n      if (s->zero.row + 1 == s->size) return 1;\n      s->p[s->zero.row][s->zero.col] = s->p[s->zero.row + 1][s->zero.col];\n      s->zero.row++;\n      break;\n    case DOWN:\n      if (s->zero.row - 1 < 0) return 1;\n      s->p[s->zero.row][s->zero.col] = s->p[s->zero.row - 1][s->zero.col];\n      s->zero.row--;\n      break;\n    case RIGHT:\n      if (s->zero.col - 1 < 0) return 1;\n      s->p[s->zero.row][s->zero.col] = s->p[s->zero.row][s->zero.col - 1];\n      s->zero.col--;\n      break;\n    case LEFT:\n      if (s->zero.col + 1 == s->size) return 1;\n      s->p[s->zero.row][s->zero.col] = s->p[s->zero.row][s->zero.col + 1];\n      s->zero.col++;\n      break;\n  }\n  s->p[s->zero.row][s->zero.col] = 0;\n  update_state_key(s);\n  s->cnt++;\n  return 0;\n}\n\nstatic void update_state_key(state_t *s) {\n  int i, j, d;\n\n  for (i = 0, d = 1; i < (s->size * s->size - 1); ++i, d *= 10) {}\n  for (i = s->key = 0; i < s->size; ++i) {\n    for (j = 0; j < s->size; ++j, d /= 10) {\n      s->key += s->p[i][j] * d;\n    }\n  }\n}\n\nstatic int eight_puzzle(const state_t *s) {\n  direction_t d[DIRECTION_SIZE] = {UP, DOWN, RIGHT, LEFT};\n  state_t *s1, *s2;\n  node_t *root, *node;\n  queue_t *q;\n  int cnt, fail, i;\n\n  cnt = -1;\n  q = new_queue(DEFAULT_QUEUE_SIZE);\n  s1 = copy_state(s);\n  enqueue(q, s1);\n  root = new_node(s1->key);\n\n  // BFS\n  while (q->size > 0) {\n    s1 = dequeue(q);\n    if (s1 == NULL) break; // unsolvable or bug\n    if (s1->key == RESOLVED_PUZZLE_KEY) {\n      cnt = s1->cnt;\n      free_state(s1);\n      break;\n    }\n    for (i = 0; i < DIRECTION_SIZE; ++i) {\n      s2 = copy_state(s1);\n      fail = advance_state(s2, d[i]);\n      node = find_node(root, s2->key);\n      if (fail || node) {\n        free_state(s2);\n        continue;\n      }\n      enqueue(q, s2);\n      node = new_node(s2->key);\n      insert_node(root, node);\n      root = rebalance(root);\n    }\n    free_state(s1);\n  }\n\n  free_queue(q);\n  free_node(root);\n  return cnt;\n}\n\nint main(int argc, char **argv) {\n  state_t *s;\n  int i, j;\n\n  for (i = 0, s = new_state(PUZZLE_SIZE); i < s->size; ++i) {\n    for (j = 0; j < s->size; ++j) {\n      scanf(\"%d\", &s->p[i][j]);\n      if (s->p[i][j] == 0) {\n        s->zero.row = i;\n        s->zero.col = j;\n      }\n    }\n  }\n  update_state_key(s);\n  printf(\"%d\\n\", eight_puzzle(s));\n  free_state(s);\n}\n"
  },
  {
    "language": "C",
    "code": "\n#include <stdio.h> \n#include <stdlib.h> \n#define n_max 500000000\nint p_8_8sul[3][3]; \nint k_3_3_template[3][3]; \nint deleta_x_j[4] = {0,1,0,-1}; \nint deleta_y_j[4] = {1,0,-1,0}; \n\n\nvoid ch_em_k(int *x,int *y);\nvoid ch_sw_k(int *a,int *b);\nint ch_cl_k();\nint ch_df_k(int x,int y,int p,int dep,const int lim);\nvoid o_check1_kaisuu(int );\nvoid o_ch_kaisuu(int );\nvoid o_ch3_kaisuu(int );  \n\n   \nint main() { \n  int i,j,cout_ans,x,y,l,n[n_max],h[n_max];\n  char p[n_max],liok[n_max];\n    int chchch=0;\n    int macc;\n    int dett;\n    int check[5000000000];\n    for(int dett=0;dett<9;dett++){\n      macc=macc*macc;\n    }\n    for(dett=0;dett<macc;dett++){\n      p[dett]='y';\n      liok[dett]='o';\n    }\n    \n    \n    for(i=0; i<3; i++){ \n        for(j=0; j<3; j++) scanf(\"%d\",&p_8_8sul[i][j]); \n    }\n    /*chchch++;\n      printf(\"%d\",chchch);*/\n    ch_em_k(&x,&y); \n    for(l=0; l<100; l++){ \n        for(i=0; i<3; i++){ \n            for(j=0; j<3; j++) k_3_3_template[i][j] = p_8_8sul[i][j];\n\t    /*chchch++;\n\t      printf(\"%d\",chchch);*/\n        } \n           \n        cout_ans = ch_df_k(x,y,-1,0,l); \n        if(cout_ans!=-1){ \n            printf(\"%d\\n\",cout_ans); \n            break; \n        } \n           \n        for(i=0; i<3; i++){ \n            for(j=0; j<3; j++) p_8_8sul[i][j] = k_3_3_template[i][j]; \n        } \n        /*chchch++;\n\t  printf(\"%d\",chchch);*/   \n        cout_ans = -1; \n        if(l==99) printf(\"%d\\n\",cout_ans); \n    } \n       \n    return 0; \n}\n\n\n\n\nvoid ch_em_k(int *x,int *y) { \n  int i,j; \n  for(i=0; i<3; i++) { \n    for(j=0; j<3; j++) { \n      if(!p_8_8sul[i][j]) { \n*x = j; \n*y = i; \nreturn; \n      } \n    } \n  } \n} \n\nvoid o_check_kaisuu(int w){\n  int i=0;\n  int m=9;\n  int check[5000000000];\n  for(i=0;i<9;i++){\n    m=m*m;\n  }\n  for(i=0;i<m;i++){\n    check[i]=m;\n  }\n}\n\n\n\n\n\nvoid ch_sw_k(int *a,int *b){ \n  int k_3_3_template; \n  k_3_3_template = *a; \n  *a = *b; \n  *b = k_3_3_template; \n} \n   \nint ch_cl_k(){ \n  int i,a,a_b_p_p=0;  \n  for(i=0; i<9; i++){ \n    a = p_8_8sul[i/3][i%3]; \n    if(a){ \n      a--; \n      a_b_p_p += abs(i/3 - a/3) + abs(i%3 - a%3); \n    } \n  }     \n  return a_b_p_p; \n} \n\nvoid o_ch_kaisuu(int w){\n  int i=0;\n  int m=8;\n  int check[5000000000];\n  for(i=0;i<8;i++){\n    m=m*m;\n  }\n  for(i=0;i<m;i++){\n    check[i]=m;\n  }\n}\n\n\n\n\n\nint ch_df_k(int x,int y,int p,int dep,const int lim){ \n    int i,h,nx,ny,res;    \n    h = ch_cl_k(); \n    if(h==0) return dep; \n    if(dep+h>lim) return -1;  \n    for(i=0; i<4; i++){ \n        nx = x+deleta_x_j[i]; \n        ny = y+deleta_y_j[i];       \n        if(~p && i==(p+2)%4) continue; \n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;     \n        ch_sw_k(&p_8_8sul[y][x],&p_8_8sul[ny][nx]); \n        res = ch_df_k(nx,ny,i,dep+1,lim); \n        if(~res) return res;        \n        ch_sw_k(&p_8_8sul[y][x],&p_8_8sul[ny][nx]); \n    }    \n    return -1; \n}\n\n\n\n\n\nvoid o_ch3_kaisuu(int w){\n  int i=0;\n  int m=7;\n  int check[5000000000];\n  for(i=0;i<7;i++){\n    m=m*m;\n  }\n  for(i=0;i<m;i++){\n    check[i]=m;\n  }\n}\n\n\n/*#include <stdio.h>\n#include <stdbool.h>\n\n\n#define Niii 8\n#define freeqqq -1\n#define not_freewww 1\n\nvoid inter(void);\nvoid board(void);\nvoid recursive(int );\n\nint row[Niii],col[Niii],dpos[2*Niii-1],dneg[2*Niii-1];\n\nbool X[Niii][Niii];\n\n\n\nint main()\n{\n  inter();\n\n  for(int i=0;i<Niii;i++){\n    for(int j=0;j<Niii;j++){\n      X[i][j]=false;\n\n    }\n  }\n\n  int k;\n  scanf(\"%d\",&k);\n  for(int i=0;i<k;i++){\n    int r,c;\n    scanf(\"%d%d\",&r,&c);\n    X[r][c]=true;\n  }\n\n  recursive(0);\n  return 0;\n}\n\n\n\nvoid inter(){\n  int i;\n  for(i=0;i<Niii;i++){\n    row[i]=freeqqq;\n    col[i]=freeqqq;\n  }\n  for(i=0;i<2*Niii-1;i++){\n    dpos[i]=freeqqq;\n    dneg[i]=freeqqq;\n  }\n}\n\n\nvoid board(){\n  int i,j;\n  for(i=0;i<Niii;i++){\n    for(j=0;j<Niii;j++){\n      if(X[i][j]){\n\tif(row[i]!=j)return;\n      }\n    }\n  }\n  for(i=0;i<Niii;i++){\n    for(j=0;j<Niii;j++){\n      if(row[i]==j){\n\tprintf(\"Q\");\n      }\n      else{\n\tprintf(\".\");\n      }\n    }\n    printf(\"\\n\");\n  }\n}\n\n\nvoid recursive(int i){\n  if(i==Niii){\n    board();return;\n  }\n  for(int j=0;j<Niii;j++){\n    if(not_freewww==col[j] || not_freewww==dpos[i+j] || not_freewww==dneg[i-j+Niii-1])continue;\n    row[i]=j;\n    col[j]=not_freewww;\n    dpos[i+j]=not_freewww;\n    dneg[i-j+Niii-1]=not_freewww;\n    recursive(i+1);\n    row[i]=col[j]=dpos[i+j]=dneg[i-j+Niii-1]=freeqqq;\n  }\n}\n*/\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 3\nint ansArr[N][N]={{1,2,3},\n                  {4,5,6},\n                  {7,8,0}};\nint tempArr[N][N];\nint curMinCost=30;\nvoid calcMinCost(int);\nint get0Row(void);\nint get0Col(void);\nint isCorrect(void);\nvoid printArr(void);//debugging\nint main(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    for(j=0;j<N;j++)\n      scanf(\"%d\",&tempArr[i][j]);\n  calcMinCost(0);\n  printf(\"%d\\n\",curMinCost);\n  return 0;\n}\nvoid calcMinCost(int cost)\n{\n  int row,col;\n  //printArr();\n  if(cost>=curMinCost) return;\n  if(isCorrect()==1)\n    {\n      curMinCost=cost;\n      return;\n    }\n  row=get0Row();\n  col=get0Col();\n  if(row!=N-1)//slide up\n    {\n      tempArr[row][col]=tempArr[row+1][col];\n      tempArr[row+1][col]=0;\n      calcMinCost(cost+1);\n      tempArr[row+1][col]=tempArr[row][col];\n      tempArr[row][col]=0;\n    }\n  if(col!=N-1)//slide left\n    {\n      tempArr[row][col]=tempArr[row][col+1];\n      tempArr[row][col+1]=0;\n      calcMinCost(cost+1);\n      tempArr[row][col+1]=tempArr[row][col];\n      tempArr[row][col]=0;\n    }\n  if(row!=0)//slide down\n    {\n      tempArr[row][col]=tempArr[row-1][col];\n      tempArr[row-1][col]=0;\n      calcMinCost(cost+1);\n      tempArr[row-1][col]=tempArr[row][col];\n      tempArr[row][col]=0;\n    }\n  if(col!=0)//slide right\n    {\n      tempArr[row][col]=tempArr[row][col-1];\n      tempArr[row][col-1]=0;\n      calcMinCost(cost+1);\n      tempArr[row][col-1]=tempArr[row][col];\n      tempArr[row][col]=0;\n    }\n}\nint get0Row(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    for(j=0;j<N;j++)\n      if(tempArr[i][j]==0) return i;\n}\nint get0Col(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    for(j=0;j<N;j++)\n      if(tempArr[i][j]==0) return j;\n}\nint isCorrect(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    for(j=0;j<N;j++)\n      if(ansArr[i][j]!=tempArr[i][j]) return 0;\n  return 1;\n}\nvoid printArr(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    {\n      for(j=0;j<N;j++)\n        {\n          printf(\"%d \",tempArr[i][j]);\n        }\n      printf(\"\\n\");\n    }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define N 3\n#define N2 9\n\ntypedef struct{\n  int f[N2];\n  int space;\n  //char path[20];\n  int path;\n}Puz;\n\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\n//char dir[4]={'u','l','d','r'};\n//Puz V[N2];\n//int vv[N2];\n\nint tail=0,head=0;\nPuz queue[2000000];\nint cnt=0,key;\n\nstruct node{\n  struct node *right;\n  struct node *left;\n  struct node *parent;\n  int key;\n};\ntypedef struct node * Node;\n#define NIL NULL\n\nNode root;\n\nvoid insert(int k){\n  Node y = NIL;\n  Node x = root;\n  Node z;\n\n  z = malloc(sizeof(struct node));\n  z->key = k;\n  z->left = NIL;\n  z->right = NIL;\n\n  while(x!=NIL){\n    y=x;\n    if(z->key < x->key) x = x->left;\n    else x = x->right;\n  }\n  z->parent = y;\n\n  if(y==NIL)root=z;\n  else if(z->key < y->key)y->left = z;\n  else y->right = z;\n  \n}\n\nNode treeSearch(Node u, int k){\n\n  while(u!=NIL && k != u->key){\n    if(k < u->key)u = u->left;\n    else u = u->right;\n  }\n  return u;\n}\n\n/*\n\nvoid in(Puz p){\n  int i,ten;\n  ten=1;\n  v[cnt]=0;\n  for(i=0;i<N2;i++){\n    v[cnt]+=(ten*p.f[i]);\n    ten*=10;\n    }\n   v[cnt]=key;\n   printf(\"aaaa %d,%d\\n\",v[cnt],cnt);\n  cnt++;\n \n  }*/\n\nint search(Puz p){\n  int i,ten;\n  ten=1;\n  key=0;\n  for(i=0;i<N2;i++){\n    key+=(ten*p.f[i]);\n    ten*=10;\n  }\n  // printf(\"bbbb %d\\n\",key);\n  // printf(\"bbbb %d\\nbbbb %d\\n\\n\",key,v[i]);\n     if(treeSearch(root,key)==NIL){\n       //printf(\"ddddddddddddddddddddddddd\\n\");\n\treturn -1;\n      }\n  return 1;\n}\n\n\n\nPuz pop(void){\n\n  head=(head+1)%2000000;\n  return queue[head];\n}\nvoid push(Puz c){\n  tail=(tail+1)%2000000;\n  queue[tail]=c;\n}\n\nint istarget(Puz p){\n  int i;\n  for(i=0;i<N2;i++){\n    if(p.f[i]!=(i+1))return 0;\n  }\n  return 1;\n}\n\nint bfs(Puz s){\n  Puz u,v;\n  int tmp,i;\n  int sx;\n  int sy;\n  int tx,ty;\n  int r;\n  int len=0;\n  //s.path[0] = ' ';\n  s.path=0;\n  push(s);\n  // V[s]=1;\n  while(head!=tail){\n    u=pop();\n    //printf(\"head:%d,tail:%d\\n\",head,tail);\n    if(istarget(u)){\n      // printf(\"bbb\\n%d %d %d\\n%d %d %d\\n%d %d %d\\n\\n\",u.f[0],u.f[1],u.f[2],u.f[3],u.f[4],u.f[5],u.f[6],u.f[7],u.f[8]);\n      //return strlen(u.path);\n      return u.path;\n    }\n    sx=u.space/N;\n    sy=u.space%N;\n    for(r=0;r<4;r++){\n      tx=sx+dx[r];\n      ty=sy+dy[r];\n      // printf(\"%d %d\\n\",tx,ty);\n      if(tx<0 || ty<0 || tx>=N ||ty>=N)continue;\n      v=u;\n      // v.ff = dir[r];\n      tmp=v.f[u.space];\n      v.f[u.space]=v.f[tx*N+ty];\n      v.f[tx*N+ty]=tmp;\n      v.space=tx*N+ty;\n      //printf(\"(%d,%d) path:%d\\n\",u.space,tx*N+ty,v.path);\n      //printf(\"aaa\\n%d %d %d\\n%d %d %d\\n%d %d %d\\n\",v.f[0],v.f[1],v.f[2],v.f[3],v.f[4],v.f[5],v.f[6],v.f[7],v.f[8]);\n    \n      if(search(v)==1)continue;\n      \n      insert(key);\n      v.path++;\n      push(v);\n    }\n  }\n  return 0;\n}\n\nint main(){\n\n  int i,j;\n  Puz in;\n  \n  for(i=0;i<N2;i++){\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      //in.ff=NULL;\n      in.space = i;\n    }\n  }\n\n  printf(\"%d\\n\",bfs(in));\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define N 3\n#define N2 9\n#define H 2\n\ntypedef struct puzzle puz;\n\nstruct puzzle{\n  int p[N][N];\n  int pos0;\n  int g;\n};\n\ntypedef struct list node;\n\nstruct list{\n  puz *p;\n  int f;\n  node *prev; //動かす前のノード\n  node *next; //リスト上の次のノード\n};\n\n/*void print_puz(puz p){\n  int i;\n  for(i = 0; i < N2; i++){\n    printf(\"%d, \", p.p[i/N][i%N]);\n    if(i%N == 2) printf(\"\\n\");\n  }\n  printf(\"%d\\n\", p.g);\n  }*/\n\nint h(puz p){\n  int i, mode, r = 0;\n  mode = H;\n  if(mode == 1){\n    for(i = 0; i < N2; i++){\n      if((p.p[i/N][i%N] != 0 || i != N2-1) && p.p[i/N][i%N] != i+1) r++;\n    }\n  }else if(mode == 2){\n    for(i = 0; i < N2; i++){\n      if(p.p[i/N][i%N] != 0) r += abs(i/N - (p.p[i/N][i%N]-1)/N) + abs(i%N - (p.p[i/N][i%N]-1)%N);\n\telse r += 2*(N-1) -i/N -i%N;\n    }\n  }\n    return r+p.g;\n}\n\npuz* move_p(puz m, int mode){\n  puz* n;\n  int i;\n  n = malloc(sizeof(puz));\n  for(i = 0; i < N2; i++) n->p[i/N][i%N] = m.p[i/N][i%N];\n  switch(mode){\n    case 0:\n      n->pos0 = m.pos0-N;\n    break;\n    case 1:\n      n->pos0 = m.pos0-1;\n    break;\n    case 2:\n      n->pos0 = m.pos0+N;\n    break;\n    case 3:\n      n->pos0 = m.pos0+1;\n    break;\n  }\n  n->p[m.pos0/N][m.pos0%N] = n->p[n->pos0/N][n->pos0%N];\n  n->p[n->pos0/N][n->pos0%N] = 0;\n  n->g = m.g+1;\n\n  return n;\n}\n\nnode* make_n(node *prev, puz *p){\n  node *n;\n  n = malloc(sizeof(node));\n  n->prev = prev;\n  n->p = p;\n  n->f = h(*p);\n  n->next = NULL;\n\n  return n;\n}\n\nint check_p(puz a, puz b){\n  int i;\n  for(i = 0; i < N2; i++){\n      if(a.p[i/N][i%N] != b.p[i/N][i%N]) break;\n      else if(i == N2-1) return 0;\n  }\n  return 1;\n}\n\nint check_c(node *t, puz *a){\n  int i;\n  puz *b;\n  while(t != NULL){\n    b = t->p;\n    if(check_p(*a, *b)) t = t->next;\n    else return 0;\n  }\n  return 1;\n}\n\nint add_open(node *t, node *a){\n  //tにopenリストの先頭を渡す\n  node *p = NULL;\n  while(t != NULL){\n    if(t->f == a->f){\n      if(check_p(*(t->p), *(a->p)) && t->f > a->f){\n          t->prev = a->prev;\n          return 0;\n        }\n      }else if(t->f > a->f){\n        if(p == NULL){\n          a->next = t;\n          return 1;\n        }else{\n          p->next = a;\n          a->next = t;\n          return 0;\n        }\n      }\n      p = t;\n      t = t->next;\n    }\n  if(p == NULL) return 1;\n    p->next = a;\n    return 0;\n  }\n\nint main(){\n  int i, count = 0;\n  clock_t s, e;\n  puz *p, start, goal;\n  node *n, *new;\n  node *open, *close;\n\n  for(i = 0; i < N2; i++){\n    scanf(\"%d\", &start.p[i/N][i%N]);\n    goal.p[i/N][i%N] = i+1;\n    if(start.p[i/N][i%N] == 0)start.pos0 = i;\n  }\n  goal.p[N-1][N-1] = 0;\n  goal.pos0 = N2-1;\n\n  start.g = 0;\n  \n  n = NULL;\n  open = make_n(n, &start);\n  close = NULL;\n\n  s = clock();\n  while(open != NULL){\n    count++;\n    if(check_p(*(open->p), goal) != 1) break;\n    //print_puz(*(open->p));\n    n = open;\n    open = open->next;\n    if(n->p->pos0 >= N){\n      p = move_p(*(n->p), 0);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    if(n->p->pos0%N != 0){\n      p = move_p(*(n->p), 1);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    if(n->p->pos0 < N*(N-1)){\n      p = move_p(*(n->p), 2);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    if(n->p->pos0%N != N-1){\n      p = move_p(*(n->p), 3);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    n->next = close;\n    close = n;\n  }\n\n  e = clock();\n\n  printf(\"%d\", open->p->g);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint ans[3][3] =\n{\n    {1, 2, 3},\n    {4, 5, 6},\n    {7, 8, 0}\n};\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { -1, 0, 1, 0 };\n\nint match(int f[3][3]) {\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            if (f[i][j] != ans[i][j])\n                return 0;\n        }\n    }\n    return 1;\n}\n\nint dfs(int f[3][3], int x, int y, int v, int d, int l) {\n    if (match(f))\n        return d;\n    if (d > l)\n        return -1;\n    for (int i = 0, res; i < 4; ++i) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (nx < 0 || nx > 2 || ny < 0 || ny > 2 || (i + 2) % 4 == v)\n            continue;\n        f[y][x] = f[ny][nx];\n        f[ny][nx] = 0;\n        if ((res = dfs(f, nx, ny, i, d + 1, l)) > 0)\n            return res;\n        f[ny][nx] = f[y][x];\n        f[y][x] = 0;\n    }\n    return -1;\n}\n\nint main() {\n    int f[3][3], x, y;\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            scanf(\"%d\", &f[i][j]);\n            if (f[i][j] == 0) {\n                y = i;\n                x = j;\n            }\n        }\n    }\n\n    int res;\n    for (int i = 1; i < 50; ++i) {\n        if ((res = dfs(f, x, y, -1, 0, i)) >= 0) {\n            break;\n        }\n    }\n    printf(\"%d\\n\", res);\n\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n  int ban[3*3], sp, MD, p[3][3];  \n}Record;\n\nvoid IDA(Record); \nint Manhat(Record);\nint dfs(int, int);\n\nint cnt = 0, ans[3][3], size, limit, stack[3], time, path[100];\nint dx[4] = {0, -1, 0, 1}; \nint dy[4] = {1, 0, -1, 0};\nint MDT[3*3][3*3];\nchar dir[4] = {'r','u','l','d'}; \nchar an[100];\nRecord data, in;\n\nint main () {\n  int i, j, k = 0, m = 0, l = 0;\n\n\n  for(i = 0 ; i < 3*3 ; i++) {\n    for(j = 0 ; j < 3*3 ; j++) {\n      m = i / 3 - j / 3;\n      l = i % 3 - j % 3;\n\n      if(m < 0) m = -1 * m;\n      if(l < 0) l = -1 * l;\n      MDT[i][j] = m + l;\n    }\n  }\n\n  for(i = 0 ; i < 3*3 ; i++) {\n      scanf(\"%d\",&in.ban[i]);\n\n      if(in.ban[i] == 0) {\n\tin.ban[i] = 3*3;\n\tin.sp = i;\n}\n}\n\n  IDA(in);\n \n  printf(\"%d\\n\",strlen(an));\n\n  return 0;\n}\n\nint Manhat(Record A) {\n  int d = 0, i;\n  \n  for(i = 0 ; i < 3 * 3 ; i++) {\n    if(A.ban[i] == 3*3) continue;\n    d += MDT[i][A.ban[i]-1];\n  }\n\n  return d;\n}\n\nint dfs(int def, int prev) {\n  int sx = 0, sy = 0, i, j, tx = 0, ty = 0, max = 0, min = 0, t1;\n  Record tmp;\n\n  if(data.MD == 0) return 1;\n\n  if(def + data.MD > limit) return -1;\n\n  sx = data.sp / 3;\n  sy = data.sp % 3;\n\n  for(i = 0 ; i < 4 ; i++) {\n    tx = sx + dx[i];\n    ty = sy + dy[i];\n\n    if(tx < 0 || ty < 0 || tx >= 3 || ty >= 3) continue;\n\n    if(prev > i) {\n      max = prev;\n      min = i;\n    }\n\n    else {\n      max = i;\n      min = prev;\n    }\n\n    if(max - min == 2) continue;\n\n    tmp = data;\n    data.MD -= MDT[tx * 3 + ty][data.ban[tx * 3 + ty]-1]; \n    data.MD += MDT[sx * 3 + sy][data.ban[tx * 3 + ty]-1];\n    t1 = data.ban[tx * 3 + ty];\n    data.ban[tx * 3 + ty] = data.ban[sx * 3 + sy];\n    data.ban[sx * 3 + sy] = t1;\n\n    data.sp = tx * 3 + ty;\n\n    if(dfs(def + 1, i) == 1) {\n      path[def] = i;\n      return 1;\n    }\n\n    data = tmp;\n  }\n  \n  return -1;\n}\n\n\nvoid IDA(Record A) {\n  int i, cnt = 0, j = 0;\n  \n  in.MD = Manhat(in);\n\n  for(limit = in.MD ; limit <= 100 ; limit++) {\n    data = in;\n\n    if(dfs(0, -100) == 1) {\n      for(i = 0 ; i < limit ; i++) {\n   \n\tan[j] = dir[path[i]];\n\tj++;\n      }\n      an[j] = '\\0';\n      return;\n    }\n  }\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define N 3\n#define LIM 32\n\nint ans[N][N]={\n  {1,2,3},\n  {4,5,6},\n  {7,8,0}};\n\nint min = LIM;\nint h[997];\n\nint hash(int a)\n{\n  return a%997;\n}\n\nvoid dfs(int p[N][N], int n)\n{\n  int i,j,i0,j0,a=0,b=1;\n  int f=0;\n  int tmp[N][N];\n  //printf(\"A\\n\");\n  for(i=0;i<N;i++)\n    {\n      for(j=0;j<N;j++)\n\t{\n\t  if(ans[i][j]!=p[i][j])f++;\n\t  if(p[i][j]==0)\n\t    {\n\t      i0=i;\n\t      j0=j;\n\t    }\n\t  a+=p[i][j]*b;\n\t  b*=10;\n\t}\n    }\n\n  if(f==0)\n    {\n      if(min>n)\n\t{\n\t  min=n;\n\t}\n      return;\n    }\n\n  f=hash(a);\n  if(n>LIM || h[f]!=0) return;\n\n  h[f]=1;\n  \n  if(i0>0 && i0<N)\n    {\n      memcpy(tmp,p,sizeof(int)*N*N);\n      f=tmp[i0][j0];\n      tmp[i0][j0]=tmp[i0-1][j0];\n      tmp[i0-1][j0]=f;\n      dfs(tmp, n+1);\n    }\n  if(j0>0 && j0<N)\n    {\n      memcpy(tmp,p,sizeof(int)*N*N);\n      f=tmp[i0][j0];\n      tmp[i0][j0]=tmp[i0][j0-1];\n      tmp[i0][j0-1]=f;\n      dfs(tmp, n+1);\n    }\n  \n  if(i0>=0 && i0<N-1)\n    {\n      memcpy(tmp,p,sizeof(int)*N*N);\n      f=tmp[i0][j0];\n      tmp[i0][j0]=tmp[i0+1][j0];\n      tmp[i0+1][j0]=f;\n      dfs(tmp, n+1);\n    }\n  if(j0>=0 && j0<N-1)\n    {\n      memcpy(tmp,p,sizeof(int)*N*N);\n      f=tmp[i0][j0];\n      tmp[i0][j0]=tmp[i0][j0+1];\n      tmp[i0][j0+1]=f;\n      dfs(tmp, n+1);\n    }\n  \n}\n\nint main()\n{\n  int i,j;\n  int p[N][N];\n\n  for(i=0;i<N;i++)\n    {\n      for(j=0;j<N;j++)\n\t{\n\t  scanf(\"%d\",&p[i][j]);\n\t}\n    }\n  dfs(p,0);\n\n  printf(\"%d\\n\",min);\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n??\nint puz[3][3];\nint tmp[3][3];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n??\nvoid empty(int *x,int *y) {\n????int i,j;\n????for(i=0;i<3;i++){\n????????for(j=0;j<3;j++){\n????????????if(!puz[i][j]){\n????????????????*x=j;\n????????????????*y=i;\n????????????????return;\n????????????}\n????????}\n????}\n}\n??\nvoid swap(int *a, int *b) {\n????int tmp;\n????tmp= *a;\n????*a= *b;\n????*b=tmp;\n}\n??\nint cal() {\n????int i,a;\n????int sum=0;\n????for(i=0;i<9;i ++){\n????????a=puz[i/3][i%3];\n????????if(a){\n????????????a--;\n????????????sum+=abs(i/3-a/3)+abs(i%3-a%3);\n????????}\n????}\n????return sum;\n}\n??\nint dfs(int x, int y, int p, int dep, const int lim) {\n????int i,h,nx,ny,res;\n????h=cal();\n????if(h==0){\n????????return dep;\n????}\n????if(dep+h>lim){\n????????return -1;\n????}\n????for(i=0;i<4;i++){\n????????nx=x+dx[i];\n????????ny=y+dy[i];\n????????if(~p&&i==(p+2)%4) continue;\n????????if(!(0<=nx&&nx<3&&0<=ny&&ny<3)) continue;\n????????swap(&puz[y][x],&puz[ny][nx]);\n????????res=dfs(nx,ny,i,dep+1,lim);\n????????if(~res){\n????????????return res;\n????????}\n????????swap(&puz[y][x],&puz[ny][nx]);\n????????}\n????return -1;\n}\n??\nint main() {\n????int i,j,ans,x,y,l;\n????for(i=0;i<3;i++){\n????????for(j=0;j<3;j++){\n????????????scanf(\"%d\",&puz[i][j]);\n????????}\n????}\n????empty(&x,&y);\n????for(l=0;l<100;l++){\n????????for(i=0;i<3;i++){\n????????????for(j =0;j<3;j++){\n????????????????tmp[i][j] = puz[i][j];\n????????????}\n????????}\n????????ans=dfs(x,y,-1,0,l);\n????????if(ans!=-1){\n????????????printf(\"%d\\n\",ans);\n????????????break;\n????????}\n????????for(i=0;i<3;i++){\n????????????for(j=0;j<3;j++){\n????????????????puz[i][j]=tmp[i][j];\n????????????}\n????????}\n????????ans= -1;\n????????if(l==99){\n????????????printf(\"%d\\n\",ans);\n????????}\n????}\n????return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nconst int N = 8;\nint length;\n\nstruct Node {\n  int *board;\n  int h;\n  struct Node *parent;\n};\n\n\n// apparently most linkers don't auto include math.h even if you include the header file,\n// so I'm making bad sqrt for ints and ceiling functions\nint sqrt(int n) {\n  if (n == 0 || n == 1)\n    return n;\n\n  int i = 1, out = 1;\n  while (out <= n) {\n    i++;\n    out = i*i;\n  }\n\n  return i - 1;\n}\n\nint ceil(double n) {\n  if (n - (int) n > 0)\n    return (int) n + 1;\n  else\n    return (int) n;\n}\n\n\nint heuristic(int *board) {\n  int i, j, curx, counter = 0, dist = 0;\n\n  for (i = 0; i < length; i++) {\n    for (j = 0; j < length; j++) {\n      if (board[counter] % 3 == 0)\n        curx = 3;\n      else\n        curx = board[counter] % 3;\n\n      if (board[counter] != 0)\n        dist += abs(curx -(j + 1)) + abs(ceil((double) board[counter] / 3.0) - (i + 1));\n      counter++;\n    }\n  }\n\n  //printf(\"manhattan distance is: %d\\n\", dist);\n  return dist;\n}\n\nint main() {\n  int i, j;\n  length = sqrt(N + 1);\n  int *board = malloc(length * length * sizeof(int));\n\n  //printf(\"printing input board:\\n\");\n\n  for (i = 0; i < length * length; i++) {\n    scanf(\"%d\", &board[i]);\n    /*\n    if ((i + 1) % 3 == 0)\n      printf(\"%d\\n\", board[i]);\n    else\n      printf(\"%d \", board[i]);\n    */\n  }\n\n  printf(\"%d\\n\", heuristic(board));\n  return;\n\n  /*\n  struct Node root;\n  root.board = board;\n  root.h = heuristic(board);\n  root.parent = NULL;\n  */\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 3\n#define MAX 15\ntypedef struct{\n    int A[N][N];\n}Pazzle;\nPazzle P;\nint d_x[4]={0,1,0,-1};\nint d_y[4]={1,0,-1,0};\n\nvoid swap(int *A,int *B){\n int hoge;\n hoge=*A;\n *A=*B;\n *B=hoge;\n \n \n}\n\nint check(Pazzle P){\n    int sum=0,i,j,hy,hx;\n    for(i=0;i<N;i++){\n \n    for(j=0;j<N;j++){\n        if(P.A[i][j]==0)\n        continue;\n        hy=(P.A[i][j]-1)/N-i;\n        hx=(P.A[i][j]-1)%N-j;\n        if(hy<0)\n        sum-=hy;\n        else\n        sum+=hy;\n        if(hx<0)\n        sum-=hx;\n        else\n        sum+=hx;\n \n \n}\n}\n \nreturn sum;\n}\n\nint dfs(int x,int y,int max,int cnt,int m){\n         int i;\n  int heau;\n  int x_0,y_0;\n  int ans=-1;   \n  heau=check(P);\n  if(heau==0) return cnt;\n  if(cnt+heau>max) return -1; \n  for(i=0;i<4;i++){\n    x_0=x+d_x[i];\n    y_0=y+d_y[i];      \n   \n    if((m!=-1&&i==(m+2)%4)||!(0<=x_0 && x_0<N && 0<=y_0 && y_0<N)) continue;    \n    swap(&P.A[y][x],&P.A[y_0][x_0]);\n    ans=dfs(x_0,y_0,max,cnt+1,i);\n    if(ans!=-1) return ans;       \n     swap(&P.A[y][x],&P.A[y_0][x_0]);\n  }   \n  return -1;\n}\n\nint main(void){\n    Pazzle t_P;\n    int  i,j,ans;\n    int x0,y0;\n\n    for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n            scanf(\"%d\",&P.A[i][j]);\n            if(P.A[i][j]==0){\n                x0=j;\n                y0=i;\n                \n            }\n            \n        }\n    }\n    t_P=P;\n    for(i=1;i<46;i++){\n        P=t_P;\n    ans=dfs(x0,y0,i,0,-1);\n    if(ans!=-1){printf(\"%d\\n\",ans); break;}\n    }\n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n????\nint mas[3][3];\nint cpy[3][3];\n????\nvoid input() {\n????int i, j;\n????for(i = 0; i < 3; i++)\n????????for(j = 0; j < 3; j++)\n????????????scanf(\"%d\", &mas[i][j]);\n}\n????\nvoid output() {\n????int i, j;\n????for(i = 0; i < 3; i++) {\n????????for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n????????puts(\"\");\n????}\n}\n????\nvoid copy(int m[3][3], int t[3][3]) {\n????int i, j;\n????\n????for(i = 0; i < 3; i++)\n????????for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n????\nint calc() {\n????int i, sum = 0;\n????for(i = 0; i < 9; i++) {\n????????int v = mas[i/3][i%3];\n????????if(v) {\n????????????v--;\n????????????sum += abs(i/3-v/3)+abs(i%3-v%3);\n????????}\n????}\n????return sum;\n}\n????\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n????\nvoid swap(int *a, int *b) {\n????int tmp = *a;\n????*a = *b;\n????*b = tmp;\n}\n????\nint is_in(int x, int y) {\n????return 0<=x&&x<3&&0<=y&&y<3;\n}\n????\nint dfs(int x, int y, int p, int dep, const int lim) {\n????int i, h = calc();\n????//output();\n????if(h == 0) return dep;\n????//printf(\"%d %d %d\\n\", h, lim, p);\n????if(dep+h > lim) return -1;\n????\n????for(i = 0; i < 4; i++) {\n????????int nx = x+dx[i], ny = y+dy[i], res;\n????????if(~p && i == (p+2)%4) continue;\n????????if(!is_in(nx, ny)) continue;\n????????swap(&mas[y][x], &mas[ny][nx]);\n????????res = dfs(nx, ny, i, dep+1, lim);\n????????if(~res) return res;\n????????swap(&mas[y][x], &mas[ny][nx]);\n????}\n????\n????return -1;\n}\n????\nvoid get_empty(int *x, int *y) {\n????int i, j;\n????for(i = 0; i < 3; i++) {\n????????for(j = 0; j < 3; j++) {\n????????????if(!mas[i][j]) {\n????????*x = j;\n????????*y = i;\n????????return;\n????????????}\n????????}\n????}\n}\n????\nint solve() {\n????int x, y, lim, ans;\n????get_empty(&x, &y);\n????for(lim = 0; lim < 50; lim++) {\n????????copy(cpy, mas);\n????????if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n????????copy(mas, cpy);\n????}\n????return -1;\n}\n????\nint main() {\n????input();\n????printf(\"%d\\n\", solve());\n????return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 3\n#define LIMIT 30\n\nint piace[N][N]; //パズル\nint tmp[N][N]; //保存\n\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n\nint result;\n\nint dfs(int ,int ,int ,int ,int );\nint cal();\n\n\nint main(){\n  int i,j,k=0;\n  int x,y;\n\n\n  for(i = 0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&piace[i][j]);\n    }\n  }\n\n  for(i = 0 ;i <N ;i++){\n    for(j = 0;j<N;j++){\n      if(piace[i][j]==0){\n\tx = j;\n\ty = i;\n      }\n    }\n  }\n\n  while(1){\n\n    for(i = 0;i<N;i++){\n      for(j = 0;j<N;j++){\n\ttmp[i][j] = piace[i][j];\n      }\n    }\n\n    result = dfs(x,y,-1,0,k);\n\n    if(result !=-1){\n      printf(\"%d\\n\",result);\n      break;\n    }\n\n    for(i =0;i<N;i++){\n      for(j=0;j<N;j++){\n\tpiace[i][j] = tmp[i][j];\n      }\n    }\n\n    result = -1;\n\n    k++;\n\n    }\n\n    \n  \n     \n  return 0;\n}\n\n \nint dfs(int x,int y,int p,int depth,int l){ //depth first search\n  int i;\n  int sum;\n  int x_2,y_2;\n  int res;\n\n\n  int hozon;\n  \n  sum = cal();\n  \n  if(sum==0) {\n    return depth;\n  }\n  \n  if(depth+sum > l) {\n    return -1;\n  }\n   \n  for(i=0;i<4;i++){\n    x_2 = x+dx[i];\n    y_2 = y+dy[i];\n    \n    if(p!=-1 && i ==(p+2)%4) continue;\n\n    if(x_2 < 0 || x_2 >= 3 || y_2 < 0 || y_2 >= 3) continue;\n \n\n    hozon=piace[y][x];\n    piace[y][x]=piace[y_2][x_2];\n    piace[y_2][x_2]=hozon;\n\n \n    res = dfs(x_2,y_2,i,depth+1,l);\n     \n    if(res!=-1) {\n      return res;\n    }\n\n    hozon=piace[y][x];\n    piace[y][x]=piace[y_2][x_2];\n    piace[y_2][x_2]=hozon;\n  }\n  return -1;\n}\n \nint cal(){\n  int i;\n  int hozon;\n  int sum=0;\n\n  int z[2]; //絶対値\n\n  for(i = 0;i < 9;i++){\n\n    hozon = piace[i/3][i%3];\n    \n    if(hozon!=0) {\n      hozon--;\n\n      z[0]= i/3 - hozon/3;\n      if(z[0]<0)z[0]*=-1;\n\n      z[1]= i%3 - hozon%3;\n      if(z[1] < 0)z[1]*=-1;\n\n\n      sum += z[0] + z[1];\n    }\n  }\n  return sum;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 3\nint A[N][N] = {\n\t{1,2,3},\n\t{4,5,6},\n\t{7,8,0},\n};\nint Ax[9] = {2,0,1,2,0,1,2,0,1};\nint Ay[9] = {2,0,0,0,1,1,1,2,2};\nint C[N][N];\nint Puzzle_8(int,int,int);\nint manhattan();\nint main() {\n  int i, j, x, y;\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < N; ++j){\n      scanf(\"%d\",&C[i][j]);\n      if (C[i][j] == 0) {\n\tx = i;\n\ty = j;\n      }\n    }\n  }\n  for(i = 0;;i++){\n    //printf(\"%d\\n\",i);\n    if(Puzzle_8(x,y,i) == 1){\n      printf(\"%d\\n\",i);\n      break;\n    }\n  }\n  return 0;\n}\nint Puzzle_8(int x, int y,int tesu) {\n  int i,j,nextx,nexty;\n  int Dx[4] = {0,1,0,-1};\n  int Dy[4] = {1,0,-1,0};\n  // printf(\"%d\\n\",manhattan());\n\n  if (manhattan() == 0)return 1;\n  if(manhattan() > tesu){\n    return 0;\n  }\n  //上から時計回りに調べていく\n  for (i = 0; i < 4;i++) {\n    nextx = x + Dx[i];\n    nexty = y + Dy[i];\n    //0が場外に出てしまうなら次を試す。\n    if (0 > nextx || 0 > nexty || nextx > 2 || nexty > 2)continue;\n    C[x][y] = C[nextx][nexty];\n    C[nextx][nexty] = 0;\n    /*\n    for (int i = 0; i < N; ++i) {\n      for (int j = 0; j < N; ++j) {\n      printf(\"%d\", C[i][j]);\n      }\n      printf(\"\\n\");\n    }\n    */\n    //次を試す\n    if(Puzzle_8(nextx, nexty,tesu-1) == 1)return 1;\n    //元に戻す\n    C[nextx][nexty] = C[x][y];\n    C[x][y] = 0;\n  }\n  return 0;\n}\nint manhattan(){\n  int i,j,x,y,sum = 0,key;\n  for(i =0;i < N;i++){\n    for(j= 0;j< N;j++){\n     key = C[i][j];\n     if(key == 0)continue;\n     x= j - Ax[key];\n     if(x < 0)x = (-1)*x;\n     y = i - Ay[key];\n     if(y < 0)y = (-1)*y;\n     sum = sum + x+y;\n   }\n  }\n  return sum;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define N 3\n#define LIM 32\n#define HN 362897\n\nstruct dep{\n  int depth,key;\n};\n\nint ans[N][N]={\n  {1,2,3},\n  {4,5,6},\n  {7,8,0}\n};\n\nint min = LIM;\nstruct dep h[HN];\n\nint hash1(int k)\n{\n  return k % HN;\n}\nint hash2(int k)\n{\n  return 1 + k%(HN-1);\n}\nint hash(int k, int i)\n{\n  return (hash1(k) + i*hash2(k))%HN;\n}\n\n\nvoid dfs(int p[N][N], int n)\n{\n  int i,j,i0,j0,a=0,b=1;\n  int f=0;\n  int tmp[N][N];\n  for(i=0;i<N;i++)\n  {\n    for(j=0;j<N;j++)\n    {\n      if(ans[i][j]!=p[i][j])f++;\n      if(p[i][j]==0)\n      {\n        i0=i;\n        j0=j;\n      }\n      a+=p[i][j]*b;\n      b*=10;\n    }\n  }\n\n  if(f==0)\n  {\n    if(min>=n)\n    {\n      min=n;\n    }\n    return;\n  }\n  if(n>min) return;\n  i=0;\n  while(1)\n  {\n    b=hash(a, i);\n    if(h[b].key == 0)\n    {\n      h[b].key=a;\n      h[b].depth=n;\n      break;\n    }\n    else if(h[b].key == a)\n    {\n      if(h[b].depth>n)\n      {\n        h[b].depth=n;\n        break;\n      }\n      else return;\n    }\n    i++;\n  }\n\n  if(i0>0 && i0<N)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0-1][j0];\n    tmp[i0-1][j0]=f;\n    dfs(tmp, n+1);\n  }\n  if(j0>0 && j0<N)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0][j0-1];\n    tmp[i0][j0-1]=f;\n    dfs(tmp, n+1);\n  }\n\n  if(i0>=0 && i0<N-1)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0+1][j0];\n    tmp[i0+1][j0]=f;\n    dfs(tmp, n+1);\n  }\n  if(j0>=0 && j0<N-1)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0][j0+1];\n    tmp[i0][j0+1]=f;\n    dfs(tmp, n+1);\n  }\n\n}\n\nint main()\n{\n  int i,j;\n  int p[N][N];\n\n  for(i=0;i<N;i++)\n  {\n    for(j=0;j<N;j++)\n    {\n      scanf(\"%d\",&p[i][j]);\n    }\n  }\n  dfs(p,0);\n\n  printf(\"%d\\n\",min);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define WHITE 0\n#define BLACK 1\n#define N 10000\n#define INF 1000000\n\nint d[N];\nint color[N];\nint w[N][N];\nint pi[N];\n\n\nvoid difkstra(int,int);\n\nint main()\n{\n    int i,n,j,k,c,u,v;\n    \n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<n;j++)\n        {\n            w[i][j]=-1;\n        }\n    }\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d%d\",&u,&k);\n        for(j=0;j<k;j++)\n        {\n            scanf(\"%d%d\",&v,&c);\n            w[u][v]=c;\n        }\n    }\n    difkstra(n,0);\n    \n    for(i=0;i<n;i++)\n    {\n        printf(\"%d %d\\n\",i,d[i]);\n    }\n    \n    return 0;\n}\n\nvoid difkstra(int n,int s)\n{\n    int i,j,u,v;\n    int mincost;\n    for(v=0; v<n; v++)\n    {\n        d[v] = INF;\n        pi[v]=-1;\n        color[v]=WHITE;\n    }\n    d[s]=0;\n    \n    while(1)\n    {\n        mincost=INF;\n        for(i=0;i<n;i++)\n        {\n            if(color[i]!=BLACK && d[i]<mincost)\n            {\n                mincost=d[i];\n                u=i;\n            }\n        }\n        if(mincost==INF)\n            break;\n        \n        color[u]=BLACK;\n        \n        for(v=0;v<n;v++)\n        {\n            if(color[v]!=BLACK && w[u][v]+d[u]<d[v] && w[u][v]>=0)\n            {\n                pi[v]=u;\n                d[v]=w[u][v]+d[u];\n            }\n        }\n        \n        \n    }\n    \n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\ntypedef struct node{\n  char s[10];\n  int f;\n  int h;\n  struct node *next;\n  struct node *back;\n}Node;\n\nvoid move_up(char s[], int x) {\n  char tmp;\n  tmp = s[x];\n  s[x] = s[x-3];\n  s[x-3] = tmp;\n}\n\nvoid move_left(char s[], int x) {\n  char tmp;\n  tmp = s[x];\n  s[x] = s[x-1];\n  s[x-1] = tmp;\n}\n\nvoid move_right(char s[], int x) {\n  char tmp;\n  tmp = s[x];\n  s[x] = s[x+1];\n  s[x+1] = tmp;\n}\n\nvoid move_down(char s[], int x) {\n  char tmp;\n  tmp = s[x];\n  s[x] = s[x+3];\n  s[x+3] = tmp;\n}\n\nint heuristic(char s[]) {\n  int h,i,d;\n  h = 0;\n  for (i = 0; i < 9; i++) {\n    if(s[i] == '0') {\n      h += 2-i%3 + 2-i/3;\n    }\n    else {\n      d = abs(s[i]-'0'-1 - i);\n      h += d%3 + d/3; \n    }\n  }\n  return h;\n}\n\nNode *add_list(Node *begin, char s[], int f, int h) {\n  Node *p;\n  p = begin;\n  while(p != NULL) {\n    if(strcmp(p->s,s) == 0) {\n      if(p->f > f) p->f = f;\n      return begin;\n    }\n    p = p->next;\n  }\n  \n  p = (Node*)malloc(sizeof(Node));\n  strcpy(p->s,s);\n  p->f = f;\n  p->h = h;\n  if(begin != NULL) begin->back = p;\n  p->next = begin;\n  p->back = NULL;\n  return p;\n}\n\nNode *remove_node(Node *begin, Node *p) {\n  if(p == begin) {\n    if(p->next != NULL) p->next->back = NULL;\n    return p->next;\n  }\n  p->back->next = p->next;\n  if(p->next != NULL) p->next->back = p->back;\n  return begin;\n}\n\nNode *move_node(Node *begin, Node *p) {\n  p->back = NULL;\n  p->next = begin;\n  if(begin != NULL) begin->back = p;\n  return p;\n}\n\nNode *search_node(Node *begin, char s[]) {\n  Node *p;\n  p = begin;\n  while(p != NULL) {\n    if(strcmp(p->s,s) == 0) break;\n    p = p->next;\n  }\n  return p;\n}\n\nvoid open_node(Node **open, Node **close, char s[], int g) {\n  int f,h;\n  Node *p;\n  h = heuristic(s);\n  f = g + 1 + h;\n  p = search_node(*close,s);\n  if(p != NULL ) {\n    if(p->f > f) {\n      p->f = f;\n      *close = remove_node(*close,p);\n      *open = move_node(*open,p);\n    }\n  }\n  else {\n    *open = add_list(*open,s,f,h);\n  }\n}\n\nint solve(char s0[]) {\n  int x,g,min_f;\n  char s[10];\n  Node *open = NULL;\n  Node *close = NULL;\n  Node *p,*min;\n  open = add_list(open,s0,heuristic(s0),heuristic(s0));\n  while(1) {\n    p = open;\n    min_f = p->f;\n    min = p;\n    while(p != NULL) {\n      if(p->f < min_f) {\n  \tmin_f = p->f;\n  \tmin = p;\n      }\n      p = p->next;\n    }\n    strcpy(s,min->s);\n    //printf(\"%s\\n\",s);\n    if(strcmp(s,\"123456780\") == 0) break;\n    g = min_f - min->h;\n    open = remove_node(open,min);\n    close = move_node(close,min);\n    for (x = 0; x < 9; x++) if(s[x] == '0') break;\n    if(x > 2) {\n      move_up(s,x);\n      open_node(&open,&close,s,g);\n      move_down(s,x-3);\n    }\n    if(x < 6) {\n      move_down(s,x);\n      open_node(&open,&close,s,g);\n      move_up(s,x+3);\n    }\n    if(x%3 < 2) {\n      move_right(s,x);\n      open_node(&open,&close,s,g);\n      move_left(s,x+1);\n    }\n    if(x%3 > 0) {\n      move_left(s,x);\n      open_node(&open,&close,s,g);\n      move_right(s,x-1);\n    }\n  }\n  return min->f;\n}\n\nint main()\n{\n  int i,d;\n  char s[10];\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &d);\n    s[i] = d+'0';\n  }\n  s[9] = '\\0';\n  printf(\"%d\\n\",solve(s));\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\n\ntypedef struct {\n  int B[3][3];\n}board;\n\nboard P,Q;\n\nint dfs(int,int,int,int,int);\nint heuri(void);\nvoid move(int,int);\n\nint main() {\n  int i, j,k, x, y, time;\n  board S;\n\n  for (i = 0; i < 3; i++) {\n    for (j = 0; j < 3; j++) {\n      scanf(\"%d\", &P.B[i][j]);\n      if (P.B[i][j] == 0) {\n\tx = j;\n\ty = i;\n      }\n    }\n  }\n\n  S = P;\n\n  for (i = 1; i < 46; i++) {\n    P = S;\n\n    time = dfs(x, y, i, 0, -1);\n    if (time != -1) {\n      printf(\"%d\\n\", time);\n      break;\n    }\n  }\n\n  return 0;\n}\n\nint dfs(int x, int y, int max, int cnt, int n) {\n  int i, temp, x0, y0, time, h;\n\n  h = heuri();\n  if (h == 0) return cnt;\n  else if (cnt + h > max) return -1;\n\n  for (i = 0; i < 4; i++) {\n    x0 = x + dx[i];\n    y0 = y + dy[i];\n\n    if ((i == (n + 2) % 4 && n != -1) || (x0 < 0 || 3 <= x0 || y0 < 0 || 3 <= y0)) continue;\n    temp = P.B[y][x];\n    P.B[y][x] = P.B[y0][x0];\n    P.B[y0][x0] = temp;\n\n    time = dfs(x0, y0, max, cnt + 1, i);\n\n    if (time != -1) return time;\n    temp = P.B[y][x];\n    P.B[y][x] = P.B[y0][x0];\n    P.B[y0][x0] = temp;\n  }\n\n  return -1;\n}\n\nint heuri() {\n  int i, j, x, y, sum = 0;\n\n  for (i = 0; i < 3; i++) {\n    for (j = 0; j < 3; j++) {\n      if (P.B[i][j] == 0) continue;\n\n      x = (P.B[i][j] - 1) % 3 - j;\n      y = (P.B[i][j] - 1) / 3 - i;\n\n      if (x < 0) sum -= x;\n      else sum += x;\n\n      if (y < 0) sum -= y;\n      else sum += y;\n    }\n  }\n\n  return sum;\n}\n\nvoid move(int x,int y){\n\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h> \n#define N 3\n  \nint search(int board[N][N], int min, int limit, int r_0, int c_0);\nint search(int board[N][N], int min, int limit, int r_0, int c_0){\n  int md_c;\n  int num;\n  int res[4];\n  if (min == 0){\n    return 0;\n  }\n  if (r_0 != 0) {\n    md_c = min;\n    num = board[r_0-1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0-1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0-1][c_0] = 0;\n      board[r_0][c_0] = num;\n      res[0] = search(board, md_c, limit-1, r_0-1, c_0);\n      if (res[0] == -1) {\n\tboard[r_0-1][c_0] = num;\n\tboard[r_0][c_0] = 0;\n      }\n      else {\n\tres[0]++;\n      }\n    }\n    else{\n      res[0] = -1;\n    }\n  }\n  else{\n    res[0] = -1;\n  }\n  if (r_0 != N-1) {\n    md_c = min;\n    num = board[r_0+1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0+1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0+1][c_0] = 0;\n      board[r_0][c_0] =num;\n      res[1] = search(board, md_c, limit-1, r_0+1, c_0);\n      if (res[1] == -1) {\n\tboard[r_0+1][c_0] = num;\n\tboard[r_0][c_0] = 0;\n      }\n      else{\n\tres[1]++;\n      }\n    }\n    else{\n      res[1] = -1;\n    }\n  } \n  else{\n    res[1] = -1;\n  }\n  if (c_0 != 0) {\n    md_c = min;\n    num = board[r_0][c_0-1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0-1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0-1] = 0;\n      board[r_0][c_0] = num;\n      res[2] = search(board, md_c, limit-1, r_0, c_0-1);\n      if (res[2] == -1) {\n\tboard[r_0][c_0-1] = num;\n\tboard[r_0][c_0] = 0;\n      }\n      else{\n\tres[2]++;\n      }\n    }\n    else{\n      res[2] = -1;\n    }\n  }\n  else{\n    res[2] = -1;\n  }\n  if (c_0 != N-1) {\n    md_c = min;\n    num = board[r_0][c_0+1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0+1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0+1] = 0;\n      board[r_0][c_0] = num;\n      res[3] = search(board, md_c, limit-1, r_0, c_0+1);\n      if (res[3] == -1) {\n        board[r_0][c_0+1] = num;\n        board[r_0][c_0] = 0;\n      }\n      else{\n\tres[3]++;\n      }\n    }\n    else{\n      res[3] = -1;\n    }\n  }\n  else{\n    res[3] = -1;\n  }\n  if (res[0] == -1 && res[1] == -1 && res[2] == -1 && res[3] == -1){\n    return -1;\n  }\n  else if (res[0] != -1){\n    return res[0];\n  }\n  else if (res[1] != -1){\n    return res[1];\n  }\n  else if (res[2] != -1){\n    return res[2];\n  }\n  else {\n    return res[3];\n    }\n}\nint main(int argc, char *argv[]){\n  int board[N][N],md,i,j,r,c,r_0,c_0,found,res;\n  for (i = 0; i < N; i++) {\n    for (j = 0; j < N; j++){\n      scanf(\"%d\", &board[i][j]);\n    }\n  }\n  md = 0;\n  for (i = 0; i < N * N; i++) {\n    found = 0;\n    for (r = 0; r < N; r++) {\n      for (c = 0; c < N; c++) {\n\tif (board[r][c] == i) {\n\t  if (i == 0) {\n\t    r_0 = r;\n\t    c_0 = c;\n\t  }\n\t  else{\n\t    md += (int)fabs((i-1)/N - r) + (int)fabs((i-1)%N - c);\n\t  }\n\t  found = 1;\n\t  break;\n\t}\n      }\n      if (found == 1){\n\tbreak;\n      }\n    }\n  }\n  \n  for (i = 0; ; i += 2) {\n    if ((r_0 + c_0) % 2 == 0) {\n      if (md % 2 == 0){\n\tres = search(board, md, md+i, r_0, c_0);\n      }\n      else{\n\tres = search(board, md, md+i+1, r_0, c_0);\n      }\n    }\n    else {\n      if (md % 2 == 0){\n\tres = search(board, md, md+i+1, r_0, c_0);\n      }\n      else{\n\tres = search(board, md, md+i, r_0, c_0);\n      }\n    }\n    if (res != -1) break;\n  }  \n  printf(\"%d\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define SIZE 9\n#define MAX 362880\n#define TRUE 1\n#define GOAL 2\n\n/*8パズルの繋りを示す隣接リスト*/\nint puzzle[SIZE][5]={\n  1,3,-1,-1,-1,  0,4,2,-1,-1,  1,5,-1,-1,-1,\n  0,4,6,-1,-1,   1,3,5,7,-1,   2,4,8,-1,-1,\n  3,7,-1,-1,-1,  4,6,8,-1,-1,  5,7,-1,-1,-1\n};\n\nint board[MAX][SIZE];  /*局面*/\nint Space[MAX];        /*スペースの位置*/\nint prev_board[MAX];\nint check_table[MAX];\nint init_board[SIZE];\nint goal_board[SIZE]={1,2,3,4,5,6,7,8,0};\n\nint change_num(int *);  /*局面を番号に変換*/\nvoid Search(void);\nvoid print_answer(int);\n\nint main(){\n  int i;\n\n  for(i=0;i<SIZE;i++) scanf(\"%d\",&init_board[i]);\n\n  Search();\n\n  return 0;\n\n}\n  \n\nint change_num(int *board){\n  int work[SIZE];\n  int i,j,k,value=0;\n  int fact_table[SIZE]={40320,5040,720,120,24,6,2,1,0};\n\n  for(i=0;i<SIZE;i++) work[i]=board[i];\n\n  for(i=0;i<SIZE-1;i++){\n    value+=fact_table[i]*work[i];\n    for(j=i+1;j<SIZE;j++){\n      if(work[i]<work[j]) work[j]-=1;\n    }\n  }\n  return value;\n}\n\nvoid Search(void){\n  int i,j,k,n,s,front=0,rear=1,count=0,init,goal;\n\n  for(i=0;i<SIZE;i++){\n    board[0][i]=init_board[i];\n    if(init_board[i]==0) Space[0]=i;\n  }\n  prev_board[0]=-1;\n  init=change_num(init_board);\n  goal=change_num(goal_board);\n  check_table[init]=TRUE;\n  check_table[goal]=GOAL;\n\n  if(init==goal) {\n      print_answer(0);\n      return;\n  }\n  \n  while(front<rear){\n    s=Space[front];\n    for(i=0;(n=puzzle[s][i])!=-1;i++){\n      /*状態のコピー*/\n      for(j=0;j<SIZE;j++) board[rear][j]=board[front][j];\n      board[rear][s]=board[rear][n]; /*空白に移動*/\n      board[rear][n]=0;\n      Space[rear]=n;\n      prev_board[rear]=front;\n      k=change_num(board[rear]);\n      if(check_table[k]==GOAL){\n\t/*発見*/\n\tprint_answer(rear);\n\treturn;\n      }\n      \n      else if(!check_table[k]){\n\t  /*キューに登録*/\n\t  check_table[k]=TRUE;\n\t  rear++;\n\t}\n    }\n    front++;\n  }\n}\n\t\nvoid print_answer(int n){\n  int i,j,count=0;\n\n  while(n!=0){\n    count++;\n    n=prev_board[n];\n  }\n\n  printf(\"%d\\n\",count);\n\n  /* if(n!=0) print_answer(prev_board[n]); */\n\n  /* for(i=0;i<3;i++){ */\n  /*   for(j=0;j<3;j++){ */\n  /*     printf(\"%d \",board[n][i*3+j]); */\n  /*   } */\n  /*   printf(\"\\n\"); */\n  /* } */\n  /* printf(\"\\n\"); */\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint board[9];\nint rows = 3, cols = 3, zeroIndex, current;\n\n// for previousMove: 0 is down, 1 is up, 2 is left, 3 is right\nint blindSearch(int x, int y, int moves, int previousMove) {\n  int i, foundAnswer;\n\n  // answer is less than manhattan distance, not possible\n  if (moves < (x + y))\n    return 0;\n\n  if (!moves) {\n    for (i = 0; i < 8; i++) {\n      if (board[i] != i + 1)\n        return 0;\n    }\n\n    return 1;\n  }\n\n  if (x > 0 && previousMove != 1) {\n    // can expand down\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n\n    foundAnswer = blindSearch(x - 1, y, moves - 1, 0);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n  }\n\n  if (y > 0 && previousMove != 3) {\n    // right\n    board[zeroIndex] = board[++zeroIndex];\n\n    foundAnswer = blindSearch(x, y - 1, moves - 1, 2);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[--zeroIndex];\n  }\n if (y < rows - 1 && previousMove != 2) {\n    // left\n    board[zeroIndex] = board[--zeroIndex];\n\n    foundAnswer = blindSearch(x, y + 1, moves - 1, 3);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[++zeroIndex];\n  }\n\n  if (x < cols - 1 && previousMove != 0) {\n    // up\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n\n    foundAnswer = blindSearch(x + 1, y, moves - 1, 1);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n  }\n\n  return 0;\n}\n\nint main() {\n  int i, x, y;\n  current = 0;\n\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &board[i]);\n    if (!board[i])\n      zeroIndex = i;\n  }\n\n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n\n  while (current < 50) {\n    if (blindSearch(x, y, current, -1)) {\n      printf(\"%d\\n\", current);\n      return;\n    }\n    current++;\n  }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint A[3][3],tmp[3][3],dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nvoid empty(int *x,int *y) {\n  int i,j;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(!A[i][j]){\n        *x=j;\n        *y=i;\n        return;\n      }\n    }\n  }\n}\n\nvoid swap(int *a, int *b) {\n  int tmp;\n  tmp= *a;\n  *a= *b;\n  *b = tmp;\n}\n\n\nint cal() {\n  int i,u,sum=0;\n  for(i=0;i<9;i ++){\n    u=A[i/3][i%3];\n    if(u != 0){\n      u--;\n      sum += abs(i/3 - u/3)+abs(i%3 - u%3);\n    }\n  }\n  return sum;\n}\n\nint dfs(int x, int y, int p, int d, const int lim) {\n  int i,v,nx,ny,res;\n  v=cal();\n  if(v == 0) return d;\n  \n  if(d+v > lim) return -1;\n  \n  for(i=0;i<4;i++){\n    nx = x+dx[i];\n    ny = y+dy[i];\n    if(~p&&i == (p+2)%4) continue;\n    if(!(0 <= nx && nx < 3 && 0 <= ny && ny < 3)) continue;\n    swap(&A[y][x],&A[ny][nx]);\n    res=dfs(nx,ny,i,d+1,lim);\n\n    if(~res) return res;\n    \n    swap(&A[y][x],&A[ny][nx]);\n  }\n\n  return -1;\n}\n\nint main() {\n  int i,j,ans,x,y,l;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&A[i][j]);\n    }\n  }\n  empty(&x,&y);\n  for(l=0;l<100;l++){\n    for(i=0;i<3;i++){\n      for(j =0;j<3;j++){\n        tmp[i][j] = A[i][j];\n      }\n    }\n    ans = dfs(x,y,-1,0,l);\n    if(ans != -1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n        A[i][j]=tmp[i][j];\n      }\n    }\n\n    ans = -1;\n\n    if(l == 99){\n      printf(\"%d\\n\",ans);\n    }\n  }\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define TRUE  1\n#define FALSE 0\n#define FORWARD  1\n#define BACKWARD 2\n#define SIZE  9\n#define NIL   (-1)\n\n/* 状態数 (9! / 2) */\n#define MAX_STATE 181440\n\n/* 隣接リスト */\nconst char adjacent[SIZE][5] = {\n  1, 3,-1,-1,-1,\n  0, 4, 2,-1,-1,\n  1, 5,-1,-1,-1,\n  0, 4, 6,-1,-1,\n  1, 3, 5, 7,-1,\n  2, 4, 8,-1,-1,\n  3, 7,-1,-1,-1,\n  4, 6, 8,-1,-1,\n  5, 7,-1,-1,-1,\n};\n\n/* キュー */\nchar state[MAX_STATE + 1][SIZE];      /* +1 はワーク領域 */\nchar space_postion[MAX_STATE];\nint  prev_state[MAX_STATE];\nint  number_table[MAX_STATE];\n\n/* 同一局面チェックテーブル */\nchar check_table[MAX_STATE * 2];\n\n/* 初期状態 */\nchar init_state[SIZE];\n\n/* 終了状態 */\nchar final_state[SIZE] = {\n  1, 2, 3, 4, 5, 6, 7, 8, 0\n};\n\nint count=0;\n\nint main()\n{\n  int i;\n  \n  for(i = 0; i < 9; i++){\n    scanf(\"%d\", &init_state[i]);\n  }\n  \n  search();\n  printf(\"count = %d\\n\", count-1);  \n\n  return 0;\n}\n\nvoid print_answer_forward(int n)\n{\n  if(n > 1) print_answer_forward(prev_state[n]);\n  count++;\n}\n\nvoid print_answer_backward( int n )\n{\n  do{\n    n = prev_state[n];\n    count++;\n  }\n\n  while( prev_state[n] != -1 );\n}\n\nvoid print_answer( int pos1, int num1, int num2 )\n{\n  /* num2 の位置を見つける */\n  int pos2 = pos1 - 1;\n\n  while( num2 != number_table[pos2] ) pos2--;\n\n  if( check_table[num1] == FORWARD ){\n    print_answer_forward( pos1 );\n    print_answer_backward( pos2 );\n  }\n  else{\n    print_answer_forward( pos2 );\n    print_answer_backward( pos1 );\n  }\n}\n\n/* 番号に変換 */\nint change_number( char *board )\n{\n  char work[SIZE];\n  static int fact_table[SIZE] = {\n    40320, 5040, 720, 120, 24, 6, 2, 1, 0,\n  };\n  int j, k, value = 0;\n  memcpy( work, board, SIZE );\n  for( j = 0; j < SIZE - 1; j++ ){\n    value += fact_table[j] * work[j];\n    for( k = j + 1; k < SIZE; k++ ){\n      if( work[j] < work[k] ) work[k]--;\n    }\n  }\n  return value;\n}\n\n/* キューの初期化 */\nvoid init_queue( void )\n{\n  int num;\n\n  /* スタート */\n  memcpy( state[0], init_state, SIZE );\n  space_postion[0] = 7;\n  prev_state[0] = -1;\n  num = change_number( init_state );\n  number_table[0] = num;\n  check_table[ num ] = FORWARD;\n\n  /* ゴール */\n  memcpy( state[1], final_state, SIZE );\n  space_postion[1] = 8;\n  prev_state[1] = -1;\n  num = change_number( final_state );\n  number_table[1] = num;\n  check_table[ num ] = BACKWARD;\n}\n\n/* 探索 */\nvoid search( void )\n{\n  int front = 0, rear = 2;\n\n  /* 初期化 */\n  init_queue();\n\n  while( front < rear ){\n    int s = space_postion[front];\n    int num1 = number_table[front];\n    int num2, i, n;\n\n    for( i = 0; (n = adjacent[s][i]) != -1; i++ ){\n      /* 状態をコピー */\n      memcpy( state[rear], state[front], SIZE );\n      /* 移動 */\n      state[rear][s] = state[rear][n];\n      state[rear][n] = 0;\n      space_postion[rear] = n;\n      prev_state[rear] = front;\n      num2 = change_number( state[rear] );\n\n      if( !check_table[num2] ){\n\t/* 登録 */\n        number_table[rear] = num2;\n        check_table[num2] = check_table[num1];\n\trear++;\n      }\n      else if( check_table[num1] != check_table[num2] ){\n        /* 解が見つかった */\n        print_answer( rear, num1, num2 );\n        return;\n      }\n    }\n    front++;\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define M 9\n#define N 3\n#define yes 1\n#define no -1\n#define lim 100\n\ntypedef struct{\n  int a[M],b,c;\n}Puzzle;\n\nPuzzle now;\n\nint s1[4]={0,-1,0,1};\nint s2[4]={1,0,-1,0};\nchar contl[4]={'r','u','l','d'};\nint bord[M][M];\n\nint max,leng[lim];\n\nint in_bord(Puzzle x){\n  int i,count=0;\n  for(i=0;i<M;i++){\n    if(x.a[i]==M) continue;\n    count+=bord[i][x.a[i]-1];\n  }\n  return count;\n}\n\nint dfs(int deep,int z){\n  int i,r1,r2,y1,y2,change;\n  \n  if(now.c==0) return yes;\n  if(deep+now.c>max) return no;\n\n   r1=now.b/N;\n   r2=now.b%N;\n  Puzzle comp;\n\n  for(i=0;i<4;i++){\n    y1=r1+s1[i];\n    y2=r2+s2[i];\n\n    if(y1<0 || y2<0 || y1>=N || y2>=N) continue;\n    if(abs(z-i)==2) continue;\n    comp=now;\n\n    now.c-=bord[y1*N+y2][now.a[y1*N+y2]-1];\n    now.c+=bord[r1*N+r2][now.a[y1*N+y2]-1];\n    change=now.a[y1*N+y2];\n    now.a[y1*N+y2]=now.a[r1*N+r2];\n    now.a[r1*N+r2]=change;\n    now.b=y1*N+y2;\n    if(dfs(deep+1,i)==yes){\n      leng[deep]=i;\n      return yes;\n    }\n    now=comp;\n  }\n  return no;\n}\n\nvoid solve(Puzzle x){\n  int i,count=0;\n  \n  x.c=in_bord(x);\n  for(max=x.c;max<=lim;max++){\n    now=x;\n    if(dfs(0,-100)==yes){\n      for(i=0;i<max;i++){\n\tcount++;\n      }\n      printf(\"%d\\n\",count);\n      return;\n    }\n  }\n}\n      \n\nint main(){\n  int i,j,keep;\n  Puzzle in;\n\n  for(i=0;i<M;i++){\n    for(j=0;j<M;j++){\n      bord[i][j]=abs(i/N-j/N)+abs(i%N-j%N);\n    }\n  }\n\n  for(i=0;i<M;i++){\n    scanf(\"%d\",&in.a[i]);\n    if(in.a[i]==0) keep=i;\n  }\n      in.a[keep]=M;\n      in.b=keep;\n\n  solve(in);\n\n  return 0;\n}\n  \n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 3\nint suretu[N][N] = {\n    {1, 2, 3},\n    {4, 5, 6},\n    {7, 8, 0}};\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { -1, 0, 1, 0 };\nint keisan(int f[N][N]) {\n  int i,j;\n    for (i=0;i<N;++i) {\n        for (j=0;j<N;++j) {\n            if(f[i][j] != suretu[i][j])\n                return 0;\n        }\n    }\n    return 1;\n}\nint jeep(int f[N][N], int x, int y, int v, int d, int l) {\n  int i,j,res,nx,ny;\n    if (keisan(f)) return d;\n    if (d > l)return -1;\n    for (i=0;i<4;++i) {\n        nx=x+dx[i]; ny=y+dy[i];\n        if (nx<0||nx>2||ny<0||ny>2||(i+2)%4==v)\n            continue;\n        f[y][x]=f[ny][nx]; f[ny][nx]=0;\n        if((res=jeep(f, nx, ny, i, d + 1, l)) > 0)return res;\n        f[ny][nx] = f[y][x];  f[y][x] = 0;\n    }\n    return -1;\n}\nint main() {\n  int f[N][N], x, y,i,j,res;\n    for (i=0; i< N; ++i) {\n        for (j=0; j<N;++j) {\n            scanf(\"%d\",&f[i][j]);\n            if(f[i][j]==0) {\n                y=i;x=j;\n            }\n        }\n    }\n        for (i=1;i<50;++i) {\n        if ((res=jeep(f,x,y,-1,0,i))>=0){\n            break;\n        }\n    }\n    printf(\"%d\\n\",res);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 100000\n#define SENTINEL 2000000000\n\nstruct Card{\n  char suit;\n  int value;\n};\n\nstruct Card L[MAX/2+2], R[MAX/2+2];\n\nvoid merge(struct Card A[], int n, int left, int mid, int right){\n\n  int i, j, k;\n  int n1 = mid - left;\n  int n2 = right - mid;\n\n  for(i=0; i<n1; i++){\n    L[i] = A[left+1];\n  }\n  for(i=0; i<n2; i++){\n    R[i] = A[mid+i];\n  }\n\n  L[n1].value = R[n2].value = SENTINEL;\n  i = j = 0;\n\n  for(k=left; k<right; k++){\n    if(L[i].value <= R[j].value){\n      A[k] = L[i++];\n    }\n    else{\n      A[k] = R[j++];\n    }\n  }\n\n}\n\nvoid mergeSort(struct Card A[], int n, int left, int right){\n\n  int mid;\n\n  if(left+1 < right){\n    mid = (left+right)/2;\n    mergeSort(A, n, left, mid);\n    mergeSort(A, n, mid, right);\n    merge(A, n, left, mid, right);\n  }\n\n}\n\nint partition(struct Card A[], int n, int p, int r){\n\n  int i, j;\n  struct Card t, x;\n  x = A[r];\n  i = p-1;\n\n  for(j=p; j<r; j++){\n    if(A[j].value <= x.value){\n      i++;\n      t = A[i];\n      A[i] = A[j];\n      A[j] = t;\n    }\n  }\n\n  t = A[i+1];\n  A[i+1] = A[r];\n  A[r] = t;\n\n  return i+1;\n\n}\n\nvoid quickSort(struct Card A[], int n, int p, int r){\n\n  int q;\n\n  if(p<r){\n    q = partition(A, n , p, r);\n    quickSort(A, n, p, q-1);\n    quickSort(A, n, q+1, r);\n  }\n\n}\n\nint main(){\n\n  int n, i, v;\n  struct Card A[MAX], B[MAX];\n  char S[10];\n  int stable=1;\n\n  scanf(\"%d\",&n);\n\n  for(i=0; i<n; i++){\n    scanf(\"%s %d\", S, &v);\n    A[i].suit = B[i].suit = S[0];\n    A[i].value = B[i].value = v;\n  }\n\n  mergeSort(A, n, 0, n);\n  quickSort(B, n, 0, n-1);\n\n  for(i=0; i<n; i++){\n    if(A[i].suit != B[i].suit){\n      stable = 0;\n    }\n  }\n\n if(stable==1){\n    printf(\"Stable\\n\");\n  }\n  else{\n    printf(\"Not stable\\n\");\n  }\n\n  for(i=0; i<n; i++){\n    printf(\"%c %d\\n\", B[i].suit, B[i].value);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n  unsigned int b;\n  char step;\n} Board;\n\nint qlen=32202;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nconst Motion motion[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}} };\n\nint findzero(unsigned int b)\n{\n  for (int i=0; i<9; i++) {\n    if (b%10==0) return 8-i;\n    b/=10;\n  }\n  return -1;\n}\n\nunsigned int sq[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000,1000000000 };\n\n#define HISTLEN 8765432\n\nint main()\n{\n  int i, j, k;\n  int qhead, qtail;\n  qhead = qtail = 0;\n  Board board;\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b = i*sq[8]+j*sq[7]+k*sq[6];\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b += i*sq[5]+j*sq[4]+k*sq[3];\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b += i*100+j*10+k;\n  short int *used = (short int*)malloc(sizeof(short int)*HISTLEN);\n  for (i=0; i<HISTLEN; i++) used[i]=0;\n  Board *Q = (Board*)malloc(sizeof(Board)*qlen);\n  board.step=0;\n  Q[qhead++] = board;\n  \n  while (qhead>qtail) {\n    board = Q[qtail++ %qlen];\n    if (board.b==123456780)   break;\n    \n    int space = findzero(board.b);\n    for (i=0; motion[space][i].pos>=0; i++) {\n      Board b = board;\n      Motion m = motion[space][i];\n      if (m.pos==0 && b.b/sq[8]==1) continue;\n      if ((m.pos==1||m.pos==2) && b.b/sq[8]==1&&(b.b%sq[8])/sq[7]==2&&(b.b%sq[7])/sq[6]==3) continue;\n      int nn=b.b%sq[8-m.pos+1]/sq[8-m.pos];\n      b.b = nn*sq[8-space]+b.b-nn*sq[8-m.pos];\n      b.step = board.step+1;\n      k=b.b/100;\n      if ((used[k] & (1<<(b.b%10)))==(1<<(b.b%10))) continue;\n      used[k] |= (1<<(board.b%10));\n      Q[qhead++ %qlen] = b;\n    }\n  }\n  printf(\"%d\\n\", board.step);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \nint p[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n \nvoid emp(int *,int *);\nint dfs(int,int,int,int,const int);\nint cal();\nvoid swap(int *,int *);\n \nint main() {\n    int i,j,a,x,y,l;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) scanf(\"%d\",&p[i][j]);\n    }\n    emp(&x,&y);\n    for(l=0; l<100; l++) {\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) tmp[i][j] = p[i][j];\n        }\n        a = dfs(x,y,-1,0,l);\n        if(a!=-1) {\n            printf(\"%d\\n\",a);\n            break;\n        }\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) p[i][j] = tmp[i][j];\n        }\n        a = -1;\n        if(l==99) printf(\"%d\\n\",a);\n    }\n     printf(\"%d\\n\",a);\n     return 0;\n}\n  \nvoid emp(int *x,int *y) {\n    int i,j;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) {\n            if(!p[i][j]) {\n                *x = j;\n                *y = i;\n                return;\n            }\n        }\n    }\n}\n \nvoid swap(int *a,int *b) {\n    int tmp;\n    tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n \nint cal() {\n    int i,a,sum=0;\n    for(i=0; i<9; i++) {\n        a = p[i/3][i%3];\n        if(a) {\n            a--;\n            sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n        }\n   }\n    return sum;\n}\n \nint dfs(int x,int y,int p1,int d,const int lim) {\n    int i,h,nx,ny,res;\n    h = cal();\n    if(h==0) return d;\n    if(d+h>lim) return -1;\n    for(i=0; i<4; i++) {\n        nx = x+dx[i];\n        ny = y+dy[i];\n        if(~p1 && i==(p1+2)%4) continue;\n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n        swap(&p[y][x],&p[ny][nx]);\n        res = dfs(nx,ny,i,d+1,lim);\n        if(~res) return res;\n        swap(&p[y][x],&p[ny][nx]);\n    }\n    return -1;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\ntypedef struct{\n  int B[3][3];\n}board;\n\nboard P;\n\nint heustric(){\n  int i,j,x,y,sum=0;\n\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(P.B[i][j] == 0) continue;\n      x = (P.B[i][j] -1)%3 - j;\n      y = (P.B[i][j] -1)/3 - i;\n\n      if(x < 0) sum -= x;\n      else sum += x;\n\n      if(y < 0) sum -=y;\n      else sum+= y;\n    }\n  }\n\n  return sum;\n}\n\nint DFS(int x,int y,int max,int cnt,int n){\n  int i,temp,x0,y0,time,h;\n\n  h = heustric();\n  if(h == 0) return cnt;\n  else if(cnt + h > max) return -1;\n\n  for(i=0;i<4;i++){\n    x0 = x + dx[i];\n    y0 = y + dy[i];\n\n    if((i == (n +2)%4 && n!= -1) || (x0 < 0 || 3<= x0 || y0 < 0 || 3 <= y0)) continue;\n    temp = P.B[y][x];\n    P.B[y][x] = P.B[y0][x0];\n    P.B[y0][x0] = temp;\n\n    time = DFS(x0,y0,max,cnt+1,i);\n\n    if(time != -1) return time;\n    temp = P.B[y][x];\n    P.B[y][x] = P.B[y0][x0];\n    P.B[y0][x0] = temp;\n  }\n\n  return -1;\n}\n\nint main(){\n  int i,j,x,y,time;\n  board S;\n  \n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n\tscanf(\"%d\",&P.B[i][j]);\n\tif(P.B[i][j] == 0){\n\t  x = j;\n\t  y = i;\n\t}\n      }\n    }\n\n    S = P;\n\n    for(i=1;i<46;i++){\n      P = S;\n\n      time = DFS(x,y,i,0,-1);\n      if(time != -1){\n\tprintf(\"%d\\n\",time);\n\tbreak;\n      }\n    }\n\n    return 0;\n}\n\t  \n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n  \nint mas[3][3];\nint cpy[3][3];\n  \nvoid input() {\n  int i, j;\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++)\n      scanf(\"%d\", &mas[i][j]);\n}\n  \nvoid output() {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n    puts(\"\");\n  }\n}\n  \nvoid copy(int m[3][3], int t[3][3]) {\n  int i, j;\n  \n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n  \nint calc() {\n  int i, sum = 0;\n  for(i = 0; i < 9; i++) {\n    int v = mas[i/3][i%3];\n    if(v) {\n      v--;\n      sum += abs(i/3-v/3)+abs(i%3-v%3);\n    }\n  }\n  return sum;\n}\n  \nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n  \nvoid swap(int *a, int *b) {\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n  \nint is_in(int x, int y) {\n  return 0<=x&&x<3&&0<=y&&y<3;\n}\n  \nint dfs(int x, int y, int p, int dep, const int lim) {\n  int i, h = calc();\n  //output();\n  if(h == 0) return dep;\n  //printf(\"%d %d %d\\n\", h, lim, p);\n  if(dep+h > lim) return -1;\n  \n  for(i = 0; i < 4; i++) {\n    int nx = x+dx[i], ny = y+dy[i], res;\n    if(~p && i == (p+2)%4) continue;\n    if(!is_in(nx, ny)) continue;\n    swap(&mas[y][x], &mas[ny][nx]);\n    res = dfs(nx, ny, i, dep+1, lim);\n    if(~res) return res;\n    swap(&mas[y][x], &mas[ny][nx]);\n  }\n  \n  return -1;\n}\n  \nvoid get_empty(int *x, int *y) {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) {\n      if(!mas[i][j]) {\n    *x = j;\n    *y = i;\n    return;\n      }\n    }\n  }\n}\n  \nint solve() {\n  int x, y, lim, ans;\n  get_empty(&x, &y);\n  for(lim = 0; lim < 50; lim++) {\n    copy(cpy, mas);\n    if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n    copy(mas, cpy);\n  }\n  return -1;\n}\n  \nint main() {\n  input();\n  printf(\"%d\\n\", solve());\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "//2020.2.1\n//s1270188 xxxmk2\n//alds1_13b\n\n#include<stdio.h>\n#include<stdlib.h>\n#define N 3\n#define D 100\n\n//struct\nstruct node{\n  int data[N][N];\n  struct node *p;\n};\nstruct xy{\n  int x;\n  int y;\n};\n\n//global\nstruct node root;\nint mv[4][2]={0,1,0,-1,-1,0,1,0};//上下左右 xy\n\n//function\nint man(int n,int x,int y){\n  int nx, ny;\n\n  nx=(n-1)%N;\n  ny=(n-1)/N;\n  \n  x=x-nx;\n  if(x<0) x*=-1;\n\n  y=y-ny;\n  if(y<0) y*=-1;\n  \n  return x+y;\n}\n\nint judge(struct node *n){\n  int i, j=0;\n\n  if(n==NULL) return -1;\n  \n  for(i=0;i<N*N;i++){\n    if(n->data[i%N][i/N]==0) continue;\n    if(n->data[i%N][i/N]!=i+1) j+=man(n->data[i%N][i/N],i%N,i/N);\n  }\n\n  return j;\n}\n\nstruct xy blank(struct node *n){\n  struct xy ddd;\n  int i;\n\n  for(i=0;i<N*N;i++)\n    if(n->data[i%N][i/N]==0) break;\n\n  ddd.x=i%N;\n  ddd.y=i/N;\n  \n  return ddd;\n}\n\nstruct node *mk(struct node *n,struct xy b, struct xy m){\n  struct node *aaa;\n  int i;\n  \n  aaa=malloc(sizeof(struct node));\n\n  for(i=0;i<N*N;i++) aaa->data[i%N][i/N]=n->data[i%N][i/N];\n  \n  aaa->data[b.x][b.y]=aaa->data[m.x][m.y];\n  aaa->data[m.x][m.y]=0;\n  aaa->p=n;\n  \n  return aaa;\n}\n\n\nint puzzle(struct node *n,struct node *bp, int g,int d){\n  int h=judge(n), i, j;\n  struct xy bl, m;\n  struct node *mm;\n  \n  if(h==0) return g;\n\n  if(g+h>d) return -1;\n  \n  bl=blank(n);\n  \n  for(i=0;i<4;i++){\n    m.x=bl.x+mv[i][0];\n    m.y=bl.y+mv[i][1];\n\n    if(m.x<0 || m.y<0 || m.x==N || m.y==N ) continue;\n    \n    mm=mk(n,bl,m);\n    if(bp!=NULL){\n      for(j=0;j<N*N;j++)\n\tif(mm->data[j%N][j/N]!=bp->data[j%N][j/N]) break;\n      if(j==N*N){\n\tfree(mm);\n\tcontinue;\n      }\n    }\n    \n    j=puzzle(mm,mm->p,g+1,d);\n    if(j>0) return j;\n  }\n\n  return -1;\n}\n\nint main(){\n  int i, ans;\n  struct node *n, *m;\n  \n  //input\n  for(i=0;i<N*N;i++) scanf(\"%d\",&root.data[i%N][i/N]);\n  root.p=NULL;\n  \n  for(i=judge(&root);i<=D;i++){\n    ans=puzzle(&root,NULL,0,i);\n\n    if(ans>0) break;\n  }\n  \n  //output\n  printf(\"%d\\n\",ans);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "if (x < cols - 1 && previousMove != 0) {\n    // up\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n\n    foundAnswer = blindSearch(x + 1, y, moves - 1, 1);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n  }\n\n  return 0;\n}\n\nint main() {\n  int i, x, y;\n  current = 0;\n\n  for (i = 0; i < N; i++) {\n    scanf(\"%d\", &board[i]);\n    if (!board[i])\n      zeroIndex = i;\n  }\n\n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n\n  //printf(\"zero index coordinates are: %d %d\\n\", x, y);\n\n  while (current < 5) {\n    if (blindSearch(x, y, current, -1)) {\n      printf(\"%d\\n\", current);\n      return;\n    }\n    current++;\n  }\n\n  //printf(\"Couldn't find an answer!\\n\");\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n\n// I/O\nint get_uint() {\n    int n = 0;\n    int c = getchar_unlocked();\n    if(c < 48 || 57 < c) return c;\n    while(47 < c && c < 58) n = 10 * n + (c & 0xf), c = getchar_unlocked();\n    return n;\n}\nvoid put_uint(int n) {\n    if(!n) {\n        putchar_unlocked('0');\n        return;\n    }\n    char buf[11];\n    int i = 0;\n    while(n) buf[i++] = (char)(n % 10 + '0'), n /= 10;\n    while(i--)putchar_unlocked(buf[i]);\n}\n//\n\n\n// Util\n#define likely(x)   __builtin_expect(!!(x), 1)\n#define unlikely(x) __builtin_expect(!!(x), 0)\n#define container_of(ptr, type, member) ({  \\\n    void *__mptr = (void *)(ptr);           \\\n    ((type *)(__mptr - offsetof(type, member))); })\n//\n\n\n// Red Black Tree\nstruct rb_node {\n    unsigned long __rb_parent_color;\n    struct rb_node *rb_right;\n    struct rb_node *rb_left;\n} __attribute__((aligned(sizeof(long))));\n\nstruct rb_root {\n    struct rb_node *rb_node;\n};\n\n#define rb_parent(r) ((struct rb_node *)((r)->__rb_parent_color & ~3))\n#define RB_ROOT (struct rb_root) { NULL, }\n#define RB_EMPTY_NODE(node)  \\\n   ((node)->__rb_parent_color == (unsigned long)(node))\n\nstatic inline void rb_link_node(struct rb_node *node, struct rb_node *parent, struct rb_node **rb_link) {\n    node->__rb_parent_color = (unsigned long)parent;\n    node->rb_left = node->rb_right = NULL;\n    *rb_link = node;\n}\n\n#define RB_RED      0\n#define RB_BLACK    1\n\n#define __rb_color(pc)      ((pc) & 1)\n#define __rb_is_red(pc)     (!__rb_color(pc))\n#define __rb_is_black(pc)   __rb_color(pc)\n#define rb_color(rb)        __rb_color((rb)->__rb_parent_color)\n#define rb_is_red(rb)       __rb_is_red((rb)->__rb_parent_color)\n#define rb_is_black(rb)     __rb_is_black((rb)->__rb_parent_color)\n\nstatic inline void rb_set_parent(struct rb_node *rb, struct rb_node *p) {\n    rb->__rb_parent_color = rb_color(rb) | (unsigned long)p;\n}\n\nstatic inline void rb_set_parent_color(struct rb_node *rb, struct rb_node *p, int color) {\n    rb->__rb_parent_color = (unsigned long)p | color;\n}\n\nstatic inline void __rb_change_child(struct rb_node *old, struct rb_node *new, struct rb_node *parent, struct rb_root *root) {\n    if(parent) {\n        if(parent->rb_left == old) parent->rb_left = new;\n        else parent->rb_right = new;\n    } else root->rb_node = new;\n}\n\nstatic inline void rb_set_black(struct rb_node *rb) {\n    rb->__rb_parent_color |= RB_BLACK;\n}\n\nstatic inline struct rb_node *rb_red_parent(struct rb_node *red) {\n    return (struct rb_node *)red->__rb_parent_color;\n}\n\nstatic inline void __rb_rotate_set_parents(struct rb_node *old, struct rb_node *new, struct rb_root *root, int color) {\n    struct rb_node *parent = rb_parent(old);\n    new->__rb_parent_color = old->__rb_parent_color;\n    rb_set_parent_color(old, new, color);\n    __rb_change_child(old, new, parent, root);\n}\n\nstatic inline void rb_insert(struct rb_node *node, struct rb_root *root) {\n    struct rb_node *parent = rb_red_parent(node), *gparent, *tmp;\n\n    while(1) {\n        // Loop invariant: node is red.\n        if(unlikely(!parent)) {\n            rb_set_parent_color(node, NULL, RB_BLACK);\n            break;\n        }\n        if(rb_is_black(parent)) break;\n\n        gparent = rb_red_parent(parent);\n\n        tmp = gparent->rb_right;\n        if(parent != tmp) {\n            if(tmp && rb_is_red(tmp)) {\n                rb_set_parent_color(tmp, gparent, RB_BLACK);\n                rb_set_parent_color(parent, gparent, RB_BLACK);\n                node = gparent;\n                parent = rb_parent(node);\n                rb_set_parent_color(node, parent, RB_RED);\n                continue;\n            }\n\n            tmp = parent->rb_right;\n            if(node == tmp) {\n                tmp = node->rb_left;\n                parent->rb_right = tmp;\n                node->rb_left = parent;\n                if(tmp) rb_set_parent_color(tmp, parent, RB_BLACK);\n                rb_set_parent_color(parent, node, RB_RED);\n                parent = node;\n                tmp = node->rb_right;\n            }\n\n            gparent->rb_left = tmp;\n            parent->rb_right = gparent;\n            if(tmp) rb_set_parent_color(tmp, gparent, RB_BLACK);\n            __rb_rotate_set_parents(gparent, parent, root, RB_RED);\n            break;\n        } else {\n            tmp = gparent->rb_left;\n            if(tmp && rb_is_red(tmp)) {\n                rb_set_parent_color(tmp, gparent, RB_BLACK);\n                rb_set_parent_color(parent, gparent, RB_BLACK);\n                node = gparent;\n                parent = rb_parent(node);\n                rb_set_parent_color(node, parent, RB_RED);\n                continue;\n            }\n\n            tmp = parent->rb_left;\n            if(node == tmp) {\n                tmp = node->rb_right;\n                parent->rb_left = tmp;\n                node->rb_right = parent;\n                if(tmp) rb_set_parent_color(tmp, parent, RB_BLACK);\n                rb_set_parent_color(parent, node, RB_RED);\n                parent = node;\n                tmp = node->rb_left;\n            }\n            gparent->rb_right = tmp;\n            parent->rb_left = gparent;\n            if(tmp) rb_set_parent_color(tmp, gparent, RB_BLACK);\n            __rb_rotate_set_parents(gparent, parent, root, RB_RED);\n            break;\n        }\n    }\n}\n\nstruct rb_node *rb_first(const struct rb_root *root) {\n    struct rb_node *n;\n    n = root->rb_node;\n    if(!n) return NULL;\n    while(n->rb_left) n = n->rb_left;\n    return n;\n}\n\nstruct rb_node *rb_next(const struct rb_node *node) {\n    struct rb_node *parent;\n    if(RB_EMPTY_NODE(node)) return NULL;\n\n    if(node->rb_right) {\n        node = node->rb_right;\n        while(node->rb_left) node = node->rb_left;\n        return (struct rb_node *)node;\n    }\n\n    while((parent = rb_parent(node)) && node == parent->rb_right) node = parent;\n\n    return parent;\n}\n//\n\n\n// node key\nstruct mykey {\n    int board[9];\n    int space;\n    int cnt;\n};\n\nint cmp_mykey(const struct mykey *l, const struct mykey *r) {\n    for(int i = 0; i < 9; ++i) {\n        if(l->board[i] == r->board[i]) continue;\n        if(l->board[i] < r->board[i]) return -1;\n        else return 1;\n    }\n    return 0;\n}\n\nstruct mynode {\n    struct rb_node node;\n    struct mykey key;\n};\n\nstruct mynode *my_search(struct rb_root *root, struct mykey key) {\n    struct rb_node *node = root->rb_node;\n\n    while(node) {\n        struct mynode *data = container_of(node, struct mynode, node);\n        int result = cmp_mykey(&key, &data->key);\n\n        if(result < 0) node = node->rb_left;\n        else if(result > 0) node = node->rb_right;\n        else return data;\n    }\n    return NULL;\n}\n\nint my_insert(struct rb_root *root, struct mynode *data) {\n    struct rb_node **new = &(root->rb_node), *parent = NULL;\n\n    while(*new) {\n        struct mynode *this = container_of(*new, struct mynode, node);\n        int result = cmp_mykey(&data->key, &this->key);\n\n        parent = *new;\n        if(result < 0) new = &((*new)->rb_left);\n        else if(result > 0) new = &((*new)->rb_right);\n        else return -1;\n    }\n    rb_link_node(&data->node, parent, new);\n    rb_insert(&data->node, root);\n    return 0;\n}\n\n/*\nvoid my_print_inorder(struct rb_root *root) {\n    struct rb_node *node;\n    for(node = rb_first(root); node; node = rb_next(node)) {\n        putchar_unlocked(' ');\n        put_int(container_of(node, struct mynode, node)->key);\n    }\n}\n*/\n//\n\n\n// List\nstruct list_head {\n    struct list_head *next, *prev;\n};\n\nstatic inline void INIT_LIST_HEAD(struct list_head *list) {\n    list->next = list;\n    list->prev = list;\n}\n\nstatic inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next) {\n    next->prev = new;\n    new->next = next;\n    new->prev = prev;\n    prev->next = new;\n}\n\nstatic inline void list_add(struct list_head *new, struct list_head *head) {\n    __list_add(new, head, head->next);\n}\n\nstatic inline void list_add_tail(struct list_head *new, struct list_head *head) {\n    __list_add(new, head->prev, head);\n}\n\nstatic inline void __list_del(struct list_head *prev, struct list_head *next) {\n    next->prev = prev;\n    prev->next = next;\n}\n\nstatic inline void __list_del_entry(struct list_head *entry) {\n    __list_del(entry->prev, entry->next);\n}\n\nstatic inline void list_del(struct list_head *entry) {\n    __list_del_entry(entry);\n    entry->next = NULL;\n    entry->prev = NULL;\n}\n\nstatic inline int list_empty(const struct list_head *head) {\n    return head->next == head;\n}\n\n#define list_entry(ptr, type, member) container_of(ptr, type, member)\n#define list_first_entry(ptr, type, member) list_entry((ptr)->next, type, member)\n//\n\nstruct my_list {\n    struct mykey key;\n    struct list_head list;\n};\n\n\n// end condition\nint is_solved(const int board[9]) {\n    for(int i = 0; i < 8; ++i)\n        if(board[i] != i + 1) return 0;\n    return 1;\n}\n\n\nstruct mynode node[200000];\n// solve\nint bfs(struct mykey s) {\n    const int N = 3;\n    const int dx[4] = {-1, 0, 1, 0};\n    const int dy[4] = {0, -1, 0, 1};\n    static int num = 0;\n    node[0].key = s;\n    struct rb_root mytree = RB_ROOT;\n\n    my_insert(&mytree, node + num++);\n    struct list_head head;\n    INIT_LIST_HEAD(&head);\n    struct my_list *data = malloc(sizeof(struct my_list));\n    data->key = s;\n    list_add_tail(&data->list, &head);\n    while(!list_empty(&head)) {\n        data = list_first_entry(&head, struct my_list, list);\n        struct mykey key = data->key;\n        list_del(&data->list);\n        free(data);\n        if(is_solved(key.board)) return key.cnt;\n        int x = key.space % N;\n        int y = key.space / N;\n        for(int i = 0; i < 4; ++i) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(nx < 0 || N <= nx || ny < 0 || N <= ny) continue;\n\n            int next_space = nx + ny * N;\n            struct mykey next_key = key;\n            next_key.board[key.space] = next_key.board[next_space];\n            next_key.board[next_space] = 0;\n            next_key.space = next_space;\n            if(my_search(&mytree, next_key)) continue;\n\n            next_key.cnt++;\n            node[num].key = next_key;\n            if(my_insert(&mytree, node + num) == 0) num++;\n            data = malloc(sizeof(struct my_list));\n            data->key = next_key;\n            list_add_tail(&data->list, &head);\n        }\n    }\n}\n\n\nint main(int argc, char **argv) {\n    struct mykey initial = {.cnt = 0};\n    for(int i = 0; i < 9; ++i) {\n        int x = get_uint();\n        initial.board[i] = x;\n        if(x == 0) initial.space = i;\n    }\n    //clock_t start, end;\n    //start = clock();\n\n    put_uint(bfs(initial));\n    putchar_unlocked('\\n');\n\n    //end = clock();\n    //printf(\"%lf\\n\", (double)(end-start)/CLOCKS_PER_SEC);\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 3\n#define MAX 15\ntypedef struct{\n  int A[N][N];\n}Pazzle;\nPazzle P;\nint d_x[4]={0,1,0,-1};\nint d_y[4]={1,0,-1,0};\n\nvoid swap(int *A,int *B){\n  int hoge;\n  hoge=*A;\n  *A=*B;\n  *B=hoge;\n \n \n}\n\nint check(Pazzle P){\n  int sum=0,i,j,hy,hx;\n  for(i=0;i<N;i++){\n \n    for(j=0;j<N;j++){\n      if(P.A[i][j]==0)\n        continue;\n      hy=(P.A[i][j]-1)/N-i;\n      hx=(P.A[i][j]-1)%N-j;\n      if(hy<0)\n        sum-=hy;\n      else\n        sum+=hy;\n      if(hx<0)\n        sum-=hx;\n      else\n        sum+=hx;\n \n \n    }\n  }\n \n  return sum;\n}\n\nint dfs(int x,int y,int max,int cnt,int m){\n  int i;\n  int heau;\n  int x_0,y_0;\n  int ans=-1;   \n  heau=check(P);\n  if(heau==0) return cnt;\n  if(cnt+heau>max) return -1; \n  for(i=0;i<4;i++){\n    x_0=x+d_x[i];\n    y_0=y+d_y[i];      \n   \n    if((m!=-1&&i==(m+2)%4)||!(0<=x_0 && x_0<N && 0<=y_0 && y_0<N)) continue;    \n    swap(&P.A[y][x],&P.A[y_0][x_0]);\n    ans=dfs(x_0,y_0,max,cnt+1,i);\n    if(ans!=-1) return ans;       \n    swap(&P.A[y][x],&P.A[y_0][x_0]);\n  }   \n  return -1;\n}\n\nint main(void){\n  Pazzle t_P;\n  int  i,j,ans;\n  int x0,y0;\n\n\n  for(i=0;i<N;i++){\n    if(i<N)break;\n  }\n  \n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&P.A[i][j]);\n      if(P.A[i][j]==0){\n\tx0=j;\n\ty0=i;\n                \n      }\n            \n    }\n  }\n  t_P=P;\n  for(i=1;i<46;i++){\n    P=t_P;\n    ans=dfs(x0,y0,i,0,-1);\n    if(ans!=-1){printf(\"%d\\n\",ans); break;}\n  }\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define N 3\n#define LIMIT 100\n#define TRUE 1\n#define FALSE 0\n#define NIL -1\n\ntypedef struct{\n  int map[N*N];\n  int space,MD;\n}PUZZLE;\n\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\nchar vector[4]={'r','u','l','d'};\nint limit,path[LIMIT];\nint MDT[N*N][N*N];\nPUZZLE status,in;\n\nint getHeur(PUZZLE);//マンハッタン距離の総和を計算し、その値をヒューリスティック値とする。\nint dfs(int,int);//深さ優先探索\nvoid getAns(PUZZLE);//IDA\n\n\nint main(){\n  int i,j,memory;\n  PUZZLE p;\n  //  for(i=0;i<LIMIT;i++)path[i]=NIL;\n   \n  \n  for(i=0;i<N*N;i++){\n    for(j=0;j<N*N;j++){\n      MDT[i][j]=abs(i/N-j/N)+abs(i%N-j%N);\n    }\n  }\n\n  for(i=0;i<N*N;i++){\n    scanf(\"%d\",&p.map[i]);\n    if(p.map[i]==0)memory=i;\n  }\n  p.map[memory]=N*N;\n  p.space=memory;\n\n  getAns(p);\n  // for(i=0;i<100;i++)printf(\"%d\\n\",path[i]);\n  \n  return 0;\n}\n\n\nint getHeur(PUZZLE p){\n  int i;\n  int h=0;//ヒューリスティック値\n  for(i=0;i<N*N;i++){\n    if(p.map[i]==N*N){\n      continue;\n    }\n    h+=MDT[i][p.map[i]-1];\n  }\n  return h;\n}\n\nint dfs(int depth,int prev){\n  int i;\n  PUZZLE pTemp;\n  int sx,sy,tx,ty,temp;\n\n  \n  if(status.MD==0) return TRUE;\n  if(depth+status.MD>limit)return FALSE;\n\n  sx=status.space/N;\n  sy=status.space%N;\n\n  for(i=0;i<4;i++){\n    tx=sx+dx[i];\n    ty=sy+dy[i];\n    if(!(tx>=0&&tx<N&&ty>=0&&ty<N))continue;\n    if(abs(prev-i)==2)continue;\n    \n    pTemp=status;\n    status.MD+=MDT[sx*N+sy][status.map[tx*N+ty]-1];\n    status.MD-=MDT[tx*N+ty][status.map[tx*N+ty]-1];\n    temp=status.map[tx*N+ty];\n    status.map[tx*N+ty]= status.map[sx*N+sy];\n    status.map[sx*N+sy]=temp;\n    status.space=tx*N+ty;\n    if(dfs(depth+1,i)==TRUE){\n      path[depth]=i;\n      return TRUE;\n    }\n    status=pTemp;\n  }\n  return FALSE;\n}\n\n\n\nvoid getAns(PUZZLE p){\n  int i,result=0;\n  p.MD=getHeur(p);\n  for(limit=p.MD;limit<=LIMIT;limit++){\n    status=p;\n    if(dfs(0,-100)==TRUE){\n      for(i=0;i<limit;i++){\n\t//if(path[i]!=NIL)\n\tresult++;      \n      }\n      printf(\"%d\\n\",result);\n      return;\n    }\n  }\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint main(){\n\tint ret;\n\tint i, j, temp;\n\tint seikai[9][2] =\n\t{\n\t\t{0,0},\n\t\t{0,1},\n\t\t{0,2},\n\t\t{1,0},\n\t\t{1,1},\n\t\t{1,2},\n\t\t{2,0},\n\t\t{2,1},\n\t\t{2,2}\n\t};\n\n\tret = 0;\n\tfor(i = 0; i < 3; i++){\n\t\tfor(j = 0; j < 3; j++){\n\t\t\tscanf(\"%d\", &temp);\n\t\t\tif(temp != 0){\n\t\t\t\tret += abs(seikai[(temp - 1)][0] - i);\n\t\t\t\tret += abs(seikai[(temp - 1)][1] - j);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define N 3\n\nint search(int board[N][N],int min,int limit,int r,int c);\n\nint main(int argc, char *argv[]){\n  int board[N][N];\n  int md;\n  int i,j,r,c,x,y,found;\n  int res;\n  for (i=0;i<N;i++) {\n    for (j=0;j<N;j++)\n    scanf(\"%d\",&board[i][j]);\n  }\n  md=0;\n  for(i=0;i<N*N;i++) {\n    found=0;\n    for(r=0;r<N;r++){\n      for(c=0;c<N;c++) {\n\t       if(board[r][c]==i){\n\t          if(i==0){\n\t             x=r;\n\t              y=c;\n\t             }\n               else md+=(int)abs((i-1)/N-r)+(int)abs((i-1)%N-c);\n\t              found=1;\n\t               break;\n\t        }\n      }\n      if (found == 1) break;\n      }\n  }\n\n  for(i=0;;i+=2){\n    if((x+y)%2==0){\n      if(md%2==0)res=search(board,md,md+i,x,y);\n      else res=search(board,md,md+i+1,x,y);\n    }\n    else{\n      if(md%2==0)res=search(board,md,md+i+1,x,y);\n      else res=search(board,md,md+i,x,y);\n    }\n    if(res!=-1)break;\n  }\n  printf(\"%d\\n\",res);\n  return 0;\n}\n\nint search(int board[N][N],int min,int limit,int x, int y){\n  int md_c,num,res[4];\n  if(min==0)return 0;\n  if(x!=0){\n    md_c=min;\n    num=board[x-1][y];\n    md_c-=(int)abs((num-1)/N-(x-1))+(int)abs((num-1)%N-y);\n    md_c+=(int)abs((num-1)/N-x)+(int)abs((num-1)%N-y);\n    if(md_c<=limit-1){\n      board[x-1][y]=0;\n      board[x][y]=num;\n      res[0]=search(board,md_c,limit-1,x-1,y);\n      if(res[0]==-1){\n\tboard[x-1][y]=num;\n\tboard[x][y]=0;\n      }\n      else res[0]++;\n    }\n    else res[0]=-1;\n  }\n  else res[0]=-1;\n  if(x!=N-1){\n    md_c=min;\n    num=board[x+1][y];\n    md_c-=(int)abs((num-1)/N-(x+1))+(int)abs((num-1)%N-y);\n    md_c+=(int)abs((num-1)/N-x)+(int)abs((num-1)%N-y);\n    if(md_c<=limit-1){\n      board[x+1][y]=0;\n      board[x][y]=num;\n      res[1]=search(board,md_c,limit-1,x+1,y);\n      if(res[1]==-1){\n\t       board[x+1][y]=num;\n\t       board[x][y]=0;\n      }\n      else res[1]++;\n    }\n    else res[1]=-1;\n  }\n  else res[1]=-1;\n\n  if(y!=0){\n    md_c=min;\n    num=board[x][y-1];\n    md_c-=(int)abs((num-1)/N-x)+(int)abs((num-1)%N-(y-1));\n    md_c+=(int)abs((num-1)/N-x)+(int)abs((num-1)%N-y);\n    if(md_c<=limit-1){\n      board[x][y-1]=0;\n      board[x][y]=num;\n      res[2]=search(board,md_c,limit-1,x,y-1);\n      if(res[2]==-1){\n\t       board[x][y-1]=num;\n\t       board[x][y]=0;\n      }\n      else res[2]++;\n    }\n    else res[2]=-1;\n  }\n  else res[2]=-1;\n  if (y!=N-1){\n    md_c=min;\n    num=board[x][y+1];\n    md_c-=(int)abs((num-1)/N-x)+(int)abs((num-1)%N-(y+1));\n    md_c+=(int)abs((num-1)/N-x)+(int)abs((num-1)%N-y);\n    if(md_c<=limit-1) {\n      board[x][y+1]=0;\n      board[x][y]=num;\n      res[3]=search(board,md_c,limit-1,x,y+1);\n      if(res[3]==-1){\n        board[x][y+1]=num;\n        board[x][y]=0;\n      }\n      else res[3]++;\n    }\n    else res[3]=-1;\n  }\n  else res[3]=-1;\n\n  if(res[0]==-1&&res[1]==-1&&res[2]==-1&&res[3]==-1) return -1;\n  else if(res[0]!=-1)return res[0];\n  else if(res[1]!=-1)return res[1];\n  else if(res[2]!=-1)return res[2];\n  else return res[3];\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\n#define N 3\n#define SPACE 9\n#define QUEUE_MAX 400000\n#define TRUE 1\n#define FALSE 0\n\ntypedef struct P {\n  int steps;\n  int board[N*N];\n  int space;\n} puzzle;\n\nint solve(puzzle);\n\npuzzle queue[QUEUE_MAX];\nint q_top = 0;\nint q_tail = 0;\n\npuzzle q_pop() {\n  puzzle result = queue[q_top];\n  q_top++;\n  q_top %= QUEUE_MAX;\n\n  return result;\n}\n\nvoid q_push(puzzle p) {\n  queue[q_tail] = p;\n  q_tail++;\n  q_tail %= QUEUE_MAX;\n}\n\nint q_size(){\n  if(q_tail >= q_top){\n    return q_tail - q_top;\n  }\n  else {\n    return q_tail + QUEUE_MAX - q_top;\n  }\n}\n\nstruct node {\n  struct node* nodes[N*N + 1];\n};\n\ntypedef struct node * NodePointer;\n\nNodePointer makeNode() {\n  NodePointer node;\n\n  node = malloc(sizeof(struct node));\n\n  for(int i = 0; i < N*N + 1; i++){\n    node->nodes[i] = NULL;\n  }\n\n  return node;\n}\n\nNodePointer memTree;\n\nint exists(puzzle *p){\n  NodePointer current = memTree;\n  \n  for(int i = 0; i < N*N; i++){\n    // printf(\"%d, \", p->board[i]);\n    if(current->nodes[p->board[i]] == NULL){\n      //printf(\"DEPTH = %d NOT FOUND\\n\", i);\n      return FALSE;\n    }\n\n    current = current->nodes[p->board[i]];\n  }\n  \n  //printf(\"FOUND!!\\n\");\n  return TRUE;\n}\n\nvoid addToMem(puzzle *p){\n  NodePointer current = memTree;\n  \n  for(int i = 0; i < N*N; i++){\n    //printf(\"DEPTH = %d ADDING\\n\", i);\n    if(current->nodes[p->board[i]] == NULL){\n      current->nodes[p->board[i]] = makeNode();\n    }\n\n    current = current->nodes[p->board[i]];\n  }\n}\n  \n\nint main() {\n  puzzle input;\n  for(int i = 0; i < N*N ; i++){\n    scanf(\"%d\", &(input.board[i]));\n    if(input.board[i] == 0) {\n      input.board[i] = SPACE;\n      input.space = i;\n    }\n      \n    //    printf(\"%d \", input.board[i]);\n  }\n\n  memTree = makeNode();\n\n  input.steps = 0;\n\n  //debug\n  //addToMem(&input);\n  //exists(&input);\n  \n  printf(\"%d\\n\", solve(input));\n\n  \n  return 0;\n}\n\nint gameClear(puzzle* p){\n  for(int i = 0; i < N*N ; i++){\n    if(p->board[i] != i + 1){\n      return FALSE;\n    }\n  }\n\n  return TRUE;\n}\n\n//solve by BFS\nint solve(puzzle s) {\n  int result = 0;\n\n  int dx[4] = {0,1,0,-1};\n  int dy[4] = {-1,0,1,0};\n  char dir[4][6] = {\"up\", \"right\", \"down\", \"left\"};\n  //printf(\"steps %d\\n\", s.steps);\n\n  q_push(s);\n  addToMem(&s);\n\n  while(q_size() > 0){\n    puzzle u = q_pop();\n    //printf(\"steps %d\\n\", u.steps);\n\n    if(gameClear(&u)){\n      result = u.steps;\n      break;\n    }\n    int col = u.space / N;\n    int row = u.space % N;\n    //printf(\"space (%d, %d)\\n\", col, row);\n    \n    for(int i = 0; i < 4; i++){\n      int tc = col + dy[i];\n      int tr = row + dx[i];\n\n      if(tc < 0 || tr < 0 || tc >= N || tr >= N){\n\tcontinue;\n      }\n\n      //printf(\"try to %s\\n\", dir[i]);\n      puzzle v = u;\n      int tmp = v.board[tc*N + tr];\n      v.board[tc*N + tr] = v.board[u.space];\n      v.board[u.space] = tmp;\n\n      if(!exists(&v)){\n\tv.space = tc*N + tr;\n\tv.steps = u.steps + 1;\n\tq_push(v);\n\taddToMem(&v);\n      }\n    }\n  }\n  return result;\n}\n  \n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\ntypedef char Board[10];\nBoard ini_board, board;\nconst Board target = \"123456780\";\nBoard *history;\nint nhistories=0;\ntypedef enum { U, D, L, R } Direction;\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\nint minstep = INT_MAX;\nconst Motion candidate[9][5] = \n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\nint move(Motion m)\n{\n  if (m.pos==0 && board[0]=='1') return -1;\n  if ((m.pos==1||m.pos==2) && board[0]=='1'&&board[1]=='2'&&board[2]=='3') return -1;\n  \n  switch (m.dir) {\n  case U:\n    if (m.pos<3) return -1;\n    board[m.pos-3] = board[m.pos];\n    break;\n  case D:\n    if (m.pos>5) return -1;\n    board[m.pos+3] = board[m.pos];\n    break;\n  case L:\n    if (m.pos%3==0) return -1;\n    board[m.pos-1] = board[m.pos];\n    break;\n  case R:\n    if (m.pos%3==2) return -1;\n    board[m.pos+1] = board[m.pos];\n    break;\n  }\n  board[m.pos] = '0';\n  return m.pos;\n}\n\nvoid search_path(int step, int space)\n{\n  int i, j, s2;\n  if (strcmp(board, \"123456780\")==0) {\n    \n    if (step==1) {\n      printf(\"1\\n\");\n      exit(0);\n    }\n    if (step<minstep) minstep=step;\n  } else {\n    if (step>=minstep) return; \n    if (step>0 && strcmp(board, ini_board)==0) return; \n    \n    Board board_bak;\n    strcpy(board_bak, board);\n    int nhistories_bak=nhistories;\n    \n    for (i=0; candidate[space][i].pos>=0; i++) {\n      if ((s2 = move(candidate[space][i]))<0) continue;\n      for (j=0; j<nhistories; j++) {\n\tif (strcmp(board, history[j])==0) \n\t  break;\n      }\n      if (j==nhistories) {\n\tstrcpy(history[nhistories++], board); \n\tsearch_path(step+1, s2);\n      }\n      nhistories = nhistories_bak;\n      strcpy(board, board_bak);\n    }\n  }\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board[0],&board[1],&board[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[3],&board[4],&board[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[6],&board[7],&board[8]);\n  strcpy(ini_board, board);\n  history = (Board*)malloc(sizeof(Board)*100000);\n  search_path(0, strchr(board, '0')-board);\n  printf(\"%d\\n\", minstep);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \nint mas[3][3];\nint cpy[3][3];\n \nvoid input() {\n  int i, j;\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++)\n      scanf(\"%d\", &mas[i][j]);\n}\n \nvoid output() {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n    puts(\"\");\n  }\n}\n \nvoid copy(int m[3][3], int t[3][3]) {\n  int i, j;\n \n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n \nint calc() {\n  int i, sum = 0;\n  for(i = 0; i < 9; i++) {\n    int v = mas[i/3][i%3];\n    if(v) {\n      v--;\n      sum += abs(i/3-v/3)+abs(i%3-v%3);\n    }\n  }\n  return sum;\n}\n \nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n \nvoid swap(int *a, int *b) {\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n \nint is_in(int x, int y) {\n  return 0<=x&&x<3&&0<=y&&y<3;\n}\n \nint dfs(int x, int y, int p, int dep, const int lim) {\n  int i, h = calc();\n  //output();\n  if(h == 0) return dep;\n  //printf(\"%d %d %d\\n\", h, lim, p);\n  if(dep+h > lim) return -1;\n \n  for(i = 0; i < 4; i++) {\n    int nx = x+dx[i], ny = y+dy[i], res;\n    if(~p && i == (p+2)%4) continue;\n    if(!is_in(nx, ny)) continue;\n    swap(&mas[y][x], &mas[ny][nx]);\n    res = dfs(nx, ny, i, dep+1, lim);\n    if(~res) return res;\n    swap(&mas[y][x], &mas[ny][nx]);\n  }\n \n  return -1;\n}\n \nvoid get_empty(int *x, int *y) {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) {\n      if(!mas[i][j]) {\n    *x = j;\n    *y = i;\n    return;\n      }\n    }\n  }\n}\n \nint solve() {\n  int x, y, lim, ans;\n  get_empty(&x, &y);\n  for(lim = 0; lim < 50; lim++) {\n    copy(cpy, mas);\n    if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n    copy(mas, cpy);\n  }\n  return -1;\n}\n \nint main() {\n  input();\n  printf(\"%d\\n\", solve());\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\n#include<map>\nusing namespace std;\nint str[5][5];\nstruct edge\n{\n    int x,y,n;\n    int s[5][5];\n};\nvoid bfs(int x,int y)\n{\n    int i,j,k=0,next[4][2]={0,1,1,0,0,-1,-1,0};    //四个方向\n    long long l=0;                                  //初始化为0\n    queue<edge>Q;\n    map<int,int>book;                               //使用map容器可以放置很大的数\n    while(!Q.empty())\n        Q.pop();\n    edge q,now;\n    for(i=0;i<3;i++)\n    {\n        for(j=0;j<3;j++)\n        {\n            l=l*10+str[i][j];\n            q.s[i][j]=str[i][j];                    //计算l的值 并将当前元素存入q.s[i][j]\n        }  \n    }\n    if(l==123456780){printf(\"0\\n\");return;}\n    book[l]=1;\n    q.x=x;                                           //记录0的横纵坐标\n    q.y=y;\n    q.n=0;\n    Q.push(q);                                       //放入对尾\n    while(!Q.empty())\n    {\n        now=Q.front();\n        Q.pop();\n        for(i=0;i<4;i++)\n        {\n            int xx=now.x+next[i][0];                   //开始四个方向便利\n            int yy=now.y+next[i][1];\n            if(xx<0||yy<0||xx>=3||yy>=3)continue;\n            q.x=xx;\n            q.y=yy;\n            q.n=now.n+1;\n            for(k=0;k<3;k++)                           //步数加一\n            {\n                for(j=0;j<3;j++)\n                {\n                    q.s[k][j]=now.s[k][j];               //将此时元素的状态存入q.s[][]中\n                }\n            }\n            k=q.s[now.x][now.y];\n            q.s[now.x][now.y]=q.s[xx][yy];\n            q.s[xx][yy]=k;                               //将此时0的位置放入q.[now.x][now,y]\n            l=0;\n            for(k=0;k<3;k++)\n            {\n                for(j=0;j<3;j++)\n                {\n                    l=l*10+q.s[k][j];\n                }\n            }\n            if(l==123456780){printf(\"%d\\n\",q.n);return;}\n            if(book[l]==0)\n            {\n                book[l]=1;\n                Q.push(q);                             //如果没被标记 将其放入队列尾\n            }       \n        }\n    }\n}\nint main()\n{\n    int i,j,a,ex,ey;\n    for(i=0;i<3;i++)\n    {\n        for(j=0;j<3;j++)\n        {\n            scanf(\"%d\",&a);\n            str[i][j]=a;\n            if(a==0)\n            {\n                ex=i;\n                ey=j;\n            }\n        }\n    }\n    bfs(ex,ey);\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nint pz[3][3],tmp[3][3];\nint dx[4] = {0,1,0,-1},dy[4] = {1,0,-1,0};\nvoid emp(int *x,int *y) {\n  int i,j;\n  for(i=0; i<3; i++) {\n    for(j=0; j<3; j++) {\n      if(!pz[i][j]) {\n    *x = j;\n    *y = i;\n      }\n    }\n  }\n}\nvoid swap(int *s,int *v){\n  int tmp;\n  tmp = *s;\n  *s = *v;\n  *v = tmp;\n}   \nint calc(){\n  int i,a,sum=0; \n  for(i=0; i<9; i++){\n    a = pz[i/3][i%3];\n    if(a){\n      a--;\n      sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n    }\n  }    \n  return sum;\n}\nint dfs(int x,int y,int p,int d,const int lim){\n    int i,h,x2,y2,res;   \n    h = calc();\n    if(h==0) {\n        return d;\n    }\n    if(d+h>lim) {\n        return -1;\n    }\n    for(i=0; i<4; i++){\n        x2 = x+dx[i];\n        y2 = y+dy[i];      \n        if(~p && i==(p+2)%4) continue;\n        if(!(0<=x2 && x2<3 && 0<=y2 && y2<3)) continue;    \n        swap(&pz[y][x],&pz[y2][x2]);\n        res = dfs(x2,y2,i,d+1,lim);\n        if(~res) {\n            return res;\n        }\n        swap(&pz[y][x],&pz[y2][x2]);\n    }   \n    return -1;\n}    \nint main() {\n    int i,j,l,ans,x,y;\n       \n    for(i=0; i<3; i++){\n        for(j=0; j<3; j++) scanf(\"%d\",&pz[i][j]);\n    }\n        \n    emp(&x,&y);\n    for(l=0; l<100; l++){\n        for(i=0; i<3; i++){\n            for(j=0; j<3; j++) tmp[i][j] = pz[i][j];\n        }\n           \n        ans = dfs(x,y,-1,0,l);\n        if(ans!=-1){\n            printf(\"%d\\n\",ans);\n            break;\n        }\n           \n        for(i=0; i<3; i++){\n            for(j=0; j<3; j++) pz[i][j] = tmp[i][j];\n        }\n           \n        ans = -1;\n        if(l==99) printf(\"%d\\n\",ans);\n    }\n       \n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define T 1\n#define F 0\n#define N 3\n\nint dx[4] = { 0,-1,0,1 };\nint dy[4] = { 1,0,-1,0 };\nint lim;\nint p[N][N];\n\nint huristic() {\n\tint i, j, n, sum = 0;\n\tfor (i = 0; i < N; i++) {\n\t\tfor (j = 0; j < N; j++) {\n\t\t\tif (p[i][j] == 0)continue;\n\t\t\tn = p[i][j] - 1;\n\t\t\tsum += abs(n / N - i) + abs(n % N - j);\n\t\t}\n\t}\n\treturn sum;\n}\n\nint dfs(int d, int pre, int y, int x) {\n\tint h = huristic();\n\tint i;\n\tif (h == 0)return T;\n\tif (lim < d + h) return F;\n\t\n\tfor (i = 0; i < 4; i++) {\n\t\tif (abs(i - pre) == 2) continue;\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)continue;\n\t\tint tmp = p[ty][tx];\n\t\tp[ty][tx] = p[y][x];\n\t\tp[y][x] = tmp;\n\n\t\tif (dfs(d + 1, i, ty, tx))return T;\n\t\ttmp = p[ty][tx];\n\t\tp[ty][tx] = p[y][x];\n\t\tp[y][x] = tmp;\n\t}\n\treturn F;\n}\n\nvoid PZL(int x, int y) {\n\tfor (lim = 0;; lim++) {\n\t\tif (dfs(0, 99, y, x)) {\n\t\t\tprintf(\"%d\\n\", lim);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main() {\n\tint i,j;\n\tint x, y;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tfor (j = 0; j < 3; j++) {\n\t\t\tscanf(\"%d\", &p[i][j]);\n\t\t\tif (p[i][j] == 0) {\n\t\t\t\ty = i;x = j;\n\t\t\t}\n\t\t}\n\t}\n\tPZL(x, y);\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define N 3\n#define N1 4\n#define N2 9\n#define N3 100\nint puz[N][N];\nint tmp[N][N];\nint dx[N1]={0,1,0,-1};\nint dy[N1]={1,0,-1,0};\nvoid empty(int x[],int y[]) {\n  int i,j;\n  for(i=0;i<N;i++) {\n    for(j=0;j<N;j++) {\n      if(!puz[i][j]) {\n        *x = j;\n        *y = i;\n        return;\n      }\n    }\n  }\n}\nvoid swap(int a[],int b[]){\n  int tmp;\n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\nint cal(){\n  int i,a,sum=0;\n  for(i=0; i<N2; i++){\n    a = puz[i/N][i%N];\n    if(a){\n      a--;\n      sum+=abs((i/N)-(a/N))+abs((i%N)-(a%N));\n    }\n  }\n  return sum;\n  }\nint dfs(int x,int y,int p,int dep,const int lim){\n  int i,h,nx,ny,res;\n  h=cal();\n  if(h==0) return dep;\n  if(dep+h>lim) return -1;\n  for(i=0;i<N1;i++){\n    nx=x+dx[i];\n    ny=y+dy[i];\n    if(~p && i==(p+2)%N2) continue;\n    if(!(0<=nx && nx<N && 0<=ny && ny<N)) continue;\n    swap(&puz[y][x],&puz[ny][nx]);\n    res = dfs(nx,ny,i,dep+1,lim);\n    if(~res) return res;\n    swap(&puz[y][x],&puz[ny][nx]);\n  }\n  return -1;\n}\nint main() {\n  int i,j,ans,x,y,l;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++) scanf(\"%d\",&puz[i][j]);\n  }\n  empty(&x,&y);\n  for(l=0;l<N3;l++){\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++) tmp[i][j] = puz[i][j];\n    }\n    ans=dfs(x,y,-1,0,l);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++) puz[i][j] = tmp[i][j];\n    }\n     ans = -1;\n    if(l==N3-1) printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX 3\n\nint pane[MAX][MAX];\nint temp[MAX][MAX];\nint d_x[4]={0,1,0,-1};\nint d_y[4]={1,0,-1,0};\n\n\nvoid empty(int *,int *);\nvoid swap(int *,int *);\nint cal();\nint dfs(int ,int ,int ,int ,const int );\n\nint main() {\n  int i,j;\n  int h,ans,row,col;\n      \n  for(i=0; i<MAX; i++){\n    for(j=0; j<MAX; j++)\n      scanf(\"%d\",&pane[i][j]);\n  }  \n  empty(&row,&col);  \n  for(h=0; h<100; h++){\n    for(i=0; i<MAX; i++){\n      for(j=0; j<MAX; j++)\n\ttemp[i][j] = pane[i][j];\n    }    \n    ans = dfs(row,col,-1,0,h);    \n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }    \n    for(i=0; i<MAX; i++){\n      for(j=0; j<MAX; j++)\n\tpane[i][j] = temp[i][j];\n    }    \n    ans = -1;\n    if(h==99) printf(\"%d\\n\\n\",ans);\n  }      \n  return 0;\n}\n\nvoid empty(int *row,int *col){\n  int i,j;\n  for(i=0; i<MAX; i++)\n    for(j=0; j<MAX; j++)\n      if(!pane[i][j]){\n\t*row = j;\n\t*col = i;\n\treturn;\n      }  \n}\n   \nvoid swap(int *a,int *b){\n  int temp;\n  \n  temp = *a;*a = *b;*b = temp;\n}\n  \nint cal(){\n  int i,e;\n  int count=0; \n  for(i=0; i<9; i++){\n    e = pane[i/3][i%3];\n    if(e){\n      e--;\n      count += abs(i/3 - e/3) + abs(i%3 - e%3);\n    }\n  }   \n  return count;\n}\n  \nint dfs(int x,int y,int p,int deep,const int limt){\n  int i, len, x_2, y_2, emc;\n  \n  len = cal();\n  if(len==0) return deep;\n  if(deep+len > limt) return -1; \n  for(i=0; i<4; i++){\n    x_2 = x+d_x[i];\n    y_2 = y+d_y[i];      \n    if(~p && i==(p+2)%4) continue;\n    if(!(0<=x_2 && x_2<3 && 0<=y_2 && y_2<3)) continue;    \n    swap(&pane[y][x],&pane[y_2][x_2]);\n    emc = dfs(x_2,y_2,i,deep+1,limt);\n    if(~emc) return emc;       \n    swap(&pane[y][x],&pane[y_2][x_2]);\n  }   \n  return -1;\n} \n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<string>\nusing namespace std;\nint c[4][2]={1,0,0,1,-1,0,0,-1};\nint puzzle[10];\n\nmap<string,int> book;\nstruct yun\n{\n    int s;\n    int state[9];\n};\n\nint bfs()\n{\n    int i,j,k,l;\n    yun st,en;\n    queue<yun> Q;\n    st.s=0;\n    for(i=0;i<9;i++)\n        st.state[i]=puzzle[i];\n    Q.push(st);\n    while(Q.size())\n    {\n        st=Q.front();\n        Q.pop();\n        for(k=0;k<9;k++)\n            if(!st.state[k])break;\n        int x=k/3,y=k%3;\n        for(j=0;j<4;j++)\n        {\n            int dx=x+c[j][0];\n            int dy=y+c[j][1];\n            int dz=dx*3+dy;\n            if(dx<0||dy<0||dx>=3||dy>=3)continue;\n            string ss=\"\";\n            for(l=0;l<9;l++)\n                en.state[l]=st.state[l];\n            en.state[k]=en.state[dz];\n            en.state[dz]=0;\n            int f=0;\n            for(l=0;l<8;l++)\n            {\n                ss+=en.state[l]+'0';\n                if(en.state[l]!=l+1)\n                    f=1;\n            }\n          //  cout<<ss<<endl;\n            if(!f)return st.s+1;\n            if(book[ss])continue;\n            book[ss]=1;\n            en.s=st.s+1;\n            Q.push(en);\n        }\n    }\n}\n\nint main()\n{\n    int i;\n    for(i=0;i<9;i++)\n        scanf(\"%d\",&puzzle[i]);\n    int g=0;\n    for(i=0;i<8;i++)\n    {\n        if(puzzle[i]!=i+1)\n            g=1;\n    }\n    int max1;\n    if(!g)\n        max1=0;\n    else max1=bfs();\n    printf(\"%d\\n\",max1);\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef unsigned char uchar;\n\n#define HASHSIZ 543217\ntypedef struct { unsigned s; char x, v; } HASH;\nHASH hash[HASHSIZ+3], *hashend = hash+HASHSIZ;\n\nint lookup(unsigned s, int x)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) return hp->v;\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\treturn 0;\n}\n\nvoid insert(unsigned s, int x, char v)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) { hp->v = v; break; }\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\thp->s = s, hp->x = x, hp->v = v;\n}\n\n#define QMAX 50000\ntypedef struct { unsigned s; char x, v; } T;\nT s[QMAX+3]; int top, end;\nint hi[9] = {2,3,2,3,4,3,2,3,2};\nint to[9][4] = {{1,3},{0,2,4},{1,5},{0,4,6},{1,3,5,7},{2,4,8},{3,7},{4,6,8},{5,7}};\n\nvoid toArray(char *nine, unsigned s, int x)\n{\n\tint i;\n\t\n\tfor (i = 8; i >= 0; i--) {\n\t\tif (i == x) nine[i] = 0;\n\t\telse nine[i] = s & 0xf, s >>= 4;\n\t}\n}\n\nunsigned swap(char *nine, int zero, int nx)\n{\n\tint i;\n\tunsigned res;\n\t\n\tres = 0;\n\tfor (i = 0; i < 9; i++) {\n\t\tif      (i == zero) res <<= 4, res |= nine[nx];\n\t\telse if (i != nx)   res <<= 4, res |= nine[i];\n\t}\n\treturn res;\n}\n\n#define MAGIC 20\n\nint main()\n{\n\tint i, x, nx, v, nv, t;\n\tunsigned a, na;\n\tunsigned gs; int gx;\t// goal\n\tchar nine[9];\n\t\n\tgs = 0; for (i = 0; i < 9; i++) {\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 0) gx = i;\n\t\telse gs <<= 4, gs |= t;\n\t}\n\ts[0].s = 0x12345678, s[0].x = 8;\n\ts[1].x = -1;\n\ttop = 0, end = 2;\n\tinsert(s[0].s, s[0].x, 0);\n\tv = 0;\n\twhile (top != end) {\n\t\ta = s[top].s, x = s[top].x;\n\t\tif (++top == QMAX) top = 0; \n\t\tif (x < 0) {\n\t\t\tif (v == MAGIC) break;\n\t\t\tv++;\n\t\t\ts[end].x = -1; if (++end == QMAX) end = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (x == gx && a == gs) goto done;\n\t\tif (lookup(a, x) < v) continue;\n\n\t\ttoArray(nine, a, x);\n\t\tfor (i = 0; i < hi[x]; i++) {\n\t\t\tnx = to[x][i];\n\t\t\tna = swap(nine, x, nx), nv = v+1;\n\t\t\tt = lookup(na, nx);\n\t\t\tif (!t || nv < t) {\n\t\t\t\ts[end].s = na, s[end].x = nx;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t\tinsert(na, nx, nv);\n\t\t\t}\n\t\t}\n\t}\n\n\ts[0].s = gs, s[0].x = gx, s[1].x = -1;\n\ttop = 0, end = 2;\n\tv = 0;\n\twhile (top != end) {\n\t\ta = s[top].s, x = s[top].x;\n\t\tif (++top == QMAX) top = 0; \n\t\tif (x < 0) {\n\t\t\tv++;\n\t\t\ts[end].x = -1; if (++end == QMAX) end = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((t = lookup(a, x)) > 0) { v += t; break; }\n\n\t\ttoArray(nine, a, x);\n\t\tfor (i = 0; i < hi[x]; i++) {\n\t\t\tnx = to[x][i];\n\t\t\tna = swap(nine, x, nx), nv = v+1;\n\t\t\tt = lookup(na, nx);\n\t\t\tif (!t || nv < t) {\n\t\t\t\ts[end].s = na, s[end].x = nx;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tprintf(\"%d\\n\", v);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define N 3\n\nint puzz[N][N];\nint dy[4]={1,0,-1,0};\nint dx[4]={0,1,0,-1};\n\nint huri(){\n\n  int x,y ,i,j,sum=0;\n\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      if(puzz[i][j] == 0)continue;\n\n      x=(puzz[i][j]-1)%N-j;\n      y=(puzz[i][j]-1)/N-i;\n      x=abs(x);\n      y=abs(y);\n      \n      sum+=x;\n      sum+=y;\n    }\n  }\n  return sum;\n}\n\nint DFS(int iof0,int jof0,int lim,int dpt){\n\n  int i,j,h,x,y,tmp,ans=-1;\n\n  h = huri();\n  if(h == 0) return dpt;\n  if(h+dpt > lim) return -1;\n\n  for(i=0;i<4;i++){\n    x = iof0 + dx[i];\n    y = jof0 + dy[i];\n\n    if(x >= N || x < 0) continue;\n    if(y >= N || y < 0) continue;\n\n    tmp = puzz[x][y];\n    puzz[x][y] = puzz[iof0][jof0];\n    puzz[iof0][jof0] = tmp;\n\n    ans = DFS(x,y,lim,dpt+1);\n\n    if(ans != -1) return ans;\n    tmp = puzz[x][y];\n    puzz[x][y] = puzz[iof0][jof0];\n    puzz[iof0][jof0] = tmp;\n  }\n  return -1;\n}\n\nint main(){\n\n  int i,j,iof0,jof0,ans;\n\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&puzz[i][j]);\n      if(puzz[i][j] == 0){\n\tiof0 = i;\n\tjof0 = j;\n      }\n    }\n  }\n\n  for(i=1;i<101;i++){\n    ans = DFS(iof0,jof0,i,0);\n    if(ans != -1) {\n      printf(\"%d\\n\",ans);\n      break;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n\nextern inline void down_0(void);\nextern inline void up_0(void);\nextern inline void right_0(void);\nextern inline void left_0(void);\n\nextern int  serch(int x, int y, int MaxCnt, int pre);\nextern int  check(void);\n\nint cnt,num = 0;\nint val[Total] ={};\n\n\nint main( void )\n{\n    int i = 0;\n    int x,y = 0;\n    \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        \n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n    \n    x = tate - (num/yoko) -1;\n    y = yoko - (num%yoko) -1;\n    \n//    printf(\"%d,%d\\n\",x,y);\n    \n    for(i=0; i<45; i++)\n    {\n        if( serch(x,y,i,4) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt, int pre)\n{\n    int result;\n    int i=0;\n    \n    // 最大数で打ち切り\n    if(MaxCnt==0)\n    {\n        return check();\n    }\n    \n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if( (x > 0) && (pre != 3) )\n                {\n                    down_0();\n                    \n                    result = serch(x-1, y, MaxCnt-1, 0);\n                    \n                    up_0();\n                }\n                break;\n            case 1:\n                if( (y > 0) && (pre != 2) )\n                {\n                    right_0();\n                    \n                    result = serch(x, y-1, MaxCnt-1, 1);\n                    \n                    left_0();\n                }\n                break;\n            case 2:\n                if( (y < yoko -1 ) && (pre != 1) )\n                {\n                    left_0();\n                    \n                    result = serch(x, y+1, MaxCnt-1, 2);\n                    \n                    right_0();\n                }\n                break;\n            case 3:\n                if( (x < tate -1 ) && (pre != 0) )\n                {\n                    up_0();\n                    \n                    result = serch(x+1, y, MaxCnt-1, 3);\n                    \n                    down_0();\n                }\n                break;\n            default:\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n        \n    }\n\n    return 0;\n}\n\n// TRUE : 完成\n// FALSE : 失敗\nint check()\n{\n    int i=0;\n    \n//    printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);\n    \n    for(i=0; i<Total-1; i++)\n    {\n        if(val[i] != (i+1))\n        {\n            return 0;\n        }\n    }\n    return 1;\n}\n\ninline void down_0()\n{\n    val[num] = val[num + yoko];\n    num = num + yoko;\n}\n \ninline void up_0()\n{\n    val[num] = val[num - yoko];\n    num = num - yoko;\n}\n \ninline void right_0()\n{\n    val[num] = val[num +1];\n    num = num + 1;\n}\n \ninline void left_0()\n{\n    val[num] = val[num -1];\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n\ntypedef struct node{\n  char s[10];\n  int t;\n  int x;\n  struct node *next;\n  struct node *back;\n}Node;\n\nchar *move_up(char s[], int x) {\n  if(x < 3) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-3];\n  s_new[x-3] = s[x];\n  return s_new;\n}\n\nchar *move_left(char s[], int x) {\n  if(x%3 == 0) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-1];\n  s_new[x-1] = s[x];\n  return s_new;\n}\n\nchar *move_right(char s[], int x) {\n  if(x%3 == 2) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+1];\n  s_new[x+1] = s[x];\n  return s_new;\n}\n\nchar *move_down(char s[], int x) {\n  if(x > 5) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+3];\n  s_new[x+3] = s[x];\n  return s_new;\n}\n\nint create(Node *root, char s[], int t) {\n  if(strcmp(s,\"123456780\") == 0) return t;\n  Node *p = (Node*)malloc(sizeof(Node));\n  strcpy(p->s,s);\n  p->t = t;\n  int i;\n  for(i = 0; i < 9; i++) {\n    if(s[i] == '0') {\n      p->x = i;\n      break;\n    }\n  }\n  root->back->next = p;\n  p->back = root->back;\n  p->next = root;\n  root->back = p;\n  return -1;\n}\n\nint distance(char *s_new) {\n  char s[] = \"123456780\";\n  int i;\n  int sum = 0;\n  for(i = 0; i < 9; i++) {\n    int a = 0;\n    int b = 0;\n    while(s[a]-'0' != i) a++;\n    while(s_new[b]-'0' != i) b++;\n    sum += abs(a/3-b/3) + abs(a%3-b%3);\n  }\n  return sum;\n}\n\nint cal(Node *root) {\n  Node *p = root->next;\n  char *s_right,*s_left,*s_up,*s_down;\n  int right,left,up,down,min;\n  int k;\n  if((s_right = move_right(p->s, p->x)) != NULL) {\n    right = distance(s_right);\n  }else{\n    right = INT_MAX;\n  }\n  if((s_left = move_left(p->s, p->x)) != NULL) {\n    left = distance(s_left);\n  }else{\n    left = INT_MAX;\n  }\n  if ((s_up = move_up(p->s, p->x)) != NULL) {\n    up = distance(s_up);\n  }else{\n    up = INT_MAX;\n  }\n  if((s_down = move_down(p->s, p->x)) != NULL) {\n    down = distance(s_down);\n  }else{\n    down = INT_MAX;\n  }\n\n  min = right;\n  if(min > left) min = left;  \n  if(min > up) min = up;  \n  if(min > down) min = down;\n\n  if(right == min) {\n    if((k = create(root,s_right,p->t+1)) != -1) return k;\n  }\n  if(left == min) {\n    if((k = create(root,s_left,p->t+1)) != -1) return k;\n  }\n  if(up == min) {\n    if((k = create(root,s_up,p->t+1)) != -1) return k;\n  }\n  if(down == min) {\n    if((k = create(root,s_down,p->t+1)) != -1) return k;\n  }\n\n  if(s_right != NULL) free(s_right);\n  if(s_left != NULL) free(s_left);\n  if(s_up != NULL) free(s_up);\n  if(s_down != NULL) free(s_down);\n  p->next->back = root;\n  root->next = p->next;\n  free(p);\n  return -1;\n}\n  \n\nint solve(char s0[]) {\n  int t;\n  Node root;\n  root.next = &root;\n  root.back = &root;\n  if((t = create(&root,s0,0)) != -1) return t;\n  \n  while(1) {\n    if((t = cal(&root)) != -1) break;\n  }\n  return t;\n}\n\nint main()\n{\n  int i,d;\n  char s[10];\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &d);\n    s[i] = d+'0';\n  }\n  s[9] = '\\0';\n  printf(\"%d\\n\",solve(s));\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n\nextern inline void down_0(void);\nextern inline void up_0(void);\nextern inline void right_0(void);\nextern inline void left_0(void);\n\nextern int  serch(int x, int y, int MaxCnt);\nextern int  check(void);\n\nint cnt,num = 0;\nint val[Total] ={};\n\n\nint main( void )\n{\n    int i = 0;\n    int x,y = 0;\n    \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        \n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n    \n    x = tate - (num/yoko) -1;\n    y = yoko - (num%yoko) -1;\n    \n    for(i=1; i<20; i++)\n    {\n        if( serch(x,y,i) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt)\n{\n    int result;\n    int i=0;\n    \n    // 最大数で打ち切り\n    if(MaxCnt==0)\n    {\n        return check();\n    }\n    \n    // 上下左右で4回回す\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if(x > 0)\n                {\n                    down_0();\n                    \n                    result = serch(x-1, y, MaxCnt-1);\n                    \n                    up_0();\n                }\n                break;\n            case 1:\n                if(y > 0)\n                {\n                    right_0();\n                    \n                    result = serch(x, y-1, MaxCnt-1);\n                    \n                    left_0();\n                }\n                break;\n            case 2:\n                if(y < yoko)\n                {\n                    left_0();\n                    \n                    result = serch(x, y+1, MaxCnt-1);\n                    \n                    right_0();\n                }\n                break;\n            case 3:\n                if(x < tate)\n                {\n                    up_0();\n                    \n                    result = serch(x+1, y, MaxCnt-1);\n                    \n                    down_0();\n                }\n                break;\n            default:\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n        \n    }\n\n    return 0;\n}\n\n// TRUE : 完成\n// FALSE : 失敗\nint check()\n{\n    int i=0;\n    \n//    printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);\n    \n    for(i=0; i<Total-1; i++)\n    {\n        if(val[i] != (i+1))\n        {\n            return 0;\n        }\n    }\n    return 1;\n}\n\ninline void down_0()\n{\n    val[num] = val[num + yoko];\n    num = num + yoko;\n}\n \ninline void up_0()\n{\n    val[num] = val[num - yoko];\n    num = num - yoko;\n}\n \ninline void right_0()\n{\n    val[num] = val[num +1];\n    num = num + 1;\n}\n \ninline void left_0()\n{\n    val[num] = val[num -1];\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct { char a[10]; } Board;\n\nBoard  board, *history;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nMotion motion[9][5] = {\n   {{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}} };\n\nint minstep = 31;\n\nvoid search(int step, int space, int nhistories)\n{\n  int i, j;\n  if (strncmp(board.a, \"123456780\", 8)==0) {\n    if (step==1 || step==31) {\n      printf(\"%d\\n\", step);\n      exit(0);\n    }\n    if (step<minstep) minstep=step;\n  } else {\n    if (step>=minstep) return;\n    for (j=0; j<nhistories; j++) {\n      if (strcmp(board.a, history[j].a)==0) return;\n    }\n    history[nhistories++] = board; \n    for (i=0; motion[space][i].pos>=0; i++) {\n      Motion *m = &motion[space][i];\n      \n      if (m->pos==0 && board.a[0]=='1') continue;\n      if ((m->pos==1||m->pos==2) && board.a[0]=='1'&&board.a[1]=='2'&&board.a[2]=='3') continue;\n      if ((m->dir==U&&m->pos<3)||(m->dir==D&&m->pos>5)||(m->dir==L&&m->pos%3==0) || (m->dir==R && m->pos%3==2)) continue;\n\n      board.a[space] = board.a[m->pos];\n      search(step+1, m->pos, nhistories);\n      board = history[nhistories-1];\n    }\n  }\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board.a[0],&board.a[1],&board.a[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board.a[3],&board.a[4],&board.a[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board.a[6],&board.a[7],&board.a[8]);\n  history = (Board*)malloc(sizeof(Board)*31);\n  search(0, strchr(board.a, '0')-board.a, 0);\n  printf(\"%d\\n\", minstep);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\nchar *flag;\nint head,rear;\nint *que;\nint factorial[10];\n\nint cal_factorial(int n) {\n  if(n == 0) return 1;\n  return cal_factorial(n-1)*n;\n}\n\nint stotag(char *s) {\n  int tag = 0;\n  int i;\n  for(i = 0; i < 9; i++) {\n    int t,j;\n    t = 0;\n    for(j = 0; j < i; j++) {\n      if(s[j] < s[i]) t++;\n    }\n    tag += factorial[8-i]*(s[i]-'0'-t);\n  }\n  return tag;\n}\n\nchar *tagtos(int tag) {\n  int i;\n  char *s;\n  s = (char*)malloc(sizeof(char)*10);\n  for(i = 0; i < 9; i++) {\n    s[i] = tag%factorial[9-i]/factorial[8-i] + '0';\n  }\n  s[9] = '\\0';\n  for(i = 7; i >= 0; i--) {\n    int j;\n    for(j = 8; j > i; j--) {\n      if(s[i] <= s[j]) s[j]++;\n    }\n  }\n  return s;\n}\n\n\nchar *move_up(char s[], int x) {\n  if(x < 3) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-3];\n  s_new[x-3] = s[x];\n  return s_new;\n}\n\nchar *move_left(char s[], int x) {\n  if(x%3 == 0) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-1];\n  s_new[x-1] = s[x];\n  return s_new;\n}\n\nchar *move_right(char s[], int x) {\n  if(x%3 == 2) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+1];\n  s_new[x+1] = s[x];\n  return s_new;\n}\n\nchar *move_down(char s[], int x) {\n  if(x > 5) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+3];\n  s_new[x+3] = s[x];\n  return s_new;\n}\n\nint create(char s[], int t) {\n  if(strcmp(s,\"123456780\") == 0) return t;\n  int tag = stotag(s);\n  if(flag[tag]) return 0;\n  flag[tag] = t;\n  que[rear] = tag;\n  rear++;\n  return 0;\n}\n\nint check_x(char *s) {\n  int i = 0;\n  while(s[i] != '0') i++;\n  return i;\n}\n\nint cal() {\n  char *s_right,*s_left,*s_up,*s_down;\n  int k,tag;\n\n  tag = que[head];\n  char *s = tagtos(tag);\n  int x = check_x(s);\n  \n  if((s_right = move_right(s, x)) != NULL) {\n    if((k = create(s_right,flag[tag]+1))) return k;\n    free(s_right);\n  }\n  if((s_left = move_left(s, x)) != NULL) {\n     if((k = create(s_left,flag[tag]+1))) return k;\n     free(s_left);\n  }\n  if ((s_up = move_up(s, x)) != NULL) {\n    if((k = create(s_up,flag[tag]+1))) return k;\n    free(s_up);\n  }\n  if((s_down = move_down(s, x)) != NULL) {\n    if((k = create(s_down,flag[tag]+1))) return k;\n    free(s_down);\n  }\n  free(s);\n  head++;\n  return 0;\n}\n  \n\nint solve(char s0[]) {\n  int k;\n  if((k = create(s0,1))) return k;\n  \n  while(!(k = cal())) {\n    if(head == rear) break;\n  }\n  return k;\n}\n\nint main()\n{\n\n  int i,d;\n  char s[10];\n  for(i = 0; i < 10; i++) factorial[i] = cal_factorial(i);\n  flag = (char*)malloc(sizeof(char)*factorial[9]);\n  memset(flag , 0, factorial[9]);\n  que = (int*)malloc(sizeof(int)*factorial[9]);\n  head = 0;\n  rear = 0;\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &d);\n    s[i] = d+'0';\n  }\n  s[9] = '\\0';\n  printf(\"%d\\n\",solve(s)-1);\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define SIZE 3\n#define UP 0\n#define DOWN 2\n#define LEFT 1\n#define RIGHT 3\n#define DEBUG 0\n#define true 1\n#define false 0\n\n\n\nint up[2] = {-1,0};\nint down[2] = {1,0};\nint left[2] = {0,-1};\nint right[2] = {0,1};\n\nint targetPoints[SIZE*SIZE][2] ;\n\nint cost;\nint blank_row,blank_column;\nint tState[SIZE][SIZE];\n\nvoid get_matrix(int tmp[][SIZE]);\nvoid print_matrix(int tmp[][SIZE]);\nvoid targetPoints_constructor(int state[][SIZE]);\nint getHeuristic(int tmp[][SIZE]);\nint checkState(int state[][SIZE]);\nint solve(int state[][SIZE], int blank_row, int blank_column, int dep, int d, int h);\n\nint main(){\n    int step  = 0;\n    int sState[SIZE][SIZE];\n    int conut = 0;\n    int x;\n    int y;\n    int i;\n    int j;\n\n    for(x = 0; x < SIZE ; x++){\n        for(y = 0; y<SIZE; y++){\n            tState[x][y] = x*SIZE + y + 1;\n        }\n    }\n    tState[SIZE-1][SIZE-1] = 0;\n\n    if(DEBUG)print_matrix(tState);\n\n    get_matrix(sState);\n\n    if(DEBUG)print_matrix(sState);\n    targetPoints_constructor(sState);\n\n    if(checkState(sState)){\n        printf(\"%d\\n\",step);\n    }else{\n        j = getHeuristic(sState);\n        i = -1;\n\n        for(cost = j; ;cost++){\n            if(solve(sState, blank_row, blank_column, 0 , i, j)){\n                break;\n            }\n        }\n        printf(\"%d\\n\",cost);\n    }\n}\n\nint solve(int state[][SIZE], int blank_row, int blank_column, int dep, int d, int h){\n    int h1;\n    int isSovled = checkState(state);\n    if(isSovled){\n        return true;\n    }\n    if(dep == cost){\n        return false;\n    }\n\n    int blank_row1;\n    int blank_column1;\n    int state2[SIZE][SIZE];\n    int direction = 0;\n    int i;\n    int j;\n\n    for(direction=0;direction<4;direction++) {\n        for(i=0;i<SIZE;i++) {\n            for(j=0;j<SIZE;j++) {\n                state2[i][j] = state[i][j];\n            }\n        }\n\n\n            if(direction != d && (d%2 == direction%2)) {\n                continue;\n            }\n\n            if(direction == UP) {\n                blank_row1 = blank_row + up[0];\n                blank_column1 = blank_column + up[1];\n            } else if(direction == DOWN) {\n                blank_row1 = blank_row + down[0];\n                blank_column1 = blank_column + down[1];\n            } else if(direction == LEFT) {\n                blank_row1 = blank_row + left[0];\n                blank_column1 = blank_column + left[1];\n            } else {\n                blank_row1 = blank_row + right[0];\n                blank_column1 = blank_column + right[1];\n            }\n\n\n            if(blank_column1 < 0 || blank_column1 == SIZE\n                    || blank_row1 < 0 || blank_row1 == SIZE) {\n                continue ;\n            }\n\n \n            state2[blank_row][blank_column] = state2[blank_row1][blank_column1];\n            state2[blank_row1][blank_column1] = 0;\n\n\n            if(direction == DOWN && blank_row1\n                    > targetPoints[state[blank_row1][blank_column1]][0]) {\n                h1 = h - 1;\n            } else if(direction == UP && blank_row1\n                    < targetPoints[state[blank_row1][blank_column1]][0]){\n                h1 = h - 1;\n            } else if(direction == RIGHT && blank_column1\n                    > targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else if(direction == LEFT && blank_column1\n                    < targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else {\n                h1 = h + 1;\n            }\n\n\n            if(h1+dep+1> cost) {\n                continue;\n            }\n\n            if(solve(state2, blank_row1, blank_column1, dep+1, direction, h1)) {\n                return true;\n            }\n        }\n        return false;\n\n\n\n}\n\nint checkState(int state[][SIZE]){\n    int b = true;\n    int i;\n    int j;\n    for(int i = 0;i<SIZE;i++) {\n        for (int j = 0; j < SIZE; j++) {\n            if (!(state[i][j] == tState[i][j])) {\n                b = false;\n            }\n        }\n    }\n    return b;\n}\n\nint getHeuristic(int tmp[][SIZE]){\n    int i;\n    int i2;\n    int j;\n    int j2;\n    int ans = 0;\n    int value = 0;\n    int gap = 0;\n    for(i = 0; i < SIZE; i++){\n        for(j = 0; j < SIZE; j++){\n            if(tmp[i][j] == 0)\n                continue;\n\n            if(tmp[i][j] != (i*SIZE+j+1)){\n                value = tmp[i][j];\n                i2 = j2 = gap = 0 ;\n                while(value >SIZE){\n                    value -= SIZE;\n                    i2++;\n                }\n                j2 = value -1;\n\n                gap += abs(i2-i);  \n                gap += abs(j2 -j);\n                //printf(\"h2 : i = %d   j = %d  gap= %d   value = %d  i2 = %d   j2 = %d \\n\",i,j,gap,tmp[i][j],i2,j2);\n                ans += gap;\n            }\n                \n        }\n    }\n    return ans;\n}\n\nvoid targetPoints_constructor(int state[][SIZE]){\n    int i;\n    int j;\n    for(i=0;i<SIZE;i++) {\n        for(j=0;j<SIZE;j++) {\n               if(state[i][j] == 0) {\n                   blank_row = i;\n                   blank_column = j;\n                   break;\n               }\n           }\n    }\n    if(DEBUG)printf(\"Xz = %d, Yz = %d\\n\",blank_row,blank_column);\n    for(i=0;i<SIZE;i++) {\n        for(j=0;j<SIZE;j++) {\n            targetPoints[tState[i][j]][0] = i;\n            targetPoints[tState[i][j]][1] = j;\n        }\n    }\n}\n\n\nvoid get_matrix(int tmp[][SIZE]){\n    int i;\n    int j;\n    for(i = 0; i < SIZE; i++){\n        for(j = 0; j < SIZE; j++){\n            scanf(\"%d\", &tmp[i][j]);\n        }\n    }\n    return;\n}\nvoid print_matrix(int tmp[][SIZE]){\n    int i;\n    int j;\n    for(i = 0; i < SIZE; i++){\n        printf(\"%d\",tmp[i][0]);\n        for(j = 1; j < SIZE; j++){\n            printf(\" %d\", tmp[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define N 3\n#define LIM 13\n\nint ans[N][N]={\n  {1,2,3},\n  {4,5,6},\n  {7,8,0}};\n\nint min = LIM;\n\n\nvoid dfs(int p[N][N], int n)\n{\n  int i,j,i0,j0,a;\n  int f=0;\n  int tmp[N][N];\n  //printf(\"A\\n\");\n  for(i=0;i<N;i++)\n    {\n      for(j=0;j<N;j++)\n\t{\n\t  if(ans[i][j]!=p[i][j])f++;\n\t  if(p[i][j]==0)\n\t    {\n\t      i0=i;\n\t      j0=j;\n\t    }\n\t}\n    }\n\n  if(f==0)\n    {\n      if(min>n)\n\t{\n\t  min=n;\n\t}\n      return;\n    }\n  if(n>LIM) return;\n  \n  if(i0>0 && i0<N)\n    {\n      memcpy(tmp,p,sizeof(int)*N*N);\n      f=tmp[i0][j0];\n      tmp[i0][j0]=tmp[i0-1][j0];\n      tmp[i0-1][j0]=f;\n      dfs(tmp, n+1);\n    }\n  if(j0>0 && j0<N)\n    {\n      memcpy(tmp,p,sizeof(int)*N*N);\n      f=tmp[i0][j0];\n      tmp[i0][j0]=tmp[i0][j0-1];\n      tmp[i0][j0-1]=f;\n      dfs(tmp, n+1);\n    }\n  \n  if(i0>=0 && i0<N-1)\n    {\n      memcpy(tmp,p,sizeof(int)*N*N);\n      f=tmp[i0][j0];\n      tmp[i0][j0]=tmp[i0+1][j0];\n      tmp[i0+1][j0]=f;\n      dfs(tmp, n+1);\n    }\n  if(j0>=0 && j0<N-1)\n    {\n      memcpy(tmp,p,sizeof(int)*N*N);\n      f=tmp[i0][j0];\n      tmp[i0][j0]=tmp[i0][j0+1];\n      tmp[i0][j0+1]=f;\n      dfs(tmp, n+1);\n    }\n  \n}\n\nint main()\n{\n  int i,j;\n  int p[N][N];\n\n  for(i=0;i<N;i++)\n    {\n      for(j=0;j<N;j++)\n\t{\n\t  scanf(\"%d\",&p[i][j]);\n\t}\n    }\n  dfs(p,0);\n\n  printf(\"%d\\n\",min);\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 3\n#define N2 9\n#define L 3628800//キューの長さ//めっちゃでかくする！\n\n\ntypedef struct{\n  int m[N][N];\n  int space;//左上0として空白のいちを示す(0=8)\n  \n  int changetime;\n}MAS;\n\n\nint head=0, tail=0;//head=tailで初期化出来る(空に出来る)////////////\nint all_tail=0;\nMAS Q[L];\nint All[L];//そこにすでにあったら1\nint way[4];//次に進む方向　上右下左\n//==================================\nvoid Swap(int *a,int *b){\n  int c=*a;\n  *a=*b;\n  *b=c;\n}\n\n//Que==================================\nint isEmpty(){//1なら空\n  if(head==tail)return 1;\n  return 0;\n}\n\n\nvoid Enqueue(MAS x){\n  Q[tail]=x;\n  tail=(tail+1)%L;\n}\n\nMAS Dequeue(){\n  MAS x=Q[head];\n  head=(head+1)%L;\n  return x;\n}\n//========================================\nint Judge(MAS A,MAS B){//成功していたら1 失敗していたら0//２つの並びが同じか確かめる\n \n  int i,j;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      if(A.m[i][j]!=B.m[i][j])return 0;\n    }\n  }\n  return 1;\n}\n\nint Allcal(MAS child){\n  return child.m[0][0]*L/9+child.m[0][1]*L/9/8+child.m[0][2]*L/9/8/7+child.m[1][0]*L/9/8/7/6+child.m[1][1]*L/9/8/7/6/5+child.m[1][2]*L/9/8/7/6/5/4+child.m[2][0]*L/9/8/7/6/5/4/3+child.m[2][1]*L/9/8/7/6/5/4/3/2+child.m[2][2];\n}\n\n\n\n  \nvoid  Way(MAS u){//次に進める方向を教える　進めない方向は0　すすめるのは1\n  int i;\n  \n  for(i=0;i<4;i++)way[i]=1;//初期化;\n\n  if(u.space==0||u.space==1||u.space==2)way[0]--;//上\n  if(u.space==2||u.space==5||u.space==8)way[1]--;//右\n  if(u.space==6||u.space==7||u.space==8)way[2]--;//下\n  if(u.space%3==0)way[3]--;//左\n    \n  // printf(\"%d%d%d%d\\n\",way[0],way[1],way[2],way[3]);\n}\n\n\nint  BFS(MAS Input){//何回で解けたか返す\n  MAS u;\n  MAS child;\n  MAS ans={1,2,3,4,5,6,7,8,0,0,0};\n  int count=0;\n  int i;\n  int haba=1;\n  int l=0;\n\n  if(Judge(ans,Input)==1)return child.changetime;\n  Enqueue(Input);\n  All[Allcal(Input)]=1;\n   \n\n\n  while(!isEmpty()){\n    u=Dequeue();\n    Way(u);\n    \n    child=u;\n    if(way[0]==1){\n      Swap(&child.m[child.space/N][child.space%N],&child.m[child.space/N-1][child.space%N]);\n      child.space-=N;\n      child.changetime++;\n      if(Judge(ans,child)==1)return child.changetime;\n\n    \n    \n      \n      if(!All[Allcal(child)]){\n\tEnqueue(child);\n\tAll[Allcal(child)]=1;\n      }\n      //printf(\"up \");\n    }   \n      \n    child=u;\t\n    if(way[1]==1){\n      Swap(&child.m[child.space/N][child.space%N],&child.m[child.space/N][child.space%N+1]);\n      child.space++;\n      child.changetime++;\n      if(Judge(ans,child)==1)return child.changetime;\n    \n    \n      \n      if(!All[Allcal(child)]){\n\tEnqueue(child);\n\tAll[Allcal(child)]=1;\n      }\n      //printf(\"right \");\n    }\n    \n    child=u;\t\n    if(way[2]==1){\n      Swap(&child.m[child.space/N][child.space%N],&child.m[child.space/N+1][child.space%N]);      child.changetime++;\n      child.space+=N;\n      if(Judge(ans,child)==1)return child.changetime;\n    \n    \n      \n      if(!All[Allcal(child)]){\n\tEnqueue(child);\n\tAll[Allcal(child)]=1;\n      }//printf(\"down \");\n    }\n    \n    child=u;\t\n    if(way[3]==1){\n      Swap(&child.m[child.space/N][child.space%N],&child.m[child.space/N][child.space%N-1]);      child.changetime++;\n      child.space--;\n      if(Judge(ans,child)==1)return child.changetime;\n    \n    \n      \n       if(!All[Allcal(child)]){\n\tEnqueue(child);\n\tAll[Allcal(child)]=1;\n      }\n    }\n    \n    //printf(\"%d     \\n\",child.changetime);\n    // printf(\"\\nchild.changetime %d\\n================\\n\",child.changetime);\n    //long=Max(long,)\n  }\n  // printf(\"long%d\\n\",long);\n  return -2;//失敗\n \n}\n\t\t     \n\n\n\n\n    \n\n\nint main(){\n  int i,j;\n  MAS Input={0,0,0,0,0,0,0,0,0,0,0};\n  \n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&Input.m[i][j]);\n      if(Input.m[i][j]==0)Input.space=i*N+j;\n    }\n  }\n\n  // printf(\"A.space=%d\\n\",A.space);\n  \n  printf(\"%d\\n\",BFS(Input));\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>        \n#include <stdlib.h>          \nint puzz[3][3];\nint temp[3][3];\nint dx[4] = { 0, 1, 0,-1};\nint dy[4] = { 1, 0,-1, 0};\n \nvoid empty(int *x, int *y){\n  int i,j;\n  for (i = 0; i < 3; ++i){\n    for (j = 0; j < 3; ++j){\n      if (!puzz[i][j]){\n\t*x = j;\n\t*y = i;\n\treturn;\n      }\n    }\n  }\n}\nvoid swap(int *a, int *b){\n  int temp = *a;\n  *a = *b;\n  *b = temp;\n}\n \nint cal(){\n  int sum = 0,i,a;\n  for (i = 0; i < 9; ++i){\n   a = puzz[i / 3][i % 3];\n    if (a){\n      a--;\n      sum += abs(i / 3 - a / 3) + abs(i % 3 - a % 3);\n    }\n  }\n  return sum;\n}\n \nint dfs(int x, int y, int p, int dep, const int lim){\n  int h,i,nx,ny,res;\n    h = cal();\n  if(h == 0) return dep;\n \n  if(dep + h > lim) return -1;\n \n  for(i = 0; i < 4; ++i){\n    nx = x + dx[i];\n    ny = y + dy[i];\n \n    if(p != -1 && i == (p + 2) % 4) continue;\n \n    if(0 <= nx && nx < 3 && 0 <= ny && ny < 3){\n      swap(&puzz[y][x], &puzz[ny][nx]);\n      res = dfs(nx, ny, i, dep + 1, lim);\n      if (res != -1) return res;\n      swap(&puzz[y][x], &puzz[ny][nx]);\n    }\n  }\n  return -1;\n}\n \nint main(){\n  int i,j,ans,x,y,l;\n  for(i = 0; i < 3; ++i){\n    for(j = 0; j < 3; ++j)scanf(\"%d\", &puzz[i][j]);\n  }\n \n  \n  empty(&x, &y);\n  \n  for(l = 0; l < 100; ++l){\n    for(i = 0; i < 3; ++i){\n      for(j = 0; j < 3; ++j) temp[i][j] = puzz[i][j];\n    }\n   ans = dfs(x, y, -1, 0, l);\n    if(ans != -1){\n      printf(\"%d\\n\", ans);\n      break;\n    }\n    for(i = 0; i < 3; ++i){\n      for(j = 0; j < 3; ++j) puzz[i][j] = temp[i][j];\n    }\n \n    ans = -1;\n    if(l == 99) printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX 3\n#define TRUE 1\n#define FALSE 0\n\nint judge(void);\nint dfs(int,int,int,int,int);\n\nint answer[MAX][MAX] = {\n  {1,2,3},\n  {4,5,6},\n  {7,8,0}\n};\n\nint f[MAX][MAX];\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\nint main(){\n  int x,y;\n  int result;\n  int i,j;\n\n  for (i = 0;i < MAX;i++)\n    for (j = 0;j < MAX;j++){\n      scanf(\"%d\",&f[i][j]);\n\n      if (f[i][j] == 0){\n\ty = i;\n\tx = j;\n      }\t\n    }\n\n  for (i = 1;i < 10000;i++){\n    result = dfs(x,y,-1,0,i);\n\n    if (result >= 0)\n      break;\n  }\n\n  printf(\"%d\\n\",result);\n\n  return 0;\n}\n\n//判定用\nint judge(void){\n  int i,j;\n\n  for (i = 0;i < MAX;i++)\n    for (j = 0;j < MAX;j++)\n      if (f[i][j] != answer[i][j])\n\treturn FALSE;\n\n  return TRUE;\n}\n\nint dfs(int x,int y,int v,int d,int l){\n  int i,j;\n  int result;\n  int nx,ny;\n\n  if (judge())\n    return d;\n\n//深さが基準値を超えていたら\n  if (d > l)\n    return -1;\n\n//移動することを考える\n  for (i = 0;i < 4;i++){\n    nx = x + dx[i];\n    ny = y + dy[i];\n\n//範囲を超えないかチェック\n    if (nx < 0 || nx > 2 || ny < 0 || ny > 2 || (i + 2) % 4 == v)\n      continue;\n\n//移動後の情報をｙ、ｘに移動\n    f[y][x] = f[ny][nx];\n    f[ny][nx] = 0;\n\n//更に掘り下げる\n    if ((result = dfs(nx,ny,i,d + 1,l)) > 0)\n      return result;\n\n    f[ny][nx] = f[y][x];\n    f[y][x] = 0;\n  }\n\n  return -1;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint puz[3][3];\nint cp[3][3];\n\nvoid input() {\n\tint i, j;\n\tfor (i = 0; i < 3; i++)\n\t\tfor (j = 0; j < 3; j++)\n\t\t\tscanf(\"%d\", &puz[i][j]);\n}\n\n\nvoid copy(int m[3][3], int t[3][3]) {\n\tint i, j;\n\tfor (i = 0; i < 3; i++)\n\t\tfor (j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n\nint calc() {\n\tint i, sum = 0;\n\tfor (i = 0; i < 9; i++) {\n\t\tint v = puz[i / 3][i % 3];\n\t\tif (v) {\n\t\t\tv--;\n\t\t\tsum += abs(i / 3 - v / 3) + abs(i % 3 - v % 3);\n\t\t}\n\t}\n\treturn sum;\n}\n\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { 1, 0, -1, 0 };\n\nvoid swap(int *a, int *b) {\n\tint tmp = *a;\n\t*a = *b;\n\t*b = tmp;\n}\n\nint is_in(int x, int y) {\n\treturn 0 <= x && x<3 && 0 <= y && y<3;\n}\n\nint depth(int x, int y, int p, int dep, const int lim) {\n\tint i, h = calc();\n\tif (h == 0) return dep;\n\tif (dep + h > lim) return -1;\n\tfor (i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i], ny = y + dy[i], res;\n\t\tif (~p && i == (p + 2) % 4) continue;\n\t\tif (!is_in(nx, ny)) continue;\n\t\tswap(&puz[y][x], &puz[ny][nx]);\n\t\tres = depth(nx, ny, i, dep + 1, lim);\n\t\tif (~res) return res;\n\t\tswap(&puz[y][x], &puz[ny][nx]);\n\t}\n\treturn -1;\n}\n\nvoid get_empty(int *x, int *y) {\n\tint i, j;\n\tfor (i = 0; i < 3; i++) {\n\t\tfor (j = 0; j < 3; j++) {\n\t\t\tif (!puz[i][j]) {\n\t\t\t\t*x = j;\n\t\t\t\t*y = i;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve() {\n\tint x, y, lim, ans;\n\tget_empty(&x, &y);\n\tfor (lim = 0; lim < 50; lim++) {\n\t\tcopy(cp, puz);\n\t\tif ((ans = depth(x, y, -1, 0, lim)) != -1) return ans;\n\t\tcopy(puz, cp);\n\t}\n\treturn -1;\n}\n\nint main() {\n\tinput();\n\tprintf(\"%d\\n\", solve());\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n  unsigned int b;\n  char step;\n} Board;\n\nint qlen=32202;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nconst Motion motion[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}} };\n\nint findzero(unsigned int b)\n{\n  for (int i=0; i<9; i++) {\n    if (b%10==0) return 8-i;\n    b/=10;\n  }\n  return -1;\n}\n\nunsigned int sq[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000,1000000000 };\n\n#define HISTLEN 876543\n\nint main()\n{\n  int i, j, k;\n  int qhead, qtail;\n  qhead = qtail = 0;//\n  Board board;\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b = i*sq[8]+j*sq[7]+k*sq[6];\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b += i*sq[5]+j*sq[4]+k*sq[3];\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b += i*100+j*10+k;\n  short int *used = (short int*)malloc(sizeof(short int)*HISTLEN);\n  for (i=0; i<HISTLEN; i++) used[i]=0;\n  Board *Q = (Board*)malloc(sizeof(Board)*qlen);\n  board.step=0;\n  Q[qhead++] = board;\n  \n  while (qhead>qtail) {\n    board = Q[qtail++ %qlen];\n    if (board.b==123456780)   break;\n    \n    int space = findzero(board.b);\n    for (i=0; motion[space][i].pos>=0; i++) {\n      Board b = board;\n      Motion m = motion[space][i];\n      if (m.pos==0 && b.b/sq[8]==1) continue;\n      if ((m.pos==1||m.pos==2) && b.b/sq[8]==1&&(b.b%sq[8])/sq[7]==2&&(b.b%sq[7])/sq[6]==3) continue;\n      int nn=b.b%sq[8-m.pos+1]/sq[8-m.pos];\n      b.b = nn*sq[8-space]+b.b-nn*sq[8-m.pos];\n      b.step = board.step+1;\n      k=b.b/1000;\n      if ((used[k] & (1<<(b.b%10)))==(1<<(b.b%10))) continue;\n      used[k] |= (1<<(board.b%10));\n      Q[qhead++ %qlen] = b;\n    }\n  }\n  printf(\"%d\\n\", board.step);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n \nchar *flag;\nint head,rear;\nint *que;\nint factorial[10];\n \nint cal_factorial(int n) {\n  if(n == 0) return 1;\n  return cal_factorial(n-1)*n;\n}\n \nint stotag(char *s) {\n  int a= 0;\n  int i;\n  for(i = 0; i < 9; i++) {\n    int t,j;\n    t = 0;\n    for(j = 0; j < i; j++) {\n      if(s[j] < s[i]) t++;\n    }\n    a+= factorial[8-i]*(s[i]-'0'-t);\n  }\n  return a;\n}\n \nchar *tagtos(int tag) {\n  int i;\n  char *s;\n  s = (char*)malloc(sizeof(char)*10);\n  for(i = 0; i < 9; i++) {\n    s[i] = tag%factorial[9-i]/factorial[8-i] + '0';\n  }\n  s[9] = '\\0';\n  for(i = 7; i >= 0; i--) {\n    int j;\n    for(j = 8; j > i; j--) {\n      if(s[i] <= s[j]) s[j]++;\n    }\n  }\n  return s;\n}\n \n \nchar *move_up(char s[], int x) {\n  if(x < 3) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-3];\n  s_new[x-3] = s[x];\n  return s_new;\n}\n \nchar *move_left(char s[], int x) {\n  if(x%3 == 0) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-1];\n  s_new[x-1] = s[x];\n  return s_new;\n}\n \nchar *move_right(char s[], int x) {\n  if(x%3 == 2) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+1];\n  s_new[x+1] = s[x];\n  return s_new;\n}\n \nchar *move_down(char s[], int x) {\n  if(x > 5) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+3];\n  s_new[x+3] = s[x];\n  return s_new;\n}\n \nint create(char s[], int t) {\n  if(strcmp(s,\"123456780\") == 0) return t;\n  int tag = stotag(s);\n  if(flag[tag]) return 0;\n  flag[tag] = t;\n  que[rear] = tag;\n  rear++;\n  return 0;\n}\n \nint check_x(char *s) {\n  int i = 0;\n  while(s[i] != '0') i++;\n  return i;\n}\n \nint cal() {\n  char *s_right,*s_left,*s_up,*s_down;\n  int k,b;\n \n  b= que[head];\n  char *s = tagtos(b);\n  int x = check_x(s);\n   \n  if((s_right = move_right(s, x)) != NULL) {\n    if((k = create(s_right,flag[b]+1))) return k;\n    free(s_right);\n  }\n  if((s_left = move_left(s, x)) != NULL) {\n     if((k = create(s_left,flag[b]+1))) return k;\n     free(s_left);\n  }\n  if ((s_up = move_up(s, x)) != NULL) {\n    if((k = create(s_up,flag[b]+1))) return k;\n    free(s_up);\n  }\n  if((s_down = move_down(s, x)) != NULL) {\n    if((k = create(s_down,flag[b]+1))) return k;\n    free(s_down);\n  }\n  free(s);\n  head++;\n  return 0;\n}\n   \n \nint solve(char s0[]) {\n  int k;\n  if((k = create(s0,1))) return k;\n   \n  while(!(k = cal())) {\n    if(head == rear) break;\n  }\n  return k;\n}\n \nint main()\n{\n \n  int i,d;\n  char a[10];\n  for(i = 0; i < 10; i++) factorial[i] = cal_factorial(i);\n  flag = (char*)malloc(sizeof(char)*factorial[9]);\n  memset(flag , 0, factorial[9]);\n  que = (int*)malloc(sizeof(int)*factorial[9]);\n  head = 0;\n  rear = 0;\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &d);\n    a[i] = d+'0';\n  }\n  a[9] = '\\0';\n  printf(\"%d\\n\",solve(a)-1);\n   \n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h> \n#define pt 3\n#define py 3\n#define psum (pt*py)\n#define cnt 45\nextern inline void ue();\nextern inline void sita();\nextern inline void hdr();\nextern inline void mgi();\nextern int  find(int,int,int,int);\nint zero = 0,pzl[psum];\nint main()\n{\n    int i = 0,x,y = 0;\n    for(i=0;i<psum;i++)\n    {\n        scanf(\"%d\",&pzl[i]);\n         \n        if(pzl[i] == 0) zero = i;\n    }\n     \n    x = pt - (zero/py) -1;\n    y = py - (zero%py) -1;\n     \n    for(i=0; i<cnt; i++)\n    {\n        if( find(x,y,i,4) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n     \n    return 0;\n}\n \nint find(int x, int y, int mcnt, int p)\n{\n    int res;\n    int i=0;\n     \n    if(mcnt < (x + y) )\n    {\n        return 0;\n    }\n    if(mcnt==0)\n    {\n        for(i=0; i<psum-1; i++)\n        {\n            if(pzl[i] != (i+1)) return 0;\n        }\n        return 1;\n    }\n    for(i=0; i<4; i++)\n    {\n        res = 0;\n         \n        switch(i)\n        {\n            case 0:\n                if( (x>0) && (p!=3) )\n                {\n                    sita();\n                    res = find(x-1, y, mcnt-1, 0);\n                    ue();\n                }\n                break;\n                 \n            case 1:\n                if((p!=2)&&(y>0))\n                {\n                    mgi();\n                    res = find(x,y-1,mcnt-1,1);\n                    hdr();\n                }\n                break;\n                 \n            case 2:\n                if((p!=1)&&(y<py-1))\n                {\n                    hdr();\n                    res = find(x,y+1, mcnt-1,2);\n                    mgi();\n                }\n                break;\n                 \n            case 3:\n                if((x<pt-1)&&(p!=0))\n                {\n                    ue();\n                    res = find(x+1,y,mcnt-1,3);\n                    sita();\n                }\n                break;\n            default:\n                break;\n        }\n         \n        if(res)\n        {\n            return 1;\n        }\n    }\n     \n    return 0;\n}\n \n \ninline void sita()\n{\n    pzl[zero] = pzl[zero+py];\n    zero += py;\n}\n  \ninline void ue()\n{\n    pzl[zero] = pzl[zero-py];\n    zero -= py;\n}\n  \ninline void mgi()\n{\n    pzl[zero] = pzl[zero+1];\n    zero += 1;\n}\n  \ninline void hdr()\n{\n    pzl[zero] = pzl[zero-1];\n    zero -= 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\n#define LEN 362880\nint head = 0, tail = 0;\nint que[LEN];\n\nint start[9]; //初期状態\t\nint goal = 46233;\t//最終状態\nint search[362880] = { 0 };\t//探索済み\nint board[362880][9];\t//盤面の状態\nint d[362880];\t//時間\nint oya; //親のナンバー\nint dummy[9];\t//盤面コピー用\nint p0[362880];\t//0の位置を記憶\n\n/*盤面の隣接リスト*/\nint next[9][5] = { {2, 1, 3},\n\t\t\t\t   {3, 0, 2, 4},\n                   {2, 1, 5},\n\t\t\t\t   {3, 0, 4, 6},\n                   {4, 1, 3, 5, 7},\n\t\t\t\t   {3, 2, 4, 8},\n                   {2, 3, 7},\n                   {3, 4, 6, 8},\n\t\t\t\t   {2, 5, 7}\n};\n\n/*キューの実装*/\nint isempty() {\n\treturn head == tail;\n}\n\nvoid enqueue(int x) {\n\tque[tail] = x;\n\tif ((tail + 1) == LEN)\n\t\ttail = 0;\n\telse\n\t\ttail++;\n}\n\nint dequeue() {\n\tint x;\n\tx = que[head];\n\tif ((head + 1) == LEN)\n\t\thead = 0;\n\telse\n\t\thead++;\n\treturn x;\n}\n\n/*0のマスを探索*/\nint a_mas0(int a[]) {\n\tfor (int i = 0; i < 9; i++)\n\t\tif (a[i] == 0)\n\t\t\treturn i;\n}\n\n/*盤面をコピー*/\nvoid board_copy(int a[], int b[]) {\n\tfor (int i = 0; i < 9; i++)\n\t\tb[i] = a[i];\n}\n\n/*階乗を計算*/\nint n_factorial(int n) {\n\tif (n == 1)\n\t\treturn 1;\n\treturn n * n_factorial(n - 1);\n}\n\n/*盤面記憶のために使用*/\nvoid a_location(int a[], int s) {\n\tfor (int i = s + 1; i < 9; i++)\n\t\tif (a[s] < a[i])\n\t\t\ta[i]--;\n}\n\n/*盤面の状態を数値に変換*/\nint assign_number(int a[]) {\n\tint b[9];\n\tint num = 0;\n\tint pos = 8;\n\tboard_copy(a, b);\n\tfor (int i = 8; i > 0; i--) {\n\t\tnum = num + b[8 - i] * n_factorial(i);\n\t\ta_location(b, 8 - i);\n\t\tif (a[8 - i] == 0)\n\t\t\tpos = 8 - i;\n\t}\n\tp0[num] = pos;\n\treturn num;\n}\n\n/*マスの移動*/\nvoid move(int *a, int *b) {\n\tint box;\n\tbox = *a;\n\t*a = *b;\n\t*b = box;\n}\n\n/*盤面の表示*/\nvoid puzzle_print(int a[]) {\n\tfor (int i = 0; i < 9; i++)\n\t\tprintf(\"%d \", a[i]);\n\tprintf(\"\\n\");\n}\n\n/*0の位置を探索*/\nint zero_position(int a[]) {\n\tfor (int i = 0; i < 9; i++)\n\t\tif (a[i] == 0)\n\t\t\treturn i;\n}\n\n/*幅優先探索*/\nint bsf() {\n\tint num;\n\tint pos;\n\twhile (isempty() != 1) {\n\t\toya = dequeue();\n\t\tpos = p0[oya];\n\t\tfor (int i = 1; i <= next[pos][0]; i++) {\n\t\t\tboard_copy(board[oya], dummy);\t//oyaの盤面をdummyにコピー\n\t\t\tmove(&dummy[pos], &dummy[next[pos][i]]);\t//dummyの盤面を移動\n\t\t\tnum = assign_number(dummy);\t//移動した盤面を数値に変換\n\t\t\tif (num == goal){\t//最終状態を発見\n\t\t\t\td[num] = d[oya] + 1;\t\n\t\t\t\tsearch[num] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if (search[num] != 1) {\t//最終状態でない\n\t\t\t\tsearch[num] = 1;\n\t\t\t\tboard_copy(dummy, board[num]);\n\t\t\t\td[num] = d[oya] + 1;\n\t\t\t\tenqueue(num);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void) {\n\tint i = 0;\n\tint num;\n\t\n\t/*初期状態の設定*/\n\tfor (i = 0; i < 9; i++)\n\t\tscanf(\"%d\", &start[i]);\n\tnum = assign_number(start);\t//初期状態の数値\n\tboard_copy(start, board[num]);\t//初期状態の盤面を記憶\n\tsearch[num] = 1;\t//初期状態の数値を記憶(1をたてる)\n\td[num] = 0;\t//初期状態の時間を0に設定\n\tenqueue(num); //初期状態の数値をキューに格納\n\t\n\t/*探索開始*/\n\tif (num == goal)\n\t\tprintf(\"0\\n\");\n\telse if (bsf() == 1)\n\t\tprintf(\"%d\\n\", d[goal]);\n\telse\n\t\tprintf(\"なし\\n\"); \n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n\nextern inline void down_0(void);\nextern inline void up_0(void);\nextern inline void right_0(void);\nextern inline void left_0(void);\n\nextern int  serch(int x, int y, int MaxCnt, int pre);\nextern int  check(void);\n\nint cnt,num = 0;\nint val[Total] ={};\n\n\nint main( void )\n{\n    int i = 0;\n    int x,y = 0;\n    \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        \n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n    \n    x = tate - (num/yoko) -1;\n    y = yoko - (num%yoko) -1;\n    \n    for(i=1; i<20; i++)\n    {\n        if( serch(x,y,i,4) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt, int pre)\n{\n    int result;\n    int i=0;\n    \n    // 最大数で打ち切り\n    if(MaxCnt==0)\n    {\n        return check();\n    }\n    \n    // 上下左右で4回回す\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if( (x > 0) && (pre != 3) )\n                {\n                    down_0();\n                    \n                    result = serch(x-1, y, MaxCnt-1, 0);\n                    \n                    up_0();\n                }\n                break;\n            case 1:\n                if( (y > 0) && (pre != 2) )\n                {\n                    right_0();\n                    \n                    result = serch(x, y-1, MaxCnt-1, 1);\n                    \n                    left_0();\n                }\n                break;\n            case 2:\n                if( (y < yoko) && (pre != 1) )\n                {\n                    left_0();\n                    \n                    result = serch(x, y+1, MaxCnt-1, 2);\n                    \n                    right_0();\n                }\n                break;\n            case 3:\n                if( (x < tate) && (pre != 0) )\n                {\n                    up_0();\n                    \n                    result = serch(x+1, y, MaxCnt-1, 3);\n                    \n                    down_0();\n                }\n                break;\n            default:\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n        \n    }\n\n    return 0;\n}\n\n// TRUE : 完成\n// FALSE : 失敗\nint check()\n{\n    int i=0;\n    \n//    printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);\n    \n    for(i=0; i<Total-1; i++)\n    {\n        if(val[i] != (i+1))\n        {\n            return 0;\n        }\n    }\n    return 1;\n}\n\ninline void down_0()\n{\n    val[num] = val[num + yoko];\n    num = num + yoko;\n}\n \ninline void up_0()\n{\n    val[num] = val[num - yoko];\n    num = num - yoko;\n}\n \ninline void right_0()\n{\n    val[num] = val[num +1];\n    num = num + 1;\n}\n \ninline void left_0()\n{\n    val[num] = val[num -1];\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 3\n#define N1 4\n#define N2 9\n#define N3 100\n\nint puz[N][N];\nint tmp[N][N];\nint dx[N1]={0,1,0,-1};\nint dy[N1]={1,0,-1,0};\n\nvoid emp(int x[],int y[]) {\n  int i,j;\n  for(i=0;i<N;i++) {\n    for(j=0;j<N;j++) {\n      if(!puz[i][j]) {\n        *x = j;\n        *y = i;\n        return;\n      }\n    }\n  }\n}\n\nvoid swap(int a[],int b[]){\n  int tmp;\n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\n\nint calsum(){\n  int i,a,sum=0;\n  for(i=0; i<N2; i++){\n    a = puz[i/N][i%N];\n    if(a){\n      a--;\n      sum+=abs((i/N)-(a/N))+abs((i%N)-(a%N));\n    }\n  }\n  return sum;\n}\n\nint dfs(int x,int y,int p,int dep,const int lim){\n  int i,h,nx,ny,res;\n  h=calsum();\n  if(h==0) return dep;\n  if(dep+h>lim) return -1;\n  for(i=0;i<N1;i++){\n    nx=x+dx[i];\n    ny=y+dy[i];\n    if(~p && i==(p+2)%N2) continue;\n    if(!(0<=nx && nx<N && 0<=ny && ny<N)) continue;\n    swap(&puz[y][x],&puz[ny][nx]);\n    res = dfs(nx,ny,i,dep+1,lim);\n    if(~res) return res;\n    swap(&puz[y][x],&puz[ny][nx]);\n  }\n  return -1;\n}\n\nint main() {\n  int i,j,ans,x,y,l;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++) scanf(\"%d\",&puz[i][j]);\n  }\n  emp(&x,&y);\n  for(l=0;l<N3;l++){\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++) tmp[i][j] = puz[i][j];\n    }\n    ans=dfs(x,y,-1,0,l);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++) puz[i][j] = tmp[i][j];\n    }\n    ans = -1;\n    if(l==N3-1) printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define Ni 3\n\nint pl[Ni][Ni],tmp[Ni][Ni];\nint Dx[4]={0,1,0,-1},Dy[4]={1,0,-1,0};\n\nvoid em(int *a,int *b){\n  int i,j;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(!pl[i][j]){\n\t*a = j;\n\t*b=i;\n      }\n    }\n  }\n}\n\nvoid SW(int *a,int *b){\n  int tmp;\n  tmp =*a;\n  *a = *b;\n  *b = tmp;\n}\n\nint cal(){\n  int i,A,S=0;\n  for(i=0;i<9;i++){\n    A = pl[i/3][i%3];\n    if(A){\n      A--;\n      S += abs(i/3-A/3) + abs(i%3 - A%3);\n    }\n  }\n  return S;\n}\n\nint df(int a,int b,int P,int D,const int shin){\n  int i,hi,A,B,result;\n  hi = cal();\n  if(hi==0){\n    return D;\n  }\n  if(D+hi>shin){\n    return -1;\n  }\n\n  for(i=0;i<4;i++){\n    A = a+Dx[i];\n    B = b+Dy[i];\n    if(~P && i==(P+2)%4) {\n      continue;\n    }\n    if(!(0<=A && A<3 && 0<=B && B<3)){\n      continue;\n    }\n    SW(&pl[b][a],&pl[B][A]);\n    result = df(A,B,i,D+1,shin);\n    if(~result){\n      return result;\n    }\n    SW(&pl[b][a],&pl[B][A]);\n  }\n  return -1;\n}\n\nint main(){\n  int i,j,li,TA,a,b;\n\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&pl[i][j]);\n    }\n  }\n\n    em(&a,&b);\n    for(li=0;li<100;li++){\n      for(i=0;i<3;i++){\n\tfor(j=0;j<3;j++){\n\t  tmp[i][j]=pl[i][j];\n\t}\n      }\n\tTA = df(a,b,-1,0,li);\n\tif(TA!=-1){\n\t  printf(\"%d\\n\",TA);\n\t  break;\n\t}\n\n\tfor(i=0;i<3;i++){\n\t  for(j=0;j<3;j++){\n\t    pl[i][j]=tmp[i][j];\n\t  }\n\t}\n\n\tTA = -1;\n\tif(li==99){\n\t      printf(\"%d\\n\",TA);\n\t    }\n      }\n\n    return 0;\n\t    }\n\n  \n  \n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n\nextern inline void down_0(void);\nextern inline void up_0(void);\nextern inline void right_0(void);\nextern inline void left_0(void);\n\nextern int  serch(int x, int y, int MaxCnt, int pre);\nextern int  check(void);\n\nint cnt,num = 0;\nint val[Total] ={};\n\n\nint main( void )\n{\n    int i = 0;\n    int x,y = 0;\n    \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        \n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n    \n    x = tate - (num/yoko) -1;\n    y = yoko - (num%yoko) -1;\n    \n    for(i=1; i<20; i++)\n    {\n        if( serch(x,y,i,4) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt, int pre)\n{\n    int result;\n    int i=0;\n    \n    // 最大数で打ち切り\n    if(MaxCnt==0)\n    {\n        return check();\n    }\n    \n    // 上下左右で4回回す\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if( (x > 0) || (pre != 3) )\n                {\n                    down_0();\n                    \n                    result = serch(x-1, y, MaxCnt-1, 0);\n                    \n                    up_0();\n                }\n                break;\n            case 1:\n                if( (y > 0) || (pre != 2) )\n                {\n                    right_0();\n                    \n                    result = serch(x, y-1, MaxCnt-1, 1);\n                    \n                    left_0();\n                }\n                break;\n            case 2:\n                if( (y < yoko) && (pre != 1) )\n                {\n                    left_0();\n                    \n                    result = serch(x, y+1, MaxCnt-1, 2);\n                    \n                    right_0();\n                }\n                break;\n            case 3:\n                if( (x < tate) && (pre != 0) )\n                {\n                    up_0();\n                    \n                    result = serch(x+1, y, MaxCnt-1, 3);\n                    \n                    down_0();\n                }\n                break;\n            default:\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n        \n    }\n\n    return 0;\n}\n\n// TRUE : 完成\n// FALSE : 失敗\nint check()\n{\n    int i=0;\n    \n//    printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);\n    \n    for(i=0; i<Total-1; i++)\n    {\n        if(val[i] != (i+1))\n        {\n            return 0;\n        }\n    }\n    return 1;\n}\n\ninline void down_0()\n{\n    val[num] = val[num + yoko];\n    num = num + yoko;\n}\n \ninline void up_0()\n{\n    val[num] = val[num - yoko];\n    num = num - yoko;\n}\n \ninline void right_0()\n{\n    val[num] = val[num +1];\n    num = num + 1;\n}\n \ninline void left_0()\n{\n    val[num] = val[num -1];\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n\n\nextern void down_0(void);\nextern void up_0(void);\nextern void right_0(void);\nextern void left_0(void);\nextern int  serch(int x, int y, int MaxCnt);\nextern int  check(void);\n\nint cnt,num = 0;\nint val[Total] ={};\n\n\nint main( void )\n{\n \n    int ori[Total] ={};\n    \n    \n    int i = 0;\n    int num_0 = 0;\n    int x,y = 0;\n     \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        ori[i]=val[i];\n        \n        if(val[i] == 0)\n        {\n            num_0 = i;\n        }\n    }\n    \n    x = tate - (num_0/yoko);\n    y = yoko - (num_0%yoko);\n    \n        // 初期化\n        for(i=0; i<Total; i++)\n        {\n            val[i]=ori[i];\n        }\n        num = num_0;\n        cnt = 0;\n        \n    for(i=1; i<10; i++)\n    {\n        if( serch(x,y,i) )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }\n        \n//  printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);        \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt)\n{\n    int result;\n    int i=0;\n    \n    // 最大数で打ち切り\n    if(cnt >= MaxCnt)\n    {\n        return check();\n    }\n    \n    //\n    if(x==0 && y==0)\n    {\n        if( check() )\n        {\n            return 1;\n        }\n    }\n    \n    // 上下左右で4回回す\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if(x != 0)\n                {\n                    down_0();\n                    x = x-1;\n                    \n                    cnt = cnt + 1;\n                    result = serch(x,y,MaxCnt);\n                    cnt=cnt-1;\n                    \n                    up_0();\n                    x = x+1;\n                }\n                break;\n            case 1:\n                if(y != 0)\n                {\n                    right_0();\n                    y = y-1;\n                    \n                    cnt = cnt + 1;\n                    result = serch(x,y,MaxCnt);\n                    cnt=cnt-1;\n                    \n                    left_0();\n                    y = y+1;\n                }\n                break;\n            case 2:\n                if(y < yoko-1)\n                {\n                    left_0();\n                    y = y+1;\n                    \n                    cnt = cnt + 1;\n                    result = serch(x,y,MaxCnt);\n                    cnt=cnt-1;\n                    \n                    right_0();\n                    y = y-1;\n                }\n                break;\n            case 3:\n                if(x < tate-1)\n                {\n                    up_0();\n                    x = x+1;\n                    \n                    cnt = cnt + 1;\n                    result = serch(x,y,MaxCnt);\n                    cnt=cnt-1;\n                    \n                    down_0();\n                    x = x-1;\n                }\n                break;\n            default:\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n        \n    }\n\n    return 0;\n}\n\n// TRUE : 完成\n// FALSE : 失敗\nint check()\n{\n    int i=0;\n    \n//    printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);\n    \n    for(i=0; i<Total-1; i++)\n    {\n        if(val[i] != (i+1))\n        {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid down_0()\n{\n    val[num] = val[num + yoko];\n    val[num + yoko] = 0;\n    num = num + yoko;\n}\n \nvoid up_0()\n{\n    val[num] = val[num - yoko];\n    val[num - yoko] = 0;\n    num = num - yoko;\n}\n \nvoid right_0()\n{\n    val[num] = val[num +1];\n    val[num +1] = 0;\n    num = num + 1;\n}\n \nvoid left_0()\n{\n    val[num] = val[num -1];\n    val[num -1] = 0;\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \nint puz[3][3];\nint tmp[3][3];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n \nvoid empty(int *x,int *y) {\n  int i,j;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(!puz[i][j]){\n        *x=j;\n        *y=i;\n        return;\n      }\n    }\n  }\n}\n \nvoid swap(int *a, int *b) {\n  int tmp;\n  tmp= *a;\n  *a= *b;\n  *b=tmp;\n}\n \nint cal() {\n  int i,a;\n  int sum=0;\n  for(i=0;i<9;i ++){\n    a=puz[i/3][i%3];\n    if(a){\n      a--;\n      sum+=abs(i/3-a/3)+abs(i%3-a%3);\n    }\n  }\n  return sum;\n}\n \nint dfs(int x, int y, int p, int dep, const int lim) {\n  int i,h,nx,ny,res;\n  h=cal();\n  if(h==0){\n    return dep;\n  }\n  if(dep+h>lim){\n    return -1;\n  }\n  for(i=0;i<4;i++){\n    nx=x+dx[i];\n    ny=y+dy[i];\n    if(~p&&i==(p+2)%4) continue;\n    if(!(0<=nx&&nx<3&&0<=ny&&ny<3)) continue;\n    swap(&puz[y][x],&puz[ny][nx]);\n    res=dfs(nx,ny,i,dep+1,lim);\n    if(~res){\n      return res;\n    }\n    swap(&puz[y][x],&puz[ny][nx]);\n    }\n  return -1;\n}\n \nint main() {\n  int i,j,ans,x,y,l;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&puz[i][j]);\n    }\n  }\n  empty(&x,&y);\n  for(l=0;l<100;l++){\n    for(i=0;i<3;i++){\n      for(j =0;j<3;j++){\n        tmp[i][j] = puz[i][j];\n      }\n    }\n    ans=dfs(x,y,-1,0,l);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n        puz[i][j]=tmp[i][j];\n      }\n    }\n    ans= -1;\n    if(l==99){\n      printf(\"%d\\n\",ans);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n  \n#define tate 3\n#define yoko 3\n#define SUM (tate*yoko)\n#define Cnt 45\nextern inline void up(void);     \nextern inline void down(void);     \nextern inline void right(void);   \nextern inline void left(void);    \nextern int  serch(int a, int b, int cnt,int p);\n \nint n = 0,A[SUM]; \n\nint main()\n{\n  int i = 0,a,b= 0;\n     \n    \n    for(i=0; i<SUM; i++)\n    {\n        scanf(\"%d\",&A[i]);\n         \n        if(A[i] == 0)n = i;\n    } \n    a = tate - (n/yoko) -1;\n    b = yoko - (n%yoko) -1;\n    for(i=0; i<Cnt; i++){\n        if( serch(a,b,i,4) == 1 ){\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }          \n    return 0;\n}\n \nint serch(int a, int b, int cnt, int p)\n{\n  int res, i=0;\n     \n  if(Cnt < (a + b) )return 0;  \n    if(cnt==0){\n        for(i=0; i<SUM-1; i++){\n            if(A[i] != (i+1))return 0;\n        }   \n        return 1;\n    }\n        \n    for(i=0; i<4; i++){\n        res= 0;        \n        switch(i){\n            case 0:\n                if( (a> 0) && (p != 3) ){\n                    down();      \n                    res = serch(a-1, b, cnt-1, 0);\n                    up();\n                }\n                break;\n                 \n            case 1:\n\t      if( (b> 0) && (p != 2)){\n                    right();\n                    res = serch(a, b-1, cnt-1, 1);\n                    left();\n                }\n                break;\n                 \n            case 2:\n                if( (b < yoko -1 ) && (p != 1) ){\n                    left();\n                    res = serch(a, b+1, cnt-1, 2);\n                    right();\n                }\n                break;\n                 \n            case 3:\n                if( (a < tate -1 ) && (p != 0) ){\n                    up();\n                    res = serch(a+1, b, cnt-1, 3);\n                    down();\n                }\n                break;\n                 \n            default:\n                break;\n        }\n        if(res)return 1;\n    }     \n    return 0;\n}\n \ninline void up()\n{\n    A[n] = A[n - yoko];\n    n = n - yoko;\n}\n \ninline void down()\n{\n    A[n] = A[n + yoko];\n    n = n + yoko;\n}\n  \ninline void right()\n{\n    A[n] = A[n +1];\n    n = n + 1;\n}\n  \ninline void left()\n{\n    A[n] = A[n -1];\n    n = n - 1;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 9\n\nint board[N];\nint rows = 3, cols = 3, zeroIndex, current;\n\n// for previousMove: 0 is down, 1 is up, 2 is left, 3 is right\nint blindSearch(int x, int y, int moves, int previousMove) {\n  int i, foundAnswer;\n\n  // answer is less than manhattan distance, not possible\n  if (moves < (x + y))\n      return 0;\n\n  if (!moves) {\n    //printf(\"done %d moves\\n\", current);\n\n    for (i = 0; i < N - 1; i++) {\n      if (board[i] != i + 1)\n        return 0;\n    }\n\n    return 1;\n  }\n\n  if (x > 0 && previousMove != 1) {\n    // can expand down\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n\n    foundAnswer = blindSearch(x - 1, y, moves - 1, 0);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n  }\n\n  if (y > 0 && previousMove != 3) {\n    // right\n    board[zeroIndex] = board[++zeroIndex];\n\n    foundAnswer = blindSearch(x, y - 1, moves - 1, 2);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[--zeroIndex];\n  }\n\n  if (y < rows - 1 && previousMove != 2) {\n    // left\n    board[zeroIndex] = board[--zeroIndex];\n\n    foundAnswer = blindSearch(x, y + 1, moves - 1, 3);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[++zeroIndex];\n  }\n\n  if (x < cols - 1 && previousMove != 0) {\n    // up\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n\n    foundAnswer = blindSearch(x + 1, y, moves - 1, 1);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n  }\n\n  return 0;\n}\n\nint main() {\n  int i, x, y;\n  current = 0;\n\n  for (i = 0; i < N; i++) {\n    scanf(\"%d\", &board[i]);\n    if (!board[i])\n      zeroIndex = i;\n  }\n\n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n\n  //printf(\"zero index coordinates are: %d %d\\n\", x, y);\n\n  while (current < 50) {\n    if (blindSearch(x, y, current, -1)) {\n      printf(\"%d\\n\", current);\n      return;\n    }\n    current++;\n  }\n\n  //printf(\"Couldn't find an answer!\\n\");\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 3\nint ansArr[N][N]={{1,2,3},\n                  {4,5,6},\n                  {7,8,0}};\nint tempArr[N][N];\nint curMinCost=40;\nvoid calcMinCost(int,int);\nint get0Row(void);\nint get0Col(void);\nint isCorrect(void);\nvoid printArr(void);//debugging\nint main(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    for(j=0;j<N;j++)\n      scanf(\"%d\",&tempArr[i][j]);\n  calcMinCost(0,0);\n  printf(\"%d\\n\",curMinCost);\n  return 0;\n}\nvoid calcMinCost(int cost,int lastMove)\n{\n  int row,col;\n  //printArr();\n  if(cost>=curMinCost) return;\n  if(isCorrect()==1)\n    {\n      curMinCost=cost;\n      return;\n    }\n  row=get0Row();\n  col=get0Col();\n  if(row!=N-1&&lastMove!=3)//slide up\n    {\n      tempArr[row][col]=tempArr[row+1][col];\n      tempArr[row+1][col]=0;\n      calcMinCost(cost+1,1);\n      tempArr[row+1][col]=tempArr[row][col];\n      tempArr[row][col]=0;\n    }\n  if(col!=N-1&&lastMove!=4)//slide left\n    {\n      tempArr[row][col]=tempArr[row][col+1];\n      tempArr[row][col+1]=0;\n      calcMinCost(cost+1,2);\n      tempArr[row][col+1]=tempArr[row][col];\n      tempArr[row][col]=0;\n    }\n  if(row!=0&&lastMove!=1)//slide down\n    {\n      tempArr[row][col]=tempArr[row-1][col];\n      tempArr[row-1][col]=0;\n      calcMinCost(cost+1,3);\n      tempArr[row-1][col]=tempArr[row][col];\n      tempArr[row][col]=0;\n    }\n  if(col!=0&&lastMove!=2)//slide right\n    {\n      tempArr[row][col]=tempArr[row][col-1];\n      tempArr[row][col-1]=0;\n      calcMinCost(cost+1,4);\n      tempArr[row][col-1]=tempArr[row][col];\n      tempArr[row][col]=0;\n    }\n}\nint get0Row(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    for(j=0;j<N;j++)\n      if(tempArr[i][j]==0) return i;\n}\nint get0Col(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    for(j=0;j<N;j++)\n      if(tempArr[i][j]==0) return j;\n}\nint isCorrect(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    for(j=0;j<N;j++)\n      if(ansArr[i][j]!=tempArr[i][j]) return 0;\n  return 1;\n}\nvoid printArr(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    {\n      for(j=0;j<N;j++)\n        {\n          printf(\"%d \",tempArr[i][j]);\n        }\n      printf(\"\\n\");\n    }\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define N 3\n\nint Puzzle[N][N];\nint tmp[N][N];\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nvoid empty(int *,int *);\nint dfs(int ,int,int ,int ,int );\nint cal(void);\n\n\nint main(){\n\tint i,j,limit;\n\tint b,a,c;\n\n\n\tfor(i =0;i < N; i++){\n\t\tfor(j = 0 ; j < N ; j++){\n\t\t\tscanf(\"%d\",&Puzzle[i][j]);\n\t\t}\n\t}\n\tempty(&a,&b);\n\n\tfor(limit = 0; limit < 60 ; limit++){\n\t\tfor(i = 0; i < N ; i++){\n\t\t\tfor(j = 0; j < N ; j++){\n\t\t\t\ttmp[i][j] = Puzzle[i][j];\n\t\t\t}\n\t\t}\n\t\tc = dfs(a,b,-1,0,limit);\n\t\tif(c!= -1){\n\t\t\tprintf(\"%d\\n\",c);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(i = 0; i < N ; i++){\n\t\t\tfor(j = 0 ; j < N ; j++){\n\t\t\t\tPuzzle[i][j] = tmp[i][j];\n\t\t\t}\n\t\t}\n\t\tc =-1;\n\t\tif(limit == 49)printf(\"%d\\n\",c);\n\t}\n\n\treturn 0;\n}\n\nvoid empty(int *x,int *y){\n\tint i,j;\n\tfor(i = 0; i < N ; i++){\n\t\tfor(j = 0 ; j < N ; j++){\n\t\t\tif(!Puzzle[i][j]){\n\t\t\t\t*x = j;\n\t\t\t\t*y = i;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint dfs(int x,int y,int p, int dep, int lim){\n\tint i,j,h,n1,n2,res;\n\tint cp;\n\n\th = cal();\n\n\tif(h == 0)return dep;\n\tif(dep + h > lim) return -1;\n\n\tfor(i = 0; i< 4; i++){\n\t\tn1 = x + dx[i];\n\t\tn2 = y + dy[i];\n\n\t\tif(~p && i == (p+2)%4) continue;\n\t\tif(!(0 <= n1 && n1 < 3 && 0 <= n2 && n2 < 3)) continue;\n\n\t\tcp = Puzzle[y][x];\n\t\tPuzzle[y][x] = Puzzle[n2][n1];\n\t\tPuzzle[n2][n1] = cp;\n\n\t\tres = dfs(n1,n2,i,dep+1,lim);\n\t\tif(~res)return res;\n\n\t\tcp = Puzzle[y][x];\n\t\tPuzzle[y][x] = Puzzle[n2][n1];\n\t\tPuzzle[n2][n1] = cp;\n\n\t}\n\treturn -1;\n}\n\nint cal(void){\n\tint i,a;\n\tint sum = 0;\n\n\tfor(i = 0; i< N+6 ; i++){\n\t\ta = Puzzle[i/3][i%3];\n\t\tif(a){\n\t\t\ta--;\n\t\t\tsum += abs(i/3 - a/3)  + abs(i%3 - a%3);\n\t\t}\n\t}\n\treturn sum;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 362880 \n\ntypedef struct \n{\n\tint f[9];\n\tint space;\n\tint path;\n}P;\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\n\nint V[MAX];\n\nP Q[MAX];\nint head, tail;\n\nint kara()\n{\n    if (head == kara)\n\t    return 1;\n    else\n        return 0;  \n}\n\nvoid push(P x)\n{\n\tQ[tail] = x;\n\ttail = (tail+1)%MAX;\n}\n\nP front()\n{\n\tP x;\n\tx = Q[head];\n\thead = (head+1)%MAX;\n\treturn x;\n}\n\nint cheak(P p)\n{\n\tint i, j, fac, count, res = 0;\n\tfor(i = 0, fac = 1; i < 9; fac*= ++i)\n    {\n\t\tfor(j = 0, count = 0; j < i; j++)\n        {\n\t\t\tif(p.f[j] < p.f[i]) \n              count++;\n\t\t}\n\t\tres = res + (count*fac);\n\t}\n\treturn res;\t\n}\n\nint target(P p)\n{\n\tint i;\n\tfor(i = 0; i < 9; i++ )\n\t\tif(p.f[i] != (i + 1) ) return 0;\n\treturn 1;\n}\n\nint bfs(P s)\n{\n\tint sx, sy, tx, ty, r, temp;\n\tP u, v;\n\t\n\ts.path = 0;\n\t\n\tpush(s);\n\t\n\tV[cheak(s)] = 1;\n\t\n\twhile(!kara())\n    {\n\t\tu = front();\n\t\tif( target(u)) return u.path;\n\t\tsx = u.space / 3;\n\t\tsy = u.space % 3;\n\t\t\n\t\tfor ( r = 0; r < 4; r++ ) \n        {\n\t\t\ttx = sx + dx[r];\n\t\t\tty = sy + dy[r];\n\t\t\tif(tx < 0 || ty < 0 || tx >= 3 || ty >= 3) continue;\n\t\t\tv = u;\n\t\t\t\n\t\t\ttemp = v.f[u.space];\n\t\t\tv.f[u.space] = v.f[tx * 3 + ty];\n\t\t\tv.f[tx * 3 + ty] = temp;\n\t\t\t\n\t\t\tv.space = tx * 3 + ty;\n\t\t\t\n\t\t\tif( !V[cheak(v)] )\n            {\n\t\t\t\tV[cheak(v)] = 1;\n\t\t\t\tv.path++;\n\t\t\t\tpush(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint i, a;\n\tP in;\n\t\n\tfor( i = 0; i < 9; i++ ) \n    {\n\t\tscanf(\"%d\", &in.f[i]);\n\t\tif( in.f[i] == 0) \n        {\n\t\t\tin.f[i] = 9;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\t\n\ta = bfs(in);\n\tprintf(\"%d\\n\",a);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n \n#define N 3\n#define LIM 32\n#define HN 362897\n \nstruct dep{\n    int depth,key;\n};\n \nint ans[N][N]={\n    {1,2,3},\n    {4,5,6},\n    {7,8,0}\n    };\n \nint min = LIM;\nstruct dep h[HN];\n \nint hash1(int k)\n{\n    return k % HN;\n}\nint hash2(int k)\n{\n    return 1 + k%(HN-1);\n}\nint hash(int k, int i)\n{\n    return (hash1(k) + i*hash2(k))%HN;\n}\n \n \nvoid dfs(int p[N][N], int n)\n{\n    int i,j,i0,j0,a=0,b=1;\n    int f=0;\n    int tmp[N][N];\n    for(i=0;i<N;i++)\n    {\n        for(j=0;j<N;j++)\n        {\n            if(ans[i][j]!=p[i][j])f++;\n            if(p[i][j]==0)\n            {\n                i0=i;\n                j0=j;\n            }\n            a+=p[i][j]*b;\n            b*=10;\n        }\n    }\n     \n    if(f==0)\n    {\n        if(min>=n)\n        {\n            min=n;\n        }\n        return;\n    }\n    if(n>min) return;\n    i=0;\n    while(1)\n    {\n        b=hash(a, i);\n        if(h[b].key == 0)\n        {\n            h[b].key=a;\n            h[b].depth=n;\n            break;\n        }\n        else if(h[b].key == a)\n        {\n            if(h[b].depth>n)\n            {\n                h[b].depth=n;\n                break;\n            }\n            else return;\n        }\n        i++;\n    }\n     \n    if(i0>0 && i0<N)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0-1][j0];\n        tmp[i0-1][j0]=f;\n        dfs(tmp, n+1);\n    }\n    if(j0>0 && j0<N)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0][j0-1];\n        tmp[i0][j0-1]=f;\n        dfs(tmp, n+1);\n    }\n     \n    if(i0>=0 && i0<N-1)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0+1][j0];\n        tmp[i0+1][j0]=f;\n        dfs(tmp, n+1);\n    }\n    if(j0>=0 && j0<N-1)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0][j0+1];\n        tmp[i0][j0+1]=f;\n        dfs(tmp, n+1);\n    }\n     \n}\n \nint main()\n{\n    int i,j;\n    int p[N][N];\n     \n    for(i=0;i<N;i++)\n    {\n        for(j=0;j<N;j++)\n        {\n            scanf(\"%d\",&p[i][j]);\n        }\n    }\n    dfs(p,0);\n     \n    printf(\"%d\\n\",min);\n     \n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define N 3\n#define LIM 32\n#define HN 362897\n\nstruct dep{\n    int depth,key;\n};\n\nint ans[N][N]={\n    {1,2,3},\n    {4,5,6},\n    {7,8,0}};\n\nint min = LIM;\nstruct dep h[HN];\n\nint hash1(int k)\n{\n    return k % HN;\n}\nint hash2(int k)\n{\n    return 1 + k%(HN-1);\n}\nint hash(int k, int i)\n{\n    return (hash1(k) + i*hash2(k))%HN;\n}\n\n\nvoid dfs(int p[N][N], int n)\n{\n    int i,j,i0,j0,a=0,b=1;\n    int f=0;\n    int tmp[N][N];\n    //printf(\"A\\n\");\n    for(i=0;i<N;i++)\n    {\n        for(j=0;j<N;j++)\n        {\n            if(ans[i][j]!=p[i][j])f++;\n            if(p[i][j]==0)\n            {\n                i0=i;\n                j0=j;\n            }\n            a+=p[i][j]*b;\n            b*=10;\n        }\n    }\n    \n    if(f==0)\n    {\n        if(min>=n)\n        {\n            min=n;\n        }\n        return;\n    }\n    if(n>min) return;\n    i=0;\n    while(1)\n    {\n        b=hash(a, i);\n        if(h[b].key == 0)\n        {\n            h[b].key=a;\n            h[b].depth=n;\n            break;\n        }\n        else if(h[b].key == a)\n        {\n            if(h[b].depth>n)\n            {\n                h[b].depth=n;\n                break;\n            }\n            else return;\n        }\n        i++;\n    }\n    \n    if(i0>0 && i0<N)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0-1][j0];\n        tmp[i0-1][j0]=f;\n        dfs(tmp, n+1);\n    }\n    if(j0>0 && j0<N)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0][j0-1];\n        tmp[i0][j0-1]=f;\n        dfs(tmp, n+1);\n    }\n    \n    if(i0>=0 && i0<N-1)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0+1][j0];\n        tmp[i0+1][j0]=f;\n        dfs(tmp, n+1);\n    }\n    if(j0>=0 && j0<N-1)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0][j0+1];\n        tmp[i0][j0+1]=f;\n        dfs(tmp, n+1);\n    }\n    \n}\n\nint main()\n{\n    int i,j;\n    int p[N][N];\n    \n    for(i=0;i<N;i++)\n    {\n        for(j=0;j<N;j++)\n        {\n            scanf(\"%d\",&p[i][j]);\n        }\n    }\n    dfs(p,0);\n    \n    printf(\"%d\\n\",min);\n    \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\n#include<queue>\nusing namespace std;\n#define N 3\n#define N2 9\n \nstruct Puzzle{\n  int i,f[N2];\n  int space;\n  string path;\n \n  bool operator < (const Puzzle &p) const{\n\n    for(i = 0;i < N2;i ++)\n      {\n\tif(f[i] == p.f[i]) continue;\n\treturn f[i] > p.f[i];\n      }\n    return false;\n  }\n};\n \nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n \n \nint main(){\n\n  Puzzle in;\n\n  int i;\n\n  string ans;\n  \n  for(i = 0;i < N2;i ++)\n    {\n      cin >> in.f[i];\n      if(in.f[i] == 0)\n\t{\n\t  in.f[i] = N2;\n\t  in.space = i;\n\t}\n    }\n  ans = bfs(in);\n\n  cout << ans.size() << endl;\n \n  return 0;\n}\n\nbool isTarget(Puzzle p){\n\n  int i;\n  \n  for(i = 0;i < N2;i ++)\n    {\n      if(p.f[i] != (i + 1)) return false;\n    }\n  \n  return true;\n}\n \nstring bfs(Puzzle s){\n\n  int sx,sy,tx,ty,r;\n  \n  queue<Puzzle> Q;\n\n  map<Puzzle, bool> V;\n\n  Puzzle u, v;\n\n  s.path = \"\";\n\n  Q.push(s);\n\n  V[s] = true;\n \n  while(!Q.empty()){\n\n    u = Q.front();\n\n    Q.pop();\n\n    if(isTarget(u))return u.path;\n\n    sx = u.space / N;\n    sy = u.space % N;\n\n    for(r = 0;r < 4;r ++)\n      {\n\ttx = sx + dx[r];\n\tty = sy + dy[r];\n\n\tif(tx < 0 || ty < 0 || tx >= N || ty >= N)continue;\n       \n\tv = u;\n      \n\tswap(v.f[u.space], v.f[tx * N + ty]);\n      \n\tv.space = tx * N + ty;\n      \n\tif(!V[v]){\n\t  V[v] = true;\n\t  v.path += dir[r];\n\t  Q.push(v);\n\t}\n      }\n  }\n \n  return \"unsolvable\";\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n\nextern inline void down_0(void);\nextern inline void up_0(void);\nextern inline void right_0(void);\nextern inline void left_0(void);\n\nextern int  serch(int x, int y, int MaxCnt, int pre);\nextern int  check(void);\n\nint cnt,num = 0;\nint val[Total] ={};\n\n\nint main( void )\n{\n    int i = 0;\n    int x,y = 0;\n    \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        \n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n    \n    x = tate - (num/yoko) -1;\n    y = yoko - (num%yoko) -1;\n    \n//    printf(\"%d,%d\\n\",x,y);\n    \n    for(i=1; i<45; i++)\n    {\n        if( serch(x,y,i,4) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt, int pre)\n{\n    int result;\n    int i=0;\n    \n    // 最大数で打ち切り\n    if(MaxCnt==0)\n    {\n        return check();\n    }\n    \n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if( (x > 0) && (pre != 3) )\n                {\n                    down_0();\n                    \n                    result = serch(x-1, y, MaxCnt-1, 0);\n                    \n                    up_0();\n                }\n                break;\n            case 1:\n                if( (y > 0) && (pre != 2) )\n                {\n                    right_0();\n                    \n                    result = serch(x, y-1, MaxCnt-1, 1);\n                    \n                    left_0();\n                }\n                break;\n            case 2:\n                if( (y < yoko -1 ) && (pre != 1) )\n                {\n                    left_0();\n                    \n                    result = serch(x, y+1, MaxCnt-1, 2);\n                    \n                    right_0();\n                }\n                break;\n            case 3:\n                if( (x < tate -1 ) && (pre != 0) )\n                {\n                    up_0();\n                    \n                    result = serch(x+1, y, MaxCnt-1, 3);\n                    \n                    down_0();\n                }\n                break;\n            default:\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n        \n    }\n\n    return 0;\n}\n\n// TRUE : 完成\n// FALSE : 失敗\nint check()\n{\n    int i=0;\n    \n//    printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);\n    \n    for(i=0; i<Total-1; i++)\n    {\n        if(val[i] != (i+1))\n        {\n            return 0;\n        }\n    }\n    return 1;\n}\n\ninline void down_0()\n{\n    val[num] = val[num + yoko];\n    num = num + yoko;\n}\n \ninline void up_0()\n{\n    val[num] = val[num - yoko];\n    num = num - yoko;\n}\n \ninline void right_0()\n{\n    val[num] = val[num +1];\n    num = num + 1;\n}\n \ninline void left_0()\n{\n    val[num] = val[num -1];\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib>\n\n int puzle[3][3];\n int tmp[3][3;\n int d1[4]={0,1,0,-1};\n int d2[4]={1,0,-1,0};\n \n void empty(int *x,int *y){\n                           int i,j;\n                           for(i=0;i<3;i++){\n                                            for(j=0;j<3;j++){\n                                                             if(!puzle[i][j]){\n                                                                              *x=j;\n                                                                              *y=i;\n                                                                              return;\n                                                                              }\n                                                              }\n                                             }\n                            }\n\n void swap(int *a,int *b){\n                          int tmp=*a;\n                          *a=*b;\n                          *b=tmp;\n                          }\n\n int cal(){\n           int a,i,sum=0;\n           for(i=0;i<9;i++){\n                            a=puzle[i/3][i%3];\n                            if(a){\n                                  a--;\n                                  sum+=abs(i/3-a/3)+abs(i%3-a%3);\n                                  }\n                            }\n           return sum;\n           }\n\n int dfs(int x,int y,int p,int dep,const int lim){\n       int i,h,n1,n2,res;\n       h=cal();\n       if(h==0){\n                return dep;\n                }\n       if(dep+h>lim){\n                     return -1;\n                     }\n       for(i=0;i<4;++i){\n                        n1=x+d1[i];\n                        n2=y+d2[i];\n \n                        if(~p&&i==(p+2)%4)continue;\n                        if(!(0<=n1&&n1<3&&0<=n2&&n2<3))continue;\n                        swap(&puzle[y][x],&puzle[n2][n1]);\n                        res=dfs(n1,n2,i,dep+1,lim);\n\n                        if(~res)return res;\n \n                        swap(&puzle[y][x],&puzle[n2][n1]);\n                        }\n       return -1; \n       }\n\n int main(){\n            int ans,x,y,l,i,j;\n\n            for(i=0;i<3;i++){\n                             for(j=0;j<3;j++){\n                                              scanf(\"%d\",&puzle[i][j]);\n                                              }\n                             }\n            empty(&x,&y);\n            for(l=0;l<100;l++){\n                               for(i=0;i<3;i++){\n                                                for(j=0;j<3;j++){\n                                                                 tmp[i][j]=puzle[i][j];\n                                                                 }\n                                                }\n                                ans=dfs(x,y,-1,0,1);\n                                if(ans!=-1){\n                                            printf(\"%d\\n\",ans);\n                                            break;\n                                            }\n                                for(i=0;i<3;i++){\n                                                 for(j=0;j<3;j++){\n                                                                  puzle[i][j]=tmp[i][j];\n                                                                  }\n                                                 }\n                                ans=-1;\n                                if(l==99)printf(\"%d\\n\",ans);\n                                }\n            return 0;\n            }\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX 3\n\nint pane[MAX][MAX];\nint temp[MAX][MAX];\nint d_x[4]={0,1,0,-1};\nint d_y[4]={1,0,-1,0};\n\nvoid empty(int *row,int *col){\n  int i,j;\n  for(i=0;i<MAX;i++)\n    for(j=0;j<MAX;j++)\n      if(!pane[i][j]){\n\t*row=j;\n\t*col=i;\n\treturn;\n      }  \n}\n   \nvoid swap(int *a,int *b){\n  int temp;\n  temp = *a;*a = *b;*b = temp;\n}\n  \nint cal(){\n  int i,e;\n  int count=0; \n  for(i=0;i<9;i++){\n    e=pane[i/3][i%3];\n    if(e){\n      e--;\n      count+=abs(i/3-e/3)+abs(i%3-e%3);\n    }\n  }   \n  return count;\n}\n  \nint dfs(int x,int y,int p,int deep,const int limt){\n  int i;\n  int len;\n  int x_2,y_2;\n  int emc;   \n  len=cal();\n  if(len==0) return deep;\n  if(deep+len>limt) return -1; \n  for(i=0;i<4;i++){\n    x_2=x+d_x[i];\n    y_2=y+d_y[i];      \n    if(~p&&i==(p+2)%4) continue;\n    if(!(0<=x_2 && x_2<3 && 0<=y_2 && y_2<3)) continue;    \n    swap(&pane[y][x],&pane[y_2][x_2]);\n    emc=dfs(x_2,y_2,i,deep+1,limt);\n    if(~emc) return emc;       \n    swap(&pane[y][x],&pane[y_2][x_2]);\n  }   \n  return -1;\n} \n\nint main() {\n  int i,j;\n  int h,a,row,col;\n      \n  for(i=0;i<MAX;i++){\n    for(j=0;j<MAX;j++)\n      scanf(\"%d\",&pane[i][j]);\n  }  \n  empty(&row,&col);  \n  for(h=0;h<100;h++){\n    for(i=0;i<MAX;i++){\n      for(j=0;j<MAX;j++)\n\ttemp[i][j]=pane[i][j];\n    }    \n    a=dfs(row,col,-1,0,h);    \n    if(a!=-1){\n      printf(\"%d\\n\",a);\n      break;\n    }    \n    for(i=0;i<MAX;i++){\n      for(j=0;j<MAX;j++)\n\tpane[i][j]=temp[i][j];\n    }    \n    a=-1;\n    if(h==99) printf(\"%d\\n\\n\",a);\n  }      \n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n  \n#define N 3\n#define L 32\n#define H 362897\n  \nstruct dep {\n    int depth, key;\n};\n  \nint ans[N][N] = {\n    {1, 2, 3},\n    {4, 5, 6},\n    {7, 8, 0}};\n  \nint min = L;\nstruct dep h[H];\n  \nint hash1(int k) {\n    return k % H;\n}\n\nint hash2(int k) {\n    return 1 + k % (H-1);\n}\n\nint hash(int k, int i) {\n    return (hash1(k) + i * hash2(k)) % H;\n}\n  \nvoid dfs(int p[N][N], int n) {\n    int i, j, i1, j1, a = 0, b = 1;\n    int f = 0;\n    int tmp[N][N];\n    for (i=0;i<N;i++) {\n        for (j = 0; j<N; j++) {\n            if (ans[i][j] != p[i][j]) f++;\n            if(p[i][j] == 0) {\n                i1 = i;\n                j1 = j;\n            }\n            a += p[i][j] * b;\n            b *= 10;\n        }\n    }\n\n    if (f == 0) {\n        if(min >= n) {\n            min = n;\n        }\n        return;\n    }\n    if(n > min) return;\n    i = 0;\n    while(1) {\n        b = hash(a, i);\n        if (h[b].key == 0) {\n            h[b].key = a;\n            h[b].depth = n;\n            break;\n        }\n        else if (h[b].key == a) {\n            if (h[b].depth > n) {\n                h[b].depth = n;\n                break;\n            }\n            else return;\n        }\n        i++;\n    }\n      \n    if(i1 > 0 && i1 < N) {\n        memcpy(tmp, p, sizeof(int) * N * N);\n        f = tmp[i1][j1];\n        tmp[i1][j1] = tmp[i1 - 1][j1];\n        tmp[i1 - 1][j1] = f;\n        dfs(tmp, n + 1);\n    }\n    if(j1 > 0 && j1 < N) {\n        memcpy(tmp, p, sizeof(int) * N * N);\n        f = tmp[i1][j1];\n        tmp[i1][j1] = tmp[i1][j1 - 1];\n        tmp[i1][j1 - 1] = f;\n        dfs(tmp, n + 1);\n    }\n      \n    if(i1 >= 0 && i1 < N - 1) {\n        memcpy(tmp, p, sizeof(int) * N * N);\n        f = tmp[i1][j1];\n        tmp[i1][j1] = tmp[i1 + 1][j1];\n        tmp[i1 + 1][j1] = f;\n        dfs(tmp, n + 1);\n    }\n    if(j1 >= 0 && j1 < N - 1) {\n        memcpy(tmp, p, sizeof(int) * N * N);\n        f = tmp[i1][j1];\n        tmp[i1][j1] = tmp[i1][j1 + 1];\n        tmp[i1][j1 + 1] = f;\n        dfs(tmp, n + 1);\n    }\n}\n  \nint main(void)\n{\n    int i, j;\n    int p[N][N];\n      \n    for (i = 0; i < N; i++) {\n        for (j = 0; j < N; j++) {\n            scanf(\"%d\", &p[i][j]);\n        }\n    }\n    dfs(p, 0);\n      \n    printf(\"%d\\n\", min);\n      \n    return 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define YOKO 3\n#define TATE 3\n\nint DFS(int P[TATE][YOKO],int,int);\nint koukanmae(int,int,int);\nvoid koukan(int P[TATE][YOKO],int irekae2[TATE][YOKO],int,int,int);\nint Heuristic(int s[TATE][YOKO]);\n\nint Ans[TATE][YOKO]={1,2,3,4,5,6,7,8,0};//答\nint puzzle[TATE][YOKO];//問題\nint irekae[TATE][YOKO];//仮puzzle\n\nint clear=100000;\nint limit;//深さの限度\n\nint x[4]={0,1,0,-1},y[4]={-1,0,1,0};\n\n/*\n\n＊＊＊x[4],y[4]について＊＊＊\n\nx[4]とy[4]はマスとマスを入れ替える時にセットで用いる。\nなぜ配列に入れるかというと、for文でまとめて入替作業ができるからである。\n\nくわしくは関数をみよ。\n\n*/\n\n\nint main()\n{\n  int i,j;\n\n  /*問題のパズルを代入*/\n  \n  for(i=0;i<TATE;i++)\n    {\n      for(j=0;j<YOKO;j++)\n\t{\n\t  scanf(\"%d\",&puzzle[i][j]);\n\t}\n    }\n\n  while(1)\n    {\n      if(DFS(puzzle,-1,0)==1)break;\n      limit++;\n    }\n\n  printf(\"%d\\n\",clear);\n\n  return 0;\n}\n\nint DFS(int P[TATE][YOKO],int not,int hukasa)\n{\n\n  int i,j,a,b;\n  int zx,zy;//０の位置特定\n  int hantei=1;\n  int OK;\n  int irekae2[TATE][YOKO];\n  int H;\n  int hata=0;\n  \n  /*puzzleがAnsとあっているか判定*/\n\n  for(i=0;i<TATE;i++)\n    {\n      for(j=0;j<YOKO;j++)\n\t{\n\t  if(P[i][j]!=Ans[i][j])\n\t    {\n\t      hantei=0;\n\t    }\n\t   if(P[i][j]==0)\n\t\t{\n\t\t  zy=i;\n\t\t  zx=j;\n\t\t}\n\t}\n    }\n\n  if(hantei==1)\n    {\n      clear=hukasa;\n      return 1;//あっていたら1返す。\n    }\n  else\n    {\n      for(i=0;i<4;i++)\n\t{\n\t  if((i+2)%4==not)continue;\n\t  \n\t  if(koukanmae(zx,zy,i)==1)\n\t    {\n\t      koukan(P,irekae2,zx,zy,i);\n\t\t  \n\t      H=Heuristic(irekae2);\n\n\t      if(hukasa+H<=limit)\n\t\t{\t\t\n\t\t  hata=DFS(irekae2,i,hukasa+1);\n\t\t  if(hata==1)return 1;\n\t\t}\n\t    }\n\t  \n\t}\n    }\n  return 0;\n}\n\n\nint koukanmae(int zx,int zy,int i)\n{\n  if( zx+x[i]>=YOKO || zx+x[i]<0\n      || zy+y[i]>=TATE || zy+y[i]<0 )\n    {\n      return 0;\n    }\n  else\n    {\n      return 1;\n    }\n}\n\n\nvoid koukan(int P[TATE][YOKO],int irekae2[TATE][YOKO],int zx,int zy,int i)\n{\n  int j,k,koukan;\n  \n  for(j=0;j<TATE;j++)\n    {\n      for(k=0;k<YOKO;k++)\n\t{\n\t  irekae2[j][k]=P[j][k];\n\t}\n    }\n  \n  koukan = irekae2[ zy +y[i] ][ zx+x[i] ];\n  irekae2[zy][zx]=koukan;\n  irekae2[ zy +y[i] ][ zx+x[i] ]=0;\n\n  }\n\n\nint Heuristic(int s[TATE][YOKO])\n{\n  int i,j,k=0,H2=0,cell[9],kyori=0;\n\n  for(i=0;i<TATE;i++)\n    {\n      for(j=0;j<YOKO;j++)\n\t{\n\t  cell[k]=s[i][j];\n\t  k++;\n\t}\n    }\n  for(i=0;i<9;i++)\n    {\n      if(cell[i]!=0)\n\t{\n\t  kyori+=abs((cell[i]-1)%3-i%3);\n\n\t  kyori+=abs((cell[i]-1)/3-i/3);\n\t}\n    }\n  \n\n  return kyori;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ ALDS1_13_B 8 Puzzle\n// 2018.5.8 bal4u\n\n#include <stdio.h>\n\ntypedef unsigned char uchar;\n\n#define HASHSIZ 543217    // 181441\ntypedef struct { unsigned s; char x, v; } HASH;\nHASH hash[HASHSIZ+3], *hashend = hash+HASHSIZ;\n\nint lookup(unsigned s, int x)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) return hp->v;\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\treturn 0;\n}\n\nvoid insert(unsigned s, int x, char v)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) { hp->v = v; break; }\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\thp->s = s, hp->x = x, hp->v = v;\n}\n\n#define QMAX 30000\ntypedef struct { unsigned s; char x, v; } T;\nT s[QMAX+3]; int top, end;\nint hi[9] = {2,3,2,3,4,3,2,3,2};\nint to[9][4] = {{1,3},{0,2,4},{1,5},{0,4,6},{1,3,5,7},{2,4,8},{3,7},{4,6,8},{5,7}};\n\nvoid toArray(char *nine, unsigned s, int x)\n{\n\tint i;\n\t\n\tfor (i = 8; i >= 0; i--) {\n\t\tif (i == x) nine[i] = 0;\n\t\telse nine[i] = s & 0xf, s >>= 4;\n\t}\n}\n\nunsigned swap(char *nine, int zero, int nx)\n{\n\tint i;\n\tunsigned res;\n\t\n\tres = 0;\n\tfor (i = 0; i < 9; i++) {\n\t\tif      (i == zero) res <<= 4, res |= nine[nx];\n\t\telse if (i != nx)   res <<= 4, res |= nine[i];\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint i;\n\tint x, nx, v, nv, t;\n\tunsigned a, na;\n\tunsigned gs; int gx;\t// goal\n\tchar nine[9];\n\t\n\tgs = 0; for (i = 0; i < 9; i++) {\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 0) gx = i;\n\t\telse gs <<= 4, gs |= t;\n\t}\n\ts[0].s = 0x12345678, s[0].x = 8, s[0].v = 0;\n\ttop = 0, end = 1;\n\tinsert(s[0].s, s[0].x, 0);\n\twhile (top != end) {\n\t\ta = s[top].s, x = s[top].x, v = s[top].v;\n\t\tif (++top == QMAX) top = 0; \n\t\tif (x == gx && a == gs) break;\n\t\tif (lookup(a, x) < v) continue;\n\n\t\ttoArray(nine, a, x);\n\t\tfor (i = 0; i < hi[x]; i++) {\n\t\t\tnx = to[x][i];\n\t\t\tna = swap(nine, x, nx), nv = v+1;\n\t\t\tt = lookup(na, nx);\n\t\t\tif (!t || nv < t) {\n\t\t\t\ts[end].s = na, s[end].x = nx, s[end].v = nv;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t\tinsert(na, nx, nv);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", v);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,1,0,-1};\n \nint calculateHeuristic(int board[3][3]) {\n    int res = 0;\n    int a, i, j;\n    \n    for (i = 0; i < 3; i++)\n        for (j = 0; j < 3; j++) {\n            if (board[i][j] == 0) continue;\n            a = board[i][j] - 1;\n            res += abs(a / 3 - i) + abs(a % 3 - j);\n        }\n    \n    return res;\n}\n\nvoid swap(int * a, int * b) {\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n\nint check(int board[3][3], int limit, int depth, int prev, int py, int px) {\n    int heuriScore = calculateHeuristic(board);\n    \n    if (heuriScore + depth > limit) return 0;\n    \n    // same board!! success!\n    if (heuriScore == 0) return 1;\n    \n    for (int i = 0; i < 4; i++) {\n        if (abs(i - prev) == 2) \n            continue;\n        \n        // new position\n        int ny = py + dy[i];\n        int nx = px + dx[i];\n        \n        // skip if swapping is out of boundary\n        if (ny <  0 || nx <  0 || ny >= 3 || nx >= 3) \n            continue;\n        \n        // try swapping\n        swap(&board[ny][nx], &board[py][px]);\n        \n        // return if success\n        if (check(board, limit, depth + 1, i, ny, nx))\n            return 1;\n        \n        // not work, swap back\n        swap(&board[ny][nx], &board[py][px]);\n    }\n    \n    return 0;\n}\n \nvoid solve(int board[3][3], int py, int px) {\n    int limit = 0;\n    \n    while (1) {\n        if (check(board, limit, 0, 99, py, px)) {\n            printf(\"%d\\n\", limit);\n            return;\n        }\n        limit++;\n    }\n}\n \nint main(int argc, char** argv) {\n    int py, px, i, j;\n    int board[3][3];\n    \n    for (i = 0; i < 3; i++)\n        for (j = 0; j < 3; j++) {\n            scanf(\"%d\", &board[i][j]);\n            \n            if (board[i][j] == 0) {\n                py = i;\n                px = j;\n            }\n        }\n\n    solve(board, py, px);\n    \n    return (EXIT_SUCCESS);\n}\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n// I/O\nint get_uint() {\n    int n = 0;\n    int c = getchar_unlocked();\n    if(c < 48 || 57 < c) return c;\n    while(47 < c && c < 58) n = 10 * n + (c & 0xf), c = getchar_unlocked();\n    return n;\n}\nvoid put_uint(int n) {\n    if(!n) {\n        putchar_unlocked('0');\n        return;\n    }\n    char buf[11];\n    int i = 0;\n    while(n) buf[i++] = (char)(n % 10 + '0'), n /= 10;\n    while(i--)putchar_unlocked(buf[i]);\n}\n\n\n// Node\ntypedef struct NodeKey {\n    int board[9];\n    int space;\n    int cnt;\n} NodeKey;\n// lt: -1, gt: 1, eq: 0\nint cmp_node(const NodeKey *l, const NodeKey *r) {\n    for(int i = 0; i < 9; ++i) {\n        if(l->board[i] == r->board[i]) continue;\n        else if(l->board[i] < r->board[i]) return -1;\n        else return 1;\n    }\n    return 0;\n}\n\n\n// Treap\ntypedef struct Node {\n    NodeKey key;\n    int priority;\n    struct Node *left, *right;\n} Node;\ntypedef struct BST {\n    Node *root;\n    size_t size;\n} BST;\nvoid bst_init(BST *BST) {\n    BST->root = NULL;\n    BST->size = 0;\n}\nNode *bst_rotate_right(Node *root) {\n    Node *tmp = root->left;\n    root->left = tmp->right;\n    tmp->right = root;\n    return tmp;\n}\nNode *bst_rotate_left(Node *root) {\n    Node *tmp = root->right;\n    root->right = tmp->left;\n    tmp->left = root;\n    return tmp;\n}\nNode *bst__insert(Node *root, const NodeKey key, const int priority) {\n    if(root == NULL) {\n        Node *new_node = malloc(sizeof(Node));\n        new_node->key = key;\n        new_node->priority = priority;\n        new_node->left = new_node->right = NULL;\n        return new_node;\n    }\n    if(cmp_node(&key, &root->key) == 0) return root;\n    if(cmp_node(&key, &root->key) == -1) {\n        root->left = bst__insert(root->left, key, priority);\n        if(root->priority < root->left->priority) root = bst_rotate_right(root);\n    } else {\n        root->right = bst__insert(root->right, key, priority);\n        if(root->priority < root->right->priority) root = bst_rotate_left(root);\n    }\n    return root;\n}\nvoid bst_insert(BST *BST, const NodeKey key, const int priority) {\n    BST->root = bst__insert(BST->root, key, priority);\n    BST->size++;\n}\nNode *bst_find(Node *root, const NodeKey key) {\n    while(root != NULL && cmp_node(&key, &root->key)) {\n        if(cmp_node(&key, &root->key) == -1) root = root->left;\n        else root = root->right;\n    }\n    return root;\n}\n\n\n// Queue\n#define QueueKey NodeKey\ntypedef struct QueueDat {\n    QueueKey key;\n    struct QueueDat *next;\n} QueueDat;\ntypedef struct Queue {\n    size_t len;\n    QueueDat *head;\n    QueueDat *tail;\n} Queue;\n#define queue_init(q) ((q) ? ((q)->len = 0, (q)->head = (q)->tail = NULL) : 0)\n#define queue_len(q) ((q) ? (q)->len : 0)\nvoid queue_push(Queue *q, QueueKey x) {\n    QueueDat *new_dat = malloc(sizeof(QueueDat));\n    *new_dat = (QueueDat){x, NULL};\n    if(q->len) {\n        q->tail->next = new_dat;\n        q->tail = new_dat;\n    } else {\n        q->head = q->tail = new_dat;\n    }\n    q->len++;\n}\nQueueKey queue_pop(Queue *q) {\n    QueueDat *old_head = q->head;\n    q->head = old_head->next;\n    QueueKey key = old_head->key;\n    free(old_head);\n    q->len--;\n    return key;\n}\n\n\n// end condition\nint is_solved(const int board[9]) {\n    for(int i = 0; i < 8; ++i)\n        if(board[i] != i + 1) return 0;\n    return 1;\n}\n\n\n// solve\nint bfs(NodeKey s) {\n    const int N = 3;\n    const int dx[4] = {-1, 0, 1, 0};\n    const int dy[4] = {0, -1, 0, 1};\n    srand((unsigned)time(NULL));\n    BST BST;\n    bst_init(&BST);\n    bst_insert(&BST, s, rand());\n    Queue Q;\n    queue_init(&Q);\n    queue_push(&Q, s);\n    while(queue_len(&Q)) {\n        NodeKey key = queue_pop(&Q);\n        if(is_solved(key.board)) return key.cnt;\n        int x = key.space % N;\n        int y = key.space / N;\n        for(int i = 0; i < 4; ++i) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(nx < 0 || N <= nx || ny < 0 || N <= ny) continue;\n\n            int next_space = nx + ny * N;\n            NodeKey next_key = key;\n            next_key.board[key.space] = next_key.board[next_space];\n            next_key.board[next_space] = 0;\n            next_key.space = next_space;\n            if(bst_find(BST.root, next_key)) continue;\n\n            next_key.cnt++;\n            bst_insert(&BST, next_key, rand());\n            queue_push(&Q, next_key);\n        }\n    }\n}\n\n\nint main(int argc, char **argv) {\n    NodeKey initial;\n    initial.cnt = 0;\n    for(int i = 0; i < 9; ++i) {\n        int x = get_uint();\n        initial.board[i] = x;\n        if(x == 0) initial.space = i;\n    }\n    put_uint(bfs(initial));\n    putchar_unlocked('\\n');\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n\n#define MAX 362880 //9の階乗\n#define N 3\n#define N2 9\n\n/*\n螺旋本の解答例`似せてc言語で書いてみた\n*/\n\ntypedef struct puzzle{\n\tint f[N2];\n\tint space;\n\tint path;\n}Puzzle;\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\n\nint V[MAX];\n\n// QUEUE --------\n\nPuzzle Q[MAX];\nint head, tail;\n\nint empty(){\n\treturn head == tail;\n}\n\nvoid push(Puzzle x){\n\tQ[tail] = x;\n\ttail = (tail+1)%MAX;\n}\n\nPuzzle front(){\n\tPuzzle x;\n\tx = Q[head];\n\thead = (head+1)%MAX;\n\treturn x;\n\t\n}\n\n// QUEUE --------\n\n\n/* \nint cheak(Puzzle p)\n1から9までの数を並び替えた数列をすべて列挙して辞書順に並び替えたとき以下の数列\np.f[8],p.f[7],p.f[6].......p.[0]\nが前から何番目にあるかを返す関数\n*/\nint cheak(Puzzle p){\n\tint i, j, fac, count, res = 0;\n\tfor(i = 0, fac = 1; i < N2; fac*= ++i){\n\t\tfor(j = 0, count = 0; j < i; j++){\n\t\t\tif(p.f[j] < p.f[i]) count++;\n\t\t\n\t\t}\n\t\tres += count*fac;\n\t}\n\t\n\treturn res;\t\n}\n\nint isTarget(Puzzle p){\n\tint i;\n\tfor(i = 0; i < N2; i++ )\n\t\tif(p.f[i] != (i + 1) ) return 0;\n\treturn 1;\n}\n\nint bfs(Puzzle s){\n\tint sx, sy, tx, ty, r, temp;\n\tPuzzle u, v;\n\t\n\ts.path = 0;\n\t\n\tpush(s);\n\t\n\tV[cheak(s)] = 1;\n\t\n\twhile(!empty()){\n\t\tu = front();\n\t\tif( isTarget(u)) return u.path;\n\t\tsx = u.space / N;\n\t\tsy = u.space % N;\n\t\t\n\t\tfor ( r = 0; r < 4; r++ ) {\n\t\t\ttx = sx + dx[r];\n\t\t\tty = sy + dy[r];\n\t\t\tif(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\t\t\tv = u;\n\t\t\t\n\t\t\ttemp = v.f[u.space];\n\t\t\tv.f[u.space] = v.f[tx * N + ty];\n\t\t\tv.f[tx * N + ty] = temp;\n\t\t\t\n\t\t\tv.space = tx * N + ty;\n\t\t\t\n\t\t\tif( !V[cheak(v)] ){\n\t\t\t\tV[cheak(v)] = 1;\n\t\t\t\tv.path++;\n\t\t\t\tpush(v);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn -1;\n}\n\nint main(){\n\tint i, ans;\n\tPuzzle in;\n\t\n\tfor( i = 0; i < N2; i++ ) {\n\t\tscanf(\"%d\", &in.f[i]);\n\t\tif( in.f[i] == 0) {\n\t\t\tin.f[i] = N2;\n\t\t\tin.space = i;\n\t\t}\n\t}\n\t\n\tans = bfs(in);\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n \n#define N 3\n#define LIM 32\n#define HN 362897\n \nstruct dep{\n    int depth,key;\n};\n \nint ans[N][N]={\n    {1,2,3},\n    {4,5,6},\n    {7,8,0}};\n \nint min = LIM;\nstruct dep h[HN];\n \nint hash1(int k){\n    return k % HN;\n}\nint hash2(int k){\n    return 1 + k%(HN-1);\n}\nint hash(int k, int i){\n    return (hash1(k) + i*hash2(k))%HN;\n}\n \n \nvoid dfs(int p[N][N], int n){\n    int i,j,i0,j0,a=0,b=1;\n    int f=0;\n    int tmp[N][N];\n    //printf(\"A\\n\");\n    for(i=0;i<N;i++)\n    {\n        for(j=0;j<N;j++)\n        {\n            if(ans[i][j]!=p[i][j])f++;\n            if(p[i][j]==0)\n            {\n                i0=i;\n                j0=j;\n            }\n            a+=p[i][j]*b;\n            b*=10;\n        }\n    }\n     \n    if(f==0)\n    {\n        if(min>=n)\n        {\n            min=n;\n        }\n        return;\n    }\n    if(n>min) return;\n    i=0;\n    while(1)\n    {\n        b=hash(a, i);\n        if(h[b].key == 0)\n        {\n            h[b].key=a;\n            h[b].depth=n;\n            break;\n        }\n        else if(h[b].key == a)\n        {\n            if(h[b].depth>n)\n            {\n                h[b].depth=n;\n                break;\n            }\n            else return;\n        }\n        i++;\n    }\n     \n    if(i0>0 && i0<N)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0-1][j0];\n        tmp[i0-1][j0]=f;\n        dfs(tmp, n+1);\n    }\n    if(j0>0 && j0<N)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0][j0-1];\n        tmp[i0][j0-1]=f;\n        dfs(tmp, n+1);\n    }\n     \n    if(i0>=0 && i0<N-1)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0+1][j0];\n        tmp[i0+1][j0]=f;\n        dfs(tmp, n+1);\n    }\n    if(j0>=0 && j0<N-1)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0][j0+1];\n        tmp[i0][j0+1]=f;\n        dfs(tmp, n+1);\n    }\n     \n}\n \nint main(){\n    int i,j;\n    int p[N][N];\n     \n    for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n            scanf(\"%d\",&p[i][j]);\n        }\n    }\n    dfs(p,0);\n     \n    printf(\"%d\\n\",min);\n     \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint V[1000000],dx[4]={-1,0,1,0},dy[4]={0,-1,0,1},head=0,tail=0;\n\nstruct P{\n  int f[9];\n  int space;\n  int path;\n};\n\nstruct P Q[1000000];\n\nvoid enqueue(struct P a){\n  int next=(tail+1)%1000000;\n  Q[tail]=a;\n  tail=next;\n}\n\nstruct P dequeue(){\n  struct P b;\n  b=Q[head];\n  head=(head+1)%1000000;\n  return b;\n}\n\nint sort(struct P p){\n  int i,j,k,cnt,a=0;\n  for(i=0,k=1;i<9;k*=++i){\n    for(j=0,cnt=0;j<i;j++){\n      if(p.f[j]<p.f[i]){\n\tcnt++;\n      }\n    }\n    a+=cnt*k;\n  }\n  return a;\n}\n\nint isTarget(struct P p){\n  int i;\n  for(i=0;i<9;i++){\n    if(p.f[i]!=i+1){\n      return 0;\n    }\n  }\n  return 1;\n}\n\nint bfs(struct P s){\n  int r,a,sx,sy,tx,ty;\n  struct P u,v;\n  s.path=0;\n  enqueue(s);\n  V[sort(s)]=1;\n  while(head!=tail){\n    u=dequeue();\n    if(isTarget(u)==1){\n      return u.path;\n    }\n    sx=u.space/3;\n    sy=u.space%3;\n    for(r=0;r<4;r++){\n      tx=sx+dx[r];\n      ty=sy+dy[r];\n      if(tx<0||ty<0||tx>=3||ty>=3){\n\tcontinue;\n      }\n      v=u;\n      a=v.f[u.space];\n      v.f[u.space]=v.f[tx*3+ty];\n      v.f[tx*3+ty]=a;\n      v.space=tx*3+ty;\n      if(V[sort(v)]!=1){\n\tV[sort(v)]=1;\n\tv.path++;\n\tenqueue(v);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int i;\n  struct P in;\n  for(i=0;i<9;i++){\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i]==0){\n      in.f[i]=9;\n      in.space=i;\n    }\n  }\n  printf(\"%d\\n\",bfs(in));\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define N 3\n#define N1 4\n#define N2 9\n#define N3 100\nint puz[N][N];\nint tmp[N][N];\nint dx[N1]={0,1,0,-1};\nint dy[N1]={1,0,-1,0};\nvoid empty(int x[],int y[]) {\n  int i,j;\n  for(i=0;i<N;i++) {\n    for(j=0;j<N;j++) {\n      if(!puz[i][j]) {\n        *x = j;\n        *y = i;\n        return;\n      }\n    }\n  }\n}\nvoid swap(int a[],int b[]){\n  int tmp;\n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\nint cal(){\n  int i,a,sum=0;\n  for(i=0; i<N2; i++){\n    a = puz[i/N][i%N];\n    if(a){\n      a--;\n      sum+=abs((i/N)-(a/N))+abs((i%N)-(a%N));\n    }\n  }\n  return sum;\n}\nint dfs(int x,int y,int p,int dep,const int lim){\n  int i,h,nx,ny,res;\n  h=cal();\n  if(h==0) return dep;\n  if(dep+h>lim) return -1;\n  for(i=0;i<N1;i++){\n    nx=x+dx[i];\n    ny=y+dy[i];\n    if(~p && i==(p+2)%N2) continue;\n    if(!(0<=nx && nx<N && 0<=ny && ny<N)) continue;\n    swap(&puz[y][x],&puz[ny][nx]);\n    res = dfs(nx,ny,i,dep+1,lim);\n    if(~res) return res;\n    swap(&puz[y][x],&puz[ny][nx]);\n  }\n  return -1;\n}\nint main() {\n  int i,j,ans,x,y,l;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++) scanf(\"%d\",&puz[i][j]);\n  }\n  empty(&x,&y);\n  for(l=0;l<N3;l++){\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++) tmp[i][j] = puz[i][j];\n    }\n    ans=dfs(x,y,-1,0,l);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++) puz[i][j] = tmp[i][j];\n    }\n    ans = -1;\n    if(l==N3-1) printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define N 9\n#define INF 330000\n\nint ans[N]={1,2,3,4,5,6,7,8,0};\nint head=0,tail=0,cnt=0;\n\nstruct qu{\n  int s[N];\n};\n\nstruct node{\n  int key;\n  struct node *parent,*left,*right;\n};\n\nstruct node *root,*NIL;\nstruct qu Q[INF];\n\nvoid enqueue(struct qu x){\n\n  int next=tail+1;\n  Q[tail]=x;\n  tail=next;\n}\nstruct qu dequeue(void){\n  struct qu x;\n\n  x=Q[head];\n  head=head+1;\n  return x;\n}\n\nint find(struct node *u, int k){\n  while(u!=NIL&&k!=u->key){\n    if(k<u->key) u=u->left;\n    else u=u->right;\n  }\n  if(u!=NIL) return 1;\n  else return 0;\n}\n\nint insert(struct qu a){\n  int k,i,j;\n\n  for(i=0;i<=N;i++){\n    if(i==0) k+=a.s[i];\n    else{\n      for(j=0;j<i;j++) a.s[i]*=10;\n      k+=a.s[i];\n    }\n  }\n\n  if(find(root,k)==1) return 0;\n\n  struct node *y=NIL;  //xの親\n  struct node *x=root;\n  struct node *z;\n\n  z=(struct node*)malloc(sizeof(struct node));\n\n  z->key=k;\n  z->left=NIL;\n  z->right=NIL;\n\n  while(x!=NIL){\n    y=x;\n    if(z->key<x->key) x=x->left;\n    else x=x->right;\n  }\n\n  z->parent=y;\n\n  if(y==NIL) root=z;\n  else if(z->key<y->key) y->left=z;\n  else y->right=z;\n\n  return 1;\n}\n\nint trade(){\n  int tmp,i,flag,loc,h[INF],sum;\n  struct qu a,b,c,d,y;\n\n  h[head]=0;\n\n  while(1){\n\n    sum=h[head];\n    y=dequeue();\n\n    flag=0;\n\n    for(i=0;i<N;i++){\n      if(y.s[i]!=ans[i]) flag=1;\n      if(y.s[i]==0) loc=i; //０の位置を記録\n    }\n    if(flag==0) break;\n\n    a=b=c=d=y;\n\n    /*\n      ０を移動させるとして　aは上　bは右　cは下　dは左\n      条件を満たす場合０と交換して、ヒューリスティック探索を行う\n    */\n    if(loc%3!=0){tmp=a.s[loc-1]; a.s[loc-1]=0; a.s[loc]=tmp;\n          if(insert(a)==1){ enqueue(a); h[tail-1]=(sum+1);}}\n\n    if(loc%3!=2){ tmp=b.s[loc+1]; b.s[loc+1]=0; b.s[loc]=tmp;\n      if(insert(b)==1){ enqueue(b); h[tail-1]=(sum+1);}}\n\n    if(loc<6){tmp=c.s[loc+3]; c.s[loc+3]=0; c.s[loc]=tmp;\n      if(insert(c)==1){ enqueue(c); h[tail-1]=(sum+1);}}\n\n    if(loc>2){tmp=d.s[loc-3]; d.s[loc-3]=0; d.s[loc]=tmp;\n      if(insert(d)==1){ enqueue(d); h[tail-1]=(sum+1);}}\n  }\n\n  return sum;\n}\n\nint main(){\n  int i,j,sum,a;\n  struct qu x;\n\n  for(i=0;i<N;i++){\n    scanf(\"%d\",&x.s[i]);\n  }\n\n  insert(x);\n  enqueue(x);\n  sum=trade();\n\n  printf(\"%d\\n\",sum);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\ntypedef char Board[10];\nBoard ini_board, board;\nconst Board target = \"123456780\";\n\nBoard *history;\nint nhistories=0;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nint minstep = 50;\n\nconst Motion candidate[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nint move(Motion m)\n{\n  if (m.pos==0 && board[0]=='1') return -1;\n  if ((m.pos==1||m.pos==2) && board[0]=='1'&&board[1]=='2'&&board[2]=='3') return -1;\n\n  switch (m.dir) {\n  case U:\n    if (m.pos<3) return -1;\n    board[m.pos-3] = board[m.pos];\n    break;\n  case D:\n    if (m.pos>5) return -1;\n    board[m.pos+3] = board[m.pos];\n    break;\n  case L:\n    if (m.pos%3==0) return -1;\n    board[m.pos-1] = board[m.pos];\n    break;\n  case R:\n    if (m.pos%3==2) return -1;\n    board[m.pos+1] = board[m.pos];\n    break;\n  }\n  board[m.pos] = '0';\n  return m.pos;\n}\n\nvoid search_path(int step, int space)\n{\n  int i, j, s2;\n  if (strcmp(board, \"123456780\")==0) {\n    if (step==1) {\n      printf(\"1\\n\");\n      exit(0);\n    }\n    if (step<minstep) minstep=step;\n  } else {\n    if (step>=minstep) return;\n    if (step>0 && strcmp(board, ini_board)==0) return;\n    \n    Board board_bak;\n    strcpy(board_bak, board);\n    int nhistories_bak=nhistories;\n\n    for (i=0; candidate[space][i].pos>=0; i++) {\n      if ((s2 = move(candidate[space][i]))<0) continue;\n      for (j=0; j<nhistories; j++) {\n\tif (strcmp(board, history[j])==0) // 前と同じ配置になったので次の手を試す\n\t  break;\n      }\n      if (j==nhistories) {\n\tstrcpy(history[nhistories++], board); \n\tsearch_path(step+1, s2);\n      }\n      nhistories = nhistories_bak;\n      strcpy(board, board_bak);\n    }\n  }\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board[0],&board[1],&board[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[3],&board[4],&board[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[6],&board[7],&board[8]);\n  strcpy(ini_board, board);\n  history = (Board*)malloc(sizeof(Board)*10000);\n  search_path(0, strchr(board, '0')-board);\n  printf(\"%d\\n\", minstep);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n??\nint mas[3][3];\nint cpy[3][3];\n??\nvoid input() {\n????int i, j;\n????for(i = 0; i < 3; i++)\n????????for(j = 0; j < 3; j++)\n????????????scanf(\"%d\", &mas[i][j]);\n}\n??\nvoid output() {\n????int i, j;\n????for(i = 0; i < 3; i++) {\n????????for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n????????puts(\"\");\n????}\n}\n??\nvoid copy(int m[3][3], int t[3][3]) {\n????int i, j;\n??\n????for(i = 0; i < 3; i++)\n????????for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n??\nint calc() {\n????int i, sum = 0;\n????for(i = 0; i < 9; i++) {\n????????int v = mas[i/3][i%3];\n????????if(v) {\n????????????v--;\n????????????sum += abs(i/3-v/3)+abs(i%3-v%3);\n????????}\n????}\n????return sum;\n}\n??\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n??\nvoid swap(int *a, int *b) {\n????int tmp = *a;\n????*a = *b;\n????*b = tmp;\n}\n??\nint is_in(int x, int y) {\n????return 0<=x&&x<3&&0<=y&&y<3;\n}\n??\nint dfs(int x, int y, int p, int dep, const int lim) {\n????int i, h = calc();\n????//output();\n????if(h == 0) return dep;\n????//printf(\"%d %d %d\\n\", h, lim, p);\n????if(dep+h > lim) return -1;\n??\n????for(i = 0; i < 4; i++) {\n????????int nx = x+dx[i], ny = y+dy[i], res;\n????????if(~p && i == (p+2)%4) continue;\n????????if(!is_in(nx, ny)) continue;\n????????swap(&mas[y][x], &mas[ny][nx]);\n????????res = dfs(nx, ny, i, dep+1, lim);\n????????if(~res) return res;\n????????swap(&mas[y][x], &mas[ny][nx]);\n????}\n??\n????return -1;\n}\n??\nvoid get_empty(int *x, int *y) {\n????int i, j;\n????for(i = 0; i < 3; i++) {\n????????for(j = 0; j < 3; j++) {\n????????????if(!mas[i][j]) {\n????????*x = j;\n????????*y = i;\n????????return;\n????????????}\n????????}\n????}\n}\n??\nint solve() {\n????int x, y, lim, ans;\n????get_empty(&x, &y);\n????for(lim = 0; lim < 50; lim++) {\n????????copy(cpy, mas);\n????????if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n????????copy(mas, cpy);\n????}\n????return -1;\n}\n??\nint main() {\n????input();\n????printf(\"%d\\n\", solve());\n????return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \nint puzzle[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n void empty(int *x,int *y) {\n    int i,j;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) {\n            if(!puzzle[i][j]) {\n                *x = j;\n                *y = i;\n                return;\n            }\n        }\n    }\n}\n\n \nvoid swap(int *a,int *b) {\n    int tmp;\n \n    tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n \n  \nint cal() {\n    int i,a,sum=0;\n \n    for(i=0; i<9; i++) {\n        a = puzzle[i/3][i%3];\n        if(a) {\n            a--;\n            sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n        }\n    }\n    return sum;\n}\n \n \n\nint dfs(int x,int y,int p,int dep,const int lim) {\n    int i,h,nx,ny,res;\n \n    h = cal();\n    if(h==0) return dep;\n    if(dep+h>lim) return -1;\n \n    for(i=0; i<4; i++) {\n        nx = x+dx[i];\n        ny = y+dy[i];\n \n        if(~p && i==(p+2)%4) continue;\n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n \n        swap(&puzzle[y][x],&puzzle[ny][nx]);\n        res = dfs(nx,ny,i,dep+1,lim);\n        if(~res) return res;\n \n        swap(&puzzle[y][x],&puzzle[ny][nx]);\n    }\n \n    return -1;\n}\n\nint main() {\n    int i,j,ans,x,y,l;\n \n    //puzzle input\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) scanf(\"%d\",&puzzle[i][j]);\n    }\n \n \n    empty(&x,&y);\n    for(l=0; l<100; l++) {\n        //copy\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) tmp[i][j] = puzzle[i][j];\n        }\n \n        //dfs\n        ans = dfs(x,y,-1,0,l);\n        if(ans!=-1) {\n            printf(\"%d\\n\",ans);\n            break;\n        }\n \n        //copy\n        for(i=0 ; i<3 ; i++) {\n            for(j=0 ; j<3 ; j++) puzzle[i][j] = tmp[i][j];\n        }\n \n        //error\n        ans = -1;\n        if(l==99) printf(\"%d\\n\",ans);\n    }\n \n    //ans output\n    //printf(\"%d\\n\",ans);\n \n    return 0;\n}\n "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 3\nint sum[N][N] =\n{\n    {1, 2, 3},\n    {4, 5, 6},\n    {7, 8, 0}\n};\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { -1, 0, 1, 0 };\n\nint num(int gum[N][N]) {\n    for (int a = 0; a < N; ++a) {\n        for (int b = 0; b < N; ++b) {\n            if (gum[a][b] != sum[a][b])\n                return 0;\n        }\n    }\n    return 1;\n}\n\nint xu(int gum[N][N], int x, int y, int v, int d, int e) {\n    if (num(gum))\n        return d;\n    if (d > e)\n        return -1;\n    for (int i = 0, fan; i < 4; ++i) {\n        int x2 = x + dx[i];\n        int y2 = y + dy[i];\n        if (x2 < 0 || x2 > 2 || y2 < 0 || y2 > 2 || (i + 2) % 4 == v)\n            continue;\n        gum[y][x] = gum[y2][x2];\n        gum[y2][x2] = 0;\n        if ((fan = xu(gum, x2, y2, i, d + 1, e)) > 0)\n            return fan;\n        gum[y2][x2] = gum[y][x];\n        gum[y][x] = 0;\n    }\n    return -1;\n}\n\nint main() {\n    int gum[N][N], x, y;\n    for (int a = 0; a < N; ++a) {\n        for (int b = 0; b < N; ++b) {\n            scanf(\"%d\", &gum[a][b]);\n            if (gum[a][b] == 0) {\n                y = a;\n                x = b;\n            }\n        }\n    }\n\n    int fan;\n    for (int a = 1; a < 50; ++a) {\n        if ((fan = xu(gum, x, y, -1, 0, a)) >= 0) {\n            break;\n        }\n    }\n    printf(\"%d\\n\", fan);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define N 3\n#define N1 4\n#define N2 9\n#define N3 100\nint puz[N][N];\nint tmp[N][N];\nint dx[N1]={0,1,0,-1};\nint dy[N1]={1,0,-1,0};\nvoid empty(int x[],int y[]) {\n  int i,j;\n  for(i=0;i<N;i++) {\n    for(j=0;j<N;j++) {\n      if(!puz[i][j]) {\n        *x = j;\n        *y = i;\n        return;\n      }\n    }\n  }\n}\nvoid swap(int a[],int b[]){\n  int tmp;\n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\nint cal(){\n  int i,a,sum=0;\n  for(i=0; i<N2; i++){\n    a = puz[i/N][i%N];\n    if(a){\n      a--;\n      sum+=abs((i/N)-(a/N))+abs((i%N)-(a%N));\n    }\n  }\n  return sum;\n  }\nint dfs(int x,int y,int p,int dep,const int lim){\n  int i,h,nx,ny,res;\n  h=cal();\n  if(h==0) return dep;\n  if(dep+h>lim) return -1;\n  for(i=0;i<N1;i++){\n    nx=x+dx[i];\n    ny=y+dy[i];\n    if(~p && i==(p+2)%N2) continue;\n    if(!(0<=nx && nx<N && 0<=ny && ny<N)) continue;\n    swap(&puz[y][x],&puz[ny][nx]);\n    res = dfs(nx,ny,i,dep+1,lim);\n    if(~res) return res;\n    swap(&puz[y][x],&puz[ny][nx]);\n  }\n  return -1;\n}\nint main() {\n  int i,j,ans,x,y,l;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++) scanf(\"%d\",&puz[i][j]);\n  }\n  empty(&x,&y);\n  for(l=0;l<N3;l++){\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++) tmp[i][j] = puz[i][j];\n    }\n    ans=dfs(x,y,-1,0,l);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++) puz[i][j] = tmp[i][j];\n    }\n     ans = -1;\n    if(l==N3-1) printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n  \nint mas[3][3];\nint cpy[3][3];\n \n  \nint main() {\n  input();\n  printf(\"%d\\n\", solve());\n  return 0;\n}\nvoid input() {\n  int i, j;\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++)\n      scanf(\"%d\", &mas[i][j]);\n}\n  \nvoid output() {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n    puts(\"\");\n  }\n}\n  \nvoid copy(int m[3][3], int t[3][3]) {\n  int i, j;\n  \n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n  \nint calc() {\n  int i, sum = 0;\n  for(i = 0; i < 9; i++) {\n    int v = mas[i/3][i%3];\n    if(v) {\n      v--;\n      sum += abs(i/3-v/3)+abs(i%3-v%3);\n    }\n  }\n  return sum;\n}\n  \nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n  \nvoid swap(int *a, int *b) {\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n  \nint is_in(int x, int y) {\n  return 0<=x&&x<3&&0<=y&&y<3;\n}\n  \nint dfs(int x, int y, int p, int dep, const int lim) {\n  int i, h = calc();\n  //output();\n  if(h == 0) return dep;\n  //printf(\"%d %d %d\\n\", h, lim, p);\n  if(dep+h > lim) return -1;\n  \n  for(i = 0; i < 4; i++) {\n    int nx = x+dx[i], ny = y+dy[i], res;\n    if(~p && i == (p+2)%4) continue;\n    if(!is_in(nx, ny)) continue;\n    swap(&mas[y][x], &mas[ny][nx]);\n    res = dfs(nx, ny, i, dep+1, lim);\n    if(~res) return res;\n    swap(&mas[y][x], &mas[ny][nx]);\n  }\n  \n  return -1;\n}\n  \nvoid get_empty(int *x, int *y) {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) {\n      if(!mas[i][j]) {\n    *x = j;\n    *y = i;\n    return;\n      }\n    }\n  }\n}\n  \nint solve() {\n  int x, y, lim, ans;\n  get_empty(&x, &y);\n  for(lim = 0; lim < 50; lim++) {\n    copy(cpy, mas);\n    if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n    copy(mas, cpy);\n  }\n  return -1;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 100000\n#define SENTINEL 2000000000\n\nstruct Card{\n  char suit;\n  int value;\n};\n\nstruct Card L[MAX/2+2], R[MAX/2+2];\n\nvoid merge(struct Card A[], int n, int left, int mid, int right){\n\n  int i, j, k;\n  int n1 = mid - left;\n  int n2 = right - mid;\n\n  for(i=0; i<n1; i++){\n    L[i] = A[left+1];\n  }\n  for(i=0; i<n2; i++){\n    R[i] = A[mid+i];\n  }\n\n  L[n1].value = R[n2].value = SENTINEL;\n  i = j = 0;\n\n  for(k=left; k<right; k++){\n    if(L[i].value <= R[j].value){\n      A[k] = L[i++];\n    }\n    else{\n      A[k] = R[j++];\n    }\n  }\n\n}\n\nvoid mergeSort(struct Card A[], int n, int left, int right){\n\n  int mid;\n\n  if(left+1 < right){\n    mid = (left+right)/2;\n    mergeSort(A, n, left, mid);\n    mergeSort(A, n, mid, right);\n    merge(A, n, left, mid, right);\n  }\n\n}\n\nint partition(struct Card A[], int n, int p, int r){\n\n  int i, j;\n  struct Card t, x;\n  x = A[r];\n  i = p-1;\n\n  for(j=p; j<r; j++){\n    if(A[j].value <= x.value){\n      i++;\n      t = A[i];\n      A[i] = A[j];\n      A[j] = t;\n    }\n  }\n\n  t = A[i+1];\n  A[i+1] = A[r];\n  A[r] = t;\n\n}\n}\n\nt = A[i+1];\nA[i+1] = A[r];\nA[r] = t;\n  return i+1;\n\n}\n\nvoid quickSort(struct Card A[], int n, int p, int r){\n\n  int q;\n\n  if(p<r){\n    q = partition(A, n , p, r);\n    quickSort(A, n, p, q-1);\n    quickSort(A, n, q+1, r);\n  }\n\n}\n\nint main(){\n\n  int n, i, v;\n  struct Card A[MAX], B[MAX];\n  char S[10];\n  int stable=1;\n\n  scanf(\"%d\",&n);\n\n  for(i=0; i<n; i++){\n    scanf(\"%s %d\", S, &v);\n    A[i].suit = B[i].suit = S[0];\n    A[i].value = B[i].value = v;\n  }\n\n  mergeSort(A, n, 0, n);\n  quickSort(B, n, 0, n-1);\n\n  for(i=0; i<n; i++){\n    if(A[i].suit != B[i].suit){\n      stable = 0;\n    }\n  }\n\n if(stable==1){\n    printf(\"Stable\\n\");\n  }\n  else{\n    printf(\"Not stable\\n\");\n  }\n\n  for(i=0; i<n; i++){\n    printf(\"%c %d\\n\", B[i].suit, B[i].value);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 3\n\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint count;\nint A[N][N];\n\nint abs(int a){\n  if(a > 0) return a;\n  else return a*-1;\n}\n\nvoid swap(int *x,int *y){\n  int tmp=*x;\n  *x=*y;\n  *y=tmp;\n  return ;\n}\n\nint Heuristic(){\n  int i,j,sum = 0,x;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n    if(A[i][j]==0)continue;\n    x = A[i][j] - 1;\n    sum+=abs(x/N - i)+abs(x%N - j);\n    }\n  }\n  return sum;\n}\n\nint move(int d,int pre,int s,int t){\n  int i,x,y,h = Heuristic();\n  if(h==0)return 1;\n  if(d+h > count)return 0;\n  for(i=0;i<4;i++){\n    if(abs(i - pre)==2)continue;/*return move*/\n\n    x = s + dy[i];\n    y = t + dx[i];\n\n    if(x<0||y<0||x>=N||y>=N)continue;/*frame over*/\n\n    swap(&A[x][y],&A[s][t]);\n    if(move(d+1,i,x,y))return 1;\n    swap(&A[x][y],&A[s][t]);/*return move because next move's starat is same this one */\n  }\n  return 0;\n}\n\nvoid counter(int s,int t){\n  count = 0;\n  while(1){\n    if(move(0,10,s,t)){\n      printf(\"%d\\n\",count);\n      return ;\n    }\n    count++;\n  }\n}\n\nint main(){\n  int i,j,s,t;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&A[i][j]);\n      if(A[i][j]==0){\n        s = i;\n        t = j;\n      }\n    }\n  }\n  counter(s,t);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define ROW 3\n#define COL 3\n\ntypedef struct {\n  int row;\n  int col;\n}location;\n\nvoid swap(int **,location,location);\nint Search_min_path(int **,location,location,int,int);\nint incorrect(int **);\n\nint main(){\n  int **puzzle;\n  int i,j,limit,move_count=0,min;\n  location pre,current;\n\n  puzzle = malloc(sizeof(int*)*ROW);\n  for(i=0;i<ROW;i++)puzzle[i] = malloc(sizeof(int)*COL);\n\n  for(i=0;i<ROW;i++)for(j=0;j<COL;j++)scanf(\"%d\",&puzzle[i][j]);\n\n  pre.row=-1;\n  pre.col=-1;\n  for(i=0;i<ROW;i++)for(j=0;j<COL;j++)if(puzzle[i][j] == 0){\n\tcurrent.row = i;\n\tcurrent.col = j;\n      }\n  limit = incorrect(puzzle);\n\n  for(;1;limit++){\n    min = Search_min_path(puzzle,pre,current,limit,move_count);\n    if(-1 != min){\n      printf(\"%d\\n\",min);\n      break;\n    }\n  }\n\n  for(i=0;i<ROW;i++)free(puzzle[i]);\n  free(puzzle);\n  \n  return 0;\n}\n\nint Search_min_path(int **puzzle,location pre,location current,int limit,int move_count){\n  int **backup_puzzle;\n  int i,j,h,state;\n  location next;\n\n  h = incorrect(puzzle);\n  if(move_count + h >limit)return -1;\n  if(0 == h){\n    /**\n    for(i=0;i<ROW;i++){\n      for(j=0;j<COL;j++)printf(\" %d\",puzzle[i][j]);\n      printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    **/\n    return move_count;\n  }\n\n  backup_puzzle = malloc(sizeof(int*)*ROW);\n  for(i=0;i<ROW;i++)backup_puzzle[i] = malloc(sizeof(int)*COL);\n\n  for(i=0;i<ROW;i++)for(j=0;j<COL;j++)backup_puzzle[i][j] = puzzle[i][j];\n  next = current;\n  move_count++;\n\n  /*********************** up ****************************/\n  if(current.row -1 >= 0 && pre.row != current.row -1){\n    next.row --;\n    swap(puzzle,current,next);\n    state = Search_min_path(puzzle,current,next,limit,move_count);\n    if(-1 != state){\n      /**\n      for(i=0;i<ROW;i++){\n\tfor(j=0;j<COL;j++)printf(\" %d\",backup_puzzle[i][j]);\n\tprintf(\"\\n\");\n      }\n      printf(\"\\n\");\n      **/\n      for(i=0;i<ROW;i++)free(backup_puzzle[i]);\n      free(backup_puzzle);\n      return state;\n    }\n  }\n  /*********************** up ****************************/\n\n  for(i=0;i<ROW;i++)for(j=0;j<COL;j++)puzzle[i][j] = backup_puzzle[i][j];\n  next= current;\n\n  /*********************** down ****************************/\n  if(current.row +1 < ROW && pre.row != current.row +1){\n    next.row ++;\n     swap(puzzle,current,next);\n    state = Search_min_path(puzzle,current,next,limit,move_count);\n    if(-1 != state){\n      /**\n      for(i=0;i<ROW;i++){\n\tfor(j=0;j<COL;j++)printf(\" %d\",backup_puzzle[i][j]);\n\tprintf(\"\\n\");\n      }\n      printf(\"\\n\");\n      **/\n      for(i=0;i<ROW;i++)free(backup_puzzle[i]);\n      free(backup_puzzle);\n      return state;\n    }\n  }\n  /*********************** down ****************************/\n\n  for(i=0;i<ROW;i++)for(j=0;j<COL;j++)puzzle[i][j] = backup_puzzle[i][j];\n  next= current;\n\n  /*********************** left ****************************/\n  if(current.col -1 >=0 && pre.col != current.col -1){  \n    next.col --;\n    swap(puzzle,current,next);\n    state = Search_min_path(puzzle,current,next,limit,move_count);\n    if(-1 != state){\n      /**\n      for(i=0;i<ROW;i++){\n\tfor(j=0;j<COL;j++)printf(\" %d\",backup_puzzle[i][j]);\n\tprintf(\"\\n\");\n      }\n      printf(\"\\n\");\n      **/\n      for(i=0;i<ROW;i++)free(backup_puzzle[i]);\n      free(backup_puzzle);\n      return state;\n    }\n  }\n  /*********************** left ****************************/\n\n  for(i=0;i<ROW;i++)for(j=0;j<COL;j++)puzzle[i][j] = backup_puzzle[i][j];\n  next= current;\n\n  /*********************** right ****************************/\n  if(current.col +1 <COL && pre.col != current.col +1){\n    next.col ++;\n    swap(puzzle,current,next);\n    state = Search_min_path(puzzle,current,next,limit,move_count);\n    if(-1 != state){\n      /**\n      for(i=0;i<ROW;i++){\n\tfor(j=0;j<COL;j++)printf(\" %d\",backup_puzzle[i][j]);\n\tprintf(\"\\n\");\n      }\n      printf(\"\\n\");\n      **/\n      for(i=0;i<ROW;i++)free(backup_puzzle[i]);\n      free(backup_puzzle);\n      return state;\n    }\n  }\n  /*********************** right ****************************/\n\n  for(i=0;i<ROW;i++)for(j=0;j<COL;j++)puzzle[i][j] = backup_puzzle[i][j];\n  \n  \n  for(i=0;i<ROW;i++)free(backup_puzzle[i]);\n  free(backup_puzzle);\n  return -1;\n}\n\nint incorrect(int **puzzle){\n  int i,j,num = 1,h=0,flag=0,tate,yoko,n,m;\n  for(num =1;num<=ROW*COL;num++){\n    n = (num-1)/ROW;\n    m = (num-1)%COL;\n    for(i=0;i<ROW;i++){\n      for(j=0;j<COL;j++){\n\tif(puzzle[i][j] == num%(ROW*COL)){\n\t  tate = i-n;\n\t  if(tate < 0)tate *=-1;\n\t  yoko = j-m;\n\t  if(yoko < 0)yoko *=-1;\n\t  flag = 1;\n\t  break;\n\t}\n      }\n      if(flag==1)break;\n    }\n    flag = 0;\n    h += tate + yoko;\n  }\n  return h;\n}\n\nvoid swap(int **puzzle,location A,location B){\n  int num;\n  num = puzzle[A.row][A.col];\n  puzzle[A.row][A.col] = puzzle[B.row][B.col];\n  puzzle[B.row][B.col]=num;\n}\n  \n\n  \n    \n\n  \n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n\n#define N 3\n#define N2 9\n#define TRUE 1\n#define FALSE 0\n#define MAX 500000\n\nint V[MAX];\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\nvoid swap(int x, int y){/*入れ替えます*/\n  int z = x;\n  x = y;\n  y = z;\n}\n\nstruct Puzzle{/*構造体の宣言*/\n  int f[N2];\n  int space;\n  int path;\n};\n\nstruct Puzzle Q[MAX];\nint head = 0, tail = 0;\n\nvoid enqueue(struct Puzzle x){/* Q[tail] に x を代入し、tail を１つ増やします。 */\n  int next = (tail+1)%MAX;  \n  Q[tail] = x;\n  tail = next;\n}\n\nstruct Puzzle dequeue(){/* Q[head] の値を返し、head を１つ増やします。  */\n  struct Puzzle t; \n  t = Q[head];\n  head = (head+1)%MAX;\n  return t;\n}\n\nint sort(struct Puzzle p){\n  int i, j, key, count, n = 0;\n  for(i = 0, key = 1; i < N2; key *= ++i){\n    for(j = 0, count = 0; j < i; j++){\n      if(p.f[j] < p.f[i])count++;\n    }\n    n += count * key;\n  }\n  return n;\n}\n\nint isTarget(struct Puzzle p){\n  for(int i = 0; i < N2; i++)if(p.f[i] != (i+1))return FALSE;\n  return TRUE;\n}\n\nint bfs(struct Puzzle s){\n  struct Puzzle u, v;\n  s.path = FALSE;\n  enqueue(s);\n  V[sort(s)] = TRUE;\n  \n\n  while(head != tail){ \n    u = dequeue();\n    if(isTarget(u) == TRUE)return u.path;\n    int sx = u.space / N;\n    int sy = u.space % N;\n    for(int r = 0; r < 4; r++){\n      int tx = sx + dx[r];\n      int ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N)continue;\n      v = u;\n      int num = v.f[u.space];\n      v.f[u.space] = v.f[tx * N + ty];\n      v.f[tx * N + ty] = num;\n      v.space = tx * N + ty;\n      if(V[sort(v)] != TRUE){\n\tV[sort(v)] = TRUE;\n\tv.path++;\n\tenqueue(v);\n      }\n    }\n  }\n\n  return -1;\n}\n\nint main(){\n  struct Puzzle in;\n\n  for(int i = 0; i < N2; i++){\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n\n  int ans = bfs(in);\n  printf(\"%d\\n\",ans);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define N 3\n#define LIM 32\n#define HN 362897\n\nstruct dep{\n  int depth,key;\n};\n\nint ans[N][N]={\n  {1,2,3},\n  {4,5,6},\n  {7,8,0}\n};\n\nint min = LIM;\nstruct dep h[HN];\n\nint hash1(int k)\n{\n  return k % HN;\n}\nint hash2(int k)\n{\n  return 1 + k%(HN-1);\n}\nint hash(int k, int i)\n{\n  return (hash1(k) + i*hash2(k))%HN;\n}\n\n\nvoid dfs(int p[N][N], int n)\n{\n  int i,j,i0,j0,a=0,b=1;\n  int f=0;\n  int tmp[N][N];\n  for(i=0;i<N;i++)\n  {\n    for(j=0;j<N;j++)\n    {\n      if(ans[i][j]!=p[i][j])f++;\n      if(p[i][j]==0)\n      {\n        i0=i;\n        j0=j;\n      }\n      a+=p[i][j]*b;\n      b*=10;\n    }\n  }\n\n  if(f==0)\n  {\n    if(min>=n)\n    {\n      min=n;\n    }\n    return;\n  }\n  if(n>min) return;\n  i=0;\n  while(1)\n  {\n    b=hash(a, i);\n    if(h[b].key == 0)\n    {\n      h[b].key=a;\n      h[b].depth=n;\n      break;\n    }\n    else if(h[b].key == a)\n    {\n      if(h[b].depth>n)\n      {\n        h[b].depth=n;\n        break;\n      }\n      else return;\n    }\n    i++;\n  }\n\n  if(i0>0 && i0<N)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0-1][j0];\n    tmp[i0-1][j0]=f;\n    dfs(tmp, n+1);\n  }\n  if(j0>0 && j0<N)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0][j0-1];\n    tmp[i0][j0-1]=f;\n    dfs(tmp, n+1);\n  }\n\n  if(i0>=0 && i0<N-1)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0+1][j0];\n    tmp[i0+1][j0]=f;\n    dfs(tmp, n+1);\n  }\n  if(j0>=0 && j0<N-1)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0][j0+1];\n    tmp[i0][j0+1]=f;\n    dfs(tmp, n+1);\n  }\n\n}\n\nint main()\n{\n  int i,j;\n  int p[N][N];\n\n  for(i=0;i<N;i++)\n  {\n    for(j=0;j<N;j++)\n    {\n      scanf(\"%d\",&p[i][j]);\n    }\n  }\n  dfs(p,0);\n\n  printf(\"%d\\n\",min);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 9\n\nint board[N];\nint rows = 3, cols = 3, zeroIndex;\n\nint blindSearch(int x, int y, int moves, int previousMove) {\n  int i,foundAnswer;\n  if (moves < (x+y))\n    return 0;\n\n  if (!moves) {\n    for (i = 0; i < N - 1; i++) {\n      if (board[i] != i + 1)\n        return 0;\n    }\n\n    return 1;\n  }\n\n  if (x > 0 && previousMove != 1){\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n\n    foundAnswer = blindSearch(x - 1, y, moves - 1, 0);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n  }\n\n  if (y > 0 && previousMove != 3) {\n    board[zeroIndex] = board[zeroIndex + 1];\n    zeroIndex++;\n\n    foundAnswer = blindSearch(x, y - 1, moves - 1, 2);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex - 1];\n    zeroIndex--;\n  }\n\n  if (y < rows - 1 && previousMove != 2){\n    board[zeroIndex] = board[zeroIndex - 1];\n    zeroIndex--;\n\n    foundAnswer = blindSearch(x, y + 1, moves - 1, 3);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex + 1];\n    zeroIndex++;\n  }\n\n  if (x < cols - 1 && previousMove != 0) {\n    // up\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n\n    foundAnswer = blindSearch(x + 1, y, moves - 1, 1);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n  }\n\n  return 0;\n}\n\nint main() {\n  int i, x, y, j;\n\n  for (i = 0; i < N; i++) {\n    scanf(\"%d\", &board[i]);\n    if (!board[i])\n      zeroIndex = i;\n  }\n\n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n\n  for (j = 0; j < 50; j++) {\n    if (blindSearch(x,y,j,-1)) {\n      printf(\"%d\\n\", j);\n      return 0;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define true 1\n#define false 0\n\n#define MAX 3\n#define INF 100000000\n\nint limit;\nint shortest = INF;\nint count;\nint puzzle[MAX * MAX];\nint road[30][MAX * MAX];\n\nvoid swap(int *x, int *y) {\n    int tmp;\n    tmp = *x;\n    *x = *y;\n    *y = tmp;\n}\n\nint history(int depth) {\n    int i, j, cnt;\n    if (depth < 2) return -1;\n\n    cnt = (MAX * MAX) - 1;\n    for (j = depth - 2; j != 0; j--) {\n        for (i = 1; i < (MAX * MAX); i++) {\n            if (puzzle[i - 1] == road[depth - 2][i - 1]) {\n                cnt--;\n            }\n        }\n        if (cnt == 0) return cnt;\n    }\n    return cnt;\n}\n\nint check() {\n    int i, cnt;\n\n    cnt = (MAX * MAX) - 1;\n    for (i = 1; i < (MAX * MAX); i++) {\n        if (puzzle[i - 1] == i) {\n            cnt--;\n        }\n    }\n    return cnt;\n}\n\nint up(int i, int *dir) {\n    *dir = i - MAX;\n    if (*dir >= 0) { return true; }\n    else return false;\n}\n\nint down(int i, int *dir) {\n    *dir = i + MAX;\n    if (*dir < (MAX * MAX)) { return true; }\n    else return false;\n}\n\nint left(int i, int *dir) {\n    *dir = i - 1;\n    if ((i % MAX != 0)) { return true; }\n    else return false;\n}\n\nint right(int i, int *dir) {\n    *dir = i + 1;\n    if ((i + 1) % MAX != 0) { return true; }\n    else return false;\n}\n\nvoid disp(int depth) {\n    int i;\n    if (depth < 0) return;\n\n    for (i = 0; i < (MAX * MAX); i++) {\n        if ((i % MAX) == 0) printf(\"\\n\");\n        printf(\"%d \", road[depth][i]);\n    }\n    printf(\"\\n\");\n    disp(depth - 1);\n}\n\nvoid cp(int depth) {\n    int i;\n    for (i = 0; i < (MAX * MAX); i++) {\n        road[depth][i] = puzzle[i];\n    }\n}\n\nvoid dfs(int depth, int pos) {\n    int dir;\n    int h = check();\n    cp(depth);\n    count++;\n\n    if (depth + h > limit || history(depth) == 0) {\n        return;\n    }\n    if (h == 0) {\n        if (shortest > depth) {\n            shortest = depth;\n            limit = depth;\n        }\n        //disp(depth);\n        return;\n    }\n\n    if (up(pos, &dir)) {\n        swap(&puzzle[pos], &puzzle[dir]);\n        dfs(depth+1, dir);\n        swap(&puzzle[pos], &puzzle[dir]);\n    }\n    if (down(pos, &dir)) {\n        swap(&puzzle[pos], &puzzle[dir]);\n        dfs(depth+1, dir);\n        swap(&puzzle[pos], &puzzle[dir]);\n    }\n    if (right(pos, &dir)) {\n        swap(&puzzle[pos], &puzzle[dir]);\n        dfs(depth+1, dir);\n        swap(&puzzle[pos], &puzzle[dir]);\n    }\n    if (left(pos, &dir)) {\n        swap(&puzzle[pos], &puzzle[dir]);\n        dfs(depth+1, dir);\n        swap(&puzzle[pos], &puzzle[dir]);\n    }\n}\n\nint  main() {\n    int i, pos;\n\n    for (i = 0; i < (MAX * MAX); i++) {\n        scanf(\"%d\", &puzzle[i]);\n        if (puzzle[i] == 0) {\n            pos = i;\n        }\n    }\n    limit = (check() + 1) * 4;\n\n    dfs(0, pos);\n\n    if (shortest != INF) {\n        printf(\"%d\\n\", shortest);\n        //printf(\"count >> %d\\n\", count);\n    } else {\n        printf(\">> not Solve limit-> %d, %d\\n\", limit, count);\n        disp(limit);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#define N 3\n#define true 1\n#define false 0\n\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\nint limit;\nint t[N][N];\n\nvoid swap(int *x,int *y){\n  int tmp=*x;\n  *x=*y;\n  *y=tmp;\n  return ;\n}\n\nint getHeuristic(){\n  int i,j,sum=0,x;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n    if(t[i][j]==0)continue;\n    x=t[i][j]-1;\n    sum+=abs(x/N-i)+abs(x%N-j);\n    }\n  }\n  return sum;\n}\n\nint dfs(int depth,int prev,int py,int px){\n  int h=getHeuristic();\n  if(h==0)return true;\n  if(depth+h>limit)return false;\n  int i;\n  for(i=0;i<4;i++){\n    if(abs(i-prev)==2)continue;\n    int tx=px+dx[i],ty=py+dy[i];\n    if(tx<0||ty<0||tx>=N||ty>=N)continue;\n    swap(&t[ty][tx],&t[py][px]);\n    if(dfs(depth+1,i,ty,tx))return true;\n    swap(&t[ty][tx],&t[py][px]);\n  }\n  return false;\n}\n\nvoid isSolved(int py,int px){\n  for(limit=0;;limit++){\n    if(dfs(0,99,py,px)){\n      printf(\"%d\\n\",limit);\n      return ;\n    }\n  }\n}\n\nint main(){\n  int i,j,px,py;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&t[i][j]);\n      if(t[i][j]==0){\n        py=i;\n        px=j;\n      }\n    }\n  }\n  isSolved(py,px);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\n\n#define N 3\n#define true 1\n#define false 0\n\n\nint x[4]={0,-1,0,1};\nint y[4]={1,0,-1,0};\nint l;\nint w[N][N];\n\nvoid swap(int *s,int *t){\n\n  int tmp = *s;\n  \n  *s = *t;\n  *t = tmp;\n  \n  return;\n\n}\n\n\nint abc(){\n\n  int i,j,s = 0,r;\n  \n  for(i = 0; i < N; i++){\n    for(j = 0; j < N; j++){\n      if(w[i][j] == 0) continue;\n      r = w[i][j] - 1;\n      s += abs(r / N - i) + abs(r % N - j);\n    }\n  }\n  \n  return s;\n\n}\n\n\nint dfs(int d,int p,int ay,int ax){\n\n  int i,m = abc();\n  \n  if(m == 0)return true;\n  \n  if(d + m > l)return false;\n  \n  for(i = 0; i < 4; i++){\n    if(abs(i - p) == 2)continue;\n    \n    int tx = ax + x[i], ty = ay + y[i];\n    \n    if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n    \n    swap(&w[ty][tx],&w[ay][ax]);\n    \n    if(dfs(d + 1,i,ty,tx))return true;\n    \n    swap(&w[ty][tx],&w[ay][ax]);\n  }\n  \n  return false;\n\n}\n\n\nvoid Solved(int ay,int ax){\n\n  for(l = 0; ; l++){\n    if(dfs(0,99,ay,ax)){\n      printf(\"%d\\n\",l);\n      return ;\n    }\n  }\n\n}\n\nint main(){\n\n  int i,j,ax,ay;\n   \n   for(i = 0; i < N; i++){\n     for(j = 0; j < N; j++){\n       scanf(\"%d\",&w[i][j]);\n        if(w[i][j] == 0){\n\t  ay = i;\n\t  ax = j;\n\t}\n     }\n   }\n     \n   Solved(ay,ax);\n     \n     return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define N 3\n#define LIM 32\n#define HN 362897\n\nstruct dep{\n  int depth,key;\n};\n\nint ans[N][N]={\n  {1,2,3},\n  {4,5,6},\n  {7,8,0}\n};\n\nint min = LIM;\nstruct dep h[HN];\n\nint hash1(int k){\n  return k % HN;\n}\nint hash2(int k){\n  return 1 + k%(HN-1);\n}\nint hash(int k, int i){\n  return (hash1(k)+i*hash2(k))%HN;\n}\n\n\nvoid dfs(int p[N][N], int n){\n  int i,j,i0,j0,a=0,b=1;\n  int f=0;\n  int tmp[N][N];\n\n  for(i = 0; i < N; i++){\n    for(j = 0; j < N; j++){\n      if(ans[i][j] != p[i][j]) f++;\n      if(p[i][j] == 0){\n        i0=i;\n        j0=j;\n      }\n      a+=p[i][j]*b;\n      b*=10;\n    }\n  }\n\n  if(f == 0){\n    if(min >= n){\n      min = n;\n    }\n    return;\n  }\n\n  if(n > min) return;\n\n  i=0;\n\n  while(1){\n    b=hash(a, i);\n\n    if(h[b].key == 0){\n      h[b].key=a;\n      h[b].depth=n;\n      break;\n    }\n    else if(h[b].key == a){\n      if(h[b].depth>n){\n        h[b].depth=n;\n        break;\n      }\n      else return;\n    }\n    i++;\n  }\n\n  if(i0 > 0 && i0 < N){\n    memcpy(tmp,p,sizeof(int)*N*N);\n\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0-1][j0];\n    tmp[i0-1][j0]=f;\n    dfs(tmp, n+1);\n  }\n\n  if(j0 > 0 && j0 < N)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0][j0-1];\n    tmp[i0][j0-1]=f;\n    dfs(tmp, n+1);\n  }\n\n  if(i0 >= 0 && i0 < N-1){\n    memcpy(tmp,p,sizeof(int)*N*N);\n\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0+1][j0];\n    tmp[i0+1][j0]=f;\n    dfs(tmp, n+1);\n  }\n  if(j0 >= 0 && j0 < N-1){\n    memcpy(tmp,p,sizeof(int)*N*N);\n\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0][j0+1];\n    tmp[i0][j0+1]=f;\n    dfs(tmp, n+1);\n  }\n}\n\nint main(){\n  int i,j;\n  int p[N][N];\n\n  for(i = 0; i < N; i++){\n    for(j = 0; j < N; j++){\n      scanf(\"%d\",&p[i][j]);\n    }\n  }\n  dfs(p,0);\n\n  printf(\"%d\\n\",min);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define N 3\n#define L 32\n#define H 362897\n\nstruct depth{\n  int dep, key;\n};\n\nint ans[N][N] = {\n  {1, 2, 3},\n  {4, 5, 6},\n  {7, 8, 0}\n};\n\nint min = L;\nstruct depth h[H];\n\nint hash1(int k){\n    return k % H;\n}\n\nint hash2(int k){\n    return 1 + k%(H-1);\n}\n\nint hash(int k, int i){\n    return (hash1(k) + i*hash2(k))%H;\n}\n\n\n\nvoid dfs(int p[N][N], int n){\n    int i, j, i0, j0;\n    int a = 0;\n    int b = 1;\n    int f = 0;\n    int tmp[N][N];\n\n    for(i = 0 ; i<N ; i++){\n        for(j=0 ; j<N ; j++){\n            if( ans[i][j] != p[i][j] ){f++;}\n            if( p[i][j] == 0 ){\n                i0 = i;\n                j0 = j;\n            }\n            a += p[i][j] * b;\n            b *= 10;\n        }\n    }\n\n    if( f == 0 ){\n        if( min >= n ){\n            min = n;\n        }\n        return;\n    }\n\n    if(n > min) return;\n    i = 0;\n    while(1){\n        b = hash(a, i);\n        if(h[b].key == 0){\n            h[b].key = a;\n            h[b].dep = n;\n            break;\n        }\n        else if(h[b].key == a){\n            if(h[b].dep>n){\n                h[b].dep = n;\n                break;\n            }\n            else return;\n        }\n        i++;\n    }\n\n    if(i0 > 0 && i0 < N){\n        memcpy(tmp, p, sizeof(int)*N*N);\n        f = tmp[i0][j0];\n        tmp[i0][j0] = tmp[i0-1][j0];\n        tmp[i0-1][j0] = f;\n        dfs(tmp, n+1);\n      }\n    if(j0>0 && j0<N){\n        memcpy(tmp, p, sizeof(int)*N*N);\n        f = tmp[i0][j0];\n        tmp[i0][j0] = tmp[i0][j0-1];\n        tmp[i0][j0-1] = f;\n        dfs(tmp, n+1);\n      }\n\n    if(i0>=0 && i0<N-1){\n        memcpy(tmp, p, sizeof(int)*N*N);\n        f = tmp[i0][j0];\n        tmp[i0][j0] = tmp[i0+1][j0];\n        tmp[i0+1][j0] = f;\n        dfs(tmp, n+1);\n      }\n    if(j0>=0 && j0<N-1){\n        memcpy(tmp, p, sizeof(int)*N*N);\n        f = tmp[i0][j0];\n        tmp[i0][j0] = tmp[i0][j0+1];\n        tmp[i0][j0+1] = f;\n        dfs(tmp, n+1);\n      }\n\n}\nint main(){\n  int i, j;\n  int p[N][N];\n\n  for(i=0 ; i<N ; i++){\n    for(j=0 ; j<N ; j++){\n      scanf(\"%d\", &p[i][j]);\n    }\n  }\n  dfs(p, 0);\n\n  printf(\"%d\\n\", min);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define T 1\n#define F 0\n#define N 3\n\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\nint lim;\nint p[N][N];\n\nint huristic()\n{\n\tint i,j,n,sum=0;\n\tfor (i=0;i<N;i++)\n  {\n\t\tfor(j=0;j<N;j++)\n    {\n\t\t\tif(p[i][j]==0)continue;\n\t\t\tn=p[i][j]-1;\n\t\t\tsum+=abs(n/N-i)+abs(n%N-j);\n\t\t}\n\t}\n\treturn sum;\n}\n\nint dfs(int d,int pre,int y,int x)\n{\n\tint h = huristic();\n\tint i;\n\tif(h==0)return T;\n\tif(lim<d+h) return F;\n\n\tfor(i=0;i<4;i++)\n  {\n\t\tif(abs(i-pre)==2)continue;\n\t\tint tx=x+dx[i],ty=y+dy[i];\n\t\tif (tx<0||ty<0||tx>=N||ty>= N)continue;\n\t\tint tmp=p[ty][tx];\n\t\tp[ty][tx]=p[y][x];\n\t\tp[y][x]=tmp;\n\n\t\tif(dfs(d+1,i,ty,tx))return T;\n\t\ttmp=p[ty][tx];\n\t\tp[ty][tx]=p[y][x];\n\t\tp[y][x]=tmp;\n\t}\n\treturn F;\n}\n\nvoid azl(int x,int y)\n{\n\tfor(lim=0;;lim++)\n  {\n\t\tif(dfs(0,99,y,x))\n     {\n\t\t\tprintf(\"%d\\n\",lim);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i,j;\n\tint a,b;\n\n\tfor(i=0;i<3;i++)\n  {\n\t\tfor(j=0;j<3;j++)\n    {\n\t\t\tscanf(\"%d\",&p[i][j]);\n\t\t\tif(p[i][j]==0)\n      {\n\t\t\t\tb=i;a=j;\n\t\t\t}\n\t\t}\n\t}\n\tazl(a,b);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define N 3\n#define LIM 32\n#define HN 362897\ntypedef struct {\n    int depth,key;\n}dep;\ndep  h[HN];\nint ans[N][N]={{1,2,3},{4,5,6},{7,8,0}},min = LIM;\nint hash1(int k) {\n    return k % HN;\n}\nint hash2(int k){\n    return 1 + k%(HN-1);\n}\nint hash(int k, int i){\n    return (hash1(k) + i*hash2(k))%HN;\n}\nvoid dfs(int p[N][N], int n){\n    int i,j,i0,j0,a=0,b=1,f=0,tmp[N][N];\n    for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n            if(ans[i][j]!=p[i][j])f++;\n            if(p[i][j]==0){\n                i0=i;\n                j0=j;\n            }\n            a+=p[i][j]*b;\n            b*=10;\n        }\n    }\n    if(f==0&&min>=n) {\n        min=n;\n        return;\n    }\n    if(n>min) return;\n    i=0;\n    while(1){\n        b=hash(a, i);\n        if(h[b].key == 0){\n            h[b].key=a;\n            h[b].depth=n;\n            break;\n        }else if(h[b].key == a){\n            if(h[b].depth>n){\n                h[b].depth=n;\n                break;\n            }\n            else return;\n        }\n        i++;\n    }\n    if(i0>0 && i0<N){\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0-1][j0];\n        tmp[i0-1][j0]=f;\n        dfs(tmp, n+1);\n    }\n    if(j0>0 && j0<N){\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0][j0-1];\n        tmp[i0][j0-1]=f;\n        dfs(tmp, n+1);\n    }\n    if(i0>=0 && i0<N-1){\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0+1][j0];\n        tmp[i0+1][j0]=f;\n        dfs(tmp, n+1);\n    }\n    if(j0>=0 && j0<N-1){\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i0][j0];\n        tmp[i0][j0]=tmp[i0][j0+1];\n        tmp[i0][j0+1]=f;\n        dfs(tmp, n+1);\n    }\n}\nint main(){\n    int i,j,p[N][N];\n    for(i=0;i<N;i++)\n        for(j=0;j<N;j++)\n            scanf(\"%d\",&p[i][j]);\n    dfs(p,0);\n    printf(\"%d\\n\",min);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 3\n\ntypedef struct{\n  int P[N][N];\n}Pazz;\n\nPazz Q;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n\nint Heu(Pazz Q){\n  int i ,j;\n  int hx,hy,sum=0;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      if(Q.P[i][j]==0)continue;\n\n      hx=(Q.P[i][j]-1)%N-j;\n      hy=(Q.P[i][j]-1)/N-i;\n\n      if(hx<0)sum-=hx;\n      else sum+=hx;\n\n      if(hy<0)sum-=hy;\n      else sum+=hy;\n    }\n  }\n  return sum;\n}\nint dfs (int x,int y,int max,int count,int n){\n  int i,temp;\n  int x0,y0,ans=-1,h;\n\n  h=Heu(Q);\n\n  if(h==0)return count;\n  if((count+h) > max)return -1;\n\n  for(i=0;i<4;i++){\n    x0=x+dx[i];\n    y0=y+dy[i];\n\n    if(((i == (n+2)%4 )&& (n!=-1))||!((0<=x0 )&&( x0<N) && (0<=y0) && (y0<N)))continue;\n    temp=Q.P[y][x];\n    Q.P[y][x]=Q.P[y0][x0];\n    Q.P[y0][x0]=temp;\n\n    ans= dfs(x0,y0,max,count+1,i);\n\n    if(ans!=-1)return ans;\n    temp=Q.P[y][x];\n    Q.P[y][x]=Q.P[y0][x0];\n    Q.P[y0][x0]=temp;\n  }\n\n  return -1;\n\n}\n\nint main(){\n  int i,j;\n  int kx,ky,ans,a;\n  Pazz tP;\n\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&a);\n      Q.P[i][j]=a;\n      if(a==0){\n        kx=j;\n        ky=i;\n      }\n    }\n  }\n\n  tP=Q;\n  for(i=1;i<46;i++){\n    Q=tP;\n    ans=dfs(kx,ky,i,0,-1);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define MAX 100000000\n\n#define N 3\n#define N2 9\n#define LIMIT 31\n\ntypedef struct { char b[N2+1]; } Board;\nBoard board;\nint minstep;\ntypedef enum { R, U, L, D } Direction;\ntypedef struct { int pos; Direction dir; } Motion;\n\nconst Motion motion[N2][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nconst int rr[4][5] = {{0,0,1,0,0},{0,0,0,1,0},{1,0,0,0,0},{0,1,0,0,0}};\n\nint dd[N2][N2];\nint dist(char *b)\n{\n  int i, n, d = 0;\n  for (i=0; i<N2; i++) {\n    n = b[i]-1;\n    if (n<0)   continue;\n    d += dd[n][i];\n  }\n  return d;\n}\n\nvoid search(int step, Motion prev)\n{\n  int i, d=0;\n  d = dist(board.b);\n  if (step+d>minstep) return;\n  if (d==0) {\n    printf(\"%d\\n\", step);\n    exit(0);\n  }\n  Board board_bak = board;\n  for (i=0; motion[prev.pos][i].pos>=0; i++) {\n    Motion m = motion[prev.pos][i];\n    if (rr[m.dir][prev.dir]) continue; //元に戻るのを防止\n    board.b[prev.pos] = board.b[m.pos];\n    board.b[m.pos] = 0;\n    search(step+1, m);\n    board = board_bak;\n  }\n}\n\nvoid aaaaa(int a){\n  int i, count=0;\n  for(i=0; i<a; i++)count++;\n}\n\nint main()\n{\n  int i, j, a=10;\n  for (i=0; i<N2; i++)\n    for (j=0; j<N2; j++)\n      dd[i][j] = abs(i%N-j%N) + abs(i/N-j/N);\n  \n  Motion m;\n  m.dir = 4;\n  Board ini_board;\n  for (i=0; i<N2; i++) {\n    fscanf(stdin, \"%hd\", (short int*)&ini_board.b[i]);\n    if (ini_board.b[i]==0) m.pos = i;\n  }\n  for (minstep=dist(ini_board.b); minstep<=LIMIT; minstep++) {\n    board = ini_board;\n    search(0, m);\n  }\n  puts(\"no result.\");\n  aaaaa(a);\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define tate 3\n#define yoko 3\n#define total (tate*yoko)\n#define N 45\n\nextern inline void down(void);\nextern inline void up(void);\nextern inline void right(void);\nextern inline void left(void);\nextern int puzzle(int x,int y,int a,int b);\n\nint n=0,board[total]={};\n\nint main(void)\n{\n  int i,x,y;\n  for(i=0;i<total;i++)\n    {\n      scanf(\"%d\",&board[i]);\n      if(board[i]==0)\n        {\n          n=i;\n        }\n    }\n  x=tate-(n/yoko)-1;\n  y=yoko-(n%yoko)-1;\n\n  for(i=0;i<N;i++)\n    {\n      if(puzzle(x,y,i,4)==1)\n        {\n          printf(\"%d\\n\",i);\n          break;\n        }\n    }\n  return 0;\n}\n\nint puzzle(int x,int y,int a,int b)\n{\n  int result,i;\n  if(a<(x+y))\n    {\n      return 0;\n    }\n  if(a==0)\n    {\n      for(i=0;i<total-1;i++)\n        {\n          if(board[i]!=(i+1))\n            {\n              return 0;\n            }\n        }\n      return 1;\n    }\n  for(i=0;i<4;i++)\n    {\n      result=0;\n      switch(i)\n        {\n        case 0:\n        if((x>0) && (b!=3))\n          {\n            down();\n            result=puzzle(x-1,y,a-1,0);\n            up();\n          }\n        break;\n        case 1:\n          if((y>0) && (b!=2))\n            {\n              right();\n              result=puzzle(x,y-1,a-1,1);\n              left();\n            }\n          break;\n        case 2:\n          if((y<yoko-1) && (b!=1))\n            {\n              left();\n              result=puzzle(x,y+1,a-1,2);\n              right();\n            }\n          break;\n        case 3:\n          if((x<tate-1) && (b!=0))\n            {\n              up();\n              result=puzzle(x+1,y,a-1,3);\n              down();\n            }\n          break;\n        default:\n          break;\n        }\n      if(result)\n        {\n          return 1;\n        }\n    }\n  return 0;\n}\n\ninline void down()\n{\n  board[n]=board[n+yoko];\n  n=n+yoko;\n}\n\ninline void up()\n{\n  board[n]=board[n-yoko];\n  n=n-yoko;\n}\n\ninline void right()\n{\n  board[n]=board[n+1];\n  n=n+1;\n}\n\ninline void left()\n{\n  board[n]=board[n-1];\n  n=n-1;\n}\n          \n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n int puzle[3][3];\n int tmp[3][3];\n int d1[4]={0,1,0,-1};\n int d2[4]={1,0,-1,0};\n \n void empty(int *x,int *y){\n                           int i,j;\n                           for(i=0;i<3;i++){\n                                            for(j=0;j<3;j++){\n                                                             if(!puzle[i][j]){\n                                                                              *x=j;\n                                                                              *y=i;\n                                                                              return;\n                                                                              }\n                                                              }\n                                             }\n                            }\n\n void swap(int *a,int *b){\n                          int tmp=*a;\n                          *a=*b;\n                          *b=tmp;\n                          }\n\n int cal(){\n           int a,i,sum=0;\n           for(i=0;i<9;i++){\n                            a=puzle[i/3][i%3];\n                            if(a){\n                                  a--;\n                                  sum+=abs(i/3-a/3)+abs(i%3-a%3);\n                                  }\n                            }\n           return sum;\n           }\n\n int dfs(int x,int y,int p,int dep,const int lim){\n       int i,h,n1,n2,res;\n       h=cal();\n       if(h==0){\n                return dep;\n                }\n       if(dep+h>lim){\n                     return -1;\n                     }\n       for(i=0;i<4;++i){\n                        n1=x+d1[i];\n                        n2=y+d2[i];\n \n                        if(~p&&i==(p+2)%4)continue;\n                        if(!(0<=n1&&n1<3&&0<=n2&&n2<3))continue;\n                        swap(&puzle[y][x],&puzle[n2][n1]);\n                        res=dfs(n1,n2,i,dep+1,lim);\n\n                        if(~res)return res;\n \n                        swap(&puzle[y][x],&puzle[n2][n1]);\n                        }\n       return -1; \n       }\n\n int main(){\n            int ans,x,y,l,i,j;\n\n            for(i=0;i<3;i++){\n                             for(j=0;j<3;j++){\n                                              scanf(\"%d\",&puzle[i][j]);\n                                              }\n                             }\n            empty(&x,&y);\n            for(l=0;l<100;l++){\n                               for(i=0;i<3;i++){\n                                                for(j=0;j<3;j++){\n                                                                 tmp[i][j]=puzle[i][j];\n                                                                 }\n                                                }\n                                ans=dfs(x,y,-1,0,l);\n                                if(ans!=-1){\n                                            printf(\"%d\\n\",ans);\n                                            break;\n                                            }\n                                for(i=0;i<3;i++){\n                                                 for(j=0;j<3;j++){\n                                                                  puzle[i][j]=tmp[i][j];\n                                                                  }\n                                                 }\n                                ans=-1;\n                                if(l==99)printf(\"%d\\n\",ans);\n                                }\n            return 0;\n            }\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n \n#define N 3\n#define LIM 32\n#define HN 362897\n \n \n \nstruct dep{\n  int depth,key;\n};\n   \n   \n   \nint ans[N][N]={\n  {1,2,3},\n  {4,5,6},\n  {7,8,0}\n};\n \nint min = LIM;\nstruct dep h[HN];\n \nint hash1(int k)\n{\n  return k % HN;\n}\nint hash2(int k)\n{\n  return 1 + k%(HN-1);\n}\nint hash(int k, int i)\n{\n  return (hash1(k) + i*hash2(k))%HN;\n}\n \n \nvoid dfs(int p[N][N], int n)\n{\n  int i,j,i0,j0,a=0,b=1;\n  int f=0;\n  int tmp[N][N];\n  for(i=0;i<N;i++)\n  {\n    for(j=0;j<N;j++)\n    {\n      if(ans[i][j]!=p[i][j])f++;\n      if(p[i][j]==0)\n      {\n        i0=i;\n        j0=j;\n      }\n      a+=p[i][j]*b;\n      b*=10;\n    }\n  }\n \n  if(f==0)\n  {\n    if(min>=n)\n    {\n      min=n;\n    }\n    return;\n  }\n  if(n>min) return;\n  i=0;\n  while(1)\n  {\n    b=hash(a, i);\n    if(h[b].key == 0)\n    {\n      h[b].key=a;\n      h[b].depth=n;\n      break;\n    }\n    else if(h[b].key == a)\n    {\n      if(h[b].depth>n)\n      {\n        h[b].depth=n;\n        break;\n      }\n      else return;\n    }\n    i++;\n  }\n \n  if(i0>0 && i0<N)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0-1][j0];\n    tmp[i0-1][j0]=f;\n    dfs(tmp, n+1);\n  }\n  if(j0>0 && j0<N)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0][j0-1];\n    tmp[i0][j0-1]=f;\n    \n    dfs(tmp, n+1);\n  }\n \n  if(i0>=0 && i0<N-1)\n  \n  \n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0+1][j0];\n    tmp[i0+1][j0]=f;\n    dfs(tmp, n+1);\n  }\n  if(j0>=0 && j0<N-1)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0][j0+1];\n    tmp[i0][j0+1]=f;\n    dfs(tmp, n+1);\n  }\n \n \n}\n \nint main()\n{\n  int i,j;\n  int p[N][N];\n \n  for(i=0;i<N;i++)\n  {\n    for(j=0;j<N;j++)\n    {\n      scanf(\"%d\",&p[i][j]);\n    }\n  }\n  dfs(p,0);\n \n \n  printf(\"%d\\n\",min);\n \n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint puzzle[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nvoid empty(int *,int *);\nint dfs(int,int,int,int,const int);\nint cal();\nvoid swap(int *,int *);\n\nint main() {\n    int i,j,a,x,y,l;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) scanf(\"%d\",&puzzle[i][j]);\n    }\n\n    empty(&x,&y);\n    for(l=0; l<100; l++) {\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) tmp[i][j] = puzzle[i][j];\n        }\n\n        a = dfs(x,y,-1,0,l);\n        if(a!=-1) {\n            printf(\"%d\\n\",a);\n            break;\n        }\n\n        for(i=0 ; i<3 ; i++) {\n            for(j=0 ; j<3 ; j++) puzzle[i][j] = tmp[i][j];\n        }\n        a = -1;\n        if(l==99) printf(\"%d\\n\",a);\n    } \n    return 0;\n}\n\nvoid empty(int *x,int *y) {\n    int i,j;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) {\n            if(!puzzle[i][j]) {\n                *x = j;\n                *y = i;\n                return;\n            }\n        }\n    }\n}\n\nvoid swap(int *a,int *b) {\n    int tmp;\n    tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n\nint cal() {\n    int i,a,sum=0;\n    for(i=0; i<9; i++) {\n        a = puzzle[i/3][i%3];\n        if(a) {\n            a--;\n            sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n        }\n    }\n    return sum;\n}\n\nint dfs(int x,int y,int p,int dep,const int lim) {\n    int i,h,nx,ny,res;\n\n    h = cal();\n    if(h==0) return dep;\n    if(dep+h>lim) return -1;\n\n    for(i=0; i<4; i++) {\n        nx = x+dx[i];\n        ny = y+dy[i];\n \n        if(~p && i==(p+2)%4) continue;\n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n \n        swap(&puzzle[y][x],&puzzle[ny][nx]);\n        res = dfs(nx,ny,i,dep+1,lim);\n        if(~res) return res;\n \n        swap(&puzzle[y][x],&puzzle[ny][nx]);\n    }\n\n    return -1;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define TRUE  1\n#define FALSE 0\n#define FORWARD  1\n#define BACKWARD 2\n#define SIZE  9\n#define NIL   (-1)\n\n/* 状態数 (9! / 2) */\n#define MAX_STATE 181440\n\n/* 隣接リスト */\nconst char adjacent[SIZE][5] = {\n  1, 3,-1,-1,-1,\n  0, 4, 2,-1,-1,\n  1, 5,-1,-1,-1,\n  0, 4, 6,-1,-1,\n  1, 3, 5, 7,-1,\n  2, 4, 8,-1,-1,\n  3, 7,-1,-1,-1,\n  4, 6, 8,-1,-1,\n  5, 7,-1,-1,-1,\n};\n\n/* キュー */\nchar state[MAX_STATE + 1][SIZE];      /* +1 はワーク領域 */\nchar space_postion[MAX_STATE];\nint  prev_state[MAX_STATE];\nint  number_table[MAX_STATE];\n\n/* 同一局面チェックテーブル */\nchar check_table[MAX_STATE * 2];\n\n/* 初期状態 */\nchar init_state[SIZE];\n\n/* 終了状態 */\nchar final_state[SIZE] = {\n  1, 2, 3, 4, 5, 6, 7, 8, 0\n};\n\nint count=0;\n\nvoid print_answer_forward(int n)\n{\n  if(n > 1) print_answer_forward(prev_state[n]);\n  count++;\n}\n\nvoid print_answer_backward( int n )\n{\n  do{\n    n = prev_state[n];\n    count++;\n  }\n\n  while( prev_state[n] != -1 );\n}\n\nvoid print_answer( int pos1, int num1, int num2 )\n{\n  /* num2 の位置を見つける */\n  int pos2 = pos1 - 1;\n\n  while( num2 != number_table[pos2] ) pos2--;\n\n  if( check_table[num1] == FORWARD ){\n    print_answer_forward( pos1 );\n    print_answer_backward( pos2 );\n  }\n  else{\n    print_answer_forward( pos2 );\n    print_answer_backward( pos1 );\n  }\n}\n\n/* 番号に変換 */\nint change_number( char *board )\n{\n  char work[SIZE];\n  static int fact_table[SIZE] = {\n    40320, 5040, 720, 120, 24, 6, 2, 1, 0,\n  };\n  int j, k, value = 0;\n  memcpy( work, board, SIZE );\n  for( j = 0; j < SIZE - 1; j++ ){\n    value += fact_table[j] * work[j];\n    for( k = j + 1; k < SIZE; k++ ){\n      if( work[j] < work[k] ) work[k]--;\n    }\n  }\n  return value;\n}\n\n/* キューの初期化 */\nvoid init_queue( void )\n{\n  int num;\n\n  /* スタート */\n  memcpy( state[0], init_state, SIZE );\n  space_postion[0] = 7;\n  prev_state[0] = -1;\n  num = change_number( init_state );\n  number_table[0] = num;\n  check_table[ num ] = FORWARD;\n\n  /* ゴール */\n  memcpy( state[1], final_state, SIZE );\n  space_postion[1] = 8;\n  prev_state[1] = -1;\n  num = change_number( final_state );\n  number_table[1] = num;\n  check_table[ num ] = BACKWARD;\n}\n\n/* 探索 */\nvoid search( void )\n{\n  int front = 0, rear = 2;\n\n  /* 初期化 */\n  init_queue();\n\n  while( front < rear ){\n    int s = space_postion[front];\n    int num1 = number_table[front];\n    int num2, i, n;\n\n    for( i = 0; (n = adjacent[s][i]) != -1; i++ ){\n      /* 状態をコピー */\n      memcpy( state[rear], state[front], SIZE );\n      /* 移動 */\n      state[rear][s] = state[rear][n];\n      state[rear][n] = 0;\n      space_postion[rear] = n;\n      prev_state[rear] = front;\n      num2 = change_number( state[rear] );\n\n      if( !check_table[num2] ){\n\t/* 登録 */\n        number_table[rear] = num2;\n        check_table[num2] = check_table[num1];\n\trear++;\n      }\n      else if( check_table[num1] != check_table[num2] ){\n        /* 解が見つかった */\n        print_answer( rear, num1, num2 );\n        return;\n      }\n    }\n    front++;\n  }\n}\n\nint main()\n{\n  int i;\n  \n  for(i = 0; i < 9; i++){\n    scanf(\"%d\", &init_state[i]);\n  }\n  \n  search();\n  printf(\"%d\\n\", count-1);  \n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 3\n\nint main(){\n  int i, j;\n  int c[N][N];\n  int sum = 0;\n\n  for(i = 0; i < N; i++){\n    for(j = 0; j < N; j++){\n      scanf(\"%d\", &c[i][j]);\n    }\n  }\n\n  if(c[0][0] == 2 || c[0][0] == 4){\n    sum = sum + 1;\n  }else if(c[0][0] == 3 || c[0][0] == 5 || c[0][0] == 7){\n    sum = sum + 2;\n  }else if(c[0][0] == 6 || c[0][0] == 8){\n    sum = sum + 7;\n  }\n  if(c[0][1] == 1 || c[0][1] == 3 || c[0][1] == 5){\n    sum = sum + 1;\n  }else if(c[0][1] == 4 || c[0][1] == 6 || c[0][1] == 8){\n    sum = sum + 2;\n  }else if(c[0][1] == 7){\n    sum = sum + 5;\n  }\n  if(c[0][2] == 2 || c[0][2] == 6){\n    sum = sum + 1;\n  }else if(c[0][2] == 1 || c[0][2] == 5){\n    sum = sum + 2;\n  }else if(c[0][2] == 4 || c[0][2] == 8){\n    sum = sum + 3;\n    if(c[1][1] == 1){\n      sum = sum + 6;\n    }\n  }else if(c[0][2] == 7){\n    sum = sum + 8;\n  }\n  if(c[1][0] == 1 || c[1][0] == 5 || c[1][0] == 7){\n    sum = sum + 1;\n  }else if(c[1][0] == 2 || c[1][0] == 6 || c[1][0] == 8){\n    sum = sum + 2;\n  }else if(c[1][0] == 3){\n    sum = sum + 3;\n  }\n  if(c[1][1] == 2 || c[1][1] == 4 || c[1][1] == 6 || c[1][1] == 8){\n    sum = sum + 1;\n  }else if(c[1][1] == 1 || c[1][1] == 3 || c[1][1] == 7){\n    sum = sum + 2;\n  }\n  if(c[1][2] == 3 || c[1][2] == 5){\n    sum = sum + 1;\n  }else if(c[1][2] == 2 || c[1][2] == 4 || c[1][2] == 8){\n    sum = sum + 2;\n  }else if(c[1][2] == 1 || c[1][2] == 7){\n    sum = sum + 6;\n  }\n  if(c[2][0] == 4 || c[2][0] == 8){\n    sum = sum + 1;\n  }else if(c[2][0] == 1 || c[2][0] == 5){\n    sum = sum + 2;\n  }else if(c[2][0] == 2 || c[2][0] == 6){\n    sum = sum + 6;\n  }else if(c[2][0] == 3){\n    sum = sum + 9;\n  }\n  if(c[2][1] == 5 || c[2][1] == 7){\n    sum = sum + 1;\n  }else if(c[2][1] == 2 || c[2][1] == 4 || c[2][1] == 6){\n    sum = sum + 2;\n  }else if(c[2][1] == 1 || c[2][1] == 3){\n    sum = sum + 5;\n    if(c[0][0] == 8){\n      sum = sum + 3;\n    }\n  }\n  if(c[2][2] == 6 || c[2][2] == 8){\n    sum = sum + 1;\n  }else if(c[2][2] == 3 || c[2][2] == 5 || c[2][2] == 7){\n    sum = sum + 2;\n  }else if(c[2][2] == 2 || c[2][2] == 4){\n    sum = sum + 4;\n    if(c[2][1] == 1){\n      sum = sum + 7;\n    }\n  }else if(c[2][2] == 1){\n    sum = sum + 9;\n    if(c[2][0] == 3 && c[0][2] == 7){\n      sum = sum - 6;\n    }\n    if(c[0][0] == 8 || c[0][0] == 6){\n      sum = sum - 2;\n    }\n  }\n\n  printf(\"%d\\n\", sum);\n    \n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "int main() {\n  int i, x, y;\n  current = 0;\n\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &board[i]);\n    if (!board[i])\n      zeroIndex = i;\n  }\n\n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n\n  while (current < 50) {\n    if (blindSearch(x, y, current, -1)) {\n      printf(\"%d\\n\", current);\n      break;\n    }\n    current++;\n  }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX 3\n\nint pane[MAX][MAX];\nint temp[MAX][MAX];\nint d_x[4]={0,1,0,-1};\nint d_y[4]={1,0,-1,0};\n\nvoid empty(int *row,int *col){\n  int i,j;\n  for(i=0;i<MAX;i++)\n    for(j=0;j<MAX;j++)\n      if(!pane[i][j]){\n\t*row=j;\n\t*col=i;\n\treturn;\n      }  \n}\n   \nvoid swap(int *a,int *b){\n  int temp;\n  temp = *a;*a = *b;*b = temp;\n}\n  \nint cal(){\n  int i,e;\n  int count=0; \n  for(i=0;i<9;i++){\n    e=pane[i/3][i%3];\n    if(e){\n      e--;\n      count+=abs(i/3-e/3)+abs(i%3-e%3);\n    }\n  }   \n  return count;\n}\n  \nint dfs(int x,int y,int p,int deep,const int limt){\n  int i;\n  int len;\n  int x_2,y_2;\n  int emc;   \n  len=cal();\n  if(len==0) return deep;\n  if(deep+len>limt) return -1; \n  for(i=0;i<4;i++){\n    x_2=x+d_x[i];\n    y_2=y+d_y[i];      \n    if(~p&&i==(p+2)%4) continue;\n    if(!(0<=x_2 && x_2<3 && 0<=y_2 && y_2<3)) continue;    \n    swap(&pane[y][x],&pane[y_2][x_2]);\n    emc=dfs(x_2,y_2,i,deep+1,limt);\n    if(~emc) return emc;       \n    swap(&pane[y][x],&pane[y_2][x_2]);\n  }   \n  return -1;\n} \n\nint main() {\n  int i,j;\n  int h,a,row,col;\n      \n  for(i=0;i<MAX;i++){\n    for(j=0;j<MAX;j++)\n      scanf(\"%d\",&pane[i][j]);\n  }  \n  empty(&row,&col);  \n  for(h=0;h<100;h++){\n    for(i=0;i<MAX;i++){\n      for(j=0;j<MAX;j++)\n\ttemp[i][j]=pane[i][j];\n    }    \n    a=dfs(row,col,-1,0,h);    \n    if(a!=-1){\n      printf(\"%d\\n\",a);\n      break;\n    }    \n    for(i=0;i<MAX;i++){\n      for(j=0;j<MAX;j++)\n\tpane[i][j]=temp[i][j];\n    }    \n    a=-1;\n    if(h==99) printf(\"%d\\n\\n\",a);\n  }      \n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint mas[3][3];\nint cpy[3][3];\n\nvoid input() {\n  int i, j;\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++)\n      scanf(\"%d\", &mas[i][j]);\n}\n\nvoid output() {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n  }\n}\n\nint calc() {\n  int i, sum = 0;\n  for(i = 0; i < 9; i++) {\n    int v = mas[i/3][i%3];\n    if(v) {\n      v--;\n      sum += abs(i/3-v/3)+abs(i%3-v%3);\n    }\n  }\n  return sum;\n}\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nint dfs(int x, int y, int p, int dep, const int lim) {\n  int i, h = calc(),a;\n  if(h == 0) return dep;\n  if(dep+h > lim) return -1;\n\n  for(i = 0; i < 4; i++) {\n    int nx = x+dx[i], ny = y+dy[i], res;\n    if(~p && i == (p+2)%4) continue;\n    if(!(0<=nx&&nx<3&&0<=ny&&ny<3)) continue;\n    a = mas[y][x];\n    mas[y][x] = mas[ny][nx];\n    mas[ny][nx] = a;\n    res = dfs(nx, ny, i, dep+1, lim);\n    if(~res) return res;\n    a = mas[y][x];\n    mas[y][x] = mas[ny][nx];\n    mas[ny][nx] = a;\n  }\n\n  return -1;\n}\n\nvoid get_empty(int *x, int *y) {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) {\n      if(!mas[i][j]) {\n    *x = j;\n    *y = i;\n    return;\n      }\n    }\n  }\n}\n\nint solve() {\n  int x, y, lim, ans,i,j;\n  get_empty(&x, &y);\n  for(lim = 0; lim < 50; lim++) {\n  \tfor(i = 0; i < 3; i++)\n  \t    for(j = 0; j < 3; j++) cpy[i][j] = mas[i][j];\n    if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n    for(i = 0; i < 3; i++)\n        for(j = 0; j < 3; j++) mas[i][j] = cpy[i][j];\n  }\n  return -1;\n}\n\nint main() {\n  input();\n  printf(\"%d\\n\", solve());\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n \ntypedef unsigned char uchar;\n \n#define HASHSIZ 543217\ntypedef struct { unsigned s; char x, v; } HASH;\nHASH hash[HASHSIZ+3], *hashend = hash+HASHSIZ;\n \nint lookup(unsigned s, int x)\n{\n    long long t = ((long long)x << 32) + s;\n    HASH *hp = hash + (int)(t % HASHSIZ);\n    while (hp->s) {\n        if (hp->s == s && hp->x == x) return hp->v;\n        if (++hp == hashend) hp = hash;\n    }\n    return 0;\n}\n \nvoid insert(unsigned s, int x, char v)\n{\n    long long t = ((long long)x << 32) + s;\n    HASH *hp = hash + (int)(t % HASHSIZ);\n    while (hp->s) {\n        if (hp->s == s && hp->x == x) { hp->v = v; break; }\n        if (++hp == hashend) hp = hash;\n    }\n    hp->s = s, hp->x = x, hp->v = v;\n}\n \n#define QMAX 50000\ntypedef struct { unsigned s; char x, v; } T;\nT s[QMAX+3]; int top, end;\nint hi[9] = {2,3,2,3,4,3,2,3,2};\nint to[9][4] = {{1,3},{0,2,4},{1,5},{0,4,6},{1,3,5,7},{2,4,8},{3,7},{4,6,8},{5,7}};\n \nvoid toArray(char *nine, unsigned s, int x)\n{\n    int i;\n     \n    for (i = 8; i >= 0; i--) {\n        if (i == x) nine[i] = 0;\n        else nine[i] = s & 0xf, s >>= 4;\n    }\n}\n \nunsigned swap(char *nine, int zero, int nx)\n{\n    int i;\n    unsigned res;\n     \n    res = 0;\n    for (i = 0; i < 9; i++) {\n        if      (i == zero) res <<= 4, res |= nine[nx];\n        else if (i != nx)   res <<= 4, res |= nine[i];\n    }\n    return res;\n}\n \n#define MAGIC 20\n \nint main()\n{\n    int i, x, nx, v, nv, t;\n    unsigned a, na;\n    unsigned gs; int gx;    // goal\n    char nine[9];\n     \n    gs = 0; for (i = 0; i < 9; i++) {\n        scanf(\"%d\", &t);\n        if (t == 0) gx = i;\n        else gs <<= 4, gs |= t;\n    }\n    s[0].s = 0x12345678, s[0].x = 8;\n    s[1].x = -1;\n    top = 0, end = 2;\n    insert(s[0].s, s[0].x, 0);\n    v = 0;\n    while (top != end) {\n        a = s[top].s, x = s[top].x;\n        if (++top == QMAX) top = 0; \n        if (x < 0) {\n            if (v == MAGIC) break;\n            v++;\n            s[end].x = -1; if (++end == QMAX) end = 0;\n            continue;\n        }\n        if (x == gx && a == gs) goto done;\n        if (lookup(a, x) < v) continue;\n \n        toArray(nine, a, x);\n        for (i = 0; i < hi[x]; i++) {\n            nx = to[x][i];\n            na = swap(nine, x, nx), nv = v+1;\n            t = lookup(na, nx);\n            if (!t || nv < t) {\n                s[end].s = na, s[end].x = nx;\n                if (++end == QMAX) end = 0;\n                insert(na, nx, nv);\n            }\n        }\n    }\n \n    s[0].s = gs, s[0].x = gx, s[1].x = -1;\n    top = 0, end = 2;\n    v = 0;\n    while (top != end) {\n        a = s[top].s, x = s[top].x;\n        if (++top == QMAX) top = 0; \n        if (x < 0) {\n            v++;\n            s[end].x = -1; if (++end == QMAX) end = 0;\n            continue;\n        }\n        if ((t = lookup(a, x)) > 0) { v += t; break; }\n \n        toArray(nine, a, x);\n        for (i = 0; i < hi[x]; i++) {\n            nx = to[x][i];\n            na = swap(nine, x, nx), nv = v+1;\n            t = lookup(na, nx);\n            if (!t || nv < t) {\n                s[end].s = na, s[end].x = nx;\n                if (++end == QMAX) end = 0;\n            }\n        }\n    }\ndone:\n    printf(\"%d\\n\", v);\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint a[10],fa[10]={1,1,2,6,24,120,720,5040,40320};\nint que[363000],quec,dp[362880];\n\nvoid swap(int i,int j){\n  int t;\n  t=a[i];\n  a[i]=a[j];\n  a[j]=t;\n}\n\nint ff(){\n  int i,ans=0,b=0;\n  for(i=8;i>=0;i--){\n    ans+=__builtin_popcount(b&((1<<a[i])-1))*fa[8-i];\n    b|=1<<a[i];\n  }\n  return ans;\n}\n\nvoid gg(int n){\n  int i,b=0;\n  for(i=0;i<9;i++) a[i]=i;\n  for(i=0;i<9;i++){\n    int x;\n    x=n/fa[8-i];\n    n%=fa[8-i];\n    for(int j=x;j>0;j--)swap(i+j,i+j-1);\n  }\n}\n\nint que[363000],quec;\nvoid ck(int p,int k){\n  int x;\n  x=ff();\n  if(!dp[x]){\n    dp[x]=k+1;\n    que[quec++]=x*10+p;\n  }\n}\n\nint cal(){\n  int i,x,p;\n  for(i=0;i<quec;i++){\n    x=que[i]/10;\n    p=que[i]%10;\n    if(x==0) return dp[x]-1;\n    gg(x);\n    if(p<6)swap(p,p+3),ck(p+3,dp[x]),swap(p,p+3);\n    if(p>2)swap(p,p-3),ck(p-3,dp[x]),swap(p,p-3);\n    if(p%3<2)swap(p,p+1),ck(p+1,dp[x]),swap(p,p+1);\n    if(p%3>0)swap(p,p-1),ck(p-1,dp[x]),swap(p,p-1);\n  }\n  return -1;\n}\n\nint main(){\n  int p,i,t;\n  for(i=0;i<9;i++){\n    scanf(\"%d\",&t);\n    if(t) a[i]=t-1;\n    else{\n      a[i]=8;\n      p=i;\n    }\n  }\n  ck(p,0);\n  printf(\"%d\\n\",cal());\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint pazzle[3][3];\nint tmp[3][3];\nint test_x[4] = {0,1,0,-1};\nint test_y[4] = {1,0,-1,0};\n\nint main() {\n    int i,j,l,sign,x,y;\n        \n    for(i=0; i<3; i++){\n        for(j=0; j<3; j++) scanf(\"%d\",&pazzle[i][j]);\n    }\n         \n    emp(&x,&y);\n    for(l=0; l<100; l++){\n        for(i=0; i<3; i++){\n            for(j=0; j<3; j++) tmp[i][j] = pazzle[i][j];\n        }\n            \n        sign = dfs(x,y,-1,0,l);\n        if(sign!=-1){\n            printf(\"%d\\n\",sign);\n            break;\n        }\n            \n        for(i=0; i<3; i++){\n            for(j=0; j<3; j++) pazzle[i][j] = tmp[i][j];\n        }\n            \n        sign = -1;\n        if(l==99) printf(\"%d\\n\",sign);\n    }\n        \n    return 0;\n}\n\nvoid emp(int *x,int *y) {\n  int i,j;\n  for(i=0; i<3; i++) {\n    for(j=0; j<3; j++) {\n      if(!pazzle[i][j]) {\n    *x = j;\n    *y = i;\n      }\n    }\n  }\n}\nvoid swap(int *s,int *v){\n  int tmp;\n  tmp = *s;\n  *s = *v;\n  *v = tmp;\n}   \nint calc(){\n  int i,a,sum=0; \n  for(i=0; i<9; i++){\n    a = pazzle[i/3][i%3];\n    if(a){\n      a--;\n      sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n    }\n  }    \n  return sum;\n}\nint dfs(int x,int y,int p,int d,const int lim){\n    int i,h,x2,y2,res;   \n    h = calc();\n    if(h==0) {\n        return d;\n    }\n    if(d+h>lim) {\n        return -1;\n    }\n    for(i=0; i<4; i++){\n        x2 = x+test_x[i];\n        y2 = y+test_y[i];      \n        if(~p && i==(p+2)%4) continue;\n        if(!(0<=x2 && x2<3 && 0<=y2 && y2<3)) continue;    \n        swap(&pazzle[y][x],&pazzle[y2][x2]);\n        res = dfs(x2,y2,i,d+1,lim);\n        if(~res) {\n            return res;\n        }\n        swap(&pazzle[y][x],&pazzle[y2][x2]);\n    }   \n    return -1;\n}    \n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n\n\nextern inline void down_0(void);\nextern inline void up_0(void);\nextern inline void right_0(void);\nextern inline void left_0(void);\n\nextern int  serch(int x, int y, int MaxCnt);\nextern int  check(void);\n\nint cnt,num = 0;\nint val[Total] ={};\n\n\nint main( void )\n{\n    int i = 0;\n    int x,y = 0;\n    \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        \n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n    \n    x = tate - (num/yoko) -1;\n    y = yoko - (num%yoko) -1;\n    \n    for(i=1; i<20; i++)\n    {\n        if( serch(x,y,i) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt)\n{\n    int result;\n    int i=0;\n    \n    // 最大数で打ち切り\n    if(MaxCnt==0)\n    {\n        return check();\n    }\n    \n    //\n    if(x==0 && y==0)\n    {\n        if( check() )\n        {\n            return 1;\n        }\n    }\n    \n    // 上下左右で4回回す\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if(x > 0)\n                {\n                    down_0();\n                    \n                    result = serch(x-1, y, MaxCnt-1);\n                    \n                    up_0();\n                }\n                break;\n            case 1:\n                if(y > 0)\n                {\n                    right_0();\n                    \n                    result = serch(x, y-1, MaxCnt-1);\n                    \n                    left_0();\n                }\n                break;\n            case 2:\n                if(y < yoko)\n                {\n                    left_0();\n                    \n                    result = serch(x, y+1, MaxCnt-1);\n                    \n                    right_0();\n                }\n                break;\n            case 3:\n                if(x < tate)\n                {\n                    up_0();\n                    \n                    result = serch(x+1, y, MaxCnt-1);\n                    \n                    down_0();\n                }\n                break;\n            default:\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n        \n    }\n\n    return 0;\n}\n\n// TRUE : 完成\n// FALSE : 失敗\nint check()\n{\n    int i=0;\n    \n//    printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);\n    \n    for(i=0; i<Total-1; i++)\n    {\n        if(val[i] != (i+1))\n        {\n            return 0;\n        }\n    }\n    return 1;\n}\n\ninline void down_0()\n{\n    val[num] = val[num + yoko];\n    num = num + yoko;\n}\n \ninline void up_0()\n{\n    val[num] = val[num - yoko];\n    num = num - yoko;\n}\n \ninline void right_0()\n{\n    val[num] = val[num +1];\n    num = num + 1;\n}\n \ninline void left_0()\n{\n    val[num] = val[num -1];\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 3\n#define Na 4\n#define Nb 9\n#define Nc 100\n\nint puz[N][N];\nint temp[N][N];\nint dx[Na]={0,1,0,-1};\nint dy[Na]={1,0,-1,0};\n\nvoid emp(int x[],int y[]) {\n  int i, j;\n  for(i=0; i<N; i++) {\n    for(j=0; j<N; j++) {\n      if(!puz[i][j]) {\n        *x = j;\n        *y = i;\n        return;\n      }\n    }\n  }\n}\n\nvoid swap(int a[], int b[]){\n  int temp;\n  temp = *a;\n  *a = *b;\n  *b = temp;\n}\n\nint calsum(){\n  int i, a, sum=0;\n  for(i=0; i<Nb; i++){\n    a = puz[i/N][i%N];\n    if(a){\n      a--;\n      sum += abs((i/N)-(a/N)) + abs((i%N)-(a%N));\n    }\n  }\n  return sum;\n}\n\nint dfs(int x,int y,int p,int dep,const int lim){\n  int i, c, nx, ny, res;\n  c = calsum();\n  if(c==0) return dep;\n  if(dep+c>lim) return -1;\n  for(i=0;i<Na;i++){\n    nx = x + dx[i];\n    ny = y + dy[i];\n    if(~p && i==(p+2)%Nb) continue;\n    if(!(0<=nx && nx<N && 0<=ny && ny<N)) continue;\n    swap(&puz[y][x],&puz[ny][nx]);\n    res = dfs(nx,ny,i,dep+1,lim);\n    if(~res) return res;\n    swap(&puz[y][x],&puz[ny][nx]);\n  }\n  return -1;\n}\n\nint main() {\n  int i, j, k, x, y, ans;\n  for(i=0; i<N; i++){\n    for(j=0; j<N; j++) scanf(\"%d\",&puz[i][j]);\n  }\n  emp(&x,&y);\n  for(k=0; k<Nc; k++){\n    for(i=0; i<N; i++){\n      for(j=0; j<N; j++) temp[i][j] = puz[i][j];\n    }\n    ans=dfs(x,y,-1,0,k);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++) puz[i][j] = temp[i][j];\n    }\n    ans = -1;\n    if(k==Nc-1) printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define N 3\n#define pos(S, x, y) ((S).state.piece[(y)*N + (x)])\n\ntypedef enum {UP, DOWN, LEFT, RIGHT} Dir;\nstatic const int dx[4] = { 0, 0, -1, 1};\nstatic const int dy[4] = {-1, 1,  0, 0};\nstatic const int opposite[4] = {DOWN, UP, RIGHT, LEFT};\n\ntypedef struct _node {\n  union {\n    unsigned char piece[9];\n    struct {\n      unsigned long long int high;\n      unsigned long long int low;\n    } hash;\n  } state;\n  struct {\n    unsigned int x;\n    unsigned int y;\n  } emptyPos;\n  unsigned int moveCount;\n} Node;\n\ntypedef struct {\n  unsigned int size;\n  unsigned int head;\n  unsigned int tail;\n  Node** body;\n} Queue;\n\ntypedef struct _element {\n  Node* value;\n  struct _element* next;\n} Element;\n\ntypedef struct {\n  unsigned int size;\n  Element* body;\n} HashMap;\n\nvoid initHM(HashMap*);\nunsigned int hash(HashMap*, Node*);\nNode* find(HashMap*, Node*);\nvoid insert(HashMap*, Node*);\n\nvoid initQueue(Queue*);\nbool enqueue(Queue*, Node*);\nNode* dequeue(Queue*);\nbool isEmpty(Queue*);\nbool isFull(Queue*);\n\nint search(HashMap*, Queue*, Node*);\nNode* move(Node*, Dir);\nvoid print(Node*);\n\nint main () {\n  Node initialState;\n  Node finalState;\n\n  initialState.state.hash.high = 0;\n  initialState.state.hash.low = 0;\n  finalState.state.hash.high = 0;\n  finalState.state.hash.low = 0;\n  \n  unsigned int piece;\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < N; ++j) {\n      scanf(\"%u\", &piece);\n      pos(initialState, j, i) = piece & 0xf;\n      pos(  finalState, j, i) = (i*N + j + 1)%9;\n      if (piece == 0) {\n\tinitialState.emptyPos.x = j;\n\tinitialState.emptyPos.y = i;\t\n      }\n    }\n  }\n  initialState.moveCount = 0;\n  \n  HashMap map;\n  initHM(&map);\n  insert(&map, &initialState);\n  \n  Queue queue;\n  initQueue(&queue);\n  enqueue(&queue, &initialState);\n  \n  printf(\"%d\\n\", search(&map, &queue, &finalState));\n\n  return 0;\n}\n\nvoid print(Node* node) {\n  printf(\"%llu\\n\", node->state.hash.high);\n  printf(\"%llu\\n\", node->state.hash.low);\n  for (unsigned int i = 0; i < N; i++) {\n    for (unsigned int j = 0; j < N; j++) {\n      fprintf(stderr, \"%2d\", pos(*node, j, i));\n    }\n    fprintf(stderr, \"\\n\");\n  }\n  fprintf(stderr, \"\\n\");\n}\n\nint search (HashMap* map, Queue* queue, Node* target) {\n  Node* node = dequeue(queue);\n  //print(node);\n  \n  if (node->moveCount > 32 || (node->state.hash.high == target->state.hash.high && node->state.hash.low == target->state.hash.low)) {\n    return node->moveCount;\n  } else {\n    Node*   newNode;\n    Node* foundNode;\n    Dir dir;\n    \n    // Up\n    dir = UP;\n    newNode = move(node, dir);\n    if (newNode != NULL) {\n      if ((foundNode = find(map, newNode)) == NULL) {\n\tnewNode->moveCount = node->moveCount + 1;\n\tinsert(map, newNode);\n\tenqueue(queue, newNode);\n      }\n    }\n    \n    // Down\n    dir = DOWN;\n    newNode = move(node, dir);\n    if (newNode != NULL) {\n      if ((foundNode = find(map, newNode)) == NULL) {\n\tnewNode->moveCount = node->moveCount + 1;\n\tinsert(map, newNode);\n\tenqueue(queue, newNode);\n      }\n    }\n    \n    // Left\n    dir = LEFT;\n    newNode = move(node, dir);\n    if (newNode != NULL) {\n      if ((foundNode = find(map, newNode)) == NULL) {\n\tnewNode->moveCount = node->moveCount + 1;\n\tinsert(map, newNode);\n\tenqueue(queue, newNode);\n      }\n    }\n    \n    // Right\n    dir = RIGHT;\n    newNode = move(node, dir);\n    if (newNode != NULL) {\n      if ((foundNode = find(map, newNode)) == NULL) {\n\tnewNode->moveCount = node->moveCount + 1;\n\tinsert(map, newNode);\n\tenqueue(queue, newNode);\n      }\n    }\n\n    return search(map, queue, target);\n  }\n}\n\nNode* move(Node* node, Dir dir) {\n  Node* newNode = (Node*)malloc(sizeof(Node));\n\n  newNode->state.hash = node->state.hash;\n  newNode->emptyPos.x = node->emptyPos.x + dx[dir];\n  newNode->emptyPos.y = node->emptyPos.y + dy[dir];\n  \n  switch (dir) {\n  case UP:\n    if (node->emptyPos.y != 0) {\n      pos(*newNode, newNode->emptyPos.x, newNode->emptyPos.y) = pos(*node,    node->emptyPos.x,    node->emptyPos.y);\n      pos(*newNode,    node->emptyPos.x,    node->emptyPos.y) = pos(*node, newNode->emptyPos.x, newNode->emptyPos.y);\n    } else {\n      free(newNode);\n      newNode = NULL;\n    }\n    break;\n  case DOWN:\n    if (node->emptyPos.y != N - 1) {\n      pos(*newNode, newNode->emptyPos.x, newNode->emptyPos.y) = pos(*node,    node->emptyPos.x,    node->emptyPos.y);\n      pos(*newNode,    node->emptyPos.x,    node->emptyPos.y) = pos(*node, newNode->emptyPos.x, newNode->emptyPos.y);\n    } else {\n      free(newNode);\n      newNode = NULL;\n    }\n    break;\n  case LEFT:\n    if (node->emptyPos.x != 0) {\n      pos(*newNode, newNode->emptyPos.x, newNode->emptyPos.y) = pos(*node,    node->emptyPos.x,    node->emptyPos.y);\n      pos(*newNode,    node->emptyPos.x,    node->emptyPos.y) = pos(*node, newNode->emptyPos.x, newNode->emptyPos.y);\n    } else {\n      free(newNode);\n      newNode = NULL;\n    }\n    break;\n  case RIGHT:\n    if (node->emptyPos.x != N - 1) {\n      pos(*newNode, newNode->emptyPos.x, newNode->emptyPos.y) = pos(*node,    node->emptyPos.x,    node->emptyPos.y);\n      pos(*newNode,    node->emptyPos.x,    node->emptyPos.y) = pos(*node, newNode->emptyPos.x, newNode->emptyPos.y);\n    } else {\n      free(newNode);\n      newNode = NULL;\n    }\n    break;\n  }\n  //fprintf(stderr, \"Done Movement\\n\");\n  \n  return newNode;\n}\n\nvoid initHM(HashMap* map) {\n  map->size = 1000007;\n  map->body = (Element*)calloc(map->size, sizeof(Element));\n  if (map->body == NULL) {\n    //fprintf(stderr, \"Cannot allocate memory for hashmap\\n\");\n    exit(-1);\n  }\n  //fprintf(stderr, \"Done HashMap Initialization\\n\");\n}\n\nunsigned int hash(HashMap* map, Node* node) {\n  unsigned int value = 0;\n  for (int i = 0; i < N*N; i++) {\n    value *= 37;\n    value += node->state.piece[i];\n    value %= map->size;\n  }\n  return value;\n}\n\nNode* find(HashMap* map, Node* node) {\n  unsigned int index = hash(map, node);\n  Element* element = map->body[index].next;\n  \n  //fprintf(stderr, \"Start HashMap Search...\\n\");\n  //fprintf(stderr, \"%u\\n\", index);\n  while (element != NULL) {\n    if (element->value->state.hash.high == node->state.hash.high && element->value->state.hash.low == node->state.hash.low) {\n      //fprintf(stderr, \"Done HashMap Search -> true\\n\");\n      return element->value;\n    }\n    element = element->next;\n  }\n\n  //fprintf(stderr, \"Done HashMap Search -> false\\n\");\n  return NULL;\n}\n\nvoid insert(HashMap* map, Node* node) {\n  //fprintf(stderr, \"Start HashMap Insertion\\n\");\n  if (find(map, node) == NULL) {\n    unsigned int index = hash(map, node);\n    \n    Element* element = &map->body[index];\n    while (element->next != NULL) {\n      element = element->next;\n    }\n    \n    Element* newElement = (Element*)malloc(sizeof(Element));\n    newElement->value = node;\n    newElement->next  = NULL;\n\n    element->next = newElement;\n  }\n  //fprintf(stderr, \"Done HashMap Insertion\\n\");\n}\n\nvoid initQueue(Queue* queue) {\n  queue->size = 1000007;\n  queue->body = (Node**)malloc(sizeof(Node*)*queue->size);\n  queue->head = queue->size - 1;\n  queue->tail = 0;\n\n  //fprintf(stderr, \"Done Queue Initialization\\n\");\n}\n\nbool enqueue(Queue* queue, Node* node) {\n  if (isFull(queue)) {\n    return false;\n  }\n\n  queue->body[queue->tail++] = node;\n  queue->tail %= queue->size;\n\n  return true;\n}\n\nNode* dequeue(Queue* queue) {\n  if (isEmpty(queue)) {\n    return NULL;\n  }\n\n  queue->head = (queue->head + 1) % queue->size;\n  return queue->body[queue->head];\n}\n\nbool isEmpty(Queue* queue) {\n  return (queue->head + 1) % queue->size == queue->tail;\n}\n\nbool isFull(Queue* queue) {\n  return queue->head == queue->tail;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define N 3\n#define N2 9\n#define H 2\n\ntypedef struct puzzle puz;\n\nstruct puzzle{\n  int p[N][N];\n  int pos0;\n  int g;\n};\n\ntypedef struct list node;\n\nstruct list{\n  puz *p;\n  int f;\n  node *prev; //動かす前のノード\n  node *next; //リスト上の次のノード\n};\n\n/*void print_puz(puz p){\n  int i;\n  for(i = 0; i < N2; i++){\n    printf(\"%d, \", p.p[i/N][i%N]);\n    if(i%N == 2) printf(\"\\n\");\n  }\n  printf(\"%d\\n\", p.g);\n  }*/\n\nint h(puz p){\n  int i, mode, r = 0;\n  mode = H;\n  if(mode == 1){\n    for(i = 0; i < N2; i++){\n      if((p.p[i/N][i%N] != 0 || i != N2-1) && p.p[i/N][i%N] != i+1) r++;\n    }\n  }else if(mode == 2){\n    for(i = 0; i < N2; i++){\n      if(p.p[i/N][i%N] != 0) r += abs(i/N - (p.p[i/N][i%N]-1)/N) + abs(i%N - (p.p[i/N][i%N]-1)%N);\n\telse r += 2*(N-1) -i/N -i%N;\n    }\n  }\n    return r+p.g;\n}\n\npuz* move_p(puz m, int mode){\n  puz* n;\n  int i;\n  n = malloc(sizeof(puz));\n  for(i = 0; i < N2; i++) n->p[i/N][i%N] = m.p[i/N][i%N];\n  switch(mode){\n    case 0:\n      n->pos0 = m.pos0-N;\n    break;\n    case 1:\n      n->pos0 = m.pos0-1;\n    break;\n    case 2:\n      n->pos0 = m.pos0+N;\n    break;\n    case 3:\n      n->pos0 = m.pos0+1;\n    break;\n  }\n  n->p[m.pos0/N][m.pos0%N] = n->p[n->pos0/N][n->pos0%N];\n  n->p[n->pos0/N][n->pos0%N] = 0;\n  n->g = m.g+1;\n\n  return n;\n}\n\nnode* make_n(node *prev, puz *p){\n  node *n;\n  n = malloc(sizeof(node));\n  n->prev = prev;\n  n->p = p;\n  n->f = h(*p);\n  n->next = NULL;\n\n  return n;\n}\n\nint check_p(puz a, puz b){\n  int i;\n  for(i = 0; i < N2; i++){\n      if(a.p[i/N][i%N] != b.p[i/N][i%N]) break;\n      else if(i == N2-1) return 0;\n  }\n  return 1;\n}\n\nint check_c(node *t, puz *a){\n  int i;\n  puz *b;\n  while(t != NULL){\n    b = t->p;\n    if(check_p(*a, *b)) t = t->next;\n    else return 0;\n  }\n  return 1;\n}\n\nint add_open(node *t, node *a){\n  //tにopenリストの先頭を渡す\n  node *p = NULL;\n  while(t != NULL){\n    if(t->f == a->f){\n      if(check_p(*(t->p), *(a->p)) && t->f > a->f){\n          t->prev = a->prev;\n          return 0;\n        }\n      }else if(t->f > a->f){\n        if(p == NULL){\n          a->next = t;\n          return 1;\n        }else{\n          p->next = a;\n          a->next = t;\n          return 0;\n        }\n      }\n      p = t;\n      t = t->next;\n    }\n  if(p == NULL) return 1;\n    p->next = a;\n    return 0;\n  }\n\nint main(){\n  int i, count = 0;\n  clock_t s, e;\n  puz *p, start, goal;\n  node *n, *new;\n  node *open, *close;\n\n  for(i = 0; i < N2; i++){\n    scanf(\"%d\", &start.p[i/N][i%N]);\n    goal.p[i/N][i%N] = i+1;\n    if(start.p[i/N][i%N] == 0)start.pos0 = i;\n  }\n  goal.p[N-1][N-1] = 0;\n  goal.pos0 = N2-1;\n\n  start.g = 0;\n  \n  n = NULL;\n  open = make_n(n, &start);\n  close = NULL;\n\n  s = clock();\n  while(open != NULL){\n    count++;\n    if(check_p(*(open->p), goal) != 1) break;\n    //print_puz(*(open->p));\n    n = open;\n    open = open->next;\n    if(n->p->pos0 >= N){\n      p = move_p(*(n->p), 0);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    if(n->p->pos0%N != 0){\n      p = move_p(*(n->p), 1);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    if(n->p->pos0 < N*(N-1)){\n      p = move_p(*(n->p), 2);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    if(n->p->pos0%N != N-1){\n      p = move_p(*(n->p), 3);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    n->next = close;\n    close = n;\n  }\n\n  e = clock();\n\n  printf(\"%d\", count);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \nint p[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n \nvoid emp(int *,int *);\nint dfs(int,int,int,int,const int);\nint cal();\nvoid swap(int *,int *);\n \nint main() {\n    int i,j,a,x,y,l;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) scanf(\"%d\",&p[i][j]);\n    }\n    emp(&x,&y);\n    for(l=0; l<100; l++) {\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) tmp[i][j] = p[i][j];\n        }\n        a = dfs(x,y,-1,0,l);\n        if(a!=-1) {\n            printf(\"%d\\n\",a);\n            break;\n        }\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) p[i][j] = tmp[i][j];\n        }\n        a = -1;\n        if(l==99) printf(\"%d\\n\",a);\n    }\n     printf(\"%d\\n\",a);\n     return 0;\n}\n  \nvoid emp(int *x,int *y) {\n    int i,j;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) {\n            if(!p[i][j]) {\n                *x = j;\n                *y = i;\n                return;\n            }\n        }\n    }\n}\n \nvoid swap(int *a1,int *b1) {\n    int tmp;\n    tmp = *a1;\n    *a1 = *b1;\n    *b1 = tmp;\n}\n \nint cal() {\n    int i,a2,sum=0;\n    for(i=0; i<9; i++) {\n        a2 = p[i/3][i%3];\n        if(a2) {\n            a2--;\n            sum += abs(i/3 - a2/3) + abs(i%3 - a2%3);\n        }\n   }\n    return sum;\n}\n \nint dfs(int x,int y,int p1,int d,const int lim) {\n    int i,h,nx,ny,res;\n    h = cal();\n    if(h==0) return d;\n    if(d+h>lim) return -1;\n    for(i=0; i<4; i++) {\n        nx = x+dx[i];\n        ny = y+dy[i];\n        if(~p1 && i==(p1+2)%4) continue;\n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n        swap(&p[y][x],&p[ny][nx]);\n        res = dfs(nx,ny,i,d+1,lim);\n        if(~res) return res;\n        swap(&p[y][x],&p[ny][nx]);\n    }\n    return -1;\n}"
  },
  {
    "language": "C",
    "code": "#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n\n// I/O\nint get_uint() {\n    int n = 0;\n    int c = getchar_unlocked();\n    if(c < 48 || 57 < c) return c;\n    while(47 < c && c < 58) n = 10 * n + (c & 0xf), c = getchar_unlocked();\n    return n;\n}\nvoid put_uint(int n) {\n    if(!n) {\n        putchar_unlocked('0');\n        return;\n    }\n    char buf[11];\n    int i = 0;\n    while(n) buf[i++] = (char)(n % 10 + '0'), n /= 10;\n    while(i--)putchar_unlocked(buf[i]);\n}\n//\n\n\n// Util\n#define likely(x)   __builtin_expect(!!(x), 1)\n#define unlikely(x) __builtin_expect(!!(x), 0)\n#define container_of(ptr, type, member) ({  \\\n    void *__mptr = (void *)(ptr);           \\\n    ((type *)(__mptr - offsetof(type, member))); })\n//\n\n\n// Red Black Tree\nstruct rb_node {\n    unsigned long __rb_parent_color;\n    struct rb_node *rb_right;\n    struct rb_node *rb_left;\n} __attribute__((aligned(sizeof(long))));\n\nstruct rb_root {\n    struct rb_node *rb_node;\n};\n\n#define rb_parent(r) ((struct rb_node *)((r)->__rb_parent_color & ~3))\n#define RB_ROOT (struct rb_root) { NULL, }\n#define RB_EMPTY_NODE(node)  \\\n   ((node)->__rb_parent_color == (unsigned long)(node))\n\nstatic inline void rb_link_node(struct rb_node *node, struct rb_node *parent, struct rb_node **rb_link) {\n    node->__rb_parent_color = (unsigned long)parent;\n    node->rb_left = node->rb_right = NULL;\n    *rb_link = node;\n}\n\n#define RB_RED      0\n#define RB_BLACK    1\n\n#define __rb_color(pc)      ((pc) & 1)\n#define __rb_is_red(pc)     (!__rb_color(pc))\n#define __rb_is_black(pc)   __rb_color(pc)\n#define rb_color(rb)        __rb_color((rb)->__rb_parent_color)\n#define rb_is_red(rb)       __rb_is_red((rb)->__rb_parent_color)\n#define rb_is_black(rb)     __rb_is_black((rb)->__rb_parent_color)\n\nstatic inline void rb_set_parent(struct rb_node *rb, struct rb_node *p) {\n    rb->__rb_parent_color = rb_color(rb) | (unsigned long)p;\n}\n\nstatic inline void rb_set_parent_color(struct rb_node *rb, struct rb_node *p, int color) {\n    rb->__rb_parent_color = (unsigned long)p | color;\n}\n\nstatic inline void __rb_change_child(struct rb_node *old, struct rb_node *new, struct rb_node *parent, struct rb_root *root) {\n    if(parent) {\n        if(parent->rb_left == old) parent->rb_left = new;\n        else parent->rb_right = new;\n    } else root->rb_node = new;\n}\n\nstatic inline void rb_set_black(struct rb_node *rb) {\n    rb->__rb_parent_color |= RB_BLACK;\n}\n\nstatic inline struct rb_node *rb_red_parent(struct rb_node *red) {\n    return (struct rb_node *)red->__rb_parent_color;\n}\n\nstatic inline void __rb_rotate_set_parents(struct rb_node *old, struct rb_node *new, struct rb_root *root, int color) {\n    struct rb_node *parent = rb_parent(old);\n    new->__rb_parent_color = old->__rb_parent_color;\n    rb_set_parent_color(old, new, color);\n    __rb_change_child(old, new, parent, root);\n}\n\nstatic inline void rb_insert(struct rb_node *node, struct rb_root *root) {\n    struct rb_node *parent = rb_red_parent(node), *gparent, *tmp;\n\n    while(1) {\n        // Loop invariant: node is red.\n        if(unlikely(!parent)) {\n            rb_set_parent_color(node, NULL, RB_BLACK);\n            break;\n        }\n        if(rb_is_black(parent)) break;\n\n        gparent = rb_red_parent(parent);\n\n        tmp = gparent->rb_right;\n        if(parent != tmp) {\n            if(tmp && rb_is_red(tmp)) {\n                rb_set_parent_color(tmp, gparent, RB_BLACK);\n                rb_set_parent_color(parent, gparent, RB_BLACK);\n                node = gparent;\n                parent = rb_parent(node);\n                rb_set_parent_color(node, parent, RB_RED);\n                continue;\n            }\n\n            tmp = parent->rb_right;\n            if(node == tmp) {\n                tmp = node->rb_left;\n                parent->rb_right = tmp;\n                node->rb_left = parent;\n                if(tmp) rb_set_parent_color(tmp, parent, RB_BLACK);\n                rb_set_parent_color(parent, node, RB_RED);\n                parent = node;\n                tmp = node->rb_right;\n            }\n\n            gparent->rb_left = tmp;\n            parent->rb_right = gparent;\n            if(tmp) rb_set_parent_color(tmp, gparent, RB_BLACK);\n            __rb_rotate_set_parents(gparent, parent, root, RB_RED);\n            break;\n        } else {\n            tmp = gparent->rb_left;\n            if(tmp && rb_is_red(tmp)) {\n                rb_set_parent_color(tmp, gparent, RB_BLACK);\n                rb_set_parent_color(parent, gparent, RB_BLACK);\n                node = gparent;\n                parent = rb_parent(node);\n                rb_set_parent_color(node, parent, RB_RED);\n                continue;\n            }\n\n            tmp = parent->rb_left;\n            if(node == tmp) {\n                tmp = node->rb_right;\n                parent->rb_left = tmp;\n                node->rb_right = parent;\n                if(tmp) rb_set_parent_color(tmp, parent, RB_BLACK);\n                rb_set_parent_color(parent, node, RB_RED);\n                parent = node;\n                tmp = node->rb_left;\n            }\n            gparent->rb_right = tmp;\n            parent->rb_left = gparent;\n            if(tmp) rb_set_parent_color(tmp, gparent, RB_BLACK);\n            __rb_rotate_set_parents(gparent, parent, root, RB_RED);\n            break;\n        }\n    }\n}\n\nstruct rb_node *rb_first(const struct rb_root *root) {\n    struct rb_node *n;\n    n = root->rb_node;\n    if(!n) return NULL;\n    while(n->rb_left) n = n->rb_left;\n    return n;\n}\n\nstruct rb_node *rb_next(const struct rb_node *node) {\n    struct rb_node *parent;\n    if(RB_EMPTY_NODE(node)) return NULL;\n\n    if(node->rb_right) {\n        node = node->rb_right;\n        while(node->rb_left) node = node->rb_left;\n        return (struct rb_node *)node;\n    }\n\n    while((parent = rb_parent(node)) && node == parent->rb_right) node = parent;\n\n    return parent;\n}\n//\n\n\n// Node\nstruct mykey {\n    int board[9];\n    int space;\n    int cnt;\n};\n\nint cmp_mykey(const struct mykey *l, const struct mykey *r) {\n    for(int i = 0; i < 9; ++i) {\n        if(l->board[i] == r->board[i]) continue;\n        if(l->board[i] < r->board[i]) return -1;\n        else return 1;\n    }\n    return 0;\n}\n\nstruct mynode {\n    struct rb_node node;\n    struct mykey key;\n};\n\nstruct mynode *my_search(struct rb_root *root, struct mykey key) {\n    struct rb_node *node = root->rb_node;\n\n    while(node) {\n        struct mynode *data = container_of(node, struct mynode, node);\n        int result = cmp_mykey(&key, &data->key);\n\n        if(result < 0) node = node->rb_left;\n        else if(result > 0) node = node->rb_right;\n        else return data;\n    }\n    return NULL;\n}\n\nint my_insert(struct rb_root *root, struct mynode *data) {\n    struct rb_node **new = &(root->rb_node), *parent = NULL;\n\n    while(*new) {\n        struct mynode *this = container_of(*new, struct mynode, node);\n        int result = cmp_mykey(&data->key, &this->key);\n\n        parent = *new;\n        if(result < 0) new = &((*new)->rb_left);\n        else if(result > 0) new = &((*new)->rb_right);\n        else return -1;\n    }\n    rb_link_node(&data->node, parent, new);\n    rb_insert(&data->node, root);\n    return 0;\n}\n\n/*\nvoid my_print_inorder(struct rb_root *root) {\n    struct rb_node *node;\n    for(node = rb_first(root); node; node = rb_next(node)) {\n        putchar_unlocked(' ');\n        put_int(container_of(node, struct mynode, node)->key);\n    }\n}\n*/\n//\n\n\n// List\nstruct list_head {\n    struct list_head *next, *prev;\n};\n\nstatic inline void INIT_LIST_HEAD(struct list_head *list) {\n    list->next = list;\n    list->prev = list;\n}\n\nstatic inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next) {\n    next->prev = new;\n    new->next = next;\n    new->prev = prev;\n    prev->next = new;\n}\n\nstatic inline void list_add(struct list_head *new, struct list_head *head) {\n    __list_add(new, head, head->next);\n}\n\nstatic inline void list_add_tail(struct list_head *new, struct list_head *head) {\n    __list_add(new, head->prev, head);\n}\n\nstatic inline void __list_del(struct list_head *prev, struct list_head *next) {\n    next->prev = prev;\n    prev->next = next;\n}\n\nstatic inline void __list_del_entry(struct list_head *entry) {\n    __list_del(entry->prev, entry->next);\n}\n\nstatic inline void list_del(struct list_head *entry) {\n    __list_del_entry(entry);\n    entry->next = NULL;\n    entry->prev = NULL;\n}\n\nstatic inline int list_empty(const struct list_head *head) {\n    return head->next == head;\n}\n\n#define list_entry(ptr, type, member) container_of(ptr, type, member)\n#define list_first_entry(ptr, type, member) list_entry((ptr)->next, type, member)\n//\n\nstruct my_list {\n    struct mykey key;\n    struct list_head list;\n};\n\n\n// end condition\nint is_solved(const int board[9]) {\n    for(int i = 0; i < 8; ++i)\n        if(board[i] != i + 1) return 0;\n    return 1;\n}\n\n\nstruct mynode node[200000];\n// solve\nint bfs(struct mykey s) {\n    const int N = 3;\n    const int dx[4] = {-1, 0, 1, 0};\n    const int dy[4] = {0, -1, 0, 1};\n    static int num = 0;\n    node[0].key = s;\n    struct rb_root mytree = RB_ROOT;\n\n    my_insert(&mytree, node + num++);\n    struct list_head head;\n    INIT_LIST_HEAD(&head);\n    struct my_list *data = malloc(sizeof(struct my_list));\n    data->key = s;\n    list_add_tail(&data->list, &head);\n    while(!list_empty(&head)) {\n        data = list_first_entry(&head, struct my_list, list);\n        struct mykey key = data->key;\n        list_del(&data->list);\n        free(data);\n        if(is_solved(key.board)) return key.cnt;\n        int x = key.space % N;\n        int y = key.space / N;\n        for(int i = 0; i < 4; ++i) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(nx < 0 || N <= nx || ny < 0 || N <= ny) continue;\n\n            int next_space = nx + ny * N;\n            struct mykey next_key = key;\n            next_key.board[key.space] = next_key.board[next_space];\n            next_key.board[next_space] = 0;\n            next_key.space = next_space;\n            if(my_search(&mytree, next_key)) continue;\n\n            next_key.cnt++;\n            node[num].key = next_key;\n            if(my_insert(&mytree, node + num) == 0) num++;\n            data = malloc(sizeof(struct my_list));\n            data->key = next_key;\n            list_add_tail(&data->list, &head);\n        }\n    }\n}\n\n\nint main(int argc, char **argv) {\n    struct mykey initial = {.cnt = 0};\n    for(int i = 0; i < 9; ++i) {\n        int x = get_uint();\n        initial.board[i] = x;\n        if(x == 0) initial.space = i;\n    }\n    //clock_t start, end;\n    //start = clock();\n\n    put_uint(bfs(initial));\n    putchar_unlocked('\\n');\n\n    //end = clock();\n    //printf(\"%lf\\n\", (double)(end-start)/CLOCKS_PER_SEC);\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 3\n#define N2 9\n\nint kei(int,int,int,int);\nint f[9];\n\nint main()\n{\n\tint i,a;\n\tfor(i=0;i<N2;i++){\n\t\tscanf(\"%d\",&f[i]);\n\t\tif(f[i]==0)a=i;\n\t}\n\tprintf(\"%d\\n\",k(a,0,10,1));\n\treturn 0;\n}\n\nint k(int a,int b,int c,int d)\n{\n\tint min=999,sum=0,i,m;\n\tif((d==b || c==10) && a==8){\t\n\t\tfor(i=0;i<8;i++){\n\t\t\tif(f[i]!=i+1){\n\t\t\t\tsum++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(sum==0)return b;\n\t}\n\twhile(b<d){\n\t\n\t\tif((a+1)%3!=0 && c!=a+1){\n\t\t\tm=f[a+1];\n\t\t\tf[a+1]=f[a];\n\t\t\tf[a]=m;\n\t\t\tm=k(a+1,b+1,a,d);\n\t\t\tif(min>m){\n\t\t\t\tmin=m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm=f[a];\n\t\t\tf[a]=f[a+1];\n\t\t\tf[a+1]=m;\n\t\t}\n\t\tif((a-1)%N!=2 && a!=0 && c!=a-1){\n\t\t\tm=f[a];\n\t\t\tf[a]=f[a-1];\n\t\t\tf[a-1]=m;\n\t\t\tm=k(a-1,b+1,a,d);\n\t\t\tif(min>m){\n\t\t\t\tmin=m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm=f[a];\n\t\t\tf[a]=f[a-1];\n\t\t\tf[a-1]=m;\n\t\t}\n\t\tif(a-N>=0 && c!=a-N){\n\t\t\tm=f[a];\n\t\t\tf[a]=f[a-N];\n\t\t\tf[a-N]=m;\n\t\t\tm=k(a-N,b+1,a,d);\n\t\t\tif(min>m){\n\t\t\t\tmin=m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm=f[a];\n\t\t\tf[a]=f[a-N];\n\t\t\tf[a-N]=m;\n\t\t}\n\t\tif(a+N<N2 && c!=a+N){\n\t\t\tm=f[a];\n\t\t\tf[a]=f[a+N];\n\t\t\tf[a+N]=m;\n\t\t\tm=k(a+N,b+1,a,d);\n\t\t\tif(min>m){\n\t\t\t\tmin=m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm=f[a];\n\t\t\tf[a]=f[a+N];\n\t\t\tf[a+N]=m;\n\t\t}\n\t\tif(c==10)d++;\t\t\n\t\telse return min;\n\t}\n\treturn min;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define MAX 2000000\n#define INFTY (1<<30)\n??\nint H, A[MAX+1];\n??\nvoid swap(int *a, int *b) {\n????????int t;\n????????t = *a;\n????????*a = *b;\n????????*b = t;\n}\n??\nvoid maxHeapify(int i) {\n????????int largest;\n????????int l = 2 * i;\n????????int r = 2 * i + 1;\n????????if (l <= H && A[l] > A[i]) largest = l;\n????????else largest = i;\n????????if (r <= H && A[r] > A[largest]) largest = r;\n????\n????????if (largest != i) {\n????????????????swap(&A[i], &A[largest]);\n????????????????maxHeapify(largest);\n????????}\n}\n??\nint extract() {\n????????int maxv;\n????????if ( H < 1 ) return -INFTY;\n????????maxv = A[1];\n????????A[1] = A[H--];\n????????maxHeapify(1);\n????????return maxv;\n}\n??\nvoid increaseKey(int i, int key) {\n????????if(key < A[i]) return;\n????????A[i] = key;\n????????while(i > 1 && A[i / 2] < A[i]) {\n????????????????swap(&A[i], &A[i / 2]);\n????????????????i = i / 2;\n????????}\n}\n??\nvoid insert(int key) {\n????????H++;\n????????A[H] = -INFTY;\n????????increaseKey(H, key);\n}\n??\nint main() {\n????????int key;\n????????char com[10];\n??\n????????while(1) {\n????????????????scanf(\"%s\", com);\n????????????????if(com[0] == 'e' && com[1] == 'n') break;\n????????????????if(com[0] == 'i') {\n????????????????????????scanf(\"%d\", &key);\n????????????????????????insert(key);\n????????????????}else {\n????????????????????????printf(\"%d\\n\", extract());\n????????????????}\n????????}\n??\n????????return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n/*----------       定数定義       ----------*/\n\n#define BOARD_SIZE          3       // パズルの行数（列数）\n#define PANEL_NUM           9       // マスの総数\n#define MAX_PATTERN         362880  // 考えられるパズルの組み合わせ数 (9の階乗)\n#define MOVE_DIRECTION_NUM  4       // 移動方向の数\n#define MALLOC_ERR         -1       // メモリ確保失敗\n#define SEARCH_FAILURE     -2       // 探索失敗\n\n\n/*----------      構造体宣言      ----------*/\n\n/*\n *  パズル盤面の情報をもつ構造体\n */\ntypedef struct {\n    int field[PANEL_NUM];   // パズルの配置\n    int space_position;     // 空白の位置\n    int num_moves;          // 手数\n} Puzzle;\n\n/*\n *  キューを実装するための構造体\n */\ntypedef struct {\n    Puzzle *data;\n    int head;\n    int tail;\n} Queue;\n\n\n/*----------   プロトタイプ宣言   ----------*/\n\nbool Init(Queue *queue);\nbool isEmpty(Queue *queue);\nvoid Push(Queue *queue, Puzzle puzzle);\nPuzzle Pop(Queue *queue);\nint CalcHashValue(int *field);\nint BreadthFirstSearch(Puzzle *start);\nvoid swap(int*a,int*b);\n\n\n/*----------      メイン処理      ----------*/\n\nint main() {\n    Puzzle start;\n\n    // 初期配置の読み込み\n    for(int i = 0; i < PANEL_NUM; i++ ){\n        scanf(\"%d\", &start.field[i]);\n        if(start.field[i] == 0){\n            start.space_position = i;\n        }\n    }\n\n    int answer = BreadthFirstSearch(&start); // 幅優先探索で最短手数を求める\n\n    if(answer == MALLOC_ERR){\n        printf(\"malloc error\\n\");\n    }\n    else if(answer == SEARCH_FAILURE){\n        printf(\"探索失敗r\\n\");\n    }\n    else{\n        printf(\"%d\\n\", answer);\n    }\n    return EXIT_SUCCESS;\n}\n\n\n/*----------       関数定義       ----------*/\n\n/*\n *  幅優先探索でパズルの最短手数を求める\n *\n *  戻り値：\n *      探索に成功した場合    最短手数\n *      mallocに失敗した場合  MALLOC_ERR\n *      探索に失敗した場合    SEARCH_FAILURE\n */\nint BreadthFirstSearch(Puzzle *start) {\n    start->num_moves = 0;\n\n    Queue queue;\n\n    if(!Init(&queue)){\n        return MALLOC_ERR;\n    }\n    Push(&queue, *start);\n\n    bool *hash_table = (bool*) malloc(sizeof(bool) * MAX_PATTERN);  // 一度探索した配置を覚えておくためのテーブル\n    if(!hash_table){\n    \tfree(queue.data);\n        return MALLOC_ERR;\n    }\n\n    int goal_field[PANEL_NUM] = {1, 2, 3, 4, 5, 6, 7, 8, 0};   // ゴールの配置\n    int goal_hash_value = CalcHashValue(goal_field);         // ゴールのハッシュ値\n\n    hash_table[CalcHashValue(start->field)] = true;\n\n    // 上、左、下、右の空白の移動方向を定義\n    const int move_direction_x[MOVE_DIRECTION_NUM] = {-1, 0, 1, 0};\n    const int move_direction_y[MOVE_DIRECTION_NUM] = {0, -1, 0, 1};\n\n    while(!isEmpty(&queue)){\n        Puzzle now = Pop(&queue); // キューの先頭の盤面を取り出す\n\n        // 現在のハッシュ値とゴールのハッシュ値が一致したら終了\n        if(CalcHashValue(now.field) == goal_hash_value){\n        \tfree(queue.data);\n        \tfree(hash_table);\n        \treturn now.num_moves;\n        }\n\n        int now_space_pos_x = now.space_position / BOARD_SIZE;\n        int now_space_pos_y = now.space_position % BOARD_SIZE;\n\n        // 上下左右の4方向に空白を移動した際の盤面をキューに追加する\n        for(int i = 0; i < MOVE_DIRECTION_NUM; i++){\n            int moved_space_pos_x = now_space_pos_x + move_direction_x[i];\n            int moved_space_pos_y = now_space_pos_y + move_direction_y[i];\n\n            if(moved_space_pos_x < 0 || moved_space_pos_y < 0 || moved_space_pos_x >= BOARD_SIZE || moved_space_pos_y >= BOARD_SIZE){\n                continue;  // 移動後の空白の位置がパズルの枠から出ている場合は次へ\n            }\n\n            Puzzle next = now; // 空白を移動した際の盤面を作成\n\n            int moved_space_posision = moved_space_pos_x * BOARD_SIZE + moved_space_pos_y;\n\n            // 空白位置の移動\n            swap(&next.field[now.space_position], &next.field[moved_space_posision]);\n\n            next.space_position = moved_space_posision;\n\n            int next_puzzle_hash_value = CalcHashValue(next.field);  // 動かした盤面のハッシュ値\n\n            // 盤面が重複しているかを調べる\n            if(!hash_table[next_puzzle_hash_value]){\n            \t// 重複が無ければハッシュテーブルを更新し、盤面をキューに追加する\n                hash_table[next_puzzle_hash_value] = true;\n                next.num_moves++;\n                Push(&queue, next);\n            }\n        }\n    }\n\n    // ゴール盤面にたどり着かずに、キューが空になった場合は探索失敗\n    free(queue.data);\n    free(hash_table);\n    return SEARCH_FAILURE;\n}\n\n/*\n *  キューを初期化する\n *\n *  戻り値：\n *      初期化に成功すれば true、失敗すれば false\n */\nbool Init(Queue *queue) {\n    queue->head = 0;\n    queue->tail = 0;\n    queue->data = (Puzzle*) malloc(sizeof(Puzzle) * MAX_PATTERN);\n    if(!queue->data){\n        return false;\n    }\n    return true;\n}\n\n/*\n *  キューが空がどうか調べる\n *\n *  戻り値：\n *      空であれば true、そうれなければ false\n */\nbool isEmpty(Queue *queue) {\n    return queue->head == queue->tail;\n}\n\n/*\n *  キューに要素を追加する\n *\n *  戻り値:\n *      なし\n */\nvoid Push(Queue *queue, Puzzle puzzle) {\n    queue->data[queue->tail] = puzzle;\n    queue->tail = (queue->tail + 1) % MAX_PATTERN;\n}\n\n/*\n *  キューの先頭要素を取り出す\n *\n *  戻り値：\n *      キューの先頭要素のパズル\n */\nPuzzle Pop(Queue *queue) {\n    Puzzle puzzle = queue->data[queue->head];\n    queue->head = (queue->head + 1) % MAX_PATTERN;\n    return puzzle;\n}\n\n/*\n *  パズル盤面のハッシュ値を計算する\n *\n *  戻り値：\n *      盤面のハッシュ値\n */\nint CalcHashValue(int *field) {\n    int res = 0;\n    int fac[] = {40320, 5040, 720, 120, 24, 6, 2, 1};\n    int fac_idx = 0;\n    bool used_num[PANEL_NUM] = {};\n    for(int i = 0; i < PANEL_NUM; i++){\n        int count = 0;\n        used_num[field[i]] = true;\n        for(int j = 0; j < field[i] ; j++){\n            if(used_num[j]){\n                continue;\n            }\n            count++;\n        }\n        res += count * fac[fac_idx++];\n    }\n    return res;\n}\n\n/*\n *  値を入れ替える\n *\n *  戻り値:\n *      なし\n */\nvoid swap(int*a,int*b) {\n    int tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct { char a[10]; } Board;\n\nBoard  board, *history;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nMotion motion[9][5] = {\n   {{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}} };\n\nint minstep = 31;\n\nvoid search(int step, int space, int nhistories)\n{\n  int i, j;\n  if (strncmp(board.a, \"123456780\", 8)==0) {\n    if (step<minstep) minstep=step;\n  } else {\n    if (step>=minstep) return;\n    for (j=0; j<nhistories; j++) {\n      if (strcmp(board.a, history[j].a)==0) return;\n    }\n    history[nhistories++] = board; \n    //    puts(board);\n\n    for (i=0; motion[space][i].pos>=0; i++) {\n      Motion m = motion[space][i];\n      if (m.pos==0 && board.a[0]=='1') continue;\n      if ((m.pos==1||m.pos==2) && board.a[0]=='1'&&board.a[1]=='2'&&board.a[2]=='3') continue;\n      if ((m.dir==U&&m.pos<3)||(m.dir==D&&m.pos>5)||(m.dir==L&&m.pos%3==0) || (m.dir==R && m.pos%3==2)) continue;\n\n      board.a[space] = board.a[m.pos];\n      //      board.a[m.pos] = '0';\n      search(step+1, m.pos, nhistories);\n      board = history[nhistories-1];\n    }\n  }\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board.a[0],&board.a[1],&board.a[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board.a[3],&board.a[4],&board.a[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board.a[6],&board.a[7],&board.a[8]);\n  history = (Board*)malloc(sizeof(Board)*31);\n  search(0, strchr(board.a, '0')-board.a, 0);\n  printf(\"%d\\n\", minstep);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\n#define size 3\n#define size2 9\n#define size3 100000\n#define max 36\n\ntypedef struct {\n  char b[size][size],m,cost;\n  int  space[2];\n} Pz;\n\nint head=0, tail=0;\nPz q[size3];\n\nvoid enq(Pz pz){\n  q[tail]=pz;\n  tail = (tail+1)%size3;\n}\n\nPz deq(void){\n  int t;\n  \n  t = head;\n  head = (head+1)%size3;\n\n  return q[t];\n}\n\nint check(Pz pz){\n  int i,j;\n\n  pz.b[pz.space[0]][pz.space[1]] = size2;\n  \n  for(i=0;i<size;i++){\n    for(j=0;j<size;j++){\n      if(pz.b[i][j] != i*size + j + 1){\n\treturn 0;\n      }\n    }\n  }\n\n  return 1;\n}\n\nint distance(Pz pz){\n  int i,j,sum=0,t   ;\n\n  /*for(i=0;i<size;i++){\n    for(j=0;j<size;j++){\n      printf(\"%d \",pz.b[i][j]);\n    }\n    printf(\"\\n\");\n  }*/\n  \n  pz.b[pz.space[0]][pz.space[1]] = size2;\n  for(i=0;i<size;i++){\n    for(j=0;j<size;j++){\n      t=pz.b[i][j]-1;\n      sum += abs(i - t/size) + abs(j - t%size);\n      //printf(\"%d \",tt);\n    }\n  }\n\n  //printf(\"sum %d\\n\",sum);\n  return sum;\n}\nint main(){\n  int i,j,tate,yoko,dis=0,count=0;\n  char tmpc;\n  Pz inisial, tmpp, tmpp2;\n\n  //nyu ryoku\n  for(i=0;i<size;i++){\n    for(j=0;j<size;j++){\n      scanf(\"%d\",&inisial.b[i][j]);\n      if(inisial.b[i][j]==0){\n\tinisial.space[0] = i;\n\tinisial.space[1] = j;\n      }\n    }\n  }\n  inisial.cost = 0;\n  inisial.m = '0';\n\n  enq(inisial);\n\n  //printf(\"%d\\n\",distance(inisial));\n  \n  if(check(inisial)!=1){\n    while(head!=tail){\n      tmpp2 = tmpp = deq();\n      tate = tmpp.space[0];\n      yoko = tmpp.space[1];\n\n      //printf(\"\\n\");\n      //printf(\"%d %d\\n\",head,tail);\n      /*for(i=0;i<size;i++){\n\tfor(j=0;j<size;j++){\n\t  printf(\"%d \",tmpp.b[i][j]);\n\t}\n\tprintf(\"\\n\");\n      }\n      //printf(\"\\n\");\n      \n      //count++;\n      //*/\n      if(tate != 0 && tmpp.m != '1'){\n\ttmpc = tmpp2.b[tate-1][yoko];\n\ttmpp2.b[tate-1][yoko] = tmpp2.b[tate][yoko];\n\ttmpp2.b[tate][yoko] = tmpc;\n\ttmpp2.space[0] = tmpp2.space[0] - 1;\n\ttmpp2.cost++;\n\tif(check(tmpp2) == 1){\n\t  dis = tmpp2.cost;\n\t  break;\n\t}\n\tif(tmpp2.cost + distance(tmpp2) < max){\n\t  tmpp2.m = '2';\n\t  enq(tmpp2);\n\t}\n      }\n      tmpp2=tmpp;\n\n      if(tate < size-1 && tmpp.m != '2'){\n\ttmpc = tmpp2.b[tate+1][yoko];\n\ttmpp2.b[tate+1][yoko] = tmpp2.b[tate][yoko];\n\ttmpp2.b[tate][yoko] = tmpc;\n\ttmpp2.space[0] = tmpp2.space[0] + 1;\n\ttmpp2.cost++;\n\tif(check(tmpp2) == 1){\n\t  dis = tmpp2.cost;\n\t  break;\n\t}\n\tif(tmpp2.cost + distance(tmpp2) < max){\n\t  tmpp2.m = '1';\n\t  enq(tmpp2);\n\t}\n      }\n      tmpp2=tmpp;\n\n      if(yoko != 0 && tmpp.m != '3'){\n\ttmpc = tmpp2.b[tate][yoko-1];\n\ttmpp2.b[tate][yoko-1] = tmpp2.b[tate][yoko];\n\ttmpp2.b[tate][yoko] = tmpc;\n\ttmpp2.space[1] = tmpp2.space[1] - 1;\n\ttmpp2.cost++;\n\tif(check(tmpp2) == 1){\n\t  dis = tmpp2.cost;\n\t  break;\n\t}\n\tif(tmpp2.cost + distance(tmpp2) < max){\n\t  tmpp2.m = '4';\n\t  enq(tmpp2);\n\t}\n      }\n      tmpp2=tmpp;\n\n      if(yoko < size-1 && tmpp.m != '4'){\n\ttmpc = tmpp2.b[tate][yoko+1];\n\ttmpp2.b[tate][yoko+1] = tmpp2.b[tate][yoko];\n\ttmpp2.b[tate][yoko] = tmpc;\n\ttmpp2.space[1] = tmpp2.space[1] + 1;\n\ttmpp2.cost++;\n\tif(check(tmpp2) == 1){\n\t  dis = tmpp2.cost;\n\t  break;\n\t}\n\tif(tmpp2.cost + distance(tmpp2) < max){\n\t  tmpp2.m = '3';\n\t  enq(tmpp2);\n\t}\n      }\n    }\n  }\n\n  printf(\"%d\\n\",dis);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n  \n#define SIZE 3\n#define LIM 32\n#define HN 362897\n  \nstruct dep {\n    int depth, key;\n};\n  \nint ans[SIZE][SIZE] = {\n    {1, 2, 3},\n    {4, 5, 6},\n    {7, 8, 0}};\n  \nint min = LIM;\nstruct dep h[HN];\n  \nint hash1(int k) {\n    return k % HN;\n}\n\nint hash2(int k) {\n    return 1 + k % (HN - 1);\n}\n\nint hash(int k, int i) {\n    return (hash1(k) + i * hash2(k)) % HN;\n}\n  \nvoid dfs(int p[SIZE][SIZE], int n) {\n    int i, j, i1, j1, a = 0, b = 1;\n    int f = 0;\n    int tmp[SIZE][SIZE];\n    for (i = 0; i < SIZE; i++) {\n        for (j = 0; j < SIZE; j++) {\n            if (ans[i][j] != p[i][j]) f++;\n            if(p[i][j] == 0) {\n                i1 = i;\n                j1 = j;\n            }\n            a += p[i][j] * b;\n            b *= 10;\n        }\n    }\n\n    if (f == 0) {\n        if(min >= n) {\n            min = n;\n        }\n        return;\n    }\n    if(n > min) return;\n    i = 0;\n    while(1) {\n        b = hash(a, i);\n        if (h[b].key == 0) {\n            h[b].key = a;\n            h[b].depth = n;\n            break;\n        }\n        else if (h[b].key == a) {\n            if (h[b].depth > n) {\n                h[b].depth = n;\n                break;\n            }\n            else return;\n        }\n        i++;\n    }\n      \n    if(i1 > 0 && i1 < SIZE) {\n        memcpy(tmp, p, sizeof(int) * SIZE * SIZE);\n        f = tmp[i1][j1];\n        tmp[i1][j1] = tmp[i1 - 1][j1];\n        tmp[i1 - 1][j1] = f;\n        dfs(tmp, n + 1);\n    }\n    if(j1 > 0 && j1 < SIZE) {\n        memcpy(tmp, p, sizeof(int) * SIZE * SIZE);\n        f = tmp[i1][j1];\n        tmp[i1][j1] = tmp[i1][j1 - 1];\n        tmp[i1][j1 - 1] = f;\n        dfs(tmp, n + 1);\n    }\n      \n    if(i1 >= 0 && i1 < SIZE - 1) {\n        memcpy(tmp, p, sizeof(int) * SIZE * SIZE);\n        f = tmp[i1][j1];\n        tmp[i1][j1] = tmp[i1 + 1][j1];\n        tmp[i1 + 1][j1] = f;\n        dfs(tmp, n + 1);\n    }\n    if(j1 >= 0 && j1 < SIZE - 1) {\n        memcpy(tmp, p, sizeof(int) * SIZE * SIZE);\n        f = tmp[i1][j1];\n        tmp[i1][j1] = tmp[i1][j1 + 1];\n        tmp[i1][j1 + 1] = f;\n        dfs(tmp, n + 1);\n    }\n}\n  \nint main(void)\n{\n    int i, j;\n    int p[SIZE][SIZE];\n      \n    for (i = 0; i < SIZE; i++) {\n        for (j = 0; j < SIZE; j++) {\n            scanf(\"%d\", &p[i][j]);\n        }\n    }\n    dfs(p, 0);\n      \n    printf(\"%d\\n\", min);\n      \n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define N 3\n\nint P[N][N],G[N][N];\nint X[4]={0,1,0,-1};\nint Y[4]={1,0,-1,0};\n\nvoid Empty(int *,int *);\nvoid Swap(int *,int *);\nint DFS(int ,int ,int ,int ,const int );\nint cal();\n\nint main()\n{\n  int i,j,a;\n  int h,ans,row,col;\n\n  for(i = 0;i < N; i++){\n    for(j = 0;j < N; j++){\n      scanf(\"%d\",&a);\n      P[i][j] = a;\n    }\n  }\n  for(i = 0; i < N; i++){\n    for(j = 0; j < N; j++){\n      G[i][j] = -1;\n    }\n  }\n\n  Empty(&row,&col);\n\n  for(h=0;h<100;h++){\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++){\n        G[i][j] = P[i][j];\n      }\n    }\n    ans = DFS(row,col,-1,0,h);\n    if(ans != -1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++){\n        P[i][j] = G[i][j];\n      }\n    }\n    ans = -1;\n    if(h == 99)\n      printf(\"%d\\n\\n\",ans);\n  }\n\n  return 0;\n}\n\nvoid Empty(int *row,int *col)\n{\n  int i,j;\n\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      if(!P[i][j]){\n        *row = j;\n        *col = i;\n        return;\n      }\n    }\n  }\n}\n\nvoid Swap(int *a,int *b)\n{\n  int tmp;\n\n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nint DFS(int x,int y,int p,int deep,const int lim)\n{\n  int i,len,emc;\n  int x2,y2;\n\n  len = cal();\n\n  if(len == 0)\n    return deep;\n  if(deep + len > lim)\n    return -1;\n\n  for(i=0; i<N+1; i++){\n    x2 = x+X[i];\n    y2 = y+Y[i];\n    if(p != -1 && i == (p+2)%4)\n      continue;\n    if(!(0<=x2 && x2<3 && 0<=y2 && y2<3))\n      continue;\n\n    Swap(&P[y][x],&P[y2][x2]);\n\n    emc = DFS(x2,y2,i,deep+1,lim);\n\n    if(emc != -1)\n      return emc;\n\n    Swap(&P[y][x],&P[y2][x2]);\n  }\n\n  return -1;\n}\n\nint cal()\n{\n  int i,e,C = 0;\n\n  for(i=0;i<9;i++){\n    e = P[i/3][i%3];\n    if(e){\n      e--;\n      C += abs(i/3-e/3) + abs(i%3-e%3);\n    }\n  }\n  return C;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\nchar *flag;\nint head,rear;\nint *que;\nint factorial[10];\n\nint cal_factorial(int n) {\n  if(n == 0) return 1;\n  return cal_factorial(n-1)*n;\n}\n\nint stotag(char *s) {\n  int tag = 0;\n  int i;\n  for(i = 0; i < 9; i++) {\n    int t,j;\n    t = 0;\n    for(j = 0; j < i; j++) {\n      if(s[j] < s[i]) t++;\n    }\n    tag += factorial[8-i]*(s[i]-'0'-t);\n  }\n  return tag;\n}\n\nchar *tagtos(int tag) {\n  int i;\n  char *s;\n  s = (char*)malloc(sizeof(char)*10);\n  for(i = 0; i < 9; i++) {\n    s[i] = tag%factorial[9-i]/factorial[8-i] + '0';\n  }\n  s[9] = '\\0';\n  for(i = 7; i >= 0; i--) {\n    int j;\n    for(j = 8; j > i; j--) {\n      if(s[i] <= s[j]) s[j]++;\n    }\n  }\n  \n  return s;\n}\n\n\nchar *move_up(char s[], int x) {\n  if(x < 3) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-3];\n  s_new[x-3] = s[x];\n  return s_new;\n}\n\nchar *move_left(char s[], int x) {\n  if(x%3 == 0) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-1];\n  s_new[x-1] = s[x];\n  return s_new;\n}\n\nchar *move_right(char s[], int x) {\n  if(x%3 == 2) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+1];\n  s_new[x+1] = s[x];\n  return s_new;\n}\n\nchar *move_down(char s[], int x) {\n  if(x > 5) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+3];\n  s_new[x+3] = s[x];\n  return s_new;\n}\n\nint create(char s[], int t) {\n  if(strcmp(s,\"123456780\") == 0) return t;\n  int tag = stotag(s);\n  if(flag[tag] != 0) return 0;\n  flag[tag] = t;\n  que[rear] = tag;\n  rear++;\n  return 0;\n}\n\nint distance(char *s_new) {\n  char s[] = \"123456780\";\n  int i;\n  int sum = 0;\n  for(i = 0; i < 9; i++) {\n    int a = 0;\n    int b = 0;\n    while(s[a]-'0' != i) a++;\n    while(s_new[b]-'0' != i) b++;\n    sum += abs(a/3-b/3) + abs(a%3-b%3);\n  }\n  return sum;\n}\n\nint check_x(char *s) {\n  int i = 0;\n  while(s[i] != '0') i++;\n  return i;\n}\n\nint cal() {\n  char *s_right,*s_left,*s_up,*s_down;\n  int right,left,up,down,min;\n  int k,tag;\n\n  tag = que[head];\n  char *s = tagtos(tag);\n  int x = check_x(s);\n  \n  if((s_right = move_right(s, x)) != NULL) {\n    right = distance(s_right);\n  }else{\n    right = INT_MAX;\n  }\n  if((s_left = move_left(s, x)) != NULL) {\n    left = distance(s_left);\n  }else{\n    left = INT_MAX;\n  }\n  if ((s_up = move_up(s, x)) != NULL) {\n    up = distance(s_up);\n  }else{\n    up = INT_MAX;\n  }\n  if((s_down = move_down(s, x)) != NULL) {\n    down = distance(s_down);\n  }else{\n    down = INT_MAX;\n  }\n\n  min = right;\n  if(min > left) min = left;  \n  if(min > up) min = up;  \n  if(min > down) min = down;\n\n  if(right == min) {\n    if((k = create(s_right,flag[tag]+1))) return k;\n  }\n  if(left == min) {\n    if((k = create(s_left,flag[tag]+1))) return k;\n  }\n  if(up == min) {\n    if((k = create(s_up,flag[tag]+1))) return k;\n  }\n  if(down == min) {\n    if((k = create(s_down,flag[tag]+1))) return k;\n  }\n\n  free(s);\n  if(s_right != NULL) free(s_right);\n  if(s_left != NULL) free(s_left);\n  if(s_up != NULL) free(s_up);\n  if(s_down != NULL) free(s_down);\n  head++;\n  return 0;\n}\n  \n\nint solve(char s0[]) {\n  int k;\n  if((k = create(s0,1))) return k;\n  \n  while(!(k = cal())) {;}\n  return k;\n}\n\nint main()\n{\n  int i,d;\n  char s[10];\n  for(i = 0; i < 10; i++) factorial[i] = cal_factorial(i);\n  flag = (char*)malloc(sizeof(char)*factorial[9]);\n  memset(flag , 0, factorial[9]);\n  que = (int*)malloc(sizeof(int)*factorial[9]);\n  head = 0;\n  rear = 0;\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &d);\n    s[i] = d+'0';\n  }\n  s[9] = '\\0';\n  printf(\"%d\\n\",solve(s)-1);\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define M 3\n\ntypedef struct{\n  int A[M][M];\n}Pazzle;\n\nPazzle P;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n\nint heuristic(Pazzle P){\n  int i,j;\n  int hx,hy,sum=0;\n\n  for(i=0; i<M; i++){\n    for(j=0; j<M; j++){\n      if(P.A[i][j] == 0)continue;\n      \n      hx = (P.A[i][j]-1)%M-j;\n      hy = (P.A[i][j]-1)/M-i;\n\n      if(hx < 0)sum -= hx;\n      else sum += hx;\n\n      if(hy < 0)sum -= hy;\n      else sum += hy;\n    }\n  }\n\n  return sum;\n}\n\nint dfs(int x,int y,int max,int cnt,int n){\n  int i,temp;\n  int x0,y0,ans=-1,h;\n\n  h = heuristic(P);\n\n  if(h == 0)return cnt;\n  if(cnt + h > max)return -1;\n\n  for(i=0; i<4; i++){\n    x0 = x + dx[i];\n    y0 = y + dy[i];\n\n    if((i == (n+2)%4 && n != -1) || !(0<=x0 && x0<M && 0<=y0 && y0<M))continue;\n    temp = P.A[y][x];\n    P.A[y][x] = P.A[y0][x0];\n    P.A[y0][x0] = temp;\n\n    ans = dfs(x0,y0,max,cnt+1,i);\n\n    if(ans != -1)return ans;\n    temp = P.A[y][x];\n    P.A[y][x] = P.A[y0][x0];\n    P.A[y0][x0] = temp;\n  }\n\n  return -1;\n}\n\nint main(){\n  int i,j;\n  int kx,ky,ans,a;\n  Pazzle tP;\n\n  for(i=0; i<M; i++){\n    for(j=0; j<M; j++){\n      scanf(\"%d\",&a);\n      P.A[i][j] = a;\n      if(a == 0){\n\tkx = j;\n\tky = i;\n      }\n    }\n  }\n\n  tP = P;\n\n  for(i=1; i<46; i++){\n    P=tP;\n    ans = dfs(kx,ky,i,0,-1);\n    if(ans != -1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n\n\nextern void down_0(void);\nextern void up_0(void);\nextern void right_0(void);\nextern void left_0(void);\nextern int  serch(int x, int y, int MaxCnt);\nextern int  check(void);\n\nint cnt,num = 0;\nint val[Total] ={};\n\n\nint main( void )\n{\n \n    int ori[Total] ={};\n    \n    \n    int i = 0;\n    int num_0 = 0;\n    int x,y = 0;\n     \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        ori[i]=val[i];\n        \n        if(val[i] == 0)\n        {\n            num_0 = i;\n        }\n    }\n    \n    x = tate - (num_0/yoko);\n    y = yoko - (num_0%yoko);\n    \n        // 初期化\n        for(i=0; i<Total; i++)\n        {\n            val[i]=ori[i];\n        }\n        num = num_0;\n        cnt = 0;\n        \n    for(i=1; i<35; i++)\n    {\n        if( serch(x,y,i) )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }\n        \n//  printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);        \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt)\n{\n    int result;\n    int i=0;\n    \n    // 最大数で打ち切り\n    if(cnt >= MaxCnt)\n    {\n        return check();\n    }\n    \n    //\n    if(x==0 && y==0)\n    {\n        if( check() )\n        {\n            return 1;\n        }\n    }\n    \n    // 上下左右で4回回す\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if(x != 0)\n                {\n                    down_0();\n                    x = x-1;\n                    \n                    cnt = cnt + 1;\n                    result = serch(x,y,MaxCnt);\n                    cnt=cnt-1;\n                    \n                    up_0();\n                    x = x+1;\n                }\n                break;\n            case 1:\n                if(y != 0)\n                {\n                    right_0();\n                    y = y-1;\n                    \n                    cnt = cnt + 1;\n                    result = serch(x,y,MaxCnt);\n                    cnt=cnt-1;\n                    \n                    left_0();\n                    y = y+1;\n                }\n                break;\n            case 2:\n                if(y < yoko-1)\n                {\n                    left_0();\n                    y = y+1;\n                    \n                    cnt = cnt + 1;\n                    result = serch(x,y,MaxCnt);\n                    cnt=cnt-1;\n                    \n                    right_0();\n                    y = y-1;\n                }\n                break;\n            case 3:\n                if(x < tate-1)\n                {\n                    up_0();\n                    x = x+1;\n                    \n                    cnt = cnt + 1;\n                    result = serch(x,y,MaxCnt);\n                    cnt=cnt-1;\n                    \n                    down_0();\n                    x = x-1;\n                }\n                break;\n            default:\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n        \n    }\n\n    return 0;\n}\n\n// TRUE : 完成\n// FALSE : 失敗\nint check()\n{\n    int i=0;\n    \n//    printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);\n    \n    for(i=0; i<Total-1; i++)\n    {\n        if(val[i] != (i+1))\n        {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid down_0()\n{\n    val[num] = val[num + yoko];\n    val[num + yoko] = 0;\n    num = num + yoko;\n}\n \nvoid up_0()\n{\n    val[num] = val[num - yoko];\n    val[num - yoko] = 0;\n    num = num - yoko;\n}\n \nvoid right_0()\n{\n    val[num] = val[num +1];\n    val[num +1] = 0;\n    num = num + 1;\n}\n \nvoid left_0()\n{\n    val[num] = val[num -1];\n    val[num -1] = 0;\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\ntypedef struct node{\n  char s[10];\n  int t;\n  int x;\n  struct node *next;\n  struct node *back;\n}Node;\n\nchar *move_up(char s[], int x) {\n  if(x < 3) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-3];\n  s_new[x-3] = s[x];\n  return s_new;\n}\n\nchar *move_left(char s[], int x) {\n  if(x%3 == 0) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-1];\n  s_new[x-1] = s[x];\n  return s_new;\n}\n\nchar *move_right(char s[], int x) {\n  if(x%3 == 2) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+1];\n  s_new[x+1] = s[x];\n  return s_new;\n}\n\nchar *move_down(char s[], int x) {\n  if(x > 5) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+3];\n  s_new[x+3] = s[x];\n  return s_new;\n}\n\nint create(Node *root, char s[], int t) {\n  if(strcmp(s,\"123456780\") == 0) return t;\n  Node *p = (Node*)malloc(sizeof(Node));\n  strcpy(p->s,s);\n  p->t = t;\n  int i;\n  for(i = 0; i < 9; i++) {\n    if(s[i] == '0') {\n      p->x = i;\n      break;\n    }\n  }\n  root->back->next = p;\n  p->back = root->back;\n  p->next = root;\n  root->back = p;\n  return -1;\n}\n\nint cal(Node *root) {\n  char *s_new;\n  int k;\n  if((s_new = move_right(root->next->s, root->next->x)) != NULL) {\n    if((k = create(root, s_new, root->next->t+1)) != -1)\n      return k;\n    free(s_new);\n  }\n  if((s_new = move_left(root->next->s, root->next->x)) != NULL) {\n    if((k = create(root, s_new, root->next->t+1)) != -1)\n      return k;\n    free(s_new);\n  }\n  if ((s_new = move_up(root->next->s, root->next->x)) != NULL) {\n    if((k = create(root, s_new, root->next->t+1)) != -1)\n      return k;\n    free(s_new);\n  }\n  if((s_new = move_down(root->next->s, root->next->x)) != NULL) {\n    if((k = create(root, s_new, root->next->t+1)) != -1)\n      return k;\n    free(s_new);\n  }\n  Node *tmp = root->next;\n  tmp->next->back = root;\n  root->next = tmp->next;\n  free(tmp);\n  return -1;\n}\n  \n\nint solve(char s0[]) {\n  int t;\n  Node root;\n  root.next = &root;\n  root.back = &root;\n  if((t = create(&root,s0,0)) != -1) return t;\n  \n  while(1) {\n    if((t = cal(&root)) != -1) break;\n  }\n  return t;\n}\n\nint main()\n{\n  int i,d;\n  char s[10];\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &d);\n    s[i] = d+'0';\n  }\n  s[9] = '\\0';\n  printf(\"%d\\n\",solve(s));\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\ntypedef struct node{\n  char s[10];\n  int f;\n  struct node *next;\n  struct node *back;\n}Node;\n\nvoid move_up(char s[], int x) {\n  char tmp;\n  tmp = s[x];\n  s[x] = s[x-3];\n  s[x-3] = tmp;\n}\n\nvoid move_left(char s[], int x) {\n  char tmp;\n  tmp = s[x];\n  s[x] = s[x-1];\n  s[x-1] = tmp;\n}\n\nvoid move_right(char s[], int x) {\n  char tmp;\n  tmp = s[x];\n  s[x] = s[x+1];\n  s[x+1] = tmp;\n}\n\nvoid move_down(char s[], int x) {\n  char tmp;\n  tmp = s[x];\n  s[x] = s[x+3];\n  s[x+3] = tmp;\n}\n\nint heuristic(char s[]) {\n  int h,i,d;\n  h = 0;\n  for (i = 0; i < 9; i++) {\n    if(s[i] == '0') {\n      h += 2-i%3 + 2-i/3;\n    }\n    else {\n      d = abs(s[i]-'0'-1 - i);\n      h += d%3 + d/3; \n    }\n  }\n  return h;\n}\n\nNode *add_list(Node *begin, char s[], int f) {\n  Node *p;\n  p = begin;\n  while(p != NULL) {\n    if(strcmp(p->s,s) == 0) {\n      if(p->f > f) p->f = f;\n      return begin;\n    }\n    p = p->next;\n  }\n  \n  p = (Node*)malloc(sizeof(Node));\n  strcpy(p->s,s);\n  p->f = f;  \n  if(begin != NULL) begin->back = p;\n  p->next = begin;\n  p->back = NULL;\n  return p;\n}\n\nNode *remove_node(Node *begin, Node *p) {\n  if(p == begin) {\n    if(p->next != NULL) p->next->back = NULL;\n    return p->next;\n  }\n  p->back->next = p->next;\n  if(p->next != NULL) p->next->back = p->back;\n  return begin;\n}\n\nNode *move_node(Node *begin, Node *p) {\n  p->back = NULL;\n  p->next = begin;\n  if(begin != NULL) begin->back = p;\n  return p;\n}\n\nNode *search_node(Node *begin, char s[]) {\n  Node *p;\n  p = begin;\n  while(p != NULL) {\n    if(strcmp(p->s,s) == 0) break;\n    p = p->next;\n  }\n  return p;\n}\n\nvoid open_node(Node **open, Node **close, char s[], int g) {\n  int f;\n  Node *p;\n  f = g + 1 + heuristic(s);\n  p = search_node(*close,s);\n  if(p != NULL ) {\n    if(p->f > f) {\n      p->f = f;\n      *close = remove_node(*close,p);\n      *open = move_node(*open,p);\n    }\n  }\n  else {\n    *open = add_list(*open,s,f);\n  }\n}\n\nint solve(char s0[]) {\n  int x,g,min_f;\n  char s[10];\n  Node *open = NULL;\n  Node *close = NULL;\n  Node *p,*min;\n  open = add_list(open,s0,heuristic(s0));\n  while(1) {\n    p = open;\n    min_f = p->f;\n    min = p;\n    while(p != NULL) {\n      if(p->f < min_f) {\n  \tmin_f = p->f;\n  \tmin = p;\n      }\n      p = p->next;\n    }\n    strcpy(s,min->s);\n    //printf(\"%s\\n\",s);\n    if(strcmp(s,\"123456780\") == 0) break;\n    g = min->f - heuristic(s);\n    open = remove_node(open,min);\n    close = move_node(close,min);\n    for (x = 0; x < 9; x++) if(s[x] == '0') break;\n    if(x > 2) {\n      move_up(s,x);\n      open_node(&open,&close,s,g);\n      move_down(s,x-3);\n    }\n    if(x < 6) {\n      move_down(s,x);\n      open_node(&open,&close,s,g);\n      move_up(s,x+3);\n    }\n    if(x%3 < 2) {\n      move_right(s,x);\n      open_node(&open,&close,s,g);\n      move_left(s,x+1);\n    }\n    if(x%3 > 0) {\n      move_left(s,x);\n      open_node(&open,&close,s,g);\n      move_right(s,x-1);\n    }\n  }\n  return min->f;\n}\n\nint main()\n{\n  int i,d;\n  char s[10];\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &d);\n    s[i] = d+'0';\n  }\n  s[9] = '\\0';\n  printf(\"%d\\n\",solve(s));\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 3\n#define MAX 15\n\ntypedef struct{\n  int A[N][N];\n}Pazzle;\n\nPazzle P;\n\nint d_x[4]={0,1,0,-1},d_y[4]={1,0,-1,0};\n\nvoid swap(int *A,int *B){\n  int h;\n  h=*A;\n  *A=*B;\n  *B=h;\n}\n\nint check(Pazzle P){\n  int sum=0,i,j,h_y,h_x;\n\n  for( i=0 ; i<N ; i++ ){\n    for( j=0 ; j<N ; j++ ){\n      if( P.A[i][j]==0 )\n        continue;\n      h_y=(P.A[i][j]-1)/N-i;\n      h_x=(P.A[i][j]-1)%N-j;\n      if( h_y<0 )\n        sum-=h_y;\n      else\n        sum+=h_y;\n      if( h_x<0 )\n        sum-=h_x;\n      else\n        sum+=h_x;\n    }\n  }\n  return sum;\n}\n\nint dfs(int x,int y,int max,int count,int m){\n  int i,h,x_0,y_0,ans=-1;\n\n  h=check(P);\n\n  if( h==0 ) return count;\n  if( count+h>max ) return -1; \n  for( i=0 ; i<4 ; i++ ){\n    x_0=x+d_x[i];\n    y_0=y+d_y[i];      \n   \n    if(( m!=-1&&i==(m+2)%4)||!(0<=x_0 && x_0<N && 0<=y_0 && y_0<N )) continue;  \n\n    swap(&P.A[y][x],&P.A[y_0][x_0]);\n\n    ans=dfs(x_0,y_0,max,count+1,i);\n\n    if( ans!=-1 ) return ans;       \n\n    swap(&P.A[y][x],&P.A[y_0][x_0]);\n\n  }   \n  return -1;\n}\n\nint main(void){\n  Pazzle t_P;\n  int  i,j,anser,x_0,y_0;\n\n  for( i=0 ; i<N ; i++ ){\n    if( i<N )break;\n  }\n  \n  for( i=0 ; i<N ; i++ ){\n    for( j=0 ; j<N ; j++ ){\n      scanf(\"%d\",&P.A[i][j]);\n      if( P.A[i][j]==0 ){\n\tx_0=j;\n\ty_0=i;           \n      }        \n    }\n  }\n\n  t_P=P;\n\n  for( i=1 ; i<46 ; i++ ){\n    P=t_P;\n    anser=dfs(x_0,y_0,i,0,-1);\n    if(anser!=-1){\n        printf(\"%d\\n\",anser); \n        break;\n        }\n  }\n  return 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint Puzzle[3][3];\nint tmp[3][3];\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nvoid Empty(int *, int *);\nvoid swap(int *, int *);\nint Cal();\nint DFS(int, int, int, int, int);\n\nint main(){\n  int i, j, l;\n  int x, y, a;\n\n  for(i = 0 ; i < 3 ; i++){\n    for(j = 0 ; j < 3 ; j++){\n      scanf(\"%d\",&Puzzle[i][j]);\n    }\n  }\n\n  Empty(&x,&y);\n\n  for(l = 0 ; l < 100 ; l++){\n    for(i = 0 ; i < 3 ; i++){\n      for(j = 0 ; j < 3 ; j++){\n\ttmp[i][j] = Puzzle[i][j];\n      }\n    }\n\n    a = DFS(x, y, -1, 0, l);\n    if(a != -1){\n      printf(\"%d\\n\",a);\n      break;\n    }\n\n    for(i = 0 ; i < 3 ; i++){\n      for(j = 0 ; j < 3 ; j++){\n\tPuzzle[i][j] = tmp[i][j];\n      }\n    }\n    \n    a = -1;\n    if(l == 99) printf(\"%d\\n\",a);\n  }\n\n  return 0;\n}\n\nvoid Empty(int *x, int *y){\n  int i, j;\n\n  for(i = 0 ; i < 3 ; i++){\n    for(j = 0 ; j < 3 ; j++){\n      if(!Puzzle[i][j]){\n\t*x = j;\n\t*y = i;\n\treturn;\n      }\n    }\n  }\n}\n\nvoid swap(int *a, int *b){\n  int tmp;\n  \n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\n\nint Cal(){\n  int i, a;\n  int sum = 0;\n\n  for(i = 0 ; i < 9 ; i++){\n    a = Puzzle[i/3][i%3];\n    if(a){\n      a--;\n      sum += abs(i/3 - a/3)  + abs(i%3 - a%3);\n    }\n  }\n\n  return sum;\n}\n\nint DFS(int x, int y, int p, int dep, int limit){\n  int i, h, nx, ny, res;\n\n  h = Cal();\n  \n  if(h == 0) return dep;\n  if(dep + h > limit) return -1;\n\n  for(i = 0 ; i < 4 ; i++){\n    nx = x + dx[i];\n    ny = y + dy[i];\n\n    if(~p && i == (p+2)%4) continue;\n    if(!(0 <= nx && nx < 3 && 0 <= ny && ny < 3)) continue;\n\n    swap(&Puzzle[y][x], &Puzzle[ny][nx]);\n    res = DFS(nx, ny, i, dep+1, limit);\n    if(~res) return res;\n\n    swap(&Puzzle[y][x], &Puzzle[ny][nx]);\n  }\n\n  return -1;\n}\n    \n\n"
  },
  {
    "language": "C",
    "code": "// AOJ ALDS1_13_B 8 Puzzle\n// 2018.5.8 bal4u\n\n#include <stdio.h>\n\ntypedef unsigned char uchar;\n\n#define HASHSIZ 543217\ntypedef struct { unsigned s; char x, v; } HASH;\nHASH hash[HASHSIZ+3], *hashend = hash+HASHSIZ;\n\nint lookup(unsigned s, int x)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) return hp->v;\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\treturn 0;\n}\n\nvoid insert(unsigned s, int x, char v)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) { hp->v = v; break; }\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\thp->s = s, hp->x = x, hp->v = v;\n}\n\n#define QMAX 50000\ntypedef struct { unsigned s; char x, v; } T;\nT s[QMAX+3]; int top, end;\nint hi[9] = {2,3,2,3,4,3,2,3,2};\nint to[9][4] = {{1,3},{0,2,4},{1,5},{0,4,6},{1,3,5,7},{2,4,8},{3,7},{4,6,8},{5,7}};\n\nvoid toArray(char *nine, unsigned s, int x)\n{\n\tint i;\n\t\n\tfor (i = 8; i >= 0; i--) {\n\t\tif (i == x) nine[i] = 0;\n\t\telse nine[i] = s & 0xf, s >>= 4;\n\t}\n}\n\nunsigned swap(char *nine, int zero, int nx)\n{\n\tint i;\n\tunsigned res;\n\t\n\tres = 0;\n\tfor (i = 0; i < 9; i++) {\n\t\tif      (i == zero) res <<= 4, res |= nine[nx];\n\t\telse if (i != nx)   res <<= 4, res |= nine[i];\n\t}\n\treturn res;\n}\n\n#define MAGIC 20\n\nint main()\n{\n\tint i, x, nx, v, nv, t;\n\tunsigned a, na;\n\tunsigned gs; int gx;\t// goal\n\tchar nine[9];\n\t\n\tgs = 0; for (i = 0; i < 9; i++) {\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 0) gx = i;\n\t\telse gs <<= 4, gs |= t;\n\t}\n\ts[0].s = 0x12345678, s[0].x = 8;\n\ts[1].x = -1;\n\ttop = 0, end = 2;\n\tinsert(s[0].s, s[0].x, 0);\n\tv = 0;\n\twhile (top != end) {\n\t\ta = s[top].s, x = s[top].x;\n\t\tif (++top == QMAX) top = 0; \n\t\tif (x < 0) {\n\t\t\tif (v == MAGIC) break;\n\t\t\tv++;\n\t\t\ts[end].x = -1; if (++end == QMAX) end = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (x == gx && a == gs) goto done;\n\t\tif (lookup(a, x) < v) continue;\n\n\t\ttoArray(nine, a, x);\n\t\tfor (i = 0; i < hi[x]; i++) {\n\t\t\tnx = to[x][i];\n\t\t\tna = swap(nine, x, nx), nv = v+1;\n\t\t\tt = lookup(na, nx);\n\t\t\tif (!t || nv < t) {\n\t\t\t\ts[end].s = na, s[end].x = nx;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t\tinsert(na, nx, nv);\n\t\t\t}\n\t\t}\n\t}\n\n\ts[0].s = gs, s[0].x = gx, s[1].x = -1;\n\ttop = 0, end = 2;\n\tv = 0;\n\twhile (top != end) {\n\t\ta = s[top].s, x = s[top].x;\n\t\tif (++top == QMAX) top = 0; \n\t\tif (x < 0) {\n\t\t\tv++;\n\t\t\ts[end].x = -1; if (++end == QMAX) end = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((t = lookup(a, x)) > 0) { v += t; break; }\n\n\t\ttoArray(nine, a, x);\n\t\tfor (i = 0; i < hi[x]; i++) {\n\t\t\tnx = to[x][i];\n\t\t\tna = swap(nine, x, nx), nv = v+1;\n\t\t\tt = lookup(na, nx);\n\t\t\tif (!t || nv < t) {\n\t\t\t\ts[end].s = na, s[end].x = nx;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tprintf(\"%d\\n\", v);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n#define TryCnt 45\n\nextern inline void down_0(void);    // 0 を下に移動\nextern inline void up_0(void);      // 0 を上に移動\nextern inline void right_0(void);   // 0 を右に移動\nextern inline void left_0(void);    // 0 を左に移動\n\nextern int  serch(int x, int y, int MaxCnt, int pre);\n\nint num = 0;        // 0 の位置を示す\nint val[Total] ={}; // 数値配列\n\n\nint main( void )\n{\n    int i = 0;\n    int x,y = 0;\n    \n    // 文字列の取り込み\n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        \n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n    \n    // 右下に行くために 0 を何回動かせばいいか。\n    x = tate - (num/yoko) -1;\n    y = yoko - (num%yoko) -1;\n    \n    for(i=0; i<TryCnt; i++)\n    {\n        if( serch(x,y,i,4) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt, int pre)\n{\n    int result;\n    int i=0;\n    \n    // 最大数でゴールと一致しているか確認\n    if(MaxCnt==0)\n    {\n        for(i=0; i<Total-1; i++)\n        {\n            if(val[i] != (i+1))\n            {\n                // ゴールと不一致\n                return 0;\n            }\n        }\n        // ゴールと一致！！\n        return 1;\n    }\n    \n    \n    // 0 の移動\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if( (x > 0) && (pre != 3) )\n                {\n                    down_0();\n                    \n                    result = serch(x-1, y, MaxCnt-1, 0);\n                    \n                    up_0();\n                }\n                break;\n                \n            case 1:\n                if( (y > 0) && (pre != 2) )\n                {\n                    right_0();\n                    \n                    result = serch(x, y-1, MaxCnt-1, 1);\n                    \n                    left_0();\n                }\n                break;\n                \n            case 2:\n                if( (y < yoko -1 ) && (pre != 1) )\n                {\n                    left_0();\n                    \n                    result = serch(x, y+1, MaxCnt-1, 2);\n                    \n                    right_0();\n                }\n                break;\n                \n            case 3:\n                if( (x < tate -1 ) && (pre != 0) )\n                {\n                    up_0();\n                    \n                    result = serch(x+1, y, MaxCnt-1, 3);\n                    \n                    down_0();\n                }\n                break;\n                \n            default:\n                // 何もしない。\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n    }\n    \n    return 0;\n}\n\n\ninline void down_0()\n{\n    val[num] = val[num + yoko];\n    num = num + yoko;\n}\n \ninline void up_0()\n{\n    val[num] = val[num - yoko];\n    num = num - yoko;\n}\n \ninline void right_0()\n{\n    val[num] = val[num +1];\n    num = num + 1;\n}\n \ninline void left_0()\n{\n    val[num] = val[num -1];\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n  \nint puz[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nvoid empty(int *x,int *y) {\n  int i,j;\n  for(i=0; i<3; i++){\n    \n    for(j=0; j<3; j++){\n      \n      if(!puz[i][j]){\n\t\n\t*x = j;\n\t*y = i;\n\treturn;\n      }\n    }\n  }\n}\n   \nvoid swap(int *a,int *b){\n  int tmp;\n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n  \nint cal(){\n  int i,a,sum=0; \n  for(i=0; i<9; i++){\n    a = puz[i/3][i%3];\n    if(a){\n      a--;\n      sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n    }\n  }    \n  return sum;\n}\n  \nint dfs(int x,int y,int p,int dep,const int lim){\n    int i,h,nx,ny,res;   \n    h = cal();\n    if(h==0) return dep;\n    if(dep+h>lim) return -1; \n    for(i=0; i<4; i++){\n        nx = x+dx[i];\n        ny = y+dy[i];      \n        if(~p && i==(p+2)%4) continue;\n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;    \n        swap(&puz[y][x],&puz[ny][nx]);\n        res = dfs(nx,ny,i,dep+1,lim);\n        if(~res) return res;       \n        swap(&puz[y][x],&puz[ny][nx]);\n    }   \n    return -1;\n}  \n    \nint main() {\n    int i,j,ans,x,y,l;\n      \n    for(i=0; i<3; i++){\n        for(j=0; j<3; j++)\n\t  scanf(\"%d\",&puz[i][j]);\n    }\n       \n    empty(&x,&y);\n    for(l=0; l<100; l++){\n        for(i=0; i<3; i++){\n            for(j=0; j<3; j++)\n\t      tmp[i][j] = puz[i][j];\n        }\n          \n        ans = dfs(x,y,-1,0,l);\n        if(ans!=-1){\n            printf(\"%d\\n\",ans);\n            break;\n        }\n          \n        for(i=0; i<3; i++){\n            for(j=0; j<3; j++)\n\t      puz[i][j] = tmp[i][j];\n        }\n          \n        ans = -1;\n\t\n        if(l==99)\n\t  printf(\"%d\\n\",ans);\n    }\n      \n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n//     +-+-+-+       +-+-+-+\n//     |1|3|0|       |1|2|3|\n//     +-+-+-+       +-+-+-+\n//     |4|2|5|       |4|5|6|\n//     +-+-+-+       +-+-+-+\n//     |7|8|6|       |7|8|0|\n//     +-+-+-+       +-+-+-+\n\ntypedef char Board[10];\nBoard ini_board, board;\nconst Board target = \"123456780\";\n\nBoard *history;\nint nhistories=0;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nint minstep = 30;\n\nconst Motion candidate[9][5] = //空いているマスの位置に対する移動できるピースとその方向\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nint move(Motion m)\n{\n  if (m.pos==0 && board[0]=='1') return -1;\n  if ((m.pos==1||m.pos==2) && board[0]=='1'&&board[1]=='2'&&board[2]=='3') return -1;\n\n  switch (m.dir) {\n  case U:\n    if (m.pos<3) return -1;\n    board[m.pos-3] = board[m.pos];\n    break;\n  case D:\n    if (m.pos>5) return -1;\n    board[m.pos+3] = board[m.pos];\n    break;\n  case L:\n    if (m.pos%3==0) return -1;\n    board[m.pos-1] = board[m.pos];\n    break;\n  case R:\n    if (m.pos%3==2) return -1;\n    board[m.pos+1] = board[m.pos];\n    break;\n  }\n  board[m.pos] = '0';\n  return m.pos;\n}\n\nvoid search_path(int step, int space)\n{\n  int i, j, s2;\n  if (strcmp(board, \"123456780\")==0) {\n    //    printf(\"STEP=%d\\n\", step);\n    if (step==1) {\n      printf(\"1\\n\");\n      exit(0);\n    }\n    if (step<minstep) minstep=step;\n  } else {\n    if (step>=minstep) return;\n    if (step>0 && strcmp(board, ini_board)==0) return;\n    \n    Board board_bak;\n    strcpy(board_bak, board);\n    int nhistories_bak=nhistories;\n    \n    //    puts(board);\n    //    printf(\"%d\\n%c%c%c\\n%c%c%c\\n%c%c%c\\n---\\n\", nhistories, board[0],board[1],board[2],  board[3],board[4],board[5],  board[6],board[7],board[8]);\n\n    for (i=0; candidate[space][i].pos>=0; i++) {\n\n      if ((s2 = move(candidate[space][i]))<0) continue;\n      for (j=0; j<nhistories; j++) {\n\tif (strcmp(board, history[j])==0) // 前と同じ配置になったので次の手を試す\n\t  break;\n      }\n      if (j==nhistories) {\n\tstrcpy(history[nhistories++], board); \n\tsearch_path(step+1, s2);\n      }\n      nhistories = nhistories_bak;\n      strcpy(board, board_bak);\n    }\n  }\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board[0],&board[1],&board[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[3],&board[4],&board[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[6],&board[7],&board[8]);\n  strcpy(ini_board, board);\n  history = (Board*)malloc(sizeof(Board)*10000);\n  search_path(0, strchr(board, '0')-board);\n  printf(\"%d\\n\", minstep);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 3\n#define MAX 8\ntypedef struct{\n    int A[N][N];\n\n}Pazzle;\nint d_x[4]={0,1,0,-1};\nint d_y[4]={1,0,-1,0};\nvoid swap(int *,int *);\nint check(Pazzle);\nint dfs(int ,int ,int ,int ,Pazzle );\n\nint main(void){\n    Pazzle P,t_P;\n    int  i,j,ans;\n    int x0,y0;\n\n    for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n            scanf(\"%d\",&P.A[i][j]);\n            if(P.A[i][j]==0){\n                x0=j;\n                y0=i;\n                \n            }\n            \n        }\n    }\n    t_P=P;\n    for(i=1;i<100;i++){\n        P=t_P;\n    ans=dfs(x0,y0,i,0,P);\n    if(ans!=-1){printf(\"%d\\n\",ans); break;}\n    }\n    return 0;\n}\n\nint dfs(int x,int y,int max,int cnt,Pazzle P){\n         int i;\n  int heau;\n  int x_0,y_0;\n  int ans=-1;   \n  heau=check(P);\n  if(heau==0) return cnt;\n  if(cnt+heau>max) return -1; \n  for(i=0;i<4;i++){\n    x_0=x+d_x[i];\n    y_0=y+d_y[i];      \n   \n    if(!(0<=x_0 && x_0<3 && 0<=y_0 && y_0<3)) continue;    \n    swap(&P.A[y][x],&P.A[y_0][x_0]);\n    ans=dfs(x_0,y_0,max,cnt+1,P);\n    if(ans!=-1) return ans;       \n     swap(&P.A[y][x],&P.A[y_0][x_0]);\n  }   \n  return -1;\n}\n\nvoid swap(int *A,int *B){\n int hoge;\n hoge=*A;\n *A=*B;\n *B=hoge;\n \n \n}\nint check(Pazzle P){\n    int sum=0,i,j,hy,hx;\n    for(i=0;i<N;i++){\n \n    for(j=0;j<N;j++){\n        if(P.A[i][j]==0)\n        continue;\n        hy=(P.A[i][j]-1)/N-i;\n        hx=(P.A[i][j]-1)%N-j;\n        if(hy<0)\n        sum-=hy;\n        else\n        sum+=hy;\n        if(hx<0)\n        sum-=hx;\n        else\n        sum+=hx;\n \n \n}\n}\n \nreturn sum;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define N 3\n#define MAX 1000\n#define INF -1\n\n\n\ntypedef struct {\n  int ban[N*N], sp, MD, p[N][N];  \n}Record;\n\n\n\nvoid IDA(Record); \nint Manhat(Record);\nint dfs(int, int);\n\n\n\n\n\nint cnt = 0, ans[N][N], size, limit, stack[N], time, path[100];\nint dx[4] = {0, -1, 0, 1}; //四方向\nint dy[4] = {1, 0, -1, 0}; //四方向\nint MDT[N*N][N*N];\nchar dir[4] = {'r','u','l','d'}; //右、上、左、下\nchar an[100];\nRecord data, in;\n\n\nint main () {\n  int i, j, k = 0, m = 0, l = 0;\n\n\n  for(i = 0 ; i < N*N ; i++) {\n    for(j = 0 ; j < N*N ; j++) {\n      m = i / N - j / N;\n      l = i % N - j % N;\n\n      if(m < 0) m = -1 * m;\n      if(l < 0) l = -1 * l;\n      MDT[i][j] = m + l;\n    }\n  }\n\n\n\n  for(i = 0 ; i < N*N ; i++) {\n      scanf(\"%d\",&in.ban[i]);\n\n      if(in.ban[i] == 0) {\n\tin.ban[i] = N*N;\n\tin.sp = i;\n      }\n    \n      //if(i * j != (N-1)*(N-1)) ans[i][j] = ++k;\n  }\n\n  IDA(in);\n \n\n  printf(\"%d\\n\",strlen(an));\n\n  return 0;\n}\n\n\n\nint Manhat(Record A) {\n  int d = 0, i;\n  \n  for(i = 0 ; i < N * N ; i++) {\n    if(A.ban[i] == N*N) continue;\n    d += MDT[i][A.ban[i]-1];\n  }\n\n  return d;\n}\n\n\n\n\n\n\nint dfs(int def, int prev) {\n  int sx = 0, sy = 0, i, j, tx = 0, ty = 0, max = 0, min = 0, t1;\n  Record tmp;\n\n  //printf(\"test\\n\");\n  if(data.MD == 0) return 1;\n\n  if(def + data.MD > limit) return -1;\n\n  sx = data.sp / N;\n  sy = data.sp % N;\n\n  for(i = 0 ; i < 4 ; i++) {\n    tx = sx + dx[i];\n    ty = sy + dy[i];\n\n    if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\n    if(prev > i) {\n      max = prev;\n      min = i;\n    }\n\n    else {\n      max = i;\n      min = prev;\n    }\n\n    if(max - min == 2) continue;\n\n    tmp = data;\n    data.MD -= MDT[tx * N + ty][data.ban[tx * N + ty]-1]; //正解に近づいているか\n    data.MD += MDT[sx * N + sy][data.ban[tx * N + ty]-1];\n    t1 = data.ban[tx * N + ty];\n    data.ban[tx * N + ty] = data.ban[sx * N + sy];\n    data.ban[sx * N + sy] = t1;\n\n    data.sp = tx * N + ty;\n\n    if(dfs(def + 1, i) == 1) {\n      path[def] = i;\n      return 1;\n    }\n\n    data = tmp;\n  }\n  \n\n  return -1;\n}\n\n\nvoid IDA(Record A) {\n  int i, cnt = 0, j = 0;\n  \n  in.MD = Manhat(in);\n\n  for(limit = in.MD ; limit <= 100 ; limit++) {\n    data = in;\n\n    if(dfs(0, -100) == 1) {\n      for(i = 0 ; i < limit ; i++) {\n   \n\tan[j] = dir[path[i]];\n\tj++;\n      }\n      //printf(\"test\\n\");\n      an[j] = '\\0';\n      return;\n    }\n\n  }\n  \n}\n\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define N 3\n#define N2 9\n#define LIMIT 31\n\ntypedef struct { char b[N2+1]; } Board;\nBoard board;\nint minstep;\ntypedef enum { R, U, L, D } Direction;\ntypedef struct { int pos; Direction dir; } Motion;\n\nconst Motion motion[N2][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nconst int rr[4][5] = {{0,0,1,0,0},{0,0,0,1,0},{1,0,0,0,0},{0,1,0,0,0}};\n\nint dd[N2][N2];\nint dist(char *b)\n{\n  int i, n, d = 0;\n  for (i=0; i<N2; i++) {\n    n = b[i]-1;\n    if (n<0)   continue;\n    d += dd[n][i];\n  }\n  return d;\n}\n\nvoid search(int step, Motion prev)\n{\n  int i, d=0;\n  d = dist(board.b);\n  if (step+d>minstep) return;\n  if (d==0) {\n    printf(\"%d\\n\", step);\n    exit(0);\n  }\n  Board board_bak = board;\n  for (i=0; motion[prev.pos][i].pos>=0; i++) {\n    Motion m = motion[prev.pos][i];\n    if (rr[m.dir][prev.dir]) continue; //元に戻るのを防止\n    board.b[prev.pos] = board.b[m.pos];\n    board.b[m.pos] = 0;\n    search(step+1, m);\n    board = board_bak;\n  }\n}\n\nint main()\n{\n  int i, j;\n  for (i=0; i<N2; i++)\n    for (j=0; j<N2; j++)\n      dd[i][j] = abs(i%N-j%N) + abs(i/N-j/N);\n\n  Motion m;\n  m.dir = 4;\n  Board ini_board;\n  for (i=0; i<N2; i++) {\n    fscanf(stdin, \"%hd\", (short int*)&ini_board.b[i]);\n    if (ini_board.b[i]==0) m.pos = i;\n  }\n  for (minstep=dist(ini_board.b); minstep<=LIMIT; minstep++) {\n    board = ini_board;\n    search(0, m);\n  }\n  puts(\"no result.\");\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define MOD 1999993\n\nconst int dy[4]={-1,1,0,0},dx[4]={0,0,-1,1};\n\nstruct P{\n\tint tile[9];\n\tint step, O;\n\tstruct P *next,*prev;\n};\ntypedef struct P* puzzle;\n\n//{{{ Hash\nint mem[2000000];\nint h1(int key){\n\treturn key%MOD;\n}\nint h2(int key){\n\treturn 1+key%(MOD-1);\n}\nint Hash(int* array, int col, char com){\n\tint i,key=0,pos;\n\tfor(i=0;i<9;i++)key=key*10 + array[i];\n\n\tpos=( h1(key) + col*h2(key) )%MOD;\n\tif(com=='M'){\n\t\t//Memo\n\t\tif(mem[pos]==0)mem[pos]=key;\n\t\telse return Hash(array,col+1, 'M');\n\n\t\treturn 0;\n\t}else if(com=='F'){\n\t\t//Find\n\t\tif(mem[pos]==key)return 1;\n\t\telse if(mem[pos]==0)return 0;\n\t\telse return Hash(array,col+1,'F');\n\t}\n\t\n}\n//}}}\n//{{{ Queue\npuzzle head;\nvoid Push(struct P in){\n\tint i,key=0,digit=1;\n\tpuzzle data=(puzzle)malloc(sizeof(struct P));\n\tfor(i=0;i<9;i++){\n\t\tdata->tile[i]=in.tile[i];\n\t\tkey+=digit*(in.tile[i]);\n\t\tdigit*=10;\n\t}\n\tHash(in.tile,0,'M');\n\tdata->step = in.step;\n\tdata->O = in.O;\n\n\tHash(in.tile, 0,'M');\n\n\tdata->next=head;\n\tdata->prev=(head->prev);\n\t(head->prev)->next=data;\n\t(head->prev)=data;\n\n\treturn;\n\n}\n\nstruct P Pop(void){\n\tif(head->next == head){\n\t\tprintf(\"empty!!\\n\");\n\t\texit(1);\n\t}\n\tint i;\n\tstruct P out;\n\tfor(i=0;i<9;i++){\n\t\tout.tile[i]=(head->next)->tile[i];\n\t}\n\tout.step=(head->next)->step;\n\tout.O=(head->next)->O;\n\n\tpuzzle del=head->next;\n\thead->next=(del)->next;\n\thead->next->prev = head;\n\tfree(del);\n\t//(head->next)->prev=head;\n\n\treturn out;\n}\n//}}}\n\nint Check(struct P x){\n\tint i;\n\tfor(i=0;i<9;i++){\n\t\tif(x.tile[i]!=(i+1)%9)return 0;\n\t}\n\n\treturn 1;\n}\n\nvoid Solve(void){\n\tint i,j,y,x,nY,nX,tmp;\n\tstruct P u,v;\n\n\twhile(head->prev != head){\n\t\tu=Pop();\n\t\tif(Check(u)){\n\t\t\tprintf(\"%d\\n\",u.step);\n\t\t\texit(0);\n\t\t}\n\t\ty=u.O/3;\tx=u.O%3;\n\t\tfor(i=0;i<4;i++){\n\t\t\tnY=y+dy[i],nX=x+dx[i];\n\t\t\tif(nY<0||nX<0||nY>=3||nX>=3)continue;\n\n\t\t\tv=u;\n\t\t\tv.step++;\n\t\t\t// O のswap\n\t\t\t\tv.O = 3*nY + nX;\n\t\t\t\ttmp=v.tile[3*nY + nX];\n\t\t\t\tv.tile[3*nY + nX]=v.tile[3*y + x];\n\t\t\t\tv.tile[3*y + x]=tmp;\n\t\t\t\t\n\t\t\tif(Hash(v.tile,0,'F'))continue;\n\t\t\t\n\t\t\tPush(v);\n\t\t}\n\t}\n\treturn;\n}\n\nsigned main(){\n\tfor(int i=0;i<4;i++){\n\t}\n\tint i;\n\thead=(puzzle)malloc(sizeof(struct P));\n\n\thead->next=head;\thead->prev = head;\n\thead->step=-1;\n\n\tstruct P in;\n\tfor(i=0;i<9;i++){\n\t\tscanf(\"%d\",&(in.tile[i]));\n\t\tif(in.tile[i]==0)in.O=i;\n\t}\n\tin.step=0;\n\tPush(in);\n\tSolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define N 3\n\nint P[N][N],T[N][N];\nint X[N+1]={0,1,0,-1};\nint Y[N+1]={1,0,-1,0};\n\nvoid empty(int *,int *);\nvoid swap(int *,int *);\nint cal();\nint dfs(int ,int ,int ,int ,const int );\n\nint main()\n{\n  int i,j;\n  int h,ans,row,col;\n\n  for(i=0; i<N; i++){\n    for(j=0; j<N; j++){\n      scanf(\"%d\",&P[i][j]);\n    }\n  }\n\n  empty(&row,&col);\n\n  for(h=0; h<100; h++){\n    for(i=0; i<N; i++){\n      for(j=0; j<N; j++){\n        T[i][j] = P[i][j];\n      }\n    }\n    ans = dfs(row,col,-1,0,h);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n    for(i=0; i<N; i++){\n      for(j=0; j<N; j++){\n        P[i][j] = T[i][j];\n      }\n    }\n    ans = -1;\n    if(h==99)\n      printf(\"%d\\n\\n\",ans);\n  }\n\n  return 0;\n}\n\nvoid empty(int *row,int *col)\n{\n  int i,j;\n\n  for(i=0; i<N; i++){\n    for(j=0; j<N; j++){\n      if(!P[i][j]){\n        *row = j;\n        *col = i;\n        return;\n      }\n    }\n  }\n}\n\nvoid swap(int *a,int *b)\n{\n  int tmp;\n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nint cal()\n{\n  int i,e;\n  int C=0;\n\n  for(i=0; i<9; i++){\n    e = P[i/3][i%3];\n    if(e){\n      e--;\n      C += abs(i/3-e/3) + abs(i%3-e%3);\n    }\n  }\n  return C;\n}\n\nint dfs(int x,int y,int p,int deep,const int limt)\n{\n  int i,len,emc;\n  int x2,y2;\n\n  len = cal();\n\n  if(len==0)\n    return deep;\n  if(deep+len > limt)\n    return -1;\n\n  for(i=0; i<N+1; i++){\n    x2 = x+X[i];\n    y2 = y+Y[i];\n    if(~p && i==(p+2)%4)\n      continue;\n    if(!(0<=x2 && x2<3 && 0<=y2 && y2<3))\n      continue;\n\n    swap(&P[y][x],&P[y2][x2]);\n\n    emc = dfs(x2,y2,i,deep+1,limt);\n\n    if(~emc)\n      return emc;\n\n    swap(&P[y][x],&P[y2][x2]);\n  }\n\n  return -1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX_LENGTH 100\nint ini[3][3];\nint changed[3][3];\nint dxn[4] = {0, 1, 0, -1};\nint dyn[4] = {1, 0, -1, 0};\nvoid makeEmpty(int *row, int *column)\n{\n    for(int i=0;i<3;i++)\n    {\n        for(int j=0;j<3;j++)\n        {\n            if(!ini[i][j]){*column = i;*row = j;}\n        }\n    }\n}\nint calculate()\n{\n    int countSum = 0;\n    for(int i=0;i<9;i++)\n    {\n        int temp = ini[i/3][i%3];\n        if(temp)\n        {\n            temp--;\n            countSum += abs(i/3-temp/3)+abs(i%3-temp%3);\n        }\n    }\n    return countSum;\n}\nint depthFirstSearch(int x, int y, int k, int depth, const int limit)\n{\n    int length;\n    length = calculate();\n    if (length == 0)return depth;\n    if (depth + length > limit)return -1;\n    for (int i = 0; i < 4; i++)\n    {\n        int a = x + dxn[i];\n        int b = y + dyn[i];\n        if (~k && i == (k + 2) % 4)continue;\n        if (!(0 <= a && a < 3 && 0 <= b && b < 3))continue;\n        int tem = ini[y][x];\n        ini[y][x]=ini[b][a];\n        ini[b][a]=tem;\n        int res = depthFirstSearch(a, b, i, depth + 1, limit);\n        if (~res)return res;\n        int te = ini[y][x];\n        ini[y][x]=ini[b][a];\n        ini[b][a]=te;\n    }\n    return -1;\n}\nint main() {\n    int row, column=0;\n    int step;\n    for(int i=0;i<3;i++)\n    {\n        for(int j=0;j<3;j++){scanf(\"%d\", &ini[i][j]);}\n    }\n    makeEmpty(&row, &column);\n    for(int l=0;l<MAX_LENGTH;l++)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++){changed[i][j]=ini[i][j];}\n        }\n        if((step = depthFirstSearch(row, column, -1, 0, l))!=-1)\n        {\n            printf(\"%d\\n\", step);\n            break;\n        }\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++){ini[i][j]=changed[i][j];}\n        }\n        step = -1;\n        if(l==MAX_LENGTH-1){printf(\"%d\\n\", step);}\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n\nint mas[3][3];\nint cpy[3][3];\n\n\n\n\n\nvoid copy(int m[3][3], int t[3][3]) {\n    int i, j;\n    \n    for(i = 0; i < 3; i++)\n        for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n\nint calc() {\n    int i, sum = 0;\n    for(i = 0; i < 9; i++) {\n        int v = mas[i/3][i%3];\n        if(v) {\n            v--;\n            sum += abs(i/3-v/3)+abs(i%3-v%3);\n        }\n    }\n    return sum;\n}\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nvoid swap(int *a, int *b) {\n    int tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n\nint is_in(int x, int y) {\n    return 0<=x&&x<3&&0<=y&&y<3;\n}\n\nint dfs(int x, int y, int p, int dep, const int lim) {\n    int i, h = calc();\n    if(h == 0) return dep;\n    if(dep+h > lim) return -1;\n    \n    for(i = 0; i < 4; i++) {\n        int nx = x+dx[i], ny = y+dy[i], res;\n        if(~p && i == (p+2)%4) continue;\n        if(!is_in(nx, ny)) continue;\n        swap(&mas[y][x], &mas[ny][nx]);\n        res = dfs(nx, ny, i, dep+1, lim);\n        if(~res) return res;\n        swap(&mas[y][x], &mas[ny][nx]);\n    }\n    \n    return -1;\n}\n\nvoid get_empty(int *x, int *y) {\n    int i, j;\n    for(i = 0; i < 3; i++) {\n        for(j = 0; j < 3; j++) {\n            if(!mas[i][j]) {\n                *x = j;\n                *y = i;\n                return;\n            }\n        }\n    }\n}\n\nint solve() {\n    int x, y, lim, ans;\n    get_empty(&x, &y);\n    for(lim = 0; lim < 50; lim++) {\n        copy(cpy, mas);\n        if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n        copy(mas, cpy);\n    }\n    return -1;\n}\n\nint main() {\n    int i, j;\n    for(i = 0; i < 3; i++)\n        for(j = 0; j < 3; j++)\n            scanf(\"%d\", &mas[i][j]);\n    printf(\"%d\\n\", solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n  \n#define N 3\n#define LIM 32\n#define HN 362897\n  \nstruct dep{\n    int depth,key;\n};\n  \nint ans[N][N]={\n    {1,2,3},\n    {4,5,6},\n    {7,8,0}};\n  \nint min = LIM;\nstruct dep h[HN];\n  \nint hash1(int k)\n{\n    return k % HN;\n}\nint hash2(int k)\n{\n    return 1 + k%(HN-1);\n}\nint hash(int k, int i)\n{\n    return (hash1(k) + i*hash2(k))%HN;\n}\n  \n  \nvoid dfs(int p[N][N], int n)\n{\n    int i,j,i1,j1,a=0,b=1;\n    int f=0;\n    int tmp[N][N];\n    //printf(\"A\\n\");\n    for(i=0;i<N;i++)\n    {\n        for(j=0;j<N;j++)\n        {\n            if(ans[i][j]!=p[i][j])f++;\n            if(p[i][j]==0)\n            {\n                i1=i;\n                j1=j;\n            }\n            a+=p[i][j]*b;\n            b*=10;\n        }\n    }\n      \n    if(f==0)\n    {\n        if(min>=n)\n        {\n            min=n;\n        }\n        return;\n    }\n    if(n>min) return;\n    i=0;\n    while(1)\n    {\n        b=hash(a, i);\n        if(h[b].key == 0)\n        {\n            h[b].key=a;\n            h[b].depth=n;\n            break;\n        }\n        else if(h[b].key == a)\n        {\n            if(h[b].depth>n)\n            {\n                h[b].depth=n;\n                break;\n            }\n            else return;\n        }\n        i++;\n    }\n      \n    if(i1>0 && i1<N)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i1][j1];\n        tmp[i1][j1]=tmp[i1-1][j1];\n        tmp[i1-1][j1]=f;\n        dfs(tmp, n+1);\n    }\n    if(j1>0 && j1<N)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i1][j1];\n        tmp[i1][j1]=tmp[i1][j1-1];\n        tmp[i1][j1-1]=f;\n        dfs(tmp, n+1);\n    }\n      \n    if(i1>=0 && i1<N-1)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i1][j1];\n        tmp[i1][j1]=tmp[i1+1][j1];\n        tmp[i1+1][j1]=f;\n        dfs(tmp, n+1);\n    }\n    if(j1>=0 && j1<N-1)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i1][j1];\n        tmp[i1][j1]=tmp[i1][j1+1];\n        tmp[i1][j1+1]=f;\n        dfs(tmp, n+1);\n    }\n      \n}\n  \nint main()\n{\n    int i,j;\n    int p[N][N];\n      \n    for(i=0;i<N;i++)\n    {\n        for(j=0;j<N;j++)\n        {\n            scanf(\"%d\",&p[i][j]);\n        }\n    }\n    dfs(p,0);\n      \n    printf(\"%d\\n\",min);\n      \n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint a[10];\nint fact[10]={1,1,2,6,24,120,720,5040,40320};\n\nint dp[362880];\nvoid swap(int i,int j){\n\tint t=a[i];\n\ta[i]=a[j];\n\ta[j]=t;\n}\n\nint f(){\n\tint ans=0,b=0;\n\tfor(int i=8;i>=0;i--){\n\t\tans+=__builtin_popcount(b&((1<<a[i])-1))*fact[8-i];\n\t\tb|=1<<a[i];\n\t}\n\treturn ans;\n}\nvoid g(int n){\n\tint b=0;\n\tfor(int i=0;i<9;i++)a[i]=i;\n\tfor(int i=0;i<9;i++){\n\t\tint x=n/fact[8-i];\n\t\tn%=fact[8-i];\n\t\tfor(int j=x;j>0;j--)swap(i+j,i+j-1);\n\t}\n}\n\nint que[363000],quecnt;\nvoid check(int p,int k){\n\tint x=f();\n\tif(!dp[x]){\n\t\tdp[x]=k+1;\n\t\tque[quecnt++]=x*10+p;\n\t}\n}\nint calc(){\n\tfor(int i=0;i<quecnt;i++){\n\t\tint x=que[i]/10;\n\t\tint p=que[i]%10;\n\t\tif(x==0)return dp[x]-1;\n\t\tg(x);\n\t\tif(p  <6)swap(p,p+3),check(p+3,dp[x]),swap(p,p+3);\n\t\tif(p  >2)swap(p,p-3),check(p-3,dp[x]),swap(p,p-3);\n\t\tif(p%3<2)swap(p,p+1),check(p+1,dp[x]),swap(p,p+1);\n\t\tif(p%3>0)swap(p,p-1),check(p-1,dp[x]),swap(p,p-1);\n\t}\n\treturn -1;\n}\n\nint main(){\n\tint p;\n\tfor(int i=0;i<9;i++){\n\t\tint t;\n\t\tscanf(\"%d\",&t);\n\t\tif(t)a[i]=t-1;\n\t\telse{\n\t\t\ta[i]=8;\n\t\t\tp=i;\n\t\t}\n\t}\n\tcheck(p,0);\n\tprintf(\"%d\\n\",calc());\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define N 3\n#define N2 9\n#define LIMIT 31\n\ntypedef struct { char b[N2+1]; } Board;\nBoard board;\nint minstep;\ntypedef enum { R, U, L, D } Direction;\ntypedef struct { int pos; Direction dir; } Motion;\n\nconst Motion motion[N2][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nconst int rr[4][5] = {{0,0,1,0,0},{0,0,0,1,0},{1,0,0,0,0},{0,1,0,0,0}};\n\nint dd[N2][N2];\nint dist(char *b)\n{\n  int i, n, d = 0;\n  for (i=0; i<N2; i++) {\n    n = b[i]-1;\n    if (n<0)   continue;\n    d += dd[n][i];\n  }\n  return d;\n}\n\nvoid search(int step, Motion prev)\n{\n  int i, d=0;\n  d = dist(board.b);\n  if (step+d>minstep) return;\n  if (d==0) {\n    printf(\"%d\\n\", step);\n    exit(0);\n  }\n  Board board_bak = board;\n  for (i=0; motion[prev.pos][i].pos>=0; i++) {\n    Motion m = motion[prev.pos][i];\n    if (rr[m.dir][prev.dir]) continue; //元に戻るのを防止\n    board.b[prev.pos] = board.b[m.pos];\n    board.b[m.pos] = 0;\n    search(step+1, m);\n    board = board_bak;\n  }\n}\n\nint main()\n{\n  int i, j;\n  for (i=0; i<N2; i++)\n    for (j=0; j<N2; j++)\n      dd[i][j] = abs(i%N-j%N) + abs(i/N-j/N);\n  \n  Motion m;\n  m.dir = 4;\n  Board ini_board;\n  for (i=0; i<N2; i++) {\n    fscanf(stdin, \"%hd\", (short int*)&ini_board.b[i]);\n    if (ini_board.b[i]==0) m.pos = i;\n  }\n  for (minstep=dist(ini_board.b); minstep<=LIMIT; minstep++) {\n    board = ini_board;\n    search(0, m);\n  }\n  puts(\"no result.\");\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint puz[3][3];\nint tmp[3][3];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n\nvoid empty(int *x,int *y){\n  int i,j;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(!puz[i][j]){\n\t*x=j;\n\t*y=i;\n\treturn;\n      }\n    }\n  }\n}\n\nvoid swap(int *a,int *b){\n  int tmp=*a;\n \n  *a=*b;\n  *b=tmp;\n}\n\nint cal(){\n  int v,i,sum=0;\n  for(i=0;i<9;i++){\n    v=puz[i/3][i%3];\n    if(v){\n      v--;\n      sum += abs(i/3-v/3) + abs(i%3-v%3);\n    }\n  }\n  return sum;\n}\n\nint dfs(int x,int y,int p,int dep,const int lim){\n  \n  int i,h,nx,ny,res;\n\n  h=cal();\n  \n  if(h==0){\n    return dep;\n  }\n  \n  if(dep+h > lim){\n    return -1;\n  }\n  \n  for(i=0;i<4;++i){\n    nx=x+dx[i];\n    ny=y+dy[i];\n    \n    if(~p && i==(p+2)%4)\n      continue;\n    if(!(0 <= nx && nx < 3 && 0 <= ny && ny < 3))\n      continue;\n    \n    swap(&puz[y][x],&puz[ny][nx]);\n    \n    res=dfs(nx,ny,i,dep+1,lim);\n    \n    if(~res){\n      return res;\n    }\n    swap(&puz[y][x],&puz[ny][nx]);\n  }\n  return -1;\n}\n\nint main(){\n  \n  int i,j,ans,x,y,l;\n  \n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&puz[i][j]);\n    }\n  }\n  \n  empty(&x,&y);\n\n  for(l=0;l<100;l++){\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n\ttmp[i][j]=puz[i][j];\n    }\n    }\n    ans=dfs(x,y,-1,0,l);\n\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n\tpuz[i][j]=tmp[i][j];\n    }\n    }\n    ans=-1;\n\n    if(l==99){\n      printf(\"%d\\n\",ans);\n  }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct node{\n  struct node *right;\n  struct node *left;\n  struct node *parent;\n  int key;\n};\n\ntypedef struct node * Node;\n\n#define NIL NULL\n#define N 3\n#define N2 9\n#define M 10000000\n\nNode root;\n\ntypedef struct{\n  int f[N2];\n  int space;\n  int path;\n}Puzzle;\n\nint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\nint sum,head=0,tail=0;\nPuzzle Q[M];\n\nvoid push(Puzzle a){\n  Q[tail]=a;\n  tail=(tail+1)%M;\n}\n\nPuzzle pop(void){\n  head=(head+1)%M;\n  return Q[head-1];\n}\n\n\nint isTarget(Puzzle p){\n  int i;\n  for(i=0;i<N2;i++){\n    if(p.f[i]!=(i+1)) return 0;\n  }\n  return 1;\n}\n\nNode treeSearch(Node u, int k){\n  if(u==NIL || k==u->key) return u; \n  if(k < u->key) return treeSearch(u->left,k);\n  else return treeSearch(u->right,k);\n}\n\nint search(Puzzle a){\n  int i,m=1,k;\n  sum=0;\n  for(i=0;i<N2;i++){\n    sum+=a.f[i]*m;\n    m*=10;\n  }\n  if(treeSearch(root,sum)==NIL) return -1;\n  else return 1;\n}\n\n\n\nvoid insert(int k){\n  Node y=NIL;\n  Node x=root;\n  Node z;\n\n  z=malloc(sizeof(struct node));\n  z->key=k;\n  z->left=NIL;\n  z->right=NIL;\n \n  while(x!=NIL){\n    y=x;\n    if(z->key < x->key) x=x->left;\n    else x=x->right;\n  }\n  z->parent=y;\n\n  if(y==NIL) root=z;\n  else if(z->key < y->key) y->left=z;\n  else y->right=z;\n}\n\n\nint bfs(Puzzle s){\n  Puzzle u,v;\n  int r,x;\n  s.path=0;\n  push(s);\n\n  while(head!=tail){\n    u=pop();\n    //     printf(\"%d %d %d\\n%d %d %d\\n%d %d %d\\n\",u.f[0],u.f[1],u.f[2],u.f[3],u.f[4],u.f[5],u.f[6],u.f[7],u.f[8]);\n    if(isTarget(u)) return u.path;\n    int sx=u.space/N, sy=u.space%N;\n    for(r=0;r<4;r++){\n      int tx=sx+dx[r], ty=sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>=N) continue;\n      v=u;\n      \n      x=v.f[u.space];\n      v.f[u.space]=v.f[tx*N + ty];\n      v.f[tx*N + ty]=x;\n     \n      v.space=tx*N + ty;\n      if(search(v)==-1){\n\tv.path++;\n\tpush(v);\n\tinsert(sum);\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  Puzzle in;\n  int i;\n  for(i=0;i<N2;i++){\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i]==0){\n      in.f[i]=N2;\n      in.space=i;\n    }\n  }\n\n  printf(\"%d\\n\",bfs(in));\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h> \n#define N 3\n  \nint search(int board[N][N], int min, int limit, int r_0, int c_0);\nint search(int board[N][N], int min, int limit, int r_0, int c_0){\n  int md_c;\n  int num;\n  int res[4];\n  if (min == 0){\n    return 0;\n  }\n  if (r_0 != 0) {\n    md_c = min;\n    num = board[r_0-1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0-1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0-1][c_0] = 0;\n      board[r_0][c_0] = num;\n      res[0] = search(board, md_c, limit-1, r_0-1, c_0);\n      if (res[0] == -1) {\n\tboard[r_0-1][c_0] = num;\n\tboard[r_0][c_0] = 0;\n      }\n      else {\n\tres[0]++;\n      }\n    }\n    else{\n      res[0] = -1;\n    }\n  }\n  else{\n    res[0] = -1;\n  }\n  if (r_0 != N-1) {\n    md_c = min;\n    num = board[r_0+1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0+1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0+1][c_0] = 0;\n      board[r_0][c_0] =num;\n      res[1] = search(board, md_c, limit-1, r_0+1, c_0);\n      if (res[1] == -1) {\n\tboard[r_0+1][c_0] = num;\n\tboard[r_0][c_0] = 0;\n      }\n      else{\n\tres[1]++;\n      }\n    }\n    else{\n      res[1] = -1;\n    }\n  } \n  else{\n    res[1] = -1;\n  }\n  if (c_0 != 0) {\n    md_c = min;\n    num = board[r_0][c_0-1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0-1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0-1] = 0;\n      board[r_0][c_0] = num;\n      res[2] = search(board, md_c, limit-1, r_0, c_0-1);\n      if (res[2] == -1) {\n\tboard[r_0][c_0-1] = num;\n\tboard[r_0][c_0] = 0;\n      }\n      else{\n\tres[2]++;\n      }\n    }\n    else{\n      res[2] = -1;\n    }\n  }\n  else{\n    res[2] = -1;\n  }\n  if (c_0 != N-1) {\n    md_c = min;\n    num = board[r_0][c_0+1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0+1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0+1] = 0;\n      board[r_0][c_0] = num;\n      res[3] = search(board, md_c, limit-1, r_0, c_0+1);\n      if (res[3] == -1) {\n        board[r_0][c_0+1] = num;\n        board[r_0][c_0] = 0;\n      }\n      else{\n\tres[3]++;\n      }\n    }\n    else{\n      res[3] = -1;\n    }\n  }\n  else{\n    res[3] = -1;\n  }\n  if (res[0] == -1 && res[1] == -1 && res[2] == -1 && res[3] == -1){\n    return -1;\n  }\n  else if (res[0] != -1){\n    return res[0];\n  }\n  else if (res[1] != -1){\n    return res[1];\n  }\n  else if (res[2] != -1){\n    return res[2];\n  }\n  else return{\n      res[3];\n    }\n}\nint main(int argc, char *argv[]){\n  int board[N][N],md,i,j,r,c,r_0,c_0,found,res;\n  for (i = 0; i < N; i++) {\n    for (j = 0; j < N; j++){\n      scanf(\"%d\", &board[i][j]);\n    }\n  }\n  md = 0;\n  for (i = 0; i < N * N; i++) {\n    found = 0;\n    for (r = 0; r < N; r++) {\n      for (c = 0; c < N; c++) {\n\tif (board[r][c] == i) {\n\t  if (i == 0) {\n\t    r_0 = r;\n\t    c_0 = c;\n\t  }\n\t  else{\n\t    md += (int)fabs((i-1)/N - r) + (int)fabs((i-1)%N - c);\n\t  }\n\t  found = 1;\n\t  break;\n\t}\n      }\n      if (found == 1){\n\tbreak;\n      }\n    }\n  }\n  \n  for (i = 0; ; i += 2) {\n    if ((r_0 + c_0) % 2 == 0) {\n      if (md % 2 == 0){\n\tres = search(board, md, md+i, r_0, c_0);\n      }\n      else{\n\tres = search(board, md, md+i+1, r_0, c_0);\n      }\n    }\n    else {\n      if (md % 2 == 0){\n\tres = search(board, md, md+i+1, r_0, c_0);\n      }\n      else{\n\tres = search(board, md, md+i, r_0, c_0);\n      }\n    }\n    if (res != -1) break;\n  }  \n  printf(\"%d\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n\nint DFS(int,int,int , int);\n\nint tag();\nvoid change(int *, int *);\n\nint xarr[4]={-1,0,1,0},yarr[4]={0,-1,0,1};\nint array[3][3],sum;\nint main(){\n  int i,j,zerox,zeroy;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&array[i][j]);\n      if(array[i][j]==0){\n\n\tzerox=j;\n\tzeroy=i;\n      }\n    }\n  }\n\n  for(sum=0;sum<32;sum++){\n    if(DFS(0,10,zerox,zeroy)==1) break;\n  }\n  printf(\"%d\\n\",sum);  /*output*/\n  return 0;\n}\nint  DFS(int dep, int prev, int zerox, int zeroy){\n  int i,xx,yy,ta;\n  ta=tag();\n  if(ta==0) return 1;\n  if(dep+ta>sum) return -1;\n\n    for(i=0;i<4;i++){\n      if(i-prev==-2 || i-prev==2) continue;\n      xx=zerox+xarr[i];\n      yy=zeroy+yarr[i];\n      if(xx<0 || yy<0 || xx>=3 || yy>=3) continue;\n      change(&array[zeroy][zerox],&array[yy][xx]);\n\n      if(DFS(dep+1,i,xx,yy)==1) return 1;\n      change(&array[zeroy][zerox],&array[yy][xx]);\n\n    }\n    return -1;\n\n}\n\n\n\nint tag(){\n  int i,j,num=0;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(array[i][j]==0) continue;\n      num+=abs((array[i][j]-1)/3-i)+abs((array[i][j]-1)%3-j);\n\n\n    }\n  }\n  return num;\n}\n\n/*exchange array[zeroy][zerox] and array[yy][xx]*/\nvoid change(int * num1, int *num2){\n  int ch;\n  ch=*num1;\n  *num1=*num2;\n  *num2=ch;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint main(){\n\tint ret;\n\tint i, j, temp;\n\tint seikai[9][2] =\n\t{\n\t\t{0,0},\n\t\t{0,1},\n\t\t{0,2},\n\t\t{1,0},\n\t\t{1,1},\n\t\t{1,2},\n\t\t{2,0},\n\t\t{2,1},\n\t\t{2,2}\n\t};\n\n\tret = 0;\n\tfor(i = 0; i < 3; i++){\n\t\tfor(j = 0; j < 3; j++){\n\t\t\tscanf(\"%d\", &temp);\n\t\t\tif(temp != 0){\n\t\t\t\tret += abs(seikai[(temp - 1)][0] - i);\n\t\t\t\tret += abs(seikai[(temp - 1)][1] - j);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n#include <stdlib.h>         // abs()\n\nint puzz[3][3];\nint temp[3][3];\nint dx[4] = { 0, 1, 0,-1};\nint dy[4] = { 1, 0,-1, 0};\n\nvoid\nempty(int *x, int *y)\n{\n\tfor (int i = 0; i < 3; ++i)\n\t{\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t{\n\t\t\tif (!puzz[i][j])\n\t\t\t{\n\t\t\t\t*x = j;\n\t\t\t\t*y = i;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid\nswap(int *a, int *b)\n{\n\tint temp = *a;\n\t*a = *b;\n\t*b = temp;\n}\n\nint\ncal()\n{\n\tint sum = 0;\n\tfor (int i = 0; i < 9; ++i)\n\t{\n\t\tint a = puzz[i / 3][i % 3];\n\t\tif (a)\n\t\t{\n\t\t\ta--;\n\t\t\tsum += abs(i / 3 - a / 3) + abs(i % 3 - a % 3);\n\t\t}\n\t}\n\n\treturn sum;\n}\n\nint\ndfs(int x, int y, int p, int dep, const int lim)\n{\n\tint h = cal();\n\tif (h == 0)\n\t\treturn dep;\n\n\tif (dep + h > lim)\n\t\treturn -1;\n\n\tfor (int i = 0; i < 4; ++i)\n\t{\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\n\t\tif (p != -1 && i == (p + 2) % 4)\n\t\t\tcontinue;\n\n\t\tif (0 <= nx && nx < 3 && 0 <= ny && ny < 3)\n\t\t{\n\t\t\tswap(&puzz[y][x], &puzz[ny][nx]);\n\t\t\tint res = dfs(nx, ny, i, dep + 1, lim);\n\t\t\tif (res != -1)\n\t\t\t\treturn res;\n\n\t\t\tswap(&puzz[y][x], &puzz[ny][nx]);\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint\nmain(int argc, char **argv)\n{\n\tfor (int i = 0; i < 3; ++i)\n\t{\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t\tscanf(\"%d\", &puzz[i][j]);\n\t}\n\n\tint x = 0, y = 0;\n\tempty(&x, &y);\n\n\tfor (int l = 0; l < 100; ++l)\n\t{\n\t\tfor (int i = 0; i < 3; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < 3; ++j)\n\t\t\t\ttemp[i][j] = puzz[i][j];\n\t\t}\n\n\t\tint ans = dfs(x, y, -1, 0, l);\n\t\tif (ans != -1)\n\t\t{\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < 3; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < 3; ++j)\n\t\t\t\tpuzz[i][j] = temp[i][j];\n\t\t}\n\n\t\tans = -1;\n\t\tif (l == 99)\n\t\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\ntypedef char Board[10];\nBoard ini_board, board;\nconst Board target = \"123456780\";\nBoard *history;\nint nhistories=0;\ntypedef enum { U, D, L, R } Direction;\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\nint minstep = INT_MAX;\nconst Motion candidate[9][5] = \n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\nint move(Motion m)\n{\n  if (m.pos==0 && board[0]=='1') return -1;\n  if ((m.pos==1||m.pos==2) && board[0]=='1'&&board[1]=='2'&&board[2]=='3') return -1;\n  \n  switch (m.dir) {\n  case U:\n    if (m.pos<3) return -1;\n    board[m.pos-3] = board[m.pos];\n    break;\n  case D:\n    if (m.pos>5) return -1;\n    board[m.pos+3] = board[m.pos];\n    break;\n  case L:\n    if (m.pos%3==0) return -1;\n    board[m.pos-1] = board[m.pos];\n    break;\n  case R:\n    if (m.pos%3==2) return -1;\n    board[m.pos+1] = board[m.pos];\n    break;\n  }\n  board[m.pos] = '0';\n  return m.pos;\n}\n\nvoid search_path(int step, int space)\n{\n  int i, j, s2;\n  if (strcmp(board, \"123456780\")==0) {\n    \n    if (step==1) {\n      printf(\"1\\n\");\n      exit(0);\n    }\n    if (step<minstep) minstep=step;\n  } else {\n    if (step>=minstep) return; \n    if (step>0 && strcmp(board, ini_board)==0) return; \n    \n    Board board_bak;\n    strcpy(board_bak, board);\n    int nhistories_bak=nhistories;\n    \n    for (i=0; candidate[space][i].pos>=0; i++) {\n      if ((s2 = move(candidate[space][i]))<0) continue;\n      for (j=0; j<nhistories; j++) {\n\tif (strcmp(board, history[j])==0) \n\t  break;\n      }\n      if (j==nhistories) {\n\tstrcpy(history[nhistories++], board); \n\tsearch_path(step+1, s2);\n      }\n      nhistories = nhistories_bak;\n      strcpy(board, board_bak);\n    }\n  }\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board[0],&board[1],&board[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[3],&board[4],&board[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[6],&board[7],&board[8]);\n  strcpy(ini_board, board);\n  history = (Board*)malloc(sizeof(Board)*100000);\n  search_path(0, strchr(board, '0')-board);\n  printf(\"%d\\n\", minstep);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define base 100000000\nint target = 123456780;\n\nint input[9];\nint n = 3;\nint nSq = 9;\n\nint qh = 0; qt = 0;\nlong long queue[200000];\nint qLength = 200000;\n\nint max = 200000;\nint T[200000];\n\ntypedef struct node {\n\tstruct node* parent;\n\tint hash;\n} node_t;\n\nnode_t* source = NULL;\n\nnode_t* newNode(int);\nint toState(int[]);\nvoid* toArray(int*, int);\n\nint getZeroPos(int);\nint swap(int, int, int);\nint getNext(long long*, node_t*);\n\nvoid getPath(node_t*);\n\nvoid bfs(node_t*);\n\nint isEmpty();\nvoid enqueue(node_t*);\nnode_t* dequeue();\n\nint hashSearch(int);\nint hashInsert(int);\nint hash(int, int);\n\nint main() {\n\tint i, j;\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++)\tscanf(\"%d\", &input[i * n + j]);\n\t}\n\tint state = toState(input);\n\tif (state == target) {\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tint hashK = hashInsert(state);\n\tsource = newNode(hashK);\n\tbfs(source);\n\n\treturn 0;\n}\n\nnode_t* newNode(int hashK) {\n\tnode_t* node = (node_t*)malloc(sizeof(node_t));\n\tnode->parent = NULL;\n\tnode->hash = hashK;\n\treturn node;\n}\n\nint toState(int from[]) {\n\tint result = 0;\n\tint weight = base;\n\n\tfor (int i = 0; i < (n * n); i++) {\n\t\tresult += from[i] * weight;\n\t\tweight /= 10;\n\t}\n\treturn result;\n}\n\nvoid* toArray(int* store, int state) {\n\tint weight = base;\n\n\tfor (int i = 0; i < (n * n); i++) {\n\t\tstore[i] = (int)(state / weight);\n\t\tstate %= weight;\n\t\tweight /= 10;\n\t}\n}\n\nint getZeroPos(int state) {\n\tint weight = base;\n\tfor (int i = 0; i < nSq; i++) {\n\t\tif (state / weight == 0) return i;\n\t\tstate %= weight;\n\t\tweight /= 10;\n\t}\n\texit(0);\n}\n\nint swap(int originalState, int zero_pos, int with_pos) {\n\tint newState;\n\tint swapArray[9];\n\ttoArray(&swapArray, originalState);\n\n\tint temp = *(swapArray + with_pos);\n\t*(swapArray + with_pos) = *(swapArray + zero_pos);\n\t*(swapArray + zero_pos) = temp;\n\n\tnewState = toState(swapArray);\n\n\treturn newState;\n}\n\nint getNext(long long* states, node_t* current) {\n\tint count = 0;\n\n\tint current_state = T[current->hash];\n\n\tint zero_pos = getZeroPos(current_state);\n\tint row = zero_pos / n;\n\tint col = zero_pos % n;\n\n\tif (row != 0) {\t//swap with above\n\t\tint newState = swap(current_state, zero_pos, zero_pos - 3);\n\n\t\tif (hashSearch(newState) == -1) {\n\t\t\tint newHash = hashInsert(newState);\n\n\t\t\tnode_t* add = newNode(newHash);\n\t\t\tadd->parent = current;\n\n\t\t\tstates[count] = add;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (row != 2) {\t//swap with below\n\t\tint newState = swap(current_state, zero_pos, zero_pos + 3);\n\n\t\tif (hashSearch(newState) == -1) {\n\t\t\tint newHash = hashInsert(newState);\n\n\t\t\tnode_t* add = newNode(newHash);\n\t\t\tadd->parent = current;\n\n\t\t\tstates[count] = add;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (col != 0) {\t//swap with left\n\t\tint newState = swap(current_state, zero_pos, zero_pos - 1);\n\n\t\tif (hashSearch(newState) == -1) {\n\t\t\tint newHash = hashInsert(newState);\n\n\t\t\tnode_t* add = newNode(newHash);\n\t\t\tadd->parent = current;\n\n\t\t\tstates[count] = add;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (col != 2) {\t//swap with right\n\t\tint newState = swap(current_state, zero_pos, zero_pos + 1);\n\n\t\tif (hashSearch(newState) == -1) {\n\t\t\tint newHash = hashInsert(newState);\n\n\t\t\tnode_t* add = newNode(newHash);\n\t\t\tadd->parent = current;\n\n\t\t\tstates[count] = add;\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n\nvoid getPath(node_t* from) {\n\tint distance = 0;\n\tnode_t* cur = from;\n\twhile (cur->parent != NULL) {\n\t\tcur = cur->parent;\n\t\tdistance++;\n\t}\n\tprintf(\"%d\\n\", distance);\n\texit(0);\n}\n\nvoid bfs(node_t* start) {\n\tenqueue(start);\n\n\twhile (!isEmpty()) {\n\t\tnode_t* init = dequeue();\n\t\tlong long states[4];\n\t\tint length = getNext(&states, init);\n\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tnode_t* cur = states[i];\n\t\t\tif (T[cur->hash] == target)\tgetPath(cur);\n\t\t\tenqueue(cur);\n\t\t}\n\t}\n}\n\n\nint isEmpty() {\n\tif (qt == qh) return 1;\n\treturn 0;\n}\n\nvoid enqueue(node_t* x) {\n\tqueue[qt] = x;\n\tif (qt + 1 == qLength) qt = 0;\n\telse qt++;\n}\n\nnode_t* dequeue() {\n\tnode_t* x = queue[qh];\n\tif (qh + 1 == qLength) qh = 0;\n\telse qh++;\n\treturn x;\n}\n\n\nint hashInsert(int k) {\n\tint i = 0;\n\twhile (1) {\n\t\tint hashKey = hash(k, i);\n\t\tif (T[hashKey] == 0) {\n\t\t\tT[hashKey] = k;\n\t\t\treturn hashKey;\n\t\t}\n\t\ti++;\n\t}\n\treturn -1;\n}\n\nint hashSearch(int k) {\n\tint i = 0;\n\twhile (1) {\n\t\tint hashKey = hash(k, i);\n\t\tif (T[hashKey] == k) return hashKey;\n\t\tif (T[hashKey] == 0) return -1;\n\t\tif (i >= max) exit(10);\n\t\ti++;\n\t}\n\treturn -1;\n}\n\nint hash(int k, int i) {\n\tint hash1 = k % 199999;\n\tint hash2 = 1 + k % 199967;\n\tint ans = ((hash1 + i * hash2) % 199999);\n\tif (ans < 0) ans *= -1;\n\treturn ans;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 9\n\nint board[N];\nint rows = 3, cols = 3, zeroIndex, current;\n\n// for previousMove: 0 is down, 1 is up, 2 is left, 3 is right\nint blindSearch(int x, int y, int moves, int previousMove) {\n  int i, foundAnswer;\n\n  // answer is less than manhattan distance, not possible\n  if (moves < (x + y))\n      return 0;\n\n  if (!moves) {\n    //printf(\"done %d moves\\n\", current);\n\n    for (i = 0; i < N - 1; i++) {\n      if (board[i] != i + 1)\n        return 0;\n    }\n\n    return 1;\n  }\n\n  if (x > 0 && previousMove != 1) {\n    // can expand down\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n\n    foundAnswer = blindSearch(x - 1, y, moves - 1, 0);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n  }\n\n  if (y > 0 && previousMove != 3) {\n    // right\n    board[zeroIndex] = board[++zeroIndex];\n\n    foundAnswer = blindSearch(x, y - 1, moves - 1, 2);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[--zeroIndex];\n  }\n\n  if (y < rows - 1 && previousMove != 2) {\n    // left\n    board[zeroIndex] = board[--zeroIndex];\n\n    foundAnswer = blindSearch(x, y + 1, moves - 1, 3);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[++zeroIndex];\n  }\n\n if (x < cols - 1 && previousMove != 0) {\n    // up\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n\n    foundAnswer = blindSearch(x + 1, y, moves - 1, 1);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n  }\n\n  return 0;\n}\n\nint main() {\n  int i, x, y;\n  current = 0;\n\n  for (i = 0; i < N; i++) {\n    scanf(\"%d\", &board[i]);\n    if (!board[i])\n      zeroIndex = i;\n  }\n\n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n\n  //printf(\"zero index coordinates are: %d %d\\n\", x, y);\n\n  while (current < 5) {\n    if (blindSearch(x, y, current, -1)) {\n      printf(\"%d\\n\", current);\n      return;\n    }\n    current++;\n  }\n\n  //printf(\"Couldn't find an answer!\\n\");\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n  unsigned int b;\n  char step;\n} Board;\n\nint qlen=32202;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nconst Motion motion[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}} };\n\nint findzero(unsigned int b)\n{\n  for (int i=0; i<9; i++) {\n    if (b%10==0) return 8-i;\n    b/=10;\n  }\n  return -1;\n}\n\nunsigned int sq[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000,1000000000 };\n\n#define HISTLEN 876543\n\nint main()\n{\n  int i, j, k;\n  int qhead, qtail;\n  qhead = qtail = 0;//\n  Board board;\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b = i*sq[8]+j*sq[7]+k*sq[6];\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b += i*sq[5]+j*sq[4]+k*sq[3];\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b += i*100+j*10+k;\n  short int *used = (short int*)malloc(sizeof(short int)*HISTLEN);\n  for (i=0; i<HISTLEN; i++) used[i]=0;\n  Board *Q = (Board*)malloc(sizeof(Board)*qlen);\n  board.step=0;\n  Q[qhead++] = board;\n  \n  while (qhead>qtail) {\n    board = Q[qtail++ %qlen];\n    if (board.b==123456780)   break;\n    \n    int space = findzero(board.b);\n    for (i=0; motion[space][i].pos>=0; i++) {\n      Board b = board;\n      Motion m = motion[space][i];\n      if (m.pos==0 && b.b/sq[8]==1) continue;\n      if ((m.pos==1||m.pos==2) && b.b/sq[8]==1&&(b.b%sq[8])/sq[7]==2&&(b.b%sq[7])/sq[6]==3) continue;\n      int nn=b.b%sq[8-m.pos+1]/sq[8-m.pos];\n      b.b = nn*sq[8-space]+b.b-nn*sq[8-m.pos];\n      b.step = board.step+1;\n      k=b.b/1000;\n      if ((used[k] & (1<<(b.b%10)))==(1<<(b.b%10))) continue;\n      used[k] |= (1<<(board.b%10));\n      Q[qhead++ %qlen] = b;\n    }\n  }\n  printf(\"%d\\n\", board.step);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define Ni 3\n\nint Pz[Ni][Ni],tmp[Ni][Ni];\nint Dx[4]={0,1,0,-1},Dy[4]={1,0,-1,0};\n\nvoid emblem(int *a,int *b){\n  int i,j;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(!Pz[i][j]){\n\t*a = j;\n\t*b=i;\n      }\n    }\n  }\n}\n\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp =*a;\n  *a = *b;\n  *b = tmp;\n}\n\nint check(){\n  int i,A,S=0;\n  for(i=0;i<9;i++){\n    A = Pz[i/3][i%3];\n    if(A){\n      A--;\n      S += abs(i/3-A/3) + abs(i%3 - A%3);\n    }\n  }\n  return S;\n}\n\nint defain(int a,int b,int P,int D,const int shin){\n  int i,hi,A,B,result;\n  hi = check();\n  if(hi==0){\n    return D;\n  }\n  if(D+hi>shin){\n    return -1;\n  }\n\n  for(i=0;i<4;i++){\n    A = a+Dx[i];\n    B = b+Dy[i];\n    if(~P && i==(P+2)%4) {\n      continue;\n    }\n    if(!(0<=A && A<3 && 0<=B && B<3)){\n      continue;\n    }\n    swap(&Pz[b][a],&Pz[B][A]);\n    result = defain(A,B,i,D+1,shin);\n    if(~result){\n      return result;\n    }\n    swap(&Pz[b][a],&Pz[B][A]);\n  }\n  return -1;\n}\n\nint main(){\n  int i,j,li,TA,a,b;\n\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&Pz[i][j]);\n    }\n  }\n\n  emblem(&a,&b);\n  for(li=0;li<100;li++){\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n\ttmp[i][j]=Pz[i][j];\n      }\n    }\n    TA = defain(a,b,-1,0,li);\n    if(TA!=-1){\n      printf(\"%d\\n\",TA);\n      break;\n    }\n\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n\tPz[i][j]=tmp[i][j];\n      }\n    }\n\n    TA = -1;\n    if(li==99){\n      printf(\"%d\\n\",TA);\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define N 3\n\nint search(int board[N][N], int min, int limit, int r_0, int c_0);\n\nint main(int argc, char *argv[])\n{\n  int board[N][N];\n  int md;\n  int i, j, r, c, r_0, c_0;\n  int res;\n\n  for (i = 0; i < N; i++) {\n    for (j = 0; j < N; j++) scanf(\"%d\", &board[i][j]);\n  }\n\n  md = 0;\n  for (i = 0; i < N * N; i++) {\n    for (r = 0; r < N; r++) {\n      for (c = 0; c < N; c++) {\n\tif (board[r][c] == i) {\n\t  if (i == 0) {\n\t    r_0 = r;\n\t    c_0 = c;\n\t  } else md += (int)fabs((i-1)/N - r) + (int)fabs((i-1)%N - c);\n\t  break;\n\t}\n      }\n      if (board[r][c] == i) break;\n    }\n  }\n\n  for (i = 0; ; i += 2) {\n    if ((r_0 + c_0) % 2 == 0) {\n      if (md % 2 == 0) res = search(board, md, md+i, r_0, c_0);\n      else res = search(board, md, md+i+1, r_0, c_0);\n    } else {\n      if (md % 2 == 0) res = search(board, md, md+i+1, r_0, c_0);\n      else res = search(board, md, md+i, r_0, c_0);\n    }\n\n    if (res != -1) break;\n  }\n\n  printf(\"%d\\n\", res);\n\n  return 0;\n}\n\nint search(int board[N][N], int min, int limit, int r_0, int c_0)\n{\n  int md_c;\n  int num;\n  int res[4];\n\n  if (min == 0) return 0;\n\n  if (r_0 != 0) {\n    md_c = min;\n    num = board[r_0-1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0-1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0-1][c_0] = 0;\n      board[r_0][c_0] = num;\n      res[0] = search(board, md_c, limit-1, r_0-1, c_0);\n      if (res[0] == -1) {\n\tboard[r_0-1][c_0] = num;\n\tboard[r_0][c_0] = 0;\n      } else res[0]++;\n    } else res[0] = -1;\n  } else res[0] = -1;\n\n  if (r_0 != N-1) {\n    md_c = min;\n    num = board[r_0+1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0+1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0+1][c_0] = 0;\n      board[r_0][c_0] =num;\n      res[1] = search(board, md_c, limit-1, r_0+1, c_0);\n      if (res[1] == -1) {\n\tboard[r_0+1][c_0] = num;\n\tboard[r_0][c_0] = 0;\n      } else res[1]++;\n    } else res[1] = -1;\n  } else res[1] = -1;\n\n  if (c_0 != 0) {\n    md_c = min;\n    num = board[r_0][c_0-1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0-1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0-1] = 0;\n      board[r_0][c_0] = num;\n      res[2] = search(board, md_c, limit-1, r_0, c_0-1);\n      if (res[2] == -1) {\n\tboard[r_0][c_0-1] = num;\n\tboard[r_0][c_0] = 0;\n      } else res[2]++;\n    } else res[2] = -1;\n  } else res[2] = -1;\n\n  if (c_0 != N-1) {\n    md_c = min;\n    num = board[r_0][c_0+1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0+1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0+1] = 0;\n      board[r_0][c_0] = num;\n      res[3] = search(board, md_c, limit-1, r_0, c_0+1);\n      if (res[3] == -1) {\n        board[r_0][c_0+1] = num;\n        board[r_0][c_0] = 0;\n      } else res[3]++;\n    } else res[3] = -1;\n  } else res[3] = -1;\n\n  if (res[0] == -1 && res[1] == -1 && res[2] == -1 && res[3] == -1) return -1;\n  else if (res[0] != -1) return res[0];\n  else if (res[1] != -1) return res[1];\n  else if (res[2] != -1) return res[2];\n  else return res[3];\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 3\n \nint p[N][N];\nint temp[N][N];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n \nint dfs(int, int, int, int, int);\nint calc();\nvoid swap(int *,int *);\n \nint main()\n{\n  int i, j;\n  int x, y;\n  int n, count = 0;\n\n  for(i = 0; i < N; i++)\n    {\n      for(j = 0; j < N; j++)\n\t{\n\t  scanf(\"%d\",&p[i][j]);\n\t  if(p[i][j] == 0)\n\t    {\n\t      x = j;\n\t      y = i;\n\t    }\n\t}\n    }\n  \n  while(1)\n    {\n      for(i = 0; i < N; i++)\n\t{\n\tfor(j = 0; j < N; j++)\n\t  {\n\t  temp[i][j] = p[i][j];\n\t  }\n\t}\n      \n      n = dfs(x, y, -1, 0, count);\n      \n      if(n != -1)\n\t{\n\t  printf(\"%d\\n\", n);\n\t  break;\n\t}\n      \n      for(i = 0; i < N; i++)\n\t{\n\t  for(j = 0; j < N; j++)\n\t    {\n\t      p[i][j] = temp[i][j];\n\t    }\n\t}\n      \n      n = -1;\n      \n      if(count++ == 99)\n\t{\n\t  printf(\"%d\\n\", n);\n\t  break;\n\t}\n    }\n  \n    return 0;\n}\n\n\nint dfs(int x, int y, int key, int dep, int lim)\n{\n  int i;\n  int nx, ny;\n  int h, ans;\n  \n  h = calc();\n  \n  if(h == 0)return dep;\n  if(dep + h > lim)return -1;\n  \n  for(i = 0; i < 4; i++)\n    {\n      nx = x + dx[i];\n      ny = y + dy[i];\n\n      if(0 > nx || nx >= N || 0 > ny || ny >= N)continue;\n      if(key > 0 && i == (key+2) % 4)continue;\n   \n      swap(&p[y][x], &p[ny][nx]);\n      \n      ans = dfs(nx, ny, i, dep+1, lim);\n      \n      if(ans != 0 && ans != -1)return ans;\n      \n      swap(&p[y][x], &p[ny][nx]);\n    }\n  \n  return -1;\n}\n\nint calc()\n{\n  int i;\n  int n, sum = 0;\n  \n  for(i = 0; i < 9; i++)\n      {\n        n = p[i/N][i%N];\n\t\n        if(n != 0)\n\t  {\n            n--;\n            sum += abs(i/N - n/N) + abs(i%N - n%N);\n\t  }\n    }\n  \n  return sum;\n}\n\nvoid swap(int *a, int *b)\n{\n  int cpy;\n  \n  cpy = *a;\n  *a = *b;\n  *b = cpy;\n\n  return;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 9\n\nint board[N];\nint rows = 3, cols = 3, zeroIndex;\n\n// for previousMove: 0 is down, 1 is up, 2 is left, 3 is right\nint blindSearch(int x, int y, int moves, int previousMove) {\n  int i, foundAnswer;\n\n  // answer is less than manhattan distance, not possible\n  if (moves < (x + y))\n    return 0;\n\n  if (!moves) {\n    for (i = 0; i < N - 1; i++) {\n      if (board[i] != i + 1)\n        return 0;\n    }\n\n    return 1;\n  }\n\n  if (x > 0 && previousMove != 1) {\n    // can expand down\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n\n    foundAnswer = blindSearch(x - 1, y, moves - 1, 0);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n  }\n\n  if (y > 0 && previousMove != 3) {\n    // right\n    board[zeroIndex] = board[zeroIndex + 1];\n    zeroIndex++;\n\n    foundAnswer = blindSearch(x, y - 1, moves - 1, 2);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex - 1];\n    zeroIndex--;\n  }\n\n  if (y < rows - 1 && previousMove != 2) {\n    // left\n    board[zeroIndex] = board[zeroIndex - 1];\n    zeroIndex--;\n\n    foundAnswer = blindSearch(x, y + 1, moves - 1, 3);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex + 1];\n    zeroIndex++;\n  }\n\n  if (x < cols - 1 && previousMove != 0) {\n    // up\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n\n    foundAnswer = blindSearch(x + 1, y, moves - 1, 1);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n  }\n\n  return 0;\n}\n\nint main() {\n  int i, x, y, current;\n\n  for (i = 0; i < N; i++) {\n    scanf(\"%d\", &board[i]);\n    if (!board[i])\n      zeroIndex = i;\n  }\n\n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n\n  for (current = 0; current < 50; current++) {\n    if (blindSearch(x, y, current, -1)) {\n      printf(\"%d\\n\", current);\n      return 0;\n    }\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\nchar *flag;\nint head,rear;\nint *que;\nint factorial[10];\n\nint cal_factorial(int n) {\n  if(n == 0) return 1;\n  return cal_factorial(n-1)*n;\n}\n\nint stotag(char *s) {\n  int tag = 0;\n  int i;\n  for(i = 0; i < 9; i++) {\n    int t,j;\n    t = 0;\n    for(j = 0; j < i; j++) {\n      if(s[j] < s[i]) t++;\n    }\n    tag += factorial[8-i]*(s[i]-'0'-t);\n  }\n  return tag;\n}\n\nchar *tagtos(int tag) {\n  int i;\n  char *s;\n  s = (char*)malloc(sizeof(char)*10);\n  for(i = 0; i < 9; i++) {\n    s[i] = tag%factorial[9-i]/factorial[8-i] + '0';\n  }\n  s[9] = '\\0';\n  for(i = 7; i >= 0; i--) {\n    int j;\n    for(j = 8; j > i; j--) {\n      if(s[i] <= s[j]) s[j]++;\n    }\n  }\n  return s;\n}\n\n\nchar *move_up(char s[], int x) {\n  if(x < 3) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-3];\n  s_new[x-3] = s[x];\n  return s_new;\n}\n\nchar *move_left(char s[], int x) {\n  if(x%3 == 0) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-1];\n  s_new[x-1] = s[x];\n  return s_new;\n}\n\nchar *move_right(char s[], int x) {\n  if(x%3 == 2) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+1];\n  s_new[x+1] = s[x];\n  return s_new;\n}\n\nchar *move_down(char s[], int x) {\n  if(x > 5) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+3];\n  s_new[x+3] = s[x];\n  return s_new;\n}\n\nint create(char s[], int t) {\n  if(strcmp(s,\"123456780\") == 0) return t;\n  int tag = stotag(s);\n  if(flag[tag]) return 0;\n  flag[tag] = t;\n  que[rear] = tag;\n  rear++;\n  return 0;\n}\n\nint check_x(char *s) {\n  int i = 0;\n  while(s[i] != '0') i++;\n  return i;\n}\n\nint cal() {\n  char *s_right,*s_left,*s_up,*s_down;\n  int k,tag;\n\n  tag = que[head];\n  char *s = tagtos(tag);\n  int x = check_x(s);\n  \n  if((s_right = move_right(s, x)) != NULL) {\n    if((k = create(s_right,flag[tag]+1))) return k;\n    free(s_right);\n  }\n  if((s_left = move_left(s, x)) != NULL) {\n     if((k = create(s_left,flag[tag]+1))) return k;\n     free(s_left);\n  }\n  if ((s_up = move_up(s, x)) != NULL) {\n    if((k = create(s_up,flag[tag]+1))) return k;\n    free(s_up);\n  }\n  if((s_down = move_down(s, x)) != NULL) {\n    if((k = create(s_down,flag[tag]+1))) return k;\n    free(s_down);\n  }\n  free(s);\n  head++;\n  return 0;\n}\n  \n\nint solve(char s0[]) {\n  int k;\n  if((k = create(s0,1))) return k;\n  \n  while(!(k = cal())) {\n    if(head == rear) break;\n  }\n  return k;\n}\n\nint main()\n{\n\n  int i,d;\n  char s[10];\n  for(i = 0; i < 10; i++) factorial[i] = cal_factorial(i);\n  flag = (char*)malloc(sizeof(char)*factorial[9]);\n  memset(flag , 0, factorial[9]);\n  que = (int*)malloc(sizeof(int)*factorial[9]);\n  head = 0;\n  rear = 0;\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &d);\n    s[i] = d+'0';\n  }\n  s[9] = '\\0';\n  printf(\"%d\\n\",solve(s)-1);\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 3\n#define MAX 15\ntypedef struct{\n    int A[N][N];\n}Pazzle;\nPazzle P;\nint d_x[4]={0,1,0,-1};\nint d_y[4]={1,0,-1,0};\n\nvoid swap(int *A,int *B){\n int hoge;\n hoge=*A;\n *A=*B;\n *B=hoge;\n\n\n}\n\nint check(Pazzle P){\n    int sum=0,i,j,hy,hx;\n    for(i=0;i<N;i++){\n\n    for(j=0;j<N;j++){\n        if(P.A[i][j]==0)\n        continue;\n        hy=(P.A[i][j]-1)/N-i;\n        hx=(P.A[i][j]-1)%N-j;\n        if(hy<0)\n        sum-=hy;\n        else\n        sum+=hy;\n        if(hx<0)\n        sum-=hx;\n        else\n        sum+=hx;\n\n\n}\n}\n\nreturn sum;\n}\n\nint dfs(int x,int y,int max,int cnt,int m){\n         int i;\n  int heau;\n  int x_0,y_0;\n  int ans=-1;\n  heau=check(P);\n  if(heau==0) return cnt;\n  if(cnt+heau>max) return -1;\n  for(i=0;i<4;i++){\n    x_0=x+d_x[i];\n    y_0=y+d_y[i];\n\n    if((m!=-1&&i==(m+2)%4)||!(0<=x_0 && x_0<N && 0<=y_0 && y_0<N)) continue;\n    swap(&P.A[y][x],&P.A[y_0][x_0]);\n    ans=dfs(x_0,y_0,max,cnt+1,i);\n    if(ans!=-1) return ans;\n     swap(&P.A[y][x],&P.A[y_0][x_0]);\n  }\n  return -1;\n}\n\nint main(void){\n    Pazzle t_P;\n    int  i,j,ans;\n    int x0,y0;\n\n    for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n            scanf(\"%d\",&P.A[i][j]);\n            if(P.A[i][j]==0){\n                x0=j;\n                y0=i;\n\n            }\n\n        }\n    }\n    t_P=P;\n    for(i=1;i<46;i++){\n        P=t_P;\n    ans=dfs(x0,y0,i,0,-1);\n    if(ans!=-1){printf(\"%d\\n\",ans); break;}\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<stdlib.h>\n#define N 3\n#define N2 9\n#define LEN 10000000\n\ntypedef struct Puzzle{\n  int f[N2];\n  int space;\n  int path;\n} Puzzle ;\n\nint V[LEN];\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\n//static const char dir[4]={'u','l','d','r'};\n\nstruct Puzzle Q[LEN];\nint head = 0, tail = 0;\n\nvoid enqueue(Puzzle x){\n   Q[tail]=x;\n   tail=(tail+1)%LEN;\n}\n\nPuzzle dequeue(){\n  Puzzle x=Q[head];\n  head=(head+1)%LEN;\n  return x;\n}\n\nint chim(Puzzle p){\n  int i, j,muri, count,n=0;\n  for(i=0,muri=1;i<N2;muri*=++i){\n    for(j=0,count=0;j<i;j++){\n      if(p.f[j]<p.f[i])count++;\n    }\n    n+=count*muri;\n  }\n  return n;\n}\n\nint isTarget(Puzzle p){\n  for(int i = 0; i < N2; i++){\n  \tif(p.f[i] != (i+1)) return 0;\n  }\n  return 1;\n}\n\nint bfs(Puzzle spc){\n  struct Puzzle u,v;\n  spc.path=0;\n  enqueue(spc);\n  V[chim(spc)]=1;\n  \n  while(head != tail){ \n  int sx,sy,tx,ty,z,r;\n    u=dequeue();\n    if(isTarget(u)){\n        return u.path;\n    }\n     sx=u.space/N;\n     sy=u.space%N;\n    for(r=0;r<4;r++){\n       tx=sx+dx[r];\n       ty=sy+dy[r];\n      if(tx<0 || ty<0 || tx>=N || ty>= N)continue;\n      v=u;\n      z=v.f[u.space];\n      v.f[u.space]=v.f[tx*N+ty];\n      v.f[tx*N+ty]=z;\n      v.space=tx*N+ty;\n      if(V[chim(v)] != 1){\n\tV[chim(v)] = 1;\n\tv.path++;//=dir[r];\n\tenqueue(v);\n      }\n    }\n  }\n\n  return -1;\n}\n\nint main(){\n  Puzzle in;\n  \n  for(int i = 0; i < N2; i++){\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\nint answer;\nanswer = bfs(in);\nprintf(\"%d\\n\",answer );\nreturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#define Size 9\n#define Queue_size 102400\n#define Hash_size 1024\n#define queue_next(i) (((i) + 1) % Queue_size)\nstruct hash_table {\n  long data;\n  struct hash_table *next;\n};\nstruct hash_table *hash[Hash_size];\nint swap_upper(int*, int*);\nint swap_lower(int*, int*);\nint swap_left(int*, int*);\nint swap_right(int*, int*);\nlong board_val(int*);\nvoid val_board(long, int*);\nvoid hash_insert(long);\nint hash_search(long);\nint Bfs(int*, int*);\nint main(void)\n{\n  int i, result, init[Size], goal[Size] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\n  for (i = 0; i < Size; i++) scanf(\"%d\", &init[i]);\n  for (i = 0; i < Hash_size; i++) hash[i] = NULL;\n  printf(\"%d\\n\", Bfs(init, goal));\n}\nint swap_upper(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if (!(pos / e)) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos - e];\n    next[pos - e] = board[pos];\n  }\n  return 1;\n}\nint swap_lower(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if ((pos / e) == e - 1) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos + e];\n    next[pos + e] = board[pos];\n  }\n  return 1;\n}\nint swap_left(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if (!(pos % e)) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos - 1];\n    next[pos - 1] = board[pos];\n  }\n  return 1;\n}\nint swap_right(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if ((pos % e) == e - 1) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos + 1];\n    next[pos + 1] = board[pos];\n  }\n  return 1;\n}\nlong board_val(int *board)\n{\n  int i, digit = 1;\n  long val = 0;\n  for (i = 0; i < Size; i++) {\n    val += board[Size - 1 - i] * digit;\n    digit *= 10;\n  }\n  return val;\n}\nvoid val_board(long val, int *board)\n{\n  int i, digit = 1;\n  for (i = 0; i < Size; i++) {\n    board[Size - 1 - i] = (val / digit) % 10;\n    digit *= 10;\n  }\n}\nvoid hash_insert(long val)\n{\n  struct hash_table *p = (struct hash_table*)malloc(sizeof(struct hash_table));\n  p->data = val;\n  p->next = hash[val % Hash_size];\n  hash[val % Hash_size] = p;\n}\nint hash_search(long val)\n{\n  struct hash_table *n;\n  for (n = hash[val % Hash_size]; n != NULL; n = n->next) {\n      if (val == n->data) return 1;\n  }\n  return 0;\n}\nint Bfs(int *init, int *goal)\n{\n  int depth = 0, ptr_front = 0, ptr_back = 0;\n  long queue[Queue_size][2];\n  queue[ptr_back][0] = board_val(init);\n  queue[ptr_back][1] = depth;\n  ptr_back = queue_next(ptr_back);\n  if (!memcmp(init, goal, sizeof(int) * Size)) return depth;\n  while (ptr_front != ptr_back) {\n    int curr[Size], next[Size];\n    long val;\n    val = queue[ptr_front][0];\n    val_board(val, curr);\n    depth = queue[ptr_front][1];\n    ptr_front = queue_next(ptr_front);\n    depth++;\n    hash_insert(val);\n    if (swap_upper(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n    if (swap_lower(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n    if (swap_left(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n    if (swap_right(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\n/* \n * File:   main.c\n * Author: kundaikwangwari\n *\n * Created on August 1, 2019, 9:38 AM\n */\n\n\n#include <stdio.h>\n#define N 3\n#define MAX 8\n#define NIL -1\n\n\ntypedef struct{\n    int Board[N][N];\n}Data;\n\n\n\nint xdistance[4]={0,1,0,-1};\nint ydistance[4]={1,0,-1,0};\n\nint IsValid(Data Puzzle){\n    \n    int sum=0,ytransitions,xtransitions;\n    for(int i=0;i<N;i++){\n \n    for(int j=0;j<N;j++){\n        if(Puzzle.Board[i][j]==0)continue;\n        ytransitions=(Puzzle.Board[i][j]-1)/N-i;\n        xtransitions=(Puzzle.Board[i][j]-1)%N-j;\n        if(ytransitions<0) sum-=ytransitions;\n        else sum+=ytransitions;\n        if(xtransitions<0) sum-=xtransitions;\n        else sum+=xtransitions;\n}\n}\n \nreturn sum;\n}\n\n\nvoid SwapPositions(int *A,int *B){\n int temp;\n temp=*A;\n *A=*B;\n *B=temp;\n \n \n}\n\n\nint DepthFirstSearch(int x,int y,int max,int count,Data Puzzle){\n    \n  int heuristic = IsValid(Puzzle), xtotal,ytotal, Sol=NIL;   \n  if(heuristic==0) return count;\n  if(count+heuristic>max) return NIL; \n  for(int i=0;i<4;i++){\n    xtotal=x+xdistance[i];\n    ytotal=y+ydistance[i];      \n   \n    if(!(0<=xtotal && xtotal<3 && 0<=ytotal && ytotal<3)) continue;\n    \n    SwapPositions(&Puzzle.Board[y][x],&Puzzle.Board[ytotal][xtotal]);\n    Sol=DepthFirstSearch(xtotal,ytotal,max,count+1,Puzzle);\n    if(Sol!= NIL) return Sol;  \n    \n     SwapPositions(&Puzzle.Board[y][x],&Puzzle.Board[ytotal][xtotal]);\n  }   \n  return NIL;\n}\n\n\n\n\nint main(void){\n    Data Puzzle,tempPuzzle;\n    int xstart,ystart;\n\n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n            scanf(\"%d\",&Puzzle.Board[i][j]);\n            if(Puzzle.Board[i][j]==0){\n                xstart=j;\n                ystart=i;   \n            }\n        }\n    }\n    tempPuzzle=Puzzle;\n    for(int i=1;i<100;i++){\n        Puzzle=tempPuzzle;\n    int Sol=DepthFirstSearch(xstart,ystart,i,0,Puzzle);\n    if(Sol!=NIL){\n        printf(\"%d\\n\",Sol);\n        break;\n    }\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define N 3\n#define D 100\n\nstruct node{\n  int data[N][N];\n  struct node *p;\n};\nstruct xy{\n  int x;\n  int y;\n};\n\nstruct node root;\nint mv[4][2]={0,1,0,-1,-1,0,1,0};\n\nint man(int n,int x,int y){\n  int nx, ny;\n\n  nx=(n-1)%N;\n  ny=(n-1)/N;\n  x=x-nx;\n  if(x<0)\n   x*=-1;\n y=y-ny;\n if(y<0)\n   y*=-1;\n return x+y;\n}\n\nint judge(struct node *n){\n  int i, j=0;\n  if(n==NULL)\n   return -1;\n for(i=0;i<N*N;i++){\n  if(n->data[i%N][i/N]==0)\n   continue;\n if(n->data[i%N][i/N]!=i+1) \n  j+=man(n->data[i%N][i/N],i%N,i/N);\n}\n\nreturn j;\n}\n\nstruct xy blank(struct node *n){\n  struct xy ddd;\n  int i;\n\n  for(i=0;i<N*N;i++)\n    if(n->data[i%N][i/N]==0)\n     break;\n\n   ddd.x=i%N;\n   ddd.y=i/N;\n\n   return ddd;\n }\n\nstruct node *mk(struct node *n,struct xy b, struct xy m){\n  struct node *aaa;\n  int i;\n  \n  aaa=malloc(sizeof(struct node));\n\n  for(i=0;i<N*N;i++) \n    aaa->data[i%N][i/N]=n->data[i%N][i/N];\n  \n  aaa->data[b.x][b.y]=aaa->data[m.x][m.y];\n  aaa->data[m.x][m.y]=0;\n  aaa->p=n;\n  return aaa;\n}\n\nint puzzle(struct node *n,struct node *bp, int g,int d){\n  int h=judge(n), i, j;\n  struct xy bl, m;\n  struct node *mm;\n  \n  if(h==0)\n   return g;\n if(g+h>d) \n  return -1;\nbl=blank(n);\nfor(i=0;i<4;i++){\n  m.x=bl.x+mv[i][0];\n  m.y=bl.y+mv[i][1];\n  if(m.x<0 || m.y<0 || m.x==N || m.y==N ) \n    continue;\n  mm=mk(n,bl,m);\n  if(bp!=NULL){\n    for(j=0;j<N*N;j++)\n      if(mm->data[j%N][j/N]!=bp->data[j%N][j/N])\n       break;\n     if(j==N*N){\n      free(mm);\n      continue;\n    }\n  }  \n  j=puzzle(mm,mm->p,g+1,d);\n  if(j>0) return j;\n}\nreturn -1;\n}\n\nint main(){\n  int i, ans;\n  struct node *n, *m;\n  for(i=0;i<N*N;i++)\n   scanf(\"%d\",&root.data[i%N][i/N]);\n root.p=NULL;\n for(i=judge(&root);i<=D;i++){\n  ans=puzzle(&root,NULL,0,i);\n  if(ans>0) break;\n}\nprintf(\"%d\\n\",ans);\nreturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n  \nint puz[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nvoid empty(int *x,int *y) {\n  int i,j;\n  for(i=0; i<3; i++) {\n    for(j=0; j<3; j++) {\n      if(!puz[i][j]) {\n\t*x = j;\n\t*y = i;\n\treturn;\n      }\n    }\n  }\n}\n   \nvoid swap(int *a,int *b){\n  int tmp;\n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n  \nint cal(){\n  int i,a,sum=0; \n  for(i=0; i<9; i++){\n    a = puz[i/3][i%3];\n    if(a){\n      a--;\n      sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n    }\n  }    \n  return sum;\n}\n  \nint dfs(int x,int y,int p,int dep,const int lim){\n    int i,h,nx,ny,res;   \n    h = cal();\n    if(h==0) return dep;\n    if(dep+h>lim) return -1; \n    for(i=0; i<4; i++){\n        nx = x+dx[i];\n        ny = y+dy[i];      \n        if(~p && i==(p+2)%4) continue;\n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;    \n        swap(&puz[y][x],&puz[ny][nx]);\n        res = dfs(nx,ny,i,dep+1,lim);\n        if(~res) return res;       \n        swap(&puz[y][x],&puz[ny][nx]);\n    }   \n    return -1;\n}  \n  \nint main() {\n    int i,j,ans,x,y,l;\n      \n    for(i=0; i<3; i++){\n        for(j=0; j<3; j++) scanf(\"%d\",&puz[i][j]);\n    }\n       \n    empty(&x,&y);\n    for(l=0; l<100; l++){\n        for(i=0; i<3; i++){\n            for(j=0; j<3; j++) tmp[i][j] = puz[i][j];\n        }\n          \n        ans = dfs(x,y,-1,0,l);\n        if(ans!=-1){\n            printf(\"%d\\n\",ans);\n            break;\n        }\n          \n        for(i=0; i<3; i++){\n            for(j=0; j<3; j++) puz[i][j] = tmp[i][j];\n        }\n          \n        ans = -1;\n        if(l==99) printf(\"%d\\n\",ans);\n    }\n      \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nint puz[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\nvoid empty(int *x,int *y) {\n  int i,j;\n  for(i=0; i<3; i++) {\n    for(j=0; j<3; j++) {\n      if(!puz[i][j]) {\n\t*x = j;\n\t*y = i;\n\treturn;\n      }\n    }\n  }\n}\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}   \nint cal(){\n  int i,a,sum=0; \n  for(i=0; i<9; i++){\n    a = puz[i/3][i%3];\n    if(a){\n      a--;\n      sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n    }\n  }    \n  return sum;\n}\nint dfs(int x,int y,int p,int dep,const int lim){\n  int i,h,nx,ny,res;   \n  h = cal();\n  if(h==0) return dep;\n  if(dep+h>lim) return -1; \n  for(i=0; i<4; i++){\n    nx = x+dx[i];\n    ny = y+dy[i];      \n    if(~p && i==(p+2)%4) continue;\n    if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;    \n    swap(&puz[y][x],&puz[ny][nx]);\n    res = dfs(nx,ny,i,dep+1,lim);\n    if(~res) return res;       \n    swap(&puz[y][x],&puz[ny][nx]);\n  }   \n  return -1;\n}    \nint main() {\n  int i,j,ans,x,y,l;\n       \n  for(i=0; i<3; i++){\n    for(j=0; j<3; j++) scanf(\"%d\",&puz[i][j]);\n  }\n        \n  empty(&x,&y);\n  for(l=0; l<100; l++){\n    for(i=0; i<3; i++){\n      for(j=0; j<3; j++) tmp[i][j] = puz[i][j];\n    }\n           \n    ans = dfs(x,y,-1,0,l);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n           \n    for(i=0; i<3; i++){\n      for(j=0; j<3; j++) puz[i][j] = tmp[i][j];\n    }\n           \n    ans = -1;\n    if(l==99) printf(\"%d\\n\",ans);\n  }\n       \n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nint puz[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\nvoid empty(int *x,int *y) {\n  int i,j;\n  for(i=0; i<3; i++) {\n    for(j=0; j<3; j++) {\n      if(!puz[i][j]) {\n        *x = j;\n        *y = i;\n        return;\n      }\n    }\n  }\n}\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\nint cal(){\n  int i,a,sum=0;\n  for(i=0; i<9; i++){\n    a = puz[i/3][i%3];\n    if(a){\n      a--;\n      sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n    }\n  }\n  return sum;\n}\nint dfs(int x,int y,int p,int dep,const int lim){\n  int i,h,nx,ny,res;\n  h = cal();\n  if(h==0) return dep;\n  if(dep+h>lim) return -1;\n  for(i=0; i<4; i++){\n    nx = x+dx[i];\n    ny = y+dy[i];\n    if(~p && i==(p+2)%4) continue;\n    if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n    swap(&puz[y][x],&puz[ny][nx]);\n    res = dfs(nx,ny,i,dep+1,lim);\n    if(~res) return res;\n    swap(&puz[y][x],&puz[ny][nx]);\n  }\n  return -1;\n}\nint main() {\n  int i,j,ans,x,y,l;\n  \n  for(i=0; i<3; i++){\n    for(j=0; j<3; j++) scanf(\"%d\",&puz[i][j]);\n  }\n  \n  empty(&x,&y);\n  for(l=0; l<100; l++){\n    for(i=0; i<3; i++){\n      for(j=0; j<3; j++) tmp[i][j] = puz[i][j];\n    }\n    \n    ans = dfs(x,y,-1,0,l);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n    \n    for(i=0; i<3; i++){\n      for(j=0; j<3; j++) puz[i][j] = tmp[i][j];\n    }\n    \n    ans = -1;\n    if(l==99) printf(\"%d\\n\",ans);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \nint puz[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n \nvoid empty(int *x,int *y)\n{\n  int i,j;\n  for(i=0; i<3; i++)\n    {\n      for(j=0; j<3; j++)\n\t{\n\t  if(!puz[i][j])\n\t    {\n\t      *x = j;\n\t      *y = i;\n\t      return;\n            }\n        }\n    }\n}\n \n \nvoid swap(int *a,int *b)\n{\n  int tmp;\n     \n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n \n \nint cal()\n{\n  int i,a,sum=0;\n     \n  for(i=0; i<9; i++)\n    {\n      a = puz[i/3][i%3];\n      if(a)\n\t{\n\t  a--;\n\t  sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n        }\n    }\n     \n  return sum;\n}\n \n \nint dfs(int x,int y,int p,int dep,const int lim)\n{\n  int i,h,nx,ny,res;\n     \n  h = cal();\n  if(h==0) return dep;\n  if(dep+h>lim) return -1;\n     \n  for(i=0; i<4; i++)\n    {\n      nx = x+dx[i];\n      ny = y+dy[i];\n         \n      if(~p && i==(p+2)%4) continue;\n      if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n         \n      swap(&puz[y][x],&puz[ny][nx]);\n      res = dfs(nx,ny,i,dep+1,lim);\n      if(~res) return res;\n         \n      swap(&puz[y][x],&puz[ny][nx]);\n    }\n    \n  return -1;\n}\n\n\n \nint main() {\n  int i,j; // roop\n  int ans,x,y,l;\n     \n  for(i=0; i<3; i++)\n    {\n      for(j=0; j<3; j++) scanf(\"%d\",&puz[i][j]);\n    }\n     \n     \n    empty(&x,&y);\n    for(l=0; l<100; l++)\n      {\n        for(i=0; i<3; i++)\n\t  {\n            for(j=0; j<3; j++) tmp[i][j] = puz[i][j];\n\t  }\n        \n        ans = dfs(x,y,-1,0,l);\n        if(ans!=-1)\n\t  {\n            printf(\"%d\\n\",ans);\n            break;\n\t  }\n        \n        for(i=0; i<3; i++)\n\t  {\n            for(j=0; j<3; j++) puz[i][j] = tmp[i][j];\n\t  }\n         \n        ans = -1;\n        if(l==99) printf(\"%d\\n\",ans);\n      }\n     \n    return 0;\n}\n \n \n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n \nint m[3][3];\nint cpy[3][3];\n \nvoid input(void){\n  int i,j;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&m[i][j]);\n    }\n  }\n}\nvoid output(void){\n  int i,j;\n for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      printf(\"%3d\",m[i][j]);\n      puts(\"\");\n    }\n }\n}\nvoid copy(int a[3][3],int b[3][3]){\n  int i,j;\n for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      a[i][j] = b[i][j];\n    }\n }\n}\nint calc(void){\n  int i,sum = 0;\n  for(i=0;i<9;i++){\n    int a = m[i/3][i%3];\n    if(a){\n      a--;\n      sum += abs(i/3 - a/3)+abs(i%3 - a%3);\n    }\n  }\n  return sum;\n}\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n \nvoid swap(int *a, int *b){\n  int tmp;\n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\nint in(int a,int b){\n  return 0<=a&&a<3&&0<=b&&b<3;\n}\nint df(int a,int b,int p,int d,const int lim){\n  int i , h=calc();\n  if(h == 0)return d;\n  if(d+h > lim)return -1;\n \n  for(i=0;i<4;i++){\n    int x= a+dx[i],y=b+dy[i];\n    int res;\n    if(~p && i == (p+2)%4)continue;\n    if(!in(x,y))continue;\n    swap(&m[b][a],&m[y][x]);\n    res = df(x,y,i,d+1,lim);\n    if(~res)return res;\n    swap(&m[b][a],&m[y][x]);\n  }\n  return -1;\n}\n \nvoid empty(int *a, int *b){\n  int i,j;\n   for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(!m[i][j]){\n    *a = j;\n    *b = i;\n    return;\n      }\n    }\n   }\n}\nint s(void){\n  int a,b,lim,x;\n  empty(&a,&b);\n  for(lim = 0;lim < 50;lim++){\n    copy(cpy,m);\n    if((x = df(a,b,-1,0,lim)) != -1)return x;\n    copy(m,cpy);\n  }\n  return -1;\n}\nint main(){\n  input();\n  printf(\"%d\\n\",s());\n \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n// I/O\nint get_uint() {\n    int n = 0;\n    int c = getchar_unlocked();\n    if(c < 48 || 57 < c) return c;\n    while(47 < c && c < 58) n = 10 * n + (c & 0xf), c = getchar_unlocked();\n    return n;\n}\nvoid put_uint(int n) {\n    if(!n) {\n        putchar_unlocked('0');\n        return;\n    }\n    char buf[11];\n    int i = 0;\n    while(n) buf[i++] = (char)(n % 10 + '0'), n /= 10;\n    while(i--)putchar_unlocked(buf[i]);\n}\n\n\n#define likely(x)   __builtin_expect(!!(x), 1)\n#define unlikely(x) __builtin_expect(!!(x), 0)\n#define container_of(ptr, type, member) ({  \\\n    void *__mptr = (void *)(ptr);           \\\n    ((type *)(__mptr - offsetof(type, member))); })\n\n\nstruct rb_node {\n    unsigned long __rb_parent_color;\n    struct rb_node *rb_right;\n    struct rb_node *rb_left;\n} __attribute__((aligned(sizeof(long))));\n\nstruct rb_root {\n    struct rb_node *rb_node;\n};\n\n#define rb_parent(r) ((struct rb_node *)((r)->__rb_parent_color & ~3))\n#define RB_ROOT (struct rb_root) { NULL, }\n#define RB_EMPTY_NODE(node)  \\\n   ((node)->__rb_parent_color == (unsigned long)(node))\n\nstatic inline void rb_link_node(struct rb_node *node, struct rb_node *parent, struct rb_node **rb_link) {\n    node->__rb_parent_color = (unsigned long)parent;\n    node->rb_left = node->rb_right = NULL;\n    *rb_link = node;\n}\n\n#define RB_RED      0\n#define RB_BLACK    1\n\n#define __rb_color(pc)      ((pc) & 1)\n#define __rb_is_red(pc)     (!__rb_color(pc))\n#define __rb_is_black(pc)   __rb_color(pc)\n#define rb_color(rb)        __rb_color((rb)->__rb_parent_color)\n#define rb_is_red(rb)       __rb_is_red((rb)->__rb_parent_color)\n#define rb_is_black(rb)     __rb_is_black((rb)->__rb_parent_color)\n\nstatic inline void rb_set_parent(struct rb_node *rb, struct rb_node *p) {\n    rb->__rb_parent_color = rb_color(rb) | (unsigned long)p;\n}\n\nstatic inline void rb_set_parent_color(struct rb_node *rb, struct rb_node *p, int color) {\n    rb->__rb_parent_color = (unsigned long)p | color;\n}\n\nstatic inline void __rb_change_child(struct rb_node *old, struct rb_node *new, struct rb_node *parent, struct rb_root *root) {\n    if(parent) {\n        if(parent->rb_left == old) parent->rb_left = new;\n        else parent->rb_right = new;\n    } else root->rb_node = new;\n}\n\nstatic inline void rb_set_black(struct rb_node *rb) {\n    rb->__rb_parent_color |= RB_BLACK;\n}\n\nstatic inline struct rb_node *rb_red_parent(struct rb_node *red) {\n    return (struct rb_node *)red->__rb_parent_color;\n}\n\nstatic inline void __rb_rotate_set_parents(struct rb_node *old, struct rb_node *new, struct rb_root *root, int color) {\n    struct rb_node *parent = rb_parent(old);\n    new->__rb_parent_color = old->__rb_parent_color;\n    rb_set_parent_color(old, new, color);\n    __rb_change_child(old, new, parent, root);\n}\n\nstatic inline void rb_insert(struct rb_node *node, struct rb_root *root) {\n    struct rb_node *parent = rb_red_parent(node), *gparent, *tmp;\n\n    while(1) {\n        // Loop invariant: node is red.\n        if(unlikely(!parent)) {\n            rb_set_parent_color(node, NULL, RB_BLACK);\n            break;\n        }\n        if(rb_is_black(parent)) break;\n\n        gparent = rb_red_parent(parent);\n\n        tmp = gparent->rb_right;\n        if(parent != tmp) {\n            if(tmp && rb_is_red(tmp)) {\n                rb_set_parent_color(tmp, gparent, RB_BLACK);\n                rb_set_parent_color(parent, gparent, RB_BLACK);\n                node = gparent;\n                parent = rb_parent(node);\n                rb_set_parent_color(node, parent, RB_RED);\n                continue;\n            }\n\n            tmp = parent->rb_right;\n            if(node == tmp) {\n                tmp = node->rb_left;\n                parent->rb_right = tmp;\n                node->rb_left = parent;\n                if(tmp) rb_set_parent_color(tmp, parent, RB_BLACK);\n                rb_set_parent_color(parent, node, RB_RED);\n                parent = node;\n                tmp = node->rb_right;\n            }\n\n            gparent->rb_left = tmp;\n            parent->rb_right = gparent;\n            if(tmp) rb_set_parent_color(tmp, gparent, RB_BLACK);\n            __rb_rotate_set_parents(gparent, parent, root, RB_RED);\n            break;\n        } else {\n            tmp = gparent->rb_left;\n            if(tmp && rb_is_red(tmp)) {\n                rb_set_parent_color(tmp, gparent, RB_BLACK);\n                rb_set_parent_color(parent, gparent, RB_BLACK);\n                node = gparent;\n                parent = rb_parent(node);\n                rb_set_parent_color(node, parent, RB_RED);\n                continue;\n            }\n\n            tmp = parent->rb_left;\n            if(node == tmp) {\n                tmp = node->rb_right;\n                parent->rb_left = tmp;\n                node->rb_right = parent;\n                if(tmp) rb_set_parent_color(tmp, parent, RB_BLACK);\n                rb_set_parent_color(parent, node, RB_RED);\n                parent = node;\n                tmp = node->rb_left;\n            }\n            gparent->rb_right = tmp;\n            parent->rb_left = gparent;\n            if(tmp) rb_set_parent_color(tmp, gparent, RB_BLACK);\n            __rb_rotate_set_parents(gparent, parent, root, RB_RED);\n            break;\n        }\n    }\n}\n\nstruct rb_node *rb_first(const struct rb_root *root) {\n    struct rb_node *n;\n    n = root->rb_node;\n    if(!n) return NULL;\n    while(n->rb_left) n = n->rb_left;\n    return n;\n}\n\nstruct rb_node *rb_next(const struct rb_node *node) {\n    struct rb_node *parent;\n    if(RB_EMPTY_NODE(node)) return NULL;\n\n    if(node->rb_right) {\n        node = node->rb_right;\n        while(node->rb_left) node = node->rb_left;\n        return (struct rb_node *)node;\n    }\n\n    while((parent = rb_parent(node)) && node == parent->rb_right) node = parent;\n\n    return parent;\n}\n\nstruct mykey {\n    int board[9];\n    int space;\n    int cnt;\n};\n\nint cmp_mykey(const struct mykey *l, const struct mykey *r) {\n    for(int i = 0; i < 9; ++i) {\n        if(l->board[i] == r->board[i]) continue;\n        if(l->board[i] < r->board[i]) return -1;\n        else return 1;\n    }\n    return 0;\n}\n\nstruct mynode {\n    struct rb_node node;\n    struct mykey key;\n};\n\nstruct mynode *my_search(struct rb_root *root, struct mykey key) {\n    struct rb_node *node = root->rb_node;\n\n    while(node) {\n        struct mynode *data = container_of(node, struct mynode, node);\n        int result = cmp_mykey(&key, &data->key);\n\n        if(result < 0) node = node->rb_left;\n        else if(result > 0) node = node->rb_right;\n        else return data;\n    }\n    return NULL;\n}\n\nint my_insert(struct rb_root *root, struct mykey *key) {\n    struct rb_node **new = &(root->rb_node), *parent = NULL;\n\n    while(*new) {\n        struct mynode *this = container_of(*new, struct mynode, node);\n        int result = cmp_mykey(key, &this->key);\n\n        parent = *new;\n        if(result < 0) new = &((*new)->rb_left);\n        else if(result > 0) new = &((*new)->rb_right);\n        else return -1;\n    }\n    struct mynode *new_data = malloc(sizeof(struct mynode));\n    new_data->key = *key;\n\n    rb_link_node(&new_data->node, parent, new);\n    rb_insert(&new_data->node, root);\n    return 0;\n}\n\n/*\nvoid my_print_inorder(struct rb_root *root) {\n    struct rb_node *node;\n    for(node = rb_first(root); node; node = rb_next(node)) {\n        putchar_unlocked(' ');\n        put_int(container_of(node, struct mynode, node)->key);\n    }\n}\n*/\n\n// Queue\n#define QueueKey struct mykey\ntypedef struct QueueDat {\n    QueueKey key;\n    struct QueueDat *next;\n} QueueDat;\ntypedef struct Queue {\n    size_t len;\n    QueueDat *head;\n    QueueDat *tail;\n} Queue;\n#define queue_init(q) ((q) ? ((q)->len = 0, (q)->head = (q)->tail = NULL) : 0)\n#define queue_len(q) ((q) ? (q)->len : 0)\nvoid queue_push(Queue *q, QueueKey x) {\n    QueueDat *new_dat = malloc(sizeof(QueueDat));\n    *new_dat = (QueueDat){x, NULL};\n    if(q->len) {\n        q->tail->next = new_dat;\n        q->tail = new_dat;\n    } else {\n        q->head = q->tail = new_dat;\n    }\n    q->len++;\n}\nQueueKey queue_pop(Queue *q) {\n    QueueDat *old_head = q->head;\n    q->head = old_head->next;\n    QueueKey key = old_head->key;\n    free(old_head);\n    q->len--;\n    return key;\n}\n\n// end condition\nint is_solved(const int board[9]) {\n    for(int i = 0; i < 8; ++i)\n        if(board[i] != i + 1) return 0;\n    return 1;\n}\n\n\n// solve\nint bfs(struct mykey s) {\n    const int N = 3;\n    const int dx[4] = {-1, 0, 1, 0};\n    const int dy[4] = {0, -1, 0, 1};\n    struct rb_root mytree = RB_ROOT;\n\n    my_insert(&mytree, &s);\n    Queue Q;\n    queue_init(&Q);\n    queue_push(&Q, s);\n    while(queue_len(&Q)) {\n        struct mykey key = queue_pop(&Q);\n        if(is_solved(key.board)) return key.cnt;\n        int x = key.space % N;\n        int y = key.space / N;\n        for(int i = 0; i < 4; ++i) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(nx < 0 || N <= nx || ny < 0 || N <= ny) continue;\n\n            int next_space = nx + ny * N;\n            struct mykey next_key = key;\n            next_key.board[key.space] = next_key.board[next_space];\n            next_key.board[next_space] = 0;\n            next_key.space = next_space;\n            if(my_search(&mytree, next_key)) continue;\n\n            next_key.cnt++;\n            my_insert(&mytree, &next_key);\n            queue_push(&Q, next_key);\n        }\n    }\n}\n\n\nint main(int argc, char **argv) {\n    struct mykey initial = {.cnt = 0};\n    for(int i = 0; i < 9; ++i) {\n        int x = get_uint();\n        initial.board[i] = x;\n        if(x == 0) initial.space = i;\n    }\n    //clock_t start, end;\n    //start = clock();\n\n    put_uint(bfs(initial));\n    putchar_unlocked('\\n');\n\n    //end = clock();\n    //printf(\"%lf\\n\", (double)(end-start)/CLOCKS_PER_SEC);\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#define Size 9\n#define Queue_size 1024\n#define Hash_size 1024\n#define queue_next(i) (((i) + 1) % Queue_size)\nstruct hash_table {\n  long data;\n  struct hash_table *next;\n};\nstruct hash_table *hash[Hash_size];\nint swap_upper(int*, int*);\nint swap_lower(int*, int*);\nint swap_left(int*, int*);\nint swap_right(int*, int*);\nlong board_val(int*);\nvoid val_board(long, int*);\nvoid hash_insert(long);\nint hash_search(long);\nint Bfs(int*, int*);\nint main(void)\n{\n  int i, result, init[Size], goal[Size] = {1, 2, 3, 4, 5, 6, 7, 8, 0};\n  for (i = 0; i < Size; i++) scanf(\"%d\", &init[i]);\n  for (i = 0; i < Hash_size; i++) hash[i] = NULL;\n  printf(\"%d\\n\", Bfs(init, goal));\n}\nint swap_upper(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if (!(pos / e)) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos - e];\n    next[pos - e] = board[pos];\n  }\n  return 1;\n}\nint swap_lower(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if ((pos / e) == e - 1) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos + e];\n    next[pos + e] = board[pos];\n  }\n  return 1;\n}\nint swap_left(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if (!(pos % e)) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos - 1];\n    next[pos - 1] = board[pos];\n  }\n  return 1;\n}\nint swap_right(int *board, int *next)\n{\n  int i, pos, e = sqrt(Size);\n  for (i = 0; i < Size; i++) {\n    if (!board[i]) pos = i;\n  }\n  if ((pos % e) == e - 1) return 0;\n  else {\n    memcpy(next, board, sizeof(int) * Size);\n    next[pos] = board[pos + 1];\n    next[pos + 1] = board[pos];\n  }\n  return 1;\n}\nlong board_val(int *board)\n{\n  int i, digit = 1;\n  long val = 0;\n  for (i = 0; i < Size; i++) {\n    val += board[Size - 1 - i] * digit;\n    digit *= 10;\n  }\n  return val;\n}\nvoid val_board(long val, int *board)\n{\n  int i, digit = 1;\n  for (i = 0; i < Size; i++) {\n    board[Size - 1 - i] = (val / digit) % 10;\n    digit *= 10;\n  }\n}\nvoid hash_insert(long val)\n{\n  struct hash_table *p = (struct hash_table*)malloc(sizeof(struct hash_table));\n  p->data = val;\n  p->next = hash[val % Hash_size];\n  hash[val % Hash_size] = p;\n}\nint hash_search(long val)\n{\n  struct hash_table *n;\n  for (n = hash[val % Hash_size]; n != NULL; n = n->next) {\n      if (val == n->data) return 1;\n  }\n  return 0;\n}\nint Bfs(int *init, int *goal)\n{\n  int depth = 0, ptr_front = 0, ptr_back = 0;\n  long queue[Queue_size][2];\n  queue[ptr_back][0] = board_val(init);\n  queue[ptr_back][1] = depth;\n  ptr_back = queue_next(ptr_back);\n  if (!memcmp(init, goal, sizeof(int) * Size)) return depth;\n  while (ptr_front != ptr_back) {\n    int curr[Size], next[Size];\n    long val;\n    val = queue[ptr_front][0];\n    val_board(val, curr);\n    depth = queue[ptr_front][1];\n    ptr_front = queue_next(ptr_front);\n    depth++;\n    hash_insert(val);\n    if (swap_upper(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n    if (swap_lower(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n    if (swap_left(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n    if (swap_right(curr, next)) {\n      if (!hash_search(board_val(next))) {\n        if (!memcmp(next, goal, sizeof(int) * Size)) return depth;\n        queue[ptr_back][0] = board_val(next);\n        queue[ptr_back][1] = depth;\n        ptr_back = queue_next(ptr_back);\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint puz[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nvoid empty(int *,int *);\nvoid swap(int *,int *);\nint cal();\nint dfs(int ,int ,int ,int ,const int );\n\n \nint main() {\n  int i,j,ans,x,y,l;\n       \n  for(i=0; i<3; i++) for(j=0; j<3; j++) scanf(\"%d\",&puz[i][j]);\n\n        \n  empty(&x,&y);\n  for(l=0; l<100; l++){\n    for(i=0; i<3; i++){\n      for(j=0; j<3; j++) tmp[i][j] = puz[i][j];\n    }\n           \n    ans = dfs(x,y,-1,0,l);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n           \n    for(i=0; i<3; i++){\n      for(j=0; j<3; j++) puz[i][j] = tmp[i][j];\n    }\n           \n    ans = -1;\n    if(l==99) printf(\"%d\\n\",ans);\n  }\n       \n  return 0;\n}\n\nvoid empty(int *x,int *y) {\n  int i,j;\n  for(i=0; i<3; i++) {\n    for(j=0; j<3; j++) {\n      if(!puz[i][j]) {\n\t*x = j;\n\t*y = i;\n\treturn;\n      }\n    }\n  }\n}\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}   \n\nint cal(){\n  int i,a,sum=0; \n  for(i=0; i<9; i++){\n    a = puz[i/3][i%3];\n    if(a){\n      a--;\n      sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n    }\n  }    \n  return sum;\n}\nint dfs(int x,int y,int p,int dep,const int lim){\n  int i,h,nx,ny,res;   \n  h = cal();\n  if(h==0) return dep;\n  if(dep+h>lim) return -1; \n  for(i=0; i<4; i++){\n    nx = x+dx[i];\n    ny = y+dy[i];      \n    if(~p && i==(p+2)%4) continue;\n    if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;    \n    swap(&puz[y][x],&puz[ny][nx]);\n    res = dfs(nx,ny,i,dep+1,lim);\n    if(~res) return res;       \n    swap(&puz[y][x],&puz[ny][nx]);\n  }   \n  return -1;\n}   \n  \n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint mas[3][3];\nint cpy[3][3];\n\nvoid input() {\n  int i, j;\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++)\n      scanf(\"%d\", &mas[i][j]);\n}\n\nvoid output() {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n    puts(\"\");\n  }\n}\n\nvoid copy(int m[3][3], int t[3][3]) {\n  int i, j;\n\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n\nint calc() {\n  int i, sum = 0;\n  for(i = 0; i < 9; i++) {\n    int v = mas[i/3][i%3];\n    if(v) {\n      v--;\n      sum += abs(i/3-v/3)+abs(i%3-v%3);\n    }\n  }\n  return sum;\n}\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nvoid swap(int *a, int *b) {\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nint is_in(int x, int y) {\n  return 0<=x&&x<3&&0<=y&&y<3;\n}\n\nint dfs(int x, int y, int p, int dep, const int lim) {\n  int i, h = calc();\n  //output();\n  if(h == 0) return dep;\n  //printf(\"%d %d %d\\n\", h, lim, p);\n  if(dep+h > lim) return -1;\n\n  for(i = 0; i < 4; i++) {\n    int nx = x+dx[i], ny = y+dy[i], res;\n    if(~p && i == (p+2)%4) continue;\n    if(!is_in(nx, ny)) continue;\n    swap(&mas[y][x], &mas[ny][nx]);\n    res = dfs(nx, ny, i, dep+1, lim);\n    if(~res) return res;\n    swap(&mas[y][x], &mas[ny][nx]);\n  }\n\n  return -1;\n}\n\nvoid get_empty(int *x, int *y) {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) {\n      if(!mas[i][j]) {\n\t*x = j;\n\t*y = i;\n\treturn;\n      }\n    }\n  }\n}\n\nint solve() {\n  int x, y, lim, ans;\n  get_empty(&x, &y);\n  for(lim = 0; lim < 50; lim++) {\n    copy(cpy, mas);\n    if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n    copy(mas, cpy);\n  }\n  return -1;\n}\n\nint main() {\n  input();\n  printf(\"%d\\n\", solve());\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdlib.h>\n#include <string.h>\n\ntypedef char Board[10];\nBoard ini_board, board, *history;\nconst Board target = \"123456780\";\nint nhistories=0;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  char pos;\n  char dir;\n} Motion;\n\nint minstep;\n\nconst Motion motion[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nint search_path(int step, char space)\n{\n  int i, j;\n  if (strcmp(board, \"123456780\")==0) {\n    //    printf(\"STEP=%d\\n\", step);                                                 \n    //printf(\"%d\\n\", step);                                                          \n    if (step<minstep) minstep=step;\n    printf(\"%d\\n\", step);\n    exit(0);\n  } else {\n    if (step>=minstep) return 1;\n    if (step>0 && strcmp(board, ini_board)==0) return 1;\n\n    Board board_bak;\n    strcpy(board_bak, board);\n    int nhistories_bak=nhistories;\n\n   for (i=0; motion[space][i].pos>=0; i++) {\n      Motion m = motion[space][i];\n\n      if (m.pos==0 && board[0]=='1') continue;\n      if ((m.pos==1||m.pos==2) && board[0]=='1'&&board[1]=='2'&&board[2]=='3') conti\\\nnue;\n      if ((m.pos==3||m.pos==6) && board[0]=='1'&&board[3]=='4'&&board[6]=='7')contin\\\nue;\n      switch (m.dir) {\n      case U:\n        if (m.pos<3) continue;\n        board[m.pos-3] = board[m.pos];\n        break;\n      case D:\n        if (m.pos>5) continue;\n        board[m.pos+3] = board[m.pos];\n        break;\n      case L:\n        if (m.pos%3==0) continue;\n        board[m.pos-1] = board[m.pos];\n        break;\n      case R:\n        if (m.pos%3==2) continue;\n        board[m.pos+1] = board[m.pos];\n        break;\n      }\n      board[m.pos] = '0';\n\n      for (j=0; j<nhistories; j++) {\n        if (strcmp(board, history[j])==0)     break;\n      }\n      if (j==nhistories) {\n        strcpy(history[nhistories++], board);\n        search_path(step+1, m.pos);\n      }\n      nhistories = nhistories_bak;\n      strcpy(board, board_bak);\n    }\n  }\n  return 1;\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board[0],&board[1],&board[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[3],&board[4],&board[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[6],&board[7],&board[8]);\n  strcpy(ini_board, board);\n  for (minstep=1; minstep<32; minstep++) {\n    strcpy(board, ini_board);\n    history = (Board*)malloc(sizeof(Board)*100000);\n    search_path(0, strchr(board, '0')-board);\n    free(history);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n  #include <stdlib.h>\n  int puzle[3][3];\n  int tmp[3][3];\n  int d1[4]={0,1,0,-1};\n  int d2[4]={1,0,-1,0};\n\n  void empty(int *x,int *y){\n    int i,j;\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n        if(!puzle[i][j]){\n  \t*x=j;\n  \t*y=i;\n  \treturn;\n        }\n      }\n    }\n  }\n\n  void swap(int *a,int *b){\n    int tmp=*a;\n    *a=*b;\n    *b=tmp;\n  }\n\n  int cal(){\n    int a,i,sum=0;\n    for(i=0;i<9;i++){\n      a=puzle[i/3][i%3];\n      if(a){\n        a--;\n        sum += abs(i/3-a/3) + abs(i%3-a%3);\n      }\n    }\n    return sum;\n  }\n\n  int dfs(int x,int y,int p,int dep,const int lim){\n    int i,h,n1,n2,res;\n    h=cal();\n    if(h==0){\n      return dep;\n    }\n    if(dep+h > lim){\n      return -1;\n    }\n    for(i=0;i<4;++i){\n      n1=x+d1[i];\n      n2=y+d2[i];\n\n      if(~p && i==(p+2)%4)\n        continue;\n      if(!(0 <= n1 && n1 < 3 && 0 <= n2 && n2 < 3))\n        continue;\n      swap(&puzle[y][x],&puzle[n2][n1]);\n      res=dfs(n1,n2,i,dep+1,lim);\n\n      if(~res){\n        return res;\n      }\n      swap(&puzle[y][x],&puzle[n2][n1]);\n    }\n    return -1;\n  }\n\n  int main(){\n    int ans,x,y,l,i,j;\n\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n        scanf(\"%d\",&puzle[i][j]);\n      }\n    }\n    empty(&x,&y);\n    for(l=0;l<100;l++){\n      for(i=0;i<3;i++){\n        for(j=0;j<3;j++){\n  \ttmp[i][j]=puzle[i][j];\n      }\n    }\n      ans=dfs(x,y,-1,0,l);\n      if(ans!=-1){\n        printf(\"%d\\n\",ans);\n        break;\n      }\n      for(i=0;i<3;i++){\n        for(j=0;j<3;j++){\n  \tpuzle[i][j]=tmp[i][j];\n      }\n      }\n      ans=-1;\n      if(l==99){\n        printf(\"%d\\n\",ans);\n    }\n    }\n    return 0;\n  }\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 3\n#define MAX 182000\n#define MEMO_MAX 380000000\n#define MIN 54481005 //パズルを9進数に置換した時の最小\n#define TRUE 1\n#define FALSE -1\n\ntypedef struct{\n  int p[N][N]; //パズルの状態を保存\n  int dis; //手数\n  int u, d, l, r; //すでに遷移した方向を表すフラグ\n}puzzle;\n\nint BFS(void);\nvoid copy(int a[N][N], int b[N][N]);\nvoid swap(int *, int *);\nint judge(int a[N][N]);\nvoid enqueue(puzzle);\npuzzle dequeue(void);\nvoid print(puzzle);\n\nint head = 0;\nint tail = 0;\nint ans[N][N] = {{1, 2, 3},\n\t\t {4, 5, 6},\n\t\t {7, 8, 0}}; //完成形 \npuzzle q[MAX]; //キュー\npuzzle s; //u, d, l, r, disはこの時点で初期化されてる\nchar memo[MEMO_MAX] = {}; //生成した盤面を保存しておく\n\nint main(){\n  int i, j;\n  \n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\", &s.p[i][j]);\n    }\n  }\n\n  BFS();\n  \n  return 0;\n}\n\nint BFS(){\n  puzzle v;\n  int cnt; //完成形と一致している数字の数\n  int i0, j0; //空白の位置\n  int i, j;\n\n  enqueue(s);\n\n  while(1){\n    \n    v = dequeue();\n    //sの初期化\n    s.u = s.d = s.l = s.r = 0;\n    s.dis = 0;\n\n    //パズルが完成したら終了\n    cnt = 0;\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++){\n\tif(v.p[i][j] == ans[i][j]) cnt++;\n      }\n    }\n    if(cnt == N * N){\n      printf(\"%d\\n\", v.dis);\n      return 0;\n    }\n\n    //空白の位置を特定\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++){\n\tif(v.p[i][j] == 0){\n\t  i0 = i;\n\t  j0 = j;\n\t}\n      }\n    }\n\n    //上\n      if(i0 != 0 && v.u == 0){\n\tcopy(s.p, v.p); //vのパズルの状態をコピーする\n\tswap(&(s.p[i0][j0]), &(s.p[i0-1][j0]));\n\tif(judge(s.p) == TRUE){\n\t  s.d = 1; //下に行かないようにする(無駄に往復しないように)\n\t  s.dis = v.dis + 1;\n\t  enqueue(s);\n\t  s.u = s.d = s.l = s.r = 0;\n\t  s.dis = 0;\n\t  //print(s);\n\t}\n      }\n      //下\n      if(i0 != N-1 && v.d == 0){\n\tcopy(s.p, v.p); //vのパズルの状態をコピーする\n\tswap(&(s.p[i0][j0]), &(s.p[i0+1][j0]));\n\tif(judge(s.p) == TRUE){\n\t  s.u = 1; //上に行かないようにする(無駄に往復しないように)\n\t  s.dis = v.dis + 1;\n\t  enqueue(s);\n\t  s.u = s.d = s.l = s.r = 0;\n\t  s.dis = 0;\n\t  //print(s);\n\t}\n      }\n      //右\n      if(j0 != N-1 && v.l == 0){\n\tcopy(s.p, v.p); //vのパズルの状態をコピーする\n\tswap(&(s.p[i0][j0]), &(s.p[i0][j0+1]));\n\tif(judge(s.p) == TRUE){\n\t  s.r = 1; //左に行かないようにする(無駄に往復しないように)\n\t  s.dis = v.dis + 1;\n\t  enqueue(s);\n\t  s.u = s.d = s.l = s.r = 0;\n\t  s.dis = 0;\n\t  //print(s);\n\t}\n      }\n      //左\n      if(j0 != 0 && v.r == 0){\n\tcopy(s.p, v.p); //vのパズルの状態をコピーする\n\tswap(&(s.p[i0][j0]), &(s.p[i0][j0-1]));\n\tif(judge(s.p) == TRUE){\n\t  s.l = 1; //右に行かないようにする(無駄に往復しないように)\n\t  s.dis = v.dis + 1;\n\t  enqueue(s);\n\t  s.u = s.d = s.l = s.r = 0;\n\t  s.dis = 0;\n\t  //print(s);\n\t}\n      }\n    \n  }\n\n};\n\nvoid copy(int a[N][N], int b[N][N]){\n  int i, j;\n  \n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      a[i][j] = b[i][j];\n    }\n  }\n}\n\nvoid swap(int *a, int *b){\n  int v;\n  v = *a;\n  *a = *b;\n  *b = v;\n}\n\nint judge(int a[N][N]){\n  long long key = 0; //ハッシュ\n  int x, y = 1;\n  int i, j;\n\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      x = a[i][j] + 1;\n      key += x * y;\n      y *= 9;\n    }\n  }\n\n  key -= MIN;\n  \n  //\\0はfree, nはnotfree\n  if(memo[key] == '\\0'){\n    memo[key] = 'n';\n    return TRUE;\n  }\n  else return FALSE;\n}\n\nvoid enqueue(puzzle x){\n  q[tail] = x;\n  if(tail == MAX-1) tail = 0;\n  else tail++;\n}\n\npuzzle dequeue(void){\n  puzzle x;\n  x = q[head];\n  if(head == MAX-1) head = 0;\n  else head++;\n  return x;\n}\n\nvoid print(puzzle s){\n  int i, j;\n  static int x = 1;\n  printf(\"%d\\n\", x);\n  x++;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      printf(\"%d \", s.p[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n// I/O\nint get_uint() {\n    int n = 0;\n    int c = getchar_unlocked();\n    if(c < 48 || 57 < c) return c;\n    while(47 < c && c < 58) n = 10 * n + (c & 0xf), c = getchar_unlocked();\n    return n;\n}\nvoid put_uint(int n) {\n    if(!n) {\n        putchar_unlocked('0');\n        return;\n    }\n    char buf[11];\n    int i = 0;\n    while(n) buf[i++] = (char)(n % 10 + '0'), n /= 10;\n    while(i--)putchar_unlocked(buf[i]);\n}\n\n\n// Node\ntypedef struct NodeKey {\n    int board[9];\n    int space;\n    int cnt;\n} NodeKey;\n// lt: -1, gt: 1, eq: 0\nint cmp_node(const NodeKey *l, const NodeKey *r) {\n    for(int i = 0; i < 9; ++i) {\n        if(l->board[i] == r->board[i]) continue;\n        else if(l->board[i] < r->board[i]) return -1;\n        else return 1;\n    }\n    return 0;\n}\n\n\n// Treap\ntypedef struct Node {\n    NodeKey key;\n    int priority;\n    struct Node *left, *right;\n} Node;\ntypedef struct BST {\n    Node *root;\n    size_t size;\n} BST;\nvoid bst_init(BST *BST) {\n    BST->root = NULL;\n    BST->size = 0;\n}\nNode *bst_rotate_right(Node *root) {\n    Node *tmp = root->left;\n    root->left = tmp->right;\n    tmp->right = root;\n    return tmp;\n}\nNode *bst_rotate_left(Node *root) {\n    Node *tmp = root->right;\n    root->right = tmp->left;\n    tmp->left = root;\n    return tmp;\n}\nNode *bst__insert(Node *root, const NodeKey key, const int priority) {\n    if(root == NULL) {\n        Node *new_node = malloc(sizeof(Node));\n        new_node->key = key;\n        new_node->priority = priority;\n        new_node->left = new_node->right = NULL;\n        return new_node;\n    }\n    if(cmp_node(&key, &root->key) == 0) return root;\n    if(cmp_node(&key, &root->key) == -1) {\n        root->left = bst__insert(root->left, key, priority);\n        if(root->priority < root->left->priority) root = bst_rotate_right(root);\n    } else {\n        root->right = bst__insert(root->right, key, priority);\n        if(root->priority < root->right->priority) root = bst_rotate_left(root);\n    }\n    return root;\n}\nvoid bst_insert(BST *BST, const NodeKey key, const int priority) {\n    BST->root = bst__insert(BST->root, key, priority);\n    BST->size++;\n}\nNode *bst_find(Node *root, const NodeKey key) {\n    while(root != NULL && cmp_node(&key, &root->key)) {\n        if(cmp_node(&key, &root->key) == -1) root = root->left;\n        else root = root->right;\n    }\n    return root;\n}\n\n\n// Queue\n#define QueueKey NodeKey\ntypedef struct QueueDat {\n    QueueKey key;\n    struct QueueDat *next;\n} QueueDat;\ntypedef struct Queue {\n    size_t len;\n    QueueDat *head;\n    QueueDat *tail;\n} Queue;\n#define queue_init(q) ((q) ? ((q)->len = 0, (q)->head = (q)->tail = NULL) : 0)\n#define queue_len(q) ((q) ? (q)->len : 0)\nvoid queue_push(Queue *q, QueueKey x) {\n    QueueDat *new_dat = malloc(sizeof(QueueDat));\n    *new_dat = (QueueDat){x, NULL};\n    if(q->len) {\n        q->tail->next = new_dat;\n        q->tail = new_dat;\n    } else {\n        q->head = q->tail = new_dat;\n    }\n    q->len++;\n}\nQueueKey queue_pop(Queue *q) {\n    QueueDat *old_head = q->head;\n    q->head = old_head->next;\n    QueueKey key = old_head->key;\n    free(old_head);\n    q->len--;\n    return key;\n}\n\n\n// end condition\nint is_solved(const int board[9]) {\n    for(int i = 0; i < 8; ++i)\n        if(board[i] != i + 1) return 0;\n    return 1;\n}\n\n\n// solve\nint bfs(NodeKey s) {\n    const int N = 3;\n    const int dx[4] = {-1, 0, 1, 0};\n    const int dy[4] = {0, -1, 0, 1};\n    BST BST;\n    bst_init(&BST);\n    bst_insert(&BST, s, rand());\n    Queue Q;\n    queue_init(&Q);\n    queue_push(&Q, s);\n    while(queue_len(&Q)) {\n        NodeKey key = queue_pop(&Q);\n        if(is_solved(key.board)) return key.cnt;\n        int x = key.space % N;\n        int y = key.space / N;\n        for(int i = 0; i < 4; ++i) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(nx < 0 || N <= nx || ny < 0 || N <= ny) continue;\n\n            int next_space = nx + ny * N;\n            NodeKey next_key = key;\n            next_key.board[key.space] = next_key.board[next_space];\n            next_key.board[next_space] = 0;\n            next_key.space = next_space;\n            if(bst_find(BST.root, next_key)) continue;\n\n            next_key.cnt++;\n            bst_insert(&BST, next_key, rand());\n            queue_push(&Q, next_key);\n        }\n    }\n}\n\n\nint main(int argc, char **argv) {\n    NodeKey initial;\n    initial.cnt = 0;\n    for(int i = 0; i < 9; ++i) {\n        int x = get_uint();\n        initial.board[i] = x;\n        if(x == 0) initial.space = i;\n    }\n    put_uint(bfs(initial));\n    putchar_unlocked('\\n');\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\n#define LEN 362880\nint head = 0, tail = 0;\nint que[LEN];\n\nint start[9]; //初期状態\t\nint goal = 46233;\t//最終状態\nint search[362880] = { 0 };\t//探索済み\nint board[362880][9];\t//盤面の状態\nint d[362880];\t//時間\nint oya; //親のナンバー\nint dummy[9];\t//盤面コピー用\nint p0[362880];\t//0の位置を記憶\n\n/*盤面の隣接リスト*/\nint next[9][5] = { {2, 1, 3},\n\t\t\t\t   {3, 0, 2, 4},\n                   {2, 1, 5},\n\t\t\t\t   {3, 0, 4, 6},\n                   {4, 1, 3, 5, 7},\n\t\t\t\t   {3, 2, 4, 8},\n                   {2, 3, 7},\n                   {3, 4, 6, 8},\n\t\t\t\t   {2, 5, 7}\n};\n\n/*キューの実装*/\nint isempty() {\n\treturn head == tail;\n}\n\nvoid enqueue(int x) {\n\tque[tail] = x;\n\tif ((tail + 1) == LEN)\n\t\ttail = 0;\n\telse\n\t\ttail++;\n}\n\nint dequeue() {\n\tint x;\n\tx = que[head];\n\tif ((head + 1) == LEN)\n\t\thead = 0;\n\telse\n\t\thead++;\n\treturn x;\n}\n\n/*0のマスを探索*/\nint a_mas0(int a[]) {\n\tfor (int i = 0; i < 9; i++)\n\t\tif (a[i] == 0)\n\t\t\treturn i;\n}\n\n/*盤面をコピー*/\nvoid board_copy(int a[], int b[]) {\n\tfor (int i = 0; i < 9; i++)\n\t\tb[i] = a[i];\n}\n\n/*階乗を計算*/\nint n_factorial(int n) {\n\tif (n == 1)\n\t\treturn 1;\n\treturn n * n_factorial(n - 1);\n}\n\n/*盤面記憶のために使用*/\nvoid a_location(int a[], int s) {\n\tfor (int i = s + 1; i < 9; i++)\n\t\tif (a[s] < a[i])\n\t\t\ta[i]--;\n}\n\n/*盤面の状態を数値に変換*/\nint assign_number(int a[]) {\n\tint b[9];\n\tint num = 0;\n\tint pos = 8;\n\tboard_copy(a, b);\n\tfor (int i = 8; i > 0; i--) {\n\t\tnum = num + b[8 - i] * n_factorial(i);\n\t\ta_location(b, 8 - i);\n\t\tif (a[8 - i] == 0)\n\t\t\tpos = 8 - i;\n\t}\n\tp0[num] = pos;\n\treturn num;\n}\n\n/*マスの移動*/\nvoid move(int *a, int *b) {\n\tint box;\n\tbox = *a;\n\t*a = *b;\n\t*b = box;\n}\n\n/*盤面の表示*/\nvoid puzzle_print(int a[]) {\n\tfor (int i = 0; i < 9; i++)\n\t\tprintf(\"%d \", a[i]);\n\tprintf(\"\\n\");\n}\n\n/*0の位置を探索*/\nint zero_position(int a[]) {\n\tfor (int i = 0; i < 9; i++)\n\t\tif (a[i] == 0)\n\t\t\treturn i;\n}\n\n/*幅優先探索*/\nint bsf() {\n\tint num;\n\tint pos;\n\twhile (isempty() != 1) {\n\t\toya = dequeue();\n\t\tpos = p0[oya];\n\t\tfor (int i = 1; i <= next[pos][0]; i++) {\n\t\t\tboard_copy(board[oya], dummy);\t//oyaの盤面をdummyにコピー\n\t\t\tmove(&dummy[pos], &dummy[next[pos][i]]);\t//dummyの盤面を移動\n\t\t\tnum = assign_number(dummy);\t//移動した盤面を数値に変換\n\t\t\tif (num == goal){\t//最終状態を発見\n\t\t\t\td[num] = d[oya] + 1;\t\n\t\t\t\tsearch[num] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if (search[num] != 1) {\t//最終状態でない\n\t\t\t\tsearch[num] = 1;\n\t\t\t\tboard_copy(dummy, board[num]);\n\t\t\t\td[num] = d[oya] + 1;\n\t\t\t\tenqueue(num);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void) {\n\tint i = 0;\n\tint num;\n\t\n\t/*初期状態の設定*/\n\tfor (i = 0; i < 9; i++)\n\t\tscanf(\"%d\", &start[i]);\n\tnum = assign_number(start);\t//初期状態の数値\n\tboard_copy(start, board[num]);\t//初期状態の盤面を記憶\n\tsearch[num] = 1;\t//初期状態の数値を記憶(1をたてる)\n\td[num] = 0;\t//初期状態の時間を0に設定\n\tenqueue(num); //初期状態の数値をキューに格納\n\t\n\t/*探索開始*/\n\tif (num == goal)\n\t\tprintf(\"0\\n\");\n\telse if (bsf() == 1)\n\t\tprintf(\"%d\\n\", d[goal]);\n\telse\n\t\tprintf(\"なし\\n\"); \n\t\n\t\n\twhile (1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n \nchar *flag;\nint head,rear;\nint *que;\nint factorial[10];\n \nint cal_factorial(int n) {\n  if(n == 0) return 1;\n  return cal_factorial(n-1)*n;\n}\n \nint stotag(char *s) {\n  int tag = 0;\n  int i;\n  for(i = 0; i < 9; i++) {\n    int t,j;\n    t = 0;\n    for(j = 0; j < i; j++) {\n      if(s[j] < s[i]) t++;\n    }\n    tag += factorial[8-i]*(s[i]-'0'-t);\n  }\n  return tag;\n}\n \nchar *tagtos(int tag) {\n  int i;\n  char *s;\n  s = (char*)malloc(sizeof(char)*10);\n  for(i = 0; i < 9; i++) {\n    s[i] = tag%factorial[9-i]/factorial[8-i] + '0';\n  }\n  s[9] = '\\0';\n  for(i = 7; i >= 0; i--) {\n    int j;\n    for(j = 8; j > i; j--) {\n      if(s[i] <= s[j]) s[j]++;\n    }\n  }\n  return s;\n}\n \n \nchar *move_up(char s[], int x) {\n  if(x < 3) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-3];\n  s_new[x-3] = s[x];\n  return s_new;\n}\n \nchar *move_left(char s[], int x) {\n  if(x%3 == 0) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-1];\n  s_new[x-1] = s[x];\n  return s_new;\n}\n \nchar *move_right(char s[], int x) {\n  if(x%3 == 2) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+1];\n  s_new[x+1] = s[x];\n  return s_new;\n}\n \nchar *move_down(char s[], int x) {\n  if(x > 5) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+3];\n  s_new[x+3] = s[x];\n  return s_new;\n}\n \nint create(char s[], int t) {\n  if(strcmp(s,\"123456780\") == 0) return t;\n  int tag = stotag(s);\n  if(flag[tag]) return 0;\n  flag[tag] = t;\n  que[rear] = tag;\n  rear++;\n  return 0;\n}\n \nint check_x(char *s) {\n  int i = 0;\n  while(s[i] != '0') i++;\n  return i;\n}\n \nint cal() {\n  char *s_right,*s_left,*s_up,*s_down;\n  int k,tag;\n \n  tag = que[head];\n  char *s = tagtos(tag);\n  int x = check_x(s);\n   \n  if((s_right = move_right(s, x)) != NULL) {\n    if((k = create(s_right,flag[tag]+1))) return k;\n    free(s_right);\n  }\n  if((s_left = move_left(s, x)) != NULL) {\n     if((k = create(s_left,flag[tag]+1))) return k;\n     free(s_left);\n  }\n  if ((s_up = move_up(s, x)) != NULL) {\n    if((k = create(s_up,flag[tag]+1))) return k;\n    free(s_up);\n  }\n  if((s_down = move_down(s, x)) != NULL) {\n    if((k = create(s_down,flag[tag]+1))) return k;\n    free(s_down);\n  }\n  free(s);\n  head++;\n  return 0;\n}\n   \n \nint solve(char s0[]) {\n  int k;\n  if((k = create(s0,1))) return k;\n   \n  while(!(k = cal())) {\n    if(head == rear) break;\n  }\n  return k;\n}\n \nint main()\n{\n \n  int i,d;\n  char s[10];\n  for(i = 0; i < 10; i++) factorial[i] = cal_factorial(i);\n  flag = (char*)malloc(sizeof(char)*factorial[9]);\n  memset(flag , 0, factorial[9]);\n  que = (int*)malloc(sizeof(int)*factorial[9]);\n  head = 0;\n  rear = 0;\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &d);\n    s[i] = d+'0';\n  }\n  s[9] = '\\0';\n  printf(\"%d\\n\",solve(s)-1);\n   \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef char Board[10];\nBoard ini_board, board, *history;\nconst Board target = \"123456780\";\nint nhistories=0;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  char pos;\n  char dir;\n} Motion;\n\nint minstep;\n\nconst Motion motion[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nint search_path(int step, char space)\n{\n  int i, j;\n  if (strcmp(board, \"123456780\")==0) {\n    //    printf(\"STEP=%d\\n\", step);                                                 \n    //printf(\"%d\\n\", step);                                                          \n    if (step<minstep) minstep=step;\n    printf(\"%d\\n\", step);\n    exit(0);\n  } else {\n    if (step>=minstep) return 1;\n    if (step>0 && strcmp(board, ini_board)==0) return 1;\n\n    Board board_bak;\n    strcpy(board_bak, board);\n    int nhistories_bak=nhistories;\n\n   for (i=0; motion[space][i].pos>=0; i++) {\n      Motion m = motion[space][i];\n\n      if (m.pos==0 && board[0]=='1') continue;\n      if ((m.pos==1||m.pos==2) && board[0]=='1'&&board[1]=='2'&&board[2]=='3') conti\\\nnue;\n      if ((m.pos==3||m.pos==6) && board[0]=='1'&&board[3]=='4'&&board[6]=='7')contin\\\nue;\n      switch (m.dir) {\n      case U:\n        if (m.pos<3) continue;\n        board[m.pos-3] = board[m.pos];\n        break;\n      case D:\n        if (m.pos>5) continue;\n        board[m.pos+3] = board[m.pos];\n        break;\n      case L:\n        if (m.pos%3==0) continue;\n        board[m.pos-1] = board[m.pos];\n        break;\n      case R:\n        if (m.pos%3==2) continue;\n        board[m.pos+1] = board[m.pos];\n        break;\n      }\n      board[m.pos] = '0';\n\n      for (j=0; j<nhistories; j++) {\n        if (strcmp(board, history[j])==0)     break;\n      }\n      if (j==nhistories) {\n        strcpy(history[nhistories++], board);\n        search_path(step+1, m.pos);\n      }\n      nhistories = nhistories_bak;\n      strcpy(board, board_bak);\n    }\n  }\n  return 1;\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board[0],&board[1],&board[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[3],&board[4],&board[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[6],&board[7],&board[8]);\n  strcpy(ini_board, board);\n  for (minstep=1; minstep<32; minstep++) {\n    strcpy(board, ini_board);\n    history = (Board*)malloc(sizeof(Board)*100000);\n    search_path(0, strchr(board, '0')-board);\n    free(history);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n \n#define N 3\n \nint search(int board[N][N], int min, int limit, int r_0, int c_0);\n \nint search(int board[N][N], int min, int limit, int r_0, int c_0)\n{\n  int md_c;\n  int num;\n  int res[4];\n \n  if (min == 0) return 0;\n \n  if (r_0 != 0) {\n    md_c = min;\n    num = board[r_0-1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0-1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0-1][c_0] = 0;\n      board[r_0][c_0] = num;\n      res[0] = search(board, md_c, limit-1, r_0-1, c_0);\n      if (res[0] == -1) {\n    board[r_0-1][c_0] = num;\n    board[r_0][c_0] = 0;\n      } else res[0]++;\n    } else res[0] = -1;\n  } else res[0] = -1;\n \n  if (r_0 != N-1) {\n    md_c = min;\n    num = board[r_0+1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0+1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0+1][c_0] = 0;\n      board[r_0][c_0] =num;\n      res[1] = search(board, md_c, limit-1, r_0+1, c_0);\n      if (res[1] == -1) {\n    board[r_0+1][c_0] = num;\n    board[r_0][c_0] = 0;\n      } else res[1]++;\n    } else res[1] = -1;\n  } else res[1] = -1;\n \n  if (c_0 != 0) {\n    md_c = min;\n    num = board[r_0][c_0-1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0-1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0-1] = 0;\n      board[r_0][c_0] = num;\n      res[2] = search(board, md_c, limit-1, r_0, c_0-1);\n      if (res[2] == -1) {\n    board[r_0][c_0-1] = num;\n    board[r_0][c_0] = 0;\n      } else res[2]++;\n    } else res[2] = -1;\n  } else res[2] = -1;\n \n  if (c_0 != N-1) {\n    md_c = min;\n    num = board[r_0][c_0+1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0+1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0+1] = 0;\n      board[r_0][c_0] = num;\n      res[3] = search(board, md_c, limit-1, r_0, c_0+1);\n      if (res[3] == -1) {\n        board[r_0][c_0+1] = num;\n        board[r_0][c_0] = 0;\n      } else res[3]++;\n    } else res[3] = -1;\n  } else res[3] = -1;\n \n  if (res[0] == -1 && res[1] == -1 && res[2] == -1 && res[3] == -1) return -1;\n  else if (res[0] != -1) return res[0];\n  else if (res[1] != -1) return res[1];\n  else if (res[2] != -1) return res[2];\n  else return res[3];\n}\nint main(int argc, char *argv[])\n{\n  int board[N][N];\n  int md;\n  int i, j, r, c, r_0, c_0, found;\n  int res;\n \n  for (i = 0; i < N; i++) {\n    for (j = 0; j < N; j++) scanf(\"%d\", &board[i][j]);\n  }\n \n  md = 0;\n  for (i = 0; i < N * N; i++) {\n    found = 0;\n    for (r = 0; r < N; r++) {\n      for (c = 0; c < N; c++) {\n    if (board[r][c] == i) {\n      if (i == 0) {\n        r_0 = r;\n        c_0 = c;\n      } else md += (int)fabs((i-1)/N - r) + (int)fabs((i-1)%N - c);\n      found = 1;\n      break;\n    }\n      }\n      if (found == 1) break;\n    }\n  }\n \n  for (i = 0; ; i += 2) {\n    if ((r_0 + c_0) % 2 == 0) {\n      if (md % 2 == 0) res = search(board, md, md+i, r_0, c_0);\n      else res = search(board, md, md+i+1, r_0, c_0);\n    } else {\n      if (md % 2 == 0) res = search(board, md, md+i+1, r_0, c_0);\n      else res = search(board, md, md+i, r_0, c_0);\n    }\n \n    if (res != -1) break;\n  }\n \n  printf(\"%d\\n\", res);\n \n  return 0;\n}\n "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define Q_MAX 362880\n#define N 3\n#define N2 9\n\ntypedef struct puzzle\n{\n\tint board[N2];\n\tint space;\n\tint path;\n} Puzzle;\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\n\nPuzzle Q[Q_MAX];\nint head, tail, V[Q_MAX];\n\nint empty();\nvoid enq(Puzzle);\nPuzzle front();\nint check(Puzzle);\nint isTarget(Puzzle);\nint BFS(Puzzle);\nvoid swap(int *, int *);\n\nint main()\n{\n\tint i, ans;\n\tPuzzle p;\n\n\tfor (i = 0; i < N2; i++)\n\t{\n\t\tscanf(\"%d\", &p.board[i]);\n\t\tif (p.board[i] == 0)\n\t\t{\n\t\t\tp.board[i] = N2;\n\t\t\tp.space = i;\n\t\t}\n\t}\n\n\tans = BFS(p);\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n\nint empty()\n{\n\treturn head == tail;\n}\n\nvoid enq(Puzzle p)\n{\n\tQ[tail] = p;\n\ttail = (tail + 1) % Q_MAX;\n}\n\nPuzzle front()\n{\n\tPuzzle p;\n\n\tp = Q[head];\n\thead = (head + 1) % Q_MAX;\n\treturn p;\n}\n\nint check(Puzzle p)\n{\n\tint i, j, f, count, res = 0;\n\n\tfor (i = 0, f = 1; i < N2; f *= ++i)\n\t{\n\t\tfor (j = 0, count = 0; j < i; j++)\n\t\t{\n\t\t\tif (p.board[j] < p.board[i])\n\t\t\t\tcount++;\n\t\t}\n\t\tres += count * f;\n\t}\n\treturn res;\n}\n\nint isTarget(Puzzle p)\n{\n\tint i;\n\n\tfor (i = 0; i < N2; i++)\n\t{\n\t\tif (p.board[i] != (i + 1))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nint BFS(Puzzle q)\n{\n\tint sx, sy, tx, ty, r, tmp;\n\tint i;\n\tPuzzle u, v;\n\n\tq.path = 0;\n\tenq(q);\n\tV[check(q)] = 1;\n\twhile (!empty())\n\t{\n\t\tu = front();\n\t\tif (isTarget(u))\n\t\t\treturn u.path;\n\t\tsx = u.space / N;\n\t\tsy = u.space % N;\n\t\tfor (r = 0; r < 4; r++)\n\t\t{\n\t\t\ttx = sx + dx[r];\n\t\t\tty = sy + dy[r];\n\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\tcontinue;\n\t\t\tv = u;\n\t\t\ttmp = v.board[u.space];\n\t\t\tv.board[u.space] = v.board[tx * N + ty];\n\t\t\tv.board[tx * N + ty] = tmp;\n\t\t\tv.space = tx * N + ty;\n\t\t\tif (!V[check(v)])\n\t\t\t{\n\t\t\t\tV[check(v)] = 1;\n\t\t\t\tv.path++;\n\t\t\t\tenq(v);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 9\n\nint board[N];\nint rows = 3, cols = 3, zeroIndex, current;\n\n// for previousMove: 0 is down, 1 is up, 2 is left, 3 is right\nint blindSearch(int x, int y, int moves, int previousMove) {\n  int i, foundAnswer;\n\n  // answer is less than manhattan distance, not possible\n  if (moves < (x + y))\n      return 0;\n\n  if (!moves) {\n    //printf(\"done %d moves\\n\", current);\n\n    for (i = 0; i < N - 1; i++) {\n      if (board[i] != i + 1)\n        return 0;\n    }\n\n    return 1;\n  }\n\n  if (x > 0 && previousMove != 1) {\n    // can expand down\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n\n    foundAnswer = blindSearch(x - 1, y, moves - 1, 0);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n  }\n  \n  if (y > 0 && previousMove != 3) {\n    // right\n    board[zeroIndex] = board[zeroIndex + 1];\n    zeroIndex++;\n\n    foundAnswer = blindSearch(x, y - 1, moves - 1, 2);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[zeroIndex - 1];\n    zeroIndex--;\n  }\n\n  if (y < rows - 1 && previousMove != 2) {\n    // left\n    board[zeroIndex] = board[zeroIndex - 1];\n    zeroIndex--;\n\n    foundAnswer = blindSearch(x, y + 1, moves - 1, 3);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[zeroIndex + 1];\n    zeroIndex++;\n  }\n\n  if (x < cols - 1 && previousMove != 0) {\n    // up\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n\n    foundAnswer = blindSearch(x + 1, y, moves - 1, 1);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n  }\n\n  return 0;\n}\n\nint main() {\n  int i, x, y;\n  current = 0;\n\n  for (i = 0; i < N; i++) {\n    scanf(\"%d\", &board[i]);\n    if (!board[i])\n      zeroIndex = i;\n  }\n\n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n\n  //printf(\"zero index coordinates are: %d %d\\n\", x, y);\n\n  while (current < 50) {\n    if (blindSearch(x, y, current, -1)) {\n      printf(\"%d\\n\", current);\n      return;\n    }\n    current++;\n  }\n\n  //printf(\"Couldn't find an answer!\\n\");\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint mas[3][3];\nint cpy[3][3];\n\n\nint main() {\n  input();\n  printf(\"%d\\n\", solve());\n  return 0;\n}\nvoid input() {\n  int i, j;\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++)\n      scanf(\"%d\", &mas[i][j]);\n}\n\nvoid output() {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n    puts(\"\");\n  }\n}\n\nvoid copy(int m[3][3], int t[3][3]) {\n  int i, j;\n\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n\nint calc() {\n  int i, sum = 0;\n  for(i = 0; i < 9; i++) {\n    int v = mas[i/3][i%3];\n    if(v) {\n      v--;\n      sum += abs(i/3-v/3)+abs(i%3-v%3);\n    }\n  }\n  return sum;\n}\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nvoid swap(int *a, int *b) {\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nint is_in(int x, int y) {\n  return 0<=x&&x<3&&0<=y&&y<3;\n}\n\nint dfs(int x, int y, int p, int dep, const int lim) {\n  int i, h = calc();\n  //output();\n  if(h == 0) return dep;\n  //printf(\"%d %d %d\\n\", h, lim, p);\n  if(dep+h > lim) return -1;\n\n  for(i = 0; i < 4; i++) {\n    int nx = x+dx[i], ny = y+dy[i], res;\n    if(~p && i == (p+2)%4) continue;\n    if(!is_in(nx, ny)) continue;\n    swap(&mas[y][x], &mas[ny][nx]);\n    res = dfs(nx, ny, i, dep+1, lim);\n    if(~res) return res;\n    swap(&mas[y][x], &mas[ny][nx]);\n  }\n\n  return -1;\n}\n\nvoid get_empty(int *x, int *y) {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) {\n      if(!mas[i][j]) {\n\t*x = j;\n\t*y = i;\n\treturn;\n      }\n    }\n  }\n}\n\nint solve() {\n  int x, y, lim, ans;\n  get_empty(&x, &y);\n  for(lim = 0; lim < 50; lim++) {\n    copy(cpy, mas);\n    if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n    copy(mas, cpy);\n  }\n  return -1;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \nint puz[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n \nvoid empty(int *,int *);\nint dfs(int,int,int,int,const int);\nint cal();\nvoid swap(int *,int *);\n \n \nint main() {\n    int i,j,ans,x,y,l;\n     \n    //puzzle input\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) scanf(\"%d\",&puz[i][j]);\n    }\n     \n     \n    empty(&x,&y);\n    for(l=0; l<100; l++) {\n        //copy\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) tmp[i][j] = puz[i][j];\n        }\n         \n        //dfs\n        ans = dfs(x,y,-1,0,l);\n        if(ans!=-1) {\n            printf(\"%d\\n\",ans);\n            break;\n        }\n         \n        //copy\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) puz[i][j] = tmp[i][j];\n        }\n         \n        //error\n        ans = -1;\n        if(l==99) printf(\"%d\\n\",ans);\n    }\n     \n    //ans output\n    //printf(\"%d\\n\",ans);\n     \n    return 0;\n}\n \n \nvoid empty(int *x,int *y) {\n    int i,j;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) {\n            if(!puz[i][j]) {\n                *x = j;\n                *y = i;\n                return;\n            }\n        }\n    }\n}\n \n \nvoid swap(int *a,int *b) {\n    int tmp;\n     \n    tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n \n \nint cal() {\n    int i,a,sum=0;\n     \n    for(i=0; i<9; i++) {\n        a = puz[i/3][i%3];\n        if(a) {\n            a--;\n            sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n        }\n    }\n     \n    return sum;\n}\n \n \nint dfs(int x,int y,int p,int dep,const int lim) {\n    int i,h,nx,ny,res;\n     \n    h = cal();\n    if(h==0) return dep;\n    if(dep+h>lim) return -1;\n     \n    for(i=0; i<4; i++) {\n        nx = x+dx[i];\n        ny = y+dy[i];\n         \n        if(~p && i==(p+2)%4) continue;\n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n         \n        swap(&puz[y][x],&puz[ny][nx]);\n        res = dfs(nx,ny,i,dep+1,lim);\n        if(~res) return res;\n         \n        swap(&puz[y][x],&puz[ny][nx]);\n    }\n     \n    return -1;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \nint puzzle[3][3];\nint tmp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n \nvoid empty(int *,int *);\nint dfs(int,int,int,int,const int);\nint cal();\nvoid swap(int *,int *);\n \nint main() {\n    int i,j,a,x,y,l;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) scanf(\"%d\",&puzzle[i][j]);\n    }\n \n    empty(&x,&y);\n    for(l=0; l<100; l++) {\n        for(i=0; i<3; i++) {\n            for(j=0; j<3; j++) tmp[i][j] = puzzle[i][j];\n        }\n \n        a = dfs(x,y,-1,0,l);\n        if(a!=-1) {\n            printf(\"%d\\n\",a);\n            break;\n        }\n \n        for(i=0 ; i<3 ; i++) {\n            for(j=0 ; j<3 ; j++) puzzle[i][j] = tmp[i][j];\n        }\n        a = -1;\n        if(l==99) printf(\"%d\\n\",a);\n    } \n    return 0;\n}\n \nvoid empty(int *x,int *y) {\n    int i,j;\n    for(i=0; i<3; i++) {\n        for(j=0; j<3; j++) {\n            if(!puzzle[i][j]) {\n                *x = j;\n                *y = i;\n                return;\n            }\n        }\n    }\n}\n \nvoid swap(int *a,int *b) {\n    int tmp;\n    tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n \nint cal() {\n    int i,a,sum=0;\n    for(i=0; i<9; i++) {\n        a = puzzle[i/3][i%3];\n        if(a) {\n            a--;\n            sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n        }\n    }\n    return sum;\n}\n \nint dfs(int x,int y,int p,int dep,const int lim) {\n    int i,h,nx,ny,res;\n \n    h = cal();\n    if(h==0) return dep;\n    if(dep+h>lim) return -1;\n \n    for(i=0; i<4; i++) {\n        nx = x+dx[i];\n        ny = y+dy[i];\n  \n        if(~p && i==(p+2)%4) continue;\n        if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n  \n        swap(&puzzle[y][x],&puzzle[ny][nx]);\n        res = dfs(nx,ny,i,dep+1,lim);\n        if(~res) return res;\n  \n        swap(&puzzle[y][x],&puzzle[ny][nx]);\n    }\n \n    return -1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <queue>\n \nusing namespace std;\n \n#define N 3\n#define N2 9\n \nstruct Puzzle{\n    int f[N2];\n    int space;\n    string path;\n     \n    bool operator < (const Puzzle &p) const{\n        for(int i=0;i<N2;i++){\n            if(f[i]==p.f[i]) continue;\n            return f[i]>p.f[i];\n        }\n        return false;\n    }\n};\n \nstatic const int dx[4]={-1,0,1,0};\n \nstatic const int dy[4]={0,-1,0,1};\n \nstatic const char dir[4]={'u','a','d','r'};\n \nbool isTarget(Puzzle p){\n    for(int i=0;i<N2;i++){\n        if(p.f[i]!=(i+1)) return false;\n    }\n    return true;\n}\n \n \nstring bfs(Puzzle s){\n    queue<Puzzle> Q;\n    map<Puzzle,bool> V;\n    Puzzle u,v;\n    s.path=\"\";\n    Q.push(s);\n    V[s]=true;\n     \n    while(!Q.empty()){\n        u=Q.front();Q.pop();\n        if(isTarget(u)) return u.path;\n        int sx=u.space/N;\n        int sy=u.space%N;\n        for(int r=0;r<4;r++){\n            int tx=sx+dx[r];\n            int ty=sy+dy[r];\n            if(tx<0||ty<0||tx>=N||ty>=N) continue;\n            v=u;\n            swap(v.f[u.space],v.f[tx*N+ty]);\n            v.space=tx*N+ty;\n            if(!V[v]){\n                V[v]=true;\n                v.path+=dir[r];\n                Q.push(v);\n            }\n        }\n    }\n     \n    return \"unsolvable\";\n}\n \n \nint main(){\n    Puzzle in;\n     \n    for(int i=0;i<N2;i++){\n        cin>>in.f[i];\n        if(in.f[i]==0){\n            in.f[i]=N2;\n            in.space=i;\n        }\n    }\n     \n    string ans = bfs(in);\n     \n    cout<<ans.size()<<endl;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 3\n#define MAX 362880\n#define FALSE 0\n#define TRUE 1\n\ntypedef struct {\n  int num[9];\n  int space;\n  int moves;\n} PUZZLE;\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nint V[MAX];\n\nPUZZLE Q[MAX];\nint head,tail;\n\nint emp(){\n  if(head == tail) return TRUE;\n  return FALSE;\n}\n\nvoid push(PUZZLE p){\n  Q[tail] = p;\n  tail = (tail+1)%MAX; //Ring Buffer\n}\n\nPUZZLE pop(){\n  PUZZLE p;\n  p = Q[head];\n  head = (head+1)%MAX;\n  return p;\n}\n\nvoid swap(int *x,int *y){\n  int tmp;\n  tmp = *x;\n  *x = *y;\n  *y = tmp;\n}\n\nint count(PUZZLE p){\n  int i, j, fac, cnt, result = 0;\n  for(i = 0, fac = 1; i < 9; fac*= ++i){\n    for(j = 0, cnt = 0; j < i; j++){\n      if(p.num[j] < p.num[i]) cnt++;\n    }\n    result += cnt*fac;\n  }\n  \n  return result;\n}\n  \n\nint check_goal(PUZZLE p){\n  int i;\n  for(i  = 0; i < 9; i++){\n    if(p.num[i] != (i + 1)) return FALSE;\n  }\n  return TRUE;\n}\n\nint BFS(PUZZLE s){\n  int sx,sy,tx,ty,r;\n  PUZZLE u,v;\n\n  s.moves = 0;\n\n  push(s);\n\n  V[count(s)] = 1;\n\n  while(emp() != TRUE){\n    u = pop();\n    if(check_goal(u) == TRUE) return u.moves;\n    sx = u.space/N;\n    sy = u.space%N;\n\n    for(r = 0; r < 4; r++){\n      tx = sx + dx[r];\n      ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      v = u;\n\n      swap(&v.num[u.space], &v.num[tx*N + ty]);\n      v.space = tx*N + ty;\n\n      if(V[count(v)] != TRUE){\n\tV[count(v)] = 1;\n\tv.moves++;\n\tpush(v);\n      }\n    }\n  }\n\n  return -1;\n}\n\nint main(){\n  int i;\n  PUZZLE in;\n\n  for(i = 0; i < 9; i++){\n    scanf(\"%d\",&in.num[i]);\n    if(in.num[i] == 0){\n      in.num[i] = 9;\n      in.space = i;\n    }\n  }\n\n  printf(\"%d\\n\",BFS(in));\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define N 3\n#define M 4\n\nint a[N][N],temp[N][N],dx[M]={0,1,0,-1},dy[M]={1,0,-1,0};\nvoid empty(int *x,int *y) {\n  int i,j;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      if(!a[i][j]){\n        *x=j;\n        *y=i;\n        return;\n      }\n    }\n  }\n}\nvoid swap(int *a, int *b) {\n  int temp;\n  temp = *a;\n  *a = *b;\n  *b = temp;\n}\nint cal() {\n  int i,u,sum=0;\n  for(i=0;i<9;i ++){\n    u=a[i/N][i%N];\n    if(u != 0){\n      u--;\n      sum += abs(i/N - u/N)+abs(i%N - u%N);\n    }\n  }\n  return sum;\n}\nint dfs(int x, int y, int p, int d, const int lim) {\n  int i,v,nx,ny,res;\n  v=cal();\n  if(v == 0) return d;\n\n  if(d+v > lim) return -1;\n\n  for(i=0;i<M;i++){\n    nx = x+dx[i];\n    ny = y+dy[i];\n    if(~p&&i == (p+2)%M) continue;\n    if(!(0 <= nx && nx < N && 0 <= ny && ny < N)) continue;\n    swap(&a[y][x],&a[ny][nx]);\n    res=dfs(nx,ny,i,d+1,lim);\n       if(~res) return res;\n\n    swap(&a[y][x],&a[ny][nx]);\n  }\n  return -1;\n}\nint main() {\n  int i,j,ans,x,y,l;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&a[i][j]);\n    }\n  }\n  empty(&x,&y);\n  for(l=0;l<100;l++){\n    for(i=0;i<N;i++){\n        for(j =0;j<N;j++){\n        temp[i][j] = a[i][j];\n      }\n    }\n    ans = dfs(x,y,-1,0,l);\n    if(ans != -1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++){\n        a[i][j]=temp[i][j];\n      }\n    }\n    ans = -1;\n    if(l == 99){\n      printf(\"%d\\n\",ans);\n    }\n  }\n  return 0;\n}\n        \n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n int puzle[3][3];\n int tmp[3][3];\n int d1[4]={0,1,0,-1};\n int d2[4]={1,0,-1,0};\n \n void empty(int *x,int *y){\n                           int i,j;\n                           for(i=0;i<3;i++){\n                                            for(j=0;j<3;j++){\n                                                             if(!puzle[i][j]){\n                                                                              *x=j;\n                                                                              *y=i;\n                                                                              return;\n                                                                              }\n                                                              }\n                                             }\n                            }\n\n void swap(int *a,int *b){\n                          int tmp=*a;\n                          *a=*b;\n                          *b=tmp;\n                          }\n\n int cal(){\n           int a,i,sum=0;\n           for(i=0;i<9;i++){\n                            a=puzle[i/3][i%3];\n                            if(a){\n                                  a--;\n                                  sum+=abs(i/3-a/3)+abs(i%3-a%3);\n                                  }\n                            }\n           return sum;\n           }\n\n int dfs(int x,int y,int p,int dep,const int lim){\n       int i,h,n1,n2,res;\n       h=cal();\n       if(h==0){\n                return dep;\n                }\n       if(dep+h>lim){\n                     return -1;\n                     }\n       for(i=0;i<4;++i){\n                        n1=x+d1[i];\n                        n2=y+d2[i];\n \n                        if(~p&&i==(p+2)%4)continue;\n                        if(!(0<=n1&&n1<3&&0<=n2&&n2<3))continue;\n                        swap(&puzle[y][x],&puzle[n2][n1]);\n                        res=dfs(n1,n2,i,dep+1,lim);\n\n                        if(~res)return res;\n \n                        swap(&puzle[y][x],&puzle[n2][n1]);\n                        }\n       return -1; \n       }\n\n  int main(){\n    int ans,x,y,l,i,j;\n  \n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n        scanf(\"%d\",&puzle[i][j]);\n      }\n    }\n    empty(&x,&y);\n    for(l=0;l<100;l++){\n      for(i=0;i<3;i++){\n        for(j=0;j<3;j++){\n    tmp[i][j]=puzle[i][j];\n      }\n    }\n      ans=dfs(x,y,-1,0,l);\n      if(ans!=-1){\n        printf(\"%d\\n\",ans);\n        break;\n      }\n      for(i=0;i<3;i++){\n        for(j=0;j<3;j++){\n    puzle[i][j]=tmp[i][j];\n      }\n      }\n      ans=-1;\n      if(l==99){\n        printf(\"%d\\n\",ans);\n    }\n    }\n    return 0;            }\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define N 3\n\nint search(int board[N][N], int min, int limit, int r_0, int c_0);\n\nint main(int argc, char *argv[])\n{\n  int board[N][N];\n  int md;\n  int i, j, r, c, r_0, c_0, found;\n  int res;\n\n  for (i = 0; i < N; i++) {\n    for (j = 0; j < N; j++) scanf(\"%d\", &board[i][j]);\n  }\n\n  md = 0;\n  for (i = 0; i < N * N; i++) {\n    found = 0;\n    for (r = 0; r < N; r++) {\n      for (c = 0; c < N; c++) {\n\tif (board[r][c] == i) {\n\t  if (i == 0) {\n\t    r_0 = r;\n\t    c_0 = c;\n\t  } else md += (int)fabs((i-1)/N - r) + (int)fabs((i-1)%N - c);\n\t  found = 1;\n\t  break;\n\t}\n      }\n      if (found == 1) break;\n    }\n  }\n\n  for (i = 0; ; i += 2) {\n    if ((r_0 + c_0) % 2 == 0) {\n      if (md % 2 == 0) res = search(board, md, md+i, r_0, c_0);\n      else res = search(board, md, md+i+1, r_0, c_0);\n    } else {\n      if (md % 2 == 0) res = search(board, md, md+i+1, r_0, c_0);\n      else res = search(board, md, md+i, r_0, c_0);\n    }\n\n    if (res != -1) break;\n  }\n\n  printf(\"%d\\n\", res);\n\n  return 0;\n}\n\nint search(int board[N][N], int min, int limit, int r_0, int c_0)\n{\n  int md_c;\n  int num;\n  int res[4];\n\n  if (min == 0) return 0;\n\n  if (r_0 != 0) {\n    md_c = min;\n    num = board[r_0-1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0-1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0-1][c_0] = 0;\n      board[r_0][c_0] = num;\n      res[0] = search(board, md_c, limit-1, r_0-1, c_0);\n      if (res[0] == -1) {\n\tboard[r_0-1][c_0] = num;\n\tboard[r_0][c_0] = 0;\n      } else res[0]++;\n    } else res[0] = -1;\n  } else res[0] = -1;\n\n  if (r_0 != N-1) {\n    md_c = min;\n    num = board[r_0+1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0+1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0+1][c_0] = 0;\n      board[r_0][c_0] =num;\n      res[1] = search(board, md_c, limit-1, r_0+1, c_0);\n      if (res[1] == -1) {\n\tboard[r_0+1][c_0] = num;\n\tboard[r_0][c_0] = 0;\n      } else res[1]++;\n    } else res[1] = -1;\n  } else res[1] = -1;\n\n  if (c_0 != 0) {\n    md_c = min;\n    num = board[r_0][c_0-1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0-1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0-1] = 0;\n      board[r_0][c_0] = num;\n      res[2] = search(board, md_c, limit-1, r_0, c_0-1);\n      if (res[2] == -1) {\n\tboard[r_0][c_0-1] = num;\n\tboard[r_0][c_0] = 0;\n      } else res[2]++;\n    } else res[2] = -1;\n  } else res[2] = -1;\n\n  if (c_0 != N-1) {\n    md_c = min;\n    num = board[r_0][c_0+1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0+1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0+1] = 0;\n      board[r_0][c_0] = num;\n      res[3] = search(board, md_c, limit-1, r_0, c_0+1);\n      if (res[3] == -1) {\n        board[r_0][c_0+1] = num;\n        board[r_0][c_0] = 0;\n      } else res[3]++;\n    } else res[3] = -1;\n  } else res[3] = -1;\n\n  if (res[0] == -1 && res[1] == -1 && res[2] == -1 && res[3] == -1) return -1;\n  else if (res[0] != -1) return res[0];\n  else if (res[1] != -1) return res[1];\n  else if (res[2] != -1) return res[2];\n  else return res[3];\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define N 3\n#define N2 9\n#define H 2\n\ntypedef struct puzzle puz;\n\nstruct puzzle{\n  int p[N][N];\n  int pos0;\n  int g;\n};\n\ntypedef struct list node;\n\nstruct list{\n  puz *p;\n  int f;\n  node *prev; //動かす前のノード\n  node *next; //リスト上の次のノード\n};\n\n/*void print_puz(puz p){\n  int i;\n  for(i = 0; i < N2; i++){\n    printf(\"%d, \", p.p[i/N][i%N]);\n    if(i%N == 2) printf(\"\\n\");\n  }\n  printf(\"%d\\n\", p.g);\n  }*/\n\nint h(puz p){\n  int i, mode, r = 0;\n  mode = H;\n  if(mode == 1){\n    for(i = 0; i < N2; i++){\n      if((p.p[i/N][i%N] != 0 || i != N2-1) && p.p[i/N][i%N] != i+1) r++;\n    }\n  }else if(mode == 2){\n    for(i = 0; i < N2; i++){\n      if(p.p[i/N][i%N] != 0) r += abs(i/N - (p.p[i/N][i%N]-1)/N) + abs(i%N - (p.p[i/N][i%N]-1)%N);\n\telse r += 2*(N-1) -i/N -i%N;\n    }\n  }\n    return r+p.g;\n}\n\npuz* move_p(puz m, int mode){\n  puz* n;\n  int i;\n  n = malloc(sizeof(puz));\n  for(i = 0; i < N2; i++) n->p[i/N][i%N] = m.p[i/N][i%N];\n  switch(mode){\n    case 0:\n      n->pos0 = m.pos0-N;\n    break;\n    case 1:\n      n->pos0 = m.pos0-1;\n    break;\n    case 2:\n      n->pos0 = m.pos0+N;\n    break;\n    case 3:\n      n->pos0 = m.pos0+1;\n    break;\n  }\n  n->p[m.pos0/N][m.pos0%N] = n->p[n->pos0/N][n->pos0%N];\n  n->p[n->pos0/N][n->pos0%N] = 0;\n  n->g = m.g+1;\n\n  return n;\n}\n\nnode* make_n(node *prev, puz *p){\n  node *n;\n  n = malloc(sizeof(node));\n  n->prev = prev;\n  n->p = p;\n  n->f = h(*p);\n  n->next = NULL;\n\n  return n;\n}\n\nint check_p(puz a, puz b){\n  int i;\n  for(i = 0; i < N2; i++){\n      if(a.p[i/N][i%N] != b.p[i/N][i%N]) break;\n      else if(i == N2-1) return 0;\n  }\n  return 1;\n}\n\nint check_c(node *t, puz *a){\n  int i;\n  puz *b;\n  while(t != NULL){\n    b = t->p;\n    if(check_p(*a, *b)) t = t->next;\n    else return 0;\n  }\n  return 1;\n}\n\nint add_open(node *t, node *a){\n  //tにopenリストの先頭を渡す\n  node *p = NULL;\n  while(t != NULL){\n    if(t->f == a->f){\n      if(check_p(*(t->p), *(a->p)) && t->f > a->f){\n          t->prev = a->prev;\n          return 0;\n        }\n      }else if(t->f > a->f){\n        if(p == NULL){\n          a->next = t;\n          return 1;\n        }else{\n          p->next = a;\n          a->next = t;\n          return 0;\n        }\n      }\n      p = t;\n      t = t->next;\n    }\n  if(p == NULL) return 1;\n    p->next = a;\n    return 0;\n  }\n\nint main(){\n  int i, count = 0;\n  clock_t s, e;\n  puz *p, start, goal;\n  node *n, *new;\n  node *open, *close;\n\n  for(i = 0; i < N2; i++){\n    scanf(\"%d\", &start.p[i/N][i%N]);\n    goal.p[i/N][i%N] = i+1;\n    if(start.p[i/N][i%N] == 0)start.pos0 = i;\n  }\n  goal.p[N-1][N-1] = 0;\n  goal.pos0 = N2-1;\n\n  start.g = 0;\n  \n  n = NULL;\n  open = make_n(n, &start);\n  close = NULL;\n\n  s = clock();\n  while(open != NULL){\n    count++;\n    if(check_p(*(open->p), goal) != 1) break;\n    //print_puz(*(open->p));\n    n = open;\n    open = open->next;\n    if(n->p->pos0 >= N){\n      p = move_p(*(n->p), 0);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    if(n->p->pos0%N != 0){\n      p = move_p(*(n->p), 1);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    if(n->p->pos0 < N*(N-1)){\n      p = move_p(*(n->p), 2);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    if(n->p->pos0%N != N-1){\n      p = move_p(*(n->p), 3);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    n->next = close;\n    close = n;\n  }\n\n  e = clock();\n\n  printf(\"%d\\n\", count);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define N 3\n#define LIM 50\nint buf[N][N];\nint tmp[N][N];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\nvoid empty(int *,int *);\nvoid swap(int *,int*);\nint cal();\nint dfs(int,int,int,int,int);\n\nint main(){\n  int i,j,k,x,y,ans;\n  for(i = 0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&buf[i][j]);\n    }\n  }\n  empty(&x,&y);\n  \n  for(k = 0;k<LIM;k++){\n\n    for(i = 0;i<N;i++){\n      for(j = 0;j<N;j++){\n\ttmp[i][j] = buf[i][j];\n      }\n    }\n    \n    ans = dfs(x,y,-1,0,k);\n    if(ans !=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n\n\n    for(i =0;i<N;i++){\n      for(j=0;j<N;j++){\n\tbuf[i][j] = tmp[i][j];\n      }\n    }\n    \n    ans = -1;\n\n    if(k == 49){\n      printf(\"%d\\n\",ans);\n    }\n  }\n\t\n  return 0;\n}\n\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\n\n\nint dfs(int x,int y,int p,int depth,int lim){\n  int i,h,nx,ny,res;\n  h = cal();\n  if(h==0) {return depth;}\n  if(depth +h >lim) {return -1;}\n  \n  for(i=0;i<4;i++){\n    nx = x+dx[i];\n    ny = y+dy[i];\n    if(~p && i ==(p+2)%4) continue;\n    if(!(0 <=nx && nx <3 && 0 <=ny && ny <3)) continue;\n\n    swap(&buf[y][x],&buf[ny][nx]);\n    \n    res = dfs(nx,ny,i,depth+1,lim);\n    \n    if(~res) {return res;}\n    swap(&buf[y][x],&buf[ny][nx]);\n  }\n  return -1;\n}\n\nint cal(){\n  int i,a,sum=0;\n  for(i = 0;i<9;i++){\n    a = buf[i/3][i%3];\n    if(a) {\n      a--;\n      sum += abs(i/3 - a/3) +abs(i%3 - a%3);\n    }\n  }\n  return sum;\n}\n\n\n\n\nvoid empty(int *x ,int *y){\n  int i,j;\n  for(i = 0 ;i <N ;i++){\n    for(j = 0;j<N;j++){\n      if(buf[i][j]==0)\n\t{\n\t  *x = j;\n\t  *y = i;\n\t  return ;\n\t}\n    }\n  }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 9\n\nint board[N];\nint rows = 3, cols = 3, zeroIndex, current;\n\n// for previousMove: 0 is down, 1 is up, 2 is left, 3 is right\nint blindSearch(int x, int y, int moves, int previousMove) {\n  int i, foundAnswer;\n\n  // answer is less than manhattan distance, not possible\n  if (moves < (x + y))\n      return 0;\n\n  if (!moves) {\n    //printf(\"done %d moves\\n\", current);\n\n    for (i = 0; i < N - 1; i++) {\n      if (board[i] != i + 1)\n        return 0;\n    }\n\n    return 1;\n  }\n\n  if (x > 0 && previousMove != 1) {\n    // can expand down\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n\n    foundAnswer = blindSearch(x - 1, y, moves - 1, 0);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n  }\n\n  if (y > 0 && previousMove != 3) {\n    // right\n    board[zeroIndex] = board[++zeroIndex];\n\n    foundAnswer = blindSearch(x, y - 1, moves - 1, 2);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[--zeroIndex];\n  }\n\n  if (y < rows - 1 && previousMove != 2) {\n    // left\n    board[zeroIndex] = board[--zeroIndex];\n\n    foundAnswer = blindSearch(x, y + 1, moves - 1, 3);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[++zeroIndex];\n  }\n\n if (x < cols - 1 && previousMove != 0) {\n    // up\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n\n    foundAnswer = blindSearch(x + 1, y, moves - 1, 1);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n  }\n\n  return 0;\n}\n\nint main() {\n  int i, x, y;\n  current = 0;\n\n  for (i = 0; i < N; i++) {\n    scanf(\"%d\", &board[i]);\n    if (!board[i])\n      zeroIndex = i;\n  }\n\n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n\n  //printf(\"zero index coordinates are: %d %d\\n\", x, y);\n\n  while (current < 50) {\n    if (blindSearch(x, y, current, -1)) {\n      printf(\"%d\\n\", current);\n      return;\n    }\n    current++;\n  }\n\n  //printf(\"Couldn't find an answer!\\n\");\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ ALDS1_13_B 8 Puzzle\n// 2018.5.8 bal4u\n\n#include <stdio.h>\n\ntypedef unsigned char uchar;\n\n#define HASHSIZ 543217\ntypedef struct { unsigned s; char x, v; } HASH;\nHASH hash[HASHSIZ+3], *hashend = hash+HASHSIZ;\n\nint lookup(unsigned s, int x)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) return hp->v;\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\treturn -1;\n}\n\nvoid insert(unsigned s, int x, char v)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) { hp->v = v; break; }\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\thp->s = s, hp->x = x, hp->v = v;\n}\n\n#define QMAX 50000\ntypedef struct { unsigned s; char x, v; } T;\nT s[QMAX+3]; int top, end;\nint hi[9] = {2,3,2,3,4,3,2,3,2};\nint to[9][4] = {{1,3},{0,2,4},{1,5},{0,4,6},{1,3,5,7},{2,4,8},{3,7},{4,6,8},{5,7}};\n\nvoid toArray(char *nine, unsigned s, int x)\n{\n\tint i;\n\t\n\tfor (i = 8; i >= 0; i--) {\n\t\tif (i == x) nine[i] = 0;\n\t\telse nine[i] = s & 0xf, s >>= 4;\n\t}\n}\n\nunsigned swap(char *nine, int zero, int nx)\n{\n\tint i;\n\tunsigned res;\n\t\n\tres = 0;\n\tfor (i = 0; i < 9; i++) {\n\t\tif      (i == zero) res <<= 4, res |= nine[nx];\n\t\telse if (i != nx)   res <<= 4, res |= nine[i];\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint i;\n\tint x, nx, v, nv, t;\n\tunsigned a, na;\n\tunsigned gs; int gx;\t// goal\n\tchar nine[9];\n\t\n\tgs = 0; for (i = 0; i < 9; i++) {\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 0) gx = i;\n\t\telse gs <<= 4, gs |= t;\n\t}\n\ts[0].s = 0x12345678, s[0].x = 8, s[0].v = 0;\n\ttop = 0, end = 1;\n\tinsert(s[0].s, s[0].x, 0);\n\twhile (top != end) {\n\t\ta = s[top].s, x = s[top].x, v = s[top].v;\n\t\tif (++top == QMAX) top = 0; \n\t\tif (x == gx && a == gs) break;\n\n\t\ttoArray(nine, a, x);\n\t\tfor (i = 0; i < hi[x]; i++) {\n\t\t\tnx = to[x][i];\n\t\t\tna = swap(nine, x, nx), nv = v+1;\n\t\t\tt = lookup(na, nx);\n\t\t\tif (t < 0 || nv < t) {\n\t\t\t\ts[end].s = na, s[end].x = nx, s[end].v = nv;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t\tinsert(na, nx, nv);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", v);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define N 3\n#define N2 9\n#define H 2\n\ntypedef struct puzzle puz;\n\nstruct puzzle{\n  int p[N][N];\n  int pos0;\n  int g;\n};\n\ntypedef struct list node;\n\nstruct list{\n  puz *p;\n  int f;\n  node *prev; //動かす前のノード\n  node *next; //リスト上の次のノード\n};\n\n/*void print_puz(puz p){\n  int i;\n  for(i = 0; i < N2; i++){\n    printf(\"%d, \", p.p[i/N][i%N]);\n    if(i%N == 2) printf(\"\\n\");\n  }\n  printf(\"%d\\n\", p.g);\n  }*/\n\nint h(puz p){\n  int i, mode, r = 0;\n  mode = H;\n  if(mode == 1){\n    for(i = 0; i < N2; i++){\n      if((p.p[i/N][i%N] != 0 || i != N2-1) && p.p[i/N][i%N] != i+1) r++;\n    }\n  }else if(mode == 2){\n    for(i = 0; i < N2; i++){\n      if(p.p[i/N][i%N] != 0) r += abs(i/N - (p.p[i/N][i%N]-1)/N) + abs(i%N - (p.p[i/N][i%N]-1)%N);\n\telse r += 2*(N-1) -i/N -i%N;\n    }\n  }\n    return r+p.g;\n}\n\npuz* move_p(puz m, int mode){\n  puz* n;\n  int i;\n  n = malloc(sizeof(puz));\n  for(i = 0; i < N2; i++) n->p[i/N][i%N] = m.p[i/N][i%N];\n  switch(mode){\n    case 0:\n      n->pos0 = m.pos0-N;\n    break;\n    case 1:\n      n->pos0 = m.pos0-1;\n    break;\n    case 2:\n      n->pos0 = m.pos0+N;\n    break;\n    case 3:\n      n->pos0 = m.pos0+1;\n    break;\n  }\n  n->p[m.pos0/N][m.pos0%N] = n->p[n->pos0/N][n->pos0%N];\n  n->p[n->pos0/N][n->pos0%N] = 0;\n  n->g = m.g+1;\n\n  return n;\n}\n\nnode* make_n(node *prev, puz *p){\n  node *n;\n  n = malloc(sizeof(node));\n  n->prev = prev;\n  n->p = p;\n  n->f = h(*p);\n  n->next = NULL;\n\n  return n;\n}\n\nint check_p(puz a, puz b){\n  int i;\n  for(i = 0; i < N2; i++){\n      if(a.p[i/N][i%N] != b.p[i/N][i%N]) break;\n      else if(i == N2-1) return 0;\n  }\n  return 1;\n}\n\nint check_c(node *t, puz *a){\n  int i;\n  puz *b;\n  while(t != NULL){\n    b = t->p;\n    if(check_p(*a, *b)) t = t->next;\n    else return 0;\n  }\n  return 1;\n}\n\nint add_open(node *t, node *a){\n  //tにopenリストの先頭を渡す\n  node *p = NULL;\n  while(t != NULL){\n    if(t->f == a->f){\n      if(check_p(*(t->p), *(a->p)) && t->f > a->f){\n          t->prev = a->prev;\n          return 0;\n        }\n      }else if(t->f > a->f){\n        if(p == NULL){\n          a->next = t;\n          return 1;\n        }else{\n          p->next = a;\n          a->next = t;\n          return 0;\n        }\n      }\n      p = t;\n      t = t->next;\n    }\n  if(p == NULL) return 1;\n    p->next = a;\n    return 0;\n  }\n\nint main(){\n  int i, count = 0;\n  clock_t s, e;\n  puz *p, start, goal;\n  node *n, *new;\n  node *open, *close;\n\n  for(i = 0; i < N2; i++){\n    scanf(\"%d\", &start.p[i/N][i%N]);\n    goal.p[i/N][i%N] = i+1;\n    if(start.p[i/N][i%N] == 0)start.pos0 = i;\n  }\n  goal.p[N-1][N-1] = 0;\n  goal.pos0 = N2-1;\n\n  start.g = 0;\n  \n  n = NULL;\n  open = make_n(n, &start);\n  close = NULL;\n\n  s = clock();\n  while(open != NULL){\n    count++;\n    if(check_p(*(open->p), goal) != 1) break;\n    //print_puz(*(open->p));\n    n = open;\n    open = open->next;\n    if(n->p->pos0 >= N){\n      p = move_p(*(n->p), 0);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    if(n->p->pos0%N != 0){\n      p = move_p(*(n->p), 1);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    if(n->p->pos0 < N*(N-1)){\n      p = move_p(*(n->p), 2);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    if(n->p->pos0%N != N-1){\n      p = move_p(*(n->p), 3);\n      if(check_c(close, p)){\n\tnew = make_n(n, p);\n\tif(add_open(open, new)) open = new;\n      } else free(p);\n    }\n    n->next = close;\n    close = n;\n  }\n\n  e = clock();\n\n  printf(\"%d\\n\", open->p->g);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n \n#define S 9\n \nint board[S];\nint rows = 3, cols = 3, zeroIndex;\n \n\nint blindSearch(int x, int y, int moves, int previousMove) {\n  int i, foundAnswer;\n \n \n  if (moves < (x + y))\n    return 0;\n \n  if (!moves) {\n    for (i = 0; i < S - 1; i++) {\n      if (board[i] != i + 1)\n        return 0;\n    }\n \n    return 1;\n  }\n \n  if (x > 0 && previousMove != 1) {\n    // can expand down\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n \n    foundAnswer = blindSearch(x - 1, y, moves - 1, 0);\n    if (foundAnswer)\n      return 1;\n \n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n  }\n \n  if (y > 0 && previousMove != 3) {\n    // right\n    board[zeroIndex] = board[zeroIndex + 1];\n    zeroIndex++;\n \n    foundAnswer = blindSearch(x, y - 1, moves - 1, 2);\n    if (foundAnswer)\n      return 1;\n \n    board[zeroIndex] = board[zeroIndex - 1];\n    zeroIndex--;\n  }\n \n  if (y < rows - 1 && previousMove != 2) {\n    // left\n    board[zeroIndex] = board[zeroIndex - 1];\n    zeroIndex--;\n \n    foundAnswer = blindSearch(x, y + 1, moves - 1, 3);\n    if (foundAnswer)\n      return 1;\n \n    board[zeroIndex] = board[zeroIndex + 1];\n    zeroIndex++;\n  }\n \n  if (x < cols - 1 && previousMove != 0) {\n    // up\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n \n    foundAnswer = blindSearch(x + 1, y, moves - 1, 1);\n    if (foundAnswer)\n      return 1;\n \n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n  }\n \n  return 0;\n}\n \nint main() {\n  int j, x, y, current;\n \n  for (j = 0; j < S; j++) {\n    scanf(\"%d\", &board[j]);\n    if (!board[j])\n      zeroIndex = j;\n  }\n \n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n \n  for (current = 0; current < 50; current++) {\n    if (blindSearch(x, y, current, -1)) {\n      printf(\"%d\\n\", current);\n      return 0;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ ALDS1_13_B 8 Puzzle\n// 2018.5.8 bal4u\n\n#include <stdio.h>\n\ntypedef unsigned char uchar;\n\n#define HASHSIZ 543217\ntypedef struct { unsigned s; char x, v; } HASH;\nHASH hash[HASHSIZ+3], *hashend = hash+HASHSIZ;\n\nint lookup(unsigned s, int x)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) return hp->v;\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\treturn 0;\n}\n\nvoid insert(unsigned s, int x, char v)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) { hp->v = v; break; }\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\thp->s = s, hp->x = x, hp->v = v;\n}\n\n#define QMAX 30000\ntypedef struct { unsigned s; char x, v; } T;\nT s[QMAX+3]; int top, end;\nint hi[9] = {2,3,2,3,4,3,2,3,2};\nint to[9][4] = {{1,3},{0,2,4},{1,5},{0,4,6},{1,3,5,7},{2,4,8},{3,7},{4,6,8},{5,7}};\n\nvoid toArray(char *nine, unsigned s, int x)\n{\n\tint i;\n\t\n\tfor (i = 8; i >= 0; i--) {\n\t\tif (i == x) nine[i] = 0;\n\t\telse nine[i] = s & 0xf, s >>= 4;\n\t}\n}\n\nunsigned swap(char *nine, int zero, int nx)\n{\n\tint i;\n\tunsigned res;\n\t\n\tres = 0;\n\tfor (i = 0; i < 9; i++) {\n\t\tif      (i == zero) res <<= 4, res |= nine[nx];\n\t\telse if (i != nx)   res <<= 4, res |= nine[i];\n\t}\n\treturn res;\n}\n\n#define MAGIC 21\n\nint main()\n{\n\tint i, x, nx, v, nv, t;\n\tunsigned a, na;\n\tunsigned gs; int gx;\t// goal\n\tchar nine[9];\n\t\n\tgs = 0; for (i = 0; i < 9; i++) {\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 0) gx = i;\n\t\telse gs <<= 4, gs |= t;\n\t}\n\ts[0].s = 0x12345678, s[0].x = 8;\n\ts[1].x = -1;\n\ttop = 0, end = 2;\n\tinsert(s[0].s, s[0].x, 0);\n\tv = 0;\n\twhile (top != end) {\n\t\ta = s[top].s, x = s[top].x;\n\t\tif (++top == QMAX) top = 0; \n\t\tif (x < 0) {\n\t\t\tif (v == MAGIC) break;\n\t\t\tv++;\n\t\t\ts[end].x = -1; if (++end == QMAX) end = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (x == gx && a == gs) goto done;\n\t\tif (lookup(a, x) < v) continue;\n\n\t\ttoArray(nine, a, x);\n\t\tfor (i = 0; i < hi[x]; i++) {\n\t\t\tnx = to[x][i];\n\t\t\tna = swap(nine, x, nx), nv = v+1;\n\t\t\tt = lookup(na, nx);\n\t\t\tif (!t || nv < t) {\n\t\t\t\ts[end].s = na, s[end].x = nx;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t\tinsert(na, nx, nv);\n\t\t\t}\n\t\t}\n\t}\n\n\ts[0].s = gs, s[0].x = gx, s[1].x = -1;\n\ttop = 0, end = 2;\n\tv = 0;\n\twhile (top != end) {\n\t\ta = s[top].s, x = s[top].x;\n\t\tif (++top == QMAX) top = 0; \n\t\tif (x < 0) {\n\t\t\tv++;\n\t\t\ts[end].x = -1; if (++end == QMAX) end = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((t = lookup(a, x)) > 0) { v += t; break; }\n\n\t\ttoArray(nine, a, x);\n\t\tfor (i = 0; i < hi[x]; i++) {\n\t\t\tnx = to[x][i];\n\t\t\tna = swap(nine, x, nx), nv = v+1;\n\t\t\tt = lookup(na, nx);\n\t\t\tif (!t || nv < t) {\n\t\t\t\ts[end].s = na, s[end].x = nx;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tprintf(\"%d\\n\", v);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 3\n#define N2 9\n#define LEN 362880\n\ntypedef struct Puzzle\n{\n  int f[N2];\n  int space;\n  int path;\n}P;\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nstatic const char dir[4] = {'u', 'l', 'd', 'r'};\n\nint V[LEN];\nP Q[LEN];\nint head = 0;\nint tail = 0;\n\nvoid enqueue(P);\nP dequeue(void);\nint bfs(P);\nint isTarget(P);\nint henkan(P);\n\nint main()\n{\n  P in;\n\n  int i, ans;\n\n  for(i = 0; i < N2; i++)\n    {\n      scanf(\"%d\",&in.f[i]);\n\n      if(in.f[i] == 0)\n\t{\n\t  in.f[i] = N2;\n\t  in.space = i;\n\t}\n    }\n\n  ans = bfs(in);\n\n  printf(\"%d\\n\",ans);\n\n  return 0;\n}\n\nvoid enqueue(P num)\n{\n  int next = (tail+1)%LEN;\n\n  Q[tail] = num;\n  tail = next;\n}\n\nP dequeue(void)\n{\n  P val;\n  \n  val = Q[head];\n  head = (head+1)%LEN;\n  \n  return val;\n}\n\nint bfs(P s)\n{\n  P u, v;\n  int sx, sy, tx, ty, r, temp;\n\n  s.path = 0;\n  enqueue(s);\n  V[henkan(s)] = 1;\n\n  while(head != tail)\n    {\n     \n      u = dequeue();\n      if(isTarget(u))return u.path;\n      sx = u.space/N;\n      sy = u.space%N;\n\n      for(r = 0; r < 4; r++)\n\t{\n\t  tx = sx + dx[r];\n\t  ty = sy + dy[r];\n\t  if( tx < 0 || ty < 0 || tx >= N || ty >= N)continue;\n\t  v = u;\n\t  temp = v.f[u.space];\n\t  v.f[u.space] = v.f[tx * N + ty];\n\t  v.f[tx * N + ty] = temp;\n\t  v.space = tx * N + ty;\n\t  if(!V[henkan(v)])\n\t    {\n\t      V[henkan(v)] = 1;\n\t      v.path++;\n\t      enqueue(v);\n\t    }\n\t}\n    }\n  return -1;\n}\n\nint isTarget(P p)\n{\n  int i;\n  \n  for(i = 0; i < N2; i++)\n    {\n      if(p.f[i] != (i+1))return 0;\n    }\n  return 1;\n}\n\nint henkan(P v)\n{\n  int i, j, a, count, order = 0;\n\n  for(i = 0, a = 1; i < N2; a*=++i)\n    {\n      for(j = 0, count = 0; j < i; j++)\n\t{\n\t  if(v.f[j] < v.f[i])count++;\n\t}\n      order += count*a;\n    }\n  return order;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint Pz[3][3],tmp[3][3],Dx[4]={0,1,0,-1},Dy[4]={1,0,-1,0};\n\nvoid emblem(int *a,int *b){\n  \n  int i,j;\n  \n  for(i = 0;i < 3;i++){\n    for(j = 0;j < 3;j++){\n      if(!Pz[i][j]){\n\t*a = j;\n\t*b=i;\n      }\n    }\n  }\n}\n\nvoid swap(int *a,int *b){\n  \n  int tmp;\n  \n  tmp =*a;\n  *a = *b;\n  *b = tmp;\n}\n\nint check(){\n  \n  int i,a,b=0;\n  \n  for(i = 0;i < 9;i++){\n    a = Pz[i/3][i%3];\n    if(a){\n      a--;\n      b += abs(i/3 - a/3) + abs(i%3 - a%3);\n    }\n  }\n  \n  return b;\n  \n}\n\nint defain(int a,int b,int P,int D,const int shin){\n  \n  int i,I,A,B,result;\n  \n  I = check();\n  if(I == 0){\n    return D;\n  }\n  if(D + I > shin){\n    return -1;\n  }\n\n  for(i = 0;i < 4;i++){\n    A = a + Dx[i];\n    B = b + Dy[i];\n    if(~P && i==(P+2)%4) continue;\n    if(!(0 <= A && A < 3 && 0 <= B && B < 3)) continue;\n    swap(&Pz[b][a],&Pz[B][A]);\n    result = defain(A,B,i,D+1,shin);\n    if(~result) return result;\n    swap(&Pz[b][a],&Pz[B][A]);\n  }\n  \n  return -1;\n  \n}\n\nint main(){\n  \n  int i,j,a,b,c,d;\n\n  for(i = 0;i < 3;i++){\n    for(j = 0;j < 3;j++){\n      scanf(\"%d\",&Pz[i][j]);\n    }\n  }\n\n  emblem(&a,&b);\n  for(c = 0;c < 100;c++){\n    for(i = 0;i < 3;i++){\n      for(j = 0;j < 3;j++) tmp[i][j]=Pz[i][j];\n    }\n    d = defain(a,b,-1,0,c);\n    if(d != -1){\n      printf(\"%d\\n\",d);\n      break;\n    }\n\n    for(i = 0;i < 3;i++){\n      for(j = 0;j < 3;j++) Pz[i][j]=tmp[i][j];\n    }\n\n    d = -1;\n    if(c == 99) printf(\"%d\\n\",d);\n  }\n\n  return 0;\n  \n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define TRUE  1\n#define FALSE 0\n#define FORWARD  1\n#define BACKWARD 2\n#define SIZE  9\n#define NIL   (-1)\n\n/* 状態数 (9! / 2) */\n#define MAX_STATE 181440\n\n/* 隣接リスト */\nconst char adjacent[SIZE][5] = {\n  1, 3,-1,-1,-1,\n  0, 4, 2,-1,-1,\n  1, 5,-1,-1,-1,\n  0, 4, 6,-1,-1,\n  1, 3, 5, 7,-1,\n  2, 4, 8,-1,-1,\n  3, 7,-1,-1,-1,\n  4, 6, 8,-1,-1,\n  5, 7,-1,-1,-1,\n};\n\n/* キュー */\nchar state[MAX_STATE + 1][SIZE];      /* +1 はワーク領域 */\nchar space_postion[MAX_STATE];\nint  prev_state[MAX_STATE];\nint  number_table[MAX_STATE];\n\n/* 同一局面チェックテーブル */\nchar check_table[MAX_STATE * 2];\n\n/* 初期状態 */\nchar init_state[SIZE];\n\n/* 終了状態 */\nchar final_state[SIZE] = {\n  1, 2, 3, 4, 5, 6, 7, 8, 0\n};\n\nint count=0;\n\nvoid print_answer_forward(int n)\n{\n  if(n > 1) print_answer_forward(prev_state[n]);\n  count++;\n}\n\nvoid print_answer_backward( int n )\n{\n  do{\n    n = prev_state[n];\n    count++;\n  }\n\n  while( prev_state[n] != -1 );\n}\n\nvoid print_answer( int pos1, int num1, int num2 )\n{\n  /* num2 の位置を見つける */\n  int pos2 = pos1 - 1;\n\n  while( num2 != number_table[pos2] ) pos2--;\n\n  if( check_table[num1] == FORWARD ){\n    print_answer_forward( pos1 );\n    print_answer_backward( pos2 );\n  }\n  else{\n    print_answer_forward( pos2 );\n    print_answer_backward( pos1 );\n  }\n}\n\n/* 番号に変換 */\nint change_number( char *board )\n{\n  char work[SIZE];\n  static int fact_table[SIZE] = {\n    40320, 5040, 720, 120, 24, 6, 2, 1, 0,\n  };\n  int j, k, value = 0;\n  memcpy( work, board, SIZE );\n  for( j = 0; j < SIZE - 1; j++ ){\n    value += fact_table[j] * work[j];\n    for( k = j + 1; k < SIZE; k++ ){\n      if( work[j] < work[k] ) work[k]--;\n    }\n  }\n  return value;\n}\n\n/* キューの初期化 */\nvoid init_queue( void )\n{\n  int num;\n\n  /* スタート */\n  memcpy( state[0], init_state, SIZE );\n  space_postion[0] = 7;\n  prev_state[0] = -1;\n  num = change_number( init_state );\n  number_table[0] = num;\n  check_table[ num ] = FORWARD;\n\n  /* ゴール */\n  memcpy( state[1], final_state, SIZE );\n  space_postion[1] = 8;\n  prev_state[1] = -1;\n  num = change_number( final_state );\n  number_table[1] = num;\n  check_table[ num ] = BACKWARD;\n}\n\n/* 探索 */\nvoid search( void )\n{\n  int front = 0, rear = 2;\n\n  /* 初期化 */\n  init_queue();\n\n  while( front < rear ){\n    int s = space_postion[front];\n    int num1 = number_table[front];\n    int num2, i, n;\n\n    for( i = 0; (n = adjacent[s][i]) != -1; i++ ){\n      /* 状態をコピー */\n      memcpy( state[rear], state[front], SIZE );\n      /* 移動 */\n      state[rear][s] = state[rear][n];\n      state[rear][n] = 0;\n      space_postion[rear] = n;\n      prev_state[rear] = front;\n      num2 = change_number( state[rear] );\n\n      if( !check_table[num2] ){\n\t/* 登録 */\n        number_table[rear] = num2;\n        check_table[num2] = check_table[num1];\n\trear++;\n      }\n      else if( check_table[num1] != check_table[num2] ){\n        /* 解が見つかった */\n        print_answer( rear, num1, num2 );\n        return;\n      }\n    }\n    front++;\n  }\n}\n\nint main()\n{\n  int i;\n  \n  for(i = 0; i < 9; i++){\n    scanf(\"%d\", &init_state[i]);\n  }\n  \n  search();\n  printf(\"count = %d\\n\", count-1);  \n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint data[9],first[9],limit = 32, cnt = 0;\nint process(int, int);\nint check();\nvoid change1(int, int);\nvoid change2(int, int);\nvoid debug(int, int);\n\nint main(){\n\n  int i;\n\n  for(i = 0; i < 9; i++)\n  {\n    scanf(\"%d\",&data[i]);\n    first[i] = data[i];\n  }\n\n\n\n  for(i = 0; i < 9; i++)\n  {\n    if(data[i] == 0)break;\n  }\n\n  process(i, -1);\n\n  printf(\"%d\\n\",limit);\n\n  return 0;\n}\n\nint process(int x, int back)\n{\n  int i, a;\n  //debug(x,back);\n  if(cnt >= limit)return 0;\n  if(check() == 1)return 1;\n\n  switch(x){\n    /*\n    case 0:\n    printf(\"x = %d, back = %d\\n\",x,back);\n    if(back != 1)\n    {\n      change1(0,1);\n      process(1,0);\n      change2(0,1);\n    }\n    if(back != 3)\n    {\n      change1(0,3);\n      process(1,0);\n      change2(0,3);\n    }\n    return 0;\n    */\n    case 0:\n    if(back != 1 && data[x] == 0)\n    {\n      change1(0,1);\n      process(1,0);\n      change2(0,1);\n    }\n    if(back != 3 && data[x] == 0)\n    {\n      change1(0,3);\n      process(3,0);\n      change2(0,3);\n    }\n    return 0;\n\n    case 1:\n    //if(cnt == 1)printf(\"x = %d, back = %d\\n\",x,back);\n    if(back != 0 && data[x] == 0)\n    {\n      change1(1,0);\n      process(0,1);\n      change2(1,0);\n    }\n    if(back != 2 && data[x] == 0)\n    {\n      change1(1,2);\n      process(2,1);\n      change2(1,2);\n    }\n    if(back != 4 && data[x] == 0)\n    {\n      change1(1,4);\n      process(4,1);\n      change2(1,4);\n    }\n    return 0;\n\n    case 2:\n    if(back != 1 && data[x] == 0)\n    {\n      change1(2,1);\n      process(1,2);\n      change2(2,1);\n    }\n    if(back != 5 && data[x] == 0)\n    {\n      change1(2,5);\n      process(5,2);\n      change2(2,5);\n    }\n    return 0;\n\n    case 3:\n    if(back != 0 && data[x] == 0)\n    {\n      change1(3,0);\n      process(0,3);\n      change2(3,0);\n    }\n    if(back != 4 && data[x] == 0)\n    {\n      change1(3,4);\n      process(4,3);\n      change2(3,4);\n    }\n    if(back != 6 && data[x] == 0)\n    {\n      change1(3,6);\n      process(6,3);\n      change2(3,6);\n    }\n    return 0;\n\n    case 4:\n    if(back != 1 && data[x] == 0)\n    {\n      change1(4,1);\n      process(1,4);\n      change2(4,1);\n    }\n    if(back != 3 && data[x] == 0)\n    {\n      change1(4,3);\n      process(3,4);\n      change2(4,3);\n    }\n    if(back != 5 && data[x] == 0)\n    {\n      change1(4,5);\n      process(5,4);\n      change2(5,4);\n    }\n    if(back != 7 && data[x] == 0)\n    {\n      change1(4,7);\n      process(7,4);\n      change2(4,7);\n    }\n    return 0;\n\n    case 5:\n    if(back != 2 && data[x] == 0)\n    {\n      change1(5,2);\n      process(2,5);\n      change2(5,2);\n    }\n    if(back != 4 && data[x] == 0)\n    {\n      change1(5,4);\n      process(4,5);\n      change2(5,4);\n    }\n    if(back != 8 && data[x] == 0)\n    {\n      change1(5,8);\n      process(8,5);\n      change2(5,8);\n    }\n    return 0;\n\n    case 6:\n    if(back != 3 && data[x] == 0)\n    {\n      change1(6,3);\n      process(3,6);\n      change2(6,3);\n    }\n    if(back != 7 && data[x] == 0)\n    {\n      change1(6,7);\n      process(7,6);\n      change2(6,7);\n    }\n    return 0;\n\n    case 7:\n    if(back != 4 && data[x] == 0)\n    {\n      change1(7,4);\n      process(4,7);\n      change2(7,4);\n    }\n    if(back != 6 && data[x] == 0)\n    {\n      change1(7,6);\n      process(6,7);\n      change2(7,6);\n    }\n    if(back != 8 && data[x] == 0)\n    {\n      change1(7,8);\n      process(8,7);\n      change2(7,8);\n    }\n    return 0;\n\n    case 8:\n    if(back != 5 && data[x] == 0)\n    {\n      change1(8,5);\n      process(5,8);\n      change2(8,5);\n    }\n    if(back != 7 && data[x] == 0)\n    {\n      change1(8,7);\n      process(7,8);\n      change2(8,7);\n    }\n    return 0;\n  }\n  return 0;\n}\n\nvoid change1(int x, int y)\n{\n  int temp;\n  cnt++;\n  temp = data[x];\n  data[x] = data[y];\n  data[y] = temp;\n}\n\nvoid change2(int x, int y)\n{\n  int temp;\n  cnt--;\n  temp = data[x];\n  data[x] = data[y];\n  data[y] = temp;\n}\n\n\nint check()\n{\n  int i;\n  for(i = 0; i < 8; i++)\n  {\n    if(data[i] != i + 1)return 0;\n  }\n  limit = cnt;\n  return 1;\n}\n\nvoid debug(int x, int back)\n{\n  int i;\n  if(cnt == 1)printf(\"--------------------------------\\n\\n\\n\\n\");\n  printf(\"cnt = %2d || limit = %2d || x:%d  back:%d ||%d → %d\\n\",cnt,limit,x,back,back,x);\n  for(i = 0; i < 9; i++)\n  {\n    printf(\"%d \",data[i]);\n    if(i % 3 == 2)printf(\"\\n\");\n  }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n \nchar *flag;\nint head,rear;\nint *que;\nint factorial[10];\n \nint cal_factorial(int n) {\n  if(n == 0) return 1;\n  return cal_factorial(n-1)*n;\n}\n \nint stotag(char *s) {\n  int tag = 0;\n  int i;\n  for(i = 0; i < 9; i++) {\n    int t,j;\n    t = 0;\n    for(j = 0; j < i; j++) {\n      if(s[j] < s[i]) t++;\n    }\n    tag += factorial[8-i]*(s[i]-'0'-t);\n  }\n  return tag;\n}\n \nchar *tagtos(int tag) {\n  int i;\n  char *s;\n  s = (char*)malloc(sizeof(char)*10);\n  for(i = 0; i < 9; i++) {\n    s[i] = tag%factorial[9-i]/factorial[8-i] + '0';\n  }\n  s[9] = '\\0';\n  for(i = 7; i >= 0; i--) {\n    int j;\n    for(j = 8; j > i; j--) {\n      if(s[i] <= s[j]) s[j]++;\n    }\n  }\n  return s;\n}\n \n \nchar *move_up(char s[], int x) {\n  if(x < 3) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-3];\n  s_new[x-3] = s[x];\n  return s_new;\n}\n \nchar *move_left(char s[], int x) {\n  if(x%3 == 0) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-1];\n  s_new[x-1] = s[x];\n  return s_new;\n}\n \nchar *move_right(char s[], int x) {\n  if(x%3 == 2) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+1];\n  s_new[x+1] = s[x];\n  return s_new;\n}\n \nchar *move_down(char s[], int x) {\n  if(x > 5) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+3];\n  s_new[x+3] = s[x];\n  return s_new;\n}\n \nint create(char s[], int t) {\n  if(strcmp(s,\"123456780\") == 0) return t;\n  int tag = stotag(s);\n  if(flag[tag]) return 0;\n  flag[tag] = t;\n  que[rear] = tag;\n  rear++;\n  return 0;\n}\n \nint check_x(char *s) {\n  int i = 0;\n  while(s[i] != '0') i++;\n  return i;\n}\n \nint cal() {\n  char *s_right,*s_left,*s_up,*s_down;\n  int k,tag;\n \n  tag = que[head];\n  char *s = tagtos(tag);\n  int x = check_x(s);\n   \n  if((s_right = move_right(s, x)) != NULL) {\n    if((k = create(s_right,flag[tag]+1))) return k;\n    free(s_right);\n  }\n  if((s_left = move_left(s, x)) != NULL) {\n     if((k = create(s_left,flag[tag]+1))) return k;\n     free(s_left);\n  }\n  if ((s_up = move_up(s, x)) != NULL) {\n    if((k = create(s_up,flag[tag]+1))) return k;\n    free(s_up);\n  }\n  if((s_down = move_down(s, x)) != NULL) {\n    if((k = create(s_down,flag[tag]+1))) return k;\n    free(s_down);\n  }\n  free(s);\n  head++;\n  return 0;\n}\n   \n \nint solve(char s0[]) {\n  int k;\n  if((k = create(s0,1))) return k;\n   \n  while(!(k = cal())) {\n    if(head == rear) break;\n  }\n  return k;\n}\n \nint main()\n{\n \n  int i,d;\n  char s[10];\n  for(i = 0; i < 10; i++) factorial[i] = cal_factorial(i);\n  flag = (char*)malloc(sizeof(char)*factorial[9]);\n  memset(flag , 0, factorial[9]);\n  que = (int*)malloc(sizeof(int)*factorial[9]);\n  head = 0;\n  rear = 0;\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &d);\n    s[i] = d+'0';\n  }\n  s[9] = '\\0';\n  printf(\"%d\\n\",solve(s)-1);\n   \n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\n\n#define N 3\n#define true 1\n#define false 0\n\n\nint x[4]={0,-1,0,1};\nint y[4]={1,0,-1,0};\nint l;\nint w[N][N];\n\n\nvoid swap(int *,int *);\nint abc();\nint dfs(int,int,int,int);\nvoid Solved(int,int);\n\nint main()\n{\n  int i,j,ax,ay;\n   \n   for(i=0;i<N;i++){\n     for(j=0;j<N;j++){\n       scanf(\"%d\",&w[i][j]);\n        if(w[i][j]==0){\n\t  ay=i;\n\t    ax=j;\n\t}\n        }\n   }\n     \n   Solved(ay,ax);\n     \n     return 0;\n}\n\n\nvoid swap(int *s,int *t)\n{\n  int tmp=*s;\n  \n  *s=*t;\n  *t=tmp;\n  \n  return ;\n}\n\n\nint abc()\n{\n  int i,j,s=0,r;\n  \n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n    if(w[i][j]==0)continue;\n    r=w[i][j]-1;\n    \n    s+=abs(r/N-i)+abs(r%N-j);\n    \n    }\n  }\n  \n  return s;\n}\n\n\nint dfs(int d,int p,int ay,int ax)\n{\n  int i,m=abc();\n  \n  if(m==0)return true;\n  \n  if(d+m>l)return false;\n  \n  for(i=0;i<4;i++){\n    if(abs(i-p)==2)continue;\n    \n    int tx=ax+x[i],ty=ay+y[i];\n    \n    if(tx<0||ty<0||tx>=N||ty>=N)continue;\n    \n    swap(&w[ty][tx],&w[ay][ax]);\n    \n    if(dfs(d+1,i,ty,tx))return true;\n    \n    swap(&w[ty][tx],&w[ay][ax]);\n  }\n  \n  return false;\n}\n\n\nvoid Solved(int ay,int ax)\n{\n  for(l=0;;l++){\n    if(dfs(0,99,ay,ax)){\n      printf(\"%d\\n\",l);\n      return ;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n   \nint mas[3][3];\nint cpy[3][3];\n  \n   \nint main() {\n  input();\n  printf(\"%d\\n\", solve());\n  return 0;\n}\nvoid input() {\n  int i, j;\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++)\n      scanf(\"%d\", &mas[i][j]);\n}\n   \nvoid output() {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n    puts(\"\");\n  }\n}\n   \nvoid copy(int m[3][3], int t[3][3]) {\n  int i, j;\n   \n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n   \nint calc() {\n  int i, sum = 0;\n  for(i = 0; i < 9; i++) {\n    int v = mas[i/3][i%3];\n    if(v) {\n      v--;\n      sum += abs(i/3-v/3)+abs(i%3-v%3);\n    }\n  }\n  return sum;\n}\n   \nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n   \nvoid swap(int *a, int *b) {\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n   \nint is_in(int x, int y) {\n  return 0<=x&&x<3&&0<=y&&y<3;\n}\n   \nint dfs(int x, int y, int p, int dep, const int lim) {\n  int i, h = calc();\n  //output();\n  if(h == 0) return dep;\n  //printf(\"%d %d %d\\n\", h, lim, p);\n  if(dep+h > lim) return -1;\n   \n  for(i = 0; i < 4; i++) {\n    int nx = x+dx[i], ny = y+dy[i], res;\n    if(~p && i == (p+2)%4) continue;\n    if(!is_in(nx, ny)) continue;\n    swap(&mas[y][x], &mas[ny][nx]);\n    res = dfs(nx, ny, i, dep+1, lim);\n    if(~res) return res;\n    swap(&mas[y][x], &mas[ny][nx]);\n  }\n   \n  return -1;\n}\n   \nvoid get_empty(int *x, int *y) {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) {\n      if(!mas[i][j]) {\n    *x = j;\n    *y = i;\n    return;\n      }\n    }\n  }\n}\n   \nint solve() {\n  int x, y, lim, ans;\n  get_empty(&x, &y);\n  for(lim = 0; lim < 50; lim++) {\n    copy(cpy, mas);\n    if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n    copy(mas, cpy);\n  }\n  return -1;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n\nextern inline void down_0(void);\nextern inline void up_0(void);\nextern inline void right_0(void);\nextern inline void left_0(void);\n\nextern int  serch(int x, int y, int MaxCnt, int pre);\nextern int  check(void);\n\nint cnt,num = 0;\nint val[Total] ={};\n\n\nint main( void )\n{\n    int i = 0;\n    int x,y = 0;\n    \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        \n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n    \n    x = tate - (num/yoko) -1;\n    y = yoko - (num%yoko) -1;\n    \n    for(i=1; i<31; i++)\n    {\n        if( serch(x,y,i,4) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt, int pre)\n{\n    int result;\n    int i=0;\n    \n    // 最大数で打ち切り\n    if(MaxCnt==0)\n    {\n        return check();\n    }\n    \n    // 上下左右で4回回す\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if( (x > 0) && (pre != 3) )\n                {\n                    down_0();\n                    \n                    result = serch(x-1, y, MaxCnt-1, 0);\n                    \n                    up_0();\n                }\n                break;\n            case 1:\n                if( (y > 0) && (pre != 2) )\n                {\n                    right_0();\n                    \n                    result = serch(x, y-1, MaxCnt-1, 1);\n                    \n                    left_0();\n                }\n                break;\n            case 2:\n                if( (y < yoko) && (pre != 1) )\n                {\n                    left_0();\n                    \n                    result = serch(x, y+1, MaxCnt-1, 2);\n                    \n                    right_0();\n                }\n                break;\n            case 3:\n                if( (x < tate) && (pre != 0) )\n                {\n                    up_0();\n                    \n                    result = serch(x+1, y, MaxCnt-1, 3);\n                    \n                    down_0();\n                }\n                break;\n            default:\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n        \n    }\n\n    return 0;\n}\n\n// TRUE : 完成\n// FALSE : 失敗\nint check()\n{\n    int i=0;\n    \n//    printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);\n    \n    for(i=0; i<Total-1; i++)\n    {\n        if(val[i] != (i+1))\n        {\n            return 0;\n        }\n    }\n    return 1;\n}\n\ninline void down_0()\n{\n    val[num] = val[num + yoko];\n    num = num + yoko;\n}\n \ninline void up_0()\n{\n    val[num] = val[num - yoko];\n    num = num - yoko;\n}\n \ninline void right_0()\n{\n    val[num] = val[num +1];\n    num = num + 1;\n}\n \ninline void left_0()\n{\n    val[num] = val[num -1];\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint A[10];\nint fa[10]={1,1,2,6,24,120,720,5040,40320};\n\nint DP[362880];\nvoid swap(int i,int j){\n  int t=A[i];\n  A[i]=A[j];\n  A[j]=t;\n}\n\nint F(){\n  int ans=0,b=0;\n  for(int i=8;i>=0;i--){\n    ans+=__builtin_popcount(b&((1<<A[i])-1))*fa[8-i];\n    b|=1<<A[i];\n  }\n  return ans;\n}\nvoid G(int n){\n  int b=0;\n  for(int i=0;i<9;i++)A[i]=i;\n  for(int i=0;i<9;i++){\n    int x=n/fa[8-i];\n    n%=fa[8-i];\n    for(int j=x;j>0;j--)swap(i+j,i+j-1);\n  }\n}\n\nint que[363000],quecnt;\nvoid ck(int p,int k){\n  int x=F();\n  if(!DP[x]){\n    DP[x]=k+1;\n    que[quecnt++]=x*10+p;\n  }\n}\nint calc(){\n  for(int i=0;i<quecnt;i++){\n    int x=que[i]/10;\n    int p=que[i]%10;\n    if(x==0)return DP[x]-1;\n    G(x);\n    if(p<6)swap(p,p+3),ck(p+3,DP[x]),swap(p,p+3);\n    if(p>2)swap(p,p-3),ck(p-3,DP[x]),swap(p,p-3);\n    if(p%3<2)swap(p,p+1),ck(p+1,DP[x]),swap(p,p+1);\n    if(p%3>0)swap(p,p-1),ck(p-1,DP[x]),swap(p,p-1);\n  }\n  return -1;\n}\n\nint main(){\n  int p;\n  for(int i=0;i<9;i++){\n    int t;\n    scanf(\"%d\",&t);\n    if(t)A[i]=t-1;\n    else{\n      A[i]=8;\n      p=i;\n    }\n  }\n  ck(p,0);\n  printf(\"%d\\n\",calc());\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \nint puzzle[3][3];\nint temp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n \nvoid empty(int *,int *);\nint dfs(int,int,int,int,const int);\nint cal();\nvoid swap(int *,int *);\n \nint main() {\n  int i,j,ans,x,y,l;\n  for(i=0;i<3;i++) {\n    for(j=0;j<3;j++) scanf(\"%d\",&puzzle[i][j]);\n  }\n     \n  empty(&x,&y);\n  for(l=0;l<100;l++) {\n       \n    for(i=0;i<3;i++) {\n      for(j=0;j<3;j++) temp[i][j]=puzzle[i][j];\n    }\n    ans = dfs(x,y,-1,0,l);\n    if(ans!=-1) {\n      printf(\"%d\\n\",ans);\n      break;\n    }\n \n    for(i=0;i<3;i++) {\n      for(j=0;j<3;j++) puzzle[i][j] = temp[i][j];\n    }\n    ans = -1;\n    if(l==99) printf(\"%d\\n\",ans);\n  }    \n  return 0;\n}\n \n \nvoid empty(int *x,int *y) {\n  int i,j;\n  for(i=0;i<3;i++) {\n    for(j=0;j<3;j++) {\n      if(!puzzle[i][j]) {\n\t*x = j;\n\t*y = i;\n\treturn;\n      }\n    }\n  }\n}\n \n \nvoid swap(int *a,int *b) {\n  int temp;\n     \n  temp=*a;\n  *a=*b;\n  *b=temp;\n}\n \n \nint cal(){\n  int i,a,sum=0;\n     \n  for(i=0;i<9;i++) {\n    a=puzzle[i/3][i%3];\n    if(a) {\n      a--;\n      sum+=abs(i/3-a/3)+abs(i%3-a%3);\n    }\n  }\n     \n  return sum;\n}\n \n \nint dfs(int x,int y,int p,int dep,const int lim) {\n  int i,h,nx,ny,res;\n     \n  h = cal();\n  if(h==0) return dep;\n  if(dep+h>lim) return -1;\n     \n  for(i=0;i<4;i++) {\n    nx=x+dx[i];\n    ny=y+dy[i];\n         \n    if(~p&&i==(p+2)%4) continue;\n    if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n         \n    swap(&puzzle[y][x],&puzzle[ny][nx]);\n    res = dfs(nx,ny,i,dep+1,lim);\n    if(~res) return res;\n         \n    swap(&puzzle[y][x],&puzzle[ny][nx]);\n  }\n     \n  return -1;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint mas[3][3];\nint cpy[3][3];\n\nvoid input() {\n  int i, j;\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++)\n      scanf(\"%d\", &mas[i][j]);\n}\n\nvoid output() {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n    puts(\"\");\n  }\n}\n\nvoid copy(int m[3][3], int t[3][3]) {\n  int i, j;\n\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n\nint calc() {\n  int i, sum = 0;\n  for(i = 0; i < 9; i++) {\n    int v = mas[i/3][i%3];\n    if(v) {\n      v--;\n      sum += abs(i/3-v/3)+abs(i%3-v%3);\n    }\n  }\n  return sum;\n}\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nvoid swap(int *a, int *b) {\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nint is_in(int x, int y) {\n  return 0<=x&&x<3&&0<=y&&y<3;\n}\n\nint dfs(int x, int y, int p, int dep, const int lim) {\n  int i, h = calc();\n  if(h == 0) return dep;\n  if(dep+h > lim) return -1;\n\n  for(i = 0; i < 4; i++) {\n    int nx = x+dx[i], ny = y+dy[i], res;\n    if(~p && i == (p+2)%4) continue;\n    if(!is_in(nx, ny)) continue;\n    swap(&mas[y][x], &mas[ny][nx]);\n    res = dfs(nx, ny, i, dep+1, lim);\n    if(~res) return res;\n    swap(&mas[y][x], &mas[ny][nx]);\n  }\n\n  return -1;\n}\n\nvoid get_empty(int *x, int *y) {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) {\n      if(!mas[i][j]) {\n    *x = j;\n    *y = i;\n    return;\n      }\n    }\n  }\n}\n\nint solve() {\n  int x, y, lim, ans;\n  get_empty(&x, &y);\n  for(lim = 0; lim < 50; lim++) {\n    copy(cpy, mas);\n    if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n    copy(mas, cpy);\n  }\n  return -1;\n}\n\nint main() {\n  input();\n  printf(\"%d\\n\", solve());\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\ntypedef char Board[10];\nconst Board ini_board = \"130425786\";\nBoard board = \"130425786\";\nconst Board target = \"123456780\";\nBoard *history;\nint nhistories=0;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nint minstep = INT_MAX;\n\nconst Motion candidate[9][5] = \n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nint move(Motion m)\n{\n  if (board[m.pos]==target[m.pos]) return -1;\n  switch (m.dir) {\n  case U:\n    if (m.pos<3) return -1;\n    board[m.pos-3] = board[m.pos];\n    break;\n  case D:\n    if (m.pos>5) return -1;\n    board[m.pos+3] = board[m.pos];\n    break;\n  case L:\n    if (m.pos%3==0) return -1;\n    board[m.pos-1] = board[m.pos];\n    break;\n  case R:\n    if (m.pos%3==2) return -1;\n    board[m.pos+1] = board[m.pos];\n    break;\n  }\n  board[m.pos] = '0';\n  return m.pos;\n}\n\nvoid search_path(int step, int space)\n{\n  int i, j;\n  if (strcmp(board, \"123456780\")==0) {\n    //    printf(\"STEP=%d\\n\", step);\n    if (step<minstep) minstep=step;\n    \n  } else {\n\n    int s2;\n    if (step>=minstep) return;\n    if (step>0 && strcmp(board, ini_board)==0) return;\n    \n    Board board_bak;\n    strcpy(board_bak, board);\n    int nhistories_bak=nhistories;\n\n    for (i=0; candidate[space][i].pos>=0; i++) {\n\n      if ((s2 = move(candidate[space][i]))<0) continue;\n      for (j=0; j<nhistories; j++) {\n\tif (strcmp(board, history[j])==0)\n\t  break;// goto next;\n      }\n      if (j==nhistories) {\n\tstrcpy(history[nhistories++], board); \n\tsearch_path(step+1, s2);\n      }\n      //    next:\n      nhistories = nhistories_bak;\n      strcpy(board, board_bak);\n    }\n  }\n}\n\nint main()\n{\n  history = (Board*)malloc(sizeof(Board)*100000);\n  search_path(0, 2);\n  printf(\"%d\\n\", minstep);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n \nchar *flag;\nint head,rear;\nint *que;\nint factorial[10];\n \nint cal_factorial(int n) {\n  if(n == 0) return 1;\n  return cal_factorial(n-1)*n;\n}\n \nint stotag(char *s) {\n  int tag = 0;\n  int i;\n  for(i = 0; i < 9; i++) {\n    int t,j;\n    t = 0;\n    for(j = 0; j < i; j++) {\n      if(s[j] < s[i]) t++;\n    }\n    tag += factorial[8-i]*(s[i]-'0'-t);\n  }\n  return tag;\n}\n \nchar *tagtos(int tag) {\n  int i;\n  char *s;\n  s = (char*)malloc(sizeof(char)*10);\n  for(i = 0; i < 9; i++) {\n    s[i] = tag%factorial[9-i]/factorial[8-i] + '0';\n  }\n  s[9] = '\\0';\n  for(i = 7; i >= 0; i--) {\n    int j;\n    for(j = 8; j > i; j--) {\n      if(s[i] <= s[j]) s[j]++;\n    }\n  }\n  return s;\n}\n \n \nchar *move_up(char s[], int x) {\n  if(x < 3) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-3];\n  s_new[x-3] = s[x];\n  return s_new;\n}\n \nchar *move_left(char s[], int x) {\n  if(x%3 == 0) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-1];\n  s_new[x-1] = s[x];\n  return s_new;\n}\n \nchar *move_right(char s[], int x) {\n  if(x%3 == 2) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+1];\n  s_new[x+1] = s[x];\n  return s_new;\n}\n \nchar *move_down(char s[], int x) {\n  if(x > 5) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+3];\n  s_new[x+3] = s[x];\n  return s_new;\n}\n \nint create(char s[], int t) {\n  if(strcmp(s,\"123456780\") == 0) return t;\n  int tag = stotag(s);\n  if(flag[tag]) return 0;\n  flag[tag] = t;\n  que[rear] = tag;\n  rear++;\n  return 0;\n}\n \nint check_x(char *s) {\n  int i = 0;\n  while(s[i] != '0') i++;\n  return i;\n}\n \nint cal() {\n  char *s_right,*s_left,*s_up,*s_down;\n  int k,tag;\n \n  tag = que[head];\n  char *s = tagtos(tag);\n  int x = check_x(s);\n   \n  if((s_right = move_right(s, x)) != NULL) {\n    if((k = create(s_right,flag[tag]+1))) return k;\n    free(s_right);\n  }\n  if((s_left = move_left(s, x)) != NULL) {\n     if((k = create(s_left,flag[tag]+1))) return k;\n     free(s_left);\n  }\n  if ((s_up = move_up(s, x)) != NULL) {\n    if((k = create(s_up,flag[tag]+1))) return k;\n    free(s_up);\n  }\n  if((s_down = move_down(s, x)) != NULL) {\n    if((k = create(s_down,flag[tag]+1))) return k;\n    free(s_down);\n  }\n  free(s);\n  head++;\n  return 0;\n}\n   \n \nint solve(char s0[]) {\n  int k;\n  if((k = create(s0,1))) return k;\n   \n  while(!(k = cal())) {\n    if(head == rear) break;\n  }\n  return k;\n}\n \nint main()\n{\n \n  int i,d;\n  char s[10];\n  for(i = 0; i < 10; i++) factorial[i] = cal_factorial(i);\n  flag = (char*)malloc(sizeof(char)*factorial[9]);\n  memset(flag , 0, factorial[9]);\n  que = (int*)malloc(sizeof(int)*factorial[9]);\n  head = 0;\n  rear = 0;\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &d);\n    s[i] = d+'0';\n  }\n  s[9] = '\\0';\n  printf(\"%d\\n\",solve(s)-1);\n   \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\nchar * VAR00 ;\nint VAR01 , VAR02 ;\nint * VAR03 ;\nint VAR04 [ 10 ] ;\n\nint FUNC00 ( int ARG00 ) {\n  if ( ARG00 == 0 ) return 1 ;\n  return FUNC00 ( ARG00 - 1 ) * ARG00 ;\n}\n\nint FUNC01 ( char * ARG01 ) {\n  int VAR05 = 0 ;\n  int VAR06 ;\n  for ( VAR06 = 0 ; VAR06 < 9 ; VAR06 ++ ) {\n    int VAR07 , VAR08 ;\n    VAR07 = 0 ;\n    for ( VAR08 = 0 ; VAR08 < VAR06 ; VAR08 ++ ) {\n      if ( ARG01 [ VAR08 ] < ARG01 [ VAR06 ] ) VAR07 ++ ;\n    }\n    VAR05 += VAR04 [ 8 - VAR06 ] * ( ARG01 [ VAR06 ] - '0' - VAR07 ) ;\n  }\n  return VAR05 ;\n}\n\nchar * FUNC02 ( int ARG02 ) {\n  int VAR09 ;\n  char * VAR10 ;\n  VAR10 = ( char * ) malloc ( sizeof ( char ) * 10 ) ;\n  for ( VAR09 = 0 ; VAR09 < 9 ; VAR09 ++ ) {\n    VAR10 [ VAR09 ] = ARG02 % VAR04 [ 9 - VAR09 ] / VAR04 [ 8 - VAR09 ] + '0' ;\n  }\n  VAR10 [ 9 ] = '\\0' ;\n  for ( VAR09 = 7 ; VAR09 >= 0 ; VAR09 -- ) {\n    int VAR11 ;\n    for ( VAR11 = 8 ; VAR11 > VAR09 ; VAR11 -- ) {\n      if ( VAR10 [ VAR09 ] <= VAR10 [ VAR11 ] ) VAR10 [ VAR11 ] ++ ;\n    }\n  }\n  return VAR10 ;\n}\n\n\nchar * FUNC03 ( char ARG03 [ ] , int ARG04 ) {\n  if ( ARG04 < 3 ) return NULL ;\n  char * VAR12 ;\n  VAR12 = ( char * ) malloc ( sizeof ( char ) * 10 ) ;\n  strcpy ( VAR12 , ARG03 ) ;\n  VAR12 [ ARG04 ] = ARG03 [ ARG04 - 3 ] ;\n  VAR12 [ ARG04 - 3 ] = ARG03 [ ARG04 ] ;\n  return VAR12 ;\n}\n\nchar * FUNC04 ( char ARG05 [ ] , int ARG06 ) {\n  if ( ARG06 % 3 == 0 ) return NULL ;\n  char * VAR13 ;\n  VAR13 = ( char * ) malloc ( sizeof ( char ) * 10 ) ;\n  strcpy ( VAR13 , ARG05 ) ;\n  VAR13 [ ARG06 ] = ARG05 [ ARG06 - 1 ] ;\n  VAR13 [ ARG06 - 1 ] = ARG05 [ ARG06 ] ;\n  return VAR13 ;\n}\n\nchar * FUNC05 ( char ARG07 [ ] , int ARG08 ) {\n  if ( ARG08 % 3 == 2 ) return NULL ;\n  char * VAR14 ;\n  VAR14 = ( char * ) malloc ( sizeof ( char ) * 10 ) ;\n  strcpy ( VAR14 , ARG07 ) ;\n  VAR14 [ ARG08 ] = ARG07 [ ARG08 + 1 ] ;\n  VAR14 [ ARG08 + 1 ] = ARG07 [ ARG08 ] ;\n  return VAR14 ;\n}\n\nchar * FUNC06 ( char ARG09 [ ] , int ARG10 ) {\n  if ( ARG10 > 5 ) return NULL ;\n  char * VAR15 ;\n  VAR15 = ( char * ) malloc ( sizeof ( char ) * 10 ) ;\n  strcpy ( VAR15 , ARG09 ) ;\n  VAR15 [ ARG10 ] = ARG09 [ ARG10 + 3 ] ;\n  VAR15 [ ARG10 + 3 ] = ARG09 [ ARG10 ] ;\n  return VAR15 ;\n}\n\nint FUNC07 ( char ARG11 [ ] , int ARG12 ) {\n  if ( strcmp ( ARG11 , \"123456780\" ) == 0 ) return ARG12 ;\n  int VAR16 = FUNC01 ( ARG11 ) ;\n  if ( VAR00 [ VAR16 ] ) return 0 ;\n  VAR00 [ VAR16 ] = ARG12 ;\n  VAR03 [ VAR02 ] = VAR16 ;\n  VAR02 ++ ;\n  return 0 ;\n}\n\nint FUNC08 ( char * ARG13 ) {\n  int VAR17 = 0 ;\n  while ( ARG13 [ VAR17 ] != '0' ) VAR17 ++ ;\n  return VAR17 ;\n}\n\nint FUNC09 ( ) {\n  char * VAR18 , * VAR19 , * VAR20 , * VAR21 ;\n  int VAR22 , VAR23 ;\n\n  VAR23 = VAR03 [ VAR01 ] ;\n  char * VAR24 = FUNC02 ( VAR23 ) ;\n  int VAR25 = FUNC08 ( VAR24 ) ;\n\n  if ( ( VAR18 = FUNC05 ( VAR24 , VAR25 ) ) != NULL ) {\n    if ( ( VAR22 = FUNC07 ( VAR18 , VAR00 [ VAR23 ] + 1 ) ) ) return VAR22 ;\n    free ( VAR18 ) ;\n  }\n  if ( ( VAR19 = FUNC04 ( VAR24 , VAR25 ) ) != NULL ) {\n     if ( ( VAR22 = FUNC07 ( VAR19 , VAR00 [ VAR23 ] + 1 ) ) ) return VAR22 ;\n     free ( VAR19 ) ;\n  }\n  if ( ( VAR20 = FUNC03 ( VAR24 , VAR25 ) ) != NULL ) {\n    if ( ( VAR22 = FUNC07 ( VAR20 , VAR00 [ VAR23 ] + 1 ) ) ) return VAR22 ;\n    free ( VAR20 ) ;\n  }\n  if ( ( VAR21 = FUNC06 ( VAR24 , VAR25 ) ) != NULL ) {\n    if ( ( VAR22 = FUNC07 ( VAR21 , VAR00 [ VAR23 ] + 1 ) ) ) return VAR22 ;\n    free ( VAR21 ) ;\n  }\n  free ( VAR24 ) ;\n  VAR01 ++ ;\n  return 0 ;\n}\n\n\nint FUNC10 ( char ARG14 [ ] ) {\n  int VAR26 ;\n  if ( ( VAR26 = FUNC07 ( ARG14 , 1 ) ) ) return VAR26 ;\n\n  while ( ! ( VAR26 = FUNC09 ( ) ) ) {\n    if ( VAR01 == VAR02 ) break ;\n  }\n  return VAR26 ;\n}\n\nint main ( )\n{\n\n  int VAR27 , VAR28 ;\n  char VAR29 [ 10 ] ;\n  for ( VAR27 = 0 ; VAR27 < 10 ; VAR27 ++ ) VAR04 [ VAR27 ] = FUNC00 ( VAR27 ) ;\n  VAR00 = ( char * ) malloc ( sizeof ( char ) * VAR04 [ 9 ] ) ;\n  memset ( VAR00 , 0 , VAR04 [ 9 ] ) ;\n  VAR03 = ( int * ) malloc ( sizeof ( int ) * VAR04 [ 9 ] ) ;\n  VAR01 = 0 ;\n  VAR02 = 0 ;\n  for ( VAR27 = 0 ; VAR27 < 9 ; VAR27 ++ ) {\n    scanf ( \"%d\" , & VAR28 ) ;\n    VAR29 [ VAR27 ] = VAR28 + '0' ;\n  }\n  VAR29 [ 9 ] = '\\0' ;\n  printf ( \"%d\\n\" , FUNC10 ( VAR29 ) - 1 ) ;\n\n  return 0 ;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n\n#define MAX 362880\n#define N 3\n#define N2 9\n\ntypedef struct puzzle{\n  int f[N2];\n  int space;\n  int path;\n}puzzle;\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\n\npuzzle Q[MAX];\nint head, tail, V[MAX];\n\nint empty()\n{\n  return head == tail;\n}\n\nvoid enqueue(puzzle x)\n{\n  Q[tail] = x;\n  tail = (tail+1)%MAX;\n}\n\npuzzle front()\n{\n  puzzle x;\n\n  x = Q[head];\n  head = (head+1)%MAX;\n\n  return x;\t\n}\n\nint cheak(puzzle p)\n{\n  int i, j, fac, count, res = 0;\n\n  for(i = 0, fac = 1; i < N2; fac*= ++i){\n    for(j = 0, count = 0; j < i; j++)\n      if(p.f[j] < p.f[i])\n\tcount++;\n    res += count*fac;\n  }\n\t\n  return res;\t\n}\n\nint isTarget(puzzle p)\n{\n  int i;\n\n  for (i = 0; i < N2; i++)\n    if(p.f[i] != (i + 1))\n      return 0;\n  return 1;\n}\n\nint bfs(puzzle s)\n{\n  int sx, sy, tx, ty, r, temp;\n  puzzle u, v;\n\t\n  s.path = 0;\n  enqueue(s);\n  V[cheak(s)] = 1;\n  while(!empty()){\n    u = front();\n    if( isTarget(u))\n      return u.path;\n    sx = u.space / N;\n    sy = u.space % N;\n    for (r = 0; r < 4; r++){\n      tx = sx + dx[r];\n      ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N)\n\tcontinue;\n      v = u;\t\t\n      temp = v.f[u.space];\n      v.f[u.space] = v.f[tx * N + ty];\n      v.f[tx * N + ty] = temp;\t\n      v.space = tx * N + ty;\n      if(!V[cheak(v)]){\n\tV[cheak(v)] = 1;\n\tv.path++;\n\tenqueue(v);\n      }\n    }\n  }\n\t\n  return -1;\n}\n\nint main()\n{\n  int i, a;\n  puzzle p;\n\t\n  for(i = 0; i < N2; i++){\n    scanf(\"%d\", &p.f[i]);\n    if( p.f[i] == 0){\n      p.f[i] = N2;\n      p.space = i;\n    }\n  }\n\t\n  a = bfs(p);\n  printf(\"%d\\n\",a);\n\t\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n int puzle[3][3];\n int tmp[3][3;\n int d1[4]={0,1,0,-1};\n int d2[4]={1,0,-1,0};\n \n void empty(int *x,int *y){\n                           int i,j;\n                           for(i=0;i<3;i++){\n                                            for(j=0;j<3;j++){\n                                                             if(!puzle[i][j]){\n                                                                              *x=j;\n                                                                              *y=i;\n                                                                              return;\n                                                                              }\n                                                              }\n                                             }\n                            }\n\n void swap(int *a,int *b){\n                          int tmp=*a;\n                          *a=*b;\n                          *b=tmp;\n                          }\n\n int cal(){\n           int a,i,sum=0;\n           for(i=0;i<9;i++){\n                            a=puzle[i/3][i%3];\n                            if(a){\n                                  a--;\n                                  sum+=abs(i/3-a/3)+abs(i%3-a%3);\n                                  }\n                            }\n           return sum;\n           }\n\n int dfs(int x,int y,int p,int dep,const int lim){\n       int i,h,n1,n2,res;\n       h=cal();\n       if(h==0){\n                return dep;\n                }\n       if(dep+h>lim){\n                     return -1;\n                     }\n       for(i=0;i<4;++i){\n                        n1=x+d1[i];\n                        n2=y+d2[i];\n \n                        if(~p&&i==(p+2)%4)continue;\n                        if(!(0<=n1&&n1<3&&0<=n2&&n2<3))continue;\n                        swap(&puzle[y][x],&puzle[n2][n1]);\n                        res=dfs(n1,n2,i,dep+1,lim);\n\n                        if(~res)return res;\n \n                        swap(&puzle[y][x],&puzle[n2][n1]);\n                        }\n       return -1; \n       }\n\n int main(){\n            int ans,x,y,l,i,j;\n\n            for(i=0;i<3;i++){\n                             for(j=0;j<3;j++){\n                                              scanf(\"%d\",&puzle[i][j]);\n                                              }\n                             }\n            empty(&x,&y);\n            for(l=0;l<100;l++){\n                               for(i=0;i<3;i++){\n                                                for(j=0;j<3;j++){\n                                                                 tmp[i][j]=puzle[i][j];\n                                                                 }\n                                                }\n                                ans=dfs(x,y,-1,0,1);\n                                if(ans!=-1){\n                                            printf(\"%d\\n\",ans);\n                                            break;\n                                            }\n                                for(i=0;i<3;i++){\n                                                 for(j=0;j<3;j++){\n                                                                  puzle[i][j]=tmp[i][j];\n                                                                  }\n                                                 }\n                                ans=-1;\n                                if(l==99)printf(\"%d\\n\",ans);\n                                }\n            return 0;\n            }\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n \n#define Ni 3\n \nint Pz[Ni][Ni],tmp[Ni][Ni];\nint Dx[4]={0,1,0,-1},Dy[4]={1,0,-1,0};\n \nvoid emblem(int *a,int *b){\n  int i,j;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(!Pz[i][j]){\n    *a = j;\n    *b=i;\n      }\n    }\n  }\n}\n \nvoid swap(int *a,int *b){\n  int tmp;\n  tmp =*a;\n  *a = *b;\n  *b = tmp;\n}\n \nint check(){\n  int i,A,S=0;\n  for(i=0;i<9;i++){\n    A = Pz[i/3][i%3];\n    if(A){\n      A--;\n      S += abs(i/3-A/3) + abs(i%3 - A%3);\n    }\n  }\n  return S;\n}\n \nint defain(int a,int b,int P,int D,const int shin){\n  int i,hi,A,B,result;\n  hi = check();\n  if(hi==0){\n    return D;\n  }\n  if(D+hi>shin){\n    return -1;\n  }\n \n  for(i=0;i<4;i++){\n    A = a+Dx[i];\n    B = b+Dy[i];\n    if(~P && i==(P+2)%4) {\n      continue;\n    }\n    if(!(0<=A && A<3 && 0<=B && B<3)){\n      continue;\n    }\n    swap(&Pz[b][a],&Pz[B][A]);\n    result = defain(A,B,i,D+1,shin);\n    if(~result){\n      return result;\n    }\n    swap(&Pz[b][a],&Pz[B][A]);\n  }\n  return -1;\n}\n \nint main(){\n  int i,j,li,TA,a,b;\n \n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&Pz[i][j]);\n    }\n  }\n \n  emblem(&a,&b);\n  for(li=0;li<100;li++){\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n    tmp[i][j]=Pz[i][j];\n      }\n    }\n    TA = defain(a,b,-1,0,li);\n    if(TA!=-1){\n      printf(\"%d\\n\",TA);\n      break;\n    }\n \n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n    Pz[i][j]=tmp[i][j];\n      }\n    }\n \n    TA = -1;\n    if(li==99){\n      printf(\"%d\\n\",TA);\n    }\n  }\n \n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n int puzle[3][3];\n int tmp[3][3];\n int d1[4]={0,1,0,-1};\n int d2[4]={1,0,-1,0};\n \n void empty(int *x,int *y){\n                           int i,j;\n                           for(i=0;i<3;i++){\n                                            for(j=0;j<3;j++){\n                                                             if(!puzle[i][j]){\n                                                                              *x=j;\n                                                                              *y=i;\n                                                                              return;\n                                                                              }\n                                                              }\n                                             }\n                            }\n\n void swap(int *a,int *b){\n                          int tmp=*a;\n                          *a=*b;\n                          *b=tmp;\n                          }\n\n int cal(){\n           int a,i,sum=0;\n           for(i=0;i<9;i++){\n                            a=puzle[i/3][i%3];\n                            if(a){\n                                  a--;\n                                  sum+=abs(i/3-a/3)+abs(i%3-a%3);\n                                  }\n                            }\n           return sum;\n           }\n\n int dfs(int x,int y,int p,int dep,const int lim){\n       int i,h,n1,n2,res;\n       h=cal();\n       if(h==0){\n                return dep;\n                }\n       if(dep+h>lim){\n                     return -1;\n                     }\n       for(i=0;i<4;++i){\n                        n1=x+d1[i];\n                        n2=y+d2[i];\n \n                        if(~p&&i==(p+2)%4)continue;\n                        if(!(0<=n1&&n1<3&&0<=n2&&n2<3))continue;\n                        swap(&puzle[y][x],&puzle[n2][n1]);\n                        res=dfs(n1,n2,i,dep+1,lim);\n\n                        if(~res)return res;\n \n                        swap(&puzle[y][x],&puzle[n2][n1]);\n                        }\n       return -1; \n       }\n\n int main(){\n            int ans,x,y,l,i,j;\n\n            for(i=0;i<3;i++){\n                             for(j=0;j<3;j++){\n                                              scanf(\"%d\",&puzle[i][j]);\n                                              }\n                             }\n            empty(&x,&y);\n            for(l=0;l<100;l++){\n                               for(i=0;i<3;i++){\n                                                for(j=0;j<3;j++){\n                                                                 tmp[i][j]=puzle[i][j];\n                                                                 }\n                                                }\n                                ans=dfs(x,y,-1,0,1);\n                                if(ans!=-1){\n                                            printf(\"%d\\n\",ans);\n                                            break;\n                                            }\n                                for(i=0;i<3;i++){\n                                                 for(j=0;j<3;j++){\n                                                                  puzle[i][j]=tmp[i][j];\n                                                                  }\n                                                 }\n                                ans=-1;\n                                if(l==99)printf(\"%d\\n\",ans);\n                                }\n            return 0;\n            }\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n//     +-+-+-+       +-+-+-+\n//     |1|3|0|       |1|2|3|\n//     +-+-+-+       +-+-+-+\n//     |4|2|5|       |4|5|6|\n//     +-+-+-+       +-+-+-+\n//     |7|8|6|       |7|8|0|\n//     +-+-+-+       +-+-+-+\n\ntypedef char Board[10];\nBoard ini_board, board;\nconst Board target = \"123456780\";\n\nBoard *history;\nint nhistories=0;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nint minstep = 50;\n\nconst Motion candidate[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nint move(Motion m)\n{\n  if (m.pos==0 && board[0]=='1') return -1;\n  if ((m.pos==1||m.pos==2) && board[0]=='1'&&board[1]=='2'&&board[2]=='3') return -1;\n\n  switch (m.dir) {\n  case U:\n    if (m.pos<3) return -1;\n    board[m.pos-3] = board[m.pos];\n    break;\n  case D:\n    if (m.pos>5) return -1;\n    board[m.pos+3] = board[m.pos];\n    break;\n  case L:\n    if (m.pos%3==0) return -1;\n    board[m.pos-1] = board[m.pos];\n    break;\n  case R:\n    if (m.pos%3==2) return -1;\n    board[m.pos+1] = board[m.pos];\n    break;\n  }\n  board[m.pos] = '0';\n  return m.pos;\n}\n\nvoid search_path(int step, int space)\n{\n  int i, j, s2;\n  if (strcmp(board, \"123456780\")==0) {\n    if (step==1) {\n      printf(\"1\\n\");\n      exit(0);\n    }\n    if (step<minstep) minstep=step;\n  } else {\n    if (step>=minstep) return;\n    if (step>0 && strcmp(board, ini_board)==0) return;\n    \n    Board board_bak;\n    strcpy(board_bak, board);\n    int nhistories_bak=nhistories;\n    \n    puts(board);\n    //    printf(\"%d\\n%c%c%c\\n%c%c%c\\n%c%c%c\\n---\\n\", nhistories, board[0],board[1],board[2],  board[3],board[4],board[5],  board[6],board[7],board[8]);\n\n    for (i=0; candidate[space][i].pos>=0; i++) {\n\n      if ((s2 = move(candidate[space][i]))<0) continue;\n      for (j=0; j<nhistories; j++) {\n\tif (strcmp(board, history[j])==0) // 前と同じ配置になったので次の手を試す\n\t  break;\n      }\n      if (j==nhistories) {\n\tstrcpy(history[nhistories++], board); \n\tsearch_path(step+1, s2);\n      }\n      nhistories = nhistories_bak;\n      strcpy(board, board_bak);\n    }\n  }\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board[0],&board[1],&board[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[3],&board[4],&board[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[6],&board[7],&board[8]);\n  strcpy(ini_board, board);\n  history = (Board*)malloc(sizeof(Board)*10000);\n  search_path(0, strchr(board, '0')-board);\n  printf(\"%d\\n\", minstep);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n????\nint mas[3][3];\nint cpy[3][3];\n????\nvoid input() {\n????int i, j;\n????for(i = 0; i < 3; i++)\n????????for(j = 0; j < 3; j++)\n????????????scanf(\"%d\", &mas[i][j]);\n}\n????\nvoid output() {\n????int i, j;\n????for(i = 0; i < 3; i++) {\n????????for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n????????puts(\"\");\n????}\n}\n????\nvoid copy(int m[3][3], int t[3][3]) {\n????int i, j;\n????\n????for(i = 0; i < 3; i++)\n????????for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n????\nint calc() {\n????int i, sum = 0;\n????for(i = 0; i < 9; i++) {\n????????int v = mas[i/3][i%3];\n????????if(v) {\n????????????v--;\n????????????sum += abs(i/3-v/3)+abs(i%3-v%3);\n????????}\n????}\n????return sum;\n}\n????\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n????\nvoid swap(int *a, int *b) {\n????int tmp = *a;\n????*a = *b;\n????*b = tmp;\n}\n????\nint is_in(int x, int y) {\n????return 0<=x&&x<3&&0<=y&&y<3;\n}\n????\nint dfs(int x, int y, int p, int dep, const int lim) {\n????int i, h = calc();\n????//output();\n????if(h == 0) return dep;\n????//printf(\"%d %d %d\\n\", h, lim, p);\n????if(dep+h > lim) return -1;\n????\n????for(i = 0; i < 4; i++) {\n????????int nx = x+dx[i], ny = y+dy[i], res;\n????????if(~p && i == (p+2)%4) continue;\n????????if(!is_in(nx, ny)) continue;\n????????swap(&mas[y][x], &mas[ny][nx]);\n????????res = dfs(nx, ny, i, dep+1, lim);\n????????if(~res) return res;\n????????swap(&mas[y][x], &mas[ny][nx]);\n????}\n????\n????return -1;\n}\n????\nvoid get_empty(int *x, int *y) {\n????int i, j;\n????for(i = 0; i < 3; i++) {\n????????for(j = 0; j < 3; j++) {\n????????????if(!mas[i][j]) {\n????????*x = j;\n????????*y = i;\n????????return;\n????????????}\n????????}\n????}\n}\n????\nint solve() {\n????int x, y, lim, ans;\n????get_empty(&x, &y);\n????for(lim = 0; lim < 50; lim++) {\n????????copy(cpy, mas);\n????????if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n????????copy(mas, cpy);\n????}\n????return -1;\n}\n????\nint main() {\n????input();\n????printf(\"%d\\n\", solve());\n????return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n  unsigned int b;\n  char step;\n} Board;\n\nint qlen=400000;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nconst Motion motion[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\n\nint findzero(unsigned int b)\n{\n  for (int i=0; i<9; i++) {\n    if (b%10==0) return 8-i;\n    b/=10;\n  }\n  return -1;\n}\n\nunsigned int sq[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000,1000000000 };\n\nint main()\n{\n  int i, j, k;\n  int qhead=0;\n  int qtail=0;\n  Board board;\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b = i*100000000+j*10000000+k*1000000;\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b += i*100000+j*10000+k*1000;\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b += i*100+j*10+k;\n  printf(\"ini: %u\\n\", board.b);\n  short int *used = (short int*)malloc(sizeof(short int)*87654321);\n  for (i=0; i<87654321; i++) used[i]=0;\n  Board *Q = (Board*)malloc(sizeof(Board)*qlen);\n  board.step=0;\n  Q[qhead++] = board;\n  \n  while (qhead>qtail) {\n    board = Q[qtail++ %qlen];\n    \n    if (board.b==123456780)   break;\n\n    k=board.b/10;\n    if ((used[k] & (1<<(board.b%10)))==(1<<(board.b%10))) continue;\n    used[k] |= (1<<(board.b%10));\n    \n    int space = findzero(board.b);\n    for (i=0; motion[space][i].pos>=0; i++) {\n      Board b = board;\n      Motion m = motion[space][i];\n      if (m.pos==0 && b.b/sq[8]==1) continue;\n      if ((m.pos==1||m.pos==2) && b.b/sq[8]==1&&(b.b%sq[8])/sq[7]==2&&(b.b%sq[7])/sq[6]==3) continue;\n//      printf(\"spc=%d, pos=%d: %u -> \", space, m.pos, b.b);\n      int nn=b.b%sq[8-m.pos+1]/sq[8-m.pos];\n      \n      b.b = nn*sq[8-space]+b.b-nn*sq[8-m.pos];\n      b.step=board.step+1;\n      printf(\"%u\\n\", b.b);\n      Q[qhead++ %qlen] = b;\n    }\n  }\n  printf(\"%d\\n\", board.step);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint mas[3][3];\nint cpy[3][3];\n\nvoid input() {\n  int i, j;\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++)\n      scanf(\"%d\", &mas[i][j]);\n}\n\nvoid output() {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n    puts(\"\");\n  }\n}\n\nvoid copy(int m[3][3], int t[3][3]) {\n  int i, j;\n\n  for(i = 0; i < 3; i++)\n    for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n\nint calc() {\n  int i, sum = 0;\n  for(i = 0; i < 9; i++) {\n    int v = mas[i/3][i%3];\n    if(v) {\n      v--;\n      sum += abs(i/3-v/3)+abs(i%3-v%3);\n    }\n  }\n  return sum;\n}\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nvoid swap(int *a, int *b) {\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nint is_in(int x, int y) {\n  return 0<=x&&x<3&&0<=y&&y<3;\n}\n\nint dfs(int x, int y, int p, int dep, const int lim) {\n  int i, h = calc();\n  //output();\n  if(h == 0) return dep;\n  //printf(\"%d %d %d\\n\", h, lim, p);\n  if(dep+h > lim) return -1;\n\n  for(i = 0; i < 4; i++) {\n    int nx = x+dx[i], ny = y+dy[i], res;\n    if(~p && i == (p+2)%4) continue;\n    if(!is_in(nx, ny)) continue;\n    swap(&mas[y][x], &mas[ny][nx]);\n    res = dfs(nx, ny, i, dep+1, lim);\n    if(~res) return res;\n    swap(&mas[y][x], &mas[ny][nx]);\n  }\n\n  return -1;\n}\n\nvoid get_empty(int *x, int *y) {\n  int i, j;\n  for(i = 0; i < 3; i++) {\n    for(j = 0; j < 3; j++) {\n      if(!mas[i][j]) {\n        *x = j;\n        *y = i;\n        return;\n      }\n    }\n  }\n}\n\nint solve() {\n  int x, y, lim, ans;\n  get_empty(&x, &y);\n  for(lim = 0; lim < 50; lim++) {\n    copy(cpy, mas);\n    if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n    copy(mas, cpy);\n  }\n  return -1;\n}\n\nint main() {\n  input();\n  printf(\"%d\\n\", solve());\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint puzzle[3][3];\nint tmp[3][3];\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nvoid empty(int *, int *);\nvoid swap(int *, int *);\nint cal();\nint dfs(int, int, int, int, int);\n\nint main(){\n  int i,j,k;\n  int x,y,a;\n\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&puzzle[i][j]);\n    }\n  }\n\n  empty(&x,&y);\n\n  for(k=0;k<100;k++){\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n\ttmp[i][j]=puzzle[i][j];\n      }\n    }\n\n    a=dfs(x,y,-1,0,k);\n    if(a!=-1){\n      printf(\"%d\\n\",a);\n      break;\n    }\n\n    for(i=0;i<3;i++){\n      for(j=0;j<3;j++){\n\tpuzzle[i][j]=tmp[i][j];\n      }\n    }\n    \n    a=-1;\n    if(k==99) printf(\"%d\\n\",a);\n  }\n\n  return 0;\n}\n\nvoid empty(int *x, int *y){\n  int i,j;\n\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(puzzle[i][j]==0){\n\t*x=j;\n\t*y=i;\n\treturn;\n      }\n    }\n  }\n}\n\nvoid swap(int *a, int *b){\n  int tmp;\n  \n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\n\n\nint cal(){\n  int i,x;\n  int sum=0;\n\n  for(i=0;i<9;i++){\n    x=puzzle[i/3][i%3];\n    if(x){\n      x--;\n      sum+=abs((i/3)-(x/3))+abs((i%3)-(x%3));\n    }\n  }\n\n  return sum;\n}\n\nint dfs(int x,int y,int p,int dep,int limit){\n  int i,h,nx,ny,res;\n\n  h=cal();\n  \n  if(h==0) return dep;\n  if(dep+h>limit) return -1;\n\n  for(i=0;i<4;i++){\n    nx=x+dx[i];\n    ny=y+dy[i];\n\n    if(~p && i==(p+2)%4) continue;\n    if(!(0<=nx && nx<3 && 0<=ny && ny<3)) continue;\n\n    swap(&puzzle[y][x],&puzzle[ny][nx]);\n    res=dfs(nx,ny,i,dep+1,limit);\n    if(~res) return res;\n\n    swap(&puzzle[y][x],&puzzle[ny][nx]);\n  }\n\n  return -1;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint Puzzle[3][3];\nint tmp[3][3];\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nvoid Empty(int *, int *);\nvoid swap(int *, int *);\nint Cal();\nint DFS(int, int, int, int, int);\n\nint main(){\n  int i, j, l;\n  int x, y, a;\n\nfor(i=0;i<3;i++)\n  for(i = 0 ; i < 3 ; i++){\n    for(j = 0 ; j < 3 ; j++){\n      scanf(\"%d\",&Puzzle[i][j]);\n    }\n  }\n\n  Empty(&x,&y);\n\n  for(l = 0 ; l < 100 ; l++){\n    for(i = 0 ; i < 3 ; i++){\n      for(j = 0 ; j < 3 ; j++){\n tmp[i][j] = Puzzle[i][j];\n      }\n    }\n\n    a = DFS(x, y, -1, 0, l);\n    if(a != -1){\n      printf(\"%d\\n\",a);\n      break;\n    }\n\n    for(i = 0 ; i < 3 ; i++){\n      for(j = 0 ; j < 3 ; j++){\n Puzzle[i][j] = tmp[i][j];\n      }\n    }\n\n    a = -1;\n    if(l == 99) printf(\"%d\\n\",a);\n  }\n\n  return 0;\n}\n\nvoid Empty(int *x, int *y){\n  int i, j;\n\n  for(i = 0 ; i < 3 ; i++){\n    for(j = 0 ; j < 3 ; j++){\n      if(!Puzzle[i][j]){\n *x = j;\n *y = i;\n return;\n      }\n    }\n  }\n}\n\nvoid swap(int *a, int *b){\n  int tmp;\n\n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\n\nint Cal(){\n  int i, a;\n  int sum = 0;\n\n  for(i = 0 ; i < 9 ; i++){\n    a = Puzzle[i/3][i%3];\n    if(a){\n      a--;\n      sum += abs(i/3 - a/3)  + abs(i%3 - a%3);\n    }\n  }\n\n  return sum;\n}\n\nint DFS(int x, int y, int p, int dep, int limit){\n  int i, h, nx, ny, res;\n\n  h = Cal();\n\n  if(h == 0) return dep;\n  if(dep + h > limit) return -1;\n\n  for(i = 0 ; i < 4 ; i++){\n    nx = x + dx[i];\n    ny = y + dy[i];\n\n    if(~p && i == (p+2)%4) continue;\n    if(!(0 <= nx && nx < 3 && 0 <= ny && ny < 3)) continue;\n\n    swap(&Puzzle[y][x], &Puzzle[ny][nx]);\n    res = DFS(nx, ny, i, dep+1, limit);\n    if(~res) return res;\n\n    swap(&Puzzle[y][x], &Puzzle[ny][nx]);\n  }\n\n  return -1;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define N 3\n\nint pl[N][N],tmp[N][N];\nint Dx[4]={0,1,0,-1},Dy[4]={1,0,-1,0};\n\nvoid em(int *a,int *b){\n  int i,j;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(!pl[i][j]){\n\t*a = j;\n\t*b=i;\n      }\n    }\n  }\n}\n\nvoid SW(int *a,int *b){\n  int tmp;\n  tmp =*a;\n  *a = *b;\n  *b = tmp;\n}\n\nint cal(){\n  int i,A,S=0;\n  for(i=0;i<9;i++){\n    A = pl[i/3][i%3];\n    if(A){\n      A--;\n      S += abs(i/3-A/3) + abs(i%3 - A%3);\n    }\n  }\n  return S;\n}\n\nint df(int a,int b,int P,int D,const int shin){\n  int i,hi,A,B,result;\n  hi = cal();\n  if(hi==0){\n    return D;\n  }\n  if(D+hi>shin){\n    return -1;\n  }\n\n  for(i=0;i<4;i++){\n    A = a+Dx[i];\n    B = b+Dy[i];\n    if(~P && i==(P+2)%4) {\n      continue;\n    }\n    if(!(0<=A && A<3 && 0<=B && B<3)){\n      continue;\n    }\n    SW(&pl[b][a],&pl[B][A]);\n    result = df(A,B,i,D+1,shin);\n    if(~result){\n      return result;\n    }\n    SW(&pl[b][a],&pl[B][A]);\n  }\n  return -1;\n}\n\nint main(){\n  int i,j,li,TA,a,b;\n\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&pl[i][j]);\n    }\n  }\n\n    em(&a,&b);\n    for(li=0;li<100;li++){\n      for(i=0;i<3;i++){\n\tfor(j=0;j<3;j++){\n\t  tmp[i][j]=pl[i][j];\n\t}\n      }\n\tTA = df(a,b,-1,0,li);\n\tif(TA!=-1){\n\t  printf(\"%d\\n\",TA);\n\t  break;\n\t}\n\n\tfor(i=0;i<3;i++){\n\t  for(j=0;j<3;j++){\n\t    pl[i][j]=tmp[i][j];\n\t  }\n\t}\n\n\tTA = -1;\n\tif(li==99){\n\t      printf(\"%d\\n\",TA);\n\t    }\n      }\n\n    return 0;\n\t    }\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint Puzzle[3][3];\nint tmp[3][3];\nint da[4] = {0, 1, 0, -1};\nint db[4] = {1, 0, -1, 0};\nint Roop(int);\nvoid Kara(int *, int *);\n\n\n\nvoid swap(int *, int *);\n\n\n\nint ABC(int, int, int, int, int);\n\n\n\n\nint Cal(){\n  int i, a;\n  int sum = 0;\n\n  for(i = 0 ; i < 9 ; i++){\n    a = Puzzle[i/3][i%3];\n    if(a){\n\n\n\n\n\n      a=a-1;\n      sum += abs(i/3 - a/3)  + abs(i%3 - a%3);\n    }\n  }\n\n  return sum;\n}\n\n\n\n\n\n\n\nint main(){\n  int i=0,j, l;\n  int gya;\n  int far;\n  int a;\n\n  while( i < 3){\n    for(j = 0 ; j < 3 ; j++){\n      scanf(\"%d\",&Puzzle[i][j]);\n    }\n    i++;\n  }\n\n  Kara(&gya,&far);\n  l=0;\n  while(l < 100){\n\n    \n    for(i = 0 ; i < 3 ; i++){\n\n\n       \n      for(j = 0 ; j < 3 ; j++){\n\ttmp[i][j] = Puzzle[i][j];\n      }\n    }\n\n    a = ABC(gya, far, -1, 0, l);\n    if(a != -1){\n      printf(\"%d\\n\",a);\n      break;\n    }\n    i=0;\n    while(i < 3){\n      for(j = 0 ; j < 3 ; j++){\n\tPuzzle[i][j] = tmp[i][j];\n      }\n      i++;\n    }\n    \n    a = -1;\n    if(l == 99) printf(\"%d\\n\",a);\n    l++;\n  }\n\n  return 0;\n}\n\nvoid Kara(int *gya, int *far){\n  int i=0, j;\n\n  while(i < 3){\n    for(j = 0 ; j < 3 ; j++){\n      if(!Puzzle[i][j]){\n\t*gya = j;\n\t*far = i;\n\treturn;\n      }\n    }\n    i++;\n  }\n}\n\nvoid swap(int *a, int *b){\n  int tmp;\n  \n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\n\n\nint ABC(int a, int b, int p, int hukasa, int seigen){\n\n\n\n\n\n  int i, h, na, nb, res;\n\n  h = Cal();\n  \n  if(h == 0) return hukasa;\n\n\n\n\n\n  if(hukasa + h > seigen) return -1;\n\nfor(i=0;i < 4;i++){\n    na = a + da[i];\n    nb = b + db[i];\n\n    if(~p && i == (p+2)%4) continue;\n    if(!(0 <= na && na < 3 && 0 <= nb && nb < 3)) continue;\n\n    swap(&Puzzle[b][a], &Puzzle[nb][na]);\n\n\n\n\n\n\n\n\n    res = ABC(na, nb, i, hukasa+1, seigen);\n    if(~res) return res;\n\n    swap(&Puzzle[b][a], &Puzzle[nb][na]);\n  }\n\n  return -1;\n}\n    \nint Roop(int c){\nc++;\nreturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n#define TRUE 1\n#define FALSE 0\n#define N 3\n\n\nint P[N][N];\nint dx[4] = {0,-1,0,1},dy[4] = {1,0,-1,0};\nint lim;\n\nint SUM();\nvoid pazz(int,int);\nvoid change(int,int,int,int);\nint bfs(int,int,int,int);\n\nint SUM()\n{\n  int i,j,num,sum=0;\n  for(i=0;i<N;i++) {\n    for(j=0;j<N;j++) {\n      if(P[i][j] == 0)\n\tcontinue;\n      num = P[i][j] - 1;\n      sum += abs(num/N-i) + abs(num%N-j);\n    }\n  }\n  return sum;\n}\n\n\nvoid pazz(int x,int y)\n{\n  for(lim=0;;lim++) {\n    if(bfs(0,99,y,x)) {\n      printf(\"%d\\n\",lim);\n      return;\n    }\n  }\n}\n\nvoid change(int a,int b,int c,int d)\n{\n  int x;\n\n  x = P[a][b];\n  P[a][b] = P[c][d];\n  P[c][d] = x;\n}\n\nint bfs(int d,int p, int y,int x)\n{\n  int i,j;\n  int l,m,n;\n\n  l = SUM();\n  if(l == 0)\n    return TRUE;\n  if(lim < d + l)\n    return FALSE;\n\n  for(i=0;i<4;i++) {\n    if(abs(i-p) == 2)\n      continue;\n    m = x + dx[i];\n    n = y + dy[i];\n    if(m < 0 || n < 0 || m >= N || n >= N)\n      continue;\n    change(n,m,y,x);\n    \n\n    if(bfs(d+1,i,n,m))\n      return TRUE;\n    change(n,m,y,x);\n  }\n    return FALSE;\n}\n    \n    \n \n  int main()\n  {\n    int i,j,x,y;\n\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++) {\n\tscanf(\"%d\",&P[i][j]);\n\tif(P[i][j] == 0) {\n\t  y = i;\n\t  x = j;\n\t}\n      }\n    }\n    pazz(x,y);\n  \n    return 0;\n  }\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\nchar *flag;\nint head,rear;\nint *que;\nint factorial[10];\n\nint cal_factorial(int n) {\n  if(n == 0) return 1;\n  return cal_factorial(n-1)*n;\n}\n\nint stotag(char *s) {\n  int tag = 0;\n  int i;\n  for(i = 0; i < 9; i++) {\n    int t,j;\n    t = 0;\n    for(j = 0; j < i; j++) {\n      if(s[j] < s[i]) t++;\n    }\n    tag += factorial[8-i]*(s[i]-'0'-t);\n  }\n  return tag;\n}\n\nchar *tagtos(int tag) {\n  int i;\n  char *s;\n  s = (char*)malloc(sizeof(char)*10);\n  for(i = 0; i < 9; i++) {\n    s[i] = tag%factorial[9-i]/factorial[8-i] + '0';\n  }\n  s[9] = '\\0';\n  for(i = 7; i >= 0; i--) {\n    int j;\n    for(j = 8; j > i; j--) {\n      if(s[i] <= s[j]) s[j]++;\n    }\n  }\n  \n  return s;\n}\n\n\nchar *move_up(char s[], int x) {\n  if(x < 3) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-3];\n  s_new[x-3] = s[x];\n  return s_new;\n}\n\nchar *move_left(char s[], int x) {\n  if(x%3 == 0) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x-1];\n  s_new[x-1] = s[x];\n  return s_new;\n}\n\nchar *move_right(char s[], int x) {\n  if(x%3 == 2) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+1];\n  s_new[x+1] = s[x];\n  return s_new;\n}\n\nchar *move_down(char s[], int x) {\n  if(x > 5) return NULL;\n  char *s_new;\n  s_new = (char*)malloc(sizeof(char)*10);\n  strcpy(s_new,s);\n  s_new[x] = s[x+3];\n  s_new[x+3] = s[x];\n  return s_new;\n}\n\nint create(char s[], int t) {\n  if(strcmp(s,\"123456780\") == 0) return t;\n  int tag = stotag(s);\n  if(flag[tag]) return 0;\n  flag[tag] = t;\n  que[rear] = tag;\n  rear++;\n  return 0;\n}\n\nint distance(char *s_new) {\n  char s[] = \"123456780\";\n  int i;\n  int sum = 0;\n  for(i = 0; i < 9; i++) {\n    int a = 0;\n    int b = 0;\n    while(s[a]-'0' != i) a++;\n    while(s_new[b]-'0' != i) b++;\n    sum += abs(a/3-b/3) + abs(a%3-b%3);\n  }\n  return sum;\n}\n\nint check_x(char *s) {\n  int i = 0;\n  while(s[i] != '0') i++;\n  return i;\n}\n\nint cal() {\n  char *s_right,*s_left,*s_up,*s_down;\n  int right,left,up,down,min;\n  int k,tag;\n\n  tag = que[head];\n  char *s = tagtos(tag);\n  int x = check_x(s);\n  \n  if((s_right = move_right(s, x)) != NULL) {\n    right = distance(s_right);\n    if((k = create(s_right,flag[tag]+1))) return k;\n  }else{\n    right = INT_MAX;\n  }\n  if((s_left = move_left(s, x)) != NULL) {\n    left = distance(s_left);\n     if((k = create(s_left,flag[tag]+1))) return k;\n  }else{\n    left = INT_MAX;\n  }\n  if ((s_up = move_up(s, x)) != NULL) {\n    up = distance(s_up);\n    if((k = create(s_up,flag[tag]+1))) return k;\n  }else{\n    up = INT_MAX;\n  }\n  if((s_down = move_down(s, x)) != NULL) {\n    down = distance(s_down);\n    if((k = create(s_down,flag[tag]+1))) return k;\n  }else{\n    down = INT_MAX;\n  }\n  /*\n  min = right;\n  if(min > left) min = left;  \n  if(min > up) min = up;  \n  if(min > down) min = down;\n\n  if(right == min) {\n    if((k = create(s_right,flag[tag]+1))) return k;\n  }\n  if(left == min) {\n    if((k = create(s_left,flag[tag]+1))) return k;\n  }\n  if(up == min) {\n    if((k = create(s_up,flag[tag]+1))) return k;\n  }\n  if(down == min) {\n    if((k = create(s_down,flag[tag]+1))) return k;\n  }\n  */\n\n  free(s);\n  if(s_right != NULL) free(s_right);\n  if(s_left != NULL) free(s_left);\n  if(s_up != NULL) free(s_up);\n  if(s_down != NULL) free(s_down);\n  head++;\n  return 0;\n}\n  \n\nint solve(char s0[]) {\n  int k;\n  if((k = create(s0,1))) return k;\n  \n  while(!(k = cal())) {\n    if(head == rear) break;\n  }\n  return k;\n}\n\nint main()\n{\n  int i,d;\n  char s[10];\n  for(i = 0; i < 10; i++) factorial[i] = cal_factorial(i);\n  flag = (char*)malloc(sizeof(char)*factorial[9]);\n  memset(flag , 0, factorial[9]);\n  que = (int*)malloc(sizeof(int)*factorial[9]);\n  head = 0;\n  rear = 0;\n  for (i = 0; i < 9; i++) {\n    scanf(\"%d\", &d);\n    s[i] = d+'0';\n  }\n  s[9] = '\\0';\n  printf(\"%d\\n\",solve(s)-1);\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define eMax 100000000\n#define existing 1234567\n#define true 1\n#define false 0\n#define nil -1\n#define Qsize 50000\n#define Psize 9\n#define N 3\ntypedef struct{\n  int state[Psize];\n  int space;\n  int path;\n} puzzule;\nint bfs(puzzule);\nint isTarget(puzzule);\nint exist(puzzule);\nint hashu(int *); //ハッシュ値を生成する関数\nvoid enqueue(puzzule);\npuzzule dequeue(void);\nint goal[Psize] = {1, 2, 3, 4, 5, 6, 7, 8, Psize};\nint dx[N+1] = {-1, 0, 1, 0}, dy[N+1] = {0, -1, 0, 1};\nint head = 0, tail = 0;\nint e[eMax];\npuzzule queue[Qsize];\n\nint main()\n{\n  puzzule in;\n  int i;\n\n  for(i = 0 ; i < Psize ; i++){\n    scanf(\"%d\",&in.state[i]);\n    if(in.state[i] == 0){\n      in.state[i] = Psize;\n      in.space = i; }\n  }\n  \n  printf(\"%d\\n\",bfs(in));\n\n  return 0;\n}\n\nvoid enqueue(puzzule p)\n{\n  int next;\n\n  next = (tail + 1) % Qsize;\n\n  if(next != head){\n    queue[tail] = p;\n    tail = next; }\n\n}\n\npuzzule dequeue(void)\n{\n  puzzule p;\n\n  if(head != tail){\n    p = queue[head];\n    head = (head + 1) % Qsize;\n    return p; }\n  \n  }\n\nint bfs(puzzule p)\n{\n  puzzule u, v;\n  int sx, sy, tx, ty;\n  int i, ForChange;\n  \n  p.path = 0;\n  e[hashu(p.state)] = existing;\n  enqueue(p);\n\n  while(head != tail){\n    u = dequeue(); \n    if(isTarget(u) == true) return u.path;\n    sx = u.space / N;\n    sy = u.space % N;\n    for(i = 0 ; i <= N ; i++){\n      tx = sx + dx[i];      \n      ty = sy + dy[i];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n      v = u;\n      ForChange = v.state[u.space];\n      v.state[u.space] = v.state[tx * N + ty];\n      v.state[tx * N + ty] = ForChange;\n      v.space = tx * N + ty;\n      if(exist(v) != true){\n\tv.path += 1;\n\tenqueue(v); }\n    }  \n  }\n  \n  return nil;\n}\n\nint exist(puzzule p)\n{\n  if(e[hashu(p.state)] == existing) return true;\n  e[hashu(p.state)] = existing;\n\n  return false;\n}\n\nint isTarget(puzzule p)\n{\n  int i;\n  \n  for(i = 0 ; i < Psize ; i++){ \n    if(p.state[i] != goal[i]) return false; }\n  \n  return true;\n}\n\nint hashu(int *table)\n{\n  int  i, j, hash = 0, work[Psize];\n  int FACTOR[Psize] = {40320,5040,720,120,24,6,2,1,1}; // i!の並びになっている。\n  \n  for (i=0; i < Psize; i++) work[i] = table[i];\n    for (i=0; i < Psize; i++) {\n    hash += work[i] * FACTOR[i];\n    for (j=i+1; j < Psize; j++)\n      if (work[i] < work[j]) work[j]--;\n  }\n    \n    return hash;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define N 3\n\nint p[N][N],t[N][N];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nvoid empty(int *x,int *y) {\n  int i,j;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      if(!p[i][j]){\n        *x = j;\n        *y = i;\n        return;\n      }\n    }\n  }\n}\n\nvoid swap(int *a,int *b){\n  int t;\n  t = *a;\n  *a = *b;\n  *b = t;\n}\n\nint cal(){\n  int i,a,sum=0;\n  for(i=0;i<9;i++){\n    a = p[i/N][i%N];\n    if(a){\n      a--;\n      sum += abs(i/N - a/N) + abs(i%N - a%N);\n    }\n  }\n  return sum;\n}\n\nint dfs(int x,int y,int pp,int dep,const int l){\n  int i,h,sx,sy,res;\n  h = cal();\n  if(h == 0)return dep;\n  if(dep+h>l)return -1;\n  for(i=0;i<4;i++){\n    sx = x+dx[i];\n    sy = y+dy[i];\n    if(~pp && i == (pp+2)%4)continue;\n    if(!(0<=sx && sx<N && 0<=sy && sy<N))continue;\n    swap(&p[y][x],&p[sy][sx]);\n    res = dfs(sx,sy,i,dep+1,l);\n    if(~res)return res;\n    swap(&p[y][x],&p[sy][sx]);\n  }\n  return -1;\n}\n\nint main() {\n  int i,j,ans,x,y,k;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&p[i][j]);\n    }\n  }\n  empty(&x,&y);\n  for(k=0;k<100;k++){\n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++){\n        t[i][j] = p[i][j];\n      }\n    }\n    ans = dfs(x,y,-1,0,k);\n    if(ans != -1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n    else {\n      for(i=0;i<N;i++){\n        for(j=0;j<N;j++){\n          p[i][j] = t[i][j];\n        }\n      }\n      ans = -1;\n      if(k == (100-1)){\n        printf(\"%d\\n\",ans);\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nint P[3][3],tmp[3][3];\nint Dx[4] = {0,1,0,-1};\nint Dy[4] = {1,0,-1,0};\nvoid emp(int *x,int *y) {\n  int i,j;\n  for(i=0; i<3; i++) {\n    for(j=0; j<3; j++) {\n      if(!P[i][j]) {\n\t*x = j;\n\t*y = i;\n      }\n    }\n  }\n}\nvoid swap(int *s,int *v){\n  int tmp;\n  tmp = *s;\n  *s = *v;\n  *v = tmp;\n}   \nint calc(){\n  int i,t,sum=0; \n  for(i=0; i<9; i++){\n    t = P[i/3][i%3];\n    if(t){\n      t--;\n      sum += abs(i/3 - t/3) + abs(i%3 - t%3);\n    }\n  }    \n  return sum;\n}\nint dfs(int x,int y,int p,int d,const int lim){\n  int i,hi,x2,y2,res;   \n  hi = calc();\n  if(hi==0) {\n    return d;\n  }\n  if(d+hi>lim) {\n    return -1;\n  }\n  for(i=0; i<4; i++){\n    x2 = x+Dx[i];\n    y2 = y+Dy[i];      \n    if(~p && i==(p+2)%4) continue;\n    if(!(0<=x2 && x2<3 && 0<=y2 && y2<3)) continue;    \n    swap(&P[y][x],&P[y2][x2]);\n    res = dfs(x2,y2,i,d+1,lim);\n    if(~res) {\n      return res;\n    }\n    swap(&P[y][x],&P[y2][x2]);\n  }   \n  return -1;\n}    \nint main() {\n  int i,j,l,ans,x,y;\n        \n  for(i=0; i<3; i++){\n    for(j=0; j<3; j++) scanf(\"%d\",&P[i][j]);\n  }\n         \n  emp(&x,&y);\n  for(l=0; l<100; l++){\n    for(i=0; i<3; i++){\n      for(j=0; j<3; j++) tmp[i][j] = P[i][j];\n    }\n            \n    ans = dfs(x,y,-1,0,l);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n            \n    for(i=0; i<3; i++){\n      for(j=0; j<3; j++) P[i][j] = tmp[i][j];\n    }\n            \n    ans = -1;\n    if(l==99) printf(\"%d\\n\",ans);\n  }\n        \n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX 3\n\nint pane[MAX][MAX];\nint temp[MAX][MAX];\nint d_x[4]={0,1,0,-1};\nint d_y[4]={1,0,-1,0};\n\n\nvoid empty(int *,int *);\nvoid swap(int *,int *);\nint cal();\nint dfs(int ,int ,int ,int ,const int );\n\nint main() {\n  int i,j;\n  int h,ans,row,col;\n      \n  for(i=0; i<MAX; i++){\n    for(j=0; j<MAX; j++)\n      scanf(\"%d\",&pane[i][j]);\n  }  \n  empty(&row,&col);  \n  for(h=0; h<100; h++){\n    for(i=0; i<MAX; i++){\n      for(j=0; j<MAX; j++)\n\ttemp[i][j] = pane[i][j];\n    }    \n    ans = dfs(row,col,-1,0,h);    \n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }    \n    for(i=0; i<MAX; i++){\n      for(j=0; j<MAX; j++)\n\tpane[i][j] = temp[i][j];\n    }    \n    ans = -1;\n    if(h==99) printf(\"%d\\n\\n\",ans);\n  }      \n  return 0;\n}\n\nvoid empty(int *row,int *col){\n  int i,j;\n  for(i=0; i<MAX; i++)\n    for(j=0; j<MAX; j++)\n      if(!pane[i][j]){\n\t*row = j;\n\t*col = i;\n\treturn;\n      }  \n}\n   \nvoid swap(int *a,int *b){\n  int temp;\n  temp = *a;*a = *b;*b = temp;\n}\n  \nint cal(){\n  int i,e;\n  int count=0; \n  for(i=0; i<9; i++){\n    e = pane[i/3][i%3];\n    if(e){\n      e--;\n      count += abs(i/3 - e/3) + abs(i%3 - e%3);\n    }\n  }   \n  return count;\n}\n  \nint dfs(int x,int y,int p,int deep,const int limt){\n  int i;\n  int len;\n  int x_2,y_2;\n  int emc;   \n  len = cal();\n  if(len==0) return deep;\n  if(deep+len > limt) return -1; \n  for(i=0; i<4; i++){\n    x_2 = x+d_x[i];\n    y_2 = y+d_y[i];      \n    if(~p && i==(p+2)%4) continue;\n    if(!(0<=x_2 && x_2<3 && 0<=y_2 && y_2<3)) continue;    \n    swap(&pane[y][x],&pane[y_2][x_2]);\n    emc = dfs(x_2,y_2,i,deep+1,limt);\n    if(~emc) return emc;       \n    swap(&pane[y][x],&pane[y_2][x_2]);\n  }   \n  return -1;\n}  \n  \n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define n 3\n\ntypedef struct{\n    int A[n][n];\n}puzzle;\n\nint X[4]={0,1,0,-1};\nint Y[4]={1,0,-1.0};\n\npuzzle p;\n\nint huri();\nint dfs(int, int, int, int, int);\nvoid target(puzzle);\n\nint main(){\n    int i,j,k,x,y,t;\n    puzzle T;\n    for(i=0;i<n;i++){\n        for(j=0;j<n;j++){\n            scanf(\"%d\",&p.A[i][j]);\n            if(p.A[i][j]==0){\n                x=j;\n                y=i;\n            }\n        }\n    }\n    T=p;\n    for(i=1;i<46;i++){\n        p=T;\n        t=dfs(x,y,i,0,-1);\n        if(t!=-1){\n            printf(\"%d\\n\",t);\n            break;\n        }\n    }\n    return 0;\n}\n\nint huri(){\n    int i,j,sum=0,s,t;\n    for(i=0;i<n;i++){\n        for(j=0;j<n;j++){\n            if(p.A[i][j]==0)continue;\n            t=(p.A[i][j]-1)/n-i;\n            s=(p.A[i][j]-1)%n-j;\n            if(s<0)sum=sum-s;\n            else sum=sum+s;\n            if(t<0)sum=sum-t;\n            else sum=sum+t;\n        }\n    }\n    return sum;\n}\nint dfs(int s, int t, int max, int count, int r){\n    int i,tmp,x,y,time,l;\n    l=huri();\n    if(l==0)return count;\n    else if(count+l>max)return -1;\n    for(i=0;i<4;i++){\n        x=s+X[i];\n        y=t+Y[i];\n        if((x<0||n<=x||y<0||3<=y)||(i==(r+2)%4 && r!=-1))continue;\n        tmp=p.A[t][s];\n        p.A[t][s]=p.A[y][x];\n        p.A[y][x]=tmp;\n        time=dfs(x,y,max,count+1,i);\n        if(time != -1)return time;\n        tmp=p.A[t][s];\n        p.A[t][s]=p.A[y][x];\n        p.A[y][x]=tmp;\n    }\n    return -1;\n}\n"
  },
  {
    "language": "C",
    "code": "//8 パズル\n//Ebitani Akira\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint array[3][3];\nint tmp[3][3];\nint Tx[4] = {0,1,0,-1};\nint Ty[4] = {1,0,-1,0};\n\n\nvoid emp(int *,int *) ;\nint calc(void);\nvoid swap(int *, int *);\nint dfs(int ,int ,int ,int ,const int );\n\nint main() {\n    int i, j;\n    int l, flg;\n    int x, y;\n\n    for(i = 0 ; i < 3 ; i++){\n        for(j = 0 ; j < 3 ; j++) scanf(\"%d\", &array[i][j]);\n    }\n\n    emp(&x, &y);\n    for(l = 0 ; l < 100 ; l++){\n        for(i = 0 ; i < 3 ; i++){\n            for(j = 0 ; j < 3 ; j++){\n               tmp[i][j] = array[i][j];\n             }\n        }\n\n        flg = dfs(x, y, -1, 0, l);\n        if(flg != -1){\n            printf(\"%d\\n\", flg);\n            break;\n        }\n\n        for(i = 0 ; i < 3 ; i++){\n            for(j = 0 ; j < 3 ; j++){\n\n            array[i][j] = tmp[i][j];\n          }\n        }\n\n        flg = -1;\n\n\n        if(l == 99) printf(\"%d\\n\",flg);\n    }\n\n    return 0;\n}\n\nvoid emp(int *x,int *y) {\n\n  int i, j;\n  for(i = 0 ; i < 3 ; i++) {\n    for(j = 0 ; j < 3 ; j++) {\n      if(! array[i][j]) {\n\n        *x = j;\n        *y = i;\n      }\n    }\n  }\n\n}\n\n\nvoid swap(int *s, int *v){\n\n  int tmp;\n  tmp = *s;\n  *s = *v;\n  *v = tmp;\n\n}\n\n\nint calc(){\n\n  int i;\n  int sum=0;\n  int X;\n\n  for(i = 0 ; i < 9 ; i++){\n    X = array[i/3][i%3];\n    if(X){\n      X--;\n      sum += abs(i/3 - X/3) + abs(i % 3 - X % 3);\n    }\n  }\n  return sum;\n}\n\n\nint dfs(int x,int y,int p,int d,const int l){\n\n    int i,h;\n    int x2, y2, res;\n\n    h = calc();\n    if(h==0) {\n        return d;\n    }\n    if(d+h > l) {\n        return -1;\n    }\n    for(i = 0 ; i < 4 ; i++){\n        x2 = x + Tx[i];\n        y2 = y + Ty[i];\n\n        if(~p && i == (p+2) % 4){\n          continue;\n        }\n\n        if(!(0 <= x2 && 0 <=y2 && x2 < 3 && y2 < 3)){\n           continue;\n         }\n\n        swap(&array[y][x], &array[y2][x2]);\n        res = dfs(x2, y2, i, d+1, l);\n\n        if(~res) {\n            return res;\n        }\n        swap(&array[y][x], &array[y2][x2]);\n    }\n    return -1;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n  unsigned int b;\n  char step;\n} Board;\n\nint qlen=32202;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nconst Motion motion[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}} };\n\nint findzero(unsigned int b)\n{\n  for (int i=0; i<9; i++) {\n    if (b%10==0) return 8-i;\n    b/=10;\n  }\n  return -1;\n}\n\nunsigned int sq[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000,1000000000 };\n\n#define HISTLEN 876543\n\nint main()\n{\n  int i, j, k;\n  int qhead, qtail;\n  qhead = qtail = 0;\n  Board board;\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b = i*sq[8]+j*sq[7]+k*sq[6];\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b += i*sq[5]+j*sq[4]+k*sq[3];\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b += i*100+j*10+k;\n  short int *used = (short int*)malloc(sizeof(short int)*HISTLEN);\n  for (i=0; i<HISTLEN; i++) used[i]=0;\n  Board *Q = (Board*)malloc(sizeof(Board)*qlen);\n  board.step=0;\n  Q[qhead++] = board;\n  \n  while (qhead>qtail) {\n    board = Q[qtail++ %qlen];\n    if (board.b==123456780)   break;\n    \n    int space = findzero(board.b);\n    for (i=0; motion[space][i].pos>=0; i++) {\n      Board b = board;\n      Motion m = motion[space][i];\n      if (m.pos==0 && b.b/sq[8]==1) continue;\n      if ((m.pos==1||m.pos==2) && b.b/sq[8]==1&&(b.b%sq[8])/sq[7]==2&&(b.b%sq[7])/sq[6]==3) continue;\n      int nn=b.b%sq[8-m.pos+1]/sq[8-m.pos];\n      b.b = nn*sq[8-space]+b.b-nn*sq[8-m.pos];\n      b.step = board.step+1;\n      k=b.b/1000;\n      if ((used[k] & (1<<(b.b%10)))==(1<<(b.b%10))) continue;\n      used[k] |= (1<<(board.b%10));\n      Q[qhead++ %qlen] = b;\n    }\n  }\n  printf(\"%d\\n\", board.step);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint m[3][3];\nint cpy[3][3];\n\nvoid input(void){\n  int i,j;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&m[i][j]);\n    }\n  }\n}\nvoid output(void){\n  int i,j;\n for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      printf(\"%3d\",m[i][j]);\n      puts(\"\");\n    }\n }\n}\nvoid copy(int a[3][3],int b[3][3]){\n  int i,j;\n for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      a[i][j] = b[i][j];\n    }\n }\n}\nint calc(void){\n  int i,sum = 0;\n  for(i=0;i<9;i++){\n    int a = m[i/3][i%3];\n    if(a){\n      a--;\n      sum += abs(i/3 - a/3)+abs(i%3 - a%3);\n    }\n  }\n  return sum;\n}\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nvoid swap(int *a, int *b){\n  int tmp;\n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\nint in(int a,int b){\n  return 0<=a&&a<3&&0<=b&&b<3;\n}\nint df(int a,int b,int p,int d,const int lim){\n  int i , h=calc();\n  if(h == 0)return d;\n  if(d+h > lim)return -1;\n\n  for(i=0;i<4;i++){\n    int x= a+dx[i],y=b+dy[i];\n    int res;\n    if(~p && i == (p+2)%4)continue;\n    if(!in(x,y))continue;\n    swap(&m[b][a],&m[y][x]);\n    res = df(x,y,i,d+1,lim);\n    if(~res)return res;\n    swap(&m[b][a],&m[y][x]);\n  }\n  return -1;\n}\n\nvoid empty(int *a, int *b){\n  int i,j;\n   for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(!m[i][j]){\n\t*a = j;\n\t*b = i;\n\treturn;\n      }\n    }\n   }\n}\nint s(void){\n  int a,b,lim,x;\n  empty(&a,&b);\n  for(lim = 0;lim < 50;lim++){\n    copy(cpy,m);\n    if((x = df(a,b,-1,0,lim)) != -1)return x;\n    copy(m,cpy);\n  }\n  return -1;\n}\nint main(){\n  input();\n  printf(\"%d\\n\",s());\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define N 3\n#define N2 9\n#define MAX 100 \n#define true 1\n#define false -1\n\nint puzzle[N][N];\nint tmp[N][N];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nvoid swap(int *a,int *b) {\n  int tmp;\n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\n\nint ca() {\n  int i,k,sum=0;\n  for(i=0;i<N2;i++) {\n    if((k=puzzle[i/3][i%3])) {\n      k--;\n      sum+=abs(i/3-k/3)+abs(i%3-k%3);\n    }\n  }\n  return sum;\n}\n\nint DFS(int x,int y,int p,int dep,const int lim) {\n  int i,h,tx,ty,res,j;\n  h=ca();\n  if(h==0) return dep;\n  if(dep+h>lim){\n    return false;\n  }\n  for(i=0;i<4;i++) {\n    tx=x+dx[i];\n    ty=y+dy[i];\n    if(~p && i==(p+2)%4) continue;\n    if(!(0<=tx && tx<3 && 0<=ty && ty<3))continue;\n    swap(&puzzle[y][x],&puzzle[ty][tx]);\n    res=DFS(tx,ty,i,dep+1,lim);\n    if(~res)return res;\n    swap(&puzzle[y][x],&puzzle[ty][tx]);\n  }\n  \n  return false;\n}\n\nint main(){\n  int i,j,c,k;\n  int x,y,r;\n  \n  for(i=0;i<N;i++) {\n    for(j=0;j<N;j++){\n      scanf(\"%d\",&puzzle[i][j]);\n      if(!puzzle[i][j]){\n\tx=j;\n\ty=i;\n      }\n    }\n  }\n  \n  for(k=0;k<MAX;k++) {\n    memcpy(tmp,puzzle,sizeof(puzzle));\n    c=DFS(x,y,false,0,k);\n    if(c!=false)\n      break;\n    memcpy(puzzle,tmp,sizeof(tmp));\n  }\n\n  printf(\"%d\\n\",c);\n  \n  return 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n#define N 3\n#define S 9\n\ntypedef struct P{\n  int f[S],space,m;\n}Puzzle;\n\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n\nint MDT[S][S];\n\nint limit;\nint path[100];\nPuzzle st;\n\nint get(Puzzle Z){\n  int i,sum=0;\n  for(i=0;i<S;i++){\n    if(Z.f[i] == S) continue;\n    sum+=MDT[i][Z.f[i]-1];\n  }\n  return sum;\n}\n\nint max(int a,int b){\n  if(a<b) return b;\n  else return a;\n}\nint min(int a,int b){\n  if(a<b) return a;\n  else return b;\n}\nvoid swap(int *a,int *b){\n  int t;\n  t=*a;\n  *a=*b;\n  *b=t;\n}\n\nchar dfs(int df,int p){\n  int sx,sy,tx,ty,i;\n  Puzzle tmp;\n\n  if(st.m==0)return 1;\n  if(df+st.m>limit)return 0;\n\n  sx=st.space/N;\n  sy=st.space%N;\n\n  for(i=0;i<4;i++){\n    tx=sx+dx[i];\n    ty=sy+dy[i];\n\n    if(tx<0||tx>=N||ty<0||ty>=N) continue;\n    if(max(p,i)-min(p,i)==2)continue;\n    tmp=st;\n\n    st.m-=MDT[tx*N+ty][st.f[tx*N+ty]-1];\n    st.m+=MDT[sx*N+sy][st.f[tx*N+ty]-1];\n\n    //printf(\"st.m=%d\\n\",st.m);\n\n    swap(&st.f[tx*N+ty],&st.f[sx*N+sy]);\n\n    st.space=tx*N+ty;\n    if(dfs(df+1,i)){\n      path[df]=i;\n      return 1;\n    }\n    st=tmp;\n  }\n  return 0;\n}\n\nint id(Puzzle in){\n  int i;\n  int ans=0;\n\n  in.m=get(in);\n\n  for(limit=in.m;limit<=100;limit++){\n      //  printf(\"aaa\\n\");\n    st=in;\n    if(dfs(0,-100)){\n      ans=0;;\n      for(i=0;i<limit;i++) ans++;\n      return ans;\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int i,j;\n  Puzzle in; \n  for(i=0;i<S;i++) for(j=0;j<S;j++) MDT[i][j]=abs(i/N-j/N)+abs(i%N-j%N);\n  for(i=0;i<S;i++){\n    //printf(\"aaa\\n\");\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i]==0){\n      in.f[i]=S;\n      in.space=i;\n    }\n  }\n  printf(\"%d\\n\",id(in));\n\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<stdlib.h>\nusing namespace std;\nconst int Max = 3;\nint a[4][2]= {0,-1,1,0,0,1,-1,0};\nint last[9][2]= {{2,2},{0,0},{0,1},{0,2},{1,0},{1,1},{1,2},{2,0},{2,1}}; // 目标状态的数字所在位置\nint k[Max][Max],k2[Max*Max],flag=0,limit,Mi;   // k用来保存八数码状态，k2用来计算曼巴顿距离\nint add(int k[Max][Max])       // 曼哈顿距离为 所有的数字要走到目标状态，最少要和0换的次数；\n{\n    int i,j;\n    int sum = 0;\n    for(i=0; i<3; i++)\n        for(j=0; j<3; j++)\n        {\n            if(k[i][j]!=0)     //判断曼哈顿距离不能判断0；\n                sum += abs(i-last[k[i][j]][0])+abs(j - last[k[i][j]][1]);  //求曼哈顿距离\n        }\n    return sum;\n}\nvoid dfs(int y,int x,int len,int f)     // x,y当前0的坐标 len 为已经走了几步了，f为当上一次的搜索方向\n{\n    int s = add(k);                     // 求当前状态的曼哈顿距离\n    if(flag) return;                    // 如果找到符合的结果，不在搜索\n    if(len<=limit)\n    {\n        if(s==0)                        //曼哈顿距离为零，为目标状态\n        {\n            flag=1;\n            Mi=len;\n            return ;\n        }\n        if(len==limit) return;          //递归到了本轮终点，结束\n    }\n    for(int i=0; i<4; i++)\n    {\n        int tx = x + a[i][0];\n        int ty = y + a[i][1];\n        if(tx>=0&&ty>=0&&ty<3&&tx<3&&((f==-1)||i!=(f+2)%4))\n        {\n            swap(k[y][x],k[ty][tx]);    // 让下一个数与 0 交换位置\n            if(len+add(k)<=limit)       // IDA* 值减少，当前走的步数 加上 当前状态到达标状态的最小步数，\n            {\n                // 要小于等于当前枚举到的最小的 从起始状态到达目标状态的步数，不能超过；\n                dfs(ty,tx,len+1,i);\n                if(flag) return ;\n            }\n            swap(k[y][x],k[ty][tx]);    //还原\n        }\n    }\n}\nint main()\n{\n    int i,j;\n    while(~scanf(\"%d\",&k2[0]))\n    {\n        int y,x;\n        k[0][0] = k2[0];\n        if(k2[0]==0)    //记录 0 所在的位置\n        {\n            y = 0;\n            x = 0;\n        }\n        for(i=1; i<Max*Max; i++)\n        {\n            scanf(\"%d\",&k2[i]);\n            k[i/3][i%3] = k2[i];//把输入的数存到二维数组\n            if(k2[i]==0)        //记录 0 所在的位置\n            {\n                y = i/3;\n                x = i%3;\n            }\n        }\n        flag = 0;\n        limit = add(k);        // 当前要达到目标状态的最小步数；\n        while(!flag&&limit<=36)\n        {\n            dfs(y,x,0,-1);\n            if(!flag)          //如果本轮没有满足的条件，扩大搜索范围\n                limit ++;      // 深搜底线 +1\n        }\n        if(flag)\n            printf(\"%d\\n\",Mi);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 3\nint ansArr[N][N]={{1,2,3},\n\t\t  {4,5,6},\n\t\t  {7,8,0}};\nint tempArr[N][N];\nint curMinCost=40;\nvoid calcMinCost(int,int);\nint get0Row(void);\nint get0Col(void);\nint isCorrect(void);\nvoid printArr(void);//debugging\nint main(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    for(j=0;j<N;j++)\n      scanf(\"%d\",&tempArr[i][j]);\n  calcMinCost(0,0);\n  printf(\"%d\\n\",curMinCost);\n  return 0;\n}\nvoid calcMinCost(int cost,int lastMove)\n{\n  int row,col;\n  //printArr();\n  if(cost>=curMinCost) return;\n  if(isCorrect()==1)\n    {\n      curMinCost=cost;\n      return;\n    }\n  row=get0Row();\n  col=get0Col();\n  if(row!=N-1&&lastMove!=3)//slide up\n    {\n      tempArr[row][col]=tempArr[row+1][col];\n      tempArr[row+1][col]=0;\n      calcMinCost(cost+1,1);\n      tempArr[row+1][col]=tempArr[row][col];\n      tempArr[row][col]=0;\n    }\n  if(col!=N-1&&lastMove!=4)//slide left\n    {\n      tempArr[row][col]=tempArr[row][col+1];\n      tempArr[row][col+1]=0;\n      calcMinCost(cost+1,2);\n      tempArr[row][col+1]=tempArr[row][col];\n      tempArr[row][col]=0;\n    }\n  if(row!=0&&lastMove!=1)//slide down\n    {\n      tempArr[row][col]=tempArr[row-1][col];\n      tempArr[row-1][col]=0;\n      calcMinCost(cost+1,3);\n      tempArr[row-1][col]=tempArr[row][col];\n      tempArr[row][col]=0;\n    }\n  if(col!=0&&lastMove!=2)//slide right\n    {\n      tempArr[row][col]=tempArr[row][col-1];\n      tempArr[row][col-1]=0;\n      calcMinCost(cost+1,4);\n      tempArr[row][col-1]=tempArr[row][col];\n      tempArr[row][col]=0;\n    }\n}\nint get0Row(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    for(j=0;j<N;j++)\n      if(tempArr[i][j]==0) return i;\n}\nint get0Col(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    for(j=0;j<N;j++)\n      if(tempArr[i][j]==0) return j;\n}\nint isCorrect(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    for(j=0;j<N;j++)\n      if(ansArr[i][j]!=tempArr[i][j]) return 0;\n  return 1;\n}\nvoid printArr(void)\n{\n  int i,j;//counter\n  for(i=0;i<N;i++)\n    {\n      for(j=0;j<N;j++)\n\t{\n\t  printf(\"%d \",tempArr[i][j]);\n\t}\n      printf(\"\\n\");\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n\nint dfs(int,int,int , int);\n\nint tag();\nvoid change(int *, int *);\n\nint xarr[4]={-1,0,1,0},yarr[4]={0,-1,0,1};\nint array[3][3],sum;\nint main(){\n  int i,j,zerox,zeroy;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      scanf(\"%d\",&array[i][j]);\n      if(array[i][j]==0){\n\t\n\tzerox=j;\n\tzeroy=i;\t\n      }\n    }\n  }\n  \n  for(sum=0;sum<32;sum++){\n    if(dfs(0,10,zerox,zeroy)==1) break;\n  }\n  printf(\"%d\\n\",sum);  /*output*/\n  return 0;\n}\nint  dfs(int dep, int prev, int zerox, int zeroy){\n  int i,xx,yy,ta;\n  ta=tag();\n  if(ta==0) return 1;\n  if(dep+ta>sum) return -1;\n  \n    for(i=0;i<4;i++){\n      if(i-prev==-2 || i-prev==2) continue;\n      xx=zerox+xarr[i];\n      yy=zeroy+yarr[i];\n      if(xx<0 || yy<0 || xx>=3 || yy>=3) continue;\n      change(&array[zeroy][zerox],&array[yy][xx]);\n      \n      if(dfs(dep+1,i,xx,yy)==1) return 1;\n      change(&array[zeroy][zerox],&array[yy][xx]);\n      \n    }\n    return -1;\n    \n}\n\n\n\nint tag(){\n  int i,j,num=0;\n  for(i=0;i<3;i++){\n    for(j=0;j<3;j++){\n      if(array[i][j]==0) continue;\n      num+=abs((array[i][j]-1)/3-i)+abs((array[i][j]-1)%3-j);\n      \n \n    }\n  }\n  return num;\n}\n\n/*exchange array[zeroy][zerox] and array[yy][xx]*/\nvoid change(int * num1, int *num2){  \n  int ch;\n  ch=*num1;\n  *num1=*num2;\n  *num2=ch;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define N 3\n#define N2 9\n#define true 1\n#define false 0\n\nint P[N][N],lim;\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\n\nvoid solve(int,int);\nint isTarget(void);\nint bfs(int,int,int,int);\n\nint main()  \n{\n  int i,j,px,py;\n for(i=0;i<N;i++){\n   for(j=0;j<N;j++){\n   scanf(\"%d\",&P[i][j]);\n   if(P[i][j]==0){\n     px=i;\n     py=j;  }}\n }\n solve(px,py);\n\n return 0;\n}\n\nvoid solve(int px,int py)\n{\n for(lim=0;;lim++){\n   if(bfs(0,99,px,py)){\n     printf(\"%d\\n\",lim);\n     return;}\n                  }\n}\n\nint isTarget()\n{\n  int i,j,sum=0,x,s,t;\n  for(i=0;i<N;i++){\n    for(j=0;j<N;j++){\n    if(P[i][j]==0)continue;\n    x=P[i][j]-1;\n    s=x/N-i;\n    if(s<0)s=s*(-1);\n    t=x%N-j;\n    if(t<0)t=t*(-1);\n    sum+=s+t;}}\n  return sum;\n}\n\nint bfs(int depth,int prev,int px,int py)\n{\n  int h,r,tx,ty,p,q,z;\n  h=isTarget();\n  if(h==0)return true;\n  if(depth+h>lim)return false;\n \n    for(r=0;r<4;r++){\n      if((r-prev)==2 && (r-prev)==-2)continue;  \n      tx=px+dx[r];\n      ty=py+dy[r];\n      if(tx<0 || ty<0 || tx >=N || ty>=N)continue;\n      \n      z=P[tx][ty];\n      P[tx][ty]=P[px][py];\n      P[px][py]=z;\n     \n      if(bfs(depth+1,r,tx,ty))return true;\n      z=P[tx][ty];\n      P[tx][ty]=P[px][py];\n      P[px][py]=z;\n\t\t\t }\n  return false;\n}\n\n\n\n  \n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 9\n\nint board[N];\nint rows = 3, cols = 3, zeroIndex;\n\n// for previousMove: 0 is down, 1 is up, 2 is left, 3 is right\nint blindSearch(int x, int y, int moves, int previousMove) {\n  int i, foundAnswer;\n\n  // answer is less than manhattan distance, not possible\n  if (moves < (x + y))\n    return 0;\n\n  if (!moves) {\n    for (i = 0; i < N - 1; i++) {\n      if (board[i] != i + 1)\n        return 0;\n    }\n\n    return 1;\n  }\n\n  if (x > 0 && previousMove != 1) {\n    // can expand down\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n\n    foundAnswer = blindSearch(x - 1, y, moves - 1, 0);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n  }\n\n  if (y > 0 && previousMove != 3) {\n    // right\n    board[zeroIndex] = board[zeroIndex + 1];\n    zeroIndex++;\n\n    foundAnswer = blindSearch(x, y - 1, moves - 1, 2);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex - 1];\n    zeroIndex--;\n  }\n\n  if (y < rows - 1 && previousMove != 2) {\n    // left\n    board[zeroIndex] = board[zeroIndex - 1];\n    zeroIndex--;\n\n    foundAnswer = blindSearch(x, y + 1, moves - 1, 3);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex + 1];\n    zeroIndex++;\n  }\n\n  if (x < cols - 1 && previousMove != 0) {\n    // up\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n\n    foundAnswer = blindSearch(x + 1, y, moves - 1, 1);\n    if (foundAnswer)\n      return 1;\n\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n  }\n\n  return 0;\n}\n\nint main() {\n  int i, x, y, current;\n\n  for (i = 0; i < N; i++) {\n    scanf(\"%d\", &board[i]);\n    if (!board[i])\n      zeroIndex = i;\n  }\n\n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n\n  for (current = 0; current < 50; current++) {\n    if (blindSearch(x, y, current, -1)) {\n      printf(\"%d\\n\", current);\n      return;\n    }\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\ntypedef char Board[10];\nBoard ini_board;// = \"130425786\";\nBoard board;// = \"130425786\";\nconst Board target = \"123456780\";\n\n//Board history[30000];\nBoard *history;\nint nhistories=0;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nint minstep = INT_MAX;\n\nconst Motion candidate[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nint move(Motion m)\n{\n  //  printf(\"[%c%c]\\n\", board[m.pos], \"UDLR\"[m.dir]);\n  if (board[m.pos]==target[m.pos]) return -1;\n  switch (m.dir) {\n  case U:\n    if (m.pos<3) return -1;\n\n    board[m.pos-3] = board[m.pos];\n    break;\n  case D:\n    if (m.pos>5) return -1;\n\n    board[m.pos+3] = board[m.pos];\n    break;\n  case L:\n    if (m.pos%3==0) return -1;\n\n    board[m.pos-1] = board[m.pos];\n    break;\n  case R:\n    if (m.pos%3==2) return -1;\n\n    board[m.pos+1] = board[m.pos];\n    break;\n  }\n  board[m.pos] = '0';\n  return m.pos;\n}\n\nvoid search_path(int step, int space)\n{\n  int i, j;\n  if (strcmp(board, \"123456780\")==0) {\n    //    printf(\"STEP=%d\\n\", step);\n    if (step<minstep) minstep=step;\n    \n  } else {\n\n    int s2;\n    if (step>=minstep) return;\n    if (step>0 && strcmp(board, ini_board)==0) return;\n    \n    Board board_bak;\n    strcpy(board_bak, board);\n    int nhistories_bak=nhistories;\n    \n    for (i=0; candidate[space][i].pos>=0; i++) {\n\n      if ((s2 = move(candidate[space][i]))<0) continue;\n      for (j=0; j<nhistories; j++) {\n\tif (strcmp(board, history[j])==0) break;\n      }\n      if (j==nhistories) {\n\tstrcpy(history[nhistories++], board); \n\tsearch_path(step+1, s2);\n      }\n      nhistories = nhistories_bak;\n      strcpy(board, board_bak);\n    }\n  }\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board[0],&board[1],&board[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[3],&board[4],&board[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[6],&board[7],&board[8]);\n  strcpy(ini_board, board);\n  int space = strchr(board, '0')-board;\n  \n  history = (Board*)malloc(sizeof(Board)*100000);\n  search_path(0, space);\n  printf(\"%d\\n\", minstep);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint puzz[3][3];\nint temp[3][3];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nvoid empty(int *x,int *y){\n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n      if(!puzz[i][j]){\n\t*x = j;\n\t*y = i;\n\treturn;\n      }\n    }\n  }\n}\n\nvoid swap(int *a,int *b){\n  int temp = *a;\n  *a = *b;\n  *b = temp;\n}\n\nint cal(){\n  int sum = 0;\n  for(int i=0;i<9;++i){\n    int a = puzz[i/3][i%3];\n    if(a){\n      a--;\n      sum += abs(i/3 - a/3) + abs(i%3 - a%3);\n    }\n  }\n  return sum;\n}\n\nint dfs(int x,int y,int p,int dep,const int lim){\n  int h=cal();\n  if(h==0)return dep;\n\n  if(dep+h>lim)return -1;\n\n  for(int i=0;i<4;++i){\n    int nx=x+dx[i];\n    int ny=y+dy[i];\n\n    if(p!=-1 && i==(p+2)%4)continue;\n    \n    if(0<=nx && nx<3 && 0<=ny && ny < 3){\n      swap(&puzz[y][x],&puzz[ny][nx]);\n      int res=dfs(nx,ny,i,dep+1,lim);\n      if(res!=-1)return res;\n\n      swap(&puzz[y][x],&puzz[ny][nx]);\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int i,j,l;\n  \n  for(i=0;i<3;++i){\n    for(j=0;j<3;++j)scanf(\"%d\",&puzz[i][j]);\n  }\n\n  int x=0,y=0;\n  empty(&x,&y);\n\n  for(l=0;l<100;++l){\n    for(i=0;i<3;++i){\n      for(j=0;j<3;++j)temp[i][j] = puzz[i][j];\n    }\n \n    int ans = dfs(x,y,-1,0,l);\n    if(ans!=-1){\n      printf(\"%d\\n\",ans);\n      break;\n    }\n\n    for(i=0;i<3;++i){\n      for(j=0;j<3;++j)puzz[i][j] = temp[i][j];\n    }\n\n    ans  = -1;\n    if(l==99)printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n\n\nextern void down_0(void);\nextern void up_0(void);\nextern void right_0(void);\nextern void left_0(void);\nextern int  serch(int x, int y, int MaxCnt);\nextern int  check(void);\n\nint cnt,num = 0;\nint val[Total] ={};\n\n\nint main( void )\n{\n    int i = 0;\n    int x,y = 0;\n    \n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        \n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n    \n    x = tate - (num/yoko) -1;\n    y = yoko - (num%yoko) -1;\n    \n//    printf(\"%d,%d\\n\",x,y);\n    \n    for(i=1; i<45; i++)\n    {\n        if( serch(x,y,i) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt)\n{\n    int result;\n    int i=0;\n    \n    // 最大数で打ち切り\n    if(MaxCnt==0)\n    {\n        return check();\n    }\n    \n    //\n    if(x==0 && y==0)\n    {\n        if( check() )\n        {\n            return 1;\n        }\n    }\n    \n    // 上下左右で4回回す\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if(x > 0)\n                {\n                    down_0();\n                    \n                    result = serch(x-1, y, MaxCnt-1);\n                    \n                    up_0();\n                }\n                break;\n            case 1:\n                if(y > 0)\n                {\n                    right_0();\n                    \n                    result = serch(x, y-1, MaxCnt-1);\n                    \n                    left_0();\n                }\n                break;\n            case 2:\n                if(y < yoko)\n                {\n                    left_0();\n                    \n                    result = serch(x, y+1, MaxCnt-1);\n                    \n                    right_0();\n                }\n                break;\n            case 3:\n                if(x < tate)\n                {\n                    up_0();\n                    \n                    result = serch(x+1, y, MaxCnt-1);\n                    \n                    down_0();\n                }\n                break;\n            default:\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n        \n    }\n\n    return 0;\n}\n\n// TRUE : 完成\n// FALSE : 失敗\nint check()\n{\n    int i=0;\n    \n//    printf(\"%d%d%d%d%d%d%d%d%d\\n\", val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7], val[8]);\n    \n    for(i=0; i<Total-1; i++)\n    {\n        if(val[i] != (i+1))\n        {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid down_0()\n{\n    val[num] = val[num + yoko];\n    val[num + yoko] = 0;\n    num = num + yoko;\n}\n \nvoid up_0()\n{\n    val[num] = val[num - yoko];\n    val[num - yoko] = 0;\n    num = num - yoko;\n}\n \nvoid right_0()\n{\n    val[num] = val[num +1];\n    val[num +1] = 0;\n    num = num + 1;\n}\n \nvoid left_0()\n{\n    val[num] = val[num -1];\n    val[num -1] = 0;\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define N 3\n#define LIM 32\n#define HN 362897\n\nstruct dep{\n  int depth,key;\n};\n\nint ans[N][N]={\n  {1,2,3},\n  {4,5,6},\n  {7,8,0}\n};\n\nint min = LIM;\nstruct dep h[HN];\n\nint hash1(int k)\n{\n  return k % HN;\n}\nint hash2(int k)\n{\n  return 1 + k%(HN-1);\n}\nint hash(int k, int i)\n{\n  return (hash1(k) + i*hash2(k))%HN;\n}\n\n\nvoid dfs(int p[N][N], int n)\n{\n  int i,j,i0,j0,a=0,b=1;\n  int f=0;\n  int tmp[N][N];\n  for(i=0;i<N;i++)\n  {\n    for(j=0;j<N;j++)\n    {\n      if(ans[i][j]!=p[i][j])f++;\n      if(p[i][j]==0)\n      {\n        i0=i;\n        j0=j;\n      }\n      a+=p[i][j]*b;\n      b*=10;\n    }\n  }\n\n  if(f==0)\n  {\n    if(min>=n)\n    {\n      min=n;\n    }\n    return;\n  }\n  if(n>min) return;\n  i=0;\n  while(1)\n  {\n    b=hash(a, i);\n    if(h[b].key == 0)\n    {\n      h[b].key=a;\n      h[b].depth=n;\n      break;\n    }\n    else if(h[b].key == a)\n    {\n      if(h[b].depth>n)\n      {\n        h[b].depth=n;\n        break;\n      }\n      else return;\n    }\n    i++;\n  }\n\n  if(i0>0 && i0<N)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0-1][j0];\n    tmp[i0-1][j0]=f;\n    dfs(tmp, n+1);\n  }\n  if(j0>0 && j0<N)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0][j0-1];\n    tmp[i0][j0-1]=f;\n    dfs(tmp, n+1);\n  }\n\n  if(i0>=0 && i0<N-1)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0+1][j0];\n    tmp[i0+1][j0]=f;\n    dfs(tmp, n+1);\n  }\n  if(j0>=0 && j0<N-1)\n  {\n    memcpy(tmp,p,sizeof(int)*N*N);\n    f=tmp[i0][j0];\n    tmp[i0][j0]=tmp[i0][j0+1];\n    tmp[i0][j0+1]=f;\n    dfs(tmp, n+1);\n  }\n\n}\n\nint main()\n{\n  int i,j;\n  int p[N][N];\n\n  for(i=0;i<N;i++)\n  {\n    for(j=0;j<N;j++)\n    {\n      scanf(\"%d\",&p[i][j]);\n    }\n  }\n  dfs(p,0);\n\n  printf(\"%d\\n\",min);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define N 3\n\nint search(int board[N][N], int min, int limit, int r_0, int c_0);\n\nint main(int argc, char *argv[])\n{\n  int board[N][N];\n  int md;\n  int i, j, r, c, r_0, c_0, found;\n  int res;\n\n  for (i = 0; i < N; i++) {\n    for (j = 0; j < N; j++) scanf(\"%d\", &board[i][j]);\n  }\n\n  md = 0;\n  for (i = 0; i < N * N; i++) {\n    found = 0;\n    for (r = 0; r < N; r++) {\n      for (c = 0; c < N; c++) {\n\tif (board[r][c] == i) {\n\t  if (i == 0) {\n\t    r_0 = r;\n\t    c_0 = c;\n\t  } else md += (int)fabs((i-1)/N - r) + (int)fabs((i-1)%N - c);\n\t  found = 1;\n\t  break;\n\t}\n      }\n      if (found == 1) break;\n    }\n  }\n\n  for (i = 0; ; i += 2) {\n    if ((r_0 + c_0) % 2 == 0) {\n      if (md % 2 == 0) res = search(board, md, md+i, r_0, c_0);\n      else res = search(board, md, md+i+1, r_0, c_0);\n    } else {\n      if (md % 2 == 0) res = search(board, md, md+i+1, r_0, c_0);\n      else res = search(board, md, md+i, r_0, c_0);\n    }\n\n    if (res != -1) break;\n  }\n\n  printf(\"%d\\n\", res);\n\n  return 0;\n}\n\nint search(int board[N][N], int min, int limit, int r_0, int c_0)\n{\n  int md_c;\n  int num;\n  int res[4];\n\n  if (min == 0) return 0;\n\n  if (r_0 != 0) {\n    md_c = min;\n    num = board[r_0-1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0-1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0-1][c_0] = 0;\n      board[r_0][c_0] = num;\n      res[0] = search(board, md_c, limit-1, r_0-1, c_0);\n      if (res[0] == -1) {\n\tboard[r_0-1][c_0] = num;\n\tboard[r_0][c_0] = 0;\n      } else res[0]++;\n    } else res[0] = -1;\n  } else res[0] = -1;\n\n  if (r_0 != N-1) {\n    md_c = min;\n    num = board[r_0+1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0+1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0+1][c_0] = 0;\n      board[r_0][c_0] =num;\n      res[1] = search(board, md_c, limit-1, r_0+1, c_0);\n      if (res[1] == -1) {\n\tboard[r_0+1][c_0] = num;\n\tboard[r_0][c_0] = 0;\n      } else res[1]++;\n    } else res[1] = -1;\n  } else res[1] = -1;\n\n  if (c_0 != 0) {\n    md_c = min;\n    num = board[r_0][c_0-1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0-1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0-1] = 0;\n      board[r_0][c_0] = num;\n      res[2] = search(board, md_c, limit-1, r_0, c_0-1);\n      if (res[2] == -1) {\n\tboard[r_0][c_0-1] = num;\n\tboard[r_0][c_0] = 0;\n      } else res[2]++;\n    } else res[2] = -1;\n  } else res[2] = -1;\n\n  if (c_0 != N-1) {\n    md_c = min;\n    num = board[r_0][c_0+1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0+1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0+1] = 0;\n      board[r_0][c_0] = num;\n      res[3] = search(board, md_c, limit-1, r_0, c_0+1);\n      if (res[3] == -1) {\n        board[r_0][c_0+1] = num;\n        board[r_0][c_0] = 0;\n      } else res[3]++;\n    } else res[3] = -1;\n  } else res[3] = -1;\n\n  if (res[0] == -1 && res[1] == -1 && res[2] == -1 && res[3] == -1) return -1;\n  else if (res[0] != -1) return res[0];\n  else if (res[1] != -1) return res[1];\n  else if (res[2] != -1) return res[2];\n  else return res[3];\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n \n#define N 3\n#define LIM 32\n#define HN 362897\n \nstruct dep{\n    int depth,key;\n};\n \nint ans[N][N]={\n    {1,2,3},\n    {4,5,6},\n    {7,8,0}};\n \nint min = LIM;\nstruct dep h[HN];\n \nint hash1(int k)\n{\n    return k % HN;\n}\nint hash2(int k)\n{\n    return 1 + k%(HN-1);\n}\nint hash(int k, int i)\n{\n    return (hash1(k) + i*hash2(k))%HN;\n}\n \n \nvoid dfs(int p[N][N], int n)\n{\n    int i,j,i1,j1,a=0,b=1;\n    int f=0;\n    int tmp[N][N];\n    //printf(\"A\\n\");\n    for(i=0;i<N;i++)\n    {\n        for(j=0;j<N;j++)\n        {\n            if(ans[i][j]!=p[i][j])f++;\n            if(p[i][j]==0)\n            {\n                i1=i;\n                j1=j;\n            }\n            a+=p[i][j]*b;\n            b*=10;\n        }\n    }\n     \n    if(f==0)\n    {\n        if(min>=n)\n        {\n            min=n;\n        }\n        return;\n    }\n    if(n>min) return;\n    i=0;\n    while(1)\n    {\n        b=hash(a, i);\n        if(h[b].key == 0)\n        {\n            h[b].key=a;\n            h[b].depth=n;\n            break;\n        }\n        else if(h[b].key == a)\n        {\n            if(h[b].depth>n)\n            {\n                h[b].depth=n;\n                break;\n            }\n            else return;\n        }\n        i++;\n    }\n     \n    if(i1>0 && i1<N)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i1][j1];\n        tmp[i1][j1]=tmp[i1-1][j1];\n        tmp[i1-1][j1]=f;\n        dfs(tmp, n+1);\n    }\n    if(j1>0 && j1<N)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i1][j1];\n        tmp[i1][j1]=tmp[i1][j1-1];\n        tmp[i1][j1-1]=f;\n        dfs(tmp, n+1);\n    }\n     \n    if(i1>=0 && i1<N-1)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i1][j1];\n        tmp[i1][j1]=tmp[i1+1][j1];\n        tmp[i1+1][j1]=f;\n        dfs(tmp, n+1);\n    }\n    if(j1>=0 && j1<N-1)\n    {\n        memcpy(tmp,p,sizeof(int)*N*N);\n        f=tmp[i1][j1];\n        tmp[i1][j1]=tmp[i1][j1+1];\n        tmp[i1][j1+1]=f;\n        dfs(tmp, n+1);\n    }\n     \n}\n \nint main()\n{\n    int i,j;\n    int p[N][N];\n     \n    for(i=0;i<N;i++)\n    {\n        for(j=0;j<N;j++)\n        {\n            scanf(\"%d\",&p[i][j]);\n        }\n    }\n    dfs(p,0);\n     \n    printf(\"%d\\n\",min);\n     \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n\n#define N 3\n#define N2 9\n#define MAX 500000\n\ntypedef struct Puzzle{\n  int f[N2];\n  int space;\n  int path;\n} Puzzle ;\n\nint bfs(Puzzle s);\nvoid swap(int x, int y);\nvoid enqueue(Puzzle x);\nint sort(Puzzle p);\nint isTarget(Puzzle p);\n\nint V[MAX];\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\n\nint main(){\n  Puzzle in;\n  int ans;\n\n  for(int i = 0; i < N2; i++){\n    scanf(\"%d\",&in.f[i]);\n    if(in.f[i] == 0){\n      in.f[i] = N2;\n      in.space = i;\n    }\n  }\n\t\n\n   ans = bfs(in);\n  printf(\"%d\\n\",ans);\n\n  return 0;\n}\n\nvoid swap(int x, int y){\n  int z;\n  z = x;\n  x = y;\n  y = z;\n}\n\n\nstruct Puzzle Q[MAX];\nint head = 0, tail = 0;\n\nvoid enqueue(Puzzle x){\nint next;\n   next = (tail+1)%MAX;  \n  Q[tail] = x;\n  tail = next;\n}\n\nPuzzle dequeue(){\n  Puzzle t; \n  t = Q[head];\n  head = (head+1)%MAX;\n  return t;\n}\n\nint sort(Puzzle p){\n  int i, j, key, count, n = 0;\n  for(i = 0, key = 1; i < N2; key *= ++i){\n    for(j = 0, count = 0; j < i; j++){\n      if(p.f[j] < p.f[i])count++;\n    }\n    n += count * key;\n  }\n  return n;\n}\n\nint isTarget(Puzzle p){\n  for(int i = 0; i < N2; i++){\n  \tif(p.f[i] != (i+1)) return 0;\n  }\n  return 1;\n}\n\nint bfs(Puzzle s){\n  struct Puzzle u, v;\n  s.path = 0;\n  enqueue(s);\n  V[sort(s)] = 1;\n  \n\n  while(head != tail){ \n  int sx, sy, tx, ty, num, r;\n    u = dequeue();\n    if(isTarget(u) )return u.path;\n     sx = u.space / N;\n     sy = u.space % N;\n    for(int r = 0; r < 4; r++){\n       tx = sx + dx[r];\n       ty = sy + dy[r];\n      if(tx < 0 || ty < 0 || tx >= N || ty >= N)continue;\n      v = u;\n       num = v.f[u.space];\n      v.f[u.space] = v.f[tx * N + ty];\n      v.f[tx * N + ty] = num;\n      v.space = tx * N + ty;\n      if(V[sort(v)] != 1){\n\tV[sort(v)] = 1;\n\tv.path++;\n\tenqueue(v);\n      }\n    }\n  }\n\n  return -1;\n}\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 3\n#define NN N*N\n#define BACK 0\n#define FOUND 1\n\nint dfs(int *);\nint visit(int *, int);\nint heuristic(int *);\nvoid printpuzzle(int *);\nvoid puzzlecopy(int *, int *);\nint zettaichi(int);\n\n\nint d; //depthlimit\nint goal[NN+1];\n\nint main()\n{\n  int i, j, number;\n  int g; // current depth\n  int puzzle[NN+1]; //添字０はつかわないため＋１\n  \n  puzzle[0] = 0;\n  for(i = 1; i <= NN; i++) {\n    scanf(\"%d\",&puzzle[i]);\n  }\n\n  d = heuristic(puzzle);\n  \n  goal[0] = 0;\n  goal[NN] = 0;\n   for(i = 1; i < NN; i++) {\n     goal[i] = i;\n  }\n\n\n  dfs(puzzle);\n\n  return 0;\n}\n\nint heuristic(int *puzzle)\n{\n  int i, j, x, tatecost, yokocost, totalcost = 0;\n\n  for(i = 1; i <= NN; i++) {\n    if(puzzle[i] != 0) {\n      tatecost = zettaichi((i-1)/3 - (puzzle[i]-1)/3);\n      yokocost = zettaichi((i+2)%3 - (puzzle[i]+2)%3);\n\t\n\ttotalcost += tatecost + yokocost;\n    }\n  }\n\n  return totalcost;\n}\n\nvoid printpuzzle(int *puzzle)\n{\n  int i, j, number = 1;\n  \n  for(i = 0; i < N; i++) {\n    for(j = 0; j < N; j++) {\n      printf(\" %d\",puzzle[number]);\n      number++;\n    }\n    printf(\"\\n\");\n  }\n  \n}\n\nint dfs(int *puzzle)\n{\n  int i;\n\n  while(1) {\n    if(visit(puzzle, 0) == FOUND) break;\n    d++;\n  }\n\n  return i;\n}\n\nint visit(int *puzzle, int g)\n{\n  int i, blanknumber, status, found;\n  int copypuzzle[NN+1];\n\n  found = 1;\n  for(i = 1; i <= NN; i++) {\n    if(puzzle[i] != goal[i]) {\n      found = 0;\n      break;\n    }\n  }\n  if(found == 1) {\n    printf(\"%d\\n\",g);\n    return FOUND;\n  }\n  \n  if(g + heuristic(puzzle) > d) return BACK;\n\n  //空白位置の確認\n  for(i = 1; i <= NN; i++) {\n    if(puzzle[i] == 0) {\n      blanknumber = i;\n      break;\n    }\n  }\n\n  //0を下と交換\n  if((blanknumber-1)/3 != 2) {\n    puzzlecopy(puzzle, copypuzzle);\n    copypuzzle[blanknumber] = copypuzzle[blanknumber+3];\n    copypuzzle[blanknumber+3] = 0;\n    if(visit(copypuzzle, g+1) == FOUND) return FOUND;\n  }\n\n  //0を右と交換\n  if((blanknumber+2)%3 != 2) {\n    puzzlecopy(puzzle, copypuzzle);\n    copypuzzle[blanknumber] = copypuzzle[blanknumber+1];\n    copypuzzle[blanknumber+1] = 0;\n    if(visit(copypuzzle, g+1) == FOUND) return FOUND;\n  }\n\n  //0を左と交換\n  if((blanknumber+2)%3 != 0) {\n    puzzlecopy(puzzle, copypuzzle);\n    copypuzzle[blanknumber] = copypuzzle[blanknumber-1];\n    copypuzzle[blanknumber-1] = 0;\n    if(visit(copypuzzle, g+1) == FOUND) return FOUND;\n  }\n\n  //0を上と交換\n  if((blanknumber-1)/3 != 0) {\n    puzzlecopy(puzzle, copypuzzle);\n    copypuzzle[blanknumber] = copypuzzle[blanknumber-3];\n    copypuzzle[blanknumber-3] = 0;\n    if(visit(copypuzzle, g+1) == FOUND) return FOUND;\n  }\n\n  return BACK;\n}\n\n\nint zettaichi(int x)\n{\n  if(x < 0) x = -x;\n  return x;\n}\n\nvoid puzzlecopy(int *puzzle, int *copypuzzle)\n{\n  int i;\n  \n  for(i = 1; i <= NN; i++) {\n    copypuzzle[i] = puzzle[i];\n  }\n}\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ ALDS1_13_B 8 Puzzle\n// 2018.5.8 bal4u\n\n#include <stdio.h>\n\ntypedef unsigned char uchar;\n\n#define HASHSIZ 300007 // 543217\ntypedef struct { unsigned s; char x, v; } HASH;\nHASH hash[HASHSIZ+3], *hashend = hash+HASHSIZ;\n\nint lookup(unsigned s, int x)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) return hp->v;\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\treturn 0;\n}\n\nvoid insert(unsigned s, int x, char v)\n{\n\tlong long t = ((long long)x << 32) + s;\n\tHASH *hp = hash + (int)(t % HASHSIZ);\n\twhile (hp->s) {\n\t\tif (hp->s == s && hp->x == x) { hp->v = v; break; }\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\thp->s = s, hp->x = x, hp->v = v;\n}\n\n#define QMAX 30000\ntypedef struct { unsigned s; char x, v; } T;\nT s[QMAX+3]; int top, end;\nint hi[9] = {2,3,2,3,4,3,2,3,2};\nint to[9][4] = {{1,3},{0,2,4},{1,5},{0,4,6},{1,3,5,7},{2,4,8},{3,7},{4,6,8},{5,7}};\n\nvoid toArray(char *nine, unsigned s, int x)\n{\n\tint i;\n\t\n\tfor (i = 8; i >= 0; i--) {\n\t\tif (i == x) nine[i] = 0;\n\t\telse nine[i] = s & 0xf, s >>= 4;\n\t}\n}\n\nunsigned swap(char *nine, int zero, int nx)\n{\n\tint i;\n\tunsigned res;\n\t\n\tres = 0;\n\tfor (i = 0; i < 9; i++) {\n\t\tif      (i == zero) res <<= 4, res |= nine[nx];\n\t\telse if (i != nx)   res <<= 4, res |= nine[i];\n\t}\n\treturn res;\n}\n\n#define MAGIC 21\n\nint main()\n{\n\tint i, x, nx, v, nv, t;\n\tunsigned a, na;\n\tunsigned gs; int gx;\t// goal\n\tchar nine[9];\n\t\n\tgs = 0; for (i = 0; i < 9; i++) {\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 0) gx = i;\n\t\telse gs <<= 4, gs |= t;\n\t}\n\ts[0].s = 0x12345678, s[0].x = 8;\n\ts[1].x = -1;\n\ttop = 0, end = 2;\n\tinsert(s[0].s, s[0].x, 0);\n\tv = 0;\n\twhile (top != end) {\n\t\ta = s[top].s, x = s[top].x;\n\t\tif (++top == QMAX) top = 0; \n\t\tif (x < 0) {\n\t\t\tif (v == MAGIC) break;\n\t\t\tv++;\n\t\t\ts[end].x = -1; if (++end == QMAX) end = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (x == gx && a == gs) goto done;\n\t\tif (lookup(a, x) < v) continue;\n\n\t\ttoArray(nine, a, x);\n\t\tfor (i = 0; i < hi[x]; i++) {\n\t\t\tnx = to[x][i];\n\t\t\tna = swap(nine, x, nx), nv = v+1;\n\t\t\tt = lookup(na, nx);\n\t\t\tif (!t || nv < t) {\n\t\t\t\ts[end].s = na, s[end].x = nx;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t\tinsert(na, nx, nv);\n\t\t\t}\n\t\t}\n\t}\n\n\ts[0].s = gs, s[0].x = gx, s[1].x = -1;\n\ttop = 0, end = 2;\n\tv = 0;\n\twhile (top != end) {\n\t\ta = s[top].s, x = s[top].x;\n\t\tif (++top == QMAX) top = 0; \n\t\tif (x < 0) {\n\t\t\tv++;\n\t\t\ts[end].x = -1; if (++end == QMAX) end = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((t = lookup(a, x)) > 0) { v += t; break; }\n\n\t\ttoArray(nine, a, x);\n\t\tfor (i = 0; i < hi[x]; i++) {\n\t\t\tnx = to[x][i];\n\t\t\tna = swap(nine, x, nx), nv = v+1;\n\t\t\tt = lookup(na, nx);\n\t\t\tif (!t || nv < t) {\n\t\t\t\ts[end].s = na, s[end].x = nx;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tprintf(\"%d\\n\", v);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint mas[3][3];\nint cpy[3][3];\n????\nvoid input() {\n????int i, j;\n????for(i = 0; i < 3; i++)\n????????for(j = 0; j < 3; j++)\n????????????scanf(\"%d\", &mas[i][j]);\n}\n????\nvoid output() {\n????int i, j;\n????for(i = 0; i < 3; i++) {\n????????for(j = 0; j < 3; j++) printf(\"%3d\", mas[i][j]);\n????????puts(\"\");\n????}\n}\n????\nvoid copy(int m[3][3], int t[3][3]) {\n????int i, j;\n????\n????for(i = 0; i < 3; i++)\n????????for(j = 0; j < 3; j++) m[i][j] = t[i][j];\n}\n????\nint calc() {\n????int i, sum = 0;\n????for(i = 0; i < 9; i++) {\n????????int v = mas[i/3][i%3];\n????????if(v) {\n????????????v--;\n????????????sum += abs(i/3-v/3)+abs(i%3-v%3);\n????????}\n????}\n????return sum;\n}\n????\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n????\nvoid swap(int *a, int *b) {\n????int tmp = *a;\n????*a = *b;\n????*b = tmp;\n}\n????\nint is_in(int x, int y) {\n????return 0<=x&&x<3&&0<=y&&y<3;\n}\n????\nint dfs(int x, int y, int p, int dep, const int lim) {\n????int i, h = calc();\n????//output();\n????if(h == 0) return dep;\n????//printf(\"%d %d %d\\n\", h, lim, p);\n????if(dep+h > lim) return -1;\n????\n????for(i = 0; i < 4; i++) {\n????????int nx = x+dx[i], ny = y+dy[i], res;\n????????if(~p && i == (p+2)%4) continue;\n????????if(!is_in(nx, ny)) continue;\n????????swap(&mas[y][x], &mas[ny][nx]);\n????????res = dfs(nx, ny, i, dep+1, lim);\n????????if(~res) return res;\n????????swap(&mas[y][x], &mas[ny][nx]);\n????}\n????\n????return -1;\n}\n????\nvoid get_empty(int *x, int *y) {\n????int i, j;\n????for(i = 0; i < 3; i++) {\n????????for(j = 0; j < 3; j++) {\n????????????if(!mas[i][j]) {\n????????*x = j;\n????????*y = i;\n????????return;\n????????????}\n????????}\n????}\n}\n????\nint solve() {\n????int x, y, lim, ans;\n????get_empty(&x, &y);\n????for(lim = 0; lim < 50; lim++) {\n????????copy(cpy, mas);\n????????if((ans = dfs(x, y, -1, 0, lim)) != -1) return ans;\n????????copy(mas, cpy);\n????}\n????return -1;\n}\n????\nint main() {\n????input();\n????printf(\"%d\\n\", solve());\n????return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<string.h>\n#include<stdbool.h>\n#define N 3\n#define M 9\n#define MAX 362880 \nstatic const int dx[4]={-1,0,1,0};\nstatic const int dy[4]={0,-1,0,1};\ntypedef struct{\n  int f[M];\n  int path;\n  int none;\n}pazzle;\npazzle A[MAX];\nint B[MAX];\nint head,tail;\n\nint empty(void);\nint check(pazzle);\npazzle front(void);\nvoid push(pazzle);\nbool isTarget(pazzle);\nint bfs(pazzle);\n\nint main(){\n  pazzle X;\n  int answer,i;\n  for(i=0;i<M;i++){\n    scanf(\"%d\",&X.f[i]);\n    if(X.f[i]==0){\n      X.f[i]=M;\n      X.none=i;\n    }\n  }\n  answer=bfs(X);\n  printf(\"%d\\n\",answer);\n  return 0;\n}\n\nint bfs(pazzle X){\n  int sx,sy,tx,ty,i,temp;\n  pazzle a,b;\n  X.path=0;\n  push(X);\n  B[check(X)]=1;\n  while(!empty()){\n    a=front();\n    if(isTarget(a))\n      return a.path;\n    sx=a.none/N;\n    sy=a.none%N;\n    for(i=0;i<4;i++){\n      tx=sx+dx[i];\n      ty=sy+dy[i];\n      if(tx<0||ty<0||tx>=N||ty>=N)\n\tcontinue; \n      b=a;\n      temp=b.f[a.none];\n      b.f[a.none]=b.f[tx*N+ty];\n      b.f[tx*N+ty]=temp;\n      b.none=tx*N+ty;\n      if(!B[check(b)]){\n\tB[check(b)]=1;\n\tb.path++;\n\tpush(b);\n      }\n    }\n  }\n  return -1;\n}\n\nbool isTarget(pazzle X){\n  int i,j;\n  for(i=0;i<M;i++){\n    if(X.f[i]!=(i+1))\n      return false;\n  }\n  return true;\n}\n\nvoid push(pazzle X){\n  A[tail]=X;\n  tail=(tail+1)%MAX;\n}\n\npazzle front(void){\n  pazzle x;\n  x=A[head];\n  head=(head+1)%MAX;\n  return x;\n}\n\nint check(pazzle x){\n  int i,j,z,count,result=0;\n  for(i=0,z=1;i<M;z*=++i){\n    for(j=0,count=0;j<i;j++){\n      if(x.f[j]<x.f[i])\n\tcount++;\n    }\n    result+=count*z;\n  }\n  return result;\n}\n\nint empty(void){\n  return head==tail;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define tate 3\n#define yoko 3\n#define Total (tate*yoko)\n#define TryCnt 45\n\nextern inline void down_0(void);    // 0 を下に移動\nextern inline void up_0(void);      // 0 を上に移動\nextern inline void right_0(void);   // 0 を右に移動\nextern inline void left_0(void);    // 0 を左に移動\n\nextern int  serch(int x, int y, int MaxCnt, int pre);\n\nint num = 0;        // 0 の位置を示す\nint val[Total] ={}; // 数値配列\n\n\nint main( void )\n{\n    int i = 0;\n    int x,y = 0;\n    \n    // 文字列の取り込み\n    for(i=0; i<Total; i++)\n    {\n        scanf(\"%d\",&val[i]);\n        \n        if(val[i] == 0)\n        {\n            num = i;\n        }\n    }\n    \n    // 右下に行くために 0 を何回動かせばいいか。\n    x = tate - (num/yoko) -1;\n    y = yoko - (num%yoko) -1;\n    \n    for(i=0; i<TryCnt; i++)\n    {\n        if( serch(x,y,i,4) == 1 )\n        {\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }     \n    \n    return 0;\n}\n\nint serch(int x, int y, int MaxCnt, int pre)\n{\n    int result;\n    int i=0;\n    \n    if(MaxCnt < (x + y) )\n    {\n        return 0;\n    }\n    \n    // 最大数でゴールと一致しているか確認\n    if(MaxCnt==0)\n    {\n        for(i=0; i<Total-1; i++)\n        {\n            if(val[i] != (i+1))\n            {\n                // ゴールと不一致\n                return 0;\n            }\n        }\n        // ゴールと一致！！\n        return 1;\n    }\n    \n    \n    // 0 の移動\n    for(i=0; i<4; i++)\n    {\n        result = 0;\n        \n        switch(i)\n        {\n            case 0:\n                if( (x > 0) && (pre != 3) )\n                {\n                    down_0();\n                    \n                    result = serch(x-1, y, MaxCnt-1, 0);\n                    \n                    up_0();\n                }\n                break;\n                \n            case 1:\n                if( (y > 0) && (pre != 2) )\n                {\n                    right_0();\n                    \n                    result = serch(x, y-1, MaxCnt-1, 1);\n                    \n                    left_0();\n                }\n                break;\n                \n            case 2:\n                if( (y < yoko -1 ) && (pre != 1) )\n                {\n                    left_0();\n                    \n                    result = serch(x, y+1, MaxCnt-1, 2);\n                    \n                    right_0();\n                }\n                break;\n                \n            case 3:\n                if( (x < tate -1 ) && (pre != 0) )\n                {\n                    up_0();\n                    \n                    result = serch(x+1, y, MaxCnt-1, 3);\n                    \n                    down_0();\n                }\n                break;\n                \n            default:\n                // 何もしない。\n                break;\n        }\n        \n        if(result)\n        {\n            return 1;\n        }\n    }\n    \n    return 0;\n}\n\n\ninline void down_0()\n{\n    val[num] = val[num + yoko];\n    num = num + yoko;\n}\n \ninline void up_0()\n{\n    val[num] = val[num - yoko];\n    num = num - yoko;\n}\n \ninline void right_0()\n{\n    val[num] = val[num +1];\n    num = num + 1;\n}\n \ninline void left_0()\n{\n    val[num] = val[num -1];\n    num = num - 1;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 9\n\nint board[N];\nint rows = 3, cols = 3, zeroIndex, current;\n\n// for previousMove: 0 is down, 1 is up, 2 is left, 3 is right\nint blindSearch(int x, int y, int moves, int previousMove) {\n  int i, foundAnswer;\n\n  // answer is less than manhattan distance, not possible\n  if (moves < (x + y))\n      return 0;\n\n  if (!moves) {\n    //printf(\"done %d moves\\n\", current);\n\n    for (i = 0; i < N - 1; i++) {\n      if (board[i] != i + 1)\n        return 0;\n    }\n\n    return 1;\n  }\n\n  if (x > 0 && previousMove != 1) {\n    // can expand down\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n\n    foundAnswer = blindSearch(x - 1, y, moves - 1, 0);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n  }\n\n  if (y > 0 && previousMove != 3) {\n    // right\n    board[zeroIndex] = board[++zeroIndex];\n\n    foundAnswer = blindSearch(x, y - 1, moves - 1, 2);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[--zeroIndex];\n  }\n\n  if (y < rows - 1 && previousMove != 2) {\n    // left\n    board[zeroIndex] = board[--zeroIndex];\n\n    foundAnswer = blindSearch(x, y + 1, moves - 1, 3);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[++zeroIndex];\n  }\n\n  if (x < cols - 1 && previousMove != 0) {\n    // up\n    board[zeroIndex] = board[zeroIndex - rows];\n    zeroIndex -= rows;\n\n    foundAnswer = blindSearch(x + 1, y, moves - 1, 1);\n    if (foundAnswer) {\n      //printf(\"yes\\n\");\n      return 1;\n    }\n\n    board[zeroIndex] = board[zeroIndex + rows];\n    zeroIndex += rows;\n  }\n\n  return 0;\n}\n\nint main() {\n  int i, x, y;\n  current = 0;\n\n  for (i = 0; i < N; i++) {\n    scanf(\"%d\", &board[i]);\n    if (!board[i])\n      zeroIndex = i;\n  }\n\n  x = cols - (zeroIndex / rows) - 1;\n  y = rows - (zeroIndex % cols) - 1;\n\n  //printf(\"zero index coordinates are: %d %d\\n\", x, y);\n\n  while (current < 5) {\n    if (blindSearch(x, y, current, -1)) {\n      printf(\"%d\\n\", current);\n      return;\n    }\n    current++;\n  }\n\n  //printf(\"Couldn't find an answer!\\n\");\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>         \n#include <stdlib.h>         \n#define N 3\n#define NIL -1\n#define NN 100\n\nint p8[N][N];\nint temp[N][N];\nint dx[4] = { 0, 1, 0,-1};\nint dy[4] = { 1, 0,-1, 0};\nvoid et(int *,int *);\nint cl();\nvoid swap(int *,int *);\nint dfs(int,int,int,int, int);\n\n\nint main(){\n  int i,j,d,a,x=0,y=0;\n  for (i = 0; i < N; ++i){\n    for (j = 0; j < N; ++j){\n      scanf(\"%d\", &p8[i][j]);\n    }\n\t}\n  et(&x, &y);\n\n  for (d = 0; d < NN; d++){\n    for (i = 0; i < N; i++){\n      for(j = 0; j < N; j++){\n\ttemp[i][j] = p8[i][j];\n      }\n    }\n    a = dfs(x, y, -1, 0, d);\n    if (a != -1){  \n      printf(\"%d\\n\", a);\n      break;\n    }\n\n    for (i = 0; i < N; ++i){\n      for(j = 0; j < N; ++j){\n       p8[i][j] = temp[i][j];\n      }\n    }\n    a = NIL;\n    if (d == NN-1)\n      printf(\"%d\\n\", a);\n  }\n\n\n  return 0;\n}\nvoid et(int *x, int *y){\n  int i,j;\n  for (i = 0; i < N; i++){\n    for (j = 0; j < N; j++){\n      if (!p8[i][j]){\n\t*x = j;\n\t*y = i;\n\t\n\treturn;\n      }\n    }\n  }\n}\n\nint cl(){\n\n  int sm = 0,i,a;\n  for (i = 0; i < 9; ++i){\n     a = p8[i / 3][i % 3];\n    if (a){\n      a--;\n      sm += abs(i / 3 - a / 3) + abs(i % 3 - a % 3);\n    }\n  }\n  return sm;\n}\n\nint dfs(int x, int y, int p, int dp, int lim){\n  int h,i,y1,x1,re;\n  h = cl();\n  if (h == 0)\n    return dp;\n\n  if (dp + h > lim) return NIL;\n  for (i = 0; i < 4; ++i){\n     x1 = x + dx[i];\n     y1 = y + dy[i];\n    if (p != NIL && i == (p + 2) % 4)continue;\n    if (0 <= x1 && x1 < N && 0 <= y1 && y1 < N){\n      swap(&p8[y][x], &p8[y1][x1]);\n      re = dfs(x1, y1, i, dp + 1, lim);\n      if (re != NIL)return re;\n      \n      swap(&p8[y][x], &p8[y1][x1]);\n    }\n  }\n\n  return NIL;\n}\nvoid swap(int *a, int *b){\n\n  int temp = *a;\n  *a = *b;\n  *b = temp;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n\n\n#define N 3\n#define M 9\n#define MAX 10000000\n\n\n struct Puzzle{\n  int f[M];\n  int path;\n  int space;\n};\n\ntypedef struct Puzzle puzzle;\n\nstatic const int dx[4] = {-1, 0, 1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\n\npuzzle Q[MAX];\nint head,tail,ori[MAX];\n\nint empty(void);\nvoid enqueue(puzzle );\npuzzle dequeue(void);\nint cheak(puzzle );\nint isTarget(puzzle );\nint bfs(puzzle p);\n\nint main()\n{\n  int i,x;\n  puzzle p;\n\n  for(i=0;i<M;i++){\n    scanf(\"%d\",&p.f[i]);\n    if(p.f[i]==0){\n      p.f[i]=M;\n      p.space=i;\n    }\n  }\n\n  x=bfs(p);\n\n  printf(\"%d\\n\",x);\n\n  return 0;\n\n}\n\nint empty()\n{\n  return head==tail;\n}\n\nvoid enqueue(puzzle x)\n{\n  Q[tail]=x;\n  tail=(tail+1)%MAX;\n}\n\npuzzle dequeue()\n{\n  puzzle x;\n\n  x=Q[head];\n  head=(head+1)%MAX;\n\n  return x;\n\n}\n\nint cheak(puzzle p)\n{\n  int i,j,fac,count,num=0;\n\n  for(i=0,fac=1;i<M;fac*=++i){\n    for(j=0,count=0;j<i;j++)\n      if(p.f[j]<p.f[i]) count++;\n      num+=count*fac;\n}\n\n  return num;\n\n}\n\nint isTarget(puzzle p)\n{\n  int i;\n\n  for(i=0;i<M;i++)\n    if(p.f[i]!=(i+1)) return 0;\n    return 1;\n}\n\nint bfs(puzzle p)\n{\n  int x,y,tx,ty,r,temp;\n  puzzle u, v;\n\n  p.path=0;\n  enqueue(p);\n  ori[cheak(p)]=1;\n\n  while(!empty()){\n    u=dequeue();\n    if(isTarget(u)) return u.path;\n    x=u.space/N;\n    y=u.space%N;\n\n    for(r=0;r<4;r++){\n      tx=x+dx[r];\n      ty=y+dy[r];\n      if(tx<0 || tx>=N || ty<0 || ty >= N) continue;\n      v=u;\n      temp=v.f[u.space];\n      v.f[u.space]=v.f[tx*N+ty];\n      v.f[tx*N+ty]=temp;\n      v.space=tx*N+ty;\n      if(!ori[cheak(v)]){\n\t       ori[cheak(v)]=1;\n\t       v.path++;\n\t       enqueue(v);\n      }\n    }\n  }\n\n  return -1;\n\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define MAX 3\nint ar[MAX][MAX];\nint tmp[MAX][MAX];\nint arx[4]={0,1,0,-1};\nint ary[4]={1,0,-1,0};\nvoid judgeof0(int *,int *);\nvoid swap(int *,int *);\nint cal(void);\nint dfs(int,int,int,int,const int);\n\nint main(){\n  int i,j,ans,x,y,k;\n  for(i=0;i<MAX;i++){\n    for(j=0;j<MAX;j++){\n      scanf(\"%d\",&ar[i][j]);\n    }\n  }\n  judgeof0(&x,&y);\n  for(i=0;i<100;i++){\n    for(j=0;j<MAX;j++){\n      for(k=0;k<MAX;k++){\n\ttmp[j][k]=ar[j][k];\n      }\n    }\n  \n  ans=dfs(x,y,-1,0,i);\n  if(ans!=-1){\n    printf(\"%d\\n\",ans);\n    break;\n  }\n  for(j=0;j<MAX;j++){\n    for(k=0;k<MAX;k++){\n      ar[j][k]=tmp[j][k];\n    }\n  }\n  ans=-1;\n  if(i==99)printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\nvoid judgeof0(int x[],int y[]){\n  int i,j;\n  for(i=0;i<MAX;i++){\n    for(j=0;j<MAX;j++){\n      if(!ar[i][j]){\n\t*x=j;\n\t*y=i;\n\treturn;\n      }\n    }\n  }\n\n}\n\nvoid swap(int x[],int y[]){\n  int tmp;\n  tmp=*x;\n  *x=*y;\n  *y=tmp;\n\n}\nint cal(){\n  int i,tmp,sum=0;\n  for(i=0;i<9;i++){\n    tmp=ar[i/MAX][i%MAX];\n    if(tmp){\n      tmp--;\n      sum+=abs((i/MAX)-(tmp/MAX))+abs((i%MAX)-(tmp%MAX));\n    }\n\n  }\n\n  return sum;\n}\n\nint dfs(int x,int y,int t,int dep,const int lim){\n  int i,x1,y1,res,h;\n  h=cal();\n  if(h==0)return dep;\n  if(dep+h>lim)return -1;\n  for(i=0;i<4;i++){\n    x1=x+arx[i];\n    y1=y+ary[i];\n  \n  if(~t && i==(t+2)%9){\n    continue;\n  }\n  if(!(x1>=0&&x1<MAX&&y1>=0&&y1<MAX)){\n    continue;\n  }\n  swap(&ar[y][x],&ar[y1][x1]);\n  res=dfs(x1,y1,i,dep+1,lim);\n  if(~res){\n    return res;\n  }\n  swap(&ar[y][x],&ar[y1][x1]);\n}\n  return -1;\n\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define N 3\n\nint search(int board[N][N], int min, int limit, int r_0, int c_0);\n\nint main(int argc, char *argv[])\n{\n  int board[N][N];\n  int md;\n  int i, j, r, c, r_0, c_0;\n  int res;\n\n  for (i = 0; i < N; i++) {\n    for (j = 0; j < N; j++) scanf(\"%d\", &board[i][j]);\n  }\n\n  md = 0;\n  for (i = 0; i < N * N - 1; i++) {\n    for (r = 0; r < N; r++) {\n      for (c = 0; c < N; c++) {\n\tif (board[r][c] == i) {\n\t  if (i == 0) {\n\t    r_0 = r;\n\t    c_0 = c;\n\t  } else md += (int)fabs((i-1)/N - r) + (int)fabs((i-1)%N - c);\n\t  break;\n\t}\n      }\n      if (board[r][c] == i) break;\n    }\n  }\n\n  for (i = 0; ; i += 2) {\n    if ((r_0 + c_0) % 2 == 0) {\n      if (md % 2 == 0) res = search(board, md, md+i, r_0, c_0);\n      else res = search(board, md, md+i+1, r_0, c_0);\n    } else {\n      if (md % 2 == 0) res = search(board, md, md+i+1, r_0, c_0);\n      else res = search(board, md, md+i, r_0, c_0);\n    }\n\n    if (res != -1) break;\n  }\n\n  printf(\"%d\\n\", res);\n\n  return 0;\n}\n\nint search(int board[N][N], int min, int limit, int r_0, int c_0)\n{\n  int md_c;\n  int num;\n  int res[4];\n\n  if (min == 0) return 0;\n\n  if (r_0 != 0) {\n    md_c = min;\n    num = board[r_0-1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0-1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0-1][c_0] = 0;\n      board[r_0][c_0] = num;\n      res[0] = search(board, md_c, limit-1, r_0-1, c_0);\n      if (res[0] == -1) {\n\tboard[r_0-1][c_0] = num;\n\tboard[r_0][c_0] = 0;\n      } else res[0]++;\n    } else res[0] = -1;\n  } else res[0] = -1;\n\n  if (r_0 != N-1) {\n    md_c = min;\n    num = board[r_0+1][c_0];\n    md_c -= (int)fabs((num-1)/N - (r_0+1)) + (int)fabs((num-1)%N - c_0);\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0+1][c_0] = 0;\n      board[r_0][c_0] =num;\n      res[1] = search(board, md_c, limit-1, r_0+1, c_0);\n      if (res[1] == -1) {\n\tboard[r_0+1][c_0] = num;\n\tboard[r_0][c_0] = 0;\n      } else res[1]++;\n    } else res[1] = -1;\n  } else res[1] = -1;\n\n  if (c_0 != 0) {\n    md_c = min;\n    num = board[r_0][c_0-1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0-1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0-1] = 0;\n      board[r_0][c_0] = num;\n      res[2] = search(board, md_c, limit-1, r_0, c_0-1);\n      if (res[2] == -1) {\n\tboard[r_0][c_0-1] = num;\n\tboard[r_0][c_0] = 0;\n      } else res[2]++;\n    } else res[2] = -1;\n  } else res[2] = -1;\n\n  if (c_0 != N-1) {\n    md_c = min;\n    num = board[r_0][c_0+1];\n    md_c -= (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - (c_0+1));\n    md_c += (int)fabs((num-1)/N - r_0) + (int)fabs((num-1)%N - c_0);\n    if (md_c <= limit - 1) {\n      board[r_0][c_0+1] = 0;\n      board[r_0][c_0] = num;\n      res[3] = search(board, md_c, limit-1, r_0, c_0+1);\n      if (res[3] == -1) {\n        board[r_0][c_0+1] = num;\n        board[r_0][c_0] = 0;\n      } else res[3]++;\n    } else res[3] = -1;\n  } else res[3] = -1;\n\n  if (res[0] == -1 && res[1] == -1 && res[2] == -1 && res[3] == -1) return -1;\n  else if (res[0] != -1) return res[0];\n  else if (res[1] != -1) return res[1];\n  else if (res[2] != -1) return res[2];\n  else return res[3];\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int n = 9;\n        int i;\n        char[] s = new char[n];\n        for (i=0;i<n;i++) {\n            s[i] = (char)('0' + scan.nextInt());\n        }\n\n        String ans = \"123456780\";\n        int[] d = {-3, 3, -1, 1};\n\n        HashMap<String, Integer> hm = new HashMap<String, Integer>();\n\n        Queue<String> q = new ArrayDeque<String>();\n        q.add(toString(s));\n        hm.put(toString(s), 0);/*sがキーで０が値*/\n\n        while (!q.isEmpty()) {\n            String u = q.remove();/*先頭を取得して削除*/\n            if (u.equals(ans)) {\n                System.out.println(hm.get(u));\n                break;\n            }\n\n            StringBuffer str = new StringBuffer(u);\n            int zero = str.indexOf(\"0\");/*０が出現する位置のインデックス*/\n            for (i=0;i<d.length;i++) {\n                if (zero+d[i]>=0 && zero+d[i]<n && !(d[i]==-1 && (zero+d[i])%3==2) && !(d[i]==1 && (zero+d[i])%3==0)) {\n                    str.setCharAt(zero, str.charAt(zero + d[i]));/*数字の入れ替え*/\n                    str.setCharAt(zero + d[i], '0');\n                    if (!hm.containsKey(str.toString())) {/*キーが存在するか*/\n                        q.add(str.toString());\n                        hm.put(str.toString(), hm.get(u) + 1);\n                    }\n                    str.setCharAt(zero + d[i], str.charAt(zero));\n                    str.setCharAt(zero, '0');\n                }\n            }\n        }\n    }\n\n    static String toString(char[] s) {\n        String ret = \"\";\n        int i;\n        for (i=0;i<s.length;i++) {\n            ret += s[i];\n        }\n\n        return ret;\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n/**\n * Created by huzhejie on 2016/10/10.\n */\npublic class Main {\n    @SuppressWarnings(\"unchecked\")\n    public static void main(String args[]){\n        State initState = new State();\n        PriorityQueue<State> queue = new PriorityQueue<State>();\n        Scanner sc = new Scanner(System.in);\n        String s = null;\n        int count = 0;\n        while (count<3){\n            s = sc.nextLine();\n            String str[] = s.split(\" \");\n            initState.map.put(Integer.parseInt(str[0]),new Coordinate(1,count+1));\n            initState.map.put(Integer.parseInt(str[1]),new Coordinate(2,count+1));\n            initState.map.put(Integer.parseInt(str[2]),new Coordinate(3,count+1));\n            initState.step = 0;\n            count++;\n        }\n        queue.add(initState);\n        int step = 0;\n        while(!queue.isEmpty()){\n            State state = queue.poll();\n            queue.clear();\n            Coordinate zero = state.map.get(0);\n            int bottomValue=state.getBottomNodeValue(zero);\n            int topValue = state.getTopNodeValue(zero);\n            int leftValue = state.getLeftNodeValue(zero);\n            int rightValue = state.getRightNodeValue(zero);\n            step++;\n            if(bottomValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(bottomValue).y = tempState.map.get(bottomValue).y-1;\n                tempState.map.get(0).y = tempState.map.get(0).y+1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                   queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    break;\n                }\n            }\n            if(topValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                    tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(topValue).y = tempState.map.get(topValue).y+1;\n                tempState.map.get(0).y = tempState.map.get(0).y-1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                    queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    break;\n                }\n            }\n            if(rightValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                    tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(rightValue).x = tempState.map.get(rightValue).x-1;\n                tempState.map.get(0).x = tempState.map.get(0).x+1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                    queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    break;\n                }\n            }\n            if(leftValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                    tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(leftValue).x = tempState.map.get(leftValue).x+1;\n                tempState.map.get(0).x = tempState.map.get(0).x-1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                    queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    break;\n                }\n            }\n        }\n    }\n\n}\n\nclass State implements Comparable<State>{\n    public HashMap<Integer,Coordinate> map;\n    public int step=0;\n    @SuppressWarnings(\"unchecked\")\n    public State(){\n        this.map = new HashMap<Integer, Coordinate>();\n    }\n   public int getRightNodeValue(Coordinate a){\n       if(a.x+1<4){\n           for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n               if (entry.getValue().x == a.x + 1 && entry.getValue().y == a.y) {\n                   return entry.getKey();\n               }\n           }\n               return -1;\n       }\n       else\n           return -1;\n   }\n    public int getLeftNodeValue(Coordinate a){\n        if(a.x-1>0){\n            for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n                if (entry.getValue().x == a.x - 1 && entry.getValue().y == a.y) {\n                    return entry.getKey();\n                }\n            }\n            return -1;\n        }\n        else\n            return -1;\n    }\n    public int getTopNodeValue(Coordinate a){\n        if(a.y-1>0){\n            for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n                if (entry.getValue().x == a.x  && entry.getValue().y == a.y-1) {\n                    return entry.getKey();\n                }\n            }\n            return -1;\n        }\n        else\n            return -1;\n    }\n    public int getBottomNodeValue(Coordinate a){\n        if(a.y+1<4){\n            for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n                if (entry.getValue().x == a.x&& entry.getValue().y == a.y+1) {\n                    return entry.getKey();\n                }\n            }\n            return -1;\n        }\n        else\n            return -1;\n    }\n    public int calculate(Map<Integer,Coordinate> map){\n        int sum = 0;\n        for(int key:map.keySet())\n                switch (key) {\n                    case 0: break;\n                    case 3: sum+=3-map.get(key).x+Math.abs(1-map.get(key).y);break;\n                    case 6: sum+=3-map.get(key).x+Math.abs(2-map.get(key).y);break;\n                    default: sum+=Math.abs(key%3-map.get(key).x)+Math.abs(key/3+1-map.get(key).y);break;\n                }\n        return sum;\n    }\n    @Override\n    public int compareTo(State o) {\n        return Integer.compare(calculate(map),o.calculate(o.map));\n    }\n}\nclass Coordinate implements Cloneable{\n    int x,y;\n    public Coordinate(int x,int y){\n        super();\n        this.x = x;\n        this.y = y;\n    }\n    @Override\n    public Coordinate clone(){\n        Coordinate c = null;\n        try{\n            c = (Coordinate)super.clone();\n        }catch (CloneNotSupportedException e){\n            e.printStackTrace();\n        }\n        return c;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeComparator nodeComparator = new NodeComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (2000,nodeComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (2000,nodeComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        //????????\\????????????????????¨???????????°?????????????????°???g??? ???????°??????°??¨???g????????????????????????\n        //???????????????????????????????????¢?????°\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenOrCloseIn(childNode,open)){\n                Iterator<Node> iterNew = open.iterator();\n                while(iterNew.hasNext())\n                {\n                    Node iterNode = iterNew.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                        }\n                    }\n                }\n            }\n            else if(isOpenOrCloseIn(childNode,close))\n            {\n                Iterator<Node> iterNew = close.iterator();\n                while(iterNew.hasNext())\n                {\n                    Node iterNode = iterNew.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                            iterNew.remove();\n                            open.add(childNode);\n                        }\n                    }\n                }\n            }\n            else\n            {\n                open.add(childNode);\n            }\n        }\n    }\n\n    private boolean isOpenOrCloseIn(Node newNode, PriorityQueue<Node> openList)\n    {\n        Iterator<Node> iter = openList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.awt.*;\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n//        long startTime = System.currentTimeMillis();\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n//        System.out.println(System.currentTimeMillis()-startTime);\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n    public NodeCloseListComparator nodeCloseListComparator = new NodeCloseListComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (1000, nodeOpenListComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (1000,nodeCloseListComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenOrCloseIn(childNode,open)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                        }\n                    }\n                }\n            }\n            else if(isOpenOrCloseIn(childNode,close)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                            iter.remove();\n                            open.add(childNode);\n                        }\n                    }\n                }\n            }\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenOrCloseIn(Node newNode, PriorityQueue<Node> List)\n    {\n        Iterator<Node> iter = List.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\n@SuppressWarnings(\"unchecked\")\nclass NodeCloseListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.awt.*;\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n//        long startTime = System.currentTimeMillis();\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n//        System.out.println(System.currentTimeMillis()-startTime);\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (1000, nodeOpenListComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (1000,nodeOpenListComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenIn(childNode,open));\n            else if(isCloseIn(childNode,close));\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenIn(Node newNode, PriorityQueue<Node> openList)\n    {\n        Iterator<Node> iter = openList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                if(newNode.gvalue < iterNode.gvalue)\n                {\n                    iterNode.parent = newNode.parent;\n                    iterNode.gvalue = newNode.gvalue;\n                    iterNode.fvalue = newNode.fvalue;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean isCloseIn(Node newNode, PriorityQueue<Node> closeList){\n        Iterator<Node> iter = closeList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                if(newNode.gvalue < iterNode.gvalue)\n                {\n                    iterNode.parent = newNode.parent;\n                    iterNode.gvalue = newNode.gvalue;\n                    iterNode.fvalue = newNode.fvalue;\n                    iter.remove();\n                    open.add(newNode);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint[] input = new int[9];\n\t\tString[] first = s.nextLine().split(\" \");\n\t\tinput[0] = Integer.parseInt(first[0]);\n\t\tinput[1] = Integer.parseInt(first[1]);\n\t\tinput[2] = Integer.parseInt(first[2]);\n\n\t\tString[] second = s.nextLine().split(\" \");\n\t\tinput[3] = Integer.parseInt(second[0]);\n\t\tinput[4] = Integer.parseInt(second[1]);\n\t\tinput[5] = Integer.parseInt(second[2]);\n\n\t\tString[] three = s.nextLine().split(\" \");\n\t\tinput[6] = Integer.parseInt(three[0]);\n\t\tinput[7] = Integer.parseInt(three[1]);\n\t\tinput[8] = Integer.parseInt(three[2]);\n\n\t\tSystem.out.println(solve(input));\n\t}\n\n\tpublic static int solve(int[] input) {\n\t\tint cnt = 0;\n\t\tLinkedList<int[]> queue = new LinkedList<int[]>();\n\t\tLinkedList<Integer> cntQueue = new LinkedList<Integer>();\n\t\tHashMap<Integer, Boolean> map = new HashMap<Integer, Boolean>();\n\t\tqueue.offer(input);\n\t\tcntQueue.offer(0);\n\n\t\twhile(! queue.isEmpty()) {\n\t\t\tint[] ban = queue.poll();\n\t\t\tcnt = cntQueue.poll();\n\t\t\t//??????\n\t\t\tif(check(ban))\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tint zeroIndex = 0;\n\t\t\t\tfor(int i=0 ; i<ban.length ; i++) {\n\t\t\t\t\tif(ban[i] == 0)\n\t\t\t\t\t\tzeroIndex = i;\n\t\t\t\t}\n\n\t\t\t\tswitch (zeroIndex) {\n\t\t\t\t//????????????????????´???\n\t\t\t\tcase 0:\n\t\t\t\t\tint[] copyArray = ban.clone();\n\t\t\t\t\tcopyArray[0] = copyArray[1];\n\t\t\t\t\tcopyArray[1] = 0;\n\t\t\t\t\tint hash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[0] = copyArray[3];\n\t\t\t\t\tcopyArray[3] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\t//??????????????????????????´???\n\t\t\t\tcase 1:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[1] = copyArray[0];\n\t\t\t\t\tcopyArray[0] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[1] = copyArray[4];\n\t\t\t\t\tcopyArray[4] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[1] = copyArray[2];\n\t\t\t\t\tcopyArray[2] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t//????????????????????´???\n\t\t\t\tcase 2:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[2] = copyArray[1];\n\t\t\t\t\tcopyArray[1] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[2] = copyArray[5];\n\t\t\t\t\tcopyArray[5] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\t//?????????????????´???\n\t\t\t\tcase 3:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[3] = copyArray[0];\n\t\t\t\t\tcopyArray[0] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[3] = copyArray[4];\n\t\t\t\t\tcopyArray[4] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[3] = copyArray[6];\n\t\t\t\t\tcopyArray[6] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t//???????????????????????´???\n\t\t\t\tcase 4:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[4] = copyArray[1];\n\t\t\t\t\tcopyArray[1] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[4] = copyArray[3];\n\t\t\t\t\tcopyArray[3] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[4] = copyArray[5];\n\t\t\t\t\tcopyArray[5] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[4] = copyArray[7];\n\t\t\t\t\tcopyArray[7] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t//?????????????????´???\n\t\t\t\tcase 5:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[5] = copyArray[2];\n\t\t\t\t\tcopyArray[2] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[5] = copyArray[4];\n\t\t\t\t\tcopyArray[4] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[5] = copyArray[8];\n\t\t\t\t\tcopyArray[8] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t//????????????????????´???\n\t\t\t\tcase 6:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[6] = copyArray[3];\n\t\t\t\t\tcopyArray[3] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[6] = copyArray[7];\n\t\t\t\t\tcopyArray[7] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t//??????????????????????????´???\n\t\t\t\tcase 7:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[7] = copyArray[6];\n\t\t\t\t\tcopyArray[6] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[7] = copyArray[4];\n\t\t\t\t\tcopyArray[4] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[7] = copyArray[8];\n\t\t\t\t\tcopyArray[8] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\t//????????????????????´???\n\t\t\t\tcase 8:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[8] = copyArray[5];\n\t\t\t\t\tcopyArray[5] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[8] = copyArray[7];\n\t\t\t\t\tcopyArray[7] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tstatic int[] value = {84, 19, 129, 67, 28, 222, 83, 80, 21};\n\tpublic static int hash(int[] ban) {\n\t\tint total = 0;\n\t\tfor(int i=0 ; i<ban.length ; i++) {\n\t\t\ttotal += (ban[i]*value[i]);\n\t\t}\n\t\treturn total%123;\n\t}\n\n\n\n\tpublic static boolean check(int[] ban) {\n\t\tfor(int i=0 ; i<ban.length ; i++) {\n\t\t\tif(i!=8 && ban[i]!=(i+1))\n\t\t\t\treturn false;\n\t\t\tif(i==8 && ban[i]!=0)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.HashMap;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in); \n\n\t\tint n = 9;\n\t\tchar[] s = new char[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ts[i] = (char)('0' + sc.nextInt());\n\t\t}\n\t\t\n\t\tString ans = \"123456780\";\n\t\tint[] d = {-3, 3, -1, 1};\n\t\t\n\t\tHashMap<String, Integer> hm = new HashMap<String, Integer>();\n\t\t\n\t\tQueue<String> q = new ArrayDeque<String>();\n\t\tq.add(toString(s));\n\t\thm.put(toString(s), 0);\n\n\t\twhile (!q.isEmpty()) {\n\t\t\tString u = q.remove();\n\t\t\tif (u.equals(ans)) {\n\t\t\t\tSystem.out.println(hm.get(u));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tStringBuffer str = new StringBuffer(u);\n\t\t\tint zero = str.indexOf(\"0\");\n\t\t\tassert (zero != -1);\n\t\t\tfor (int i = 0; i < d.length; i++) {\n\t\t\t\tif (zero + d[i] >= 0 && zero + d[i] < n && !(d[i] == -1 && zero + d[i] % 3 == 2) && !(d[i] == 1 && zero + d[i] % 3 == 0)) {\n\t\t\t\t\tstr.setCharAt(zero, str.charAt(zero + d[i]));\n\t\t\t\t\tstr.setCharAt(zero + d[i], '0');\n\t\t\t\t\tif (!hm.containsKey(str.toString())) {\n\t\t\t\t\t\tq.add(str.toString());\n\t\t\t\t\t\thm.put(str.toString(), hm.get(u) + 1);\n\t\t\t\t\t}\n\t\t\t\t\tstr.setCharAt(zero + d[i], str.charAt(zero));\n\t\t\t\t\tstr.setCharAt(zero, '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        sc.close();\n\t}\n\t\n\tprivate static String toString(char[] s) {\n\t\tString ret = \"\";\n\t\tfor (int i = 0; i < s.length; i++) {\n\t\t\tret += s[i];\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Queue<Puzzle> queue=new LinkedList<Puzzle>();\n\tstatic Map<String, Integer> map=new HashMap<>();\n\tstatic int[][] goal;\n\t\n\tstatic class Puzzle{\n\t\tint[][] p=new int[4][4];\n\t\tint step;\n\t\tPuzzle(int[][] p, int step){\n\t\t\tthis.step=step;\n\t\t\tfor(int i=0; i<3; i++) {\n\t\t\t\tfor(int j=0; j<3; j++) {\n\t\t\t\t\tthis.p[i][j]=p[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic int bfs() {\n\t\tint minstep=0;\n\t\tint[][] dt={{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n\t\twhile(! queue.isEmpty()) {\n\t\t\tint[][] field=new int[4][4];\n\t\t\tString str=\"\";\n\t\t\tint r=0, c=0;\n\t\t\tPuzzle q=queue.remove();\n\t\t\tboolean tf=true;\n\t\t\tfor(int i=0; i<3; i++) {\n\t\t\t\tfor(int j=0; j<3; j++) {\n\t\t\t\t\tfield[i][j]=q.p[i][j];\n\t\t\t\t\tstr+=String.valueOf(field[i][j]);\n\t\t\t\t\tif(q.p[i][j]==0) {\n\t\t\t\t\t\tr=i;\n\t\t\t\t\t\tc=j;\n\t\t\t\t\t}\n\t\t\t\t\tif(q.p[i][j]!=goal[i][j]) {\n\t\t\t\t\t\ttf=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tminstep=q.step;\n\t\t\tif(tf) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(map.get(str)!=null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmap.put(str, minstep);\n\t\t\t\n\t\t\tfor(int i=0; i<4; i++) {\n\t\t\t\tif(r+dt[i][0]>2 || r+dt[i][0]<0 || c+dt[i][1]>2 || c+dt[i][1]<0){\n\t\t            continue;\n\t\t        }\n\t\t\t\tint swap=field[r][c];\n\t\t\t\tfield[r][c]=field[r+dt[i][0]][c+dt[i][1]];\n\t\t\t\tfield[r+dt[i][0]][c+dt[i][1]]=swap;\n\t\t\t\tqueue.add(new Puzzle(field, minstep+1));\n\t\t\t\tswap=field[r][c];\n\t\t\t\tfield[r][c]=field[r+dt[i][0]][c+dt[i][1]];\n\t\t\t\tfield[r+dt[i][0]][c+dt[i][1]]=swap;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn minstep;\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tgoal=new int[4][4];\n\t\t\tfor(int i=0; i<3; i++) {\n\t\t\t\tfor(int j=0; j<3; j++) {\n\t\t\t\t\tgoal[i][j]=sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] start=new int[4][4];\n\t\t\tint count=1;\n\t\t\tfor(int i=0; i<3; i++) {\n\t\t\t\tfor(int j=0; j<3; j++) {\n\t\t\t\t\tstart[i][j]=count%9;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tqueue.add(new Puzzle(start, 0));\n\t\t\tSystem.out.println(bfs());\n\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tclass Pazzle {\n\t\tint y, x;\n\t\tint[][] board;\n\t\tPazzle(int y, int x, int[][] board) {\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.board = new int[N][N];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\t\tthis.board[i][j] = board[i][j];\n\t\t}\n\t\tPazzle(Pazzle p) {\n\t\t\tthis.y = p.y;\n\t\t\tthis.x = p.x;\n\t\t\tboard = new int[N][N];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\t\tboard[i][j] = p.board[i][j];\n\t\t}\n\t\tString boardToString() {\n\t\t\tString str = \"\";\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tstr += Integer.toString(board[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t\tvoid swapBoard(int ny, int nx) {\n\t\t\tint tmp = board[y][x];\n\t\t\tboard[y][x] = board[ny][nx];\n\t\t\tboard[ny][nx] = tmp;\n\t\t\ty = ny;\n\t\t\tx = nx;\n\t\t}\n\t\tvoid printDebug() {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\t\tSystem.out.print(board[i][j] + \" \");\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\tfinal int N = 3;\n\tint[][] board;\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tboard = new int[N][N];\n\t\tint y = 0, x = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tboard[i][j] = scan.nextInt();\n\t\t\t\tif (board[i][j] == 0) {\n\t\t\t\t\ty = i;\n\t\t\t\t\tx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQueue<Pazzle> que = new LinkedList<Pazzle>();\n\t\tHashSet<String> hash = new HashSet<String>();\n\t\tque.add(new Pazzle(y, x, board));\n\t\tString ansPazzle = \"123456780\";\n\t\tint ans = 0;\n\t\tint[] dy = { 1, 0, -1, 0 };\n\t\tint[] dx = { 0, 1, 0, -1 };\n\t\twhile (!que.isEmpty()) {\n\t\t\tint length = que.size();\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\tPazzle p = que.poll();\n\t\t\t\tString boardStr = p.boardToString();\n\t\t\t\tif (boardStr.equals(ansPazzle)) {\n\t\t\t\t\tSystem.out.println(ans);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\thash.add(boardStr);\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tint ny = p.y + dy[j];\n\t\t\t\t\tint nx = p.x + dx[j];\n\t\t\t\t\tif (ny >= 0 && nx >= 0 && ny < N && nx < N) {\n\t\t\t\t\t\tPazzle np = new Pazzle(p);\n\t\t\t\t\t\tnp.swapBoard(ny, nx);\n\t\t\t\t\t\tif (hash.contains(np.boardToString()))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tque.add(np);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans++;\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeComparator nodeComparator = new NodeComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (2000,nodeComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (2000,nodeComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        //????????\\????????????????????¨???????????°?????????????????°???g??? ???????°??????°??¨???g????????????????????????\n        //???????????????????????????????????¢?????°\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenOrCloseIn(childNode,open)){\n                Iterator<Node> iterNew = open.iterator();\n                while(iterNew.hasNext())\n                {\n                    Node iterNode = iterNew.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                        }\n                    }\n                }\n            }\n            else if(isOpenOrCloseIn(childNode,close))\n            {\n                Iterator<Node> iterNew = close.iterator();\n                while(iterNew.hasNext())\n                {\n                    Node iterNode = iterNew.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                            close.remove(iterNode);\n                            open.add(childNode);\n                        }\n                    }\n                }\n            }\n            else\n            {\n                open.add(childNode);\n            }\n        }\n    }\n\n    private boolean isOpenOrCloseIn(Node newNode, PriorityQueue<Node> openList)\n    {\n        Iterator<Node> iter = openList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n    public NodeCloseListComparator nodeCloseListComparator = new NodeCloseListComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (1000, nodeOpenListComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (1000,nodeCloseListComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        //????????\\????????????????????¨???????????°?????????????????°???g??? ???????°??????°??¨???g????????????????????????\n        //???????????????????????????????????¢?????°\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenIn(childNode,open));\n            else if(isCloseIn(childNode,close));\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenIn(Node newNode, PriorityQueue<Node> openList)\n    {\n        Iterator<Node> iter = openList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                if(newNode.gvalue < iterNode.gvalue)\n                {\n                    iterNode.parent = newNode.parent;\n                    iterNode.gvalue = newNode.gvalue;\n                    iterNode.fvalue = newNode.fvalue;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean isCloseIn(Node newNode, PriorityQueue<Node> closeList){\n        Iterator<Node> iter = closeList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                if(newNode.gvalue < iterNode.gvalue)\n                {\n                    iterNode.parent = newNode.parent;\n                    iterNode.gvalue = newNode.gvalue;\n                    iterNode.fvalue = newNode.fvalue;\n                    iter.remove();\n                    open.add(newNode);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\n@SuppressWarnings(\"unchecked\")\nclass NodeCloseListComparator implements  Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.gvalue-y.gvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\t\n\tprivate int[] up = {-1,0};\n\tprivate int[] down = {1,0};\n\tprivate int[] left = {0,-1};\n\tprivate int[] right = {0,1};\n\t\n\tpublic static int sum=0;\n\tprivate final int UP = 0;\n\tprivate final int DOWN = 2;\n\tprivate final int LEFT = 1;\n\tprivate final int RIGHT = 3;\n\t\n\tprivate static int SIZE = 3;\n\t\n\t\n\tprivate int[][] targetPoints; \n\t\n\t\n\tprivate static int[] moves = new int[100000];\n\t\n\tprivate static long ans = 0;\n\t\n\t\n\tprivate static int[][] tState = {\n\t\t{1 ,2 ,3 } ,\n\t\t{4, 5 ,6 } ,\n\t\t{7, 8 ,0 } ,\n\t};\n\t\n\tprivate static int[][] sState;\n\t\n\n\t\n\tprivate static int blank_row,blank_column;\n\t\n\tpublic Main(int[][] state) {\n\t\tSIZE = state.length;\n\t\ttargetPoints = new int[SIZE * SIZE][2];\n\t\t\n\t\tthis.sState = state;\n\t\t\n\t\tfor(int i=0;i<state.length;i++) {\n\t\t\tfor(int j=0;j<state[i].length;j++) {\n\t\t\t\tif(state[i][j] == 0) {\n\t\t\t\t\tblank_row = i;\n\t\t\t\t\tblank_column = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i=0;i<state.length;i++) {\n\t\t\tfor(int j=0;j<state.length;j++) {\n\t\t\t\ttargetPoints[tState[i][j]][0] = i; \n\t\t\t\t\n\t\t\t\ttargetPoints[tState[i][j]][1] = j; \n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tsState = new int[SIZE][SIZE];\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfor(int i=0;i<SIZE;i++) {\n\t\t\tfor(int j=0;j<SIZE;j++)\n\t\t\t\tsState[i][j]=sc.nextInt();\n\t\t}\n\t\t\n\t\t\n\t\tMain idaAlgorithm = new Main(sState);\n\t\t\n\t\n\t\tint j = idaAlgorithm.getHeuristic(sState);\n\t\t\n\t\tint i = -1;\n\t\t\n\t\t\n\t\tfor(ans=j;;ans++) {\n\t\t\tif(idaAlgorithm.solve(sState\n\t\t\t\t\t,blank_row,blank_column,0,i,j)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tif(ans != 0) {\n\t\t\tint[][] matrix = idaAlgorithm.move(sState,moves[0]);\n\t\t\tfor(int k=1;k<ans;k++) {\n\t\t\t\tmatrix = idaAlgorithm.move(matrix, moves[k]);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sum);\n\t\t\n\t}\n\t\n\tpublic int[][] move(int[][]state,int direction) {\n\t\tint row = 0;\n\t\tint column = 0;\n\t\tfor(int i=0;i<state.length;i++) {\n\t\t\tfor(int j=0;j<state.length;j++) {\n\t\t\t\tif(state[i][j] == 0) {\n\t\t\t\t\trow = i;\n\t\t\t\t\tcolumn = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswitch(direction) {\n\t\tcase UP:\n\t\t\tstate[row][column] = state[row-1][column];\n\t\t\tstate[row-1][column] = 0;\n\t\t\tbreak;\n\t\tcase DOWN:\n\t\t\tstate[row][column] = state[row+1][column];\n\t\t\tstate[row+1][column] = 0;\n\t\t\tbreak;\n\t\tcase LEFT:\n\t\t\tstate[row][column] = state[row][column-1];\n\t\t\tstate[row][column-1] = 0;\n\t\t\tbreak;\n\t\tcase RIGHT:\n\t\t\tstate[row][column] = state[row][column+1];\n\t\t\tstate[row][column+1] = 0;\n\t\t\tbreak;\n\t\t}\n\t\tsum++;\n\t\treturn state;\n\t}\n\t\n\t\n\t\n\t\n\tpublic boolean solve(int[][] state,int blank_row,int blank_column,\n\t\t\tint dep,long d,long h) {\n\t\t\n\t\tlong h1;\n\t\t\n\t\t\n\t\tboolean isSolved = true;\n\t\tfor(int i=0;i<SIZE;i++) {\n\t\t\tfor(int j=0;j<SIZE;j++) {\n\t\t\t\tif(state[i][j] != tState[i][j]) {\n\t\t\t\t\tisSolved = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(isSolved) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif(dep == ans) {\n\t\t\treturn false;\n\t\t}\n\n\t\t\n\t\tint blank_row1 = blank_row;\n\t\tint blank_column1  = blank_column;\n\t\tint[][] state2 = new int[SIZE][SIZE];\n\n\t\tfor(int direction=0;direction<4;direction++) {\n\t\t\tfor(int i=0;i<state.length;i++) {\n\t\t\t\tfor(int j=0;j<state.length;j++) {\n\t\t\t\t\tstate2[i][j] = state[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif(direction != d && (d%2 == direction%2)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(direction == UP) {\n\t\t\t\tblank_row1 = blank_row + up[0];\n\t\t\t\tblank_column1 = blank_column + up[1];\n\t\t\t} else if(direction == DOWN) {\n\t\t\t\tblank_row1 = blank_row + down[0];\n\t\t\t\tblank_column1 = blank_column + down[1];\n\t\t\t} else if(direction == LEFT) {\n\t\t\t\tblank_row1 = blank_row + left[0];\n\t\t\t\tblank_column1 = blank_column + left[1];\n\t\t\t} else {\n\t\t\t\tblank_row1 = blank_row + right[0];\n\t\t\t\tblank_column1 = blank_column + right[1];\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif(blank_column1 < 0 || blank_column1 == SIZE\n\t\t\t\t\t|| blank_row1 < 0 || blank_row1 == SIZE) {\n\t\t\t\tcontinue ;\n\t\t\t}\n\t\t\t\n\t\t\t\t\n\t\t\tstate2[blank_row][blank_column] = state2[blank_row1][blank_column1];\n\t\t\tstate2[blank_row1][blank_column1] = 0;\n\t\t\t\n\t\t\t\n\t\t\tif(direction == DOWN && blank_row1 \n\t\t\t\t\t> targetPoints[state[blank_row1][blank_column1]][0]) {\n\t\t\t\th1 = h - 1;\n\t\t\t} else if(direction == UP && blank_row1 \n\t\t\t\t\t< targetPoints[state[blank_row1][blank_column1]][0]){\n\t\t\t\th1 = h - 1;\n\t\t\t} else if(direction == RIGHT && blank_column1 \n\t\t\t\t\t> targetPoints[state[blank_row1][blank_column1]][1]) {\n\t\t\t\th1 = h - 1;\n\t\t\t} else if(direction == LEFT && blank_column1 \n\t\t\t\t\t< targetPoints[state[blank_row1][blank_column1]][1]) {\n\t\t\t\th1 = h - 1;\n\t\t\t} else { \n\t\t\t\t\n\t\t\t\th1 = h + 1;\n\t\t\t}\n\t\t\t\n\t\t\tif(h1+dep+1>ans) { \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tmoves[dep] = direction;\n\t\t\t\n\t\t\t\n\t\t\tif(solve(state2, blank_row1, blank_column1, dep+1, direction, h1)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\n\tpublic int getHeuristic(int[][] state) {\n\t\tint heuristic = 0;\n\t\tfor(int i=0;i<state.length;i++) {\n\t\t\tfor(int j=0;j<state[i].length;j++) {\n\t\t\t\tif(state[i][j] != 0) {\n\t\t\t\t\theuristic = heuristic + \n\t\t\t\t\t\t\tMath.abs(targetPoints[state[i][j]][0] - i)\n\t\t\t\t\t\t\t+ Math.abs(targetPoints[state[i][j]][1] - j);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn heuristic;\n\t}\n\t\n\t\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n/**\n * Created by huzhejie on 2016/10/10.\n */\npublic class Main {\n    @SuppressWarnings(\"unchecked\")\n    public static void main(String args[]){\n        State initState = new State();\n        PriorityQueue<State> queue = new PriorityQueue<State>();\n        Scanner sc = new Scanner(System.in);\n        String s = null;\n        int count = 0;\n        while ((s = sc.nextLine())!=null&&count<3){\n            String str[] = s.split(\" \");\n            initState.map.put(Integer.parseInt(str[0]),new Coordinate(1,count+1));\n            initState.map.put(Integer.parseInt(str[1]),new Coordinate(2,count+1));\n            initState.map.put(Integer.parseInt(str[2]),new Coordinate(3,count+1));\n            initState.step = 0;\n            count++;\n        }\n        queue.add(initState);\n        int step = 0;\n        while(!queue.isEmpty()){\n            State state = queue.poll();\n            queue.clear();\n            Coordinate zero = state.map.get(0);\n            int bottomValue=state.getBottomNodeValue(zero);\n            int topValue = state.getTopNodeValue(zero);\n            int leftValue = state.getLeftNodeValue(zero);\n            int rightValue = state.getRightNodeValue(zero);\n            step++;\n            if(bottomValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(bottomValue).y = tempState.map.get(bottomValue).y-1;\n                tempState.map.get(0).y = tempState.map.get(0).y+1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                   queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    break;\n                }\n            }\n            if(topValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                    tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(topValue).y = tempState.map.get(topValue).y+1;\n                tempState.map.get(0).y = tempState.map.get(0).y-1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                    queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    break;\n                }\n            }\n            if(rightValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                    tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(rightValue).x = tempState.map.get(rightValue).x-1;\n                tempState.map.get(0).x = tempState.map.get(0).x+1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                    queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    break;\n                }\n            }\n            if(leftValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                    tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(leftValue).x = tempState.map.get(leftValue).x+1;\n                tempState.map.get(0).x = tempState.map.get(0).x-1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                    queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    break;\n                }\n            }\n        }\n    }\n\n}\n\nclass State implements Comparable<State>{\n    public HashMap<Integer,Coordinate> map;\n    public int step=0;\n    @SuppressWarnings(\"unchecked\")\n    public State(){\n        this.map = new HashMap<Integer, Coordinate>();\n    }\n   public int getRightNodeValue(Coordinate a){\n       if(a.x+1<4){\n           for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n               if (entry.getValue().x == a.x + 1 && entry.getValue().y == a.y) {\n                   return entry.getKey();\n               }\n           }\n               return -1;\n       }\n       else\n           return -1;\n   }\n    public int getLeftNodeValue(Coordinate a){\n        if(a.x-1>0){\n            for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n                if (entry.getValue().x == a.x - 1 && entry.getValue().y == a.y) {\n                    return entry.getKey();\n                }\n            }\n            return -1;\n        }\n        else\n            return -1;\n    }\n    public int getTopNodeValue(Coordinate a){\n        if(a.y-1>0){\n            for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n                if (entry.getValue().x == a.x  && entry.getValue().y == a.y-1) {\n                    return entry.getKey();\n                }\n            }\n            return -1;\n        }\n        else\n            return -1;\n    }\n    public int getBottomNodeValue(Coordinate a){\n        if(a.y+1<4){\n            for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n                if (entry.getValue().x == a.x&& entry.getValue().y == a.y+1) {\n                    return entry.getKey();\n                }\n            }\n            return -1;\n        }\n        else\n            return -1;\n    }\n    public int calculate(Map<Integer,Coordinate> map){\n        int sum = 0;\n        for(int key:map.keySet())\n                switch (key) {\n                    case 0: break;\n                    case 3: sum+=3-map.get(key).x+Math.abs(1-map.get(key).y);break;\n                    case 6: sum+=3-map.get(key).x+Math.abs(2-map.get(key).y);break;\n                    default: sum+=Math.abs(key%3-map.get(key).x)+Math.abs(key/3+1-map.get(key).y);break;\n                }\n        return sum;\n    }\n    @Override\n    public int compareTo(State o) {\n        return Integer.compare(calculate(map),o.calculate(o.map));\n    }\n}\nclass Coordinate implements Cloneable{\n    int x,y;\n    public Coordinate(int x,int y){\n        super();\n        this.x = x;\n        this.y = y;\n    }\n    @Override\n    public Coordinate clone(){\n        Coordinate c = null;\n        try{\n            c = (Coordinate)super.clone();\n        }catch (CloneNotSupportedException e){\n            e.printStackTrace();\n        }\n        return c;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static final int SIZE = 3;\n\tpublic static final int ALL_SIZE = SIZE * SIZE;\n\t\n\tpublic static int[] factor=  {\n\t\t1, 1, 2, 6, 24, 120, 720, 5040, 50320, 362880\n\t}; //0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n\t\n\t//完全最小ハッシュを作る.\n\tpublic static int hash(int[] A){\n\t\tint[] A_ = new int[A.length];\n\t\tSystem.arraycopy(A, 0, A_, 0, A.length);\n\t\t\n\t\tint ret = 0;\n\t\t\n\t\tfor(int i = 0; i < A_.length; i++){\n\t\t\tret += A_[i] * factor[(A.length - i - 1)];\n\t\t\t\n\t\t\tfor(int j = i + 1; j < A_.length; j++){\n\t\t\t\tif(A_[j] >= A_[i]){ A_[j]--; }\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tpublic static int[] unhash(int hash){\n\t\tint[] ret = new int[ALL_SIZE];\n\t\t\n\t\tfor(int i = 0; i < ALL_SIZE; i++){\n\t\t\tret[i] = hash / factor[ALL_SIZE - i - 1];\n\t\t\thash -= factor[ALL_SIZE - i - 1] * ret[i];\n\t\t}\n\t\t\n\t\tfor(int i = ALL_SIZE - 1; i >= 0; i--){\n\t\t\tfor(int j = i + 1; j < ALL_SIZE; j++){\n\t\t\t\tif(ret[i] <= ret[j]) ret[j]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\n\tpublic static final int GOAL = hash(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 0});\n\tpublic static final int MAX = hash(new int[]{8, 7, 6, 5, 4, 3, 2, 1, 0}) + 1;\n\t\n\tpublic static final int[] moves = new int[]{1, -1, SIZE, -SIZE};\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t//System.out.println(Arrays.toString(unhash(GOAL)));\n\t\t\n\t\tint[] visited = new int[MAX];\n\t\tArrays.fill(visited, Integer.MAX_VALUE);\n\t\tLinkedList<Integer> queue = new LinkedList<Integer>();\n\t\t\n\t\tint[] input = new int[ALL_SIZE];\n\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\tfor(int j = 0; j < SIZE; j++){\n\t\t\t\tinput[i * SIZE + j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal int hash_input = hash(input);\n\t\tqueue.add(hash_input);\n\t\tvisited[hash_input] = 0;\n\t\twhile(!queue.isEmpty()){\n\t\t\tfinal int hashed = queue.poll();\n\t\t\t\n\t\t\tif(hashed == GOAL){\n\t\t\t\tSystem.out.println(visited[hashed]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int dist = visited[hashed];\n\t\t\t\n\t\t\tint[] ret = unhash(hashed);\n\t\t\t\n\t\t\tfor(int i = 0; i < ALL_SIZE; i++){\n\t\t\t\tif(ret[i] == 0){\n\t\t\t\t\tfor(int move : moves){\n\t\t\t\t\t\tif(i + move >= 0 && i + move < ALL_SIZE){\n\t\t\t\t\t\t\tint tmp = ret[i];\n\t\t\t\t\t\t\tret[i] = ret[i + move];\n\t\t\t\t\t\t\tret[i + move] = tmp;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfinal int next_hash = hash(ret);\n\t\t\t\t\t\t\tif(visited[next_hash] > dist + 1){\n\t\t\t\t\t\t\t\tvisited[next_hash] = dist + 1;\n\t\t\t\t\t\t\t\tqueue.add(next_hash);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttmp = ret[i];\n\t\t\t\t\t\t\tret[i] = ret[i + move];\n\t\t\t\t\t\t\tret[i + move] = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\tpublic static class Scanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.awt.*;\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n        long startTime = System.currentTimeMillis();\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n        System.out.println(System.currentTimeMillis()-startTime);\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n    public NodeCloseListComparator nodeCloseListComparator = new NodeCloseListComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (1000, nodeOpenListComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (1000,nodeCloseListComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenOrCloseIn(childNode,open)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                        }\n                    }\n                }\n            }\n            else if(isOpenOrCloseIn(childNode,close)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                            iter.remove();\n                            open.add(childNode);\n                        }\n                    }\n                }\n            }\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenOrCloseIn(Node newNode, PriorityQueue<Node> List)\n    {\n        Iterator<Node> iter = List.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\n@SuppressWarnings(\"unchecked\")\nclass NodeCloseListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeComparator nodeComparator = new NodeComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (2000,nodeComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (2000,nodeComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue(endStatus);\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        //????????\\????????????????????¨???????????°?????????????????°???g??? ???????°??????°??¨???g????????????????????????\n        //???????????????????????????????????¢?????°\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue(endStatus);\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue(endStatus);\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue(endStatus);\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue(endStatus);\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenOrCloseIn(childNode,open)){\n                Iterator<Node> iterNew = open.iterator();\n                while(iterNew.hasNext())\n                {\n                    Node iterNode = iterNew.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                        }\n                    }\n                }\n            }\n            else if(isOpenOrCloseIn(childNode,close))\n            {\n                Iterator<Node> iterNew = close.iterator();\n                while(iterNew.hasNext())\n                {\n                    Node iterNode = iterNew.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                            iterNew.remove();\n                            open.add(childNode);\n                        }\n                    }\n                }\n            }\n            else\n            {\n                open.add(childNode);\n            }\n        }\n    }\n\n    private boolean isOpenOrCloseIn(Node newNode, PriorityQueue<Node> openList)\n    {\n        Iterator<Node> iter = openList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue(int[][] endStatus)\n    {\n        int k=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j] != endStatus[i][j])\n                {\n                    k+=1;\n                }\n            }\n        }\n        return k;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tclass Pazzle {\n\t\tint y, x;\n\t\tint[][] board;\n\t\tPazzle(int y, int x, int[][] board) {\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.board = new int[N][N];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\t\tthis.board[i][j] = board[i][j];\n\t\t}\n\t\tPazzle(Pazzle p) {\n\t\t\tthis.y = p.y;\n\t\t\tthis.x = p.x;\n\t\t\tboard = new int[N][N];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\t\tboard[i][j] = p.board[i][j];\n\t\t}\n\t\tString boardToString() {\n\t\t\tString str = \"\";\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tstr += Integer.toString(board[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t\tvoid swapBoard(int ny, int nx) {\n\t\t\tint tmp = board[y][x];\n\t\t\tboard[y][x] = board[ny][nx];\n\t\t\tboard[ny][nx] = tmp;\n\t\t\ty = ny;\n\t\t\tx = nx;\n\t\t}\n\t\tvoid printDebug() {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\t\tSystem.out.print(board[i][j] + \" \");\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\tfinal int N = 3;\n\tint[][] board;\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tboard = new int[N][N];\n\t\tint y = 0, x = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tboard[i][j] = scan.nextInt();\n\t\t\t\tif (board[i][j] == 0) {\n\t\t\t\t\ty = i;\n\t\t\t\t\tx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQueue<Pazzle> que = new LinkedList<Pazzle>();\n\t\tHashSet<String> hash = new HashSet<String>();\n\t\tque.add(new Pazzle(y, x, board));\n\t\tString ansPazzle = \"123456780\";\n\t\tint ans = 0;\n\t\tint[] dy = { 1, 0, -1, 0 };\n\t\tint[] dx = { 0, 1, 0, -1 };\n\t\twhile (!que.isEmpty()) {\n\t\t\tint length = que.size();\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\tPazzle p = que.poll();\n\t\t\t\tString boardStr = p.boardToString();\n\t\t\t\tif (boardStr.equals(ansPazzle)) {\n\t\t\t\t\tSystem.out.println(ans);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\thash.add(boardStr);\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tint ny = p.y + dy[j];\n\t\t\t\t\tint nx = p.x + dx[j];\n\t\t\t\t\tif (ny >= 0 && nx >= 0 && ny < N && nx < N) {\n\t\t\t\t\t\tPazzle np = new Pazzle(p);\n\t\t\t\t\t\tnp.swapBoard(ny, nx);\n\t\t\t\t\t\tif (hash.contains(np.boardToString()))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tque.add(np);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans++;\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.awt.*;\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n        long startTime = System.currentTimeMillis();\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n        System.out.println(System.currentTimeMillis()-startTime);\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n    public NodeCloseListComparator nodeCloseListComparator = new NodeCloseListComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (100, nodeOpenListComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (100,nodeCloseListComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenOrCloseIn(childNode,open)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                        }\n                    }\n                }\n            }\n            else if(isOpenOrCloseIn(childNode,close)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                            iter.remove();\n                            open.add(childNode);\n                        }\n                    }\n                }\n            }\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenOrCloseIn(Node newNode, PriorityQueue<Node> List)\n    {\n        Iterator<Node> iter = List.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\n@SuppressWarnings(\"unchecked\")\nclass NodeCloseListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.gvalue - y.gvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.awt.*;\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        long startTime = System.currentTimeMillis();\n        Astar test = new Astar(startStatus);\n        test.run();\n        System.out.println(System.currentTimeMillis()-startTime);\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (1000, nodeOpenListComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (1000,nodeOpenListComparator);\n    public Astar(int[][] startStatus)\n    {\n        this.startStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n//        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenOrCloseIn(childNode,open)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n//                            iterNode.fvalue = childNode.fvalue;\n                        }\n                    }\n                }\n            }\n            else if(isOpenOrCloseIn(childNode,close)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n//                            iterNode.fvalue = childNode.fvalue;\n                            iter.remove();\n                            open.add(childNode);\n                        }\n                    }\n                }\n            }\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenOrCloseIn(Node newNode, PriorityQueue<Node> List)\n    {\n        Iterator<Node> iter = List.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.gvalue+x.hvalue - y.gvalue-y.hvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n//    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "package sample;\n\nimport java.util.Scanner;\n\n/**\n * IDA*?±??§£15puzzle????¢?\n * IDA*??´??????IDDFS???A*???????????¶???IDDFS??§??¶????±??§£????¨??????????????????????A*???????????????\"?????????\"????´¢???\n * IDA*?????\\????§£????????£??±??????A*???????????¶????????????\"??±???\"?????????????¢?????§£???\"????????????\"???\n * ???\"????????????\"???????????£?¢????????£???????????????¨\"????????????\"??????????????°???????§£?????????????????????????°±??§????????£???\n * ?????????A*???????????????????????????????????¨?????±????????¨???IDDFS????????\\???IDA*?????±?????????????´¢?????????????????????????????¨???\n * @author wly\n * @date 2013-12-20\n *\n */\npublic class IDAStarAlgorithm {\n\n    //????????£??¨????????????????????????????§???¨?????????????????°\n    private int[] up = {-1,0};\n    private int[] down = {1,0};\n    private int[] left = {0,-1};\n    private int[] right = {0,1};\n\n    /**??¨????????????UP???DOWN???LEFT???RIGHT??????????????????????????????????????¢??£???????????¨\n     * ((dPrev != dCurr) && (dPrev%2 == dCurr%2))\n     * ??\\???????????????????§???¨??????????????????\n     */\n    private final int UP = 0;\n    private final int DOWN = 2;\n    private final int LEFT = 1;\n    private final int RIGHT = 3;\n\n    private int SIZE;\n\n    //?????????????????????\n    private int[][] targetPoints;\n\n    //??¨?????°????§???¨??\\???????????¨0,1,2,3,???????????????????????????\n    private static int[] moves = new int[100000];\n\n    private static long ans = 0;; //???????????£???\"????????£???\"\n\n    //????????¶???\n    private static int[][] tState = {\n            {1 ,2 ,3  } ,\n            {4 ,5 ,6  } ,\n            {7 ,8, 0  }\n\n    };\n\n    private static int[][] sState;\n\n\n    private static int blank_row,blank_column;\n\n    public IDAStarAlgorithm(int[][] state) {\n        SIZE = state.length;\n        targetPoints = new int[SIZE * SIZE][2];\n\n        this.sState = state;\n        //?????°????????????\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] == 0) {\n                    blank_row = i;\n                    blank_column = j;\n                    break;\n                }\n            }\n        }\n\n        //?????°?????????????????°???\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state.length;j++) {\n                targetPoints[tState[i][j]][0] = i; //?????????\n\n                targetPoints[tState[i][j]][1] = j; //?????????\n            }\n        }\n    }\n\n    /**\n     * ??¨???????¢????????§£??§\n     * @param state ??¶???\n     */\n    private boolean canSolve(int[][] state) {\n        if(state.length % 2 == 1) { //????¢???????????\\???°\n            return (getInversions(state) % 2 == 0);\n        } else { //????¢????????????¶??°\n            if((state.length - blank_row) % 2 == 1) { //??????????????°,?????????????\\???°???\n                return (getInversions(state) % 2 == 0);\n            } else { //??????????????°,??????????????¶??°???\n                return (getInversions(state) % 2 == 1);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int step = 0;\n        int[][] sState=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            sState[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            sState[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            sState[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n\n        IDAStarAlgorithm idaAlgorithm = new IDAStarAlgorithm(sState);\n//            System.out.println(\"--????¢?????§£???????§??±??§£--\");\n            //??\\??????????????????????§?????°???£?????°\n            int j = idaAlgorithm.getHeuristic(sState);\n//            System.out.println(\"????§?manhattan??????:\" + j);\n            int i = -1;//?????????????§???¨??????\n\n//            long time = System.currentTimeMillis();\n            //?????£?????±\"????°???£?????°\"\n            for(ans=j;;ans++) {\n                if(idaAlgorithm.solve(sState\n                        ,blank_row,blank_column,0,i,j)) {\n                    break;\n                }\n            }\n//            System.out.println(\"?±??§£??¨??¶:\"+(System.currentTimeMillis() - time));\n\n//            idaAlgorithm.printMatrix(sState);\n            int[][] matrix = idaAlgorithm.move(sState,moves[0]);\n            step ++;\n            for(int k=1;k<ans;k++) {\n                matrix = idaAlgorithm.move(matrix, moves[k]);\n                step ++;\n            }\n            System.out.println(step);\n    }\n\n    public int[][] move(int[][]state,int direction) {\n        int row = 0;\n        int column = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state.length;j++) {\n                if(state[i][j] == 0) {\n                    row = i;\n                    column = j;\n                }\n            }\n        }\n        switch(direction) {\n            case UP:\n                state[row][column] = state[row-1][column];\n                state[row-1][column] = 0;\n                break;\n            case DOWN:\n                state[row][column] = state[row+1][column];\n                state[row+1][column] = 0;\n                break;\n            case LEFT:\n                state[row][column] = state[row][column-1];\n                state[row][column-1] = 0;\n                break;\n            case RIGHT:\n                state[row][column] = state[row][column+1];\n                state[row][column+1] = 0;\n                break;\n        }\n//        printMatrix(state);\n        return state;\n    }\n\n//    public void printMatrix(int[][] matrix) {\n//        System.out.println(\"------------\");\n//        for(int i=0;i<matrix.length;i++) {\n//            for(int j=0;j<matrix.length;j++) {\n//                System.out.print(matrix[i][j] + \" \");\n//            }\n//            System.out.println();\n//        }\n//    }\n\n    /**\n     * ?±??§£??????\n     * @param state ????????¶???\n     * @param blank_row ??????????????????\n     * @param blank_column ??????????????????\n     * @param dep ????????±???\n     * @param d ???????¬??§???¨?????????\n     * @param h ????????¶?????°????????°\n     * @return\n     */\n    public boolean solve(int[][] state,int blank_row,int blank_column,\n                         int dep,long d,long h) {\n\n        long h1;\n\n        //???????????????????????????????????????????????????????????¨???????¢?????§£\n        boolean isSolved = true;\n        for(int i=0;i<SIZE;i++) {\n            for(int j=0;j<SIZE;j++) {\n                if(state[i][j] != tState[i][j]) {\n                    isSolved = false;\n                }\n            }\n        }\n        if(isSolved) {\n            return true;\n        }\n\n        if(dep == ans) {\n            return false;\n        }\n\n        //??¨?????¨???\"??????\"?§???¨??????????????????\n        int blank_row1 = blank_row;\n        int blank_column1  = blank_column;\n        int[][] state2 = new int[SIZE][SIZE];\n\n        for(int direction=0;direction<4;direction++) {\n            for(int i=0;i<state.length;i++) {\n                for(int j=0;j<state.length;j++) {\n                    state2[i][j] = state[i][j];\n                }\n            }\n\n            //??¬??°?§???¨?????????????¬??§???¨??????????\\????????????????????§????????????¨???\n            if(direction != d && (d%2 == direction%2)) {\n                continue;\n            }\n\n            if(direction == UP) {\n                blank_row1 = blank_row + up[0];\n                blank_column1 = blank_column + up[1];\n            } else if(direction == DOWN) {\n                blank_row1 = blank_row + down[0];\n                blank_column1 = blank_column + down[1];\n            } else if(direction == LEFT) {\n                blank_row1 = blank_row + left[0];\n                blank_column1 = blank_column + left[1];\n            } else {\n                blank_row1 = blank_row + right[0];\n                blank_column1 = blank_column + right[1];\n            }\n\n            //???????£???\\\n            if(blank_column1 < 0 || blank_column1 == SIZE\n                    || blank_row1 < 0 || blank_row1 == SIZE) {\n                continue ;\n            }\n\n            //?????¢??????????????????????§???¨????????????????????????\n            state2[blank_row][blank_column] = state2[blank_row1][blank_column1];\n            state2[blank_row1][blank_column1] = 0;\n\n            //??\\???????????????????????£??¨???????????????\n            if(direction == DOWN && blank_row1\n                    > targetPoints[state[blank_row1][blank_column1]][0]) {\n                h1 = h - 1;\n            } else if(direction == UP && blank_row1\n                    < targetPoints[state[blank_row1][blank_column1]][0]){\n                h1 = h - 1;\n            } else if(direction == RIGHT && blank_column1\n                    > targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else if(direction == LEFT && blank_column1\n                    < targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else {\n                //????§???????????????¨????????????????§???¨????????????????????°????????°????????§\n                h1 = h + 1;\n            }\n\n            if(h1+dep+1>ans) { //??????\n                continue;\n            }\n\n            moves[dep] = direction;\n\n            //?????£??±????±??§£\n            if(solve(state2, blank_row1, blank_column1, dep+1, direction, h1)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * ?????°??°????????°???\n     */\n    public int getHeuristic(int[][] state) {\n        int heuristic = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] != 0) {\n                    heuristic = heuristic +\n                            Math.abs(targetPoints[state[i][j]][0] - i)\n                            + Math.abs(targetPoints[state[i][j]][1] - j);\n\n                }\n            }\n        }\n        return heuristic;\n    }\n\n    /**\n     * ??????????¢????\"???????????????\"\n     * @param state\n     */\n    private int getInversions(int[][] state) {\n        int inversion = 0;\n        int temp = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                int index = i* state.length + j + 1;\n                while(index < (state.length * state.length)) {\n                    if(state[index/state.length][index%state.length] != 0\n                            && state[index/state.length]\n                            [index%state.length] < state[i][j]) {\n                        temp ++;\n                    }\n                    index ++;\n                }\n                inversion = temp + inversion;\n                temp = 0;\n            }\n        }\n        return inversion;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n/**\n * IDA*?±??§£15puzzle????¢?\n * IDA*??´??????IDDFS???A*???????????¶???IDDFS??§??¶????±??§£????¨??????????????????????A*???????????????\"?????????\"????´¢???\n * IDA*?????\\????§£????????£??±??????A*???????????¶????????????\"??±???\"?????????????¢?????§£???\"????????????\"???\n * ???\"????????????\"???????????£?¢????????£???????????????¨\"????????????\"??????????????°???????§£?????????????????????????°±??§????????£???\n * ?????????A*???????????????????????????????????¨?????±????????¨???IDDFS????????\\???IDA*?????±?????????????´¢?????????????????????????????¨???\n * @author wly\n * @date 2013-12-20\n *\n */\npublic class Main {\n\n    //????????£??¨????????????????????????????§???¨?????????????????°\n    private int[] up = {-1,0};\n    private int[] down = {1,0};\n    private int[] left = {0,-1};\n    private int[] right = {0,1};\n\n    /**??¨????????????UP???DOWN???LEFT???RIGHT??????????????????????????????????????¢??£???????????¨\n     * ((dPrev != dCurr) && (dPrev%2 == dCurr%2))\n     * ??\\???????????????????§???¨??????????????????\n     */\n    private final int UP = 0;\n    private final int DOWN = 2;\n    private final int LEFT = 1;\n    private final int RIGHT = 3;\n\n    private int SIZE;\n\n    //?????????????????????\n    private int[][] targetPoints;\n\n    //??¨?????°????§???¨??\\???????????¨0,1,2,3,???????????????????????????\n    private static int[] moves = new int[100000];\n\n    private static long ans = 0;; //???????????£???\"????????£???\"\n\n    //????????¶???\n    private static int[][] tState = {\n            {1 ,2 ,3  } ,\n            {4 ,5 ,6  } ,\n            {7 ,8, 0  }\n\n    };\n\n    private static int[][] sState;\n\n\n    private static int blank_row,blank_column;\n\n    public Main(int[][] state) {\n        SIZE = state.length;\n        targetPoints = new int[SIZE * SIZE][2];\n\n        this.sState = state;\n        //?????°????????????\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] == 0) {\n                    blank_row = i;\n                    blank_column = j;\n                    break;\n                }\n            }\n        }\n\n        //?????°?????????????????°???\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state.length;j++) {\n                targetPoints[tState[i][j]][0] = i; //?????????\n\n                targetPoints[tState[i][j]][1] = j; //?????????\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int step = 0;\n        int[][] sState=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            sState[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            sState[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            sState[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n\n        Main idaAlgorithm = new Main(sState);\n            //??\\??????????????????????§?????°???£?????°\n            int j = idaAlgorithm.getHeuristic(sState);\n            int i = -1;//?????????????§???¨??????\n            //?????£?????±\"????°???£?????°\"\n            for(ans=j;;ans++) {\n                if(idaAlgorithm.solve(sState\n                        ,blank_row,blank_column,0,i,j)) {\n                    break;\n                }\n            }\n            int[][] matrix = idaAlgorithm.move(sState,moves[0]);\n            step ++;\n            for(int k=1;k<ans;k++) {\n                matrix = idaAlgorithm.move(matrix, moves[k]);\n                step ++;\n            }\n            System.out.println(step);\n    }\n\n    public int[][] move(int[][]state,int direction) {\n        int row = 0;\n        int column = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state.length;j++) {\n                if(state[i][j] == 0) {\n                    row = i;\n                    column = j;\n                }\n            }\n        }\n        switch(direction) {\n            case UP:\n                state[row][column] = state[row-1][column];\n                state[row-1][column] = 0;\n                break;\n            case DOWN:\n                state[row][column] = state[row+1][column];\n                state[row+1][column] = 0;\n                break;\n            case LEFT:\n                state[row][column] = state[row][column-1];\n                state[row][column-1] = 0;\n                break;\n            case RIGHT:\n                state[row][column] = state[row][column+1];\n                state[row][column+1] = 0;\n                break;\n        }\n        return state;\n    }\n\n\n    /**\n     * ?±??§£??????\n     * @param state ????????¶???\n     * @param blank_row ??????????????????\n     * @param blank_column ??????????????????\n     * @param dep ????????±???\n     * @param d ???????¬??§???¨?????????\n     * @param h ????????¶?????°????????°\n     * @return\n     */\n    public boolean solve(int[][] state,int blank_row,int blank_column,\n                         int dep,long d,long h) {\n\n        long h1;\n\n        //???????????????????????????????????????????????????????????¨???????¢?????§£\n        boolean isSolved = true;\n        for(int i=0;i<SIZE;i++) {\n            for(int j=0;j<SIZE;j++) {\n                if(state[i][j] != tState[i][j]) {\n                    isSolved = false;\n                }\n            }\n        }\n        if(isSolved) {\n            return true;\n        }\n\n        if(dep == ans) {\n            return false;\n        }\n\n        //??¨?????¨???\"??????\"?§???¨??????????????????\n        int blank_row1 = blank_row;\n        int blank_column1  = blank_column;\n        int[][] state2 = new int[SIZE][SIZE];\n\n        for(int direction=0;direction<4;direction++) {\n            for(int i=0;i<state.length;i++) {\n                for(int j=0;j<state.length;j++) {\n                    state2[i][j] = state[i][j];\n                }\n            }\n\n            //??¬??°?§???¨?????????????¬??§???¨??????????\\????????????????????§????????????¨???\n            if(direction != d && (d%2 == direction%2)) {\n                continue;\n            }\n\n            if(direction == UP) {\n                blank_row1 = blank_row + up[0];\n                blank_column1 = blank_column + up[1];\n            } else if(direction == DOWN) {\n                blank_row1 = blank_row + down[0];\n                blank_column1 = blank_column + down[1];\n            } else if(direction == LEFT) {\n                blank_row1 = blank_row + left[0];\n                blank_column1 = blank_column + left[1];\n            } else {\n                blank_row1 = blank_row + right[0];\n                blank_column1 = blank_column + right[1];\n            }\n\n            //???????£???\\\n            if(blank_column1 < 0 || blank_column1 == SIZE\n                    || blank_row1 < 0 || blank_row1 == SIZE) {\n                continue ;\n            }\n\n            //?????¢??????????????????????§???¨????????????????????????\n            state2[blank_row][blank_column] = state2[blank_row1][blank_column1];\n            state2[blank_row1][blank_column1] = 0;\n\n            //??\\???????????????????????£??¨???????????????\n            if(direction == DOWN && blank_row1\n                    > targetPoints[state[blank_row1][blank_column1]][0]) {\n                h1 = h - 1;\n            } else if(direction == UP && blank_row1\n                    < targetPoints[state[blank_row1][blank_column1]][0]){\n                h1 = h - 1;\n            } else if(direction == RIGHT && blank_column1\n                    > targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else if(direction == LEFT && blank_column1\n                    < targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else {\n                //????§???????????????¨????????????????§???¨????????????????????°????????°????????§\n                h1 = h + 1;\n            }\n\n            if(h1+dep+1>ans) { //??????\n                continue;\n            }\n\n            moves[dep] = direction;\n\n            //?????£??±????±??§£\n            if(solve(state2, blank_row1, blank_column1, dep+1, direction, h1)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * ?????°??°????????°???\n     */\n    public int getHeuristic(int[][] state) {\n        int heuristic = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] != 0) {\n                    heuristic = heuristic +\n                            Math.abs(targetPoints[state[i][j]][0] - i)\n                            + Math.abs(targetPoints[state[i][j]][1] - j);\n\n                }\n            }\n        }\n        return heuristic;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeComparator nodeComparator = new NodeComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (2000,nodeComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (2000,nodeComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        //????????\\????????????????????¨???????????°?????????????????°???g??? ???????°??????°??¨???g????????????????????????\n        //???????????????????????????????????¢?????°\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenOrCloseIn(childNode,open)){\n                Iterator<Node> iterNew = open.iterator();\n                while(iterNew.hasNext())\n                {\n                    Node iterNode = iterNew.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                        }\n                    }\n                }\n            }\n            else if(isOpenOrCloseIn(childNode,close))\n            {\n                Iterator<Node> iterNew = close.iterator();\n                while(iterNew.hasNext())\n                {\n                    Node iterNode = iterNew.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                            iterNew.remove();\n                            open.add(childNode);\n                        }\n                    }\n                }\n            }\n            else\n            {\n                open.add(childNode);\n            }\n        }\n    }\n\n    private boolean isOpenOrCloseIn(Node newNode, PriorityQueue<Node> openList)\n    {\n        Iterator<Node> iter = openList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\tstatic int N = 3;\n\tstatic int N2 = 9;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tPuzzle puzzle = new Puzzle();\n\t\tfor (int i = 0; i < N2; i++) {\n\t\t\tint v = scanner.nextInt();\n\t\t\tpuzzle.map[i] = v;\n\t\t\tif (v == 0) {\n\t\t\t\tpuzzle.space = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(slove(puzzle));\n\t}\n\n\tint[][] dxy = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\tprivate int slove(Puzzle in) {\n\t\tPuzzle u = new Puzzle();\n\t\tPuzzle v = new Puzzle();\n\t\tDeque<Puzzle> deque = new ArrayDeque<Puzzle>();\n\t\tSet<Puzzle> set = new HashSet<Main.Puzzle>();\n\t\tset.add(in);\n\t\tdeque.offer(in);\n\t\twhile (!deque.isEmpty()) {\n\t\t\tu = deque.poll();\n\t\t\tif (isTrue(u)) {\n\t\t\t\treturn u.count;\n\t\t\t}\n\t\t\tint y = u.space / N;\n\t\t\tint x = u.space % N;\n\t\t\tfor (int[] a : dxy) {\n\t\t\t\tint dy = y + a[0];\n\t\t\t\tint dx = x + a[1];\n\t\t\t\tif (dy < 0 || dx < 0 || N <= dy || N <= dx)\n\t\t\t\t\tcontinue;\n\t\t\t\tv = u.clone();\n\t\t\t\tswap(v, u.space, dy * N + dx);\n\t\t\t\tv.space = dy * N + dx;\n\t\t\t\tif (!set.contains(v)) {\n\t\t\t\t\tset.add(v);\n\t\t\t\t\tv.count++;\n\t\t\t\t\tdeque.offer(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tprivate boolean isTrue(Puzzle u) {\n\t\tfor (int i = 0; i < N2 - 1; i++) {\n\t\t\tif (u.map[i] != i + 1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate void swap(Puzzle v, int space, int i) {\n\t\tint t = v.map[i];\n\t\tv.map[i] = v.map[space];\n\t\tv.map[space] = t;\n\n\t}\n\tclass Puzzle implements Cloneable {\n\t\tint[] map = new int[N2];\n\t\tint space;\n\t\tint count = 0;\n\n\t\t@Override\n\t\tpublic Puzzle clone() {\n\t\t\ttry {\n\t\t\t\tPuzzle clonePuzzle = (Puzzle) super.clone();\n\t\t\t\tclonePuzzle.map = Arrays.copyOf(map, N2);\n\t\t\t\treturn clonePuzzle;\n\t\t\t} catch (CloneNotSupportedException e) {\n\t\t\t\tthrow new InternalError();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + getOuterType().hashCode();\n\t\t\tresult = prime * result + Arrays.hashCode(map);\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPuzzle other = (Puzzle) obj;\n\t\t\tif (!getOuterType().equals(other.getOuterType()))\n\t\t\t\treturn false;\n\t\t\tif (!Arrays.equals(map, other.map))\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate Main getOuterType() {\n\t\t\treturn Main.this;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "    import java.io.*; \n    import java.util.*; \n    public class Main {\n        public static final int SIZE = 3; \n        public static final int ALL_SIZE = SIZE * SIZE; \n        public static int[] factor= { 1, 1, 2, 6, 24, 120, 720, 5040, 50320, 362880 };\n        public static int hash(int[] A){ \n            int[] A_ = new int[A.length]; \n            System.arraycopy(A, 0, A_, 0, A.length); \n            int ret = 0; \n            for(int i = 0; i < A_.length; i++){ \n                ret += A_[i] * factor[(A.length - i - 1)]; \n                for(int j = i + 1; j < A_.length; j++){ \n                    if(A_[j] >= A_[i]){ \n                        A_[j]--; \n                    } \n                } \n            } \n            return ret; \n        } \n        public static int[] unhash(int hash){ \n            int[] ret = new int[ALL_SIZE]; \n            for(int i = 0; i < ALL_SIZE; i++) { \n                ret[i] = hash / factor[ALL_SIZE - i - 1]; \n                hash -= factor[ALL_SIZE - i - 1] * ret[i]; \n            } \n            for(int i = ALL_SIZE - 1; i >= 0; i--){ \n                for(int j = i + 1; j < ALL_SIZE; j++){ \n                    if(ret[i] <= ret[j]) \n                        ret[j]++; \n                } \n            } \n            return ret; \n        } \n        public static final int GOAL = hash(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 0}); \n        public static final int MAX = hash(new int[]{8, 7, 6, 5, 4, 3, 2, 1, 0}) + 1;\n        public static void main(String[] args) throws IOException { \n            Scanner sc = new Scanner(System.in);\n            int[] visited = new int[MAX]; \n            Arrays.fill(visited, Integer.MAX_VALUE); \n            LinkedList<Integer> queue = new LinkedList<>(); \n            int[] input = new int[ALL_SIZE]; \n            for(int i = 0; i < SIZE; i++){ \n                for(int j = 0; j < SIZE; j++){ \n                    input[i * SIZE + j] = sc.nextInt(); \n                } \n            } \n            final int hash_input = hash(input); \n            queue.add(hash_input); \n            visited[hash_input] = 0; \n            while(!queue.isEmpty()){ \n                final int hashed = queue.poll(); \n                if(hashed == GOAL){ \n                    System.out.println(visited[hashed]); \n                    break; \n                } \n                final int dist = visited[hashed]; \n                int[] ret = unhash(hashed); \n                for(int i = 0; i < ALL_SIZE; i++){ \n                    if(ret[i] == 0){ \n                        if(i % 3 != 0){ \n                            int tmp = ret[i]; \n                            ret[i] = ret[i - 1]; \n                            ret[i - 1] = tmp; \n                            final int next_hash = hash(ret); \n                            if(visited[next_hash] > dist + 1){ \n                                visited[next_hash] = dist + 1; \n                                queue.add(next_hash); \n                            } \n                            tmp = ret[i]; \n                            ret[i] = ret[i - 1]; \n                            ret[i - 1] = tmp; \n                        } \n                        if(i % 3 != 2){ \n                            int tmp = ret[i]; \n                            ret[i] = ret[i + 1]; \n                            ret[i + 1] = tmp; \n                            final int next_hash = hash(ret); \n                            if(visited[next_hash] > dist + 1){ \n                                visited[next_hash] = dist + 1; \n                            queue.add(next_hash); } tmp = ret[i]; \n                            ret[i] = ret[i + 1]; \n                            ret[i + 1] = tmp; \n                        } \n                        if(i / 3 != 0){ \n                            int tmp = ret[i]; \n                            ret[i] = ret[i - SIZE]; \n                            ret[i - SIZE] = tmp; \n                            final int next_hash = hash(ret); \n                            if(visited[next_hash] > dist + 1){ \n                                visited[next_hash] = dist + 1; \n                                queue.add(next_hash); \n                            } \n                            tmp = ret[i]; \n                            ret[i] = ret[i - SIZE]; \n                            ret[i - SIZE] = tmp; \n                        } \n                        if(i / 3 != 2){ \n                            int tmp = ret[i]; \n                            ret[i] = ret[i + SIZE]; \n                            ret[i + SIZE] = tmp; \n                            final int next_hash = hash(ret); \n                            if(visited[next_hash] > dist + 1){ \n                                visited[next_hash] = dist + 1; \n                                queue.add(next_hash); \n                            } \n                            tmp = ret[i]; \n                            ret[i] = ret[i + SIZE]; \n                            ret[i + SIZE] = tmp; \n                        } \n                    } \n                } \n            } \n        } \n        public static class Scanner { \n            private BufferedReader br; \n            private StringTokenizer tok; \n            public Scanner(InputStream is) throws IOException { \n                br = new BufferedReader(new InputStreamReader(is)); \n            } \n            private void getLine() throws IOException { \n                while (!hasNext()) { \n                    tok = new StringTokenizer(br.readLine()); \n                } \n            } \n            private boolean hasNext() { \n                return tok != null && tok.hasMoreTokens(); \n            } \n            public String next() throws IOException { \n                getLine(); \n                return tok.nextToken(); \n            } \n            public int nextInt() throws IOException {\n                return Integer.parseInt(next()); \n            } \n            public long nextLong() throws IOException { \n                return Long.parseLong(next()); \n            } \n            public void close() throws IOException { \n                br.close(); \n            }\n        }\n    }\n    }\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\n\nclass field{\n\tint cell[] = new int[9];\n\tint evaluation;\n\tint route[];\n\tint floor;\n\n\tfield(int cell[], int hash){\n\t\tfloor = 1;\n\t\troute = new int[1];\n\t\troute[0] = hash;\n\t\tfor(int i = 0; i < 9; i++) this.cell[i] = cell[i];\n\t\tint eva = 0;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tif(cell[i] != 0){\n\t\t\t\t//?¨???????????????¢?????????\n\t\t\t\t//i???????????????????????????\n\t\t\t\t//cell[i]???????????????????????°???\n\t\t\t\teva += Math.abs((cell[i]-1)%3 - i%3);\n\t\t\t\t//?????????????????¢?????????\n\t\t\t\teva += Math.abs((cell[i]-1)/3 - i/3);\n\t\t\t}\n\t\t}\n\t\tevaluation = eva;\n\t}\n\n\t/**/\n\n\tfield(int cell[], int route[], int hash){\n\t\tthis.floor = route.length;\n\t\tthis.route = new int[floor+1];\n\t\tSystem.arraycopy(route, 0, this.route, 0, floor);\n\t\tthis.route[floor] = hash; //hash???????´???????\n\t\tfor(int i = 0; i < 9; i++) this.cell[i] = cell[i];\n\t\tint eva = 0;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tif(cell[i] != 0){\n\t\t\t\t//?¨???????????????¢?????????\n\t\t\t\t//i???????????????????????????\n\t\t\t\t//cell[i]???????????????????????°???\n\t\t\t\teva += Math.abs((cell[i]-1)%3 - i%3);\n\t\t\t\t//?????????????????¢?????????\n\t\t\t\teva += Math.abs((cell[i]-1)/3 - i/3);\n\t\t\t}\n\t\t}\n\t\tevaluation = eva; //??¨????????????\n\t}\n\n\tpublic String toString(){\n\t\treturn new String(cell[0] + \" \" + cell[1] + \" \" + cell[2] + \"\\n\" + cell[3] + \" \" + cell[4] + \" \" + cell[5] + \"\\n\" + cell[6] + \" \" + cell[7] + \" \" + cell[8] + \"\\n\");\n\t}\n}\n\n/**/\nclass ev_list{\n\tfield elem;\n\tev_list next;\n\t\n\tev_list(){\n\t\tnext = null;\n\t\tthis.elem = null;\n\t}\n\n\tev_list(field elem){\n\t\tnext = null;\n\t\tthis.elem = elem;\n\t}\n\n\t/**/\n\tpublic void insert(ev_list node){\n\t\t//?????\\??????????????£????????¢??°??????????¬???????????????????????????§?????????\n\t\t//??????????¬???????????????????????????¨????????\\\n\t\tif(this.next == null || this.next.elem.evaluation + this.next.elem.floor < node.elem.evaluation + node.elem.floor){\n\t\t\t//?¬????????????????????????\\??????????????£????????¢??°??????????°??????????\n\t\t\t//this, this.next???node????????\\??????this, node, node.next(this.next)?????????\n\t\t\tnode.next = this.next;\n\t\t\tthis.next = node;\n\t\t}else this.next.insert(node);\n\t\t//?¬????????????????????????????????????§????????¨???????¬????????????????node????????\\??????\n\t}\n\n\t/**/\n\tpublic field pop(){\n\t\tif(this.next == null) return null;\n\t\tif(this.next.next == null){ //?¬?????¬????null??????\n\t\t\tfield temp = this.next.elem; //???????¬?????????£????????????temp???\n\t\t\tthis.next = null; //???????¬????null?????????\n\t\t\treturn temp; //???????¬??????£?????????temp?????????\n\t\t}else return this.next.pop(); //?¬?????¬????null??§????????£??????????¬????pop??????\n\t}\n}\n\n/**/\n\npublic class Main{\n\n\tstatic final int LEFT = 0;\n\tstatic final int RIGHT = 1;\n\tstatic final int UP = 2;\n\tstatic final int DOWN = 3;\n\tstatic final int factor[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320}; //1???????§????????????????????´????n?????????\n\n\t/**/\n\t//???????????\\??????????????¢??°\n\tstatic public int hashkey(int[] cell){\n\t\tint val[] = new int[9];\n\t\tSystem.arraycopy(cell, 0, val, 0, 9);\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tfor(int j = i+1; j < 9; j++){\n\t\t\t\tif(val[j] > val[i]) val[j]--;\n\t\t\t}\n\t\t}\n\t\t//val??????0??????????????????????????????????????????????????????????????\\?????¢????????°\n\t\tint hash = 0;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\thash += val[i]  * factor[8-i]; //factor????????§????????°?????????????????????????????????????????????\n\t\t}\n\t\treturn hash;\n\t}\n\n\t/**/\n\tstatic public field dehash(int key){\n\t\tint cell[] = new int[9];\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tcell[i] = key/factor[8-i]; //factor????????§????????°??????????????£????????????cell???val??¨??????\n\t\t\tkey %= factor[8-i];//factor?????????????????????key???\n\t\t}\n\t\tfor(int i = 8; i >= 0; i--){\n\t\t\tfor(int j = i+1; j < 9; j++){\n\t\t\t\tif(cell[i] <= cell[j]) cell[j] ++;\n\t\t\t}\n\t\t}\n\t\t//hash??????key??????????????¨???val???cell??????????????????????????§??????cell???????????????dehash??§???????????¨????¢????\n\t\treturn new field(cell, key);\n\t}\n\n\t/**/\n\n\t//3*3????????£????????????????§??????§????????????\n\t//move[i][LEFT]:??????????????????(0,1)\n\t//move[i][RIGHT]:??????????????????(0,1)\n\t//move[i][UP]:??????????????????(0,1)\n\t//move[i][DOWN]:??????????????????(0,1)\n\tstatic boolean move[][] = new boolean[9][4];\n\n\tpublic static void main(String[] args){\n\t\t\n\t\t//?§????????????????????¨??????¨???\n\n\t\t//?§??????§?????????????????????????????????????¨??????????\n\t\t//????????????????????????????????????\n\t\tmove[0][RIGHT]=move[1][RIGHT]=move[3][RIGHT]=move[4][RIGHT]=move[6][RIGHT]=move[7][RIGHT]=true;\n\t\tmove[2][RIGHT]=move[5][RIGHT]=move[8][RIGHT]=false;\n\n\t\t//????????????????????????????????????\n\t\tmove[1][LEFT]=move[2][LEFT]=move[4][LEFT]=move[5][LEFT]=move[7][LEFT]=move[8][LEFT]=true;\n\t\tmove[0][LEFT]=move[3][LEFT]=move[6][LEFT]=false;\n\n\t\t/**/\n\t\t//????????????????????????????????????\n\t\tmove[3][UP]=move[4][UP]=move[5][UP]=move[6][UP]=move[7][UP]=move[8][UP]=true;\n\t\tmove[0][UP]=move[1][UP]=move[2][UP]=false;\n\n\t\t//????????????????????????????????????\n\t\tmove[0][DOWN]=move[1][DOWN]=move[2][DOWN]=move[3][DOWN]=move[4][DOWN]=move[5][DOWN]=true;\n\t\tmove[6][DOWN]=move[7][DOWN]=move[8][DOWN]=false;\n\n\t\t/**/\n\t\t//????????????????¨??????¨???\n\t\t//????????????\n\t\tfield st;\n\t\tint cell[] = new int[9];\n\n\t\tScanner scan = new Scanner(System.in).useDelimiter(\"[\\\\s]+\");\n\t\tfor(int i=0;i<3;i++)\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\tcell[3i+j] = scan.nextInt();\n\t\t//for?????°???????????§cell??\\???\n\n\t\tst = new field(cell, hashkey(cell)); //??¨????????¢?????¨?????????????????¨???????????\\??????????????£????????????????????????\n\t\t/**/\n\t\t//???????????\\????????????\n\t\tboolean visited[] = new boolean[362880];\n\t\tfor(int i=0; i<362880; i++)\n\t\t\tvisited[i] = false;\n\n\t\t//??¢?´¢??¨???\n\n\t\t//??????????????????????¨????\n\t\tev_list list = new ev_list();\n\t\tlist.insert(new ev_list(st)); //?????????????????£?????????????????\\??????\n\t\tvisited[hashkey(cell)] = true; //???????????\\????????????????????????true?????????\n\n\t\t/**/\n\t\tfield cur;\n\t\tint hash;\n\t\tint count=0;\n\t\twhile( (cur=list.pop() )!= null){\n\t\t\tcount++; //??¢?´¢?????°???1?¢???????\n\n\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\tif(cur.cell[i]==0){ //cur????????¬???????????£????????????cell[i]???0??????\n\t\t\t\t\tif(move[i][LEFT]){ //?????????????????????????????¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i-1];\n\t\t\t\t\t\tcur.cell[i-1]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell); //hashkey?????????\n\t\t\t\t\t\tif(!visited[hash]){ //hashkey????¨??????????????????????\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) )); //list????????£?????????????????\\??????\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i-1]=cur.cell[i]; //????????????\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t\t/**/\n\t\t\t\t\tif(move[i][RIGHT]){ //?????????????????????????????¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i+1];\n\t\t\t\t\t\tcur.cell[i+1]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell); //hashkey?????????\n\t\t\t\t\t\tif(!visited[hash]){ //hashkey????¨??????????????????????\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) ));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i+1]=cur.cell[i];\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(move[i][UP]){ //?????????????????????????????¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i-3];\n\t\t\t\t\t\tcur.cell[i-3]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell);\n\t\t\t\t\t\tif(!visited[hash]){\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) ));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i-3]=cur.cell[i];\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(move[i][DOWN]){ //?????????????????????????????¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i+3];\n\t\t\t\t\t\tcur.cell[i+3]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell); //hashkey?????????\n\t\t\t\t\t\tif(!visited[hash]){\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) ));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i+3]=cur.cell[i];\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/**/\n\t\t\tif(cur.evaluation==0){\n\t\t\t\tSystem.out.println(cur.route.length);\n\t\t\t\t//System.out.println(count+\"\");\n\t\t\t\t//System.out.println(\"evaluation[ \"+0+\" ]=\"+dehash(cur.route[0]).evaluation+\"\\n\"+dehash(cur.route[0]) );\n\t\t\t\t//evaluation??¨???????????????cur.route[0]?????????????????\\??????\n\t\t\t\t//for(int i=1;i<cur.route.length;i++){\n\t\t\t\t\t//System.out.println(\"???\");\n\t\t\t\t\t//System.out.println(\"evaluation[ \" +i+\" ]=\"+dehash(cur.route[i]).evaluation);\n\t\t\t\t\t//System.out.println(\"evaluation+floor[ \"+i+\" ]=\"+(dehash(cur.route[i]).evaluation+i) );\n\t\t\t\t\t//evalution??¨???????????????floor?§?????????¢\n\t\t\t\t\t//System.out.println( dehash(cur.route[i]).toString() );\n\t\t\t\t//}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint[] input = new int[9];\n\t\tString[] first = s.nextLine().split(\" \");\n\t\tinput[0] = Integer.parseInt(first[0]);\n\t\tinput[1] = Integer.parseInt(first[1]);\n\t\tinput[2] = Integer.parseInt(first[2]);\n\n\t\tString[] second = s.nextLine().split(\" \");\n\t\tinput[3] = Integer.parseInt(second[0]);\n\t\tinput[4] = Integer.parseInt(second[1]);\n\t\tinput[5] = Integer.parseInt(second[2]);\n\n\t\tString[] three = s.nextLine().split(\" \");\n\t\tinput[6] = Integer.parseInt(three[0]);\n\t\tinput[7] = Integer.parseInt(three[1]);\n\t\tinput[8] = Integer.parseInt(three[2]);\n\n\t\tSystem.out.println(solve(input));\n\t}\n\n\tpublic static int solve(int[] input) {\n\t\tint cnt = 0;\n\t\tLinkedList<int[]> queue = new LinkedList<int[]>();\n\t\tLinkedList<Integer> cntQueue = new LinkedList<Integer>();\n\t\tqueue.offer(input);\n\t\tcntQueue.offer(0);\n\n\t\twhile(! queue.isEmpty()) {\n\t\t\tint[] ban = queue.poll();\n\t\t\tcnt = cntQueue.poll();\n\t\t\t//??????\n\t\t\tif(check(ban))\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tint zeroIndex = 0;\n\t\t\t\tfor(int i=0 ; i<ban.length ; i++) {\n\t\t\t\t\tif(ban[i] == 0)\n\t\t\t\t\t\tzeroIndex = i;\n\t\t\t\t}\n\n\t\t\t\tswitch (zeroIndex) {\n\t\t\t\t//????????????????????´???\n\t\t\t\tcase 0:\n\t\t\t\t\tint[] copyArray = ban.clone();\n\t\t\t\t\tcopyArray[0] = copyArray[1];\n\t\t\t\t\tcopyArray[1] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[0] = copyArray[3];\n\t\t\t\t\tcopyArray[3] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\tbreak;\n\n\t\t\t\t//??????????????????????????´???\n\t\t\t\tcase 1:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[1] = copyArray[0];\n\t\t\t\t\tcopyArray[0] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[1] = copyArray[4];\n\t\t\t\t\tcopyArray[4] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[1] = copyArray[2];\n\t\t\t\t\tcopyArray[2] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\tbreak;\n\n\t\t\t\t//????????????????????´???\n\t\t\t\tcase 2:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[2] = copyArray[1];\n\t\t\t\t\tcopyArray[1] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[2] = copyArray[5];\n\t\t\t\t\tcopyArray[5] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\tbreak;\n\n\t\t\t\t//?????????????????´???\n\t\t\t\tcase 3:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[3] = copyArray[0];\n\t\t\t\t\tcopyArray[0] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[3] = copyArray[4];\n\t\t\t\t\tcopyArray[4] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[3] = copyArray[6];\n\t\t\t\t\tcopyArray[6] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\tbreak;\n\n\t\t\t\t//???????????????????????´???\n\t\t\t\tcase 4:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[4] = copyArray[1];\n\t\t\t\t\tcopyArray[1] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[4] = copyArray[3];\n\t\t\t\t\tcopyArray[3] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[4] = copyArray[5];\n\t\t\t\t\tcopyArray[5] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[4] = copyArray[7];\n\t\t\t\t\tcopyArray[7] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\tbreak;\n\n\t\t\t\t//?????????????????´???\n\t\t\t\tcase 5:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[5] = copyArray[2];\n\t\t\t\t\tcopyArray[2] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[5] = copyArray[4];\n\t\t\t\t\tcopyArray[4] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[5] = copyArray[8];\n\t\t\t\t\tcopyArray[8] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\tbreak;\n\n\t\t\t\t//????????????????????´???\n\t\t\t\tcase 6:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[6] = copyArray[3];\n\t\t\t\t\tcopyArray[3] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[6] = copyArray[7];\n\t\t\t\t\tcopyArray[7] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\tbreak;\n\n\t\t\t\t//??????????????????????????´???\n\t\t\t\tcase 7:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[7] = copyArray[6];\n\t\t\t\t\tcopyArray[6] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[7] = copyArray[4];\n\t\t\t\t\tcopyArray[4] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[7] = copyArray[8];\n\t\t\t\t\tcopyArray[8] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\tbreak;\n\n\t\t\t\t//????????????????????´???\n\t\t\t\tcase 8:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[8] = copyArray[5];\n\t\t\t\t\tcopyArray[5] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[8] = copyArray[7];\n\t\t\t\t\tcopyArray[7] = 0;\n\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tpublic static boolean check(int[] ban) {\n\t\tfor(int i=0 ; i<ban.length ; i++) {\n\t\t\tif(i!=8 && ban[i]!=(i+1))\n\t\t\t\treturn false;\n\t\t\tif(i==8 && ban[i]!=0)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\tstatic int SIZE = 3;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tPuzzle p = new Puzzle();\n\n\t\tfor (int i = 0; i < SIZE*SIZE; i++) {\n\t\t\tp.board[i] = scanner.nextInt();\n\t\t\tif(p.board[i] == 0)\n\t\t\t\tp.space = i;\n\t\t}\n\n\t\tint steps = solve(p);\n\t\tSystem.out.println(steps);\n\t}\n\n    int[][] dxy = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\tprivate int solve(Puzzle p) {\n\t\tPuzzle u = new Puzzle();\n\t\tPuzzle v = new Puzzle();\n\n\t\tDeque<Puzzle> queue = new ArrayDeque<>();\n\t\tqueue.offer(p);\n\n\t\tSet<Puzzle> set = new HashSet<Main.Puzzle>();\n\t\tset.add(p);\n\n\t\twhile(!queue.isEmpty()) {\n\t\t\tu = queue.poll();\n\t\t\t\n\t\t\tif(isSolution(u)) \n\t\t\t\treturn u.countStep;\n\n\t\t\tint y = u.space/SIZE;\n\t\t\tint x = u.space%SIZE;\n\n\t\t\tfor(int[] d : dxy) {\n\t\t\t\tint dy = y + d[0];\n\t\t\t\tint dx = x + d[1];\n\n\t\t\t\tif(dy < 0 || dx < 0 || SIZE <= dy || SIZE <= dx) \n\t\t\t\t\tcontinue;\n\n\t\t\t\tv = u.clone();\n\t\t\t\tmove(v, u.space, dy*SIZE+dx);\n\t\t\t\tv.space = dy*SIZE+dx;\n\n\t\t\t\tif(!set.contains(v)) {\n\t\t\t\t\tset.add(v);\n\t\t\t\t\tv.countStep++;\n\t\t\t\t\tqueue.offer(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tprivate boolean isSolution(Puzzle p) {\n\t\tfor (int i = 0; i < SIZE*SIZE-1; i++) {\n\t\t\tif(p.board[i] != i+1)\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate void move(Puzzle p, int space, int i) {\n\t\tint tmp = p.board[i];\n\t\tp.board[i] = p.board[space];\n\t\tp.board[space] = tmp;\n\t}\n\n\n\tclass Puzzle implements Cloneable {\n\t\tint[] board = new int[SIZE*SIZE];\n\t\tint space;\n\t\tint countStep = 0;\n\n\t\t@Override\n\t\tpublic Puzzle clone(){\n\t\t\ttry {\n\t\t\t\tPuzzle newPuzzle = (Puzzle)super.clone();\n\t\t\t\tnewPuzzle.board = Arrays.copyOf(board, SIZE*SIZE);\n\t\t\t\treturn newPuzzle;\n\t\t\t} catch (CloneNotSupportedException e) {\n\t\t\t\tthrow new InternalError();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime*result + getOuterType().hashCode();\n\t\t\tresult = prime*result + Arrays.hashCode(board);\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif(this == obj)\n\t\t\t\treturn true;\n\n\t\t\tif(obj == null)\n\t\t\t\treturn false;\n\n\t\t\tif(getClass() != obj.getClass())\n\t\t\t\treturn false;\n\n\t\t\tPuzzle p = (Puzzle)obj;\n\t\t\t\n\t\t\tif(!getOuterType().equals(p.getOuterType()))\n\t\t\t\treturn false;\n\n\t\t\tif(!Arrays.equals(board, p.board))\n\t\t\t\treturn false;\n\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate Main getOuterType() {\n\t\t\treturn Main.this;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/12.\n */\nimport java.util.Scanner;\n\n/**\n * IDA* for 8 or 15 puzzle\n * f(x) = h(x) +depth(g(x))\n * @author huzhejie\n *\n */\npublic class Main {\n\n    private int[] up = {-1,0};\n    private int[] down = {1,0};\n    private int[] left = {0,-1};\n    private int[] right = {0,1};\n\n    private final int UP = 0;\n    private final int DOWN = 2;\n    private final int LEFT = 1;\n    private final int RIGHT = 3;\n\n    private int SIZE;\n\n    /*\n    store the position of the each point of the target state\n     */\n    private int[][] targetPoints;\n\n    /*\n    f(x),total cost\n     */\n    private static int cost;\n\n    //target state\n    private static int[][] tState = {{1,2,3},{4,5,6},{7,8,0}};\n\n    private static int blank_row,blank_column;\n\n    public Main(int[][] state) {\n        SIZE = state.length;\n        targetPoints = new int[SIZE * SIZE][2];\n\n        /*\n        get the position of blank point\n         */\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] == 0) {\n                    blank_row = i;\n                    blank_column = j;\n                    break;\n                }\n            }\n        }\n        /*\n        get the position(x,y) by using a two-dimensional array.\n        e.g. 2's position is (2,1),\n        targetPoints [2][0] = 2-1 =1,targetPoints[2][1]=1-1=0\n         */\n        for(int i=0;i<tState.length;i++) {\n            for(int j=0;j<tState.length;j++) {\n                targetPoints[tState[i][j]][0] = i;\n\n                targetPoints[tState[i][j]][1] = j;\n            }\n        }\n    }\n    public boolean checkState(int[][] state){\n        boolean b =true;\n        for(int i = 0;i<SIZE;i++)\n            for(int j=0;j<SIZE;j++){\n                if(!(state[i][j]==tState[i][j]))\n                    b = false;\n            }\n        return b;\n    }\n\n    public static void main(String[] args) {\n        int step = 0;\n        int[][] sState=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3&&(s=sc.nextLine())!=null){\n            sState[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            sState[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            sState[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        Main idaAlgorithm = new Main(sState);\n\n        if(idaAlgorithm.checkState(sState)){\n            System.out.println(step);\n        }\n        else{\n            int j = idaAlgorithm.getHeuristic(sState);\n            int i = -1;\n\n            for (cost = j; ; cost++) {\n                if (idaAlgorithm.solve(sState\n                        , blank_row, blank_column, 0, i, j)) {\n                    break;\n                }\n            }\n            System.out.println(cost);\n        }\n    }\n    /**\n     *\n     * @param state\n     * @param blank_row the row-coordinate of 0 in ths state\n     * @param blank_column the column-coordinate of 0 in ths state\n     * @param dep the depth of the state\n     * @param d the direction of the last move\n     * @param h the value of h(x)\n     * @return\n     */\n    public boolean solve(int[][] state,int blank_row,int blank_column,\n                         int dep,int d,int h) {\n        /*\n        the value of h(x) after moving\n         */\n        int h1;\n\n        /*\n        make a comparison with the target state\n         */\n        boolean isSolved = checkState(state);\n        if(isSolved) {\n            return true;\n        }\n\n        if(dep == cost) {\n            return false;\n        }\n\n        /*\n        the position of the blank point after moving\n         */\n        int blank_row1 ;\n        int blank_column1;\n        int[][] state2 = new int[SIZE][SIZE];\n\n        for(int direction=0;direction<4;direction++) {\n            for(int i=0;i<state.length;i++) {\n                for(int j=0;j<state.length;j++) {\n                    state2[i][j] = state[i][j];\n                }\n            }\n\n            /*\n            check whether the direction of this movement is opposite of the direction of the last move or not\n             */\n            if(direction != d && (d%2 == direction%2)) {\n                continue;\n            }\n\n            if(direction == UP) {\n                blank_row1 = blank_row + up[0];\n                blank_column1 = blank_column + up[1];\n            } else if(direction == DOWN) {\n                blank_row1 = blank_row + down[0];\n                blank_column1 = blank_column + down[1];\n            } else if(direction == LEFT) {\n                blank_row1 = blank_row + left[0];\n                blank_column1 = blank_column + left[1];\n            } else {\n                blank_row1 = blank_row + right[0];\n                blank_column1 = blank_column + right[1];\n            }\n\n            /*\n            border check\n             */\n            if(blank_column1 < 0 || blank_column1 == SIZE\n                    || blank_row1 < 0 || blank_row1 == SIZE) {\n                continue ;\n            }\n\n            /*\n            swap position\n             */\n            state2[blank_row][blank_column] = state2[blank_row1][blank_column1];\n            state2[blank_row1][blank_column1] = 0;\n\n            /*\n            calculate the h(x)\n             */\n            if(direction == DOWN && blank_row1\n                    > targetPoints[state[blank_row1][blank_column1]][0]) {\n                h1 = h - 1;\n            } else if(direction == UP && blank_row1\n                    < targetPoints[state[blank_row1][blank_column1]][0]){\n                h1 = h - 1;\n            } else if(direction == RIGHT && blank_column1\n                    > targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else if(direction == LEFT && blank_column1\n                    < targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else {\n                h1 = h + 1;\n            }\n\n            /*\n            if f(x) increases,prune\n             */\n            if(h1+dep+1> cost) {\n                continue;\n            }\n\n            /*\n            do the iteration with depth increasing\n             */\n            if(solve(state2, blank_row1, blank_column1, dep+1, direction, h1)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * get the value of h(x)\n     * @param state\n     */\n    public int getHeuristic(int[][] state) {\n        int heuristic = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] != 0) {\n                    heuristic = heuristic +\n                            Math.abs(targetPoints[state[i][j]][0] - i)\n                            + Math.abs(targetPoints[state[i][j]][1] - j);\n                }\n            }\n        }\n        return heuristic;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Deque;\nimport java.util.StringTokenizer;\n\nclass Main{\n    public static void main(String[] Args) throws IOException{\n        final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        final int[] board = new int[9];\n        StringTokenizer st = new StringTokenizer(br.readLine(), \" \");\n        for(int i = 0; i<9; i++){\n            if(i==3||i==6) st = new StringTokenizer(br.readLine(), \" \");\n            board[i] = Integer.parseInt(st.nextToken());\n        }\n        final Deque<state> q = new ArrayDeque<state>();\n        final BitSet cl = new BitSet(362880);\n        q.add(new state(board, 0));\n        cl.set(hash(board));\n        int minstep = -1;\n        while(!q.isEmpty()){\n            final state stat = q.remove();\n            if(hash(stat.board)==46233){\n                minstep = stat.step;\n                break;\n            }\n            int f;\n            for(f = 0; f<9&&stat.board[f]!=0; f++);\n            if(f%3!=0){\n                final int[] next = Arrays.copyOf(stat.board, stat.board.length);\n                next[f] = next[f-1];\n                next[f-1] = 0;\n                final int h = hash(next);\n                if(!cl.get(h)){\n                    cl.set(h);\n                    q.add(new state(next, stat.step+1));\n                }\n            }\n            if(f%3!=2){\n                final int[] next = Arrays.copyOf(stat.board, stat.board.length);\n                next[f] = next[f+1];\n                next[f+1] = 0;\n                final int h = hash(next);\n                if(!cl.get(h)){\n                    cl.set(h);\n                    q.add(new state(next, stat.step+1));\n                }\n            }\n            if(f>2){\n                final int[] next = Arrays.copyOf(stat.board, stat.board.length);\n                next[f] = next[f-3];\n                next[f-3] = 0;\n                final int h = hash(next);\n                if(!cl.get(h)){\n                    cl.set(h);\n                    q.add(new state(next, stat.step+1));\n                }\n            }\n            if(f<6){\n                final int[] next = Arrays.copyOf(stat.board, stat.board.length);\n                next[f] = next[f+3];\n                next[f+3] = 0;\n                final int h = hash(next);\n                if(!cl.get(h)){\n                    cl.set(h);\n                    q.add(new state(next, stat.step+1));\n                }\n            }\n        }\n        System.out.println(minstep);\n    }\n    private static int hash(int[] board){\n        int h = board[0];\n        for(int i = 1; i<8; i++){\n            h *= 9-i;\n            h += board[i];\n            for(int j = 0; j<i; j++){\n                if(board[j]<board[i]) --h;\n            }\n        }\n        return h;\n    }\n}\n\nclass state{\n    final int[] board;\n    final int step;\n    state(int[] board, int step){\n        this.board = board;\n        this.step = step;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n/**\n * Created by huzhejie on 2016/10/10.\n */\npublic class Main {\n    @SuppressWarnings(\"unchecked\")\n    public static void main(String args[]){\n        State initState = new State();\n        PriorityQueue<State> queue = new PriorityQueue<State>();\n        Scanner sc = new Scanner(System.in);\n        String s = null;\n        int count = 0;\n        while ((s = sc.nextLine())!=null&&count<3){\n            String str[] = s.split(\" \");\n            initState.map.put(Integer.parseInt(str[0]),new Coordinate(1,count+1));\n            initState.map.put(Integer.parseInt(str[1]),new Coordinate(2,count+1));\n            initState.map.put(Integer.parseInt(str[2]),new Coordinate(3,count+1));\n            initState.step = 0;\n            count++;\n        }\n        queue.add(initState);\n        int step = 0;\n        while(!queue.isEmpty()){\n            State state = queue.poll();\n            queue.clear();\n            Coordinate zero = state.map.get(0);\n            int bottomValue=state.getBottomNodeValue(zero);\n            int topValue = state.getTopNodeValue(zero);\n            int leftValue = state.getLeftNodeValue(zero);\n            int rightValue = state.getRightNodeValue(zero);\n            step++;\n            if(bottomValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(bottomValue).y = tempState.map.get(bottomValue).y-1;\n                tempState.map.get(0).y = tempState.map.get(0).y+1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                   queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    System.exit(0);\n                }\n            }\n            if(topValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                    tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(topValue).y = tempState.map.get(topValue).y+1;\n                tempState.map.get(0).y = tempState.map.get(0).y-1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                    queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    System.exit(0);\n                }\n            }\n            if(rightValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                    tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(rightValue).x = tempState.map.get(rightValue).x-1;\n                tempState.map.get(0).x = tempState.map.get(0).x+1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                    queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    System.exit(0);\n                }\n            }\n            if(leftValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                    tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(leftValue).x = tempState.map.get(leftValue).x+1;\n                tempState.map.get(0).x = tempState.map.get(0).x-1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                    queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    System.exit(0);\n                }\n            }\n        }\n    }\n\n}\n\nclass State implements Comparable<State>{\n    public HashMap<Integer,Coordinate> map;\n    public int step=0;\n    @SuppressWarnings(\"unchecked\")\n    public State(){\n        this.map = new HashMap<Integer, Coordinate>();\n    }\n   public int getRightNodeValue(Coordinate a){\n       if(a.x+1<4){\n           for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n               if (entry.getValue().x == a.x + 1 && entry.getValue().y == a.y) {\n                   return entry.getKey();\n               }\n           }\n               return -1;\n       }\n       else\n           return -1;\n   }\n    public int getLeftNodeValue(Coordinate a){\n        if(a.x-1>0){\n            for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n                if (entry.getValue().x == a.x - 1 && entry.getValue().y == a.y) {\n                    return entry.getKey();\n                }\n            }\n            return -1;\n        }\n        else\n            return -1;\n    }\n    public int getTopNodeValue(Coordinate a){\n        if(a.y-1>0){\n            for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n                if (entry.getValue().x == a.x  && entry.getValue().y == a.y-1) {\n                    return entry.getKey();\n                }\n            }\n            return -1;\n        }\n        else\n            return -1;\n    }\n    public int getBottomNodeValue(Coordinate a){\n        if(a.y+1<4){\n            for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n                if (entry.getValue().x == a.x&& entry.getValue().y == a.y+1) {\n                    return entry.getKey();\n                }\n            }\n            return -1;\n        }\n        else\n            return -1;\n    }\n    public int calculate(Map<Integer,Coordinate> map){\n        int sum = 0;\n        for(int key:map.keySet())\n                switch (key) {\n                    case 0: break;\n                    case 3: sum+=3-map.get(key).x+Math.abs(1-map.get(key).y);break;\n                    case 6: sum+=3-map.get(key).x+Math.abs(2-map.get(key).y);break;\n                    default: sum+=Math.abs(key%3-map.get(key).x)+Math.abs(key/3+1-map.get(key).y);break;\n                }\n        return sum;\n    }\n    @Override\n    public int compareTo(State o) {\n        return Integer.compare(calculate(map),o.calculate(o.map));\n    }\n}\nclass Coordinate implements Cloneable{\n    int x,y;\n    public Coordinate(int x,int y){\n        super();\n        this.x = x;\n        this.y = y;\n    }\n    @Override\n    public Coordinate clone(){\n        Coordinate c = null;\n        try{\n            c = (Coordinate)super.clone();\n        }catch (CloneNotSupportedException e){\n            e.printStackTrace();\n        }\n        return c;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\n/**\n * IDA*?±??§£15puzzle????¢?\n * IDA*??´??????IDDFS???A*???????????¶???IDDFS??§??¶????±??§£????¨??????????????????????A*???????????????\"?????????\"????´¢???\n * IDA*?????\\????§£????????£??±??????A*???????????¶????????????\"??±???\"?????????????¢?????§£???\"????????????\"???\n * ???\"????????????\"???????????£?¢????????£???????????????¨\"????????????\"??????????????°???????§£?????????????????????????°±??§????????£???\n * ?????????A*???????????????????????????????????¨?????±????????¨???IDDFS????????\\???IDA*?????±?????????????´¢?????????????????????????????¨???\n * @author wly\n * @date 2013-12-20\n *\n */\npublic class Main {\n\n    //????????£??¨????????????????????????????§???¨?????????????????°\n    private int[] up = {-1,0};\n    private int[] down = {1,0};\n    private int[] left = {0,-1};\n    private int[] right = {0,1};\n\n    /**??¨????????????UP???DOWN???LEFT???RIGHT??????????????????????????????????????¢??£???????????¨\n     * ((dPrev != dCurr) && (dPrev%2 == dCurr%2))\n     * ??\\???????????????????§???¨??????????????????\n     */\n    private final int UP = 0;\n    private final int DOWN = 2;\n    private final int LEFT = 1;\n    private final int RIGHT = 3;\n\n    private int SIZE;\n\n    //?????????????????????\n    private int[][] targetPoints;\n\n    //??¨?????°????§???¨??\\???????????¨0,1,2,3,???????????????????????????\n    private static int[] moves = new int[100000];\n\n    private static long ans = 0;; //???????????£???\"????????£???\"\n\n    //????????¶???\n    private static int[][] tState = {\n            {1 ,2 ,3 } ,\n            {4 ,5 ,6 } ,\n            {7 ,8, 0 }\n\n    };\n\n    private static int[][] sState;\n\n\n    private static int blank_row,blank_column;\n\n    public Main(int[][] state) {\n        SIZE = state.length;\n        targetPoints = new int[SIZE * SIZE][2];\n\n        this.sState = state;\n        //?????°????????????\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] == 0) {\n                    blank_row = i;\n                    blank_column = j;\n                    break;\n                }\n            }\n        }\n\n        //?????°?????????????????°???\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state.length;j++) {\n                targetPoints[tState[i][j]][0] = i; //?????????\n\n                targetPoints[tState[i][j]][1] = j; //?????????\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int step = 0;\n        int[][] sState=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            sState[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            sState[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            sState[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        boolean b =true;\n        for(int i = 0;i<3;i++)\n            for(int j=0;j<3;j++){\n                if(!(sState[i][j]==tState[i][j]))\n                    b = false;\n            }\n        if(b){\n            System.out.println(step);\n        }\n        else {\n\n            Main idaAlgorithm = new Main(sState);\n            //??\\??????????????????????§?????°???£?????°\n            int j = idaAlgorithm.getHeuristic(sState);\n            int i = -1;//?????????????§???¨??????\n            //?????£?????±\"????°???£?????°\"\n            for (ans = j; ; ans++) {\n                if (idaAlgorithm.solve(sState\n                        , blank_row, blank_column, 0, i, j)) {\n                    break;\n                }\n            }\n            int[][] matrix = idaAlgorithm.move(sState, moves[0]);\n            step++;\n            for (int k = 1; k < ans; k++) {\n                matrix = idaAlgorithm.move(matrix, moves[k]);\n                step++;\n            }\n            System.out.println(step);\n        }\n    }\n\n    public int[][] move(int[][]state,int direction) {\n        int row = 0;\n        int column = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state.length;j++) {\n                if(state[i][j] == 0) {\n                    row = i;\n                    column = j;\n                }\n            }\n        }\n        switch(direction) {\n            case UP:\n                state[row][column] = state[row-1][column];\n                state[row-1][column] = 0;\n                break;\n            case DOWN:\n                state[row][column] = state[row+1][column];\n                state[row+1][column] = 0;\n                break;\n            case LEFT:\n                state[row][column] = state[row][column-1];\n                state[row][column-1] = 0;\n                break;\n            case RIGHT:\n                state[row][column] = state[row][column+1];\n                state[row][column+1] = 0;\n                break;\n        }\n        return state;\n    }\n\n\n    /**\n     * ?±??§£??????\n     * @param state ????????¶???\n     * @param blank_row ??????????????????\n     * @param blank_column ??????????????????\n     * @param dep ????????±???\n     * @param d ???????¬??§???¨?????????\n     * @param h ????????¶?????°????????°\n     * @return\n     */\n    public boolean solve(int[][] state,int blank_row,int blank_column,\n                         int dep,long d,long h) {\n\n        long h1;\n\n        //???????????????????????????????????????????????????????????¨???????¢?????§£\n        boolean isSolved = true;\n        for(int i=0;i<SIZE;i++) {\n            for(int j=0;j<SIZE;j++) {\n                if(state[i][j] != tState[i][j]) {\n                    isSolved = false;\n                }\n            }\n        }\n        if(isSolved) {\n            return true;\n        }\n\n        if(dep == ans) {\n            return false;\n        }\n\n        //??¨?????¨???\"??????\"?§???¨??????????????????\n        int blank_row1 = blank_row;\n        int blank_column1  = blank_column;\n        int[][] state2 = new int[SIZE][SIZE];\n\n        for(int direction=0;direction<4;direction++) {\n            for(int i=0;i<state.length;i++) {\n                for(int j=0;j<state.length;j++) {\n                    state2[i][j] = state[i][j];\n                }\n            }\n\n            //??¬??°?§???¨?????????????¬??§???¨??????????\\????????????????????§????????????¨???\n            if(direction != d && (d%2 == direction%2)) {\n                continue;\n            }\n\n            if(direction == UP) {\n                blank_row1 = blank_row + up[0];\n                blank_column1 = blank_column + up[1];\n            } else if(direction == DOWN) {\n                blank_row1 = blank_row + down[0];\n                blank_column1 = blank_column + down[1];\n            } else if(direction == LEFT) {\n                blank_row1 = blank_row + left[0];\n                blank_column1 = blank_column + left[1];\n            } else {\n                blank_row1 = blank_row + right[0];\n                blank_column1 = blank_column + right[1];\n            }\n\n            //???????£???\\\n            if(blank_column1 < 0 || blank_column1 == SIZE\n                    || blank_row1 < 0 || blank_row1 == SIZE) {\n                continue ;\n            }\n\n            //?????¢??????????????????????§???¨????????????????????????\n            state2[blank_row][blank_column] = state2[blank_row1][blank_column1];\n            state2[blank_row1][blank_column1] = 0;\n\n            //??\\???????????????????????£??¨???????????????\n            if(direction == DOWN && blank_row1\n                    > targetPoints[state[blank_row1][blank_column1]][0]) {\n                h1 = h - 1;\n            } else if(direction == UP && blank_row1\n                    < targetPoints[state[blank_row1][blank_column1]][0]){\n                h1 = h - 1;\n            } else if(direction == RIGHT && blank_column1\n                    > targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else if(direction == LEFT && blank_column1\n                    < targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else {\n                //????§???????????????¨????????????????§???¨????????????????????°????????°????????§\n                h1 = h + 1;\n            }\n\n            if(h1+dep+1>ans) { //??????\n                continue;\n            }\n\n            moves[dep] = direction;\n\n            //?????£??±????±??§£\n            if(solve(state2, blank_row1, blank_column1, dep+1, direction, h1)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * ?????°??°????????°???\n     */\n    public int getHeuristic(int[][] state) {\n        int heuristic = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] != 0) {\n                    heuristic = heuristic +\n                            Math.abs(targetPoints[state[i][j]][0] - i)\n                            + Math.abs(targetPoints[state[i][j]][1] - j);\n\n                }\n            }\n        }\n        return heuristic;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\n/**\n * IDA*?±??§£15puzzle????¢?\n * IDA*??´??????IDDFS???A*???????????¶???IDDFS??§??¶????±??§£????¨??????????????????????A*???????????????\"?????????\"????´¢???\n * IDA*?????\\????§£????????£??±??????A*???????????¶????????????\"??±???\"?????????????¢?????§£???\"????????????\"???\n * ???\"????????????\"???????????£?¢????????£???????????????¨\"????????????\"??????????????°???????§£?????????????????????????°±??§????????£???\n * ?????????A*???????????????????????????????????¨?????±????????¨???IDDFS????????\\???IDA*?????±?????????????´¢?????????????????????????????¨???\n * @author wly\n * @date 2013-12-20\n *\n */\npublic class Main {\n\n    //????????£??¨????????????????????????????§???¨?????????????????°\n    private int[] up = {-1,0};\n    private int[] down = {1,0};\n    private int[] left = {0,-1};\n    private int[] right = {0,1};\n\n    /**??¨????????????UP???DOWN???LEFT???RIGHT??????????????????????????????????????¢??£???????????¨\n     * ((dPrev != dCurr) && (dPrev%2 == dCurr%2))\n     * ??\\???????????????????§???¨??????????????????\n     */\n    private final int UP = 0;\n    private final int DOWN = 2;\n    private final int LEFT = 1;\n    private final int RIGHT = 3;\n\n    private int SIZE;\n\n    //?????????????????????\n    private int[][] targetPoints;\n\n    //??¨?????°????§???¨??\\???????????¨0,1,2,3,???????????????????????????\n    private static int[] moves = new int[100000];\n\n    private static long ans = 0;; //???????????£???\"????????£???\"\n\n    //????????¶???\n    private static int[][] tState = {\n            {1 ,2 ,3  } ,\n            {4 ,5 ,6  } ,\n            {7 ,8, 0  }\n\n    };\n\n    private static int[][] sState;\n\n\n    private static int blank_row,blank_column;\n\n    public Main(int[][] state) {\n        SIZE = state.length;\n        targetPoints = new int[SIZE * SIZE][2];\n\n        this.sState = state;\n        //?????°????????????\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] == 0) {\n                    blank_row = i;\n                    blank_column = j;\n                    break;\n                }\n            }\n        }\n\n        //?????°?????????????????°???\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state.length;j++) {\n                targetPoints[tState[i][j]][0] = i; //?????????\n\n                targetPoints[tState[i][j]][1] = j; //?????????\n            }\n        }\n    }\n\n    /**\n     * ??¨???????¢????????§£??§\n     * @param state ??¶???\n     */\n    private boolean canSolve(int[][] state) {\n        if(state.length % 2 == 1) { //????¢???????????\\???°\n            return (getInversions(state) % 2 == 0);\n        } else { //????¢????????????¶??°\n            if((state.length - blank_row) % 2 == 1) { //??????????????°,?????????????\\???°???\n                return (getInversions(state) % 2 == 0);\n            } else { //??????????????°,??????????????¶??°???\n                return (getInversions(state) % 2 == 1);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int step = 0;\n        int[][] sState=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            sState[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            sState[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            sState[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n\n        Main idaAlgorithm = new Main(sState);\n//            System.out.println(\"--????¢?????§£???????§??±??§£--\");\n            //??\\??????????????????????§?????°???£?????°\n            int j = idaAlgorithm.getHeuristic(sState);\n//            System.out.println(\"????§?manhattan??????:\" + j);\n            int i = -1;//?????????????§???¨??????\n\n//            long time = System.currentTimeMillis();\n            //?????£?????±\"????°???£?????°\"\n            for(ans=j;;ans++) {\n                if(idaAlgorithm.solve(sState\n                        ,blank_row,blank_column,0,i,j)) {\n                    break;\n                }\n            }\n//            System.out.println(\"?±??§£??¨??¶:\"+(System.currentTimeMillis() - time));\n\n//            idaAlgorithm.printMatrix(sState);\n            int[][] matrix = idaAlgorithm.move(sState,moves[0]);\n            step ++;\n            for(int k=1;k<ans;k++) {\n                matrix = idaAlgorithm.move(matrix, moves[k]);\n                step ++;\n            }\n            System.out.println(step);\n    }\n\n    public int[][] move(int[][]state,int direction) {\n        int row = 0;\n        int column = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state.length;j++) {\n                if(state[i][j] == 0) {\n                    row = i;\n                    column = j;\n                }\n            }\n        }\n        switch(direction) {\n            case UP:\n                state[row][column] = state[row-1][column];\n                state[row-1][column] = 0;\n                break;\n            case DOWN:\n                state[row][column] = state[row+1][column];\n                state[row+1][column] = 0;\n                break;\n            case LEFT:\n                state[row][column] = state[row][column-1];\n                state[row][column-1] = 0;\n                break;\n            case RIGHT:\n                state[row][column] = state[row][column+1];\n                state[row][column+1] = 0;\n                break;\n        }\n//        printMatrix(state);\n        return state;\n    }\n\n//    public void printMatrix(int[][] matrix) {\n//        System.out.println(\"------------\");\n//        for(int i=0;i<matrix.length;i++) {\n//            for(int j=0;j<matrix.length;j++) {\n//                System.out.print(matrix[i][j] + \" \");\n//            }\n//            System.out.println();\n//        }\n//    }\n\n    /**\n     * ?±??§£??????\n     * @param state ????????¶???\n     * @param blank_row ??????????????????\n     * @param blank_column ??????????????????\n     * @param dep ????????±???\n     * @param d ???????¬??§???¨?????????\n     * @param h ????????¶?????°????????°\n     * @return\n     */\n    public boolean solve(int[][] state,int blank_row,int blank_column,\n                         int dep,long d,long h) {\n\n        long h1;\n\n        //???????????????????????????????????????????????????????????¨???????¢?????§£\n        boolean isSolved = true;\n        for(int i=0;i<SIZE;i++) {\n            for(int j=0;j<SIZE;j++) {\n                if(state[i][j] != tState[i][j]) {\n                    isSolved = false;\n                }\n            }\n        }\n        if(isSolved) {\n            return true;\n        }\n\n        if(dep == ans) {\n            return false;\n        }\n\n        //??¨?????¨???\"??????\"?§???¨??????????????????\n        int blank_row1 = blank_row;\n        int blank_column1  = blank_column;\n        int[][] state2 = new int[SIZE][SIZE];\n\n        for(int direction=0;direction<4;direction++) {\n            for(int i=0;i<state.length;i++) {\n                for(int j=0;j<state.length;j++) {\n                    state2[i][j] = state[i][j];\n                }\n            }\n\n            //??¬??°?§???¨?????????????¬??§???¨??????????\\????????????????????§????????????¨???\n            if(direction != d && (d%2 == direction%2)) {\n                continue;\n            }\n\n            if(direction == UP) {\n                blank_row1 = blank_row + up[0];\n                blank_column1 = blank_column + up[1];\n            } else if(direction == DOWN) {\n                blank_row1 = blank_row + down[0];\n                blank_column1 = blank_column + down[1];\n            } else if(direction == LEFT) {\n                blank_row1 = blank_row + left[0];\n                blank_column1 = blank_column + left[1];\n            } else {\n                blank_row1 = blank_row + right[0];\n                blank_column1 = blank_column + right[1];\n            }\n\n            //???????£???\\\n            if(blank_column1 < 0 || blank_column1 == SIZE\n                    || blank_row1 < 0 || blank_row1 == SIZE) {\n                continue ;\n            }\n\n            //?????¢??????????????????????§???¨????????????????????????\n            state2[blank_row][blank_column] = state2[blank_row1][blank_column1];\n            state2[blank_row1][blank_column1] = 0;\n\n            //??\\???????????????????????£??¨???????????????\n            if(direction == DOWN && blank_row1\n                    > targetPoints[state[blank_row1][blank_column1]][0]) {\n                h1 = h - 1;\n            } else if(direction == UP && blank_row1\n                    < targetPoints[state[blank_row1][blank_column1]][0]){\n                h1 = h - 1;\n            } else if(direction == RIGHT && blank_column1\n                    > targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else if(direction == LEFT && blank_column1\n                    < targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else {\n                //????§???????????????¨????????????????§???¨????????????????????°????????°????????§\n                h1 = h + 1;\n            }\n\n            if(h1+dep+1>ans) { //??????\n                continue;\n            }\n\n            moves[dep] = direction;\n\n            //?????£??±????±??§£\n            if(solve(state2, blank_row1, blank_column1, dep+1, direction, h1)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * ?????°??°????????°???\n     */\n    public int getHeuristic(int[][] state) {\n        int heuristic = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] != 0) {\n                    heuristic = heuristic +\n                            Math.abs(targetPoints[state[i][j]][0] - i)\n                            + Math.abs(targetPoints[state[i][j]][1] - j);\n\n                }\n            }\n        }\n        return heuristic;\n    }\n\n    /**\n     * ??????????¢????\"???????????????\"\n     * @param state\n     */\n    private int getInversions(int[][] state) {\n        int inversion = 0;\n        int temp = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                int index = i* state.length + j + 1;\n                while(index < (state.length * state.length)) {\n                    if(state[index/state.length][index%state.length] != 0\n                            && state[index/state.length]\n                            [index%state.length] < state[i][j]) {\n                        temp ++;\n                    }\n                    index ++;\n                }\n                inversion = temp + inversion;\n                temp = 0;\n            }\n        }\n        return inversion;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n//        long startTime = System.currentTimeMillis();\n        Astar test = new Astar(startStatus);\n        test.run();\n//        System.out.println(System.currentTimeMillis()-startTime);\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (1000, nodeOpenListComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (1000,nodeOpenListComparator);\n    public Astar(int[][] startStatus)\n    {\n        this.startStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n//        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenOrCloseIn(childNode,open)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n//                            iterNode.fvalue = childNode.fvalue;\n                        }\n                    }\n                }\n            }\n            else if(isOpenOrCloseIn(childNode,close)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n//                            iterNode.fvalue = childNode.fvalue;\n                            iter.remove();\n                            open.add(childNode);\n                        }\n                    }\n                }\n            }\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenOrCloseIn(Node newNode, PriorityQueue<Node> List)\n    {\n        Iterator<Node> iter = List.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.gvalue+x.hvalue - y.gvalue-y.hvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n//    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int time = 0;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new\n\t\t// File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\ALDS1_6_A-in9.txt\"));\n\n\t\tHS hs = new HS();\n\n\t\tfor (int y = 0; y < 3; y++)\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\ths.SetIni(x, y, scan.nextInt());\n\n\t\tSystem.out.println(hs.solve());\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass HS {\n\tclass Bd {\n\t\tbyte[][] pn = new byte[3][3];\n\t\tint oper = 0;\n\t\tint diff = 0;\n\n\t\tpublic int getKey() {\n\t\t\tint key = 0;\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++) {\n\t\t\t\t\tkey *= 10;\n\t\t\t\t\tkey += pn[x][y];\n\t\t\t\t}\n\t\t\treturn key;\n\t\t}\n\n\t\tpublic int eval() {\n\t\t\tint ret = 0;\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++) {\n\t\t\t\t\tint p = pn[x][y];\n\t\t\t\t\tif (p != 0)\n\t\t\t\t\t\tret += Math.abs(x - gx[p]) + Math.abs(y - gy[p]);\n\t\t\t\t}\n\t\t\tdiff = ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic void copy(Bd b) {\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\t\t\tpn[x][y] = b.pn[x][y];\n\t\t\tdiff = b.diff;\n\t\t\toper = b.oper;\n\t\t}\n\n\t\tprivate boolean up() {\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 2; y++)\n\t\t\t\t\tif (pn[x][y] == 0) {\n\t\t\t\t\t\tpn[x][y] = pn[x][y + 1];\n\t\t\t\t\t\tpn[x][y + 1] = 0;\n\t\t\t\t\t\toper++;\n\t\t\t\t\t\teval();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate boolean down() {\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 1; y < 3; y++)\n\t\t\t\t\tif (pn[x][y] == 0) {\n\t\t\t\t\t\tpn[x][y] = pn[x][y - 1];\n\t\t\t\t\t\tpn[x][y - 1] = 0;\n\t\t\t\t\t\toper++;\n\t\t\t\t\t\teval();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate boolean right() {\n\t\t\tfor (int x = 1; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\t\t\tif (pn[x][y] == 0) {\n\t\t\t\t\t\tpn[x][y] = pn[x - 1][y];\n\t\t\t\t\t\tpn[x - 1][y] = 0;\n\t\t\t\t\t\toper++;\n\t\t\t\t\t\teval();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate boolean left() {\n\t\t\tfor (int x = 0; x < 2; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\t\t\tif (pn[x][y] == 0) {\n\t\t\t\t\t\tpn[x][y] = pn[x + 1][y];\n\t\t\t\t\t\tpn[x + 1][y] = 0;\n\t\t\t\t\t\toper++;\n\t\t\t\t\t\teval();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic boolean move(int op) {\n\t\t\tswitch (op) {\n\t\t\tcase (0):\n\t\t\t\treturn up();\n\t\t\tcase (1):\n\t\t\t\treturn down();\n\t\t\tcase (2):\n\t\t\t\treturn right();\n\t\t\tcase (3):\n\t\t\t\treturn left();\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic boolean isSame(Bd b) {\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\t\t\tif (b.pn[x][y] != pn[x][y])\n\t\t\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate Bd bd = new Bd();\n\tprivate int[] gx = { 2, 0, 1, 2, 0, 1, 2, 0, 1 };\n\tprivate int[] gy = { 2, 0, 0, 0, 1, 1, 1, 2, 2 };\n\t// private ArrayList<Bd> hist = new ArrayList<Bd>();\n\tprivate Map<Integer, Integer> hist = new HashMap<>();\n\tprivate PriorityQueue<Bd> pqueue = new PriorityQueue<Bd>(3, new Qcomparator());\n\n\tclass Qcomparator implements Comparator<Bd> {\n\t\t@Override\n\t\tpublic int compare(Bd b1, Bd b2) {\n\t\t\tif (b1.diff + b1.oper > b2.diff + b2.oper)\n\t\t\t\treturn 1;\n\t\t\telse if (b1.diff + b1.oper == b2.diff + b2.oper)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tpublic void SetIni(int x, int y, int a) {\n\t\tbd.pn[x][y] = (byte) a;\n\t}\n\n\tpublic int solve() {\n\t\tBd b = new Bd();\n\t\tb.copy(bd);\n\t\tb.eval();\n\t\tpqueue.add(b);\n\t\thist.put(b.getKey(), 0);\n\t\treturn search();\n\t}\n\n\tprivate int search() {\n\t\twhile (true) {\n\t\t\tBd b = pqueue.poll();\n\t\t\tif (b == null)\n\t\t\t\treturn -1;\n\n\t\t\t// printBd(b);\n\n\t\t\tif (b.diff == 0)\n\t\t\t\treturn b.oper;\n\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tBd nb = new Bd();\n\t\t\t\tnb.copy(b);\n\t\t\t\tif (nb.move(i))\n\t\t\t\t\taddQueue(nb);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean addQueue(Bd b) {\n\t\tint k = b.getKey();\n\t\tif (hist.containsKey(k)) {\n\t\t\tint oper = hist.get(k);\n\t\t\tif (oper > b.oper) {\n\t\t\t\thist.put(k, b.oper);\n\t\t\t\tpqueue.add(b);\n\t\t\t\treturn true;\n\t\t\t} else\n\t\t\t\treturn false;\n\t\t}\n\t\thist.put(k, b.oper);\n\t\tpqueue.add(b);\n\t\treturn true;\n\t}\n\n\tprivate void printBd(Bd b) {\n\t\tSystem.out.println(\"----------------\");\n\t\tfor (int y = 0; y < 3; y++)\n\t\t\tSystem.out.println(\"- \" + b.pn[0][y] + \" \" + b.pn[1][y] + \" \" + b.pn[2][y] + \" -\");\n\t\tSystem.out.println(\"------- diff \" + b.diff + \" oper \" + b.oper + \" queue \" + pqueue.size());\n\t\tif (pqueue.size() > 100000)\n\t\t\tSystem.exit(0);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint[] input = new int[9];\n\t\tString[] first = s.nextLine().split(\" \");\n\t\tinput[0] = Integer.parseInt(first[0]);\n\t\tinput[1] = Integer.parseInt(first[1]);\n\t\tinput[2] = Integer.parseInt(first[2]);\n\n\t\tString[] second = s.nextLine().split(\" \");\n\t\tinput[3] = Integer.parseInt(second[0]);\n\t\tinput[4] = Integer.parseInt(second[1]);\n\t\tinput[5] = Integer.parseInt(second[2]);\n\n\t\tString[] three = s.nextLine().split(\" \");\n\t\tinput[6] = Integer.parseInt(three[0]);\n\t\tinput[7] = Integer.parseInt(three[1]);\n\t\tinput[8] = Integer.parseInt(three[2]);\n\n\t\tSystem.out.println(solve(input));\n\t}\n\n\tpublic static int solve(int[] input) {\n\t\tint cnt = 0;\n\t\tLinkedList<int[]> queue = new LinkedList<int[]>();\n\t\tLinkedList<Integer> cntQueue = new LinkedList<Integer>();\n\t\tHashMap<Integer, Boolean> map = new HashMap<Integer, Boolean>();\n\t\tqueue.offer(input);\n\t\tcntQueue.offer(0);\n\n\t\twhile(! queue.isEmpty()) {\n\t\t\tint[] ban = queue.poll();\n\t\t\tcnt = cntQueue.poll();\n\t\t\t//??????\n\t\t\tif(check(ban))\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tint zeroIndex = 0;\n\t\t\t\tfor(int i=0 ; i<ban.length ; i++) {\n\t\t\t\t\tif(ban[i] == 0)\n\t\t\t\t\t\tzeroIndex = i;\n\t\t\t\t}\n\n\t\t\t\tswitch (zeroIndex) {\n\t\t\t\t//????????????????????´???\n\t\t\t\tcase 0:\n\t\t\t\t\tint[] copyArray = ban.clone();\n\t\t\t\t\tcopyArray[0] = copyArray[1];\n\t\t\t\t\tcopyArray[1] = 0;\n\t\t\t\t\tint hash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[0] = copyArray[3];\n\t\t\t\t\tcopyArray[3] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\t//??????????????????????????´???\n\t\t\t\tcase 1:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[1] = copyArray[0];\n\t\t\t\t\tcopyArray[0] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[1] = copyArray[4];\n\t\t\t\t\tcopyArray[4] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[1] = copyArray[2];\n\t\t\t\t\tcopyArray[2] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t//????????????????????´???\n\t\t\t\tcase 2:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[2] = copyArray[1];\n\t\t\t\t\tcopyArray[1] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[2] = copyArray[5];\n\t\t\t\t\tcopyArray[5] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\t//?????????????????´???\n\t\t\t\tcase 3:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[3] = copyArray[0];\n\t\t\t\t\tcopyArray[0] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[3] = copyArray[4];\n\t\t\t\t\tcopyArray[4] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[3] = copyArray[6];\n\t\t\t\t\tcopyArray[6] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t//???????????????????????´???\n\t\t\t\tcase 4:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[4] = copyArray[1];\n\t\t\t\t\tcopyArray[1] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[4] = copyArray[3];\n\t\t\t\t\tcopyArray[3] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[4] = copyArray[5];\n\t\t\t\t\tcopyArray[5] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[4] = copyArray[7];\n\t\t\t\t\tcopyArray[7] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t//?????????????????´???\n\t\t\t\tcase 5:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[5] = copyArray[2];\n\t\t\t\t\tcopyArray[2] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[5] = copyArray[4];\n\t\t\t\t\tcopyArray[4] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[5] = copyArray[8];\n\t\t\t\t\tcopyArray[8] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t//????????????????????´???\n\t\t\t\tcase 6:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[6] = copyArray[3];\n\t\t\t\t\tcopyArray[3] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[6] = copyArray[7];\n\t\t\t\t\tcopyArray[7] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t//??????????????????????????´???\n\t\t\t\tcase 7:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[7] = copyArray[6];\n\t\t\t\t\tcopyArray[6] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[7] = copyArray[4];\n\t\t\t\t\tcopyArray[4] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[7] = copyArray[8];\n\t\t\t\t\tcopyArray[8] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\t//????????????????????´???\n\t\t\t\tcase 8:\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[8] = copyArray[5];\n\t\t\t\t\tcopyArray[5] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyArray = ban.clone();\n\t\t\t\t\tcopyArray[8] = copyArray[7];\n\t\t\t\t\tcopyArray[7] = 0;\n\t\t\t\t\thash = hash(copyArray);\n\t\t\t\t\tif(!map.containsKey(hash)) {\n\t\t\t\t\t\tqueue.offer(copyArray);\n\t\t\t\t\t\tcntQueue.offer(cnt+1);\n\t\t\t\t\t\tmap.put(hash, true);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tstatic int[] value = {8400, 1999, 129, 67222, 281, 2, 832, 8, 21};\n\tpublic static int hash(int[] ban) {\n\t\tint total = 1;\n\t\tfor(int i=0 ; i<ban.length ; i++) {\n\t\t\ttotal = 31*total + ban[i];\n\t\t}\n\t\treturn total;\n\t}\n\n\n\n\tpublic static boolean check(int[] ban) {\n\t\tfor(int i=0 ; i<ban.length ; i++) {\n\t\t\tif(i!=8 && ban[i]!=(i+1))\n\t\t\t\treturn false;\n\t\t\tif(i==8 && ban[i]!=0)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\n/**\n * Created by huzhejie on 2016/10/10.\n * dijkstra algorithm for single source shortest path\n */\npublic class Main {\n    /**\n     * the main execution part of dijkstra algorithm\n     * @param source source vertex\n     */\n    @SuppressWarnings(\"unchecked\")\n    private static void dijkstra(Vertex source){\n        source.minDistance = 0;\n        PriorityQueue<Vertex> queue = new PriorityQueue<Vertex>();\n        queue.add(source);\n        while(!queue.isEmpty()){\n            Vertex v = queue.poll();\n            for(Edge edge:v.nighbors){\n                int newDist = v.minDistance +edge.weight;\n                /*\n                make a comparision with new distance\n                 */\n                if(edge.target.minDistance>newDist){\n                    /*\n                    change the value of minDistance of the target vertex of the directed edge\n                     */\n                    queue.remove(edge.target);\n                    edge.target.minDistance = newDist;\n                    queue.add(edge.target);\n                }\n            }\n        }\n    }\n\n    public static void main(String args[]){\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int l = 1;\n        String str;\n        /*\n        read the data and make the graph\n         */\n        try {\n            str = br.readLine();\n            Graph g = new Graph(Integer.parseInt(str.split(\" \")[0]));\n            int source  = Integer.parseInt(str.split(\" \")[2]);\n            int edge = Integer.parseInt(str.split(\" \")[1]);\n            while ((str = br.readLine()) != null&&l<=edge){\n                String record[] = str.split(\" \");\n                g.addEdge(Integer.parseInt(record[0]),Integer.parseInt(record[1]),Integer.parseInt(record[2]));\n                l++;\n            }\n            br.close();\n        /*\n        execute dijkstra algorithm\n         */\n            dijkstra(g.vertices.get(source));\n        /*\n        output the result\n        */\n            for(Vertex v:g.vertices.values()){\n                if(v.minDistance == Integer.MAX_VALUE)\n                    System.out.println(\"INF\");\n                else\n                    System.out.println(v.minDistance);\n            }\n        }catch (IOException e){\n            e.printStackTrace();\n        }\n    }\n\n}\nclass Edge{\n    /*\n    the target vertex of the edge\n     */\n    public final Vertex target;\n    /*\n    the weight of the edge\n     */\n    public final int weight;\n\n    public Edge(Vertex target,int weight){\n        this.target = target;\n        this.weight = weight;\n    }\n}\nclass Graph{\n    /*\n    the set of the vertices of the graph\n     */\n    Map<Integer,Vertex> vertices;\n    public Graph(int vertexNumber){\n        vertices = new LinkedHashMap<Integer, Vertex>();\n        for(int i = 0;i<vertexNumber;i++){\n            vertices.put(i,new Vertex(i));\n        }\n    }\n\n    /**\n     * add an edge into the graph\n     * @param source the start vertex of the edge\n     * @param target the target vertex of the edge\n     * @param weight the weight of the edge\n     */\n    public void addEdge(int source,int target,int weight){\n        Vertex v = vertices.get(source);\n        Edge edge = new Edge(vertices.get(target),weight);\n        v.nighbors.add(edge);\n    }\n}\n@SuppressWarnings(\"unchecked\")\nclass Vertex implements Comparable<Vertex>{\n    /*\n    the id of vertex\n     */\n    int id;\n    /*\n    minimal distance from the source to this vertex\n     */\n    int minDistance = Integer.MAX_VALUE;\n    /*\n    stores edges whose start vertex's id equals to this vertex's id\n     */\n    ArrayList<Edge> nighbors;\n\n    public Vertex(int id){\n        this.id = id;\n        this.nighbors = new ArrayList<Edge>();\n    }\n    public int compareTo(Vertex o) {\n        return Integer.compare(minDistance,o.minDistance);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n//    public NodeCloseListComparator nodeCloseListComparator = new NodeCloseListComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (1000, nodeOpenListComparator);\n    public List<Node>  close =new ArrayList<Node> ();\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        //????????\\????????????????????¨???????????°?????????????????°???g??? ???????°??????°??¨???g????????????????????????\n        //???????????????????????????????????¢?????°\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenIn(childNode,open));\n            else if(isCloseIn(childNode,close));\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenIn(Node newNode, PriorityQueue<Node> openList)\n    {\n        Iterator<Node> iter = openList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                if(newNode.gvalue < iterNode.gvalue)\n                {\n                    iterNode.parent = newNode.parent;\n                    iterNode.gvalue = newNode.gvalue;\n                    iterNode.fvalue = newNode.fvalue;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean isCloseIn(Node newNode, List<Node> closeList){\n        Iterator<Node> iter = closeList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                if(newNode.gvalue < iterNode.gvalue)\n                {\n                    iterNode.parent = newNode.parent;\n                    iterNode.gvalue = newNode.gvalue;\n                    iterNode.fvalue = newNode.fvalue;\n                    iter.remove();\n                    open.add(newNode);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\n@SuppressWarnings(\"unchecked\")\nclass NodeCloseListComparator implements  Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.gvalue-y.gvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "package sample;\n\nimport java.util.Scanner;\n\n/**\n * IDA*?±??§£15puzzle????¢?\n * IDA*??´??????IDDFS???A*???????????¶???IDDFS??§??¶????±??§£????¨??????????????????????A*???????????????\"?????????\"????´¢???\n * IDA*?????\\????§£????????£??±??????A*???????????¶????????????\"??±???\"?????????????¢?????§£???\"????????????\"???\n * ???\"????????????\"???????????£?¢????????£???????????????¨\"????????????\"??????????????°???????§£?????????????????????????°±??§????????£???\n * ?????????A*???????????????????????????????????¨?????±????????¨???IDDFS????????\\???IDA*?????±?????????????´¢?????????????????????????????¨???\n * @author wly\n * @date 2013-12-20\n *\n */\npublic class Main {\n\n    //????????£??¨????????????????????????????§???¨?????????????????°\n    private int[] up = {-1,0};\n    private int[] down = {1,0};\n    private int[] left = {0,-1};\n    private int[] right = {0,1};\n\n    /**??¨????????????UP???DOWN???LEFT???RIGHT??????????????????????????????????????¢??£???????????¨\n     * ((dPrev != dCurr) && (dPrev%2 == dCurr%2))\n     * ??\\???????????????????§???¨??????????????????\n     */\n    private final int UP = 0;\n    private final int DOWN = 2;\n    private final int LEFT = 1;\n    private final int RIGHT = 3;\n\n    private int SIZE;\n\n    //?????????????????????\n    private int[][] targetPoints;\n\n    //??¨?????°????§???¨??\\???????????¨0,1,2,3,???????????????????????????\n    private static int[] moves = new int[100000];\n\n    private static long ans = 0;; //???????????£???\"????????£???\"\n\n    //????????¶???\n    private static int[][] tState = {\n            {1 ,2 ,3  } ,\n            {4 ,5 ,6  } ,\n            {7 ,8, 0  }\n\n    };\n\n    private static int[][] sState;\n\n\n    private static int blank_row,blank_column;\n\n    public Main(int[][] state) {\n        SIZE = state.length;\n        targetPoints = new int[SIZE * SIZE][2];\n\n        this.sState = state;\n        //?????°????????????\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] == 0) {\n                    blank_row = i;\n                    blank_column = j;\n                    break;\n                }\n            }\n        }\n\n        //?????°?????????????????°???\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state.length;j++) {\n                targetPoints[tState[i][j]][0] = i; //?????????\n\n                targetPoints[tState[i][j]][1] = j; //?????????\n            }\n        }\n    }\n\n    /**\n     * ??¨???????¢????????§£??§\n     * @param state ??¶???\n     */\n    private boolean canSolve(int[][] state) {\n        if(state.length % 2 == 1) { //????¢???????????\\???°\n            return (getInversions(state) % 2 == 0);\n        } else { //????¢????????????¶??°\n            if((state.length - blank_row) % 2 == 1) { //??????????????°,?????????????\\???°???\n                return (getInversions(state) % 2 == 0);\n            } else { //??????????????°,??????????????¶??°???\n                return (getInversions(state) % 2 == 1);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int step = 0;\n        int[][] sState=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            sState[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            sState[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            sState[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n\n        Main idaAlgorithm = new Main(sState);\n//            System.out.println(\"--????¢?????§£???????§??±??§£--\");\n            //??\\??????????????????????§?????°???£?????°\n            int j = idaAlgorithm.getHeuristic(sState);\n//            System.out.println(\"????§?manhattan??????:\" + j);\n            int i = -1;//?????????????§???¨??????\n\n//            long time = System.currentTimeMillis();\n            //?????£?????±\"????°???£?????°\"\n            for(ans=j;;ans++) {\n                if(idaAlgorithm.solve(sState\n                        ,blank_row,blank_column,0,i,j)) {\n                    break;\n                }\n            }\n//            System.out.println(\"?±??§£??¨??¶:\"+(System.currentTimeMillis() - time));\n\n//            idaAlgorithm.printMatrix(sState);\n            int[][] matrix = idaAlgorithm.move(sState,moves[0]);\n            step ++;\n            for(int k=1;k<ans;k++) {\n                matrix = idaAlgorithm.move(matrix, moves[k]);\n                step ++;\n            }\n            System.out.println(step);\n    }\n\n    public int[][] move(int[][]state,int direction) {\n        int row = 0;\n        int column = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state.length;j++) {\n                if(state[i][j] == 0) {\n                    row = i;\n                    column = j;\n                }\n            }\n        }\n        switch(direction) {\n            case UP:\n                state[row][column] = state[row-1][column];\n                state[row-1][column] = 0;\n                break;\n            case DOWN:\n                state[row][column] = state[row+1][column];\n                state[row+1][column] = 0;\n                break;\n            case LEFT:\n                state[row][column] = state[row][column-1];\n                state[row][column-1] = 0;\n                break;\n            case RIGHT:\n                state[row][column] = state[row][column+1];\n                state[row][column+1] = 0;\n                break;\n        }\n//        printMatrix(state);\n        return state;\n    }\n\n//    public void printMatrix(int[][] matrix) {\n//        System.out.println(\"------------\");\n//        for(int i=0;i<matrix.length;i++) {\n//            for(int j=0;j<matrix.length;j++) {\n//                System.out.print(matrix[i][j] + \" \");\n//            }\n//            System.out.println();\n//        }\n//    }\n\n    /**\n     * ?±??§£??????\n     * @param state ????????¶???\n     * @param blank_row ??????????????????\n     * @param blank_column ??????????????????\n     * @param dep ????????±???\n     * @param d ???????¬??§???¨?????????\n     * @param h ????????¶?????°????????°\n     * @return\n     */\n    public boolean solve(int[][] state,int blank_row,int blank_column,\n                         int dep,long d,long h) {\n\n        long h1;\n\n        //???????????????????????????????????????????????????????????¨???????¢?????§£\n        boolean isSolved = true;\n        for(int i=0;i<SIZE;i++) {\n            for(int j=0;j<SIZE;j++) {\n                if(state[i][j] != tState[i][j]) {\n                    isSolved = false;\n                }\n            }\n        }\n        if(isSolved) {\n            return true;\n        }\n\n        if(dep == ans) {\n            return false;\n        }\n\n        //??¨?????¨???\"??????\"?§???¨??????????????????\n        int blank_row1 = blank_row;\n        int blank_column1  = blank_column;\n        int[][] state2 = new int[SIZE][SIZE];\n\n        for(int direction=0;direction<4;direction++) {\n            for(int i=0;i<state.length;i++) {\n                for(int j=0;j<state.length;j++) {\n                    state2[i][j] = state[i][j];\n                }\n            }\n\n            //??¬??°?§???¨?????????????¬??§???¨??????????\\????????????????????§????????????¨???\n            if(direction != d && (d%2 == direction%2)) {\n                continue;\n            }\n\n            if(direction == UP) {\n                blank_row1 = blank_row + up[0];\n                blank_column1 = blank_column + up[1];\n            } else if(direction == DOWN) {\n                blank_row1 = blank_row + down[0];\n                blank_column1 = blank_column + down[1];\n            } else if(direction == LEFT) {\n                blank_row1 = blank_row + left[0];\n                blank_column1 = blank_column + left[1];\n            } else {\n                blank_row1 = blank_row + right[0];\n                blank_column1 = blank_column + right[1];\n            }\n\n            //???????£???\\\n            if(blank_column1 < 0 || blank_column1 == SIZE\n                    || blank_row1 < 0 || blank_row1 == SIZE) {\n                continue ;\n            }\n\n            //?????¢??????????????????????§???¨????????????????????????\n            state2[blank_row][blank_column] = state2[blank_row1][blank_column1];\n            state2[blank_row1][blank_column1] = 0;\n\n            //??\\???????????????????????£??¨???????????????\n            if(direction == DOWN && blank_row1\n                    > targetPoints[state[blank_row1][blank_column1]][0]) {\n                h1 = h - 1;\n            } else if(direction == UP && blank_row1\n                    < targetPoints[state[blank_row1][blank_column1]][0]){\n                h1 = h - 1;\n            } else if(direction == RIGHT && blank_column1\n                    > targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else if(direction == LEFT && blank_column1\n                    < targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else {\n                //????§???????????????¨????????????????§???¨????????????????????°????????°????????§\n                h1 = h + 1;\n            }\n\n            if(h1+dep+1>ans) { //??????\n                continue;\n            }\n\n            moves[dep] = direction;\n\n            //?????£??±????±??§£\n            if(solve(state2, blank_row1, blank_column1, dep+1, direction, h1)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * ?????°??°????????°???\n     */\n    public int getHeuristic(int[][] state) {\n        int heuristic = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] != 0) {\n                    heuristic = heuristic +\n                            Math.abs(targetPoints[state[i][j]][0] - i)\n                            + Math.abs(targetPoints[state[i][j]][1] - j);\n\n                }\n            }\n        }\n        return heuristic;\n    }\n\n    /**\n     * ??????????¢????\"???????????????\"\n     * @param state\n     */\n    private int getInversions(int[][] state) {\n        int inversion = 0;\n        int temp = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                int index = i* state.length + j + 1;\n                while(index < (state.length * state.length)) {\n                    if(state[index/state.length][index%state.length] != 0\n                            && state[index/state.length]\n                            [index%state.length] < state[i][j]) {\n                        temp ++;\n                    }\n                    index ++;\n                }\n                inversion = temp + inversion;\n                temp = 0;\n            }\n        }\n        return inversion;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\n\nclass field{\n\tint cell[] = new int[9];\n\tint evaluation;\n\tint route[];\n\tint floor;\n\n\tfield(int cell[], int hash){\n\t\tfloor = 1;\n\t\troute = new int[1];\n\t\troute[0] = hash;\n\t\tfor(int i = 0; i < 9; i++) this.cell[i] = cell[i];\n\t\tint eva = 0;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tif(cell[i] != 0){\n\t\t\t\t//?¨???????????????¢?????????\n\t\t\t\t//i???????????????????????????\n\t\t\t\t//cell[i]???????????????????????°???\n\t\t\t\teva += Math.abs((cell[i]-1)%3 - i%3);\n\t\t\t\t//?????????????????¢?????????\n\t\t\t\teva += Math.abs((cell[i]-1)/3 - i/3);\n\t\t\t}\n\t\t}\n\t\tevaluation = eva;\n\t}\n\n\t/**/\n\n\tfield(int cell[], int route[], int hash){\n\t\tthis.floor = route.length;\n\t\tthis.route = new int[floor+1];\n\t\tSystem.arraycopy(route, 0, this.route, 0, floor);\n\t\tthis.route[floor] = hash; //hash???????´???????\n\t\tfor(int i = 0; i < 9; i++) this.cell[i] = cell[i];\n\t\tint eva = 0;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tif(cell[i] != 0){\n\t\t\t\t//?¨???????????????¢?????????\n\t\t\t\t//i???????????????????????????\n\t\t\t\t//cell[i]???????????????????????°???\n\t\t\t\teva += Math.abs((cell[i]-1)%3 - i%3);\n\t\t\t\t//?????????????????¢?????????\n\t\t\t\teva += Math.abs((cell[i]-1)/3 - i/3);\n\t\t\t}\n\t\t}\n\t\tevaluation = eva; //??¨????????????\n\t}\n\n\tpublic String toString(){\n\t\treturn new String(cell[0] + \" \" + cell[1] + \" \" + cell[2] + \"\\n\" + cell[3] + \" \" + cell[4] + \" \" + cell[5] + \"\\n\" + cell[6] + \" \" + cell[7] + \" \" + cell[8] + \"\\n\");\n\t}\n}\n\n/**/\nclass ev_list{\n\tfield elem;\n\tev_list next;\n\t\n\tev_list(){\n\t\tnext = null;\n\t\tthis.elem = null;\n\t}\n\n\tev_list(field elem){\n\t\tnext = null;\n\t\tthis.elem = elem;\n\t}\n\n\t/**/\n\tpublic void insert(ev_list node){\n\t\t//?????\\??????????????£????????¢??°??????????¬???????????????????????????§?????????\n\t\t//??????????¬???????????????????????????¨????????\\\n\t\tif(this.next == null || this.next.elem.evaluation + this.next.elem.floor < node.elem.evaluation + node.elem.floor){\n\t\t\t//?¬????????????????????????\\??????????????£????????¢??°??????????°??????????\n\t\t\t//this, this.next???node????????\\??????this, node, node.next(this.next)?????????\n\t\t\tnode.next = this.next;\n\t\t\tthis.next = node;\n\t\t}else this.next.insert(node);\n\t\t//?¬????????????????????????????????????§????????¨???????¬????????????????node????????\\??????\n\t}\n\n\t/**/\n\tpublic field pop(){\n\t\tif(this.next == null) return null;\n\t\tif(this.next.next == null){ //?¬?????¬????null??????\n\t\t\tfield temp = this.next.elem; //???????¬?????????£????????????temp???\n\t\t\tthis.next = null; //???????¬????null?????????\n\t\t\treturn temp; //???????¬??????£?????????temp?????????\n\t\t}else return this.next.pop(); //?¬?????¬????null??§????????£??????????¬????pop??????\n\t}\n}\n\n/**/\n\npublic class Main{\n\n\tstatic final int LEFT = 0;\n\tstatic final int RIGHT = 1;\n\tstatic final int UP = 2;\n\tstatic final int DOWN = 3;\n\tstatic final int factor[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320}; //1???????§????????????????????´????n?????????\n\n\t/**/\n\t//???????????\\??????????????¢??°\n\tstatic public int hashkey(int[] cell){\n\t\tint val[] = new int[9];\n\t\tSystem.arraycopy(cell, 0, val, 0, 9);\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tfor(int j = i+1; j < 9; j++){\n\t\t\t\tif(val[j] > val[i]) val[j]--;\n\t\t\t}\n\t\t}\n\t\t//val??????0??????????????????????????????????????????????????????????????\\?????¢????????°\n\t\tint hash = 0;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\thash += val[i]  * factor[8-i]; //factor????????§????????°?????????????????????????????????????????????\n\t\t}\n\t\treturn hash;\n\t}\n\n\t/**/\n\tstatic public field dehash(int key){\n\t\tint cell[] = new int[9];\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tcell[i] = key/factor[8-i]; //factor????????§????????°??????????????£????????????cell???val??¨??????\n\t\t\tkey %= factor[8-i];//factor?????????????????????key???\n\t\t}\n\t\tfor(int i = 8; i >= 0; i--){\n\t\t\tfor(int j = i+1; j < 9; j++){\n\t\t\t\tif(cell[i] <= cell[j]) cell[j] ++;\n\t\t\t}\n\t\t}\n\t\t//hash??????key??????????????¨???val???cell??????????????????????????§??????cell???????????????dehash??§???????????¨????¢????\n\t\treturn new field(cell, key);\n\t}\n\n\t/**/\n\n\t//3*3????????£????????????????§??????§????????????\n\t//move[i][LEFT]:??????????????????(0,1)\n\t//move[i][RIGHT]:??????????????????(0,1)\n\t//move[i][UP]:??????????????????(0,1)\n\t//move[i][DOWN]:??????????????????(0,1)\n\tstatic boolean move[][] = new boolean[9][4];\n\n\tpublic static void main(String[] args){\n\t\t\n\t\t//?§????????????????????¨??????¨???\n\n\t\t//?§??????§?????????????????????????????????????¨??????????\n\t\t//????????????????????????????????????\n\t\tmove[0][RIGHT]=move[1][RIGHT]=move[3][RIGHT]=move[4][RIGHT]=move[6][RIGHT]=move[7][RIGHT]=true;\n\t\tmove[2][RIGHT]=move[5][RIGHT]=move[8][RIGHT]=false;\n\n\t\t//????????????????????????????????????\n\t\tmove[1][LEFT]=move[2][LEFT]=move[4][LEFT]=move[5][LEFT]=move[7][LEFT]=move[8][LEFT]=true;\n\t\tmove[0][LEFT]=move[3][LEFT]=move[6][LEFT]=false;\n\n\t\t/**/\n\t\t//????????????????????????????????????\n\t\tmove[3][UP]=move[4][UP]=move[5][UP]=move[6][UP]=move[7][UP]=move[8][UP]=true;\n\t\tmove[0][UP]=move[1][UP]=move[2][UP]=false;\n\n\t\t//????????????????????????????????????\n\t\tmove[0][DOWN]=move[1][DOWN]=move[2][DOWN]=move[3][DOWN]=move[4][DOWN]=move[5][DOWN]=true;\n\t\tmove[6][DOWN]=move[7][DOWN]=move[8][DOWN]=false;\n\n\t\t/**/\n\t\t//????????????????¨??????¨???\n\t\t//????????????\n\t\tfield st;\n\t\tint cell[] = new int[9];\n\n\t\tScanner scan = new Scanner(System.in);\n\t\tfor(int i=0; i<9; i++)\n\t\t\tcell[i] = scan.nextInt();\n\n\t\tst = new field(cell, hashkey(cell)); //??¨????????¢?????¨?????????????????¨???????????\\??????????????£????????????????????????\n\t\t/**/\n\t\t//???????????\\????????????\n\t\tboolean visited[] = new boolean[362880];\n\t\tfor(int i=0; i<362880; i++)\n\t\t\tvisited[i] = false;\n\n\t\t//??¢?´¢??¨???\n\n\t\t//??????????????????????¨????\n\t\tev_list list = new ev_list();\n\t\tlist.insert(new ev_list(st)); //?????????????????£?????????????????\\??????\n\t\tvisited[hashkey(cell)] = true; //???????????\\????????????????????????true?????????\n\n\t\t/**/\n\t\tfield cur;\n\t\tint hash;\n\t\tint count=0;\n\t\twhile( (cur=list.pop() )!= null){\n\t\t\tcount++; //??¢?´¢?????°???1?¢???????\n\n\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\tif(cur.cell[i]==0){ //cur????????¬???????????£????????????cell[i]???0??????\n\t\t\t\t\tif(move[i][LEFT]){ //?????????????????????????????¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i-1];\n\t\t\t\t\t\tcur.cell[i-1]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell); //hashkey?????????\n\t\t\t\t\t\tif(!visited[hash]){ //hashkey????¨??????????????????????\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) )); //list????????£?????????????????\\??????\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i-1]=cur.cell[i]; //????????????\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t\t/**/\n\t\t\t\t\tif(move[i][RIGHT]){ //?????????????????????????????¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i+1];\n\t\t\t\t\t\tcur.cell[i+1]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell); //hashkey?????????\n\t\t\t\t\t\tif(!visited[hash]){ //hashkey????¨??????????????????????\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) ));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i+1]=cur.cell[i];\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(move[i][UP]){ //?????????????????????????????¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i-3];\n\t\t\t\t\t\tcur.cell[i-3]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell);\n\t\t\t\t\t\tif(!visited[hash]){\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) ));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i-3]=cur.cell[i];\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(move[i][DOWN]){ //?????????????????????????????¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i+3];\n\t\t\t\t\t\tcur.cell[i+3]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell); //hashkey?????????\n\t\t\t\t\t\tif(!visited[hash]){\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) ));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i+3]=cur.cell[i];\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/**/\n\t\t\tif(cur.evaluation==0){\n\t\t\t\tSystem.out.println(cur.route.length);\n\t\t\t\t//System.out.println(count+\"\");\n\t\t\t\t//System.out.println(\"evaluation[ \"+0+\" ]=\"+dehash(cur.route[0]).evaluation+\"\\n\"+dehash(cur.route[0]) );\n\t\t\t\t//evaluation??¨???????????????cur.route[0]?????????????????\\??????\n\t\t\t\t//for(int i=1;i<cur.route.length;i++){\n\t\t\t\t\t//System.out.println(\"???\");\n\t\t\t\t\t//System.out.println(\"evaluation[ \" +i+\" ]=\"+dehash(cur.route[i]).evaluation);\n\t\t\t\t\t//System.out.println(\"evaluation+floor[ \"+i+\" ]=\"+(dehash(cur.route[i]).evaluation+i) );\n\t\t\t\t\t//evalution??¨???????????????floor?§?????????¢\n\t\t\t\t\t//System.out.println( dehash(cur.route[i]).toString() );\n\t\t\t\t//}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n/**\n * Created by huzhejie on 2016/10/10.\n */\npublic class Main {\n    @SuppressWarnings(\"unchecked\")\n    public static void main(String args[]){\n        State initState = new State();\n        PriorityQueue<State> queue = new PriorityQueue<State>();\n        Scanner sc = new Scanner(System.in);\n        String s = null;\n        int count = 0;\n        while ((s = sc.nextLine())!=null&&count<3){\n            String str[] = s.split(\" \");\n            initState.map.put(Integer.parseInt(str[0]),new Coordinate(1,count+1));\n            initState.map.put(Integer.parseInt(str[1]),new Coordinate(2,count+1));\n            initState.map.put(Integer.parseInt(str[2]),new Coordinate(3,count+1));\n            initState.step = 0;\n            count++;\n        }\n        queue.add(initState);\n        int step = 0;\n        while(!queue.isEmpty()){\n            State state = queue.poll();\n            queue.clear();\n            Coordinate zero = state.map.get(0);\n            int bottomValue=state.getBottomNodeValue(zero);\n            int topValue = state.getTopNodeValue(zero);\n            int leftValue = state.getLeftNodeValue(zero);\n            int rightValue = state.getRightNodeValue(zero);\n            step++;\n            if(bottomValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(bottomValue).y = tempState.map.get(bottomValue).y-1;\n                tempState.map.get(0).y = tempState.map.get(0).y+1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                   queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    System.exit(0);\n                }\n            }\n            if(topValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                    tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(topValue).y = tempState.map.get(topValue).y+1;\n                tempState.map.get(0).y = tempState.map.get(0).y-1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                    queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    System.exit(0);\n                }\n            }\n            if(rightValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                    tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(rightValue).x = tempState.map.get(rightValue).x-1;\n                tempState.map.get(0).x = tempState.map.get(0).x+1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                    queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    System.exit(0);\n                }\n            }\n            if(leftValue!=-1){\n                State tempState = new State();\n                for(int i:state.map.keySet())\n                    tempState.map.put(i,state.map.get(i).clone());\n                tempState.map.get(leftValue).x = tempState.map.get(leftValue).x+1;\n                tempState.map.get(0).x = tempState.map.get(0).x-1;\n                tempState.step = step;\n                if(tempState.calculate(tempState.map)!=0)\n                    queue.add(tempState);\n                else {\n                    System.out.println(tempState.step);\n                    System.exit(0);\n                }\n            }\n        }\n    }\n\n}\n\nclass State implements Comparable<State>{\n    public HashMap<Integer,Coordinate> map;\n    public int step=0;\n    @SuppressWarnings(\"unchecked\")\n    public State(){\n        this.map = new HashMap<Integer, Coordinate>();\n    }\n   public int getRightNodeValue(Coordinate a){\n       if(a.x+1<4){\n           for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n               if (entry.getValue().x == a.x + 1 && entry.getValue().y == a.y) {\n                   return entry.getKey();\n               }\n           }\n               return -1;\n       }\n       else\n           return -1;\n   }\n    public int getLeftNodeValue(Coordinate a){\n        if(a.x-1>0){\n            for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n                if (entry.getValue().x == a.x - 1 && entry.getValue().y == a.y) {\n                    return entry.getKey();\n                }\n            }\n            return -1;\n        }\n        else\n            return -1;\n    }\n    public int getTopNodeValue(Coordinate a){\n        if(a.y-1>0){\n            for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n                if (entry.getValue().x == a.x  && entry.getValue().y == a.y-1) {\n                    return entry.getKey();\n                }\n            }\n            return -1;\n        }\n        else\n            return -1;\n    }\n    public int getBottomNodeValue(Coordinate a){\n        if(a.y+1<4){\n            for(Map.Entry<Integer,Coordinate> entry:map.entrySet()) {\n                if (entry.getValue().x == a.x&& entry.getValue().y == a.y+1) {\n                    return entry.getKey();\n                }\n            }\n            return -1;\n        }\n        else\n            return -1;\n    }\n    public int calculate(Map<Integer,Coordinate> map){\n        int sum = 0;\n        for(int key:map.keySet())\n                switch (key) {\n                    case 0: break;\n                    case 3: sum+=3-map.get(key).x+Math.abs(1-map.get(key).y);break;\n                    case 6: sum+=3-map.get(key).x+Math.abs(2-map.get(key).y);break;\n                    default: sum+=Math.abs(key%3-map.get(key).x)+Math.abs(key/3+1-map.get(key).y);break;\n                }\n        return sum;\n    }\n    @Override\n    public int compareTo(State o) {\n        return Integer.compare(calculate(map),o.calculate(o.map));\n    }\n}\nclass Coordinate implements Cloneable{\n    int x,y;\n    public Coordinate(int x,int y){\n        super();\n        this.x = x;\n        this.y = y;\n    }\n    @Override\n    public Coordinate clone(){\n        Coordinate c = null;\n        try{\n            c = (Coordinate)super.clone();\n        }catch (CloneNotSupportedException e){\n            e.printStackTrace();\n        }\n        return c;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.awt.*;\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n//        long startTime = System.currentTimeMillis();\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n//        System.out.println(System.currentTimeMillis()-startTime);\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n    public NodeCloseListComparator nodeCloseListComparator = new NodeCloseListComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (1000, nodeOpenListComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (1000,nodeCloseListComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenOrCloseIn(childNode,open)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                        }\n                    }\n                }\n            }\n            else if(isOpenOrCloseIn(childNode,close)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                            iter.remove();\n                            open.add(childNode);\n                        }\n                    }\n                }\n            }\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenOrCloseIn(Node newNode, PriorityQueue<Node> List)\n    {\n        Iterator<Node> iter = List.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\n@SuppressWarnings(\"unchecked\")\nclass NodeCloseListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.hvalue - y.hvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.HashSet;\nimport java.util.Queue;\nimport java.util.Set;\n\npublic class Main {\n\n  final byte ROW       = 3;\n  final byte MATRIX    = 9;\n  final byte DIRECTION = 4;\n  final byte[] dx = {-1, 0, 1, 0};\n  final byte[] dy = { 0,-1, 0, 1};\n  final String[] dir = {\"u\",\"l\",\"d\",\"r\"};\n\n  public static void main(String[] args) {\n    \n    new Main().run();\n  }\n\n  public void run() {\n\n    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {\n\n      Puzzule first;\n      String[] line ;\n      byte[] inPuzzle = new byte[MATRIX];\n      int posSpace = 0;\n\n      for(int i=0; i<MATRIX; ) {\n        line = br.readLine().split(\" \");\n        for(int j=0; j<ROW; j++, i++) {\n          inPuzzle[i] = (byte)Integer.parseInt(line[j]);\n          if(inPuzzle[i] == 0) {\n            inPuzzle[i] = (byte)MATRIX;\n            posSpace = i;\n          }\n        }\n      }\n\n      first = new Puzzule(inPuzzle, (byte)posSpace);\n      System.out.println( bfs(first).length() );\n    }\n    catch(IOException e) {\n      System.err.println(e);\n    }\n  }\n\n  private String bfs(Puzzule s) {\n    Queue<Puzzule> queue = new ArrayDeque<>();\n    Set<Puzzule> set = new HashSet<>();\n    Puzzule u, v;\n    queue.offer(s);\n    set.add(s);\n\n    byte sx,sy,tx,ty;\n    while(!queue.isEmpty()) {\n      u = queue.poll();\n\n      if(u.isTarget()) {\n        // System.out.println(queue.size());\n        // System.out.println(set.size());\n        return u.path;\n      }\n\n      sx = (byte)(u.space / ROW);\n      sy = (byte)(u.space % ROW);\n      for(int i=0; i<DIRECTION; i++) {\n        tx = (byte)(sx + dx[i]);\n        ty = (byte)(sy + dy[i]);\n        if(tx<0 || ty<0 || tx>=ROW || ty>=ROW)\n          continue;\n        \n        v = u.clone();\n        v.swap(u.space, tx*ROW+ty);\n        if(set.add(v)) {\n          v.path += dir[i];\n          queue.offer(v);\n        }\n      }\n    }\n\n    return \"unsolvable.\";\n  }\n\n  class Puzzule implements Cloneable {\n\n    byte[] mat;\n    byte   space;\n    String path;\n    long   state;\n\n    public Puzzule() {\n      mat = null;\n      space = 0;\n      path = \"\";\n      state = 0;\n    }\n    public Puzzule(byte[] mat, byte space) {\n      this.mat = mat;\n      this.space = space;\n      path = \"\";\n      updateState();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n      if(obj == this) return true;\n      if(obj == null) return false;\n      if(!(obj instanceof Puzzule)) return false;\n\n      Puzzule ref = (Puzzule)obj;\n\n      return this.state == ref.state ? true : false;\n    }\n    @Override\n    public int hashCode() {\n      int result = 31;\n\n      return result * 17 + Long.valueOf(state).hashCode();\n    }\n    @Override\n    public Puzzule clone() {\n      Puzzule ret = new Puzzule();\n      ret.mat   = this.mat.clone();\n      ret.space = this.space;\n      ret.path  = this.path;\n      ret.state = this.state;\n\n      return ret;\n    }\n\n    public boolean isTarget() {\n      for(int i=0; i<MATRIX; i++)\n        if(mat[i]!=(i+1)) return false;\n\n      return true;\n    }\n    public void swap(int a, int b) {\n      byte t = mat[a]; mat[a] = mat[b]; mat[b] = t;\n      space = (byte)b;\n      updateState();\n    }\n    public void updateState() {\n      state = 0;\n      for (byte var : mat) {\n        state = state * 10 + var;\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\t\n\tScanner sc = new Scanner(System.in);\n\t\n\tfinal int N = 3;\n\tint[][] board;\n\tString ans = \"123456780\";\n    int count = 0;\n    int[] dy = {1, 0, -1, 0};\n    int[] dx = {0, 1, 0, -1};\n    \n\t\n\tQueue<Pazzle> Q = new LinkedList<Pazzle>();\n    HashSet<String> H = new HashSet<String>();\n\t\n\tclass Pazzle{\n\t\tint y, x;\n\t\tint[][] board;\n\t\tPazzle(int y, int x, int[][] board){\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.board = new int[N][N];\n\t\t\tfor(int i=0; i<N; i++) { for(int j=0; j<N; j++) { this.board[i][j] = board[i][j]; } }\n\t\t}\n\t\t\n\t\tPazzle(Pazzle p){\n\t\t\tthis.y = p.y;\n\t\t\tthis.x = p.x;\n\t\t\tboard = new int[N][N];\n\t\t\tfor(int i=0; i<N; i++) { for(int j=0; j<N; j++) { board[i][j] = p.board[i][j]; } }\n\t\t}\n\t\t\n\t\tpublic String getString() {\n\t\t\tString str = \"\";\n\t\t\tfor(int i=0; i<N; i++) { for(int j=0; j<N; j++) { str += Integer.toString(board[i][j]); } }\n\t\t\treturn str;\n\t\t}\n\t\t\n\t\tpublic void swap(int ny, int nx) {\n\t\t\tint tmp = board[y][x];\n\t\t\tboard[y][x] = board[ny][nx];\n\t\t\tboard[ny][nx] = tmp;\n\t\t\ty = ny;\n\t\t\tx = nx;\n\t\t}\n\t\t\n\t\tpublic void printBoard() {\n\t\t\tfor(int i=0; i<N; i++) {\n\t\t\t\tfor(int j=0; j<N; j++) { System.out.print(board[i][j]+\" \"); }\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic void solve() {\n\t\tboard = new int[N][N];\n\t\tint y = 0, x = 0;\n\t\t\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tfor(int j=0; j<N; j++) {\n\t\t\t\tboard[i][j] = sc.nextInt();\n\t\t\t\tif(board[i][j] == 0) { y = i; x = j; }\n\t\t\t}\n\t\t}\n\t\t\n        Q.add(new Pazzle(y,x,board));\n        \n        while( !Q.isEmpty() ) {\n        \t\tint length = Q.size();\n        \t\tfor(int i=0; i<length; i++) {\n        \t\t\tPazzle p = Q.poll();\n        \t\t\tString str = p.getString();\n        \t\t\tif( str.equals(ans) ) { System.out.println(count); return; }\n        \t\t\tH.add(str);\n        \t\t\t\n        \t\t\tfor(int j=0; j<4; j++) {\n        \t\t\t\tint ny = p.y + dy[j];\n        \t\t\t\tint nx = p.x + dx[j];\n        \t\t\t\tif(ny>=0 && nx>=0 && ny<N && nx<N) {\n        \t\t\t\t\tPazzle np = new Pazzle(p);\n        \t\t\t\t\tnp.swap(ny, nx);\n        \t\t\t\t\tif( H.contains( np.getString() ) ) { continue; }\n        \t\t\t\t\tQ.add(np);\n        \t\t\t\t}\n        \t\t\t}\n        \t\t}\n        \t\tcount++;\n        }\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.solve();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate static Scanner sc = new Scanner(System.in);\n\tstatic final int PUZZLE_SIZE = 9;\n\tstatic final int PUZZLE_WIDTH = 3;\n\tstatic long[] fac = new long[PUZZLE_SIZE];\n\tstatic long GOAL_HASH;\n\n\tstatic HashMap<Long, State> hmap = new HashMap<>();\n\tstatic PriorityQueue<State> que = new PriorityQueue<>((a, b) -> (a.m+a.h) - (b.m+b.h));\t//A*algorithm\n\n\tpublic static void main(String[] args) {\n\t\tArrayList<Integer> A = new ArrayList<>();\n\t\tfor(int i=0; i<PUZZLE_SIZE; i++) {\n\t\t\tA.add((i+1)%PUZZLE_SIZE);\n\t\t}\n\t\tGOAL_HASH = getHash(A);\n\n\t\tA.clear();\n\t\tfor(int i=0; i<PUZZLE_SIZE; i++) {\n\t\t\tA.add(sc.nextInt());\n\t\t}\n\n\t\tState init = new State(A, 0);\n\t\thmap.put(init.hash, init);\n\t\tque.add(init);\n\n\t\twhile(true) {\n\t\t\tque.poll().heuristicSearch();\n\t\t}\n\t}\n\n\tstatic class State {\n\t\tArrayList<Integer> A;\n\t\tlong hash;\n\t\tint m;\t//???????????§???????°??????°\n\t\tint h;\t//?????\\??????????????£????????¢??°\n\n\t\tState(ArrayList<Integer> A, int m) {\n\t\t\tthis.A = A;\n\t\t\tthis.m = m;\n\t\t\tthis.hash = getHash(A);\n\t\t\tthis.h = calcHeuristic();\n\n\t\t\t//???????????¶\n\t\t\tif(hash == GOAL_HASH) {\n\t\t\t\tSystem.out.println(m);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t}\n\n\t\tpublic void heuristicSearch() {\n\t\t\tArrayList<Integer> Ac = new ArrayList<>(A);\n//\t\t\tSystem.out.println(hash + \" \" + m + \" \" + h);\n//\t\t\tSystem.out.println(Ac);\n\n\t\t\t//up\n\t\t\tif(Ac.indexOf(0) >= PUZZLE_WIDTH) {\n//\t\t\t\tSystem.out.println(\"up\");\n\t\t\t\tint idx_1 = Ac.indexOf(0);\n\t\t\t\tint idx_2 = Ac.indexOf(0) - PUZZLE_WIDTH;\n\t\t\t\tAc.set(idx_1, Ac.get(idx_2));\n\t\t\t\tAc.set(idx_2, 0);\n\t\t\t\tlong hash = getHash(Ac);\n\t\t\t\tif(hmap.containsKey(hash)) {\n\t\t\t\t\tState state = hmap.get(hash);\n\t\t\t\t\tif(this.m + 1 < state.m) {\n\t\t\t\t\t\tif(que.contains(state)) {\n\t\t\t\t\t\t\tque.remove(state);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstate.m = this.m + 1;\n\t\t\t\t\t\tque.add(state);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tState state = new State(Ac, m+1);\n\t\t\t\t\thmap.put(state.hash, state);\n\t\t\t\t\tque.add(state);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//down\n\t\t\tAc = new ArrayList<>(A);\n\t\t\tif(Ac.indexOf(0) < PUZZLE_SIZE - PUZZLE_WIDTH) {\n//\t\t\t\tSystem.out.println(\"down\");\n\t\t\t\tint idx_1 = Ac.indexOf(0);\n\t\t\t\tint idx_2 = Ac.indexOf(0) + PUZZLE_WIDTH;\n\t\t\t\tAc.set(idx_1, Ac.get(idx_2));\n\t\t\t\tAc.set(idx_2, 0);\n\t\t\t\tlong hash = getHash(Ac);\n\t\t\t\tif(hmap.containsKey(hash)) {\n\t\t\t\t\tState state = hmap.get(hash);\n\t\t\t\t\tif(this.m + 1 < state.m) {\n\t\t\t\t\t\tif(que.contains(state)) {\n\t\t\t\t\t\t\tque.remove(state);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstate.m = this.m + 1;\n\t\t\t\t\t\tque.add(state);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tState state = new State(Ac, m+1);\n\t\t\t\t\thmap.put(state.hash, state);\n\t\t\t\t\tque.add(state);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//left\n\t\t\tAc = new ArrayList<>(A);\n\t\t\tif(Ac.indexOf(0) % PUZZLE_WIDTH != 0) {\n//\t\t\t\tSystem.out.println(\"left\");\n\t\t\t\tint idx_1 = Ac.indexOf(0);\n\t\t\t\tint idx_2 = Ac.indexOf(0) - 1;\n\t\t\t\tAc.set(idx_1, Ac.get(idx_2));\n\t\t\t\tAc.set(idx_2, 0);\n\t\t\t\tlong hash = getHash(Ac);\n\t\t\t\tif(hmap.containsKey(hash)) {\n\t\t\t\t\tState state = hmap.get(hash);\n\t\t\t\t\tif(this.m + 1 < state.m) {\n\t\t\t\t\t\tif(que.contains(state)) {\n\t\t\t\t\t\t\tque.remove(state);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstate.m = this.m + 1;\n\t\t\t\t\t\tque.add(state);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tState state = new State(Ac, m+1);\n\t\t\t\t\thmap.put(state.hash, state);\n\t\t\t\t\tque.add(state);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//right\n\t\t\tAc = new ArrayList<>(A);\n\t\t\tif(Ac.indexOf(0) % PUZZLE_WIDTH != PUZZLE_WIDTH - 1) {\n//\t\t\t\tSystem.out.println(\"right\");\n\t\t\t\tint idx_1 = Ac.indexOf(0);\n\t\t\t\tint idx_2 = Ac.indexOf(0) + 1;\n\t\t\t\tAc.set(idx_1, Ac.get(idx_2));\n\t\t\t\tAc.set(idx_2, 0);\n\t\t\t\tlong hash = getHash(Ac);\n\t\t\t\tif(hmap.containsKey(hash)) {\n\t\t\t\t\tState state = hmap.get(hash);\n\t\t\t\t\tif(this.m + 1 < state.m) {\n\t\t\t\t\t\tif(que.contains(state)) {\n\t\t\t\t\t\t\tque.remove(state);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstate.m = this.m + 1;\n\t\t\t\t\t\tque.add(state);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tState state = new State(Ac, m+1);\n\t\t\t\t\thmap.put(state.hash, state);\n\t\t\t\t\tque.add(state);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate int calcHeuristic() {\n\t\t\tint heuristic = 0;\n\t\t\tfor(int i=0; i<PUZZLE_SIZE; i++) {\n\t\t\t\tint idx_1 = A.indexOf(i);\n\t\t\t\tint idx_2 = (i-1+PUZZLE_SIZE)%PUZZLE_SIZE;\n\t\t\t\tint d_1 = Math.abs((idx_1 % PUZZLE_WIDTH - idx_2 % PUZZLE_WIDTH));\n\t\t\t\tint d_2 = Math.abs((idx_1 / PUZZLE_WIDTH - idx_2 / PUZZLE_WIDTH));\n\t\t\t\theuristic +=  d_1 + d_2;\t//ex d=8 -> heu=2+2\n\t\t\t}\n\t\t\treturn heuristic;\n\t\t}\n\t}\n\n\tpublic static long getHash(ArrayList<Integer> A) {\n\t\tlong hash = 0;\n\t\tArrayList<Integer> set = new ArrayList<>();\n\t\tfor(int i=0; i<PUZZLE_SIZE; i++) {\n\t\t\tset.add(i);\n\t\t}\n\t\tfor(int i=PUZZLE_SIZE-1; i>=1; i--) {\n\t\t\thash += set.indexOf(A.get(i)) * factorial(i);\n\t\t\tset.remove(set.indexOf(A.get(i)));\n\t\t}\n\t\treturn hash;\n\t}\n\n\tprivate static long factorial(int k) {\n\t\tif(k == 1) {\n\t\t\treturn 1;\n\t\t} else if(fac[k] != 0) {\n\t\t\treturn fac[k];\n\t\t} else {\n\t\t\treturn k * factorial(k-1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.awt.*;\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n        long startTime = System.currentTimeMillis();\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n        System.out.println(System.currentTimeMillis()-startTime);\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n    public NodeCloseListComparator nodeCloseListComparator = new NodeCloseListComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (100, nodeOpenListComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (100,nodeCloseListComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenOrCloseIn(childNode,open)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                        }\n                    }\n                }\n            }\n            else if(isOpenOrCloseIn(childNode,close)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                            iter.remove();\n                            open.add(childNode);\n                        }\n                    }\n                }\n            }\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenOrCloseIn(Node newNode, PriorityQueue<Node> List)\n    {\n        Iterator<Node> iter = List.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\n@SuppressWarnings(\"unchecked\")\nclass NodeCloseListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.hvalue - y.hvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/12.\n */\npackage sample;\n\nimport java.util.Scanner;\n\n/**\n * IDA* for 8 or 15 puzzle\n * f(x) = h(x) +depth(g(x))\n * @author huzhejie\n *\n */\npublic class Main {\n\n    private int[] up = {-1,0};\n    private int[] down = {1,0};\n    private int[] left = {0,-1};\n    private int[] right = {0,1};\n\n    private final int UP = 0;\n    private final int DOWN = 2;\n    private final int LEFT = 1;\n    private final int RIGHT = 3;\n\n    private int SIZE;\n\n    /*\n    store the position of the each point of the target state\n     */\n    private int[][] targetPoints;\n\n    /*\n    f(x),total cost\n     */\n    private static int cost;\n\n    //target state\n    private static int[][] tState = {{1 ,2 ,3 },{4 ,5 ,6 },{7 ,8, 0}};\n\n    private static int blank_row,blank_column;\n\n    public Main(int[][] state) {\n        SIZE = state.length;\n        targetPoints = new int[SIZE * SIZE][2];\n\n        /*\n        get the position of blank point\n         */\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] == 0) {\n                    blank_row = i;\n                    blank_column = j;\n                    break;\n                }\n            }\n        }\n        /*\n        get the position(x,y) by using a two-dimensional array.\n        e.g. 2's position is (2,1),\n        targetPoints [2][0] = 2-1 =1,targetPoints[2][1]=1-1=0\n         */\n        for(int i=0;i<tState.length;i++) {\n            for(int j=0;j<tState.length;j++) {\n                targetPoints[tState[i][j]][0] = i;\n\n                targetPoints[tState[i][j]][1] = j;\n            }\n        }\n    }\n    public boolean checkState(int[][] state){\n        boolean b =true;\n        for(int i = 0;i<SIZE;i++)\n            for(int j=0;j<SIZE;j++){\n                if(!(state[i][j]==tState[i][j]))\n                    b = false;\n            }\n        return b;\n    }\n\n    public static void main(String[] args) {\n        int step = 0;\n        int[][] sState=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3&&(s=sc.nextLine())!=null){\n            sState[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            sState[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            sState[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        Main idaAlgorithm = new Main(sState);\n\n        if(idaAlgorithm.checkState(sState)){\n            System.out.println(step);\n        }\n        else{\n            int j = idaAlgorithm.getHeuristic(sState);\n            int i = -1;\n\n            for (cost = j; ; cost++) {\n                if (idaAlgorithm.solve(sState\n                        , blank_row, blank_column, 0, i, j)) {\n                    break;\n                }\n            }\n            System.out.println(cost);\n        }\n    }\n    /**\n     *\n     * @param state\n     * @param blank_row the row-coordinate of 0 in ths state\n     * @param blank_column the column-coordinate of 0 in ths state\n     * @param dep the depth of the state\n     * @param d the direction of the last move\n     * @param h the value of h(x)\n     * @return\n     */\n    public boolean solve(int[][] state,int blank_row,int blank_column,\n                         int dep,int d,int h) {\n        /*\n        the value of h(x) after moving\n         */\n        int h1;\n\n        /*\n        make a comparison with the target state\n         */\n        boolean isSolved = checkState(state);\n        if(isSolved) {\n            return true;\n        }\n\n        if(dep == cost) {\n            return false;\n        }\n\n        /*\n        the position of the blank point after moving\n         */\n        int blank_row1 ;\n        int blank_column1;\n        int[][] state2 = new int[SIZE][SIZE];\n\n        for(int direction=0;direction<4;direction++) {\n            for(int i=0;i<state.length;i++) {\n                for(int j=0;j<state.length;j++) {\n                    state2[i][j] = state[i][j];\n                }\n            }\n\n            /*\n            check whether the direction of this movement is opposite of the direction of the last move or not\n             */\n            if(direction != d && (d%2 == direction%2)) {\n                continue;\n            }\n\n            if(direction == UP) {\n                blank_row1 = blank_row + up[0];\n                blank_column1 = blank_column + up[1];\n            } else if(direction == DOWN) {\n                blank_row1 = blank_row + down[0];\n                blank_column1 = blank_column + down[1];\n            } else if(direction == LEFT) {\n                blank_row1 = blank_row + left[0];\n                blank_column1 = blank_column + left[1];\n            } else {\n                blank_row1 = blank_row + right[0];\n                blank_column1 = blank_column + right[1];\n            }\n\n            /*\n            border check\n             */\n            if(blank_column1 < 0 || blank_column1 == SIZE\n                    || blank_row1 < 0 || blank_row1 == SIZE) {\n                continue ;\n            }\n\n            /*\n            swap position\n             */\n            state2[blank_row][blank_column] = state2[blank_row1][blank_column1];\n            state2[blank_row1][blank_column1] = 0;\n\n            /*\n            calculate the h(x)\n             */\n            if(direction == DOWN && blank_row1\n                    > targetPoints[state[blank_row1][blank_column1]][0]) {\n                h1 = h - 1;\n            } else if(direction == UP && blank_row1\n                    < targetPoints[state[blank_row1][blank_column1]][0]){\n                h1 = h - 1;\n            } else if(direction == RIGHT && blank_column1\n                    > targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else if(direction == LEFT && blank_column1\n                    < targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else {\n                h1 = h + 1;\n            }\n\n            /*\n            if f(x) increases,prune\n             */\n            if(h1+dep+1> cost) {\n                continue;\n            }\n\n            /*\n            do the iteration with depth increasing\n             */\n            if(solve(state2, blank_row1, blank_column1, dep+1, direction, h1)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * get the value of h(x)\n     * @param state\n     */\n    public int getHeuristic(int[][] state) {\n        int heuristic = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] != 0) {\n                    heuristic = heuristic +\n                            Math.abs(targetPoints[state[i][j]][0] - i)\n                            + Math.abs(targetPoints[state[i][j]][1] - j);\n                }\n            }\n        }\n        return heuristic;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.awt.*;\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n//        long startTime = System.currentTimeMillis();\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n//        System.out.println(System.currentTimeMillis()-startTime);\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (1000, nodeOpenListComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (1000,nodeOpenListComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenOrCloseIn(childNode,open)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                        }\n                    }\n                }\n            }\n            else if(isOpenOrCloseIn(childNode,close)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                            iter.remove();\n                            open.add(childNode);\n                        }\n                    }\n                }\n                \n            }\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenOrCloseIn(Node newNode, PriorityQueue<Node> List)\n    {\n        Iterator<Node> iter = List.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                    return true;\n            }\n        }\n        return false;\n    }\n\n//    private boolean isCloseIn(Node newNode, PriorityQueue<Node> closeList){\n//        Iterator<Node> iter = closeList.iterator();\n//        while(iter.hasNext())\n//        {\n//            Node iterNode = iter.next();\n//            if(iterNode.equal(newNode.status))\n//            {\n//                if(newNode.gvalue < iterNode.gvalue)\n//                {\n//                    iterNode.parent = newNode.parent;\n//                    iterNode.gvalue = newNode.gvalue;\n//                    iterNode.fvalue = newNode.fvalue;\n//                    iter.remove();\n//                    open.add(newNode);\n//                    return true;\n//                }\n//            }\n//        }\n//        return false;\n//    }\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "    import java.io.*; \n    import java.util.*; \n    public class Main {\n        public static final int SIZE = 3; \n        public static final int ALL_SIZE = SIZE * SIZE; \n        public static int[] factor= { 1, 1, 2, 6, 24, 120, 720, 5040, 50320, 362880 };\n        public static int hash(int[] A){ \n            int[] A_ = new int[A.length]; \n            System.arraycopy(A, 0, A_, 0, A.length); \n            int ret = 0; \n            for(int i = 0; i < A_.length; i++){ \n                ret += A_[i] * factor[(A.length - i - 1)]; \n                for(int j = i + 1; j < A_.length; j++){ \n                    if(A_[j] >= A_[i]){ \n                        A_[j]--; \n                    } \n                } \n            } \n            return ret; \n        } \n        public static int[] unhash(int hash){ \n            int[] ret = new int[ALL_SIZE]; \n            for(int i = 0; i < ALL_SIZE; i++) { \n                ret[i] = hash / factor[ALL_SIZE - i - 1]; \n                hash -= factor[ALL_SIZE - i - 1] * ret[i]; \n            } \n            for(int i = ALL_SIZE - 1; i >= 0; i--){ \n                for(int j = i + 1; j < ALL_SIZE; j++){ \n                    if(ret[i] <= ret[j]) \n                        ret[j]++; \n                } \n            } \n            return ret; \n        } \n        public static final int GOAL = hash(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 0}); \n        public static final int MAX = hash(new int[]{8, 7, 6, 5, 4, 3, 2, 1, 0}) + 1;\n        public static void main(String[] args) throws IOException { \n            Scanner sc = new Scanner(System.in);\n            int[] visited = new int[MAX]; \n            Arrays.fill(visited, Integer.MAX_VALUE); \n            LinkedList<Integer> queue = new LinkedList<>(); \n            int[] input = new int[ALL_SIZE]; \n            for(int i = 0; i < SIZE; i++){ \n                for(int j = 0; j < SIZE; j++){ \n                    input[i * SIZE + j] = sc.nextInt(); \n                } \n            } \n            final int hash_input = hash(input); \n            queue.add(hash_input); \n            visited[hash_input] = 0; \n            while(!queue.isEmpty()){ \n                final int hashed = queue.poll(); \n                if(hashed == GOAL){ \n                    System.out.println(visited[hashed]); \n                    break; \n                } \n                final int dist = visited[hashed]; \n                int[] ret = unhash(hashed); \n                for(int i = 0; i < ALL_SIZE; i++){ \n                    if(ret[i] == 0){ \n                        if(i % 3 != 0){ \n                            int tmp = ret[i]; \n                            ret[i] = ret[i - 1]; \n                            ret[i - 1] = tmp; \n                            final int next_hash = hash(ret); \n                            if(visited[next_hash] > dist + 1){ \n                                visited[next_hash] = dist + 1; \n                                queue.add(next_hash); \n                            } \n                            tmp = ret[i]; \n                            ret[i] = ret[i - 1]; \n                            ret[i - 1] = tmp; \n                        } \n                        if(i % 3 != 2){ \n                            int tmp = ret[i]; \n                            ret[i] = ret[i + 1]; \n                            ret[i + 1] = tmp; \n                            final int next_hash = hash(ret); \n                            if(visited[next_hash] > dist + 1){ \n                                visited[next_hash] = dist + 1; \n                            queue.add(next_hash); } tmp = ret[i]; \n                            ret[i] = ret[i + 1]; \n                            ret[i + 1] = tmp; \n                        } \n                        if(i / 3 != 0){ \n                            int tmp = ret[i]; \n                            ret[i] = ret[i - SIZE]; \n                            ret[i - SIZE] = tmp; \n                            final int next_hash = hash(ret); \n                            if(visited[next_hash] > dist + 1){ \n                                visited[next_hash] = dist + 1; \n                                queue.add(next_hash); \n                            } \n                            tmp = ret[i]; \n                            ret[i] = ret[i - SIZE]; \n                            ret[i - SIZE] = tmp; \n                        } \n                        if(i / 3 != 2){ \n                            int tmp = ret[i]; \n                            ret[i] = ret[i + SIZE]; \n                            ret[i + SIZE] = tmp; \n                            final int next_hash = hash(ret); \n                            if(visited[next_hash] > dist + 1){ \n                                visited[next_hash] = dist + 1; \n                                queue.add(next_hash); \n                            } \n                            tmp = ret[i]; \n                            ret[i] = ret[i + SIZE]; \n                            ret[i + SIZE] = tmp; \n                        } \n                    } \n                } \n            } \n        } \n        public static class Scanner { \n            private BufferedReader br; \n            private StringTokenizer tok; \n            public Scanner(InputStream is) throws IOException { \n                br = new BufferedReader(new InputStreamReader(is)); \n            } \n            private void getLine() throws IOException { \n                while (!hasNext()) { \n                    tok = new StringTokenizer(br.readLine()); \n                } \n            } \n            private boolean hasNext() { \n                return tok != null && tok.hasMoreTokens(); \n            } \n            public String next() throws IOException { \n                getLine(); \n                return tok.nextToken(); \n            } \n            public int nextInt() throws IOException {\n                return Integer.parseInt(next()); \n            } \n            public long nextLong() throws IOException { \n                return Long.parseLong(next()); \n            } \n            public void close() throws IOException { \n                br.close(); \n            }\n        }\n    }\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int time = 0;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new\n\t\t// File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\ALDS1_6_A-in9.txt\"));\n\n\t\tHS hs = new HS();\n\n\t\tfor (int y = 0; y < 3; y++)\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\ths.SetIni(x, y, scan.nextInt());\n\n\t\tSystem.out.println(hs.solve());\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass HS {\n\tclass Bd {\n\t\tint[][] pn = new int[3][3];\n\t\tint oper = 0;\n\t\tint diff = 0;\n\n\t\tpublic int eval() {\n\t\t\tint ret = 0;\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++) {\n\t\t\t\t\tint p = pn[x][y];\n\t\t\t\t\tif (p != 0)\n\t\t\t\t\t\tret += Math.abs(x - gx[p]) + Math.abs(y - gy[p]);\n\t\t\t\t}\n\t\t\tdiff = ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic void copy(Bd b) {\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\t\t\tpn[x][y] = b.pn[x][y];\n\t\t\tdiff = b.diff;\n\t\t\toper = b.oper;\n\t\t}\n\n\t\tprivate boolean up() {\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 2; y++)\n\t\t\t\t\tif (pn[x][y] == 0) {\n\t\t\t\t\t\tpn[x][y] = pn[x][y + 1];\n\t\t\t\t\t\tpn[x][y + 1] = 0;\n\t\t\t\t\t\toper++;\n\t\t\t\t\t\teval();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate boolean down() {\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 1; y < 3; y++)\n\t\t\t\t\tif (pn[x][y] == 0) {\n\t\t\t\t\t\tpn[x][y] = pn[x][y - 1];\n\t\t\t\t\t\tpn[x][y - 1] = 0;\n\t\t\t\t\t\toper++;\n\t\t\t\t\t\teval();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate boolean right() {\n\t\t\tfor (int x = 1; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\t\t\tif (pn[x][y] == 0) {\n\t\t\t\t\t\tpn[x][y] = pn[x - 1][y];\n\t\t\t\t\t\tpn[x - 1][y] = 0;\n\t\t\t\t\t\toper++;\n\t\t\t\t\t\teval();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate boolean left() {\n\t\t\tfor (int x = 0; x < 2; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\t\t\tif (pn[x][y] == 0) {\n\t\t\t\t\t\tpn[x][y] = pn[x + 1][y];\n\t\t\t\t\t\tpn[x + 1][y] = 0;\n\t\t\t\t\t\toper++;\n\t\t\t\t\t\teval();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic boolean move(int op) {\n\t\t\tswitch (op) {\n\t\t\tcase (0):\n\t\t\t\treturn up();\n\t\t\tcase (1):\n\t\t\t\treturn down();\n\t\t\tcase (2):\n\t\t\t\treturn right();\n\t\t\tcase (3):\n\t\t\t\treturn left();\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic boolean isSame(Bd b) {\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\t\t\tif (b.pn[x][y] != pn[x][y])\n\t\t\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate Bd bd = new Bd();\n\tprivate int[] gx = { 2, 0, 1, 2, 0, 1, 2, 0, 1 };\n\tprivate int[] gy = { 2, 0, 0, 0, 1, 1, 1, 2, 2 };\n\tprivate ArrayList<Bd> hist = new ArrayList<Bd>();\n\tprivate PriorityQueue<Bd> pqueue = new PriorityQueue<Bd>(3, new Qcomparator());\n\n\tclass Qcomparator implements Comparator<Bd> {\n\t\t@Override\n\t\tpublic int compare(Bd b1, Bd b2) {\n\t\t\tif (b1.diff + b1.oper > b2.diff + b2.oper)\n\t\t\t\treturn 1;\n\t\t\telse if (b1.diff + b1.oper == b2.diff + b2.oper)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tpublic void SetIni(int x, int y, int a) {\n\t\tbd.pn[x][y] = a;\n\t}\n\n\tpublic int solve() {\n\t\tBd b = new Bd();\n\t\tb.copy(bd);\n\t\tb.eval();\n\t\tpqueue.add(b);\n\t\thist.add(b);\n\t\treturn search();\n\t}\n\n\tprivate int search() {\n\t\twhile (true) {\n\t\t\tBd b = pqueue.poll();\n\t\t\tif (b == null)\n\t\t\t\treturn -1;\n\n\t//\t\tprintBd(b);\n\n\t\t\tif (b.diff == 0)\n\t\t\t\treturn b.oper;\n\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tBd nb = new Bd();\n\t\t\t\tnb.copy(b);\n\t\t\t\tif (nb.move(i))\n\t\t\t\t\taddQueue(nb);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean addQueue(Bd b) {\n\t\tfor (int i = 0; i < hist.size(); i++)\n\t\t\tif (b.isSame(hist.get(i)))\n\t\t\t\tif (b.oper < hist.get(i).oper) {\n\t\t\t\t\thist.get(i).oper = b.oper;\n\t\t\t\t\tpqueue.add(b);\n\t\t\t\t\treturn true;\n\t\t\t\t} else\n\t\t\t\t\treturn false;\n\t\tpqueue.add(b);\n\t\treturn true;\n\t}\n\n\tprivate void printBd(Bd b) {\n\t\tSystem.out.println(\"----------------\");\n\t\tfor (int y = 0; y < 3; y++)\n\t\t\tSystem.out.println(\"- \" + b.pn[0][y] + \" \" + b.pn[1][y] + \" \" + b.pn[2][y] + \" -\");\n\t\tSystem.out.println(\"------- diff \" + b.diff + \" oper \" + b.oper);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\tstatic int N = 3;\n\tstatic int N2 = 9;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tPuzzle puzzle = new Puzzle();\n\t\tfor (int i = 0; i < N2; i++) {\n\t\t\tint v = scanner.nextInt();\n\t\t\tpuzzle.map[i] = v;\n\t\t\tif (v == 0) {\n\t\t\t\tpuzzle.space = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(slove(puzzle));\n\t}\n\n\tint[][] dxy = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\tprivate int slove(Puzzle in) {\n\t\tPuzzle u = new Puzzle();\n\t\tPuzzle v = new Puzzle();\n\t\tDeque<Puzzle> deque = new ArrayDeque<Puzzle>();\n\t\tSet<Puzzle> set = new HashSet<Main.Puzzle>();\n\t\tset.add(in);\n\t\tdeque.offer(in);\n\t\twhile (!deque.isEmpty()) {\n\t\t\tu = deque.poll();\n\t\t\tif (isTrue(u)) {\n\t\t\t\treturn u.count;\n\t\t\t}\n\t\t\tint y = u.space / N;\n\t\t\tint x = u.space % N;\n\t\t\tfor (int[] a : dxy) {\n\t\t\t\tint dy = y + a[0];\n\t\t\t\tint dx = x + a[1];\n\t\t\t\tif (dy < 0 || dx < 0 || N <= dy || N <= dx)\n\t\t\t\t\tcontinue;\n\t\t\t\tv = u.clone();\n\t\t\t\tswap(v, u.space, dy * N + dx);\n\t\t\t\tv.space = dy * N + dx;\n\t\t\t\tif (!set.contains(v)) {\n\t\t\t\t\tset.add(v);\n\t\t\t\t\tv.count++;\n\t\t\t\t\tdeque.offer(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tprivate boolean isTrue(Puzzle u) {\n\t\tfor (int i = 0; i < N2 - 1; i++) {\n\t\t\tif (u.map[i] != i + 1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate void swap(Puzzle v, int space, int i) {\n\t\tint t = v.map[i];\n\t\tv.map[i] = v.map[space];\n\t\tv.map[space] = t;\n\n\t}\n\tclass Puzzle implements Cloneable {\n\t\tint[] map = new int[N2];\n\t\tint space;\n\t\tint count = 0;\n\n\t\t@Override\n\t\tpublic Puzzle clone() {\n\t\t\ttry {\n\t\t\t\tPuzzle clonePuzzle = (Puzzle) super.clone();\n\t\t\t\tclonePuzzle.map = Arrays.copyOf(map, N2);\n\t\t\t\treturn clonePuzzle;\n\t\t\t} catch (CloneNotSupportedException e) {\n\t\t\t\tthrow new InternalError();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + getOuterType().hashCode();\n\t\t\tresult = prime * result + Arrays.hashCode(map);\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPuzzle other = (Puzzle) obj;\n\t\t\tif (!getOuterType().equals(other.getOuterType()))\n\t\t\t\treturn false;\n\t\t\tif (!Arrays.equals(map, other.map))\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate Main getOuterType() {\n\t\t\treturn Main.this;\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.HashMap;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in); \n\n\t\tint n = 9;\n\t\tchar[] s = new char[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ts[i] = (char)('0' + sc.nextInt());\n\t\t}\n\t\t\n\t\tString ans = \"123456780\";\n\t\tint[] d = {-3, 3, -1, 1};\n\t\t\n\t\tHashMap<String, Integer> hm = new HashMap<String, Integer>();\n\t\t\n\t\tQueue<String> q = new ArrayDeque<String>();\n\t\tq.add(toString(s));\n\t\thm.put(toString(s), 0);\n\n\t\twhile (!q.isEmpty()) {\n\t\t\tString u = q.remove();\n\t\t\tif (u.equals(ans)) {\n\t\t\t\tSystem.out.println(hm.get(u));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tStringBuffer str = new StringBuffer(u);\n\t\t\tint zero = str.indexOf(\"0\");\n\t\t\tassert (zero != -1);\n\t\t\tfor (int i = 0; i < d.length; i++) {\n\t\t\t\tif (zero + d[i] >= 0 && zero + d[i] < n && !(d[i] == -1 && (zero + d[i]) % 3 == 2) && !(d[i] == 1 && (zero + d[i]) % 3 == 0)) {\n\t\t\t\t\tstr.setCharAt(zero, str.charAt(zero + d[i]));\n\t\t\t\t\tstr.setCharAt(zero + d[i], '0');\n\t\t\t\t\tif (!hm.containsKey(str.toString())) {\n\t\t\t\t\t\tq.add(str.toString());\n\t\t\t\t\t\thm.put(str.toString(), hm.get(u) + 1);\n\t\t\t\t\t}\n\t\t\t\t\tstr.setCharAt(zero + d[i], str.charAt(zero));\n\t\t\t\t\tstr.setCharAt(zero, '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        sc.close();\n\t}\n\t\n\tprivate static String toString(char[] s) {\n\t\tString ret = \"\";\n\t\tfor (int i = 0; i < s.length; i++) {\n\t\t\tret += s[i];\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\n\nclass field{\n\tint cell[] = new int[9];\n\tint evaluation;\n\tint route[];\n\tint floor;\n\n\tfield(int cell[], int hash){\n\t\tfloor = 1;\n\t\troute = new int[1];\n\t\troute[0] = hash;\n\t\tfor(int i = 0; i < 9; i++) this.cell[i] = cell[i];\n\t\tint eva = 0;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tif(cell[i] != 0){\n\t\t\t\t//?¨???????????????¢?????????\n\t\t\t\t//i???????????????????????????\n\t\t\t\t//cell[i]???????????????????????°???\n\t\t\t\teva += Math.abs((cell[i]-1)%3 - i%3);\n\t\t\t\t//?????????????????¢?????????\n\t\t\t\teva += Math.abs((cell[i]-1)/3 - i/3);\n\t\t\t}\n\t\t}\n\t\tevaluation = eva;\n\t}\n\n\t/**/\n\n\tfield(int cell[], int route[], int hash){\n\t\tthis.floor = route.length;\n\t\tthis.route = new int[floor+1];\n\t\tSystem.arraycopy(route, 0, this.route, 0, floor);\n\t\tthis.route[floor] = hash; //hash???????´???????\n\t\tfor(int i = 0; i < 9; i++) this.cell[i] = cell[i];\n\t\tint eva = 0;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tif(cell[i] != 0){\n\t\t\t\t//?¨???????????????¢?????????\n\t\t\t\t//i???????????????????????????\n\t\t\t\t//cell[i]???????????????????????°???\n\t\t\t\teva += Math.abs((cell[i]-1)%3 - i%3);\n\t\t\t\t//?????????????????¢?????????\n\t\t\t\teva += Math.abs((cell[i]-1)/3 - i/3);\n\t\t\t}\n\t\t}\n\t\tevaluation = eva; //??¨????????????\n\t}\n\n\tpublic String toString(){\n\t\treturn new String(cell[0] + \" \" + cell[1] + \" \" + cell[2] + \"\\n\" + cell[3] + \" \" + cell[4] + \" \" + cell[5] + \"\\n\" + cell[6] + \" \" + cell[7] + \" \" + cell[8] + \"\\n\");\n\t}\n}\n\n/**/\nclass ev_list{\n\tfield elem;\n\tev_list next;\n\t\n\tev_list(){\n\t\tnext = null;\n\t\tthis.elem = null;\n\t}\n\n\tev_list(field elem){\n\t\tnext = null;\n\t\tthis.elem = elem;\n\t}\n\n\t/**/\n\tpublic void insert(ev_list node){\n\t\t//?????\\??????????????£????????¢??°??????????¬???????????????????????????§?????????\n\t\t//??????????¬???????????????????????????¨????????\\\n\t\tif(this.next == null || this.next.elem.evaluation + this.next.elem.floor < node.elem.evaluation + node.elem.floor){\n\t\t\t//?¬????????????????????????\\??????????????£????????¢??°??????????°??????????\n\t\t\t//this, this.next???node????????\\??????this, node, node.next(this.next)?????????\n\t\t\tnode.next = this.next;\n\t\t\tthis.next = node;\n\t\t}else this.next.insert(node);\n\t\t//?¬????????????????????????????????????§????????¨???????¬????????????????node????????\\??????\n\t}\n\n\t/**/\n\tpublic field pop(){\n\t\tif(this.next == null) return null;\n\t\tif(this.next.next == null){ //?¬?????¬????null??????\n\t\t\tfield temp = this.next.elem; //???????¬?????????£????????????temp???\n\t\t\tthis.next = null; //???????¬????null?????????\n\t\t\treturn temp; //???????¬??????£?????????temp?????????\n\t\t}else return this.next.pop(); //?¬?????¬????null??§????????£??????????¬????pop??????\n\t}\n}\n\n/**/\n\npublic class Main{\n\n\tstatic final int LEFT = 0;\n\tstatic final int RIGHT = 1;\n\tstatic final int UP = 2;\n\tstatic final int DOWN = 3;\n\tstatic final int factor[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320}; //1???????§????????????????????´????n?????????\n\n\t/**/\n\t//???????????\\??????????????¢??°\n\tstatic public int hashkey(int[] cell){\n\t\tint val[] = new int[9];\n\t\tSystem.arraycopy(cell, 0, val, 0, 9);\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tfor(int j = i+1; j < 9; j++){\n\t\t\t\tif(val[j] > val[i]) val[j]--;\n\t\t\t}\n\t\t}\n\t\t//val??????0??????????????????????????????????????????????????????????????\\?????¢????????°\n\t\tint hash = 0;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\thash += val[i]  * factor[8-i]; //factor????????§????????°?????????????????????????????????????????????\n\t\t}\n\t\treturn hash;\n\t}\n\n\t/**/\n\tstatic public field dehash(int key){\n\t\tint cell[] = new int[9];\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tcell[i] = key/factor[8-i]; //factor????????§????????°??????????????£????????????cell???val??¨??????\n\t\t\tkey %= factor[8-i];//factor?????????????????????key???\n\t\t}\n\t\tfor(int i = 8; i >= 0; i--){\n\t\t\tfor(int j = i+1; j < 9; j++){\n\t\t\t\tif(cell[i] <= cell[j]) cell[j] ++;\n\t\t\t}\n\t\t}\n\t\t//hash??????key??????????????¨???val???cell??????????????????????????§??????cell???????????????dehash??§???????????¨????¢????\n\t\treturn new field(cell, key);\n\t}\n\n\t/**/\n\n\t//3*3????????£????????????????§??????§????????????\n\t//move[i][LEFT]:??????????????????(0,1)\n\t//move[i][RIGHT]:??????????????????(0,1)\n\t//move[i][UP]:??????????????????(0,1)\n\t//move[i][DOWN]:??????????????????(0,1)\n\tstatic boolean move[][] = new boolean[9][4];\n\n\tpublic static void main(String[] args){\n\t\t\n\t\t//?§????????????????????¨??????¨???\n\n\t\t//?§??????§?????????????????????????????????????¨??????????\n\t\t//????????????????????????????????????\n\t\tmove[0][RIGHT]=move[1][RIGHT]=move[3][RIGHT]=move[4][RIGHT]=move[6][RIGHT]=move[7][RIGHT]=true;\n\t\tmove[2][RIGHT]=move[5][RIGHT]=move[8][RIGHT]=false;\n\n\t\t//????????????????????????????????????\n\t\tmove[1][LEFT]=move[2][LEFT]=move[4][LEFT]=move[5][LEFT]=move[7][LEFT]=move[8][LEFT]=true;\n\t\tmove[0][LEFT]=move[3][LEFT]=move[6][LEFT]=false;\n\n\t\t/**/\n\t\t//????????????????????????????????????\n\t\tmove[3][UP]=move[4][UP]=move[5][UP]=move[6][UP]=move[7][UP]=move[8][UP]=true;\n\t\tmove[0][UP]=move[1][UP]=move[2][UP]=false;\n\n\t\t//????????????????????????????????????\n\t\tmove[0][DOWN]=move[1][DOWN]=move[2][DOWN]=move[3][DOWN]=move[4][DOWN]=move[5][DOWN]=true;\n\t\tmove[6][DOWN]=move[7][DOWN]=move[8][DOWN]=false;\n\n\t\t/**/\n\t\t//????????????????¨??????¨???\n\t\t//????????????\n\t\tfield st;\n\t\tint cell[] = new int[9];\n\n\t\tScanner scan = new Scanner(System.in).useDelimiter(\"[\\\\s]+\");\n\t\tfor(int i=0;i<3;i++)\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\tcell[3*i+j] = scan.nextInt();\n\t\t//for?????°???????????§cell??\\???\n\n\t\tst = new field(cell, hashkey(cell)); //??¨????????¢?????¨?????????????????¨???????????\\??????????????£????????????????????????\n\t\t/**/\n\t\t//???????????\\????????????\n\t\tboolean visited[] = new boolean[362880];\n\t\tfor(int i=0; i<362880; i++)\n\t\t\tvisited[i] = false;\n\n\t\t//??¢?´¢??¨???\n\n\t\t//??????????????????????¨????\n\t\tev_list list = new ev_list();\n\t\tlist.insert(new ev_list(st)); //?????????????????£?????????????????\\??????\n\t\tvisited[hashkey(cell)] = true; //???????????\\????????????????????????true?????????\n\n\t\t/**/\n\t\tfield cur;\n\t\tint hash;\n\t\tint count=0;\n\t\twhile( (cur=list.pop() )!= null){\n\t\t\tcount++; //??¢?´¢?????°???1?¢???????\n\n\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\tif(cur.cell[i]==0){ //cur????????¬???????????£????????????cell[i]???0??????\n\t\t\t\t\tif(move[i][LEFT]){ //?????????????????????????????¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i-1];\n\t\t\t\t\t\tcur.cell[i-1]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell); //hashkey?????????\n\t\t\t\t\t\tif(!visited[hash]){ //hashkey????¨??????????????????????\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) )); //list????????£?????????????????\\??????\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i-1]=cur.cell[i]; //????????????\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t\t/**/\n\t\t\t\t\tif(move[i][RIGHT]){ //?????????????????????????????¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i+1];\n\t\t\t\t\t\tcur.cell[i+1]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell); //hashkey?????????\n\t\t\t\t\t\tif(!visited[hash]){ //hashkey????¨??????????????????????\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) ));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i+1]=cur.cell[i];\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(move[i][UP]){ //?????????????????????????????¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i-3];\n\t\t\t\t\t\tcur.cell[i-3]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell);\n\t\t\t\t\t\tif(!visited[hash]){\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) ));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i-3]=cur.cell[i];\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(move[i][DOWN]){ //?????????????????????????????¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i+3];\n\t\t\t\t\t\tcur.cell[i+3]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell); //hashkey?????????\n\t\t\t\t\t\tif(!visited[hash]){\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) ));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i+3]=cur.cell[i];\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/**/\n\t\t\tif(cur.evaluation==0){\n\t\t\t\tSystem.out.println(cur.route.length);\n\t\t\t\t//System.out.println(count+\"\");\n\t\t\t\t//System.out.println(\"evaluation[ \"+0+\" ]=\"+dehash(cur.route[0]).evaluation+\"\\n\"+dehash(cur.route[0]) );\n\t\t\t\t//evaluation??¨???????????????cur.route[0]?????????????????\\??????\n\t\t\t\t//for(int i=1;i<cur.route.length;i++){\n\t\t\t\t\t//System.out.println(\"???\");\n\t\t\t\t\t//System.out.println(\"evaluation[ \" +i+\" ]=\"+dehash(cur.route[i]).evaluation);\n\t\t\t\t\t//System.out.println(\"evaluation+floor[ \"+i+\" ]=\"+(dehash(cur.route[i]).evaluation+i) );\n\t\t\t\t\t//evalution??¨???????????????floor?§?????????¢\n\t\t\t\t\t//System.out.println( dehash(cur.route[i]).toString() );\n\t\t\t\t//}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeComparator nodeComparator = new NodeComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (100,nodeComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (100,nodeComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n//        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        //????????\\????????????????????¨???????????°?????????????????°???g??? ???????°??????°??¨???g????????????????????????\n        //???????????????????????????????????¢?????°\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenIn(childNode,open));\n            else if(isCloseIn(childNode,close));\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenIn(Node newNode, PriorityQueue<Node> openList)\n    {\n        Iterator<Node> iter = openList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                if(newNode.gvalue < iterNode.gvalue)\n                {\n                    iterNode.parent = newNode.parent;\n                    iterNode.gvalue = newNode.gvalue;\n//                    iterNode.fvalue = newNode.fvalue;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean isCloseIn(Node newNode, PriorityQueue<Node> closeList){\n        Iterator<Node> iter = closeList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                if(newNode.gvalue < iterNode.gvalue)\n                {\n                    iterNode.parent = newNode.parent;\n                    iterNode.gvalue = newNode.gvalue;\n//                    iterNode.fvalue = newNode.fvalue;\n                    iter.remove();\n                    open.add(newNode);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.gvalue+x.hvalue - y.gvalue-y.hvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int N = 3;\n\tstatic int N2 = 9;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tPuzzle in = new Puzzle();\n\t\tScanner scanner = new Scanner(System.in);\n\t\tfor (int i = 0; i < N2; i++) {\n\t\t\tin.f[i] = scanner.nextInt();\n\t\t\tif (in.f[i] == 0) {\n\t\t\t\tin.f[i] = N2;\n\t\t\t\tin.space = i;\n\t\t\t}\n\t\t}\n\t\tString ans = bfs(in);\n\t\tSystem.out.println(ans.length());\n\t}\n\n\tint[] dx = { -1, 0, 1, 0 };\n\tint[] dy = { 0, -1, 0, 1 };\n\tchar[] dir = { 'u', 'l', 'd', 'r' };\n\n\tprivate String bfs(Puzzle s) {\n\t\tDeque<Puzzle> Q = new ArrayDeque<Main.Puzzle>();\n\t\tMap<Puzzle, Boolean> V = new HashMap<Main.Puzzle, Boolean>();\n\t\tPuzzle u = new Puzzle();\n\t\tPuzzle v = new Puzzle();\n\t\ts.path = \"\";\n\t\tQ.push(s);\n\t\tV.put(s, true);\n\t\twhile (!Q.isEmpty()) {\n\t\t\tu = Q.poll();\n\t\t\tif (isTarget(u))\n\t\t\t\treturn u.path;\n\t\t\tint sx = u.space / N;\n\t\t\tint sy = u.space % N;\n\t\t\tfor (int r = 0; r < 4; r++) {\n\t\t\t\tint tx = sx + dx[r];\n\t\t\t\tint ty = sy + dy[r];\n\t\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\t\tcontinue;\n\t\t\t\tv = (Puzzle) u.clone();\n\t\t\t\tswap(v, u.space, tx * N + ty);\n\t\t\t\tv.space = tx * N + ty;\n\t\t\t\tif (!V.containsKey(v) || !V.get(v)) {\n\t\t\t\t\tV.put(v, true);\n\t\t\t\t\tv.path += dir[r];\n\t\t\t\t\tQ.offer(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn \"unslovable\";\n\t}\n\n\tprivate void swap(Puzzle v, int space, int i) {\n\t\tint tmp = v.f[space];\n\t\tv.f[space] = v.f[i];\n\t\tv.f[i] = tmp;\n\t}\n\n\tprivate boolean isTarget(Puzzle p) {\n\t\tfor (int i = 0; i < N2; i++) {\n\t\t\tif (p.f[i] != (i + 1))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\tclass Puzzle implements Cloneable {\n\t\tint[] f = new int[N2];\n\t\tint space;\n\t\tString path;\n\t\t\n\t\tpublic Puzzle clone() {\n\t\t\ttry {\n\t\t\t\tPuzzle clonePuzzle = (Puzzle) super.clone();\n\t\t\t\tint[] clonef = Arrays.copyOf(f, f.length);\n\t\t\t\tclonePuzzle.f = clonef;\n\t\t\t\treturn clonePuzzle;\n\t\t\t} catch (CloneNotSupportedException e) {\n\t\t\t\tthrow new InternalError(e.toString());\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + getOuterType().hashCode();\n\t\t\tresult = prime * result + Arrays.hashCode(f);\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPuzzle other = (Puzzle) obj;\n\t\t\tif (!getOuterType().equals(other.getOuterType()))\n\t\t\t\treturn false;\n\t\t\tif (!Arrays.equals(f, other.f))\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate Main getOuterType() {\n\t\t\treturn Main.this;\n\t\t}\n\t\t\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int time = 0;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new\n\t\t// File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\ALDS1_6_A-in9.txt\"));\n\n\t\tHS hs = new HS();\n\n\t\tfor (int y = 0; y < 3; y++)\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\ths.SetIni(x, y, scan.nextInt());\n\n\t\tSystem.out.println(hs.solve());\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass HS {\n\tclass Bd {\n\t\tint[][] pn = new int[3][3];\n\n\t\tpublic int eval() {\n\t\t\tint ret = 0;\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++) {\n\t\t\t\t\tint p = pn[x][y];\n\t\t\t\t\tif (p != 0)\n\t\t\t\t\t\tret += Math.abs(x - gx[p]) + Math.abs(y - gy[p]);\n\t\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic void copy(Bd bd) {\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\t\t\tpn[x][y] = bd.pn[x][y];\n\t\t}\n\n\t\tprivate boolean up() {\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 2; y++)\n\t\t\t\t\tif (pn[x][y] == 0) {\n\t\t\t\t\t\tpn[x][y] = pn[x][y + 1];\n\t\t\t\t\t\tpn[x][y + 1] = 0;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate boolean down() {\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 1; y < 3; y++)\n\t\t\t\t\tif (pn[x][y] == 0) {\n\t\t\t\t\t\tpn[x][y] = pn[x][y - 1];\n\t\t\t\t\t\tpn[x][y - 1] = 0;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate boolean right() {\n\t\t\tfor (int x = 1; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\t\t\tif (pn[x][y] == 0) {\n\t\t\t\t\t\tpn[x][y] = pn[x - 1][y];\n\t\t\t\t\t\tpn[x - 1][y] = 0;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate boolean left() {\n\t\t\tfor (int x = 0; x < 2; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\t\t\tif (pn[x][y] == 0) {\n\t\t\t\t\t\tpn[x][y] = pn[x + 1][y];\n\t\t\t\t\t\tpn[x + 1][y] = 0;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic boolean move(int op) {\n\t\t\tswitch (op) {\n\t\t\tcase (0):\n\t\t\t\treturn up();\n\t\t\tcase (1):\n\t\t\t\treturn down();\n\t\t\tcase (2):\n\t\t\t\treturn right();\n\t\t\tcase (3):\n\t\t\t\treturn left();\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic boolean same(Bd b) {\n\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\t\t\tif (b.pn[x][y] != pn[x][y])\n\t\t\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate Bd bd = new Bd();\n\tprivate int[] gx = { 2, 0, 1, 2, 0, 1, 2, 0, 1 };\n\tprivate int[] gy = { 2, 0, 0, 0, 1, 1, 1, 2, 2 };\n\tprivate ArrayList<Bd> hist = new ArrayList<Bd>();\n\n\tpublic void SetIni(int x, int y, int a) {\n\t\tbd.pn[x][y] = a;\n\t}\n\n\tpublic int solve() {\n\t\tBd b = new Bd();\n\t\tb.copy(bd);\n\t\thist.add(0, b);\n\t\tsearch(b);\n\t\treturn hist.size() - 1;\n\t}\n\n\tprivate boolean search(Bd b) {\n\t\t// printBd(b);\n\n\t\tif (b.eval() == 0)\n\t\t\treturn true;\n\n\t\tint[] pri = new int[4];\n\t\tBd[] nb = new Bd[4];\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tnb[i] = new Bd();\n\t\t\tnb[i].copy(b);\n\t\t\tif (nb[i].move(i) && newPat(nb[i]))\n\t\t\t\tpri[i] = nb[i].eval();\n\t\t\telse\n\t\t\t\tpri[i] = -1;\n\t\t}\n\n\t\twhile (true) {\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tint imin = -1;\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t\tif (pri[i] != -1 && pri[i] < min) {\n\t\t\t\t\tmin = pri[i];\n\t\t\t\t\timin = i;\n\t\t\t\t}\n\t\t\tif (imin == -1)\n\t\t\t\tbreak;\n\n\t\t\tpri[imin] = -1;\n\t\t\thist.add(0, nb[imin]);\n\t\t\tif (search(nb[imin]))\n\t\t\t\treturn true;\n\t\t\thist.remove(0);\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean newPat(Bd b) {\n\t\tfor (int i = 0; i < hist.size(); i++)\n\t\t\tif (b.same(hist.get(i)))\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tprivate void printBd(Bd b) {\n\t\tSystem.out.println(\"----------------\");\n\t\tfor (int y = 0; y < 3; y++)\n\t\t\tSystem.out.println(\"- \" + b.pn[0][y] + \" \" + b.pn[1][y] + \" \" + b.pn[2][y] + \" -\");\n\t\tSystem.out.println(\"------- \" + b.eval() + \" hist \" + hist.size());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nclass Main{\n  public static final int N = 9;\n  public static void main(String args[]){\n    Scanner sc = new Scanner(System.in);\n    char c[] = new char[N];\n    String end = \"123456780\";\n    String puzzle=\"\";\n    // int right = 1, left = -1, on = -3, under = 3;\n    int index[] = {1,-1,-3,3};\n    HashMap<String, Integer> hash = new HashMap<String, Integer>();\n    Queue<String> queue = new ArrayDeque<String>();\n    for(int i = 0; i<N; i++){\n      c[i] += (char)(sc.nextInt()+48);\n      puzzle +=c[i];\n    }\n    // for(int i = 0; i<N; i++){\n    //   System.out.print(c[i]);\n    // }\n    // puzzle = toString(c);\n    queue.add(puzzle);\n    hash.put(puzzle,0);\n\n    while(!queue.isEmpty()){\n      String comfirm = queue.remove();\n      if(comfirm.equals(end)){\n        // String comfirm = queue.remove();\n        System.out.println(hash.get(comfirm));\n        break;\n      }\n\n      StringBuffer s = new StringBuffer(comfirm);\n      int vacancy = s.indexOf(\"0\");\n      for(int i = 0; i<4; i++){\n        if(vacancy + index[i] >= 0 && vacancy + index[i]<N){//範囲外でない（上下）\n          if( !((index[i] == -1)&& ((index[i]+vacancy) % 3==2))  &&  !((index[i] == 1) &&((index[i]+vacancy) % 3 == 0))  ){//左右の範囲外確認\n            //交換作業して存在しなければキューとハッシュ追加。\n            s.setCharAt(vacancy, s.charAt(vacancy + index[i]));\n            s.setCharAt(vacancy + index[i], '0');\n            if (!hash.containsKey(s.toString())) {\n              queue.add(s.toString());\n              hash.put(s.toString(), hash.get(comfirm)+1);\n            }\n            //そして戻す。\n            s.setCharAt(vacancy + index[i], s.charAt(vacancy));\n            s.setCharAt(vacancy, '0');\n          }\n        }\n      }\n\n      // @Override\n      // public String toString() {\n      // }\n    }\n  }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n/**\n * IDA* for 8 or 15 puzzle\n * f(x) = h(x) +depth(g(x))\n *\n */\npublic class Main {\n\n    private int[] up = {-1,0};\n    private int[] down = {1,0};\n    private int[] left = {0,-1};\n    private int[] right = {0,1};\n\n    private final int UP = 0;\n    private final int DOWN = 2;\n    private final int LEFT = 1;\n    private final int RIGHT = 3;\n\n    private int SIZE;\n\n    /*\n    store the position of the each point of the target state\n     */\n    private int[][] targetPoints;\n\n    /*\n    f(x),total cost\n     */\n    private static int cost;\n\n    //target state\n    private static int[][] tState = {{1 ,2 ,3 },{4 ,5 ,6 },{7 ,8, 0}};\n\n    private static int blank_row,blank_column;\n\n    public Main(int[][] state) {\n        SIZE = state.length;\n        targetPoints = new int[SIZE * SIZE][2];\n\n        /*\n        get the position of blank point\n         */\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] == 0) {\n                    blank_row = i;\n                    blank_column = j;\n                    break;\n                }\n            }\n        }\n        /*\n        get the position(x,y) by using a two-dimensional array.\n        e.g. 2's position is (2,1),\n        targetPoints [2][0] = 2-1 =1,targetPoints[2][1]=1-1=0\n         */\n        for(int i=0;i<tState.length;i++) {\n            for(int j=0;j<tState.length;j++) {\n                targetPoints[tState[i][j]][0] = i;\n\n                targetPoints[tState[i][j]][1] = j;\n            }\n        }\n    }\n    public boolean checkState(int[][] state){\n        boolean b =true;\n        for(int i = 0;i<SIZE;i++)\n            for(int j=0;j<SIZE;j++){\n                if(!(state[i][j]==tState[i][j]))\n                    b = false;\n            }\n        return b;\n    }\n\n    public static void main(String[] args) {\n        int step = 0;\n        int[][] sState=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3&&(s=sc.nextLine())!=null){\n            sState[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            sState[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            sState[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        Main idaAlgorithm = new Main(sState);\n\n        if(idaAlgorithm.checkState(sState)){\n            System.out.println(step);\n        }\n        else{\n            int j = idaAlgorithm.getHeuristic(sState);\n            int i = -1;\n\n            for (cost = j; ; cost++) {\n                if (idaAlgorithm.solve(sState\n                        , blank_row, blank_column, 0, i, j)) {\n                    break;\n                }\n            }\n            System.out.println(cost);\n        }\n    }\n    /**\n     *\n     * @param state\n     * @param blank_row the row-coordinate of 0 in ths state\n     * @param blank_column the column-coordinate of 0 in ths state\n     * @param dep the depth of the state\n     * @param d the direction of the last move\n     * @param h the value of h(x)\n     * @return\n     */\n    public boolean solve(int[][] state,int blank_row,int blank_column,\n                         int dep,int d,int h) {\n        /*\n        the value of h(x) after moving\n         */\n        int h1;\n\n        /*\n        make a comparison with the target state\n         */\n        boolean isSolved = checkState(state);\n        if(isSolved) {\n            return true;\n        }\n\n        if(dep == cost) {\n            return false;\n        }\n\n        /*\n        the position of the blank point after moving\n         */\n        int blank_row1 ;\n        int blank_column1;\n        int[][] state2 = new int[SIZE][SIZE];\n\n        for(int direction=0;direction<4;direction++) {\n            for(int i=0;i<state.length;i++) {\n                for(int j=0;j<state.length;j++) {\n                    state2[i][j] = state[i][j];\n                }\n            }\n\n            /*\n            check whether the direction of this movement is opposite of the direction of the last move or not\n             */\n            if(direction != d && (d%2 == direction%2)) {\n                continue;\n            }\n\n            if(direction == UP) {\n                blank_row1 = blank_row + up[0];\n                blank_column1 = blank_column + up[1];\n            } else if(direction == DOWN) {\n                blank_row1 = blank_row + down[0];\n                blank_column1 = blank_column + down[1];\n            } else if(direction == LEFT) {\n                blank_row1 = blank_row + left[0];\n                blank_column1 = blank_column + left[1];\n            } else {\n                blank_row1 = blank_row + right[0];\n                blank_column1 = blank_column + right[1];\n            }\n\n            /*\n            border check\n             */\n            if(blank_column1 < 0 || blank_column1 == SIZE\n                    || blank_row1 < 0 || blank_row1 == SIZE) {\n                continue ;\n            }\n\n            /*\n            swap position\n             */\n            state2[blank_row][blank_column] = state2[blank_row1][blank_column1];\n            state2[blank_row1][blank_column1] = 0;\n\n            /*\n            calculate the h(x)\n             */\n            if(direction == DOWN && blank_row1\n                    > targetPoints[state[blank_row1][blank_column1]][0]) {\n                h1 = h - 1;\n            } else if(direction == UP && blank_row1\n                    < targetPoints[state[blank_row1][blank_column1]][0]){\n                h1 = h - 1;\n            } else if(direction == RIGHT && blank_column1\n                    > targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else if(direction == LEFT && blank_column1\n                    < targetPoints[state[blank_row1][blank_column1]][1]) {\n                h1 = h - 1;\n            } else {\n                h1 = h + 1;\n            }\n\n            /*\n            if f(x) increases,prune\n             */\n            if(h1+dep+1> cost) {\n                continue;\n            }\n\n            /*\n            do the iteration with depth increasing\n             */\n            if(solve(state2, blank_row1, blank_column1, dep+1, direction, h1)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * get the value of h(x)\n     * @param state\n     */\n    public int getHeuristic(int[][] state) {\n        int heuristic = 0;\n        for(int i=0;i<state.length;i++) {\n            for(int j=0;j<state[i].length;j++) {\n                if(state[i][j] != 0) {\n                    heuristic = heuristic +\n                            Math.abs(targetPoints[state[i][j]][0] - i)\n                            + Math.abs(targetPoints[state[i][j]][1] - j);\n                }\n            }\n        }\n        return heuristic;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.HashMap;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in); \n\n\t\tint n = 9;\n\t\tchar[] s = new char[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ts[i] = (char)('0' + sc.nextInt());\n\t\t}\n\t\t\n\t\tString ans = \"123456780\";\n\t\tint[] d = {-3, 3, -1, 1};\n\t\t\n\t\tHashMap<String, Integer> hm = new HashMap<String, Integer>();\n\t\t\n\t\tQueue<String> q = new ArrayDeque<String>();\n\t\tq.add(toString(s));\n\t\thm.put(toString(s), 0);\n\n\t\twhile (!q.isEmpty()) {\n\t\t\tString u = q.remove();\n\t\t\tif (u.equals(ans)) {\n\t\t\t\tSystem.out.println(hm.get(u));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tStringBuffer str = new StringBuffer(u);\n\t\t\tint zero = str.indexOf(\"0\");\n\t\t\tfor (int i = 0; i < d.length; i++) {\n\t\t\t\tif (zero + d[i] >= 0 && zero + d[i] < n) {\n\t\t\t\t\tstr.setCharAt(zero, str.charAt(zero + d[i]));\n\t\t\t\t\tstr.setCharAt(zero + d[i], '0');\n\t\t\t\t\tif (!hm.containsKey(str.toString())) {\n\t\t\t\t\t\tq.add(str.toString());\n\t\t\t\t\t\thm.put(str.toString(), hm.get(u) + 1);\n\t\t\t\t\t}\n\t\t\t\t\tstr.setCharAt(zero + d[i], str.charAt(zero));\n\t\t\t\t\tstr.setCharAt(zero, '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        sc.close();\n\t}\n\t\n\tprivate static String toString(char[] s) {\n\t\tString ret = \"\";\n\t\tfor (int i = 0; i < s.length; i++) {\n\t\t\tret += s[i];\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.awt.*;\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n//        long startTime = System.currentTimeMillis();\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n//        System.out.println(System.currentTimeMillis()-startTime);\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n    public NodeCloseListComparator nodeCloseListComparator = new NodeCloseListComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (1000, nodeOpenListComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (1000,nodeCloseListComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenOrCloseIn(childNode,open)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                        }\n                    }\n                }\n            }\n            else if(isOpenOrCloseIn(childNode,close)){\n                Iterator<Node> iter = open.iterator();\n                while(iter.hasNext())\n                {\n                    Node iterNode = iter.next();\n                    if(iterNode.equal(childNode.status))\n                    {\n                        if(childNode.gvalue < iterNode.gvalue)\n                        {\n                            iterNode.parent = childNode.parent;\n                            iterNode.gvalue = childNode.gvalue;\n                            iterNode.fvalue = childNode.fvalue;\n                            iter.remove();\n                            open.add(childNode);\n                        }\n                    }\n                }\n            }\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenOrCloseIn(Node newNode, PriorityQueue<Node> List)\n    {\n        Iterator<Node> iter = List.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\n@SuppressWarnings(\"unchecked\")\nclass NodeCloseListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.gvalue - y.gvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\nclass Main {\n\n\t\n\tprivate int[] up = {-1,0};\n\tprivate int[] down = {1,0};\n\tprivate int[] left = {0,-1};\n\tprivate int[] right = {0,1};\n\t\n\tpublic static int sum = 0;\n\tprivate final int UP = 0;\n\tprivate final int DOWN = 2;\n\tprivate final int LEFT = 1;\n\tprivate final int RIGHT = 3;\n\t\n\tprivate static int SIZE = 3;\n\t\n\t\n\tprivate int[][] target; \n\t\n\t\n\tprivate static int[] moves = new int[100000];\n\t\n\tprivate static long ans = 0;\n\t\n\t\n\tprivate static int[][] tState = {\n\t\t{1 ,2 ,3 } ,\n\t\t{4, 5 ,6 } ,\n\t\t{7, 8 ,0 } ,\n\t};\n\t\n\tprivate static int[][] sState;\n\t\n\n\t\n\tprivate static int blank_row,blank_column;\n\t\n\tpublic Main(int[][] state) {\n\t\tSIZE = state.length;\n\t\ttarget = new int[SIZE * SIZE][2];\n\t\t\n\t\tthis.sState = state;\n\t\t\n\t\tfor(int i=0;i<state.length;i++) {\n\t\t\tfor(int j=0;j<state[i].length;j++) {\n\t\t\t\tif(state[i][j] == 0) {\n\t\t\t\t\tblank_row = i;\n\t\t\t\t\tblank_column = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i=0;i<state.length;i++) {\n\t\t\tfor(int j=0;j<state.length;j++) {\n\t\t\t\ttarget[tState[i][j]][0] = i; \n\t\t\t\t\n\t\t\t\ttarget[tState[i][j]][1] = j; \n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tsState = new int[SIZE][SIZE];\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfor(int i=0;i<SIZE;i++) {\n\t\t\tfor(int j=0;j<SIZE;j++)\n\t\t\t\tsState[i][j]=sc.nextInt();\n\t\t}\n\t\t\n\t\t\n\t\tMain idaAlgorithm = new Main(sState);\n\t\t\n\t\n\t\tint j = idaAlgorithm.getHeuristic(sState);\n\t\t\n\t\tint i = -1;\n\t\t\n\t\t\n\t\tfor(ans=j;;ans++) {\n\t\t\tif(idaAlgorithm.solve(sState\n\t\t\t\t\t,blank_row,blank_column,0,i,j)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tif(ans != 0) {\n\t\t\tint[][] matrix = idaAlgorithm.move(sState,moves[0]);\n\t\t\tfor(int k=1;k<ans;k++) {\n\t\t\t\tmatrix = idaAlgorithm.move(matrix, moves[k]);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sum);\n\t\t\n\t}\n\t\n\tpublic int[][] move(int[][]state,int direction) {\n\t\tint row = 0;\n\t\tint column = 0;\n\t\tfor(int i=0;i<state.length;i++) {\n\t\t\tfor(int j=0;j<state.length;j++) {\n\t\t\t\tif(state[i][j] == 0) {\n\t\t\t\t\trow = i;\n\t\t\t\t\tcolumn = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswitch(direction) {\n\t\tcase UP:\n\t\t\tstate[row][column] = state[row-1][column];\n\t\t\tstate[row-1][column] = 0;\n\t\t\tbreak;\n\t\tcase DOWN:\n\t\t\tstate[row][column] = state[row+1][column];\n\t\t\tstate[row+1][column] = 0;\n\t\t\tbreak;\n\t\tcase LEFT:\n\t\t\tstate[row][column] = state[row][column-1];\n\t\t\tstate[row][column-1] = 0;\n\t\t\tbreak;\n\t\tcase RIGHT:\n\t\t\tstate[row][column] = state[row][column+1];\n\t\t\tstate[row][column+1] = 0;\n\t\t\tbreak;\n\t\t}\n\t\tsum++;\n\t\treturn state;\n\t}\n\t\n\t\n\t\n\t\n\tpublic boolean solve(int[][] state,int blank_row,int blank_column,\n\t\t\tint dep,long d,long h) {\n\t\t\n\t\tlong h1;\n\t\t\n\t\tboolean isSolved = true;\n\t\tfor(int i=0;i<SIZE;i++) {\n\t\t\tfor(int j=0;j<SIZE;j++) {\n\t\t\t\tif(state[i][j] != tState[i][j]) {\n\t\t\t\t\tisSolved = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(isSolved) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif(dep == ans) {\n\t\t\treturn false;\n\t\t}\n\n\t\t\n\t\tint blank_row1 = blank_row;\n\t\tint blank_column1  = blank_column;\n\t\tint[][] state2 = new int[SIZE][SIZE];\n\n\t\tfor(int direction=0;direction<4;direction++) {\n\t\t\tfor(int i=0;i<state.length;i++) {\n\t\t\t\tfor(int j=0;j<state.length;j++) {\n\t\t\t\t\tstate2[i][j] = state[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif(direction != d && (d%2 == direction%2)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(direction == UP) {\n\t\t\t\tblank_row1 = blank_row + up[0];\n\t\t\t\tblank_column1 = blank_column + up[1];\n\t\t\t} else if(direction == DOWN) {\n\t\t\t\tblank_row1 = blank_row + down[0];\n\t\t\t\tblank_column1 = blank_column + down[1];\n\t\t\t} else if(direction == LEFT) {\n\t\t\t\tblank_row1 = blank_row + left[0];\n\t\t\t\tblank_column1 = blank_column + left[1];\n\t\t\t} else {\n\t\t\t\tblank_row1 = blank_row + right[0];\n\t\t\t\tblank_column1 = blank_column + right[1];\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif(blank_column1 < 0 || blank_column1 == SIZE\n\t\t\t\t\t|| blank_row1 < 0 || blank_row1 == SIZE) {\n\t\t\t\tcontinue ;\n\t\t\t}\n\t\t\t\n\t\t\t\t\n\t\t\tstate2[blank_row][blank_column] = state2[blank_row1][blank_column1];\n\t\t\tstate2[blank_row1][blank_column1] = 0;\n\t\t\t\n\t\t\t\n\t\t\tif(direction == DOWN && blank_row1 \n\t\t\t\t\t> target[state[blank_row1][blank_column1]][0]) {\n\t\t\t\th1 = h - 1;\n\t\t\t} else if(direction == UP && blank_row1 \n\t\t\t\t\t< target[state[blank_row1][blank_column1]][0]){\n\t\t\t\th1 = h - 1;\n\t\t\t} else if(direction == RIGHT && blank_column1 \n\t\t\t\t\t> target[state[blank_row1][blank_column1]][1]) {\n\t\t\t\th1 = h - 1;\n\t\t\t} else if(direction == LEFT && blank_column1 \n\t\t\t\t\t< target[state[blank_row1][blank_column1]][1]) {\n\t\t\t\th1 = h - 1;\n\t\t\t} else { \n\t\t\t\t\n\t\t\t\th1 = h + 1;\n\t\t\t}\n\t\t\t\n\t\t\tif(h1+dep+1>ans) { \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tmoves[dep] = direction;\n\t\t\t\n\t\t\t\n\t\t\tif(solve(state2, blank_row1, blank_column1, dep+1, direction, h1)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\n\tpublic int getHeuristic(int[][] state) {\n\t\tint he = 0;\n\t\tfor(int i=0;i<state.length;i++) {\n\t\t\tfor(int j=0;j<state[i].length;j++) {\n\t\t\t\tif(state[i][j] != 0) {\n\t\t\t\t\the = he + \n\t\t\t\t\t\t\tMath.abs(target[state[i][j]][0] - i)\n\t\t\t\t\t\t\t+ Math.abs(target[state[i][j]][1] - j);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn he;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Main {\n\t// Main\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint[] board = new int[9];\n\t\tStringTokenizer st = new StringTokenizer(br.readLine(),\" \");\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (i==3||i==6) {\n\t\t\t\tst = new StringTokenizer(br.readLine(), \" \");\n\t\t\t}\n\t\t\tboard[i] = Integer.parseInt(st.nextToken());\n\t\t}\n\t\tDeque<state> mainq = new ArrayDeque<state>();\n\t\tBitSet cl = new BitSet(500000);\n\t\tmainq.add(new state(board, 0));\n\t\tcl.set(hashBoard(board));\n\t\tint minStep = -1;\n\t\twhile(!mainq.isEmpty()){\n\t\t\tfinal state s = mainq.remove();\n\t\t\tif (hashBoard(s.board) == 46233) {\n\t\t\t\tminStep = s.move;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint pos;\n\t\t\tfor(pos = 0; pos<9 && s.board[pos] != 0; pos++);\n\t\t\t\n\t\t\tif (pos%3 != 0) {\n\t\t\t\tfinal int[] next = Arrays.copyOf(s.board, s.board.length);\n\t\t\t\tnext[pos] = next[pos-1];\n\t\t\t\tnext[pos-1] = 0;\n\t\t\t\tfinal int h = hashBoard(next);\n\t\t\t\tif(!cl.get(h)){\n\t\t\t\t\tcl.set(h);\n\t\t\t\t\tmainq.add(new state(next, s.move+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (pos%3 != 2) {\n\t\t\t\tfinal int[] next = Arrays.copyOf(s.board, s.board.length);\n\t\t\t\tnext[pos] = next[pos+1];\n\t\t\t\tnext[pos+1] = 0;\n\t\t\t\tfinal int h = hashBoard(next);\n\t\t\t\tif(!cl.get(h)){\n\t\t\t\t\tcl.set(h);\n\t\t\t\t\tmainq.add(new state(next, s.move+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (pos > 2) {\n\t\t\t\tfinal int[] next = Arrays.copyOf(s.board, s.board.length);\n\t\t\t\tnext[pos] = next[pos - 3];\n\t\t\t\tnext[pos-3] = 0;\n\t\t\t\tfinal int h = hashBoard(next);\n\t\t\t\tif(!cl.get(h)){\n\t\t\t\t\tcl.set(h);\n\t\t\t\t\tmainq.add(new state(next, s.move+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (pos < 6) {\n\t\t\t\tfinal int[] next = Arrays.copyOf(s.board, s.board.length);\n\t\t\t\tnext[pos] = next[pos + 3];\n\t\t\t\tnext[pos+3] = 0;\n\t\t\t\tfinal int h = hashBoard(next);\n\t\t\t\tif(!cl.get(h)){\n\t\t\t\t\tcl.set(h);\n\t\t\t\t\tmainq.add(new state(next, s.move+1));\n\t\t\t\t}\n\t\t\t}\n\t\t} //end while\n\tSystem.out.println(minStep);\t\n\t}// End Main\n\t\n\t// Hash the game board state\n\tprivate static int hashBoard(int[] board){\n\t\tint h = board[0];\n\t\tfor (int i = 1; i < 8; i++) {\n\t\t\th = h*(9-i);\n\t\t\th = h+board[i];\n\t\t\tfor (int a = 0; a < i; a++) {\n\t\t\t\tif (board[a]<board[i]) {\n\t\t\t\t\t--h;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn h;\n\t}// End Hash Board\n}\n\n\n\n\n\n// State Class\nclass state{\n\tfinal int[] board;\n\tfinal int move;\n\tstate(int[] board, int move){\n\t\tthis.board = board;\n\t\tthis.move = move;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\n \npublic class Main {\n \n    public static void main(String[] args) throws IOException {\n        // TODO ?????????????????????????????????????????????\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n         \n        int input = 0;\n        for(int i = 0; i < 3; i++){\n            String[] tmpStr = br.readLine().split(\" \");\n            for(int j = 0; j < 3; j++){\n                int number = Integer.parseInt(tmpStr[j]);\n                //?????????????????\\???????????§0???9???????????????\n                if(number == 0){\n                    number = 9;\n                }\n                input += number * Math.pow(10, 8 - (i*3 + j));\n            }\n        }\n        //???????????????????????????\n        //System.out.println(swapTiles(123496758, DOWN));\n        /*\n        boolean[] tmpResult = checkAvailable(921436795);\n        if(tmpResult[UP]){\n        \tSystem.out.println(\"UP OK\");\n        }\n        if(tmpResult[RIGHT]){\n        \tSystem.out.println(\"RIGHT OK\");\n        }\n        if(tmpResult[DOWN]){\n        \tSystem.out.println(\"DOWN OK\");\n        }\n        if(tmpResult[LEFT]){\n        \tSystem.out.println(\"LEFT OK\");\n        }\n        */\n        \n        //System.out.println(input);\n        \n        searchPath(input, 0, START);\n        //System.out.println(\"END\");\n        System.out.println(minimumTurn.get(123456789));\n    }\n     \n    static int call = 0;\n    static void recursiveTest(int depth){\n        char[][] test = new char[3][3];\n         \n        call++;\n        System.out.println(\"depth is \"+depth+\" call \"+call);\n        if(depth == 32){\n            return;\n        }\n        recursiveTest(depth + 1);\n        recursiveTest(depth + 1);\n        recursiveTest(depth + 1);\n        recursiveTest(depth + 1);\n    }\n    \n    static HashMap<Integer, Integer> minimumTurn = new HashMap<Integer, Integer>();\n    static final int finish = 123456789;\n    static int currentMin = Integer.MAX_VALUE;\n    \n    static int searchPath(int condition, int depth, int direction){\n    \t//?????§??????????????£?????????????????±??????????????????\n    \tif(depth >= currentMin || depth >= 32){\n    \t\treturn 0;\n    \t}\n    \t//??????????\\?\n    \tif(direction != START){\n    \t\tcondition = swapTiles(condition, direction);\n    \t}\n    \t//System.out.println(condition+\" depth = \"+depth + \" hash size \"+ minimumTurn.size());\n    \tif(!minimumTurn.containsKey(condition) || minimumTurn.get(condition) > depth){\n    \t\tminimumTurn.put(condition, depth);\n    \t}\n    \t\n    \t//????§?????????????????????§??????\n    \telse if(minimumTurn.get(condition) <= depth){\n    \t\treturn 0;\n    \t}\n    \t\n    \t//??¢?´¢?????????????????§??????\n    \tif(condition == finish){\n    \t\t///System.exit(0);\n    \t\tcurrentMin = depth;\n    \t\treturn 1;\n    \t}\n    \tboolean[] available = checkAvailable(condition);\n    \tint result = 0;\n    \t//???\n    \tif(direction != DOWN && available[UP]){\n    \t\tsearchPath(condition, depth + 1, UP);\n    \t}\n    \t//???\n    \tif(direction != LEFT && available[RIGHT]){\n    \t\tsearchPath(condition, depth + 1, RIGHT);\n    \t}\n    \t//???\n    \tif(direction != UP && available[DOWN]){\n    \t\tsearchPath(condition, depth + 1, DOWN);\n    \t}\n    \t//???\n    \tif(direction != RIGHT && available[LEFT]){\n    \t\tsearchPath(condition, depth + 1, LEFT);\n    \t}\n    \treturn 0;\n    }\n    \n    private static int swapTiles (int condition, int direction){\n    \tchar[] condChar = Integer.toString(condition).toCharArray();\n    \t\n    \tint index9 = Integer.toString(condition).indexOf('9');\n    \tint targetIndex;\n    \tif(direction == UP){\n    \t\ttargetIndex = index9 - 3;\n    \t}\n    \telse if(direction == RIGHT){\n    \t\ttargetIndex = index9 + 1;\n    \t}\n    \telse if(direction == DOWN){\n    \t\ttargetIndex = index9 + 3;\n    \t}\n    \telse{\n    \t\ttargetIndex = index9 - 1;\n    \t}\n    \t\n    \tchar tmp = condChar[index9];\n    \tcondChar[index9] = condChar[targetIndex];\n    \tcondChar[targetIndex] = tmp;\n    \t\t\t\n    \t\n    \treturn Integer.parseInt(new String(condChar));\n    }\n    \n    static final int UP = 0;\n    static final int RIGHT = 1;\n    static final int DOWN = 2;\n    static final int LEFT = 3;\n    static final int START = 4;\n    \n    private static boolean[] checkAvailable(int condition){\n    \tboolean [] result = new boolean[4];\n    \tArrays.fill(result, true);\n    \t\n    \tString condStr = Integer.toString(condition);\n    \tint index9 = condStr.indexOf('9');\n    \t\n    \tif(index9 == 0 || index9 == 1 || index9 == 2 ){\n    \t\tresult[UP] = false;\n    \t}\n    \tif(index9 == 2 || index9 == 5 || index9 == 8){\n    \t\tresult[RIGHT] = false;\n    \t}\n    \tif(index9 == 6 || index9 == 7 || index9 == 8){\n    \t\tresult[DOWN] = false;\n    \t}\n    \tif(index9 == 0 || index9 == 3 || index9 == 6){\n    \t\tresult[LEFT] = false;\n    \t}\n    \t\n    \treturn result;\n    }\n \n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n    public NodeCloseListComparator nodeCloseListComparator = new NodeCloseListComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (1000, nodeOpenListComparator);\n    public PriorityQueue<Node>  close =new PriorityQueue<Node> (1000,nodeCloseListComparator);\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        //????????\\????????????????????¨???????????°?????????????????°???g??? ???????°??????°??¨???g????????????????????????\n        //???????????????????????????????????¢?????°\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenIn(childNode,open));\n            else if(isCloseIn(childNode,close));\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenIn(Node newNode, PriorityQueue<Node> openList)\n    {\n        Iterator<Node> iter = openList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                if(newNode.gvalue < iterNode.gvalue)\n                {\n                    iterNode.parent = newNode.parent;\n                    iterNode.gvalue = newNode.gvalue;\n                    iterNode.fvalue = newNode.fvalue;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean isCloseIn(Node newNode, PriorityQueue<Node> closeList){\n        Iterator<Node> iter = closeList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                if(newNode.gvalue < iterNode.gvalue)\n                {\n                    iterNode.parent = newNode.parent;\n                    iterNode.gvalue = newNode.gvalue;\n                    iterNode.fvalue = newNode.fvalue;\n                    iter.remove();\n                    open.add(newNode);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.fvalue - y.fvalue;\n    }\n}\n@SuppressWarnings(\"unchecked\")\nclass NodeCloseListComparator implements  Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.gvalue-y.gvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int fvalue;\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\n\nclass field{\n\tint cell[] = new int[9];\n\tint evaluation;\n\tint route[];\n\tint floor;\n\n\tfield(int cell[], int hash){\n\t\tfloor = 1;\n\t\troute = new int[1];\n\t\troute[0] = hash;\n\t\tfor(int i = 0; i < 9; i++) this.cell[i] = cell[i];\n\t\tint eva = 0;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tif(cell[i] != 0){\n\t\t\t\t//?¨???????????????¢?????????\n\t\t\t\t//i???????????????????????????\n\t\t\t\t//cell[i]???????????????????????°???\n\t\t\t\teva += Math.abs((cell[i]-1)%3 - i%3);\n\t\t\t\t//?????????????????¢?????????\n\t\t\t\teva += Math.abs((cell[i]-1)/3 - i/3);\n\t\t\t}\n\t\t}\n\t\tevaluation = eva;\n\t}\n\n\t/**/\n\n\tfield(int cell[], int route[], int hash){\n\t\tthis.floor = route.length;\n\t\tthis.route = new int[floor+1];\n\t\tSystem.arraycopy(route, 0, this.route, 0, floor);\n\t\tthis.route[floor] = hash; //hash???????´???????\n\t\tfor(int i = 0; i < 9; i++) this.cell[i] = cell[i];\n\t\tint eva = 0;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tif(cell[i] != 0){\n\t\t\t\t//?¨???????????????¢?????????\n\t\t\t\t//i???????????????????????????\n\t\t\t\t//cell[i]???????????????????????°???\n\t\t\t\teva += Math.abs((cell[i]-1)%3 - i%3);\n\t\t\t\t//?????????????????¢?????????\n\t\t\t\teva += Math.abs((cell[i]-1)/3 - i/3);\n\t\t\t}\n\t\t}\n\t\tevaluation = eva; //??¨????????????\n\t}\n\n\tpublic String toString(){\n\t\treturn new String(cell[0] + \" \" + cell[1] + \" \" + cell[2] + \"\\n\" + cell[3] + \" \" + cell[4] + \" \" + cell[5] + \"\\n\" + cell[6] + \" \" + cell[7] + \" \" + cell[8] + \"\\n\");\n\t}\n}\n\n/**/\nclass ev_list{\n\tfield elem;\n\tev_list next;\n\t\n\tev_list(){\n\t\tnext = null;\n\t\tthis.elem = null;\n\t}\n\n\tev_list(field elem){\n\t\tnext = null;\n\t\tthis.elem = elem;\n\t}\n\n\t/**/\n\tpublic void insert(ev_list node){\n\t\t//?????\\??????????????£????????¢??°??????????¬???????????????????????????§?????????\n\t\t//??????????¬???????????????????????????¨????????\\\n\t\tif(this.next == null || this.next.elem.evaluation + this.next.elem.floor < node.elem.evaluation + node.elem.floor){\n\t\t\t//?¬????????????????????????\\??????????????£????????¢??°??????????°??????????\n\t\t\t//this, this.next???node????????\\??????this, node, node.next(this.next)?????????\n\t\t\tnode.next = this.next;\n\t\t\tthis.next = node;\n\t\t}else this.next.insert(node);\n\t\t//?¬????????????????????????????????????§????????¨???????¬????????????????node????????\\??????\n\t}\n\n\t/**/\n\tpublic field pop(){\n\t\tif(this.next == null) return null;\n\t\tif(this.next.next == null){ //?¬?????¬????null??????\n\t\t\tfield temp = this.next.elem; //???????¬?????????£????????????temp???\n\t\t\tthis.next = null; //???????¬????null?????????\n\t\t\treturn temp; //???????¬??????£?????????temp?????????\n\t\t}else return this.next.pop(); //?¬?????¬????null??§????????£??????????¬????pop??????\n\t}\n}\n\n/**/\n\npublic class Main{\n\n\tstatic final int LEFT = 0;\n\tstatic final int RIGHT = 1;\n\tstatic final int UP = 2;\n\tstatic final int DOWN = 3;\n\tstatic final int factor[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320}; //1???????§????????????????????´????n?????????\n\n\t/**/\n\t//???????????\\??????????????¢??°\n\tstatic public int hashkey(int[] cell){\n\t\tint val[] = new int[9];\n\t\tSystem.arraycopy(cell, 0, val, 0, 9);\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tfor(int j = i+1; j < 9; j++){\n\t\t\t\tif(val[j] > val[i]) val[j]--;\n\t\t\t}\n\t\t}\n\t\t//val??????0??????????????????????????????????????????????????????????????\\?????¢????????°\n\t\tint hash = 0;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\thash += val[i]  * factor[8-i]; //factor????????§????????°?????????????????????????????????????????????\n\t\t}\n\t\treturn hash;\n\t}\n\n\t/**/\n\tstatic public field dehash(int key){\n\t\tint cell[] = new int[9];\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tcell[i] = key/factor[8-i]; //factor????????§????????°??????????????£????????????cell???val??¨??????\n\t\t\tkey %= factor[8-i];//factor?????????????????????key???\n\t\t}\n\t\tfor(int i = 8; i >= 0; i--){\n\t\t\tfor(int j = i+1; j < 9; j++){\n\t\t\t\tif(cell[i] <= cell[j]) cell[j] ++;\n\t\t\t}\n\t\t}\n\t\t//hash??????key??????????????¨???val???cell??????????????????????????§??????cell???????????????dehash??§???????????¨????¢????\n\t\treturn new field(cell, key);\n\t}\n\n\t/**/\n\n\t//3*3????????£????????????????§??????§????????????\n\t//move[i][LEFT]:??????????????????(0,1)\n\t//move[i][RIGHT]:??????????????????(0,1)\n\t//move[i][UP]:??????????????????(0,1)\n\t//move[i][DOWN]:??????????????????(0,1)\n\tstatic boolean move[][] = new boolean[9][4];\n\n\tpublic static void main(String[] args){\n\t\t\n\t\t//?§????????????????????¨??????¨???\n\n\t\t//?§??????§?????????????????????????????????????¨??????????\n\t\t//????????????????????????????????????\n\t\tmove[0][RIGHT]=move[1][RIGHT]=move[3][RIGHT]=move[4][RIGHT]=move[6][RIGHT]=move[7][RIGHT]=true;\n\t\tmove[2][RIGHT]=move[5][RIGHT]=move[8][RIGHT]=false;\n\n\t\t//????????????????????????????????????\n\t\tmove[1][LEFT]=move[2][LEFT]=move[4][LEFT]=move[5][LEFT]=move[7][LEFT]=move[8][LEFT]=true;\n\t\tmove[0][LEFT]=move[3][LEFT]=move[6][LEFT]=false;\n\n\t\t/**/\n\t\t//????????????????????????????????????\n\t\tmove[3][UP]=move[4][UP]=move[5][UP]=move[6][UP]=move[7][UP]=move[8][UP]=true;\n\t\tmove[0][UP]=move[1][UP]=move[2][UP]=false;\n\n\t\t//????????????????????????????????????\n\t\tmove[0][DOWN]=move[1][DOWN]=move[2][DOWN]=move[3][DOWN]=move[4][DOWN]=move[5][DOWN]=true;\n\t\tmove[6][DOWN]=move[7][DOWN]=move[8][DOWN]=false;\n\n\t\t/**/\n\t\t//????????????????¨??????¨???\n\t\t//????????????\n\t\tfield st;\n\t\tint cell[] = new int[9];\n\n\t\tScanner scan = new Scanner(System.in).useDelimiter(\"[\\\\s]+\");\n\t\tfor(int i=0;i<3;i++)\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\tcell[3*i+j] = scan.nextInt();\n\t\t//for?????°???????????§cell??\\???\n\n\t\tst = new field(cell, hashkey(cell)); //??¨????????¢?????¨?????????????????¨???????????\\??????????????£????????????????????????\n\t\t/**/\n\t\t//???????????\\????????????\n\t\tboolean visited[] = new boolean[362880];\n\t\tfor(int i=0; i<362880; i++)\n\t\t\tvisited[i] = false;\n\n\t\t//??¢?´¢??¨???\n\n\t\t//??????????????????????¨????\n\t\tev_list list = new ev_list();\n\t\tlist.insert(new ev_list(st)); //?????????????????£?????????????????\\??????\n\t\tvisited[hashkey(cell)] = true; //???????????\\????????????????????????true?????????\n\n\t\t/**/\n\t\tfield cur;\n\t\tint hash;\n\t\tint count=0;\n\t\twhile( (cur=list.pop() )!= null){\n\t\t\tcount++; //??¢?´¢?????°???1?¢???????\n\n\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\tif(cur.cell[i]==0){ //cur????????¬???????????£????????????cell[i]???0??????\n\t\t\t\t\tif(move[i][LEFT]){ //?????????????????????????????¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i-1];\n\t\t\t\t\t\tcur.cell[i-1]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell); //hashkey?????????\n\t\t\t\t\t\tif(!visited[hash]){ //hashkey????¨??????????????????????\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) )); //list????????£?????????????????\\??????\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i-1]=cur.cell[i]; //????????????\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t\t/**/\n\t\t\t\t\tif(move[i][RIGHT]){ //?????????????????????????????¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i+1];\n\t\t\t\t\t\tcur.cell[i+1]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell); //hashkey?????????\n\t\t\t\t\t\tif(!visited[hash]){ //hashkey????¨??????????????????????\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) ));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i+1]=cur.cell[i];\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(move[i][UP]){ //?????????????????????????????¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i-3];\n\t\t\t\t\t\tcur.cell[i-3]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell);\n\t\t\t\t\t\tif(!visited[hash]){\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) ));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i-3]=cur.cell[i];\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(move[i][DOWN]){ //?????????????????????????????¨??????\n\t\t\t\t\t\tcur.cell[i]=cur.cell[i+3];\n\t\t\t\t\t\tcur.cell[i+3]=0;\n\t\t\t\t\t\thash=hashkey(cur.cell); //hashkey?????????\n\t\t\t\t\t\tif(!visited[hash]){\n\t\t\t\t\t\t\tvisited[hash]=true;\n\t\t\t\t\t\t\tlist.insert(new ev_list(new field(cur.cell, cur.route, hash) ));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur.cell[i+3]=cur.cell[i];\n\t\t\t\t\t\tcur.cell[i]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/**/\n\t\t\tif(cur.evaluation==0){\n\t\t\t\tSystem.out.println(cur.route.length-1);\n\t\t\t\t//System.out.println(count+\"\");\n\t\t\t\t//System.out.println(\"evaluation[ \"+0+\" ]=\"+dehash(cur.route[0]).evaluation+\"\\n\"+dehash(cur.route[0]) );\n\t\t\t\t//evaluation??¨???????????????cur.route[0]?????????????????\\??????\n\t\t\t\t//for(int i=1;i<cur.route.length;i++){\n\t\t\t\t\t//System.out.println(\"???\");\n\t\t\t\t\t//System.out.println(\"evaluation[ \" +i+\" ]=\"+dehash(cur.route[i]).evaluation);\n\t\t\t\t\t//System.out.println(\"evaluation+floor[ \"+i+\" ]=\"+(dehash(cur.route[i]).evaluation+i) );\n\t\t\t\t\t//evalution??¨???????????????floor?§?????????¢\n\t\t\t\t\t//System.out.println( dehash(cur.route[i]).toString() );\n\t\t\t\t//}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static final int SIZE = 3;\n\tpublic static final int ALL_SIZE = SIZE * SIZE;\n\t\n\tpublic static int[] factor=  {\n\t\t1, 1, 2, 6, 24, 120, 720, 5040, 50320, 362880\n\t}; //0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n\t\n\t//完全最小ハッシュを作る.\n\tpublic static int hash(int[] A){\n\t\tint[] A_ = new int[A.length];\n\t\tSystem.arraycopy(A, 0, A_, 0, A.length);\n\t\t\n\t\tint ret = 0;\n\t\t\n\t\tfor(int i = 0; i < A_.length; i++){\n\t\t\tret += A_[i] * factor[(A.length - i - 1)];\n\t\t\t\n\t\t\tfor(int j = i + 1; j < A_.length; j++){\n\t\t\t\tif(A_[j] >= A_[i]){ A_[j]--; }\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tpublic static int[] unhash(int hash){\n\t\tint[] ret = new int[ALL_SIZE];\n\t\t\n\t\tfor(int i = 0; i < ALL_SIZE; i++){\n\t\t\tret[i] = hash / factor[ALL_SIZE - i - 1];\n\t\t\thash -= factor[ALL_SIZE - i - 1] * ret[i];\n\t\t}\n\t\t\n\t\tfor(int i = ALL_SIZE - 1; i >= 0; i--){\n\t\t\tfor(int j = i + 1; j < ALL_SIZE; j++){\n\t\t\t\tif(ret[i] <= ret[j]) ret[j]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\n\tpublic static final int GOAL = hash(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 0});\n\tpublic static final int MAX = hash(new int[]{8, 7, 6, 5, 4, 3, 2, 1, 0}) + 1;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t//System.out.println(Arrays.toString(unhash(GOAL)));\n\t\t\n\t\tint[] visited = new int[MAX];\n\t\tArrays.fill(visited, Integer.MAX_VALUE);\n\t\tLinkedList<Integer> queue = new LinkedList<Integer>();\n\t\t\n\t\tint[] input = new int[ALL_SIZE];\n\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\tfor(int j = 0; j < SIZE; j++){\n\t\t\t\tinput[i * SIZE + j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinal int hash_input = hash(input);\n\t\tqueue.add(hash_input);\n\t\tvisited[hash_input] = 0;\n\t\twhile(!queue.isEmpty()){\n\t\t\tfinal int hashed = queue.poll();\n\t\t\t\n\t\t\tif(hashed == GOAL){\n\t\t\t\tSystem.out.println(visited[hashed]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int dist = visited[hashed];\n\t\t\t\n\t\t\tint[] ret = unhash(hashed);\n\t\t\t\n\t\t\tfor(int i = 0; i < ALL_SIZE; i++){\n\t\t\t\tif(ret[i] == 0){\n\t\t\t\t\tif(i % 3 != 0){\n\t\t\t\t\t\tint tmp = ret[i];\n\t\t\t\t\t\tret[i] = ret[i - 1];\n\t\t\t\t\t\tret[i - 1] = tmp;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfinal int next_hash = hash(ret);\n\t\t\t\t\t\tif(visited[next_hash] > dist + 1){\n\t\t\t\t\t\t\tvisited[next_hash] = dist + 1;\n\t\t\t\t\t\t\tqueue.add(next_hash);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\ttmp = ret[i];\n\t\t\t\t\t\tret[i] = ret[i - 1];\n\t\t\t\t\t\tret[i - 1] = tmp;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(i % 3 != 2){\n\t\t\t\t\t\tint tmp = ret[i];\n\t\t\t\t\t\tret[i] = ret[i + 1];\n\t\t\t\t\t\tret[i + 1] = tmp;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfinal int next_hash = hash(ret);\n\t\t\t\t\t\tif(visited[next_hash] > dist + 1){\n\t\t\t\t\t\t\tvisited[next_hash] = dist + 1;\n\t\t\t\t\t\t\tqueue.add(next_hash);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\ttmp = ret[i];\n\t\t\t\t\t\tret[i] = ret[i + 1];\n\t\t\t\t\t\tret[i + 1] = tmp;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(i / 3 != 0){\n\t\t\t\t\t\tint tmp = ret[i];\n\t\t\t\t\t\tret[i] = ret[i - SIZE];\n\t\t\t\t\t\tret[i - SIZE] = tmp;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfinal int next_hash = hash(ret);\n\t\t\t\t\t\tif(visited[next_hash] > dist + 1){\n\t\t\t\t\t\t\tvisited[next_hash] = dist + 1;\n\t\t\t\t\t\t\tqueue.add(next_hash);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\ttmp = ret[i];\n\t\t\t\t\t\tret[i] = ret[i - SIZE];\n\t\t\t\t\t\tret[i - SIZE] = tmp;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(i / 3 != 2){\n\t\t\t\t\t\tint tmp = ret[i];\n\t\t\t\t\t\tret[i] = ret[i + SIZE];\n\t\t\t\t\t\tret[i + SIZE] = tmp;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfinal int next_hash = hash(ret);\n\t\t\t\t\t\tif(visited[next_hash] > dist + 1){\n\t\t\t\t\t\t\tvisited[next_hash] = dist + 1;\n\t\t\t\t\t\t\tqueue.add(next_hash);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\ttmp = ret[i];\n\t\t\t\t\t\tret[i] = ret[i + SIZE];\n\t\t\t\t\t\tret[i + SIZE] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\tpublic static class Scanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startStatus=new int[3][3];\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startStatus[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startStatus[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startStatus[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        int[][] endStatus = {{1,2,3},{4,5,6},{7,8,0}};\n        Astar test = new Astar(startStatus,endStatus);\n        test.run();\n    }\n\n}\nclass Astar\n{\n    public int[][] startStatus;\n    public int[][] endStatus;\n    public NodeComparator nodeComparator = new NodeComparator();\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (100,nodeComparator);\n    public List<Node>  close =new ArrayList<Node> ();\n    public Astar(int[][] startStatus, int[][] endStatus )\n    {\n        this.startStatus = new int[3][3];\n        this.endStatus = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startStatus[i][j] = startStatus[i][j];\n                this.endStatus[i][j] = endStatus[i][j];\n            }\n        }\n    }\n\n    private void initStart()\n    {\n        Node startNode = new Node(startStatus);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n//        startNode.fvalue = startNode.gvalue+startNode.hvalue;\n        open.add(startNode);\n    }\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        //????????\\????????????????????¨???????????°?????????????????°???g??? ???????°??????°??¨???g????????????????????????\n        //???????????????????????????????????¢?????°\n        while(newNodeParent != null)\n        {\n            if(lNode.equal(newNodeParent.status))\n            {\n                return true;\n            }\n            newNodeParent = newNodeParent.parent;\n        }\n        return false;\n    }\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        int zeroPosition = 0;//from 0 to 8;\n        zeroPosition = newNode.getZeroPosition();\n\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.status[zeroPosition/3][(zeroPosition%3)-1] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3+1][zeroPosition%3];\n            lNode.status[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n\n\n        }\n\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.status);\n            lNode.status[zeroPosition/3][zeroPosition%3] = lNode.status[zeroPosition/3-1][zeroPosition%3];\n            lNode.status[zeroPosition/3-1][zeroPosition%3] = 0;\n            if(!isInList(lNode,newNode.parent))\n            {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue+1;\n                lNode.hvalue = lNode.getHvalue();\n//                lNode.fvalue = lNode.gvalue+lNode.hvalue;\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n    private void updateNode(List<Node> newNodeChild){\n        for(Node childNode:newNodeChild){\n            if(isOpenIn(childNode,open));\n            else if(isCloseIn(childNode,close));\n            else open.add(childNode);\n        }\n    }\n\n    private boolean isOpenIn(Node newNode, PriorityQueue<Node> openList)\n    {\n        Iterator<Node> iter = openList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                if(newNode.gvalue < iterNode.gvalue)\n                {\n                    iterNode.parent = newNode.parent;\n                    iterNode.gvalue = newNode.gvalue;\n//                    iterNode.fvalue = newNode.fvalue;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean isCloseIn(Node newNode, List<Node> closeList){\n        Iterator<Node> iter = closeList.iterator();\n        while(iter.hasNext())\n        {\n            Node iterNode = iter.next();\n            if(iterNode.equal(newNode.status))\n            {\n                if(newNode.gvalue < iterNode.gvalue)\n                {\n                    iterNode.parent = newNode.parent;\n                    iterNode.gvalue = newNode.gvalue;\n//                    iterNode.fvalue = newNode.fvalue;\n                    iter.remove();\n                    open.add(newNode);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode);\n            if (newNode.equal(endStatus)) {\n                int i = 0;\n                while (newNode != null) {\n                    newNode = newNode.parent;\n                    i += 1;\n                }\n                System.out.println(i - 1);\n                break;\n            }\n            List<Node> newNodeChild = new ArrayList<Node>();\n            initChild(newNode, newNodeChild);\n            updateNode(newNodeChild);\n        }\n    }\n}\n@SuppressWarnings(\"unchencked\")\nclass NodeComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.gvalue+x.hvalue - y.gvalue-y.hvalue;\n    }\n}\nclass Node\n{\n    Node parent;\n    public int[][] status = new int[3][3];\n\n    int gvalue;\n    int hvalue;\n\n    public Node(int[][] status)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.status[i][j] = status[i][j];\n            }\n        }\n    }\n    public int getZeroPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(status[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    public boolean equal(int[][] endStatus)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!= endStatus[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(status[i][j]!=0)\n                    sum+=Math.abs(i-(status[i][j]-1)/3)+Math.abs(j-(status[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(0,i,j,puz))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        c_puz = items[3]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+simpleHS(c_puz)) > depth):\n            continue\n\n        if(_i != 0):\n            heapq.heappush(q,(c_depth+1,_i-1,_j,swapPuz(c_puz[0:],_i,_j,_i-1,_j)))\n        if(_i != 2):\n            heapq.heappush(q,(c_depth+1,_i+1,_j,swapPuz(c_puz[0:],_i,_j,_i+1,_j)))\n        if(_j != 0):\n            heapq.heappush(q,(c_depth+1,_i,_j-1,swapPuz(c_puz[0:],_i,_j,_i,_j-1)))\n        if(_j != 2):\n            heapq.heappush(q,(c_depth+1,_i,_j+1,swapPuz(c_puz[0:],_i,_j,_i,_j+1)))\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(c_puz):\n    value = 0\n    for i in range(len(c_puz)):\n        k = correctPuz.index(c_puz[i])\n        _i = (int)(i/3)\n        _j = i - _i\n        ki = (int)(k/3)\n        kj = k - ki\n        value = abs(_i-ki)+abs(_j-kj) \n\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Java",
    "code": "/**\n * Created by huzhejie on 2016/10/11.\n */\nimport java.util.*;\nimport java.util.List;\n\n/**\n * A* for 8 puzzle\n * f(x) = h(x) +step(g(x))\n * @author huzhejie\n *\n */\n\npublic class Main {\n\n    public static void main(String args[])\n    {\n        int[][] startState=new int[3][3];\n        /*\n        read the data and build the startState two-dimentional array\n         */\n        Scanner sc = new Scanner(System.in);\n        int count = 0;\n        String s;\n        while(count<3){\n            s = sc.nextLine();\n            startState[count][0] = Integer.parseInt(s.split(\" \")[0]);\n            startState[count][1] = Integer.parseInt(s.split(\" \")[1]);\n            startState[count][2] = Integer.parseInt(s.split(\" \")[2]);\n            count++;\n        }\n        Astar test = new Astar(startState);\n        test.run();\n    }\n\n}\nclass Astar\n{\n    /*\n    store the start state\n     */\n    public int[][] startState;\n\n    /*\n    end state\n     */\n    public int[][] endState = {{1,2,3},{4,5,6},{7,8,0}};\n\n    /*\n    node comparator\n     */\n    public NodeOpenListComparator nodeOpenListComparator = new NodeOpenListComparator();\n\n    /*\n    a open list that stores the states that have not been checked\n     */\n    public PriorityQueue<Node> open = new PriorityQueue<Node> (1000, nodeOpenListComparator);\n\n    /*\n    a close list that stores two-dimentional arrays that have been checked\n     */\n    public Set<int[][]>  close =new HashSet<int[][]>();\n\n\n    public Astar(int[][] startState)\n    {\n        this.startState = new int[3][3];\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.startState[i][j] = startState[i][j];\n            }\n        }\n    }\n\n    /**\n     * initialize A* with giving values to the start node(start state)\n     */\n\n    private void initStart()\n    {\n        Node startNode = new Node(startState);\n        startNode.gvalue = 0;\n        startNode.parent = null;\n        startNode.hvalue = startNode.getHvalue();\n        open.add(startNode);\n    }\n\n    /**\n     * check if the node(state) has been checked before\n     * @param lNode\n     * @param newNodeParent\n     * @return\n     */\n    private boolean isInList(Node lNode,Node newNodeParent)\n    {\n        if(newNodeParent != null&&lNode.equal(newNodeParent.state))\n        {\n            return true;\n        }\n        else\n            return false;\n    }\n\n    /**\n     * initialize the child nodes of the new nodes by moving in four diffirent directions\n     * @param newNode\n     * @param newNodeChild\n     */\n    private void initChild(Node newNode,List<Node> newNodeChild)\n    {\n\n        /*\n        zeroPosition is from 0 to 8.\n        e.g. if it is 2,then the position of blank block is (3,1)(third column,first row)\n         */\n        int zeroPosition;\n        zeroPosition = newNode.getBlankPosition();\n\n        /*\n        check if the blank block can be moved leftwards\n         */\n        if((zeroPosition%3) !=2)\n        {\n            Node lNode = new Node(newNode.state);\n            lNode.state[zeroPosition/3][zeroPosition%3] = lNode.state[zeroPosition/3][(zeroPosition%3)+1];\n            lNode.state[zeroPosition/3][(zeroPosition%3)+1] = 0;\n            if(!(isInList(lNode,newNode.parent))) {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue + 1;\n                lNode.hvalue = lNode.getHvalue();\n                newNodeChild.add(lNode);\n            }\n        }\n\n        /*\n        check if the blank block can be moved rightwards\n         */\n        if((zeroPosition%3) !=0)\n        {\n            Node lNode = new Node(newNode.state);\n            lNode.state[zeroPosition/3][zeroPosition%3] = lNode.state[zeroPosition/3][(zeroPosition%3)-1];\n            lNode.state[zeroPosition/3][(zeroPosition%3)-1] = 0;\n\n            if(!(isInList(lNode,newNode.parent))) {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue + 1;\n                lNode.hvalue = lNode.getHvalue();\n                newNodeChild.add(lNode);\n            }\n\n        }\n\n        /*\n        check if the blank block can be moved downwards\n         */\n        if((zeroPosition/3) !=2)\n        {\n            Node lNode = new Node(newNode.state);\n            lNode.state[zeroPosition/3][zeroPosition%3] = lNode.state[zeroPosition/3+1][zeroPosition%3];\n            lNode.state[zeroPosition/3+1][zeroPosition%3] = 0;\n            if(!(isInList(lNode,newNode.parent))) {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue + 1;\n                lNode.hvalue = lNode.getHvalue();\n                newNodeChild.add(lNode);\n            }\n        }\n\n        /*\n        check if the blank block can be moved upwards\n         */\n        if((zeroPosition/3) !=0)\n        {\n            Node lNode = new Node(newNode.state);\n            lNode.state[zeroPosition/3][zeroPosition%3] = lNode.state[zeroPosition/3-1][zeroPosition%3];\n            lNode.state[zeroPosition/3-1][zeroPosition%3] = 0;\n\n            if(!(isInList(lNode,newNode.parent))) {\n                lNode.parent = newNode;\n                lNode.gvalue = newNode.gvalue + 1;\n                lNode.hvalue = lNode.getHvalue();\n                newNodeChild.add(lNode);\n            }\n        }\n    }\n\n    /**\n     * update open list\n     * @param NodeList  the child nodes list of the new node\n     */\n    private void updateOpenList(List<Node> NodeList){\n        for(Node childNode:NodeList) {\n            if (isInCloseList(childNode.state, close));\n            else open.add(childNode);\n        }\n    }\n\n    /**\n     * check if the state is already checked\n     * @param state  the state that is to be checked\n     * @param closeList close list\n     * @return\n     */\n    private boolean isInCloseList(int[][] state, Set<int[][]> closeList)\n    {\n        if(closeList.contains(state)){\n            return true;\n        }\n        else\n            return false;\n    }\n\n    /**\n     *  the main execution part of the A* algorithm\n     */\n    public void run()\n    {\n        initStart();\n        while(!open.isEmpty()) {\n            Node newNode = open.poll();\n            close.add(newNode.state);\n            if (newNode.equal(endState)) {\n                int step = 0;\n                while (newNode.parent!=null) {\n                    newNode = newNode.parent;\n                    step += 1;\n                }\n                System.out.println(step);\n                break;\n            }\n            List<Node> newNodeChild =new ArrayList<Node>();\n            initChild(newNode,newNodeChild);\n            updateOpenList(newNodeChild);\n        }\n    }\n}\n\n/**\n * node comparator\n */\n@SuppressWarnings(\"unchencked\")\nclass NodeOpenListComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node x, Node y) {\n        return x.gvalue+x.hvalue - y.gvalue-y.hvalue;\n    }\n}\n\n\nclass Node\n{\n    /*\n    the prarent node of this node\n     */\n    Node parent;\n\n    /*\n    state of the node\n     */\n    public int[][] state = new int[3][3];\n\n    /*\n    the value of g(x)\n     */\n    int gvalue;\n\n    /*\n    the value of h(x)\n     */\n    int hvalue;\n\n\n    public Node(int[][] state)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                this.state[i][j] = state[i][j];\n            }\n        }\n    }\n\n    /**\n     * get the position of the blank block\n     * @return\n     */\n    public int getBlankPosition()\n    {\n        int k=0;\n        for(int i=0;i<9;i++)\n        {\n            if(state[i/3][i%3] == 0)\n            {\n                k=i;\n                return k;\n            }\n        }\n        return k;\n    }\n\n    /**\n     * check if the state is equal to the end state\n     * @param endState\n     * @return\n     */\n    public boolean equal(int[][] endState)\n    {\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(state[i][j]!= endState[i][j])\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * calculate the h(x) of the node\n     * @return\n     */\n    public int getHvalue()\n    {\n        int sum=0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(state[i][j]!=0)\n                    sum+=Math.abs(i-(state[i][j]-1)/3)+Math.abs(j-(state[i][j]-1)%3);\n            }\n        }\n        return sum;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int N = 3;\n\tstatic int N2 = 9;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tPuzzle in = new Puzzle();\n\t\tScanner scanner = new Scanner(System.in);\n\t\tfor (int i = 0; i < N2; i++) {\n\t\t\tin.f[i] = scanner.nextInt();\n\t\t\tif (in.f[i] == 0) {\n\t\t\t\tin.f[i] = N2;\n\t\t\t\tin.space = i;\n\t\t\t}\n\t\t}\n\t\tString ans = bfs(in);\n\t\tSystem.out.println(ans.length());\n\t}\n\n\tint[] dx = { -1, 0, 1, 0 };\n\tint[] dy = { 0, -1, 0, 1 };\n\tchar[] dir = { 'u', 'l', 'd', 'r' };\n\n\tprivate String bfs(Puzzle s) {\n\t\tDeque<Puzzle> Q = new ArrayDeque<Main.Puzzle>();\n\t\tMap<Puzzle, Boolean> V = new HashMap<Main.Puzzle, Boolean>();\n\t\tPuzzle u = new Puzzle();\n\t\tPuzzle v = new Puzzle();\n\t\ts.path = \"\";\n\t\tQ.push(s);\n\t\tV.put(s, true);\n\t\twhile (!Q.isEmpty()) {\n\t\t\tu = Q.poll();\n\t\t\tif (isTarget(u))\n\t\t\t\treturn u.path;\n\t\t\tint sx = u.space / N;\n\t\t\tint sy = u.space % N;\n\t\t\tfor (int r = 0; r < 4; r++) {\n\t\t\t\tint tx = sx + dx[r];\n\t\t\t\tint ty = sy + dy[r];\n\t\t\t\tif (tx < 0 || ty < 0 || tx >= N || ty >= N)\n\t\t\t\t\tcontinue;\n\t\t\t\tv = (Puzzle) u.clone();\n\t\t\t\tswap(v, u.space, tx * N + ty);\n\t\t\t\tv.space = tx * N + ty;\n\t\t\t\tif (!V.containsKey(v) || !V.get(v)) {\n\t\t\t\t\tV.put(v, true);\n\t\t\t\t\tv.path += dir[r];\n\t\t\t\t\tQ.offer(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn \"unslovable\";\n\t}\n\n\tprivate void swap(Puzzle v, int space, int i) {\n\t\tint tmp = v.f[space];\n\t\tv.f[space] = v.f[i];\n\t\tv.f[i] = tmp;\n\t}\n\n\tprivate boolean isTarget(Puzzle p) {\n\t\tfor (int i = 0; i < N2; i++) {\n\t\t\tif (p.f[i] != (i + 1))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\tclass Puzzle implements Cloneable {\n\t\tint[] f = new int[N2];\n\t\tint space;\n\t\tString path;\n\t\t\n\t\tpublic Puzzle clone() {\n\t\t\ttry {\n\t\t\t\tPuzzle clonePuzzle = (Puzzle) super.clone();\n\t\t\t\tint[] clonef = Arrays.copyOf(f, f.length);\n\t\t\t\tclonePuzzle.f = clonef;\n\t\t\t\treturn clonePuzzle;\n\t\t\t} catch (CloneNotSupportedException e) {\n\t\t\t\tthrow new InternalError(e.toString());\n\t\t\t}\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    final static int LineN=3;\n    final static int FullN=9;\n    final static int[] dx={-1,0,1,0};\n    final static int[] dy={0,-1,0,1};\n    final static long Goalhash=1234567890;\n    final static String[] dir={\"u\",\"l\",\"d\",\"r\"};//up left down right\n    static Queue<Puzzle> que= new ArrayDeque<Puzzle>();\n    static Map<Long,Puzzle> mp= new LinkedHashMap<Long,Puzzle>(16,0.75f,true);\n    public static void main(String[]args){\n\tint i;\n\tString path;\n\tPuzzle nyu= new Puzzle(FullN);\n\tScanner sca = new Scanner(System.in);\n\tfor(i=0;i<FullN;i++){\n\t    nyu.f[i]=sca.nextInt();\n\t    if(nyu.f[i]==0){\n\t\tnyu.f[i]=FullN;//0<->9\n\t\tnyu.space=i;\n\t    }\n\t}\n\tnyu.path=\"\";\n\tpath=play(nyu);\n\tSystem.out.println(path.length());\n    }\n    static long makemyhash(Puzzle p){\n\tint i;\n\tlong ha=0;\n\tfor(i=0;i<FullN;i++){\n\t    ha+=p.f[i];//making hash;\n\t    ha*=10;\n\t}\n\tif(p.f[0]==1&&p.kotei==false)p.kotei=true;//fixing 1 to f[0]\n \treturn ha;\n    }\n    \n    static String play(Puzzle first){\n\tint sx,sy,i,hzi,tx,ty;\n\tlong hzhash;\n\tPuzzle u,v;\n\tque.add(first);\n\tmp.put(makemyhash(first),first);\n\twhile(!que.isEmpty()){\n\t    u=que.poll();\n\t    if(makemyhash(u)==Goalhash)return u.path;\n\t    sx=u.space/LineN;//5->1(calculate x index of 0)\n\t    sy=u.space%LineN;//5->2(calculate y index of 0)\n\t    for(i=0;i<4;i++){\n\t\ttx=sx+dx[i];//calculate movement x\n\t\tty=sy+dy[i];\n\t\tif(tx<0||ty<0||tx>=LineN||ty>=LineN)continue;\n\t      \tif(tx==0&&ty==0&&u.kotei==true)continue;\n\t\tv=myclone(u);\n\t\thzi=v.f[v.space];\n\t\tv.f[v.space]=v.f[tx*LineN+ty];//changing\n\t\tv.f[tx*LineN+ty]=hzi;\n\t\tv.space=tx*LineN+ty;\n\t\tv.hash=hzhash=makemyhash(v);\n\t\tif(mp.containsKey(hzhash)==false){\n\t\t    mp.put(hzhash,v);\n\t\t    v.path+=dir[i];//add char\n\t\t    que.add(v);\n\t       \t}else{\n\t\t}\n\t    }\n\t}\n\treturn \"impossible\";\n    }\n    public static Puzzle myclone(Puzzle p){\n\tint i;\n\tPuzzle im=new Puzzle(FullN);\n\tfor(i=0;i<FullN;i++){\n\t     im.f[i]=p.f[i];\n\t}\n\tim.space=p.space;\n\tim.path=p.path;\n\tim.kotei=p.kotei;\n      \tim.hash=p.hash;\n\treturn im;\n    }\n}\nclass Puzzle{\n     public int f[];\n     public int space;\n     public String path;\n    public long hash;\n    public boolean kotei=false;\n    Puzzle(int n){\n\tf=new int[n];\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Puzzle : IComparable\n    {\n        internal int[] f;\n        internal int space, MD, cost;\n\n        public Puzzle(int n)\n        {\n            f = new int[n];\n            space = MD = cost = default(int);\n        }\n\n        public Puzzle(Puzzle source)\n        {\n            f = (int[])source.f.Clone();\n            space = source.space;\n            MD = source.MD;\n            cost = source.cost;\n        }\n\n        public override int GetHashCode()\n        {\n            return MakeString(f).GetHashCode();\n        }\n\n        public override bool Equals(object obj)\n        {\n            Puzzle other = (Puzzle)obj;\n            return MakeString(f) == MakeString(other.f);\n        }\n\n        public int CompareTo(object obj)\n        {\n            Puzzle other = (Puzzle)obj;\n            return (other.cost + other.MD) - (cost + MD);\n        }\n\n        private string MakeString(int[] arr)\n        {\n            StringBuilder sb = new StringBuilder();\n            foreach (var item in arr) sb.Append(item);\n            return sb.ToString();\n        }\n    }\n\n    class NPuzzle\n    {\n        readonly int n, h, w;\n\n        readonly int[] moveX = new int[] { 0, -1, 0, +1 };\n        readonly int[] moveY = new int[] { -1, 0, +1, 0 };\n        //readonly char[] dir = new char[] { 'u', 'l', 'd', 'r' };\n\n        int[,] MDT;\n\n        public NPuzzle(int h, int w)\n        {\n            this.h = h;\n            this.w = w;\n            n = h * w;\n\n            MDT = new int[n, n];\n\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    MDT[i, j] = Math.Abs(i / h - j / w) + Math.Abs(i % h - j % w);\n        }\n\n        public int Astar(Puzzle p)\n        {\n            PriorityQueue<Puzzle> PQ = new PriorityQueue<Puzzle>();\n            p.MD = GetAllMD(p);\n\n            HashSet<Puzzle> V = new HashSet<Puzzle>();\n\n            PQ.Enqueue(p);\n\n            Puzzle u, v;\n\n            while (PQ.Count() > 0)\n            {\n                u = PQ.Dequeue();\n\n                if (u.MD == 0) return u.cost;\n\n                V.Add(u);\n\n                int sx = u.space % w;\n                int sy = u.space / w;\n\n                for (int r = 0; r < 4; r++)\n                {\n                    int tx = sx + moveX[r];\n                    int ty = sy + moveY[r];\n\n                    if (!IsValid(tx, ty)) continue;\n\n                    v = new Puzzle(u);\n\n                    int indexT = tx + ty * w;\n                    int indexS = sx + sy * w;\n\n                    v.MD -= MDT[indexT, v.f[indexT] - 1];\n                    v.MD += MDT[indexS, v.f[indexT] - 1];\n\n                    int temp = v.f[indexT];\n                    v.f[indexT] = v.f[indexS];\n                    v.f[indexS] = temp;\n\n                    v.space = indexT;\n\n                    if (!V.Contains(v))\n                    {\n                        v.cost++;\n                        PQ.Enqueue(v);\n                    }\n                }\n            }\n            return -1;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0) return false;\n            if (y < 0) return false;\n            if (x >= w) return false;\n            if (y >= h) return false;\n            return true;\n        }\n\n        private int GetAllMD(Puzzle p)\n        {\n            int sum = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                if (p.f[i] != n) sum += MDT[i, p.f[i] - 1];\n            }\n            return sum;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int h = 3, w = 3;\n            int n = h * w;\n\n            NPuzzle NP = new NPuzzle(h, w);\n            Puzzle s = new Puzzle(n);\n\n            for (int i = 0; i < h; i++)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                for (int j = 0; j < w; j++)\n                {\n                    int index = i * w + j;\n                    s.f[index] = input[j];\n\n                    if (input[j] == 0)\n                    {\n                        s.f[index] = n;\n                        s.space = index;\n                    }\n                }\n            }\n            Console.WriteLine(NP.Astar(s));\n        }\n    }\n\n    class PriorityQueue<T> where T : IComparable\n    {\n        List<T> heap;\n        int size;\n\n        public PriorityQueue() { heap = new List<T>(); }\n\n        public void Enqueue(T x)\n        {\n            heap.Add(x);\n            int i = size++;\n\n            while (i > 0)\n            {\n                int p = (i - 1) / 2;\n\n                if (Compare(heap[p], x) <= 0) break;\n\n                heap[i] = heap[p];\n                i = p;\n            }\n            heap[i] = x;\n        }\n\n        public T Dequeue()\n        {\n            T ret = heap[0];\n            T x = heap[--size];\n\n            int i = 0;\n            while (i * 2 + 1 < size)\n            {\n                int a = i * 2 + 1;\n                int b = i * 2 + 2;\n\n                if (b < size && Compare(heap[b], heap[a]) < 0)\n                    a = b;\n                if (Compare(heap[a], x) >= 0)\n                    break;\n\n                heap[i] = heap[a];\n                i = a;\n            }\n            heap[i] = x;\n            heap.RemoveAt(size);\n            return ret;\n        }\n\n        public int Count() { return size; }\n\n        private int Compare(T x, T y) { return y.CompareTo(x); }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 1;\n        while (board.Move(max) == -1)\n        {\n            board = new Board(inputs);\n            max++;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    public int MoveCount { get; set; }\n    \n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        MoveCount = 0;\n    }\n    \n    public Board() { }\n    \n    public int Move(int max)\n    {\n        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToList();\n        \n        empty.AdjacentNumbers\n            .Zip(children, (i, board) => \n            {\n                return board.SwapNode(board.Nodes.First(x => x.Current == 0), board.Nodes.First(x => x.CorrectNumber == i));\n            })\n            .ToArray();\n        \n        if (children.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            return MoveCount;\n        }\n        \n        if (MoveCount == max)\n            return -1;\n        \n        return children.Select(x => x.Move(max))\n            .Where(x => x != -1)\n            .DefaultIfEmpty(-1)\n            .Min();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n        var temp = right.Current;\n        right.Current = left.Current;\n        left.Current = temp;\n        \n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n            MoveCount = board.MoveCount\n        };\n    }\n\n    public string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n}\n\npublic class Node\n{\n    private static Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        LastNumber = -1;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing static System.Console;\nusing System.Text;\nusing System.IO;\n\nnamespace AOJ\n{\n    class Program\n    {\n        static public long[] Sarray() { return ReadLine().Trim().Split().Select(long.Parse).ToArray(); }\n        static public List<long> Slist() { return ReadLine().Split().Select(long.Parse).ToList(); }\n\n        static void Main(string[] args)\n        {\n            var n = 3;\n            var n2 = n * n;\n            var masu = new int[n, n];\n            for (var i = 0; i < n; ++i)\n            {\n                var num = Sarray();\n                for (var j = 0; j < n; ++j)\n                    masu[i, j ] = (int)num[j];\n            }\n            var e = new EPuzzle(masu);\n            WriteLine(e.bfs().Length);\n        }\n        class EPuzzle\n        {\n            public class Puzzle :IEquatable<Puzzle>\n            {\n                public int space;\n                public string path;\n                public int[] f;\n                public Puzzle(int N2, int space, int MD)\n                {\n                    this.space = space;\n                    f = new int[N2];\n                    path = string.Empty;\n                }\n                public Puzzle(Puzzle p)\n                {\n                    space = p.space;\n                    path = p.path;\n                    f = new int[p.f.Length];\n                    Array.Copy(p.f, f, p.f.Length);\n                }\n                public bool Equals(Puzzle other) => this.f.SequenceEqual(other.f);\n                public override int GetHashCode() => f.Aggregate(0, (acc, i) => unchecked(acc * 457 + i * 389));\n            }\n            readonly int[] dx = new int[] { 0, -1, 0, 1 };//Height\n            readonly int[] dy = new int[] { 1, 0, -1, 0 };//Width\n            readonly string dir = \"ruld\";\n            readonly int N;\n            readonly int N2;\n            Puzzle p;\n            public EPuzzle(int[,] inp)\n            {\n                N = inp.GetLength(0);\n                N2 = N * N;\n                p = new Puzzle(N2, 0, 0);\n                for(var i=0;i<N;++i)\n                    for(var j=0;j<N;++j)\n                    {\n                        p.f[i * N + j] = inp[i, j];\n                        if (p.f[i * N + j] == 0)\n                        {\n                            p.space = i * N + j;\n                            p.f[i * N + j] = N2;\n                        }\n                    }\n            }\n            bool isTarget(Puzzle p)\n            {\n                for (var i = 0; i < N2; ++i)\n                    if (p.f[i] != i + 1) return false;\n                return true;\n            }\n            public string bfs()\n            {\n                var Q = new Queue<Puzzle>();\n                var V = new HashSet<Puzzle>();\n\n                Q.Enqueue(p);\n                V.Add(p);\n\n                while(Q.Any())\n                {\n                    var u = Q.Dequeue();\n                    if (isTarget(u)) return u.path;\n                    var sx = u.space / N;\n                    var sy = u.space % N;\n                    for (var r = 0; r < 4; ++r)\n                    {\n                        var tx = sx + dx[r];\n                        var ty = sy + dy[r];\n                        if (tx < 0 || ty < 0 || N <= tx || N <= ty) continue;\n                        var v = new Puzzle(u);\n\n                        v.f[u.space] = v.f[tx * N + ty];\n                        v.f[tx * N + ty] = N2;\n                        v.space = tx * N + ty;\n\n                        if (!V.Contains(v))\n                        {\n                            v.path += dir[r];\n                            V.Add(v);\n                            Q.Enqueue(v);\n                        }\n                    }\n                }\n                return \"unsolvable\";\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n\tpublic string s { get; set; }\n\tpublic int x { get; set; }\n\tpublic int y { get; set; }\n\tpublic int step { get; set; }\n}\n\npublic class hello\n{\n\tpublic static void Main()\n\t{\n\t\tvar map = new int[3, 3];\n\t\tvar sx = 0;  var sy = 0;\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t{\n\t\t\t\tmap[i, j] = int.Parse(line[j]);\n\t\t\t\tif (map[i,j] == 0) { sx = i; sy = j; };\n\t\t\t}\n\t\t}\n\t\tvar ans = goBfs(map, sx, sy);\n\t\tConsole.WriteLine(ans);\n\t}\n\tstatic int goBfs (int [,] map, int sx , int sy)\n\t{\n\t\tvar hs = new HashSet<string>();\n\t\tvar dx = new int[] { 0, 1, 0, -1 };\n\t\tvar dy = new int[] { 1, 0, -1, 0 };\n\t\tvar q = new Queue<P>();\n\t\tvar t = MapToString(map);\n\t\tq.Enqueue(new P { s = t, x = sx,y = sy,step = 0});\n\t\ths.Add(t);\n\t\twhile (q.Count() > 0)\n\t\t{\n\t\t\tvar w = q.Dequeue();\n\t\t\tif (w.s == \"123456780\") return w.step;\n\t\t\tvar tmap = StringToMap(w.s);\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tvar nx = w.x + dx[i];\n\t\t\t\tvar ny = w.y + dy[i];\n\t\t\t\tif (nx >= 0 && nx < 3 && ny >= 0 && ny < 3)\n\t\t\t\t{\n\t\t\t\t\ttmap[w.x, w.y] = tmap[nx, ny];\n\t\t\t\t\ttmap[nx, ny] = 0;\n\t\t\t\t\tvar tt= MapToString(tmap);\n\t\t\t\t\tif (hs.Add(tt)) q.Enqueue(new P { s = tt, x = nx, y = ny, step = w.step + 1 });\n\t\t\t\t\ttmap[nx, ny] = tmap[w.x, w.y];\n\t\t\t\t\ttmap[w.x, w.y] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tstatic string MapToString (int [,] map)\n\t{\n\t\tvar s = \"\";\n\t\tforeach (var x in map) s += x;\n\t\treturn s;\n\t}\n\tstatic int[,] StringToMap (string s)\n\t{\n\t\tvar map = new int[3, 3];\n\t\tvar p = 0;\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t\tmap[i, j] = s[p++] - '0';\n\t\treturn map;\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class Program{\n    public static int N = 3;\n    public static int[] STEPS = new int[]{0, 1, 0, -1, 0};\n    public static void Main(){\n        /*\n        var watch = new Stopwatch();\n        watch.Start();\n        */\n        TextReader reader;\n        string filename = \"\";\n        if(filename.Count()>0) reader = new StreamReader(filename);\n        else reader = Console.In;\n        \n        var Board = new int[N, N];\n        for(int i=0; i<N; i++){\n            var line = reader.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<N; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        \n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var Target = Board2Long(Goal);\n        var queue = new Queue<State>();\n        var all_list = new HashSet<long>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            var longed = Board2Long(curr.table);\n            if(all_list.Contains(longed))continue;\n            all_list.Add(longed);\n            if(longed==Target){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n\n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            for(int i=0; i<4; i++){\n                var nx = cx+STEPS[i+1]; \n                var ny = cy+STEPS[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n        /*\n        watch.Stop();\n        Console.WriteLine($\"????????????{watch.ElapsedMilliseconds}???????§?\");\n        */\n    }\n\n    public static long Board2Long(int[,] board){\n        var keta = board.GetLength(0)*board.GetLength(1)-1;\n        long ret = 0;\n        for(int i=0; i<board.GetLength(0); i++){\n            for(int j=0; j<board.GetLength(1); j++){\n                ret+=board[i,j]*(int)Math.Pow(10, keta-(i*board.GetLength(0)+j));\n            }\n        }\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing CompProgLib;\n\nnamespace ALDS1_13_C\n{\n    public class Program\n\n    {\n        public static void Main(string[] args)\n        {\n            const int VSize = 3;\n            const int HSize = 3;\n            int[,] board = new int[VSize, HSize];\n            NPuzzle np = new NPuzzle();\n\n            for (int i = 0 ; i < VSize ; i++)\n            {\n                int[] tmp = ReadIntAr();\n                for (int j = 0 ; j < HSize ; j++)\n                {\n                    board[i, j] = tmp[j];\n                }\n            }       \n           Console.WriteLine(np.FindShortestRange(board));\n        }\n\n        static string ReadSt() { return Console.ReadLine(); }\n        static int ReadInt() { return int.Parse(Console.ReadLine()); }\n        static long ReadLong() { return long.Parse(Console.ReadLine()); }\n        static double ReadDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] ReadStAr(char sep = ' ') { return Console.ReadLine().Split(sep); }\n        static int[] ReadIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => int.Parse(e)); }\n        static long[] ReadLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => long.Parse(e)); }\n        static double[] ReadDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => double.Parse(e)); }\n\n    }\n\n}\n\nnamespace CompProgLib\n{\n    public class NPuzzle\n    {\n        public int VSize;\n        public int HSize;\n        public const int MAX_DISTANCE = 45;\n\n        public class Node : IComparable<Node>\n        {\n\n            public int[,] Board { get; private set; }\n            public int Distance { get; private set; }\n            public int EvaluationValue { get; private set; }\n\n            public Node(int[,] board, int distance,int evaluationValue)\n            {\n                Board = board;\n                Distance = distance;\n                EvaluationValue = evaluationValue;\n            }\n\n            public int CompareTo(Node other)\n            {\n                return -1 * ((EvaluationValue+ Distance) - (other.EvaluationValue+ other.Distance));\n                //return -1 * ((int)(Math.Pow(EvaluationValue, 0.5) + Distance) - ((int)Math.Pow(other.EvaluationValue, 0.5) + other.Distance)); \n                //return -1 * ((EvaluationValue) - (other.EvaluationValue));\n                //return -1 * ((Distance) - (other.Distance));\n            }\n\n        }\n\n        public int FindShortestRange(int[,] board)\n        {\n\n            //出現した盤面の記録\n            HashSet<int> visited = new HashSet<int>();\n\n            PriorityQueue<Node> pq = new PriorityQueue<Node>();\n            Node start = new Node(board, 0,GetEvaluationValue(board));\n            visited.Add(GetHash(board));\n            pq.Enqueue(start);\n\n            while (pq.Count > 0)\n            {\n                Node tmp = pq.Dequeue();\n                for (int i = 0 ; i < tmp.Board.GetLength(0) ; i++)\n                {\n                    for (int j = 0 ; j < tmp.Board.GetLength(1) ; j++)\n                    {\n                        if (tmp.Board[i, j] == 0)\n                        {\n                            //左移動\n                            if (j != 0)\n                            {\n                                int[,] newBoard = (int[,])tmp.Board.Clone();\n                                newBoard[i, j] = newBoard[i, j - 1];\n                                newBoard[i, j - 1] = 0;\n                                int Hash = GetHash(newBoard);\n                                int evaluationValue = GetEvaluationValue(newBoard);\n                                if (!visited.Contains(Hash) && tmp.Distance + evaluationValue <= MAX_DISTANCE)\n                                {\n                                    visited.Add(Hash);\n                                    pq.Enqueue(new Node(newBoard, tmp.Distance + 1, evaluationValue));\n                                }\n                            }\n\n                            //右移動\n                            if (j != tmp.Board.GetLength(1) - 1)\n                            {\n                                int[,] newBoard = (int[,])tmp.Board.Clone();\n                                newBoard[i, j] = newBoard[i, j + 1];\n                                newBoard[i, j + 1] = 0;\n                                int Hash = GetHash(newBoard);\n                                int evaluationValue = GetEvaluationValue(newBoard);\n                                if (!visited.Contains(Hash) && tmp.Distance + evaluationValue <= MAX_DISTANCE)\n                                {\n                                    visited.Add(Hash);\n                                    pq.Enqueue(new Node(newBoard, tmp.Distance + 1, evaluationValue));\n                                }\n                            }\n\n                            //上移動\n                            if (i != 0)\n                            {\n                                int[,] newBoard = (int[,])tmp.Board.Clone();\n                                newBoard[i, j] = newBoard[i - 1, j];\n                                newBoard[i - 1, j] = 0;\n                                int Hash = GetHash(newBoard);\n                                int evaluationValue = GetEvaluationValue(newBoard);\n                                if (!visited.Contains(Hash) && tmp.Distance + evaluationValue <= MAX_DISTANCE)\n                                {\n                                    visited.Add(Hash);\n                                    pq.Enqueue(new Node(newBoard, tmp.Distance + 1, evaluationValue));\n                                }\n                            }\n\n                            //下移動\n                            if (i != tmp.Board.GetLength(0) - 1)\n                            {\n                                int[,] newBoard = (int[,])tmp.Board.Clone();\n                                newBoard[i, j] = newBoard[i + 1, j];\n                                newBoard[i + 1, j] = 0;\n                                int Hash = GetHash(newBoard);\n                                int evaluationValue = GetEvaluationValue(newBoard);\n                                if (!visited.Contains(Hash) && tmp.Distance + evaluationValue <= MAX_DISTANCE)\n                                {\n                                    visited.Add(Hash);\n                                    pq.Enqueue(new Node(newBoard, tmp.Distance + 1, evaluationValue));\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (tmp.EvaluationValue == 0)\n                {\n                    return tmp.Distance;\n                }\n\n            }\n            return 0;\n        }\n\n        private int GetEvaluationValue(int[,] board)\n        {\n            int res = 0;\n            for (int i = 0 ; i < board.GetLength(0) ; i++)\n            {\n                for (int j = 0 ; j < board.GetLength(1) ; j++)\n                {\n                    if (board[i, j] != 0)\n                    {\n                        res += Math.Abs((board[i, j] - 1) / board.GetLength(1) - i);//縦方向\n                        res += Math.Abs((board[i, j] - 1) % board.GetLength(1) - j);//横方向\n                    }\n                }\n            }\n            return res;\n        }\n\n        private int GetHash(int[,] board)\n        {\n\n            string tmp = \"\";\n            for (int i = 0 ; i < board.GetLength(0) ; i++)\n            {\n                for (int j = 0 ; j < board.GetLength(1) ; j++)\n                {\n                    tmp += board[i, j].ToString(\"0000\");\n                }\n            }\n            return tmp.GetHashCode();\n           // return board.ToString().GetHashCode();\n        }\n    }\n}\n\nnamespace CompProgLib\n{\n    public class PriorityQueue<T> where T : IComparable<T>\n\n    {\n\n        private List<T> Buffer { get; set; }\n\n        public int Count { get { return Buffer.Count; } }\n\n        public PriorityQueue() { Buffer = new List<T>(); }\n        public PriorityQueue(int capacity) { Buffer = new List<T>(capacity); }\n\n\n        /// <summary>\n        /// ヒープ化されている配列リストに新しい要素を追加する。\n        /// </summary>\n        public void Enqueue(T item)\n        {\n            int n = Buffer.Count;\n            Buffer.Add(item);\n\n            while (n != 0)\n            {\n                int i = (n - 1) / 2;\n                if (Buffer[n].CompareTo(Buffer[i]) > 0)\n                {\n                    T tmp = Buffer[n]; Buffer[n] = Buffer[i]; Buffer[i] = tmp;\n                }\n                n = i;\n            }\n        }\n\n        /// <summary>\n        /// ヒープから最大値を取り出し、削除する。\n        /// </summary>\n        public T Dequeue()\n        {\n            T ret = Buffer[0];\n            int n = Buffer.Count - 1;\n            Buffer[0] = Buffer[n];\n            Buffer.RemoveAt(n);\n\n            for (int i = 0, j ; (j = 2 * i + 1) < n ;)\n            {\n                if ((j != n - 1) && (Buffer[j].CompareTo(Buffer[j + 1]) < 0))\n                    j++;\n                if (Buffer[i].CompareTo(Buffer[j]) < 0)\n                {\n                    T tmp = Buffer[j]; Buffer[j] = Buffer[i]; Buffer[i] = tmp;\n                }\n                i = j;\n            }\n            return ret;\n        }\n\n        /// <summary>\n        /// ヒープから最大値を参照する。\n        /// </summary>\n        public T Peek()\n        {\n            if (Count == 0) throw new InvalidOperationException();\n            return this.Buffer[0];\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_13_B_8_Puzzle\n{\n\tclass Program\n\t{\n\t\tstatic void Main ( string[] args )\n\t\t{\n\t\t\t//input\n\t\t\tList<int> input = new List<int> (9);\n\n\t\t\tfor (int lp = 0; lp < 3; lp++)\n\t\t\t{\n\t\t\t\tint[] state = Array.ConvertAll (Console.ReadLine ().Split (' '), int.Parse);\n\t\t\t\tinput.AddRange (state);\n\t\t\t}\n\n\t\t\t//process\n\t\t\tQueue<Puzzle> puzzleQueue = new Queue<Puzzle> (3000);\n\t\t\tEqual equal = new Equal ();\n\t\t\tDictionary<int[], bool> puzzleState = new Dictionary<int[], bool> (3000, equal);\n\n\t\t\tint[] answer = { 1, 2, 3, 4, 5, 6, 7, 8, 0 };\n\n\t\t\tPuzzle p = new Puzzle (input.ToArray (), 0, input.IndexOf (0));\n\t\t\tpuzzleQueue.Enqueue (p);\n\t\t\tpuzzleState.Add (p.Area, true);\n\n\t\t\twhile (puzzleQueue.Count != 0)\n\t\t\t{\n\t\t\t\tPuzzle item = puzzleQueue.Dequeue ();\n\n\t\t\t\tif (Puzzle.IsMatch (item.Area, answer))\n\t\t\t\t{\n\t\t\t\t\tConsole.WriteLine (item.Count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tPuzzle[] next = item.Move (puzzleState);\n\n\t\t\t\tforeach (var element in next)\n\t\t\t\t{\n\t\t\t\t\tpuzzleState.Add (element.Area, true);\n\t\t\t\t\tpuzzleQueue.Enqueue (element);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tclass Puzzle\n\t{\n\t\tpublic Puzzle ( int[] area, int count, int emptyIndex )\n\t\t{\n\t\t\tthis.Area = new int[Length];\n\t\t\tarea.CopyTo (this.Area, 0);\n\t\t\tthis.Count = count;\n\t\t\tthis.EmptyIndex = emptyIndex;\n\t\t}\n\n\t\tpublic int[] Area { private set; get; }\n\t\tpublic int Count { private set; get; }\n\t\tprivate int EmptyIndex { set; get; }\n\n\t\tprivate const int Length = 9;\n\n\t\tpublic Puzzle[] Move ( Dictionary<int[], bool> dictionary )\n\t\t{\n\t\t\tint[] indexArray;\n\t\t\tint createCount = MoveData (EmptyIndex, out indexArray);\n\n\t\t\tList<Puzzle> puzzle = new List<Puzzle> (createCount);\n\n\t\t\tfor (int lp = 0; lp < createCount; lp++)\n\t\t\t{\n\t\t\t\tint index = indexArray[lp];\n\n\t\t\t\tint[] copyArea = new int[Length];\n\t\t\t\tArea.CopyTo (copyArea, 0);\n\n\t\t\t\tvar tmp = copyArea[EmptyIndex];\n\t\t\t\tcopyArea[EmptyIndex] = copyArea[index];\n\t\t\t\tcopyArea[index] = tmp;\n\n\t\t\t\tif (!dictionary.ContainsKey (copyArea))\n\t\t\t\t{\n\t\t\t\t\tpuzzle.Add (new Puzzle (copyArea, Count + 1, index));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn puzzle.ToArray ();\n\t\t}\n\n\t\tpublic static bool IsMatch ( int[] area1, int[] area2 )\n\t\t{\n\t\t\tif (area1.SequenceEqual (area2))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\n\t\tprivate int MoveData ( int emptyIndex, out int[] indexArray )\n\t\t{\n\t\t\tint createCount;\n\n\t\t\tswitch (emptyIndex)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 0;\n\t\t\t\t\tindexArray[1] = 2;\n\t\t\t\t\tindexArray[2] = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 0;\n\t\t\t\t\tindexArray[1] = 4;\n\t\t\t\t\tindexArray[2] = 6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tcreateCount = 4;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 3;\n\t\t\t\t\tindexArray[2] = 5;\n\t\t\t\t\tindexArray[3] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 2;\n\t\t\t\t\tindexArray[1] = 4;\n\t\t\t\t\tindexArray[2] = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 3;\n\t\t\t\t\tindexArray[1] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 4;\n\t\t\t\t\tindexArray[1] = 6;\n\t\t\t\t\tindexArray[2] = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 5;\n\t\t\t\t\tindexArray[1] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcreateCount = -1;\n\t\t\t\t\tindexArray = null;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn createCount;\n\t\t}\n\t}\n\n\tclass Equal : EqualityComparer<int[]>\n\t{\n\t\tpublic override bool Equals ( int[] area1, int[] area2 )\n\t\t{\n\t\t\treturn area1.SequenceEqual (area2);\n\t\t}\n\t\tpublic override int GetHashCode ( int[] item )\n\t\t{\n\t\t\treturn base.GetHashCode ();\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.IO;\nusing System.Collections.Generic;\n\npublic class Program{\n    public static int N = 3;\n    public static int[] STEPS = new int[]{0, 1, 0, -1, 0};\n    public static void Main(){\n\n        var Board = new int[N, N];\n        for(int i=0; i<N; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<N; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        \n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var queue = new Queue<State>();\n        var all_list = new HashSet<long>();\n        var all_dict = new Dictionary<long, int>();\n        \n        //????????????????????´?????????????????????????????£????????????????????¨??????\n        //???????????¢??????????????????1???????????????????????¶??????????§?????????¨????????¢?´¢???????????????-2?????????????°????????????????\n        queue.Enqueue(new State{table = Goal, cnt = -1});\n        queue.Enqueue(new State{table = Board, cnt = 1});\n        all_dict[Board2Long(Goal)] = -1;\n        all_dict[Board2Long(Board)] = 1;\n\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            var longed = Board2Long(curr.table);\n            if(all_list.Contains(longed)){\n                //??¢????????£?????????????????¨????????´?????????????????°?????£???????????°???????????¢?????£????????¨??????????????§??????\n                //????????????????????£??§??????????????§????????´????????????????????????????????????????£????????????????????????????\n                if( (all_dict[longed]<0 && 0<curr.cnt) || curr.cnt<0 && 0<(all_dict[longed]) ){\n                    var other = Math.Abs(all_dict[longed]);\n                    var me = Math.Abs(curr.cnt);\n                    Console.WriteLine(other+me-2);\n                    break;\n                }else{\n                    continue;\n                }\n            }\n            \n            all_list.Add(longed);\n            all_dict[longed] = curr.cnt;\n            \n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            for(int i=0; i<4; i++){\n                var nx = cx+STEPS[i+1]; \n                var ny = cy+STEPS[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n    }\n\n    public static long Board2Long(int[,] board){\n        var keta = board.GetLength(0)*board.GetLength(1)-1;\n        long ret = 0;\n        for(int i=0; i<board.GetLength(0); i++){\n            for(int j=0; j<board.GetLength(1); j++){\n                ret+=board[i,j]*(int)Math.Pow(10, keta-(i*board.GetLength(0)+j));\n            }\n        }\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        var ad = _cnt>0 ? 1 : -1;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=ad, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_13_B_8_Puzzle\n{\n\tclass Program\n\t{\n\t\tstatic void Main ( string[] args )\n\t\t{\n\t\t\t//input\n\t\t\tList<int> input = new List<int> (9);\n\n\t\t\tfor (int lp = 0; lp < 3; lp++)\n\t\t\t{\n\t\t\t\tint[] state = Array.ConvertAll (Console.ReadLine ().Split (' '), int.Parse);\n\t\t\t\tinput.AddRange (state);\n\t\t\t}\n\n\t\t\t//process\n\t\t\tQueue<Puzzle> puzzleQueue = new Queue<Puzzle> (3000);\n\t\t\tEqual equal = new Equal ();\n\t\t\tDictionary<int[], bool> puzzleState = new Dictionary<int[], bool> (3000, equal);\n\n\t\t\tint[] answer = { 1, 2, 3, 4, 5, 6, 7, 8, 0 };\n\n\t\t\tPuzzle p = new Puzzle (input.ToArray (), 0, input.IndexOf (0));\n\t\t\tpuzzleQueue.Enqueue (p);\n\t\t\tpuzzleState.Add (p.Area, true);\n\n\t\t\twhile (puzzleQueue.Count != 0)\n\t\t\t{\n\t\t\t\tPuzzle item = puzzleQueue.Dequeue ();\n\n\t\t\t\tif (Puzzle.IsMatch (item.Area, answer))\n\t\t\t\t{\n\t\t\t\t\tConsole.WriteLine (item.Count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tPuzzle[] next = item.Move (puzzleState);\n\n\t\t\t\tforeach (var element in next)\n\t\t\t\t{\n\t\t\t\t\tpuzzleState.Add (element.Area, true);\n\t\t\t\t\tpuzzleQueue.Enqueue (element);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tclass Puzzle\n\t{\n\t\tpublic Puzzle ( int[] area, int count, int emptyIndex )\n\t\t{\n\t\t\tthis.Area = new int[Length];\n\t\t\tarea.CopyTo (this.Area, 0);\n\t\t\tthis.Count = count;\n\t\t\tthis.EmptyIndex = emptyIndex;\n\t\t}\n\n\t\tpublic int[] Area { private set; get; }\n\t\tpublic int Count { private set; get; }\n\t\tprivate int EmptyIndex { set; get; }\n\n\t\tprivate const int Length = 9;\n\n\t\tpublic Puzzle[] Move ( Dictionary<int[], bool> dictionary )\n\t\t{\n\t\t\tint[] indexArray;\n\t\t\tint createCount = MoveData (EmptyIndex, out indexArray);\n\n\t\t\tList<Puzzle> puzzle = new List<Puzzle> (createCount);\n\n\t\t\tfor (int lp = 0; lp < createCount; lp++)\n\t\t\t{\n\t\t\t\tint index = indexArray[lp];\n\n\t\t\t\tint[] copyArea = new int[Length];\n\t\t\t\tArea.CopyTo (copyArea, 0);\n\n\t\t\t\tvar tmp = copyArea[EmptyIndex];\n\t\t\t\tcopyArea[EmptyIndex] = copyArea[index];\n\t\t\t\tcopyArea[index] = tmp;\n\n\t\t\t\tif (!dictionary.ContainsKey (copyArea))\n\t\t\t\t{\n\t\t\t\t\tpuzzle.Add (new Puzzle (copyArea, Count + 1, index));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn puzzle.ToArray ();\n\t\t}\n\n\t\tpublic static bool IsMatch ( int[] area1, int[] area2 )\n\t\t{\n\t\t\tif (area1.SequenceEqual (area2))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\n\t\tprivate int MoveData ( int emptyIndex, out int[] indexArray )\n\t\t{\n\t\t\tint createCount;\n\n\t\t\tswitch (emptyIndex)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 0;\n\t\t\t\t\tindexArray[1] = 2;\n\t\t\t\t\tindexArray[2] = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 0;\n\t\t\t\t\tindexArray[1] = 4;\n\t\t\t\t\tindexArray[2] = 6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tcreateCount = 4;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 3;\n\t\t\t\t\tindexArray[2] = 5;\n\t\t\t\t\tindexArray[3] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 2;\n\t\t\t\t\tindexArray[1] = 4;\n\t\t\t\t\tindexArray[2] = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 3;\n\t\t\t\t\tindexArray[1] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 4;\n\t\t\t\t\tindexArray[1] = 6;\n\t\t\t\t\tindexArray[2] = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 5;\n\t\t\t\t\tindexArray[1] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcreateCount = -1;\n\t\t\t\t\tindexArray = null;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn createCount;\n\t\t}\n\t}\n\n\tclass Equal : EqualityComparer<int[]>\n\t{\n\t\tpublic override bool Equals ( int[] area1, int[] area2 )\n\t\t{\n\t\t\treturn area1.SequenceEqual (area2);\n\t\t}\n\t\tpublic override int GetHashCode ( int[] item )\n\t\t{\n\t\t\t//return base.GetHashCode ();\n\t\t\treturn item[0] + item[1] * 10 + item[2] * 100 + item[3] * 1000;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 0;\n        var boards = new [] {board};\n//        var sw = new Stopwatch();\n        while (true)\n        {\n            max++;\n//            max.Dump(\"?????????max?????????\");\n//            sw.Restart();\n            boards = boards.SelectMany(x => x.Move(max))\n                .ToArray();\n//            sw.Stop();\n//            sw.ElapsedMilliseconds.Dump(\"move\");\n//            sw.Restart();\n            if (boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n                break;\n//            sw.Stop();\n//            sw.ElapsedMilliseconds.Dump(\"all\");\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    private int MoveCount { get; set; }\n    static HashSet<Board> hash;\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        hash = new HashSet<Board>(); \n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n        MoveCount++;\n        \n//        var sw = Stopwatch.StartNew();\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n//        sw.Stop();\n//        sw.ElapsedMilliseconds.Dump(\"clone\");\n//        sw.Restart();\n        \n        empty.AdjacentNumbers\n            .Select((adj, i) => \n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                if (left.LastNumber == right.Current)\n                {\n                    children[i] = null;\n                    return 0;\n                }\n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board))\n                    children[i] = null;\n                return 0;\n            })\n            .ToArray();\n        \n//        if (children.Where(x => x != null).Any(x => x.Nodes.All(node => node.IsCorrect())))\n//        {\n//            return children.Where(x => x != null).Where(x => x.Nodes.All(node => node.IsCorrect())).ToArray();\n//        }\n            return children.Where(x => x != null).ToArray();\n        \n//        if (MoveCount == max)\n//            return children.Where(x => x != null).ToArray();\n//        \n//        return children.Where(x => x != null)\n//            .SelectMany(x => x.Move(max))\n//            .ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n        left.LastNumber = left.Current;\n        right.LastNumber = right.Current;\n\n        left.Current = right.LastNumber;\n        right.Current = left.LastNumber;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n    \n    public override int GetHashCode()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n    public override bool Equals(Object o)\n    {\n        return Equals((Board)o);\n    }\n    public bool Equals(Board other)\n    {\n        return ToString() == other.ToString();\n    }\n}\n\npublic class Node\n{\n    private static Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 1;\n        while (board.Move(max) == -1)\n        {\n            board = new Board(inputs);\n            max++;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    public int MoveCount { get; set; }\n    \n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        MoveCount = 0;\n    }\n    \n    public Board() { }\n    \n    public int Move(int max)\n    {\n        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .Select((number, i) => \n            {\n                var board = children[i];\n                return board.SwapNode(board.Nodes.First(x => x.Current == 0), board.Nodes.First(x => x.CorrectNumber == i));\n            })\n            .ToArray();\n        \n        if (children.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            return MoveCount;\n        }\n        \n        if (MoveCount == max)\n            return -1;\n        \n        return children.Select(x => x.Move(max))\n            .Where(x => x != -1)\n            .DefaultIfEmpty(-1)\n            .Min();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n        var temp = right.Current;\n        right.Current = left.Current;\n        left.Current = temp;\n        \n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n}\n\npublic class Node\n{\n    private static Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        LastNumber = -1;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_13_B2\n{\n    class Program\n    {\n        static int[] dx = { -1, 0, 1, 0 };\n        static int[] dy = { 0, -1, 0, 1 };\n\n        static void Main(string[] args)\n        {\n            var cnt = 0;\n            int[] Puzzle = new int[11];\n            for (int i = 0; i < 3; i++)\n            {\n                var k = scan;\n                for (int j = 0; j < 3; j++)\n                {\n                    Puzzle[cnt++] = k[j];\n                    if (k[j] == 0)\n                    {\n                        Puzzle[cnt - 1] = 9;\n                        Puzzle[9] = cnt - 1;\n                    } \n                }\n            }\n            bfs(Puzzle);\n            \n        }\n        static void bfs(int[] s)\n        {\n            //index 0-10\n            var Q = new Queue<string>();\n            //index 0-8\n            var V = new HashSet<string>();\n            \n            Q.Enqueue(string.Join(\" \",s));\n            V.Add(string.Join(\" \",s.Take(9)));\n            \n            while (Q.Any())\n            {\n                int[] u = Q.Dequeue().Split().Select(int.Parse).ToArray();\n                //Console.WriteLine(string.Concat(u));\n                if (string.Concat(u.Take(9)) == \"123456789\")\n                {\n                    Console.WriteLine(u[10]);\n                    return;\n                }\n                int sx = u[9] / 3;\n                int sy = u[9] % 3;\n                for (int r = 0; r <= 3; r++)\n                {\n                    int tx = sx + dx[r];\n                    int ty = sy + dy[r];\n                    if (tx < 0 || ty < 0 || tx >= 3 || ty >= 3) continue;\n\n                    var position = (tx * 3 + ty);\n                    var nowspace = u[9];\n\n                    swap(u, position, nowspace);\n                    u[9] = position;\n                    var k = string.Join(\" \", u.Take(9));\n\n                    if (!V.Contains(k))\n                    {\n                        V.Add(k);\n                        u[10]++;\n                        Q.Enqueue(string.Join(\" \", u));\n                        u[10]--;\n                    }\n                    u[9] = nowspace;\n                    swap(u, position, nowspace);\n\n                }\n                //Console.WriteLine(string.Join(\" & \",Q));\n            }\n            Console.WriteLine(\"WA\");\n        }\n        static void swap(int[] s, int x, int y)\n        {\n            var t = s[x];\n            s[x] = s[y];\n            s[y] = t;\n        }\n        static int[] scan { get { return Array.ConvertAll(Console.ReadLine().Split(), int.Parse); } }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 0;\n        var boards = new [] {board};\n        \n        while (true)\n        {\n            max++;\n            \"move\".Measure(() => {\n                boards = boards.SelectMany(x => x.Move(max))\n                    .ToArray();\n            });\n            \n            var correct = false;\n            \"correct\".Measure(() => {\n                correct = boards.Any(x => x.Nodes.All(node => node.IsCorrect()));\n            });\n            \n            if (correct) break;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n//    private int MoveCount { get; set; }\n    static HashSet<int> hash;\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        hash = new HashSet<int>(); \n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n//        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n//                if (left.LastNumber == right.Current)\n//                {\n//                    children[i] = null;\n//                }\n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHashCode()))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n//        left.LastNumber = left.Current;\n//        right.LastNumber = right.Current;\n//\n//        left.Current = right.LastNumber;\n//        right.Current = left.LastNumber;\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n//            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n    \n    public override int GetHashCode()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n    public override bool Equals(Object o)\n    {\n        return Equals((Board)o);\n    }\n    public bool Equals(Board other)\n    {\n        return ToString() == other.ToString();\n    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n//    public int LastNumber { get; set; }\n    private int[] an;\n    public int[] AdjacentNumbers { get { return an; } }\n\n    public Node(int correct, int current)//, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        an = adjacentNumbersDic[correct];\n//        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);//, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var queue = new Queue<State>();\n        var all_list = new List<string>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        int c = 0;\n        while(queue.Count()>0&&c<500){\n            var curr = queue.Dequeue();\n            //Print(curr.table);\n            if(all_list.Contains(ToStringForList(curr.table)))continue;\n            else all_list.Add(ToStringForList(curr.table));\n            if(curr.table.ContentEqual(Goal)){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n            \n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i]; \n                var ny = cy+steps[i+1];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n            c++;\n        }\n        \n    }\n    \n    public static string ToStringForList(int[,] map){\n        var ret=\"\";\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret+=map[i, j];\n            }\n        }\n        return ret;\n    }\n    \n    /*\n    AOJ C# compiler is considered old version, so \"$\" keyword cant use. fuck.\n    public static void Print(int[,] map){\n        Console.WriteLine(new string(Enumerable.Repeat('-', 10).ToArray()));\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                //Console.Write($\"{map[i, j]} \");\n            }\n            Console.WriteLine();\n        }\n    }\n    */\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n    \n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}\n\npublic static class Exclass{\n    public static bool ContentEqual<T>(this T[,] array, T[,] other)where T : IComparable\n    {\n        if(array.GetLength(0)!=other.GetLength(0) || array.GetLength(1)!=other.GetLength(1)) return false;\n        for(int i=0; i<array.GetLength(0); i++){\n            for(int j=0; j<array.GetLength(1); j++){\n                if(array[i, j].CompareTo(other[i, j])!=0) return false;\n            }\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 0;\n        var boards = new [] {board};\n        \n        while (true)\n        {\n            max++;\n            boards = boards.SelectMany(x => x.Move(max))\n                .ToArray();\n            \n            if (boards.Any(x => x.Nodes.All(node => node.IsCorrect()))) break;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n//    private int MoveCount { get; set; }\n    static HashSet<int> hash;\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        hash = new HashSet<int>(); \n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n//        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n//                if (left.LastNumber == right.Current)\n//                {\n//                    children[i] = null;\n//                }\n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHashCode()))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n//        left.LastNumber = left.Current;\n//        right.LastNumber = right.Current;\n//\n//        left.Current = right.LastNumber;\n//        right.Current = left.LastNumber;\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n//            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n    \n    public override int GetHashCode()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n    public override bool Equals(Object o)\n    {\n        return Equals((Board)o);\n    }\n    public bool Equals(Board other)\n    {\n        return ToString() == other.ToString();\n    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n//    public int LastNumber { get; set; }\n    private int[] an;\n    public int[] AdjacentNumbers { get { return an; } }\n\n    public Node(int correct, int current)//, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        an = adjacentNumbersDic[correct];\n//        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);//, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        int sx, sy;\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n                if(line[j]==0){\n                    sx = j;\n                    sy = i;\n                }\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var queue = new Queue<State>();\n        var all_list = new List<string>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        int c = 0;\n        while(queue.Count()>0&&c<500){\n            var curr = queue.Dequeue();\n            //Print(curr.table);\n            if(all_list.Contains(ToStringForList(curr.table)))continue;\n            else all_list.Add(ToStringForList(curr.table));\n            if(curr.table.ContentEqual(Goal)){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n            \n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i]; \n                var ny = cy+steps[i+1];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n            c++;\n        }\n        \n    }\n    \n    public static string ToStringForList(int[,] map){\n        var ret=\"\";\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret+=map[i, j];\n            }\n        }\n        return ret;\n    }\n    \n    /*\n    AOJ C# compiler is considered old version, so \"$\" keyword cant use. fuck.\n    public static void Print(int[,] map){\n        Console.WriteLine(new string(Enumerable.Repeat('-', 10).ToArray()));\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                //Console.Write($\"{map[i, j]} \");\n            }\n            Console.WriteLine();\n        }\n    }\n    */\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n    \n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}\n\npublic static class Exclass{\n    public static bool ContentEqual<T>(this T[,] array, T[,] other)where T : IComparable\n    {\n        if(array.GetLength(0)!=other.GetLength(0) || array.GetLength(1)!=other.GetLength(1)) return false;\n        for(int i=0; i<array.GetLength(0); i++){\n            for(int j=0; j<array.GetLength(1); j++){\n                if(array[i, j].CompareTo(other[i, j])!=0) return false;\n            }\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 0;\n        var boards = new [] {board};\n        while (true)\n        {\n            max++;\n            boards = boards.SelectMany(x => x.Move(max))\n                .ToArray();\n\n            if (boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n                break;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    private int MoveCount { get; set; }\n    static HashSet<Board> hash;\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        hash = new HashSet<Board>(); \n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                if (left.LastNumber == right.Current)\n                {\n                    children[i] = null;\n                }\n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n        left.LastNumber = left.Current;\n        right.LastNumber = right.Current;\n\n        left.Current = right.LastNumber;\n        right.Current = left.LastNumber;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n    \n    public override int GetHashCode()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n    public override bool Equals(Object o)\n    {\n        return Equals((Board)o);\n    }\n    public bool Equals(Board other)\n    {\n        return ToString() == other.ToString();\n    }\n}\n\npublic class Node\n{\n    private static Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Puzzle\n    {\n        internal int[] f;\n        internal int space, MD;\n\n        public Puzzle(int n)\n        {\n            f = new int[n];\n        }\n\n        public Puzzle(Puzzle other)\n        {\n            f = (int[])other.f.Clone();\n\n            space = other.space;\n            MD = other.MD;\n        }\n    }\n\n    class NPuzzle\n    {\n        readonly int Limit = 50;\n        readonly int n, h, w;\n\n        readonly int[] moveX = new int[] { 0, -1, 0, +1 };\n        readonly int[] moveY = new int[] { -1, 0, +1, 0 };\n        readonly char[] dir = new char[] { 'u', 'l', 'd', 'r' };\n\n        int limit;\n        int[] path;\n        int[,] MDT;\n\n        public NPuzzle(int h, int w)\n        {\n            this.h = h;\n            this.w = w;\n            n = h * w;\n\n            MDT = new int[n, n];\n            path = new int[Limit];\n\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    MDT[i, j] = Math.Abs(i / h - j / w) + Math.Abs(i % h - j % w);\n                }\n            }\n        }\n\n        public string IterativeDeeping(Puzzle p)\n        {\n            StringBuilder ret = new StringBuilder();\n            Puzzle state;\n\n            p.MD = GetAllMD(p);\n\n            for (limit = p.MD; limit <= Limit; limit++)\n            {\n                state = new Puzzle(p);\n\n                if (DFS(state, 0, -50))\n                {\n                    for (int i = 0; i < limit; i++)\n                    {\n                        ret.Append(dir[path[i]]);\n                    }\n                    return ret.ToString();\n                }\n            }\n            return null;\n        }\n\n        private bool DFS(Puzzle state, int depth, int prev)\n        {\n            if (state.MD == 0) return true;\n\n            if (depth + state.MD > limit) return false;\n\n            int sx = state.space % w;\n            int sy = state.space / w;\n\n            Puzzle tempState;\n\n            for (int r = 0; r < 4; r++)\n            {\n                int tx = sx + moveX[r];\n                int ty = sy + moveY[r];\n\n                if (!IsValid(tx, ty)) continue;\n\n                if (Math.Abs(prev - r) == 2) continue;\n\n                tempState = new Puzzle(state);\n\n                int indexT = tx + ty * w;\n                int indexS = sx + sy * w;\n\n                state.MD -= MDT[indexT, state.f[indexT] - 1];\n                state.MD += MDT[indexS, state.f[indexT] - 1];\n\n                int temp = state.f[indexT];\n                state.f[indexT] = state.f[indexS];\n                state.f[indexS] = temp;\n\n                state.space = indexT;\n\n                if (DFS(state, depth + 1, r))\n                {\n                    path[depth] = r;\n                    return true;\n                }\n\n                state = new Puzzle(tempState);\n            }\n            return false;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0) return false;\n            if (y < 0) return false;\n            if (x >= w) return false;\n            if (y >= h) return false;\n            return true;\n        }\n\n        private int GetAllMD(Puzzle p)\n        {\n            int sum = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                if (p.f[i] != n) sum += MDT[i, p.f[i] - 1];\n            }\n            return sum;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int h = 3, w = 3;\n            int n = h * w;\n\n            NPuzzle NP = new NPuzzle(h, w);\n            Puzzle s = new Puzzle(n);\n\n            for (int i = 0; i < h; i++)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                for (int j = 0; j < w; j++)\n                {\n                    int index = i * w + j;\n                    s.f[index] = input[j];\n\n                    if (input[j] == 0)\n                    {\n                        s.f[index] = n;\n                        s.space = index;\n                    }\n                }\n            }\n\n            string ans = NP.IterativeDeeping(s);\n\n            Console.WriteLine(ans != null ? ans.Length : 0);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Threading;\n\npublic class Parallel\n{\n    public static void ForEach<T>(IEnumerable<T> items, Action<T> action)\n    {\n        if (items == null)\n            throw new ArgumentNullException(\"enumerable\");\n        if (action == null)\n            throw new ArgumentNullException(\"action\");\n\n        var resetEvents = new List<ManualResetEvent>();\n\n        foreach (var item in items)\n        {\n            var evt = new ManualResetEvent(false);\n            ThreadPool.QueueUserWorkItem((i) =>\n            {\n                action((T)i);\n                evt.Set();\n            }, item);\n            resetEvents.Add(evt);\n        }\n\n        foreach (var re in resetEvents)\n            re.WaitOne();\n    }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        ThreadPool.SetMinThreads(8, 8);\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var count = 0;\n        var boards = new [] { new Board(inputs) };\n        while (!boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            count++;\n            boards = boards.SelectMany(x => x.Move())\n                .ToArray();\n        }\n        \n        Console.WriteLine(count);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    static HashSet<int> hash = new HashSet<int>();\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n    }\n    \n    public Board() { }\n    \n    public Board[] Move()\n    {\n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        Parallel.ForEach(Enumerable.Range(0, empty.AdjacentNumbers.Count()),\n            i =>\n            {\n                var adj = empty.AdjacentNumbers[i];\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHash()))\n                    children[i] = null;\n            });\n//        empty.AdjacentNumbers\n//            .ForEach((adj, i) =>\n//            {\n//                var board = children[i];\n//                var left = board.Nodes.First(x => x.Current == 0);\n//                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n//                \n//                board.SwapNode(left, right);\n//                \n//                if (!hash.Add(board.GetHash()))\n//                    children[i] = null;\n//            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public void SwapNode(Node left, Node right)\n    {\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n        };\n    }\n\n//    public override string ToString()\n//    {\n//        return Nodes.Select(x => x.Current)\n//            .Select(x => x.ToString())\n//            .Aggregate((acc, x) => acc + \" \" + x);\n//    }\n    \n    public int GetHash()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n//    public override bool Equals(Object o)\n//    {\n//        return Equals((Board)o);\n//    }\n//    public bool Equals(Board other)\n//    {\n//        return ToString() == other.ToString();\n//    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int[] AdjacentNumbers { get; set; }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        AdjacentNumbers = adjacentNumbersDic[correct];\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Puzzle : IComparable\n    {\n        internal int[] f;\n        internal int space, MD, cost;\n\n        public Puzzle(int n)\n        {\n            f = new int[n];\n            space = MD = cost = default(int);\n        }\n\n        public Puzzle(Puzzle source)\n        {\n            f = (int[])source.f.Clone();\n            space = source.space;\n            MD = source.MD;\n            cost = source.cost;\n        }\n\n        public override int GetHashCode()\n        {\n            return string.Join(\"\", f).GetHashCode();\n        }\n\n        public override bool Equals(object obj)\n        {\n            Puzzle other = (Puzzle)obj;\n            return string.Join(\"\", f) == string.Join(\"\", other.f);\n        }\n\n        public int CompareTo(object obj)\n        {\n            Puzzle other = (Puzzle)obj;\n            return (other.cost + other.MD) - (cost + MD);\n        }\n    }\n\n    class NPuzzle\n    {\n        readonly int n, h, w;\n\n        readonly int[] moveX = new int[] { 0, -1, 0, +1 };\n        readonly int[] moveY = new int[] { -1, 0, +1, 0 };\n        readonly char[] dir = new char[] { 'u', 'l', 'd', 'r' };\n\n        int[,] MDT;\n\n        public NPuzzle(int h, int w)\n        {\n            this.h = h;\n            this.w = w;\n            n = h * w;\n\n            MDT = new int[n, n];\n\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    MDT[i, j] = Math.Abs(i / h - j / w) + Math.Abs(i % h - j % w);\n        }\n\n        public int Astar(Puzzle p)\n        {\n            PriorityQueue<Puzzle> PQ = new PriorityQueue<Puzzle>();\n            p.MD = GetAllMD(p);\n\n            HashSet<Puzzle> V = new HashSet<Puzzle>();\n\n            PQ.Enqueue(p);\n\n            Puzzle u, v;\n\n            while (PQ.Count() > 0)\n            {\n                u = PQ.Dequeue();\n\n                if (u.MD == 0) return u.cost;\n\n                V.Add(u);\n\n                int sx = u.space % w;\n                int sy = u.space / w;\n\n                for (int r = 0; r < 4; r++)\n                {\n                    int tx = sx + moveX[r];\n                    int ty = sy + moveY[r];\n\n                    if (!IsValid(tx, ty)) continue;\n\n                    v = new Puzzle(u);\n\n                    int indexT = tx + ty * w;\n                    int indexS = sx + sy * w;\n\n                    v.MD -= MDT[indexT, v.f[indexT] - 1];\n                    v.MD += MDT[indexS, v.f[indexT] - 1];\n\n                    int temp = v.f[indexT];\n                    v.f[indexT] = v.f[indexS];\n                    v.f[indexS] = temp;\n\n                    v.space = indexT;\n\n                    if (!V.Contains(v))\n                    {\n                        v.cost++;\n                        PQ.Enqueue(v);\n                    }\n                }\n            }\n            return -1;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0) return false;\n            if (y < 0) return false;\n            if (x >= w) return false;\n            if (y >= h) return false;\n            return true;\n        }\n\n        private int GetAllMD(Puzzle p)\n        {\n            int sum = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                if (p.f[i] != n) sum += MDT[i, p.f[i] - 1];\n            }\n            return sum;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int h = 3, w = 3;\n            int n = h * w;\n\n            NPuzzle NP = new NPuzzle(h, w);\n            Puzzle s = new Puzzle(n);\n\n            for (int i = 0; i < h; i++)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                for (int j = 0; j < w; j++)\n                {\n                    int index = i * w + j;\n                    s.f[index] = input[j];\n\n                    if (input[j] == 0)\n                    {\n                        s.f[index] = n;\n                        s.space = index;\n                    }\n                }\n            }\n            Console.WriteLine(NP.Astar(s));\n        }\n    }\n\n    class PriorityQueue<T> where T : IComparable\n    {\n        List<T> heap;\n        int size;\n\n        public PriorityQueue() { heap = new List<T>(); }\n\n        public void Enqueue(T x)\n        {\n            heap.Add(x);\n            int i = size++;\n\n            while (i > 0)\n            {\n                int p = (i - 1) / 2;\n\n                if (Compare(heap[p], x) <= 0) break;\n\n                heap[i] = heap[p];\n                i = p;\n            }\n            heap[i] = x;\n        }\n\n        public T Dequeue()\n        {\n            T ret = heap[0];\n            T x = heap[--size];\n\n            int i = 0;\n            while (i * 2 + 1 < size)\n            {\n                int a = i * 2 + 1;\n                int b = i * 2 + 2;\n\n                if (b < size && Compare(heap[b], heap[a]) < 0)\n                    a = b;\n                if (Compare(heap[a], x) >= 0)\n                    break;\n\n                heap[i] = heap[a];\n                i = a;\n            }\n            heap[i] = x;\n            heap.RemoveAt(size);\n            return ret;\n        }\n\n        public int Count() { return size; }\n\n        private int Compare(T x, T y) { return y.CompareTo(x); }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var queue = new Queue<State>();\n        var all_list = new List<string>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        int c = 0;\n        while(queue.Count()>0&&c<500){\n            var curr = queue.Dequeue();\n            //Print(curr.table);\n            if(all_list.Contains(ToStringForList(curr.table)))continue;\n            else all_list.Add(ToStringForList(curr.table));\n            if(curr.table.ContentEqual(Goal)){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n            \n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i]; \n                var ny = cy+steps[i+1];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n            c++;\n        }\n        \n    }\n    \n    public static string ToStringForList(int[,] map){\n        var ret=\"\";\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret+=map[i, j];\n            }\n        }\n        return ret;\n    }\n    \n    /*\n    AOJ C# compiler is considered old version, so \"$\" keyword cant use. fuck.\n    public static void Print(int[,] map){\n        Console.WriteLine(new string(Enumerable.Repeat('-', 10).ToArray()));\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                //Console.Write($\"{map[i, j]} \");\n            }\n            Console.WriteLine();\n        }\n    }\n    */\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n    \n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}\n\npublic static class Exclass{\n    public static bool ContentEqual<T>(this T[,] array, T[,] other)where T : IComparable\n    {\n        if(array.GetLength(0)!=other.GetLength(0) || array.GetLength(1)!=other.GetLength(1)) return false;\n        for(int i=0; i<array.GetLength(0); i++){\n            for(int j=0; j<array.GetLength(1); j++){\n                if(array[i, j].CompareTo(other[i, j])!=0) return false;\n            }\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var StrGoal = ToStringForList(Goal);\n        var queue = new Queue<State>();\n        var all_list = new HashSet<string>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            \n            // Console.WriteLine(all_list.Count());\n            if(ToStringForList(curr.table)==StrGoal){\n                Console.WriteLine(curr.cnt);\n                Console.WriteLine(all_list.Count());\n                break;\n            }\n\n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i+1]; \n                var ny = cy+steps[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    // Console.WriteLine(ToStringForList(curr.table) + \" -> \" + ToStringForList(NexMap.table));\n                    if(all_list.Contains(ToStringForList(NexMap.table)))continue;\n                    all_list.Add(ToStringForList(NexMap.table));\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n\n    }\n\n    public static string ToStringForList(int[,] map){\n        var ret=\"\";\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret+=map[i, j];\n            }\n        }\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Threading;\n\npublic class Parallel\n{\n    public static void ForEach<T>(IEnumerable<T> items, Action<T> action)\n    {\n        if (items == null)\n            throw new ArgumentNullException(\"enumerable\");\n        if (action == null)\n            throw new ArgumentNullException(\"action\");\n\n        var resetEvents = new List<ManualResetEvent>();\n\n        foreach (var item in items)\n        {\n            var evt = new ManualResetEvent(false);\n            ThreadPool.QueueUserWorkItem((i) =>\n            {\n                action((T)i);\n                evt.Set();\n            }, item);\n            resetEvents.Add(evt);\n        }\n\n        foreach (var re in resetEvents)\n            re.WaitOne();\n    }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var count = 0;\n        var boards = new [] { new Board(inputs) };\n        while (!boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            count++;\n            boards = boards.SelectMany(x => x.Move())\n                .ToArray();\n        }\n        \n        Console.WriteLine(count);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    static HashSet<int> hash = new HashSet<int>();\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n    }\n    \n    public Board() { }\n    \n    public Board[] Move()\n    {\n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        Parallel.ForEach(Enumerable.Range(0, empty.AdjacentNumbers.Count()),\n            i =>\n            {\n                var adj = empty.AdjacentNumbers[i];\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHash()))\n                    children[i] = null;\n            });\n//        empty.AdjacentNumbers\n//            .ForEach((adj, i) =>\n//            {\n//                var board = children[i];\n//                var left = board.Nodes.First(x => x.Current == 0);\n//                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n//                \n//                board.SwapNode(left, right);\n//                \n//                if (!hash.Add(board.GetHash()))\n//                    children[i] = null;\n//            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public void SwapNode(Node left, Node right)\n    {\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n        };\n    }\n\n//    public override string ToString()\n//    {\n//        return Nodes.Select(x => x.Current)\n//            .Select(x => x.ToString())\n//            .Aggregate((acc, x) => acc + \" \" + x);\n//    }\n    \n    public int GetHash()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n//    public override bool Equals(Object o)\n//    {\n//        return Equals((Board)o);\n//    }\n//    public bool Equals(Board other)\n//    {\n//        return ToString() == other.ToString();\n//    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int[] AdjacentNumbers { get; set; }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        AdjacentNumbers = adjacentNumbersDic[correct];\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 0;\n        var boards = new [] {board};\n        \n        while (true)\n        {\n            max++;\n            boards = boards.SelectMany(x => x.Move(max))\n                .ToArray();\n            \n            if (boards.Any(x => x.Nodes.All(node => node.IsCorrect()))) break;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n//    private int MoveCount { get; set; }\n    static HashSet<int> hash;\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        hash = new HashSet<int>(); \n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n//        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n//                if (left.LastNumber == right.Current)\n//                {\n//                    children[i] = null;\n//                }\n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHashCode()))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n//        left.LastNumber = left.Current;\n//        right.LastNumber = right.Current;\n//\n//        left.Current = right.LastNumber;\n//        right.Current = left.LastNumber;\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n//            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n    \n    public override int GetHashCode()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n    public override bool Equals(Object o)\n    {\n        return Equals((Board)o);\n    }\n    public bool Equals(Board other)\n    {\n        return ToString() == other.ToString();\n    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n//    public int LastNumber { get; set; }\n    private int[] an;\n    public int[] AdjacentNumbers { get { return an; } }\n\n    public Node(int correct, int current)//, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        an = adjacentNumbersDic[correct];\n//        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);//, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Threading;\n\npublic class Parallel\n{\n    public static void ForEach<T>(IEnumerable<T> items, Action<T> action)\n    {\n        if (items == null)\n            throw new ArgumentNullException(\"enumerable\");\n        if (action == null)\n            throw new ArgumentNullException(\"action\");\n\n        var resetEvents = new List<ManualResetEvent>();\n\n        foreach (var item in items)\n        {\n            var evt = new ManualResetEvent(false);\n            ThreadPool.QueueUserWorkItem((i) =>\n            {\n                action((T)i);\n                evt.Set();\n            }, item);\n            resetEvents.Add(evt);\n        }\n\n        WaitHandle.WaitAll(resetEvents);\n    }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var count = 0;\n        var boards = new [] { new Board(inputs) };\n        while (!boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            count++;\n            boards = boards.SelectMany(x => x.Move())\n                .ToArray();\n        }\n        \n        Console.WriteLine(count);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    static HashSet<int> hash = new HashSet<int>();\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n    }\n    \n    public Board() { }\n    \n    public Board[] Move()\n    {\n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        Parallel.ForEach(Enumerable.Range(0, empty.AdjacentNumbers.Count()),\n            i =>\n            {\n                var adj = empty.AdjacentNumbers[i];\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHash()))\n                    children[i] = null;\n            });\n//        empty.AdjacentNumbers\n//            .ForEach((adj, i) =>\n//            {\n//                var board = children[i];\n//                var left = board.Nodes.First(x => x.Current == 0);\n//                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n//                \n//                board.SwapNode(left, right);\n//                \n//                if (!hash.Add(board.GetHash()))\n//                    children[i] = null;\n//            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public void SwapNode(Node left, Node right)\n    {\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n        };\n    }\n\n//    public override string ToString()\n//    {\n//        return Nodes.Select(x => x.Current)\n//            .Select(x => x.ToString())\n//            .Aggregate((acc, x) => acc + \" \" + x);\n//    }\n    \n    public int GetHash()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n//    public override bool Equals(Object o)\n//    {\n//        return Equals((Board)o);\n//    }\n//    public bool Equals(Board other)\n//    {\n//        return ToString() == other.ToString();\n//    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int[] AdjacentNumbers { get; set; }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        AdjacentNumbers = adjacentNumbersDic[correct];\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n \nnamespace ALDS1_13_B2\n{\n    class Program\n    {\n        static int[] dx = { -1, 0, 1, 0 };\n        static int[] dy = { 0, -1, 0, 1 };\n \n        static void Main(string[] args)\n        {\n            var cnt = 0;\n            int[] Puzzle = new int[11];\n            for (int i = 0; i < 3; i++)\n            {\n                var k = scan;\n                for (int j = 0; j < 3; j++)\n                {\n                    Puzzle[cnt++] = k[j];\n                    if (k[j] == 0)\n                    {\n                        Puzzle[cnt - 1] = 9;\n                        Puzzle[9] = cnt - 1;\n                    } \n                }\n            }\n            bfs(Puzzle);\n             \n        }\n        static bool checker(int[] a)\n        {\n        \tfor(int i = 0; i < 9; i++)\n        \t{\n        \t\tif(a[i] == i+1)continue;\n        \t\treturn false;\n        \t}\n        \treturn true;\n        }\n        static void bfs(int[] s)\n        {\n            //index 0-10\n            var Q = new Queue<string>();\n            //index 0-8\n            var V = new SortedSet<string>();\n            \n            string m = s[0].ToString(), n;\n            for(int i = 1;i < 11; i++)\n            {\n            \tm += \" \" + s[i].ToString();\n            }\n            n = m.Substring(0, 17);\n            Q.Enqueue(m);\n            V.Add(n);\n             \n            while (Q.Any())\n            {\n                int[] u = Q.Dequeue().Split().Select(int.Parse).ToArray();\n                \n                //Console.WriteLine(string.Concat(u));\n                if (checker(u))\n                {\n                    Console.WriteLine(u[10]);\n                    return;\n                }\n                int sx = u[9] / 3;\n                int sy = u[9] % 3;\n                for (int r = 0; r <= 3; r++)\n                {\n                    int tx = sx + dx[r];\n                    int ty = sy + dy[r];\n                    if (tx < 0 || ty < 0 || tx >= 3 || ty >= 3) continue;\n \n                    var position = (tx * 3 + ty);\n                    var nowspace = u[9];\n \n                    swap(u, position, nowspace);\n                    u[9] = position;\n                    \n                    n = u[0].ToString();\n                    for(int i = 1; i < 9; i++)\n                    {\n                    \tn += \" \" + u[i].ToString();\n                    }\n                    if (!V.Contains(n))\n                    {\n                        V.Add(n);\n                        u[10]++;\n                        for(int j = 9; j < 11; j++)\n                        {\n                        \tn += \" \" +u[j].ToString();\n                        }\n                        Q.Enqueue(n);\n                        u[10]--;\n                    }\n                    u[9] = nowspace;\n                    swap(u, position, nowspace);\n \n                }\n                //Console.WriteLine(string.Join(\" & \",Q));\n            }\n            Console.WriteLine(\"WA\");\n        }\n        static void swap(int[] s, int x, int y)\n        {\n            var t = s[x];\n            s[x] = s[y];\n            s[y] = t;\n        }\n        static int[] scan { get { return Array.ConvertAll(Console.ReadLine().Split(), int.Parse); } }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class Program{\n    public static int N = 3;\n    public static int[] STEPS = new int[]{0, 1, 0, -1, 0};\n    public static void Main(){\n        var watch = new Stopwatch();\n        watch.Start();\n        TextReader reader;\n        string filename = \"\";\n        //filename = @\"\";\n        if(filename.Count()>0) reader = new StreamReader(filename);\n        else reader = Console.In;\n        \n        var Board = new int[N, N];\n        for(int i=0; i<N; i++){\n            var line = reader.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<N; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        \n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var Target = Board2Long(Goal);\n        var stack = new Stack<State>();\n        stack.Push(new State{table = Board, cnt = 0});\n\n        //????????±?????§????????¢??????????´????????????¢????????£?????????????¨?????????????\n        //??????????????¶?????????????????????????????\\???????????????\n        \n        int point = 0;\n        for(; point<10000; point++){\n            bool flag = false;\n            while(stack.Count()>0){\n                var curr = stack.Pop();\n                var longed = Board2Long(curr.table);\n                if(curr.cnt>point) continue;\n                if(Board2Long(curr.table)==Target){\n                    Console.WriteLine(curr.cnt);\n                    flag = true;\n                    break;\n                }\n                var Now = curr.GetPos();\n                var cx = Now.X;\n                var cy = Now.Y;\n                for(int i=0; i<4; i++){\n                    var nx = cx+STEPS[i+1]; \n                    var ny = cy+STEPS[i];\n                    if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                        var Nex = new Pos{Y = ny, X = nx};\n                        var NexMap = curr.Swap(Nex, Now);\n                        if(longed!=Board2Long(NexMap.table))stack.Push(NexMap);\n                    }\n                }\n            }\n            \n            if(flag){\n                break;\n            }else{\n                stack.Push(new State{table = Board, cnt = 0});\n            }\n        }\n    }\n\n    public static long Board2Long(int[,] board){\n        var keta = board.GetLength(0)*board.GetLength(1)-1;\n        long ret = 0;\n        for(int i=0; i<board.GetLength(0); i++){\n            for(int j=0; j<board.GetLength(1); j++){\n                ret+=board[i,j]*(int)Math.Pow(10, keta-(i*board.GetLength(0)+j));\n            }\n        }\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n    \n    public int GetManhattanDist(){\n        int ret = 0;\n        \n        return ret;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Puzzle\n    {\n        internal int[] f;\n        internal int space, MD;\n\n        public Puzzle(int n)\n        {\n            f = new int[n];\n        }\n\n        public Puzzle(Puzzle other)\n        {\n            f = (int[])other.f.Clone();\n\n            space = other.space;\n            MD = other.MD;\n        }\n    }\n\n    class NPuzzle\n    {\n        readonly int Limit = 50;\n        readonly int n, h, w;\n\n        readonly int[] moveX = new int[] { 0, -1, 0, +1 };\n        readonly int[] moveY = new int[] { -1, 0, +1, 0 };\n        readonly char[] dir = new char[] { 'u', 'l', 'd', 'r' };\n\n        int limit;\n        int[] path;\n        int[,] MDT;\n\n        public NPuzzle(int h, int w)\n        {\n            this.h = h;\n            this.w = w;\n            n = h * w;\n\n            MDT = new int[n, n];\n            path = new int[Limit];\n\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    MDT[i, j] = Math.Abs(i / h - j / w) + Math.Abs(i % h - j % w);\n                }\n            }\n        }\n\n        public string IterativeDeeping(Puzzle p)\n        {\n            StringBuilder ret = new StringBuilder();\n            Puzzle state;\n\n            p.MD = GetAllMD(p);\n\n            for (limit = p.MD; limit <= Limit; limit++)\n            {\n                state = new Puzzle(p);\n\n                if (DFS(state, 0, -50))\n                {\n                    for (int i = 0; i < limit; i++)\n                    {\n                        ret.Append(dir[path[i]]);\n                    }\n                    return ret.ToString();\n                }\n            }\n            return null;\n        }\n\n        private bool DFS(Puzzle state, int depth, int prev)\n        {\n            if (state.MD == 0) return true;\n\n            if (depth + state.MD > limit) return false;\n\n            int sx = state.space % w;\n            int sy = state.space / w;\n\n            Puzzle tempState;\n\n            for (int r = 0; r < 4; r++)\n            {\n                int tx = sx + moveX[r];\n                int ty = sy + moveY[r];\n\n                if (!IsValid(tx, ty)) continue;\n\n                if (Math.Abs(prev - r) == 2) continue;\n\n                tempState = new Puzzle(state);\n\n                int indexT = tx + ty * w;\n                int indexS = sx + sy * w;\n\n                state.MD -= MDT[indexT, state.f[indexT] - 1];\n                state.MD += MDT[indexS, state.f[indexT] - 1];\n\n                int temp = state.f[indexT];\n                state.f[indexT] = state.f[indexS];\n                state.f[indexS] = temp;\n\n                state.space = indexT;\n\n                if (DFS(state, depth + 1, r))\n                {\n                    path[depth] = r;\n                    return true;\n                }\n\n                state = tempState;\n            }\n            return false;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0) return false;\n            if (y < 0) return false;\n            if (x >= w) return false;\n            if (y >= h) return false;\n            return true;\n        }\n\n        private int GetAllMD(Puzzle p)\n        {\n            int sum = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                if (p.f[i] != n) sum += MDT[i, p.f[i] - 1];\n            }\n            return sum;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int h = 3, w = 3;\n            int n = h * w;\n\n            NPuzzle NP = new NPuzzle(h, w);\n            Puzzle s = new Puzzle(n);\n\n            for (int i = 0; i < h; i++)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                for (int j = 0; j < w; j++)\n                {\n                    int index = i * w + j;\n                    s.f[index] = input[j];\n\n                    if (input[j] == 0)\n                    {\n                        s.f[index] = n;\n                        s.space = index;\n                    }\n                }\n            }\n\n            string ans = NP.IterativeDeeping(s);\n\n            Console.WriteLine(ans != null ? ans.Length : 0);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_13_B\n{\n    class Program\n    {\n        const int N = 3;\n        const int N2 = 9;\n        static int[] dx = { -1, 0, 1, 0 };\n        static int[] dy = { 0, -1, 0, 1 };\n        static char[] dir = { 'u', 'l', 'd', 'r' };\n        static int cnt;\n\n        class Puzzle\n        {\n            internal int[] f;\n            internal int space;\n            internal string path;\n            \n            public Puzzle()\n            {\n                f = new int[N2];\n                space = -1;\n                path = \"\";\n            } \n        }\n        static void Main(string[] args)\n        {\n            var P = new Puzzle();\n            for (int i = 0; i < N; i++)\n            {\n                var k = scan;\n                for (int j = 0; j < N; j++)\n                {\n                    P.f[cnt++] = k[j];\n                    if (k[j] == 0)\n                    {\n                        P.f[cnt - 1] = N2;\n                        P.space = cnt - 1;\n                    }\n                }\n            }\n            bfs(P);\n        }\n\n        static void bfs(Puzzle s)\n        {\n            var Q = new Queue<Puzzle>();\n\n            string st = \"\";\n            for (int i = 0; i < 9; i++)\n            {\n                st += s.f[i].ToString();\n            }\n            var V = new HashSet<string>();\n\n            var u = new Puzzle();\n            var v = new Puzzle();\n\n            Q.Enqueue(s);\n            V.Add(st);\n       \n\n            while (Q.Any())\n            {\n                u = Q.Dequeue();\n\n                \n                if(isTarget(u))\n                {\n                    Console.WriteLine(u.path.Length);\n                    return;\n                }\n\n                int sx = u.space / N;\n                int sy = u.space % N;\n\n                for (int r = 0; r < 4; r++)\n                {\n                    int tx = sx + dx[r];\n                    int ty = sy + dy[r];\n                    if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;\n\n                    var us = u.space;\n                    var vs = tx * N + ty;\n\n                    v = new Puzzle();\n                    for (int i = 0; i < 9; i++)\n                    {\n                        v.f[i] = u.f[i];\n                    }\n                    int tt = v.f[us];\n                    v.f[us] = v.f[vs];\n                    v.f[vs] = tt;\n\n\n                    v.space = vs;\n                    v.path = u.path;\n  \n\n                    st = \"\";\n                    for (int i = 0; i < 9; i++)\n                    {\n                        st += v.f[i].ToString();\n                    }\n\n                    if (!V.Contains(st))\n                    {\n                        V.Add(st);\n                        v.path += dir[r];\n                        Q.Enqueue(v);\n                     }\n                }\n            }\n\n            Console.WriteLine(\"unsolvable\");\n        }\n\n\n        static bool isTarget(Puzzle p)\n        {\n            for (int i = 0; i < N2; i++)\n            {\n                if (p.f[i] != (i + 1)) return false;\n            }\n            return true;\n        }\n        static int[] scan { get { return Array.ConvertAll(Console.ReadLine().Split(), int.Parse); } }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 1;\n        var boards = new [] {board}.AsEnumerable();\n        while (true)\n        {\n            boards = boards.SelectMany(x => x.Move(max));\n            if (boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n                break;\n            max++;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    private int MoveCount { get; set; }\n    \n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        MoveCount = 0;\n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .Select((adj, i) => \n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                if (left.LastNumber == right.Current)\n                {\n                    children[i] = null;\n                    return 0;\n                }\n                return board.SwapNode(left, right);\n            })\n            .ToArray();\n        \n        return children.Where(x => x != null).ToArray();\n//        if (children.Where(x => x != null).Any(x => x.Nodes.All(node => node.IsCorrect())))\n//        {\n//            return children.Where(x => x != null).Where(x => x.Nodes.All(node => node.IsCorrect())).ToArray();\n//        }\n//        \n//        if (MoveCount == max)\n//            return children.Where(x => x != null).ToArray();\n//        \n//        return children.Where(x => x != null)\n//            .SelectMany(x => x.Move(max))\n//            .ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n        left.LastNumber = left.Current;\n        right.LastNumber = right.Current;\n\n        left.Current = right.LastNumber;\n        right.Current = left.LastNumber;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n}\n\npublic class Node\n{\n    private static Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_13_B_8_Puzzle\n{\n\tclass Program\n\t{\n\t\tstatic void Main ( string[] args )\n\t\t{\n\t\t\t//input\n\t\t\tList<int> input = new List<int> (9);\n\n\t\t\tfor (int lp = 0; lp < 3; lp++)\n\t\t\t{\n\t\t\t\tint[] state = Array.ConvertAll (Console.ReadLine ().Split (' '), int.Parse);\n\t\t\t\tinput.AddRange (state);\n\t\t\t}\n\n\t\t\t//process\n\t\t\tQueue<Puzzle> puzzleQueue = new Queue<Puzzle> (3000);\n\t\t\tEqual equal = new Equal ();\n\t\t\tDictionary<int[], bool> puzzleState = new Dictionary<int[], bool> (3000, equal);\n\n\t\t\tint[] answer = { 1, 2, 3, 4, 5, 6, 7, 8, 0 };\n\n\t\t\tPuzzle p = new Puzzle (input.ToArray (), 0, input.IndexOf (0));\n\t\t\tpuzzleQueue.Enqueue (p);\n\t\t\tpuzzleState.Add (p.Area, true);\n\n\t\t\twhile (puzzleQueue.Count != 0)\n\t\t\t{\n\t\t\t\tPuzzle item = puzzleQueue.Dequeue ();\n\n\t\t\t\tif (Puzzle.IsMatch (item.Area, answer))\n\t\t\t\t{\n\t\t\t\t\tConsole.WriteLine (item.Count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tPuzzle[] next = item.Move (puzzleState);\n\n\t\t\t\tforeach (var element in next)\n\t\t\t\t{\n\t\t\t\t\tpuzzleState.Add (element.Area, true);\n\t\t\t\t\tpuzzleQueue.Enqueue (element);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tclass Puzzle\n\t{\n\t\tpublic Puzzle ( int[] area, int count, int emptyIndex )\n\t\t{\n\t\t\tthis.Area = new int[Length];\n\t\t\tarea.CopyTo (this.Area, 0);\n\t\t\tthis.Count = count;\n\t\t\tthis.EmptyIndex = emptyIndex;\n\t\t}\n\n\t\tpublic int[] Area { private set; get; }\n\t\tpublic int Count { private set; get; }\n\t\tprivate int EmptyIndex { set; get; }\n\n\t\tprivate const int Length = 9;\n\n\t\tpublic Puzzle[] Move ( Dictionary<int[], bool> dictionary )\n\t\t{\n\t\t\tint[] indexArray;\n\t\t\tint createCount = MoveData (EmptyIndex, out indexArray);\n\n\t\t\tList<Puzzle> puzzle = new List<Puzzle> (createCount);\n\n\t\t\tfor (int lp = 0; lp < createCount; lp++)\n\t\t\t{\n\t\t\t\tint index = indexArray[lp];\n\n\t\t\t\tint[] copyArea = new int[Length];\n\t\t\t\tArea.CopyTo (copyArea, 0);\n\n\t\t\t\tvar tmp = copyArea[EmptyIndex];\n\t\t\t\tcopyArea[EmptyIndex] = copyArea[index];\n\t\t\t\tcopyArea[index] = tmp;\n\n\t\t\t\tif (!dictionary.ContainsKey (copyArea))\n\t\t\t\t{\n\t\t\t\t\tpuzzle.Add (new Puzzle (copyArea, Count + 1, index));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn puzzle.ToArray ();\n\t\t}\n\n\t\tpublic static bool IsMatch ( int[] area1, int[] area2 )\n\t\t{\n\t\t\tif (area1.SequenceEqual (area2))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\n\t\tprivate int MoveData ( int emptyIndex, out int[] indexArray )\n\t\t{\n\t\t\tint createCount;\n\n\t\t\tswitch (emptyIndex)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 0;\n\t\t\t\t\tindexArray[1] = 2;\n\t\t\t\t\tindexArray[2] = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 0;\n\t\t\t\t\tindexArray[1] = 4;\n\t\t\t\t\tindexArray[2] = 6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tcreateCount = 4;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 3;\n\t\t\t\t\tindexArray[2] = 5;\n\t\t\t\t\tindexArray[3] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 2;\n\t\t\t\t\tindexArray[1] = 4;\n\t\t\t\t\tindexArray[2] = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 3;\n\t\t\t\t\tindexArray[1] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 4;\n\t\t\t\t\tindexArray[1] = 6;\n\t\t\t\t\tindexArray[2] = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 5;\n\t\t\t\t\tindexArray[1] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcreateCount = -1;\n\t\t\t\t\tindexArray = null;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn createCount;\n\t\t}\n\t}\n\n\tclass Equal : EqualityComparer<int[]>\n\t{\n\t\tpublic override bool Equals ( int[] area1, int[] area2 )\n\t\t{\n\t\t\treturn area1.SequenceEqual (area2);\n\t\t}\n\t\tpublic override int GetHashCode ( int[] item )\n\t\t{\n\t\t\t//return base.GetHashCode ();\n\t\t\treturn\n\t\t\t\titem[0] +\n\t\t\t\titem[1] * 10 +\n\t\t\t\titem[2] * 100 +\n\t\t\t\titem[3] * 1000 +\n\t\t\t\titem[4] * 10000 +\n\t\t\t\titem[5] * 100000;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var queue = new Queue<State>();\n        var all_list = new List<string>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        int c = 0;\n        while(queue.Count()>0&&c<500){\n            var curr = queue.Dequeue();\n            //Print(curr.table);\n            if(all_list.Contains(ToStringForList(curr.table)))continue;\n            else all_list.Add(ToStringForList(curr.table));\n            if(curr.table.ContentEqual(Goal)){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n            \n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i]; \n                var ny = cy+steps[i+1];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n            c++;\n        }\n        \n    }\n    \n    public static string ToStringForList(int[,] map){\n        var ret=\"\";\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret+=map[i, j];\n            }\n        }\n        return ret;\n    }\n    \n    /*\n    AOJ C# compiler is considered old version, so \"$\" keyword cant use. fuck.\n    public static void Print(int[,] map){\n        Console.WriteLine(new string(Enumerable.Repeat('-', 10).ToArray()));\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                //Console.Write($\"{map[i, j]} \");\n            }\n            Console.WriteLine();\n        }\n    }\n    */\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n    \n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}\n\npublic static class Exclass{\n    public static bool ContentEqual<T>(this T[,] array, T[,] other)where T : IComparable\n    {\n        if(array.GetLength(0)!=other.GetLength(0) || array.GetLength(1)!=other.GetLength(1)) return false;\n        for(int i=0; i<array.GetLength(0); i++){\n            for(int j=0; j<array.GetLength(1); j++){\n                if(array[i, j].CompareTo(other[i, j])!=0) return false;\n            }\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Text;  //StringBuilder?????????????????????????????°????????????????????????\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var StrGoal = ToStringForList(Goal);\n        var queue = new Queue<State>();\n        var all_list = new HashSet<string>();   //List??????HashSet????????´???????????????\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            var state = ToStringForList(curr.table); //ToStringForList?????????????????°state????????????????????¨??§????????????????????§??????????????????????????????\n            if(all_list.Contains(state)) continue;\n            else all_list.Add(state);\n            if(state==StrGoal){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n\n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i+1]; \n                var ny = cy+steps[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n\n    }\n\n    public static string ToStringForList(int[,] map){\n        //var ret = new StringBuilder();\n        var ret = \"\";\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                //ret.Append(map[i, j]);\n                ret+=map[i,j];\n            }\n        }\n        //return ret.ToString();\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_13_B_8_Puzzle\n{\n\tclass Program\n\t{\n\t\tstatic void Main ( string[] args )\n\t\t{\n\t\t\t//input\n\t\t\tList<int> input = new List<int> (9);\n\n\t\t\tfor (int lp = 0; lp < 3; lp++)\n\t\t\t{\n\t\t\t\tint[] state = Array.ConvertAll (Console.ReadLine ().Split (' '), int.Parse);\n\t\t\t\tinput.AddRange (state);\n\t\t\t}\n\n\t\t\t//process\n\t\t\tQueue<Puzzle> puzzleQueue = new Queue<Puzzle> (100);\n\t\t\tEqual equal = new Equal ();\n\t\t\tHashSet<int[]> puzzleState = new HashSet<int[]> (equal);\n\n\t\t\tint[] answer = { 1, 2, 3, 4, 5, 6, 7, 8, 0 };\n\n\t\t\tPuzzle p = new Puzzle (input.ToArray (), 0, input.IndexOf (0));\n\t\t\tpuzzleQueue.Enqueue (p);\n\t\t\tpuzzleState.Add (p.Area);\n\n\t\t\twhile (puzzleQueue.Count != 0)\n\t\t\t{\n\t\t\t\tPuzzle item = puzzleQueue.Dequeue ();\n\n\t\t\t\tif (Puzzle.IsMatch (item.Area, answer))\n\t\t\t\t{\n\t\t\t\t\tConsole.WriteLine (item.Count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tPuzzle[] next = item.Move ();\n\n\t\t\t\tforeach (var element in next)\n\t\t\t\t{\n\t\t\t\t\tif (!puzzleState.Contains (element.Area))\n\t\t\t\t\t{\n\t\t\t\t\t\tpuzzleQueue.Enqueue (element);\n\t\t\t\t\t\tpuzzleState.Add (element.Area);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tclass Puzzle\n\t{\n\t\tpublic Puzzle ( int[] area, int count, int emptyIndex )\n\t\t{\n\t\t\tthis.Area = new int[Length];\n\t\t\tarea.CopyTo (this.Area, 0);\n\t\t\tthis.Count = count;\n\t\t\tthis.EmptyIndex = emptyIndex;\n\t\t}\n\n\t\tpublic int[] Area { private set; get; }\n\t\tpublic int Count { private set; get; }\n\t\tprivate int EmptyIndex { set; get; }\n\n\t\tprivate const int Length = 9;\n\n\t\tpublic Puzzle[] Move ()\n\t\t{\n\t\t\tint[] indexArray;\n\t\t\tint createCount = MoveData (EmptyIndex, out indexArray);\n\n\t\t\tPuzzle[] puzzle = new Puzzle[createCount];\n\n\t\t\tfor (int lp = 0; lp < puzzle.Length; lp++)\n\t\t\t{\n\t\t\t\tint index = indexArray[lp];\n\n\t\t\t\tint[] copyArea = new int[Length];\n\t\t\t\tArea.CopyTo (copyArea, 0);\n\n\t\t\t\tvar tmp = copyArea[EmptyIndex];\n\t\t\t\tcopyArea[EmptyIndex] = copyArea[index];\n\t\t\t\tcopyArea[index] = tmp;\n\n\t\t\t\tpuzzle[lp] = new Puzzle (copyArea, (int) (Count + 1), index);\n\t\t\t}\n\n\t\t\treturn puzzle;\n\t\t}\n\n\t\tpublic static bool IsMatch ( int[] area1, int[] area2 )\n\t\t{\n\t\t\tif (area1.SequenceEqual (area2))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\n\t\tprivate int MoveData ( int emptyIndex, out int[] indexArray )\n\t\t{\n\t\t\tint createCount = 0;\n\t\t\tindexArray = null;\n\n\t\t\tswitch (emptyIndex)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 0;\n\t\t\t\t\tindexArray[1] = 2;\n\t\t\t\t\tindexArray[2] = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 0;\n\t\t\t\t\tindexArray[1] = 4;\n\t\t\t\t\tindexArray[2] = 6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tcreateCount = 4;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 3;\n\t\t\t\t\tindexArray[2] = 5;\n\t\t\t\t\tindexArray[3] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 2;\n\t\t\t\t\tindexArray[1] = 4;\n\t\t\t\t\tindexArray[2] = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 3;\n\t\t\t\t\tindexArray[1] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 4;\n\t\t\t\t\tindexArray[1] = 6;\n\t\t\t\t\tindexArray[2] = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 5;\n\t\t\t\t\tindexArray[1] = 7;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn createCount;\n\t\t}\n\t}\n\n\tclass Equal : EqualityComparer<int[]>\n\t{\n\t\tpublic override bool Equals ( int[] area1, int[] area2 )\n\t\t{\n\t\t\treturn area1.SequenceEqual (area2);\n\t\t}\n\t\tpublic override int GetHashCode ( int[] item )\n\t\t{\n\t\t\treturn base.GetHashCode ();\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var count = 0;\n        var boards = new [] { new Board(inputs) };\n        \n        while (!boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            count++;\n            boards = boards.SelectMany(x => x.Move())\n                .ToArray();\n        }\n        \n        Console.WriteLine(count);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    static HashSet<int> hash = new HashSet<int>();\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n    }\n    \n    public Board() { }\n    \n    public Board[] Move()\n    {\n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHash()))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public void SwapNode(Node left, Node right)\n    {\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n        };\n    }\n\n//    public override string ToString()\n//    {\n//        return Nodes.Select(x => x.Current)\n//            .Select(x => x.ToString())\n//            .Aggregate((acc, x) => acc + \" \" + x);\n//    }\n    \n    public int GetHash()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n//    public override bool Equals(Object o)\n//    {\n//        return Equals((Board)o);\n//    }\n//    public bool Equals(Board other)\n//    {\n//        return ToString() == other.ToString();\n//    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int[] AdjacentNumbers { get; set; }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        AdjacentNumbers = adjacentNumbersDic[correct];\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 1;\n        while (board.Move(max) == -1)\n        {\n            board = new Board(inputs);\n            max++;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    public int MoveCount { get; set; }\n    \n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        MoveCount = 0;\n    }\n    \n    public Board() { }\n    \n    public int Move(int max)\n    {\n        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .Select((adj, i) => \n            {\n                var board = children[i];\n                return board.SwapNode(board.Nodes.First(x => x.Current == 0), board.Nodes.First(x => x.CorrectNumber == adj));\n            })\n            .ToArray();\n        \n        if (children.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            return MoveCount;\n        }\n        \n        if (MoveCount == max)\n            return -1;\n        \n        return children.Select(x => x.Move(max))\n            .Where(x => x != -1)\n            .DefaultIfEmpty(-1)\n            .Min();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n        var temp = right.Current;\n        right.Current = left.Current;\n        left.Current = temp;\n        \n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n}\n\npublic class Node\n{\n    private static Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        LastNumber = -1;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 1;\n        var boards = new [] {board};\n        while (true)\n        {\n            boards = boards.SelectMany(x => x.Move(max)).ToArray();\n            if (boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n                break;\n            max++;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    private int MoveCount { get; set; }\n    \n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        MoveCount = 0;\n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .Select((adj, i) => \n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                if (left.LastNumber == right.Current)\n                {\n                    children[i] = null;\n                    return 0;\n                }\n                return board.SwapNode(left, right);\n            })\n            .ToArray();\n        \n        if (children.Where(x => x != null).Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            return children.Where(x => x != null).Where(x => x.Nodes.All(node => node.IsCorrect())).ToArray();\n        }\n        \n        if (MoveCount == max)\n            return children.Where(x => x != null).ToArray();\n        \n        return children.Where(x => x != null)\n            .SelectMany(x => x.Move(max))\n            .ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n        left.LastNumber = left.Current;\n        right.LastNumber = right.Current;\n\n        left.Current = right.LastNumber;\n        right.Current = left.LastNumber;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n}\n\npublic class Node\n{\n    private static Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var count = 0;\n        var boards = new [] { new Board(inputs) };\n        \n        while (!boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            count++;\n            boards = boards.SelectMany(x => x.Move())\n                .ToArray();\n        }\n        \n        Console.WriteLine(count);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    static HashSet<int> hash = new HashSet<int>();\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n    }\n    \n    public Board() { }\n    \n    public Board[] Move()\n    {\n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHash()))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public void SwapNode(Node left, Node right)\n    {\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n        };\n    }\n\n//    public override string ToString()\n//    {\n//        return Nodes.Select(x => x.Current)\n//            .Select(x => x.ToString())\n//            .Aggregate((acc, x) => acc + \" \" + x);\n//    }\n    \n    public int GetHash()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n//    public override bool Equals(Object o)\n//    {\n//        return Equals((Board)o);\n//    }\n//    public bool Equals(Board other)\n//    {\n//        return ToString() == other.ToString();\n//    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int[] AdjacentNumbers { get; set; }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        AdjacentNumbers = adjacentNumbersDic[correct];\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 1;\n        while (board.Move(max) == -1)\n        {\n            board = new Board(inputs);\n            max++;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    private int MoveCount { get; set; }\n    \n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        MoveCount = 0;\n    }\n    \n    public Board() { }\n    \n    public int Move(int max)\n    {\n        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .Select((adj, i) => \n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                if (left.LastNumber == right.Current)\n                {\n                    children[i] = null;\n                    return 0;\n                }\n                return board.SwapNode(left, right);\n            })\n            .ToArray();\n        \n        if (children.Where(x => x != null).Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            return MoveCount;\n        }\n        \n        if (MoveCount == max)\n            return -1;\n        \n        return children.Where(x => x != null)\n            .Select(x => x.Move(max))\n            .Where(x => x != -1)\n            .DefaultIfEmpty(-1)\n            .Min();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n        left.LastNumber = left.Current;\n        right.LastNumber = right.Current;\n\n        left.Current = right.LastNumber;\n        right.Current = left.LastNumber;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n}\n\npublic class Node\n{\n    private static Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class Program{\n    public static int N = 3;\n    public static int[] STEPS = new int[]{0, 1, 0, -1, 0};\n    public static void Main(){\n        //var watch = new Stopwatch();\n        //watch.Start();\n        string filename = \"\";\n        //filename = @\"\";\n        TextReader reader;\n        if(filename.Count()>0) reader = new StreamReader(filename);\n        else reader = Console.In;\n        \n        var Board = new int[N, N];\n        for(int i=0; i<N; i++){\n            var line = reader.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<N; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        \n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var Target = Board2Long(Goal);\n        var queue = new Queue<State>();\n        var all_list = new HashSet<long>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            if(all_list.Contains(Board2Long(curr.table)))continue;\n            else all_list.Add(Board2Long(curr.table));\n            if(Board2Long(curr.table)==Target){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n\n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            for(int i=0; i<4; i++){\n                var nx = cx+STEPS[i+1]; \n                var ny = cy+STEPS[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n        //watch.Stop();\n        //Console.WriteLine($\"????????????{watch.ElapsedMilliseconds}???????§?\");\n    }\n\n    public static long Board2Long(int[,] board){\n        var keta = board.GetLength(0)*board.GetLength(1)-1;\n        long ret = 0;\n        for(int i=0; i<board.GetLength(0); i++){\n            for(int j=0; j<board.GetLength(1); j++){\n                ret+=board[i,j]*(int)Math.Pow(10, keta-(i*board.GetLength(0)+j));\n            }\n        }\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var queue = new Queue<State>();\n        var all_list = new List<string>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            //Print(curr.table);\n            if(all_list.Contains(ToStringForList(curr.table)))continue;\n            else all_list.Add(ToStringForList(curr.table));\n            if(curr.table.ContentEqual(Goal)){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n            \n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i]; \n                var ny = cy+steps[i+1];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n        \n    }\n    \n    public static string ToStringForList(int[,] map){\n        var ret=\"\";\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret+=map[i, j];\n            }\n        }\n        return ret;\n    }\n    \n    \n    //AOJ C# compiler is considered old version, so \"$\" keyword cant use. fuck.\n    /*\n    public static void Print(int[,] map){\n        Console.WriteLine(new string(Enumerable.Repeat('-', 10).ToArray()));\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                Console.Write($\"{map[i, j]} \");\n            }\n            Console.WriteLine();\n        }\n    }\n    */\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n    \n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}\n\npublic static class Exclass{\n    public static bool ContentEqual<T>(this T[,] array, T[,] other)where T : IComparable\n    {\n        if(array.GetLength(0)!=other.GetLength(0) || array.GetLength(1)!=other.GetLength(1)) return false;\n        for(int i=0; i<array.GetLength(0); i++){\n            for(int j=0; j<array.GetLength(1); j++){\n                if(array[i, j].CompareTo(other[i, j])!=0) return false;\n            }\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n \nnamespace ALDS1_13_B2\n{\n    class Program\n    {\n        static int[] dx = { -1, 0, 1, 0 };\n        static int[] dy = { 0, -1, 0, 1 };\n \n        static void Main(string[] args)\n        {\n            var cnt = 0;\n            int[] Puzzle = new int[11];\n            for (int i = 0; i < 3; i++)\n            {\n                var k = scan;\n                for (int j = 0; j < 3; j++)\n                {\n                    Puzzle[cnt++] = k[j];\n                    if (k[j] == 0)\n                    {\n                        Puzzle[cnt - 1] = 9;\n                        Puzzle[9] = cnt - 1;\n                    } \n                }\n            }\n            bfs(Puzzle);\n             \n        }\n        static bool checker(int[] a)\n        {\n        \tfor(int i = 0; i < 9; i++)\n        \t{\n        \t\tif(a[i] == i+1)continue;\n        \t\treturn false;\n        \t}\n        \treturn true;\n        }\n        static void bfs(int[] s)\n        {\n            //index 0-10\n            var Q = new Queue<string>();\n            //index 0-8\n            var V = new HashSet<string>();\n            \n            string m = s[0].ToString(), n;\n            for(int i = 1;i < 11; i++)\n            {\n            \tm += \" \" + s[i].ToString();\n            }\n            n = m.Substring(0, 17);\n            Q.Enqueue(m);\n            V.Add(n);\n             \n            while (Q.Any())\n            {\n                int[] u = Q.Dequeue().Split().Select(int.Parse).ToArray();\n                \n                //Console.WriteLine(string.Concat(u));\n                if (checker(u))\n                {\n                    Console.WriteLine(u[10]);\n                    return;\n                }\n                int sx = u[9] / 3;\n                int sy = u[9] % 3;\n                for (int r = 0; r <= 3; r++)\n                {\n                    int tx = sx + dx[r];\n                    int ty = sy + dy[r];\n                    if (tx < 0 || ty < 0 || tx >= 3 || ty >= 3) continue;\n \n                    var position = (tx * 3 + ty);\n                    var nowspace = u[9];\n \n                    swap(u, position, nowspace);\n                    u[9] = position;\n                    \n                    n = u[0].ToString();\n                    for(int i = 1; i < 9; i++)\n                    {\n                    \tn += \" \" + u[i].ToString();\n                    }\n                    if (!V.Contains(n))\n                    {\n                        V.Add(n);\n                        u[10]++;\n                        for(int j = 9; j < 11; j++)\n                        {\n                        \tn += \" \" +u[j].ToString();\n                        }\n                        Q.Enqueue(n);\n                        u[10]--;\n                    }\n                    u[9] = nowspace;\n                    swap(u, position, nowspace);\n \n                }\n                //Console.WriteLine(string.Join(\" & \",Q));\n            }\n            Console.WriteLine(\"WA\");\n        }\n        static void swap(int[] s, int x, int y)\n        {\n            var t = s[x];\n            s[x] = s[y];\n            s[y] = t;\n        }\n        static int[] scan { get { return Array.ConvertAll(Console.ReadLine().Split(), int.Parse); } }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class Program{\n    public static int N = 3;\n    public static int[] STEPS = new int[]{0, 1, 0, -1, 0};\n    public static void Main(){\n        /*\n        var watch = new Stopwatch();\n        watch.Start();\n        */\n        TextReader reader;\n        string filename = \"\";\n        if(filename.Count()>0) reader = new StreamReader(filename);\n        else reader = Console.In;\n        \n        var Board = new int[N, N];\n        for(int i=0; i<N; i++){\n            var line = reader.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<N; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        \n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var queue = new Queue<State>();\n        var all_list = new HashSet<long>();\n        var all_dict = new Dictionary<long, int>();\n        \n        //????????????????????´?????????????????????????????£????????????????????¨??????\n        //???????????¢??????????????????1???????????????????????¶??????????§?????????¨????????¢?´¢???????????????-2?????????????°????????????????\n        queue.Enqueue(new State{table = Goal, cnt = -1});\n        queue.Enqueue(new State{table = Board, cnt = 1});\n        all_dict[Board2Long(Goal)] = -1;\n        all_dict[Board2Long(Board)] = 1;\n\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            var longed = Board2Long(curr.table);\n            if(all_list.Contains(longed)){\n                //??¢????????£?????????????????¨????????´?????????????????°?????£???????????°???????????¢?????£????????¨??????????????§??????\n                //????????????????????£??§??????????????§????????´????????????????????????????????????????£????????????????????????????\n                if( (all_dict[longed]<0 && 0<curr.cnt) || curr.cnt<0 && 0<(all_dict[longed]) ){\n                    var other = Math.Abs(all_dict[longed]);\n                    var me = Math.Abs(curr.cnt);\n                    Console.WriteLine(other+me-2);\n                    break;\n                }else{\n                    continue;\n                }\n            }\n            \n            all_list.Add(longed);\n            all_dict[longed] = curr.cnt;\n            \n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            for(int i=0; i<4; i++){\n                var nx = cx+STEPS[i+1]; \n                var ny = cy+STEPS[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n        /*\n        watch.Stop();\n        Console.WriteLine($\"????????????{watch.ElapsedMilliseconds}???????§?\");\n        */\n    }\n\n    public static long Board2Long(int[,] board){\n        var keta = board.GetLength(0)*board.GetLength(1)-1;\n        long ret = 0;\n        for(int i=0; i<board.GetLength(0); i++){\n            for(int j=0; j<board.GetLength(1); j++){\n                ret+=board[i,j]*(int)Math.Pow(10, keta-(i*board.GetLength(0)+j));\n            }\n        }\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        var ad = _cnt>0 ? 1 : -1;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=ad, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 0;\n        var boards = new [] {board};\n//        var sw = new Stopwatch();\n        while (true)\n        {\n            max++;\n//            max.Dump(\"?????????max?????????\");\n//            sw.Restart();\n            boards = boards.SelectMany(x => x.Move(max))\n                .ToArray();\n//            sw.Stop();\n//            sw.ElapsedMilliseconds.Dump(\"move\");\n//            sw.Restart();\n            if (boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n                break;\n//            sw.Stop();\n//            sw.ElapsedMilliseconds.Dump(\"all\");\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    private int MoveCount { get; set; }\n    static HashSet<Board> hash;\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        hash = new HashSet<Board>(); \n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n        MoveCount++;\n        \n//        var sw = Stopwatch.StartNew();\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n//        sw.Stop();\n//        sw.ElapsedMilliseconds.Dump(\"clone\");\n//        sw.Restart();\n        \n        empty.AdjacentNumbers\n            .Select((adj, i) => \n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                if (left.LastNumber == right.Current)\n                {\n                    children[i] = null;\n                    return 0;\n                }\n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board))\n                    children[i] = null;\n                return 0;\n            })\n            .ToArray();\n        \n//        if (children.Where(x => x != null).Any(x => x.Nodes.All(node => node.IsCorrect())))\n//        {\n//            return children.Where(x => x != null).Where(x => x.Nodes.All(node => node.IsCorrect())).ToArray();\n//        }\n            return children.Where(x => x != null).ToArray();\n        \n//        if (MoveCount == max)\n//            return children.Where(x => x != null).ToArray();\n//        \n//        return children.Where(x => x != null)\n//            .SelectMany(x => x.Move(max))\n//            .ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n        left.LastNumber = left.Current;\n        right.LastNumber = right.Current;\n\n        left.Current = right.LastNumber;\n        right.Current = left.LastNumber;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n    \n    public override int GetHashCode()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n    public override bool Equals(Object o)\n    {\n        return Equals((Board)o);\n    }\n    public bool Equals(Board other)\n    {\n        return ToString() == other.ToString();\n    }\n}\n\npublic class Node\n{\n    private static Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var count = 0;\n        var boards = new [] { new Board(inputs) };\n        \n        while (!boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            count++;\n            boards = boards.SelectMany(x => x.Move())\n                .ToArray();\n            \n             var firstLineCompleted = boards\n                //.Where(x => x.Nodes[0].Current == 1 && x.Nodes[1].Current == 2 && x.Nodes[2].Current == 3)\n                .Where(x => x.Nodes[0].Current == 1)\n                .ToArray();\n            if (firstLineCompleted.Any())\n            {\n                boards = firstLineCompleted;\n            }\n        }\n        \n        Console.WriteLine(count);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    static HashSet<int> hash = new HashSet<int>();\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n    }\n    \n    public Board() { }\n    \n    public Board[] Move()\n    {\n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHash()))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public void SwapNode(Node left, Node right)\n    {\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n        };\n    }\n\n//    public override string ToString()\n//    {\n//        return Nodes.Select(x => x.Current)\n//            .Select(x => x.ToString())\n//            .Aggregate((acc, x) => acc + \" \" + x);\n//    }\n    \n    public int GetHash()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n//    public override bool Equals(Object o)\n//    {\n//        return Equals((Board)o);\n//    }\n//    public bool Equals(Board other)\n//    {\n//        return ToString() == other.ToString();\n//    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int[] AdjacentNumbers { get; set; }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        AdjacentNumbers = adjacentNumbersDic[correct];\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var count = 0;\n        var boards = new [] { new Board(inputs) };\n        \n        while (!boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            count++;\n            boards = boards.SelectMany(x => x.Move())\n                .ToArray();\n            \n            var firstLineCompleted = boards\n                .Where(x => x.Nodes[0].Current == 1 && x.Nodes[1].Current == 2 && x.Nodes[2].Current == 3)\n                .ToArray();\n            if (firstLineCompleted.Any())\n            {\n                boards = firstLineCompleted;\n            }\n        }\n        \n        Console.WriteLine(count);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    static HashSet<int> hash = new HashSet<int>();\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n    }\n    \n    public Board() { }\n    \n    public Board[] Move()\n    {\n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHash()))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public void SwapNode(Node left, Node right)\n    {\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n        };\n    }\n\n//    public override string ToString()\n//    {\n//        return Nodes.Select(x => x.Current)\n//            .Select(x => x.ToString())\n//            .Aggregate((acc, x) => acc + \" \" + x);\n//    }\n    \n    public int GetHash()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n//    public override bool Equals(Object o)\n//    {\n//        return Equals((Board)o);\n//    }\n//    public bool Equals(Board other)\n//    {\n//        return ToString() == other.ToString();\n//    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int[] AdjacentNumbers { get; set; }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        AdjacentNumbers = adjacentNumbersDic[correct];\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class State\n    {\n        internal int[,] map;\n        internal string moveLog;\n        internal char preMove;\n    }\n\n    class NPuzzle\n    {\n        readonly int n, h, w;\n\n        public NPuzzle(int h, int w)\n        {\n            n = h * w;\n            this.h = h;\n            this.w = w;\n        }\n\n        public string Solve(State s)\n        {\n            Queue<State> que = new Queue<State>();\n            que.Enqueue(s);\n\n            while (que.Count > 0)\n            {\n                State cur = que.Dequeue();\n\n                if (IsGoal(cur)) return cur.moveLog;\n\n                KeyValuePair<int, int> spacePos = FindSpace(cur);\n                int x = spacePos.Value;\n                int y = spacePos.Key;\n\n                if (x != 0 && cur.preMove != 'l')\n                {\n                    State saved = new State();\n                    saved.map = (int[,])cur.map.Clone();\n                    saved.map[y, x - 1] = 0;\n                    saved.map[y, x] = cur.map[y, x - 1];\n                    saved.moveLog = cur.moveLog + \"r\";\n                    saved.preMove = 'r';\n                    que.Enqueue(saved);\n                }\n\n                if (x != w - 1 && cur.preMove != 'r')\n                {\n                    State saved = new State();\n                    saved.map = (int[,])cur.map.Clone();\n                    saved.map[y, x + 1] = 0;\n                    saved.map[y, x] = cur.map[y, x + 1];\n                    saved.moveLog = cur.moveLog + \"l\";\n                    saved.preMove = 'l';\n                    que.Enqueue(saved);\n                }\n\n                if (y != 0 && cur.preMove != 'u')\n                {\n                    State saved = new State();\n                    saved.map = (int[,])cur.map.Clone();\n                    saved.map[y - 1, x] = 0;\n                    saved.map[y, x] = cur.map[y - 1, x];\n                    saved.moveLog = cur.moveLog + \"d\";\n                    saved.preMove = 'd';\n                    que.Enqueue(saved);\n                }\n\n                if (y != h - 1 && cur.preMove != 'd')\n                {\n                    State saved = new State();\n                    saved.map = (int[,])cur.map.Clone();\n                    saved.map[y + 1, x] = 0;\n                    saved.map[y, x] = cur.map[y + 1, x];\n                    saved.moveLog = cur.moveLog + \"u\";\n                    saved.preMove = 'u';\n                    que.Enqueue(saved);\n                }\n            }\n            return null;\n        }\n\n        private KeyValuePair<int, int> FindSpace(State s)\n        {\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    if (s.map[i, j] == 0) return new KeyValuePair<int, int>(i, j);\n                }\n            }\n            return new KeyValuePair<int, int>(-1, -1);\n        }\n\n        private bool IsGoal(State s)\n        {\n            int mustNumber = 0;\n\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    ++mustNumber;\n\n                    if (mustNumber != n && s.map[i, j] != mustNumber) return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int h = 3, w = 3;\n\n            NPuzzle NP = new NPuzzle(h, w);\n            State s = new State();\n            s.map = new int[h, w];\n\n            for (int i = 0; i < h; i++)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                for (int j = 0; j < w; j++)\n                {\n                    s.map[i, j] = input[j];\n                }\n            }\n\n            string ans = NP.Solve(s);\n\n            Console.WriteLine(ans != null ? ans.Length : 0);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_13_B_8_Puzzle\n{\n\tclass Program\n\t{\n\t\tstatic void Main ( string[] args )\n\t\t{\n\t\t\t//input\n\t\t\tList<int> input = new List<int> (9);\n\n\t\t\tfor (int lp = 0; lp < 3; lp++)\n\t\t\t{\n\t\t\t\tint[] state = Array.ConvertAll (Console.ReadLine ().Split (' '), int.Parse);\n\t\t\t\tinput.AddRange (state);\n\t\t\t}\n\n\t\t\t//process\n\t\t\tQueue<Puzzle> puzzleQueue = new Queue<Puzzle> (100);\n\t\t\tHashSet<int[]> puzzleState = new HashSet<int[]> ();\n\n\t\t\tint[] answer = { 1, 2, 3, 4, 5, 6, 7, 8, 0 };\n\n\t\t\tPuzzle p = new Puzzle (input.ToArray (), 0, input.IndexOf (0));\n\t\t\tpuzzleQueue.Enqueue (p);\n\t\t\tpuzzleState.Add (p.Area);\n\n\t\t\twhile (puzzleQueue.Count != 0)\n\t\t\t{\n\t\t\t\tPuzzle item = puzzleQueue.Dequeue ();\n\n\t\t\t\tif (Puzzle.IsMatch (item.Area, answer))\n\t\t\t\t{\n\t\t\t\t\tConsole.WriteLine (item.Count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tPuzzle[] next = item.Move ();\n\n\t\t\t\tforeach (var element in next)\n\t\t\t\t{\n\t\t\t\t\tif (!puzzleState.Contains (element.Area))\n\t\t\t\t\t{\n\t\t\t\t\t\tpuzzleQueue.Enqueue (element);\n\t\t\t\t\t\tpuzzleState.Add (element.Area);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Puzzle\n\t{\n\t\tpublic Puzzle ( int[] area, int count, int emptyIndex )\n\t\t{\n\t\t\tthis.Area = new int[Length];\n\t\t\tarea.CopyTo (this.Area, 0);\n\t\t\tthis.Count = count;\n\t\t\tthis.EmptyIndex = emptyIndex;\n\t\t}\n\n\t\tpublic int[] Area { private set; get; }\n\t\tpublic int Count { private set; get; }\n\t\tprivate int EmptyIndex { set; get; }\n\n\t\tprivate const int Length = 9;\n\n\t\tpublic Puzzle[] Move ()\n\t\t{\n\t\t\tint[] indexArray;\n\t\t\tint createCount = MoveData (EmptyIndex, out indexArray);\n\n\t\t\tPuzzle[] puzzle = new Puzzle[createCount];\n\n\t\t\tfor (int lp = 0; lp < puzzle.Length; lp++)\n\t\t\t{\n\t\t\t\tint index = indexArray[lp];\n\n\t\t\t\tint[] copyArea = new int[Length];\n\t\t\t\tArea.CopyTo (copyArea, 0);\n\n\t\t\t\tvar tmp = copyArea[EmptyIndex];\n\t\t\t\tcopyArea[EmptyIndex] = copyArea[index];\n\t\t\t\tcopyArea[index] = tmp;\n\n\t\t\t\tpuzzle[lp] = new Puzzle (copyArea, Count + 1, index);\n\t\t\t}\n\n\t\t\treturn puzzle;\n\t\t}\n\n\t\tpublic static bool IsMatch ( int[] area1, int[] area2 )\n\t\t{\n\t\t\tif (area1.SequenceEqual (area2))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\n\t\tprivate int MoveData ( int emptyIndex, out int[] indexArray )\n\t\t{\n\t\t\tint createCount = -1;\n\t\t\tindexArray = null;\n\n\t\t\tswitch (emptyIndex)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 0;\n\t\t\t\t\tindexArray[1] = 2;\n\t\t\t\t\tindexArray[2] = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 0;\n\t\t\t\t\tindexArray[1] = 4;\n\t\t\t\t\tindexArray[2] = 6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tcreateCount = 4;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 3;\n\t\t\t\t\tindexArray[2] = 5;\n\t\t\t\t\tindexArray[3] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 2;\n\t\t\t\t\tindexArray[1] = 4;\n\t\t\t\t\tindexArray[2] = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 3;\n\t\t\t\t\tindexArray[1] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 4;\n\t\t\t\t\tindexArray[1] = 6;\n\t\t\t\t\tindexArray[2] = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 5;\n\t\t\t\t\tindexArray[1] = 7;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn createCount;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class Program{\n    public static int N = 3;\n    public static int[] STEPS = new int[]{0, 1, 0, -1, 0};\n    public static void Main(){\n        //var watch = new Stopwatch();\n        //watch.Start();\n        TextReader reader;\n        string filename = \"\";\n        //filename = @\"/Volumes/ExtremeDrive/CSharpProj/AOJ/ALDS/ALDS1_13B.txt\";\n        if(filename.Count()>0) reader = new StreamReader(filename);\n        else reader = Console.In;\n        \n        var Board = new int[N, N];\n        for(int i=0; i<N; i++){\n            var line = reader.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<N; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        \n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var Target = Board2Long(Goal);\n        var queue = new Queue<State>();\n        var all_list = new HashSet<long>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            if(all_list.Contains(Board2Long(curr.table)))continue;\n            else all_list.Add(Board2Long(curr.table));\n            if(Board2Long(curr.table)==Target){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n\n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            for(int i=0; i<4; i++){\n                var nx = cx+STEPS[i+1]; \n                var ny = cy+STEPS[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n        //watch.Stop();\n        //Console.WriteLine($\"????????????{watch.ElapsedMilliseconds}???????§?\");\n    }\n\n    public static long Board2Long(int[,] board){\n        var keta = board.GetLength(0)*board.GetLength(1)-1;\n        long ret = 0;\n        for(int i=0; i<board.GetLength(0); i++){\n            for(int j=0; j<board.GetLength(1); j++){\n                ret+=board[i,j]*(int)Math.Pow(10, keta-(i*board.GetLength(0)+j));\n            }\n        }\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct Puzzle\n    {\n        internal int[] f;\n        internal int space;\n        internal string path;\n\n        public Puzzle(int n)\n        {\n            f = new int[n];\n            space = default(int);\n            path = default(string);\n        }\n\n        public Puzzle(Puzzle other)\n        {\n            int len = other.f.Length;\n            f = new int[len];\n            other.f.CopyTo(f, 0);\n\n            space = other.space;\n            path = other.path;\n        }\n    }\n\n    class NPuzzle\n    {\n        readonly int n, h, w;\n\n        readonly int[] moveX = new int[] { 0, -1, 0, +1 };\n        readonly int[] moveY = new int[] { -1, 0, +1, 0 };\n        readonly char[] dir = new char[] { 'u', 'l', 'd', 'r' };\n\n        public NPuzzle(int h, int w)\n        {\n            this.h = h;\n            this.w = w;\n            n = h * w;\n        }\n\n        public string Solve(Puzzle s)\n        {\n            Queue<Puzzle> que = new Queue<Puzzle>();\n            HashSet<Puzzle> visited = new HashSet<Puzzle>();\n\n            que.Enqueue(s);\n            visited.Add(s);\n\n            while (que.Count > 0)\n            {\n                Puzzle u = que.Dequeue();\n\n                if (IsTarget(u)) return u.path;\n\n                int sx = u.space % w;\n                int sy = u.space / w;\n\n                for (int r = 0; r < 4; r++)\n                {\n                    int tx = sx + moveX[r];\n                    int ty = sy + moveY[r];\n\n                    if (!IsValid(tx, ty)) continue;\n\n                    Puzzle v = new Puzzle(u);\n\n                    int temp = v.f[u.space];\n                    v.f[u.space] = v.f[tx + ty * w];\n                    v.f[tx + ty * w] = temp;\n\n                    v.space = tx + ty * w;\n\n                    if (!visited.Contains(v))\n                    {\n                        visited.Add(v);\n                        v.path += dir[r];\n                        que.Enqueue(v);\n                    }\n                }\n            }\n            return null;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0) return false;\n            if (y < 0) return false;\n            if (x >= w) return false;\n            if (y >= h) return false;\n            return true;\n        }\n\n        private bool IsTarget(Puzzle p)\n        {\n            for (int i = 0; i < n; i++)\n            {\n                if (p.f[i] != i + 1) return false;\n            }\n            return true;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int h = 3, w = 3;\n            int n = h * w;\n\n            NPuzzle NP = new NPuzzle(h, w);\n            Puzzle s = new Puzzle(n);\n\n            for (int i = 0; i < h; i++)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                for (int j = 0; j < w; j++)\n                {\n                    int index = i * w + j;\n                    s.f[index] = input[j];\n\n                    if (input[j] == 0)\n                    {\n                        s.f[index] = n;\n                        s.space = index;\n                    }\n                }\n            }\n\n            string ans = NP.Solve(s);\n\n            Console.WriteLine(ans.Length);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var count = 0;\n        var boards = new [] { new Board(inputs) };\n        \n        while (!boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            count++;\n            boards = boards.SelectMany(x => x.Move())\n                .ToArray();\n        }\n        \n        Console.WriteLine(count);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    static HashSet<int> hash;\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        hash = new HashSet<int>(); \n    }\n    \n    public Board() { }\n    \n    public Board[] Move()\n    {\n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHashCode()))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public void SwapNode(Node left, Node right)\n    {\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n    \n    public override int GetHashCode()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n    public override bool Equals(Object o)\n    {\n        return Equals((Board)o);\n    }\n    public bool Equals(Board other)\n    {\n        return ToString() == other.ToString();\n    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    private int[] an;\n    public int[] AdjacentNumbers { get { return an; } }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        an = adjacentNumbersDic[correct];\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var count = 0;\n        var boards = new [] { new Board(inputs) };\n        \n        while (!boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            count++;\n            boards = boards.SelectMany(x => x.Move())\n                .ToArray();\n            \n             var firstLineCompleted = boards\n                 .Where(x => x.Nodes[0].Current == 1 && x.Nodes[1].Current == 2 && x.Nodes[2].Current == 3 && x.Nodes[3].Current == 4)\n               .ToArray();\n            if (firstLineCompleted.Any())\n            {\n                boards = firstLineCompleted;\n            }\n        }\n        \n        Console.WriteLine(count);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    static HashSet<int> hash = new HashSet<int>();\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n    }\n    \n    public Board() { }\n    \n    public Board[] Move()\n    {\n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHash()))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public void SwapNode(Node left, Node right)\n    {\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n        };\n    }\n\n//    public override string ToString()\n//    {\n//        return Nodes.Select(x => x.Current)\n//            .Select(x => x.ToString())\n//            .Aggregate((acc, x) => acc + \" \" + x);\n//    }\n    \n    public int GetHash()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n//    public override bool Equals(Object o)\n//    {\n//        return Equals((Board)o);\n//    }\n//    public bool Equals(Board other)\n//    {\n//        return ToString() == other.ToString();\n//    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int[] AdjacentNumbers { get; set; }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        AdjacentNumbers = adjacentNumbersDic[correct];\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class Program{\n    public static int N = 3;\n    public static int[] STEPS = new int[]{0, 1, 0, -1, 0};\n    public static void Main(){\n        /*\n        var watch = new Stopwatch();\n        watch.Start();\n        */\n        TextReader reader;\n        string filename = \"\";\n        if(filename.Count()>0) reader = new StreamReader(filename);\n        else reader = Console.In;\n        \n        var Board = new int[N, N];\n        for(int i=0; i<N; i++){\n            var line = reader.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<N; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        \n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var Target = Board2Long(Goal);\n        var queue = new Queue<State>();\n        var all_list = new HashSet<long>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            var longed = Board2Long(curr.table);\n            if(all_list.Contains(longed))continue;\n            all_list.Add(longed);\n            if(longed==Target){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n\n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            for(int i=0; i<4; i++){\n                var nx = cx+STEPS[i+1]; \n                var ny = cy+STEPS[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n        /*\n        watch.Stop();\n        Console.WriteLine($\"????????????{watch.ElapsedMilliseconds}???????§?\");\n        */\n    }\n\n    public static long Board2Long(int[,] board){\n        var keta = board.GetLength(0)*board.GetLength(1)-1;\n        long ret = 0;\n        for(int i=0; i<board.GetLength(0); i++){\n            for(int j=0; j<board.GetLength(1); j++){\n                ret+=board[i,j]*(int)Math.Pow(10, keta-(i*board.GetLength(0)+j));\n            }\n        }\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Threading;\n\npublic class Parallel\n{\n    public static void ForEach<T>(IEnumerable<T> items, Action<T> action)\n    {\n        if (items == null)\n            throw new ArgumentNullException(\"enumerable\");\n        if (action == null)\n            throw new ArgumentNullException(\"action\");\n\n        var resetEvents = new List<ManualResetEvent>();\n\n        foreach (var item in items)\n        {\n            var evt = new ManualResetEvent(false);\n            ThreadPool.QueueUserWorkItem((i) =>\n            {\n                action((T)i);\n                evt.Set();\n            }, item);\n            resetEvents.Add(evt);\n        }\n\n        WaitHandle.WaitAll(resetEvents.ToArray());\n   }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var count = 0;\n        var boards = new [] { new Board(inputs) };\n        while (!boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            count++;\n            boards = boards.SelectMany(x => x.Move())\n                .ToArray();\n        }\n        \n        Console.WriteLine(count);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    static HashSet<int> hash = new HashSet<int>();\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n    }\n    \n    public Board() { }\n    \n    public Board[] Move()\n    {\n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        Parallel.ForEach(Enumerable.Range(0, empty.AdjacentNumbers.Count()),\n            i =>\n            {\n                var adj = empty.AdjacentNumbers[i];\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHash()))\n                    children[i] = null;\n            });\n//        empty.AdjacentNumbers\n//            .ForEach((adj, i) =>\n//            {\n//                var board = children[i];\n//                var left = board.Nodes.First(x => x.Current == 0);\n//                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n//                \n//                board.SwapNode(left, right);\n//                \n//                if (!hash.Add(board.GetHash()))\n//                    children[i] = null;\n//            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public void SwapNode(Node left, Node right)\n    {\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n        };\n    }\n\n//    public override string ToString()\n//    {\n//        return Nodes.Select(x => x.Current)\n//            .Select(x => x.ToString())\n//            .Aggregate((acc, x) => acc + \" \" + x);\n//    }\n    \n    public int GetHash()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n//    public override bool Equals(Object o)\n//    {\n//        return Equals((Board)o);\n//    }\n//    public bool Equals(Board other)\n//    {\n//        return ToString() == other.ToString();\n//    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int[] AdjacentNumbers { get; set; }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        AdjacentNumbers = adjacentNumbersDic[correct];\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Text;  //StringBuilder?????????????????????????????°????????????????????????\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var StrGoal = ToStringForList(Goal);\n        var queue = new Queue<State>();\n        var all_list = new HashSet<string>();   //List??????HashSet????????´???????????????\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            var state = ToStringForList(curr.table); //ToStringForList?????????????????°state????????????????????¨??§????????????????????§??????????????????????????????\n            if(all_list.Contains(state)) continue;\n            else all_list.Add(state);\n            if(state==StrGoal){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n\n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i+1]; \n                var ny = cy+steps[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n\n    }\n\n    public static string ToStringForList(int[,] map){\n        var ret = new StringBuilder();\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret.Append(map[i, j]);\n            }\n        }\n        return ret.ToString();\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class State\n    {\n        internal int[,] map;\n        internal string moveLog;\n        internal char preMove;\n    }\n\n    class NPuzzle\n    {\n        readonly int n, h, w;\n\n        public NPuzzle(int h, int w)\n        {\n            n = h * w;\n            this.h = h;\n            this.w = w;\n        }\n\n        public string Solve(State s)\n        {\n            Queue<State> que = new Queue<State>();\n            que.Enqueue(s);\n\n            while (que.Count > 0)\n            {\n                State cur = que.Dequeue();\n\n                if (IsGoal(cur)) return cur.moveLog;\n\n                KeyValuePair<int, int> spacePos = FindSpace(cur);\n                int x = spacePos.Value;\n                int y = spacePos.Key;\n\n                if (x != 0 && cur.preMove != 'l')\n                {\n                    State saved = new State();\n                    saved.map = (int[,])cur.map.Clone();\n                    saved.map[y, x - 1] = 0;\n                    saved.map[y, x] = cur.map[y, x - 1];\n                    saved.moveLog = cur.moveLog + \"r\";\n                    saved.preMove = 'r';\n                    que.Enqueue(saved);\n                }\n\n                if (x != w - 1 && cur.preMove != 'r')\n                {\n                    State saved = new State();\n                    saved.map = (int[,])cur.map.Clone();\n                    saved.map[y, x + 1] = 0;\n                    saved.map[y, x] = cur.map[y, x + 1];\n                    saved.moveLog = cur.moveLog + \"l\";\n                    saved.preMove = 'l';\n                    que.Enqueue(saved);\n                }\n\n                if (y != 0 && cur.preMove != 'u')\n                {\n                    State saved = new State();\n                    saved.map = (int[,])cur.map.Clone();\n                    saved.map[y - 1, x] = 0;\n                    saved.map[y, x] = cur.map[y - 1, x];\n                    saved.moveLog = cur.moveLog + \"d\";\n                    saved.preMove = 'd';\n                    que.Enqueue(saved);\n                }\n\n                if (y != h - 1 && cur.preMove != 'd')\n                {\n                    State saved = new State();\n                    saved.map = (int[,])cur.map.Clone();\n                    saved.map[y + 1, x] = 0;\n                    saved.map[y, x] = cur.map[y + 1, x];\n                    saved.moveLog = cur.moveLog + \"u\";\n                    saved.preMove = 'u';\n                    que.Enqueue(saved);\n                }\n            }\n            return null;\n        }\n\n        private KeyValuePair<int, int> FindSpace(State s)\n        {\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    if (s.map[i, j] == 0) return new KeyValuePair<int, int>(i, j);\n                }\n            }\n            return new KeyValuePair<int, int>(-1, -1);\n        }\n\n        private bool IsGoal(State s)\n        {\n            int mustNumber = 0;\n\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    ++mustNumber;\n\n                    if (mustNumber != n && s.map[i, j] != mustNumber) return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int h = 3, w = 3;\n\n            NPuzzle NP = new NPuzzle(h, w);\n            State s = new State();\n            s.map = new int[h, w];\n\n            for (int i = 0; i < h; i++)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                for (int j = 0; j < w; j++)\n                {\n                    s.map[i, j] = input[j];\n                }\n            }\n\n            string ans = NP.Solve(s);\n\n            Console.WriteLine(ans.Length);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 1;\n        var boards = new [] {board}.AsEnumerable();\n        while (true)\n        {\n            boards = boards.SelectMany(x => x.Move(max));\n            if (boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n                break;\n            max++;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    private int MoveCount { get; set; }\n    \n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        MoveCount = 0;\n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .Select((adj, i) => \n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                if (left.LastNumber == right.Current)\n                {\n                    children[i] = null;\n                    return 0;\n                }\n                return board.SwapNode(left, right);\n            })\n            .ToArray();\n        \n        if (children.Where(x => x != null).Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            return children.Where(x => x != null).Where(x => x.Nodes.All(node => node.IsCorrect())).ToArray();\n        }\n        \n        if (MoveCount == max)\n            return children.Where(x => x != null).ToArray();\n        \n        return children.Where(x => x != null)\n            .SelectMany(x => x.Move(max))\n            .ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n        left.LastNumber = left.Current;\n        right.LastNumber = right.Current;\n\n        left.Current = right.LastNumber;\n        right.Current = left.LastNumber;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n}\n\npublic class Node\n{\n    private static Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 1;\n        var boards = new [] {board}.AsEnumerable();\n        while (true)\n        {\n            boards = boards.SelectMany(x => x.Move(max));\n            if (boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n                break;\n            max++;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    private int MoveCount { get; set; }\n    \n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        MoveCount = 0;\n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .Select((adj, i) => \n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                if (left.LastNumber == right.Current)\n                {\n                    children[i] = null;\n                    return 0;\n                }\n                return board.SwapNode(left, right);\n            })\n            .ToArray();\n        \n        if (children.Where(x => x != null).Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            return children.Where(x => x != null).Where(x => x.Nodes.All(node => node.IsCorrect())).ToArray();\n        }\n        \n        if (MoveCount == max)\n            return children.Where(x => x != null).ToArray();\n        \n        return children.Where(x => x != null)\n            .SelectMany(x => x.Move(max))\n            .ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n        left.LastNumber = left.Current;\n        right.LastNumber = right.Current;\n\n        left.Current = right.LastNumber;\n        right.Current = left.LastNumber;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n}\n\npublic class Node\n{\n    private static Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        int sx, sy;\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n                if(line[j]==0){\n                    sx = j;\n                    sy = i;\n                }\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var queue = new Queue<State>();\n        var all_list = new List<string>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        int c = 0;\n        while(queue.Count()>0&&c<500){\n            var curr = queue.Dequeue();\n            //Print(curr.table);\n            if(all_list.Contains(ToStringForList(curr.table)))continue;\n            else all_list.Add(ToStringForList(curr.table));\n            if(curr.table.ContentEqual(Goal)){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n            \n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i]; \n                var ny = cy+steps[i+1];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n            c++;\n        }\n        \n    }\n    \n    public static string ToStringForList(int[,] map){\n        var ret=\"\";\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret+=map[i, j];\n            }\n        }\n        return ret;\n    }\n    \n    /*\n    AOJ C# compiler is considered old version, so \"$\" keyword cant use. fuck.\n    public static void Print(int[,] map){\n        Console.WriteLine(new string(Enumerable.Repeat('-', 10).ToArray()));\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                //Console.Write($\"{map[i, j]} \");\n            }\n            Console.WriteLine();\n        }\n    }\n    */\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n    \n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}\n\npublic static class Exclass{\n    public static bool ContentEqual<T>(this T[,] array, T[,] other)where T : IComparable\n    {\n        if(array.GetLength(0)!=other.GetLength(0) || array.GetLength(1)!=other.GetLength(1)) return false;\n        for(int i=0; i<array.GetLength(0); i++){\n            for(int j=0; j<array.GetLength(1); j++){\n                if(array[i, j].CompareTo(other[i, j])!=0) return false;\n            }\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Puzzle : IComparable\n    {\n        internal int[] f;\n        internal int space, MD, cost;\n\n        public Puzzle(int n)\n        {\n            f = new int[n];\n            space = MD = cost = default(int);\n        }\n\n        public Puzzle(Puzzle source)\n        {\n            f = (int[])source.f.Clone();\n            space = source.space;\n            MD = source.MD;\n            cost = source.cost;\n        }\n\n        public override int GetHashCode()\n        {\n            return MakeString(f).GetHashCode();\n        }\n\n        public override bool Equals(object obj)\n        {\n            Puzzle other = (Puzzle)obj;\n            return MakeString(f) == MakeString(other.f);\n        }\n\n        public int CompareTo(object obj)\n        {\n            Puzzle other = (Puzzle)obj;\n            return (other.cost + other.MD) - (cost + MD);\n        }\n\n        private string MakeString(int[] arr)\n        {\n            StringBuilder sb = new StringBuilder();\n            foreach (var item in arr) sb.Append(item);\n            return sb.ToString();\n        }\n    }\n\n    class NPuzzle\n    {\n        readonly int n, h, w;\n\n        readonly int[] moveX = new int[] { 0, -1, 0, +1 };\n        readonly int[] moveY = new int[] { -1, 0, +1, 0 };\n        readonly char[] dir = new char[] { 'u', 'l', 'd', 'r' };\n\n        int[,] MDT;\n\n        public NPuzzle(int h, int w)\n        {\n            this.h = h;\n            this.w = w;\n            n = h * w;\n\n            MDT = new int[n, n];\n\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    MDT[i, j] = Math.Abs(i / h - j / w) + Math.Abs(i % h - j % w);\n        }\n\n        public int Astar(Puzzle p)\n        {\n            PriorityQueue<Puzzle> PQ = new PriorityQueue<Puzzle>();\n            p.MD = GetAllMD(p);\n\n            HashSet<Puzzle> V = new HashSet<Puzzle>();\n\n            PQ.Enqueue(p);\n\n            Puzzle u, v;\n\n            while (PQ.Count() > 0)\n            {\n                u = PQ.Dequeue();\n\n                if (u.MD == 0) return u.cost;\n\n                V.Add(u);\n\n                int sx = u.space % w;\n                int sy = u.space / w;\n\n                for (int r = 0; r < 4; r++)\n                {\n                    int tx = sx + moveX[r];\n                    int ty = sy + moveY[r];\n\n                    if (!IsValid(tx, ty)) continue;\n\n                    v = new Puzzle(u);\n\n                    int indexT = tx + ty * w;\n                    int indexS = sx + sy * w;\n\n                    v.MD -= MDT[indexT, v.f[indexT] - 1];\n                    v.MD += MDT[indexS, v.f[indexT] - 1];\n\n                    int temp = v.f[indexT];\n                    v.f[indexT] = v.f[indexS];\n                    v.f[indexS] = temp;\n\n                    v.space = indexT;\n\n                    if (!V.Contains(v))\n                    {\n                        v.cost++;\n                        PQ.Enqueue(v);\n                    }\n                }\n            }\n            return -1;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0) return false;\n            if (y < 0) return false;\n            if (x >= w) return false;\n            if (y >= h) return false;\n            return true;\n        }\n\n        private int GetAllMD(Puzzle p)\n        {\n            int sum = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                if (p.f[i] != n) sum += MDT[i, p.f[i] - 1];\n            }\n            return sum;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int h = 3, w = 3;\n            int n = h * w;\n\n            NPuzzle NP = new NPuzzle(h, w);\n            Puzzle s = new Puzzle(n);\n\n            for (int i = 0; i < h; i++)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                for (int j = 0; j < w; j++)\n                {\n                    int index = i * w + j;\n                    s.f[index] = input[j];\n\n                    if (input[j] == 0)\n                    {\n                        s.f[index] = n;\n                        s.space = index;\n                    }\n                }\n            }\n            Console.WriteLine(NP.Astar(s));\n        }\n    }\n\n    class PriorityQueue<T> where T : IComparable\n    {\n        List<T> heap;\n        int size;\n\n        public PriorityQueue() { heap = new List<T>(); }\n\n        public void Enqueue(T x)\n        {\n            heap.Add(x);\n            int i = size++;\n\n            while (i > 0)\n            {\n                int p = (i - 1) / 2;\n\n                if (Compare(heap[p], x) <= 0) break;\n\n                heap[i] = heap[p];\n                i = p;\n            }\n            heap[i] = x;\n        }\n\n        public T Dequeue()\n        {\n            T ret = heap[0];\n            T x = heap[--size];\n\n            int i = 0;\n            while (i * 2 + 1 < size)\n            {\n                int a = i * 2 + 1;\n                int b = i * 2 + 2;\n\n                if (b < size && Compare(heap[b], heap[a]) < 0)\n                    a = b;\n                if (Compare(heap[a], x) >= 0)\n                    break;\n\n                heap[i] = heap[a];\n                i = a;\n            }\n            heap[i] = x;\n            heap.RemoveAt(size);\n            return ret;\n        }\n\n        public int Count() { return size; }\n\n        private int Compare(T x, T y) { return y.CompareTo(x); }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class Program{\n    public static int N = 3;\n    public static int[] STEPS = new int[]{0, 1, 0, -1, 0};\n    public static void Main(){\n        //var watch = new Stopwatch();\n        //watch.Start();\n        string filename = \"\";\n        //filename = @\"\";\n        TextReader reader;\n        if(filename.Count()>0) reader = new StreamReader(filename);\n        else reader = Console.In;\n        \n        var Board = new int[N, N];\n        for(int i=0; i<N; i++){\n            var line = reader.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<N; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        \n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var Target = Board2Long(Goal);\n        var queue = new Queue<State>();\n        var all_list = new HashSet<long>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            if(all_list.Contains(Board2Long(curr.table)))continue;\n            else all_list.Add(Board2Long(curr.table));\n            if(Board2Long(curr.table)==Target){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n\n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            for(int i=0; i<4; i++){\n                var nx = cx+STEPS[i+1]; \n                var ny = cy+STEPS[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n        //watch.Stop();\n        //Console.WriteLine($\"????????????{watch.ElapsedMilliseconds}???????§?\");\n    }\n\n    public static long Board2Long(int[,] board){\n        var keta = board.GetLength(0)*board.GetLength(1)-1;\n        long ret = 0;\n        for(int i=0; i<board.GetLength(0); i++){\n            for(int j=0; j<board.GetLength(1); j++){\n                ret+=board[i,j]*(int)Math.Pow(10, keta-(i*board.GetLength(0)+j));\n            }\n        }\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 0;\n        var boards = new [] {board};\n        while (true)\n        {\n            max++;\n            boards = boards.SelectMany(x => x.Move(max))\n                .ToArray();\n\n            if (boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n                break;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n//    private int MoveCount { get; set; }\n    static HashSet<Board> hash;\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        hash = new HashSet<Board>(); \n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n//        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n//                if (left.LastNumber == right.Current)\n//                {\n//                    children[i] = null;\n//                }\n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n//        left.LastNumber = left.Current;\n//        right.LastNumber = right.Current;\n//\n//        left.Current = right.LastNumber;\n//        right.Current = left.LastNumber;\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n//            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n    \n    public override int GetHashCode()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n    public override bool Equals(Object o)\n    {\n        return Equals((Board)o);\n    }\n    public bool Equals(Board other)\n    {\n        return ToString() == other.ToString();\n    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n//    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current)//, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n//        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);//, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 1;\n        var boards = new [] {board};\n        while (true)\n        {\n            boards = boards.SelectMany(x => x.Move(max)).ToArray();\n            if (boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n                break;\n            max++;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    private int MoveCount { get; set; }\n    \n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .Select((adj, i) => \n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                if (left.LastNumber == right.Current)\n                {\n                    children[i] = null;\n                    return 0;\n                }\n                return board.SwapNode(left, right);\n            })\n            .ToArray();\n        \n        if (children.Where(x => x != null).Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            return children.Where(x => x != null).Where(x => x.Nodes.All(node => node.IsCorrect())).ToArray();\n        }\n            return children.Where(x => x != null).ToArray();\n        \n//        if (MoveCount == max)\n//            return children.Where(x => x != null).ToArray();\n//        \n//        return children.Where(x => x != null)\n//            .SelectMany(x => x.Move(max))\n//            .ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n        left.LastNumber = left.Current;\n        right.LastNumber = right.Current;\n\n        left.Current = right.LastNumber;\n        right.Current = left.LastNumber;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n}\n\npublic class Node\n{\n    private static Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 0;\n        var boards = new [] {board};\n        \n        while (true)\n        {\n            max++;\n            boards = boards.SelectMany(x => x.Move(max))\n                .ToArray();\n            \n            if (boards.Any(x => x.Nodes.All(node => node.IsCorrect()))) break;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n//    private int MoveCount { get; set; }\n    static HashSet<int> hash;\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        hash = new HashSet<int>(); \n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n//        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n//                if (left.LastNumber == right.Current)\n//                {\n//                    children[i] = null;\n//                }\n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHashCode()))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n//        left.LastNumber = left.Current;\n//        right.LastNumber = right.Current;\n//\n//        left.Current = right.LastNumber;\n//        right.Current = left.LastNumber;\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n//            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n    \n    public override int GetHashCode()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n    public override bool Equals(Object o)\n    {\n        return Equals((Board)o);\n    }\n    public bool Equals(Board other)\n    {\n        return ToString() == other.ToString();\n    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n//    public int LastNumber { get; set; }\n    private int[] an;\n    public int[] AdjacentNumbers { get { return an; } }\n\n    public Node(int correct, int current)//, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        an = adjacentNumbersDic[correct];\n//        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);//, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace lec13BandC\n{\n    public class Board\n    {\n        public int[] state;\n        public int space;\n        public int score;\n        public int index;\n\n        public Board()\n        {\n            state = new int[Program.N];\n            index = 0;\n        }\n\n        public void NumberIn(int n)\n        {\n            if (n == 0) { space = index; state[index] = 0; }\n            else { state[index] = n; }\n            index++;\n        }\n\n        public void Copy(Board t)\n        {\n            t.space = this.space;\n            t.score = this.score;\n            for (int i = 0; i < Program.N; i++)\n            {\n                t.state[i] = this.state[i];\n            }\n        }\n        \n        public void ScoreCheck()\n        {\n            score = 0;\n            for (int i = 0; i < Program.N; i++)\n            {\n                int  t = this.state[i]; if(t == 0) { continue; }\n                score += Program.Ruler[i,t];\n            }\n        }\n    }\n\n\n    class Program\n    {\n        public static int NO = -999;\n        public static int N;\n        public static int[,] Ruler;\n        public static int [] LIMIT_ARRAY= { 0,0,3,31,80};\n        public static int ans;\n        public static Board now;\n\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            NO = input.Length;\n            N = NO * NO;\n            Board start = new Board();\n\n            foreach (var str in input)\n            {\n                start.NumberIn(int.Parse(str));\n            }\n\n            for (int i = 1; i < NO; i++)\n            {\n                input = Console.ReadLine().Split(' ');\n                foreach (var str in input)\n                { \n                    start.NumberIn(int.Parse(str));\n                }\n            }\n\n            MakeOfRuler();\n            start.ScoreCheck();\n            now = new Board();\n            start.Copy(now);\n\n            for (ans = start.score; ans <= LIMIT_ARRAY[NO]; ans++)\n            {\n                start.Copy(now);\n                if (PazzleSrearch(0 , 999) == true)\n                {\n                    Console.WriteLine(ans);\n                    break;\n                }\n\n            }\n\n            Console.ReadLine();\n        }\n\n\n        static bool PazzleSrearch(int dep ,int prej)\n        {\n            if (now.score == 0)\n            {\n                return true;\n            }\n            else if (now.score + dep > ans)\n            {\n                return false;\n            }\n\n            Board tmp = new Board();\n            int z = now.space;\n\n            for (int j = 0; j < 4; j++)\n            {\n                int v = -100;\n                \n                switch (j)\n                {\n                    case 0:\n                        if (z < NO) { continue; }\n                        v = z  - NO;\n                        break;\n                    case 1:\n                        if ((z + 1) % NO == 0) { continue; }\n                        v = z + 1;\n                        break;\n                    case 2:\n                        if ((z + NO) >= N) { continue; }\n                        v = z + NO;\n                        break;\n                    case 3:\n                        if (z % NO == 0) { continue; }\n                        v = z - 1;\n                        break;\n                }\n                if (Math.Abs(prej - j) == 2) { continue; }\n\n                now.Copy(tmp);\n\n                now.score -= Ruler[v, now.state[v] ];\n                now.score += Ruler[z, now.state[v] ];\n\n\n                int t = now.state[v];\n                now.state[v] = now.state[z];\n                now.state[z] = t;\n\n                now.space = v;\n\n                if (PazzleSrearch(dep + 1 , j) == true)\n                {\n                    return true;\n                }\n                tmp.Copy(now);\n            }\n\n            return false;\n        }\n        \n        static void MakeOfRuler()\n        {\n            Ruler = new int[N, N];\n            for (int i = 0; i < N; i++)\n            {\n                for (int j =0; j< N; j++)\n                {\n                    int k  = Math.Abs(i / NO - j / NO) + Math.Abs(i % NO - j % NO);\n                    int tj = j + 1;\n                    if (tj == N) { tj = 0; }\n                    Ruler[i, tj] = k;\n                }\n            }\n        }\n\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var StrGoal = ToStringForList(Goal);\n        var queue = new Queue<State>();\n        var all_list = new HashSet<string>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            \n            // Console.WriteLine(all_list.Count());\n            if(ToStringForList(curr.table)==StrGoal){\n                Console.WriteLine(curr.cnt);\n                // Console.WriteLine(all_list.Count());\n                break;\n            }\n\n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i+1]; \n                var ny = cy+steps[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    // Console.WriteLine(ToStringForList(curr.table) + \" -> \" + ToStringForList(NexMap.table));\n                    if(all_list.Contains(ToStringForList(NexMap.table)))continue;\n                    all_list.Add(ToStringForList(NexMap.table));\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n\n    }\n\n    public static string ToStringForList(int[,] map){\n        var ret=\"\";\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret+=map[i, j];\n            }\n        }\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var count = 0;\n        var boards = new [] { new Board(inputs) };\n        \n        while (!boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            count++;\n            boards = boards.SelectMany(x => x.Move())\n                .ToArray();\n        }\n        \n        Console.WriteLine(count);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    static HashSet<int> hash = new HashSet<int>();\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n    }\n    \n    public Board() { }\n    \n    public Board[] Move()\n    {\n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHash()))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public void SwapNode(Node left, Node right)\n    {\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n        };\n    }\n\n//    public override string ToString()\n//    {\n//        return Nodes.Select(x => x.Current)\n//            .Select(x => x.ToString())\n//            .Aggregate((acc, x) => acc + \" \" + x);\n//    }\n    \n    public int GetHash()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n//    public override bool Equals(Object o)\n//    {\n//        return Equals((Board)o);\n//    }\n//    public bool Equals(Board other)\n//    {\n//        return ToString() == other.ToString();\n//    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    private int[] an;\n    public int[] AdjacentNumbers { get { return an; } }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        an = adjacentNumbersDic[correct];\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\npublic class Parallel\n{\n    public static void ForEach<T>(IEnumerable<T> items, Action<T> action)\n    {\n        if (items == null)\n            throw new ArgumentNullException(\"enumerable\");\n        if (action == null)\n            throw new ArgumentNullException(\"action\");\n\n        var resetEvents = new List<ManualResetEvent>();\n\n        foreach (var item in items)\n        {\n            var evt = new ManualResetEvent(false);\n            ThreadPool.QueueUserWorkItem((i) =>\n            {\n                action((T)i);\n                evt.Set();\n            }, item);\n            resetEvents.Add(evt);\n        }\n\n        foreach (var re in resetEvents)\n            re.WaitOne();\n    }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var count = 0;\n        var boards = new [] { new Board(inputs) };\n        while (!boards.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            count++;\n            boards = boards.SelectMany(x => x.Move())\n                .ToArray();\n        }\n        \n        Console.WriteLine(count);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    static HashSet<int> hash = new HashSet<int>();\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n    }\n    \n    public Board() { }\n    \n    public Board[] Move()\n    {\n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        Parallel.ForEach(Enumerable.Range(0, empty.AdjacentNumbers.Count()),\n            i =>\n            {\n                var adj = empty.AdjacentNumbers[i];\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHash()))\n                    children[i] = null;\n            });\n//        empty.AdjacentNumbers\n//            .ForEach((adj, i) =>\n//            {\n//                var board = children[i];\n//                var left = board.Nodes.First(x => x.Current == 0);\n//                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n//                \n//                board.SwapNode(left, right);\n//                \n//                if (!hash.Add(board.GetHash()))\n//                    children[i] = null;\n//            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public void SwapNode(Node left, Node right)\n    {\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n        };\n    }\n\n//    public override string ToString()\n//    {\n//        return Nodes.Select(x => x.Current)\n//            .Select(x => x.ToString())\n//            .Aggregate((acc, x) => acc + \" \" + x);\n//    }\n    \n    public int GetHash()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n//    public override bool Equals(Object o)\n//    {\n//        return Equals((Board)o);\n//    }\n//    public bool Equals(Board other)\n//    {\n//        return ToString() == other.ToString();\n//    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int[] AdjacentNumbers { get; set; }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        AdjacentNumbers = adjacentNumbersDic[correct];\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_13_B_8_Puzzle\n{\n\tclass Program\n\t{\n\t\tstatic void Main ( string[] args )\n\t\t{\n\t\t\t//input\n\t\t\tList<int> input = new List<int> (9);\n\n\t\t\tfor (int lp = 0; lp < 3; lp++)\n\t\t\t{\n\t\t\t\tint[] state = Array.ConvertAll (Console.ReadLine ().Split (' '), int.Parse);\n\t\t\t\tinput.AddRange (state);\n\t\t\t}\n\n\t\t\t//process\n\t\t\tQueue<Puzzle> puzzleQueue = new Queue<Puzzle> (1000);\n\t\t\tEqual equal = new Equal ();\n\t\t\tHashSet<int[]> puzzleState = new HashSet<int[]> (equal);\n\n\t\t\tint[] answer = { 1, 2, 3, 4, 5, 6, 7, 8, 0 };\n\n\t\t\tPuzzle p = new Puzzle (input.ToArray (), 0, input.IndexOf (0));\n\t\t\tpuzzleQueue.Enqueue (p);\n\t\t\tpuzzleState.Add (p.Area);\n\n\t\t\twhile (puzzleQueue.Count != 0)\n\t\t\t{\n\t\t\t\tPuzzle item = puzzleQueue.Dequeue ();\n\n\t\t\t\tif (Puzzle.IsMatch (item.Area, answer))\n\t\t\t\t{\n\t\t\t\t\tConsole.WriteLine (item.Count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tPuzzle[] next = item.Move ();\n\n\t\t\t\tforeach (var element in next)\n\t\t\t\t{\n\t\t\t\t\tif (puzzleState.Add (element.Area))\n\t\t\t\t\t{\n\t\t\t\t\t\tpuzzleQueue.Enqueue (element);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tclass Puzzle\n\t{\n\t\tpublic Puzzle ( int[] area, int count, int emptyIndex )\n\t\t{\n\t\t\tthis.Area = new int[Length];\n\t\t\tarea.CopyTo (this.Area, 0);\n\t\t\tthis.Count = count;\n\t\t\tthis.EmptyIndex = emptyIndex;\n\t\t}\n\n\t\tpublic int[] Area { private set; get; }\n\t\tpublic int Count { private set; get; }\n\t\tprivate int EmptyIndex { set; get; }\n\n\t\tprivate const int Length = 9;\n\n\t\tpublic Puzzle[] Move ()\n\t\t{\n\t\t\tint[] indexArray;\n\t\t\tint createCount = MoveData (EmptyIndex, out indexArray);\n\n\t\t\tPuzzle[] puzzle = new Puzzle[createCount];\n\n\t\t\tfor (int lp = 0; lp < puzzle.Length; lp++)\n\t\t\t{\n\t\t\t\tint index = indexArray[lp];\n\n\t\t\t\tint[] copyArea = new int[Length];\n\t\t\t\tArea.CopyTo (copyArea, 0);\n\n\t\t\t\tvar tmp = copyArea[EmptyIndex];\n\t\t\t\tcopyArea[EmptyIndex] = copyArea[index];\n\t\t\t\tcopyArea[index] = tmp;\n\n\t\t\t\tpuzzle[lp] = new Puzzle (copyArea, Count + 1, index);\n\t\t\t}\n\n\t\t\treturn puzzle;\n\t\t}\n\n\t\tpublic static bool IsMatch ( int[] area1, int[] area2 )\n\t\t{\n\t\t\tif (area1.SequenceEqual (area2))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\n\t\tprivate int MoveData ( int emptyIndex, out int[] indexArray )\n\t\t{\n\t\t\tint createCount = 0;\n\t\t\tindexArray = null;\n\n\t\t\tswitch (emptyIndex)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 0;\n\t\t\t\t\tindexArray[1] = 2;\n\t\t\t\t\tindexArray[2] = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 0;\n\t\t\t\t\tindexArray[1] = 4;\n\t\t\t\t\tindexArray[2] = 6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tcreateCount = 4;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 1;\n\t\t\t\t\tindexArray[1] = 3;\n\t\t\t\t\tindexArray[2] = 5;\n\t\t\t\t\tindexArray[3] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 2;\n\t\t\t\t\tindexArray[1] = 4;\n\t\t\t\t\tindexArray[2] = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 3;\n\t\t\t\t\tindexArray[1] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\tcreateCount = 3;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 4;\n\t\t\t\t\tindexArray[1] = 6;\n\t\t\t\t\tindexArray[2] = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\tcreateCount = 2;\n\t\t\t\t\tindexArray = new int[createCount];\n\t\t\t\t\tindexArray[0] = 5;\n\t\t\t\t\tindexArray[1] = 7;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn createCount;\n\t\t}\n\t}\n\n\tclass Equal : EqualityComparer<int[]>\n\t{\n\t\tpublic override bool Equals ( int[] area1, int[] area2 )\n\t\t{\n\t\t\treturn area1.SequenceEqual (area2);\n\t\t}\n\t\tpublic override int GetHashCode ( int[] item )\n\t\t{\n\t\t\treturn base.GetHashCode ();\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing static System.Math;\nusing MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;\nusing MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;\n\npublic static class P\n{\n    public static void Main()\n    {\n        ulong data = 0UL;\n        int pos = 0;\n        int shift = 64;\n        for (int i = 0; i < 3; i++)\n        {\n            foreach (var item in Console.ReadLine().Split().Select(ulong.Parse))\n            {\n                shift -= 4;\n                data |= item << shift;\n                if (item == 0) pos = shift / 4;\n            }\n            shift -= 4;\n        }\n        Dictionary<ulong, int> dists = new Dictionary<ulong, int>();\n        PriorityQueue<Board, int> pqueue = new PriorityQueue<Board, int>(x => dists[x.Data]);\n        //Stack<Board> pqueue = new Stack<Board>();\n        dists.Add(data, 0);\n        pqueue.Push(new Board() { Data = data, Pos = pos });\n        while (pqueue.Count > 0)\n        {\n            var board = pqueue.Pop();\n            var dist = dists[board.Data];\n            foreach (var next in board.Next)\n            {\n                if (!dists.ContainsKey(next.Data)) dists.Add(next.Data, int.MaxValue);\n                if (dists[next.Data] <= dist + 1) continue;\n                //if (45 < dist + next.IncorrectCount) continue;\n                dists[next.Data] = dist + 1;\n                if (next.Data == Board.CorrectData) goto end;\n                pqueue.Push(next);\n            }\n        }\n        end:;\n        Console.WriteLine(dists[Board.CorrectData]);\n    }\n}\n\n\nclass PriorityQueue<TValue, TKey> where TKey : IComparable<TKey>\n{\n    public int Count { get; private set; }\n    private Func<TValue, TKey> KeySelector;\n    private bool Descendance;\n    private TValue[] data = new TValue[65536];\n    private TKey[] keys = new TKey[65536];\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public PriorityQueue(Func<TValue, TKey> keySelector, bool descendance = false) { KeySelector = keySelector; Descendance = descendance; }\n    public TValue Top\n    {\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        get { ValidateNonEmpty(); return data[1]; }\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public TValue Pop()\n    {\n        var top = Top;\n        var item = data[Count];\n        var key = keys[Count--];\n        int index = 1;\n        while (true)\n        {\n            if ((index << 1) >= Count)\n            {\n                if (index << 1 > Count) break;\n                if (key.CompareTo(keys[index << 1]) > 0 ^ Descendance)\n                { data[index] = data[index << 1]; keys[index] = keys[index << 1]; index <<= 1; }\n                else break;\n            }\n            else\n            {\n                var nextIndex = keys[index << 1].CompareTo(keys[(index << 1) + 1]) <= 0 ^ Descendance ? (index << 1) : (index << 1) + 1;\n                if (key.CompareTo(keys[nextIndex]) > 0 ^ Descendance)\n                { data[index] = data[nextIndex]; keys[index] = keys[nextIndex]; index = nextIndex; }\n                else break;\n            }\n        }\n        data[index] = item;\n        keys[index] = key;\n        return top;\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public void Push(TValue item)\n    {\n        var key = KeySelector(item);\n        int index = ++Count;\n        if (data.Length == Count) Extend(data.Length * 2);\n        while ((index >> 1) != 0)\n        {\n            if (keys[index >> 1].CompareTo(key) > 0 ^ Descendance)\n            { data[index] = data[index >> 1]; keys[index] = keys[index >> 1]; index >>= 1; }\n            else break;\n        }\n        data[index] = item;\n        keys[index] = key;\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    private void Extend(int newSize)\n    {\n        TValue[] newData = new TValue[newSize];\n        TKey[] newKeys = new TKey[newSize];\n        data.CopyTo(newData, 0);\n        keys.CopyTo(newKeys, 0);\n        data = newData;\n        keys = newKeys;\n    }\n    private void ValidateNonEmpty() { if (Count == 0) throw new IndexOutOfRangeException(); }\n}\n\nstruct Board\n{\n    public const ulong CorrectData = 0x1230456078000000;\n    public ulong Data;\n    public int Pos;\n\n    public IEnumerable<Board> Next\n    {\n        get\n        {\n            if ((Pos & 2) != 0) yield return new Board() { Data = Swap(Data, Pos, Pos - 1), Pos = Pos - 1 };\n            if ((Pos & 3) != 3) yield return new Board() { Data = Swap(Data, Pos, Pos + 1), Pos = Pos + 1 };\n            if (8 <= Pos) yield return new Board() { Data = Swap(Data, Pos, Pos - 4), Pos = Pos - 4 };\n            if (Pos < 12) yield return new Board() { Data = Swap(Data, Pos, Pos + 4), Pos = Pos + 4 };\n        }\n    }\n\n    public int IncorrectCount => NonZeroCellCount(Data ^ CorrectData);\n    static private int NonZeroCellCount(ulong data)\n    {\n        if (data == 0) return 0;\n        data |= data >> 1;\n        data |= data >> 2;\n        data &= 0x1111111111111111UL;\n        data *= 0x1111111111111111UL;\n        data >>= 60;\n        if (data == 0) data = 16;\n        return (int)data;\n    }\n\n    static private ulong Swap(ulong data, int pos1, int pos2)\n    {\n        var xoredData = ((data >> pos1 * 4) ^ (data >> pos2 * 4)) & 0xf;\n        data ^= xoredData << pos1 * 4;\n        data ^= xoredData << pos2 * 4;\n        return data;\n    }\n\n    public override string ToString() => Data.ToString(\"x\");\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var StrGoal = ToStringForList(Goal);\n        var queue = new Queue<State>();\n        var all_list = new HashSet<string>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            if(all_list.Contains(ToStringForList(curr.table)))continue;\n            else all_list.Add(ToStringForList(curr.table));\n            if(ToStringForList(curr.table)==StrGoal){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n\n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i+1]; \n                var ny = cy+steps[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n\n    }\n\n    public static string ToStringForList(int[,] map){\n        var ret=\"\";\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret+=map[i, j];\n            }\n        }\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var StrGoal = ToStringForList(Goal);\n        var queue = new Queue<State>();\n        var all_list = new List<string>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            if(all_list.Contains(ToStringForList(curr.table)))continue;\n            else all_list.Add(ToStringForList(curr.table));\n            if(ToStringForList(curr.table)==StrGoal){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n\n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i+1]; \n                var ny = cy+steps[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n\n    }\n\n    public static string ToStringForList(int[,] map){\n        var ret=\"\";\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret+=map[i, j];\n            }\n        }\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var StrGoal = ToStringForList(Goal);\n        // Console.WriteLine(StrGoal);\n        var queue = new Queue<State>();\n        var all_list = new HashSet<int>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            // Console.WriteLine(all_list.Count());\n            if(ToStringForList(curr.table)==StrGoal){\n                Console.WriteLine(curr.cnt);\n                // Console.WriteLine(all_list.Count());\n                break;\n            }\n\n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i+1]; \n                var ny = cy+steps[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    // Console.WriteLine(ToStringForList(curr.table) + \" -> \" + ToStringForList(NexMap.table));\n                    if(all_list.Contains(ToStringForList(NexMap.table)))continue;\n                    all_list.Add(ToStringForList(NexMap.table));\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n\n    }\n\n    public static int ToStringForList(int[,] map){\n        var ret=0;\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret = ret * 10 + map[i, j];\n            }\n        }\n        return ret;\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 1;\n        while (board.Move(max) == -1)\n        {\n            board = new Board(inputs);\n            max++;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n    public int MoveCount { get; set; }\n    \n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        MoveCount = 0;\n    }\n    \n    public Board() { }\n    \n    public int Move(int max)\n    {\n        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .Select((adj, i) => \n            {\n                var board = children[i];\n                return board.SwapNode(board.Nodes.First(x => x.Current == 0), board.Nodes.First(x => x.CorrectNumber == adj));\n            })\n            .ToArray();\n        \n        if (children.Any(x => x.Nodes.All(node => node.IsCorrect())))\n        {\n            return MoveCount;\n        }\n        \n        if (MoveCount == max)\n            return -1;\n        \n        return children.Select(x => x.Move(max))\n            .Where(x => x != -1)\n            .DefaultIfEmpty(-1)\n            .Min();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n        var temp = right.Current;\n        right.Current = left.Current;\n        left.Current = temp;\n        \n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n}\n\npublic class Node\n{\n    private static Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n    public int LastNumber { get; set; }\n    public int[] AdjacentNumbers { get { return adjacentNumbersDic[CorrectNumber]; } }\n\n    public Node(int correct, int current)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        LastNumber = -1;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Text;  //StringBuilder?????????????????????????????°????????????????????????\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var StrGoal = ToStringForList(Goal);\n        var queue = new Queue<State>();\n        var all_list = new HashSet<string>();   //List??????HashSet????????´???????????????\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        while(queue.Count()>0){\n            var curr = queue.Dequeue();\n            var state = ToStringForList(curr.table); //ToStringForList?????????????????°state????????????????????¨??§????????????????????§??????????????????????????????\n            if(all_list.Contains(state)) continue;\n            else all_list.Add(state);\n            if(state==StrGoal){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n\n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i+1]; \n                var ny = cy+steps[i];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n        }\n\n    }\n\n    public static string ToStringForList(int[,] map){\n        var ret = new StringBuilder();\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret.Append(map[i, j]);\n            }\n        }\n        return ret.ToString();\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n\n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct Puzzle\n    {\n        internal int[] f;\n        internal int space, MD;\n\n        public Puzzle(int n)\n        {\n            f = new int[n];\n            space = MD = default(int);\n        }\n\n        public Puzzle(Puzzle source)\n        {\n            f = (int[])source.f.Clone();\n\n            space = source.space;\n            MD = source.MD;\n        }\n    }\n\n    class NPuzzle\n    {\n        readonly int Limit = 50;\n        readonly int n, h, w;\n\n        readonly int[] moveX = new int[] { 0, -1, 0, +1 };\n        readonly int[] moveY = new int[] { -1, 0, +1, 0 };\n        readonly char[] dir = new char[] { 'u', 'l', 'd', 'r' };\n\n        int limit;\n        int[] path;\n        int[,] MDT;\n\n        public NPuzzle(int h, int w)\n        {\n            this.h = h;\n            this.w = w;\n            n = h * w;\n\n            MDT = new int[n, n];\n            path = new int[Limit];\n\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    MDT[i, j] = Math.Abs(i / h - j / w) + Math.Abs(i % h - j % w);\n                }\n            }\n        }\n\n        public string IterativeDeeping(Puzzle p)\n        {\n            StringBuilder ret = new StringBuilder();\n            Puzzle state;\n\n            p.MD = GetAllMD(p);\n\n            for (limit = p.MD; limit <= Limit; limit++)\n            {\n                state = new Puzzle(p);\n\n                if (DFS(state, 0, -50))\n                {\n                    for (int i = 0; i < limit; i++)\n                    {\n                        ret.Append(dir[path[i]]);\n                    }\n                    return ret.ToString();\n                }\n            }\n            return null;\n        }\n\n        private bool DFS(Puzzle state, int depth, int prev)\n        {\n            if (state.MD == 0) return true;\n\n            if (depth + state.MD > limit) return false;\n\n            int sx = state.space % w;\n            int sy = state.space / w;\n\n            Puzzle tempState;\n\n            for (int r = 0; r < 4; r++)\n            {\n                int tx = sx + moveX[r];\n                int ty = sy + moveY[r];\n\n                if (!IsValid(tx, ty)) continue;\n\n                if (Math.Abs(prev - r) == 2) continue;\n\n                tempState = new Puzzle(state);\n\n                int indexT = tx + ty * w;\n                int indexS = sx + sy * w;\n\n                state.MD -= MDT[indexT, state.f[indexT] - 1];\n                state.MD += MDT[indexS, state.f[indexT] - 1];\n\n                int temp = state.f[indexT];\n                state.f[indexT] = state.f[indexS];\n                state.f[indexS] = temp;\n\n                state.space = indexT;\n\n                if (DFS(state, depth + 1, r))\n                {\n                    path[depth] = r;\n                    return true;\n                }\n\n                state = tempState;\n            }\n            return false;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0) return false;\n            if (y < 0) return false;\n            if (x >= w) return false;\n            if (y >= h) return false;\n            return true;\n        }\n\n        private int GetAllMD(Puzzle p)\n        {\n            int sum = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                if (p.f[i] != n) sum += MDT[i, p.f[i] - 1];\n            }\n            return sum;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int h = 3, w = 3;\n            int n = h * w;\n\n            NPuzzle NP = new NPuzzle(h, w);\n            Puzzle s = new Puzzle(n);\n\n            for (int i = 0; i < h; i++)\n            {\n                int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                for (int j = 0; j < w; j++)\n                {\n                    int index = i * w + j;\n                    s.f[index] = input[j];\n\n                    if (input[j] == 0)\n                    {\n                        s.f[index] = n;\n                        s.space = index;\n                    }\n                }\n            }\n\n            string ans = NP.IterativeDeeping(s);\n\n            Console.WriteLine(ans != null ? ans.Length : 0);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n\n\n\npublic class EightPuzzle\n{\n    public static void Main()\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse)\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Concat(Console.ReadLine().Split(' ').Select(int.Parse))\n            .Cast<int>()\n            .ToArray();\n        \n        var board = new Board(inputs);\n        \n        var max = 0;\n        var boards = new [] {board};\n        \n        while (true)\n        {\n            max++;\n            boards = boards.SelectMany(x => x.Move(max))\n                .ToArray();\n            \n            if (boards.Any(x => x.Nodes.All(node => node.IsCorrect()))) break;\n        }\n        \n        Console.WriteLine(max);\n    }\n}\n\npublic class Board\n{\n    public Node[] Nodes { get; set; }\n//    private int MoveCount { get; set; }\n    static HashSet<int> hash;\n    public Board(IEnumerable<int> inputs)\n    {\n        Nodes = inputs.Select((x, i) => new Node((i + 1) % 9, x))\n            .ToArray();\n        hash = new HashSet<int>(); \n    }\n    \n    public Board() { }\n    \n    public Board[] Move(int max)\n    {\n//        MoveCount++;\n        \n        var empty = Nodes.First(x => x.Current == 0);\n        var children = empty.AdjacentNumbers\n            .Select(_ => Board.Clone(this))\n            .ToArray();\n        \n        empty.AdjacentNumbers\n            .ForEach((adj, i) =>\n            {\n                var board = children[i];\n                var left = board.Nodes.First(x => x.Current == 0);\n                var right = board.Nodes.First(x => x.CorrectNumber == adj);\n                \n//                if (left.LastNumber == right.Current)\n//                {\n//                    children[i] = null;\n//                }\n                board.SwapNode(left, right);\n                \n                if (!hash.Add(board.GetHashCode()))\n                    children[i] = null;\n            });\n        \n        return children.Where(x => x != null).ToArray();\n    }\n    \n    public int SwapNode(Node left, Node right)\n    {\n//        left.LastNumber = left.Current;\n//        right.LastNumber = right.Current;\n//\n//        left.Current = right.LastNumber;\n//        right.Current = left.LastNumber;\n        var temp = left.Current;\n        left.Current = right.Current;\n        right.Current = temp;\n        return 0; // dummy\n    }\n    \n    private static Board Clone(Board board)\n    {\n        return new Board\n        {\n            Nodes = board.Nodes.Select(Node.Clone)\n                .ToArray(),\n//            MoveCount = board.MoveCount\n        };\n    }\n\n    public override string ToString()\n    {\n        return Nodes.Select(x => x.Current)\n            .Select(x => x.ToString())\n            .Aggregate((acc, x) => acc + \" \" + x);\n    }\n    \n    public override int GetHashCode()\n    {\n        var code = Nodes.Select(x => x.Current).Aggregate((accum, x) => accum * 10 + x);\n        return code;\n    }\n    public override bool Equals(Object o)\n    {\n        return Equals((Board)o);\n    }\n    public bool Equals(Board other)\n    {\n        return ToString() == other.ToString();\n    }\n}\n\npublic class Node\n{\n    private static readonly Dictionary<int, int[]> adjacentNumbersDic =\n        new Dictionary<int, int[]>\n        {\n            { 1, new [] { 2, 4 } },\n            { 2, new [] { 1, 3, 5 } },\n            { 3, new [] { 2, 6 } },\n            { 4, new [] { 1, 5, 7 } },\n            { 5, new [] { 2, 4, 6, 8 } },\n            { 6, new [] { 3, 5, 0 } },\n            { 7, new [] { 4, 8 } },\n            { 8, new [] { 5, 7, 0 } },\n            { 0, new [] { 6, 8 } },\n        };\n\n    public int CorrectNumber { get; private set; }    \n    public int Current { get; set; }\n//    public int LastNumber { get; set; }\n    private int[] an;\n    public int[] AdjacentNumbers { get { return an; } }\n\n    public Node(int correct, int current)//, int lastNumber = -1)\n    {\n        CorrectNumber = correct;\n        Current = current;\n        an = adjacentNumbersDic[correct];\n//        LastNumber = lastNumber;\n    }\n    \n    public static Node Clone(Node node)\n    {\n        return new Node(node.CorrectNumber, node.Current);//, node.LastNumber);\n    }\n    \n    public bool IsCorrect() { return CorrectNumber == Current; }\n}\n\npublic static class a\n{\n\tpublic static void ForEach<T>(this IEnumerable<T> e, Action<T, int> action)\n\t{\n\t\tvar i = 0;\n\t\tforeach (var element in e) action(element, i++);\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program{\n    public static void Main(){\n        var Board = new int[3, 3];\n        int sx, sy;\n        for(int i=0; i<3; i++){\n            var line = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            for(int j=0; j<3; j++){\n                Board[i, j] = line[j];\n                if(line[j]==0){\n                    sx = j;\n                    sy = i;\n                }\n            }\n        }\n        var Goal = new int[,]{ {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };\n        var queue = new Queue<State>();\n        var all_list = new List<string>();\n        queue.Enqueue(new State{table = Board, cnt = 0});\n        int c = 0;\n        while(queue.Count()>0&&c<500){\n            var curr = queue.Dequeue();\n            //Print(curr.table);\n            if(all_list.Contains(ToStringForList(curr.table)))continue;\n            else all_list.Add(ToStringForList(curr.table));\n            if(curr.table.ContentEqual(Goal)){\n                Console.WriteLine(curr.cnt);\n                break;\n            }\n            \n            var Now = curr.GetPos();\n            var cx = Now.X;\n            var cy = Now.Y;\n            var steps = new int[]{0, 1, 0, -1, 0};\n            for(int i=0; i<4; i++){\n                var nx = cx+steps[i]; \n                var ny = cy+steps[i+1];\n                if(0<=nx && nx<Board.GetLength(1) && 0<=ny && ny<Board.GetLength(0)){\n                    var Nex = new Pos{Y = ny, X = nx};\n                    var NexMap = curr.Swap(Nex, Now);\n                    queue.Enqueue(NexMap);\n                }\n            }\n            c++;\n        }\n        \n    }\n    \n    public static string ToStringForList(int[,] map){\n        var ret=\"\";\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                ret+=map[i, j];\n            }\n        }\n        return ret;\n    }\n    \n    public static void Print(int[,] map){\n        Console.WriteLine(new string(Enumerable.Repeat('-', 10).ToArray()));\n        for(int i=0; i<map.GetLength(0); i++){\n            for(int j=0; j<map.GetLength(1); j++){\n                Console.Write($\"{map[i, j]} \");\n            }\n            Console.WriteLine();\n        }\n    }\n}\n\npublic struct Pos{\n    public int X{set; get;}\n    public int Y{set; get;}\n}\n\npublic struct State{\n    public int cnt{set; get;}\n    public int[,] table{set; get;}\n    public Pos GetPos(){\n        var retPos = new Pos{X = -1, Y = -1};\n        for(int i=0; i<this.table.GetLength(0); i++){\n            for(int j=0; j<this.table.GetLength(1); j++){\n                if(this.table[i, j]==0){\n                    retPos.X = j;\n                    retPos.Y = i;\n                }\n            }\n        }\n        return retPos;\n    }\n    \n    public State Swap(Pos pre, Pos nex){\n        var _tmp = this.table.Clone() as int[,];\n        var _cnt = this.cnt;\n        _tmp[nex.Y, nex.X] = this.table[pre.Y, pre.X];\n        _tmp[pre.Y, pre.X] = this.table[nex.Y, nex.X];\n        return new State{cnt = _cnt+=1, table = _tmp};\n    }\n}\n\npublic static class Exclass{\n    public static bool ContentEqual<T>(this T[,] array, T[,] other)where T : IComparable\n    {\n        if(array.GetLength(0)!=other.GetLength(0) || array.GetLength(1)!=other.GetLength(1)) return false;\n        for(int i=0; i<array.GetLength(0); i++){\n            for(int j=0; j<array.GetLength(1); j++){\n                if(array[i, j].CompareTo(other[i, j])!=0) return false;\n            }\n        }\n        return true;\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "class Node {\n  constructor(board = [], zeroIndex = null, parent = null) {\n    this.board = board;\n    this.zeroIndex = zeroIndex || this.getZeroIndex();\n    this.parent = parent;\n  }\n\n  getZeroIndex() {return this.board.indexOf(0);}\n\n  get depth() {\n    let node = this, depth = 0;\n    while ((node = node.parent)) depth++;\n    return depth;\n  }\n}\n\nclass EightPazzle {\n  init() {\n    EightPazzle.inited = true;\n    EightPazzle.correct_board = [1, 2, 3, 4, 5, 6, 7, 8, 0];\n    EightPazzle.adjLists = [\n      [1, 3], [0, 2, 4], [1, 5],\n      [0, 4, 6], [1, 3, 5, 7], [2, 4, 8],\n      [3, 7], [4, 6, 8], [5, 7]\n    ];\n  }\n\n  constructor(begin_board) {\n    EightPazzle.inited || this.init();\n    this.cache = {begin_board: true};\n    this.queue = [new Node(begin_board)];\n  }\n\n  solve() {\n    const cb = EightPazzle.correct_board.toString();\n    const isCorrect = (n) => n.board.toString() === cb;\n    if (isCorrect(this.queue[0])) return this.queue[0];\n\n    let node, newNode, board, zeroIdx, flg;\n    while ((node = this.queue.shift()) !== undefined) {\n      zeroIdx = node.zeroIndex;\n      \n      flg = EightPazzle.adjLists[zeroIdx].some(next => {\n        board = [].concat(node.board);\n        board[zeroIdx] = [board[next], board[next] = board[zeroIdx]][0];\n        newNode = new Node(board, next, node);\n        if (!this.cache[board]) {\n          if (isCorrect(newNode)) return true;\n          this.cache[board] = true;\n          this.queue.push(newNode);\n        }\n        return false;\n      });\n      if (flg) return newNode;\n    }\n  }\n}\n\n(function main() {\n  const board = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split(/[ \\n]/).map(Number);\n  const E = new EightPazzle(board);\n  console.log(E.solve().depth);\n})();\n\n"
  },
  {
    "language": "JavaScript",
    "code": "function puzzle(){\n   var obj={};\n   obj[\"123456780\"]=0;\n   var dy=[-1,0,0,1];\n   var dx=[0,-1,1,0];\n   var V=[1,2,3,4,5,6,7,8,0];\n   var P=[[V,0]];\n   while(P.length>0){\n      var A=P.shift();\n      var arr=A[0];\n      var cnt=A[1];\n      var index=arr.indexOf(0);\n      var y=Math.floor(index/3);\n      var x=index%3;\n      var yx=[arr.slice(0,3),arr.slice(3,6),arr.slice(6,9)];\n      for(var i=0;i<4;i++){\n         var yy=y+dy[i];\n         var xx=x+dx[i];\n         if(yy<0 || xx<0 || yy>=3 || xx>=3)continue;\n         yx[y][x]=yx[yy][xx];\n         var card=yx[yy][xx];\n         yx[yy][xx]=0;\n         var YX=yx[0].concat(yx[1],yx[2]);\n         var str=YX.join(\"\");\n         if(obj.hasOwnProperty(str)==false){\n               obj[str]=cnt+1;\n               P.push([YX,cnt+1]);\n         }\n         yx[yy][xx]=card;\n         yx[y][x]=0;\n      }\n   }\n   return obj;\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar str=(input.trim()).replace(/\\n|\\s/g,\"\");\nvar PUZZLE=puzzle();\nconsole.log(PUZZLE[str]);"
  },
  {
    "language": "JavaScript",
    "code": "//config = { input: 'tmp', newline: '\\r\\n' }; // win\nconfig = { input: '/dev/stdin', newline: '\\n' }; // linux\n\nconst assert = require('assert');\n\nconst SIZE = 9;\n\ninit = require('fs').readFileSync(config.input, 'ascii')\n  .trim()\n  .split(config.newline)\n  .join('')\n  .replace(/ /g, '');\ngoal = [];\nfor (i = 1; i < SIZE; i++) goal.push(i);\ngoal = goal.join('') + '0';\n\ncnt = 0;\nstep = {};\nnext = [];\nfunction register_string(str, next, cnt) {\n  if (!step.hasOwnProperty(str)) {\n    step[str] = cnt;\n    next.push(str);\n  }\n}\nregister_string(init, next, cnt);\n\nfunction switch_array(ary, i, j) {\n  var tmp = ary[i];\n  ary[i] = ary[j];\n  ary[j] = tmp;\n}\n\nfunction register(ary, next, i, j, cnt) {\n  switch_array(ary, i, j);\n  register_string(ary.join(''), next, cnt);\n  switch_array(ary, i, j);\n}\n\nfunction widen(cur) {\n  var next = [], i, ary, idx0;\n  cnt++;\n  for (i in cur) {\n    ary = cur[i].split('');\n    idx0 = ary.indexOf('0');\n    if (idx0 === 0) {\n      register(ary, next, 0, 1, cnt);\n      register(ary, next, 0, 3, cnt);\n    } else if (idx0 === 1) {\n      register(ary, next, 1, 0, cnt);\n      register(ary, next, 1, 2, cnt);\n      register(ary, next, 1, 4, cnt);\n    } else if (idx0 === 2) {\n      register(ary, next, 2, 1, cnt);\n      register(ary, next, 2, 5, cnt);\n    } else if (idx0 === 3) {\n      register(ary, next, 3, 0, cnt);\n      register(ary, next, 3, 4, cnt);\n      register(ary, next, 3, 6, cnt);\n    } else if (idx0 === 4) {\n      register(ary, next, 4, 1, cnt);\n      register(ary, next, 4, 3, cnt);\n      register(ary, next, 4, 5, cnt);\n      register(ary, next, 4, 7, cnt);\n    } else if (idx0 === 5) {\n      register(ary, next, 5, 2, cnt);\n      register(ary, next, 5, 4, cnt);\n      register(ary, next, 5, 8, cnt);\n    } else if (idx0 === 6) {\n      register(ary, next, 6, 3, cnt);\n      register(ary, next, 6, 7, cnt);\n    } else if (idx0 === 7) {\n      register(ary, next, 7, 4, cnt);\n      register(ary, next, 7, 6, cnt);\n      register(ary, next, 7, 8, cnt);\n    } else if (idx0 === 8) {\n      register(ary, next, 8, 5, cnt);\n      register(ary, next, 8, 7, cnt);\n    }\n  }\n  return next;\n}\n\nwhile (next.indexOf(goal) === -1)\n  next = widen(next);\nconsole.log(cnt);"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nMove = [ [1, 3], [0, 2, 4], [1, 5],\n         [0, 4, 6], [1, 3, 5, 7], [2, 4, 8],\n         [3, 7], [4, 6, 8], [5, 7] ]\n\nFactorials = (1...9).each_with_object([1]){ |i, arr| arr << arr[-1] * i }.reverse\n\ndef create_hash(brd)\n  b = brd.dup\n  9.times do |i|\n    (i+1...9).each do |j|\n      b[j] -= 1 if b[i] < b[j]\n    end\n  end\n  9.times.reduce(0){ |sum, i| sum += b[i] * Factorials[i] }\nend\n\ndef dehash(key)\n  brd = 9.times.map { |i| d, key = key.divmod(Factorials[i]); d }\n  8.downto(0) do |i|\n    (i+1...9).each do |j|\n      brd[j] += 1 if brd[j] >= brd[i]\n    end\n  end\n  brd\nend\n\nGoal = create_hash([1,2,3,4,5,6,7,8,0])\n\nbrd = 3.times.map{ gets.split.map(&:to_i) }.flatten\nq = [[k = create_hash(brd), 0]]\nans = -1\nset = Set.new([])\nset.add(k)\nuntil q.empty?\n  key, cnt = q.shift\n  if key == Goal\n    ans = cnt\n    break\n  end\n  b = dehash(key)\n  n = b.index(0)\n  Move[n].each do |m|\n    b[n], b[m] = b[m], b[n]\n    k = create_hash(b)\n    unless set.include?(k)\n      set.add(k)\n      q << [k, cnt + 1]\n    end\n    b[n], b[m] = b[m], b[n]\n  end\nend\np ans"
  },
  {
    "language": "Ruby",
    "code": "class Puzzle\n  attr_accessor :mat, :step, :cost\n  def initialize(mat, step)\n    @mat = mat\n    @step = step\n    @cost = distance\n  end\n  def >(other)\n    return self.cost + self.step < other.cost + other.step ? true : false\n  end\n  def <(other)\n    return self.cost + self.step > other.cost + other.step ? true : false\n  end\n  def distance\n    goal = [1,2,3,4,5,6,7,8,0]\n    d = 0\n    goal.size.times{|i|\n      d += (@mat.index(goal[i]) - i).abs\n    }\n    return d\n  end\nend\n\ndef cal(mat)\n    goal = [1,2,3,4,5,6,7,8,0]\n    d = 0\n    9.times{|i|\n      d += 1 if mat[i] != goal[i]\n    }\n    return d\nend\n\nclass Heep\n  def initialize\n    @node = []\n  end\n  def insert(num)\n    i = @node.size\n    @node[i] = num\n    p = (i+1)/2-1\n    while i > 0 && @node[p] < @node[i]\n      @node[i], @node[p] = @node[p], @node[i]\n      i = p\n      p = (i+1)/2-1\n    end\n  end\n  def extract\n    ret = @node[0]\n    if @node.size > 1\n      @node[0] = @node.pop()\n      maxHeapify(0)\n    else\n      @node = []\n    end\n    return ret\n  end\n  def maxHeapify(i)\n    h = @node.size\n    largest = i\n    l = 2 * i + 1\n    largest = l if l < h && @node[l] > @node[largest]\n    r = 2 * i + 2\n    largest = r if r < h && @node[r] > @node[largest]\n    if largest != i then\n      @node[i], @node[largest] = @node[largest], @node[i]\n      maxHeapify(largest)\n    end\n  end\n  def size\n    return @node.size\n  end\n  def contain(node)\n    if @node.index(node) == nil\n      return false\n    else\n      return true\n    end\n  end\nend\n\nmat = []\n3.times{|i|\n  mat[3*i], mat[3*i+1], mat[3*i+2] = gets.split.map(&:to_i)\n}\n\nini = Puzzle.new(mat, 0)\nq = Heep.new\nq.insert(ini)\n\ndone = {}\nloop do\n  break if q.size == 0\n  it = q.extract\n  p it\n  if it.cost == 0 then\n    puts it.step\n    exit\n  end\n  done[it.mat.join(\" \")] = true\n  idx = it.mat.index(0)\n\n  #Down\n  unless idx < 3 then\n    mat = it.mat.clone\n    mat[idx], mat[idx-3] = mat[idx-3], mat[idx]\n    unless done[mat.join(\" \")]\n      tmp = Puzzle.new(mat, it.step+1)\n      q.insert(tmp)\n    end\n  end\n  \n  #Up\n  unless idx > 5 then\n    mat = it.mat.clone\n    mat[idx], mat[idx+3] = mat[idx+3], mat[idx]\n    unless done[mat.join(\" \")]\n      tmp = Puzzle.new(mat, it.step+1)\n      q.insert(tmp)\n    end\n  end\n\n  #Left\n  unless idx % 3 == 0 then\n    mat = it.mat.clone\n    mat[idx], mat[idx-1] = mat[idx-1], mat[idx]\n    unless done[mat.join(\" \")]\n      tmp = Puzzle.new(mat, it.step+1)\n      q.insert(tmp)\n    end\n  end\n\n  #Right\n  unless idx % 3 == 2 then\n    mat = it.mat.clone\n    mat[idx], mat[idx+1] = mat[idx+1], mat[idx]\n    unless done[mat.join(\" \")]\n      tmp = Puzzle.new(mat, it.step+1)\n      q.insert(tmp)\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "\nclass Puzzle\n  attr_accessor :mat, :cost\n  def initialize(mat)\n    @mat = mat\n    @cost = 9 - distance\n  end\n  def >(other)\n    return self.cost < other.cost ? true : false\n  end\n  def <(other)\n    return self.cost > other.cost ? true : false\n  end\n  def distance\n    goal = [1,2,3,4,5,6,7,8,0]\n    d = 0\n    9.times{|i|\n      d += 1 if @mat[i] == goal[i]\n    }\n    return d\n  end\nend\n\n\nclass Heep\n  def initialize\n    @node = []\n  end\n  def insert(num)\n    i = @node.size\n    @node[i] = num\n    p = (i+1)/2-1\n    while i > 0 && @node[p] < @node[i]\n      @node[i], @node[p] = @node[p], @node[i]\n      i = p\n      p = (i+1)/2-1\n    end\n  end\n  def extract\n    ret = @node[0]\n    if @node.size > 1\n      @node[0] = @node.pop()\n      maxHeapify(0)\n    else\n      @node = []\n    end\n    return ret\n  end\n  def maxHeapify(i)\n    h = @node.size\n    largest = i\n    l = 2 * i + 1\n    largest = l if l < h && @node[l] > @node[largest]\n    r = 2 * i + 2\n    largest = r if r < h && @node[r] > @node[largest]\n    if largest != i then\n      @node[i], @node[largest] = @node[largest], @node[i]\n      maxHeapify(largest)\n    end\n  end\n  def size\n    return @node.size\n  end\n  def contain(node)\n    if @node.index(node) == nil\n      return false\n    else\n      return true\n    end\n  end\nend\n\nmat = []\n3.times{|i|\n  mat[3*i], mat[3*i+1], mat[3*i+2] = gets.split.map(&:to_i)\n}\n\nini = Puzzle.new(mat)\nq = Heep.new\nq.insert(ini)\n\nsteps = 0\ndone = {}\nloop do\n  newq = Heep.new\n  loop do\n    break if q.size == 0\n    theMat = q.extract\n    p theMat\n    if theMat.cost == 0 then\n      puts steps\n    end\n    done[theMat.mat.join(\" \")] = true\n    idx = theMat.mat.index(0)\n    #Down\n    unless idx < 3 then\n      newMat = theMat.mat.clone\n      newMat[idx], newMat[idx-3] = newMat[idx-3], newMat[idx]\n      newq.insert(Puzzle.new(newMat)) unless done[newMat.join(\" \")]\n    end\n    #Up\n    unless idx > 5 then\n      newMat = theMat.mat.clone\n      newMat[idx], newMat[idx+3] = newMat[idx+3], newMat[idx]\n      newq.insert(Puzzle.new(newMat)) unless done[newMat.join(\" \")]\n    end\n    #Left\n    unless idx % 3 == 0 then\n      newMat = theMat.mat.clone\n      newMat[idx], newMat[idx-1] = newMat[idx-1], newMat[idx]\n      newq.insert(Puzzle.new(newMat)) unless done[newMat.join(\" \")]\n    end\n    #Right\n    unless idx % 3 == 2 then\n      newMat = theMat.mat.clone\n      newMat[idx], newMat[idx+1] = newMat[idx+1], newMat[idx]\n      newq.insert(Puzzle.new(newMat)) unless done[newMat.join(\" \")]\n    end\n  end\n  q = newq\n  steps += 1\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nMove = [ [1, 3], [0, 2, 4], [1, 5],\n         [0, 4, 6], [1, 3, 5, 7], [2, 4, 8],\n         [3, 7], [4, 6, 8], [5, 7] ]\n\nR = [0, 0, 0, 1, 1, 1, 2, 2, 2]\nC = [0, 1, 2, 0, 1, 2, 0, 1, 2]\n\ndef min_heapify(x = 1)\n  l = 2*x\n  r = 2*x+1\n  if l <= $n && $heap[l][0] < $heap[x][0]\n    minimum = l\n  else\n    minimum = x\n  end\n  if r <= $n && $heap[r][0] < $heap[minimum][0]\n    minimum = r\n  end\n  if minimum != x\n    $heap[x], $heap[minimum] = $heap[minimum], $heap[x]\n    min_heapify(minimum)\n  end\nend\n\ndef extract\n  key = $heap[1]\n  $heap[1] = $heap[$n]\n  $n -= 1\n  min_heapify\n  key\nend\n\ndef insert(key)\n  $n += 1\n  $heap[$n] = key\n  i = $n\n  while i > 1 && $heap[i/2][0] > $heap[i][0]\n    $heap[i], $heap[i/2] = $heap[i/2], $heap[i]\n    i /= 2\n  end\nend\n\ndef judge(brd, c)\n  ret = c\n  9.times do |i|\n    if brd[i] > 0\n      [R, C].each do |a|\n        ret += (a[i] - a[brd[i] - 1]).abs\n      end\n    end\n  end\n  ret\nend\n\nbrd = 3.times.map{ gets.split.map(&:to_i) }.flatten\n$heap = []\n$n = 0\ninsert [judge(brd, 0), brd, 0]\nset = Set.new([])\nset.add(brd)\nwhile $n > 0\n  val, b, cnt = extract\n  if val == cnt\n    p cnt\n    break\n  end\n  n = b.index(0)\n  Move[n].each do |m|\n    b[n], b[m] = b[m], b[n]\n    nb = b.dup\n    unless set.include?(nb)\n      set.add(nb)\n      insert [judge(b, cnt+1), nb, cnt + 1]\n    end\n    b[n], b[m] = b[m], b[n]\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nMove = [ [1, 3], [0, 2, 4], [1, 5],\n         [0, 4, 6], [1, 3, 5, 7], [2, 4, 8],\n         [3, 7], [4, 6, 8], [5, 7] ]\n\nR = [0, 0, 0, 1, 1, 1, 2, 2, 2]\nC = [0, 1, 2, 0, 1, 2, 0, 1, 2]\n\ndef min_heapify(x = 1)\n  l = 2*x\n  r = 2*x+1\n  if l <= $n && $heap[l][0] < $heap[x][0]\n    minimum = l\n  else\n    minimum = x\n  end\n  if r <= $n && $heap[r][0] < $heap[minimum][0]\n    minimum = r\n  end\n  if minimum != x\n    $heap[x], $heap[minimum] = $heap[minimum], $heap[x]\n    min_heapify(minimum)\n  end\nend\n\ndef extract\n  key = $heap[1]\n  $heap[1] = $heap[$n]\n  $n -= 1\n  min_heapify\n  key\nend\n\ndef insert(key)\n  $n += 1\n  $heap[$n] = key\n  i = $n\n  while i > 1 && $heap[i/2][0] > $heap[i][0]\n    $heap[i], $heap[i/2] = $heap[i/2], $heap[i]\n    i /= 2\n  end\nend\n\ndef judge(brd, c)\n  ret = c\n  9.times do |i|\n    if brd[i] > 0\n      [R, C].each do |a|\n        ret += (a[i] - a[brd[i] - 1]).abs\n      end\n    end\n  end\n  ret\nend\n\nbrd = 3.times.map{ gets.split.map(&:to_i) }.flatten\n$heap = []\n$n = 0\ninsert [judge(brd, 0), brd, 0]\nset = SortedSet.new([])\nset.add(brd)\nwhile $n > 0\n  val, b, cnt = extract\n  next if val > 45\n  if val == cnt\n    p cnt\n    break\n  end\n  n = b.index(0)\n  Move[n].each do |m|\n    b[n], b[m] = b[m], b[n]\n    nb = b.dup\n    unless set.include?(nb)\n      set.add(nb)\n      insert [judge(b, cnt+1), nb, cnt + 1]\n    end\n    b[n], b[m] = b[m], b[n]\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "# ???????????¢??¶?????????\nend_panels = []\n3.times do |i|\n  end_panels << STDIN.gets.chomp.split(' ').map(&:to_i)\nend\nend_panels.flatten!\n\nstart_panels = [1, 2, 3, 4, 5, 6, 7, 8, 0]\nwidth = 3\nheight = 3\n$queue = [[true, []], [false, []]]\nforward_cache = {}\nbackward_cache = {}\n\ndef add_queue(is_forward, dicts, dict)\n  dicts2 = dicts.dup\n  dicts2 << dict\n  $queue << [is_forward, dicts2]\nend\n\nwhile true do\n  # ?§????\n  q = $queue.shift\n  is_forward, dicts = q[0], q[1]\n  if is_forward\n    panels = start_panels.dup\n  else\n    panels = end_panels.dup\n  end\n  z = panels.index(0)\n  dicts.each do |d|\n    case d\n    when :u then panels[z], panels[z-3] = panels[z-3], panels[z]\n    when :d then panels[z], panels[z+3] = panels[z+3], panels[z]\n    when :l then panels[z], panels[z-1] = panels[z-1], panels[z]\n    when :r then panels[z], panels[z+1] = panels[z+1], panels[z]\n    end\n    z = panels.index(0)\n  end\n#pp dicts\n  # ??????????????????\n  if is_forward && backward_cache.key?(panels)\n    puts dicts.size + backward_cache[panels].size\n    break\n  elsif !is_forward && forward_cache.key?(panels)\n    puts dicts.size + forward_cache[panels].size\n    break\n  end\n  if is_forward\n    if !forward_cache.key?(panels) || forward_cache[panels].size > dicts.size\n      forward_cache[panels] = dicts\n    end\n  else\n    if !backward_cache.key?(panels) || backward_cache[panels].size > dicts.size\n      backward_cache[panels] = dicts\n    end\n  end\n\n  # ?¬??????¢?´¢?????????\n  if z / width != 0 \\\n     && dicts[-1] != :d\n     # && dicts[-3, 3] != [:l, :d, :r] \\\n     # && dicts[-3, 3] != [:r, :d, :l]\n    add_queue(is_forward, dicts, :u)\n  end\n  if z / width != height - 1 \\\n     && dicts[-1] != :u\n     # && dicts[-3, 3] != [:l, :u, :r] \\\n     # && dicts[-3, 3] != [:r, :u, :l]\n    add_queue(is_forward, dicts, :d)\n  end\n  if z % width != 0 \\\n     && dicts[-1] != :r\n     # && dicts[-3, 3] != [:u, :r, :d] \\\n     # && dicts[-3, 3] != [:d, :r, :u]\n    add_queue(is_forward, dicts, :l)\n  end\n  if z % width != width - 1 \\\n     && dicts[-1] != :l\n     # && dicts[-3, 3] != [:u, :l, :d] \\\n     # && dicts[-3, 3] != [:d, :l, :u]\n    add_queue(is_forward, dicts, :r)\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "\nclass Puzzle\n  attr_accessor :mat, :cost\n  def initialize(mat)\n    @mat = mat\n    @cost = 9 - distance\n  end\n  def >(other)\n    return self.cost < other.cost ? true : false\n  end\n  def <(other)\n    return self.cost > other.cost ? true : false\n  end\n  def distance\n    goal = [1,2,3,4,5,6,7,8,0]\n    d = 0\n    9.times{|i|\n      d += 1 if @mat[i] == goal[i]\n    }\n    return d\n  end\nend\n\n\nclass Heep\n  def initialize\n    @node = []\n  end\n  def insert(num)\n    i = @node.size\n    @node[i] = num\n    p = (i+1)/2-1\n    while i > 0 && @node[p] < @node[i]\n      @node[i], @node[p] = @node[p], @node[i]\n      i = p\n      p = (i+1)/2-1\n    end\n  end\n  def extract\n    ret = @node[0]\n    if @node.size > 1\n      @node[0] = @node.pop()\n      maxHeapify(0)\n    else\n      @node = []\n    end\n    return ret\n  end\n  def maxHeapify(i)\n    h = @node.size\n    largest = i\n    l = 2 * i + 1\n    largest = l if l < h && @node[l] > @node[largest]\n    r = 2 * i + 2\n    largest = r if r < h && @node[r] > @node[largest]\n    if largest != i then\n      @node[i], @node[largest] = @node[largest], @node[i]\n      maxHeapify(largest)\n    end\n  end\n  def size\n    return @node.size\n  end\n  def contain(node)\n    if @node.index(node) == nil\n      return false\n    else\n      return true\n    end\n  end\nend\n\nmat = []\n3.times{|i|\n  mat[3*i], mat[3*i+1], mat[3*i+2] = gets.split.map(&:to_i)\n}\n\nini = Puzzle.new(mat)\nq = Heep.new\nq.insert(ini)\n\nsteps = 0\ndone = {}\nloop do\n  newq = Heep.new\n  loop do\n    break if q.size == 0\n    theMat = q.extract\n    if theMat.cost == 0 then\n      puts steps\n    end\n    done[theMat.mat.join(\" \")] = true\n    idx = theMat.mat.index(0)\n    #Down\n    unless idx < 3 then\n      newMat = theMat.mat.clone\n      newMat[idx], newMat[idx-3] = newMat[idx-3], newMat[idx]\n      newq.insert(Puzzle.new(newMat)) unless done[newMat.join(\" \")]\n    end\n    #Up\n    unless idx > 5 then\n      newMat = theMat.mat.clone\n      newMat[idx], newMat[idx+3] = newMat[idx+3], newMat[idx]\n      newq.insert(Puzzle.new(newMat)) unless done[newMat.join(\" \")]\n    end\n    #Left\n    unless idx % 3 == 0 then\n      newMat = theMat.mat.clone\n      newMat[idx], newMat[idx-1] = newMat[idx-1], newMat[idx]\n      newq.insert(Puzzle.new(newMat)) unless done[newMat.join(\" \")]\n    end\n    #Right\n    unless idx % 3 == 2 then\n      newMat = theMat.mat.clone\n      newMat[idx], newMat[idx+1] = newMat[idx+1], newMat[idx]\n      newq.insert(Puzzle.new(newMat)) unless done[newMat.join(\" \")]\n    end\n  end\n  q = newq\n  steps += 1\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nMove = [ [1, 3], [0, 2, 4], [1, 5],\n         [0, 4, 6], [1, 3, 5, 7], [2, 4, 8],\n         [3, 7], [4, 6, 8], [5, 7] ]\n\nR = [0, 0, 0, 1, 1, 1, 2, 2, 2]\nC = [0, 1, 2, 0, 1, 2, 0, 1, 2]\n\nFactorials = (1...9).each_with_object([1]){ |i, arr| arr << arr[-1] * i }.reverse\n\ndef min_heapify(x = 1)\n  l = 2*x\n  r = 2*x+1\n  if l <= $n && $heap[l][0] < $heap[x][0]\n    minimum = l\n  else\n    minimum = x\n  end\n  if r <= $n && $heap[r][0] < $heap[minimum][0]\n    minimum = r\n  end\n  if minimum != x\n    $heap[x], $heap[minimum] = $heap[minimum], $heap[x]\n    min_heapify(minimum)\n  end\nend\n\ndef extract\n  key = $heap[1]\n  $heap[1] = $heap[$n]\n  $n -= 1\n  min_heapify\n  key\nend\n\ndef insert(key)\n  $n += 1\n  $heap[$n] = key\n  i = $n\n  while i > 1 && $heap[i/2][0] > $heap[i][0]\n    $heap[i], $heap[i/2] = $heap[i/2], $heap[i]\n    i /= 2\n  end\nend\n\ndef create_hash(brd)\n  b = brd.dup\n  9.times do |i|\n    (i+1...9).each do |j|\n      b[j] -= 1 if b[i] < b[j]\n    end\n  end\n  9.times.reduce(0){ |sum, i| sum += b[i] * Factorials[i] }\nend\n\ndef dehash(key)\n  brd = 9.times.map { |i| d, key = key.divmod(Factorials[i]); d }\n  8.downto(0) do |i|\n    (i+1...9).each do |j|\n      brd[j] += 1 if brd[j] >= brd[i]\n    end\n  end\n  brd\nend\n\ndef judge(brd, c)\n  ret = c\n  9.times do |i|\n    if brd[i] > 0\n      [R, C].each do |a|\n        ret += (a[i] - a[brd[i] - 1]).abs\n      end\n    end\n  end\n  ret\nend\n\nGoal = create_hash([1,2,3,4,5,6,7,8,0])\n\nbrd = 3.times.map{ gets.split.map(&:to_i) }.flatten\n$heap = []\n$n = 0\ninsert [judge(brd, 0), k = create_hash(brd), 0]\nset = Set.new([])\nset.add(k)\nwhile $n > 0\n  val, key, cnt = extract\n  if val == cnt\n    p cnt\n    break\n  end\n  b = dehash(key)\n  n = b.index(0)\n  Move[n].each do |m|\n    b[n], b[m] = b[m], b[n]\n    k = create_hash(b)\n    unless set.include?(k)\n      set.add(k)\n      insert [judge(b, cnt+1), k, cnt + 1]\n    end\n    b[n], b[m] = b[m], b[n]\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "# frozen_string_literal: true\nrequire 'set'\n\nchecked_puzzles = Set.new\ncurrent_puzzles = Set.new\n\ninput_puzzle = 3.times.map{gets.split.map(&:to_i)}.flatten\ncurrent_puzzles.add(input_puzzle)\ncount = 0\n\ngoal_puzzle = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\nloop do\n  next_puzzles = Set.new\n  current_puzzles.each do |puzzle|\n    if puzzle == goal_puzzle\n      puts count\n      exit\n    end\n\n    zero_point = puzzle.index(0)\n    y, x = zero_point.divmod(3)\n    if x != 2\n      tmp_puzzle = puzzle.dup\n      tmp_puzzle[zero_point] = puzzle[zero_point + 1]\n      tmp_puzzle[zero_point + 1] = 0\n      next_puzzles.add(tmp_puzzle)\n    end\n    if x != 0\n      tmp_puzzle = puzzle.dup\n      tmp_puzzle[zero_point] = puzzle[zero_point - 1]\n      tmp_puzzle[zero_point - 1] = 0\n      next_puzzles.add(tmp_puzzle)\n    end\n    if y != 2\n      tmp_puzzle = puzzle.dup\n      tmp_puzzle[zero_point] = puzzle[zero_point + 3]\n      tmp_puzzle[zero_point + 3] = 0\n      next_puzzles.add(tmp_puzzle)\n    end\n    if y != 0\n      tmp_puzzle = puzzle.dup\n      tmp_puzzle[zero_point] = puzzle[zero_point - 3]\n      tmp_puzzle[zero_point - 3] = 0\n      next_puzzles.add(tmp_puzzle)\n    end\n  end\n  checked_puzzles.merge(current_puzzles)\n  current_puzzles = next_puzzles - checked_puzzles\n  count += 1\nend"
  },
  {
    "language": "Ruby",
    "code": "def calc_number(puzzle)\n  nums = puzzle.dup\n  puzzle.each_with_index do |x, i_x|\n    puzzle[i_x..-1].each_with_index do |y, i_y|\n      nums[i_x + i_y] -= 1 if y > x\n    end\n  end\n\n  number = 0\n  nums.each_with_index do |x, i_x|\n    factorial = (nums.size - 1 - i_x).downto(1).inject(:*)\n    number += factorial * x if factorial != nil\n  end\n  return number\nend\n\ndef find_zero(puzzle)\n  return puzzle.index(0)\nend\n\nSWAP_CHOICE = [[1, 3],    [0, 2, 4],    [1, 5], \n               [0, 4, 6], [1, 3, 5, 7], [2, 4, 8],\n               [3, 7],    [4, 6, 8],    [5, 7]]\n\nGOAL_STATE = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\n# main\ninit_state = []\n3.times do \n  init_state.concat(gets.chomp.split.map(&:to_i))\nend\n\nstates = Array.new(9.downto(1).inject(:*), false)\nstates[calc_number(init_state)] = true\nqueue = [[init_state, 0]]\n\nwhile queue.size > 0 do\n  state = queue.shift\n  break if state[0] == GOAL_STATE\n  zero_position = find_zero(state[0])\n  swap_positions = SWAP_CHOICE[zero_position]\n\n  swap_positions.each do |swap_position|\n    new_state = [state[0].dup, state[1]]\n    new_state[0][zero_position], new_state[0][swap_position] = \n      new_state[0][swap_position], new_state[0][zero_position]\n    new_number = calc_number(new_state[0])\n    next if states[new_number] == true\n    new_state[1] += 1\n    queue << new_state\n    states[new_number] = true\n  end\nend\n\np state[1]"
  },
  {
    "language": "Ruby",
    "code": "class EightPuzzle\n  DX = [0, -1, 0, 1]\n  DY = [-1, 0, 1, 0]\n  TARGET = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\n  class Puzzle\n    attr_accessor :place, :sp, :cnt\n\n    def initialize(place)\n      @place = place\n      @sp = place.index(0)\n      @cnt = 0\n    end\n\n    def initialize_copy(obj)\n      @place = obj.place.dup\n      @sp = obj.sp\n      @cnt = obj.cnt\n    end\n  end\n\n  def initialize\n    place = []\n    3.times do\n      place << gets.split.map(&:to_i)\n    end\n    place.flatten!\n    @puz = Puzzle.new(place)\n    @q = []\n    @s = {}\n  end\n\n  def solve\n    @q << @puz\n    @s[@puz.place] = true\n\n    while !@q.empty?\n      puz = @q.shift\n      return puz.cnt if puz.place == TARGET\n      sx = puz.sp % 3\n      sy = puz.sp / 3\n      (0..3).each do |i|\n        x = sx + DX[i]\n        y = sy + DY[i]\n        next if x < 0 || 2 < x || y < 0 || 2 < y\n        v = puz.dup\n        v.place[puz.sp], v.place[3 * y + x] = v.place[3 * y + x], v.place[puz.sp]\n        v.sp = 3 * y + x\n        unless @s[v.place]\n          @s[v.place] = true\n          v.cnt += 1\n          @q << v\n        end\n      end\n    end\n  end\nend\n\nep = EightPuzzle.new\nputs ep.solve"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nMove = [ [1, 3], [0, 2, 4], [1, 5],\n         [0, 4, 6], [1, 3, 5, 7], [2, 4, 8],\n         [3, 7], [4, 6, 8], [5, 7] ]\n\nR = [0, 0, 0, 1, 1, 1, 2, 2, 2]\nC = [0, 1, 2, 0, 1, 2, 0, 1, 2]\nFactorials = (1...9).each_with_object([1]){ |i, arr| arr << arr[-1] * i }.reverse\n\ndef create_hash(brd)\n  b = brd.dup\n  9.times do |i|\n    (i+1...9).each do |j|\n      b[j] -= 1 if b[i] < b[j]\n    end\n  end\n  9.times.reduce(0){ |sum, i| sum += b[i] * Factorials[i] }\nend\n\ndef dehash(key)\n  brd = 9.times.map { |i| d, key = key.divmod(Factorials[i]); d }\n  8.downto(0) do |i|\n    (i+1...9).each do |j|\n      brd[j] += 1 if brd[j] >= brd[i]\n    end\n  end\n  brd\nend\n\ndef judge(brd)\n  ret = 0\n  9.times do |i|\n    if brd[i] > 0\n      [R, C].each do |a|\n        ret += (a[i] - a[brd[i] - 1]).abs\n      end\n    end\n  end\n  ret\nend\n\nGoal = create_hash([1,2,3,4,5,6,7,8,0])\n\nbrd = 3.times.map{ gets.split.map(&:to_i) }.flatten\nq = [[judge(brd), k = create_hash(brd), 0]]\nans = -1\nset = Set.new([])\nset.add(k)\nuntil q.empty?\n  arr = q.min{ |a, b| a <=> b }\n  q.delete(arr)\n  _, key, cnt = arr\n  if key == Goal\n    ans = cnt\n    break\n  end\n  b = dehash(key)\n  n = b.index(0)\n  Move[n].each do |m|\n    b[n], b[m] = b[m], b[n]\n    k = create_hash(b)\n    unless set.include?(k)\n      set.add(k)\n      q << [judge(b), k, cnt + 1]\n    end\n    b[n], b[m] = b[m], b[n]\n  end\nend\np ans"
  },
  {
    "language": "Ruby",
    "code": "class Puzzle\n  def initialize(state, direction, count=-1)\n    @state = state\n    @count = count\n    @direction = direction\n  end\n\n  def calc_number\n    nums = @state.dup\n    @state.each_with_index do |x, i_x|\n      @state[i_x..-1].each_with_index do |y, i_y|\n        nums[i_x + i_y] -= 1 if y > x\n      end\n    end\n\n    number = 0\n    nums.each_with_index do |x, i_x|\n      factorial = (nums.size - 1 - i_x).downto(1).inject(:*)\n      number += factorial * x if factorial != nil\n    end\n    return number\n  end\n\n  def find_zero\n    return @state.index(0)\n  end\n\n  def print_puzzle\n    puts state[0..2].join(' ')\n    puts state[3..5].join(' ')\n    puts state[6..8].join(' ')\n  end\n\n  attr_accessor :state, :count, :direction\nend\n\nclass Dictionary\n  def initialize(num)\n    @visited_dict = Array.new(num, 1)\n    @count_dict = Array.new(num, 0)\n  end\n\n  attr_reader :visited_dict, :count_dict\n\n  def visited?(index, direction)\n    return @visited_dict[index] != 1 && @visited_dict[index] % direction == 0\n  end\n\n  def visit(puzzle)\n    index = puzzle.calc_number\n    direction = puzzle.direction\n    count = puzzle.count\n    @visited_dict[index] *= direction\n    @count_dict[index] += count\n  end\n\n  def get_count(puzzle)\n    return count_dict[puzzle.calc_number]\n  end\nend\n\nSWAP_CHOICE = [[1, 3],    [0, 2, 4],    [1, 5], \n               [0, 4, 6], [1, 3, 5, 7], [2, 4, 8],\n               [3, 7],    [4, 6, 8],    [5, 7]]\n\nGOAL_STATE = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\nFORWARD = 2\nBACKWARD = 3\n\n# main\ninit_state = []\n3.times do \n  init_state.concat(gets.chomp.split.map(&:to_i))\nend\n\nqueue = []\ninit_puzzle = Puzzle.new(init_state, FORWARD, 0)\ngoal_puzzle = Puzzle.new(GOAL_STATE, BACKWARD, 0)\nqueue << init_puzzle \nqueue << goal_puzzle\n\ndict = Dictionary.new(9.downto(1).inject(:*))\ndict.visit(init_puzzle)\ndict.visit(goal_puzzle)\n\nwhile queue.size > 0 do\n  puzzle = queue.shift\n  index = puzzle.calc_number\n  if dict.visited?(index, FORWARD) && dict.visited?(index, BACKWARD) then\n    puts dict.count_dict[index] \n    break\n  end\n\n  zero_position = puzzle.find_zero\n  swap_positions = SWAP_CHOICE[zero_position]\n\n  swap_positions.each do |swap_pos|\n    new_puzzle = Puzzle.new(puzzle.state.dup, \n                            puzzle.direction, \n                            puzzle.count + 1)\n    new_puzzle.state[zero_position], new_puzzle.state[swap_pos] = \n      new_puzzle.state[swap_pos], new_puzzle.state[zero_position]\n    next if dict.visited?(new_puzzle.calc_number, new_puzzle.direction)\n\n    queue << new_puzzle\n    dict.visit(new_puzzle)\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "class Puzzle\n  attr_accessor :s, :cou, :direction\n  def initialize(s, direction, cou=-1)\n    @s = s\n    @cou = cou\n    @direction = direction\n  end\n\n  def calc\n    nums = @s.dup\n    @s.each_with_index do |x, i_x|\n      @s[i_x..-1].each_with_index do |y, i_y|\n        nums[i_x + i_y] -= 1 if y > x\n      end\n    end\n    number = 0\n    nums.each_with_index do |x, i_x|\n      factorial = (nums.size - 1 - i_x).downto(1).inject(:*)\n      number += factorial * x if factorial != nil\n    end\n    return number\n  end\n\n  def zero\n    return @s.index(0)\n  end\nend\n\nclass Dic\n  attr_reader :visit, :cou\n  def initialize(num)\n    @visit = Array.new(num, 1)\n    @cou = Array.new(num, 0)\n  end\n  def visited?(id, direction)\n    return @visit[id] != 1 && @visit[id] % direction == 0\n  end\n  def visit(puzzle)\n    id = puzzle.calc\n    direction = puzzle.direction\n    cou = puzzle.cou\n    @visit[id] *= direction\n    @cou[id] += cou\n  end\n\n  def get(puzzle)\n    return cou[puzzle.calc]\n  end\nend\n\nmove = [[1, 3],\n        [0, 2, 4],\n        [1, 5],\n        [0, 4, 6],\n        [1, 3, 5, 7],\n        [2, 4, 8],\n        [3, 7],\n        [4, 6, 8],\n        [5, 7]]\n\ncol = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\nf = 2\nb = 3\n\n# main\ninit_s = []\n3.times do\n  init_s.concat(gets.chomp.split.map(&:to_i))\nend\n\nqueue = []\ninit = Puzzle.new(init_s, f, 0)\ngoal = Puzzle.new(col, b, 0)\nqueue << init\nqueue << goal\n\ndict = Dic.new(9.downto(1).inject(:*))\ndict.visit(init)\ndict.visit(goal)\n\nwhile queue.size > 0 do\n  puzzle = queue.shift\n  id = puzzle.calc\n  if dict.visited?(id, f) && dict.visited?(id, b) then\n    puts dict.cou[id]\n    break\n  end\n\n  zero = puzzle.zero\n  swap = move[zero]\n\n  swap.each{|swap_pos|\n    new = Puzzle.new(puzzle.s.dup,puzzle.direction,puzzle.cou+1)\n    new.s[zero], new.s[swap_pos] = new.s[swap_pos], new.s[zero]\n    next if dict.visited?(new.calc, new.direction)\n    queue << new\n    dict.visit(new)\n  }\nend\n"
  },
  {
    "language": "Ruby",
    "code": "class Puzzle\n  attr_accessor :mat, :step, :cost\n  def initialize(mat, step)\n    @mat = mat\n    @step = step\n    @cost = 9 - distance\n  end\n  def >(other)\n    return self.cost + self.step < other.cost + other.step ? true : false\n  end\n  def <(other)\n    return self.cost + self.step > other.cost + other.step ? true : false\n  end\n  def distance\n    goal = [1,2,3,4,5,6,7,8,0]\n    d = 0\n    9.times{|i|\n      d += 1 if @mat[i] == goal[i]\n    }\n    return d\n  end\nend\n\n\nclass Heep\n  def initialize\n    @node = []\n  end\n  def insert(num)\n    i = @node.size\n    @node[i] = num\n    p = (i+1)/2-1\n    while i > 0 && @node[p] < @node[i]\n      @node[i], @node[p] = @node[p], @node[i]\n      i = p\n      p = (i+1)/2-1\n    end\n  end\n  def extract\n    ret = @node[0]\n    if @node.size > 1\n      @node[0] = @node.pop()\n      maxHeapify(0)\n    else\n      @node = []\n    end\n    return ret\n  end\n  def maxHeapify(i)\n    h = @node.size\n    largest = i\n    l = 2 * i + 1\n    largest = l if l < h && @node[l] > @node[largest]\n    r = 2 * i + 2\n    largest = r if r < h && @node[r] > @node[largest]\n    if largest != i then\n      @node[i], @node[largest] = @node[largest], @node[i]\n      maxHeapify(largest)\n    end\n  end\n  def size\n    return @node.size\n  end\n  def contain(node)\n    if @node.index(node) == nil\n      return false\n    else\n      return true\n    end\n  end\nend\n\nmat = []\n3.times{|i|\n  mat[3*i], mat[3*i+1], mat[3*i+2] = gets.split.map(&:to_i)\n}\n\nini = Puzzle.new(mat, 0)\nq = Heep.new\nq.insert(ini)\n\ndone = {}\nloop do\n  break if q.size == 0\n  theMat = q.extract\n  if theMat.cost == 0 then\n    puts theMat.step\n    exit\n  end\n  done[theMat.mat.join(\" \")] = true\n  idx = theMat.mat.index(0)\n  #Down\n  unless idx < 3 then\n    newMat = theMat.mat.clone\n    newMat[idx], newMat[idx-3] = newMat[idx-3], newMat[idx]\n    q.insert(Puzzle.new(newMat, theMat.step+1)) unless done[newMat.join(\" \")]\n  end\n  #Up\n  unless idx > 5 then\n    newMat = theMat.mat.clone\n    newMat[idx], newMat[idx+3] = newMat[idx+3], newMat[idx]\n    q.insert(Puzzle.new(newMat, theMat.step+1)) unless done[newMat.join(\" \")]\n  end\n  #Left\n  unless idx % 3 == 0 then\n    newMat = theMat.mat.clone\n    newMat[idx], newMat[idx-1] = newMat[idx-1], newMat[idx]\n    q.insert(Puzzle.new(newMat, theMat.step+1)) unless done[newMat.join(\" \")]\n  end\n  #Right\n  unless idx % 3 == 2 then\n    newMat = theMat.mat.clone\n    newMat[idx], newMat[idx+1] = newMat[idx+1], newMat[idx]\n    q.insert(Puzzle.new(newMat, theMat.step+1)) unless done[newMat.join(\" \")]\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "# frozen_string_literal: true\nrequire 'set'\n\ndef array_to_puzzle(list)\n  Array.new(9) { |i| list[i] << (i * 4) }.inject(:+)\nend\n\ndef puzzle_point(puzzle, point)\n  puzzle & (0xF << point)\nend\n\ndef clear_point(puzzle, point_list)\n  point_list.inject(puzzle) do |acc, point|\n    acc & ~(0xF << point)\n  end\nend\n\ndef find_zero_point(puzzle)\n  0.step(32, 4).find { |point| puzzle_point(puzzle, point).zero? }\nend\n\nchecked_puzzles = Set.new\ncurrent_puzzles = Set.new\n\ninput_puzzle = array_to_puzzle(Array.new(3) { gets.split.map(&:to_i) }.flatten)\ncurrent_puzzles.add(input_puzzle)\ncount = 0\n\ngoal_puzzle = array_to_puzzle([1, 2, 3, 4, 5, 6, 7, 8, 0])\n\nloop do\n  next_puzzles = Set.new\n  current_puzzles.each do |puzzle|\n    if puzzle == goal_puzzle\n      puts count\n      exit\n    end\n\n    zero_point = find_zero_point(puzzle)\n    y, x = (zero_point / 4).divmod(3)\n    if x != 2\n      next_puzzles.add(clear_point(puzzle, [zero_point, zero_point + 4]) |\n                       (puzzle_point(puzzle, zero_point + 4) >> 4))\n    end\n    if x != 0\n      next_puzzles.add(clear_point(puzzle, [zero_point, zero_point - 4]) |\n                       (puzzle_point(puzzle, zero_point - 4) << 4))\n    end\n    if y != 2\n      next_puzzles.add(clear_point(puzzle, [zero_point, zero_point + 12]) |\n                       (puzzle_point(puzzle, zero_point + 12) >> 12))\n    end\n    if y != 0\n      next_puzzles.add(clear_point(puzzle, [zero_point, zero_point - 12]) |\n                       (puzzle_point(puzzle, zero_point - 12) << 12))\n    end\n  end\n  checked_puzzles.merge(current_puzzles)\n  current_puzzles = next_puzzles - checked_puzzles\n  count += 1\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nMove = [ [1, 3], [0, 2, 4], [1, 5],\n         [0, 4, 6], [1, 3, 5, 7], [2, 4, 8],\n         [3, 7], [4, 6, 8], [5, 7] ]\n\nR = [0, 0, 0, 1, 1, 1, 2, 2, 2]\nC = [0, 1, 2, 0, 1, 2, 0, 1, 2]\nFactorials = (1...9).each_with_object([1]){ |i, arr| arr << arr[-1] * i }.reverse\n\ndef create_hash(brd)\n  b = brd.dup\n  9.times do |i|\n    (i+1...9).each do |j|\n      b[j] -= 1 if b[i] < b[j]\n    end\n  end\n  9.times.reduce(0){ |sum, i| sum += b[i] * Factorials[i] }\nend\n\ndef dehash(key)\n  brd = 9.times.map { |i| d, key = key.divmod(Factorials[i]); d }\n  8.downto(0) do |i|\n    (i+1...9).each do |j|\n      brd[j] += 1 if brd[j] >= brd[i]\n    end\n  end\n  brd\nend\n\ndef judge(brd, c)\n  ret = c\n  9.times do |i|\n    if brd[i] > 0\n      [R, C].each do |a|\n        ret += (a[i] - a[brd[i] - 1]).abs\n      end\n    end\n  end\n  ret\nend\n\nGoal = create_hash([1,2,3,4,5,6,7,8,0])\n\nbrd = 3.times.map{ gets.split.map(&:to_i) }.flatten\nq = [[judge(brd, 0), k = create_hash(brd), 0]]\nans = -1\nset = Set.new([])\nset.add(k)\nuntil q.empty?\n  arr = q.min{ |a, b| a <=> b }\n  q.delete(arr)\n  _, key, cnt = arr\n  if key == Goal\n    ans = cnt\n    break\n  end\n  b = dehash(key)\n  n = b.index(0)\n  Move[n].each do |m|\n    b[n], b[m] = b[m], b[n]\n    k = create_hash(b)\n    unless set.include?(k)\n      set.add(k)\n      q << [judge(b, cnt+1), k, cnt + 1]\n    end\n    b[n], b[m] = b[m], b[n]\n  end\nend\np ans"
  },
  {
    "language": "Ruby",
    "code": "class Puzzle\n  attr_accessor :mat, :cost\n  def initialize(mat)\n    @mat = mat\n    @cost = 9 - distance\n  end\n  def >(other)\n    return self.cost < other.cost ? true : false\n  end\n  def <(other)\n    return self.cost > other.cost ? true : false\n  end\n  def distance\n    goal = [1,2,3,4,5,6,7,8,0]\n    d = 0\n    9.times{|i|\n      d += 1 if @mat[i] == goal[i]\n    }\n    return d\n  end\nend\n\n\nclass Heep\n  def initialize\n    @node = []\n  end\n  def insert(num)\n    i = @node.size\n    @node[i] = num\n    p = (i+1)/2-1\n    while i > 0 && @node[p] < @node[i]\n      @node[i], @node[p] = @node[p], @node[i]\n      i = p\n      p = (i+1)/2-1\n    end\n  end\n  def extract\n    ret = @node[0]\n    if @node.size > 1\n      @node[0] = @node.pop()\n      maxHeapify(0)\n    else\n      @node = []\n    end\n    return ret\n  end\n  def maxHeapify(i)\n    h = @node.size\n    largest = i\n    l = 2 * i + 1\n    largest = l if l < h && @node[l] > @node[largest]\n    r = 2 * i + 2\n    largest = r if r < h && @node[r] > @node[largest]\n    if largest != i then\n      @node[i], @node[largest] = @node[largest], @node[i]\n      maxHeapify(largest)\n    end\n  end\n  def size\n    return @node.size\n  end\n  def contain(node)\n    if @node.index(node) == nil\n      return false\n    else\n      return true\n    end\n  end\nend\n\nmat = []\n3.times{|i|\n  mat[3*i], mat[3*i+1], mat[3*i+2] = gets.split.map(&:to_i)\n}\n\nini = Puzzle.new(mat)\nq = Heep.new\nq.insert(ini)\n\nsteps = 0\ndone = {}\nloop do\n  newq = Heep.new\n  loop do\n    break if q.size == 0\n    theMat = q.extract\n    if theMat.cost == 0 then\n      puts steps\n      exit\n    end\n    done[theMat.mat.join(\" \")] = true\n    idx = theMat.mat.index(0)\n    #Down\n    unless idx < 3 then\n      newMat = theMat.mat.clone\n      newMat[idx], newMat[idx-3] = newMat[idx-3], newMat[idx]\n      newq.insert(Puzzle.new(newMat)) unless done[newMat.join(\" \")]\n    end\n    #Up\n    unless idx > 5 then\n      newMat = theMat.mat.clone\n      newMat[idx], newMat[idx+3] = newMat[idx+3], newMat[idx]\n      newq.insert(Puzzle.new(newMat)) unless done[newMat.join(\" \")]\n    end\n    #Left\n    unless idx % 3 == 0 then\n      newMat = theMat.mat.clone\n      newMat[idx], newMat[idx-1] = newMat[idx-1], newMat[idx]\n      newq.insert(Puzzle.new(newMat)) unless done[newMat.join(\" \")]\n    end\n    #Right\n    unless idx % 3 == 2 then\n      newMat = theMat.mat.clone\n      newMat[idx], newMat[idx+1] = newMat[idx+1], newMat[idx]\n      newq.insert(Puzzle.new(newMat)) unless done[newMat.join(\" \")]\n    end\n  end\n  q = newq\n  steps += 1\nend"
  },
  {
    "language": "Ruby",
    "code": "# ???????????¢??¶?????????\ntarget_panels = []\n3.times do |i|\n  target_panels << STDIN.gets.chomp.split(' ').map(&:to_i)\nend\ntarget_panels.flatten!\n\nfirst_panels = [1, 2, 3, 4, 5, 6, 7, 8, 0]\nwidth = 3\nheight = 3\n$queue = []\n\ndef add_queue(dicts, dict)\n  dicts2 = dicts.dup\n  dicts2 << dict\n  $queue << dicts2\nend\n\nwhile true do\n  # ?§????\n  panels = first_panels.dup\n  z = panels.index(0)\n  dicts = $queue.shift || []\n  dicts.each do |d|\n    case d\n    when :u then panels[z], panels[z-3] = panels[z-3], panels[z]\n    when :d then panels[z], panels[z+3] = panels[z+3], panels[z]\n    when :l then panels[z], panels[z-1] = panels[z-1], panels[z]\n    when :r then panels[z], panels[z+1] = panels[z+1], panels[z]\n    end\n    z = panels.index(0)\n  end\n  # ??????????????????\n  if panels == target_panels\n    puts dicts.size\n    break\n  end\n  # ?¬??????¢?´¢?????????\n  if z / width != 0 && dicts[-1] != :d\n    add_queue(dicts, :u)\n  end\n  if z / width != height - 1 && dicts[-1] != :u\n    add_queue(dicts, :d)\n  end\n  if z % width != 0 && dicts[-1] != :r\n    add_queue(dicts, :l)\n  end\n  if z % width != width - 1 && dicts[-1] != :l\n    add_queue(dicts, :r)\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "class Puzzle\n  attr_accessor :mat, :step, :cost\n  def initialize(mat, step)\n    @mat = mat\n    @step = step\n    @cost = distance\n  end\n  def >(other)\n    return self.cost + self.step < other.cost + other.step ? true : false\n  end\n  def <(other)\n    return self.cost + self.step > other.cost + other.step ? true : false\n  end\n  def distance\n    goal = [1,2,3,4,5,6,7,8,0]\n    d = 0\n    goal.size.times{|i|\n      d += (@mat.index(goal[i]) - i).abs\n    }\n    return d\n  end\nend\n\ndef cal(mat)\n    goal = [1,2,3,4,5,6,7,8,0]\n    d = 0\n    9.times{|i|\n      d += 1 if mat[i] != goal[i]\n    }\n    return d\nend\n\nclass Heep\n  def initialize\n    @node = []\n  end\n  def insert(num)\n    i = @node.size\n    @node[i] = num\n    p = (i+1)/2-1\n    while i > 0 && @node[p] < @node[i]\n      @node[i], @node[p] = @node[p], @node[i]\n      i = p\n      p = (i+1)/2-1\n    end\n  end\n  def extract\n    ret = @node[0]\n    if @node.size > 1\n      @node[0] = @node.pop()\n      maxHeapify(0)\n    else\n      @node = []\n    end\n    return ret\n  end\n  def maxHeapify(i)\n    h = @node.size\n    largest = i\n    l = 2 * i + 1\n    largest = l if l < h && @node[l] > @node[largest]\n    r = 2 * i + 2\n    largest = r if r < h && @node[r] > @node[largest]\n    if largest != i then\n      @node[i], @node[largest] = @node[largest], @node[i]\n      maxHeapify(largest)\n    end\n  end\n  def size\n    return @node.size\n  end\n  def contain(node)\n    if @node.index(node) == nil\n      return false\n    else\n      return true\n    end\n  end\nend\n\nmat = []\n3.times{|i|\n  mat[3*i], mat[3*i+1], mat[3*i+2] = gets.split.map(&:to_i)\n}\n\nini = Puzzle.new(mat, 0)\nq = Heep.new\nq.insert(ini)\n\ndone = {}\nloop do\n  break if q.size == 0\n  it = q.extract\n  if it.cost == 0 then\n    puts it.step\n    exit\n  end\n  done[it.mat.join(\" \")] = true\n  idx = it.mat.index(0)\n\n  #Down\n  unless idx < 3 then\n    mat = it.mat.clone\n    mat[idx], mat[idx-3] = mat[idx-3], mat[idx]\n    unless done[mat.join(\" \")]\n      tmp = Puzzle.new(mat, it.step+1)\n      q.insert(tmp)\n    end\n  end\n  \n  #Up\n  unless idx > 5 then\n    mat = it.mat.clone\n    mat[idx], mat[idx+3] = mat[idx+3], mat[idx]\n    unless done[mat.join(\" \")]\n      tmp = Puzzle.new(mat, it.step+1)\n      q.insert(tmp)\n    end\n  end\n\n  #Left\n  unless idx % 3 == 0 then\n    mat = it.mat.clone\n    mat[idx], mat[idx-1] = mat[idx-1], mat[idx]\n    unless done[mat.join(\" \")]\n      tmp = Puzzle.new(mat, it.step+1)\n      q.insert(tmp)\n    end\n  end\n\n  #Right\n  unless idx % 3 == 2 then\n    mat = it.mat.clone\n    mat[idx], mat[idx+1] = mat[idx+1], mat[idx]\n    unless done[mat.join(\" \")]\n      tmp = Puzzle.new(mat, it.step+1)\n      q.insert(tmp)\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "class Puzzle\n  attr_accessor :mat, :step, :cost\n  def initialize(mat, step)\n    @mat = mat\n    @step = step\n    @cost = distance\n  end\n  def >(other)\n    return self.cost + self.step < other.cost + other.step ? true : false\n  end\n  def <(other)\n    return self.cost + self.step > other.cost + other.step ? true : false\n  end\n  def distance\n    goal = [1,2,3,4,5,6,7,8,0]\n    d = 0\n    9.times{|n|\n      m = @mat.index(goal[n])\n      y1, x1 = n.divmod(3)\n      y2, x2 = m.divmod(3)\n      d += (y1-y2).abs + (x1-x2).abs\n    }\n    return d\n  end\nend\n\nclass Heep\n  def initialize\n    @node = []\n  end\n  def insert(num)\n    i = @node.size\n    @node[i] = num\n    p = (i+1)/2-1\n    while i > 0 && @node[p] < @node[i]\n      @node[i], @node[p] = @node[p], @node[i]\n      i = p\n      p = (i+1)/2-1\n    end\n  end\n  def extract\n    ret = @node[0]\n    if @node.size > 1\n      @node[0] = @node.pop()\n      maxHeapify(0)\n    else\n      @node = []\n    end\n    return ret\n  end\n  def maxHeapify(i)\n    h = @node.size\n    largest = i\n    l = 2 * i + 1\n    largest = l if l < h && @node[l] > @node[largest]\n    r = 2 * i + 2\n    largest = r if r < h && @node[r] > @node[largest]\n    if largest != i then\n      @node[i], @node[largest] = @node[largest], @node[i]\n      maxHeapify(largest)\n    end\n  end\n  def size\n    return @node.size\n  end\n  def contain(node)\n    if @node.index(node) == nil\n      return false\n    else\n      return true\n    end\n  end\nend\n\nmat = []\n3.times{|i|\n  mat[3*i],mat[3*i+1],mat[3*i+2] = gets.split.map(&:to_i)\n}\n\nini = Puzzle.new(mat, 0)\nq = Heep.new\nq.insert(ini)\n\ndone = {}\nloop do\n  break if q.size == 0\n  it = q.extract\n  if it.cost == 0 then\n    p it.step\n    exit\n  else\n    done[it.mat.join(\"\")] = true\n  end\n  idx = it.mat.index(0)\n  y, x = idx.divmod(3)\n  #Down\n  unless y == 0 then\n    mat = it.mat.clone\n    mat[idx], mat[idx-3] = mat[idx-3], mat[idx]\n    unless done[mat.join]\n      tmp = Puzzle.new(mat, it.step+1)\n      q.insert(tmp)\n    end\n  end\n\n  #Up\n  unless y == 2 then\n    mat = it.mat.clone\n    mat[idx], mat[idx+3] = mat[idx+3], mat[idx]\n    tmp = Puzzle.new(mat, it.step+1)\n    unless done[mat.join]\n      tmp = Puzzle.new(mat, it.step+1)\n      q.insert(tmp)\n    end\n  end\n  \n  #Left\n  unless x == 0 then\n    mat = it.mat.clone\n    mat[idx], mat[idx-1] = mat[idx-1], mat[idx]\n    tmp = Puzzle.new(mat, it.step+1)\n    unless done[mat.join]\n      tmp = Puzzle.new(mat, it.step+1)\n      q.insert(tmp)\n    end\n  end\n\n  #Right\n  unless x == 2 then\n    mat = it.mat.clone\n    mat[idx], mat[idx+1] = mat[idx+1], mat[idx]\n    tmp = Puzzle.new(mat, it.step+1)\n    unless done[mat.join]\n      tmp = Puzzle.new(mat, it.step+1)\n      q.insert(tmp)\n    end\n  end\n  \nend"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar sc = bufio.NewScanner(os.Stdin)\n\nfunc search(in [9]byte) int {\n\tfor i := 0; i < 9; i++ {\n\t\tif in[i] == byte(0) {\n\t\t\treturn i\n\t\t}\n\t}\n\tpanic(\"not found 0\")\n}\n\nfunc up(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos > 2 {\n\t\tin[pos], in[pos-3] = in[pos-3], in[pos]\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n}\n\nfunc down(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos < 6 {\n\t\tin[pos], in[pos+3] = in[pos+3], in[pos]\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n}\n\nfunc left(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos != 0 && pos != 3 && pos != 6 {\n\t\tin[pos], in[pos-1] = in[pos-1], in[pos]\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\nfunc right(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos != 2 && pos != 5 && pos != 8 {\n\t\tin[pos], in[pos+1] = in[pos+1], in[pos]\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n}\n\nfunc next() int {\n\tsc.Scan()\n\ti, _ := strconv.Atoi(sc.Text())\n\treturn i\n}\n\nvar goal = [9]byte{1, 2, 3, 4, 5, 6, 7, 8, 0}\n\ntype item struct {\n\td *[9]byte\n\tc int\n}\n\nvar queue = []item{}\nvar closed = map[[9]byte]bool{}\n\nfunc bfs() int {\n\tfor {\n\t\ttop := queue[0]\n\t\tqueue = queue[1:]\n\n\t\tif *top.d == goal {\n\t\t\treturn top.c\n\t\t}\n\t\tclosed[*top.d] = true\n\n\t\tok, ur := up(*top.d)\n\t\tok2, _ := closed[ur]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&ur, top.c + 1})\n\t\t}\n\t\tok, dr := down(*top.d)\n\t\tok2, _ = closed[dr]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&dr, top.c + 1})\n\t\t}\n\t\tok, lr := left(*top.d)\n\t\tok2, _ = closed[lr]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&lr, top.c + 1})\n\t\t}\n\t\tok, rr := right(*top.d)\n\t\tok2, _ = closed[rr]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&rr, top.c + 1})\n\t\t}\n\t}\n}\n\nfunc main() {\n\tsc.Split(bufio.ScanWords)\n\tvar state [9]byte\n\tfor i := 0; i < 9; i++ {\n\t\tstate[i] = byte(next())\n\t}\n\tqueue = append(queue, item{&state, 0})\n\tcost := bfs()\n\tfmt.Println(cost)\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar sc = bufio.NewScanner(os.Stdin)\n\nfunc search(in [9]byte) int {\n\tfor i := 0; i < 9; i++ {\n\t\tif in[i] == byte(0) {\n\t\t\treturn i\n\t\t}\n\t}\n\tpanic(\"not found 0\")\n}\n\nfunc Up(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos > 2 {\n\t\tin[pos], in[pos-3] = in[pos-3], in[pos]\n\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\n\nfunc Down(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos < 6 {\n\t\tin[pos], in[pos+3] = in[pos+3], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc Left(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\t// mod(pos, 3) == 0\n\tif pos != 0 && pos != 3 && pos != 6 {\n\t\tin[pos], in[pos-1] = in[pos-1], in[pos]\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\nfunc Right(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\t// mod(pos, 3) == 2\n\tif pos != 2 && pos != 5 && pos != 8 {\n\t\tin[pos], in[pos+1] = in[pos+1], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc nextInt() int {\n\tsc.Scan()\n\ti, _ := strconv.Atoi(sc.Text())\n\treturn i\n}\n\nvar goal = [9]byte{1, 2, 3, 4, 5, 6, 7, 8, 0}\n\ntype item struct {\n\td *[9]byte\n\tc int\n}\n\nvar queue = []item{}\nvar closed = map[[9]byte]bool{}\n\nfunc bfs(cost int) int {\n\tfor {\n\n\t\ttop := queue[0]\n\t\tqueue = queue[1:]\n\n\t\tif *top.d == goal {\n\t\t\treturn top.c\n\t\t}\n\t\tclosed[*top.d] = true\n\n\t\tok, ur := Up(*top.d)\n\t\tok2, _ := closed[ur]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&ur, top.c + 1})\n\t\t}\n\t\tok, dr := Down(*top.d)\n\t\tok2, _ = closed[dr]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&dr, top.c + 1})\n\t\t}\n\t\tok, lr := Left(*top.d)\n\t\tok2, _ = closed[lr]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&lr, top.c + 1})\n\t\t}\n\t\tok, rr := Right(*top.d)\n\t\tok2, _ = closed[rr]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&rr, top.c + 1})\n\t\t}\n\t}\n\n}\n\nfunc main() {\n\tsc.Split(bufio.ScanWords)\n\tvar state [9]byte\n\tfor i := 0; i < 9; i++ {\n\t\tstate[i] = byte(nextInt())\n\t}\n\tqueue = append(queue, item{&state, 0})\n\tcost := bfs(0)\n\tfmt.Println(cost)\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport(\n\t\"fmt\"\n)\n// import \"time\"\n\n// ボードの状態\ntype Board = [9]int\n// パズル全体\ntype Puzzle struct {\n\tBrd Board\n\tZero int\n\tMoved int\n}\nvar FINISH_STATE Board = Board{ 1, 2, 3, 4, 5, 6, 7, 8, 0 }\nfunc (this *Puzzle) IsDone() bool {\n\treturn this.Brd == FINISH_STATE\n}\n\nfunc FindZero(board* Board) int {\n\tfor i, v := range board {\n\t\tif v == 0 {\n\t\t\treturn i\n\t\t}\n\t}\n\tfmt.Println(\"Error 0 Not found\")\n\treturn -1\n}\n\n\n// 移動可能か\nfunc (this *Puzzle) CanUp() bool {\n\treturn 2 < this.Zero\n}\n\nfunc (this *Puzzle) CanDown() bool {\n\treturn this.Zero < 6\n}\n\nfunc (this *Puzzle) CanLeft() bool {\n\treturn this.Zero % 3 != 0\n}\n\nfunc (this *Puzzle) CanRight() bool {\n\treturn this.Zero % 3 != 2\n}\n\n// 移動後の状態を\nfunc (this *Puzzle) Up() Puzzle {\n\treturn Puzzle{ Move(this.Brd, this.Zero, -3), this.Zero - 3, this.Moved + 1 }\n}\nfunc (this *Puzzle) Down() Puzzle {\n\treturn Puzzle{ Move(this.Brd, this.Zero, +3), this.Zero + 3, this.Moved + 1 }\n}\nfunc (this *Puzzle) Left() Puzzle {\n\treturn Puzzle{ Move(this.Brd, this.Zero, -1), this.Zero -1, this.Moved + 1 }\n}\nfunc (this *Puzzle) Right() Puzzle {\n\treturn Puzzle{ Move(this.Brd, this.Zero, 1), this.Zero + 1, this.Moved + 1 }\n}\n// common move\nfunc Move(board Board, zero int, direction int) Board {\n\tboard[zero], board[zero + direction] = board[zero + direction], board[zero]\n\treturn board\n}\n\n\ntype Memo struct {\n\tData map[int][]Board\n}\nfunc NewMemo() Memo{\n\t// var data [9][9][]Board = [9][9][]Board{}\n\t// for i := 0; i < 9; i++ {\n\t// \tfor j := 0; j < 9; j++ {\n\t// \t\tdata[i][j] = make([]Board, 0)\n\t// \t}\n\t// }\n\treturn Memo{ make(map[int][]Board) }\n}\nfunc (m *Memo) Add(board Board) {\n\tindex := board[0] * 10000 + board[1] * 1000 + board[2] * 100 + board[3] * 10 + board[4] * 1\n\tm.Data[index] = append(m.Data[index], board)\n}\n\nfunc (m *Memo) HasTried(board *Board) bool {\n\tindex := board[0] * 10000 + board[1] * 1000 + board[2] * 100 + board[3] * 10 + board[4] * 1\n\tfor _, state := range m.Data[index] {\n\t\tif state == *board {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n\n\nfunc Solve(board Board) int {\n\t// prepare\n\tqueue := make([]Puzzle, 0)\n\tpzl := Puzzle{ board, FindZero(&board), 0 }\n\tqueue = append(queue, pzl)\n\tmemo := NewMemo()\n\n\tcount := 0\n\tfor len(queue) != 0 {\n\t\tcount++\n\t\t// before := time.Now()\n\n\t\te := queue[0]\n\t\tqueue = queue[1:]\n\n\t\tif e.IsDone() {\n\t\t\t// fmt.Printf(\"count:%d\\n\", count)\n\t\t\treturn e.Moved\n\t\t} else {\n\t\t\t// memo = append(memo, e.Brd)\n\t\t\tmemo.Add(e.Brd)\n\t\t}\n\t\tif e.CanUp() {\n\t\t\t// fmt.Println(\"up\")\n\t\t\tnewPzl := e.Up()\n\t\t\tif !memo.HasTried(&newPzl.Brd) {\n\t\t\t\tqueue = append(queue, newPzl)\n\t\t\t}\n\t\t}\n\t\tif e.CanDown() {\n\t\t\t// fmt.Println(\"down\")\n\t\t\tnewPzl := e.Down()\n\t\t\tif !memo.HasTried(&newPzl.Brd) {\n\t\t\t\tqueue = append(queue, newPzl)\n\t\t\t}\n\t\t}\n\t\tif e.CanLeft() {\n\t\t\t// fmt.Println(\"left\")\n\t\t\tnewPzl := e.Left()\n\t\t\tif !memo.HasTried(&newPzl.Brd) {\n\t\t\t\tqueue = append(queue, newPzl)\n\t\t\t}\n\t\t}\n\t\tif e.CanRight() {\n\t\t\t// fmt.Println(\"right\")\n\t\t\tnewPzl := e.Right()\n\t\t\tif !memo.HasTried(&newPzl.Brd) {\n\t\t\t\tqueue = append(queue, newPzl)\n\t\t\t}\n\t\t}\n\t\t// fmt.Printf(\"spend: %v\\n\", time.Now().Sub(before))\n\t}\n\treturn -1\n}\n\nfunc main() {\n\tvar board Board\n\tfor i := 0; i < 9; i++ {\n\t\tvar v int\n\t\tfmt.Scanf(\"%d\", &v)\n\t\tboard[i] = v\n\t}\n\tresult := Solve(board)\n\tfmt.Println(result)\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nconst (\n\tN    = 3\n\tBASE = 10007\n\tMOD  = 1000000007\n)\n\ntype Puzzle struct {\n\tboard [N * N]int // (x, y). (0, 0) = 0,  (1, 0) = 1, (0, 1) = 3\n}\n\ntype SolveContext struct {\n\tcurrent *Puzzle\n\tcount   int\n}\n\ntype Position struct {\n\tx int\n\ty int\n}\n\nfunc NewPuzzle(b [N * N]int) *Puzzle {\n\treturn &Puzzle{board: b}\n}\n\nfunc (puzzle *Puzzle) hash() int {\n\tarr := puzzle.board\n\tsum := arr[0]\n\tfor i := 1; i < len(arr); i++ {\n\t\tsum = sum*BASE + arr[i]\n\t\tif sum > MOD {\n\t\t\tsum = sum % MOD\n\t\t}\n\t}\n\treturn sum\n}\n\nfunc (puzzle *Puzzle) isSolved() bool {\n\tsolvedBoard := [N * N]int{1, 2, 3, 4, 5, 6, 7, 8, 0}\n\treturn puzzle.board == solvedBoard\n}\n\nfunc swap(puzzle *Puzzle, one, two Position) *Puzzle {\n\tswapped := NewPuzzle(puzzle.board)\n\tswapped.board[one.y*N+one.x], swapped.board[two.y*N+two.x] =\n\t\tswapped.board[two.y*N+two.x], swapped.board[one.y*N+one.x]\n\treturn swapped\n}\n\nfunc (puzzle *Puzzle) getEmptyPosition() *Position {\n\tfor i := 0; i < N; i++ {\n\t\tfor j := 0; j < N; j++ {\n\t\t\tif puzzle.board[i*N+j] == 0 {\n\t\t\t\treturn &Position{x: j, y: i}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (puzzle *Puzzle) nextPuzzles() []*Puzzle {\n\temptyPosition := puzzle.getEmptyPosition()\n\tif emptyPosition == nil {\n\t\tpanic(fmt.Errorf(\"emptyPostion must not be empty\"))\n\t}\n\tbasePosition := *emptyPosition\n\tdirections := [][2]int{[2]int{-1, 0}, [2]int{1, 0}, [2]int{0, -1}, [2]int{0, 1}} // []{x, y}\n\tnexts := []*Puzzle{}\n\tfor _, dir := range directions {\n\t\tnextPosition := Position{basePosition.x + dir[0], basePosition.y + dir[1]}\n\t\tif nextPosition.x >= 0 && nextPosition.x <= N-1 &&\n\t\t\tnextPosition.y >= 0 && nextPosition.y <= N-1 {\n\t\t\tnexts = append(nexts, swap(puzzle, basePosition, nextPosition))\n\t\t}\n\t}\n\treturn nexts\n}\n\nfunc solve(initialPuzzle *Puzzle) int {\n\tinitial := SolveContext{initialPuzzle, 0}\n\tvisited := make(map[int]*struct{})\n\tstack := []SolveContext{initial}\n\tvar solved SolveContext\n\tfor len(stack) > 0 {\n\t\tsolveContext := stack[0]\n\t\tcurrent := solveContext.current\n\t\tcount := solveContext.count\n\t\tvisited[current.hash()] = &struct{}{}\n\t\tstack = stack[1:]\n\t\tif current.isSolved() {\n\t\t\tsolved = solveContext\n\t\t\tbreak\n\t\t}\n\t\tfor _, v := range current.nextPuzzles() {\n\t\t\tif visited[v.hash()] == nil {\n\t\t\t\tnextContext := SolveContext{v, count + 1}\n\t\t\t\tstack = append(stack, nextContext)\n\t\t\t}\n\t\t}\n\t}\n\treturn solved.count\n}\n\nfunc main() {\n\tsc := bufio.NewScanner(os.Stdin)\n\tsc.Split(bufio.ScanWords)\n\n\tvar arr [N * N]int\n\tfor i := 0; i < len(arr); i++ {\n\t\tx, err := nextInt(sc)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tarr[i] = x\n\t}\n\n\tpuzzle := NewPuzzle(arr)\n\tfmt.Println(solve(puzzle))\n}\n\nfunc nextInt(sc *bufio.Scanner) (int, error) {\n\tsc.Scan()\n\treturn strconv.Atoi(sc.Text())\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar sc = bufio.NewScanner(os.Stdin)\n\nfunc search(in [9]byte) int {\n\tfor i := 0; i < 9; i++ {\n\t\tif in[i] == byte(0) {\n\t\t\treturn i\n\t\t}\n\t}\n\tpanic(\"not found 0\")\n}\n\nfunc up(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos > 2 {\n\t\tin[pos], in[pos-3] = in[pos-3], in[pos]\n\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\n\nfunc down(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos < 6 {\n\t\tin[pos], in[pos+3] = in[pos+3], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc left(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\t// mod(pos, 3) == 0\n\tif pos != 0 && pos != 3 && pos != 6 {\n\t\tin[pos], in[pos-1] = in[pos-1], in[pos]\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\nfunc right(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\t// mod(pos, 3) == 2\n\tif pos != 2 && pos != 5 && pos != 8 {\n\t\tin[pos], in[pos+1] = in[pos+1], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc next() int {\n\tsc.Scan()\n\ti, _ := strconv.Atoi(sc.Text())\n\treturn i\n\n}\n\nvar goal = [9]byte{1, 2, 3, 4, 5, 6, 7, 8, 0}\n\nfunc pp(s [9]byte) {\n\n\tfor i := 0; i < 3; i++ {\n\t\tfmt.Printf(\"%d %d %d\\n\", s[0+3*i], s[1+3*i], s[2+3*i])\n\t}\n\tfmt.Println(\"----------------------\")\n\n}\n\ntype item struct {\n\td [9]byte\n\tc int\n}\n\nvar queue = []item{}\n\nfunc bfs(cost int) int {\n\tfor {\n\n\t\ttop := queue[0]\n\t\tqueue = queue[1:]\n\n\t\tif top.d == goal {\n\t\t\treturn top.c\n\n\t\t}\n\n\t\tok, ur := up(top.d)\n\t\tif ok {\n\t\t\tqueue = append(queue, item{ur, top.c + 1})\n\t\t}\n\t\tok, dr := down(top.d)\n\t\tif ok {\n\t\t\tqueue = append(queue, item{dr, top.c + 1})\n\t\t}\n\t\tok, lr := left(top.d)\n\t\tif ok {\n\t\t\tqueue = append(queue, item{lr, top.c + 1})\n\t\t}\n\t\tok, rr := right(top.d)\n\t\tif ok {\n\t\t\tqueue = append(queue, item{rr, top.c + 1})\n\t\t}\n\t}\n\n}\n\nfunc main() {\n\tsc.Split(bufio.ScanWords)\n\tvar state [9]byte\n\tfor i := 0; i < 9; i++ {\n\t\tstate[i] = byte(next())\n\t}\n\tqueue = append(queue, item{state, 0})\n\tcost := bfs(0)\n\tfmt.Println(cost)\n}\n\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar sc = bufio.NewScanner(os.Stdin)\n\nfunc search(in [9]byte) int {\n\tfor i := 0; i < 9; i++ {\n\t\tif in[i] == byte(0) {\n\t\t\treturn i\n\t\t}\n\t}\n\tpanic(\"not found 0\")\n}\n\nfunc up(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos > 2 {\n\t\tin[pos], in[pos-3] = in[pos-3], in[pos]\n\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\n\nfunc down(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos < 6 {\n\t\tin[pos], in[pos+3] = in[pos+3], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc left(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\t// mod(pos, 3) == 0\n\tif pos != 0 && pos != 3 && pos != 6 {\n\t\tin[pos], in[pos-1] = in[pos-1], in[pos]\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\nfunc right(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\t// mod(pos, 3) == 2\n\tif pos != 2 && pos != 5 && pos != 8 {\n\t\tin[pos], in[pos+1] = in[pos+1], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc next() int {\n\tsc.Scan()\n\ti, _ := strconv.Atoi(sc.Text())\n\treturn i\n\n}\n\nvar goal = [9]byte{1, 2, 3, 4, 5, 6, 7, 8, 0}\n\nfunc pp(s [9]byte) {\n\n\tfor i := 0; i < 3; i++ {\n\t\tfmt.Printf(\"%d %d %d\\n\", s[0+3*i], s[1+3*i], s[2+3*i])\n\t}\n\tfmt.Println(\"----------------------\")\n\n}\n\ntype item struct {\n\td *[9]byte\n\tc int\n}\n\nvar queue = []item{}\nvar closed = map[[9]byte]bool{}\n\nfunc bfs(cost int) int {\n\tfor {\n\n\t\ttop := queue[0]\n\t\tqueue = queue[1:]\n\n\t\tif *top.d == goal {\n\t\t\treturn top.c\n\t\t}\n\t\tclosed[*top.d] = true\n\n\t\tok, ur := up(*top.d)\n\t\tok2, _ := closed[ur]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&ur, top.c + 1})\n\t\t}\n\t\tok, dr := down(*top.d)\n\t\tok2, _ = closed[dr]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&dr, top.c + 1})\n\t\t}\n\t\tok, lr := left(*top.d)\n\t\tok2, _ = closed[lr]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&lr, top.c + 1})\n\t\t}\n\t\tok, rr := right(*top.d)\n\t\tok2, _ = closed[rr]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&rr, top.c + 1})\n\t\t}\n\t}\n\n}\n\nfunc main() {\n\tsc.Split(bufio.ScanWords)\n\tvar state [9]byte\n\tfor i := 0; i < 9; i++ {\n\t\tstate[i] = byte(next())\n\t}\n\tqueue = append(queue, item{&state, 0})\n\tcost := bfs(0)\n\tfmt.Println(cost)\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar sc = bufio.NewScanner(os.Stdin)\n\nfunc search(in [9]int) int {\n\tfor i := 0; i < 9; i++ {\n\t\tif in[i] == 0 {\n\t\t\treturn i\n\t\t}\n\t}\n\tpanic(\"not found 0\")\n}\n\nfunc up(in [9]int) (bool, [9]int) {\n\tpos := search(in)\n\tif pos > 2 {\n\t\tin[pos], in[pos-3] = in[pos-3], in[pos]\n\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\n\nfunc down(in [9]int) (bool, [9]int) {\n\tpos := search(in)\n\tif pos < 6 {\n\t\tin[pos], in[pos+3] = in[pos+3], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc left(in [9]int) (bool, [9]int) {\n\tpos := search(in)\n\t// mod(pos, 3) == 0\n\tif pos != 0 && pos != 3 && pos != 6 {\n\t\tin[pos], in[pos-1] = in[pos-1], in[pos]\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\nfunc right(in [9]int) (bool, [9]int) {\n\tpos := search(in)\n\t// mod(pos, 3) == 2\n\tif pos != 2 && pos != 5 && pos != 8 {\n\t\tin[pos], in[pos+1] = in[pos+1], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc next() int {\n\tsc.Scan()\n\ti, _ := strconv.Atoi(sc.Text())\n\treturn i\n\n}\n\nvar goal = [9]int{1, 2, 3, 4, 5, 6, 7, 8, 0}\n\nfunc pp(s [9]int) {\n\n\tfor i := 0; i < 3; i++ {\n\t\tfmt.Printf(\"%d %d %d\\n\", s[0+3*i], s[1+3*i], s[2+3*i])\n\t}\n\tfmt.Println(\"----------------------\")\n\n}\n\ntype item struct {\n\td [9]int\n\tc int\n}\n\nvar queue = []item{}\n\nfunc bfs(cost int) int {\n\tfor {\n\n\t\ttop := queue[0]\n\t\tqueue = queue[1:]\n\n\t\tif top.d == goal {\n\t\t\treturn top.c\n\n\t\t}\n\n\t\tok, ur := up(top.d)\n\t\tif ok {\n\t\t\tqueue = append(queue, item{ur, top.c + 1})\n\t\t}\n\t\tok, dr := down(top.d)\n\t\tif ok {\n\t\t\tqueue = append(queue, item{dr, top.c + 1})\n\t\t}\n\t\tok, lr := left(top.d)\n\t\tif ok {\n\t\t\tqueue = append(queue, item{lr, top.c + 1})\n\t\t}\n\t\tok, rr := right(top.d)\n\t\tif ok {\n\t\t\tqueue = append(queue, item{rr, top.c + 1})\n\t\t}\n\t}\n\n}\n\nfunc main() {\n\tsc.Split(bufio.ScanWords)\n\tvar state [9]int\n\tfor i := 0; i < 9; i++ {\n\t\tstate[i] = next()\n\t}\n\tqueue = append(queue, item{state, 0})\n\tcost := bfs(0)\n\tfmt.Println(cost)\n}\n\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc getScanner(fp *os.File) *bufio.Scanner {\n\tscanner := bufio.NewScanner(fp)\n\tscanner.Split(bufio.ScanWords)\n\tscanner.Buffer(make([]byte, 500001), 500000)\n\treturn scanner\n}\n\nfunc getNextString(scanner *bufio.Scanner) string {\n\tscanner.Scan()\n\treturn scanner.Text()\n}\n\nfunc getNextInt(scanner *bufio.Scanner) int {\n\ti, _ := strconv.Atoi(getNextString(scanner))\n\treturn i\n}\n\nfunc getNextInt64(scanner *bufio.Scanner) int64 {\n\ti, _ := strconv.ParseInt(getNextString(scanner), 10, 64)\n\treturn i\n}\n\nfunc getNextUint64(scanner *bufio.Scanner) uint64 {\n\ti, _ := strconv.ParseUint(getNextString(scanner), 10, 64)\n\treturn i\n}\n\nfunc getNextFloat64(scanner *bufio.Scanner) float64 {\n\ti, _ := strconv.ParseFloat(getNextString(scanner), 64)\n\treturn i\n}\n\nfunc main() {\n\tfp := os.Stdin\n\twfp := os.Stdout\n\n\tif len(os.Args) > 1 {\n\t\tfp, _ = os.Open(os.Args[1])\n\t\tif len(os.Args) > 2 {\n\t\t\twfp, _ = os.Create(os.Args[2])\n\t\t}\n\t}\n\n\tscanner := getScanner(fp)\n\twriter := bufio.NewWriter(wfp)\n\n\tpath := make([]string, 9)\n\n\tfor i := 0; i < 9; i++ {\n\t\tpath[i] = getNextString(scanner)\n\t}\n\n\tq := make([]Pair, 0)\n\n\tq = append(q, Pair{\n\t\tpath: strings.Join(path, \"\"),\n\t\tc:    0,\n\t})\n\n\tvisited := make(map[string]int, 0)\n\tans := 0\n\tvisited[q[0].path] = 1\n\tfor len(q) > 0 {\n\t\tp := q[0]\n\t\tq = q[1:]\n\t\tif p.path == \"123456780\" {\n\t\t\tans = p.c\n\t\t\tbreak\n\t\t}\n\t\tfor i := 0; i < 9; i++ {\n\t\t\tif p.path[i] == '0' {\n\t\t\t\tif i-3 >= 0 {\n\t\t\t\t\tap := swap(p.path, i, i-3)\n\t\t\t\t\tif _, ok := visited[ap]; ok == false {\n\t\t\t\t\t\tq = append(q, Pair{\n\t\t\t\t\t\t\tpath: ap,\n\t\t\t\t\t\t\tc:    p.c + 1,\n\t\t\t\t\t\t})\n\t\t\t\t\t\tvisited[ap] = 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif i+3 < 9 {\n\t\t\t\t\tap := swap(p.path, i, i+3)\n\t\t\t\t\tif _, ok := visited[ap]; ok == false {\n\t\t\t\t\t\tq = append(q, Pair{\n\t\t\t\t\t\t\tpath: ap,\n\t\t\t\t\t\t\tc:    p.c + 1,\n\t\t\t\t\t\t})\n\t\t\t\t\t\tvisited[ap] = 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif i%3 != 0 {\n\t\t\t\t\tap := swap(p.path, i, i-1)\n\t\t\t\t\tif _, ok := visited[ap]; ok == false {\n\t\t\t\t\t\tq = append(q, Pair{\n\t\t\t\t\t\t\tpath: ap,\n\t\t\t\t\t\t\tc:    p.c + 1,\n\t\t\t\t\t\t})\n\t\t\t\t\t\tvisited[ap] = 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif i%3 != 2 {\n\t\t\t\t\tap := swap(p.path, i, i+1)\n\t\t\t\t\tif _, ok := visited[ap]; ok == false {\n\t\t\t\t\t\tq = append(q, Pair{\n\t\t\t\t\t\t\tpath: ap,\n\t\t\t\t\t\t\tc:    p.c + 1,\n\t\t\t\t\t\t})\n\t\t\t\t\t\tvisited[ap] = 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tfmt.Fprintln(writer, ans)\n\twriter.Flush()\n}\n\ntype Pair struct {\n\tpath string\n\tc    int\n}\n\nfunc swap(s string, i, j int) string {\n\tsp := strings.Split(s, \"\")\n\tsp[i], sp[j] = sp[j], sp[i]\n\treturn strings.Join(sp, \"\")\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"container/heap\"\n)\n\ntype State struct {\n\tPuzzle []int\n\tZero int\n\tPrev int\n\tTurn int\n\tDis int\n\tCost int\n}\n\ntype PriorityQueue []*State\n\nfunc (pq PriorityQueue) Len() int { return len(pq) }\n\nfunc (pq PriorityQueue) Less(i, j int) bool {\n\treturn pq[i].Cost < pq[j].Cost\n}\n\nfunc (pq PriorityQueue) Swap(i, j int) {\n\tpq[i], pq[j] = pq[j], pq[i]\n}\n\nfunc (pq *PriorityQueue) Push(x interface{}) {\n\t*pq = append(*pq, x.(*State))\n}\n\nfunc (pq *PriorityQueue) Pop() interface{} {\n\tn := len(*pq)\n\tpop := (*pq)[n-1]\n\t*pq = (*pq)[0:n-1]\n\treturn pop\n}\n\nfunc main() {\n\tn := 9\n\tpuzzle := make([]int, n)\n\tvar zero int\n\tfor i := 0; i < n; i++ {\n\t\tfmt.Scan(&puzzle[i])\n\t\tif puzzle[i] == 0 {\n\t\t\tpuzzle[i] = n\n\t\t\tzero = i\n\t\t}\n\t}\n\n\tturn := 0\n\tdis := dist(&puzzle)\n\tif dis == 0 {\n\t\tfmt.Println(turn)\n\t\treturn\n\t}\n\tque := PriorityQueue{&State{puzzle, zero, -1, turn, dis, turn + dis}}\n\theap.Init(&que)\n\tdir := []int{-3,-1,1,3}\n\tfor que.Len() > 0 {\n\t\tpop := heap.Pop(&que).(*State)\n\t\tfor i := 0; i < len(dir); i++ {\n\t\t\tnext := (*pop).Zero + dir[i]\n\t\t\tif next == (*pop).Prev {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif next < 0 || n <= next {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif (next%3 - (*pop).Zero%3) * dir[i] < 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\tp := make([]int, n)\n\t\t\tcopy(p, (*pop).Puzzle)\n\t\t\tp[next], p[(*pop).Zero] = p[(*pop).Zero], p[next]\n\t\t\tturn = (*pop).Turn + 1\n\t\t\tdis = dist(&p)\n\t\t\tif dis == 0 {\n\t\t\t\tfmt.Println(turn)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t\n\t\t\theap.Push(&que, &State{p, next, (*pop).Zero, turn, dis, turn + dis})\n\t\t}\n\t}\n}\n\nfunc dist(p *[]int) int {\n\tsum := 0\n\tn := len(*p)\n\tfor i := 0; i < n; i++ {\n\t\tv := (*p)[i] - 1\n\t\tsum += abs(v/3 - i/3)\n\t\tsum += abs(v%3 - i%3)\n\t}\n\treturn sum / 2\n}\n\nfunc abs(x int) int {\n\tif x < 0 {\n\t\treturn -x\n\t}\n\treturn x\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar sc = bufio.NewScanner(os.Stdin)\n\nfunc search(in [9]byte) int {\n\tfor i := 0; i < 9; i++ {\n\t\tif in[i] == byte(0) {\n\t\t\treturn i\n\t\t}\n\t}\n\tpanic(\"not found 0\")\n}\n\nfunc up(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos > 2 {\n\t\tin[pos], in[pos-3] = in[pos-3], in[pos]\n\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\n\nfunc down(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos < 6 {\n\t\tin[pos], in[pos+3] = in[pos+3], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc left(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\t// mod(pos, 3) == 0\n\tif pos != 0 && pos != 3 && pos != 6 {\n\t\tin[pos], in[pos-1] = in[pos-1], in[pos]\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\nfunc right(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\t// mod(pos, 3) == 2\n\tif pos != 2 && pos != 5 && pos != 8 {\n\t\tin[pos], in[pos+1] = in[pos+1], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc next() int {\n\tsc.Scan()\n\ti, _ := strconv.Atoi(sc.Text())\n\treturn i\n\n}\n\nvar goal = [9]byte{1, 2, 3, 4, 5, 6, 7, 8, 0}\n\nfunc pp(s [9]byte) {\n\n\tfor i := 0; i < 3; i++ {\n\t\tfmt.Printf(\"%d %d %d\\n\", s[0+3*i], s[1+3*i], s[2+3*i])\n\t}\n\tfmt.Println(\"----------------------\")\n\n}\n\ntype item struct {\n\td *[9]byte\n\tc int\n}\n\nvar queue = []item{}\nvar closed = map[[9]byte]bool{}\n\nfunc bfs(cost int) int {\n\tfor {\n\n\t\ttop := queue[0]\n\t\tqueue = queue[1:]\n\n\t\tif *top.d == goal {\n\t\t\treturn top.c\n\t\t}\n\t\tclosed[*top.d] = true\n\n\t\tok, ur := up(*top.d)\n\t\tok2, _ := closed[ur]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&ur, top.c + 1})\n\t\t}\n\t\tok, dr := down(*top.d)\n\t\tok2, _ = closed[dr]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&dr, top.c + 1})\n\t\t}\n\t\tok, lr := left(*top.d)\n\t\tok2, _ = closed[lr]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&lr, top.c + 1})\n\t\t}\n\t\tok, rr := right(*top.d)\n\t\tok2, _ = closed[rr]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&rr, top.c + 1})\n\t\t}\n\t}\n\n}\n\nfunc main() {\n\tsc.Split(bufio.ScanWords)\n\tvar state [9]byte\n\tfor i := 0; i < 9; i++ {\n\t\tstate[i] = byte(next())\n\t}\n\tqueue = append(queue, item{&state, 0})\n\tcost := bfs(0)\n\tfmt.Println(cost)\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar sc = bufio.NewScanner(os.Stdin)\n\nfunc search(in [9]byte) int {\n\tfor i := 0; i < 9; i++ {\n\t\tif in[i] == byte(0) {\n\t\t\treturn i\n\t\t}\n\t}\n\tpanic(\"not found 0\")\n}\n\nfunc up(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos > 2 {\n\t\tin[pos], in[pos-3] = in[pos-3], in[pos]\n\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\n\nfunc down(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos < 6 {\n\t\tin[pos], in[pos+3] = in[pos+3], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc left(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\t// mod(pos, 3) == 0\n\tif pos != 0 && pos != 3 && pos != 6 {\n\t\tin[pos], in[pos-1] = in[pos-1], in[pos]\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\nfunc right(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\t// mod(pos, 3) == 2\n\tif pos != 2 && pos != 5 && pos != 8 {\n\t\tin[pos], in[pos+1] = in[pos+1], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc next() int {\n\tsc.Scan()\n\ti, _ := strconv.Atoi(sc.Text())\n\treturn i\n\n}\n\nvar goal = [9]byte{1, 2, 3, 4, 5, 6, 7, 8, 0}\n\nfunc pp(s [9]byte) {\n\n\tfor i := 0; i < 3; i++ {\n\t\tfmt.Printf(\"%d %d %d\\n\", s[0+3*i], s[1+3*i], s[2+3*i])\n\t}\n\tfmt.Println(\"----------------------\")\n\n}\n\ntype item struct {\n\td *[9]byte\n\tc int\n}\n\nvar queue = []item{}\n\nfunc bfs(cost int) int {\n\tfor {\n\n\t\ttop := queue[0]\n\t\tqueue = queue[1:]\n\n\t\tif *top.d == goal {\n\t\t\treturn top.c\n\n\t\t}\n\n\t\tok, ur := up(*top.d)\n\t\tif ok {\n\t\t\tqueue = append(queue, item{&ur, top.c + 1})\n\t\t}\n\t\tok, dr := down(*top.d)\n\t\tif ok {\n\t\t\tqueue = append(queue, item{&dr, top.c + 1})\n\t\t}\n\t\tok, lr := left(*top.d)\n\t\tif ok {\n\t\t\tqueue = append(queue, item{&lr, top.c + 1})\n\t\t}\n\t\tok, rr := right(*top.d)\n\t\tif ok {\n\t\t\tqueue = append(queue, item{&rr, top.c + 1})\n\t\t}\n\t}\n\n}\n\nfunc main() {\n\tsc.Split(bufio.ScanWords)\n\tvar state [9]byte\n\tfor i := 0; i < 9; i++ {\n\t\tstate[i] = byte(next())\n\t}\n\tqueue = append(queue, item{&state, 0})\n\tcost := bfs(0)\n\tfmt.Println(cost)\n}\n\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nconst (\n\tN    = 3\n\tBASE = 10007\n\tMOD  = 1000000007\n)\n\ntype Puzzle struct {\n\tboard [N * N]int // (x, y). (0, 0) = 0,  (1, 0) = 1, (0, 1) = 3\n}\n\ntype SolveContext struct {\n\tcurrent  *Puzzle\n\tprevious *Puzzle\n\tcount    int\n}\n\ntype Position struct {\n\tx int\n\ty int\n}\n\nfunc NewPuzzle(b [N * N]int) *Puzzle {\n\treturn &Puzzle{board: b}\n}\n\nfunc (puzzle *Puzzle) toInt() int {\n\tarr := puzzle.board\n\tsum := arr[0]\n\tfor i := 1; i < len(arr); i++ {\n\t\tsum = sum*BASE + arr[i]\n\t\tif sum > MOD {\n\t\t\tsum = sum % MOD\n\t\t}\n\t}\n\treturn sum\n}\n\nfunc (puzzle *Puzzle) isSolved() bool {\n\tsolvedBoard := [N * N]int{1, 2, 3, 4, 5, 6, 7, 8, 0}\n\treturn puzzle.board == solvedBoard\n}\n\nfunc swap(puzzle *Puzzle, one, two Position) *Puzzle {\n\tswapped := NewPuzzle(puzzle.board)\n\tswapped.board[one.y*N+one.x], swapped.board[two.y*N+two.x] =\n\t\tswapped.board[two.y*N+two.x], swapped.board[one.y*N+one.x]\n\treturn swapped\n}\n\nfunc (puzzle *Puzzle) getEmptyPosition() *Position {\n\tfor i := 0; i < N; i++ {\n\t\tfor j := 0; j < N; j++ {\n\t\t\tif puzzle.board[i*N+j] == 0 {\n\t\t\t\treturn &Position{x: j, y: i}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (puzzle *Puzzle) nextPuzzles() []*Puzzle {\n\temptyPosition := puzzle.getEmptyPosition()\n\tif emptyPosition == nil {\n\t\tpanic(fmt.Errorf(\"emptyPostion must not be empty\"))\n\t}\n\tbasePosition := *emptyPosition\n\tdirections := [][2]int{[2]int{-1, 0}, [2]int{1, 0}, [2]int{0, -1}, [2]int{0, 1}} // []{x, y}\n\tnexts := []*Puzzle{}\n\tfor _, dir := range directions {\n\t\tnextPosition := Position{basePosition.x + dir[0], basePosition.y + dir[1]}\n\t\tif nextPosition.x >= 0 && nextPosition.x <= N-1 &&\n\t\t\tnextPosition.y >= 0 && nextPosition.y <= N-1 {\n\t\t\tnexts = append(nexts, swap(puzzle, basePosition, nextPosition))\n\t\t}\n\t}\n\treturn nexts\n}\n\nfunc solve(initialPuzzle *Puzzle) int {\n\tinitial := SolveContext{initialPuzzle, nil, 0}\n\tvisited := make(map[int]*struct{})\n\tstack := []SolveContext{initial}\n\tvar solved SolveContext\n\tfor len(stack) > 0 {\n\t\tsolveContext := stack[0]\n\t\tcurrent := solveContext.current\n\t\tcount := solveContext.count\n\t\tvisited[current.toInt()] = &struct{}{}\n\t\tstack = stack[1:]\n\t\tif current.isSolved() {\n\t\t\tsolved = solveContext\n\t\t\tbreak\n\t\t}\n\t\tfor _, v := range current.nextPuzzles() {\n\t\t\tif visited[v.toInt()] == nil {\n\t\t\t\tnextContext := SolveContext{v, current, count + 1}\n\t\t\t\tstack = append(stack, nextContext)\n\t\t\t}\n\t\t}\n\t}\n\treturn solved.count\n}\n\nfunc main() {\n\tsc := bufio.NewScanner(os.Stdin)\n\tsc.Split(bufio.ScanWords)\n\n\tvar arr [N * N]int\n\tfor i := 0; i < len(arr); i++ {\n\t\tx, err := nextInt(sc)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tarr[i] = x\n\t}\n\n\tpuzzle := NewPuzzle(arr)\n\tfmt.Println(solve(puzzle))\n}\n\nfunc nextInt(sc *bufio.Scanner) (int, error) {\n\tsc.Scan()\n\treturn strconv.Atoi(sc.Text())\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\nfunc nextString() string {\n\tscanner.Scan()\n\treturn scanner.Text()\n}\n\nfunc nextInt() int {\n\tn, err := strconv.Atoi(nextString())\n\tif err != nil {\n\t\tfmt.Printf(\"strconv.Atoi failed: %v\\n\", err)\n\t}\n\treturn n\n}\n\ntype Puzzle struct {\n\tnumbers     []int\n\tiZero       int\n\tpathHistory string\n}\n\nfunc (p Puzzle) toString() string {\n\ts := \"\"\n\tfor i := 0; i < len(p.numbers); i++ {\n\t\ts += strconv.Itoa(p.numbers[i])\n\t}\n\treturn s\n}\n\nfunc newPuzzle(size int) Puzzle {\n\tpuzzle := Puzzle{}\n\tpuzzle.numbers = make([]int, size)\n\treturn puzzle\n}\n\nfunc (p *Puzzle) isSolved() bool {\n\tfor i := 0; i <= 7; i++ {\n\t\tif p.numbers[i] != i+1 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (p *Puzzle) swap(i, j int) {\n\tp.numbers[i], p.numbers[j] = p.numbers[j], p.numbers[i]\n}\n\nfunc copy(p1, p2 *Puzzle) {\n\tp1.numbers = append([]int{}, p2.numbers...)\n\tp1.iZero = p2.iZero\n\tp1.pathHistory = p2.pathHistory\n}\n\nvar d = []int{1, -3, -1, 3}\n\nfunc newQueue() Queue {\n\tqueue := Queue{}\n\tqueue.array = []Puzzle{}\n\treturn queue\n}\n\ntype Queue struct {\n\tarray []Puzzle\n}\n\nfunc (q *Queue) push(p Puzzle) {\n\tq.array = append(q.array, p)\n}\n\nfunc (q *Queue) pop() Puzzle {\n\tp := q.array[0]\n\tq.array = q.array[1:len(q.array)]\n\treturn p\n}\n\nfunc (q *Queue) isEmpty() bool {\n\treturn len(q.array) == 0\n}\n\nfunc bfs(start Puzzle) string {\n\tqueue := newQueue()\n\tqueue.push(start)\n\n\thistory := map[string]bool{}\n\thistory[start.toString()] = true\n\n\tfor !queue.isEmpty() {\n\t\tu := queue.pop()\n\t\tif u.isSolved() {\n\t\t\treturn u.pathHistory\n\t\t}\n\n\t\tfor i := 0; i < 4; i++ {\n\t\t\tdi := d[i]\n\n\t\t\tiZeroOld := u.iZero\n\t\t\tiZeroNew := u.iZero + di\n\n\t\t\tif iZeroNew < 0 || iZeroNew >= 9 || (di == -1 && iZeroOld%3 == 0) || (di == 1 && iZeroOld%3 == 2) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tv := Puzzle{}\n\t\t\tcopy(&v, &u)\n\t\t\tv.swap(iZeroOld, iZeroNew)\n\n\t\t\tif !history[v.toString()] {\n\t\t\t\thistory[v.toString()] = true\n\t\t\t\tv.iZero = iZeroNew\n\t\t\t\tv.pathHistory += strconv.Itoa(iZeroOld)\n\t\t\t\t// fmt.Println(v.toString())\n\t\t\t\tqueue.push(v)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"failed\"\n}\n\nfunc main() {\n\tscanner.Split(bufio.ScanWords)\n\n\tpuzzle := newPuzzle(9)\n\tfor j := 0; j < 9; j++ {\n\t\tpuzzle.numbers[j] = nextInt()\n\t\tif puzzle.numbers[j] == 0 {\n\t\t\tpuzzle.iZero = j\n\t\t}\n\t}\n\n\tnUpdates := bfs(puzzle)\n\n\tfmt.Println(len(nUpdates))\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar sc = bufio.NewScanner(os.Stdin)\n\nfunc search(in [9]byte) int {\n\tfor i := 0; i < 9; i++ {\n\t\tif in[i] == byte(0) {\n\t\t\treturn i\n\t\t}\n\t}\n\tpanic(\"not found 0\")\n}\n\nfunc up(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos > 2 {\n\t\tin[pos], in[pos-3] = in[pos-3], in[pos]\n\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\n\nfunc down(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\tif pos < 6 {\n\t\tin[pos], in[pos+3] = in[pos+3], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc left(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\t// mod(pos, 3) == 0\n\tif pos != 0 && pos != 3 && pos != 6 {\n\t\tin[pos], in[pos-1] = in[pos-1], in[pos]\n\t} else {\n\t\treturn false, in\n\t}\n\treturn true, in\n\n}\nfunc right(in [9]byte) (bool, [9]byte) {\n\tpos := search(in)\n\t// mod(pos, 3) == 2\n\tif pos != 2 && pos != 5 && pos != 8 {\n\t\tin[pos], in[pos+1] = in[pos+1], in[pos]\n\t} else {\n\t\treturn false, in\n\n\t}\n\treturn true, in\n\n}\n\nfunc next() int {\n\tsc.Scan()\n\ti, _ := strconv.Atoi(sc.Text())\n\treturn i\n\n}\n\nvar goal = [9]byte{1, 2, 3, 4, 5, 6, 7, 8, 0}\n\nfunc pp(s [9]byte) {\n\n\tfor i := 0; i < 3; i++ {\n\t\tfmt.Printf(\"%d %d %d\\n\", s[0+3*i], s[1+3*i], s[2+3*i])\n\t}\n\tfmt.Println(\"----------------------\")\n\n}\n\ntype item struct {\n\td *[9]byte\n\tc int\n}\n\nvar queue = []item{}\nvar closed = map[[9]byte]bool{}\n\nfunc bfs(cost int) int {\n\tfor {\n\n\t\ttop := queue[0]\n\t\tqueue = queue[1:]\n\n\t\tif *top.d == goal {\n\t\t\treturn top.c\n\t\t}\n\t\tclosed[*top.d] = true\n\n\t\tok, ur := up(*top.d)\n\t\tok2, _ := closed[ur]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&ur, top.c + 1})\n\t\t}\n\t\tok, dr := down(*top.d)\n\t\tok2, _ = closed[ur]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&dr, top.c + 1})\n\t\t}\n\t\tok, lr := left(*top.d)\n\t\tok2, _ = closed[ur]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&lr, top.c + 1})\n\t\t}\n\t\tok, rr := right(*top.d)\n\t\tok2, _ = closed[ur]\n\t\tif ok && !ok2 {\n\t\t\tqueue = append(queue, item{&rr, top.c + 1})\n\t\t}\n\t}\n\n}\n\nfunc main() {\n\tsc.Split(bufio.ScanWords)\n\tvar state [9]byte\n\tfor i := 0; i < 9; i++ {\n\t\tstate[i] = byte(next())\n\t}\n\tqueue = append(queue, item{&state, 0})\n\tcost := bfs(0)\n\tfmt.Println(cost)\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n)\n\nvar up=[2]int{-1,0}\nvar down=[2]int{1,0}\nvar left=[2]int{0,-1}\nvar right=[2]int{0,1}\n\nconst size int =3\n\nconst UP int =0\nconst DOWN int =2\nconst LEFT int =1\nconst RIGHT int =3\n\nvar targetPoints [size*size][2]int\n\nvar movesHistory [100000]int\nvar ans=0\nvar tState =[][]int {//aim state\n\t{1 ,2 ,3} ,\n\t{4 ,5 ,6} ,\n\t{7 ,8,0}}\nvar STEP_SUM=0\nvar sState [][]int  //Init state\nvar blank_row,blank_column int\nfunc main(){\n\tvar in = bufio.NewReader(os.Stdin)\n\tvar out = bufio.NewWriter(os.Stdout)\n\tsState=make([][]int,size)\n\tfor i,_ := range sState {\n\t\tsState[i]=make([]int,size)\n\t}\n\tfor i := 0; i < size; i++ {\n\t\tfmt.Fscanf(in, \"%d %d %d\\n\", &sState[i][0], &sState[i][1],&sState[i][2])\n\t}\n\tgetPoint()\n\tj:=getHeuristic(sState)\n\ti:=-1\n\tfor ans = j; ; ans++ {\n\t\tif solve(sState,blank_row,blank_column,0,i,j) {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor k:=0;k<ans;k++ {\n\t\tmove(sState, movesHistory[k])\n\t}\n\tfmt.Fprintln(out,STEP_SUM)\n\tout.Flush()\n}\nfunc getPoint(){\n\tfor i:=0;i<size;i++ {\n\t\tfor j:=0;j<size;j++ {\n\t\t\tif sState[i][j] == 0 {\n\t\t\t\tblank_row = i;\n\t\t\t\tblank_column = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor i:=0;i<size;i++ { //get aim coordinate\n\t\tfor j:=0;j<size;j++ {\n\t\t\ttargetPoints[tState[i][j]][0] = i; //y-coordinate\n\t\t\ttargetPoints[tState[i][j]][1] = j; //x-coordinate\n\t\t}\n\t}\n}\nfunc getHeuristic(state [][]int) int {\n\theuristic := 0;\n\tfor i:=0;i<len(state);i++ {\n\t\tfor j:=0;j<len(state[i]);j++ {\n\t\t\tif state[i][j] != 0 {\n\t\t\t\theuristic = heuristic +\tint(math.Abs(float64(targetPoints[state[i][j]][0] - i))+math.Abs(float64(targetPoints[state[i][j]][1] - j)))\n\t\t\t}\n\t\t}\n\t}\n\treturn heuristic;\n}\n\nfunc solve(state [][]int, blank_row, blank_column, dep, d, h int) bool{\n\t//compare with aim matrix, check same or not, if same mean it's solved.\n\tisSolved := true\n\tfor i:=0;i<size;i++ {\n\t\tfor j:=0;j<size;j++ {\n\t\t\tif state[i][j] != tState[i][j] {\n\t\t\t\tisSolved = false\n\t\t\t}\n\t\t}\n\t}\n\tif isSolved {\n\t\treturn true\n\t}\n\tif dep == ans {\n\t\treturn false\n\t}\n\t//For express \"blank\" moved coordinate location\n\tblank_row1:= blank_row\n\tblank_column1:= blank_column\n\tstate2 := make([][]int,size)\n\tfor i,_ := range state2 {\n\t\tstate2[i]=make([]int,size)\n\t}\n\tfor direction:=0;direction<4;direction++ {\n\t\tfor i:=0;i<len(state);i++ {\n\t\t\tfor j:=0;j<len(state);j++ {\n\t\t\t\tstate2[i][j] = state[i][j]\n\t\t\t}\n\t\t}\n\t\t//if backtrace same with last time. end this situation.\n\t\tif direction != d && (d%2 == direction%2) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif direction == UP {\n\t\t\tblank_row1 = blank_row + up[0]\n\t\t\tblank_column1 = blank_column + up[1]\n\t\t} else if direction == DOWN {\n\t\t\tblank_row1 = blank_row + down[0]\n\t\t\tblank_column1 = blank_column + down[1]\n\t\t} else if direction == LEFT {\n\t\t\tblank_row1 = blank_row + left[0]\n\t\t\tblank_column1 = blank_column + left[1]\n\t\t} else {\n\t\t\tblank_row1 = blank_row + right[0]\n\t\t\tblank_column1 = blank_column + right[1]\n\t\t}\n\n\t\t//check the edge\n\t\tif blank_column1 < 0 || blank_column1 == size|| blank_row1 < 0 || blank_row1 == size {\n\t\t\tcontinue\n\t\t}\n\n\t\t//swap blank and right now moved locate coordinate\n\t\tstate2[blank_row][blank_column] = state2[blank_row1][blank_column1]\n\t\tstate2[blank_row1][blank_column1] = 0\n\t\tvar h1 int\n\t\t//check the blank whether close the aim coordinate\n\t\tif direction == DOWN && blank_row1> targetPoints[state[blank_row1][blank_column1]][0] {\n\t\t\th1 = h - 1\n\t\t} else if direction == UP && blank_row1< targetPoints[state[blank_row1][blank_column1]][0] {\n\t\t\th1 = h - 1\n\t\t} else if direction == RIGHT && blank_column1> targetPoints[state[blank_row1][blank_column1]][1] {\n\t\t\th1 = h - 1\n\t\t} else if direction == LEFT && blank_column1< targetPoints[state[blank_row1][blank_column1]][1] {\n\t\t\th1 = h - 1\n\t\t} else {\n\t\t\t//bad situation make the step bigger.\n\t\t\th1 = h + 1\n\t\t}\n\t\tif h1+dep+1>ans { //pruning\n\t\t\tcontinue\n\t\t}\n\t\tmovesHistory[dep] = direction\n\n\t\tif solve(state2, blank_row1, blank_column1, dep+1, direction, h1) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\nfunc move(state [][]int,direction int)  {\n\trow := 0\n\tcolumn := 0\n\tfor i:=0;i<len(state);i++ {\n\t\tfor j:=0;j<len(state);j++ {\n\t\t\tif state[i][j] == 0 {\n\t\t\t\trow = i\n\t\t\t\tcolumn = j\n\t\t\t}\n\t\t}\n\t}\n\tswitch direction {\n\tcase UP:\n\t\tstate[row][column] = state[row-1][column]\n\t\tstate[row-1][column] = 0\n\t\tbreak\n\tcase DOWN:\n\t\tstate[row][column] = state[row+1][column]\n\t\tstate[row+1][column] = 0\n\t\tbreak\n\tcase LEFT:\n\t\tstate[row][column] = state[row][column-1]\n\t\tstate[row][column-1] = 0\n\t\tbreak\n\tcase RIGHT:\n\t\tstate[row][column] = state[row][column+1]\n\t\tstate[row][column+1] = 0\n\t\tbreak\n\t}\n\tSTEP_SUM++\n}\n"
  },
  {
    "language": "OCaml",
    "code": "let (n1, n2, n_limit) = (3, 9, 31)\n\nlet area =\n  [| [1; 3]; [0; 2; 4]; [1; 5]\n   ; [0; 4; 6]; [1; 3; 5; 7]; [2; 4; 8]\n   ; [3; 7]; [4; 6; 8]; [5; 7] |]\n\nlet goal = Array.init n2 (fun i -> (i + 1) mod n2)\n\nlet md = Array.make_matrix n2 n2 0\n\nlet initialize_md () =\n  for i = 0 to n2 - 2 do\n    for j = 0 to n2 - 1 do\n      md.(i+1).(j) <- abs (i / n1 - j / n1) + abs (i mod n1 - j mod n1)\n    done\n  done\n\nlet idastar a limit space lower =\n  let rec doit i space moved lower =\n    if i = limit then\n      if a <> goal then ()\n      else begin\n        List.length moved - 1 |> Printf.printf \"%d\\n\";\n        exit 0;\n      end\n    else\n      List.iter (fun j ->\n        let x = a.(j) in\n        if x = List.hd moved then () else\n        let lower = lower - md.(x).(j) + md.(x).(space) in\n        if lower + i > limit then ()\n        else begin\n          a.(j) <- 0;\n          a.(space) <- x;\n          doit (i + 1) j (x :: moved) lower;\n          a.(j) <- x;\n          a.(space) <- 0;\n        end) area.(space) in\n  doit 0 space [-1] lower\n\nlet findi a x =\n  let n = Array.length a in\n  let rec doit i =\n    if i = n then assert false\n    else if a.(i) = x then i\n    else doit (i + 1) in\n  doit 0\n\nlet () =\n  initialize_md ();\n  let a = Array.init n2 (fun _ -> Scanf.scanf \"%d \" (fun i -> i)) in\n  let space = findi a 0 in\n  let lower =\n    Array.fold_left (fun (i, sum) e -> (i + 1, sum + md.(e).(i))) (0, 0) a |> snd in\n  for limit = lower to n_limit do\n    idastar a limit space lower\n  done"
  },
  {
    "language": "OCaml",
    "code": "let (n1, n2) = (3, 9)\nlet n_limit = 100\nlet mdt = Array.make_matrix n2 n2 0\nlet path = Array.make n_limit 0\nlet dx = [| 0; -1; 0; 1 |]\nlet dy = [| 1; 0; -1; 0 |]\nlet dir = [| \"r\"; \"u\"; \"l\"; \"d\" |]\n\ntype puzzle = { tbl : int array; space : int; md : int }\n\nlet dfs puzzle limit =\n  let rec doit depth prev pzl =\n    if pzl.md = 0 then true\n    else if depth + pzl.md > limit then false\n    else begin\n      let (sx, sy) = (pzl.space / n1, pzl.space mod n1) in\n      let { tbl; md } = pzl in\n      let swap tbl i j = let t = tbl.(i) in tbl.(i) <- tbl.(j); tbl.(j) <- t in\n      let rec move r =\n        if r = 4 then false\n        else\n          let (tx, ty) = (sx + dx.(r), sy + dy.(r)) in\n          if tx < 0 || ty < 0 || tx >= n1 || ty >= n1 then move (r + 1)\n          else if max prev r - min prev r = 2 then move (r + 1)\n          else begin\n            let (space, num) = (tx * n1 + ty, sx * n1 + sy) in\n            let md = md - mdt.(space).(tbl.(space) - 1) in\n            let md = md + mdt.(num).(tbl.(space) - 1) in\n            let tbl = Array.copy tbl in\n            swap tbl space num;\n            if doit (depth + 1) r { tbl; space; md } then begin\n              path.(depth) <- r;\n              true\n            end else move (r + 1)\n          end in\n      move 0\n    end in\n  doit 0 (-n_limit) puzzle\n\nlet idastar tbl space =\n  let (_, md) =\n    Array.fold_left (fun (i, sum) e ->\n      (i + 1, if e = n2 then sum else sum + mdt.(i).(e-1)))\n      (0, 0) tbl in\n  let pzl = { tbl; space; md } in\n  let rec doit limit =\n    if limit > n_limit then assert false\n    else if dfs pzl limit then begin\n      let str = ref \"\" in\n      for i = 0 to limit - 1 do\n        str := !str ^ dir.(path.(i));\n      done;\n      !str\n    end else doit (limit + 1) in\n  doit pzl.md\n\nlet () =\n  for i = 0 to n2 - 1 do\n    for j = 0 to n2 - 1 do\n      mdt.(i).(j) <- abs (i / n1 - j / n1) + abs (i mod n1 - j mod n1)\n    done\n  done;\n  let tbl = Array.make n2 0 in\n  let rec doit i space =\n    if i = n2 then space\n    else begin\n      let x = Scanf.scanf \"%d \" (fun i -> i) in\n      let (x, space) = if x = 0 then (n2, i) else (x, space) in\n      tbl.(i) <- x;\n      doit (i + 1) space\n    end in\n  doit 0 0 |> idastar tbl |> String.length |> Printf.printf \"%d\\n\""
  },
  {
    "language": "OCaml",
    "code": "let (n1, n2) = (3, 9)\n(* let (n1, n2) = (4, 16) *)\nlet n_limit = 100\nlet mdt = Array.make_matrix n2 n2 0\nlet path = Array.make n_limit 0\nlet dx = [| 0; -1; 0; 1 |]\nlet dy = [| 1; 0; -1; 0 |]\nlet dir = [| \"r\"; \"u\"; \"l\"; \"d\" |]\n\ntype puzzle = { tbl : int array; space : int; md : int }\n\nlet dfs puzzle limit =\n  let rec doit depth prev pzl =\n    if pzl.md = 0 then true\n    else if depth + pzl.md > limit then false\n    else begin\n      let rec move r =\n        if r = 4 then false\n        else\n          let (sx, sy) = (pzl.space / n1, pzl.space mod n1) in\n          let (tx, ty) = (sx + dx.(r), sy + dy.(r)) in\n          if tx < 0 || ty < 0 || tx >= n1 || ty >= n1 then move (r + 1)\n          else if max prev r - min prev r = 2 then move (r + 1)\n          else begin\n            let { tbl; space; md } = pzl in\n            let (space, num) = (tx * n1 + ty, sx * n1 + sy) in\n            let md = md - mdt.(space).(tbl.(space)-1) in\n            let md = md + mdt.(num).(tbl.(space)-1) in\n            let tbl = Array.copy tbl in\n            let t = tbl.(space) in\n            tbl.(space) <- tbl.(num);\n            tbl.(num) <- t;\n            if doit (depth + 1) r { tbl; space; md } then begin\n              path.(depth) <- r;\n              true\n            end else move (r + 1)\n          end in\n      move 0\n    end in\n  doit 0 (-n_limit) puzzle\n\nlet idastar tbl space =\n  let (_, md) =\n    Array.fold_left (fun (i, sum) e ->\n      (i + 1, if e = n2 then sum else sum + mdt.(i).(e-1)))\n      (0, 0) tbl in\n  let pzl = { tbl; space; md } in\n  let rec doit limit =\n    if limit > n_limit then assert false\n    else if dfs pzl limit then begin\n      let str = ref \"\" in\n      for i = 0 to limit - 1 do\n        str := !str ^ dir.(path.(i));\n      done;\n      !str\n    end else doit (limit + 1) in\n  doit pzl.md\n\nlet () =\n  for i = 0 to n2 - 1 do\n    for j = 0 to n2 - 1 do\n      mdt.(i).(j) <- abs (i / n1 - j / n1) + abs (i mod n1 - j mod n1)\n    done\n  done;\n  let tbl = Array.make n2 0 in\n  let rec doit i space =\n    if i = n2 then space\n    else begin\n      let x = Scanf.scanf \"%d \" (fun i -> i) in\n      let (x, space) = if x = 0 then (n2, i) else (x, space) in\n      tbl.(i) <- x;\n      doit (i + 1) space\n    end in\n  doit 0 0 |> idastar tbl |> String.length |> Printf.printf \"%d\\n\""
  },
  {
    "language": "OCaml",
    "code": "let area =\n  [| [1; 3]; [0; 2; 4]; [1; 5]\n   ; [0; 4; 6]; [1; 3; 5; 7]; [2; 4; 8]\n   ; [3; 7]; [4; 6; 8]; [5; 7] |]\n\nlet m_d =\n  [| [|0; 0; 0; 0; 0; 0; 0; 0; 0|]\n   ; [|0; 1; 2; 1; 2; 3; 2; 3; 4|]\n   ; [|1; 0; 1; 2; 1; 2; 3; 2; 3|]\n   ; [|2; 1; 0; 3; 2; 1; 4; 3; 2|]\n   ; [|1; 2; 3; 0; 1; 2; 1; 2; 3|]\n   ; [|2; 1; 2; 1; 0; 1; 2; 1; 2|]\n   ; [|3; 2; 1; 2; 1; 0; 3; 2; 1|]\n   ; [|2; 3; 4; 1; 2; 3; 0; 1; 2|]\n   ; [|3; 2; 3; 2; 1; 2; 1; 0; 1|] |]\n\nlet idastar a limit space_i lower goal =\n  let moved = [-1] in\n  let rec doit i space_i moved lower =\n    if i = limit then begin\n      if a = goal then begin\n        List.length moved - 1 |> Printf.printf \"%d\\n\"; exit 0\n      end;\n    end else\n      List.iter (fun j ->\n        let x = a.(j) in\n        if x = List.hd moved then () else\n        let lower = lower - m_d.(x).(j) + m_d.(x).(space_i) in\n        if lower + i > limit then ()\n        else begin\n          a.(j) <- 0;\n          a.(space_i) <- x;\n          doit (i + 1) j (x :: moved) lower;\n          a.(j) <- x;\n          a.(space_i) <- 0;\n        end) area.(space_i) in\n  doit 0 space_i moved lower\n\nlet () =\n  let a = Array.init 9 (fun _ -> Scanf.scanf \"%d \" (fun i -> i)) in\n  let rec f i =\n    if i = 9 then assert false\n    else if a.(i) = 0 then i\n    else f (i + 1) in\n  let space_i = f 0 in\n  let goal = [|1; 2; 3; 4; 5; 6; 7; 8; 0|] in\n  let rec g i acc =\n    if i = 9 then acc\n    else g (i + 1) (acc + m_d.(a.(i)).(i)) in\n  let lower = g 0 0 in\n  for limit = lower to 31 do\n    idastar a limit space_i lower goal;\n  done"
  },
  {
    "language": "OCaml",
    "code": "let (n1, n2, n_limit) = (3, 9, 31)\n\nlet goal = Array.init n2 (fun i -> (i + 1) mod n2)\n\nlet area = Array.make n2 []\n\nlet md = Array.make_matrix n2 n2 0\n\nlet initialize_area () =\n  for i = 0 to n2 - 1 do\n    let lst = [] in\n    let lst = if i + n1 < n2 then (i + n1) :: lst else lst in\n    let lst = if (i + 1) mod n1 <> 0 then (i + 1) :: lst else lst in\n    let lst = if i - 1 >= 0 && (i - 1) mod n1 <> n1 - 1 then (i - 1) :: lst else lst in\n    let lst = if i - n1 >= 0 then (i - n1) :: lst else lst in\n    area.(i) <- lst;\n  done\n\nlet initialize_md () =\n  for i = 0 to n2 - 2 do\n    for j = 0 to n2 - 1 do\n      md.(i+1).(j) <- abs (i / n1 - j / n1) + abs (i mod n1 - j mod n1)\n    done\n  done\n\nlet idastar a limit space lower =\n  let rec doit i space moved lower =\n    if i = limit then\n      if a <> goal then ()\n      else begin\n        Printf.printf \"%d\\n\" limit;\n        exit 0;\n      end\n    else\n      List.iter (fun j ->\n        let x = a.(j) in\n        if x = moved then ()\n        else\n          let lower = lower - md.(x).(j) + md.(x).(space) in\n          if lower + i > limit then ()\n          else begin\n            a.(j) <- 0;\n            a.(space) <- x;\n            doit (i + 1) j x lower;\n            a.(j) <- x;\n            a.(space) <- 0;\n          end)\n      area.(space) in\n  doit 0 space (-1) lower\n\nlet findi a x =\n  let n = Array.length a in\n  let rec doit i =\n    if i = n then assert false\n    else if a.(i) = x then i\n    else doit (i + 1) in\n  doit 0\n\nlet () =\n  initialize_area ();\n  initialize_md ();\n  let a = Array.init n2 (fun _ -> Scanf.scanf \"%d \" (fun i -> i)) in\n  let space = findi a 0 in\n  let lower =\n    Array.fold_left (fun (i, sum) e -> (i + 1, sum + md.(e).(i))) (0, 0) a |> snd in\n  for limit = lower to n_limit do\n    idastar a limit space lower\n  done"
  },
  {
    "language": "OCaml",
    "code": "let area =\n  [| [1; 3]; [0; 2; 4]; [1; 5]\n   ; [0; 4; 6]; [1; 3; 5; 7]; [2; 4; 8]\n   ; [3; 7]; [4; 6; 8]; [5; 7] |]\n\nlet md = Array.make_matrix 9 9 0\n\nlet initialize_md () =\n  for i = 0 to 7 do\n    for j = 0 to 8 do\n      md.(i+1).(j) <- abs (i / 3 - j / 3) + abs (i mod 3 - j mod 3)\n    done\n  done\n\nlet idastar a limit space_i lower goal =\n  let rec doit i space_i moved lower =\n    if i = limit then begin\n      if a = goal then begin\n        List.length moved - 1 |> Printf.printf \"%d\\n\"; exit 0\n      end;\n    end else\n      List.iter (fun j ->\n        let x = a.(j) in\n        if x = List.hd moved then () else\n        let lower = lower - md.(x).(j) + md.(x).(space_i) in\n        if lower + i > limit then ()\n        else begin\n          a.(j) <- 0;\n          a.(space_i) <- x;\n          doit (i + 1) j (x :: moved) lower;\n          a.(j) <- x;\n          a.(space_i) <- 0;\n        end) area.(space_i) in\n  doit 0 space_i [-1] lower\n\nlet () =\n  initialize_md ();\n  let a = Array.init 9 (fun _ -> Scanf.scanf \"%d \" (fun i -> i)) in\n  let rec f i =\n    if i = 9 then assert false\n    else if a.(i) = 0 then i\n    else f (i + 1) in\n  let space_i = f 0 in\n  let rec g i acc =\n    if i = 9 then acc\n    else g (i + 1) (acc + md.(a.(i)).(i)) in\n  let lower = g 0 0 in\n  let goal = [|1; 2; 3; 4; 5; 6; 7; 8; 0|] in\n  for limit = lower to 31 do\n    idastar a limit space_i lower goal;\n  done"
  },
  {
    "language": "OCaml",
    "code": "let (n1, n2) = (3, 9)\nlet n_limit = 100\nlet mdt = Array.make_matrix n2 n2 0\nlet path = Array.make n_limit 0\nlet dx = [| 0; -1; 0; 1 |]\nlet dy = [| 1; 0; -1; 0 |]\n\ntype puzzle = { tbl : int array; space : int; md : int }\n\nlet dfs puzzle limit =\n  let rec doit depth prev pzl =\n    if pzl.md = 0 then true\n    else if depth + pzl.md > limit then false\n    else begin\n      let (sx, sy) = (pzl.space / n1, pzl.space mod n1) in\n      let { tbl; md } = pzl in\n      let swap tbl i j = let t = tbl.(i) in tbl.(i) <- tbl.(j); tbl.(j) <- t in\n      let rec move r =\n        if r = 4 then false\n        else\n          let (tx, ty) = (sx + dx.(r), sy + dy.(r)) in\n          if tx < 0 || ty < 0 || tx >= n1 || ty >= n1 then move (r + 1)\n          else if max prev r - min prev r = 2 then move (r + 1)\n          else begin\n            let (space, num) = (tx * n1 + ty, sx * n1 + sy) in\n            let md = md - mdt.(space).(tbl.(space) - 1) in\n            let md = md + mdt.(num).(tbl.(space) - 1) in\n            let tbl = Array.copy tbl in\n            swap tbl space num;\n            if doit (depth + 1) r { tbl; space; md } then begin\n              path.(depth) <- r;\n              true\n            end else move (r + 1)\n          end in\n      move 0\n    end in\n  doit 0 (-n_limit) puzzle\n\nlet idastar tbl space =\n  let (_, md) =\n    Array.fold_left (fun (i, sum) e ->\n      (i + 1, if e = n2 then sum else sum + mdt.(i).(e-1)))\n      (0, 0) tbl in\n  let pzl = { tbl; space; md } in\n  let rec doit limit =\n    if limit > n_limit then assert false\n    else if dfs pzl limit then limit\n    else doit (limit + 1) in\n  doit pzl.md\n\nlet () =\n  for i = 0 to n2 - 1 do\n    for j = 0 to n2 - 1 do\n      mdt.(i).(j) <- abs (i / n1 - j / n1) + abs (i mod n1 - j mod n1)\n    done\n  done;\n  let tbl = Array.make n2 0 in\n  let rec doit i space =\n    if i = n2 then space\n    else begin\n      let x = Scanf.scanf \"%d \" (fun i -> i) in\n      let (x, space) = if x = 0 then (n2, i) else (x, space) in\n      tbl.(i) <- x;\n      doit (i + 1) space\n    end in\n  doit 0 0 |> idastar tbl |> Printf.printf \"%d\\n\""
  },
  {
    "language": "OCaml",
    "code": "let area =\n  [| [1; 3]\n   ; [0; 2; 4]\n   ; [1; 5]\n   ; [0; 4; 6]\n   ; [1; 3; 5; 7]\n   ; [2; 4; 8]\n   ; [3; 7]\n   ; [4; 6; 8]\n   ; [5; 7] |]\n\nlet m_d =\n  [| [|0; 0; 0; 0; 0; 0; 0; 0; 0|]\n   ; [|0; 1; 2; 1; 2; 3; 2; 3; 4|]\n   ; [|1; 0; 1; 2; 1; 2; 3; 2; 3|]\n   ; [|2; 1; 0; 3; 2; 1; 4; 3; 2|]\n   ; [|1; 2; 3; 0; 1; 2; 1; 2; 3|]\n   ; [|2; 1; 2; 1; 0; 1; 2; 1; 2|]\n   ; [|3; 2; 1; 2; 1; 0; 3; 2; 1|]\n   ; [|2; 3; 4; 1; 2; 3; 0; 1; 2|]\n   ; [|3; 2; 3; 2; 1; 2; 1; 0; 1|] |]\n\nlet h a =\n  let rec doit i acc =\n    if i = 9 then acc\n    else doit (i + 1) (acc + m_d.(a.(i)).(i))\n  in doit 0 0\n\nlet idx_by_val x a =\n  let n = Array.length a in\n  let rec doit i =\n    if i = n then raise Not_found\n    else if x = a.(i) then i\n    else doit (i + 1)\n  in doit 0\n\nlet solve a =\n  let goal = [|1; 2; 3; 4; 5; 6; 7; 8; 0|] in\n  let rec idastar i limit space_i moved lower =\n    if i = limit then begin\n      if a = goal then (Printf.printf \"%d\\n\" (List.length moved - 1); exit 0)\n    end else\n      let move j =\n        let x = a.(j) in\n        if x <> List.hd moved then\n          let new_lower = lower - m_d.(x).(j) + m_d.(x).(space_i) in\n          if new_lower + i <= limit then begin\n            a.(j) <- 0;\n            a.(space_i) <- x;\n            idastar (i + 1) limit j (x :: moved) new_lower;\n            a.(j) <- x;\n            a.(space_i) <- 0;\n          end in\n      List.iter move area.(space_i)\n  in\n  let lower = h a in\n  let rec doit limit =\n    if limit < 32 then begin\n      idastar 0 limit (idx_by_val 0 a) [-1] lower;\n      doit (limit + 1)\n    end in\n  doit lower\n\nlet () =\n  solve (Array.init 9 (fun _ -> Scanf.scanf \"%d \" (fun i -> i)))"
  },
  {
    "language": "OCaml",
    "code": "let (n1, n2, n_limit) = (3, 9, 31)\n\nlet area =\n  [| [1; 3]; [0; 2; 4]; [1; 5]\n   ; [0; 4; 6]; [1; 3; 5; 7]; [2; 4; 8]\n   ; [3; 7]; [4; 6; 8]; [5; 7] |]\n\nlet md = Array.make_matrix n2 n2 0\n\nlet initialize_md () =\n  for i = 0 to n2 - 2 do\n    for j = 0 to n2 - 1 do\n      md.(i+1).(j) <- abs (i / n1 - j / n1) + abs (i mod n1 - j mod n1)\n    done\n  done\n\nlet idastar a limit space_i lower goal =\n  let rec doit i space_i moved lower =\n    if i = limit then begin\n      if a = goal then begin\n        List.length moved - 1 |> Printf.printf \"%d\\n\";\n        exit 0;\n      end\n    end else\n      List.iter (fun j ->\n        let x = a.(j) in\n        if x = List.hd moved then () else\n        let lower = lower - md.(x).(j) + md.(x).(space_i) in\n        if lower + i > limit then ()\n        else begin\n          a.(j) <- 0;\n          a.(space_i) <- x;\n          doit (i + 1) j (x :: moved) lower;\n          a.(j) <- x;\n          a.(space_i) <- 0;\n        end) area.(space_i) in\n  doit 0 space_i [-1] lower\n\nlet () =\n  initialize_md ();\n  let a = Array.init n2 (fun _ -> Scanf.scanf \"%d \" (fun i -> i)) in\n  let rec f i =\n    if i = n2 then assert false\n    else if a.(i) = 0 then i\n    else f (i + 1) in\n  let space_i = f 0 in\n  let rec g i acc =\n    if i = n2 then acc\n    else g (i + 1) (acc + md.(a.(i)).(i)) in\n  let lower = g 0 0 in\n  let goal = [|1; 2; 3; 4; 5; 6; 7; 8; 0|] in\n  for limit = lower to n_limit do\n    idastar a limit space_i lower goal\n  done"
  },
  {
    "language": "OCaml",
    "code": "let (n1, n2) = (3, 9)\n\nlet n_limit = 100\nlet mdt = Array.make_matrix n2 n2 0\nlet path = Array.make n_limit 0\nlet dx = [| 0; -1; 0; 1 |]\nlet dy = [| 1; 0; -1; 0 |]\nlet dir = [| \"r\"; \"u\"; \"l\"; \"d\" |]\n\ntype puzzle = { f : int array; space : int; md : int }\n\nlet initialize_mdt () =\n  for i = 0 to n2 - 1 do\n    for j = 0 to n2 - 1 do\n      mdt.(i).(j) <- abs (i / n1 - j / n1) + abs (i mod n1 - j mod n1)\n    done\n  done\n\nlet get_all_md f =\n  Array.fold_left (fun (i, sum) e ->\n    (i + 1, if e = n2 then sum else sum + mdt.(i).(e-1)))\n    (0, 0) f\n  |> snd\n\nlet dfs pzl limit =\n  let rec doit depth prev pzl =\n    if pzl.md = 0 then true\n    else if depth + pzl.md > limit then false\n    else begin\n      let sx = pzl.space / n1 in\n      let sy = pzl.space mod n1 in\n      let rec move r =\n        if r = 4 then false\n        else begin\n          let tx = sx + dx.(r) in\n          let ty = sy + dy.(r) in\n          if tx < 0 || ty < 0 || tx >= n1 || ty >= n1 then move (r + 1)\n          else if max prev r - min prev r = 2 then move (r + 1)\n          else begin\n            let { f; space; md } = pzl in\n            let a = tx*n1 + ty in\n            let b = sx*n1 + sy in\n            let md = md - mdt.(a).(f.(a) - 1) in\n            let md = md + mdt.(b).(f.(a) - 1) in\n            let newf = Array.copy f in\n            let t = newf.(a) in\n            newf.(a) <- newf.(b);\n            newf.(b) <- t;\n            if doit (depth + 1) r { f = newf; space = a; md } then begin\n              path.(depth) <- r;\n              true\n            end else move (r + 1)\n          end\n        end in\n      move 0\n    end in\n  doit 0 (-n_limit) pzl\n\nlet idastar f space =\n  let pzl = { f; space; md = get_all_md f } in\n  let rec doit limit =\n    if limit > n_limit then assert false\n    else if dfs pzl limit then begin\n      let str = ref \"\" in\n      for i = 0 to limit - 1 do\n        str := !str ^ dir.(path.(i));\n      done;\n      !str\n    end else doit (limit + 1) in\n  doit pzl.md\n\nlet () =\n  initialize_mdt ();\n  let f = Array.make n2 0 in\n  let space = ref 0 in\n  for i = 0 to n2 - 1 do\n    f.(i) <- Scanf.scanf \"%d \" (fun i -> i);\n    if f.(i) = 0 then begin\n      f.(i) <- n2;\n      space := i;\n    end\n  done;\n  idastar f !space |> String.length |> Printf.printf \"%d\\n\""
  },
  {
    "language": "OCaml",
    "code": "open Printf\nopen Scanf\n\nlet id x = x\n\ntype state = {mv : int; sp : int; bd : int array}\n\nlet () =\n  let goal = [|1;2;3;4;5;6;7;8;0|] in\n  let isp = ref 0 in\n  let bd = Array.init 9 (fun i -> let v = scanf \"%d \" id in if v = 0 then isp := i; v) in\n  let que = Queue.create () in\n  let ht = Hashtbl.create 100 in\n  let rec loop () =\n    if Queue.is_empty que then failwith \"8 puzzle\"\n    else\n      let st = Queue.pop que in\n      if st.bd = goal then st.mv\n      else begin\n          List.iter (fun (dx, dy) ->\n                     let x, y = (st.sp/3, st.sp mod 3) in\n                     let nx, ny = (dx + x, dy + y) in\n                     if 0 <= nx && nx <= 2 && 0 <= ny && ny <= 2 then\n                       let nsp = 3 * nx + ny in\n                       let nbd = Array.copy st.bd in\n                       begin\n                         nbd.(st.sp) <- st.bd.(nsp);\n                         nbd.(nsp) <- 0;\n                         if Hashtbl.mem ht nbd then ()\n                         else\n                           let nst = {mv = st.mv + 1; sp = nsp; bd = nbd} in Queue.push nst que;\n                                                                             Hashtbl.add ht nbd true\n                       end\n                    ) [(1,0);(0,1);(-1,0);(0,-1)];\n          loop ()\n        end                  \n  in\n  Queue.push {mv = 0; sp = !isp; bd = bd} que;\n  Hashtbl.add ht bd true;\n  loop () |> printf \"%d\\n\""
  },
  {
    "language": "OCaml",
    "code": "let (n1, n2) = (3, 9)\n\nlet n_limit = 100\nlet mdt = Array.make_matrix n2 n2 0\nlet path = Array.make n_limit 0\nlet dx = [| 0; -1; 0; 1 |]\nlet dy = [| 1; 0; -1; 0 |]\nlet dir = [| \"r\"; \"u\"; \"l\"; \"d\" |]\n\ntype puzzle = { f : int array; space : int; md : int }\n\nlet initialize_mdt () =\n  for i = 0 to n2 - 1 do\n    for j = 0 to n2 - 1 do\n      mdt.(i).(j) <- abs (i / n1 - j / n1) + abs (i mod n1 - j mod n1)\n    done\n  done\n\nlet get_all_md f =\n  Array.fold_left (fun (i, sum) e ->\n    (i + 1, if e = n2 then sum else sum + mdt.(i).(e-1)))\n    (0, 0) f\n  |> snd\n\nlet dfs pzl limit =\n  let rec doit depth prev pzl =\n    if pzl.md = 0 then true\n    else if depth + pzl.md > limit then false\n    else begin\n      let sx = pzl.space / n1 in\n      let sy = pzl.space mod n1 in\n      let rec move r =\n        if r = 4 then false\n        else begin\n          let tx = sx + dx.(r) in\n          let ty = sy + dy.(r) in\n          if tx < 0 || ty < 0 || tx >= n1 || ty >= n1 then move (r + 1)\n          else if max prev r - min prev r = 2 then move (r + 1)\n          else begin\n            let { f; space; md } = pzl in\n            let a = tx*n1 + ty in\n            let b = sx*n1 + sy in\n            let md = md - mdt.(a).(f.(a) - 1) in\n            let md = md + mdt.(b).(f.(a) - 1) in\n            let t = f.(a) in\n            f.(a) <- f.(b);\n            f.(b) <- t;\n            if doit (depth + 1) r { f; space = a; md } then begin\n              path.(depth) <- r;\n              true\n            end else move (r + 1)\n          end\n        end in\n      move 0\n    end in\n  doit 0 (-n_limit) pzl\n\nlet idastar f space =\n  let pzl = { f; space; md = get_all_md f } in\n  let rec doit limit =\n    if limit > n_limit then assert false\n    else if dfs pzl limit then begin\n      let str = ref \"\" in\n      for i = 0 to limit - 1 do\n        str := !str ^ dir.(path.(i));\n      done;\n      !str\n    end else doit (limit + 1) in\n  doit pzl.md\n\nlet () =\n  initialize_mdt ();\n  let f = Array.make n2 0 in\n  let space = ref 0 in\n  for i = 0 to n2 - 1 do\n    f.(i) <- Scanf.scanf \"%d \" (fun i -> i);\n    if f.(i) = 0 then begin\n      f.(i) <- n2;\n      space := i;\n    end\n  done;\n  idastar f !space |> String.length |> Printf.printf \"%d\\n\""
  },
  {
    "language": "OCaml",
    "code": "let (n1, n2) = (3, 9)\n(* let (n1, n2) = (4, 16) *)\n\nlet n_limit = 100\nlet mdt = Array.make_matrix n2 n2 0\nlet path = Array.make n_limit 0\nlet dx = [| 0; -1; 0; 1 |]\nlet dy = [| 1; 0; -1; 0 |]\nlet dir = [| \"r\"; \"u\"; \"l\"; \"d\" |]\n\ntype puzzle = { f : int array; space : int; md : int }\n\nlet initialize_mdt () =\n  for i = 0 to n2 - 1 do\n    for j = 0 to n2 - 1 do\n      mdt.(i).(j) <- abs (i / n1 - j / n1) + abs (i mod n1 - j mod n1)\n    done\n  done\n\nlet get_all_md f =\n  Array.fold_left (fun (i, sum) e ->\n    (i + 1, if e = n2 then sum else sum + mdt.(i).(e-1)))\n    (0, 0) f\n  |> snd\n\nlet dfs pzl limit =\n  let rec doit depth prev pzl =\n    if pzl.md = 0 then true\n    else if depth + pzl.md > limit then false\n    else begin\n      let sx = pzl.space / n1 in\n      let sy = pzl.space mod n1 in\n      let rec move r =\n        if r = 4 then false\n        else begin\n          let tx = sx + dx.(r) in\n          let ty = sy + dy.(r) in\n          if tx < 0 || ty < 0 || tx >= n1 || ty >= n1 then move (r + 1)\n          else if max prev r - min prev r = 2 then move (r + 1)\n          else begin\n            let { f; space; md } = pzl in\n            let a = tx*n1 + ty in\n            let b = sx*n1 + sy in\n            let md = md - mdt.(a).(f.(a) - 1) in\n            let md = md + mdt.(b).(f.(a) - 1) in\n            let newf = Array.init n2 (fun i -> f.(i)) in\n            let t = newf.(a) in\n            newf.(a) <- newf.(b);\n            newf.(b) <- t;\n            if doit (depth + 1) r { f = newf; space = a; md } then begin\n              path.(depth) <- r;\n              true\n            end else move (r + 1)\n          end\n        end in\n      move 0\n    end in\n  doit 0 (-n_limit) pzl\n\nlet idastar f space =\n  let pzl = { f; space; md = get_all_md f } in\n  let rec doit limit =\n    if limit > n_limit then assert false\n    else if dfs pzl limit then begin\n      let str = ref \"\" in\n      for i = 0 to limit - 1 do\n        str := !str ^ dir.(path.(i));\n      done;\n      !str\n    end else doit (limit + 1) in\n  doit pzl.md\n\nlet () =\n  initialize_mdt ();\n  let f = Array.make n2 0 in\n  let space = ref 0 in\n  for i = 0 to n2 - 1 do\n    f.(i) <- Scanf.scanf \"%d \" (fun i -> i);\n    if f.(i) = 0 then begin\n      f.(i) <- n2;\n      space := i;\n    end\n  done;\n  idastar f !space |> String.length |> Printf.printf \"%d\\n\""
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv;\nimport std.algorithm;\nimport std.range;\nimport std.string;\nimport std.typecons;\nimport std.math;\nimport std.random;\nimport std.range;\nimport std.functional;\nimport std.container;\nstruct Puzzle\n{\n    int[9] panel;\n    size_t toHash() const @safe pure nothrow\n    {\n        size_t hash = 0;\n        foreach (i; panel)\n        {\n            hash *= 10;\n            hash += i;\n        }\n        return hash;\n    }\n    bool opEquals(ref const Puzzle s) const @safe pure nothrow\n    {\n        return equal(panel[0..$], s.panel[0..$]);\n    }\n    int c;\n}\nint[] dx = [-1, 0, 1, 0];\nint[] dy = [0, -1, 0, 1];\nvoid main()\n{\n    bool[Puzzle] set;\n    auto queue = DList!Puzzle();\n    Puzzle initial;\n    foreach (i; 0..9)\n    {\n        scanf(\"%d\", &initial.panel[i]);\n    }\n    set[initial] = true;\n    queue.insertBack(initial);\n    while (!queue.empty)\n    {\n        auto u = queue.front;\n        queue.removeFront;\n        if (u.panel[0..$].equal([1, 2, 3, 4, 5, 6, 7, 8, 0]))\n        {\n            writeln(u.c);\n            break;\n        }\n        auto sp = u.panel[0..$].countUntil(0);\n        auto sx = sp % 3;\n        auto sy = sp / 3;\n        foreach (r; 0..4)\n        {\n            auto tx = sx + dx[r];\n            auto ty = sy + dy[r];\n            if (tx < 0 || tx >= 3 || ty < 0 || ty >= 3)\n                continue;\n            auto temp = u;\n            temp.panel[sp].swap(temp.panel[tx + ty * 3]);\n            if (temp !in set)\n            {\n                set[temp] = true;\n                temp.c++;\n                queue.insertBack(temp);\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.algorithm, std.conv, std.range, std.stdio, std.string;\nimport std.container, std.typecons;\n\nconst auto n = 3;\nconst auto bits = 4;\n\nvoid main()\n{\n  auto b = 0UL;\n  foreach (i; 0..n) {\n    auto rd = readln.split.to!(int[]);\n    foreach (j, d; rd)\n      b = b.setDigit(i * n + j, d);\n  }\n\n  auto g = goal;\n\n  auto vi = [b: true];\n  auto qi = new DList!bl(bl(b, 0));\n  while (!qi.empty) {\n    auto q = qi.front; qi.removeFront;\n    if (q.b == g) {\n      writeln(q.l);\n      break;\n    }\n      \n    auto i = q.b.findZero;\n\n    void insertQueue(bl q, size_t j)\n    {\n      auto c = q.b.swapDigit(i, j);\n      if (c !in vi) {\n        qi.insertBack(bl(c, q.l + 1));\n        vi[c] = true;\n      }\n    }\n\n    if (i / n > 0)     insertQueue(q, i - n);\n    if (i / n < n - 1) insertQueue(q, i + n);\n    if (i % n > 0)     insertQueue(q, i - 1);\n    if (i % n < n - 1) insertQueue(q, i + 1);\n  }\n}\n\nalias Tuple!(ulong, \"b\", int, \"l\") bl;\n\nulong goal()\n{\n  auto r = 0UL;\n  foreach (i; 0..n*n-1)\n    r = r.setDigit(i, i + 1);\n  return r;\n}\n\nulong setDigit(ulong b, size_t i, int val)\n{\n  return b & (~(((1UL << bits) - 1) << i * bits)) | (val.to!ulong << i * bits);\n}\n\nint digit(ulong b, size_t i)\n{\n  return (b >> i * bits) & ((1UL << bits) - 1);\n}\n\nulong swapDigit(ulong b, size_t i, size_t j)\n{\n  auto x = b.digit(i), y = b.digit(j);\n  return b.setDigit(i, y).setDigit(j, x);\n}\n\nptrdiff_t findZero(ulong b)\n{\n  foreach (i; 0..n*n)\n    if (b.digit(i) == 0)\n      return i;\n  return -1;\n}"
  },
  {
    "language": "Python",
    "code": "import copy\nimport functools as ft\nN = 3\n\n\ndef solved(game):\n    for i in range(N):\n        for j in range(N):\n            if (game[i][j] - 1) != i * N + j and game[i][j] != 0:\n                return False\n    return True\n\ndef debug_game(game):\n    for i in range(N):\n        print(ft.reduce(lambda x,y: x + str(y) + \" \", game[i], \"\"))\n\ndef convert_code(game):\n    hash_code = \"\"\n    for i in range(N):\n        hash_code = hash_code + ft.reduce(lambda x,y: x + str(y), game[i], \"\")\n    return hash_code\n\ndef calc_cost(game):\n    cost = 0\n    for i in range(N):\n        for j in range(N):\n            if game[i][j] != 0:\n                ideal = (int((game[i][j] - 1) / N), (game[i][j] - 1) % N)\n                cost += abs(i - ideal[0]) + abs(j - ideal[1])\n\n    return cost\n\ngames = []\nclosed = []\ninit = [[] for i in range(N)]\n\nfor i in range(N):\n    init[i] = [int(item) for item in input().split()]\n    for j in range(N):\n        if init[i][j] == 0:\n            #queue.put((i, j))\n            zero = (i, j)\n\ngames = games + [(init, zero, calc_cost(init), 0)]\ndirection = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n\nwhile len(games) > 0:\n    current = games.pop(0)\n    zero = current[1]\n    print(\"Depth: \"+str(current[3]) + \" Cost: \"+str(current[2]))\n    debug_game(current[0])\n    closed = closed + [convert_code(current[0])]\n\n    if solved(current[0]):\n        print(current[3])\n        break\n\n    for d in direction :\n        next_step = (zero[0] + d[0], zero[1] + d[1])\n        if next_step[0] >= 0 and next_step[0] <= 2 and next_step[1] >= 0 and next_step[1] <= 2:\n\n            tmp = copy.deepcopy(current[0])\n            tmp[zero[0]][zero[1]], tmp[next_step[0]][next_step[1]] = tmp[next_step[0]][next_step[1]], tmp[zero[0]][zero[1]]\n            tmp_cost = calc_cost(tmp)\n            hash_code = convert_code(tmp)\n\n            if not hash_code in closed:\n                games = games + [(tmp, next_step, tmp_cost, current[3]+1)]\n\n    games.sort(key=lambda x: x[2]+x[3])\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(simpleHS(puz),0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_dWithH = items[0]\n        c_depth = items[1]\n        _i = items[2]\n        _j = items[3]\n        prev_move = items[4]\n        c_puz = items[5]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+c_dWithH) >= depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i-1,_j,2,swap_puz))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i+1,_j,1,swap_puz))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j-1,4,swap_puz))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j+1,3,swap_puz))\n\ndef checkPuzIsExisted(puz,q):\n    for i in range(len(q)):\n        exist_puz = q[i][4]\n        count = 0\n        for j in range(len(exist_puz)):\n            if(exist_puz[j] != puz[j]):\n                count = 1\n        if(count == 0):\n            return True\n    return False\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nN = 3\nM = []\nfor i in range(N):\n    M.append(list(map(int, input().split())))\n\nA = (1, 2, 3, 4, 5, 6, 7, 8, 0)\ndef h(M):\n    c = 0\n    it = iter(A).__next__\n    for i in range(N):\n        for v in M[i]:\n            if v != it():\n                c += 1\n    return c\ndef f(M):\n    M0 = []\n    for m in M:\n        M0.extend(m)\n    return tuple(M0)\n\n\ndd = ((-1, 0), (0, -1), (1, 0), (0, 1))\nci = cj = -1\nfor i in range(N):\n    for j in range(N):\n        if M[i][j] == 0:\n            ci = i; cj = j\nque = [(h(M), 0, ci, cj, M)]\nU = set(f(M))\nwhile que:\n    hc, c, cr, cc, M = heappop(que)\n    if hc == c:\n        print(c)\n        break\n    for dr, dc in dd:\n        nr = cr+dr; nc = cc+dc\n        if not 0 <= nr < N or not 0 <= nc < N:\n            continue\n        MM = [m[:] for m in M]\n        MM[cr][cc] = MM[nr][nc]\n        MM[nr][nc] = 0\n        s = f(MM)\n        if s in U:\n            continue\n\n        U.add(s)\n        heappush(que, (h(MM)+c+1, c+1, nr, nc, MM))\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python\n#coding:utf-8\n\ndef _downheap(buff, n):\n\tsize = len(buff)\n\twhile True:\n\t\tc = 2 * n + 1\n\t\tif c >= size: break\n\t\tif c + 1 < size:\n\t\t\tif buff[c] > buff[c + 1]: c += 1\n\t\tif buff[n] <= buff[c]: break\n\t\ttemp = buff[n]\n\t\tbuff[n] = buff[c]\n\t\tbuff[c] = temp\n\t\tn = c\n\n# ???????????????\ndef _upheap(buff, n):\n\twhile True:\n\t\tp = (n - 1) / 2\n\t\tif p < 0 or buff[p] <= buff[n]: break\n\t\ttemp = buff[n]\n\t\tbuff[n] = buff[p]\n\t\tbuff[p] = temp\n\t\tn = p\n\nclass PQueue:\n\tdef __init__(self, buff = []):\n\t\tself.buff = buff[:]   # ?????????\n\t\tfor n in xrange(len(self.buff) / 2 - 1, -1, -1):\n\t\t\t_downheap(self.buff, n)\n\n\t# ??????????????????\n\tdef push(self, data):\n\t\tself.buff.append(data)\n\t\t_upheap(self.buff, len(self.buff) - 1)\n\n\t# ????°???????????????????\n\tdef pop(self):\n\t\tif len(self.buff) == 0: raise IndexError\n\t\tvalue = self.buff[0]\n\t\tlast = self.buff.pop()\n\t\tif len(self.buff) > 0:\n\t\t\t# ????????????????§????\n\t\t\tself.buff[0] = last\n\t\t\t_downheap(self.buff, 0)\n\t\treturn value\n\n\t# ????°????????±???????\n\tdef peek(self):\n\t\tif len(self.buff) == 0: raise IndexError\n\t\treturn self.buff[0]\n\n\t# ??????\n\tdef isEmpty(self): return len(self.buff) == 0\n\n\nimport time\n\n# ??£??\\?????????\nadjacent = (\n\t(1, 3),\t   # 0\n\t(0, 2, 4),\t# 1\n\t(1, 5),\t   # 2\n\t(0, 4, 6),\t# 3\n\t(1, 3, 5, 7), # 4\n\t(2, 4, 8),\t# 5\n\t(3, 7),\t   # 6\n\t(4, 6, 8),\t# 7\n\t(5, 7)\t\t# 8\n)\n\n# ?????°\nOPEN = 0\nCLOSE = 1\nFORE = 0\nBACK = 1\n\n# ?????¢??¨?????????\ndef make_distance_table(board, wide):\n\tsize = len(board)\n\ttable = [[0] * size for _ in xrange(size)]\n\tfor i in xrange(size):\n\t\tp = board[i]\n\t\tif p == 0: continue\n\t\tx1 = i / wide\n\t\ty1 = i % wide\n\t\tfor j in xrange(size):\n\t\t\tx2 = j / wide\n\t\t\ty2 = j % wide\n\t\t\ttable[p][j] += max(x1 - x2, x2 - x1)\n\t\t\ttable[p][j] += max(y1 - y2, y2 - y1)\n\treturn table\n\n# ?????¢????±???????\ndef get_distance(board, distance):\n\tv = 0\n\tfor x in xrange(9):\n\t\tp = board[x]\n\t\tif p == 0: continue\n\t\tv += distance[p][x]\n\treturn v\n\n# ?±???¢?????????\nclass State:\n\tdef __init__(self, board, space, prev, move, dir, kind = OPEN):\n\t\tself.board = board\n\t\tself.space = space\n\t\tself.prev = prev\n\t\tself.move = move\n\t\tself.dir = dir\n\t\tself.kind = kind\n\t\tif dir == FORE:\n\t\t\tdt = start_distance\n\t\telse:\n\t\t\tdt = goal_distance\n\t\tif prev is None:\n\t\t\tself.cost = move + get_distance(board, dt)\n\t\telse:\n\t\t\tp = board[prev.space]\n\t\t\tself.cost = prev.cost + 1 - dt[p][space] + dt[p][prev.space]\n\n\tdef __cmp__(x, y):\n\t\treturn x.cost - y.cost\n\n# ???????????? A* ??¢?????´?????????\ndef a_star_search(start, goal):\n\tglobal start_distance, goal_distance\n\tq = PQueue()\n\ttable ={}\n\t# ?????????????????????\n\tstart_distance = make_distance_table(goal, 3)\n\ta = State(start, start.index(0), None, 0, FORE)\n\tq.push(a)\n\ttable[tuple(start)] = a\n\t# ??´???????????????\n\tgoal_distance = make_distance_table(start, 3)\n\ta = State(goal, goal.index(0), None, 0, BACK)\n\tq.push(a)\n\ttable[tuple(goal)] = a\n\twhile not q.isEmpty():\n\t\ta = q.pop()\n\t\tif a.kind == CLOSE: continue   # ????£????????????§??????\n\t\tfor x in adjacent[a.space]:\n\t\t\tb = a.board[:]\n\t\t\tb[a.space] = b[x]\n\t\t\tb[x] = 0\n\t\t\tkey = tuple(b)\n\t\t\tif key in table:\n\t\t\t\t# ???????±???¢?????????\n\t\t\t\tc = table[key]\n\t\t\t\tif a.dir != c.dir:\n\t\t\t\t\t# ??????\n\t\t\t\t\tif a.dir == FORE:\n\t\t\t\t\t\tprint print_answer(a)+print_answer_goal(c)-1\n\t\t\t\t\telse:\n\t\t\t\t\t\tprint print_answer(c)+print_answer_goal(a)-1\n\t\t\t\t\treturn\n\t\t\t\t# ?????¢???????????????????????°?????????????????°??????\n\t\t\t\tif c.move > a.move + 1:\n\t\t\t\t\t# ??´??°??????\n\t\t\t\t\tif c.kind == OPEN:\n\t\t\t\t\t\tc.kind = CLOSE\n\t\t\t\t\t\tc = State(b, x, a, a.move + 1, a.dir)\n\t\t\t\t\t\ttable[key] = c\n\t\t\t\t\telse:\n\t\t\t\t\t\tc.prev = a\n\t\t\t\t\t\tc.cost = c.cost - c.move + a.move + 1\n\t\t\t\t\t\tc.move = a.move + 1\n\t\t\t\t\t\tc.kind = OPEN\n\t\t\t\t\t# ??????????????????\n\t\t\t\t\tq.push(c)\n\t\t\telse:\n\t\t\t\tc = State(b, x, a, a.move + 1, a.dir)\n\t\t\t\tq.push(c)\n\t\t\t\ttable[key] = c\n\t\t# a ???????????????????±??????????\n\t\ta.kind = CLOSE\n\n# ???????????¨???\ndef print_answer(x):\n\tif x is not None:\n\t\treturn 1+print_answer(x.prev)\n\t\t#print x.board\n\treturn 0\n\ndef print_answer_goal(x):\n\tr=0\n\twhile x is not None:\n\t\t#print x.board\n\t\tx = x.prev\n\t\tr+=1\n\treturn r\n\n# ??????\ngoal = [1,2,3,4,5,6,7,8,0]\na = []\ntry:\n\twhile True:\n\t\ta+=[int(e) for e in raw_input().split()]\nexcept EOFError:\n\tpass\n\n#s = time.clock()\na_star_search(a, goal)\n#e = time.clock()\n#print \"%.3f\" % (e - s)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nimport sys\nimport copy\n\n\ndef get_completed_board(height, width):\n    return [[str((y * width + x + 1) % (width * height)) for x in range(width)] for y in range(height)]\n\n\ndef serialize_board(board):\n    return \":\".join(list(map(lambda cell: \",\".join(cell), board)))\n\n\ndef get_empty_pos(board):\n    for y, row in enumerate(board):\n        for x, cell in enumerate(row):\n            if cell == \"0\":\n                return (x, y)\n\n\ndef get_all_possible_next_boards(board, height, width, empty_pos=None):\n    if empty_pos is None:\n        empty_pos = get_empty_pos(board)\n    next_boards = []\n    # 左との入れ替え\n    if empty_pos[0] > 0:\n        next_board = copy.deepcopy(board)\n        next_board[empty_pos[1]][empty_pos[0]], next_board[empty_pos[1]][empty_pos[0] - 1] = \\\n            next_board[empty_pos[1]][empty_pos[0] - 1], next_board[empty_pos[1]][empty_pos[0]]\n        next_boards.append((next_board, (empty_pos[0] - 1, empty_pos[1])))\n    # 右との入れ替え\n    if empty_pos[0] < width - 1:\n        next_board = copy.deepcopy(board)\n        next_board[empty_pos[1]][empty_pos[0]], next_board[empty_pos[1]][empty_pos[0] + 1] = \\\n            next_board[empty_pos[1]][empty_pos[0] + 1], next_board[empty_pos[1]][empty_pos[0]]\n        next_boards.append((next_board, (empty_pos[0] + 1, empty_pos[1])))\n    # 上との入れ替え\n    if empty_pos[1] > 0:\n        next_board = copy.deepcopy(board)\n        next_board[empty_pos[1]][empty_pos[0]], next_board[empty_pos[1] - 1][empty_pos[0]] = \\\n            next_board[empty_pos[1] - 1][empty_pos[0]], next_board[empty_pos[1]][empty_pos[0]]\n        next_boards.append((next_board, (empty_pos[0], empty_pos[1] - 1)))\n    # 下との入れ替え\n    if empty_pos[1] < height - 1:\n        next_board = copy.deepcopy(board)\n        next_board[empty_pos[1]][empty_pos[0]], next_board[empty_pos[1] + 1][empty_pos[0]] = \\\n            next_board[empty_pos[1] + 1][empty_pos[0]], next_board[empty_pos[1]][empty_pos[0]]\n        next_boards.append((next_board, (empty_pos[0], empty_pos[1] + 1)))\n    return next_boards\n\n\ndef resolve(board, height, width):\n    # 既知の盤面を保存\n    known_serialized_boards = set([])\n    # 正解の盤面を保存\n    completed_serialized_board = serialize_board(get_completed_board(width, height))\n    step_count = 0\n    current_boards = [(board, None)]\n    while step_count <= 45:\n        next_boards = []\n        for board, empty_pos in current_boards:\n            serialized_board = serialize_board(board)\n            # 正答があった場合はステップ数を返して終了\n            if serialized_board == completed_serialized_board:\n                return step_count\n            # 既知の盤面は後続の処理対象としない\n            if serialized_board in known_serialized_boards:\n                continue\n            else:\n                known_serialized_boards.add(serialized_board)\n            # 次のステップでの現れ得る局面を全て取得\n            next_boards.extend(get_all_possible_next_boards(board, height, width, empty_pos))\n        current_boards = next_boards\n        step_count = step_count + 1\n        # print((step_count, len(known_serialized_boards), len(current_boards)))\n    return None\n\n\ndef main():\n    inputStr = sys.stdin.read()\n    lines = inputStr.split(\"\\n\")\n    lines = filter(lambda line: line, lines)\n    board = list(map(lambda line: line.split(\" \"), lines))\n    height = len(board)\n    width = len(board[0])\n    step_count = resolve(board, height, width)\n    print(step_count)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": " \ngoal = ((1, 2, 3), (4, 5, 6), (7, 8, 0))\n\nparents = {}\ntotal = {}\nflag = True\n\ninitial = []\nposition = []\nfor i in range(3):\n\ta, b, c = map(int, input().split())\n\tif a == 0:\n\t\tposition.extend([i, 0])\n\telif b == 0:\n\t\tposition.extend([i, 1])\n\telif c == 0:\n \t\tposition.extend([i, 2])\n\tinitial.append( (a, b, c) )\n\nparents[tuple(initial)] = position\ntotal[tuple(initial)] = 1\n\ncount = 0\n\nif tuple(initial) == goal:\n\tflag = False\n\nwhile flag:\n\tcount += 1\n\tchildren = {}\n\tfor par_key in parents.keys():\n\t\tposition = parents[par_key]\n\n\t\tif position[0] < 2:\n\t\t\tchild = [list(par_key[0]), list(par_key[1]), list(par_key[2])]\n\t\t\tchild[position[0]][position[1]] = child[position[0]+1][position[1]]\n\t\t\tchild[position[0]+1][position[1]] = 0\n\t\t\tchild_tuple = (tuple(child[0]), tuple(child[1]), tuple(child[2]))\n\t\t\tif child_tuple == goal:\n\t\t\t\tflag = False\n\t\t\t\tbreak\n\t\t\telif child_tuple not in total:\n\t\t\t\tchildren[child_tuple] = [position[0]+1, position[1]]\n\t\t\t\ttotal[child_tuple] = 1\n\n\t\tif position[0] > 0:\n\t\t\tchild = [list(par_key[0]), list(par_key[1]), list(par_key[2])]\n\t\t\tchild[position[0]][position[1]] = child[position[0]-1][position[1]]\n\t\t\tchild[position[0]-1][position[1]] = 0\n\t\t\tchild_tuple = (tuple(child[0]), tuple(child[1]), tuple(child[2]))\n\t\t\tif child_tuple == goal:\n\t\t\t\tflag = False\n\t\t\t\tbreak\n\t\t\telif child_tuple not in total:\n\t\t\t\tchildren[child_tuple] = [position[0]-1, position[1]]\n\t\t\t\ttotal[child_tuple] = 1\n\n\t\tif position[1] < 2:\n\t\t\tchild = [list(par_key[0]), list(par_key[1]), list(par_key[2])]\n\t\t\tchild[position[0]][position[1]] = child[position[0]][position[1]+1]\n\t\t\tchild[position[0]][position[1]+1] = 0\n\t\t\tchild_tuple = (tuple(child[0]), tuple(child[1]), tuple(child[2]))\n\t\t\tif child_tuple == goal:\n\t\t\t\tflag = False\n\t\t\t\tbreak\n\t\t\telif child_tuple not in total:\n\t\t\t\tchildren[child_tuple] = [position[0], position[1]+1]\n\t\t\t\ttotal[child_tuple] = 1\n\n\t\tif position[1] > 0:\n\t\t\tchild = [list(par_key[0]), list(par_key[1]), list(par_key[2])]\n\t\t\tchild[position[0]][position[1]] = child[position[0]][position[1]-1]\n\t\t\tchild[position[0]][position[1]-1] = 0\n\t\t\tchild_tuple = (tuple(child[0]), tuple(child[1]), tuple(child[2]))\n\t\t\tif child_tuple == goal:\n\t\t\t\tflag = False\n\t\t\t\tbreak\n\t\t\telif child_tuple not in total:\n\t\t\t\tchildren[child_tuple] = [position[0], position[1]-1]\n\t\t\t\ttotal[child_tuple] = 1\n\n\tparents = children\n\nprint(count)\n"
  },
  {
    "language": "Python",
    "code": "#include <stdlib.h>\n#include <string.h>\n\ntypedef char Board[10];\nBoard ini_board, board, *history;\nconst Board target = \"123456780\";\nint nhistories=0;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  char pos;\n  char dir;\n} Motion;\n\nint minstep;\n\nconst Motion motion[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nint search_path(int step, char space)\n{\n  int i, j;\n  if (strcmp(board, \"123456780\")==0) {\n    //    printf(\"STEP=%d\\n\", step);                                                 \n    //printf(\"%d\\n\", step);                                                          \n    if (step<minstep) minstep=step;\n    printf(\"%d\\n\", step);\n    exit(0);\n  } else {\n    if (step>=minstep) return 1;\n    if (step>0 && strcmp(board, ini_board)==0) return 1;\n\n    Board board_bak;\n    strcpy(board_bak, board);\n    int nhistories_bak=nhistories;\n\n   for (i=0; motion[space][i].pos>=0; i++) {\n      Motion m = motion[space][i];\n\n      if (m.pos==0 && board[0]=='1') continue;\n      if ((m.pos==1||m.pos==2) && board[0]=='1'&&board[1]=='2'&&board[2]=='3') conti\\\nnue;\n      if ((m.pos==3||m.pos==6) && board[0]=='1'&&board[3]=='4'&&board[6]=='7')contin\\\nue;\n      switch (m.dir) {\n      case U:\n        if (m.pos<3) continue;\n        board[m.pos-3] = board[m.pos];\n        break;\n      case D:\n        if (m.pos>5) continue;\n        board[m.pos+3] = board[m.pos];\n        break;\n      case L:\n        if (m.pos%3==0) continue;\n        board[m.pos-1] = board[m.pos];\n        break;\n      case R:\n        if (m.pos%3==2) continue;\n        board[m.pos+1] = board[m.pos];\n        break;\n      }\n      board[m.pos] = '0';\n\n      for (j=0; j<nhistories; j++) {\n        if (strcmp(board, history[j])==0)     break;\n      }\n      if (j==nhistories) {\n        strcpy(history[nhistories++], board);\n        search_path(step+1, m.pos);\n      }\n      nhistories = nhistories_bak;\n      strcpy(board, board_bak);\n    }\n  }\n  return 1;\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board[0],&board[1],&board[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[3],&board[4],&board[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[6],&board[7],&board[8]);\n  strcpy(ini_board, board);\n  for (minstep=1; minstep<32; minstep++) {\n    strcpy(board, ini_board);\n    history = (Board*)malloc(sizeof(Board)*100000);\n    search_path(0, strchr(board, '0')-board);\n    free(history);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "Python",
    "code": "import copy\ndef hashnum(state):\n    num = 0\n    for i in range(3):\n        for j in range(3):\n            num *= 10\n            num += state[i][j]\n    return num\n\nanswer = 123456780\nini_state = []\nfor i in range(3):\n    temp = [int(n) for n in input().split(\" \")]\n    if 0 in temp:\n        zero_x, zero_y = temp.index(0), i\n    ini_state.append(temp)\nend_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\nqueue = [[ini_state, zero_x, zero_y, 0], [end_state, 2, 2, 1]]\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\nvisited = {}\nvisited[hashnum(ini_state)] = [0, 0]\nvisited[answer] = [0, 1]\ntrial = 0\nended = 0\nwhile queue:\n    new_queue = []\n    trial += 1\n    for q in queue:\n        if ended:\n            break\n        state, zero_x, zero_y, direction = q\n        for i in range(len(dx)):\n            new_state = copy.deepcopy(state)\n            new_x = zero_x + dx[i]\n            new_y = zero_y + dy[i]\n            if 0 <= new_x < 3 and 0 <= new_y < 3:\n                new_state[new_y][new_x], new_state[zero_y][zero_x] = new_state[zero_y][zero_x], new_state[new_y][new_x]\n                perm = hashnum(new_state)\n                if perm in visited and direction != visited[perm][1]:\n                    print(trial + visited[perm][0])\n                    ended = 1\n                    break\n                elif perm not in visited:\n                    visited[perm] = [trial, direction]\n                    new_queue.append([new_state, new_x, new_y, direction])\n    queue = new_queue"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nfrom collections import deque\nimport copy\n\nclass Puzzle(list):\n    def __init__(self, size):\n        list.__init__(self)\n        self.size = size\n        self.space = None\n        self.path = \"\"\n    \n    def __hash__(self):\n        return hash(str(self))\n\nif __name__ == '__main__':\n    \n    N = 3\n    N2 = 9\n    dx = [-1, 0, 1, 0]\n    dy = [0, -1, 0, 1]\n    d = [\"u\", \"l\", \"d\", \"r\"]\n\n    p = Puzzle(N2)\n    for i in range(N):\n        p += [int(x) for x in input().split()]\n    for i in range(N2):\n        if p[i] == 0:\n            p[i] = N2\n            p.space = i\n    target = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    def isTarget(p):\n        return p[:] == target[:]\n        \n    def bfs(s):\n        cnt = 0\n        Q = deque()\n        V = set()\n        Q.append(s)\n        V.add(s)\n        while Q:\n            cnt += 1\n            u = Q.popleft()\n            if isTarget(u):\n                return u.path\n            sx = u.space // N\n            sy = u.space % N\n            for r in range(4):\n                tx = sx + dx[r]\n                ty = sy + dy[r]\n                if tx < 0 or ty < 0 or tx >= N or ty >= N:\n                    continue\n                v = copy.copy(u)\n                v[u.space], v[tx * N + ty] = v[tx * N + ty], v[u.space]\n                v.space = tx * N + ty\n                if not v in V:\n                    V.add(v)\n                    v.path += d[r]\n                    Q.append(v)\n\n        return \"unsolvable\"\n\n    ans = bfs(p)\n    print(len(ans))\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport copy\nfrom collections import deque\n\ndef main():\n    s = []\n    for _ in range(3):\n        s += list(map(int,input().split()))\n    goal = [1,2,3,4,5,6,7,8,0]\n    st = set()\n    inf = 1000000007\n    move = [[1,3], #0がi番目にいる時に交換できる位置\n            [0,2,4],\n            [1,5],\n            [0,4,6],\n            [1,3,5,7],\n            [2,4,8],\n            [3,7],\n            [4,6,8],\n            [5,7]]\n\n    def bfs():\n        k = 0\n        for i in range(9):\n            if s[i] == 0: k = i #空の位置\n        dq = deque()\n        dq.append([s, k, 0]) #局面、0の位置、ステップ数\n        st.add(''.join(map(str, s)))\n        while dq:\n            state = dq.popleft()\n            t, i, steps = state[0], state[1], state[2]\n            if t == goal: return steps\n            for j in move[i]:\n                u = copy.copy(t)\n                u[i], u[j] = u[j], u[i] #0を移動\n                if ''.join(map(str, u)) in st:continue #同一局面があったのでスキップ\n                dq.append([u, j, steps+1])\n                st.add( ''.join(map(str, u)))\n\n    print (bfs())\n\nif __name__ == '__main__':\n    main()\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom copy import deepcopy, copy\ndy = [-1, 0, 0, 1]\ndx = [0, -1, 1, 0]\nN = 3\ndef MAIN():\n    MAP = tuple(sum([input().split() for _ in range(N)], []))\n    y0, x0 = divmod(MAP.index(\"0\"), N)\n    goal = ('1', '2', '3', '4', '5', '6', '7', '8', '0')\n    ans = 0\n    dp = deque([[y0, x0, 0, MAP]])\n    LOG = {MAP}\n    while dp:\n        y, x, cnt, M = dp.popleft()\n        if M == goal:\n            print(cnt)\n            break\n        cnt += 1\n        yx = y * N + x\n        for ny, nx in ((y - 1, x), (y, x - 1), (y, x + 1), (y + 1, x)):\n            if 0 <= ny < N and 0 <= nx < N:\n                CM = list(deepcopy(M))\n                nyx = ny * N + nx\n                CM[yx], CM[nyx] = CM[nyx], CM[yx]\n                CM = tuple(CM)\n                if not CM in LOG:\n                    dp.append([ny, nx, cnt, CM])\n                    LOG.add(CM)\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or (c_depth+simpleHS(c_puz)) > depth):\n        return\n\n    if(i != 0):\n        iterative(i-1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i-1,j))\n    if(i != 2):\n        iterative(i+1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i+1,j))\n    if(j != 0):\n        iterative(i,j-1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j-1))\n    if(j != 2):\n        iterative(i,j+1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j+1))\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    if(c_puz[8] == 0):\n        count+=1\n    return count\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(8)]\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque, OrderedDict\nimport copy\n\nclass Puzzle:\n    def __init__(self, field=None, path=''):\n        self.f = field\n        self.space = None\n        for i in range(9):\n            if self.f[i] == 9: self.space = i\n        self.path = path\n\n    def __lt__(self, pzl): # <\n        for i in range(9):\n            if self.f[i] == pzl.f[i]: continue\n            return self.f[i] > pzl.f[i]\n        return False\n\n    def __gt__(self, pzl): # >\n        for i in range(9):\n            if self.f[i] == pzl.f[i]: continue\n            return self.f[i] < pzl.f[i]\n        return False\n\ndx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\ndir = ['u', 'l', 'd', 'r']\n\ndef is_target(pzl):\n    for i in range(9):\n        if pzl.f[i] != i+1:\n            return False\n    return True\n\ndef print_puzzle(pzl):\n    for i, p in enumerate(pzl.f):\n        print(p, '', end='')\n        if i%3 == 2:\n            print('')\n\ndef bfs(pzl):\n    queue = deque([])\n    V = OrderedDict()\n    pzl.path = ''\n    queue.append(pzl)\n    V[pzl] = True\n\n    while len(queue) != 0:\n        u = queue.popleft()\n        if is_target(u): return u.path\n        sx, sy = u.space//3, u.space%3\n        for r in range(4):\n            tx, ty = sx + dx[r], sy + dy[r]\n            if tx < 0 or ty < 0 or tx >= 3 or ty >= 3: continue\n            v = copy.deepcopy(u)\n            v.f[u.space], v.f[tx*3+ty] = v.f[tx*3+ty], v.f[u.space]\n            v.space = tx*3 + ty\n            if not V.get(v, None):\n                V[v] = True\n                v.path += dir[r]\n                queue.append(v)\n    return 'unsolvable'\n\nfield = []\nfor i in range(3):\n    field.extend(list(map(int, input().split(' '))))\n\nfor i in range(9):\n    if field[i] == 0: field[i] = 9\n\npzl = Puzzle(field=field)\nans = bfs(pzl)\nprint(len(ans))\n\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nreadline = stdin.readline\n\n\nadjacent = (\n    (1, 3),        # 0\n    (0, 2, 4),     # 1\n    (1, 5),        # 2\n    (0, 4, 6),     # 3\n    (1, 3, 5, 7),  # 4\n    (2, 4, 8),     # 5\n    (3, 7),        # 6\n    (4, 6, 8),     # 7\n    (5, 7)         # 8\n)\n\n\ndef next_board(board, space, prev):\n    for nxt in adjacent[space]:\n        if nxt == prev:\n            continue\n        b = board[:]\n        b[space], b[nxt] = b[nxt], 0\n        yield b, nxt\nfrom heapq import heappop, heappush\n\nend = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\n# ???????????¨????????°\nFORE = 1\nBACK = 0\n\n\ndef search(start):\n    table = {}\n\n    table[tuple(start)] = (FORE, 0)\n    table[tuple(end)] = (BACK, 0)\n\n    heap = [(0, start, start.index(0), None, FORE), (0, end, end.index(0), None, BACK)]\n    while heap:\n        i, board, space, prev, direction = heappop(heap)\n        i += 1\n        for b, nxt in next_board(board, space, prev):\n            key = tuple(b)\n            if key in table:\n                if table[key][0] != direction:\n                    print(table[key][1] + i)\n                    return\n                continue\n            table[key] = (direction, i)\n            if b == end:\n                print(i)\n                return\n            heappush(heap, (i, b, nxt, space, direction))\n\n\ndef main():\n    start = (map(int, readline().split()) for _ in range(3))\n    start = [y for x in start for y in x]\n    search(start)\nmain()"
  },
  {
    "language": "Python",
    "code": "N = 3\n#f = [input().split() for _ in range(3)]\nf = input().split()\nf += input().split()\nf += input().split()\ndd = [[-1, 0], [0, -1], [1, 0], [0, 1]]\n\nQ = [[f, f.index(\"0\"), 0]]\n#T = {f: True}\nT = set(f)\n\nwhile len(Q) > 0:\n    board = Q.pop(0)\n    if board[0] == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"0\"]:\n        break\n    # int//int = int\n    # location of zero\n    x, y = board[1]//N, board[1]%N\n    for dx, dy in dd:\n        tx, ty = x+dx, y+dy\n        # 0とswap後boardの範囲外に出たら除外\n        if tx<0 or ty<0 or tx>=N or ty>=N:\n            continue\n        new = board[:]\n        # n1 is location of zero on string\n        # n2 is location of zero after moving on string\n        n1, n2 = board[1], tx*N+ty\n        new[1] = n2\n        # swap\n        if n1 > n2:\n            n1, n2 = n2, n1\n        # swaped string\n        new[0] = new[0][0:n1] + list(new[0][n2]) + new[0][n1+1:n2] + list(new[0][n1]) + new[0][n2+1:]\n        hashstr = \"\".join(new[0])\n        if hashstr not in T:\n        #if new[0] not in T.keys():\n        #if not T.get(new[0], False):\n            #T[new[0]] = True\n            T.add(hashstr)\n            new[2] += 1\n            Q.append(new)\n\nprint(board[2])\n\n"
  },
  {
    "language": "Python",
    "code": "# 幅優先探索 #双方向探索\nimport sys\nimport queue\n\nSPACE = 0\n\nadjacents_list = (\n    (1, 3),       # 0\n    (0, 2, 4),    # 1\n    (1, 5),       # 2\n    (0, 4, 6),    # 3\n    (1, 3, 5, 7), # 4\n    (2, 4, 8),    # 5\n    (3, 7),       # 6\n    (4, 6, 8),    # 7\n    (5, 7)        # 8\n)\n\nclass State:\n    def __init__(self, board, space, prev):\n        self.board = board\n        self.space = space\n        self.prev = prev\n\ndef mininum_steps(start, goal):\n    if start == goal:\n        return 0\n    q = queue.Queue()\n    q.put(State(start, start.index(0), None))\n    history = [tuple(start)]\n    while not q.empty():\n        state = q.get()\n        for adjacent in adjacents_list[state.space]:\n            board = state.board[:]\n            board[state.space] = board[adjacent]\n            board[adjacent] = SPACE\n            if tuple(board) in history:\n                 continue\n            if board == goal:\n                return go_back(state)\n            history.append(tuple(board))\n            next_state = State(board, adjacent, state)\n            q.put(next_state)\n\nstep = 0\ndef go_back(state):\n    global step\n    if state is not None:\n        step += 1\n        go_back(state.prev)\n    return step\n\n\ninitial_board = list(map(int, sys.stdin.read().split()))\ngoal = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\nprint(mininum_steps(initial_board, goal))\n\n"
  },
  {
    "language": "Python",
    "code": "import heapq\nfrom itertools import chain\nfrom operator import mul\n\nexp10 = [10 ** a for a in range(8, -1, -1)]\nmovables = [{1, 3}, {0, 2, 4}, {1, 5}, {0, 4, 6}, {1, 3, 5, 7}, {2, 4, 8}, {3, 7}, {4, 6, 8}, {5, 7}]\n\ndestination = 123456780\n\n\ndef swap(board, move_from, move_to):\n    return board + (exp10[move_to] - exp10[move_from]) * (board // exp10[move_from] % 10)\n\n\nboard0 = sum(map(mul, exp10, chain.from_iterable(map(int, input().split()) for _ in range(3))))\np0 = ('0' + str(board0))[-9:].index('0')\n\nappeared = ({board0: 0}, {destination: 0})\nqueue = []\nqueue.extend((0, 0, move_from, p0, board0) for move_from in movables[p0])\nqueue.extend((0, 1, move_from, 8, destination) for move_from in movables[8])\nheapq.heapify(queue)\n\nwhile True:\n    total_cost, direction, move_from, move_to, board = heapq.heappop(queue)\n    if board in appeared[not direction]:\n        print(total_cost + appeared[not direction][board])\n        break\n    new_board = swap(board, move_from, move_to)\n    if new_board in appeared[direction]:\n        continue\n    appeared[direction][new_board] = total_cost + 1\n    for move_from2 in movables[move_from]:\n        if move_from2 != move_to:\n            heapq.heappush(queue, (total_cost + 1, direction, move_from2, move_from, new_board))"
  },
  {
    "language": "Python",
    "code": "import copy\nimport functools as ft\nN = 3\n\n\ndef solved(game):\n    for i in range(N):\n        for j in range(N):\n            if (game[i][j] - 1) != i * N + j and game[i][j] != 0:\n                return False\n    return True\n\ndef debug_game(game):\n    for i in range(N):\n        print(ft.reduce(lambda x,y: x + str(y) + \" \", game[i], \"\"))\n\ndef convert_code(game):\n    hash_code = \"\"\n    for i in range(N):\n        hash_code = hash_code + ft.reduce(lambda x,y: x + str(y), game[i], \"\")\n    return hash_code\n\ndef calc_cost(game):\n    cost = 0\n    for i in range(N):\n        for j in range(N):\n            if game[i][j] != 0:\n                ideal = (int((game[i][j] - 1) / N), (game[i][j] - 1) % N)\n                cost += abs(i - ideal[0]) + abs(j - ideal[1])\n\n    return cost\n\ngames = []\nclosed = []\ninit = [[] for i in range(N)]\n\nfor i in range(N):\n    init[i] = [int(item) for item in input().split()]\n    for j in range(N):\n        if init[i][j] == 0:\n            #queue.put((i, j))\n            zero = (i, j)\n\ngames = games + [(init, zero, calc_cost(init), 0)]\ndirection = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n\nwhile len(games) > 0:\n    current = games.pop(0)\n    zero = current[1]\n    print(\"Depth: \"+str(current[3]) + \" Cost: \"+str(current[2]))\n    debug_game(current[0])\n    closed = closed + [convert_code(current[0])]\n\n    if solved(current[0]):\n        print(current[3])\n        break\n\n    for d in direction :\n        next_step = (zero[0] + d[0], zero[1] + d[1])\n        if next_step[0] >= 0 and next_step[0] <= 2 and next_step[1] >= 0 and next_step[1] <= 2:\n\n            tmp = copy.deepcopy(current[0])\n            tmp[zero[0]][zero[1]], tmp[next_step[0]][next_step[1]] = tmp[next_step[0]][next_step[1]], tmp[zero[0]][zero[1]]\n            tmp_cost = calc_cost(tmp)\n            hash_code = convert_code(tmp)\n\n            if not hash_code in closed:\n                games = games + [(tmp, next_step, tmp_cost, current[3]+1)]\n\n    games.sort(key=lambda x: x[2]+x[3])\n\n"
  },
  {
    "language": "Python",
    "code": "import queue\nadjacent=((1,3), (0,2,4), (1,5), (0,4,6), (1,3,5,7), (2,4,8), (3,7), (4,6,8), (5,7))\n\nclass State:\n    def __init__(self, board, space, prev):\n        self.board = board\n        self.space = space\n        self.prev = prev\n\ndef bf_search(start, GOAL):\n    q = queue.Queue()\n    q.put(State(start, start.index(0), None))\n    table = {}\n    table[tuple(start)] = True\n    while not q.empty():\n        a = q.get()\n        for x in adjacent[a.space]:\n            b = a.board[:]\n            b[a.space] = b[x]\n            b[x] = 0\n            key = tuple(b)\n            if key in table: continue\n            c = State(b,x,a)\n            if b == GOAL:\n                return print_answer(c)\n            q.put(c)\n            table[key] = True\n\ncnt = -1\ndef print_answer(x):\n    global cnt\n    if x is not None:\n        cnt += 1\n        print_answer(x.prev)\n    return str(cnt)\n\nGOAL = [1,2,3,4,5,6,7,8,0]\nstart = []\nfor i in range(3):\n x,y,z = map(int, input().split())\n start += [x,y,z]\n\nprint(bf_search(start, GOAL))"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nfrom collections import deque\nimport copy\n\nclass Puzzle(list):\n    def __init__(self, size):\n        list.__init__(self)\n        self.size = size\n        self.space = None\n        self.path = \"\"\n    \n    def __hash__(self):\n        return hash(str(self[:]))\n\nif __name__ == '__main__':\n    \n    N = 3\n    N2 = 9\n    dx = [-1, 0, 1, 0]\n    dy = [0, -1, 0, 1]\n    d = [\"u\", \"l\", \"d\", \"r\"]\n\n    p = Puzzle(N2)\n    for i in range(N):\n        p += [int(x) for x in input().split()]\n    for i in range(N2):\n        if p[i] == 0:\n            p[i] = N2\n            p.space = i\n    target = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    def isTarget(p):\n        return p[:] == target[:]\n\n    def bfs(s):\n        cnt = 0\n        Q = deque()\n        V = set()\n        Q.append(s)\n        V.add(s)\n        while Q:\n            cnt += 1\n            u = Q.popleft()\n            if isTarget(u):\n                return u.path\n            sx = u.space // N\n            sy = u.space % N\n            for r in range(4):\n                tx = sx + dx[r]\n                ty = sy + dy[r]\n                if tx < 0 or ty < 0 or tx >= N or ty >= N:\n                    continue\n                v = copy.copy(u)\n                v[u.space], v[tx * N + ty] = v[tx * N + ty], v[u.space]\n                v.space = tx * N + ty\n                if not v in V:\n                    V.add(v)\n                    v.path += d[r]\n                    Q.append(v)\n\n        return \"unsolvable\"\n\n    ans = bfs(p)\n    print(len(ans))\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ninit = ''.join(sys.stdin.read().split())\n\ngenerated_state = {init: 0}\n\ndef bfs(root):\n    s = 0\n    configure = [root]\n    while '123456780' not in configure:\n        q = iter(configure)\n        configure = []\n        s += 1\n        for c in q:\n            i = c.find('0')\n            if 0 <= i <= 5:\n                t = str.maketrans('0' + c[i+3], c[i+3] + '0')\n                t_c = c.translate(t)\n                if t_c not in generated_state:\n                    generated_state[t_c] = s\n                    configure.append(t_c)\n            if i >= 3:\n                t = str.maketrans('0' + c[i-3], c[i-3] + '0')\n                t_c = c.translate(t)\n                if t_c not in generated_state:\n                    generated_state[t_c] = s\n                    configure.append(t_c)\n            if i == 0 or i == 1 or i == 3 or i == 4 or i == 6 or i == 7:\n                t = str.maketrans('0' + c[i+1], c[i+1] + '0')\n                t_c = c.translate(t)\n                if t_c not in generated_state:\n                    generated_state[t_c] = s\n                    configure.append(t_c)\n            if i == 1 or i == 2 or i == 4 or i == 5 or i == 7 or i == 8:\n                t = str.maketrans('0' + c[i-1], c[i-1] + '0')\n                t_c = c.translate(t)\n                if t_c not in generated_state:\n                    generated_state[t_c] = s\n                    configure.append(t_c)\n            if '123456780' in generated_state:\n                break\n    print(s)\n\nbfs(init)"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz,costs):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or (c_depth+checkSumCost(costs)) > depth):\n        return\n\n    if(i != 0 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i-1,j)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[(i-1)*3+j] = HS(i,j,_c_puz[(i-1)*3+j])\n        iterative(i-1,j,c_depth+1,_c_puz[0:],_costs[0:])\n    if(i != 2 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i+1,j)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[(i+1)*3+j] = HS(i,j,_c_puz[(i+1)*3+j])\n        iterative(i+1,j,c_depth+1,_c_puz[0:],_costs[0:])\n    if(j != 0 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i,j-1)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[i*3+j-1] = HS(i,j,_c_puz[i*3+j]-1)\n        iterative(i,j-1,c_depth+1,_c_puz[0:],_costs[0:])\n    if(j != 2 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i,j+1)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[i*3+j+1] = HS(i,j,_c_puz[i*3+j+1])\n        iterative(i,j+1,c_depth+1,_c_puz[0:],_costs[0:])\n\ndef checkSumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value+=costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki\n    value = abs(i-ki)+abs(j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz[0:]\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:],costs[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(0,i,j,puz))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        c_puz = items[3]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+simpleHS(c_puz)) > depth):\n            continue\n\n        if(_i != 0):\n            heapq.heappush(q,(c_depth+1,_i-1,_j,swapPuz(c_puz[0:],_i,_j,_i-1,_j)))\n        if(_i != 2):\n            heapq.heappush(q,(c_depth+1,_i+1,_j,swapPuz(c_puz[0:],_i,_j,_i+1,_j)))\n        if(_j != 0):\n            heapq.heappush(q,(c_depth+1,_i,_j-1,swapPuz(c_puz[0:],_i,_j,_i,_j-1)))\n        if(_j != 2):\n            heapq.heappush(q,(c_depth+1,_i,_j+1,swapPuz(c_puz[0:],_i,_j,_i,_j+1)))\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(c_puz):\n    value = 0\n    for i in range(len(c_puz)):\n        k = correctPuz.index(c_puz[i])\n        _i = (int)(i/3)\n        _j = i - _i\n        ki = (int)(k/3)\n        kj = k - ki\n        value = abs(_i-ki)+abs(_j-kj) \n\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom heapq import heappop, heappush\n\n\nadjacent = (\n    (1, 3),        # 位置 0 に 0が存在したときに入れ替え可能な位置\n    (0, 2, 4),     # 位置 1 に 0が存在したときに入れ替え可能な位置\n    (1, 5),        # 位置 2 に 0が存在したときに入れ替え可能な位置\n    (0, 4, 6),     # 位置 3 に 0が存在したときに入れ替え可能な位置\n    (1, 3, 5, 7),  # 位置 4 に 0が存在したときに入れ替え可能な位置\n    (2, 4, 8),     # 位置 5 に 0が存在したときに入れ替え可能な位置\n    (3, 7),        # 位置 6 に 0が存在したときに入れ替え可能な位置\n    (4, 6, 8),     # 位置 7 に 0が存在したときに入れ替え可能な位置\n    (5, 7)         # 位置 8 に 0が存在したときに入れ替え可能な位置\n)\n\n\ndef move(board, space, prev_space):\n    for next_space in adjacent[space]:\n        if next_space == prev_space:\n            continue\n        next_board = board[:]\n        next_board[space], next_board[next_space] = next_board[next_space], 0\n        yield next_board, next_space\n\n\nend = [1, 2, 3, 4, 5, 6, 7, 8, 0]\ndiscovered_state = set()  # すでに知っている状態を記録する\n\n\ndef search(start):\n    discovered_state.add(tuple(start))\n    heap = [(0, start, start.index(0), None)]  # 今の状態へ到達する手順回数\n\n    while heap:\n        i, board, space, prev = heappop(heap)\n\n        if board == end:\n            return i\n\n        i += 1\n        for next_board, next_space in move(board, space, prev):\n            if tuple(next_board) in discovered_state:\n                continue\n            discovered_state.add(tuple(next_board))\n            heappush(heap, (i, next_board, next_space, space))\n\n\ndef main():\n    start = []\n    for _ in range(3):\n        start.extend(list(map(int, sys.stdin.readline().strip().split())))\n    ans = search(start)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nCORRECT_STATE = \"123456780\"\n\n\nclass PuzzleState:\n    __slots__ = ['state', 'spc_x', 'spc_y', 'depth']\n\n    def __init__(self, state: str, depth=0):\n        self.state = state\n        index = state.find('0')\n        self.spc_x = index % 3\n        self.spc_y = index // 3\n        self.depth = depth\n\n    def swap_state(self, ch_x, ch_y):\n        conv_char = self.state[ch_y * 3 + ch_x]\n        self.state = self.state.replace('0', 'X')\n        self.state = self.state.replace(conv_char, '0')\n        self.state = self.state.replace('X', conv_char)\n        self.spc_x, self.spc_y = ch_x, ch_y\n\n    def is_correct(self):\n        return self.state == CORRECT_STATE\n\n    def __repr__(self):\n        return f'{self.state}'\n\n\nmove = [(0, -1), (0, 1), (-1, 0), (1, 0)]\ndef puzzle8_breadth_first_search(puzzle: PuzzleState):\n    mem_state = {puzzle.state: ''}\n    p_queue = deque()\n    p_queue.append(puzzle)\n\n    while len(p_queue) != 0:\n        u = p_queue.popleft()\n        if u.is_correct():\n            #print(\"CORRECT\")\n            return u.depth\n        for mx, my in move:\n            sp_new_x = u.spc_x + mx\n            sp_new_y = u.spc_y + my\n            if not(0 <= sp_new_x <= 2 and 0 <= sp_new_y <= 2):\n                continue\n            new_puzzle = PuzzleState(u.state, depth=u.depth+1)\n            new_puzzle.swap_state(sp_new_x, sp_new_y)\n\n            if new_puzzle.state not in mem_state:\n                mem_state[new_puzzle.state] = ''\n                p_queue.append(new_puzzle)\n    return False\n\n\ndef main():\n    input_text = \"\"\n    for i in range(3):\n        input_text += \"\".join(input().split())\n\n    # 8 puzzle main\n    ans_puzzle = puzzle8_breadth_first_search(PuzzleState(input_text))\n    print(ans_puzzle)\n    return\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    q.append((sumCost(costs),0,i,j,0,puz,costs))\n    global finding\n\n    while len(q):\n        items = q.pop(0)\n        cost = items[0]\n        c_depth = items[1]\n        _i = items[2]\n        _j = items[3]\n        prev_move = items[4]\n        c_puz = items[5]\n        _costs = items[6]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+cost) >= depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[(_i-1)*3+_j] = HS(_i-1,_j,swap_puz[(_i-1)*3+_j])\n            q.append((c_depth+1+sumCost(swap_cost),c_depth+1,_i-1,_j,2,swap_puz,swap_cost))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[(_i+1)*3+_j] = HS(_i+1,_j,swap_puz[(_i+1)*3+_j])\n            q.append((c_depth+1+sumCost(swap_cost),c_depth+1,_i+1,_j,1,swap_puz,swap_cost))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[_i*3+_j-1] = HS(_i,_j-1,swap_puz[_i*3+_j-1])\n            q.append((c_depth+1+sumCost(swap_cost),c_depth+1,_i,_j-1,4,swap_puz,swap_cost))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[_i*3+_j+1] = HS(_i,_j+1,swap_puz[_i*3+_j+1])\n            q.append((c_depth+1+sumCost(swap_cost),c_depth+1,_i,_j+1,3,swap_puz,swap_cost))\n\ndef checkPuzIsExisted(puz,q):\n    for i in range(len(q)):\n        exist_puz = q[i][4]\n        count = 0\n        for j in range(len(exist_puz)):\n            if(exist_puz[j] != puz[j]):\n                count = 1\n        if(count == 0):\n            return True\n    return False\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i*3\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nfrom collections import deque\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\nN = 3\n# グリッドを最初から文字列として1次元で保持する\ngrid = '*' * (N+2)\nfor i in range(N):\n    grid += '*' + input().replace(' ', '') + '*'\ngrid += '*' * (N+2)\nstart = grid.find('0')\n\n# 完成形の盤面\ngoal = '******123**456**780******'\nque = deque()\nque.append((grid, 0, start))\n# その盤面に至る移動コスト\nmemo = {}\nwhile len(que):\n    grid, cost, cur = que.popleft()\n    if grid in memo:\n        continue\n    memo[grid] = cost\n    grid = list(grid)\n    # 4方向見る\n    for direction in (-1, 1, -(N+2), N+2):\n        nxt = cur + direction\n        if grid[nxt] != '*':\n            grid[cur], grid[nxt] = grid[nxt], grid[cur]\n            que.append((''.join(grid), cost+1, nxt))\n            grid[cur], grid[nxt] = grid[nxt], grid[cur]\n\nprint(memo[goal])\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or c_depth > depth):\n        return\n\n    if(i != 0):\n        iterative(i-1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i-1,j))\n    if(i != 2):\n        iterative(i+1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i+1,j))\n    if(j != 0):\n        iterative(i,j-1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j-1))\n    if(j != 2):\n        iterative(i,j+1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j+1))\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(8)]\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(simpleHS(swap_puz),0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_dWithH = items[0]\n        c_depth = items[1]\n        _i = items[2]\n        _j = items[3]\n        prev_move = items[4]\n        c_puz = items[5]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+c_dWithH) >= depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i-1,_j,2,swap_puz))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i+1,_j,1,swap_puz))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j-1,4,swap_puz))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j+1,3,swap_puz))\n\ndef checkPuzIsExisted(puz,q):\n    for i in range(len(q)):\n        exist_puz = q[i][4]\n        count = 0\n        for j in range(len(exist_puz)):\n            if(exist_puz[j] != puz[j]):\n                count = 1\n        if(count == 0):\n            return True\n    return False\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom copy import deepcopy, copy\ndy = [-1, 0, 0, 1]\ndx = [0, -1, 1, 0]\nN = 3\nf = lambda x: \"\\n\".join(\" \".join(map(str, x[i])) for i in range(3))\ndef MAIN():\n    MAP = [list(map(int, input().split())) for _ in range(N)]\n    goal = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n    ans = 0\n    dp = deque([[0, MAP]])\n    LOG = [MAP]\n    while dp:\n        cnt, M = dp.popleft()\n        if M == goal:\n            print(cnt)\n            break\n        y, x = divmod(sum(M, []).index(0), N)\n        cnt += 1\n        for i in range(4):\n            ny = y + dy[i]\n            nx = x + dx[i]\n            if 0 <= ny < N and 0 <= nx < N:\n                CM = deepcopy(M)\n                CM[y][x], CM[ny][nx] = CM[ny][nx], CM[y][x]\n                if not CM in LOG:\n                    dp.append([cnt, CM])\n                    LOG.append(CM)\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "import copy\ndef hashnum(state):\n    num = 0\n    for i in range(3):\n        for j in range(3):\n            num *= 10\n            num += state[i][j]\n    return num\n\nanswer = 123456780\nini_state = []\nfor i in range(3):\n    temp = [int(n) for n in input().split(\" \")]\n    if 0 in temp:\n        zero_x, zero_y = temp.index(0), i\n    ini_state.append(temp)\nqueue = [[ini_state, zero_x, zero_y]]\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\nvisited = set()\nvisited |= {hashnum(ini_state)}\ntrial = 0\nwhile answer not in visited:\n    new_queue = []\n    trial += 1\n    for q in queue:\n        state, zero_x, zero_y = q\n        for i in range(len(dx)):\n            new_state = copy.deepcopy(state)\n            new_x = zero_x + dx[i]\n            new_y = zero_y + dy[i]\n            if 0 <= new_x < 3 and 0 <= new_y < 3:\n                new_state[new_y][new_x], new_state[zero_y][zero_x] = new_state[zero_y][zero_x], new_state[new_y][new_x]\n                perm = hashnum(new_state)\n                if perm == answer:\n                    print(trial)\n                    exit()\n                if perm not in visited:\n                    visited |= {perm}\n                    new_queue.append([new_state, new_x, new_y])\n    queue = new_queue\n    \n# print(trial)"
  },
  {
    "language": "Python",
    "code": "\nfrom heapq import heappop, heappush\nfrom copy import deepcopy\n\n\nclass Board:\n    def __init__(self, size, nums):\n        self.size = size\n        self.nums = nums\n        self.code = self._code()\n\n    def __eq__(self, other):\n        return self.code == other.code\n\n    def __lt__(self, other):\n        return self.code < other.code\n\n    def __gt__(self, other):\n        return self.code > other.code\n\n    def __hash__(self):\n        nums = tuple(self.nums[i][j]\n                     for i in range(self.size)\n                     for j in range(self.size))\n        hash(nums)\n\n    def same(self, other):\n        if other is None:\n            return False\n        if self.__class__ != other.__class__:\n            return False\n\n        for i in range(self.size):\n            for j in range(self.size):\n                if self.nums[i][j] != other.nums[i][j]:\n                    return False\n        return True\n\n    def solved(self):\n        for i in range(self.size):\n            for j in range(self.size):\n                if (i, j) != self._validpos(self.nums[i][j]):\n                    return False\n        return True\n\n    def _validpos(self, num):\n        if num > 0:\n            return ((num-1) // self.size, (num-1) % self.size)\n        else:\n            return (self.size-1, self.size-1)\n\n    def _code(self):\n        code = 0\n        for i in range(self.size):\n            for j in range(self.size):\n                if self.nums[i][j] != 0:\n                    vi, vj = self._validpos(self.nums[i][j])\n                    code += abs(vi - i) + abs(vj - j)\n        return code\n\n    def find(self, num):\n        for i in range(self.size):\n            for j in range(self.size):\n                if self.nums[i][j] == num:\n                    return (i, j)\n        raise IndexError()\n\n    def move(self, p1, p2):\n        i1, j1 = p1\n        i2, j2 = p2\n        nums = deepcopy(self.nums)\n        nums[i1][j1], nums[i2][j2] = nums[i2][j2], nums[i1][j1]\n        return self.__class__(self.size, nums)\n\n    def moves(self):\n        i, j = self.find(0)\n        if i > 0:\n            yield self.move((i, j), (i-1, j))\n        if j > 0:\n            yield self.move((i, j), (i, j-1))\n        if i < self.size-1:\n            yield self.move((i, j), (i+1, j))\n        if j < self.size-1:\n            yield self.move((i, j), (i, j+1))\n\n    def __str__(self):\n        s = ''\n        for i in range(self.size):\n            for j in range(self.size):\n                s += ' {}'.format(self.nums[i][j])\n            s += '\\n'\n        return s\n\n\nclass EightPuzzle:\n    def __init__(self, board):\n        self.board = Board(3, board)\n        self.steps = 0\n\n        if not self.board.solved():\n            self._solve()\n\n    def _solve(self):\n        bs = []\n        heappush(bs, (self.board, 0, None))\n\n        while len(bs) > 0:\n            b, step, pb = heappop(bs)\n            for nb in b.moves():\n                if nb.solved():\n                    self.steps = step+1\n                    return\n                elif nb.same(pb):\n                    continue\n                else:\n                    heappush(bs, (nb, step+1, b))\n\n\ndef run():\n    board = []\n    for i in range(3):\n        board.append([int(i) for i in input().split()])\n\n    eight_puzzle = EightPuzzle(board)\n    print(eight_puzzle.steps)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or (c_depth+HS(c_puz)) > depth):\n        return\n\n    if(i != 0):\n        iterative(i-1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i-1,j))\n    if(i != 2):\n        iterative(i+1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i+1,j))\n    if(j != 0):\n        iterative(i,j-1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j-1))\n    if(j != 2):\n        iterative(i,j+1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j+1))\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(c_puz):\n    value = 0\n    for i in range(len(c_puz)):\n        k = correctPuz.index(c_puz[i])\n        _i = (int)(i/3)\n        _j = i - _i\n        ki = (int)(k/3)\n        kj = k - ki\n        value = abs(_i-ki)+abs(_j-kj)\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz,costs):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or (c_depth+checkSumCost(costs)) > depth):\n        return\n\n    if(i != 0 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i-1,j)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[(i-1)*3+j] = HS(i,j,_c_puz[(i-1)*3+j])\n        iterative(i-1,j,c_depth+1,_c_puz[0:],_costs[0:])\n    if(i != 2 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i+1,j)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[(i+1)*3+j] = HS(i,j,_c_puz[(i+1)*3+j])\n        iterative(i+1,j,c_depth+1,_c_puz[0:],_costs[0:])\n    if(j != 0 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i,j-1)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[i*3+j-1] = HS(i,j,_c_puz[i*3+j]-1)\n        iterative(i,j-1,c_depth+1,_c_puz[0:],_costs[0:])\n    if(j != 2 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i,j+1)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[i*3+j+1] = HS(i,j,_c_puz[i*3+j+1])\n        iterative(i,j+1,c_depth+1,_c_puz[0:],_costs[0:])\n\ndef checkSumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value+=costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki\n    value = abs(i-ki)+abs(j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:],costs[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom copy import deepcopy, copy\ndy = [-1, 0, 0, 1]\ndx = [0, -1, 1, 0]\nN = 3\ndef MAIN():\n    MAP = tuple(sum([input().split() for _ in range(N)], []))\n    y0, x0 = divmod(MAP.index(\"0\"), N)\n    goal = ('1', '2', '3', '4', '5', '6', '7', '8', '0')\n    ans = 0\n    dp = deque([[y0, x0, 0, MAP]])\n    LOG = {MAP}\n    while dp:\n        y, x, cnt, M = dp.popleft()\n        cnt += 1\n        yx = y * N + x\n        for i in range(4):\n            ny = y + dy[i]\n            nx = x + dx[i]\n            if 0 <= ny < N and 0 <= nx < N:\n                CM = list(deepcopy(M))\n                nyx = ny * N + nx\n                CM[yx], CM[nyx] = CM[nyx], CM[yx]\n                CM = tuple(CM)\n                if not CM in LOG:\n                    if CM == goal:\n                        print(cnt)\n                        dp = []\n                        break\n                    dp.append([ny, nx, cnt, CM])\n                    LOG.add(CM)\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque, OrderedDict\n\nclass Puzzle:\n    def __init__(self, field=None, path=''):\n        self.f = field\n        self.space = None\n        for i in range(9):\n            if self.f[i] == 9:\n                self.space = i\n        self.path = path\n\n    def __lt__(self, pzl): # <\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] > pzl.f[i]\n        return False\n\n    def __gt__(self, pzl): # >\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] < pzl.f[i]\n        return False\n\ndx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\ndir = ['u', 'l', 'd', 'r']\n\ndef is_target(pzl):\n    for i in range(9):\n        if pzl.f[i] != i+1:\n            return False\n    return True\n\ndef bfs(pzl):\n    queue = deque([])\n    V = {}\n    pzl.path = ''\n    queue.append(pzl)\n    V[str(pzl.f)] = True\n    if is_target(pzl): return pzl.path\n\n    while len(queue) != 0:\n        u = queue.popleft()\n        sx, sy = u.space//3, u.space%3\n        for r in range(4):\n            tx, ty = sx + dx[r], sy + dy[r]\n            if tx < 0 or ty < 0 or tx >= 3 or ty >= 3:\n                continue\n            v = Puzzle(field=[u.f[i] for i in range(9)], path=u.path)\n            v.f[u.space], v.f[tx*3+ty] = v.f[tx*3+ty], v.f[u.space]\n            v.space = tx*3 + ty\n            if str(v.f) not in V:\n                V[str(v.f)] = True\n                v.path += dir[r]\n                if is_target(v): return v.path\n                queue.append(v)\n    return 'unsolvable'\n\nfield = []\nfor i in range(3):\n    field.extend(list(map(int, input().split(' '))))\n\nfor i in range(9):\n    if field[i] == 0: field[i] = 9\n\npzl = Puzzle(field=field)\nans= bfs(pzl)\nprint(len(ans))\n\n\n"
  },
  {
    "language": "Python",
    "code": "import heapq\n\ndef d_manhattan(node_list):\n    s = 0\n    for i in range(9):\n        x_goal = i%3\n        y_goal = i//3\n        x_now = (node_list[i] - 1)%3\n        y_now = (node_list[i] - 1)//3\n        if y_now == -1:\n            y_now = 2\n        dx = abs(x_now - x_goal)\n        dy = abs(y_now - y_goal)\n        s += dx + dy\n    return s\n\ndef moveNodeE(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 1] = node_tmp[space + 1], node_tmp[space]\n    return node_tmp\ndef moveNodeW(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 1] = node_tmp[space - 1], node_tmp[space]\n    return node_tmp\ndef moveNodeN(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 3] = node_tmp[space - 3], node_tmp[space]\n    return node_tmp\ndef moveNodeS(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 3] = node_tmp[space + 3], node_tmp[space]\n    return node_tmp\n\nclass board:\n    def __init__(self, node_list, g):\n        self.node = node_list\n        self.space = node_list.index(0)\n        self.g = g\n        self.h = d_manhattan(node_list)\n        self.f = self.g + self.h\n\n    def makeBoard(self):\n        space = self.space\n        cost_now = self.f\n        x_s = space%3\n        y_s = space//3\n        if x_s < 2:\n            node_tmp = moveNodeE(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if x_s > 0:\n            node_tmp = moveNodeW(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s < 2:\n            node_tmp = moveNodeS(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s > 0:\n            node_tmp = moveNodeN(self.node, space)\n            yield board(node_tmp, self.g + 1)\n\nb_open = []\nn_close = []\nn_goal = [1,2,3,4,5,6,7,8,0]\nn_start = []\n\nfor i in range(3):\n    inp = list(map(int, input().split()))\n    n_start.extend(inp)\n\nb_start = board(n_start, 0)\nheapq.heappush(b_open, (b_start.f, b_start.h, 0, b_start))\n\nprint(b_start.node, b_start.f)\n\ni = 0\nwhile b_open:\n    _, _, _, b_now = heapq.heappop(b_open)\n    if b_now.node == n_goal:\n        b_goal = b_now\n        break\n    n_close.append(b_now.node)\n    for b_new in b_now.makeBoard():\n        if b_new.node in n_close:\n            continue\n        heapq.heappush(b_open, (b_new.f, b_new.h, i, b_new))\n        i += 1\n\nprint(b_goal.g)"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(0,i,j,puz))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        c_puz = items[3]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+simpleHS(c_puz)) >= depth):\n            continue\n\n        if(_i != 0):\n            heapq.heappush(q,(c_depth+1,_i-1,_j,swapPuz(c_puz[0:],_i,_j,_i-1,_j)))\n        if(_i != 2):\n            heapq.heappush(q,(c_depth+1,_i+1,_j,swapPuz(c_puz[0:],_i,_j,_i+1,_j)))\n        if(_j != 0):\n            heapq.heappush(q,(c_depth+1,_i,_j-1,swapPuz(c_puz[0:],_i,_j,_i,_j-1)))\n        if(_j != 2):\n            heapq.heappush(q,(c_depth+1,_i,_j+1,swapPuz(c_puz[0:],_i,_j,_i,_j+1)))\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(c_puz):\n    value = 0\n    for i in range(len(c_puz)):\n        k = correctPuz.index(c_puz[i])\n        _i = (int)(i/3)\n        _j = i - _i\n        ki = (int)(k/3)\n        kj = k - ki\n        value = abs(_i-ki)+abs(_j-kj) \n\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nreadline = stdin.readline\n\n\nadjacent = (\n    (1, 3),        # 0\n    (0, 2, 4),     # 1\n    (1, 5),        # 2\n    (0, 4, 6),     # 3\n    (1, 3, 5, 7),  # 4\n    (2, 4, 8),     # 5\n    (3, 7),        # 6\n    (4, 6, 8),     # 7\n    (5, 7)         # 8\n)\n\n\ndef next_board(board, space, prev):\n    for nxt in adjacent[space]:\n        if nxt == prev:\n            continue\n        b = board[:]\n        b[space], b[nxt] = b[nxt], 0\n        yield b, nxt\nfrom heapq import heappop, heappush\n\nend = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\n# ???????????¨????????°\nFORE = 1\nBACK = 0\n\n\ndef search(start):\n    if start == end:\n        return 0\n    table = {}\n\n    table[tuple(start)] = (FORE, 0)\n    table[tuple(end)] = (BACK, 0)\n\n    heap = [(0, start, start.index(0), None, FORE), (0, end, end.index(0), None, BACK)]\n    while heap:\n        i, board, space, prev, direction = heappop(heap)\n        i += 1\n        for b, nxt in next_board(board, space, prev):\n            key = tuple(b)\n            if key in table:\n                if table[key][0] != direction:\n                    return table[key][1] + i\n                continue\n            table[key] = (direction, i)\n            if b == end:\n                return i\n            heappush(heap, (i, b, nxt, space, direction))\n\n\ndef main():\n    start = (map(int, readline().split()) for _ in range(3))\n    start = [y for x in start for y in x]\n    print(search(start))\nmain()"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport copy\n\nrow = 3\nmaxx = 9\n\n\nclass Puzzle():\n    def __init__(self,f=None,space=None,path=''):\n        self.f=f\n        self.space=space\n        self.path=path\n        \n    def __hash__(self):  \n        ss=''\n        for i in range(1,len(self.f),2):\n            ss.join(str(self.f[i]))\n        return hash(ss)\n    \n  \n    def __eq__(self, other):  \n        if self.f== other.f :  \n            return True  \n        return False      \n    \n    def __str__(self):\n        return str(self.f)\n\n   \ndx = [ -1, 0, 1, 0 ]\ndy= [ 0, -1, 0 ,1 ]\ndirect = [ 'u','l','d','r']\n\n\ndef isTarget(p) :\n    for i in range(maxx):\n        if (p.f[i] != (i + 1)):\n            return False;\n    return True;\n\ndef bfs(s): \n    global row\n    global maxx\n    global dx\n    global dy\n    global direct\n    global Q\n    \n    V={}\n    #Puzzle u, v;\n    s.path = \"\"\n    Q.append(s)\n    V[s] = True\n\n    while (len(Q)!=0): \n        u =Q.popleft()\n        if (isTarget(u)):\n            return u.path\n        \n        sx = u.space // row\n        sy = u.space % row\n        for r in range(4):\n            tx = sx + dx[r]\n            ty = sy + dy[r]\n\n            if (tx < 0 or ty < 0 or tx >= row or ty >= row):\n                continue;\n            v = copy.deepcopy(u)\n            v.f[u.space], v.f[tx * row + ty]=v.f[tx * row + ty],v.f[u.space]\n            v.space = tx * row + ty\n            \n            #if v in V:\n                #print(v)\n                \n            if  (not( v in V))  or V[v]!=True :\n                   V[v] = True;\n                   v.path += direct[r];\n                   Q.append(v)\n\n    return \"unsolveable\"\n\nstart=Puzzle()\nstart.f=[None for i in range(maxx)]\nQ=deque()\n\n\nfor i in range(3) :\n    start.f[i*3:i*3+3]=[int(x) for x in input().split()]\n    \nfor i in range(maxx):\n    if (start.f[i] == 0):\n        start.f[i] = maxx\n        start.space = i\n    \nans = bfs(start)\nif (ans!=\"unsolveable\"):\n    print(len(ans))\n\n"
  },
  {
    "language": "Python",
    "code": "import heapq\n\ndef d_manhattan(node_list):\n    s = 0\n    for i in range(9):\n        x = (i+1)%3\n        y = (i+1)//3\n        if y == 3:\n            y = 0\n        dx = abs(node_list[i]%3 - x)\n        dy = abs(node_list[i]//3 - y)\n        s += dx + dy\n    return s\n\ndef moveNodeE(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 1] = node_tmp[space + 1], node_tmp[space]\n    return node_tmp\ndef moveNodeW(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 1] = node_tmp[space - 1], node_tmp[space]\n    return node_tmp\ndef moveNodeN(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 3] = node_tmp[space - 3], node_tmp[space]\n    return node_tmp\ndef moveNodeS(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 3] = node_tmp[space + 3], node_tmp[space]\n    return node_tmp\n\nclass board:\n    def __init__(self, node_list, g):\n        self.node = node_list\n        self.space = node_list.index(0)\n        self.g = g\n        self.h = d_manhattan(node_list)\n        self.f = self.g + self.h\n\n    def makeBoard(self):\n        space = self.space\n        cost_now = self.f\n        x_s = space%3\n        y_s = space//3\n        if x_s < 2:\n            node_tmp = moveNodeE(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if x_s > 0:\n            node_tmp = moveNodeW(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s < 2:\n            node_tmp = moveNodeS(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s > 0:\n            node_tmp = moveNodeN(self.node, space)\n            yield board(node_tmp, self.g + 1)\n\nb_open = []\nn_close = []\nn_goal = [1,2,3,4,5,6,7,8,0]\nn_start = []\n\nfor i in range(3):\n    inp = list(map(int, input().split()))\n    n_start.extend(inp)\n\nb_start = board(n_start, 0)\nheapq.heappush(b_open, (b_start.f, b_start.h, 0, b_start))\n\n\ni = 0\nwhile b_open:\n    _, _, _, b_now = heapq.heappop(b_open)\n    if b_now.node == n_goal:\n        b_goal = b_now\n        break\n    n_close.append(b_now.node)\n    for b_new in b_now.makeBoard():\n        if b_new.node in n_close:\n            continue\n        heapq.heappush(b_open, (b_new.f, b_new.h, i, b_new))\n        i += 1\n\nprint(b_goal.node, b_goal.g)"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+simpleHS(c_puz)) >= depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            if(not checkPuzIsExisted(swap_puz,q)):\n                heapq.heappush(q,(c_depth+1,_i-1,_j,2,swap_puz))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            if(not checkPuzIsExisted(swap_puz,q)):\n                heapq.heappush(q,(c_depth+1,_i+1,_j,1,swap_puz))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            if(not checkPuzIsExisted(swap_puz,q)):\n                heapq.heappush(q,(c_depth+1,_i,_j-1,4,swap_puz))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            if(not checkPuzIsExisted(swap_puz,q)):\n                heapq.heappush(q,(c_depth+1,_i,_j+1,3,swap_puz))\n\ndef checkPuzIsExisted(puz,q):\n    for i in range(len(q)):\n        exist_puz = q[i][4]\n        count = 0\n        for j in range(len(exist_puz)):\n            if(exist_puz[j] != puz[j]):\n                count = 1\n        if(count == 0):\n            return True\n    return False\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i*3\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "import sys, itertools\nf = sys.stdin\n\nstart = [line.split() for line in f]\nstart = tuple(int(x) for y in start for x in y)\nend =(1, 2, 3, 4, 5, 6,7, 8, 0)\n\nd = {start:0}\n\ndef next_board(b):\n    brank = b.index(0)\n    if brank % 3:\n        yield b[:brank - 1] + (b[brank], b[brank - 1]) + b[brank + 1:]\n    if brank // 3:\n        yield b[:brank - 3] + (b[brank],)+ b[brank - 2:brank] +  (b[brank - 3],) + b[brank + 1:]\n    if brank % 3 != 2:\n        yield b[:brank] + (b[brank + 1], b[brank]) + b[brank + 2:]\n    if brank // 3 != 2:\n        yield b[:brank] + (b[brank + 3],)+ b[brank + 1:brank + 3] +  (b[brank],) + b[brank + 4:]\n\nqueue = set([start])\nwhile len(queue):\n    u = queue.pop()\n    for b in next_board(u):\n        if b not in d or d[b] > d[u] + 1:\n            d[b] = d[u] + 1\n            queue.update([b])\n        \nprint(d[end])"
  },
  {
    "language": "Python",
    "code": "import sys\nimport queue\n\nN = 3\nf= ''.join(sys.stdin.readline().split())\nf+= ''.join(sys.stdin.readline().split())\nf+= ''.join(sys.stdin.readline().split())\n\ndd = [[-1, 0], [0, -1], [1, 0], [0, 1]]\n\nQ = queue.Queue()\nV = dict()\n\nQ.put([f,f.index('0'),0])\nV[f] = True\n\nwhile not Q.empty():\n    u = Q.get()\n    if u[0] == '123456780':  break\n    sx, sy = u[1]//N, u[1]%N\n    for dx, dy in dd:\n        tx, ty = sx+dx, sy+dy\n        if tx<0 or ty<0 or tx>=N or ty>=N: continue\n        v = u[:]\n        n1, n2 = u[1], tx*N+ty\n        v[1] = n2\n\tif n1>n2: n1, n2 = n2, n1\n        v[0] = v[0][0:n1]+v[0][n2]+v[0][n1+1:n2]+v[0][n1]+v[0][n2+1:]\n        if not V.get(v[0], False):\n            V[v[0]] = True\n            v[2] += 1 # dir[r]                                                       \n            Q.put(v)\n\nprint(u[2])\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\ndef move(P):\n    for i in range(3):\n        for j in range(3):\n            if P[i][j] == 0:\n                r,c = i,j\n    if not r == 0:\n        tmp = [[i for i in j] for j in P]\n        tmp[r][c],tmp[r-1][c] = tmp[r-1][c],tmp[r][c]\n        yield tmp\n    if not r == 2:\n        tmp = [[i for i in j] for j in P]\n        tmp[r][c],tmp[r+1][c] = tmp[r+1][c],tmp[r][c]\n        yield tmp\n    if not c == 0:\n        tmp = [[i for i in j] for j in P]\n        tmp[r][c],tmp[r][c-1] = tmp[r][c-1],tmp[r][c]\n        yield tmp\n    if not c == 2:\n        tmp = [[i for i in j] for j in P]\n        tmp[r][c],tmp[r][c+1] = tmp[r][c+1],tmp[r][c]\n        yield tmp\n\ndef dpkey(P):\n    tmp = \"\"\n    for i in P:\n        for j in i:\n            tmp += str(j)\n    return tmp\n\nA = [[int(i) for i in input().split()] for _ in range(3)]\ndp = {dpkey(A) : 1}\nd = deque([(A,0)])\nc = 0\nflag = True\nwhile(flag):\n    tmp,c = d.pop()\n    for i in move(tmp):\n        key = dpkey(i)\n        if key == \"123456780\":\n            ans = c + 1\n            flag = False\n        elif not key in dp:\n            dp[key] = 1\n            d.appendleft((i,c+1))\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom heapq import heappop, heappush\nFORE = 1\nBACK = 0\nadjacent = ((1,3), (0,2,4), (1,5), (0,4,6), (1,3,5,7), (2,4,8), (3,7), (4,6,8), (5,7))\nstart = [int(a) for _ in range(3) for a in stdin.readline().split()]\nend = [1, 2, 3, 4, 5, 6, 7, 8, 0]\ndef next_board(board, space, prev):\n    for nxt in adjacent[space]:\n        if nxt == prev: continue\n        b = board[:]\n        b[space], b[nxt] = b[nxt], 0\n        yield b, nxt\ndef search(start):\n    if start == end: return 0\n    table = {}\n    table[tuple(start)] = (FORE, 0)\n    table[tuple(end)] = (BACK, 0)\n    heap = [(0, start, start.index(0), None, FORE), (0, end, end.index(0), None, BACK)]\n    while heap:\n        i, board, space, prev, direction = heappop(heap)\n        i += 1\n        for b, nxt in next_board(board, space, prev):\n            key = tuple(b)\n            if key in table:\n                if table[key][0] != direction: return table[key][1] + i\n                continue\n            table[key] = (direction, i)\n            if b == end: return i\n            heappush(heap, (i, b, nxt, space, direction))\nprint(search(start))"
  },
  {
    "language": "Python",
    "code": "import sys, collections\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = 10**10\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef resolve():\n    S = []\n    SOLVED = (1, 2, 3, 4, 5, 6, 7, 8, 0)\n    for _ in range(3):\n        S += LI()\n\n    neighbor = (\n        (1, 3),      \n        (0, 2, 4),   \n        (1, 5),      \n        (0, 4, 6),   \n        (1, 3, 5, 7),\n        (2, 4, 8),   \n        (3, 7),      \n        (4, 6, 8),   \n        (5, 7)       \n    )\n\n    dist = dict()\n    que = collections.deque()\n    S = tuple(S)\n    que.append((S, S.index(0)))\n    dist[S] = 0\n    while que:\n        c, idx_0 = que.popleft()\n        if c == SOLVED:\n            break\n        for i in neighbor[idx_0]:\n            c_l = list(c)\n            c_l[idx_0], c_l[i] = c_l[i], c_l[idx_0]\n            n = tuple(c_l)\n            if not n in dist:\n                que.append((n, i))\n                dist[n] = dist[c] + 1\n\n    print(dist[SOLVED])\n\nif __name__ == '__main__':\n    resolve()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+simpleHS(c_puz)) >= depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            heapq.heappush(q,(c_depth+1,_i-1,_j,2,swapPuz(c_puz[0:],_i,_j,_i-1,_j)))\n        if(_i != 2 and prev_move != 2):\n            heapq.heappush(q,(c_depth+1,_i+1,_j,1,swapPuz(c_puz[0:],_i,_j,_i+1,_j)))\n        if(_j != 0 and prev_move != 3):\n            heapq.heappush(q,(c_depth+1,_i,_j-1,4,swapPuz(c_puz[0:],_i,_j,_i,_j-1)))\n        if(_j != 2 and prev_move != 4):\n            heapq.heappush(q,(c_depth+1,_i,_j+1,3,swapPuz(c_puz[0:],_i,_j,_i,_j+1)))\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(c_puz):\n    value = 0\n    for i in range(len(c_puz)):\n        k = correctPuz.index(c_puz[i])\n        _i = (int)(i/3)\n        _j = i - _i\n        ki = (int)(k/3)\n        kj = k - ki\n        value = abs(_i-ki)+abs(_j-kj) \n\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "# 幅優先探索 #双方向探索\nimport sys\nimport queue\n\nSPACE = 0\n\nadjacents_list = (\n    (1, 3),       # 0\n    (0, 2, 4),    # 1\n    (1, 5),       # 2\n    (0, 4, 6),    # 3\n    (1, 3, 5, 7), # 4\n    (2, 4, 8),    # 5\n    (3, 7),       # 6\n    (4, 6, 8),    # 7\n    (5, 7)        # 8\n)\n\nclass State:\n    def __init__(self, board, space, prev):\n        self.board = board\n        self.space = space\n        self.prev = prev\n\ndef mininum_steps(start, goal):\n    if start == goal:\n        return 0\n    q = queue.Queue()\n    q.put(State(start, start.index(0), None))\n    history = {}\n    history[tuple(start)] = True\n    while not q.empty():\n        state = q.get()\n        for adjacent in adjacents_list[state.space]:\n            board = state.board[:]\n            board[state.space] = board[adjacent]\n            board[adjacent] = SPACE\n            if tuple(board) in history:\n                 continue\n            if board == goal:\n                return go_back(state)\n            history[tuple(board)] = True\n            next_state = State(board, adjacent, state)\n            q.put(next_state)\n\nstep = 0\ndef go_back(state):\n    global step\n    if state is not None:\n        step += 1\n        go_back(state.prev)\n    return step\n\n\ninitial_board = list(map(int, sys.stdin.read().split()))\ngoal = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\nprint(mininum_steps(initial_board, goal))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz,costs):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or (c_depth+checkSumCost(costs)) > depth):\n        return\n\n    if(i != 0 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i-1,j)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[(i-1)*3+j] = HS(i,j,_c_puz[(i-1)*3+j])\n        iterative(i-1,j,c_depth+1,_c_puz[0:],_costs[0:])\n    if(i != 2 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i+1,j)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[(i+1)*3+j] = HS(i,j,_c_puz[(i+1)*3+j])\n        iterative(i+1,j,c_depth+1,_c_puz[0:],_costs[0:])\n    if(j != 0 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i,j-1)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[i*3+j-1] = HS(i,j,_c_puz[i*3+j]-1)\n        iterative(i,j-1,c_depth+1,_c_puz[0:],_costs[0:])\n    if(j != 2 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i,j+1)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[i*3+j+1] = HS(i,j,_c_puz[i*3+j+1])\n        iterative(i,j+1,c_depth+1,_c_puz[0:],_costs[0:])\n\ndef checkSumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value+=costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki\n    value = abs(i-ki)+abs(j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz[0:]\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:],costs[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nN = 3\nM = 3\nboard = []\nexpected = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n\nqueue = deque()\nbqueue = deque()\n\nhistory = set()\n# todo 数字で表す\n# todo 2分担作にする\n\n\ndef swap(x1, y1, x2, y2, b):\n    # 2次元配列を浅いコピーするなんて\n    t = [x[:] for x in b]\n    t[x1][y1], t[x2][y2] = t[x2][y2], t[x1][y1]\n    return t\n\n\ndef p2i(b):\n    tmp = 0\n    for i in range(N):\n        for j in range(M):\n            tmp += b[i][j] * 10**(3*i+j)\n    return tmp\n\n\ndef bfs():\n    if expected == board:\n        print(0)\n        exit(0)\n\n    while len(queue):\n        pazzle = queue.popleft()\n        cost = bqueue.popleft()\n        # 0の場所を探す\n        xz = None\n        yz = None\n        for i in range(N):\n            for j in range(M):\n                if pazzle[i][j] == 0:\n                    xz, yz = i, j\n        # 動かすことのできる方向を全て調べる\n        xm = [1, 0, 0, -1]\n        ym = [0, -1, 1, 0]\n        for k in range(4):\n            if 0 <= xz + xm[k] < N and 0 <= yz + ym[k] < N:\n                # １手動かしてあったら終了。なかったら次の手に行く。\n                t = swap(xz, yz, xz + xm[k], yz + ym[k], pazzle)\n                ipz = p2i(t)\n                if 87654321 == ipz:\n                    print(cost+1)\n                    exit(0)\n                # 今までに出てないならキューに追加\n                if ipz not in history:\n                    queue.append(t)\n                    history.add(ipz)\n                    bqueue.append(cost+1)\n\n\nfor i in range(N):\n    board.append(list(map(int, input().split())))\nqueue.append(board)\nbqueue.append(0)\nbfs()\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ninit = ''.join(sys.stdin.read().split())\n\n# Bidirectional search using breadth-first search\ndef solve(start, goal):\n    if start == goal:\n        return 0\n    generated_state = {start: 0, goal: 1}   # 0: foreward, 1: backward\n    step = {start: 0, goal: 0}\n    s = 0\n    c_d = [(start, 0), (goal, 1)] # configure and direction\n    while True:\n        q = iter(c_d)\n        c_d = []\n        s += 1\n        for c, d in q:\n            i = c.find('0')\n            if 0 <= i <= 5:\n                t = str.maketrans('0' + c[i+3], c[i+3] + '0')\n                t_c = c.translate(t)\n                if t_c in generated_state:\n                    if generated_state[t_c] != d:\n                        return s + step[t_c]\n                else:\n                    generated_state[t_c] = d\n                    step[t_c] = s\n                    c_d.append((t_c, d))\n            if i >= 3:\n                t = str.maketrans('0' + c[i-3], c[i-3] + '0')\n                t_c = c.translate(t)\n                if t_c in generated_state:\n                    if generated_state[t_c] != d:\n                        return s + step[t_c]\n                else:\n                    generated_state[t_c] = d\n                    step[t_c] = s\n                    c_d.append((t_c, d))\n            if i == 0 or i == 1 or i == 3 or i == 4 or i == 6 or i == 7:\n                t = str.maketrans('0' + c[i+1], c[i+1] + '0')\n                t_c = c.translate(t)\n                if t_c in generated_state:\n                    if generated_state[t_c] != d:\n                        return s + step[t_c]\n                else:\n                    generated_state[t_c] = d\n                    step[t_c] = s\n                    c_d.append((t_c, d))\n            if i == 1 or i == 2 or i == 4 or i == 5 or i == 7 or i == 8:\n                t = str.maketrans('0' + c[i-1], c[i-1] + '0')\n                t_c = c.translate(t)\n                if t_c in generated_state:\n                    if generated_state[t_c] != d:\n                        return s + step[t_c]\n                else:\n                    generated_state[t_c] = d\n                    step[t_c] = s\n                    c_d.append((t_c, d))\n\nprint(solve(init, '123456780'))"
  },
  {
    "language": "Python",
    "code": "# 8 Puzzle\nimport copy\n[N, d] = [3, 0]\nstart = []\ngoal = [[i + j*N for i in range(1, N + 1)] for j in range(N)]\ngoal[2][2] = 0\nfor i in range(N):\n    start.append(list(map(int, input().split())))\n\n\ndef manhattan(value, pairs):\n    h = 0\n\n    if value == 1:\n        h = (pairs[0] + pairs[1])\n    if value == 2:\n        h = (pairs[0] + abs(pairs[1] - 1))\n    if value == 3:\n        h = (pairs[0] + abs(pairs[1] - 2))\n    \n    if value == 4:\n        h = (abs(pairs[0] - 1) + pairs[1])\n    if value == 5:\n        h = (abs(pairs[0] - 1) + abs(pairs[1] - 1)) \n    if value == 6:\n        h = (abs(pairs[0] - 1) + abs(pairs[1] - 2))\n        \n    if value == 7:\n        h = (abs(pairs[0] - 2) + pairs[1])      \n    if value == 8:\n        h = (abs(pairs[0] - 2) + abs(pairs[1] - 1))\n        \n    return h\n\ns_h = 0\nfor i in range(N):\n    for j in range(N):\n        s_h += manhattan(start[i][j], [i, j])\n\nfor i in range(N):\n        check = start[i].count(0)\n        if check != 0:\n            [s_r, s_c] = [i, start[i].index(0)]\n            break\n        if i == 3:\n            print(\"Error\")\n\nwhile True:\n    d += 1\n    flag = 0\n    queue = [[s_h, start, 0, [s_r, s_c], flag]]\n    \n    while len(queue) != 0:\n        short_n = queue.pop(0)\n        h = short_n[0] - short_n[2]\n        state = short_n[1]\n        g = short_n[2]\n        [r, c] = short_n[3]\n        flag = short_n[4]\n        \n        if h == 0:\n            print(short_n[2])\n            break\n       \n        if r - 1 >= 0 and flag != 3:\n            temp = copy.deepcopy(state)\n            h = short_n[0] - short_n[2] - manhattan(temp[r - 1][c], [r - 1, c]) + manhattan(temp[r - 1][c], [r, c])\n            [temp[r][c], temp[r - 1][c]] = [temp[r - 1][c], temp[r][c]]\n            if g + 1 + h <= d:\n                queue.append([h + g + 1, temp, g + 1, [r - 1, c], 1])\n        \n        if c + 1 < N and flag != 4:\n            temp = copy.deepcopy(state)\n            h = short_n[0] - short_n[2] - manhattan(temp[r][c + 1], [r, c + 1]) + manhattan(temp[r][c + 1], [r, c])\n            [temp[r][c], temp[r][c + 1]] = [temp[r][c + 1], temp[r][c]]\n            if g + 1 + h <= d:\n                queue.append([h + g + 1, temp, g + 1, [r, c + 1], 2])\n\n        if r + 1 < N and flag != 1:\n            temp = copy.deepcopy(state)\n            h = short_n[0] - short_n[2] - manhattan(temp[r + 1][c], [r + 1, c]) + manhattan(temp[r + 1][c], [r, c])\n            [temp[r][c], temp[r + 1][c]] = [temp[r + 1][c], temp[r][c]]\n            if g + 1 + h <= d:\n                queue.append([h + g + 1, temp, g + 1, [r + 1, c], 3])\n        \n        if c - 1 >= 0 and flag != 2:\n            temp = copy.deepcopy(state)\n            h = short_n[0] - short_n[2] - manhattan(temp[r][c - 1], [r, c - 1]) + manhattan(temp[r][c - 1], [r, c])\n            [temp[r][c], temp[r][c - 1]] = [temp[r][c - 1], temp[r][c]]\n            if g + 1 + h <= d:\n                queue.append([h + g + 1, temp, g + 1, [r, c - 1], 4])\n                \n        queue.sort(key = lambda data:data[0])\n        queue.sort(key = lambda data:data[2], reverse = True)\n\n        data = []\n        g_data = []\n\n    if state == goal:\n        break\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nfrom collections import deque\nimport copy\n\nclass Puzzle(list):\n    def __init__(self, size):\n        list.__init__(self)\n        self.size = size\n        self.space = None\n        self.path = \"\"\n    \n    def __hash__(self):\n        return hash(str(self))\n\nif __name__ == '__main__':\n    \n    N = 3\n    N2 = 9\n    dx = [-1, 0, 1, 0]\n    dy = [0, -1, 0, 1]\n    d = [\"u\", \"l\", \"d\", \"r\"]\n\n    p = Puzzle(N2)\n    for i in range(N):\n        p += [int(x) for x in input().split()]\n    for i in range(N2):\n        if p[i] == 0:\n            p[i] = N2\n            p.space = i\n    def isTarget(p):\n        for i in range(N2):\n            if p[i] != i+1:\n                return False\n        return True\n\n    def bfs(s):\n        cnt = 0\n        Q = deque()\n        V = set()\n        Q.append(s)\n        V.add(s)\n        while Q:\n            cnt += 1\n            u = Q.popleft()\n            if isTarget(u):\n                return u.path\n            sx = u.space // N\n            sy = u.space % N\n            for r in range(4):\n                tx = sx + dx[r]\n                ty = sy + dy[r]\n                if tx < 0 or ty < 0 or tx >= N or ty >= N:\n                    continue\n                v = copy.copy(u)\n                v[u.space], v[tx * N + ty] = v[tx * N + ty], v[u.space]\n                v.space = tx * N + ty\n                if not v in V:\n                    V.add(v)\n                    v.path += d[r]\n                    Q.append(v)\n\n        return \"unsolvable\"\n\n    ans = bfs(p)\n    print(len(ans))\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz,costs):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or (c_depth+checkSumCost(costs)) > depth):\n        return\n\n    if(i != 0 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i-1,j)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[(i-1)*3+j] = HS(i,j,_c_puz[(i-1)*3+j])\n        iterative(i-1,j,c_depth+1,_c_puz[0:],_costs[0:])\n    if(i != 2 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i+1,j)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[(i+1)*3+j] = HS(i,j,_c_puz[(i+1)*3+j])\n        iterative(i+1,j,c_depth+1,_c_puz[0:],_costs[0:])\n    if(j != 0 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i,j-1)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[i*3+j-1] = HS(i,j,_c_puz[i*3+j]-1)\n        iterative(i,j-1,c_depth+1,_c_puz[0:],_costs[0:])\n    if(j != 2 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i,j+1)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[i*3+j+1] = HS(i,j,_c_puz[i*3+j+1])\n        iterative(i,j+1,c_depth+1,_c_puz[0:],_costs[0:])\n\ndef checkSumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value+=costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(i-ki)+abs(j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz[0:]\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i*3\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:],costs[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python\n#coding:utf-8\n\ndef _downheap(buff, n):\n\tsize = len(buff)\n\twhile True:\n\t\tc = 2 * n + 1\n\t\tif c >= size: break\n\t\tif c + 1 < size:\n\t\t\tif buff[c] > buff[c + 1]: c += 1\n\t\tif buff[n] <= buff[c]: break\n\t\ttemp = buff[n]\n\t\tbuff[n] = buff[c]\n\t\tbuff[c] = temp\n\t\tn = c\n\n# ???????????????\ndef _upheap(buff, n):\n\twhile True:\n\t\tp = (n - 1) / 2\n\t\tif p < 0 or buff[p] <= buff[n]: break\n\t\ttemp = buff[n]\n\t\tbuff[n] = buff[p]\n\t\tbuff[p] = temp\n\t\tn = p\n\nclass PQueue:\n\tdef __init__(self, buff = []):\n\t\tself.buff = buff[:]   # ?????????\n\t\tfor n in xrange(len(self.buff) / 2 - 1, -1, -1):\n\t\t\t_downheap(self.buff, n)\n\n\t# ??????????????????\n\tdef push(self, data):\n\t\tself.buff.append(data)\n\t\t_upheap(self.buff, len(self.buff) - 1)\n\n\t# ????°???????????????????\n\tdef pop(self):\n\t\tif len(self.buff) == 0: raise IndexError\n\t\tvalue = self.buff[0]\n\t\tlast = self.buff.pop()\n\t\tif len(self.buff) > 0:\n\t\t\t# ????????????????§????\n\t\t\tself.buff[0] = last\n\t\t\t_downheap(self.buff, 0)\n\t\treturn value\n\n\t# ????°????????±???????\n\tdef peek(self):\n\t\tif len(self.buff) == 0: raise IndexError\n\t\treturn self.buff[0]\n\n\t# ??????\n\tdef isEmpty(self): return len(self.buff) == 0\n\n# ?????°\nOPEN = 0\nCLOSE = 1\nFORE = 0\nBACK = 1\n\nX=3\nY=3\n\nadjacent=[]\nfor coor in range(X*Y):\n\tlst=[]\n\tx=coor%X\n\ty=coor/X\n\tif 0<x: lst.append(coor-1)\n\tif x<X-1: lst.append(coor+1)\n\tif 0<y: lst.append(coor-X)\n\tif y<Y-1: lst.append(coor+X)\n\tadjacent.append(lst)\n\n# ?????¢??¨?????????\ndef make_distance_table(board, wide):\n\tsize = len(board)\n\ttable = [[0] * size for _ in xrange(size)]\n\tfor i in xrange(size):\n\t\tp = board[i]\n\t\tif p == 0: continue\n\t\tx1 = i / wide\n\t\ty1 = i % wide\n\t\tfor j in xrange(size):\n\t\t\tx2 = j / wide\n\t\t\ty2 = j % wide\n\t\t\ttable[p][j] += max(x1 - x2, x2 - x1)\n\t\t\ttable[p][j] += max(y1 - y2, y2 - y1)\n\treturn table\n\n# ?????¢????±???????\ndef get_distance(board, distance):\n\tv = 0\n\tfor x in xrange(X*Y):\n\t\tp = board[x]\n\t\tif p == 0: continue\n\t\tv += distance[p][x]\n\treturn v\n\n# ?±???¢?????????\nclass State:\n\tdef __init__(self, board, space, prev, move, dir, kind = OPEN):\n\t\tself.board = board\n\t\tself.space = space\n\t\tself.prev = prev\n\t\tself.move = move\n\t\tself.dir = dir\n\t\tself.kind = kind\n\t\tif dir == FORE:\n\t\t\tdt = start_distance\n\t\telse:\n\t\t\tdt = goal_distance\n\t\tif prev is None:\n\t\t\tself.cost = move + get_distance(board, dt)\n\t\telse:\n\t\t\tp = board[prev.space]\n\t\t\tself.cost = prev.cost + 1 - dt[p][space] + dt[p][prev.space]\n\n\tdef __cmp__(x, y):\n\t\treturn x.cost - y.cost\n\n# ???????????? A* ??¢?????´?????????\ndef a_star_search(start, goal):\n\tglobal start_distance, goal_distance\n\tq = PQueue()\n\ttable ={}\n\t# ?????????????????????\n\tstart_distance = make_distance_table(goal, X)\n\ta = State(start, start.index(0), None, 0, FORE)\n\tq.push(a)\n\ttable[tuple(start)] = a\n\t# ??´???????????????\n\tgoal_distance = make_distance_table(start, X)\n\ta = State(goal, goal.index(0), None, 0, BACK)\n\tq.push(a)\n\ttable[tuple(goal)] = a\n\twhile not q.isEmpty():\n\t\ta = q.pop()\n\t\tif a.kind == CLOSE: continue   # ????£????????????§??????\n\t\tfor x in adjacent[a.space]:\n\t\t\tb = a.board[:]\n\t\t\tb[a.space] = b[x]\n\t\t\tb[x] = 0\n\t\t\tkey = tuple(b)\n\t\t\tif key in table:\n\t\t\t\t# ???????±???¢?????????\n\t\t\t\tc = table[key]\n\t\t\t\tif a.dir != c.dir:\n\t\t\t\t\t# ??????\n\t\t\t\t\tif a.dir == FORE:\n\t\t\t\t\t\tprint print_answer(a)+print_answer_goal(c)-1\n\t\t\t\t\telse:\n\t\t\t\t\t\tprint print_answer(c)+print_answer_goal(a)-1\n\t\t\t\t\treturn\n\t\t\t\t# ?????¢???????????????????????°?????????????????°??????\n\t\t\t\tif c.move > a.move + 1:\n\t\t\t\t\t# ??´??°??????\n\t\t\t\t\tif c.kind == OPEN:\n\t\t\t\t\t\tc.kind = CLOSE\n\t\t\t\t\t\tc = State(b, x, a, a.move + 1, a.dir)\n\t\t\t\t\t\ttable[key] = c\n\t\t\t\t\telse:\n\t\t\t\t\t\tc.prev = a\n\t\t\t\t\t\tc.cost = c.cost - c.move + a.move + 1\n\t\t\t\t\t\tc.move = a.move + 1\n\t\t\t\t\t\tc.kind = OPEN\n\t\t\t\t\t# ??????????????????\n\t\t\t\t\tq.push(c)\n\t\t\telse:\n\t\t\t\tc = State(b, x, a, a.move + 1, a.dir)\n\t\t\t\tq.push(c)\n\t\t\t\ttable[key] = c\n\t\t# a ???????????????????±??????????\n\t\ta.kind = CLOSE\n\n# ???????????¨???\ndef print_answer(x):\n\tif x is not None:\n\t\treturn 1+print_answer(x.prev)\n\t\t#print x.board\n\treturn 0\n\ndef print_answer_goal(x):\n\tr=0\n\twhile x is not None:\n\t\t#print x.board\n\t\tx = x.prev\n\t\tr+=1\n\treturn r\n\n# ??????\ngoal = [1,2,3,4,5,6,7,8,0]\na = []\ntry:\n    while True:\n        a+=[int(e) for e in raw_input().split()]\nexcept EOFError:\n    pass\n\na_star_search(a, goal)"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop, heappush\nfrom copy import deepcopy\n\n\nclass Board:\n    def __init__(self, size, nums):\n        self.size = size\n        self.nums = nums\n        self.code = self._code()\n\n    def __eq__(self, other):\n        return self.code == other.code\n\n    def __lt__(self, other):\n        return self.code < other.code\n\n    def __gt__(self, other):\n        return self.code > other.code\n\n    def __hash__(self):\n        nums = tuple(self.nums[i][j]\n                     for i in range(self.size)\n                     for j in range(self.size))\n        return hash(nums)\n\n    def same(self, other):\n        if other is None:\n            return False\n        if self.__class__ != other.__class__:\n            return False\n\n        for i in range(self.size):\n            for j in range(self.size):\n                if self.nums[i][j] != other.nums[i][j]:\n                    return False\n        return True\n\n    def solved(self):\n        for i in range(self.size):\n            for j in range(self.size):\n                if (i, j) != self._validpos(self.nums[i][j]):\n                    return False\n        return True\n\n    def _validpos(self, num):\n        if num > 0:\n            return ((num-1) // self.size, (num-1) % self.size)\n        else:\n            return (self.size-1, self.size-1)\n\n    def _code(self):\n        code = 0\n        for i in range(self.size):\n            for j in range(self.size):\n                if self.nums[i][j] != 0:\n                    vi, vj = self._validpos(self.nums[i][j])\n                    code += abs(vi - i) + abs(vj - j)\n        return code\n\n    def find(self, num):\n        for i in range(self.size):\n            for j in range(self.size):\n                if self.nums[i][j] == num:\n                    return (i, j)\n        raise IndexError()\n\n    def move(self, p1, p2):\n        i1, j1 = p1\n        i2, j2 = p2\n        nums = deepcopy(self.nums)\n        nums[i1][j1], nums[i2][j2] = nums[i2][j2], nums[i1][j1]\n        return self.__class__(self.size, nums)\n\n    def moves(self):\n        i, j = self.find(0)\n        if i > 0:\n            yield self.move((i, j), (i-1, j))\n        if j > 0:\n            yield self.move((i, j), (i, j-1))\n        if i < self.size-1:\n            yield self.move((i, j), (i+1, j))\n        if j < self.size-1:\n            yield self.move((i, j), (i, j+1))\n\n    def __str__(self):\n        s = ''\n        for i in range(self.size):\n            for j in range(self.size):\n                s += ' {}'.format(self.nums[i][j])\n            s += '\\n'\n        return s\n\n\nclass EightPuzzle:\n    def __init__(self, board):\n        self.board = Board(3, board)\n        self.steps = 0\n\n        if not self.board.solved():\n            self._solve()\n\n    def _solve(self):\n        bs = []\n        checked = {}\n        heappush(bs, (self.board.code, self.board, 0))\n\n        while len(bs) > 0:\n            w, b, step = heappop(bs)\n            if 0 < self.steps <= step:\n                continue\n            checked[b] = step\n            for nb in b.moves():\n                if nb.solved():\n                    self.steps = step+1\n                    return\n                elif nb in checked and checked[nb] <= step:\n                    continue\n                else:\n                    heappush(bs, (nb.code + step + 1, nb, step+1))\n\n\ndef run():\n    board = []\n    for i in range(3):\n        board.append([int(i) for i in input().split()])\n\n    eight_puzzle = EightPuzzle(board)\n    print(eight_puzzle.steps)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nfrom collections import deque\nimport copy\n\nclass Puzzle(list):\n    def __init__(self):\n        list.__init__(self)\n        self.space = None\n        self.path = \"\"\n    \n    def __hash__(self):\n        return hash(str(self[:]))\n\nif __name__ == '__main__':\n    \n    N = 3\n    N2 = 9\n    dx = [-1, 0, 1, 0]\n    dy = [0, -1, 0, 1]\n    d = [\"u\", \"l\", \"d\", \"r\"]\n\n    p = Puzzle()\n    for i in range(N):\n        p += [int(x) for x in input().split()]\n    for i in range(N2):\n        if p[i] == 0:\n            p[i] = N2\n            p.space = i\n    target = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    def isTarget(p):\n        return p[:] == target[:]\n\n    def bfs(s):\n        Q = deque()\n        V = set()\n        Q.append(s)\n        V.add(s)\n        while Q:\n            u = Q.popleft()\n            if isTarget(u):\n                return u.path\n            sx = u.space // N\n            sy = u.space % N\n            for r in range(4):\n                tx = sx + dx[r]\n                ty = sy + dy[r]\n                if not (0<= tx < N and 0 <= ty < N):\n                    continue\n                v = copy.copy(u)\n                v[u.space], v[tx * N + ty] = v[tx * N + ty], v[u.space]\n                v.space = tx * N + ty\n                if not v in V:\n                    V.add(v)\n                    v.path += d[r]\n                    Q.append(v)\n\n        return \"unsolvable\"\n\n    ans = bfs(p)\n    print(len(ans))\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "class Puzzle:\n    def __init__(self, field=None, path=''):\n        self.f = field\n        self.space = None\n        for i in range(9):\n            if self.f[i] == 9:\n                self.space = i\n        self.path = path\n\n    def __lt__(self, pzl): # <\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] > pzl.f[i]\n        return False\n\n    def __gt__(self, pzl): # >\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] < pzl.f[i]\n        return False\n\ndx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\ndir = ['u', 'l', 'd', 'r']\n\ndef is_target(pzl):\n    for i in range(9):\n        if pzl.f[i] != i+1:\n            return False\n    return True\n\ndef bfs(pzl):\n    queue = deque([])\n    V = {}\n    pzl.path = ''\n    queue.append(pzl)\n    V[str(pzl.f)] = True\n    if is_target(pzl): return u.path\n\n    while len(queue) != 0:\n        u = queue.popleft()\n        sx, sy = u.space//3, u.space%3\n        for r in range(4):\n            tx, ty = sx + dx[r], sy + dy[r]\n            if tx < 0 or ty < 0 or tx >= 3 or ty >= 3:\n                continue\n            v = Puzzle(field=[u.f[i] for i in range(9)], path=u.path)\n            v.f[u.space], v.f[tx*3+ty] = v.f[tx*3+ty], v.f[u.space]\n            v.space = tx*3 + ty\n            if str(v.f) not in V:\n                V[str(v.f)] = True\n                v.path += dir[r]\n                if is_target(v): return v.path\n                queue.append(v)\n    return 'unsolvable'\n\nfield = []\nfor i in range(3):\n    field.extend(list(map(int, input().split(' '))))\n\nfor i in range(9):\n    if field[i] == 0: field[i] = 9\n\npzl = Puzzle(field=field)\nans= bfs(pzl)\nprint(len(ans))\n\n\n"
  },
  {
    "language": "Python",
    "code": "import heapq\n\n\nN = 3\nFORE = 1\nBACK = 0\n\nboard_goal = [i for i in range(1, N ** 2)] + [0]\n\n\nBOARD_ADJACENT = (\n    (1, 3),        # 0\n    (0, 2, 4),     # 1\n    (1, 5),        # 2\n    (0, 4, 6),     # 3\n    (1, 3, 5, 7),  # 4\n    (2, 4, 8),     # 5\n    (3, 7),        # 6\n    (4, 6, 8),     # 7\n    (5, 7)         # 8\n)\n\n\ndef slove(board_start):\n    if board_start == board_goal:\n        return 0\n\n    dict_board_state = {}\n    dict_board_state[tuple(board_start)] = (FORE, 0)\n\n    heap_board = [(0, board_start, board_start.index(0), None, FORE)]\n\n    while heap_board:\n        cnt_move, board, space_now, space_prev, direction = heapq.heappop(heap_board)\n        cnt_move += 1\n\n        for board_next, space_next in next_board(board, space_now, space_prev):\n            key = tuple(board_next)\n            if key in dict_board_state:\n                continue\n\n            dict_board_state[key] = (direction, cnt_move)\n            if board_next == board_goal:\n                return cnt_move\n\n            heapq.heappush(heap_board, (cnt_move, board_next, space_next, space_now, direction))\n\n            \ndef next_board(board, space_now, space_prev):\n    for space_next in BOARD_ADJACENT[space_now]:\n        if space_next == space_prev:\n            continue\n\n        board_next = board[:]\n        board_next[space_now], board_next[space_next] = board_next[space_next], 0\n        yield board_next, space_next\n\n\n\nboard_input = []\n\nfor _ in range(N):\n    board_input.extend(list(map(int, input().split())))\n\n\nprint(slove(board_input))\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\ndef move(P):\n    for i in range(3):\n        for j in range(3):\n            if P[i][j] == 0:\n                r,c = i,j\n    if not r == 0:\n        tmp = [[i for i in j] for j in P]\n        tmp[r][c],tmp[r-1][c] = tmp[r-1][c],tmp[r][c]\n        yield tmp\n    if not r == 2:\n        tmp = [[i for i in j] for j in P]\n        tmp[r][c],tmp[r+1][c] = tmp[r+1][c],tmp[r][c]\n        yield tmp\n    if not c == 0:\n        tmp = [[i for i in j] for j in P]\n        tmp[r][c],tmp[r][c-1] = tmp[r][c-1],tmp[r][c]\n        yield tmp\n    if not c == 2:\n        tmp = [[i for i in j] for j in P]\n        tmp[r][c],tmp[r][c+1] = tmp[r][c+1],tmp[r][c]\n        yield tmp\n\ndef dpkey(P):\n    tmp = \"\"\n    for i in P:\n        for j in i:\n            tmp += str(j)\n    return tmp\n\nA = [[int(i) for i in input().split()] for _ in range(3)]\ndp = {dpkey(A) : 1}\nd = deque([(A,0)])\nc = 0\nflag = True\nwhile(flag):\n    tmp,c = d.pop()\n    for i in move(tmp):\n        key = dpkey(i)\n        if key == \"123456780\":\n            ans = c + 1\n            flag = False\n        elif not key in dp:\n            dp[key] = 1\n            d.appendleft((i,c+1))\nif dpkey(A) == \"123456780\":\n    ans = 0\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\n\ndef gen_hash(panel):\n    _hash = \"\"\n    for i in range(3):\n        for j in range(3):\n            _hash += str(panel[i][j])\n    return _hash\n\n\ndef get_matchings(_hash):\n    ans = \"123456780\"\n    cnt = 0\n    for i in range(9):\n        if _hash[i] == str(ans[i]):\n            cnt += 1\n    return cnt\n\n\ndef bfs(panel):\n    swap_candidates = {\n        0: (1, 3),\n        1: (0, 2, 4),\n        2: (1, 5),\n        3: (0, 4, 6),\n        4: (1, 3, 5, 7),\n        5: (2, 4, 8),\n        6: (3, 7),\n        7: (4, 6, 8),\n        8: (5, 7)\n    }\n    dq = deque()\n    dq.append((gen_hash(panel), 0))\n    seen = set()\n    seen.add(gen_hash(panel))\n    while dq:\n        _hash, cnt = dq.popleft()\n        if get_matchings(_hash) == 9:\n            return cnt\n        z_ptr = _hash.index(\"0\")\n        for n_ptr in swap_candidates[z_ptr]:\n            next_hash = list(_hash)\n            next_hash[z_ptr], next_hash[n_ptr] = next_hash[n_ptr], next_hash[z_ptr]\n            next_hash = \"\".join(next_hash)\n            if next_hash not in seen:\n                seen.add(next_hash)\n                dq.append((next_hash, cnt + 1))\n\n\npanel = []\nfor _ in range(3):\n    panel.append([int(i) for i in input().split()])\n\nans = bfs(panel)\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(sumcost,(0,i,j,0,puz)))\n    global finding\n\n    while len(q):\n        c_dWithH, items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        _sum_cost = c_dWithH - c_depth\n\n        if(c_dWithH - c_depth == 0):\n            finding = 1\n            print(c_depth)\n            break\n        if(c_dWithH > depth):\n            continue\n\n        c_cost = simpleHS(c_puz,_i,_j)\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            heapq.heappush(q,(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i-1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i-1,_j)),(c_depth+1,_i-1,_j,2,swap_puz)))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            heapq.heappush(q,(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i+1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i+1,_j)),(c_depth+1,_i+1,_j,1,swap_puz)))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            heapq.heappush(q,(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j-1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j-1)),(c_depth+1,_i,_j-1,4,swap_puz)))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            heapq.heappush(q,(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j+1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j+1)),(c_depth+1,_i,_j+1,3,swap_puz)))\n\ndef checkCost(c_cost,m_cost,c2_cost,m2_cost):\n    return c2_cost - c_cost + m2_cost - m_cost\n    \n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz,i,j):\n    if(correctPuz[i*3+j] != c_puz[i*3+j]):\n        return 1\n    return 0\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nsumcost=0\nfor i in range(len(correctPuz)):\n    if(correctPuz[i] != puz[i]):\n        sumcost+=1\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nimport queue\n\n# ??£??\\?????????\nadjacent =(\n    (1,3),     # 0\n    (0,2,4),   # 1\n    (1,5),     # 2\n    (0,4,6),   # 3\n    (1,3,5,7), # 4\n    (2,4,8),   # 5\n    (3,7),     # 6\n    (4,6,8),   # 7\n    (5,7)      # 8\n)\n\n# ?±???¢?????????\nclass State:\n    def __init__(self,board,space,prev):\n        self.board = board # ?????¢?????¨?????????\n        self.space = space # ?????´????????????(0?????????)\n        self.prev = prev   # 1??????????±???¢(State??????????????§??????)\n\ndef bf_search(start,end):\n    q = queue.Queue()\n    q.put(State(start,start.index(0),None)) #item???Q?????\\??????\n    table = {} # ??????????????????\n    table[tuple(start)] = True # ???????±???¢????????§???????????????????????????\n\n    while not q.empty(): # empty()???Q???????????´??????True????????????????????§????????´??????False?????????\n        a = q.get() # Q??????item????????????????????????????????????\n        for i in adjacent[a.space]: # i????????????0?????????\n            b = a.board[:] # ???????????¢???b????????????\n            b[a.space] = b[i] # ?¬?????????¢?????????\n            b[i] = 0          # ?¬?????????¢?????????\n            \n            \n            key = tuple(b) # b???????????¨??????table????????¨??????????¢??????????\n            if key in table:\n                continue # ?????¨?????????for?????????????????£?????°???????????¢b?????????\n\n            # table????????¨???????????´????????°???????±???¢c?????????\n            # b?????°???????????¢?????¨????????????i????????????0????????????a???1??????????±???¢\n            c = State(b,i,a) \n\n            # b???end????????´?????????printAns()??§???????????°?????¨???\n            if b == end:\n                return printAns(c)\n\n            # ?????´???????????£??????Q???c????????????\n            q.put(c)\n            # key????????£???True?????????\n            table[key] = True\n\ncount = -1\ndef printAns(c):\n    global count\n    if c is not None: \n        count += 1\n        printAns(c.prev) # c.prev??????????????????????????¨????????£????????°?????°??????\n    return count\n\n\n# ??????????????????????????????\nend = [1,2,3,4,5,6,7,8,0]\n\n# ??\\???\nstart = [ int(n) for _ in range(3) for n in stdin.readline().split() ]\n\nif start == end:\n    print(0)\nelse:\n    print(bf_search(start,end))"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(0,i,j,puz))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        c_puz = items[3]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+HS(c_puz)) > depth):\n            continue\n\n        if(_i != 0):\n            heapq.heappush(q,(c_depth+1,_i-1,_j,swapPuz(c_puz[0:],_i,_j,_i-1,_j)))\n        if(_i != 2):\n            heapq.heappush(q,(c_depth+1,_i+1,_j,swapPuz(c_puz[0:],_i,_j,_i+1,_j)))\n        if(_j != 0):\n            heapq.heappush(q,(c_depth+1,_i,_j-1,swapPuz(c_puz[0:],_i,_j,_i,_j-1)))\n        if(_j != 2):\n            heapq.heappush(q,(c_depth+1,_i,_j+1,swapPuz(c_puz[0:],_i,_j,_i,_j+1)))\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(c_puz):\n    value = 0\n    for i in range(len(c_puz)):\n        k = correctPuz.index(c_puz[i])\n        _i = (int)(i/3)\n        _j = i - _i\n        ki = (int)(k/3)\n        kj = k - ki\n        value = abs(_i-ki)+abs(_j-kj) \n\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import heapq\n\n\ndef check_goal(p):\n    return p == [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\n\ndef up(p):\n    q = p.copy()\n    zero = p.index(0)\n    q[zero] = q[zero - 3]\n    q[zero - 3] = 0\n    return q\n\n\ndef low(p):\n    q = p.copy()\n    zero = p.index(0)\n    q[zero] = q[zero + 3]\n    q[zero + 3] = 0\n    return q\n\n\ndef right(p):\n    q = p.copy()\n    zero = p.index(0)\n    q[zero] = q[zero + 1]\n    q[zero + 1] = 0\n    return q\n\n\ndef left(p):\n    q = p.copy()\n    zero = p.index(0)\n    q[zero] = q[zero - 1]\n    q[zero - 1] = 0\n    return q\n\n\ndef cost(p, n_mov):\n    c = n_mov\n    for i in range(9):\n        if p[i] != (i + 1) % 9:\n            c += 1\n    return c\n\n\ndef solve(p):\n    ans = 0\n    zero = p.index(0)\n    will = list()\n    done = [p]\n    while not check_goal(p):\n        ans += 1\n        if zero >= 3 and up(p) not in done:\n            done.append(up(p))\n            heapq.heappush(will, (up(p), ans))\n        if zero <= 5 and low(p) not in done:\n            done.append(low(p))\n            heapq.heappush(will, (low(p), ans))\n        if zero % 3 <= 1 and right(p) not in done:\n            done.append(right(p))\n            heapq.heappush(will, (right(p), ans))\n        if zero % 3 >= 1 and left(p) not in done:\n            done.append(left(p))\n            heapq.heappush(will, (left(p), ans))\n        p, ans = heapq.heappop(will)\n        zero = p.index(0)\n    return ans\n\n\np = list(map(int, input().split()))\np.extend(list(map(int, input().split())))\np.extend(list(map(int, input().split())))\nprint(solve(p))\n"
  },
  {
    "language": "Python",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\ntypedef char Board[10];\nBoard ini_board, board;\nconst Board target = \"123456780\";\n\nBoard *history;\nint nhistories=0;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nint minstep = 50;\n\nconst Motion candidate[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nint move(Motion m)\n{\n  if (m.pos==0 && board[0]=='1') return -1;\n  if ((m.pos==1||m.pos==2) && board[0]=='1'&&board[1]=='2'&&board[2]=='3') return -1;\n\n  switch (m.dir) {\n  case U:\n    if (m.pos<3) return -1;\n    board[m.pos-3] = board[m.pos];\n    break;\n  case D:\n    if (m.pos>5) return -1;\n    board[m.pos+3] = board[m.pos];\n    break;\n  case L:\n    if (m.pos%3==0) return -1;\n    board[m.pos-1] = board[m.pos];\n    break;\n  case R:\n    if (m.pos%3==2) return -1;\n    board[m.pos+1] = board[m.pos];\n    break;\n  }\n  board[m.pos] = '0';\n  return m.pos;\n}\n\nvoid search_path(int step, int space)\n{\n  int i, j, s2;\n  if (strcmp(board, \"123456780\")==0) {\n    if (step==1) {\n      printf(\"1\\n\");\n      exit(0);\n    }\n    if (step<minstep) minstep=step;\n  } else {\n    if (step>=minstep) return;\n    if (step>0 && strcmp(board, ini_board)==0) return;\n    \n    Board board_bak;\n    strcpy(board_bak, board);\n    int nhistories_bak=nhistories;\n\n    for (i=0; candidate[space][i].pos>=0; i++) {\n      if ((s2 = move(candidate[space][i]))<0) continue;\n      for (j=0; j<nhistories; j++) {\n\tif (strcmp(board, history[j])==0) // 前と同じ配置になったので次の手を試す\n\t  break;\n      }\n      if (j==nhistories) {\n\tstrcpy(history[nhistories++], board); \n\tsearch_path(step+1, s2);\n      }\n      nhistories = nhistories_bak;\n      strcpy(board, board_bak);\n    }\n  }\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board[0],&board[1],&board[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[3],&board[4],&board[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[6],&board[7],&board[8]);\n  strcpy(ini_board, board);\n  history = (Board*)malloc(sizeof(Board)*10000);\n  search_path(0, strchr(board, '0')-board);\n  printf(\"%d\\n\", minstep);\n  return 0;\n}\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    q.append(sumcost,(0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        c_dWithH, items = q.pop(0)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        _sum_cost = c_dWithH - c_depth\n\n        if(c_dWithH - c_depth == 0):\n            finding = 1\n            print(c_depth)\n            break\n        if(c_dWithH > depth):\n            continue\n\n        c_cost = simpleHS(c_puz,_i,_j)\n\n        print(c_depth)\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            q.append(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i-1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i-1,_j)),(c_depth+1,_i-1,_j,2,swap_puz))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            q.append(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i+1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i+1,_j)),(c_depth+1,_i+1,_j,1,swap_puz))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            q.append(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j-1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j-1)),(c_depth+1,_i,_j-1,4,swap_puz))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            q.append(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j+1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j+1)),(c_depth+1,_i,_j+1,3,swap_puz))\n\ndef checkCost(c_cost,m_cost,c2_cost,m2_cost):\n    return c2_cost - c_cost + m2_cost - m_cost\n    \n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz,i,j):\n    if(correctPuz[i*3+j] != c_puz[i*3+j]):\n        return 1\n    return 0\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nsumcost=0\nfor i in range(len(correctPuz)):\n    if(correctPuz[i] != puz[i]):\n        sumcost+=1\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nN = 3\nN2 = 9\n\ndx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\ndirc = ['u', 'l', 'd', 'r']\n\nclass Puzzle:\n    def __init__(self, f=None, space=None, path=None):\n        if f is None:\n            self.f = []\n        else:\n            self.f = f\n        self.space = space\n        self.path = path\n\n    def __lt__(self, p):\n        for i in range(N2):\n            if self.f[i] == p.f[i]:\n                continue\n            return self.f[i] > p.f[i]\n        return False\n\n\ndef isTarget(p):\n    for i in range(N2):\n        if p.f[i] != (i + 1):\n            return False\n    return True\n\n\ndef bfs(s):\n    q = deque()\n    dic = {}\n    s.path = ''\n    q.append(s)\n    dic[tuple(s.f)] = True\n\n    while len(q) != 0:\n        u = q.popleft()\n        if isTarget(u):\n            return u.path\n        sx = u.space // N\n        sy = u.space % N\n        for r in range(4):\n            tx = sx + dx[r]\n            ty = sy + dy[r]\n            if tx < 0 or ty < 0 or tx >= N or ty >= N:\n                continue\n            v = Puzzle(u.f[:], u.space, u.path)\n            v.f[u.space], v.f[tx * N + ty] = v.f[tx * N + ty], v.f[u.space]\n            v.space = tx * N + ty\n            key = tuple(v.f)\n            if key not in dic:\n                dic[key] = True\n                v.path += dirc[r]\n                q.append(v)\n\n    return 'unsolvable'\n\n\nif __name__ == '__main__':\n    p = Puzzle()\n    for i in range(N):\n        line = [int(v) for v in input().split()]\n        for j in range(N):\n            if line[j] == 0:\n                line[j] = N2\n                p.space = i * N + j\n        p.f.extend(line)\n\n    ans = bfs(p)\n    print(len(ans))\n"
  },
  {
    "language": "Python",
    "code": "adjacent = (\n    (1, 3),       # 0\n    (0, 2, 4),    # 1\n    (1, 5),       # 2\n    (0, 4, 6),    # 3\n    (1, 3, 5, 7), # 4\n    (2, 4, 8),    # 5\n    (3, 7),       # 6\n    (4, 6, 8),    # 7\n    (5, 7)        # 8\n)\n \nGOAL = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n \n# Bidirectional search using breadth-first search\ndef solve(start):\n    if start == GOAL:\n        return 0\n    # 0: forward, 1: backward\n    generated_state = {tuple(start): 0, tuple(GOAL): 1}\n    step = {tuple(start): 0, tuple(GOAL): 0}\n    s = 0\n    state1 = [(start, 0), (GOAL, 1)]\n    while state1:\n        state2 = state1[:]\n        state1 = []\n        s += 1\n        for s2, d in state2:\n            i = s2.index(0)\n            for p in adjacent[i]:\n                s1 = s2[:]\n                s1[i], s1[p] = s1[p], 0\n                key = tuple(s1)\n                if key in generated_state:\n                    if generated_state[key] != d:\n                        return s + step[key]\n                    continue\n                state1.append((s1, d))\n                generated_state[key] = d\n                step[key] = s\n \nimport sys\n \nstart = list(map(int, sys.stdin.read().split()))\n \nprint(solve(start))\n"
  },
  {
    "language": "Python",
    "code": "import heapq\nfrom itertools import chain\nfrom operator import mul\n\nexp10 = [10 ** a for a in range(8, -1, -1)]\nmovables = [{1, 3}, {0, 2, 4}, {1, 5}, {0, 4, 6}, {1, 3, 5, 7}, {2, 4, 8}, {3, 7}, {4, 6, 8}, {5, 7}]\n\ndestination = 123456780\n\n\ndef swap(board, move_from, move_to):\n    return board + (exp10[move_to] - exp10[move_from]) * (board // exp10[move_from] % 10)\n\n\nboard0 = sum(map(mul, exp10, chain.from_iterable(map(int, input().split()) for _ in range(3))))\np0 = str(board0).index('0')\n\nappeared = {board0}\nqueue = list((0, move_from, p0, board0) for move_from in movables[p0])\nheapq.heapify(queue)\n\nwhile True:\n    total_cost, move_from, move_to, board = heapq.heappop(queue)\n    if board == destination:\n        print(total_cost)\n        break\n    new_board = swap(board, move_from, move_to)\n    if new_board in appeared:\n        continue\n    for move_from2 in movables[move_from]:\n        if move_from2 != move_to:\n            heapq.heappush(queue, (total_cost + 1, move_from2, move_from, new_board))"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    q.append((simpleHS(puz),0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = q.pop()\n        c_dWithH = items[0]\n        c_depth = items[1]\n        _i = items[2]\n        _j = items[3]\n        prev_move = items[4]\n        c_puz = items[5]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n        if((c_depth+c_dWithH) > depth):\n            continue\n            \n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i-1,_j,2,swap_puz))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i+1,_j,1,swap_puz))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j-1,4,swap_puz))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j+1,3,swap_puz))\n\ndef checkPuzIsExisted(puz,q):\n    for i in range(len(q)):\n        exist_puz = q[i][4]\n        count = 0\n        for j in range(len(exist_puz)):\n            if(exist_puz[j] != puz[j]):\n                count = 1\n        if(count == 0):\n            return True\n    return False\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "import queue\nimport time\n\nN=3\nN2=9\ndiry=[0,1,0,-1]\ndirx=[1,0,-1,0]\npos=[[2,2],[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1]]\nmove=[[1,3],[0,2,4],[1,5],[0,4,6],[1,3,5,7],[2,4,8],[3,7],[4,6,8],[5,7]]\n\nclass Puzzle:\n    board=\"\"\n    space=0\n\n    def __init__(self,board,space):\n        self.board=board\n        self.space=space\n\n    #盤面を表示\n    def showBoard(self):\n        for i in range(N2):\n            if self.board[i]!=0:\n                print(self.board[i],end=' ')\n            else:\n                print('  ',end='')\n            if i%3==2:\n                print()\n        print()\n\nclass State:\n    pz=None\n    g=0\n    h=0\n    f=0\n    pr=None\n\n    def __init__(self,pz,g,h=0,pr=None):\n        self.pz=pz\n        self.g=g\n        self.h=h\n        self.f=g+h\n        self.pr=pr\n\n    #初期盤面から1手ずつ表示\n    def showRoot(self):\n        if self.pr!=None:\n            self.pr.showRoot()\n        self.pz.showBoard()\n\n    def __lt__(self,other):\n        if self.f==other.f:\n            return self.g>other.g\n        return self.f<other.f\n\n#正解とのマンハッタン距離\ndef h2(p):\n    count=0\n    for i in range(N2):\n        n=int(p.board[i])\n        count+=abs(pos[n][0]-i//N)+abs(pos[n][1]-i%N)\n    return count\n\n#h1を用いたヒューリスティック探索\ndef heuristic(pz,h):\n    closedList=set()\n    s=State(pz,0,h(pz),None)\n    q=queue.PriorityQueue()\n    q.put(s)\n    while not q.empty():\n        s=q.get()\n        if s.pz.board in closedList:\n            continue\n        if s.pz.board=='123456780':\n            return s.g\n        space=s.pz.space\n        for next in move[space]:\n            nb=list(s.pz.board)\n            nb[space],nb[next]=nb[next],nb[space]\n            newb=''.join(nb)\n            if not newb in closedList:\n                np=Puzzle(newb,next)\n                ns=State(np,s.g+1,h(np),s)\n                q.put(ns)\n        closedList.add(s.pz.board)\n    return -1\n\n#初期盤面の読み込み\ns=''\nfor i in range(3):\n    s+=input()\ninitialBoard=s.replace(' ','')\n\n#空白の設定\nspace=initialBoard.find('0')\n\n#Puzzleオブジェクトの作成\ninitialPuzzle=Puzzle(initialBoard,space)\n\nif initialBoard=='123456780':\n    print(0)\nelse:\n    print(heuristic(initialPuzzle,h2))\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom copy import deepcopy, copy\ndy = [-1, 0, 0, 1]\ndx = [0, -1, 1, 0]\nN = 3\ndef MAIN():\n    MAP = sum([input().split() for _ in range(N)], [])\n    y0, x0 = divmod(MAP.index(\"0\"), N)\n    goal = ['1', '2', '3', '4', '5', '6', '7', '8', '0']\n    ans = 0\n    dp = deque([[y0, x0, 0, MAP]])\n    LOG = [MAP]\n    while dp:\n        y, x, cnt, M = dp.popleft()\n        if M == goal:\n            print(cnt)\n            break\n        cnt += 1\n        yx = y * N + x\n        for i in range(4):\n            ny = y + dy[i]\n            nx = x + dx[i]\n            if 0 <= ny < N and 0 <= nx < N:\n                CM = deepcopy(M)\n                nyx = ny * N + nx\n                CM[yx], CM[nyx] = CM[nyx], CM[yx]\n                if not CM in LOG:\n                    dp.append([ny, nx, cnt, CM])\n                    LOG.append(CM)\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom collections import deque\nfrom copy import deepcopy\n\n\nclass State:\n    def dup(self):\n        ns = State()\n        ns.b = self.b[:]\n        ns.z = self.z\n        ns.c = self.c\n        return ns\n\n\ndef read_board():\n    s = State()\n    s.b = [int(x) for x in stdin.read().split()]\n    s.z = s.b.index(0)\n    s.c = 0\n    return s\n\n\ndef move_zero(s, h):\n    ns = s.dup()\n    ns.z += h\n    ns.b[s.z], ns.b[ns.z] = ns.b[ns.z], ns.b[s.z]\n    ns.c += 1\n    return ns\n\n\ndef push_hands(q, s):\n    if s.z % 3 != 0:\n        q.append(move_zero(s, -1))\n    if s.z % 3 != 3 - 1:\n        q.append(move_zero(s, 1))\n    if s.z // 3 != 0:\n        q.append(move_zero(s, -3))\n    if s.z // 3 != 3 - 1:\n        q.append(move_zero(s, 3))\n\n\ndef solve(s):\n    hist = set()\n    q = deque([])\n    while True:\n        t = tuple(s.b)\n        if t == (1, 2, 3, 4, 5, 6, 7, 8, 0):\n            return s.c\n        if t not in hist:\n            push_hands(q, s)\n            hist.add(t)\n        s = q.popleft()\n\n\ndef main():\n    b = read_board()\n    print(solve(b))\n\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nMOVE = {'U': (0, -1), 'D': (0, 1), 'L': (-1, 0), 'R': (1, 0)}\n\ndef next(numbers):\n    for d in 'UDLR':\n        z = numbers.index(0)\n        tx, ty = z % 3 + MOVE[d][0], z \n        if 0 <= tx < 3 and 0 <= ty < 3:\n            t = ty * 3 + tx\n            result = list(numbers)\n            result[z], result[t] = numbers[t], 0\n            yield d, tuple(result)\n\ndef bfs(puzzle):\n    queue = deque([(puzzle, '')])\n    seen = set()\n    while queue:\n        numbers, route = queue.popleft()\n        seen.add(numbers)\n        if numbers == (1, 2, 3, 4, 5, 6, 7, 8, 0):\n            return route\n        for direction, new_numbers in next(numbers):\n            if new_numbers not in seen:\n                queue.append((new_numbers, route + direction))\n    return route\n\npuzzle = ()\nfor i in range(3):\n    a,b,c = map(int, input().split())\n    puzzle += (a,b,c)\n\nprint(len(bfs(puzzle)))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or (c_depth+HS(c_puz)) > depth):\n        return\n\n    if(i != 0):\n        iterative(i-1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i-1,j))\n    if(i != 2):\n        iterative(i+1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i+1,j))\n    if(j != 0):\n        iterative(i,j-1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j-1))\n    if(j != 2):\n        iterative(i,j+1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j+1))\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(c_puz):\n    value = 0\n    for i in range(len(c_puz)):\n        k = correctPuz.index(c_puz[i])\n        k = abs(i-k)\n        if(k >= 3):\n            value += (int)(k/3)\n        value += k - (int)(k/3)*3\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import queue\n\nGOAL = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\nadjacent = (\n    (1, 3),       # 0\n    (0, 2, 4),    # 1\n    (1, 5),       # 2\n    (0, 4, 6),    # 3\n    (1, 3, 5, 7), # 4\n    (2, 4, 8),    # 5\n    (3, 7),       # 6\n    (4, 6, 8),    # 7\n    (5, 7)        # 8\n)\n\nclass State:\n    def __init__(self, board, space, prev):\n        self.board = board\n        self.space = space\n        self.prev  = prev\n\n\ndef bf_search(start):\n    q = queue.Queue()\n    q.put(State(start, start.index(0), None))\n\n    table = {}\n    table[tuple(start)] = True\n\n    while not q.empty():\n        a = q.get()\n\n        for x in adjacent[a.space]:\n            b = a.board[:]\n            b[a.space] = b[x]\n            b[x] = 0\n\n            key = tuple(b)\n\n            if key in table: continue\n\n            c = State(b, x, a)\n\n            if b == GOAL:\n                print_answer(c)\n                return\n\n            q.put(c)\n            table[key] = True\n\n\n# 手順の表示\ndef print_answer(x):\n    count = 0\n\n    while x.prev != None:\n        x = x.prev\n        count += 1\n\n    print(count)\n\n\n\nif(__name__ == '__main__'):\n    p = []\n    for i in range(3):\n        p.extend([int(x) for x in input().split()])\n\n    bf_search(p)\n\n"
  },
  {
    "language": "Python",
    "code": "adjacent = (\n    (1, 3),       # 0\n    (0, 2, 4),    # 1\n    (1, 5),       # 2\n    (0, 4, 6),    # 3\n    (1, 3, 5, 7), # 4\n    (2, 4, 8),    # 5\n    (3, 7),       # 6\n    (4, 6, 8),    # 7\n    (5, 7)        # 8\n)\n\nimport collections\n\nGOAL = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\n# Bidirectional search using breadth-first search\ndef solve(start):\n    if start == GOAL:\n        return 0\n    # 0: forward, 1: backward\n    generated_state = {tuple(start): 0, tuple(GOAL): 1}\n    step = {tuple(start): 0, tuple(GOAL): 0}\n    s = 0\n    state1 = [(start, 0), (GOAL, 1)]\n    while state1:\n        state2 = state1[:]\n        state1 = []\n        s += 1\n        for s2, d in state2:\n            i = s2.index(0)\n            for p in adjacent[i]:\n                s1 = s2[:]\n                s1[i], s1[p] = s1[p], 0\n                key = tuple(s1)\n                if key in generated_state:\n                    if generated_state[key] != d:\n                        return s + step[key]\n                    continue\n                state1.append((s1, d))\n                generated_state[key] = d\n                step[key] = s\n\nimport sys\n\nstart = list(map(int, sys.stdin.read().split()))\n\nprint(solve(start))"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    q.append((simpleHS(puz),0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = q.pop(0)\n        c_dWithH = items[0]\n        c_depth = items[1]\n        _i = items[2]\n        _j = items[3]\n        prev_move = items[4]\n        c_puz = items[5]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n        if((c_depth+c_dWithH) > depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            q.append((c_depth+1+simpleHS(swap_puz),c_depth+1,_i-1,_j,2,swap_puz))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            q.append((c_depth+1+simpleHS(swap_puz),c_depth+1,_i+1,_j,1,swap_puz))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            q.append((c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j-1,4,swap_puz))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            q.append((c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j+1,3,swap_puz))\n\n\ndef checkPuzIsExisted(puz,q):\n    for i in range(len(q)):\n        exist_puz = q[i][4]\n        count = 0\n        for j in range(len(exist_puz)):\n            if(exist_puz[j] != puz[j]):\n                count = 1\n        if(count == 0):\n            return True\n    return False\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN = 3\nm = {8: {7, 5}, 7: {8, 6, 4}, 6: {7, 3}, 5: {8, 4, 2}, 4: {7, 5, 3, 1}, 3: {6, 4, 0}, 2: {5, 1}, 1: {4, 2, 0},\n     0: {3, 1}}\ngoal = 123456780\ndef g(i, j, a):\n    t = a // (10 ** j) % 10\n    return a - t * (10 ** j) + t * (10 ** i)\ndef solve():\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n    zero = 8 - MAP.find(\"0\")\n    start = int(MAP)\n    if start == goal:\n        return 0\n    dp = deque([(0, start, zero, 1), (0, goal, 0, 0)])\n    TABLE = {start: (1, 0), goal: (0, 0)}\n    while dp:\n        cnt, M, yx, flg = dp.popleft()\n        cnt += 1\n        for nyx in m[yx]:\n            key = g(yx, nyx, M)\n            if key in TABLE:\n                if TABLE[key][0] != flg:\n                    return TABLE[key][1] + cnt\n                continue\n            TABLE[key] = (flg, cnt)\n            dp.append((cnt, key, nyx, flg))\ndef MAIN():\n    print(solve())\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz,costs):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or (c_depth+checkSumCost(costs)) > depth):\n        return\n\n    if(i != 0 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i-1,j)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[(i-1)*3+j] = HS(i,j,_c_puz[(i-1)*3+j])\n        iterative(i-1,j,c_depth+1,_c_puz[0:],_costs[0:])\n    if(i != 2 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i+1,j)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[(i+1)*3+j] = HS(i,j,_c_puz[(i+1)*3+j])\n        iterative(i+1,j,c_depth+1,_c_puz[0:],_costs[0:])\n    if(j != 0 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i,j-1)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[i*3+j-1] = HS(i,j,_c_puz[i*3+j]-1)\n        iterative(i,j-1,c_depth+1,_c_puz[0:],_costs[0:])\n    if(j != 2 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i,j+1)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[i*3+j+1] = HS(i,j,_c_puz[i*3+j+1])\n        iterative(i,j+1,c_depth+1,_c_puz[0:],_costs[0:])\n\ndef checkSumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value+=costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(i-ki)+abs(j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz[0:]\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:],costs[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nboard = [int(s) for _ in range(3) for s in input().split()]\nend = [1, 2, 3, 4, 5, 6, 7, 8, 0]\ntable = set()\ndef print_board(board):\n    for i in range(0, 9, 3):\n        print(*board[i:i + 3])\n\ndef swap(q, step_q, step, board):\n    key = tuple(board)\n    if key in table:\n        return\n    else:\n        table.add(key)\n\n    empty = board.index(0)\n    def _swap(q, step_q, step, board, k, s):\n        b = board.copy()\n        b[k], b[s] = b[s], b[k]\n        q.append(b)\n        step_q.append(step + 1)\n\n    if empty % 3 != 2:\n        _swap(q, step_q, step, board, empty, empty + 1)\n    if empty % 3 != 0:\n        _swap(q, step_q, step, board, empty, empty - 1)\n    if empty // 3 < 2:\n        _swap(q, step_q, step, board, empty, empty + 3)\n    if empty // 3 > 0:\n        _swap(q, step_q, step, board, empty, empty - 3)\n\n\nq = deque([board])\nstep_q = deque([0])\n# print_board(board)\nwhile q[0] != end:\n    b = q.popleft()\n    step = step_q.popleft()\n    swap(q, step_q, step, b)\n# print_board(q.popleft())\nprint(step_q.popleft())\n"
  },
  {
    "language": "Python",
    "code": "#codinh -utf8\nimport sys\nimport copy\n\ngoal_state=[1,2,3,4,5,6,7,8,0]\nopen_list=[]    #????????¢?´¢??????????????????????´?\nclosed_list=[]  #??¢?´¢????????????????????????????´?\n\n\ndef getH(a, b): #???????????????????????¢????¨????\n    h2=0\n    i=0\n    for n in a:\n        if n!=-1:   #????????\\??????????????????????????????????????????????????¶????????§????????¢??????????±???????\n            j=b.index(n)\n            dist=j-i\n            dist=abs(dist)  #|i??¨j??????dist|: ??´???????????§????????¢\n            if dist==1:     #?????¢??????????????§?¨???????????????????????????????????????§????????¢?????????\n                if (i==2 and j==3) or (j==2 and i==3) or (i==5 and j==6) or (j==5 and i==6):\n                    dist=3\n            elif dist==3:\n                dist=1\n            elif dist==4:\n                if(i!=2 and j!=6) and (i!=6 and j!=2):\n                    dist=2\n            elif dist==5:\n                dist=3\n            elif dist==6:\n                dist=2\n            elif dist==7:\n                dist=3\n            elif dist==8:\n                dist=4\n            h2+=dist    #?????????????????¢?????????\n        i+=1\n    return  h2  #?????¢??????????????????\n\ndef findChildState(space, std_node):    #???????????????????????????????????????????????????\n    nxt_space=[]    #????????????????????????????????????????????????????´?\n    if space==0:    #?????????????????????????????????????????£?????´???\n        nxt_space.append(space+1)\n        nxt_space.append(space+3)\n    elif space==1:    #???????????????????????????0??????????????????????????£?????´???\n        nxt_space.append(space-1)\n        nxt_space.append(space+1)\n        nxt_space.append(space+3)\n    elif space==2:    #?????????????????????????????????????????£?????´???\n        nxt_space.append(space-1)\n        nxt_space.append(space+3)\n    elif space==3:    #??????????????????????????????????????????????????£?????´???\n        nxt_space.append(space-3)\n        nxt_space.append(space+1)\n        nxt_space.append(space+3)\n    elif space==4:    #????????????????????????????????????????????£?????´???\n        nxt_space.append(space-3)\n        nxt_space.append(space-1)\n        nxt_space.append(space+1)\n        nxt_space.append(space+3)\n    elif space==5:    #??????????????????????????????????????????????????£?????´???\n        nxt_space.append(space-3)\n        nxt_space.append(space-1)\n        nxt_space.append(space+3)\n    elif space==6:    #?????????????????????????????????????????£?????´???\n        nxt_space.append(space-3)\n        nxt_space.append(space+1)\n    elif space==7:    #????????????????????????????????????????????????????????£?????´???\n        nxt_space.append(space-3)\n        nxt_space.append(space-1)\n        nxt_space.append(space+1)\n    elif space==8:    #?????????????????????????????????????????£?????´???\n        nxt_space.append(space-3)\n        nxt_space.append(space-1)\n    child_set=[]\n    for i in nxt_space: #???????????????????????????????????????????????¶???child_state?????????\n        child_state=copy.deepcopy(std_node[3])\n        child_state[space], child_state[i]=child_state[i], child_state[space]\n        child_set.append(child_state)   #chld_set??????????????????????????????????????????????????¶???????????????????´???????\n    return child_set\n\ndef openChildNode(std_node):    #?????¶??????????????????????????????openlist????????????\n    child_set=findChildState(std_node[3].index(0), std_node)   #???????????????????????????????????????\n    del open_list[0]    #??????????????????openlist??????????????????\n    closed_list.append(std_node)    #??????????????????closedlist???????????????\n    for i in child_set:\n        g=std_node[0]+1\n        h=getH(i, goal_state)\n        f=g+h\n        child=(g,h,f,i) #?????????????????????????????°????????\\??????????????£???????????????????????????????????¶???????¨???????child?????????\n        op=list(map(lambda x: i==x[3], open_list))\n        cl=list(map(lambda x: i==x[3], closed_list))\n        if  (True not in op) and (True not in cl):  #openlist??????closedlist????????????????????¨?????????????????¶??????????????´???\n            open_list.append(child) #openlist?????????\n        elif (True in op):  #openlist?????????????????¨?????????????????¶??????????????´???\n            n=op.index(True)\n            if f<open_list[n][2]:   #????????????????????????????????????????????????????°????????????°openlist????????????????????´??°\n                open_list[n]=copy.deepcopy(child)\n        elif (True in cl):  #closedlist?????????????????¨?????????????????¶??????????????´???\n            n=cl.index(True)\n            if f<closed_list[n][2]:   #????????????????????????????????????????????????????°????????????°closedlist??????????????????openlist?????????\n                del closed_list[n]\n                open_list.append(child)\n\ndef updateStandard():   #openlist??????????????????????°???????????????????????????????????¨??????????\n    min=100000000\n    std=()\n    if open_list==[]:   #openlist??????????????´?????¢?´¢??±???\n        return -1\n    for i in open_list: #openlist??????????????????????°????????????????????´¢\n        if i[2]<min:\n            min=i[2]\n            std=copy.deepcopy(i)\n    n=open_list.index(std)  #????????????????°???????????????????????????????????¨????\n    open_list[0], open_list[n]=open_list[n], open_list[0]   #??????????????????openlist?????????????§????\n    return std  #????????????????????????\n\n\na=[]\nfor i in sys.stdin:\n    x=list(map(int, i.split()))\n    for j in x:\n        a.append(j)\n\ng=0     #??????????????§?????????????????°???0\nh=getH(a, goal_state)  #?????\\??????????????£?????????????¨????\nf=g+h   #??´???????????§????¨±???????????????????¨????\nstd_node=(g, h, f, a)   #?????????(??????????????°????????\\??????????????£??????????????????????????????????????¶???)??????????????????????¨????\nopen_list.append(std_node)\n\nwhile 1:\n    if std_node[3]==goal_state: #????????????????????????????????´???????????¶?????¨?????´????????°??¢?´¢??????\n        flag=\"Done\"\n        break\n    openChildNode(std_node) #open_list????????????????????????\n    std=updateStandard()    #openlist?????????????????????f???????°???????????????????\n    if std==-1: #openlist???????????£?????´?????¢?´¢??±???\n        flag=\"Failed\"\n        break\n    std_node=copy.deepcopy(std)    #?????????????????????????????????????°????????????????????????????????¨????\n\n\nif flag==\"Done\":    #??¢?´¢?????????????????´????????´???????????§???????????????????????°??¨????????¶????????¨???\n    print(std_node[0])\nelif flag==\"Failed\":    #??¢?´¢?????±???????????´???????????¨?????????\n    print(\"Search failed\")"
  },
  {
    "language": "Python",
    "code": "import sys\nimport copy\nfrom collections import deque\n\ndef main():\n    s = []\n    for _ in range(3):\n        s+=list(map(int,input().split()))\n    g = [1,2,3,4,5,6,7,8,0]\n    st = set()\n    inf = 1000000007\n    move = [[1,3],\n            [0,2,4],\n            [1,5],\n            [0,4,6],\n            [1,3,5,7],\n            [2,4,8],\n            [3,7],\n            [4,6,8],\n            [5,7]]\n\n    def bfs():\n        k = 0\n        for i in range(9):\n            if s[i]==0:k = i\n        dq = deque()\n        dq.append([s,k,0])\n        st.add(''.join(map(str,s)))\n        while dq:\n            state = dq.popleft()\n            t,i,steps = state[0],state[1],state[2]\n            if t==g:return steps\n            for j in move[i]:\n                u = copy.copy(t)\n                u[i],u[j] = u[j],u[i]\n                if ''.join(map(str,u)) in st:continue\n                dq.append([u,j,steps+1])\n                st.add( ''.join(map(str,u)))\n\n    print (bfs())\n\nif __name__ == '__main__':\n    main()\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN = 3\nm = {8: {7, 5}, 7: {8, 6, 4}, 6: {7, 3}, 5: {8, 4, 2}, 4: {7, 5, 3, 1}, 3: {6, 4, 0}, 2: {5, 1}, 1: {4, 2, 0},\n     0: {3, 1}}\ngoal = 123456780\ndef g(i, j, a):\n    t = a // (10 ** j) % 10\n    return a - t * (10 ** j) + t * (10 ** i)\ndef solve():\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n    start = 8 - MAP.find(\"0\")\n    MAP = int(MAP)\n    if MAP == goal:\n        return 0\n    dp = deque([(0, start, MAP)])\n    LOG = {MAP}\n    while dp:\n        cnt, yx, M = dp.popleft()\n        if M == goal:\n            return cnt\n        cnt += 1\n        for nyx in m[yx]:\n            CM = g(yx, nyx, M)\n            if not CM in LOG:\n                dp.append((cnt, nyx, CM))\n                LOG.add(CM)\ndef MAIN():\n    print(solve())\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+simpleHS(c_puz)) >= depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            heapq.heappush(q,(c_depth+1,_i-1,_j,2,swap_puz))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            heapq.heappush(q,(c_depth+1,_i+1,_j,1,swap_puz))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            heapq.heappush(q,(c_depth+1,_i,_j-1,4,swap_puz))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            heapq.heappush(q,(c_depth+1,_i,_j+1,3,swap_puz))\n\ndef checkPuzIsExisted(puz,q):\n    for i in range(len(q)):\n        exist_puz = q[i][4]\n        count = 0\n        for j in range(len(exist_puz)):\n            if(exist_puz[j] != puz[j]):\n                count = 1\n        if(count == 0):\n            return True\n    return False\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i*3\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque, OrderedDict\nimport copy\n\nclass Puzzle:\n    def __init__(self, field=None, path=''):\n        self.f = field\n        self.space = None\n        for i in range(9):\n            if self.f[i] == 9: self.space = i\n        self.path = path\n\n    def __lt__(self, pzl): # <\n        for i in range(9):\n            if self.f[i] == pzl.f[i]: continue\n            return self.f[i] > pzl.f[i]\n        return False\n\n    def __gt__(self, pzl): # >\n        for i in range(9):\n            if self.f[i] == pzl.f[i]: continue\n            return self.f[i] < pzl.f[i]\n        return False\n\ndx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\ndir = ['u', 'l', 'd', 'r']\n\ndef is_target(pzl):\n    for i in range(9):\n        if pzl.f[i] != i+1:\n            return False\n    return True\n\ndef print_puzzle(pzl):\n    for i, p in enumerate(pzl.f):\n        print(p, '', end='')\n        if i%3 == 2:\n            print('')\n\ndef bfs(pzl):\n    queue = deque([])\n    V = OrderedDict()\n    pzl.path = ''\n    queue.append(pzl)\n    V[pzl] = True\n\n    while len(queue) != 0:\n        u = queue.popleft()\n        if is_target(u): return u.path\n        sx, sy = u.space//3, u.space%3\n        for r in range(4):\n            tx, ty = sx + dx[r], sy + dy[r]\n            if tx < 0 or ty < 0 or tx >= 3 or ty >= 3: continue\n            v = copy.deepcopy(u)\n            v.f[u.space], v.f[tx*3+ty] = v.f[tx*3+ty], v.f[u.space]\n            v.space = tx*3 + ty\n            if v not in V.keys():\n                V[v] = True\n                v.path += dir[r]\n                queue.append(v)\n    return 'unsolvable'\n\nfield = []\nfor i in range(3):\n    field.extend(list(map(int, input().split(' '))))\n\nfor i in range(9):\n    if field[i] == 0: field[i] = 9\n\npzl = Puzzle(field=field)\nans = bfs(pzl)\nprint(len(ans))\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop, heappush\nfrom copy import deepcopy\n\n\nclass Board:\n    def __init__(self, size, nums):\n        self.size = size\n        self.nums = nums\n        self.code = self._code()\n\n    def __eq__(self, other):\n        return self.code == other.code\n\n    def __lt__(self, other):\n        return self.code < other.code\n\n    def __gt__(self, other):\n        return self.code > other.code\n\n    def __hash__(self):\n        nums = tuple(self.nums[i][j]\n                     for i in range(self.size)\n                     for j in range(self.size))\n        return hash(nums)\n\n    def same(self, other):\n        if other is None:\n            return False\n        if self.__class__ != other.__class__:\n            return False\n\n        for i in range(self.size):\n            for j in range(self.size):\n                if self.nums[i][j] != other.nums[i][j]:\n                    return False\n        return True\n\n    def solved(self):\n        for i in range(self.size):\n            for j in range(self.size):\n                if (i, j) != self._validpos(self.nums[i][j]):\n                    return False\n        return True\n\n    def _validpos(self, num):\n        if num > 0:\n            return ((num-1) // self.size, (num-1) % self.size)\n        else:\n            return (self.size-1, self.size-1)\n\n    def _code(self):\n        code = 0\n        for i in range(self.size):\n            for j in range(self.size):\n                if self.nums[i][j] != 0:\n                    vi, vj = self._validpos(self.nums[i][j])\n                    code += abs(vi - i) + abs(vj - j)\n        return code\n\n    def find(self, num):\n        for i in range(self.size):\n            for j in range(self.size):\n                if self.nums[i][j] == num:\n                    return (i, j)\n        raise IndexError()\n\n    def move(self, p1, p2):\n        i1, j1 = p1\n        i2, j2 = p2\n        nums = deepcopy(self.nums)\n        nums[i1][j1], nums[i2][j2] = nums[i2][j2], nums[i1][j1]\n        return self.__class__(self.size, nums)\n\n    def moves(self):\n        i, j = self.find(0)\n        if i > 0:\n            yield self.move((i, j), (i-1, j))\n        if j > 0:\n            yield self.move((i, j), (i, j-1))\n        if i < self.size-1:\n            yield self.move((i, j), (i+1, j))\n        if j < self.size-1:\n            yield self.move((i, j), (i, j+1))\n\n    def __str__(self):\n        s = ''\n        for i in range(self.size):\n            for j in range(self.size):\n                s += ' {}'.format(self.nums[i][j])\n            s += '\\n'\n        return s\n\n\nclass EightPuzzle:\n    def __init__(self, board):\n        self.board = Board(3, board)\n        self.steps = 0\n\n        if not self.board.solved():\n            self._solve()\n\n    def _solve(self):\n        bs = []\n        checked = {}\n        heappush(bs, (self.board, 0))\n\n        while len(bs) > 0:\n            b, step = heappop(bs)\n            if 0 < self.steps <= step:\n                continue\n            checked[b] = step\n            for nb in b.moves():\n                if nb.solved():\n                    if self.steps == 0 or step < self.steps:\n                        self.steps = step+1\n                elif nb in checked and checked[nb] <= step:\n                    continue\n                else:\n                    heappush(bs, (nb, step+1))\n\n\ndef run():\n    board = []\n    for i in range(3):\n        board.append([int(i) for i in input().split()])\n\n    eight_puzzle = EightPuzzle(board)\n    print(eight_puzzle.steps)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nfrom collections import deque\nimport copy\n\nclass Puzzle(list):\n    def __init__(self, size):\n        list.__init__(self)\n        self.size = size\n        self.space = None\n        self.path = \"\"\n    \n    def __hash__(self):\n        return hash(str(self))\n\nif __name__ == '__main__':\n    \n    N = 3\n    N2 = 9\n    dx = [-1, 0, 1, 0]\n    dy = [0, -1, 0, 1]\n    d = [\"u\", \"l\", \"d\", \"r\"]\n\n    p = Puzzle(N2)\n    for i in range(N):\n        p += [int(x) for x in input().split()]\n    for i in range(N2):\n        if p[i] == 0:\n            p[i] = N2\n            p.space = i\n    def isTarget(p):\n        for i in range(N2):\n            if p[i] != i+1:\n                return False\n        return True\n\n    def bfs(s):\n        cnt = 0\n        Q = deque()\n        V = set()\n        Q.append(s)\n        V.add(s)\n        while Q:\n            cnt += 1\n            u = Q.popleft()\n            if isTarget(u):\n                return u.path\n            sx = u.space // N\n            sy = u.space % N\n            for r in range(4):\n                tx = sx + dx[r]\n                ty = sy + dy[r]\n                if tx < 0 or ty < 0 or tx >= N or ty >= N:\n                    continue\n                v = copy.deepcopy(u)\n                v[u.space], v[tx * N + ty] = v[tx * N + ty], v[u.space]\n                v.space = tx * N + ty\n                if not v in V:\n                    V.add(v)\n                    v.path += d[r]\n                    Q.append(v)\n\n        return \"unsolvable\"\n\n    ans = bfs(p)\n    print(len(ans))\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque, OrderedDict\nimport copy\n\nclass Puzzle:\n    def __init__(self, field=None, path=''):\n        self.f = field\n        self.space = None\n        for i in range(9):\n            if self.f[i] == 9: self.space = i\n        self.path = path\n\n    def __lt__(self, pzl): # <\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] > pzl.f[i]\n        return False\n\n    def __gt__(self, pzl): # >\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] < pzl.f[i]\n        return False\n\ndx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\ndir = ['u', 'l', 'd', 'r']\n\ndef is_target(pzl):\n    for i in range(9):\n        if pzl.f[i] != i+1:\n            return False\n    return True\n\ndef print_puzzle(pzl):\n    for i, p in enumerate(pzl.f):\n        print(p, '', end='')\n        if i%3 == 2:\n            print('')\n\ndef bfs(pzl):\n    queue = deque([])\n    V = OrderedDict()\n    pzl.path = ''\n    queue.append(pzl)\n    V[pzl] = True\n    if is_target(pzl): return u.path\n\n    while len(queue) != 0:\n        u = queue.popleft()\n        sx, sy = u.space//3, u.space%3\n        for r in range(4):\n            tx, ty = sx + dx[r], sy + dy[r]\n            if tx < 0 or ty < 0 or tx >= 3 or ty >= 3:\n                continue\n            v = copy.deepcopy(u)\n            v.f[u.space], v.f[tx*3+ty] = v.f[tx*3+ty], v.f[u.space]\n            v.space = tx*3 + ty\n            if v not in V.keys():\n                V[v] = True\n                v.path += dir[r]\n                if is_target(v):\n                    return v.path\n                queue.append(v)\n    return 'unsolvable'\n\nfield = []\nfor i in range(3):\n    field.extend(list(map(int, input().split(' '))))\n\nfor i in range(9):\n    if field[i] == 0: field[i] = 9\n\npzl = Puzzle(field=field)\nans= bfs(pzl)\nprint(len(ans))\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import copy\n\ndef movable_state(state):\n    x, y = None, None\n    for i in range(3):\n        for j in range(3):\n            if state[i][j] == 0:\n                x, y = i, j\n                break\n\n    rsts = []\n    for r, c in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:\n        if 0 <= r and r < 3 and 0 <= c and c < 3:\n            rst = copy.deepcopy(state)\n            rst[x][y], rst[r][c] = rst[r][c], rst[x][y]\n            rsts.append(rst)\n    return rsts\n\ndef hist_check(state, depth):\n    for i in range(depth-1):\n        for hist in state_history[i]:\n            if hist == state:\n                return True\n    return False\n\npuzzle = [list(map(int, input().split(' '))) for i in range(3)]\nstate_history = [[puzzle]]\n\ngoal = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\nexchange_num = 0\ndepth = 0\nstill_not = True\nwhile still_not:\n    depth += 1\n    state_history.append([])\n    for hist in state_history[depth-1]:\n        next_states = movable_state(hist)\n        for next_stat in next_states:\n            if hist_check(next_stat, depth): continue\n            if next_stat == goal:\n                still_not = False\n                break\n            state_history[depth].append(next_stat)\n        if not still_not: break\nprint(depth)\n\n"
  },
  {
    "language": "Python",
    "code": "import copy\nimport functools as ft\nN = 3\n\n\ndef solved(game):\n    for i in range(N):\n        for j in range(N):\n            if (game[i][j] - 1) != i * N + j and game[i][j] != 0:\n                return False\n    return True\n\ndef debug_game(game):\n    for i in range(N):\n        print(ft.reduce(lambda x,y: x + str(y) + \" \", game[i], \"\"))\n\ndef convert_code(game):\n    hash_code = \"\"\n    for i in range(N):\n        hash_code = hash_code + ft.reduce(lambda x,y: x + str(y), game[i], \"\")\n    return hash_code\n\ndef calc_cost(game):\n    cost = 0\n    for i in range(N):\n        for j in range(N):\n            if game[i][j] != 0:\n                ideal = (int((game[i][j] - 1) / N), (game[i][j] - 1) % N)\n                cost += abs(i - ideal[0]) + abs(j - ideal[1])\n            else:\n                cost += abs(i - (N-1)) + abs(j - (N-1))\n\n    return cost\n\ngames = []\nclosed = []\ninit = [[] for i in range(N)]\n\nfor i in range(N):\n    init[i] = [int(item) for item in input().split()]\n    for j in range(N):\n        if init[i][j] == 0:\n            #queue.put((i, j))\n            zero = (i, j)\n\ngames = games + [(init, zero, calc_cost(init), 0)]\ndirection = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n\nwhile len(games) > 0:\n    current = games.pop(0)\n    zero = current[1]\n    #print(\"Depth: \"+str(current[3]) + \" Cost: \"+str(current[2]))\n    #debug_game(current[0])\n    closed = closed + [convert_code(current[0])]\n\n    if solved(current[0]):\n        print(current[3])\n        break\n\n    for d in direction :\n        next_step = (zero[0] + d[0], zero[1] + d[1])\n        if next_step[0] >= 0 and next_step[0] <= 2 and next_step[1] >= 0 and next_step[1] <= 2:\n\n            tmp = copy.deepcopy(current[0])\n            tmp[zero[0]][zero[1]], tmp[next_step[0]][next_step[1]] = tmp[next_step[0]][next_step[1]], tmp[zero[0]][zero[1]]\n            tmp_cost = calc_cost(tmp)\n            hash_code = convert_code(tmp)\n            if not hash_code in closed:\n                #print(hash_code)\n                games = games + [(tmp, next_step, tmp_cost, current[3]+1)]\n\n    games.sort(key=lambda x: x[2] + x[3])\n"
  },
  {
    "language": "Python",
    "code": "import copy\ndef decision(a):\n    #print(a)\n    #print(data)\n    #print(count)\n    if a == 123456789:\n        print(count)\n        exit()\n    if a in data:\n        pass\n    else:\n        data[a] = 1\n        kariokiba.append(a)\n        #print(a)\n        #print(data)\n\n\ndef str_create(i, j, h):\n    h = h[:i] + h[j] + h[i+1:j] + h[i] + h[j+1:]\n    #print(h)\n    decision(int(h))\n\n\ndef create(a):\n    #print(a)\n    a = str(a)\n    place = a.find('9')\n    #print(place)\n    b = c = d = e = a\n    if place == 0:\n        str_create(0, 1, b)\n        str_create(0, 3, c)\n    elif place == 1:\n        str_create(0, 1, b)\n        str_create(1, 2, c)\n        str_create(1, 4, d)\n    elif place == 2:\n        str_create(1, 2, b)\n        str_create(2, 5, c)\n    elif place == 3:\n        str_create(0, 3, b)\n        str_create(3, 4, c)\n        str_create(3, 6, d)\n    elif place == 4:\n        str_create(1, 4, b)\n        str_create(3, 4, c)\n        str_create(4, 5, d)\n        str_create(4, 7, e)\n    elif place == 5:\n        str_create(2, 5, b)\n        str_create(4, 5, c)\n        str_create(5, 8, d)\n    elif place == 6:\n        str_create(3, 6, b)\n        str_create(6, 7, c)\n    elif place == 7:\n        str_create(6, 7, b)\n        str_create(4, 7, c)\n        str_create(7, 8, d)\n    elif place == 8:\n        str_create(5, 8, b)\n        str_create(7, 8, c)\n\n\n\ntmp0 = [list(map(int, input().split())) for _ in range(3)]\ndata = {}\ntmp1 = 0\nkariokiba = []\nkariokiba1 = []\nfor i in tmp0:\n    for j in i:\n        if j == 0:\n            j = 9\n        tmp1 *= 10\n        tmp1 += j\ndata[tmp1] = 1\n#print(data)\n#print(tmp1)\ntmp1 = str(tmp1)\ncount = 0\nkariokiba.append(int(tmp1))\n\nif tmp1 == '123456789':\n    print(0)\n    exit()\n'''\ncreate(tmp1)\nprint(kariokiba)\n#print(data)\n\n'''\nwhile True:\n    #print(kariokiba)\n    kariokiba1 = copy.deepcopy(kariokiba)\n    kariokiba.clear()\n    count += 1\n    #print(count)\n    #print(data)\n    for i in kariokiba1:\n        create(i)\n\n\n"
  },
  {
    "language": "Python",
    "code": "# coding=utf-8\nimport heapq as hq\n\ndef next_board(board, space, prev):\n    for nxt in adjacent[space]:\n        if nxt == prev:\n            continue\n        b = board.copy()\n        b[space], b[nxt] = b[nxt], 0\n        yield b, nxt\n\ndef search(start):\n    FORE = 1\n    BACK = -1\n\n    table = {}\n    table[tuple(start)] = (FORE, 0)\n    table[tuple(goal)] = (BACK, 0)\n\n    heap = [(0, start, start.index(0), None, FORE), (0, goal, goal.index(0), None, BACK)]\n\n    while heap:\n        i, board, space, prev, direction = hq.heappop(heap)\n        i += 1\n        for b, nxt in next_board(board, space, prev):\n            key = tuple(b)\n            if key in table:\n                if table[key][0] != direction:\n                    return table[key][1] + i\n            table[key] = (direction, i)\n            hq.heappush(heap, (i, b, b.index(0), nxt, direction))\n\nadjacent = (\n    (1, 3),\n    (0, 2, 4),\n    (1, 5),\n    (0, 4, 6),\n    (1, 3, 5, 7),\n    (2, 4, 8),\n    (3, 7),\n    (4, 6, 8),\n    (5, 7),\n)\ngoal = [1, 2, 3, 4, 5, 6, 7, 8, 0]\nstart = []\n\nfor _ in range(3):\n    x = list(map(int, input().split()))\n    start += x\n\nprint(search(start))"
  },
  {
    "language": "Python",
    "code": "import sys\nimport queue\n\nN = 3\nf= ''.join(sys.stdin.readline().split())\nf+= ''.join(sys.stdin.readline().split())\nf+= ''.join(sys.stdin.readline().split())\n\ndd = [[-1, 0], [0, -1], [1, 0], [0, 1]]\n\nQ = queue.Queue()\nV = dict()\n\nQ.put([f,f.index('0'),0])\nV[f] = True\n\nwhile not Q.empty():\n    u = Q.get()\n    if u[0] == '123456780':  break\n    sx, sy = u[1]//N, u[1]%N\n    for dx, dy in dd:\n        tx, ty = sx+dx, sy+dy\n        if tx<0 or ty<0 or tx>=N or ty>=N: continue\n        v = u[:]\n        n1, n2 = u[1], tx*N+ty\n        v[1] = n2\n        if n1>n2: n1, n2 = n2, n1\n        v[0] = v[0][0:n1]+v[0][n2]+v[0][n1+1:n2]+v[0][n1]+v[0][n2+1:]\n        if not V.get(v[0], False):\n            V[v[0]] = True\n            v[2] += 1                                                    \n            Q.put(v)\n\nprint(u[2])\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz,costs):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or (c_depth+checkSumCost(costs)) > depth):\n        return\n\n    if(i != 0 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i-1,j)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[(i-1)*3+j] = HS(i-1,j,_c_puz[(i-1)*3+j])\n        iterative(i-1,j,c_depth+1,_c_puz[0:],_costs[0:])\n    if(i != 2 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i+1,j)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[(i+1)*3+j] = HS(i+1,j,_c_puz[(i+1)*3+j])\n        iterative(i+1,j,c_depth+1,_c_puz[0:],_costs[0:])\n    if(j != 0 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i,j-1)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[i*3+j-1] = HS(i,j-1,_c_puz[i*3+j]-1)\n        iterative(i,j-1,c_depth+1,_c_puz[0:],_costs[0:])\n    if(j != 2 and finding != 1):\n        _c_puz = swapPuz(c_puz[0:],i,j,i,j+1)\n        _costs = costs[0:]\n        _costs[i*3+j] = HS(i,j,_c_puz[i*3+j])\n        _costs[i*3+j+1] = HS(i,j+1,_c_puz[i*3+j+1])\n        iterative(i,j+1,c_depth+1,_c_puz[0:],_costs[0:])\n\ndef checkSumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value+=costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(i-ki)+abs(j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz[0:]\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i*3\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:],costs[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import heapq\n\ndef d_manhattan(node_list):\n    s = 0\n    for i in range(9):\n        x_goal = i%3\n        y_goal = i//3\n        x_now = (node_list[i] - 1)%3\n        y_now = (node_list[i] - 1)//3\n        if y_now == -1:\n            y_now = 2\n        dx = abs(x_now - x_goal)\n        dy = abs(y_now - y_goal)\n        s += dx + dy\n    return s\n\ndef moveNodeE(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 1] = node_tmp[space + 1], node_tmp[space]\n    return node_tmp\ndef moveNodeW(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 1] = node_tmp[space - 1], node_tmp[space]\n    return node_tmp\ndef moveNodeN(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 3] = node_tmp[space - 3], node_tmp[space]\n    return node_tmp\ndef moveNodeS(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 3] = node_tmp[space + 3], node_tmp[space]\n    return node_tmp\n\nclass board:\n    def __init__(self, node_list, g):\n        self.node = node_list\n        self.space = node_list.index(0)\n        self.g = g\n        self.h = d_manhattan(node_list)\n        self.f = self.g + self.h\n\n    def makeBoard(self):\n        space = self.space\n        cost_now = self.f\n        x_s = space%3\n        y_s = space//3\n        if x_s < 2:\n            node_tmp = moveNodeE(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if x_s > 0:\n            node_tmp = moveNodeW(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s < 2:\n            node_tmp = moveNodeS(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s > 0:\n            node_tmp = moveNodeN(self.node, space)\n            yield board(node_tmp, self.g + 1)\n\nb_open = []\nn_close = {}\nn_goal = [1,2,3,4,5,6,7,8,0]\nn_start = []\n\nfor i in range(3):\n    inp = list(map(int, raw_input().split()))\n    n_start.extend(inp)\n\nb_start = board(n_start, 0)\nheapq.heappush(b_open, (b_start.f, b_start.h, 0, b_start))\n\ni = 0\nwhile b_open:\n    _, _, _, b_now = heapq.heappop(b_open)\n    if b_now.node == n_goal:\n        b_goal = b_now\n        break\n    n_close[\"\".join(map(str, b_now.node))] = i\n    for b_new in b_now.makeBoard():\n        if \"\".join(map(str, b_new.node)) in n_close:\n            continue\n        heapq.heappush(b_open, (b_new.f, b_new.h, i, b_new))\n        i += 1\n\nprint(b_goal.g)"
  },
  {
    "language": "Python",
    "code": "import time\nimport math\n\nclass Node:\n    def __init__(self, board, parent, fValue, depth):\n        self.board = board\n        self.parent = parent\n        self.fValue = fValue\n        self.depth = depth\n\n    def __eq__(self, other):\n        return self.board == other.board\n\n    def __lt__(self, other):\n        return self.fValue < other.fValue\n\n    def __hash__(self):\n        return hash(self.board)\n\n    def __bool__(self):\n        return True\n\nclass Board:\n    # The 8-puzzle board representation #\n    def __init__(self, matrix):\n        self.matrix = matrix\n\n        for i in range(len(matrix)):\n            if 0 in matrix[i]:\n                self.blankPos = (i, matrix[i].index(0))\n\n    def __str__(self):\n        s = \"\"\n        for i in range(len(self.matrix)):\n            s += str(self.matrix[i]) + \"\\n\"\n        return s + \"\\n\"\n\n    def __eq__(self, other):\n        otherMatrix = other.matrix\n        thisMatrix = self.matrix\n\n        if len(thisMatrix) != len(otherMatrix):\n            return False\n        for i in range(len(thisMatrix)):\n            if len(thisMatrix[i]) != len(otherMatrix[i]):\n                return False\n            for j in range(len(thisMatrix[i])):\n                if thisMatrix[i][j] != otherMatrix[i][j]:\n                    return False\n        return True\n\n    def duplicate(self):\n        newMatrix = []\n        for i in range(len(self.matrix)):\n            newMatrix.append([])\n            for j in range(len(self.matrix[i])):\n                newMatrix[i].append(self.matrix[i][j])\n        return Board(newMatrix)\n\n    def findElement(self, elem):\n        for i in range(len(self.matrix)):\n            for j in range(len(self.matrix[i])):\n                if self.matrix[i][j] == elem:\n                    return (i, j)\n        return None\n\n    def slideBlank(self, dir):\n        # dir is a tuple (deltaY,deltaX)\n        if dir not in [(0, 1), (0, -1), (-1, 0), (1, 0)]:\n            raise ValueError(\"Invalid dir\")\n        newBlankPos = (self.blankPos[0] + dir[0], self.blankPos[1] + dir[1])\n        if newBlankPos[0] < 0 or newBlankPos[0] > len(self.matrix) - 1:\n            return None\n        elif newBlankPos[1] < 0 or newBlankPos[1] > len(self.matrix[0]) - 1:\n            return None\n        else:\n            newBoard = self.duplicate()\n            saveVal = newBoard.matrix[self.blankPos[0] + dir[0]][self.blankPos[1] + dir[1]]\n            newBoard.matrix[self.blankPos[0] + dir[0]][self.blankPos[1] + dir[1]] = 0\n            newBoard.matrix[self.blankPos[0]][self.blankPos[1]] = saveVal\n            newBoard.blankPos = (self.blankPos[0] + dir[0], self.blankPos[1] + dir[1])\n            return newBoard\n\n    def __hash__(self):\n        s = 0\n        for i in range(len(self.matrix)):\n            for j in range(len(self.matrix[i])):\n                s *= 10\n                s += self.matrix[i][j]\n\n        return s\n\n\ndef fastSearch(frontier, goalBoard, explored):\n    curNode = frontier.pop(0)\n    explored.add(curNode)\n    if curNode.board == goalBoard:\n        print(curNode.depth)\n        return True\n    aStarExpansion(curNode, frontier, goalBoard, explored)\n    return False\n\n\ndef fastSearchClient(board, goalBoard):\n    frontier = [Node(board, None, heuristic(board, goalBoard), 0)]\n    explored = set()\n\n    limit = 0\n\n    while (limit < 1000):\n        retval = fastSearch(frontier, goalBoard, explored)\n        if retval:\n            return\n        limit += 1\n    return\n\ndef aStarExpansion(currentNode, frontier, goalBoard, explored):\n    sideLength = len(currentNode.board.matrix)\n    pos = currentNode.board.blankPos\n    depth = currentNode.depth + 1\n    toInsert = []\n\n    # if we can move there, make a node and put it in toInsert\n    if pos[0] != 0:\n        upCost = depth + heuristic(currentNode.board.slideBlank((-1, 0)), goalBoard)\n        upNode = Node(currentNode.board.slideBlank((-1, 0)), currentNode, upCost, depth)\n        toInsert.append(upNode)\n    if pos[0] != sideLength - 1:\n        downCost = depth + heuristic(currentNode.board.slideBlank((1, 0)), goalBoard)\n        downNode = Node(currentNode.board.slideBlank((1, 0)), currentNode, downCost, depth)\n        toInsert.append(downNode)\n    if pos[1] != 0:\n        leftCost = depth + heuristic(currentNode.board.slideBlank((0, -1)), goalBoard)\n        leftNode = Node(currentNode.board.slideBlank((0, -1)), currentNode, leftCost, depth)\n        toInsert.append(leftNode)\n    if pos[1] != sideLength - 1:\n        rightCost = depth + heuristic(currentNode.board.slideBlank((0, 1)), goalBoard)\n        rightNode = Node(currentNode.board.slideBlank((0, 1)), currentNode, rightCost, depth)\n        toInsert.append(rightNode)\n\n    # if we've already been there, we don't want to try that board again\n    for node in explored:\n        for insertNode in toInsert:\n            if insertNode == node:\n                toInsert.remove(insertNode)\n\n    # now we are putting the nodes to be inserted into the correct place in frontier\n    for node in toInsert:\n        for i in range(len(frontier) + 1):\n            if i == len(frontier):\n                frontier.append(node)\n                break\n            if frontier[i] > node:\n                frontier.insert(i, node)\n                break\n\ndef heuristic(currentBoard, goalBoard):\n    currentMatrix = currentBoard.matrix\n    sum = 0\n\n    for i in range(len(currentMatrix)):\n        for j in range(len(currentMatrix[i])):\n            cur = currentMatrix[i][j]\n\n            if cur % 3 == 0:\n                curx = 3\n            else:\n                curx = cur % 3\n\n            if cur != 0:\n                sum += abs(curx - (j + 1)) + abs(math.ceil(cur / 3) - (i + 1))\n\n    return sum\n\narr = [[1 for i in range(3)] for j in range(3)]\n\nfor i in range(3):\n    arr[i][0], arr[i][1], arr[i][2] = input().split()\n\n\nfor i in range(3):\n    for j in range(3):\n        arr[i][j] = int(arr[i][j])\n\nfastSearchClient(Board(arr), Board([[1, 2, 3], [4, 5, 6], [7, 8, 0]]))\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(sumcost,(0,i,j,0,puz)))\n    global finding\n\n    while len(q):\n        cost, items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        _sum_cost = cost - c_depth\n        if(_sum_cost == 0):\n            finding = 1\n            print(c_depth)\n            break\n        if(cost > depth):\n            continue\n\n        c_cost = HS(_i,_j,c_puz[_i*3+_j])\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            n_cost = cost+1+checkCost(c_cost,HS(_i-1,_j,c_puz[(_i-1)*3+_j]),HS(_i,_j,swap_puz[_i*3+_j]),HS(_i-1,_j,swap_puz[(_i-1)*3+_j]))\n            if(n_cost <= depth):\n                heapq.heappush(q,(n_cost,(c_depth+1,_i-1,_j,2,swap_puz)))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            n_cost = cost+1+checkCost(c_cost,HS(_i+1,_j,c_puz[(_i+1)*3+_j]),HS(_i,_j,swap_puz[_i*3+_j]),HS(_i+1,_j,swap_puz[(_i+1)*3+_j]))\n            if(n_cost <= depth):\n                heapq.heappush(q,(n_cost,(c_depth+1,_i+1,_j,1,swap_puz,)))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            n_cost = cost+1+checkCost(c_cost,HS(_i,_j-1,c_puz[_i*3+_j-1]),HS(_i,_j,swap_puz[_i*3+_j]),HS(_i,_j-1,swap_puz[_i*3+_j-1]))\n            if(n_cost <= depth):\n                heapq.heappush(q,(n_cost,(c_depth+1,_i,_j-1,4,swap_puz)))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            n_cost = cost+1+checkCost(c_cost,HS(_i,_j+1,c_puz[_i*3+_j+1]),HS(_i,_j,swap_puz[_i*3+_j]),HS(_i,_j+1,swap_puz[_i*3+_j+1]))\n            if(n_cost <= depth):\n                heapq.heappush(q,(n_cost,(c_depth+1,_i,_j+1,3,swap_puz)))\n\ndef checkCost(c_cost,m_cost,c2_cost,m2_cost):\n    return c2_cost - c_cost + m2_cost - m_cost\n\ndef sumCost(puz):\n    value = 0\n    for i in range(3):\n        value += HS(i,0,puz[i*3])\n        value += HS(i,1,puz[i*3+1])\n        value += HS(i,2,puz[i*3+2])\n    return value\n\ndef HS(i,j,num):\n    if(num != 0):\n        k = num-1\n    else:\n        k = 8\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(i-ki)+abs(j-kj)\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nsumcost = sumCost(puz)\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or (c_depth+HS(c_puz)) > depth):\n        return\n\n    if(i != 0):\n        iterative(i-1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i-1,j))\n    if(i != 2):\n        iterative(i+1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i+1,j))\n    if(j != 0):\n        iterative(i,j-1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j-1))\n    if(j != 2):\n        iterative(i,j+1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j+1))\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(c_puz):\n    value = 0\n    for i in range(len(c_puz)):\n        k = correctPuz.index(c_puz[i])\n        _i = (int)(i/3)\n        _j = i - _i\n        ki = (int)(k/3)\n        kj = k - ki\n        value = abs(_i-ki)+abs(_j-kj) \n\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = HS(puz)\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef char Board[10];\nBoard ini_board, board, *history;\nconst Board target = \"123456780\";\nint nhistories=0;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  char pos;\n  char dir;\n} Motion;\n\nint minstep;\n\nconst Motion motion[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nint search_path(int step, char space)\n{\n  int i, j;\n  if (strcmp(board, \"123456780\")==0) {\n    //    printf(\"STEP=%d\\n\", step);                                                 \n    //printf(\"%d\\n\", step);                                                          \n    if (step<minstep) minstep=step;\n    printf(\"%d\\n\", step);\n    exit(0);\n  } else {\n    if (step>=minstep) return 1;\n    if (step>0 && strcmp(board, ini_board)==0) return 1;\n\n    Board board_bak;\n    strcpy(board_bak, board);\n    int nhistories_bak=nhistories;\n\n   for (i=0; motion[space][i].pos>=0; i++) {\n      Motion m = motion[space][i];\n\n      if (m.pos==0 && board[0]=='1') continue;\n      if ((m.pos==1||m.pos==2) && board[0]=='1'&&board[1]=='2'&&board[2]=='3') conti\\\nnue;\n      if ((m.pos==3||m.pos==6) && board[0]=='1'&&board[3]=='4'&&board[6]=='7')contin\\\nue;\n      switch (m.dir) {\n      case U:\n        if (m.pos<3) continue;\n        board[m.pos-3] = board[m.pos];\n        break;\n      case D:\n        if (m.pos>5) continue;\n        board[m.pos+3] = board[m.pos];\n        break;\n      case L:\n        if (m.pos%3==0) continue;\n        board[m.pos-1] = board[m.pos];\n        break;\n      case R:\n        if (m.pos%3==2) continue;\n        board[m.pos+1] = board[m.pos];\n        break;\n      }\n      board[m.pos] = '0';\n\n      for (j=0; j<nhistories; j++) {\n        if (strcmp(board, history[j])==0)     break;\n      }\n      if (j==nhistories) {\n        strcpy(history[nhistories++], board);\n        search_path(step+1, m.pos);\n      }\n      nhistories = nhistories_bak;\n      strcpy(board, board_bak);\n    }\n  }\n  return 1;\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board[0],&board[1],&board[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[3],&board[4],&board[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[6],&board[7],&board[8]);\n  strcpy(ini_board, board);\n  for (minstep=1; minstep<32; minstep++) {\n    strcpy(board, ini_board);\n    history = (Board*)malloc(sizeof(Board)*100000);\n    search_path(0, strchr(board, '0')-board);\n    free(history);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "Python",
    "code": "import queue\nadjacent=((1,3), (0,2,4), (1,5), (0,4,6), (1,3,5,7), (2,4,8), (3,7), (4,6,8), (5,7))\n \nclass State:\n    def __init__(self, board, space, prev):\n        self.board = board\n        self.space = space\n        self.prev = prev\n \ndef bf_search(start, GOAL):\n    q = queue.Queue()\n    q.put(State(start, start.index(0), None))\n    table = {}\n    table[tuple(start)] = True\n    while not q.empty():\n        a = q.get()\n        for x in adjacent[a.space]:\n            b = a.board[:]\n            b[a.space] = b[x]\n            b[x] = 0\n            key = tuple(b)\n            if key in table: continue\n            c = State(b,x,a)\n            if b == GOAL:\n                return print_answer(c)\n            q.put(c)\n            table[key] = True\n \ncnt = -1\ndef print_answer(x):\n    global cnt\n    if x is not None:\n        cnt += 1\n        print_answer(x.prev)\n    return str(cnt)\n \nGOAL = [1,2,3,4,5,6,7,8,0]\nstart = []\nfor i in range(3):\n x,y,z = map(int, input().split())\n start += [x,y,z]\n\nif start == GOAL:\n    print(\"0\")\nelse:\n    print(bf_search(start, GOAL))"
  },
  {
    "language": "Python",
    "code": "# 8 Puzzle\nimport copy\nz = 0\n[N, d] = [3, 0]\ncheck_flag = [[1, 2, 3, 4,  1, 2, 3, 4,  1, 2, 3, 4],\n              [2, 3, 4, 1,  2, 3, 4, 1,  2, 3, 4, 1],\n              [3, 4, 1, 2,  3, 4, 1, 2,  3, 4, 1, 2],\n              [4, 1, 2, 3,  4, 1, 2, 3,  4, 1, 2, 3],\n              [3, 2, 1, 4,  3, 2, 1, 4,  3, 2, 1, 4],\n              [2, 1, 4, 3,  2, 1, 4, 3,  2, 1, 4, 3],\n              [1, 4, 3, 2,  1, 4, 3, 2,  1, 4, 3, 2],\n              [4, 3, 2, 1,  4, 3, 2, 1,  4, 3, 2, 1]]\n\nstart = []\ngoal = [[i + j*N for i in range(1, N + 1)] for j in range(N)]\ngoal[2][2] = 0\nfor i in range(N):\n    start.append(list(map(int, input().split())))\n\n\ndef manhattan(value, pairs):\n    h = 0\n\n    if value == 1:\n        h = (pairs[0] + pairs[1])\n    if value == 2:\n        h = (pairs[0] + abs(pairs[1] - 1))\n    if value == 3:\n        h = (pairs[0] + abs(pairs[1] - 2))\n    \n    if value == 4:\n        h = (abs(pairs[0] - 1) + pairs[1])\n    if value == 5:\n        h = (abs(pairs[0] - 1) + abs(pairs[1] - 1)) \n    if value == 6:\n        h = (abs(pairs[0] - 1) + abs(pairs[1] - 2))\n        \n    if value == 7:\n        h = (abs(pairs[0] - 2) + pairs[1])      \n    if value == 8:\n        h = (abs(pairs[0] - 2) + abs(pairs[1] - 1))\n        \n    return h\n\ndef flag_array(flag, input):\n\n    flag.pop(0)\n    flag.append(input)\n    return flag\n\n\ns_h = 0\nfor i in range(N):\n    for j in range(N):\n        s_h += manhattan(start[i][j], [i, j])\n\n# print(s_h)\n\nfor i in range(N):\n        check = start[i].count(0)\n        if check != 0:\n            [s_r, s_c] = [i, start[i].index(0)]\n            break\n        if i == 3:\n            print(\"Error\")\n\nwhile True:\n    d += 1\n    queue = []\n    flag = [0 for i in range(12)]\n    queue.append([s_h, start, 0, [s_r, s_c], flag])\n\n    #while True:\n    while len(queue) != 0:\n        #print(\"Q: \", len(queue), \"depth: \", d)\n        short_n = queue.pop(0)\n        h = short_n[0] - short_n[2]\n        state = short_n[1]\n        g = short_n[2]\n        [r, c] = short_n[3]\n        flag = short_n[4]\n        #print(\"left_Q: \", len(queue), \"depth: \", d, \"h: \", h, \"g: \", g, \"state: \", state, \"g+h: \", short_n[0], \"flag: \", flag[len(flag) - 1])\n        #print(\"left_Q: \", len(queue), \"depth: \", d, \"h: \", h, \"g: \", g, \"flag: \", flag, \"g+h: \", short_n[0])\n        #if d == 1:\n            #print(short_n[0])\n            #print(state)\n            #print(g)\n\n        if h == 0:\n            print(short_n[2])\n            #print(z)\n            break\n        \"\"\"\n        if flag in check_flag:\n            z += 1\n            continue\n        \"\"\"\n        if r - 1 >= 0 and flag[len(flag) - 1] != 3:\n            [temp, temp_array] = [copy.deepcopy(state), flag[:]]\n            h = short_n[0] - short_n[2] - manhattan(temp[r - 1][c], [r - 1, c]) + manhattan(temp[r - 1][c], [r, c])\n            [temp[r][c], temp[r - 1][c]] = [temp[r - 1][c], temp[r][c]]\n            #if temp[r][c] != goal[r][c]:\n            #[r, c] = [r - 1, c]\n            #if temp\n            #h = manhattan(temp)\n            #print(\"1: \", h, temp)\n            if g + 1 + h <= d:\n                queue.append([h + g + 1, temp, g + 1, [r - 1, c], flag_array(temp_array, 1)])\n        \n        if c + 1 < N and flag[len(flag) - 1] != 4:\n            #print(\"2: \")\n            [temp, temp_array] = [copy.deepcopy(state), flag[:]]\n            #temp_array = copy.deepcopy(flag)\n            h = short_n[0] - short_n[2] - manhattan(temp[r][c + 1], [r, c + 1]) + manhattan(temp[r][c + 1], [r, c])\n            [temp[r][c], temp[r][c + 1]] = [temp[r][c + 1], temp[r][c]]\n            #queue.append(calculate(temp, g + 1))\n            #print(\"2: \", h, temp)\n            if g + 1 + h <= d:\n                queue.append([h + g + 1, temp, g + 1, [r, c + 1], flag_array(temp_array, 2)])\n\n        if r + 1 < N and flag[len(flag) - 1] != 1:\n            #print(\"3: \")\n            [temp, temp_array] = [copy.deepcopy(state), flag[:]]\n            #temp_array = copy.deepcopy(flag)\n            h = short_n[0] - short_n[2] - manhattan(temp[r + 1][c], [r + 1, c]) + manhattan(temp[r + 1][c], [r, c])\n            [temp[r][c], temp[r + 1][c]] = [temp[r + 1][c], temp[r][c]]\n            #queue.append(calculate(temp, g + 1))\n            #print(\"3: \", h, temp)\n            if g + 1 + h <= d:\n                queue.append([h + g + 1, temp, g + 1, [r + 1, c], flag_array(temp_array, 3)])\n        \n        if c - 1 >= 0 and flag[len(flag) - 1] != 2:\n            #print(\"4: \")\n            [temp, temp_array] = [copy.deepcopy(state), flag[:]]\n            h = short_n[0] - short_n[2] - manhattan(temp[r][c - 1], [r, c - 1]) + manhattan(temp[r][c - 1], [r, c])\n            [temp[r][c], temp[r][c - 1]] = [temp[r][c - 1], temp[r][c]]\n            if g + 1 + h <= d:\n                queue.append([h + g + 1, temp, g + 1, [r, c - 1], flag_array(temp_array, 4)])\n                \n        queue.sort(key = lambda data:data[0])\n        queue.sort(key = lambda data:data[2], reverse = True)\n\n        data = []\n        g_data = []\n        #print(queue)\n        \"\"\"\n        for i in range(len(queue)):\n            data.append(str(queue[i][0]))\n            g_data.append(str(queue[i][2]))\n            #print(queue[i])\n        print(\"g+h: \",' '.join(data))\n        print(\"g: \",' '.join(g_data))\n        \"\"\"\n        #if d == 1:\n        #print(len(queue))\n\n    if state == goal:\n        break\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque, OrderedDict\n\nclass Puzzle:\n    def __init__(self, field=None, path=''):\n        self.f = field\n        self.space = None\n        for i in range(9):\n            if self.f[i] == 9:\n                self.space = i\n        self.path = path\n\n    def __lt__(self, pzl): # <\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] > pzl.f[i]\n        return False\n\n    def __gt__(self, pzl): # >\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] < pzl.f[i]\n        return False\n\ndx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\ndir = ['u', 'l', 'd', 'r']\n\ndef is_target(pzl):\n    for i in range(9):\n        if pzl.f[i] != i+1:\n            return False\n    return True\n\ndef bfs(pzl):\n    queue = deque([])\n    V = {}\n    pzl.path = ''\n    queue.append(pzl)\n    V[str(pzl.f)] = True\n    if is_target(pzl):\n      return pzl.path\n\n    while len(queue) != 0:\n        u = queue.popleft()\n        sx, sy = u.space//3, u.space%3\n        for r in range(4):\n            tx, ty = sx + dx[r], sy + dy[r]\n            if tx < 0 or ty < 0 or tx >= 3 or ty >= 3:\n                continue\n            v = Puzzle(field=[u.f[i] for i in range(9)], path=u.path)\n            v.f[u.space], v.f[tx*3+ty] = v.f[tx*3+ty], v.f[u.space]\n            v.space = tx*3 + ty\n            if str(v.f) not in V:\n                V[str(v.f)] = True\n                v.path += dir[r]\n                if is_target(v): return v.path\n                queue.append(v)\n    return 'unsolvable'\n\nfield = []\nfor i in range(3):\n    field.extend(list(map(int, input().split(' '))))\n\nfor i in range(9):\n    if field[i] == 0: field[i] = 9\n\npzl = Puzzle(field=field)\nans= bfs(pzl)\nprint(len(ans))\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom copy import deepcopy, copy\ndy = [-1, 0, 0, 1]\ndx = [0, -1, 1, 0]\nN = 3\ndef g(i, j, a):\n    t = a // (10 ** j) % 10\n    return a - t * (10 ** j) + t * (10 ** i)\ndef MAIN():\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n    start = 8 - MAP.find(\"0\")\n    MAP = int(MAP)\n    goal = ('1', '2', '3', '4', '5', '6', '7', '8', '0')\n    goal = 123456780\n    dp = deque([(0, start, MAP)])\n    LOG = {MAP}\n    while dp:\n        cnt, yx, M = dp.popleft()\n        if M == goal:\n            print(cnt)\n            break\n        cnt += 1\n        for nyx in m[yx]:\n            CM = g(yx, nyx, M)\n            if not CM in LOG:\n                dp.append((cnt, nyx, CM))\n                LOG.add(CM)\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n  unsigned int b;\n  char step;\n} Board;\n\nint qlen=32202;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nconst Motion motion[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}} };\n\nint findzero(unsigned int b)\n{\n  for (int i=0; i<9; i++) {\n    if (b%10==0) return 8-i;\n    b/=10;\n  }\n  return -1;\n}\n\nunsigned int sq[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000,1000000000 };\n\n#define HISTLEN 8765432\n\nint main()\n{\n  int i, j, k;\n  int qhead, qtail;\n  qhead = qtail = 0;\n  Board board;\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b = i*sq[8]+j*sq[7]+k*sq[6];\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b += i*sq[5]+j*sq[4]+k*sq[3];\n  fscanf(stdin, \"%d %d %d\\n\", &i, &j, &k);\n  board.b += i*100+j*10+k;\n  short int *used = (short int*)malloc(sizeof(short int)*HISTLEN);\n  for (i=0; i<HISTLEN; i++) used[i]=0;\n  Board *Q = (Board*)malloc(sizeof(Board)*qlen);\n  board.step=0;\n  Q[qhead++] = board;\n  \n  while (qhead>qtail) {\n    board = Q[qtail++ %qlen];\n    if (board.b==123456780)   break;\n    \n    int space = findzero(board.b);\n    for (i=0; motion[space][i].pos>=0; i++) {\n      Board b = board;\n      Motion m = motion[space][i];\n      if (m.pos==0 && b.b/sq[8]==1) continue;\n      if ((m.pos==1||m.pos==2) && b.b/sq[8]==1&&(b.b%sq[8])/sq[7]==2&&(b.b%sq[7])/sq[6]==3) continue;\n      int nn=b.b%sq[8-m.pos+1]/sq[8-m.pos];\n      b.b = nn*sq[8-space]+b.b-nn*sq[8-m.pos];\n      b.step = board.step+1;\n      k=b.b/100;\n      if ((used[k] & (1<<(b.b%10)))==(1<<(b.b%10))) continue;\n      used[k] |= (1<<(board.b%10));\n      Q[qhead++ %qlen] = b;\n    }\n  }\n  printf(\"%d\\n\", board.step);\n  return 0;\n}\n\n"
  },
  {
    "language": "Python",
    "code": "# 8 Puzzle\nimport copy\nz = 0\n[N, d] = [3, 0]\ncheck_flag = [[1, 2, 3, 4,  1, 2, 3, 4,  1, 2, 3, 4],\n              [2, 3, 4, 1,  2, 3, 4, 1,  2, 3, 4, 1],\n              [3, 4, 1, 2,  3, 4, 1, 2,  3, 4, 1, 2],\n              [4, 1, 2, 3,  4, 1, 2, 3,  4, 1, 2, 3],\n              [3, 2, 1, 4,  3, 2, 1, 4,  3, 2, 1, 4],\n              [2, 1, 4, 3,  2, 1, 4, 3,  2, 1, 4, 3],\n              [1, 4, 3, 2,  1, 4, 3, 2,  1, 4, 3, 2],\n              [4, 3, 2, 1,  4, 3, 2, 1,  4, 3, 2, 1]]\n\nstart = []\ngoal = [[i + j*N for i in range(1, N + 1)] for j in range(N)]\ngoal[2][2] = 0\nfor i in range(N):\n    start.append(list(map(int, input().split())))\n\n\ndef manhattan(value, pairs):\n    h = 0\n\n    if value == 1:\n        h = (pairs[0] + pairs[1])\n    if value == 2:\n        h = (pairs[0] + abs(pairs[1] - 1))\n    if value == 3:\n        h = (pairs[0] + abs(pairs[1] - 2))\n    \n    if value == 4:\n        h = (abs(pairs[0] - 1) + pairs[1])\n    if value == 5:\n        h = (abs(pairs[0] - 1) + abs(pairs[1] - 1)) \n    if value == 6:\n        h = (abs(pairs[0] - 1) + abs(pairs[1] - 2))\n        \n    if value == 7:\n        h = (abs(pairs[0] - 2) + pairs[1])      \n    if value == 8:\n        h = (abs(pairs[0] - 2) + abs(pairs[1] - 1))\n        \n    return h\n\ndef flag_array(flag, input):\n\n    flag.pop(0)\n    flag.append(input)\n    return flag\n\n\ns_h = 0\nfor i in range(N):\n    for j in range(N):\n        s_h += manhattan(start[i][j], [i, j])\n\n# print(s_h)\n\nfor i in range(N):\n        check = start[i].count(0)\n        if check != 0:\n            [s_r, s_c] = [i, start[i].index(0)]\n            break\n        if i == 3:\n            print(\"Error\")\n\nwhile True:\n    d += 1\n    queue = []\n    flag = [0 for i in range(12)]\n    queue.append([s_h, start, 0, [s_r, s_c], flag])\n\n    #while True:\n    while len(queue) != 0:\n        #print(\"Q: \", len(queue), \"depth: \", d)\n        short_n = queue.pop(0)\n        h = short_n[0] - short_n[2]\n        state = short_n[1]\n        g = short_n[2]\n        [r, c] = short_n[3]\n        flag = short_n[4]\n        print(\"left_Q: \", len(queue), \"depth: \", d, \"h: \", h, \"g: \", g, \"state: \", state, \"g+h: \", short_n[0], \"flag: \", flag[len(flag) - 1])\n        #print(\"left_Q: \", len(queue), \"depth: \", d, \"h: \", h, \"g: \", g, \"flag: \", flag, \"g+h: \", short_n[0])\n        #if d == 1:\n            #print(short_n[0])\n            #print(state)\n            #print(g)\n\n        if h == 0:\n            print(short_n[2])\n            print(z)\n            break\n        \"\"\"\n        if flag in check_flag:\n            z += 1\n            continue\n        \"\"\"\n        if r - 1 >= 0 and flag[len(flag) - 1] != 3:\n            [temp, temp_array] = [copy.deepcopy(state), flag[:]]\n            h = short_n[0] - short_n[2] - manhattan(temp[r - 1][c], [r - 1, c]) + manhattan(temp[r - 1][c], [r, c])\n            [temp[r][c], temp[r - 1][c]] = [temp[r - 1][c], temp[r][c]]\n            #if temp[r][c] != goal[r][c]:\n            #[r, c] = [r - 1, c]\n            #if temp\n            #h = manhattan(temp)\n            #print(\"1: \", h, temp)\n            if g + 1 + h <= d:\n                queue.append([h + g + 1, temp, g + 1, [r - 1, c], flag_array(temp_array, 1)])\n        \n        if c + 1 < N and flag[len(flag) - 1] != 4:\n            #print(\"2: \")\n            [temp, temp_array] = [copy.deepcopy(state), flag[:]]\n            #temp_array = copy.deepcopy(flag)\n            h = short_n[0] - short_n[2] - manhattan(temp[r][c + 1], [r, c + 1]) + manhattan(temp[r][c + 1], [r, c])\n            [temp[r][c], temp[r][c + 1]] = [temp[r][c + 1], temp[r][c]]\n            #queue.append(calculate(temp, g + 1))\n            #print(\"2: \", h, temp)\n            if g + 1 + h <= d:\n                queue.append([h + g + 1, temp, g + 1, [r, c + 1], flag_array(temp_array, 2)])\n\n        if r + 1 < N and flag[len(flag) - 1] != 1:\n            #print(\"3: \")\n            [temp, temp_array] = [copy.deepcopy(state), flag[:]]\n            #temp_array = copy.deepcopy(flag)\n            h = short_n[0] - short_n[2] - manhattan(temp[r + 1][c], [r + 1, c]) + manhattan(temp[r + 1][c], [r, c])\n            [temp[r][c], temp[r + 1][c]] = [temp[r + 1][c], temp[r][c]]\n            #queue.append(calculate(temp, g + 1))\n            #print(\"3: \", h, temp)\n            if g + 1 + h <= d:\n                queue.append([h + g + 1, temp, g + 1, [r + 1, c], flag_array(temp_array, 3)])\n        \n        if c - 1 >= 0 and flag[len(flag) - 1] != 2:\n            #print(\"4: \")\n            [temp, temp_array] = [copy.deepcopy(state), flag[:]]\n            h = short_n[0] - short_n[2] - manhattan(temp[r][c - 1], [r, c - 1]) + manhattan(temp[r][c - 1], [r, c])\n            [temp[r][c], temp[r][c - 1]] = [temp[r][c - 1], temp[r][c]]\n            if g + 1 + h <= d:\n                queue.append([h + g + 1, temp, g + 1, [r, c - 1], flag_array(temp_array, 4)])\n                \n        queue.sort(key = lambda data:data[0])\n        queue.sort(key = lambda data:data[2], reverse = True)\n\n        data = []\n        g_data = []\n        #print(queue)\n        \"\"\"\n        for i in range(len(queue)):\n            data.append(str(queue[i][0]))\n            g_data.append(str(queue[i][2]))\n            #print(queue[i])\n        print(\"g+h: \",' '.join(data))\n        print(\"g: \",' '.join(g_data))\n        \"\"\"\n        #if d == 1:\n        #print(len(queue))\n\n    if state == goal:\n        break\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\n\n\nclass P(list):\n    def __init__(self):\n        list.__init__(self)\n        self.space = None\n        self.path = \"\"\n\n    def __hash__(self):\n        return hash(str(self[:]))\n\n\ndef is_target(p):\n    return p[:] == ans[:]\n\n\nN = 3\nN2 = N*N\nans = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n# space index\nsi = 0\n\n# move\ndx = (-1, 0, 1, 0)\ndy = (0, -1, 0, 1)\ndirection = ('u', 'l', 'd', 'r')\n\n\ndef bfs(p):\n    Q = deque()\n    Q.append(p)\n    V = set()\n    V.add(p)\n\n    while Q:\n        u = Q.popleft()\n        if u == ans:\n            return u.path\n        sx = u.space // N\n        sy = u.space % N\n        for i in range(4):\n            tx = sx + dx[i]\n            ty = sy + dy[i]\n            if tx < 0 or ty < 0 or tx >= N or ty >= N:\n                continue\n            v = P()\n            v[:] = u[:]\n            v.path = u.path\n            c = int(tx*N+ty)\n            v[u.space] = v[c]\n            v[c] = 9\n            v.space = c\n            if v not in V:\n                V.add(v)\n                v.path += direction[i]\n                Q.append(v)\n\n\np = P()\nfor i in range(N):\n    line = sys.stdin.readline()\n    a, b, c = map(int, line.split())\n    p.append(a)\n    p.append(b)\n    p.append(c)\nfor i in range(N2):\n    if p[i] == 0:\n        p[i] = 9\n        p.space = i\n\nre = bfs(p)\nprint(len(re))\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nclass Puzzle:\n    def __init__(self, ls, answer_flag=False):\n        self.piece_vec = list(ls)\n        self.update_value = [-3, 3, -1, 1]\n        for idx, piece in enumerate(ls):\n            if piece == 0:\n                self.space_idx = idx\n        \n        self.space_idx_before_slide = deque()\n        self.manhattan_distance = list()\n        if answer_flag:\n            for i in range(9):\n                self.manhattan_distance.append([(abs(i % 3 - j % 3) + abs(i // 3 - j // 3)) for j in range(9)])\n                    \n        \n    def GetManhattanDistance(self, ans_idx, idx):\n        return self.manhattan_distance[ans_idx][idx]\n        \n    def SumManhattanDistance(self, answer_board):\n        sum_MD = 0\n        for idx, piece in enumerate(self.piece_vec):\n            if piece == 0:\n                continue\n            answer_idx = piece - 1\n            sum_MD += answer_board.GetManhattanDistance(answer_idx, idx)\n        return sum_MD\n    \n    def SlideSpace(self, command):\n        is_frame = [self.space_idx < 3, self.space_idx >= 6, self.space_idx % 3 == 0, self.space_idx % 3 == 2]\n        if is_frame[command]:\n            return False\n        \n        next_space_idx = self.space_idx + self.update_value[command]\n        if len(self.space_idx_before_slide) > 0 and next_space_idx == self.space_idx_before_slide[-1]:\n            return False\n        \n        self.piece_vec[self.space_idx], self.piece_vec[next_space_idx] = self.piece_vec[next_space_idx], self.piece_vec[self.space_idx]\n        self.space_idx_before_slide.append(self.space_idx)\n        self.space_idx = next_space_idx\n        return True\n    \n    def BackState(self):\n        self.piece_vec[self.space_idx], self.piece_vec[self.space_idx_before_slide[-1]] = self.piece_vec[self.space_idx_before_slide[-1]], self.piece_vec[self.space_idx]\n        self.space_idx = self.space_idx_before_slide.pop()\n\ndef SolvePuzzleByDFS(board, answer_board, limit, depth = 0):\n    if board.SumManhattanDistance(answer_board) == 0:\n        return True\n    \n    if depth + board.SumManhattanDistance(answer_board) > limit:\n        return False\n    \n    for command in range(4):\n        if board.SlideSpace(command) == False:\n            continue\n        \n        if SolvePuzzleByDFS(board, answer_board, limit, depth+1):\n            return True\n        board.BackState()\n    \n    return False\n\ndef CalcMinStepOf15Puzzle(board, answer_board):\n    for limit in range(board.SumManhattanDistance(answer_board), 35):\n        if SolvePuzzleByDFS(board, answer_board, limit):\n            return limit\n    \n    return -1\n\ndef main():\n    inputLs = list()\n    answerLs = [ 1, 2, 3,\n                 4, 5, 6, \n                 7, 8, 9]\n    for _ in range(3):\n        inputLs += list(map(int, input().split()))\n\n    start_board = Puzzle(inputLs)\n    answer_board = Puzzle(answerLs, True)\n    \n    min_step = CalcMinStepOf15Puzzle(start_board, answer_board);\n    \n    print(min_step)\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom copy import deepcopy, copy\ndy = [-1, 0, 0, 1]\ndx = [0, -1, 1, 0]\nN = 3\ndef MAIN():\n    MAP = tuple(sum([input().split() for _ in range(N)], []))\n    y0, x0 = divmod(MAP.index(\"0\"), N)\n    goal = ('1', '2', '3', '4', '5', '6', '7', '8', '0')\n    ans = 0\n    dp = deque([[y0, x0, 0, MAP]])\n    LOG = {MAP}\n    while dp:\n        y, x, cnt, M = dp.popleft()\n        if M == goal:\n            print(cnt)\n            break\n        cnt += 1\n        yx = y * N + x\n        for i in range(4):\n            ny = y + dy[i]\n            nx = x + dx[i]\n            if 0 <= ny < N and 0 <= nx < N:\n                CM = list(deepcopy(M))\n                nyx = ny * N + nx\n                CM[yx], CM[nyx] = CM[nyx], CM[yx]\n                CM = tuple(CM)\n                if not CM in LOG:\n                    dp.append([ny, nx, cnt, CM])\n                    LOG.add(CM)\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\ndy = [-1, 0, 0, 1]\ndx = [0, -1, 1, 0]\ndef g(i, j, a):\n    t = a // (10 ** j) % 10\n    return a - t * (10 ** j) + t * (10 ** i)\ndef MAIN():\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n    start = 8 - MAP.find(\"0\")\n    MAP = int(MAP)\n    goal = ('1', '2', '3', '4', '5', '6', '7', '8', '0')\n    goal = 123456780\n    dp = deque([(0, start, MAP)])\n    LOG = {MAP}\n    while dp:\n        cnt, yx, M = dp.popleft()\n        if M == goal:\n            print(cnt)\n            break\n        cnt += 1\n        for nyx in m[yx]:\n            CM = g(yx, nyx, M)\n            if not CM in LOG:\n                dp.append((cnt, nyx, CM))\n                LOG.add(CM)\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom copy import deepcopy, copy\nN = 3\ndef g(i, j, a):\n    if i > j:\n        i, j = j, i\n    return a[:i] + a[j] + a[i + 1:j] + a[i] + a[j + 1:]\ndef MAIN():\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n    start = MAP.find(\"0\")\n    goal = \"123456780\"\n    dp = deque([(0, start, MAP)])\n    LOG = {MAP}\n    while dp:\n        cnt, yx, M = dp.popleft()\n        if M == goal:\n            print(cnt)\n            break\n        cnt += 1\n        for nyx in m[yx]:\n            CM = g(yx, nyx, M)\n            if not CM in LOG:\n                dp.append((cnt, nyx, CM))\n                LOG.add(CM)\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "import queue\n\nGOAL = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\nadjacent = (\n    (1, 3),       # 0\n    (0, 2, 4),    # 1\n    (1, 5),       # 2\n    (0, 4, 6),    # 3\n    (1, 3, 5, 7), # 4\n    (2, 4, 8),    # 5\n    (3, 7),       # 6\n    (4, 6, 8),    # 7\n    (5, 7)        # 8\n)\n\nclass State:\n    def __init__(self, board, space, prev):\n        self.board = board\n        self.space = space\n        self.prev  = prev\n\n\ndef bf_search(start):\n    q = queue.Queue()\n    q.put(State(start, start.index(0), None))\n\n    table = {}\n    table[tuple(start)] = True\n\n    while not q.empty():\n        a = q.get()\n\n        for x in adjacent[a.space]:\n            b = a.board[:]\n            b[a.space] = b[x]\n            b[x] = 0\n\n            key = tuple(b)\n\n            if key in table: continue\n\n            c = State(b, x, a)\n\n            if b == GOAL:\n                print_answer(c)\n                return\n\n            q.put(c)\n            table[key] = True\n\n\n# 手順の表示\ndef print_answer(x):\n    count = 0\n\n    while x.prev != None:\n        x = x.prev\n        count += 1\n\n    print(count)\n\n\n\nif(__name__ == '__main__'):\n    p = []\n    for i in range(3):\n        p.extend([int(x) for x in input().split()])\n\n    print(p)\n    bf_search(p)\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heapify, heappush, heappop\nfrom collections import deque\nfrom copy import deepcopy, copy\nN = 3\nm = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\ndef g(i, j, a):\n    if i > j:\n        i, j = j, i\n    return a[:i] + a[j] + a[i + 1:j] + a[i] + a[j + 1:]\ndef MAIN():\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n    goal = \"123456780\"\n    if MAP == goal:\n        print(0)\n        return\n    start = MAP.find(\"0\")\n    dp = [(0, MAP, start)]\n    LOG = {MAP}\n    while dp:\n        cnt, M, yx = heappop(dp)\n        cnt += 1\n        for nyx in m[yx]:\n            CM = g(yx, nyx, M)\n            if not CM in LOG:\n                if CM == goal:\n                    print(cnt)\n                    return\n                heappush(dp, (cnt, CM, nyx))\n                LOG.add(CM)\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    q.append((sumcost,0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = q.pop(0)\n        c_dWithH = items[0]\n        c_depth = items[1]\n        _i = items[2]\n        _j = items[3]\n        prev_move = items[4]\n        c_puz = items[5]\n        _sum_cost = c_dWithH - c_depth\n\n        if(c_dWithH - c_depth == 0):\n            finding = 1\n            print(c_depth)\n            break\n        if(c_dWithH > depth):\n            continue\n\n        c_cost = simpleHS(c_puz,_i,_j)\n\n        print(c_depth)\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            q.append((c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i-1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i-1,_j)),c_depth+1,_i-1,_j,2,swap_puz))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            q.append((c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i+1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i+1,_j)),c_depth+1,_i+1,_j,1,swap_puz))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            q.append((c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j-1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j-1)),c_depth+1,_i,_j-1,4,swap_puz))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            q.append((c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j+1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j+1)),c_depth+1,_i,_j+1,3,swap_puz))\n\ndef checkCost(c_cost,m_cost,c2_cost,m2_cost):\n    return c2_cost - c_cost + m2_cost - m_cost\n    \n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz,i,j):\n    if(correctPuz[i*3+j] != c_puz[i*3+j]):\n        return 1\n    return 0\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nsumcost=0\nfor i in range(len(correctPuz)):\n    if(correctPuz[i] != puz[i]):\n        sumcost+=1\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(sumcost,(0,i,j,0,puz)))\n    global finding\n\n    while len(q):\n        c_dWithH, items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        _sum_cost = c_dWithH - c_depth\n\n        if(c_dWithH - c_depth == 0):\n            finding = 1\n            print(c_depth)\n            break\n        if(c_dWithH > depth):\n            continue\n\n        c_cost = simpleHS(c_puz,_i,_j)\n\n        print(c_depth)\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            heapq.heappush(q,(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i-1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i-1,_j)),(c_depth+1,_i-1,_j,2,swap_puz)))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            heapq.heappush(q,(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i+1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i+1,_j)),(c_depth+1,_i+1,_j,1,swap_puz)))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            heapq.heappush(q,(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j-1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j-1)),(c_depth+1,_i,_j-1,4,swap_puz)))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            heapq.heappush(q,(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j+1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j+1)),(c_depth+1,_i,_j+1,3,swap_puz)))\n\ndef checkCost(c_cost,m_cost,c2_cost,m2_cost):\n    return c2_cost - c_cost + m2_cost - m_cost\n    \n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz,i,j):\n    if(correctPuz[i*3+j] != c_puz[i*3+j]):\n        return 1\n    return 0\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nsumcost=0\nfor i in range(len(correctPuz)):\n    if(correctPuz[i] != puz[i]):\n        sumcost+=1\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom copy import deepcopy, copy\ndy = [-1, 0, 0, 1]\ndx = [0, -1, 1, 0]\nN = 3\nf = lambda x: \"\\n\".join(\" \".join(map(str, x[i])) for i in range(3))\ndef MAIN():\n    MAP = [list(map(int, input().split())) for _ in range(N)]\n    start = divmod(sum(MAP, []).index(0), N)\n    goal = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n    ans = 0\n    dp = deque([[start[0], start[1], 0, MAP]])\n    LOG = [MAP]\n    while dp:\n        y, x, cnt, M = dp.popleft()\n        if M == goal:\n            print(cnt)\n            break\n        cnt += 1\n        for i in range(4):\n            ny = y + dy[i]\n            nx = x + dx[i]\n            if 0 <= ny < N and 0 <= nx < N:\n                CM = deepcopy(M)\n                CM[y][x], CM[ny][nx] = CM[ny][nx], CM[y][x]\n                if not CM in LOG:\n                    dp.append([ny, nx, cnt, CM])\n                    LOG.append(CM)\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python3\n\ndef get_patten(B):\n    return ''.join(map(str, B))\n\ndef change_left(index, B):\n    C = B.copy()\n    C[index], C[index - 1] = C[index - 1], C[index]\n    return C\n\ndef change_right(index, B):\n    C = B.copy()\n    C[index], C[index + 1] = C[index + 1], C[index]\n    return C\n\ndef change_top(index, B):\n    C = B.copy()\n    C[index], C[index - 3] = C[index - 3], C[index]\n    return C\n\ndef change_bottom(index, B):\n    C = B.copy()\n    C[index], C[index + 3] = C[index + 3], C[index]\n    return C\n\n# main\nboad = []\nfor i in range(3):\n    boad.extend(map(int, input().split()))\nexist_patten = set()\n\nq = []\nq.append((boad, None, 0))\n\nwhile len(q) > 0:\n    B, prev, count = q.pop(0)\n    p = get_patten(B)\n    if p in exist_patten:\n        continue\n    exist_patten.add(p)\n    if p == '123456780':\n        print(count)\n        exit()\n\n    index = B.index(0)\n\n    if index % 3 != 0 and prev != 'right':\n        C = change_left(index, B)\n        q.append((C, 'left', count + 1))\n\n    if index % 3 != 2 and prev != 'left':\n        C = change_right(index, B)\n        q.append((C, 'right', count + 1))\n\n    if index >= 3 and prev != 'bottom':\n        C = change_top(index, B)\n        q.append((C, 'top', count + 1))\n\n    if index <= 5 and prev != 'top':\n        C = change_bottom(index, B)\n        q.append((C, 'bottom', count + 1))"
  },
  {
    "language": "Python",
    "code": "import copy\ndef hashnum(state):\n    num = 0\n    for i in range(3):\n        for j in range(3):\n            num *= 10\n            num += state[i][j]\n    return num\n\nanswer = 123456780\nini_state = []\nfor i in range(3):\n    temp = [int(n) for n in input().split(\" \")]\n    if 0 in temp:\n        zero_x, zero_y = temp.index(0), i\n    ini_state.append(temp)\nend_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\nqueue = [[ini_state, zero_x, zero_y, 0], [end_state, 2, 2, 1]]\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\nvisited = {}\nvisited[hashnum(ini_state)] = [0, 0]\nvisited[answer] = [0, 1]\ntrial = 0\nwhile answer not in visited:\n    new_queue = []\n    trial += 1\n    for q in queue:\n        state, zero_x, zero_y, direction = q\n        for i in range(len(dx)):\n            new_state = copy.deepcopy(state)\n            new_x = zero_x + dx[i]\n            new_y = zero_y + dy[i]\n            if 0 <= new_x < 3 and 0 <= new_y < 3:\n                new_state[new_y][new_x], new_state[zero_y][zero_x] = new_state[zero_y][zero_x], new_state[new_y][new_x]\n                perm = hashnum(new_state)\n                if perm in visited and direction != visited[perm][1]:\n                    print(trial + visited[perm][0])\n                    exit()\n                if perm not in visited:\n                    visited[perm] = [trial, direction]\n                    new_queue.append([new_state, new_x, new_y, direction])\n    queue = new_queue"
  },
  {
    "language": "Python",
    "code": "from heapq import heapify, heappush, heappop\nfrom collections import deque\nfrom copy import deepcopy, copy\nN = 3\ndef g(i, j, a):\n    if i > j:\n        i, j = j, i\n    return a[:i] + a[j] + a[i + 1:j] + a[i] + a[j + 1:]\ndef MAIN():\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n    start = MAP.find(\"0\")\n    goal = \"123456780\"\n    dp = [(0, MAP, start)]\n    LOG = {MAP}\n    while dp:\n        cnt, M, yx = heappop(dp)\n        if M == goal:\n            print(cnt)\n            break\n        cnt += 1\n        for nyx in m[yx]:\n            CM = g(yx, nyx, M)\n            if not CM in LOG:\n                heappush(dp, (cnt, CM, nyx))\n                LOG.add(CM)\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport queue\n\nN = 3\nf= ''.join(sys.stdin.readline().split())\nf+= ''.join(sys.stdin.readline().split())\nf+= ''.join(sys.stdin.readline().split())\n\ndd = [[-1, 0], [0, -1], [1, 0], [0, 1]]\n\nQ = queue.Queue()\nV = dict()\n\nQ.put([f,f.index('0'),0])\nV[f] = True\n\nwhile not Q.empty():\n    u = Q.get()\n    if u[0] == '123456780':  break\n    sx, sy = u[1]//N, u[1]%N\n    for dx, dy in dd:\n        tx, ty = sx+dx, sy+dy\n        if tx<0 or ty<0 or tx>=N or ty>=N: continue\n        v = u[:]\n        n1, n2 = u[1], tx*N+ty\n        v[1] = n2\n\tif n1>n2: n1, n2 = n2, n1\n        v[0] = v[0][0:n1]+v[0][n2]+v[0][n1+1:n2]+v[0][n1]+v[0][n2+1:]\n        if not V.get(v[0], False):\n            V[v[0]] = True\n            v[2] += 1 # dir[r]                                                       \n            Q.put(v)\n\nprint(u[2])\n\n"
  },
  {
    "language": "Python",
    "code": "class Queue:\n    '''\n    パズルオブジェクトを格納するキュークラス\n    '''\n    def __init__(self, puzzle):\n        self.puzzle_list = []\n\n        self.puzzle_list.append(puzzle)\n\n    def enqueue(self, puzzle):\n        self.puzzle_list.append(puzzle)\n\n    def dequeue(self):\n        return self.puzzle_list.pop(0)\n    def is_empty(self):\n        return len(self.puzzle_list) == 0\n\n\nclass _8Puzzle:\n    def __init__(self, panel_list, state_list, size):\n        self.panel_list = panel_list\n\n        self.state_list = state_list\n        self.state_list.append(panel_list)\n\n        self.size = size\n\n    # パネルの0を左右上下に移動させたときのパネル配置を返すジェネレーター\n    def gene_next_panel(self, puzzle):\n        zero_pos = puzzle.panel_list.index(0)\n        col = zero_pos // self.size\n        raw = zero_pos % self.size\n\n        def __get_next_panel():\n            panel_list = puzzle.panel_list[:]\n            n = panel_list[next_pos]\n            panel_list[next_pos] = 0\n            panel_list[zero_pos] = n\n            return panel_list\n\n        if self.size > col + 1:\n            next_pos = (col + 1) * self.size + raw\n            panel_list = __get_next_panel()\n            yield tuple(panel_list)\n\n        if col - 1 >= 0:\n            next_pos = (col - 1) * self.size + raw\n            panel_list = __get_next_panel()\n            yield tuple(panel_list)\n\n        if self.size > raw + 1:\n            next_pos = col * self.size + raw + 1\n            panel_list = __get_next_panel()\n            yield tuple(panel_list)\n\n        if raw - 1 >= 0:\n            next_pos = col * self.size + raw - 1\n            panel_list = __get_next_panel()\n            yield tuple(panel_list)\n\n    def result_print(self):\n        i = 0\n        for s in self.state_list:\n            i += 1\n\n        print(i-1)\n\ndef breadth_first(size, goal, panel_list):\n    puzzle = _8Puzzle(panel_list, [], size)\n    queue = Queue(puzzle)\n    checked_dict = {}\n\n    while queue.is_empty() is False:\n        puzzle = queue.dequeue()\n        num = 0\n        for next_panel in puzzle.gene_next_panel(puzzle):\n            next_puzzle = _8Puzzle(list(next_panel), puzzle.state_list[:], size)\n\n            if next_panel in checked_dict:\n                continue\n\n            if list(next_panel) == goal:\n\n                return next_puzzle\n\n            checked_dict[next_panel] = True\n            queue.enqueue(next_puzzle)\n\nif __name__ == '__main__':\n    size = 3\n    goal = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n    input_puzzle = []\n    for i in range(3):\n        _in1, _in2, _in3 = (int(z) for z in input().split())\n        input_puzzle.append(_in1)\n        input_puzzle.append(_in2)\n        input_puzzle.append(_in3)\n\n    if goal == input_puzzle:\n        print(0)\n        exit()\n\n    puzzle = breadth_first(size, goal, input_puzzle)\n\n    puzzle.result_print()\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nimport sys\nfrom itertools import chain\n\n\ndef get_completed_board(height, width):\n    return [str((i + 1) % (width * height)) for i in range(width * height)]\n\n\ndef serialize_board(board):\n    return \":\".join(board)\n\n\ndef get_empty_pos(board, width, height):\n    for i, cell in enumerate(board):\n        if cell == \"0\":\n            return i\n\n\ndef get_all_possible_next_boards(board, height, width, empty_pos=None):\n    if empty_pos is None:\n        empty_pos = get_empty_pos(board, height, width)\n    next_boards = []\n    x, y = empty_pos % width, empty_pos // height\n    # 左との入れ替え\n    if x > 0:\n        next_board = []\n        next_board.extend(board)\n        dest_pos = empty_pos - 1\n        next_board[empty_pos], next_board[dest_pos] = next_board[dest_pos], next_board[empty_pos]\n        next_boards.append((next_board, dest_pos))\n    # 右との入れ替え\n    if x < width - 1:\n        next_board = []\n        next_board.extend(board)\n        dest_pos = empty_pos + 1\n        next_board[empty_pos], next_board[dest_pos] = next_board[dest_pos], next_board[empty_pos]\n        next_boards.append((next_board, dest_pos))\n    # 上との入れ替え\n    if y > 0:\n        next_board = []\n        next_board.extend(board)\n        dest_pos = empty_pos - height\n        next_board[empty_pos], next_board[dest_pos] = next_board[dest_pos], next_board[empty_pos]\n        next_boards.append((next_board, dest_pos))\n    # 下との入れ替え\n    if y < height - 1:\n        next_board = []\n        next_board.extend(board)\n        dest_pos = empty_pos + height\n        next_board[empty_pos], next_board[dest_pos] = next_board[dest_pos], next_board[empty_pos]\n        next_boards.append((next_board, dest_pos))\n\n    return next_boards\n\n\ndef resolve(board, height, width):\n    # 既知の盤面を保存\n    known_serialized_boards = set([serialize_board(board)])\n    # 正解の盤面を保存\n    completed_board = get_completed_board(width, height)\n    known_serialized_completed_boards = set([serialize_board(completed_board)])\n    if known_serialized_boards & known_serialized_completed_boards:\n        return 0\n    current_boards = [(board, None)]\n    current_completed_boards = [(get_completed_board(width, height), None)]\n    step_count = 1\n    while step_count <= 45:\n        # インプット側の盤面を一つ進める\n        next_boards = []\n        for board, empty_pos in current_boards:\n            # 次のステップでの現れ得る局面を全て取得\n            tmp_next_boards = get_all_possible_next_boards(board, height, width, empty_pos)\n            filtered_next_board = []\n            for board, empty_pos in tmp_next_boards:\n                serialized_board = serialize_board(board)\n                if serialized_board not in known_serialized_boards:\n                    known_serialized_boards.add(serialized_board)\n                    filtered_next_board.append((board, empty_pos))\n            next_boards.extend(filtered_next_board)\n\n        if known_serialized_boards & known_serialized_completed_boards:\n            return step_count\n\n        step_count = step_count + 1\n        current_boards = next_boards\n\n        # 正解盤面側を１つ進める\n        next_completed_boards = []\n        for board, empty_pos in current_completed_boards:\n            # 次のステップでの現れ得る局面を全て取得\n            tmp_next_boards = get_all_possible_next_boards(board, height, width, empty_pos)\n            filtered_next_board = []\n            for board, empty_pos in tmp_next_boards:\n                serialized_board = serialize_board(board)\n                if serialized_board not in known_serialized_completed_boards:\n                    known_serialized_completed_boards.add(serialized_board)\n                    filtered_next_board.append((board, empty_pos))\n            next_completed_boards.extend(filtered_next_board)\n\n        if known_serialized_boards & known_serialized_completed_boards:\n            return step_count\n        step_count = step_count + 1\n        current_completed_boards = next_completed_boards\n\n    return None\n\n\ndef main():\n    inputStr = sys.stdin.read()\n    lines = inputStr.split(\"\\n\")\n    lines = filter(lambda line: line, lines)\n    board = list(map(lambda line: line.split(\" \"), lines))\n    height = len(board)\n    width = len(board[0])\n    board = list(chain.from_iterable(board))\n    print(resolve(board, height, width))\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "#codinh -utf8\nimport sys\nimport copy\n\ngoal_state=[1,2,3,4,5,6,7,8,0]\nopen_list=[]    #????????¢?´¢??????????????????????´?\nclosed_list=[]  #??¢?´¢????????????????????????????´?\n\n\ndef getH(a, b): #???????????????????????¢????¨????\n    h2=0\n    i=0\n    for n in a:\n        if n!=-1:   #????????\\??????????????????????????????????????????????????¶????????§????????¢??????????±???????\n            j=b.index(n)\n            dist=j-i\n            dist=abs(dist)  #|i??¨j??????dist|: ??´???????????§????????¢\n            if dist==1:     #?????¢??????????????§?¨???????????????????????????????????????§????????¢?????????\n                if (i==2 and j==3) or (j==2 and i==3) or (i==5 and j==6) or (j==5 and i==6):\n                    dist=3\n            elif dist==3:\n                dist=1\n            elif dist==4:\n                if(i!=2 and j!=6) and (i!=6 and j!=2):\n                    dist=2\n            elif dist==5:\n                dist=3\n            elif dist==6:\n                dist=2\n            elif dist==7:\n                dist=3\n            elif dist==8:\n                dist=4\n            h2+=dist    #?????????????????¢?????????\n        i+=1\n    return  h2  #?????¢??????????????????\n\ndef findChildState(space, std_node):    #???????????????????????????????????????????????????\n    nxt_space=[]    #????????????????????????????????????????????????????´?\n    if space==0:    #?????????????????????????????????????????£?????´???\n        nxt_space.append(space+1)\n        nxt_space.append(space+3)\n    elif space==1:    #???????????????????????????0??????????????????????????£?????´???\n        nxt_space.append(space-1)\n        nxt_space.append(space+1)\n        nxt_space.append(space+3)\n    elif space==2:    #?????????????????????????????????????????£?????´???\n        nxt_space.append(space-1)\n        nxt_space.append(space+3)\n    elif space==3:    #??????????????????????????????????????????????????£?????´???\n        nxt_space.append(space-3)\n        nxt_space.append(space+1)\n        nxt_space.append(space+3)\n    elif space==4:    #????????????????????????????????????????????£?????´???\n        nxt_space.append(space-3)\n        nxt_space.append(space-1)\n        nxt_space.append(space+1)\n        nxt_space.append(space+3)\n    elif space==5:    #??????????????????????????????????????????????????£?????´???\n        nxt_space.append(space-3)\n        nxt_space.append(space-1)\n        nxt_space.append(space+3)\n    elif space==6:    #?????????????????????????????????????????£?????´???\n        nxt_space.append(space-3)\n        nxt_space.append(space+1)\n    elif space==7:    #????????????????????????????????????????????????????????£?????´???\n        nxt_space.append(space-3)\n        nxt_space.append(space-1)\n        nxt_space.append(space+1)\n    elif space==8:    #?????????????????????????????????????????£?????´???\n        nxt_space.append(space-3)\n        nxt_space.append(space-1)\n    child_set=[]\n    for i in nxt_space: #???????????????????????????????????????????????¶???child_state?????????\n        child_state=copy.deepcopy(std_node[3])\n        child_state[space], child_state[i]=child_state[i], child_state[space]\n        child_set.append(child_state)   #chld_set??????????????????????????????????????????????????¶???????????????????´???????\n    return child_set\n\ndef openChildNode(std_node):    #?????¶??????????????????????????????openlist????????????\n    child_set=findChildState(std_node[3].index(0), std_node)   #???????????????????????????????????????\n    del open_list[0]    #??????????????????openlist??????????????????\n    closed_list.append(std_node)    #??????????????????closedlist???????????????\n    for i in child_set:\n        g=std_node[0]+1\n        h=getH(i, goal_state)\n        f=g+h\n        child=(g,h,f,i) #?????????????????????????????°????????\\??????????????£???????????????????????????????????¶???????¨???????child?????????\n        op=list(map(lambda x: i==x[3], open_list))\n        cl=list(map(lambda x: i==x[3], closed_list))\n        if  (True not in op) and (True not in cl):  #openlist??????closedlist????????????????????¨?????????????????¶??????????????´???\n            open_list.append(child) #openlist?????????\n        elif (True in op):  #openlist?????????????????¨?????????????????¶??????????????´???\n            n=op.index(True)\n            if f<open_list[n][2]:   #????????????????????????????????????????????????????°????????????°openlist????????????????????´??°\n                open_list[n]=copy.deepcopy(child)\n        elif (True in cl):  #closedlist?????????????????¨?????????????????¶??????????????´???\n            n=cl.index(True)\n            if f<closed_list[n][2]:   #????????????????????????????????????????????????????°????????????°closedlist??????????????????openlist?????????\n                del closed_list[n]\n                open_list.append(child)\n\ndef updateStandard():   #openlist??????????????????????°???????????????????????????????????¨??????????\n    min=100000000\n    std=()\n    if open_list==[]:   #openlist??????????????´?????¢?´¢??±???\n        return -1\n    for i in open_list: #openlist??????????????????????°????????????????????´¢\n        if i[2]<min:\n            min=i[2]\n            std=copy.deepcopy(i)\n    n=open_list.index(std)  #????????????????°???????????????????????????????????¨????\n    open_list[0], open_list[n]=open_list[n], open_list[0]   #??????????????????openlist?????????????§????\n    return std  #????????????????????????\n\n\na=[]\nfor i in sys.stdin:\n    x=list(map(int, i.split()))\n    for j in x:\n        a.append(j)\n\ng=0     #??????????????§?????????????????°???0\nh=getH(a, goal_state)  #?????\\??????????????£?????????????¨????\nf=g+h   #??´???????????§????¨±???????????????????¨????\nstd_node=(g, h, f, a)   #?????????(??????????????°????????\\??????????????£??????????????????????????????????????¶???)??????????????????????¨????\nopen_list.append(std_node)\n\nwhile 1:\n    openChildNode(std_node) #open_list????????????????????????\n    std=updateStandard()    #openlist?????????????????????f???????°???????????????????\n    if std==-1: #openlist???????????£?????´?????¢?´¢??±???\n        flag=\"Failed\"\n        break\n    std_node=copy.deepcopy(std)    #?????????????????????????????????????°????????????????????????????????¨????\n    if std_node[3]==goal_state: #????????????????????????????????´???????????¶?????¨?????´????????°??¢?´¢??????\n        flag=\"Done\"\n        break\n\nif flag==\"Done\":    #??¢?´¢?????????????????´????????´???????????§???????????????????????°??¨????????¶????????¨???\n    print(std_node[0])\nelif flag==\"Failed\":    #??¢?´¢?????±???????????´???????????¨?????????\n    print(\"Search failed\")"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN = 3\nm = {8: {7, 5}, 7: {8, 6, 4}, 6: {7, 3}, 5: {8, 4, 2}, 4: {7, 5, 3, 1}, 3: {6, 4, 0}, 2: {5, 1}, 1: {4, 2, 0},\n     0: {3, 1}}\ngoal = 123456780\ndef g(i, j, a):\n    t = a // (10 ** j) % 10\n    return a - t * (10 ** j) + t * (10 ** i)\ndef solve():\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n    zero = 8 - MAP.find(\"0\")\n    start = int(MAP)\n    if MAP == goal:\n        return 0\n    dp = deque([(0, start, zero, 1), (0, goal, 0, 0)])\n    TABLE = {start: (1, 0), goal: (0, 0)}\n    while dp:\n        cnt, M, yx, flg = dp.popleft()\n        cnt += 1\n        for nyx in m[yx]:\n            key = g(yx, nyx, M)\n            if key in TABLE:\n                if TABLE[key][0] != flg:\n                    return TABLE[key][1] + cnt\n                continue\n            TABLE[key] = (flg, cnt)\n            dp.append((cnt, key, nyx, flg))\ndef MAIN():\n    print(solve())\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    q.append((sumcost,0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = q.pop(0)\n        c_dWithH = items[0]\n        c_depth = items[1]\n        _i = items[2]\n        _j = items[3]\n        prev_move = items[4]\n        c_puz = items[5]\n        _sum_cost = c_dWithH - c_depth\n\n        if(c_dWithH - c_depth == 0):\n            finding = 1\n            print(c_depth)\n            break\n        if(c_dWithH > depth):\n            continue\n\n        c_cost = simpleHS(c_puz,_i,_j)\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            q.append((c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i-1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i-1,_j)),c_depth+1,_i-1,_j,2,swap_puz))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            q.append((c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i+1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i+1,_j)),c_depth+1,_i+1,_j,1,swap_puz))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            q.append((c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j-1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j-1)),c_depth+1,_i,_j-1,4,swap_puz))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            q.append((c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j+1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j+1)),c_depth+1,_i,_j+1,3,swap_puz))\n\ndef checkCost(c_cost,m_cost,c2_cost,m2_cost):\n    return c2_cost - c_cost + m2_cost - m_cost\n    \n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz,i,j):\n    if(correctPuz[i*3+j] != c_puz[i*3+j]):\n        return 1\n    return 0\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nsumcost=0\nfor i in range(len(correctPuz)):\n    if(correctPuz[i] != puz[i]):\n        sumcost+=1\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth) >= depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            heapq.heappush(q,(c_depth+1,_i-1,_j,2,swapPuz(c_puz[0:],_i,_j,_i-1,_j)))\n        if(_i != 2 and prev_move != 2):\n            heapq.heappush(q,(c_depth+1,_i+1,_j,1,swapPuz(c_puz[0:],_i,_j,_i+1,_j)))\n        if(_j != 0 and prev_move != 3):\n            heapq.heappush(q,(c_depth+1,_i,_j-1,4,swapPuz(c_puz[0:],_i,_j,_i,_j-1)))\n        if(_j != 2 and prev_move != 4):\n            heapq.heappush(q,(c_depth+1,_i,_j+1,3,swapPuz(c_puz[0:],_i,_j,_i,_j+1)))\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(c_puz):\n    value = 0\n    for i in range(len(c_puz)):\n        k = correctPuz.index(c_puz[i])\n        _i = (int)(i/3)\n        _j = i - _i*3\n        ki = (int)(k/3)\n        kj = k - ki*3\n        value = abs(_i-ki)+abs(_j-kj) \n\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import time import math class Node: def __init__(self, board, parent, fValue, depth): self.board = board self.parent = parent self.fValue = fValue self.depth = depth def __eq__(self, other): return self.board == other.board def __lt__(self, other): return self.fValue < other.fValue def __hash__(self): return hash(self.board) def __bool__(self): return True class Board: # The 8-puzzle board representation # def __init__(self, matrix): self.matrix = matrix for i in range(len(matrix)): if 0 in matrix[i]: self.blankPos = (i, matrix[i].index(0)) def __str__(self): s = \"\" for i in range(len(self.matrix)): s += str(self.matrix[i]) + \"\\n\" return s + \"\\n\" def __eq__(self, other): otherMatrix = other.matrix thisMatrix = self.matrix if len(thisMatrix) != len(otherMatrix): return False for i in range(len(thisMatrix)): if len(thisMatrix[i]) != len(otherMatrix[i]): return False for j in range(len(thisMatrix[i])): if thisMatrix[i][j] != otherMatrix[i][j]: return False return True def duplicate(self): newMatrix = [] for i in range(len(self.matrix)): newMatrix.append([]) for j in range(len(self.matrix[i])): newMatrix[i].append(self.matrix[i][j]) return Board(newMatrix) def findElement(self, elem): for i in range(len(self.matrix)): for j in range(len(self.matrix[i])): if self.matrix[i][j] == elem: return (i, j) return None def slideBlank(self, dir): # dir is a tuple (deltaY,deltaX) if dir not in [(0, 1), (0, -1), (-1, 0), (1, 0)]: raise ValueError(\"Invalid dir\") newBlankPos = (self.blankPos[0] + dir[0], self.blankPos[1] + dir[1]) if newBlankPos[0] < 0 or newBlankPos[0] > len(self.matrix) - 1: return None elif newBlankPos[1] < 0 or newBlankPos[1] > len(self.matrix[0]) - 1: return None else: newBoard = self.duplicate() saveVal = newBoard.matrix[self.blankPos[0] + dir[0]][self.blankPos[1] + dir[1]] newBoard.matrix[self.blankPos[0] + dir[0]][self.blankPos[1] + dir[1]] = 0 newBoard.matrix[self.blankPos[0]][self.blankPos[1]] = saveVal newBoard.blankPos = (self.blankPos[0] + dir[0], self.blankPos[1] + dir[1]) return newBoard def __hash__(self): s = 0 for i in range(len(self.matrix)): for j in range(len(self.matrix[i])): s *= 10 s += self.matrix[i][j] return s def fastSearch(frontier, goalBoard, explored): curNode = frontier.pop(0) explored.add(curNode) if curNode.board == goalBoard: print(curNode.depth) return True aStarExpansion(curNode, frontier, goalBoard, explored) return False def fastSearchClient(board, goalBoard): frontier = [Node(board, None, heuristic(board, goalBoard), 0)] explored = set() limit = 0 while (limit < 1000): retval = fastSearch(frontier, goalBoard, explored) if retval: return limit += 1 return # Function to expand the frontier using aStar # def aStarExpansion(currentNode, frontier, goalBoard, explored): sideLength = len(currentNode.board.matrix) pos = currentNode.board.blankPos depth = currentNode.depth + 1 toInsert = [] # if we can move there, make a node and put it in toInsert if pos[0] != 0: upCost = depth + heuristic(currentNode.board.slideBlank((-1, 0)), goalBoard) upNode = Node(currentNode.board.slideBlank((-1, 0)), currentNode, upCost, depth) toInsert.append(upNode) if pos[0] != sideLength - 1: downCost = depth + heuristic(currentNode.board.slideBlank((1, 0)), goalBoard) downNode = Node(currentNode.board.slideBlank((1, 0)), currentNode, downCost, depth) toInsert.append(downNode) if pos[1] != 0: leftCost = depth + heuristic(currentNode.board.slideBlank((0, -1)), goalBoard) leftNode = Node(currentNode.board.slideBlank((0, -1)), currentNode, leftCost, depth) toInsert.append(leftNode) if pos[1] != sideLength - 1: rightCost = depth + heuristic(currentNode.board.slideBlank((0, 1)), goalBoard) rightNode = Node(currentNode.board.slideBlank((0, 1)), currentNode, rightCost, depth) toInsert.append(rightNode) # if we've already been there, we don't want to try that board again for node in explored: for insertNode in toInsert: if insertNode == node: toInsert.remove(insertNode) # now we are putting the nodes to be inserted into the correct place in frontier for node in toInsert: for i in range(len(frontier) + 1): if i == len(frontier): frontier.append(node) break if frontier[i] > node: frontier.insert(i, node) break def heuristic(currentBoard, goalBoard): currentMatrix = currentBoard.matrix sum = 0 for i in range(len(currentMatrix)): for j in range(len(currentMatrix[i])): cur = currentMatrix[i][j] if cur % 3 == 0: curx = 3 else: curx = cur % 3 if cur != 0: sum += abs(curx - (j + 1)) + abs(math.ceil(cur / 3) - (i + 1)) return sum arr = [[1 for i in range(3)] for j in range(3)] for i in range(3): arr[i][0], arr[i][1], arr[i][2] = input().split() for i in range(3): for j in range(3): arr[i][j] = int(arr[i][j]) fastSearchClient(Board(arr), Board([[1, 2, 3], [4, 5, 6], [7, 8, 0]]))\n"
  },
  {
    "language": "Python",
    "code": "N = 3\ndx = [0,-1,0,1]\ndy = [1,0,-1,0]\nlimit = 0\nt = [[0 for i in range(N)] for j in range(N)]\n\ndef getH():\n    sum = 0\n    x = int(0)\n    for i in range(N):\n        for j in range(N):\n            if t[i][j]==0:continue\n            x=t[i][j]-1\n            sum += abs(int(x/N)-i)+abs((int(x%N)-j))\n    return sum\n\ndef dfs( depth, prev,py,px):\n    h=getH()\n    if h == 0 :return True \n    if depth+h > limit: return False\n    for i in range(4):\n        if abs(i-prev) == 2 : continue\n        tx=px+dx[i]\n        ty=py+dy[i]\n        if tx<0 or ty<0 or tx>=N or ty>=N:continue\n        t[ty][tx],t[py][px] = t[py][px],t[ty][tx]\n        if dfs(depth+1,i,ty,tx) :return True\n        t[ty][tx],t[py][px] = t[py][px],t[ty][tx]\n    return False\n\ndef Solve(py, px):\n    global limit\n    limit =0\n    while True:\n        if dfs(0,99,py,px):\n            print(limit)\n            return \n        limit += 1\n \nif __name__=='__main__':\n    for i in range(N):\n        tmp =list(map(int, input().split()))\n        for j in range(N):\n            t[i][j]=tmp[j]\n            if t[i][j]==0:\n                py=i\n                px=j\n    Solve(py,px)\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ninit = ''.join(sys.stdin.read().split())\n\n# Bidirectional search using breadth-first search\ndef solve(start, goal):\n    generated_state = {start: 0, goal: 1}   # 0: foreward, 1: backward\n    step = {start: 0, goal: 0}\n    s = 0\n    c_d = [(start, 0), (goal, 1)] # configure and direction\n    while True:\n        q = iter(c_d)\n        c_d = []\n        s += 1\n        for c, d in q:\n            i = c.find('0')\n            if 0 <= i <= 5:\n                t = str.maketrans('0' + c[i+3], c[i+3] + '0')\n                t_c = c.translate(t)\n                if t_c in generated_state:\n                    if generated_state[t_c] != d:\n                        return s + step[t_c]\n                else:\n                    generated_state[t_c] = d\n                    step[t_c] = s\n                    c_d.append((t_c, d))\n            if i >= 3:\n                t = str.maketrans('0' + c[i-3], c[i-3] + '0')\n                t_c = c.translate(t)\n                if t_c in generated_state:\n                    if generated_state[t_c] != d:\n                        return s + step[t_c]\n                else:\n                    generated_state[t_c] = d\n                    step[t_c] = s\n                    c_d.append((t_c, d))\n            if i == 0 or i == 1 or i == 3 or i == 4 or i == 6 or i == 7:\n                t = str.maketrans('0' + c[i+1], c[i+1] + '0')\n                t_c = c.translate(t)\n                if t_c in generated_state:\n                    if generated_state[t_c] != d:\n                        return s + step[t_c]\n                else:\n                    generated_state[t_c] = d\n                    step[t_c] = s\n                    c_d.append((t_c, d))\n            if i == 1 or i == 2 or i == 4 or i == 5 or i == 7 or i == 8:\n                t = str.maketrans('0' + c[i-1], c[i-1] + '0')\n                t_c = c.translate(t)\n                if t_c in generated_state:\n                    if generated_state[t_c] != d:\n                        return s + step[t_c]\n                else:\n                    generated_state[t_c] = d\n                    step[t_c] = s\n                    c_d.append((t_c, d))\n\nprint(solve(init, '123456780'))"
  },
  {
    "language": "Python",
    "code": "import copy\nN = 3\n\n\ndef solved(game):\n    for i in range(N):\n        for j in range(N):\n            if (game[i][j] - 1) != i * N + j and game[i][j] != 0:\n                return False\n    return True\n\n\ndef calc_cost(game):\n    cost = 0\n\n    for i in range(N):\n        for j in range(N):\n            if game[i][j] != 0:\n                ideal = (int((game[i][j] - 1) / N), (game[i][j] - 1) % N)\n                cost += abs(i - ideal[0]) + abs(j - ideal[1])\n\n    return cost\n\ngames = []\n\ninit = [[] for i in range(N)]\n\nfor i in range(N):\n    init[i] = [int(item) for item in input().split()]\n    for j in range(N):\n        if init[i][j] == 0:\n            #queue.put((i, j))\n            zero = (i, j)\n\ngames = games + [(init, zero, calc_cost(init), 0)]\ndirection = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n\nwhile len(games) > 0:\n    current = games.pop(0)\n    zero = current[1]\n    if solved(current[0]):\n        print(current[3])\n        break\n\n    for d in direction :\n        next_step = (zero[0] + d[0], zero[1] + d[1])\n        if next_step[0] >= 0 and next_step[0] <= 2 and next_step[1] >= 0 and next_step[1] <= 2:\n\n            tmp = copy.deepcopy(current[0])\n            tmp[zero[0]][zero[1]], tmp[next_step[0]][next_step[1]] = tmp[next_step[0]][next_step[1]], tmp[zero[0]][zero[1]]\n            tmp_cost = calc_cost(tmp)\n\n            if tmp_cost <= current[2]:\n                games = games + [(tmp, next_step, tmp_cost, current[3]+1)]\n\n    games.sort(key=lambda x: x[2])\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    q.append((simpleHS(puz),0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_dWithH = items[0]\n        c_depth = items[1]\n        _i = items[2]\n        _j = items[3]\n        prev_move = items[4]\n        c_puz = items[5]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n        if((c_depth+c_dWithH) > depth):\n            continue\n            \n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i-1,_j,2,swap_puz))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i+1,_j,1,swap_puz))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j-1,4,swap_puz))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j+1,3,swap_puz))\n\ndef checkPuzIsExisted(puz,q):\n    for i in range(len(q)):\n        exist_puz = q[i][4]\n        count = 0\n        for j in range(len(exist_puz)):\n            if(exist_puz[j] != puz[j]):\n                count = 1\n        if(count == 0):\n            return True\n    return False\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(sumcost,(0,i,j,0,puz)))\n    global finding\n\n    while len(q):\n        c_dWithH, items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        _sum_cost = c_dWithH - c_depth\n\n        if(c_dWithH - c_depth == 0):\n            finding = 1\n            print(c_depth)\n            break\n        if(c_dWithH > depth):\n            continue\n\n        c_cost = simpleHS(c_puz,_i,_j)\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            heapq.heappush(q,(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i-1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i-1,_j)),(c_depth+1,_i-1,_j,2,swap_puz)))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            heapq.heappush(q,(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i+1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i+1,_j)),(c_depth+1,_i+1,_j,1,swap_puz)))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            heapq.heappush(q,(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j-1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j-1)),(c_depth+1,_i,_j-1,4,swap_puz)))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            heapq.heappush(q,(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j+1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j+1)),(c_depth+1,_i,_j+1,3,swap_puz)))\n\ndef checkCost(c_cost,m_cost,c2_cost,m2_cost):\n    return c2_cost - c_cost + m2_cost - m_cost\n    \n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz,i,j):\n    if(correctPuz[i*3+j] != c_puz[i*3+j]):\n        return 1\n    return 0\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nsumcost=0\nfor i in range(len(correctPuz)):\n    if(correctPuz[i] != puz[i]):\n        sumcost+=1\n\nfinding = 0\ndepth = sumcost\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(0,i,j,0,puz,costs))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        _costs = items[5]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+sumCost(_costs)) >= depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[(_i-1)*3+_j] = HS(_i-1,_j,swap_puz[(_i-1)*3+_j])\n            if(not checkPuzIsExisted(swap_puz,q)):\n                heapq.heappush(q,(c_depth+1,_i-1,_j,2,swap_puz,swap_cost))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[(_i+1)*3+_j] = HS(_i+1,_j,swap_puz[(_i+1)*3+_j])\n            if(not checkPuzIsExisted(swap_puz,q)):\n                heapq.heappush(q,(c_depth+1,_i+1,_j,1,swap_puz,swap_cost))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[_i*3+_j-1] = HS(_i,_j-1,swap_puz[_i*3+_j-1])\n            if(not checkPuzIsExisted(swap_puz,q)):\n                heapq.heappush(q,(c_depth+1,_i,_j-1,4,swap_puz,swap_cost))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[_i*3+_j+1] = HS(_i,_j+1,swap_puz[_i*3+_j+1])\n            if(not checkPuzIsExisted(swap_puz,q)):\n                heapq.heappush(q,(c_depth+1,_i,_j+1,3,swap_puz,swap_cost))\n\ndef checkPuzIsExisted(puz,q):\n    for i in range(len(q)):\n        exist_puz = q[i][4]\n        count = 0\n        for j in range(len(exist_puz)):\n            if(exist_puz[j] != puz[j]):\n                count = 1\n        if(count == 0):\n            return True\n    return False\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i*3\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(simpleHS(puz),(0,i,j,0,puz)))\n    global finding\n\n    while len(q):\n        c_dWithH, items = q.pop(0)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n        if((c_dWithH) > depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),(c_depth+1,_i-1,_j,2,swap_puz)))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),(c_depth+1,_i+1,_j,1,swap_puz)))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),(c_depth+1,_i,_j-1,4,swap_puz)))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),(c_depth+1,_i,_j+1,3,swap_puz)))\n\ndef checkPuzIsExisted(puz,q):\n    for i in range(len(q)):\n        exist_puz = q[i][4]\n        count = 0\n        for j in range(len(exist_puz)):\n            if(exist_puz[j] != puz[j]):\n                count = 1\n        if(count == 0):\n            return True\n    return False\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i*3\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(simpleHS(swap_puz),0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_dWithH = items[0]\n        c_depth = items[1]\n        _i = items[2]\n        _j = items[3]\n        prev_move = items[4]\n        c_puz = items[5]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+c_dWithH) >= depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i-1,_j,2,swap_puz))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i+1,_j,1,swap_puz))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j-1,4,swap_puz))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j+1,3,swap_puz))\n\ndef checkPuzIsExisted(puz,q):\n    for i in range(len(q)):\n        exist_puz = q[i][4]\n        count = 0\n        for j in range(len(exist_puz)):\n            if(exist_puz[j] != puz[j]):\n                count = 1\n        if(count == 0):\n            return True\n    return False\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "import time\nimport math\n\nclass Node:\n    def __init__(self, board, parent, fValue, depth):\n        self.board = board\n        self.parent = parent\n        self.fValue = fValue\n        self.depth = depth\n\n    def __eq__(self, other):\n        return self.board == other.board\n\n    def __lt__(self, other):\n        return self.fValue < other.fValue\n\n    def __hash__(self):\n        return hash(self.board)\n\n    def __bool__(self):\n        return True\n\nclass Board:\n    # The 8-puzzle board representation #\n    def __init__(self, matrix):\n        self.matrix = matrix\n\n        for i in range(len(matrix)):\n            if 0 in matrix[i]:\n                self.blankPos = (i, matrix[i].index(0))\n\n    def __str__(self):\n        s = \"\"\n        for i in range(len(self.matrix)):\n            s += str(self.matrix[i]) + \"\\n\"\n        return s + \"\\n\"\n\n    def __eq__(self, other):\n        otherMatrix = other.matrix\n        thisMatrix = self.matrix\n\n        if len(thisMatrix) != len(otherMatrix):\n            return False\n        for i in range(len(thisMatrix)):\n            if len(thisMatrix[i]) != len(otherMatrix[i]):\n                return False\n            for j in range(len(thisMatrix[i])):\n                if thisMatrix[i][j] != otherMatrix[i][j]:\n                    return False\n        return True\n\n    def duplicate(self):\n        newMatrix = []\n        for i in range(len(self.matrix)):\n            newMatrix.append([])\n            for j in range(len(self.matrix[i])):\n                newMatrix[i].append(self.matrix[i][j])\n        return Board(newMatrix)\n\n    def findElement(self, elem):\n        for i in range(len(self.matrix)):\n            for j in range(len(self.matrix[i])):\n                if self.matrix[i][j] == elem:\n                    return (i, j)\n        return None\n\n    def slideBlank(self, dir):\n        # dir is a tuple (deltaY,deltaX)\n        if dir not in [(0, 1), (0, -1), (-1, 0), (1, 0)]:\n            raise ValueError(\"Invalid dir\")\n        newBlankPos = (self.blankPos[0] + dir[0], self.blankPos[1] + dir[1])\n        if newBlankPos[0] < 0 or newBlankPos[0] > len(self.matrix) - 1:\n            return None\n        elif newBlankPos[1] < 0 or newBlankPos[1] > len(self.matrix[0]) - 1:\n            return None\n        else:\n            newBoard = self.duplicate()\n            saveVal = newBoard.matrix[self.blankPos[0] + dir[0]][self.blankPos[1] + dir[1]]\n            newBoard.matrix[self.blankPos[0] + dir[0]][self.blankPos[1] + dir[1]] = 0\n            newBoard.matrix[self.blankPos[0]][self.blankPos[1]] = saveVal\n            newBoard.blankPos = (self.blankPos[0] + dir[0], self.blankPos[1] + dir[1])\n            return newBoard\n\n    def __hash__(self):\n        s = 0\n        for i in range(len(self.matrix)):\n            for j in range(len(self.matrix[i])):\n                s *= 10\n                s += self.matrix[i][j]\n\n        return s\n\n\ndef fastSearch(frontier, goalBoard, explored):\n    curNode = frontier.pop(0)\n    explored.add(curNode)\n    if curNode.board == goalBoard:\n        print(curNode.depth)\n        return True\n    aStarExpansion(curNode, frontier, goalBoard, explored)\n    return False\n\n\ndef fastSearchClient(board, goalBoard):\n    frontier = [Node(board, None, heuristic(board, goalBoard), 0)]\n    explored = set()\n\n    limit = 0\n\n    while (limit < 1000):\n        retval = fastSearch(frontier, goalBoard, explored)\n        if retval:\n            return\n        limit += 1\n    return\n\n# Function to expand the frontier using aStar #\ndef aStarExpansion(currentNode, frontier, goalBoard, explored):\n    sideLength = len(currentNode.board.matrix)\n    pos = currentNode.board.blankPos\n    depth = currentNode.depth + 1\n    toInsert = []\n\n    # if we can move there, make a node and put it in toInsert\n    if pos[0] != 0:\n        upCost = depth + heuristic(currentNode.board.slideBlank((-1, 0)), goalBoard)\n        upNode = Node(currentNode.board.slideBlank((-1, 0)), currentNode, upCost, depth)\n        toInsert.append(upNode)\n    if pos[0] != sideLength - 1:\n        downCost = depth + heuristic(currentNode.board.slideBlank((1, 0)), goalBoard)\n        downNode = Node(currentNode.board.slideBlank((1, 0)), currentNode, downCost, depth)\n        toInsert.append(downNode)\n    if pos[1] != 0:\n        leftCost = depth + heuristic(currentNode.board.slideBlank((0, -1)), goalBoard)\n        leftNode = Node(currentNode.board.slideBlank((0, -1)), currentNode, leftCost, depth)\n        toInsert.append(leftNode)\n    if pos[1] != sideLength - 1:\n        rightCost = depth + heuristic(currentNode.board.slideBlank((0, 1)), goalBoard)\n        rightNode = Node(currentNode.board.slideBlank((0, 1)), currentNode, rightCost, depth)\n        toInsert.append(rightNode)\n\n    # if we've already been there, we don't want to try that board again\n    for node in explored:\n        for insertNode in toInsert:\n            if insertNode == node:\n                toInsert.remove(insertNode)\n\n    # now we are putting the nodes to be inserted into the correct place in frontier\n    for node in toInsert:\n        for i in range(len(frontier) + 1):\n            if i == len(frontier):\n                frontier.append(node)\n                break\n            if frontier[i] > node:\n                frontier.insert(i, node)\n                break\n\ndef heuristic(currentBoard, goalBoard):\n    currentMatrix = currentBoard.matrix\n    sum = 0\n\n    for i in range(len(currentMatrix)):\n        for j in range(len(currentMatrix[i])):\n            cur = currentMatrix[i][j]\n\n            if cur % 3 == 0:\n                curx = 3\n            else:\n                curx = cur % 3\n\n            if cur != 0:\n                sum += abs(curx - (j + 1)) + abs(math.ceil(cur / 3) - (i + 1))\n\n    return sum\n\narr = [[1 for i in range(3)] for j in range(3)]\n\nfor i in range(3):\n    arr[i][0], arr[i][1], arr[i][2] = raw_input().split()\n\n\nfor i in range(3):\n    for j in range(3):\n        arr[i][j] = int(arr[i][j])\n\nfastSearchClient(Board(arr), Board([[1, 2, 3], [4, 5, 6], [7, 8, 0]]))\n\n"
  },
  {
    "language": "Python",
    "code": "import copy\nfrom typing import List, Tuple\n\n\ndef _generate_goal() -> List[List[int]]:\n    goal = [[0] * 3 for _ in range(3)]\n    for row in range(3):\n        for col in range(3):\n            if 9 == 3 * row + col + 1:\n                goal[row][col] = 0\n            else:\n                goal[row][col] = 3 * row + col + 1\n    return goal\n\n\ndef _find_zero_pos(board: List[List[int]]) -> Tuple[int, int]:\n    for row in range(3):\n        for col in range(3):\n            if 0 == board[row][col]:\n                return (row, col)\n    # Never reaches here.\n    return (-1, -1)\n\n\ndef _swappable_cand(zero_pos: Tuple[int, int]) -> List[Tuple[int, int]]:\n    row, col = zero_pos[0], zero_pos[1]\n    cand_pos_list: List[Tuple[int, int]] = []\n    if 0 != row:\n        cand_pos_list.append((row - 1, col))\n    if 2 != row:\n        cand_pos_list.append((row + 1, col))\n    if 0 != col:\n        cand_pos_list.append((row, col - 1))\n    if 2 != col:\n        cand_pos_list.append((row, col + 1))\n\n    return cand_pos_list\n\n\ndef solve_8puzzle(board: List[List[int]]) -> int:\n    goal = _generate_goal()\n    if board == goal:\n        return 0\n    generated_boards = {tuple(sum(board, [])): 0, tuple(sum(goal, [])): 1}\n    steps = {tuple(sum(board, [])): 0, tuple(sum(goal, [])): 0}\n    step = 0\n    state = [(board, 0), (goal, 1)]\n    while state:\n        state_copied = copy.deepcopy(state)\n        state = []\n        step += 1\n        for s2, d in state_copied:\n            zero_row, zero_col = _find_zero_pos(s2)\n            cand_pos_list = _swappable_cand((zero_row, zero_col))\n            for (row, col) in cand_pos_list:\n                s1 = copy.deepcopy(s2)\n                s1[zero_row][zero_col], s1[row][col] = s1[row][col], 0\n                key = tuple(sum(s1, []))\n                if key in generated_boards:\n                    if generated_boards[key] != d:\n                        return step + steps[key]\n                    continue\n                state.append((s1, d))\n                generated_boards[key] = d\n                steps[key] = step\n    # Never reaches here.\n    return -1\n\n\nif __name__ == \"__main__\":\n    board = [[0] * 3 for _ in range(3)]\n\n    for row in range(3):\n        input_nums = list(map(lambda x: int(x), input().split()))\n        for col in range(3):\n            # if 0 == input_nums[col]:\n            #     zero_pos = (row, col)\n            board[row][col] = input_nums[col]\n\n    print(f\"{solve_8puzzle(board)}\")\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(sumcost,(0,i,j,0,puz)))\n    global finding\n\n    while len(q):\n        c_dWithH, items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        _sum_cost = c_dWithH - c_depth\n\n        if(c_dWithH - c_depth == 0):\n            finding = 1\n            print(c_depth)\n            break\n        if(c_dWithH > depth):\n            continue\n\n        c_cost = simpleHS(c_puz,_i,_j)\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            n_cost = c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i-1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i-1,_j))\n            if(n_cost <= depth):\n                heapq.heappush(q,(n_cost,(c_depth+1,_i-1,_j,2,swap_puz)))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            n_cost = c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i+1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i+1,_j))\n            if(n_cost <= depth):\n                heapq.heappush(q,(n_cost,(c_depth+1,_i+1,_j,1,swap_puz)))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            n_cost = c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j-1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j-1))\n            if(n_cost <= depth):\n                heapq.heappush(q,(n_cost,(c_depth+1,_i,_j-1,4,swap_puz)))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            n_cost = c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j+1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j+1))\n            if(n_cost <= depth):\n                heapq.heappush(q,(n_cost,(c_depth+1,_i,_j+1,3,swap_puz)))\n\ndef checkCost(c_cost,m_cost,c2_cost,m2_cost):\n    return c2_cost - c_cost + m2_cost - m_cost\n    \n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz,i,j):\n    if(correctPuz[i*3+j] != c_puz[i*3+j]):\n        return 1\n    return 0\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nsumcost=0\nfor i in range(len(correctPuz)):\n    if(correctPuz[i] != puz[i]):\n        sumcost+=1\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "import copy\n\ndef movable_state(state):\n    x, y = None, None\n    for i in range(3):\n        for j in range(3):\n            if state[3*i+j] == 0:\n                x, y = i, j\n                break\n\n    rsts = []\n    for r, c in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:\n        if 0 <= r and r < 3 and 0 <= c and c < 3:\n            rst = copy.copy(state)\n            rst[3*x+y], rst[3*r+c] = rst[3*r+c], rst[3*x+y]\n            rsts.append(rst)\n    return rsts\n\ndef hist_check(state, depth):\n    for i in range(depth-2, -1, -1):\n        for hist in state_history[i]:\n            if hist == state:\n                return True\n    return False\n\npuzzle = []\nfor i in range(3):\n    puzzle.extend(list(map(int, input().split(' '))))\nstate_history = [[puzzle]]\n\ngoal = [1, 2, 3, 4, 5, 6, 7, 8, 0]\nexchange_num = 0\ndepth = 0\nstill_not = True\nwhile still_not:\n    depth += 1\n    state_history.append([])\n    for hist in state_history[depth-1]:\n        next_states = movable_state(hist)\n        for next_stat in next_states:\n            if hist_check(next_stat, depth): continue\n            if next_stat == goal:\n                still_not = False\n                break\n            state_history[depth].append(next_stat)\n        if not still_not: break\nprint(depth)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(0,i,j,0,puz,costs))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        _costs = items[5]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+sumCost(_costs)) >= depth or (c_depth+simpleHS(c_puz) >= depth)):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[(_i-1)*3+_j] = HS(_i-1,_j,swap_puz[(_i-1)*3+_j])\n            heapq.heappush(q,(c_depth+1,_i-1,_j,2,swap_puz,swap_cost))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[(_i+1)*3+_j] = HS(_i+1,_j,swap_puz[(_i+1)*3+_j])\n            heapq.heappush(q,(c_depth+1,_i+1,_j,1,swap_puz,swap_cost))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[_i*3+_j-1] = HS(_i,_j-1,swap_puz[_i*3+_j-1])\n            heapq.heappush(q,(c_depth+1,_i,_j-1,4,swap_puz,swap_cost))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[_i*3+_j+1] = HS(_i,_j+1,swap_puz[_i*3+_j+1])\n            heapq.heappush(q,(c_depth+1,_i,_j+1,3,swap_puz,swap_cost))\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i*3\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nMOVE = {'U': (0, -1), 'D': (0, 1), 'L': (-1, 0), 'R': (1, 0)}\n\ndef next(numbers):\n    for d in 'UDLR':\n        z = numbers.index(0)\n        tx, ty = z % 3 + MOVE[d][0], z // 3 + MOVE[d][1]\n        if 0 <= tx < 3 and 0 <= ty < 3:\n            t = ty * 3 + tx\n            result = list(numbers)\n            result[z], result[t] = numbers[t], 0\n            yield d, tuple(result)\n\ndef bfs(puzzle):\n    queue = deque([(puzzle, '')])\n    seen = set()\n    while queue:\n        numbers, route = queue.popleft()\n        seen.add(numbers)\n        if numbers == (1, 2, 3, 4, 5, 6, 7, 8, 0):\n            return route\n        for direction, new_numbers in next(numbers):\n            if new_numbers not in seen:\n                queue.append((new_numbers, route + direction))\n    return route\n\npuzzle = ()\nfor i in range(3):\n    a,b,c = map(int, input().split())\n    puzzle += (a,b,c)\n\nprint(len(bfs(puzzle)))\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict,deque\nimport sys\n\n\nM = [list(map(int,input().split())) for _ in range(3)]\n\nstart = 0\nfor i in range(3):\n    for j in range(3):\n        start += M[i][j]*10**((2-i)*3 + (2-j))\nstart = \"{:0>9}\".format(start)\n\ndef make_next_states(h,w,s):\n    ret = []\n    x = [-1,0,1,0]\n    y = [0,-1,0,1]\n    for i in range(4):\n        nh,nw = h+y[i],w+x[i]\n        if (0<=nh<=2) and (0<=nw<=2):\n            swap_ind = nh*3 + nw\n            char = s[swap_ind]\n            next_s = s.replace(char,\"x\").replace(\"0\",char).replace(\"x\",\"0\")\n            ret.append(next_s)\n    return ret\n\nfinished = defaultdict(bool)\nfinished[start] = True\n\nq = deque()\nq.append([start,0])\nwhile 1:\n    s,n = q.popleft()\n    finished[s] = True\n    if s == \"123456780\":\n        break\n    null = s.index(\"0\")\n    null_h = null//3\n    null_w = null%3\n    next_states = make_next_states(null_h,null_w,s)\n    for next_s in next_states:\n        if not finished[next_s]:\n            q.append([next_s,n+1])\n\nprint(n)\n    \n\n\n\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "def iterative(i,j):\n    q = []\n    q.append((simpleHS(puz),0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = q.pop(0)\n        c_dWithH = items[0]\n        c_depth = items[1]\n        _i = items[2]\n        _j = items[3]\n        prev_move = items[4]\n        c_puz = items[5]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n        if((c_depth+c_dWithH) > depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i-1,_j,2,swap_puz))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i+1,_j,1,swap_puz))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j-1,4,swap_puz))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j+1,3,swap_puz))\n"
  },
  {
    "language": "Python",
    "code": "import heapq\n\ndef d_manhattan(node_list):\n    s = 0\n    for i in range(9):\n        x_goal = i%3\n        y_goal = i//3\n        x_now = (node_list[i] - 1)%3\n        y_now = (node_list[i] - 1)//3\n        if y_now == -1:\n            y_now = 2\n        dx = abs(x_now - x_goal)\n        dy = abs(y_now - y_goal)\n        s += dx + dy\n    return s\n\ndef moveNodeE(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 1] = node_tmp[space + 1], node_tmp[space]\n    return node_tmp\ndef moveNodeW(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 1] = node_tmp[space - 1], node_tmp[space]\n    return node_tmp\ndef moveNodeN(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 3] = node_tmp[space - 3], node_tmp[space]\n    return node_tmp\ndef moveNodeS(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 3] = node_tmp[space + 3], node_tmp[space]\n    return node_tmp\n\nclass board:\n    def __init__(self, node_list, g):\n        self.node = node_list\n        self.space = node_list.index(0)\n        self.g = g\n        self.h = d_manhattan(node_list)\n        self.f = self.g + self.h\n\n    def makeBoard(self):\n        space = self.space\n        cost_now = self.f\n        x_s = space%3\n        y_s = space//3\n        if x_s < 2:\n            node_tmp = moveNodeE(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if x_s > 0:\n            node_tmp = moveNodeW(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s < 2:\n            node_tmp = moveNodeS(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s > 0:\n            node_tmp = moveNodeN(self.node, space)\n            yield board(node_tmp, self.g + 1)\n\nb_open = []\nn_close = {}\nn_goal = [1,2,3,4,5,6,7,8,0]\nn_start = []\n\nfor i in range(3):\n    inp = list(map(int, input().split()))\n    n_start.extend(inp)\n\nb_start = board(n_start, 0)\nheapq.heappush(b_open, (b_start.f, b_start.h, 0, b_start))\n\ni = 0\nwhile b_open:\n    _, _, _, b_now = heapq.heappop(b_open)\n    if b_now.node == n_goal:\n        b_goal = b_now\n        break\n    n_close[\"\".join(map(str, b_now.node))] = i\n    for b_new in b_now.makeBoard():\n        if \"\".join(map(str, b_new.node)) in n_close:\n            continue\n        heapq.heappush(b_open, (b_new.f, b_new.h, i, b_new))\n        i += 1\n\nprint(b_goal.g)"
  },
  {
    "language": "Python",
    "code": "N = 3\n#f = [input().split() for _ in range(3)]\nf = input().split()\nf += input().split()\nf += input().split()\ndd = [[-1, 0], [0, -1], [1, 0], [0, 1]]\n\nQ = [[f, f.index(\"0\"), 0]]\n#T = {f: True}\nT = set(f)\n\nwhile len(Q) > 0:\n    board = Q.pop(0)\n    if board[0] == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"0\"]:\n        break\n    x, y = int(board[1]/N), board[1]%N\n    for dx, dy in dd:\n        tx, ty = x+dx, y+dy\n        if tx<0 or ty<0 or tx>=N or ty>=N:\n            continue\n        new = board[:]\n\n        n1, n2 = board[1], tx*N+ty\n        new[1] = n2\n        # swap\n        if n1 > n2:\n            n1, n2 = n2, n1\n        # swaped string\n        new[0] = new[0][0:n1] + list(new[0][n2]) + new[0][n1+1:n2] + list(new[0][n1]) + new[0][n2+1:]\n        hashstr = \"\".join(new[0])\n        if hashstr not in T:\n            #T[new[0]] = True\n            T.add(hashstr)\n            new[2] += 1\n            Q.append(new)\n\nprint(board[2])\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or (c_depth+HS(c_puz)) > depth):\n        return\n\n    if(i != 0):\n        iterative(i-1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i-1,j))\n        if(finding == 1):\n            return\n    if(i != 2):\n        iterative(i+1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i+1,j))\n        if(finding == 1):\n            return\n    if(j != 0):\n        iterative(i,j-1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j-1))\n        if(finding == 1):\n            return\n    if(j != 2):\n        iterative(i,j+1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j+1))\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(c_puz):\n    value = 0\n    for i in range(len(c_puz)):\n        k = correctPuz.index(c_puz[i])\n        _i = (int)(i/3)\n        _j = i - _i\n        ki = (int)(k/3)\n        kj = k - ki\n        value = abs(_i-ki)+abs(_j-kj) \n\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import heapq\n\ndef d_manhattan(node_list):\n    s = 0\n    for i in range(9):\n        x_goal = i%3\n        y_goal = i//3\n        x_now = (node_list[i] - 1)%3\n        y_now = (node_list[i] - 1)//3\n        if y_now == -1:\n            y_now = 2\n        dx = abs(x_now - x_goal)\n        dy = abs(y_now - y_goal)\n        s += dx + dy\n    return s\n\ndef moveNodeE(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 1] = node_tmp[space + 1], node_tmp[space]\n    return node_tmp\ndef moveNodeW(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 1] = node_tmp[space - 1], node_tmp[space]\n    return node_tmp\ndef moveNodeN(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 3] = node_tmp[space - 3], node_tmp[space]\n    return node_tmp\ndef moveNodeS(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 3] = node_tmp[space + 3], node_tmp[space]\n    return node_tmp\n\nclass board:\n    def __init__(self, node_list, g):\n        self.node = node_list\n        self.space = node_list.index(0)\n        self.g = g\n        self.h = d_manhattan(node_list)\n        self.f = self.g + self.h\n\n    def makeBoard(self):\n        space = self.space\n        cost_now = self.f\n        x_s = space%3\n        y_s = space//3\n        if x_s < 2:\n            node_tmp = moveNodeE(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if x_s > 0:\n            node_tmp = moveNodeW(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s < 2:\n            node_tmp = moveNodeS(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s > 0:\n            node_tmp = moveNodeN(self.node, space)\n            yield board(node_tmp, self.g + 1)\n\nb_open = []\nn_close = {}\nn_goal = [1,2,3,4,5,6,7,8,0]\nn_start = []\n\nfor i in range(3):\n    inp = list(map(int, input().split()))\n    n_start.extend(inp)\n\nb_start = board(n_start, 0)\nheapq.heappush(b_open, (b_start.f, b_start.h, 0, b_start))\n\ni = 0\nwhile b_open:\n    _, _, _, b_now = heapq.heappop(b_open)\n    if b_now.node == n_goal:\n        b_goal = b_now\n        break\n    n_close[\"\".join(map(str, b_now.node))] = i\n    for b_new in b_now.makeBoard():\n        if \"\".join(map(str, b_new.node)) in n_close:\n            continue\n        heapq.heappush(b_open, (b_new.f, b_new.h, i, b_new))\n        i += 1\n\nprint(b_goal.g)"
  },
  {
    "language": "Python",
    "code": "import heapq\n\ndef d_manhattan(node_list):\n    s = 0\n    for i in range(9):\n        x_goal = i%3\n        y_goal = i//3\n        x_now = (node_list[i] - 1)%3\n        y_now = (node_list[i] - 1)//3\n        if y_now == -1:\n            y_now = 2\n        dx = abs(x_now - x_goal)\n        dy = abs(y_now - y_goal)\n        s += dx + dy\n    return s\n\ndef moveNodeE(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 1] = node_tmp[space + 1], node_tmp[space]\n    return node_tmp\ndef moveNodeW(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 1] = node_tmp[space - 1], node_tmp[space]\n    return node_tmp\ndef moveNodeN(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 3] = node_tmp[space - 3], node_tmp[space]\n    return node_tmp\ndef moveNodeS(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 3] = node_tmp[space + 3], node_tmp[space]\n    return node_tmp\n\nclass board:\n    def __init__(self, node_list, g):\n        self.node = node_list\n        self.space = node_list.index(0)\n        self.g = g\n        self.h = d_manhattan(node_list)\n        self.f = self.g + self.h\n\n    def makeBoard(self):\n        space = self.space\n        cost_now = self.f\n        x_s = space%3\n        y_s = space//3\n        if x_s < 2:\n            node_tmp = moveNodeE(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if x_s > 0:\n            node_tmp = moveNodeW(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s < 2:\n            node_tmp = moveNodeS(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s > 0:\n            node_tmp = moveNodeN(self.node, space)\n            yield board(node_tmp, self.g + 1)\n\nb_open = []\nn_close = {}\nn_goal = [1,2,3,4,5,6,7,8,0]\nn_start = []\n\nfor i in range(3):\n    inp = list(map(int, raw_input().split()))\n    n_start.extend(inp)\n\nb_start = board(n_start, 0)\nheapq.heappush(b_open, (b_start.f, b_start.h, 0, b_start))\n\ni = 0\nwhile b_open:\n    _, _, _, b_now = heapq.heappop(b_open)\n    if b_now.node == n_goal:\n        b_goal = b_now\n        break\n    n_close[\"\".join(map(str, b_now.node))] = i\n    for b_new in b_now.makeBoard():\n        if \"\".join(map(str, b_new.node)) in n_close:\n            continue\n        heapq.heappush(b_open, (b_new.f, b_new.h, i, b_new))\n        i += 1\n\nprint(b_goal.g)"
  },
  {
    "language": "Python",
    "code": "import heapq\n\ndef d_manhattan(node_list):\n    s = 0\n    for i in range(9):\n        x = (i+1)%3\n        y = (i+1)//3\n        if y == 3:\n            y = 0\n        dx = abs(node_list[i]%3 - x)\n        dy = abs(node_list[i]//3 - y)\n        s += dx + dy\n    return s\n\ndef moveNodeE(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 1] = node_tmp[space + 1], node_tmp[space]\n    return node_tmp\ndef moveNodeW(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 1] = node_tmp[space - 1], node_tmp[space]\n    return node_tmp\ndef moveNodeN(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 3] = node_tmp[space - 3], node_tmp[space]\n    return node_tmp\ndef moveNodeS(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 3] = node_tmp[space + 3], node_tmp[space]\n    return node_tmp\n\nclass board:\n    def __init__(self, node_list, g):\n        self.node = node_list\n        self.space = node_list.index(0)\n        self.g = g\n        self.h = d_manhattan(node_list)\n        self.f = self.g + self.h\n\n    def makeBoard(self):\n        space = self.space\n        cost_now = self.f\n        x_s = space%3\n        y_s = space//3\n        if x_s < 2:\n            node_tmp = moveNodeE(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if x_s > 0:\n            node_tmp = moveNodeW(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s < 2:\n            node_tmp = moveNodeS(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s > 0:\n            node_tmp = moveNodeN(self.node, space)\n            yield board(node_tmp, self.g + 1)\n\nb_open = []\nn_close = []\nn_goal = [1,2,3,4,5,6,7,8,0]\nn_start = []\n\nfor i in range(3):\n    inp = list(map(int, input().split()))\n    n_start.extend(inp)\n\nb_start = board(n_start, 0)\nheapq.heappush(b_open, (b_start.f, b_start.h, 0, b_start))\n\n\ni = 0\nwhile b_open:\n    _, _, _, b_now = heapq.heappop(b_open)\n    if b_now.node == n_goal:\n        b_goal = b_now\n        break\n    n_close.append(b_now.node)\n    for b_new in b_now.makeBoard():\n        if b_new.node in n_close:\n            continue\n        heapq.heappush(b_open, (b_new.f, b_new.h, i, b_new))\n        i += 1\n\nprint(b_goal.g)"
  },
  {
    "language": "Python",
    "code": "import copy\ndef hashnum(state):\n    num = 0\n    for i in range(3):\n        for j in range(3):\n            num *= 10\n            num += state[i][j]\n    return num\n\nanswer = 123456780\nini_state = []\nfor i in range(3):\n    temp = [int(n) for n in input().split(\" \")]\n    if 0 in temp:\n        zero_x, zero_y = temp.index(0), i\n    ini_state.append(temp)\nend_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\nqueue = [[ini_state, zero_x, zero_y, 0], [end_state, 2, 2, 1]]\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\nvisited = {}\nif hashnum(ini_state) == answer:\n    print(0)\nelse:\n    visited[hashnum(ini_state)] = [0, 0]\n    visited[answer] = [0, 1]\n    trial = 0\n    ended = 0\n    while queue:\n        new_queue = []\n        trial += 1\n        for q in queue:\n            if ended:\n                break\n            state, zero_x, zero_y, direction = q\n            for i in range(len(dx)):\n                new_state = copy.deepcopy(state)\n                new_x = zero_x + dx[i]\n                new_y = zero_y + dy[i]\n                if 0 <= new_x < 3 and 0 <= new_y < 3:\n                    new_state[new_y][new_x], new_state[zero_y][zero_x] = new_state[zero_y][zero_x], new_state[new_y][new_x]\n                    perm = hashnum(new_state)\n                    if perm in visited and direction != visited[perm][1]:\n                        print(trial + visited[perm][0])\n                        ended = 1\n                        break\n                    elif perm not in visited:\n                        visited[perm] = [trial, direction]\n                        new_queue.append([new_state, new_x, new_y, direction])\n        queue = new_queue"
  },
  {
    "language": "Python",
    "code": "import heapq\n\ndef d_manhattan(node_list):\n    s = 0\n    for i in range(9):\n        x = (i+1)%3\n        y = (i+1)//3\n        if y == 3:\n            y = 0\n        dx = abs(node_list[i]%3 - x)\n        dy = abs(node_list[i]//3 - y)\n        s += dx + dy\n    return s\n\ndef moveNodeE(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 1] = node_tmp[space + 1], node_tmp[space]\n    return node_tmp\ndef moveNodeW(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 1] = node_tmp[space - 1], node_tmp[space]\n    return node_tmp\ndef moveNodeN(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 3] = node_tmp[space - 3], node_tmp[space]\n    return node_tmp\ndef moveNodeS(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 3] = node_tmp[space + 3], node_tmp[space]\n    return node_tmp\n\nclass board:\n    def __init__(self, node_list, g):\n        self.node = node_list\n        self.space = node_list.index(0)\n        self.g = g\n        self.h = d_manhattan(node_list)\n        self.f = self.g + self.h\n\n    def makeBoard(self):\n        space = self.space\n        cost_now = self.f\n        x_s = space%3\n        y_s = space//3\n        if x_s < 2:\n            node_tmp = moveNodeE(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if x_s > 0:\n            node_tmp = moveNodeW(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s < 2:\n            node_tmp = moveNodeS(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s > 0:\n            node_tmp = moveNodeN(self.node, space)\n            yield board(node_tmp, self.g + 1)\n\nb_open = []\nn_close = []\nn_goal = [1,2,3,4,5,6,7,8,0]\nn_start = []\n\nfor i in range(3):\n    inp = list(map(int, input().split()))\n    n_start.extend(inp)\n\nb_start = board(n_start, 0)\nheapq.heappush(b_open, (b_start.f, b_start.h, 0, b_start))\n\ni = 0\nwhile b_open:\n    _, _, _, b_now = heapq.heappop(b_open)\n    if b_now.node == n_goal:\n        b_goal = b_now\n        break\n    n_close.append(b_now.node)\n    for b_new in b_now.makeBoard():\n        if b_new.node in n_close:\n            continue\n        heapq.heappush(b_open, (b_new.f, b_new.h, i, b_new))\n        i += 1\n\nprint(b_goal.g)"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    q.append(sumcost,0,i,j,0,puz)\n    global finding\n\n    while len(q):\n        c_dWithH, items = q.pop(0)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        _sum_cost = c_dWithH - c_depth\n\n        if(c_dWithH - c_depth == 0):\n            finding = 1\n            print(c_depth)\n            break\n        if(c_dWithH > depth):\n            continue\n\n        c_cost = simpleHS(c_puz,_i,_j)\n\n        print(c_depth)\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            q.append(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i-1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i-1,_j)),c_depth+1,_i-1,_j,2,swap_puz)\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            q.append(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i+1,_j),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i+1,_j)),c_depth+1,_i+1,_j,1,swap_puz)\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            q.append(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j-1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j-1)),c_depth+1,_i,_j-1,4,swap_puz)\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            q.append(c_depth+1+_sum_cost+checkCost(c_cost,simpleHS(c_puz,_i,_j+1),simpleHS(swap_puz,_i,_j),simpleHS(swap_puz,_i,_j+1)),c_depth+1,_i,_j+1,3,swap_puz)\n\ndef checkCost(c_cost,m_cost,c2_cost,m2_cost):\n    return c2_cost - c_cost + m2_cost - m_cost\n    \n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz,i,j):\n    if(correctPuz[i*3+j] != c_puz[i*3+j]):\n        return 1\n    return 0\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nsumcost=0\nfor i in range(len(correctPuz)):\n    if(correctPuz[i] != puz[i]):\n        sumcost+=1\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nfrom collections import deque\nimport copy\n\nclass Puzzle(list):\n    def __init__(self):\n        list.__init__(self)\n        self.space = None\n        self.path = \"\"\n    \n    def __hash__(self):\n        return hash(str(self[:]))\n\nif __name__ == '__main__':\n    \n    N = 3\n    N2 = 9\n    dx = [-1, 0, 1, 0]\n    dy = [0, -1, 0, 1]\n    d = [\"u\", \"l\", \"d\", \"r\"]\n\n    p = Puzzle()\n    for i in range(N):\n        p += [int(x) for x in input().split()]\n    for i in range(N2):\n        if p[i] == 0:\n            p[i] = N2\n            p.space = i\n    target = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    def isTarget(p):\n        return p[:] == target[:]\n\n    def bfs(s):\n        Q = deque()\n        V = set()\n        Q.append(s)\n        V.add(s)\n        while Q:\n            u = Q.popleft()\n            if isTarget(u):\n                return u.path\n            sx = u.space // N\n            sy = u.space % N\n            for r in range(4):\n                tx = sx + dx[r]\n                ty = sy + dy[r]\n                if not (0<= tx < N and 0 <= ty < N):\n                    continue\n                v = Puzzle()\n                v[:] = u[:]\n                v.path = u.path\n                change = tx * N + ty\n                v[u.space], v[change] = v[change], v[u.space]\n                v.space = change\n                if not v in V:\n                    V.add(v)\n                    v.path += d[r]\n                    Q.append(v)\n\n        return \"unsolvable\"\n\n    ans = bfs(p)\n    print(len(ans))\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from itertools import permutations\nfrom heapq import heappop, heappush\n\n\ndef main():\n    *A, = map(int, open(0).read().split())\n    initial = get_hash(A)\n    goal = get_hash([1, 2, 3, 4, 5, 6, 7, 8, 0])\n\n    ans = search(initial, goal)\n    print(ans)\n\n\ndef get_hash(A):\n    board = 0\n    for i, a in enumerate(A):\n        board += a << i*4\n    return board\n\n\ndef gen_move_table():\n    mask = 0b1111\n    dirs = [(-1, 0), (0, -1), (0, 1), (1, 0)]\n    ret = [[] for _ in [0]*9]\n    for y in range(3):\n        for x in range(3):\n            i = 3*y+x\n            for dy, dx in dirs:\n                dr = 3*dy+dx\n                if 0 <= y+dy < 3 and 0 <= x+dx < 3:\n                    sqmask = mask << (i+dr)*4\n                    ret[i].append((dr, sqmask))\n    return ret\n\n\ndef gen_next_board(board, move_table):\n    mask = 0b1111\n    ret = []\n    for i in range(9):\n        piece = board >> 4*i & mask\n        if piece == 0:\n            for move in move_table[i]:\n                ret.append(do_move(board, move))\n    return ret\n\n\ndef do_move(board, move):\n    dr, sqmask = move\n\n    sq = board & sqmask\n    board ^= sq\n    if dr > 0:\n        board ^= sq >> dr*4\n    else:\n        board ^= sq << -dr*4\n\n    return board\n\n\ndef heuristic(board):\n    mask = 0b1111\n    h = 0\n    for i in range(9):\n        y, x = divmod(i, 3)\n\n        piece = board >> 4*i & mask\n        if piece == 0:\n            py, px = 2, 2\n        else:\n            py, px = divmod(piece-1, 3)\n        h += abs(py-y)+abs(px-x)\n\n    return h\n\n\ndef search(initial, goal):\n    move_table = gen_move_table()\n\n    dist = {}\n    q = []\n\n    dist[initial] = 0\n    heappush(q, (heuristic(initial), 0, initial))\n    while q:\n        _, d, board = heappop(q)\n\n        if board == goal:\n            return d\n\n        if board in dist and d > dist[board]:\n            continue\n        dist[board] = d\n\n        for nboard in gen_next_board(board, move_table):\n            nd = d + 1\n            if (\n                nboard not in dist or\n                nboard in dist and nd < dist[nboard]\n            ):\n                heappush(q, (nd+heuristic(nboard), nd, nboard))\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque, defaultdict\n\ngrid_size = 3\n\ndef generate_next_state(q, visited, current_state, zero_pos, dx, dy):\n\tr = zero_pos // grid_size\n\tc = zero_pos % grid_size\n\tnext_state = current_state[:]\n\tnext_r = r + dx\n\tnext_c = c + dy\n\tif next_r < 0 or next_r >= grid_size:\n\t\treturn None\n\tif next_c < 0 or next_c >= grid_size:\n\t\treturn None\n\tnext_state[next_r * grid_size + next_c], next_state[r * grid_size + c] = next_state[r * grid_size + c], next_state[next_r * grid_size + next_c]\n\tif visited.get(tuple(next_state)) is not None:\n\t\treturn None\n\tq.append(next_state)\n\ndef bfs(initial_state, goal):\n\tvisited = defaultdict()\n\tq = deque()\n\tq.append(initial_state)\n\tstep = 0\n\twhile(len(q) > 0):\n\t\tnode_count = len(q)\n\t\twhile(node_count > 0):\n\t\t\tcurrent_state = q.popleft()\n\t\t\tvisited[tuple(current_state)] = True\n\t\t\t# print(current_state)\n\t\t\tnode_count -= 1\n\t\t\tif current_state == goal:\n\t\t\t\tprint(step)\n\t\t\t\treturn 0\n\t\t\tzero_pos = current_state.index(0)\n\t\t\tgenerate_next_state(q, visited, current_state, zero_pos, 0, -1)\n\t\t\tgenerate_next_state(q, visited, current_state, zero_pos, 0, 1)\n\t\t\tgenerate_next_state(q, visited, current_state, zero_pos, -1, 0)\n\t\t\tgenerate_next_state(q, visited, current_state, zero_pos, 1, 0)\n\n\n\t\tstep += 1\n\ndef init():\n\tinitial_state = []\n\tgoal = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\tfor i in range(grid_size):\n\t\tinput_list = input().rstrip().split()\n\t\tinitial_state.extend([int(val) for val in input_list])\n\treturn initial_state, goal\n\ninitial_state, goal = init()\nbfs(initial_state, goal)\n\n\n"
  },
  {
    "language": "Python",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\ntypedef char Board[10];\nBoard ini_board, board;\nconst Board target = \"123456780\";\n\nBoard *history;\nint nhistories=0;\n\ntypedef enum { U, D, L, R } Direction;\n\ntypedef struct {\n  int pos;\n  Direction dir;\n} Motion;\n\nint minstep = INT_MAX;\n\nconst Motion candidate[9][5] =\n  {{{1,L},{3,U},{-1}}, {{0,R},{2,L},{4,U},{-1}}, {{1,R},{5,U},{-1}},\n   {{0,D},{4,L},{6,U},{-1}}, {{1,D},{5,L},{7,U},{3,R},{-1}},\n   {{2,D},{8,U},{4,R},{-1}},\n   {{3,D},{7,L},{-1}}, {{4,D},{8,L},{6,R},{-1}}, {{5,D},{7,R},{-1}}  };\n\nint move(Motion m)\n{\n  if (m.pos==0 && board[0]=='1') return -1;\n  if ((m.pos==1||m.pos==2) && board[0]=='1'&&board[1]=='2'&&board[2]=='3') return -1;\n\n  switch (m.dir) {\n  case U:\n    if (m.pos<3) return -1;\n    \n    board[m.pos-3] = board[m.pos];\n    break;\n  case D:\n    if (m.pos>5) return -1;\n\n    board[m.pos+3] = board[m.pos];\n    break;\n  case L:\n    if (m.pos%3==0) return -1;\n\n    board[m.pos-1] = board[m.pos];\n    break;\n  case R:\n    if (m.pos%3==2) return -1;\n\n    board[m.pos+1] = board[m.pos];\n    break;\n  }\n  board[m.pos] = '0';\n  return m.pos;\n}\n\nvoid search_path(int step, int space)\n{\n  int i, j;\n  if (strcmp(board, \"123456780\")==0) {\n    //    printf(\"STEP=%d\\n\", step);\n    if (step==1) {\n      printf(\"1\\n\");\n      exit(0);\n    }\n    if (step<minstep) minstep=step;\n    \n  } else {\n\n    int s2;\n    if (step>=minstep) return;\n    if (step>0 && strcmp(board, ini_board)==0) return;\n    \n    Board board_bak;\n    strcpy(board_bak, board);\n    int nhistories_bak=nhistories;\n    \n    for (i=0; candidate[space][i].pos>=0; i++) {\n\n      if ((s2 = move(candidate[space][i]))<0) continue;\n      for (j=0; j<nhistories; j++) {\n\tif (strcmp(board, history[j])==0)\n\t  break;\n      }\n      if (j==nhistories) {\n\tstrcpy(history[nhistories++], board); \n\tsearch_path(step+1, s2);\n      }\n      nhistories = nhistories_bak;\n      strcpy(board, board_bak);\n    }\n  }\n}\n\nint main()\n{\n  fscanf(stdin, \"%c %c %c\\n\", &board[0],&board[1],&board[2]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[3],&board[4],&board[5]);\n  fscanf(stdin, \"%c %c %c\\n\", &board[6],&board[7],&board[8]);\n  strcpy(ini_board, board);\n  int space = strchr(board, '0')-board;\n  \n  history = (Board*)malloc(sizeof(Board)*100000);\n  search_path(0, space);\n  printf(\"%d\\n\", minstep);\n  return 0;\n}\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(sumcost,(0,i,j,0,puz)))\n    global finding\n\n    while len(q):\n        cost, items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        _sum_cost = cost - c_depth\n        if(_sum_cost == 0):\n            finding = 1\n            print(c_depth)\n            break\n        if(cost > depth):\n            continue\n\n        c_cost = HS(_i,_j,c_puz[_i*3+_j])\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            n_cost = cost+1+checkCost(c_cost,HS(_i-1,_j,c_puz[(_i-1)*3+_j]),HS(_i,_j,swap_puz[_i*3+_j]),HS(_i-1,_j,swap_puz[(_i-1)*3+_j]))\n            if(n_cost <= depth):\n                heapq.heappush(q,(n_cost,(c_depth+1,_i-1,_j,2,swap_puz)))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            n_cost = cost+1+checkCost(c_cost,HS(_i+1,_j,c_puz[(_i+1)*3+_j]),HS(_i,_j,swap_puz[_i*3+_j]),HS(_i+1,_j,swap_puz[(_i+1)*3+_j]))\n            if(n_cost <= depth):\n                heapq.heappush(q,(n_cost,(c_depth+1,_i+1,_j,1,swap_puz,)))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            n_cost = cost+1+checkCost(c_cost,HS(_i,_j-1,c_puz[_i*3+_j-1]),HS(_i,_j,swap_puz[_i*3+_j]),HS(_i,_j-1,swap_puz[_i*3+_j-1]))\n            if(n_cost <= depth):\n                heapq.heappush(q,(n_cost,(c_depth+1,_i,_j-1,4,swap_puz)))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            n_cost = cost+1+checkCost(c_cost,HS(_i,_j+1,c_puz[_i*3+_j+1]),HS(_i,_j,swap_puz[_i*3+_j]),HS(_i,_j+1,swap_puz[_i*3+_j+1]))\n            if(n_cost <= depth):\n                heapq.heappush(q,(n_cost,(c_depth+1,_i,_j+1,3,swap_puz)))\n\ndef checkCost(c_cost,m_cost,c2_cost,m2_cost):\n    return c2_cost - c_cost + m2_cost - m_cost\n\ndef sumCost(puz):\n    value = 0\n    for i in range(3):\n        value += HS(i,0,puz[i*3])\n        value += HS(i,1,puz[i*3+1])\n        value += HS(i,2,puz[i*3+2])\n    return value\n\ndef HS(i,j,num):\n    if(num != 0):\n        k = num-1\n    else:\n        k = 8\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(i-ki)+abs(j-kj)\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nsumcost = sumCost(puz)\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ninit = ''.join(sys.stdin.read().split())\n\ngenerated_state = {init: 0}\n\ndef bfs(root):\n    s = 0\n    configure = [root]\n    while '123456780' not in configure:\n        q = iter(configure)\n        configure = []\n        s += 1\n        for c in q:\n            i = c.find('0')\n            if 0 <= i <= 5:\n                t = str.maketrans('0' + c[i+3], c[i+3] + '0')\n                t_c = c.translate(t)\n                if t_c not in generated_state:\n                    generated_state[t_c] = s\n                    configure.append(t_c)\n            if i >= 3:\n                t = str.maketrans('0' + c[i-3], c[i-3] + '0')\n                t_c = c.translate(t)\n                if t_c not in generated_state:\n                    generated_state[t_c] = s\n                    configure.append(t_c)\n            if i == 0 or i == 1 or i == 3 or i == 4 or i == 6 or i == 7:\n                t = str.maketrans('0' + c[i+1], c[i+1] + '0')\n                t_c = c.translate(t)\n                if t_c not in generated_state:\n                    generated_state[t_c] = s\n                    configure.append(t_c)\n            if i == 1 or i == 2 or i == 4 or i == 5 or i == 7 or i == 8:\n                t = str.maketrans('0' + c[i-1], c[i-1] + '0')\n                t_c = c.translate(t)\n                if t_c not in generated_state:\n                    generated_state[t_c] = s\n                    configure.append(t_c)\n            if '123456780' in generated_state:\n                print(s)\n                break\n\nbfs(init)"
  },
  {
    "language": "Python",
    "code": "class Puzzle:\n    def __init__(self, field=None, path=''):\n        self.f = field\n        self.space = None\n        for i in range(9):\n            if self.f[i] == 9:\n                self.space = i\n        self.path = path\n\n    def __lt__(self, pzl): # <\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] > pzl.f[i]\n        return False\n\n    def __gt__(self, pzl): # >\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] < pzl.f[i]\n        return False\n\ndx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\ndir = ['u', 'l', 'd', 'r']\n\ndef is_target(pzl):\n    for i in range(9):\n        if pzl.f[i] != i+1:\n            return False\n    return True\n\ndef bfs(pzl):\n    queue = deque([])\n    V = {}\n    pzl.path = ''\n    queue.append(pzl)\n    V[str(pzl.f)] = True\n    if is_target(pzl): return u.path\n\n    while len(queue) != 0:\n        u = queue.popleft()\n        sx, sy = u.space//3, u.space%3\n        for r in range(4):\n            tx, ty = sx + dx[r], sy + dy[r]\n            if tx < 0 or ty < 0 or tx >= 3 or ty >= 3:\n                continue\n            v = Puzzle(field=[u.f[i] for i in range(9)], path=u.path)\n            v.f[u.space], v.f[tx*3+ty] = v.f[tx*3+ty], v.f[u.space]\n            v.space = tx*3 + ty\n            if str(v.f) not in V:\n                V[str(v.f)] = True\n                v.path += dir[r]\n                if is_target(v): return v.path\n                queue.append(v)\n    return 'unsolvable'\n\nfield = []\nfor i in range(3):\n    field.extend(list(map(int, input().split(' '))))\n\nfor i in range(9):\n    if field[i] == 0: field[i] = 9\n\npzl = Puzzle(field=field)\nans= bfs(pzl)\nprint(len(ans))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(sumCost(costs),(0,i,j,0,puz,costs)))\n    global finding\n\n    while len(q):\n        cost, items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        _costs = items[5]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n        if((c_depth+cost) >= depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[(_i-1)*3+_j] = HS(_i-1,_j,swap_puz[(_i-1)*3+_j])\n            heapq.heappush(q,(c_depth+1+sumCost(swap_cost),(c_depth+1,_i-1,_j,2,swap_puz,swap_cost)))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[(_i+1)*3+_j] = HS(_i+1,_j,swap_puz[(_i+1)*3+_j])\n            heapq.heappush(q,(c_depth+1+sumCost(swap_cost),(c_depth+1,_i+1,_j,1,swap_puz,swap_cost)))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[_i*3+_j-1] = HS(_i,_j-1,swap_puz[_i*3+_j-1])\n            heapq.heappush(q,(c_depth+1+sumCost(swap_cost),(c_depth+1,_i,_j-1,4,swap_puz,swap_cost)))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[_i*3+_j+1] = HS(_i,_j+1,swap_puz[_i*3+_j+1])\n            heapq.heappush(q,(c_depth+1+sumCost(swap_cost),(c_depth+1,_i,_j+1,3,swap_puz,swap_cost)))\n\ndef checkPuzIsExisted(puz,q):\n    for i in range(len(q)):\n        exist_puz = q[i][4]\n        count = 0\n        for j in range(len(exist_puz)):\n            if(exist_puz[j] != puz[j]):\n                count = 1\n        if(count == 0):\n            return True\n    return False\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i*3\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque, OrderedDict\n\nclass Puzzle:\n    def __init__(self, field=None, path=''):\n        self.f = field\n        self.space = None\n        for i in range(9):\n            if self.f[i] == 9:\n                self.space = i\n        self.path = path\n\n    def __lt__(self, pzl): # <\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] > pzl.f[i]\n        return False\n\n    def __gt__(self, pzl): # >\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] < pzl.f[i]\n        return False\n\ndx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\ndir = ['u', 'l', 'd', 'r']\n\ndef is_target(pzl):\n    for i in range(9):\n        if pzl.f[i] != i+1:\n            return False\n    return True\n\ndef print_puzzle(pzl):\n    for i, p in enumerate(pzl.f):\n        print(p, '', end='')\n        if i%3 == 2:\n            print('')\n\ndef bfs(pzl):\n    queue = deque([])\n    V = OrderedDict()\n    pzl.path = ''\n    queue.append(pzl)\n    V[pzl] = True\n    if is_target(pzl): return u.path\n\n    while len(queue) != 0:\n        u = queue.popleft()\n        sx, sy = u.space//3, u.space%3\n        for r in range(4):\n            tx, ty = sx + dx[r], sy + dy[r]\n            if tx < 0 or ty < 0 or tx >= 3 or ty >= 3:\n                continue\n            v = Puzzle(field=[u.f[i] for i in range(9)], path=u.path)\n            v.f[u.space], v.f[tx*3+ty] = v.f[tx*3+ty], v.f[u.space]\n            v.space = tx*3 + ty\n            if v not in V:\n                V[v] = True\n                v.path += dir[r]\n                if is_target(v): return v.path\n                queue.append(v)\n    return 'unsolvable'\n\nfield = []\nfor i in range(3):\n    field.extend(list(map(int, input().split(' '))))\n\nfor i in range(9):\n    if field[i] == 0: field[i] = 9\n\npzl = Puzzle(field=field)\nans= bfs(pzl)\nprint(len(ans))\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or (c_depth+HS(c_puz)) > depth or (c_depth+simpleHS(c_puz)) > depth):\n        return\n\n    if(i != 0 and finding != 1):\n        iterative(i-1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i-1,j))\n    if(i != 2 and finding != 1):\n        iterative(i+1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i+1,j))\n    if(j != 0 and finding != 1):\n        iterative(i,j-1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j-1))\n    if(j != 2 and finding != 1):\n        iterative(i,j+1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j+1))\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(c_puz):\n    value = 0\n    for i in range(len(c_puz)):\n        k = correctPuz.index(c_puz[i])\n        _i = (int)(i/3)\n        _j = i - _i\n        ki = (int)(k/3)\n        kj = k - ki\n        value = abs(_i-ki)+abs(_j-kj) \n\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import heapq\n\ndef d_manhattan(node_list):\n    s = 0\n    for i in range(9):\n        x_goal = i%3\n        y_goal = i//3\n        x_now = (node_list[i] - 1)%3\n        y_now = (node_list[i] - 1)//3\n        if y_now == -1:\n            y_now = 2\n        dx = abs(x_now - x_goal)\n        dy = abs(y_now - y_goal)\n        s += dx + dy\n    return s\n\ndef moveNodeE(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 1] = node_tmp[space + 1], node_tmp[space]\n    return node_tmp\ndef moveNodeW(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 1] = node_tmp[space - 1], node_tmp[space]\n    return node_tmp\ndef moveNodeN(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space - 3] = node_tmp[space - 3], node_tmp[space]\n    return node_tmp\ndef moveNodeS(node_list, space):\n    node_tmp = node_list[:]\n    node_tmp[space], node_tmp[space + 3] = node_tmp[space + 3], node_tmp[space]\n    return node_tmp\n\nclass board:\n    def __init__(self, node_list, g):\n        self.node = node_list\n        self.space = node_list.index(0)\n        self.g = g\n        self.h = d_manhattan(node_list)\n        self.f = self.g + self.h\n\n    def makeBoard(self):\n        space = self.space\n        cost_now = self.f\n        x_s = space%3\n        y_s = space//3\n        if x_s < 2:\n            node_tmp = moveNodeE(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if x_s > 0:\n            node_tmp = moveNodeW(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s < 2:\n            node_tmp = moveNodeS(self.node, space)\n            yield board(node_tmp, self.g + 1)\n        if y_s > 0:\n            node_tmp = moveNodeN(self.node, space)\n            yield board(node_tmp, self.g + 1)\n\nb_open = []\nn_close = []\nn_goal = [1,2,3,4,5,6,7,8,0]\nn_start = []\n\nfor i in range(3):\n    inp = list(map(int, input().split()))\n    n_start.extend(inp)\n\nb_start = board(n_start, 0)\nheapq.heappush(b_open, (b_start.f, b_start.h, 0, b_start))\n\ni = 0\nwhile b_open:\n    _, _, _, b_now = heapq.heappop(b_open)\n    if b_now.node == n_goal:\n        b_goal = b_now\n        break\n    n_close.append(b_now.node)\n    for b_new in b_now.makeBoard():\n        if b_new.node in n_close:\n            continue\n        heapq.heappush(b_open, (b_new.f, b_new.h, i, b_new))\n        i += 1\n\nprint(b_goal.g)"
  },
  {
    "language": "Python",
    "code": "from collections import deque, OrderedDict\n\nclass Puzzle:\n    def __init__(self, field=None, path=''):\n        self.f = field\n        self.space = None\n        for i in range(9):\n            if self.f[i] == 9:\n                self.space = i\n        self.path = path\n\n    def __lt__(self, pzl): # <\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] > pzl.f[i]\n        return False\n\n    def __gt__(self, pzl): # >\n        for i in range(9):\n            if self.f[i] == pzl.f[i]:\n                continue\n            return self.f[i] < pzl.f[i]\n        return False\n\ndx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\ndir = ['u', 'l', 'd', 'r']\n\ndef is_target(pzl):\n    for i in range(9):\n        if pzl.f[i] != i+1:\n            return False\n    return True\n\ndef bfs(pzl):\n    queue = deque([])\n    V = {}\n    pzl.path = ''\n    queue.append(pzl)\n    V[str(pzl.f)] = True\n    if is_target(pzl): return u.path\n\n    while len(queue) != 0:\n        u = queue.popleft()\n        sx, sy = u.space//3, u.space%3\n        for r in range(4):\n            tx, ty = sx + dx[r], sy + dy[r]\n            if tx < 0 or ty < 0 or tx >= 3 or ty >= 3:\n                continue\n            v = Puzzle(field=[u.f[i] for i in range(9)], path=u.path)\n            v.f[u.space], v.f[tx*3+ty] = v.f[tx*3+ty], v.f[u.space]\n            v.space = tx*3 + ty\n            if str(v.f) not in V:\n                V[str(v.f)] = True\n                v.path += dir[r]\n                if is_target(v): return v.path\n                queue.append(v)\n    return 'unsolvable'\n\nfield = []\nfor i in range(3):\n    field.extend(list(map(int, input().split(' '))))\n\nfor i in range(9):\n    if field[i] == 0: field[i] = 9\n\npzl = Puzzle(field=field)\nans= bfs(pzl)\nprint(len(ans))\n\n\n"
  },
  {
    "language": "Python",
    "code": "import copy\ndef hashnum(state):\n    num = 0\n    for i in range(3):\n        for j in range(3):\n            num *= 10\n            num += state[i][j]\n    return num\n\nanswer = 123456780\nini_state = []\nfor i in range(3):\n    temp = [int(n) for n in input().split(\" \")]\n    if 0 in temp:\n        zero_x, zero_y = temp.index(0), i\n    ini_state.append(temp)\nqueue = [[ini_state, zero_x, zero_y]]\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\nvisited = set()\nvisited |= {hashnum(ini_state)}\ntrial = 0\nwhile answer not in visited:\n    new_queue = []\n    for q in queue:\n        state, zero_x, zero_y = q\n        for i in range(len(dx)):\n            new_state = copy.deepcopy(state)\n            new_x = zero_x + dx[i]\n            new_y = zero_y + dy[i]\n            if 0 <= new_x < 3 and 0 <= new_y < 3:\n                new_state[new_y][new_x], new_state[zero_y][zero_x] = new_state[zero_y][zero_x], new_state[new_y][new_x]\n                perm = hashnum(new_state)\n                if perm not in visited:\n                    visited |= {perm}\n                    new_queue.append([new_state, new_x, new_y])\n    queue = new_queue\n    trial += 1\nprint(trial)"
  },
  {
    "language": "Python",
    "code": " \ngoal = ((1, 2, 3), (4, 5, 6), (7, 8, 0))\n\nparents = {}\ntotal = {}\nflag = True\n\ninitial = []\nposition = []\nfor i in range(3):\n\ta, b, c = map(int, input().split())\n\tif a == 0:\n\t\tposition.extend([i, 0])\n\telif b == 0:\n\t\tposition.extend([i, 1])\n\telif c == 0:\n \t\tposition.extend([i, 2])\n\tinitial.append( (a, b, c) )\n\nparents[tuple(initial)] = position\ntotal[tuple(initial)] = 1\n\ncount = 0\n\nif tuple(initial) == goal:\n\tflag = False\n\nwhile flag:\n\tcount += 1\n\tchildren = {}\n\tfor par_key in parents.keys():\n\t\tposition = parents[par_key]\n\n\t\tif position[0] < 2:\n\t\t\tchild = [list(par_key[0]), list(par_key[1]), list(par_key[2])]\n\t\t\tchild[position[0]][position[1]] = child[position[0]+1][position[1]]\n\t\t\tchild[position[0]+1][position[1]] = 0\n\t\t\tchild_tuple = (tuple(child[0]), tuple(child[1]), tuple(child[2]))\n\t\t\tif child_tuple == goal:\n\t\t\t\tflag = False\n\t\t\t\tbreak\n\t\t\telif child_tuple not in total:\n\t\t\t\tchildren[child_tuple] = [position[0]+1, position[1]]\n\t\t\t\ttotal[child_tuple] = 1\n\n\t\tif position[0] > 0:\n\t\t\tchild = [list(par_key[0]), list(par_key[1]), list(par_key[2])]\n\t\t\tchild[position[0]][position[1]] = child[position[0]-1][position[1]]\n\t\t\tchild[position[0]-1][position[1]] = 0\n\t\t\tchild_tuple = (tuple(child[0]), tuple(child[1]), tuple(child[2]))\n\t\t\tif child_tuple == goal:\n\t\t\t\tflag = False\n\t\t\t\tbreak\n\t\t\telif child_tuple not in total:\n\t\t\t\tchildren[child_tuple] = [position[0]-1, position[1]]\n\t\t\t\ttotal[child_tuple] = 1\n\n\t\tif position[1] < 2:\n\t\t\tchild = [list(par_key[0]), list(par_key[1]), list(par_key[2])]\n\t\t\tchild[position[0]][position[1]] = child[position[0]][position[1]+1]\n\t\t\tchild[position[0]][position[1]+1] = 0\n\t\t\tchild_tuple = (tuple(child[0]), tuple(child[1]), tuple(child[2]))\n\t\t\tif child_tuple == goal:\n\t\t\t\tflag = False\n\t\t\t\tbreak\n\t\t\telif child_tuple not in total:\n\t\t\t\tchildren[child_tuple] = [position[0], position[1]+1]\n\t\t\t\ttotal[child_tuple] = 1\n\n\t\tif position[1] > 0:\n\t\t\tchild = [list(par_key[0]), list(par_key[1]), list(par_key[2])]\n\t\t\tchild[position[0]][position[1]] = child[position[0]][position[1]-1]\n\t\t\tchild[position[0]][position[1]-1] = 0\n\t\t\tchild_tuple = (tuple(child[0]), tuple(child[1]), tuple(child[2]))\n\t\t\tif child_tuple == goal:\n\t\t\t\tflag = False\n\t\t\t\tbreak\n\t\t\telif child_tuple not in total:\n\t\t\t\tchildren[child_tuple] = [position[0], position[1]-1]\n\t\t\t\ttotal[child_tuple] = 1\n\n\tparents = children\n\nprint(count)\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    q.append((simpleHS(puz),0,i,j,0,puz))\n    global finding\n\n    while len(q):\n        items = q.pop(0)\n        c_dWithH = items[0]\n        c_depth = items[1]\n        _i = items[2]\n        _j = items[3]\n        prev_move = items[4]\n        c_puz = items[5]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n        if((c_depth+c_dWithH) > depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i-1,_j,2,swap_puz))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i+1,_j,1,swap_puz))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j-1,4,swap_puz))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            heapq.heappush(q,(c_depth+1+simpleHS(swap_puz),c_depth+1,_i,_j+1,3,swap_puz))\n\ndef checkPuzIsExisted(puz,q):\n    for i in range(len(q)):\n        exist_puz = q[i][4]\n        count = 0\n        for j in range(len(exist_puz)):\n            if(exist_puz[j] != puz[j]):\n                count = 1\n        if(count == 0):\n            return True\n    return False\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i*3\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n"
  },
  {
    "language": "Python",
    "code": "import queue\nboard = []\nfor i in range(3):\n    board.extend(list(map(int, input().split())))\n\nq = queue.PriorityQueue()\nq.put((0, board))\n\nwhile True:\n    entry = q.get()\n    step = entry[0]\n    b = entry[1]\n    if b == [1, 2, 3, 4, 5, 6, 7, 8, 0]:\n        print(step)\n        break\n    i = b.index(0)\n    step += 1\n\n    if i != 0:\n        b_new = list(b)\n        b_new[i - 1], b_new[i] = 0, b_new[i - 1]\n        q.put((step, b_new))\n    if i != len(b) - 1:\n        b_new = list(b)\n        b_new[i], b_new[i + 1] = b_new[i + 1], 0\n        q.put((step, b_new))\n    if i > 2:\n        b_new = list(b)\n        b_new[i - 3], b_new[i] = 0, b_new[i - 3]\n        q.put((step, b_new))\n    if i < 6:\n        b_new = list(b)\n        b_new[i], b_new[i + 3] = b_new[i + 3], 0\n        q.put((step, b_new))\n\n\n"
  },
  {
    "language": "Python",
    "code": "from queue import Queue\ngoal = [1,2,3,4,5,6,7,8,0]\nSIZE = 3\ncmds = ['up','down','left','right']\n\ndef puz_hash(p):\n    hash = ''.join(map(str, p))\n    return hash\n\ndef up(p,z,c):\n    if z >= 3 and c != 'down':\n        p[z], p[z - 3] = p[z - 3], p[z]\n    return p\n\ndef down(p,z,c):\n    if z <= 5 and c != 'up':\n        p[z], p[z + 3] = p[z + 3], p[z]\n    return p\n\ndef left(p,z,c):\n    if z % 3 != 0 and c != 'right':\n        p[z], p[z - 1] = p[z - 1], p[z]\n    return p\n\ndef right(p,z,c):\n    if z % 3 != 2 and c != 'left':\n        p[z], p[z + 1] = p[z + 1], p[z]\n    return p\n\ndef search(p):\n    q = Queue()\n    # init\n    q.put((p,0,''))\n    visited = set()#[]\n\n    while True:\n        if(q.empty()):\n            return None\n        current_p, current_d, prev_move = q.get()\n        current_z = current_p.index(0)\n        current_p_hash = puz_hash(current_p)\n\n        if(current_p_hash in visited):\n            continue\n        if(current_p_hash == goal_hash):\n            return current_d\n        visited.add(current_p_hash)\n\n        next_p = current_p.copy()\n        next_p = up(next_p, current_z, prev_move)\n        if(next_p.index(0) != current_z):\n            q.put((next_p, current_d+1, cmds[0]))\n\n        next_p = current_p.copy()\n        next_p = down(next_p, current_z, prev_move)\n        if(next_p.index(0) != current_z):\n            q.put((next_p, current_d+1, cmds[1]))\n\n        next_p = current_p.copy()\n        next_p = left(next_p, current_z, prev_move)\n        if(next_p.index(0) != current_z):\n            q.put((next_p, current_d+1, cmds[2]))\n\n        next_p = current_p.copy()\n        next_p = right(next_p, current_z, prev_move)\n        if(next_p.index(0) != current_z):\n            q.put((next_p, current_d+1, cmds[3]))\n\n        # kkkkkusso jikan kakaru\n        # for cmd in cmds:\n        #     next_p = current_p.copy()\n        #     next_p = get_next_states(cmd,next_p,current_z,prev_move)#eval(cmd)(next_p, current_z, prev_move)\n        #     if(next_p is not None):\n        #         print(current_d+1)\n        #         q.put((next_p, current_d+1, cmd))\n\np = []\nfor i in range(3):\n    p.extend(map(int, input().split()))\n\ngoal_hash = puz_hash(goal)\nres = search(p)\nprint(res)\n\n"
  },
  {
    "language": "Python",
    "code": "adjacent = (\n    (1, 3),       # 0\n    (0, 2, 4),    # 1\n    (1, 5),       # 2\n    (0, 4, 6),    # 3\n    (1, 3, 5, 7), # 4\n    (2, 4, 8),    # 5\n    (3, 7),       # 6\n    (4, 6, 8),    # 7\n    (5, 7)        # 8\n)\n\nGOAL = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\n# Bidirectional search using breadth-first search\ndef solve(start):\n    if start == GOAL:\n        return 0\n    # 0: forward, 1: backward\n    generated_state = {tuple(start): 0, tuple(GOAL): 1}\n    step = {tuple(start): 0, tuple(GOAL): 0}\n    s = 0\n    state1 = [(start, 0), (GOAL, 1)]\n    while state1:\n        state2 = state1[:]\n        state1 = []\n        s += 1\n        for s2, d in state2:\n            i = s2.index(0)\n            for p in adjacent[i]:\n                s1 = s2[:]\n                s1[i], s1[p] = s1[p], 0\n                key = tuple(s1)\n                if key in generated_state:\n                    if generated_state[key] != d:\n                        return s + step[key]\n                    continue\n                state1.append((s1, d))\n                generated_state[key] = d\n                step[key] = s\n\nimport sys\n\nstart = list(map(int, sys.stdin.read().split()))\n\nprint(solve(start))"
  },
  {
    "language": "Python",
    "code": "import copy\nimport functools as ft\nN = 3\n\n\ndef solved(game):\n    for i in range(N):\n        for j in range(N):\n            if (game[i][j] - 1) != i * N + j and game[i][j] != 0:\n                return False\n    return True\n\ndef debug_game(game):\n    for i in range(N):\n        print(ft.reduce(lambda x,y: x + str(y) + \" \", game[i], \"\"))\n\ndef convert_code(game):\n    hash_code = \"\"\n    for i in range(N):\n        hash_code = hash_code + ft.reduce(lambda x,y: x + str(y), game[i], \"\")\n    return hash_code\n\ndef calc_cost(game):\n    cost = 0\n    for i in range(N):\n        for j in range(N):\n            if game[i][j] != 0:\n                ideal = (int((game[i][j] - 1) / N), (game[i][j] - 1) % N)\n                cost += abs(i - ideal[0]) + abs(j - ideal[1])\n\n    return cost\n\ngames = []\nclosed = []\ninit = [[] for i in range(N)]\n\nfor i in range(N):\n    init[i] = [int(item) for item in input().split()]\n    for j in range(N):\n        if init[i][j] == 0:\n            #queue.put((i, j))\n            zero = (i, j)\n\ngames = games + [(init, zero, calc_cost(init), 0)]\ndirection = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n\nwhile len(games) > 0:\n    current = games.pop(0)\n    zero = current[1]\n    #print(\"Depth: \"+str(current[3]) + \" Cost: \"+str(current[2]))\n    #debug_game(current[0])\n    closed = closed + [convert_code(current[0])]\n\n    if solved(current[0]):\n        print(current[3])\n        break\n\n    for d in direction :\n        next_step = (zero[0] + d[0], zero[1] + d[1])\n        if next_step[0] >= 0 and next_step[0] <= 2 and next_step[1] >= 0 and next_step[1] <= 2:\n\n            tmp = copy.deepcopy(current[0])\n            tmp[zero[0]][zero[1]], tmp[next_step[0]][next_step[1]] = tmp[next_step[0]][next_step[1]], tmp[zero[0]][zero[1]]\n            tmp_cost = calc_cost(tmp)\n            hash_code = convert_code(tmp)\n\n            if not hash_code in closed:\n                games = games + [(tmp, next_step, tmp_cost, current[3]+1)]\n\n    games.sort(key=lambda x: x[2]+x[3])\n"
  },
  {
    "language": "Python",
    "code": "# 幅優先探索 #双方向探索\nimport sys\nimport queue\n\nSPACE = 0\n\nadjacents_list = (\n    (1, 3),       # 0\n    (0, 2, 4),    # 1\n    (1, 5),       # 2\n    (0, 4, 6),    # 3\n    (1, 3, 5, 7), # 4\n    (2, 4, 8),    # 5\n    (3, 7),       # 6\n    (4, 6, 8),    # 7\n    (5, 7)        # 8\n)\n\nclass State:\n    def __init__(self, board, space, prev):\n        self.board = board\n        self.space = space\n        self.prev = prev\n\ndef mininum_steps(start, goal):\n    if start == goal:\n        return 0\n    q = queue.Queue()\n    q.put(State(start, start.index(0), None))\n    history = [start]\n    while not q.empty():\n        state = q.get()\n        for adjacent in adjacents_list[state.space]:\n            board = state.board[:]\n            board[state.space] = board[adjacent]\n            board[adjacent] = SPACE\n            if board in history:\n                 continue\n            if board == goal:\n                return go_back(state)\n            history.append(board)\n            next_state = State(board, adjacent, state)\n            q.put(next_state)\n\nstep = 0\ndef go_back(state):\n    global step\n    if state is not None:\n        step += 1\n        go_back(state.prev)\n    return step\n\n\ninitial_board = list(map(int, sys.stdin.read().split()))\ngoal = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\nprint(mininum_steps(initial_board, goal))\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN = 3\ngoal = \"123456780\"\ndef g(i, j, a):\n    if i > j:\n        i, j = j, i\n    return a[:i] + a[j] + a[i + 1:j] + a[i] + a[j + 1:]\ndef solve():\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n    start = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n    if start == goal:\n        return 0\n    zero = start.find(\"0\")\n    dp = deque([(0, start, zero, 1), (0, goal, 8, 0)])\n    TABLE = {start:(1, 0), goal:(0, 0)}\n    for _ in range(100):\n        cnt, M, yx, flg = dp.popleft()\n        cnt += 1\n        for nyx in m[yx]:\n            key = g(yx, nyx, M)\n            if key in TABLE:\n                if TABLE[key][0] != flg:\n                    return TABLE[key][1] + cnt\n                continue\n            TABLE[key] = (flg, cnt)\n            dp.append((cnt, key, nyx, flg))\ndef MAIN():\n    print(solve())\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "import queue\n\n\n\n\"\"\"\nstart : スタートの盤面を表す配列\n# bf_search([8, 6, 7, 2, 5, 4, 3, 0, 1])\nbf_search([1,2,3,4,5,0,7,8,6])\nbf_search([1,3,0,4,2,5,7,8,6])\n\"\"\"\n\n\ndef bf_search(start):\n    # 隣接リスト\n    adjacent = (\n        # 0のコマから1or3へ移動できる\n        (1, 3),  # 0\n        # 1のコマから0or2or4へ移動できる\n        (0, 2, 4),  # 1\n        (1, 5),  # 2\n        (0, 4, 6),  # 3\n        (1, 3, 5, 7),  # 4\n        (2, 4, 8),  # 5\n        (3, 7),  # 6\n        (4, 6, 8),  # 7\n        (5, 7)  # 8\n    )\n    # 最終的に至りたい形\n    GOAL = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n    # 初期値の時点でゴールだったら\n    if start == GOAL:\n        print(0)\n        return\n    \n\n    q = queue.Queue()\n    \n    # キューにStateオブジェクトを追加する\n    q.put(State(start, start.index(0), None))\n    \n    # table:同一局面があるかチェックするための辞書（ハッシュ）\n    table = {}\n    \n    # 配列をタプル型に変換してそれをキーとする\n    # Trueなら一度見たことがある状態\n    table[tuple(start)] = True\n\n    # ゴールにたどり着くまでループ\n    # キューが空になってループが終了　-> goalにたどり着けなかった\n    while not q.empty():\n        # キューから局面を取り出してaに格納\n        a = q.get()\n        #print(a.board)\n        # adjacent[a.space]: 動かせるコマの位置\n        \"\"\"\n        完成形から考えて\n        空白0のインデックスが7だったら隣接リストより4,6,8の方向へを動かすことができるので\n        \n        最初のループでxに4が入る\n        \"\"\"\n        #print(\"a.apace=\"+str(a.space))\n        for x in adjacent[a.space]:\n            #print(\"x=\"+str(x))\n            # 元の局面をコピー(State型でなく状態のみ「startと同じ」)\n            b = a.board[:]\n\n            b[a.space] = b[x]\n            # 0: 空き場所を表す\n            b[x] = 0\n            key = tuple(b)\n            # 同一局面がないかチェック　あればcontinueでループをスキップ\n            if key in table: continue\n            # 同一局面がなければ新しい局面を生成\n            c = State(b, x, a)\n            if b == GOAL:\n                # print(\"answer\")\n                min = Min()\n                min.print_answer(c)\n                min.result()\n                return\n            # 局面を追加\n            q.put(c)\n            table[key] = True\n\n\nclass State:\n    def __init__(self, board, space, prev):\n        # 盤面を表す配列\n        self.board = board\n        # 空き場所の位置\n        self.space = space\n        # ひとつ前の局面（Stateオブジェクト）\n        self.prev = prev\n\nclass Min:\n    def __init__(self):\n        self.min = 0\n    def increment(self):\n        self.min = self.min + 1\n    def result(self):\n        print(self.min - 1)\n\n    # 手順の表示\n    def print_answer(self,x):\n        if x is not None:\n            self.increment()\n            self.print_answer(x.prev)\n            # print(x.board)\n\n\n\ndef main():\n    p = []  ##appendのために宣言が必要\n    # 入力受付\n    i = 0\n    while i < 3:\n        try:\n            p.append(list(map(int, input().split())))\n            i = i + 1\n        except:\n            break;\n    # ↓この形に変形したい\n    # start =[1,3,0,4,2,5,7,8,6]\n    start = sum(p,[])\n\n    bf_search(start)\n\n    return\n\n\n\n\n\n\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import heapq\nfrom itertools import chain\nfrom operator import mul\n\nexp10 = [10 ** a for a in range(8, -1, -1)]\nmovables = [{1, 3}, {0, 2, 4}, {1, 5}, {0, 4, 6}, {1, 3, 5, 7}, {2, 4, 8}, {3, 7}, {4, 6, 8}, {5, 7}]\n\ndestination = 123456780\n\n\ndef swap(board, move_from, move_to):\n    return board + (exp10[move_to] - exp10[move_from]) * (board // exp10[move_from] % 10)\n\n\nboard0 = sum(map(mul, exp10, chain.from_iterable(map(int, input().split()) for _ in range(3))))\np0 = ('0' + str(board0))[-9:].index('0')\n\nappeared = {board0}\nqueue = list((0, move_from, p0, board0) for move_from in movables[p0])\nheapq.heapify(queue)\n\nwhile True:\n    total_cost, move_from, move_to, board = heapq.heappop(queue)\n    if board == destination:\n        print(total_cost)\n        break\n    new_board = swap(board, move_from, move_to)\n    if new_board in appeared:\n        continue\n    for move_from2 in movables[move_from]:\n        if move_from2 != move_to:\n            heapq.heappush(queue, (total_cost + 1, move_from2, move_from, new_board))"
  },
  {
    "language": "Python",
    "code": "import sys\nimport queue\n\nN = 3\nf= ''.join(sys.stdin.readline().split())\nf+= ''.join(sys.stdin.readline().split())\nf+= ''.join(sys.stdin.readline().split())\n\ndd = [[-1, 0], [0, -1], [1, 0], [0, 1]]\n\nQ = queue.Queue()\nV = dict()\n\nQ.put([f,f.index('0'),0])\nV[f] = True\n\nwhile not Q.empty():\n    u = Q.get()\n    if u[0] == '123456780':  break\n    sx, sy = u[1]//N, u[1]%N\n    for dx, dy in dd:\n        tx, ty = sx+dx, sy+dy\n        if tx<0 or ty<0 or tx>=N or ty>=N: continue\n        v = u[:]\n        n1, n2 = u[1], tx*N+ty\n        v[1] = n2\n\tif n1>n2: n1, n2 = n2, n1\n        v[0] = v[0][0:n1]+v[0][n2]+v[0][n1+1:n2]+v[0][n1]+v[0][n2+1:]\n        if not V.get(v[0], False):\n            V[v[0]] = True\n            v[2] += 1 # dir[r]                                                       \n            Q.put(v)\n\nprint(u[2])\n"
  },
  {
    "language": "Python",
    "code": "dy = [-1, 0, 1, 0]\ndx = [0, 1, 0, -1]\nt = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n\n\ndef get_heuri():\n    res = 0\n    for i in range(3):\n        for j in range(3):\n            if t[i][j] == 0:\n                continue\n            a = t[i][j] - 1\n            res += abs(a // 3 - i) + abs(a % 3 - j)\n    return res\n\n\ndef check(depth, prev, py, px, limit):\n    heuri = get_heuri()\n    if heuri + depth > limit:\n        return False\n    if heuri == 0:\n        return True\n    for i in range(4):\n        if abs(i - prev) == 2:\n            continue\n        ny = py + dy[i]\n        nx = px + dx[i]\n        if ny < 0 or nx < 0 or ny >= 3 or nx >= 3:\n            continue\n        t[ny][nx], t[py][px] = t[py][px], t[ny][nx]\n        if check(depth + 1, i, ny, nx, limit):\n            return True\n        t[ny][nx], t[py][px] = t[py][px], t[ny][nx]\n    return False\n\nfor i in range(3):\n    s = list(map(int, input().split()))\n    for j in range(3):\n        if s[j] == 0:\n            py = i\n            px = j\n        t[i][j] = s[j]\nlimit = 0\nwhile True:\n    if check(0, 99, py, px, limit):\n        print(limit)\n        break\n    limit += 1\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nclass Node:\n    def __init__(self, board, parent, fValue, depth):\n        self.board = board\n        self.parent = parent\n        self.fValue = fValue\n        self.depth = depth\n\n    def __eq__(self, other):\n        return self.board == other.board\n\n    def __lt__(self, other):\n        return self.fValue < other.fValue\n\n    def __str__(self):\n        return str(self.board)+\"\\nf: \" + str(self.fValue)+ \"\\nsteps: \"+ str(self.depth)+\"\\n\"\n\n    def __bool__(self):\n        return True\n\n    def __hash__(self):\n        return hash(self.board)\n\nclass Board:\n    def __init__(self, matrix):\n        self.matrix = matrix\n        for i in range(len(matrix)):\n            if 0 in matrix[i]:\n                self.blankPos = (i, matrix[i].index(0))\n                return\n        raise ValueError(\"Invalid Matrix!\")\n\n    def __str__(self):\n        s = \"\"\n        for i in range(len(self.matrix)):\n            s += str(self.matrix[i]) + \"\\n\"\n        return s + \"\\n\"\n\n    def __eq__(self, other):\n        if type(other) is not Board:\n            return False\n        otherMatrix = other.matrix\n        thisMatrix = self.matrix\n        if len(thisMatrix) != len(otherMatrix):\n            return False\n        for i in range(len(thisMatrix)):\n            if len(thisMatrix[i]) != len(otherMatrix[i]):\n                return False\n            for j in range(len(thisMatrix[i])):\n                if thisMatrix[i][j] != otherMatrix[i][j]:\n                    return False\n        return True\n\n    def duplicate(self):\n        newMatrix = []\n        for i in range(len(self.matrix)):\n            newMatrix.append([])\n            for j in range(len(self.matrix[i])):\n                newMatrix[i].append(self.matrix[i][j])\n        return Board(newMatrix)\n\n    def findElement(self, elem):\n        for i in range(len(self.matrix)):\n            for j in range(len(self.matrix[i])):\n                if self.matrix[i][j] == elem:\n                    return (i, j)\n        return None\n\n    def slideBlank(self, dir):\n        # dir is a tuple (deltaY,deltaX)\n        if dir not in [(0, 1), (0, -1), (-1, 0), (1, 0)]:\n            raise ValueError(\"Invalid dir\")\n        newBlankPos = (self.blankPos[0] + dir[0], self.blankPos[1] + dir[1])\n        if newBlankPos[0] < 0 or newBlankPos[0] > len(self.matrix) - 1:\n            return None\n        elif newBlankPos[1] < 0 or newBlankPos[1] > len(self.matrix[0]) - 1:\n            return None\n        else:\n            newBoard = self.duplicate()\n            saveVal = newBoard.matrix[self.blankPos[0] + dir[0]][self.blankPos[1] + dir[1]]\n            newBoard.matrix[self.blankPos[0] + dir[0]][self.blankPos[1] + dir[1]] = 0\n            newBoard.matrix[self.blankPos[0]][self.blankPos[1]] = saveVal\n            newBoard.blankPos = (self.blankPos[0] + dir[0], self.blankPos[1] + dir[1])\n            return newBoard\n\n    def __hash__(self):\n        s = 0\n        for i in range(len(self.matrix)):\n            for j in range(len(self.matrix[i])):\n                s *= 10\n                s += self.matrix[i][j]\n        return s\n\n\ndef fastSearch(frontier, limit, goalBoard, explored, astar):\n    if not frontier:\n        return True\n    else:\n        curNode = frontier.pop(0)\n        explored.add(curNode)\n        if curNode.board == goalBoard:\n            print(curNode.depth)\n            return curNode\n        elif limit == 0:\n            print(\"Limit Reached\")\n            return True\n        elif astar:\n            aStarExpansion(curNode, frontier, goalBoard, explored)\n            return False\n\ndef fastSearchClient(board, limit, goalBoard, astar):\n    if astar:\n        frontier = [Node(board, None, heuristic(board, goalBoard), 0)]\n    else:\n        frontier = [Node(board, None, 0, 0)]\n    explored = set()\n    for i in range(limit):\n        retval = fastSearch(frontier, limit - i, goalBoard, explored, astar)\n        if retval:\n            return retval\n    return None\n\n# Function to expand the frontier using aStar #\ndef aStarExpansion(currentNode, frontier, goalBoard, explored):\n    sideLength = len(currentNode.board.matrix)\n    pos = currentNode.board.blankPos\n    depth = currentNode.depth + 1\n    toInsert = []\n\n    # if we can move there, make a node and put it in toInsert\n    if pos[0] != 0:\n        upCost = depth + heuristic(currentNode.board.slideBlank((-1, 0)), goalBoard)\n        upNode = Node(currentNode.board.slideBlank((-1, 0)), currentNode, upCost, depth)\n        toInsert.append(upNode)\n    if pos[0] != sideLength - 1:\n        downCost = depth + heuristic(currentNode.board.slideBlank((1, 0)), goalBoard)\n        downNode = Node(currentNode.board.slideBlank((1, 0)), currentNode, downCost, depth)\n        toInsert.append(downNode)\n    if pos[1] != 0:\n        leftCost = depth + heuristic(currentNode.board.slideBlank((0, -1)), goalBoard)\n        leftNode = Node(currentNode.board.slideBlank((0, -1)), currentNode, leftCost, depth)\n        toInsert.append(leftNode)\n    if pos[1] != sideLength - 1:\n        rightCost = depth + heuristic(currentNode.board.slideBlank((0, 1)), goalBoard)\n        rightNode = Node(currentNode.board.slideBlank((0, 1)), currentNode, rightCost, depth)\n        toInsert.append(rightNode)\n\n    # if we've already been there, we don't want to try that board again\n    for node in explored:\n        for insertNode in toInsert:\n            if insertNode == node:\n                toInsert.remove(insertNode)\n\n    # now we are putting the nodes to be inserted into the correct place in frontier\n    for node in toInsert:\n        for i in range(len(frontier) + 1):\n            if i == len(frontier):\n                frontier.append(node)\n                break\n            if frontier[i] > node:\n                frontier.insert(i, node)\n                break\n\ndef heuristic(currentBoard, goalBoard):\n    return manhattan(currentBoard)\n\n\ndef manhattan(currentBoard):\n    currentMatrix = currentBoard.matrix\n    sum = 0\n\n    for i in range(len(currentMatrix)):\n        for j in range(len(currentMatrix[i])):\n            cur = currentMatrix[i][j]\n\n            if cur % 3 == 0:\n                curx = 3\n            else:\n                curx = cur % 3\n\n            if cur != 0:\n                sum += abs(curx - (j + 1)) + abs(math.ceil(cur / 3) - (i + 1))\n\n    return sum\n\ndef main():\n\n    goalBoard = Board([[1, 2, 3], [4, 5, 6], [7, 8, 0]])\n\n    arr = [[1 for i in range(3)] for j in range(3)]\n\n    for i in range(3):\n        arr[i][0], arr[i][1], arr[i][2] = input().split()\n\n    for i in range(3):\n        for j in range(3):\n            arr[i][j] = int(arr[i][j])\n\n    fastSearchClient(Board(arr), 1000, goalBoard, True)\n\nif __name__ == \"__main__\":\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nfrom collections import deque\nimport copy\n\nclass Puzzle(list):\n    def __init__(self, size):\n        list.__init__(self)\n        self.size = size\n        #self[:] = [None] * size\n        self.space = None\n        self.path = \"\"\n\nif __name__ == '__main__':\n    \n    N = 3\n    N2 = 9\n    dx = [-1, 0, 1, 0]\n    dy = [0, -1, 0, 1]\n    d = [\"u\", \"l\", \"d\", \"r\"]\n\n    p = Puzzle(N2)\n    for i in range(N):\n        p += [int(x) for x in input().split()]\n    for i in range(N2):\n        if p[i] == 0:\n            p[i] = N2\n            p.space = i\n    def isTarget(p):\n        for i in range(N2):\n            if p[i] != i+1:\n                return False\n        return True\n\n    def bfs(s):\n        cnt = 0\n        Q = deque()\n        V = []\n        Q.append(s)\n        V.append(s)\n        while Q:\n            cnt += 1\n            u = Q.popleft()\n            if isTarget(u):\n                return u.path\n            sx = u.space // N\n            sy = u.space % N\n            for r in range(4):\n                tx = sx + dx[r]\n                ty = sy + dy[r]\n                if tx < 0 or ty < 0 or tx >= N or ty >= N:\n                    continue\n                v = copy.copy(u)\n                v[u.space], v[tx * N + ty] = v[tx * N + ty], v[u.space]\n                v.space = tx * N + ty\n                if not v in V:\n                    V.append(v)\n                    v.path += d[r]\n                    Q.append(v)\n\n        return \"unsolvable\"\n\n    ans = bfs(p)\n    print(len(ans))\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN = 3\ndef g(i, j, a):\n    t = a // (10 ** j) % 10\n    return a - t * (10 ** j) + t * (10 ** i)\ndef solve():\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n    start = 8 - MAP.find(\"0\")\n    MAP = int(MAP)\n    goal = 123456780\n    dp = deque([(0, start, MAP)])\n    LOG = {MAP}\n    while dp:\n        cnt, yx, M = dp.popleft()\n        if M == goal:\n            print(cnt)\n            break\n        cnt += 1\n        for nyx in m[yx]:\n            CM = g(yx, nyx, M)\n            if not CM in LOG:\n                dp.append((cnt, nyx, CM))\n                LOG.add(CM)\ndef MAIN():\n    print(solve())\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN = 3\ndef g(i, j, a):\n    t = a // (10 ** j) % 10\n    return a - t * (10 ** j) + t * (10 ** i)\ndef solve():\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n    start = 8 - MAP.find(\"0\")\n    MAP = int(MAP)\n    goal = 123456780\n    dp = deque([(0, start, MAP)])\n    LOG = {MAP}\n    while dp:\n        cnt, yx, M = dp.popleft()\n        if M == goal:\n            print(cnt)\n            break\n        cnt += 1\n        for nyx in m[yx]:\n            CM = g(yx, nyx, M)\n            if not CM in LOG:\n                dp.append((cnt, nyx, CM))\n                LOG.add(CM)\ndef MAIN():\n    print(solve())\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport heapq\n\ndef iterative(i,j):\n    q = []\n    heapq.heappush(q,(0,i,j,0,puz,costs))\n    global finding\n\n    while len(q):\n        items = heapq.heappop(q)\n        c_depth = items[0]\n        _i = items[1]\n        _j = items[2]\n        prev_move = items[3]\n        c_puz = items[4]\n        _costs = items[5]\n        if(puzzleCheck(c_puz)):\n            finding = 1\n            print(c_depth)\n            break\n\n        if((c_depth+sumCost(_costs)) >= depth):\n            continue\n\n        if(_i != 0 and prev_move != 1):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[(_i-1)*3+_j] = HS(_i-1,_j,swap_puz[(_i-1)*3+_j])\n            heapq.heappush(q,(c_depth+1,_i-1,_j,2,swap_puz,swap_cost))\n        if(_i != 2 and prev_move != 2):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[(_i+1)*3+_j] = HS(_i+1,_j,swap_puz[(_i+1)*3+_j])\n            heapq.heappush(q,(c_depth+1,_i+1,_j,1,swap_puz,swap_cost))\n        if(_j != 0 and prev_move != 3):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[_i*3+_j-1] = HS(_i,_j-1,swap_puz[_i*3+_j-1])\n            heapq.heappush(q,(c_depth+1,_i,_j-1,4,swap_puz,swap_cost))\n        if(_j != 2 and prev_move != 4):\n            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)\n            swap_cost = _costs[0:]\n            swap_cost[_i*3+_j] = HS(_i,_j,swap_puz[_i*3+_j])\n            swap_cost[_i*3+_j+1] = HS(_i,_j+1,swap_puz[_i*3+_j+1])\n            heapq.heappush(q,(c_depth+1,_i,_j+1,3,swap_puz,swap_cost))\n\ndef sumCost(costs):\n    value = 0\n    for i in range(len(costs)):\n        value += costs[i]\n    return value\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(i,j,num):\n    k = correctPuz.index(num)\n    ki = (int)(k/3)\n    kj = k - ki*3\n    value = abs(_i-ki)+abs(_j-kj) \n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\ncosts = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfor i in range(len(costs)):\n    _i = (int)(i/3)\n    _j = i - _i*3\n    costs[i] = HS(_i,_j,puz[i])\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start)\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN = 3\ngoal = \"123456780\"\ndef g(i, j, a):\n    if i > j:\n        i, j = j, i\n    return a[:i] + a[j] + a[i + 1:j] + a[i] + a[j + 1:]\ndef solve():\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n    start = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n    if start == goal:\n        return 0\n    zero = start.find(\"0\")\n    dp = deque([(0, start, zero, 1), (0, goal, 8, 0)])\n    TABLE = {start:(1, 0), goal:(0, 0)}\n    while dp:\n        cnt, M, yx, flg = dp.popleft()\n        cnt += 1\n        for nyx in m[yx]:\n            key = g(yx, nyx, M)\n            if key in TABLE:\n                if TABLE[key][0] != flg:\n                    return TABLE[key][1] + cnt\n                continue\n            TABLE[key] = (flg, cnt)\n            dp.append((cnt, key, nyx, flg))\ndef MAIN():\n    print(solve())\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "import time\nimport math\n\nclass Node:\n    def __init__(self, board, parent, fValue, depth):\n        self.board = board\n        self.parent = parent\n        self.fValue = fValue\n        self.depth = depth\n\n    def __eq__(self, other):\n        return self.board == other.board\n\n    def __lt__(self, other):\n        return self.fValue < other.fValue\n\n    def __hash__(self):\n        return hash(self.board)\n\n\nclass Board:\n    # The 8-puzzle board representation #\n    def __init__(self, matrix):\n        self.matrix = matrix\n\n        for i in range(len(matrix)):\n            if 0 in matrix[i]:\n                self.blankPos = (i, matrix[i].index(0))\n\n    def __str__(self):\n        s = \"\"\n        for i in range(len(self.matrix)):\n            s += str(self.matrix[i]) + \"\\n\"\n        return s + \"\\n\"\n\n    def __eq__(self, other):\n        #print other\n\n        otherMatrix = other.matrix\n        thisMatrix = self.matrix\n\n        if len(thisMatrix) != len(otherMatrix):\n            print \"failing here 0\"\n            return False\n        for i in range(len(thisMatrix)):\n            if len(thisMatrix[i]) != len(otherMatrix[i]):\n                print \"failing here 1\"\n                return False\n            for j in range(len(thisMatrix[i])):\n                if thisMatrix[i][j] != otherMatrix[i][j]:\n                    #print \"failing here expected\"\n                    return False\n        return True\n\n    def duplicate(self):\n        newMatrix = []\n        for i in range(len(self.matrix)):\n            newMatrix.append([])\n            for j in range(len(self.matrix[i])):\n                newMatrix[i].append(self.matrix[i][j])\n        return Board(newMatrix)\n\n    def findElement(self, elem):\n        for i in range(len(self.matrix)):\n            for j in range(len(self.matrix[i])):\n                if self.matrix[i][j] == elem:\n                    return (i, j)\n        return None\n\n    def slideBlank(self, dir):\n        # dir is a tuple (deltaY,deltaX)\n        if dir not in [(0, 1), (0, -1), (-1, 0), (1, 0)]:\n            raise ValueError(\"Invalid dir\")\n        newBlankPos = (self.blankPos[0] + dir[0], self.blankPos[1] + dir[1])\n        if newBlankPos[0] < 0 or newBlankPos[0] > len(self.matrix) - 1:\n            return None\n        elif newBlankPos[1] < 0 or newBlankPos[1] > len(self.matrix[0]) - 1:\n            return None\n        else:\n            newBoard = self.duplicate()\n            saveVal = newBoard.matrix[self.blankPos[0] + dir[0]][self.blankPos[1] + dir[1]]\n            newBoard.matrix[self.blankPos[0] + dir[0]][self.blankPos[1] + dir[1]] = 0\n            newBoard.matrix[self.blankPos[0]][self.blankPos[1]] = saveVal\n            newBoard.blankPos = (self.blankPos[0] + dir[0], self.blankPos[1] + dir[1])\n            return newBoard\n\n    def __hash__(self):\n        s = 0\n        for i in range(len(self.matrix)):\n            for j in range(len(self.matrix[i])):\n                s *= 10\n                s += self.matrix[i][j]\n\n        return s\n\ndef fastSearch(frontier, goalBoard, explored):\n    if not frontier:\n        return True\n    else:\n        curNode = frontier.pop(0)\n        explored.add(curNode)\n        if curNode.board == goalBoard:\n            print curNode.depth\n            return True\n        aStarExpansion(curNode, frontier, goalBoard, explored)\n        return False\n\n\ndef fastSearchClient(board, goalBoard):\n    frontier = [Node(board, None, heuristic(board, goalBoard), 0)]\n    explored = set()\n\n    limit = 0\n\n    while (limit < 1000):\n        retval = fastSearch(frontier, goalBoard, explored)\n        if retval:\n            return\n        limit += 1\n    return\n\n# Function to expand the frontier using aStar #\ndef aStarExpansion(currentNode, frontier, goalBoard, explored):\n    sideLength = len(currentNode.board.matrix)\n    pos = currentNode.board.blankPos\n    depth = currentNode.depth + 1\n    toInsert = []\n\n    # if we can move there, make a node and put it in toInsert\n    if pos[0] != 0:\n        upCost = depth + heuristic(currentNode.board.slideBlank((-1, 0)), goalBoard)\n        upNode = Node(currentNode.board.slideBlank((-1, 0)), currentNode, upCost, depth)\n        toInsert.append(upNode)\n    if pos[0] != sideLength - 1:\n        downCost = depth + heuristic(currentNode.board.slideBlank((1, 0)), goalBoard)\n        downNode = Node(currentNode.board.slideBlank((1, 0)), currentNode, downCost, depth)\n        toInsert.append(downNode)\n    if pos[1] != 0:\n        leftCost = depth + heuristic(currentNode.board.slideBlank((0, -1)), goalBoard)\n        leftNode = Node(currentNode.board.slideBlank((0, -1)), currentNode, leftCost, depth)\n        toInsert.append(leftNode)\n    if pos[1] != sideLength - 1:\n        rightCost = depth + heuristic(currentNode.board.slideBlank((0, 1)), goalBoard)\n        rightNode = Node(currentNode.board.slideBlank((0, 1)), currentNode, rightCost, depth)\n        toInsert.append(rightNode)\n\n    # if we've already been there, we don't want to try that board again\n    for node in explored:\n        for insertNode in toInsert:\n            if insertNode == node:\n                toInsert.remove(insertNode)\n\n    # now we are putting the nodes to be inserted into the correct place in frontier\n    for node in toInsert:\n        for i in range(len(frontier) + 1):\n            if i == len(frontier):\n                frontier.append(node)\n                break\n            if frontier[i] > node:\n                frontier.insert(i, node)\n                break\n\ndef heuristic(currentBoard, goalBoard):\n    currentMatrix = currentBoard.matrix\n    sum = 0\n\n    for i in range(len(currentMatrix)):\n        for j in range(len(currentMatrix[i])):\n            cur = currentMatrix[i][j]\n\n            if cur % 3 == 0:\n                curx = 3\n            else:\n                curx = cur % 3\n\n            if cur != 0:\n                sum += abs(curx - (j + 1)) + abs(math.ceil(cur / 3) - (i + 1))\n\n    return sum\n\n\narr = [[1 for i in range(3)] for j in range(3)]\n\nfor i in range(3):\n    arr[i][0], arr[i][1], arr[i][2] = raw_input().split()\n\n\nfor i in range(3):\n    for j in range(3):\n        arr[i][j] = int(arr[i][j])\n\nfastSearchClient(Board(arr), Board([[1, 2, 3], [4, 5, 6], [7, 8, 0]]))\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN = 3\ndef g(i, j, a):\n    if i > j:\n        i, j = j, i\n    return a[:i] + a[j] + a[i + 1:j] + a[i] + a[j + 1:]\ngoal = \"123456780\"\ndef solve():\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n    if MAP == goal:\n        return 0\n    start = MAP.find(\"0\")\n    dp = deque([(0, MAP, start, 1), (0, goal, 8, 0)])\n    TABLE = {MAP:(1, 0), goal:(0, 0)}\n    while dp:\n        cnt, M, yx, flg = dp.popleft()\n        cnt += 1\n        for nyx in m[yx]:\n            CM = g(yx, nyx, M)\n            if CM in TABLE:\n                if TABLE[CM][0] != flg:\n                    return TABLE[CM][1] + cnt\n                continue\n            TABLE[CM] = (flg, cnt)\n            dp.append((cnt, CM, nyx, flg))\ndef MAIN():\n    print(solve())\nMAIN()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys;\nimport queue;\n\ndef iterative(i,j,c_depth,c_puz):\n    if(puzzleCheck(c_puz)):\n        global finding\n        finding = 1\n        print(c_depth)\n\n    if(finding == 1 or (c_depth+HS(c_puz)) > depth or (c_depth+simpleHS(c_puz)) > depth):\n        return\n\n    if(i != 0):\n        iterative(i-1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i-1,j))\n    if(i != 2):\n        iterative(i+1,j,c_depth+1,swapPuz(c_puz[0:],i,j,i+1,j))\n    if(j != 0):\n        iterative(i,j-1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j-1))\n    if(j != 2):\n        iterative(i,j+1,c_depth+1,swapPuz(c_puz[0:],i,j,i,j+1))\n\ndef simpleHS(c_puz):\n    count = 0\n    for i in range(len(correctPuz)):\n        if(correctPuz[i] != c_puz[i]):\n            count+=1\n    return count\n\ndef HS(c_puz):\n    value = 0\n    for i in range(len(c_puz)):\n        k = correctPuz.index(c_puz[i])\n        _i = (int)(i/3)\n        _j = i - _i\n        ki = (int)(k/3)\n        kj = k - ki\n        value = abs(_i-ki)+abs(_j-kj) \n\n    return value\n\n\ndef swapPuz(c_puz, i, j, i2,j2):\n    swap = c_puz[i*3+j]\n    c_puz[i*3+j] = c_puz[i2*3+j2]\n    c_puz[i2*3+j2] = swap\n    return c_puz\n\ndef puzzleCheck(c_puz):\n    if(c_puz[8] == 0):\n        for i in range(len(correctPuz)):\n            if(correctPuz[i] != c_puz[i]):\n                return False\n        return True\n    return False\n\ncorrectPuz = [i+1 for i in range(9)]\ncorrectPuz[8] = 0\npuz = [0 for i in range(9)]\n\ni_start = 0\nj_start = 0\n\nfor i in range(3):\n    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());\n    if(puz[i*3] == 0):\n        i_start,j_start = i,0\n    elif(puz[i*3+1] == 0):\n        i_start,j_start = i,1\n    elif(puz[i*3+2] == 0):\n        i_start,j_start = i,2\n\nfinding = 0\ndepth = 0\nwhile True:\n    if(finding == 1):\n        break\n    iterative(i_start,j_start,0,puz[0:])\n    depth+=1\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "adjacent = (\n    (1, 3),       # 0\n    (0, 2, 4),    # 1\n    (1, 5),       # 2\n    (0, 4, 6),    # 3\n    (1, 3, 5, 7), # 4\n    (2, 4, 8),    # 5\n    (3, 7),       # 6\n    (4, 6, 8),    # 7\n    (5, 7)        # 8\n)\n\nGOAL = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\n# Bidirectional search using breadth-first search\ndef solve(start):\n    if start == GOAL:\n        return 0\n    # 0: forward, 1: backward\n    generated_state = {tuple(start): 0, tuple(GOAL): 1}\n    step = {tuple(start): 0, tuple(GOAL): 0}\n    s = 0\n    state1 = [(start, 0), (GOAL, 1)]\n    while state1:\n        state2 = state1[:]\n        state1 = []\n        s += 1\n        for s2, d in state2:\n            i = s2.index(0)\n            for p in adjacent[i]:\n                s1 = s2[:]\n                s1[i], s1[p] = s1[p], 0\n                key = tuple(s1)\n                if key in generated_state:\n                    if generated_state[key] != d:\n                        return s + step[key]\n                    continue\n                state1.append((s1, d))\n                generated_state[key] = d\n                step[key] = s\n\nimport sys\n\nstart = list(map(int, sys.stdin.read().split()))\n\nprint(solve(start))"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nfrom collections import deque\nimport copy\n\nclass Puzzle(list):\n    def __init__(self):\n        list.__init__(self)\n        self.space = None\n        self.path = \"\"\n    \n    def __hash__(self):\n        return hash(str(self[:]))\n\nif __name__ == '__main__':\n    \n    N = 3\n    N2 = 9\n    dx = [-1, 0, 1, 0]\n    dy = [0, -1, 0, 1]\n    d = [\"u\", \"l\", \"d\", \"r\"]\n\n    p = Puzzle()\n    for i in range(N):\n        p += [int(x) for x in input().split()]\n    for i in range(N2):\n        if p[i] == 0:\n            p[i] = N2\n            p.space = i\n    target = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    def isTarget(p):\n        return p[:] == target[:]\n\n    def bfs(s):\n        Q = deque()\n        V = set()\n        Q.append(s)\n        V.add(s)\n        while Q:\n            u = Q.popleft()\n            if isTarget(u):\n                return u.path\n            sx = u.space // N\n            sy = u.space % N\n            for r in range(4):\n                tx = sx + dx[r]\n                ty = sy + dy[r]\n                if not (0<= tx < N and 0 <= ty < N):\n                    continue\n                v = copy.copy(u)\n                change = tx * N + ty\n                v[u.space], v[change] = v[change], v[u.space]\n                v.space = change\n                if not v in V:\n                    V.add(v)\n                    v.path += d[r]\n                    Q.append(v)\n\n        return \"unsolvable\"\n\n    ans = bfs(p)\n    print(len(ans))\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "#codinh -utf8\nimport sys\nimport copy\n\ngoal_state=[1,2,3,4,5,6,7,8,0]\nadj=[(1, 3),(0, 2, 4),(1, 5),(0, 4, 6),(1, 3, 5, 7),(2, 4, 8),(3, 7),(4, 6, 8),(5, 7)]\nopen_list=[]    #????????¢?´¢??????????????????????´?\nclosed_list=[]  #??¢?´¢????????????????????????????´?\n\n\ndef getH(a, b): #???????????????????????¢????¨????\n    h2=0\n    i=0\n    for n in a:\n        if n!=-1:   #????????\\??????????????????????????????????????????????????¶????????§????????¢??????????±???????\n            j=b.index(n)\n            dist=j-i\n            dist=abs(dist)  #|i??¨j??????dist|: ??´???????????§????????¢\n            if dist==1:     #?????¢??????????????§?¨???????????????????????????????????????§????????¢?????????\n                if (i==2 and j==3) or (j==2 and i==3) or (i==5 and j==6) or (j==5 and i==6):\n                    dist=3\n            elif dist==3:\n                dist=1\n            elif dist==4:\n                if(i!=2 and j!=6) and (i!=6 and j!=2):\n                    dist=2\n            elif dist==5:\n                dist=3\n            elif dist==6:\n                dist=2\n            elif dist==7:\n                dist=3\n            elif dist==8:\n                dist=4\n            h2+=dist    #?????????????????¢?????????\n        i+=1\n    return  h2  #?????¢??????????????????\n\ndef findChildState(space, std_node):    #???????????????????????????????????????????????????\n    ad=adj[space]\n    child_set=[]\n    for i in ad: #???????????????????????????????????????????????¶???child_state?????????\n        child_state=copy.deepcopy(std_node[3])\n        child_state[space], child_state[i]=child_state[i], child_state[space]\n        child_set.append(child_state)   #chld_set??????????????????????????????????????????????????¶???????????????????´???????\n    return child_set\n\ndef openChildNode(std_node):    #?????¶??????????????????????????????openlist????????????\n    child_set=findChildState(std_node[3].index(0), std_node)   #???????????????????????????????????????\n    del open_list[0]    #??????????????????openlist??????????????????\n    closed_list.append(std_node)    #??????????????????closedlist???????????????\n    for i in child_set:\n        g=std_node[0]+1\n        h=getH(i, goal_state)\n        f=g+h\n        child=(g,h,f,i) #?????????????????????????????°????????\\??????????????£???????????????????????????????????¶???????¨???????child?????????\n        op=list(map(lambda x: i==x[3], open_list))\n        cl=list(map(lambda x: i==x[3], closed_list))\n        if  (True not in op) and (True not in cl):  #openlist??????closedlist????????????????????¨?????????????????¶??????????????´???\n            open_list.append(child) #openlist?????????\n        elif (True in op):  #openlist?????????????????¨?????????????????¶??????????????´???\n            n=op.index(True)\n            if f<open_list[n][2]:   #????????????????????????????????????????????????????°????????????°openlist????????????????????´??°\n                open_list[n]=copy.deepcopy(child)\n        elif (True in cl):  #closedlist?????????????????¨?????????????????¶??????????????´???\n            n=cl.index(True)\n            if f<closed_list[n][2]:   #????????????????????????????????????????????????????°????????????°closedlist??????????????????openlist?????????\n                del closed_list[n]\n                open_list.append(child)\n\ndef updateStandard():   #openlist??????????????????????°???????????????????????????????????¨??????????\n    min=100000000\n    std=()\n    if open_list==[]:   #openlist??????????????´?????¢?´¢??±???\n        return -1\n    for i in open_list: #openlist??????????????????????°????????????????????´¢\n        if i[2]<min:\n            min=i[2]\n            std=copy.deepcopy(i)\n    n=open_list.index(std)  #????????????????°???????????????????????????????????¨????\n    open_list[0], open_list[n]=open_list[n], open_list[0]   #??????????????????openlist?????????????§????\n    return std  #????????????????????????\n\n\na=list(map(int, sys.stdin.read().split()))\ng=0     #??????????????§?????????????????°???0\nh=getH(a, goal_state)  #?????\\??????????????£?????????????¨????\nf=g+h   #??´???????????§????¨±???????????????????¨????\nstd_node=(g, h, f, a)   #?????????(??????????????°????????\\??????????????£??????????????????????????????????????¶???)??????????????????????¨????\nopen_list.append(std_node)\n\nwhile 1:\n    if std_node[3]==goal_state: #????????????????????????????????´???????????¶?????¨?????´????????°??¢?´¢??????\n        flag=\"Done\"\n        break\n    openChildNode(std_node) #open_list????????????????????????\n    std=updateStandard()    #openlist?????????????????????f???????°??????????????????????????????¨??????\n    if std==-1: #openlist???????????£?????´?????¢?´¢??±???\n        flag=\"Failed\"\n        break\n    std_node=copy.deepcopy(std)    #?????????????????????????????????????°????????????????????????????????¨????\n\n\nif flag==\"Done\":    #??¢?´¢?????????????????´????????´???????????§???????????????????????°??¨????????¶????????¨???\n    print(std_node[0])\nelif flag==\"Failed\":    #??¢?´¢?????±???????????´???????????¨?????????\n    print(\"Search failed\")"
  },
  {
    "language": "Python",
    "code": "import sys\nimport queue\n\nN = 3\n\nf = ''.join(sys.stdin.readline().split())\nf += ''.join(sys.stdin.readline().split())\nf += ''.join(sys.stdin.readline().split())\n\ndd = [[-1, 0], [0, -1], [1, 0], [0, 1]]\n\nQ = [[f,f.index('0'),0]]\nV = { f: True }\n\nwhile len(Q)>0:\n    u = Q.pop(0)\n    if u[0] == '123456780':  break\n    sx, sy = u[1]//N, u[1]%N\n    for dx, dy in dd:\n        tx, ty = sx+dx, sy+dy\n        if tx<0 or ty<0 or tx>=N or ty>=N: continue\n        v = u[:]\n        n1, n2 = u[1], tx*N+ty\n        v[1] = n2\n        if n1>n2: n1, n2 = n2, n1\n        v[0] = v[0][0:n1]+v[0][n2]+v[0][n1+1:n2]+v[0][n1]+v[0][n2+1:]\n        if not V.get(v[0], False):\n            V[v[0]] = True\n            v[2] += 1 # dir[r]                                                       \n            Q.append(v)\n\nprint(u[2])\n"
  },
  {
    "language": "Python",
    "code": "start =  list(map(int, [n for a in [input().split() for i in range(3)] for n in a]))\ngoal = [1, 2, 3, 4, 5 ,6, 7, 8, 0]\n\nadjacent = (\n    (1, 3),\n    (0, 2, 4),\n    (1, 5),\n    (0, 4, 6),\n    (1, 3, 5, 7),\n    (2, 4, 8),\n    (3, 7),\n    (4, 6, 8),\n    (5, 7)\n)\n\nclass State():\n    def __init__(self, board, space, path):\n        self.board = board\n        self.space = space\n        self.path = path\n\ndef main():\n    if start == goal:\n        return 0\n\n    queue = [State(start[:], start.index(0), 0)]\n    stateList = {\"\".join(map(str, start)) : True}\n\n    while len(queue) != 0:\n        state = queue.pop(0)\n        for i in adjacent[state.space]:\n            next_state = State(state.board[:], i, state.path + 1)\n            next_state.board[i], next_state.board[state.space] = next_state.board[state.space], next_state.board[i]\n            state_str = \"\".join(map(str, next_state.board))\n            if stateList.get(state_str) :\n                continue\n            stateList[state_str] = True\n            if next_state.board == goal:\n                return next_state.path\n            queue.append(next_state)\n\nif __name__ == '__main__':\n    result = main()\n    print(result)\n"
  },
  {
    "language": "Rust",
    "code": "use std::collections::HashSet;\nuse std::collections::VecDeque;\nuse std::io::*;\nuse std::str::FromStr;\n\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\nconst N: usize = 3;\nconst N2: usize = 9;\n\nconst DX: [i32; 4] = [-1, 0, 1, 0];\nconst DY: [i32; 4] = [0, -1, 0, 1];\nconst DIR: [&str; 4] = [&\"u\", &\"l\", &\"d\", &\"r\"];\n\n#[derive(PartialEq, Eq, Hash, Clone)]\nstruct Puzzle {\n    f: Vec<usize>,\n    space: usize,\n    path: String,\n}\n\nfn is_target(puzzle: Puzzle) -> bool {\n    for index in 0..N2 {\n        if puzzle.f[index] != (index + 1) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn puzzle_key(puzzle: Puzzle) -> String {\n    return puzzle.f.iter().map(|&s| s.to_string()).collect::<String>();\n}\n\nfn bfs(puzzle: Puzzle) -> String {\n    let mut q: VecDeque<Puzzle> = VecDeque::new();\n    let mut v = HashSet::new();\n    let new_puzzle = puzzle;\n    let v_key: String = puzzle_key(new_puzzle.clone());\n    q.push_back(new_puzzle);\n    v.insert(v_key);\n    while q.len() > 0 {\n        let u_puzzle: Puzzle = q.pop_front().unwrap();\n        if is_target(u_puzzle.clone()) {\n            return u_puzzle.path;\n        }\n        let sx = u_puzzle.space / N;\n        let sy = u_puzzle.space % N;\n        for r in 0..4 {\n            let tx: i32 = sx as i32 + DX[r];\n            let ty: i32 = sy as i32 + DY[r];\n            if tx < 0 || ty < 0 || tx >= N as i32 || ty >= N as i32 {\n                continue;\n            }\n            let mut v_puzzle = u_puzzle.clone();\n            v_puzzle\n                .f\n                .swap(u_puzzle.space, tx as usize * N + ty as usize);\n            v_puzzle.space = tx as usize * N + ty as usize;\n            let v_puzzle_key: String = puzzle_key(v_puzzle.clone());\n\n            if !v.contains(&v_puzzle_key) {\n                v.insert(v_puzzle_key);\n                v_puzzle.path = v_puzzle.path + DIR[r];\n                q.push_back(v_puzzle);\n            }\n        }\n    }\n    return \"\".to_string();\n}\n\nfn main() {\n    let mut init_numbers: Vec<usize> = vec![0; N2];\n    let mut init_space: usize = 0;\n    for i in 0..N2 {\n        let number: usize = read();\n        init_numbers[i] = number;\n\n        if init_numbers[i] == 0 {\n            init_numbers[i] = N2;\n            init_space = i;\n        }\n    }\n\n    let puzzle = Puzzle {\n        f: init_numbers,\n        space: init_space,\n        path: \"\".to_string(),\n    };\n\n    let ans: String = bfs(puzzle);\n    println!(\"{}\", ans.len());\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "pub fn read<T: std::str::FromStr>() -> T {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).ok();\n    s.trim().parse().ok().unwrap()\n}\n\npub fn read_vec<T: std::str::FromStr>() -> Vec<T> {\n    read::<String>()\n        .split_whitespace()\n        .map(|e| e.parse().ok().unwrap())\n        .collect()\n}\n\npub fn read_vec2<T: std::str::FromStr>(n: usize) -> Vec<Vec<T>> {\n    (0..n).map(|_| read_vec()).collect()\n}\n\npub fn read_col<T: std::str::FromStr>(n: usize) -> Vec<T> {\n    (0..n).map(|_| read()).collect()\n}\n\nfn fact(n: usize) -> usize {\n    if n == 0 {\n        1\n    } else {\n        n * fact(n - 1)\n    }\n}\n\nfn encode(v: &Vec<u8>) -> usize {\n    let n: usize = v.len();\n    if n == 1 {\n        return 0;\n    }\n    let mut c = 0;\n    for i in 0..n {\n        if v[i] < v[0] {\n            c += 1;\n        }\n    }\n    let mut nv = vec![];\n    for i in 1..n {\n        nv.push(v[i]);\n    }\n    c * fact(n - 1) + encode(&nv)\n}\n\nuse std::collections::VecDeque;\n\nfn next(v: &Vec<u8>, check: &mut Vec<bool>) -> Vec<Vec<u8>> {\n    let mut i = 0;\n    for j in 0..9 {\n        if v[j] == 0 {\n            i = j;\n            break;\n        }\n    }\n    let mut ret = vec![];\n    if i % 3 != 0 {\n        let mut n = v.clone();\n        let tmp = n[i];\n        n[i] = n[i - 1];\n        n[i - 1] = tmp;\n        let c = encode(&n);\n        if !check[c] {\n            check[c] = true;\n            ret.push(n);\n        }\n    }\n    if i % 3 != 2 {\n        let mut n = v.clone();\n        let tmp = n[i];\n        n[i] = n[i + 1];\n        n[i + 1] = tmp;\n        let c = encode(&n);\n        if !check[c] {\n            check[c] = true;\n            ret.push(n);\n        }\n    }\n    if i > 2 {\n        let mut n = v.clone();\n        let tmp = n[i];\n        n[i] = n[i - 3];\n        n[i - 3] = tmp;\n        let c = encode(&n);\n        if !check[c] {\n            check[c] = true;\n            ret.push(n);\n        }\n    }\n    if i < 6 {\n        let mut n = v.clone();\n        let tmp = n[i];\n        n[i] = n[i + 3];\n        n[i + 3] = tmp;\n        let c = encode(&n);\n        if !check[c] {\n            check[c] = true;\n            ret.push(n);\n        }\n    }\n    ret\n}\n\nfn main() {\n    let mut v: Vec<u8> = vec![];\n    let t: Vec<u8> = read_vec();\n    for a in t {\n        v.push(a);\n    }\n    let t: Vec<u8> = read_vec();\n    for a in t {\n        v.push(a);\n    }\n    let t: Vec<u8> = read_vec();\n    for a in t {\n        v.push(a);\n    }\n\n    let goal = encode(&vec![1, 2, 3, 4, 5, 6, 7, 8, 0]);\n\n    let mut check: Vec<bool> = vec![false; 362880];\n    let mut vd = VecDeque::new();\n    check[encode(&v)] = true;\n    vd.push_back((v, 0));\n\n    loop {\n        let (v, d) = vd.pop_front().unwrap();\n        if encode(&v) == goal {\n            println!(\"{}\", d);\n            break;\n        }\n        for n in next(&v, &mut check) {\n            vd.push_back((n, d + 1));\n        }\n    }\n}\n\n"
  }
]